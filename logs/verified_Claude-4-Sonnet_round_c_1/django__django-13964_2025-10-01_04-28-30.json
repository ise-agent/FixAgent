{
  "zero_patches": {
    "Location 1 (/root/hy/projects/django/django/db/models/fields/related_descriptors.py lines 254-262)": "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                # Check if the related object is unsaved and has an empty/None primary key\n                rh_value = getattr(value, rh_field.attname)\n                if (rh_value == '' or rh_value is None) and hasattr(value, '_state') and value._state.adding:\n                    # For unsaved objects with empty primary keys, store None to defer resolution\n                    setattr(instance, lh_field.attname, None)\n                else:\n                    setattr(instance, lh_field.attname, rh_value)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n",
    "Location 2 (/root/hy/projects/django/django/db/models/fields/related_descriptors.py lines 172-176)": "\n        try:\n            rel_obj = self.field.get_cached_value(instance)\n        except KeyError:\n            has_value = None not in self.field.get_local_related_value(instance)\n            ancestor_link = instance._meta.get_ancestor_link(self.field.model) if has_value else None\n",
    "Location 3 (/root/hy/projects/django/django/db/models/fields/related.py lines 646-647)": "\ndef get_local_related_value(self, instance):\n    # Check if there's a cached related object that might have a more current primary key\n    if hasattr(self, 'cache_name'):\n        try:\n            cached_obj = getattr(instance, self.cache_name, None)\n            if cached_obj is not None and hasattr(cached_obj, '_state') and not cached_obj._state.adding:\n                # Get the current primary key values from the cached object\n                cached_values = []\n                for lhs_field, rhs_field in self.related_fields:\n                    if rhs_field:\n                        cached_val = getattr(cached_obj, rhs_field.attname)\n                        if cached_val is not None and cached_val != '':\n                            cached_values.append(cached_val)\n                        else:\n                            break\n                else:\n                    # All cached values are valid, use them instead of stored values\n                    if len(cached_values) == len(self.local_related_fields):\n                        return tuple(cached_values)\n        except AttributeError:\n            pass\n    \n    return self.get_instance_value_for_fields(instance, self.local_related_fields)\n",
    "Location 4 (/root/hy/projects/django/django/db/models/fields/related.py lines 653-668)": "\n    @staticmethod\n    def get_instance_value_for_fields(instance, fields):\n        ret = []\n        opts = instance._meta\n        for field in fields:\n            # Gotcha: in some cases (like fixture loading) a model can have\n            # different values in parent_ptr_id and parent's id. So, use\n            # instance.pk (that is, parent_ptr_id) when asked for instance.id.\n            if field.primary_key:\n                possible_parent_link = opts.get_ancestor_link(field.model)\n                if (not possible_parent_link or\n                        possible_parent_link.primary_key or\n                        possible_parent_link.model._meta.abstract):\n                    ret.append(instance.pk)\n                    continue\n            \n            # For foreign key fields, check if there's a cached related object\n            # with a different primary key value than what's stored\n            if hasattr(field, 'related_model') and field.related_model:\n                stored_value = getattr(instance, field.attname)\n                cached_attr_name = field.get_cache_name()\n                \n                # Check if there's a cached related object\n                if hasattr(instance, '_state') and hasattr(instance._state, 'fields_cache'):\n                    cached_obj = instance._state.fields_cache.get(cached_attr_name)\n                    if cached_obj is not None:\n                        # Get the primary key of the cached object\n                        cached_pk = cached_obj.pk\n                        # If the cached object has a valid pk and it differs from stored value,\n                        # use the cached object's pk\n                        if cached_pk is not None and cached_pk != stored_value:\n                            ret.append(cached_pk)\n                            continue\n            \n            ret.append(getattr(instance, field.attname))\n        return tuple(ret)\n",
    "Location 5 (/root/hy/projects/django/django/db/models/fields/related_descriptors.py lines 186-194)": "\n            if rel_obj is None and has_value:\n                # Check if we have a cached related object that should be used instead\n                # This handles cases where the foreign key was set to an unsaved object\n                # and we need to use the cached object rather than querying the database\n                cached_rel_obj = self.field.get_cached_value(instance, default=None)\n                if cached_rel_obj is not None:\n                    # Verify the cached object has a valid primary key\n                    pk_val = getattr(cached_rel_obj, cached_rel_obj._meta.pk.attname, None)\n                    if pk_val is not None and pk_val != '':\n                        rel_obj = cached_rel_obj\n                    else:\n                        # Cached object exists but has no valid PK, use it anyway\n                        # as it represents the intended relationship\n                        rel_obj = cached_rel_obj\n                else:\n                    # No cached object, proceed with database lookup\n                    rel_obj = self.get_object(instance)\n                    remote_field = self.field.remote_field\n                    # If this is a one-to-one relation, set the reverse accessor\n                    # cache on the related object to the current instance to avoid\n                    # an extra SQL query if it's accessed later on.\n                    if not remote_field.multiple:\n                        remote_field.set_cached_value(rel_obj, instance)\n            self.field.set_cached_value(instance, rel_obj)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/django/django/db/models/fields/related_descriptors.py lines 254-262)": [
      "\n        # Set the values of the related field.\n        else:\n            # Check if this is an unsaved object with an unset primary key\n            # If so, we'll defer the foreign key assignment until the related object is saved\n            should_defer = False\n            if hasattr(value, '_state') and not value._state.adding is False:\n                # Object might be unsaved, check if primary key is effectively empty\n                for lh_field, rh_field in self.field.related_fields:\n                    pk_value = getattr(value, rh_field.attname)\n                    if pk_value in (None, ''):\n                        should_defer = True\n                        break\n            \n            if should_defer:\n                # For unsaved objects with empty PKs, just cache the object\n                # The foreign key values will be resolved dynamically when needed\n                for lh_field, rh_field in self.field.related_fields:\n                    setattr(instance, lh_field.attname, None)\n            else:\n                # Normal case: set the foreign key values immediately\n                for lh_field, rh_field in self.field.related_fields:\n                    setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n",
      "\n        # Set the values of the related field.\n        else:\n            # Check if the related object is unsaved and has empty primary key values\n            has_empty_pk = False\n            if hasattr(value, '_state') and not value._state.adding is False:\n                for lh_field, rh_field in self.field.related_fields:\n                    pk_value = getattr(value, rh_field.attname)\n                    if pk_value in (None, ''):\n                        has_empty_pk = True\n                        break\n            \n            # If the related object has empty primary keys, store placeholder values\n            # but rely on dynamic resolution during access\n            if has_empty_pk:\n                for lh_field, rh_field in self.field.related_fields:\n                    # Store a marker that indicates deferred resolution needed\n                    setattr(instance, lh_field.attname, getattr(value, rh_field.attname) or '')\n            else:\n                for lh_field, rh_field in self.field.related_fields:\n                    setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n",
      "\n        # Set the values of the related field.\n        else:\n            # Check if the related object is unsaved and has empty primary key values\n            needs_deferred_assignment = False\n            if hasattr(value, '_state') and value._state.adding:\n                # Check if any of the primary key fields are empty/None\n                for lh_field, rh_field in self.field.related_fields:\n                    rh_value = getattr(value, rh_field.attname)\n                    if rh_value in (None, ''):\n                        needs_deferred_assignment = True\n                        break\n            \n            if needs_deferred_assignment:\n                # For unsaved objects with empty PKs, store None in foreign key fields\n                # The actual values will be resolved dynamically when needed\n                for lh_field, rh_field in self.field.related_fields:\n                    setattr(instance, lh_field.attname, None)\n            else:\n                # Normal case: set the foreign key values immediately\n                for lh_field, rh_field in self.field.related_fields:\n                    setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n",
      "\n        # Set the values of the related field.\n        else:\n            # Check if the related object is unsaved and has empty primary key values\n            needs_lazy_resolution = False\n            if hasattr(value, '_state') and value._state.adding:\n                for lh_field, rh_field in self.field.related_fields:\n                    rh_value = getattr(value, rh_field.attname)\n                    if rh_value is None or rh_value == '':\n                        needs_lazy_resolution = True\n                        break\n            \n            if needs_lazy_resolution:\n                # For unsaved objects with empty PKs, store a marker for lazy resolution\n                for lh_field, rh_field in self.field.related_fields:\n                    setattr(instance, lh_field.attname, None)\n                # Store metadata to indicate lazy resolution is needed\n                if not hasattr(instance, '_lazy_fk_resolution'):\n                    instance._lazy_fk_resolution = {}\n                instance._lazy_fk_resolution[self.field.name] = True\n            else:\n                # Normal case: set the foreign key values immediately\n                for lh_field, rh_field in self.field.related_fields:\n                    setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n",
      "\n        # Set the values of the related field.\n        else:\n            # Check if we're assigning an unsaved related object with empty primary key\n            needs_deferred_assignment = False\n            if hasattr(value, '_state') and not value._state.db:\n                # Object is unsaved, check if primary key fields are empty\n                for lh_field, rh_field in self.field.related_fields:\n                    pk_value = getattr(value, rh_field.attname)\n                    if pk_value == '' or pk_value is None:\n                        needs_deferred_assignment = True\n                        break\n            \n            if needs_deferred_assignment:\n                # For unsaved objects with empty PKs, set foreign key to None\n                # and rely on the cached object for dynamic resolution\n                for lh_field, rh_field in self.field.related_fields:\n                    setattr(instance, lh_field.attname, None)\n            else:\n                # Normal case: set foreign key values from related object\n                for lh_field, rh_field in self.field.related_fields:\n                    setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n",
      "\n        # Set the values of the related field.\n        else:\n            # Check if we have an unsaved related object with unset primary key\n            has_deferred_pk = False\n            if hasattr(value, '_state') and value._state.adding:\n                # Check if any of the related fields have empty/None values\n                for lh_field, rh_field in self.field.related_fields:\n                    rh_value = getattr(value, rh_field.attname)\n                    if not rh_value:  # Empty string, None, or other falsy values\n                        has_deferred_pk = True\n                        break\n            \n            if has_deferred_pk:\n                # For unsaved objects with unset primary keys, store None temporarily\n                # The actual value will be resolved dynamically when needed\n                for lh_field, rh_field in self.field.related_fields:\n                    setattr(instance, lh_field.attname, None)\n            else:\n                # Normal case: set the foreign key values immediately\n                for lh_field, rh_field in self.field.related_fields:\n                    setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                # Check if the related object is unsaved and has an empty/None primary key\n                rh_value = getattr(value, rh_field.attname)\n                if (hasattr(value, '_state') and value._state.adding and \n                    (rh_value == '' or rh_value is None)):\n                    # For unsaved objects with empty primary keys, store None to defer resolution\n                    setattr(instance, lh_field.attname, None)\n                else:\n                    setattr(instance, lh_field.attname, rh_value)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n",
      "\n        # Set the values of the related field.\n        else:\n            # Check if the related object is unsaved and has empty primary key values\n            # If so, we need to defer the foreign key assignment to avoid capturing\n            # empty string values that won't be updated when the primary key is later set\n            should_defer = False\n            if hasattr(value, '_state') and value._state.adding:\n                # Check if any of the primary key fields are empty/None\n                for lh_field, rh_field in self.field.related_fields:\n                    pk_value = getattr(value, rh_field.attname, None)\n                    if pk_value in (None, ''):\n                        should_defer = True\n                        break\n            \n            if should_defer:\n                # For unsaved objects with empty primary keys, store a special marker\n                # that indicates the foreign key should be resolved dynamically\n                for lh_field, rh_field in self.field.related_fields:\n                    setattr(instance, lh_field.attname, None)\n            else:\n                # Normal case: capture the primary key values immediately\n                for lh_field, rh_field in self.field.related_fields:\n                    setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n"
    ],
    "Location 2 (/root/hy/projects/django/django/db/models/fields/related_descriptors.py lines 172-176)": [
      "\n        try:\n            rel_obj = self.field.get_cached_value(instance)\n        except KeyError:\n            has_value = None not in self.field.get_local_related_value(instance)\n            ancestor_link = instance._meta.get_ancestor_link(self.field.model) if has_value else None\n",
      "\n        try:\n            rel_obj = self.field.get_cached_value(instance)\n        except KeyError:\n            has_value = None not in self.field.get_local_related_value(instance)\n            ancestor_link = instance._meta.get_ancestor_link(self.field.model) if has_value else None\n",
      "\n        try:\n            rel_obj = self.field.get_cached_value(instance)\n        except KeyError:\n            has_value = None not in self.field.get_local_related_value(instance)\n            ancestor_link = instance._meta.get_ancestor_link(self.field.model) if has_value else None\n            if ancestor_link and ancestor_link.is_cached(instance):\n                # An ancestor link will exist if this field is defined on a\n                # multi-table inheritance parent of the instance's class.\n                ancestor = ancestor_link.get_cached_value(instance)\n                # The value might be cached on an ancestor if the instance\n                # originated from walking down the inheritance chain.\n                rel_obj = self.field.get_cached_value(ancestor, default=None)\n            else:\n                rel_obj = None\n            if rel_obj is None and has_value:\n                # Check if there's a cached related object that should be used instead\n                # This handles cases where the foreign key was set but the related object's\n                # primary key was modified after assignment\n                cached_related = None\n                try:\n                    cached_related = getattr(instance, self.field.get_cache_name(), None)\n                except AttributeError:\n                    pass\n                \n                if cached_related is not None:\n                    # Use the cached related object instead of fetching from database\n                    rel_obj = cached_related\n                else:\n",
      "\n        try:\n            rel_obj = self.field.get_cached_value(instance)\n        except KeyError:\n            has_value = None not in self.field.get_local_related_value(instance)\n            ancestor_link = instance._meta.get_ancestor_link(self.field.model) if has_value else None\n",
      "\n        try:\n            rel_obj = self.field.get_cached_value(instance)\n        except KeyError:\n            has_value = None not in self.field.get_local_related_value(instance)\n            ancestor_link = instance._meta.get_ancestor_link(self.field.model) if has_value else None\n",
      "\n        try:\n            rel_obj = self.field.get_cached_value(instance)\n        except KeyError:\n            has_value = None not in self.field.get_local_related_value(instance)\n            ancestor_link = instance._meta.get_ancestor_link(self.field.model) if has_value else None\n",
      "\n        try:\n            rel_obj = self.field.get_cached_value(instance)\n        except KeyError:\n            has_value = None not in self.field.get_local_related_value(instance)\n            ancestor_link = instance._meta.get_ancestor_link(self.field.model) if has_value else None\n",
      "\n        try:\n            rel_obj = self.field.get_cached_value(instance)\n        except KeyError:\n            has_value = None not in self.field.get_local_related_value(instance)\n            ancestor_link = instance._meta.get_ancestor_link(self.field.model) if has_value else None\n"
    ],
    "Location 3 (/root/hy/projects/django/django/db/models/fields/related.py lines 646-647)": [
      "\ndef get_local_related_value(self, instance):\n    # First get the standard stored values\n    stored_values = self.get_instance_value_for_fields(instance, self.local_related_fields)\n    \n    # Check if there's a cached related object that might have updated primary key values\n    if hasattr(instance, '_state') and hasattr(self, 'get_cache_name'):\n        cache_name = self.get_cache_name()\n        if hasattr(instance, cache_name):\n            try:\n                cached_obj = getattr(instance, cache_name)\n                if cached_obj is not None:\n                    # Get current values from the cached related object\n                    current_values = self.get_instance_value_for_fields(cached_obj, self.foreign_related_fields)\n                    # If any stored value is empty/None but current value is not, use current values\n                    if any(not stored_val and current_val for stored_val, current_val in zip(stored_values, current_values)):\n                        return current_values\n            except AttributeError:\n                pass\n    \n    return stored_values\n",
      "\n    def get_local_related_value(self, instance):\n        # Check if there's a cached related object that might have a more current primary key\n        if hasattr(instance, '_state') and not instance._state.adding:\n            # For existing instances, check for cached related objects\n            for field in self.local_related_fields:\n                if hasattr(field, 'related_model') and hasattr(instance, field.get_cache_name()):\n                    cached_obj = getattr(instance, field.get_cache_name(), None)\n                    if cached_obj is not None and hasattr(cached_obj, '_state'):\n                        # Get the current primary key from the cached object\n                        cached_pk = getattr(cached_obj, field.target_field.attname, None)\n                        # Get the stored foreign key value\n                        stored_fk = getattr(instance, field.attname, None)\n                        # If they differ and the cached object has a valid primary key, use the cached one\n                        if cached_pk and cached_pk != stored_fk:\n                            # Update the stored foreign key value to match the cached object\n                            setattr(instance, field.attname, cached_pk)\n        \n        return self.get_instance_value_for_fields(instance, self.local_related_fields)\n",
      "\n    def get_local_related_value(self, instance):\n        # Check if there's a cached related object that might have a more current primary key value\n        if hasattr(instance, '_state') and not instance._state.db:\n            # For unsaved instances, check if there's a cached related object\n            cache_name = self.get_cache_name()\n            if hasattr(instance, cache_name):\n                cached_obj = getattr(instance, cache_name)\n                if cached_obj is not None:\n                    # Get the current primary key value from the cached object\n                    cached_values = self.get_instance_value_for_fields(cached_obj, self.foreign_related_fields)\n                    # If the cached object has valid primary key values, use them\n                    if all(val not in (None, '') for val in cached_values):\n                        return cached_values\n        \n        return self.get_instance_value_for_fields(instance, self.local_related_fields)\n",
      "\n    def get_local_related_value(self, instance):\n        # Check if there's a cached related object that might have a different primary key\n        # than what's currently stored in the foreign key field\n        if hasattr(self, 'cached_name'):\n            try:\n                cached_obj = getattr(instance, self.cached_name, None)\n                if cached_obj is not None and hasattr(cached_obj, '_state') and not cached_obj._state.db:\n                    # Related object exists but is unsaved - use its current primary key values\n                    cached_values = []\n                    for lhs_field, rhs_field in self.related_fields:\n                        if rhs_field:\n                            cached_value = getattr(cached_obj, rhs_field.attname)\n                            # Only use cached value if it's not empty/None\n                            if cached_value not in (None, ''):\n                                cached_values.append(cached_value)\n                            else:\n                                # Fall back to stored value if cached object's pk is empty\n                                cached_values.append(getattr(instance, lhs_field.attname))\n                        else:\n                            cached_values.append(getattr(instance, lhs_field.attname))\n                    return tuple(cached_values)\n            except AttributeError:\n                pass\n        \n        return self.get_instance_value_for_fields(instance, self.local_related_fields)\n",
      "\ndef get_local_related_value(self, instance):\n    # First get the stored foreign key values\n    stored_values = self.get_instance_value_for_fields(instance, self.local_related_fields)\n    \n    # Check if there's a cached related object that might have a different primary key\n    if hasattr(instance, '_state') and hasattr(instance._state, 'fields_cache'):\n        cache_name = self.get_cache_name()\n        if cache_name in instance._state.fields_cache:\n            related_obj = instance._state.fields_cache[cache_name]\n            if related_obj is not None:\n                # Get the current primary key values from the cached related object\n                current_values = self.get_instance_value_for_fields(related_obj, self.foreign_related_fields)\n                \n                # If the cached object has valid primary key values and they differ from stored values,\n                # use the current values from the cached object\n                if (current_values and all(val is not None and val != '' for val in current_values) and\n                    current_values != stored_values):\n                    return current_values\n    \n    return stored_values\n",
      "\ndef get_local_related_value(self, instance):\n    # Check if there's a cached related object that might have a more current primary key\n    cached_obj = getattr(instance, self.get_cache_name(), None)\n    if cached_obj is not None and hasattr(cached_obj, '_state') and not cached_obj._state.adding:\n        # If the cached object has been saved and has a primary key, use its current value\n        cached_values = self.get_instance_value_for_fields(cached_obj, self.foreign_related_fields)\n        if all(val is not None and val != '' for val in cached_values):\n            return cached_values\n    \n    return self.get_instance_value_for_fields(instance, self.local_related_fields)\n",
      "\n    def get_local_related_value(self, instance):\n        # Check if there's a cached related object with a more current primary key\n        if hasattr(instance, '_state') and not instance._state.adding:\n            for field in self.local_related_fields:\n                if hasattr(field, 'remote_field') and field.remote_field:\n                    cache_name = field.get_cache_name()\n                    if hasattr(instance, cache_name):\n                        cached_obj = getattr(instance, cache_name, None)\n                        if cached_obj is not None:\n                            # Get the current primary key from the cached object\n                            remote_field = field.remote_field.get_related_field()\n                            cached_pk = getattr(cached_obj, remote_field.attname)\n                            stored_pk = getattr(instance, field.attname)\n                            # If cached object has a valid PK that differs from stored value, use it\n                            if cached_pk and cached_pk != stored_pk:\n                                # Return updated values with the current cached object's PK\n                                ret = []\n                                for lhs_field in self.local_related_fields:\n                                    if lhs_field == field:\n                                        ret.append(cached_pk)\n                                    else:\n                                        ret.append(getattr(instance, lhs_field.attname))\n                                return tuple(ret)\n        \n        return self.get_instance_value_for_fields(instance, self.local_related_fields)\n",
      "\ndef get_local_related_value(self, instance):\n    # Check if there's a cached related object that might have a more current primary key\n    if hasattr(instance, '_state') and not instance._state.adding:\n        # For saved instances, use the stored foreign key value\n        return self.get_instance_value_for_fields(instance, self.local_related_fields)\n    \n    # For unsaved instances, check if we have a cached related object with a valid primary key\n    cache_name = self.get_cache_name()\n    if hasattr(instance, '_' + cache_name + '_cache'):\n        cached_obj = getattr(instance, '_' + cache_name + '_cache', None)\n        if cached_obj is not None:\n            # Get the current primary key value from the cached object\n            cached_pk_values = []\n            for local_field, remote_field in self.related_fields:\n                if remote_field:\n                    cached_value = getattr(cached_obj, remote_field.attname, None)\n                    # If the cached object has a valid primary key, use it\n                    if cached_value not in (None, ''):\n                        cached_pk_values.append(cached_value)\n                    else:\n                        # Fall back to stored value if cached object's PK is still empty\n                        cached_pk_values.append(getattr(instance, local_field.attname, None))\n                else:\n                    cached_pk_values.append(getattr(instance, local_field.attname, None))\n            \n            # If we got valid values from cache, return them as a tuple\n            if len(cached_pk_values) == len(self.local_related_fields):\n                return tuple(cached_pk_values)\n    \n    # Fall back to the standard implementation\n    return self.get_instance_value_for_fields(instance, self.local_related_fields)\n"
    ],
    "Location 4 (/root/hy/projects/django/django/db/models/fields/related.py lines 653-668)": [
      "\n    @staticmethod\n    def get_instance_value_for_fields(instance, fields):\n        ret = []\n        opts = instance._meta\n        for field in fields:\n            # Gotcha: in some cases (like fixture loading) a model can have\n            # different values in parent_ptr_id and parent's id. So, use\n            # instance.pk (that is, parent_ptr_id) when asked for instance.id.\n            if field.primary_key:\n                possible_parent_link = opts.get_ancestor_link(field.model)\n                if (not possible_parent_link or\n                        possible_parent_link.primary_key or\n                        possible_parent_link.model._meta.abstract):\n                    ret.append(instance.pk)\n                    continue\n            \n            # For foreign key fields, check if there's a cached related object\n            # with a different primary key value than what's stored\n            if hasattr(field, 'related_model') and hasattr(instance, field.get_cache_name()):\n                try:\n                    cached_obj = getattr(instance, field.get_cache_name())\n                    if cached_obj is not None:\n                        # Get the current primary key of the cached related object\n                        cached_pk = cached_obj.pk\n                        stored_fk = getattr(instance, field.attname)\n                        \n                        # If the cached object has a primary key and it differs from stored value,\n                        # use the cached object's current primary key\n                        if cached_pk is not None and cached_pk != stored_fk:\n                            ret.append(cached_pk)\n                            continue\n                except AttributeError:\n                    # Cache name method doesn't exist or other attribute error\n                    pass\n            \n            ret.append(getattr(instance, field.attname))\n        return tuple(ret)\n",
      "\n    @staticmethod\n    def get_instance_value_for_fields(instance, fields):\n        ret = []\n        opts = instance._meta\n        for field in fields:\n            # Gotcha: in some cases (like fixture loading) a model can have\n            # different values in parent_ptr_id and parent's id. So, use\n            # instance.pk (that is, parent_ptr_id) when asked for instance.id.\n            if field.primary_key:\n                possible_parent_link = opts.get_ancestor_link(field.model)\n                if (not possible_parent_link or\n                        possible_parent_link.primary_key or\n                        possible_parent_link.model._meta.abstract):\n                    ret.append(instance.pk)\n                    continue\n            \n            # For foreign key fields, check if there's a cached related object\n            # with a different primary key value than what's stored\n            if hasattr(field, 'related_model') and hasattr(instance, '_state'):\n                cached_rel_obj = getattr(instance, field.get_cache_name(), None)\n                if (cached_rel_obj is not None and \n                    hasattr(cached_rel_obj, '_state') and \n                    cached_rel_obj._state.adding):\n                    # Use the current primary key of the cached related object\n                    cached_pk = getattr(cached_rel_obj, cached_rel_obj._meta.pk.attname)\n                    stored_fk = getattr(instance, field.attname)\n                    if cached_pk and cached_pk != stored_fk:\n                        ret.append(cached_pk)\n                        continue\n            \n            ret.append(getattr(instance, field.attname))\n        return tuple(ret)\n",
      "\n    @staticmethod\n    def get_instance_value_for_fields(instance, fields):\n        ret = []\n        opts = instance._meta\n        for field in fields:\n            # Gotcha: in some cases (like fixture loading) a model can have\n            # different values in parent_ptr_id and parent's id. So, use\n            # instance.pk (that is, parent_ptr_id) when asked for instance.id.\n            if field.primary_key:\n                possible_parent_link = opts.get_ancestor_link(field.model)\n                if (not possible_parent_link or\n                        possible_parent_link.primary_key or\n                        possible_parent_link.model._meta.abstract):\n                    ret.append(instance.pk)\n                    continue\n            \n            # For foreign key fields, check if there's a cached related object\n            # with a different primary key value than what's stored\n            if hasattr(field, 'related_model') and hasattr(instance, field.get_cache_name()):\n                try:\n                    cached_obj = getattr(instance, field.get_cache_name())\n                    if cached_obj is not None:\n                        cached_pk = cached_obj.pk\n                        stored_value = getattr(instance, field.attname)\n                        # Use the cached object's current pk if it differs from stored value\n                        if cached_pk is not None and cached_pk != stored_value:\n                            ret.append(cached_pk)\n                            continue\n                except AttributeError:\n                    pass\n            \n            ret.append(getattr(instance, field.attname))\n        return tuple(ret)\n",
      "\n    @staticmethod\n    def get_instance_value_for_fields(instance, fields):\n        ret = []\n        opts = instance._meta\n        for field in fields:\n            # Gotcha: in some cases (like fixture loading) a model can have\n            # different values in parent_ptr_id and parent's id. So, use\n            # instance.pk (that is, parent_ptr_id) when asked for instance.id.\n            if field.primary_key:\n                possible_parent_link = opts.get_ancestor_link(field.model)\n                if (not possible_parent_link or\n                        possible_parent_link.primary_key or\n                        possible_parent_link.model._meta.abstract):\n                    ret.append(instance.pk)\n                    continue\n            \n            # For foreign key fields, check if there's a cached related object\n            # with a different primary key value than what's stored\n            if hasattr(field, 'related_model') and hasattr(instance, field.name):\n                cached_related_obj = getattr(instance, field.name, None)\n                if (cached_related_obj is not None and \n                    hasattr(cached_related_obj, 'pk') and \n                    cached_related_obj.pk is not None):\n                    stored_value = getattr(instance, field.attname)\n                    # Use the cached object's current pk if it differs from stored value\n                    if cached_related_obj.pk != stored_value:\n                        ret.append(cached_related_obj.pk)\n                        continue\n            \n            ret.append(getattr(instance, field.attname))\n        return tuple(ret)\n",
      "\n    @staticmethod\n    def get_instance_value_for_fields(instance, fields):\n        ret = []\n        opts = instance._meta\n        for field in fields:\n            # Gotcha: in some cases (like fixture loading) a model can have\n            # different values in parent_ptr_id and parent's id. So, use\n            # instance.pk (that is, parent_ptr_id) when asked for instance.id.\n            if field.primary_key:\n                possible_parent_link = opts.get_ancestor_link(field.model)\n                if (not possible_parent_link or\n                        possible_parent_link.primary_key or\n                        possible_parent_link.model._meta.abstract):\n                    ret.append(instance.pk)\n                    continue\n            \n            # For foreign key fields, check if there's a cached related object\n            # with a different primary key value than what's stored\n            if hasattr(field, 'related_model') and hasattr(instance, '_state'):\n                cache_name = field.get_cache_name()\n                if cache_name in instance.__dict__:\n                    cached_obj = instance.__dict__[cache_name]\n                    if cached_obj is not None:\n                        # Get the target field on the related model\n                        target_field = field.target_field\n                        cached_pk_value = getattr(cached_obj, target_field.attname, None)\n                        stored_fk_value = getattr(instance, field.attname, None)\n                        \n                        # If cached object has a valid PK that differs from stored FK value,\n                        # use the cached object's PK (handles case where PK was set after FK assignment)\n                        if (cached_pk_value is not None and \n                            cached_pk_value != stored_fk_value and\n                            cached_pk_value != ''):\n                            ret.append(cached_pk_value)\n                            continue\n            \n            ret.append(getattr(instance, field.attname))\n        return tuple(ret)\n",
      "\n    @staticmethod\n    def get_instance_value_for_fields(instance, fields):\n        ret = []\n        opts = instance._meta\n        for field in fields:\n            # Gotcha: in some cases (like fixture loading) a model can have\n            # different values in parent_ptr_id and parent's id. So, use\n            # instance.pk (that is, parent_ptr_id) when asked for instance.id.\n            if field.primary_key:\n                possible_parent_link = opts.get_ancestor_link(field.model)\n                if (not possible_parent_link or\n                        possible_parent_link.primary_key or\n                        possible_parent_link.model._meta.abstract):\n                    ret.append(instance.pk)\n                    continue\n            \n            # For foreign key fields, check if there's a cached related object\n            # with a valid primary key that differs from the stored value\n            if hasattr(field, 'remote_field') and field.remote_field:\n                stored_value = getattr(instance, field.attname)\n                cache_name = field.get_cache_name()\n                \n                # Check if there's a cached related object\n                if hasattr(instance, '_state') and cache_name in instance.__dict__:\n                    related_obj = instance.__dict__[cache_name]\n                    if related_obj is not None and hasattr(related_obj, 'pk') and related_obj.pk:\n                        # Use the related object's current primary key if it's valid\n                        # and different from the stored value (handles unsaved object case)\n                        if not stored_value or stored_value != related_obj.pk:\n                            ret.append(related_obj.pk)\n                            continue\n            \n            ret.append(getattr(instance, field.attname))\n        return tuple(ret)\n",
      "\n    @staticmethod\n    def get_instance_value_for_fields(instance, fields):\n        ret = []\n        opts = instance._meta\n        for field in fields:\n            # Gotcha: in some cases (like fixture loading) a model can have\n            # different values in parent_ptr_id and parent's id. So, use\n            # instance.pk (that is, parent_ptr_id) when asked for instance.id.\n            if field.primary_key:\n                possible_parent_link = opts.get_ancestor_link(field.model)\n                if (not possible_parent_link or\n                        possible_parent_link.primary_key or\n                        possible_parent_link.model._meta.abstract):\n                    ret.append(instance.pk)\n                    continue\n            \n            # For foreign key fields, check if there's a cached related object\n            # with a different primary key value than what's stored\n            if hasattr(field, 'related_model'):\n                stored_value = getattr(instance, field.attname)\n                cache_name = field.get_cache_name()\n                \n                # Check if there's a cached related object\n                if hasattr(instance, '_state') and hasattr(instance, cache_name):\n                    try:\n                        cached_obj = getattr(instance, cache_name)\n                        if cached_obj is not None:\n                            cached_pk = cached_obj.pk\n                            # If cached object has a different pk than stored value, use the cached pk\n                            if cached_pk is not None and cached_pk != stored_value:\n                                ret.append(cached_pk)\n                                continue\n                    except AttributeError:\n                        pass\n            \n            ret.append(getattr(instance, field.attname))\n        return tuple(ret)\n",
      "\n@staticmethod\ndef get_instance_value_for_fields(instance, fields):\n    ret = []\n    opts = instance._meta\n    for field in fields:\n        # Gotcha: in some cases (like fixture loading) a model can have\n        # different values in parent_ptr_id and parent's id. So, use\n        # instance.pk (that is, parent_ptr_id) when asked for instance.id.\n        if field.primary_key:\n            possible_parent_link = opts.get_ancestor_link(field.model)\n            if (not possible_parent_link or\n                    possible_parent_link.primary_key or\n                    possible_parent_link.model._meta.abstract):\n                ret.append(instance.pk)\n                continue\n        \n        # For foreign key fields, check if there's a cached related object\n        # with a different primary key value than what's stored\n        if hasattr(field, 'related_model') and hasattr(instance, field.get_cache_name()):\n            try:\n                cached_obj = getattr(instance, field.get_cache_name())\n                if cached_obj is not None:\n                    # Get the current primary key of the cached object\n                    cached_pk = cached_obj.pk\n                    stored_value = getattr(instance, field.attname)\n                    # If cached object has a primary key and it differs from stored value,\n                    # use the cached object's primary key\n                    if cached_pk is not None and cached_pk != stored_value:\n                        ret.append(cached_pk)\n                        continue\n            except AttributeError:\n                pass\n        \n        ret.append(getattr(instance, field.attname))\n    return tuple(ret)\n"
    ],
    "Location 5 (/root/hy/projects/django/django/db/models/fields/related_descriptors.py lines 186-194)": [
      "\n            if rel_obj is None and has_value:\n                # Check if we have a cached related object that should be used instead\n                # This handles cases where the foreign key was set before the related object's PK was assigned\n                cached_rel_obj = self.field.get_cached_value(instance, default=None)\n                if cached_rel_obj is not None:\n                    # Use the cached object and update the foreign key value if needed\n                    current_pk = getattr(cached_rel_obj, self.field.target_field.attname, None)\n                    if current_pk is not None and current_pk != '':\n                        # Update the stored foreign key value to match the related object's current PK\n                        setattr(instance, self.field.attname, current_pk)\n                        rel_obj = cached_rel_obj\n                    else:\n                        # Related object still doesn't have a valid PK, use it as-is\n                        rel_obj = cached_rel_obj\n                else:\n                    # No cached object, proceed with database lookup\n                    rel_obj = self.get_object(instance)\n                    remote_field = self.field.remote_field\n                    # If this is a one-to-one relation, set the reverse accessor\n                    # cache on the related object to the current instance to avoid\n                    # an extra SQL query if it's accessed later on.\n                    if not remote_field.multiple:\n                        remote_field.set_cached_value(rel_obj, instance)\n            self.field.set_cached_value(instance, rel_obj)\n",
      "\n            if rel_obj is None and has_value:\n                # Check if we have a cached related object that should be used\n                # instead of doing a database lookup with potentially stale foreign key values\n                cached_obj = self.field.get_cached_value(instance, default=None)\n                if cached_obj is not None:\n                    # Use the cached object if it exists\n                    rel_obj = cached_obj\n                else:\n                    rel_obj = self.get_object(instance)\n                \n                remote_field = self.field.remote_field\n                # If this is a one-to-one relation, set the reverse accessor\n                # cache on the related object to the current instance to avoid\n                # an extra SQL query if it's accessed later on.\n                if not remote_field.multiple:\n                    remote_field.set_cached_value(rel_obj, instance)\n            self.field.set_cached_value(instance, rel_obj)\n",
      "\n            if rel_obj is None and has_value:\n                # Check if there's a cached related object that should be used instead\n                # of doing a database lookup with potentially stale foreign key values\n                cached_rel_obj = self.field.get_cached_value(instance, default=None)\n                if cached_rel_obj is not None:\n                    # Use the cached object if it exists\n                    rel_obj = cached_rel_obj\n                else:\n                    rel_obj = self.get_object(instance)\n                remote_field = self.field.remote_field\n                # If this is a one-to-one relation, set the reverse accessor\n                # cache on the related object to the current instance to avoid\n                # an extra SQL query if it's accessed later on.\n                if not remote_field.multiple:\n                    remote_field.set_cached_value(rel_obj, instance)\n            self.field.set_cached_value(instance, rel_obj)\n",
      "\n            if rel_obj is None and has_value:\n                # Check if we have a cached related object that should be used instead\n                # This handles cases where the foreign key was set before the related object's PK was assigned\n                try:\n                    cached_obj = self.field.get_cached_value(instance, default=None)\n                    if cached_obj is not None:\n                        # Use the cached object instead of doing a database lookup\n                        rel_obj = cached_obj\n                    else:\n                        rel_obj = self.get_object(instance)\n                except (ValueError, self.RelatedObjectDoesNotExist):\n                    # If database lookup fails, check for cached object one more time\n                    cached_obj = self.field.get_cached_value(instance, default=None)\n                    if cached_obj is not None:\n                        rel_obj = cached_obj\n                    else:\n                        raise\n                \n                if rel_obj is not None:\n                    remote_field = self.field.remote_field\n                    # If this is a one-to-one relation, set the reverse accessor\n                    # cache on the related object to the current instance to avoid\n                    # an extra SQL query if it's accessed later on.\n                    if not remote_field.multiple:\n                        remote_field.set_cached_value(rel_obj, instance)\n",
      "\n            if rel_obj is None and has_value:\n                # Check if we have a cached related object that should be used instead\n                # of performing a database lookup with potentially stale foreign key values\n                cached_rel_obj = self.field.get_cached_value(instance, default=None)\n                if cached_rel_obj is not None:\n                    # Use the cached object instead of database lookup\n                    rel_obj = cached_rel_obj\n                else:\n                    rel_obj = self.get_object(instance)\n                remote_field = self.field.remote_field\n                # If this is a one-to-one relation, set the reverse accessor\n                # cache on the related object to the current instance to avoid\n                # an extra SQL query if it's accessed later on.\n                if not remote_field.multiple:\n                    remote_field.set_cached_value(rel_obj, instance)\n            self.field.set_cached_value(instance, rel_obj)\n",
      "\n            if rel_obj is None and has_value:\n                # Check if we have a cached related object that should be used instead\n                # of doing a database lookup with potentially stale foreign key values\n                cached_obj = self.field.get_cached_value(instance, default=None)\n                if cached_obj is not None:\n                    # Use the cached object if it exists\n                    rel_obj = cached_obj\n                else:\n                    # Fall back to database lookup\n                    rel_obj = self.get_object(instance)\n                \n                if rel_obj is not None:\n                    remote_field = self.field.remote_field\n                    # If this is a one-to-one relation, set the reverse accessor\n                    # cache on the related object to the current instance to avoid\n                    # an extra SQL query if it's accessed later on.\n                    if not remote_field.multiple:\n                        remote_field.set_cached_value(rel_obj, instance)\n            self.field.set_cached_value(instance, rel_obj)\n",
      "\n            if rel_obj is None and has_value:\n                # Check if there's a cached related object that should be used instead\n                # of fetching from database with potentially stale foreign key values\n                cached_obj = self.field.get_cached_value(instance, default=None)\n                if cached_obj is not None:\n                    # Use the cached object if it exists\n                    rel_obj = cached_obj\n                else:\n                    rel_obj = self.get_object(instance)\n                remote_field = self.field.remote_field\n                # If this is a one-to-one relation, set the reverse accessor\n                # cache on the related object to the current instance to avoid\n                # an extra SQL query if it's accessed later on.\n                if not remote_field.multiple:\n                    remote_field.set_cached_value(rel_obj, instance)\n            self.field.set_cached_value(instance, rel_obj)\n",
      "\n            if rel_obj is None and has_value:\n                # Check if we have a cached related object that should take precedence\n                # over the stored foreign key value (handles case where PK was set after FK assignment)\n                cached_obj = None\n                try:\n                    cached_obj = self.field.get_cached_value(instance, default=None)\n                except KeyError:\n                    pass\n                \n                if cached_obj is not None:\n                    # Use the cached object instead of doing a database lookup\n                    rel_obj = cached_obj\n                else:\n                    # Proceed with normal database lookup\n                    rel_obj = self.get_object(instance)\n                    \n                remote_field = self.field.remote_field\n                # If this is a one-to-one relation, set the reverse accessor\n                # cache on the related object to the current instance to avoid\n                # an extra SQL query if it's accessed later on.\n                if not remote_field.multiple:\n                    remote_field.set_cached_value(rel_obj, instance)\n            self.field.set_cached_value(instance, rel_obj)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 899ae8efe8..0181e318f2 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -643,12 +643,36 @@ class ForeignObject(RelatedField):\n     def foreign_related_fields(self):\n         return tuple(rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field)\n \n+\n     def get_local_related_value(self, instance):\n-        return self.get_instance_value_for_fields(instance, self.local_related_fields)\n+        # First get the standard stored values\n+        stored_values = self.get_instance_value_for_fields(instance, self.local_related_fields)\n+        \n+        # Check if we need to resolve any deferred foreign key values\n+        try:\n+            cached_obj = self.get_cached_value(instance)\n+            if cached_obj is not None:\n+                # Check if any of the stored values are empty but the cached object has valid values\n+                updated_values = list(stored_values)\n+                for i, (lh_field, rh_field) in enumerate(self.related_fields):\n+                    if (rh_field.primary_key and \n+                        not stored_values[i] and \n+                        hasattr(instance, lh_field.attname + '_deferred')):\n+                        # Get the current value from the cached related object\n+                        current_value = getattr(cached_obj, rh_field.attname)\n+                        if current_value:\n+                            updated_values[i] = current_value\n+                return tuple(updated_values)\n+        except KeyError:\n+            pass\n+        \n+        return stored_values\n \n     def get_foreign_related_value(self, instance):\n         return self.get_instance_value_for_fields(instance, self.foreign_related_fields)\n \n+    @staticmethod\n+\n     @staticmethod\n     def get_instance_value_for_fields(instance, fields):\n         ret = []\n@@ -664,7 +688,39 @@ class ForeignObject(RelatedField):\n                         possible_parent_link.model._meta.abstract):\n                     ret.append(instance.pk)\n                     continue\n-            ret.append(getattr(instance, field.attname))\n+            \n+            # Check if this is a foreign key field that might need dynamic resolution\n+            field_value = getattr(instance, field.attname)\n+            \n+            # For foreign key fields, check if we have a deferred value that needs resolution\n+            if (hasattr(field, 'related_model') and \n+                not field_value and \n+                hasattr(instance, field.attname + '_deferred')):\n+                \n+                # Try to get the value from the cached related object\n+                try:\n+                    # Find the corresponding foreign key field\n+                    for fk_field in opts.get_fields():\n+                        if (hasattr(fk_field, 'attname') and \n+                            fk_field.attname == field.attname and\n+                            hasattr(fk_field, 'get_cached_value')):\n+                            try:\n+                                cached_obj = fk_field.get_cached_value(instance)\n+                                if cached_obj is not None:\n+                                    # Get the primary key from the cached object\n+                                    for lh_field, rh_field in fk_field.related_fields:\n+                                        if lh_field == field:\n+                                            current_pk = getattr(cached_obj, rh_field.attname)\n+                                            if current_pk:\n+                                                field_value = current_pk\n+                                            break\n+                                break\n+                            except KeyError:\n+                                pass\n+                except (AttributeError, KeyError):\n+                    pass\n+            \n+            ret.append(field_value)\n         return tuple(ret)\n \n     def get_attname_column(self):\ndiff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex 872a4c98dc..ed1d44e564 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -169,10 +169,25 @@ class ForwardManyToOneDescriptor:\n         # The related instance is loaded from the database and then cached\n         # by the field on the model instance state. It can also be pre-cached\n         # by the reverse accessor (ReverseOneToOneDescriptor).\n+\n         try:\n             rel_obj = self.field.get_cached_value(instance)\n         except KeyError:\n             has_value = None not in self.field.get_local_related_value(instance)\n+            # Check for deferred foreign key values - if we have a cached related object\n+            # with a valid primary key but the stored foreign key value is empty/None,\n+            # we should consider this as having a value\n+            if not has_value:\n+                try:\n+                    cached_rel_obj = self.field.get_cached_value(instance)\n+                    if cached_rel_obj is not None:\n+                        # Check if the cached object now has a valid primary key\n+                        for lh_field, rh_field in self.field.related_fields:\n+                            if rh_field.primary_key and getattr(cached_rel_obj, rh_field.attname):\n+                                has_value = True\n+                                break\n+                except KeyError:\n+                    pass\n             ancestor_link = instance._meta.get_ancestor_link(self.field.model) if has_value else None\n             if ancestor_link and ancestor_link.is_cached(instance):\n                 # An ancestor link will exist if this field is defined on a\n@@ -183,8 +198,25 @@ class ForwardManyToOneDescriptor:\n                 rel_obj = self.field.get_cached_value(ancestor, default=None)\n             else:\n                 rel_obj = None\n+\n             if rel_obj is None and has_value:\n-                rel_obj = self.get_object(instance)\n+                # Before fetching from database, check if we have a cached related object\n+                # that should be used instead (for deferred foreign key scenarios)\n+                try:\n+                    cached_rel_obj = self.field.get_cached_value(instance)\n+                    if cached_rel_obj is not None:\n+                        # Check if the cached object has a valid primary key now\n+                        for lh_field, rh_field in self.field.related_fields:\n+                            if rh_field.primary_key and getattr(cached_rel_obj, rh_field.attname):\n+                                rel_obj = cached_rel_obj\n+                                break\n+                except KeyError:\n+                    pass\n+                \n+                # If we still don't have a related object, fetch from database\n+                if rel_obj is None:\n+                    rel_obj = self.get_object(instance)\n+                    \n                 remote_field = self.field.remote_field\n                 # If this is a one-to-one relation, set the reverse accessor\n                 # cache on the related object to the current instance to avoid\n@@ -251,15 +283,31 @@ class ForwardManyToOneDescriptor:\n             for lh_field, rh_field in self.field.related_fields:\n                 setattr(instance, lh_field.attname, None)\n \n+\n         # Set the values of the related field.\n         else:\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+                # Get the current value from the related object\n+                rh_value = getattr(value, rh_field.attname)\n+                \n+                # For unsaved objects with empty primary keys, defer the assignment\n+                # to allow for lazy resolution when the primary key is later set\n+                if (rh_field.primary_key and \n+                    not rh_value and \n+                    value._state.adding and \n+                    not value._state.db):\n+                    # Mark this field for deferred resolution by setting a special marker\n+                    setattr(instance, lh_field.attname + '_deferred', True)\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # Remove any deferred marker if it exists\n+                    if hasattr(instance, lh_field.attname + '_deferred'):\n+                        delattr(instance, lh_field.attname + '_deferred')\n+                    setattr(instance, lh_field.attname, rh_value)\n \n         # Set the related instance cache used by __get__ to avoid an SQL query\n         # when accessing the attribute we just set.\n         self.field.set_cached_value(instance, value)\n-\n         # If this is a one-to-one relation, set the reverse accessor cache on\n         # the related object to the current instance to avoid an extra SQL\n         # query if it's accessed later on.\n",
    "variant_0": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 899ae8efe8..9de1bb4213 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -643,12 +643,36 @@ class ForeignObject(RelatedField):\n     def foreign_related_fields(self):\n         return tuple(rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field)\n \n-    def get_local_related_value(self, instance):\n-        return self.get_instance_value_for_fields(instance, self.local_related_fields)\n+\n+def get_local_related_value(self, instance):\n+    # Check if there's a cached related object that might have a more current primary key\n+    if hasattr(self, 'cache_name'):\n+        try:\n+            cached_obj = getattr(instance, self.cache_name, None)\n+            if cached_obj is not None and hasattr(cached_obj, '_state') and not cached_obj._state.adding:\n+                # Get the current primary key values from the cached object\n+                cached_values = []\n+                for lhs_field, rhs_field in self.related_fields:\n+                    if rhs_field:\n+                        cached_val = getattr(cached_obj, rhs_field.attname)\n+                        if cached_val is not None and cached_val != '':\n+                            cached_values.append(cached_val)\n+                        else:\n+                            break\n+                else:\n+                    # All cached values are valid, use them instead of stored values\n+                    if len(cached_values) == len(self.local_related_fields):\n+                        return tuple(cached_values)\n+        except AttributeError:\n+            pass\n+    \n+    return self.get_instance_value_for_fields(instance, self.local_related_fields)\n \n     def get_foreign_related_value(self, instance):\n         return self.get_instance_value_for_fields(instance, self.foreign_related_fields)\n \n+    @staticmethod\n+\n     @staticmethod\n     def get_instance_value_for_fields(instance, fields):\n         ret = []\n@@ -664,6 +688,25 @@ class ForeignObject(RelatedField):\n                         possible_parent_link.model._meta.abstract):\n                     ret.append(instance.pk)\n                     continue\n+            \n+            # For foreign key fields, check if there's a cached related object\n+            # with a different primary key value than what's stored\n+            if hasattr(field, 'related_model') and field.related_model:\n+                stored_value = getattr(instance, field.attname)\n+                cached_attr_name = field.get_cache_name()\n+                \n+                # Check if there's a cached related object\n+                if hasattr(instance, '_state') and hasattr(instance._state, 'fields_cache'):\n+                    cached_obj = instance._state.fields_cache.get(cached_attr_name)\n+                    if cached_obj is not None:\n+                        # Get the primary key of the cached object\n+                        cached_pk = cached_obj.pk\n+                        # If the cached object has a valid pk and it differs from stored value,\n+                        # use the cached object's pk\n+                        if cached_pk is not None and cached_pk != stored_value:\n+                            ret.append(cached_pk)\n+                            continue\n+            \n             ret.append(getattr(instance, field.attname))\n         return tuple(ret)\n \ndiff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex 872a4c98dc..ada104f338 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -169,6 +169,7 @@ class ForwardManyToOneDescriptor:\n         # The related instance is loaded from the database and then cached\n         # by the field on the model instance state. It can also be pre-cached\n         # by the reverse accessor (ReverseOneToOneDescriptor).\n+\n         try:\n             rel_obj = self.field.get_cached_value(instance)\n         except KeyError:\n@@ -183,14 +184,30 @@ class ForwardManyToOneDescriptor:\n                 rel_obj = self.field.get_cached_value(ancestor, default=None)\n             else:\n                 rel_obj = None\n+\n             if rel_obj is None and has_value:\n-                rel_obj = self.get_object(instance)\n-                remote_field = self.field.remote_field\n-                # If this is a one-to-one relation, set the reverse accessor\n-                # cache on the related object to the current instance to avoid\n-                # an extra SQL query if it's accessed later on.\n-                if not remote_field.multiple:\n-                    remote_field.set_cached_value(rel_obj, instance)\n+                # Check if we have a cached related object that should be used instead\n+                # This handles cases where the foreign key was set to an unsaved object\n+                # and we need to use the cached object rather than querying the database\n+                cached_rel_obj = self.field.get_cached_value(instance, default=None)\n+                if cached_rel_obj is not None:\n+                    # Verify the cached object has a valid primary key\n+                    pk_val = getattr(cached_rel_obj, cached_rel_obj._meta.pk.attname, None)\n+                    if pk_val is not None and pk_val != '':\n+                        rel_obj = cached_rel_obj\n+                    else:\n+                        # Cached object exists but has no valid PK, use it anyway\n+                        # as it represents the intended relationship\n+                        rel_obj = cached_rel_obj\n+                else:\n+                    # No cached object, proceed with database lookup\n+                    rel_obj = self.get_object(instance)\n+                    remote_field = self.field.remote_field\n+                    # If this is a one-to-one relation, set the reverse accessor\n+                    # cache on the related object to the current instance to avoid\n+                    # an extra SQL query if it's accessed later on.\n+                    if not remote_field.multiple:\n+                        remote_field.set_cached_value(rel_obj, instance)\n             self.field.set_cached_value(instance, rel_obj)\n \n         if rel_obj is None and not self.field.null:\n@@ -251,15 +268,21 @@ class ForwardManyToOneDescriptor:\n             for lh_field, rh_field in self.field.related_fields:\n                 setattr(instance, lh_field.attname, None)\n \n+\n         # Set the values of the related field.\n         else:\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+                # Check if the related object is unsaved and has an empty/None primary key\n+                rh_value = getattr(value, rh_field.attname)\n+                if (rh_value == '' or rh_value is None) and hasattr(value, '_state') and value._state.adding:\n+                    # For unsaved objects with empty primary keys, store None to defer resolution\n+                    setattr(instance, lh_field.attname, None)\n+                else:\n+                    setattr(instance, lh_field.attname, rh_value)\n \n         # Set the related instance cache used by __get__ to avoid an SQL query\n         # when accessing the attribute we just set.\n         self.field.set_cached_value(instance, value)\n-\n         # If this is a one-to-one relation, set the reverse accessor cache on\n         # the related object to the current instance to avoid an extra SQL\n         # query if it's accessed later on.\n",
    "variant_1": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 899ae8efe8..9e10df8f65 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -643,12 +643,33 @@ class ForeignObject(RelatedField):\n     def foreign_related_fields(self):\n         return tuple(rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field)\n \n-    def get_local_related_value(self, instance):\n-        return self.get_instance_value_for_fields(instance, self.local_related_fields)\n+\n+def get_local_related_value(self, instance):\n+    # First get the standard stored values\n+    stored_values = self.get_instance_value_for_fields(instance, self.local_related_fields)\n+    \n+    # Check if there's a cached related object that might have updated primary key values\n+    if hasattr(instance, '_state') and hasattr(self, 'get_cache_name'):\n+        cache_name = self.get_cache_name()\n+        if hasattr(instance, cache_name):\n+            try:\n+                cached_obj = getattr(instance, cache_name)\n+                if cached_obj is not None:\n+                    # Get current values from the cached related object\n+                    current_values = self.get_instance_value_for_fields(cached_obj, self.foreign_related_fields)\n+                    # If any stored value is empty/None but current value is not, use current values\n+                    if any(not stored_val and current_val for stored_val, current_val in zip(stored_values, current_values)):\n+                        return current_values\n+            except AttributeError:\n+                pass\n+    \n+    return stored_values\n \n     def get_foreign_related_value(self, instance):\n         return self.get_instance_value_for_fields(instance, self.foreign_related_fields)\n \n+    @staticmethod\n+\n     @staticmethod\n     def get_instance_value_for_fields(instance, fields):\n         ret = []\n@@ -664,6 +685,26 @@ class ForeignObject(RelatedField):\n                         possible_parent_link.model._meta.abstract):\n                     ret.append(instance.pk)\n                     continue\n+            \n+            # For foreign key fields, check if there's a cached related object\n+            # with a different primary key value than what's stored\n+            if hasattr(field, 'related_model') and hasattr(instance, field.get_cache_name()):\n+                try:\n+                    cached_obj = getattr(instance, field.get_cache_name())\n+                    if cached_obj is not None:\n+                        # Get the current primary key of the cached related object\n+                        cached_pk = cached_obj.pk\n+                        stored_fk = getattr(instance, field.attname)\n+                        \n+                        # If the cached object has a primary key and it differs from stored value,\n+                        # use the cached object's current primary key\n+                        if cached_pk is not None and cached_pk != stored_fk:\n+                            ret.append(cached_pk)\n+                            continue\n+                except AttributeError:\n+                    # Cache name method doesn't exist or other attribute error\n+                    pass\n+            \n             ret.append(getattr(instance, field.attname))\n         return tuple(ret)\n \ndiff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex 872a4c98dc..807281c97c 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -169,6 +169,7 @@ class ForwardManyToOneDescriptor:\n         # The related instance is loaded from the database and then cached\n         # by the field on the model instance state. It can also be pre-cached\n         # by the reverse accessor (ReverseOneToOneDescriptor).\n+\n         try:\n             rel_obj = self.field.get_cached_value(instance)\n         except KeyError:\n@@ -183,14 +184,30 @@ class ForwardManyToOneDescriptor:\n                 rel_obj = self.field.get_cached_value(ancestor, default=None)\n             else:\n                 rel_obj = None\n+\n             if rel_obj is None and has_value:\n-                rel_obj = self.get_object(instance)\n-                remote_field = self.field.remote_field\n-                # If this is a one-to-one relation, set the reverse accessor\n-                # cache on the related object to the current instance to avoid\n-                # an extra SQL query if it's accessed later on.\n-                if not remote_field.multiple:\n-                    remote_field.set_cached_value(rel_obj, instance)\n+                # Check if we have a cached related object that should be used instead\n+                # This handles cases where the foreign key was set before the related object's PK was assigned\n+                cached_rel_obj = self.field.get_cached_value(instance, default=None)\n+                if cached_rel_obj is not None:\n+                    # Use the cached object and update the foreign key value if needed\n+                    current_pk = getattr(cached_rel_obj, self.field.target_field.attname, None)\n+                    if current_pk is not None and current_pk != '':\n+                        # Update the stored foreign key value to match the related object's current PK\n+                        setattr(instance, self.field.attname, current_pk)\n+                        rel_obj = cached_rel_obj\n+                    else:\n+                        # Related object still doesn't have a valid PK, use it as-is\n+                        rel_obj = cached_rel_obj\n+                else:\n+                    # No cached object, proceed with database lookup\n+                    rel_obj = self.get_object(instance)\n+                    remote_field = self.field.remote_field\n+                    # If this is a one-to-one relation, set the reverse accessor\n+                    # cache on the related object to the current instance to avoid\n+                    # an extra SQL query if it's accessed later on.\n+                    if not remote_field.multiple:\n+                        remote_field.set_cached_value(rel_obj, instance)\n             self.field.set_cached_value(instance, rel_obj)\n \n         if rel_obj is None and not self.field.null:\n@@ -251,15 +268,33 @@ class ForwardManyToOneDescriptor:\n             for lh_field, rh_field in self.field.related_fields:\n                 setattr(instance, lh_field.attname, None)\n \n+\n         # Set the values of the related field.\n         else:\n-            for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+            # Check if this is an unsaved object with an unset primary key\n+            # If so, we'll defer the foreign key assignment until the related object is saved\n+            should_defer = False\n+            if hasattr(value, '_state') and not value._state.adding is False:\n+                # Object might be unsaved, check if primary key is effectively empty\n+                for lh_field, rh_field in self.field.related_fields:\n+                    pk_value = getattr(value, rh_field.attname)\n+                    if pk_value in (None, ''):\n+                        should_defer = True\n+                        break\n+            \n+            if should_defer:\n+                # For unsaved objects with empty PKs, just cache the object\n+                # The foreign key values will be resolved dynamically when needed\n+                for lh_field, rh_field in self.field.related_fields:\n+                    setattr(instance, lh_field.attname, None)\n+            else:\n+                # Normal case: set the foreign key values immediately\n+                for lh_field, rh_field in self.field.related_fields:\n+                    setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n \n         # Set the related instance cache used by __get__ to avoid an SQL query\n         # when accessing the attribute we just set.\n         self.field.set_cached_value(instance, value)\n-\n         # If this is a one-to-one relation, set the reverse accessor cache on\n         # the related object to the current instance to avoid an extra SQL\n         # query if it's accessed later on.\n",
    "variant_2": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 899ae8efe8..50720dac9f 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -643,12 +643,31 @@ class ForeignObject(RelatedField):\n     def foreign_related_fields(self):\n         return tuple(rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field)\n \n+\n     def get_local_related_value(self, instance):\n+        # Check if there's a cached related object that might have a more current primary key\n+        if hasattr(instance, '_state') and not instance._state.adding:\n+            # For existing instances, check for cached related objects\n+            for field in self.local_related_fields:\n+                if hasattr(field, 'related_model') and hasattr(instance, field.get_cache_name()):\n+                    cached_obj = getattr(instance, field.get_cache_name(), None)\n+                    if cached_obj is not None and hasattr(cached_obj, '_state'):\n+                        # Get the current primary key from the cached object\n+                        cached_pk = getattr(cached_obj, field.target_field.attname, None)\n+                        # Get the stored foreign key value\n+                        stored_fk = getattr(instance, field.attname, None)\n+                        # If they differ and the cached object has a valid primary key, use the cached one\n+                        if cached_pk and cached_pk != stored_fk:\n+                            # Update the stored foreign key value to match the cached object\n+                            setattr(instance, field.attname, cached_pk)\n+        \n         return self.get_instance_value_for_fields(instance, self.local_related_fields)\n \n     def get_foreign_related_value(self, instance):\n         return self.get_instance_value_for_fields(instance, self.foreign_related_fields)\n \n+    @staticmethod\n+\n     @staticmethod\n     def get_instance_value_for_fields(instance, fields):\n         ret = []\n@@ -664,6 +683,21 @@ class ForeignObject(RelatedField):\n                         possible_parent_link.model._meta.abstract):\n                     ret.append(instance.pk)\n                     continue\n+            \n+            # For foreign key fields, check if there's a cached related object\n+            # with a different primary key value than what's stored\n+            if hasattr(field, 'related_model') and hasattr(instance, '_state'):\n+                cached_rel_obj = getattr(instance, field.get_cache_name(), None)\n+                if (cached_rel_obj is not None and \n+                    hasattr(cached_rel_obj, '_state') and \n+                    cached_rel_obj._state.adding):\n+                    # Use the current primary key of the cached related object\n+                    cached_pk = getattr(cached_rel_obj, cached_rel_obj._meta.pk.attname)\n+                    stored_fk = getattr(instance, field.attname)\n+                    if cached_pk and cached_pk != stored_fk:\n+                        ret.append(cached_pk)\n+                        continue\n+            \n             ret.append(getattr(instance, field.attname))\n         return tuple(ret)\n \ndiff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex 872a4c98dc..14591be345 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -169,6 +169,7 @@ class ForwardManyToOneDescriptor:\n         # The related instance is loaded from the database and then cached\n         # by the field on the model instance state. It can also be pre-cached\n         # by the reverse accessor (ReverseOneToOneDescriptor).\n+\n         try:\n             rel_obj = self.field.get_cached_value(instance)\n         except KeyError:\n@@ -183,8 +184,17 @@ class ForwardManyToOneDescriptor:\n                 rel_obj = self.field.get_cached_value(ancestor, default=None)\n             else:\n                 rel_obj = None\n+\n             if rel_obj is None and has_value:\n-                rel_obj = self.get_object(instance)\n+                # Check if we have a cached related object that should be used\n+                # instead of doing a database lookup with potentially stale foreign key values\n+                cached_obj = self.field.get_cached_value(instance, default=None)\n+                if cached_obj is not None:\n+                    # Use the cached object if it exists\n+                    rel_obj = cached_obj\n+                else:\n+                    rel_obj = self.get_object(instance)\n+                \n                 remote_field = self.field.remote_field\n                 # If this is a one-to-one relation, set the reverse accessor\n                 # cache on the related object to the current instance to avoid\n@@ -251,15 +261,31 @@ class ForwardManyToOneDescriptor:\n             for lh_field, rh_field in self.field.related_fields:\n                 setattr(instance, lh_field.attname, None)\n \n+\n         # Set the values of the related field.\n         else:\n-            for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+            # Check if the related object is unsaved and has empty primary key values\n+            has_empty_pk = False\n+            if hasattr(value, '_state') and not value._state.adding is False:\n+                for lh_field, rh_field in self.field.related_fields:\n+                    pk_value = getattr(value, rh_field.attname)\n+                    if pk_value in (None, ''):\n+                        has_empty_pk = True\n+                        break\n+            \n+            # If the related object has empty primary keys, store placeholder values\n+            # but rely on dynamic resolution during access\n+            if has_empty_pk:\n+                for lh_field, rh_field in self.field.related_fields:\n+                    # Store a marker that indicates deferred resolution needed\n+                    setattr(instance, lh_field.attname, getattr(value, rh_field.attname) or '')\n+            else:\n+                for lh_field, rh_field in self.field.related_fields:\n+                    setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n \n         # Set the related instance cache used by __get__ to avoid an SQL query\n         # when accessing the attribute we just set.\n         self.field.set_cached_value(instance, value)\n-\n         # If this is a one-to-one relation, set the reverse accessor cache on\n         # the related object to the current instance to avoid an extra SQL\n         # query if it's accessed later on.\n",
    "variant_3": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 899ae8efe8..41c5d365a6 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -643,12 +643,28 @@ class ForeignObject(RelatedField):\n     def foreign_related_fields(self):\n         return tuple(rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field)\n \n+\n     def get_local_related_value(self, instance):\n+        # Check if there's a cached related object that might have a more current primary key value\n+        if hasattr(instance, '_state') and not instance._state.db:\n+            # For unsaved instances, check if there's a cached related object\n+            cache_name = self.get_cache_name()\n+            if hasattr(instance, cache_name):\n+                cached_obj = getattr(instance, cache_name)\n+                if cached_obj is not None:\n+                    # Get the current primary key value from the cached object\n+                    cached_values = self.get_instance_value_for_fields(cached_obj, self.foreign_related_fields)\n+                    # If the cached object has valid primary key values, use them\n+                    if all(val not in (None, '') for val in cached_values):\n+                        return cached_values\n+        \n         return self.get_instance_value_for_fields(instance, self.local_related_fields)\n \n     def get_foreign_related_value(self, instance):\n         return self.get_instance_value_for_fields(instance, self.foreign_related_fields)\n \n+    @staticmethod\n+\n     @staticmethod\n     def get_instance_value_for_fields(instance, fields):\n         ret = []\n@@ -664,6 +680,22 @@ class ForeignObject(RelatedField):\n                         possible_parent_link.model._meta.abstract):\n                     ret.append(instance.pk)\n                     continue\n+            \n+            # For foreign key fields, check if there's a cached related object\n+            # with a different primary key value than what's stored\n+            if hasattr(field, 'related_model') and hasattr(instance, field.get_cache_name()):\n+                try:\n+                    cached_obj = getattr(instance, field.get_cache_name())\n+                    if cached_obj is not None:\n+                        cached_pk = cached_obj.pk\n+                        stored_value = getattr(instance, field.attname)\n+                        # Use the cached object's current pk if it differs from stored value\n+                        if cached_pk is not None and cached_pk != stored_value:\n+                            ret.append(cached_pk)\n+                            continue\n+                except AttributeError:\n+                    pass\n+            \n             ret.append(getattr(instance, field.attname))\n         return tuple(ret)\n \ndiff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex 872a4c98dc..ff6552156f 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -169,6 +169,7 @@ class ForwardManyToOneDescriptor:\n         # The related instance is loaded from the database and then cached\n         # by the field on the model instance state. It can also be pre-cached\n         # by the reverse accessor (ReverseOneToOneDescriptor).\n+\n         try:\n             rel_obj = self.field.get_cached_value(instance)\n         except KeyError:\n@@ -184,7 +185,38 @@ class ForwardManyToOneDescriptor:\n             else:\n                 rel_obj = None\n             if rel_obj is None and has_value:\n-                rel_obj = self.get_object(instance)\n+                # Check if there's a cached related object that should be used instead\n+                # This handles cases where the foreign key was set but the related object's\n+                # primary key was modified after assignment\n+                cached_related = None\n+                try:\n+                    cached_related = getattr(instance, self.field.get_cache_name(), None)\n+                except AttributeError:\n+                    pass\n+                \n+                if cached_related is not None:\n+                    # Use the cached related object instead of fetching from database\n+                    rel_obj = cached_related\n+                else:\n+            if ancestor_link and ancestor_link.is_cached(instance):\n+                # An ancestor link will exist if this field is defined on a\n+                # multi-table inheritance parent of the instance's class.\n+                ancestor = ancestor_link.get_cached_value(instance)\n+                # The value might be cached on an ancestor if the instance\n+                # originated from walking down the inheritance chain.\n+                rel_obj = self.field.get_cached_value(ancestor, default=None)\n+            else:\n+                rel_obj = None\n+\n+            if rel_obj is None and has_value:\n+                # Check if there's a cached related object that should be used instead\n+                # of doing a database lookup with potentially stale foreign key values\n+                cached_rel_obj = self.field.get_cached_value(instance, default=None)\n+                if cached_rel_obj is not None:\n+                    # Use the cached object if it exists\n+                    rel_obj = cached_rel_obj\n+                else:\n+                    rel_obj = self.get_object(instance)\n                 remote_field = self.field.remote_field\n                 # If this is a one-to-one relation, set the reverse accessor\n                 # cache on the related object to the current instance to avoid\n@@ -251,15 +283,32 @@ class ForwardManyToOneDescriptor:\n             for lh_field, rh_field in self.field.related_fields:\n                 setattr(instance, lh_field.attname, None)\n \n+\n         # Set the values of the related field.\n         else:\n-            for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+            # Check if the related object is unsaved and has empty primary key values\n+            needs_deferred_assignment = False\n+            if hasattr(value, '_state') and value._state.adding:\n+                # Check if any of the primary key fields are empty/None\n+                for lh_field, rh_field in self.field.related_fields:\n+                    rh_value = getattr(value, rh_field.attname)\n+                    if rh_value in (None, ''):\n+                        needs_deferred_assignment = True\n+                        break\n+            \n+            if needs_deferred_assignment:\n+                # For unsaved objects with empty PKs, store None in foreign key fields\n+                # The actual values will be resolved dynamically when needed\n+                for lh_field, rh_field in self.field.related_fields:\n+                    setattr(instance, lh_field.attname, None)\n+            else:\n+                # Normal case: set the foreign key values immediately\n+                for lh_field, rh_field in self.field.related_fields:\n+                    setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n \n         # Set the related instance cache used by __get__ to avoid an SQL query\n         # when accessing the attribute we just set.\n         self.field.set_cached_value(instance, value)\n-\n         # If this is a one-to-one relation, set the reverse accessor cache on\n         # the related object to the current instance to avoid an extra SQL\n         # query if it's accessed later on.\n",
    "variant_4": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 899ae8efe8..6045cf9315 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -643,12 +643,38 @@ class ForeignObject(RelatedField):\n     def foreign_related_fields(self):\n         return tuple(rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field)\n \n+\n     def get_local_related_value(self, instance):\n+        # Check if there's a cached related object that might have a different primary key\n+        # than what's currently stored in the foreign key field\n+        if hasattr(self, 'cached_name'):\n+            try:\n+                cached_obj = getattr(instance, self.cached_name, None)\n+                if cached_obj is not None and hasattr(cached_obj, '_state') and not cached_obj._state.db:\n+                    # Related object exists but is unsaved - use its current primary key values\n+                    cached_values = []\n+                    for lhs_field, rhs_field in self.related_fields:\n+                        if rhs_field:\n+                            cached_value = getattr(cached_obj, rhs_field.attname)\n+                            # Only use cached value if it's not empty/None\n+                            if cached_value not in (None, ''):\n+                                cached_values.append(cached_value)\n+                            else:\n+                                # Fall back to stored value if cached object's pk is empty\n+                                cached_values.append(getattr(instance, lhs_field.attname))\n+                        else:\n+                            cached_values.append(getattr(instance, lhs_field.attname))\n+                    return tuple(cached_values)\n+            except AttributeError:\n+                pass\n+        \n         return self.get_instance_value_for_fields(instance, self.local_related_fields)\n \n     def get_foreign_related_value(self, instance):\n         return self.get_instance_value_for_fields(instance, self.foreign_related_fields)\n \n+    @staticmethod\n+\n     @staticmethod\n     def get_instance_value_for_fields(instance, fields):\n         ret = []\n@@ -664,6 +690,20 @@ class ForeignObject(RelatedField):\n                         possible_parent_link.model._meta.abstract):\n                     ret.append(instance.pk)\n                     continue\n+            \n+            # For foreign key fields, check if there's a cached related object\n+            # with a different primary key value than what's stored\n+            if hasattr(field, 'related_model') and hasattr(instance, field.name):\n+                cached_related_obj = getattr(instance, field.name, None)\n+                if (cached_related_obj is not None and \n+                    hasattr(cached_related_obj, 'pk') and \n+                    cached_related_obj.pk is not None):\n+                    stored_value = getattr(instance, field.attname)\n+                    # Use the cached object's current pk if it differs from stored value\n+                    if cached_related_obj.pk != stored_value:\n+                        ret.append(cached_related_obj.pk)\n+                        continue\n+            \n             ret.append(getattr(instance, field.attname))\n         return tuple(ret)\n \ndiff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex 872a4c98dc..0f39a4d2ae 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -169,6 +169,7 @@ class ForwardManyToOneDescriptor:\n         # The related instance is loaded from the database and then cached\n         # by the field on the model instance state. It can also be pre-cached\n         # by the reverse accessor (ReverseOneToOneDescriptor).\n+\n         try:\n             rel_obj = self.field.get_cached_value(instance)\n         except KeyError:\n@@ -183,15 +184,32 @@ class ForwardManyToOneDescriptor:\n                 rel_obj = self.field.get_cached_value(ancestor, default=None)\n             else:\n                 rel_obj = None\n+\n             if rel_obj is None and has_value:\n-                rel_obj = self.get_object(instance)\n-                remote_field = self.field.remote_field\n-                # If this is a one-to-one relation, set the reverse accessor\n-                # cache on the related object to the current instance to avoid\n-                # an extra SQL query if it's accessed later on.\n-                if not remote_field.multiple:\n-                    remote_field.set_cached_value(rel_obj, instance)\n-            self.field.set_cached_value(instance, rel_obj)\n+                # Check if we have a cached related object that should be used instead\n+                # This handles cases where the foreign key was set before the related object's PK was assigned\n+                try:\n+                    cached_obj = self.field.get_cached_value(instance, default=None)\n+                    if cached_obj is not None:\n+                        # Use the cached object instead of doing a database lookup\n+                        rel_obj = cached_obj\n+                    else:\n+                        rel_obj = self.get_object(instance)\n+                except (ValueError, self.RelatedObjectDoesNotExist):\n+                    # If database lookup fails, check for cached object one more time\n+                    cached_obj = self.field.get_cached_value(instance, default=None)\n+                    if cached_obj is not None:\n+                        rel_obj = cached_obj\n+                    else:\n+                        raise\n+                \n+                if rel_obj is not None:\n+                    remote_field = self.field.remote_field\n+                    # If this is a one-to-one relation, set the reverse accessor\n+                    # cache on the related object to the current instance to avoid\n+                    # an extra SQL query if it's accessed later on.\n+                    if not remote_field.multiple:\n+                        remote_field.set_cached_value(rel_obj, instance)\n \n         if rel_obj is None and not self.field.null:\n             raise self.RelatedObjectDoesNotExist(\n@@ -251,15 +269,34 @@ class ForwardManyToOneDescriptor:\n             for lh_field, rh_field in self.field.related_fields:\n                 setattr(instance, lh_field.attname, None)\n \n+\n         # Set the values of the related field.\n         else:\n-            for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+            # Check if the related object is unsaved and has empty primary key values\n+            needs_lazy_resolution = False\n+            if hasattr(value, '_state') and value._state.adding:\n+                for lh_field, rh_field in self.field.related_fields:\n+                    rh_value = getattr(value, rh_field.attname)\n+                    if rh_value is None or rh_value == '':\n+                        needs_lazy_resolution = True\n+                        break\n+            \n+            if needs_lazy_resolution:\n+                # For unsaved objects with empty PKs, store a marker for lazy resolution\n+                for lh_field, rh_field in self.field.related_fields:\n+                    setattr(instance, lh_field.attname, None)\n+                # Store metadata to indicate lazy resolution is needed\n+                if not hasattr(instance, '_lazy_fk_resolution'):\n+                    instance._lazy_fk_resolution = {}\n+                instance._lazy_fk_resolution[self.field.name] = True\n+            else:\n+                # Normal case: set the foreign key values immediately\n+                for lh_field, rh_field in self.field.related_fields:\n+                    setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n \n         # Set the related instance cache used by __get__ to avoid an SQL query\n         # when accessing the attribute we just set.\n         self.field.set_cached_value(instance, value)\n-\n         # If this is a one-to-one relation, set the reverse accessor cache on\n         # the related object to the current instance to avoid an extra SQL\n         # query if it's accessed later on.\n",
    "variant_5": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 899ae8efe8..fcc1724815 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -643,12 +643,33 @@ class ForeignObject(RelatedField):\n     def foreign_related_fields(self):\n         return tuple(rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field)\n \n-    def get_local_related_value(self, instance):\n-        return self.get_instance_value_for_fields(instance, self.local_related_fields)\n+\n+def get_local_related_value(self, instance):\n+    # First get the stored foreign key values\n+    stored_values = self.get_instance_value_for_fields(instance, self.local_related_fields)\n+    \n+    # Check if there's a cached related object that might have a different primary key\n+    if hasattr(instance, '_state') and hasattr(instance._state, 'fields_cache'):\n+        cache_name = self.get_cache_name()\n+        if cache_name in instance._state.fields_cache:\n+            related_obj = instance._state.fields_cache[cache_name]\n+            if related_obj is not None:\n+                # Get the current primary key values from the cached related object\n+                current_values = self.get_instance_value_for_fields(related_obj, self.foreign_related_fields)\n+                \n+                # If the cached object has valid primary key values and they differ from stored values,\n+                # use the current values from the cached object\n+                if (current_values and all(val is not None and val != '' for val in current_values) and\n+                    current_values != stored_values):\n+                    return current_values\n+    \n+    return stored_values\n \n     def get_foreign_related_value(self, instance):\n         return self.get_instance_value_for_fields(instance, self.foreign_related_fields)\n \n+    @staticmethod\n+\n     @staticmethod\n     def get_instance_value_for_fields(instance, fields):\n         ret = []\n@@ -664,6 +685,27 @@ class ForeignObject(RelatedField):\n                         possible_parent_link.model._meta.abstract):\n                     ret.append(instance.pk)\n                     continue\n+            \n+            # For foreign key fields, check if there's a cached related object\n+            # with a different primary key value than what's stored\n+            if hasattr(field, 'related_model') and hasattr(instance, '_state'):\n+                cache_name = field.get_cache_name()\n+                if cache_name in instance.__dict__:\n+                    cached_obj = instance.__dict__[cache_name]\n+                    if cached_obj is not None:\n+                        # Get the target field on the related model\n+                        target_field = field.target_field\n+                        cached_pk_value = getattr(cached_obj, target_field.attname, None)\n+                        stored_fk_value = getattr(instance, field.attname, None)\n+                        \n+                        # If cached object has a valid PK that differs from stored FK value,\n+                        # use the cached object's PK (handles case where PK was set after FK assignment)\n+                        if (cached_pk_value is not None and \n+                            cached_pk_value != stored_fk_value and\n+                            cached_pk_value != ''):\n+                            ret.append(cached_pk_value)\n+                            continue\n+            \n             ret.append(getattr(instance, field.attname))\n         return tuple(ret)\n \ndiff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex 872a4c98dc..3c987fb8c7 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -169,6 +169,7 @@ class ForwardManyToOneDescriptor:\n         # The related instance is loaded from the database and then cached\n         # by the field on the model instance state. It can also be pre-cached\n         # by the reverse accessor (ReverseOneToOneDescriptor).\n+\n         try:\n             rel_obj = self.field.get_cached_value(instance)\n         except KeyError:\n@@ -183,8 +184,16 @@ class ForwardManyToOneDescriptor:\n                 rel_obj = self.field.get_cached_value(ancestor, default=None)\n             else:\n                 rel_obj = None\n+\n             if rel_obj is None and has_value:\n-                rel_obj = self.get_object(instance)\n+                # Check if we have a cached related object that should be used instead\n+                # of performing a database lookup with potentially stale foreign key values\n+                cached_rel_obj = self.field.get_cached_value(instance, default=None)\n+                if cached_rel_obj is not None:\n+                    # Use the cached object instead of database lookup\n+                    rel_obj = cached_rel_obj\n+                else:\n+                    rel_obj = self.get_object(instance)\n                 remote_field = self.field.remote_field\n                 # If this is a one-to-one relation, set the reverse accessor\n                 # cache on the related object to the current instance to avoid\n@@ -251,15 +260,32 @@ class ForwardManyToOneDescriptor:\n             for lh_field, rh_field in self.field.related_fields:\n                 setattr(instance, lh_field.attname, None)\n \n+\n         # Set the values of the related field.\n         else:\n-            for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+            # Check if we're assigning an unsaved related object with empty primary key\n+            needs_deferred_assignment = False\n+            if hasattr(value, '_state') and not value._state.db:\n+                # Object is unsaved, check if primary key fields are empty\n+                for lh_field, rh_field in self.field.related_fields:\n+                    pk_value = getattr(value, rh_field.attname)\n+                    if pk_value == '' or pk_value is None:\n+                        needs_deferred_assignment = True\n+                        break\n+            \n+            if needs_deferred_assignment:\n+                # For unsaved objects with empty PKs, set foreign key to None\n+                # and rely on the cached object for dynamic resolution\n+                for lh_field, rh_field in self.field.related_fields:\n+                    setattr(instance, lh_field.attname, None)\n+            else:\n+                # Normal case: set foreign key values from related object\n+                for lh_field, rh_field in self.field.related_fields:\n+                    setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n \n         # Set the related instance cache used by __get__ to avoid an SQL query\n         # when accessing the attribute we just set.\n         self.field.set_cached_value(instance, value)\n-\n         # If this is a one-to-one relation, set the reverse accessor cache on\n         # the related object to the current instance to avoid an extra SQL\n         # query if it's accessed later on.\n",
    "variant_6": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 899ae8efe8..912c91492f 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -643,12 +643,23 @@ class ForeignObject(RelatedField):\n     def foreign_related_fields(self):\n         return tuple(rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field)\n \n-    def get_local_related_value(self, instance):\n-        return self.get_instance_value_for_fields(instance, self.local_related_fields)\n+\n+def get_local_related_value(self, instance):\n+    # Check if there's a cached related object that might have a more current primary key\n+    cached_obj = getattr(instance, self.get_cache_name(), None)\n+    if cached_obj is not None and hasattr(cached_obj, '_state') and not cached_obj._state.adding:\n+        # If the cached object has been saved and has a primary key, use its current value\n+        cached_values = self.get_instance_value_for_fields(cached_obj, self.foreign_related_fields)\n+        if all(val is not None and val != '' for val in cached_values):\n+            return cached_values\n+    \n+    return self.get_instance_value_for_fields(instance, self.local_related_fields)\n \n     def get_foreign_related_value(self, instance):\n         return self.get_instance_value_for_fields(instance, self.foreign_related_fields)\n \n+    @staticmethod\n+\n     @staticmethod\n     def get_instance_value_for_fields(instance, fields):\n         ret = []\n@@ -664,6 +675,23 @@ class ForeignObject(RelatedField):\n                         possible_parent_link.model._meta.abstract):\n                     ret.append(instance.pk)\n                     continue\n+            \n+            # For foreign key fields, check if there's a cached related object\n+            # with a valid primary key that differs from the stored value\n+            if hasattr(field, 'remote_field') and field.remote_field:\n+                stored_value = getattr(instance, field.attname)\n+                cache_name = field.get_cache_name()\n+                \n+                # Check if there's a cached related object\n+                if hasattr(instance, '_state') and cache_name in instance.__dict__:\n+                    related_obj = instance.__dict__[cache_name]\n+                    if related_obj is not None and hasattr(related_obj, 'pk') and related_obj.pk:\n+                        # Use the related object's current primary key if it's valid\n+                        # and different from the stored value (handles unsaved object case)\n+                        if not stored_value or stored_value != related_obj.pk:\n+                            ret.append(related_obj.pk)\n+                            continue\n+            \n             ret.append(getattr(instance, field.attname))\n         return tuple(ret)\n \ndiff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex 872a4c98dc..37586f986a 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -169,6 +169,7 @@ class ForwardManyToOneDescriptor:\n         # The related instance is loaded from the database and then cached\n         # by the field on the model instance state. It can also be pre-cached\n         # by the reverse accessor (ReverseOneToOneDescriptor).\n+\n         try:\n             rel_obj = self.field.get_cached_value(instance)\n         except KeyError:\n@@ -183,14 +184,25 @@ class ForwardManyToOneDescriptor:\n                 rel_obj = self.field.get_cached_value(ancestor, default=None)\n             else:\n                 rel_obj = None\n+\n             if rel_obj is None and has_value:\n-                rel_obj = self.get_object(instance)\n-                remote_field = self.field.remote_field\n-                # If this is a one-to-one relation, set the reverse accessor\n-                # cache on the related object to the current instance to avoid\n-                # an extra SQL query if it's accessed later on.\n-                if not remote_field.multiple:\n-                    remote_field.set_cached_value(rel_obj, instance)\n+                # Check if we have a cached related object that should be used instead\n+                # of doing a database lookup with potentially stale foreign key values\n+                cached_obj = self.field.get_cached_value(instance, default=None)\n+                if cached_obj is not None:\n+                    # Use the cached object if it exists\n+                    rel_obj = cached_obj\n+                else:\n+                    # Fall back to database lookup\n+                    rel_obj = self.get_object(instance)\n+                \n+                if rel_obj is not None:\n+                    remote_field = self.field.remote_field\n+                    # If this is a one-to-one relation, set the reverse accessor\n+                    # cache on the related object to the current instance to avoid\n+                    # an extra SQL query if it's accessed later on.\n+                    if not remote_field.multiple:\n+                        remote_field.set_cached_value(rel_obj, instance)\n             self.field.set_cached_value(instance, rel_obj)\n \n         if rel_obj is None and not self.field.null:\n@@ -251,15 +263,32 @@ class ForwardManyToOneDescriptor:\n             for lh_field, rh_field in self.field.related_fields:\n                 setattr(instance, lh_field.attname, None)\n \n+\n         # Set the values of the related field.\n         else:\n-            for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+            # Check if we have an unsaved related object with unset primary key\n+            has_deferred_pk = False\n+            if hasattr(value, '_state') and value._state.adding:\n+                # Check if any of the related fields have empty/None values\n+                for lh_field, rh_field in self.field.related_fields:\n+                    rh_value = getattr(value, rh_field.attname)\n+                    if not rh_value:  # Empty string, None, or other falsy values\n+                        has_deferred_pk = True\n+                        break\n+            \n+            if has_deferred_pk:\n+                # For unsaved objects with unset primary keys, store None temporarily\n+                # The actual value will be resolved dynamically when needed\n+                for lh_field, rh_field in self.field.related_fields:\n+                    setattr(instance, lh_field.attname, None)\n+            else:\n+                # Normal case: set the foreign key values immediately\n+                for lh_field, rh_field in self.field.related_fields:\n+                    setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n \n         # Set the related instance cache used by __get__ to avoid an SQL query\n         # when accessing the attribute we just set.\n         self.field.set_cached_value(instance, value)\n-\n         # If this is a one-to-one relation, set the reverse accessor cache on\n         # the related object to the current instance to avoid an extra SQL\n         # query if it's accessed later on.\n",
    "variant_7": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 899ae8efe8..c22123b83e 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -643,12 +643,38 @@ class ForeignObject(RelatedField):\n     def foreign_related_fields(self):\n         return tuple(rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field)\n \n+\n     def get_local_related_value(self, instance):\n+        # Check if there's a cached related object with a more current primary key\n+        if hasattr(instance, '_state') and not instance._state.adding:\n+            for field in self.local_related_fields:\n+                if hasattr(field, 'remote_field') and field.remote_field:\n+                    cache_name = field.get_cache_name()\n+                    if hasattr(instance, cache_name):\n+                        cached_obj = getattr(instance, cache_name, None)\n+                        if cached_obj is not None:\n+                            # Get the current primary key from the cached object\n+                            remote_field = field.remote_field.get_related_field()\n+                            cached_pk = getattr(cached_obj, remote_field.attname)\n+                            stored_pk = getattr(instance, field.attname)\n+                            # If cached object has a valid PK that differs from stored value, use it\n+                            if cached_pk and cached_pk != stored_pk:\n+                                # Return updated values with the current cached object's PK\n+                                ret = []\n+                                for lhs_field in self.local_related_fields:\n+                                    if lhs_field == field:\n+                                        ret.append(cached_pk)\n+                                    else:\n+                                        ret.append(getattr(instance, lhs_field.attname))\n+                                return tuple(ret)\n+        \n         return self.get_instance_value_for_fields(instance, self.local_related_fields)\n \n     def get_foreign_related_value(self, instance):\n         return self.get_instance_value_for_fields(instance, self.foreign_related_fields)\n \n+    @staticmethod\n+\n     @staticmethod\n     def get_instance_value_for_fields(instance, fields):\n         ret = []\n@@ -664,6 +690,26 @@ class ForeignObject(RelatedField):\n                         possible_parent_link.model._meta.abstract):\n                     ret.append(instance.pk)\n                     continue\n+            \n+            # For foreign key fields, check if there's a cached related object\n+            # with a different primary key value than what's stored\n+            if hasattr(field, 'related_model'):\n+                stored_value = getattr(instance, field.attname)\n+                cache_name = field.get_cache_name()\n+                \n+                # Check if there's a cached related object\n+                if hasattr(instance, '_state') and hasattr(instance, cache_name):\n+                    try:\n+                        cached_obj = getattr(instance, cache_name)\n+                        if cached_obj is not None:\n+                            cached_pk = cached_obj.pk\n+                            # If cached object has a different pk than stored value, use the cached pk\n+                            if cached_pk is not None and cached_pk != stored_value:\n+                                ret.append(cached_pk)\n+                                continue\n+                    except AttributeError:\n+                        pass\n+            \n             ret.append(getattr(instance, field.attname))\n         return tuple(ret)\n \ndiff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex 872a4c98dc..7558b6603f 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -169,6 +169,7 @@ class ForwardManyToOneDescriptor:\n         # The related instance is loaded from the database and then cached\n         # by the field on the model instance state. It can also be pre-cached\n         # by the reverse accessor (ReverseOneToOneDescriptor).\n+\n         try:\n             rel_obj = self.field.get_cached_value(instance)\n         except KeyError:\n@@ -183,8 +184,16 @@ class ForwardManyToOneDescriptor:\n                 rel_obj = self.field.get_cached_value(ancestor, default=None)\n             else:\n                 rel_obj = None\n+\n             if rel_obj is None and has_value:\n-                rel_obj = self.get_object(instance)\n+                # Check if there's a cached related object that should be used instead\n+                # of fetching from database with potentially stale foreign key values\n+                cached_obj = self.field.get_cached_value(instance, default=None)\n+                if cached_obj is not None:\n+                    # Use the cached object if it exists\n+                    rel_obj = cached_obj\n+                else:\n+                    rel_obj = self.get_object(instance)\n                 remote_field = self.field.remote_field\n                 # If this is a one-to-one relation, set the reverse accessor\n                 # cache on the related object to the current instance to avoid\n@@ -251,15 +260,22 @@ class ForwardManyToOneDescriptor:\n             for lh_field, rh_field in self.field.related_fields:\n                 setattr(instance, lh_field.attname, None)\n \n+\n         # Set the values of the related field.\n         else:\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+                # Check if the related object is unsaved and has an empty/None primary key\n+                rh_value = getattr(value, rh_field.attname)\n+                if (hasattr(value, '_state') and value._state.adding and \n+                    (rh_value == '' or rh_value is None)):\n+                    # For unsaved objects with empty primary keys, store None to defer resolution\n+                    setattr(instance, lh_field.attname, None)\n+                else:\n+                    setattr(instance, lh_field.attname, rh_value)\n \n         # Set the related instance cache used by __get__ to avoid an SQL query\n         # when accessing the attribute we just set.\n         self.field.set_cached_value(instance, value)\n-\n         # If this is a one-to-one relation, set the reverse accessor cache on\n         # the related object to the current instance to avoid an extra SQL\n         # query if it's accessed later on.\n",
    "variant_8": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 899ae8efe8..0d263be814 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -643,29 +643,79 @@ class ForeignObject(RelatedField):\n     def foreign_related_fields(self):\n         return tuple(rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field)\n \n-    def get_local_related_value(self, instance):\n+\n+def get_local_related_value(self, instance):\n+    # Check if there's a cached related object that might have a more current primary key\n+    if hasattr(instance, '_state') and not instance._state.adding:\n+        # For saved instances, use the stored foreign key value\n         return self.get_instance_value_for_fields(instance, self.local_related_fields)\n+    \n+    # For unsaved instances, check if we have a cached related object with a valid primary key\n+    cache_name = self.get_cache_name()\n+    if hasattr(instance, '_' + cache_name + '_cache'):\n+        cached_obj = getattr(instance, '_' + cache_name + '_cache', None)\n+        if cached_obj is not None:\n+            # Get the current primary key value from the cached object\n+            cached_pk_values = []\n+            for local_field, remote_field in self.related_fields:\n+                if remote_field:\n+                    cached_value = getattr(cached_obj, remote_field.attname, None)\n+                    # If the cached object has a valid primary key, use it\n+                    if cached_value not in (None, ''):\n+                        cached_pk_values.append(cached_value)\n+                    else:\n+                        # Fall back to stored value if cached object's PK is still empty\n+                        cached_pk_values.append(getattr(instance, local_field.attname, None))\n+                else:\n+                    cached_pk_values.append(getattr(instance, local_field.attname, None))\n+            \n+            # If we got valid values from cache, return them as a tuple\n+            if len(cached_pk_values) == len(self.local_related_fields):\n+                return tuple(cached_pk_values)\n+    \n+    # Fall back to the standard implementation\n+    return self.get_instance_value_for_fields(instance, self.local_related_fields)\n \n     def get_foreign_related_value(self, instance):\n         return self.get_instance_value_for_fields(instance, self.foreign_related_fields)\n \n     @staticmethod\n-    def get_instance_value_for_fields(instance, fields):\n-        ret = []\n-        opts = instance._meta\n-        for field in fields:\n-            # Gotcha: in some cases (like fixture loading) a model can have\n-            # different values in parent_ptr_id and parent's id. So, use\n-            # instance.pk (that is, parent_ptr_id) when asked for instance.id.\n-            if field.primary_key:\n-                possible_parent_link = opts.get_ancestor_link(field.model)\n-                if (not possible_parent_link or\n-                        possible_parent_link.primary_key or\n-                        possible_parent_link.model._meta.abstract):\n-                    ret.append(instance.pk)\n-                    continue\n-            ret.append(getattr(instance, field.attname))\n-        return tuple(ret)\n+\n+@staticmethod\n+def get_instance_value_for_fields(instance, fields):\n+    ret = []\n+    opts = instance._meta\n+    for field in fields:\n+        # Gotcha: in some cases (like fixture loading) a model can have\n+        # different values in parent_ptr_id and parent's id. So, use\n+        # instance.pk (that is, parent_ptr_id) when asked for instance.id.\n+        if field.primary_key:\n+            possible_parent_link = opts.get_ancestor_link(field.model)\n+            if (not possible_parent_link or\n+                    possible_parent_link.primary_key or\n+                    possible_parent_link.model._meta.abstract):\n+                ret.append(instance.pk)\n+                continue\n+        \n+        # For foreign key fields, check if there's a cached related object\n+        # with a different primary key value than what's stored\n+        if hasattr(field, 'related_model') and hasattr(instance, field.get_cache_name()):\n+            try:\n+                cached_obj = getattr(instance, field.get_cache_name())\n+                if cached_obj is not None:\n+                    # Get the current primary key of the cached object\n+                    cached_pk = cached_obj.pk\n+                    stored_value = getattr(instance, field.attname)\n+                    # If cached object has a primary key and it differs from stored value,\n+                    # use the cached object's primary key\n+                    if cached_pk is not None and cached_pk != stored_value:\n+                        ret.append(cached_pk)\n+                        continue\n+            except AttributeError:\n+                pass\n+        \n+        ret.append(getattr(instance, field.attname))\n+    return tuple(ret)\n \n     def get_attname_column(self):\n         attname, column = super().get_attname_column()\ndiff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex 872a4c98dc..022c150652 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -169,6 +169,7 @@ class ForwardManyToOneDescriptor:\n         # The related instance is loaded from the database and then cached\n         # by the field on the model instance state. It can also be pre-cached\n         # by the reverse accessor (ReverseOneToOneDescriptor).\n+\n         try:\n             rel_obj = self.field.get_cached_value(instance)\n         except KeyError:\n@@ -183,8 +184,23 @@ class ForwardManyToOneDescriptor:\n                 rel_obj = self.field.get_cached_value(ancestor, default=None)\n             else:\n                 rel_obj = None\n+\n             if rel_obj is None and has_value:\n-                rel_obj = self.get_object(instance)\n+                # Check if we have a cached related object that should take precedence\n+                # over the stored foreign key value (handles case where PK was set after FK assignment)\n+                cached_obj = None\n+                try:\n+                    cached_obj = self.field.get_cached_value(instance, default=None)\n+                except KeyError:\n+                    pass\n+                \n+                if cached_obj is not None:\n+                    # Use the cached object instead of doing a database lookup\n+                    rel_obj = cached_obj\n+                else:\n+                    # Proceed with normal database lookup\n+                    rel_obj = self.get_object(instance)\n+                    \n                 remote_field = self.field.remote_field\n                 # If this is a one-to-one relation, set the reverse accessor\n                 # cache on the related object to the current instance to avoid\n@@ -251,15 +267,34 @@ class ForwardManyToOneDescriptor:\n             for lh_field, rh_field in self.field.related_fields:\n                 setattr(instance, lh_field.attname, None)\n \n+\n         # Set the values of the related field.\n         else:\n-            for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+            # Check if the related object is unsaved and has empty primary key values\n+            # If so, we need to defer the foreign key assignment to avoid capturing\n+            # empty string values that won't be updated when the primary key is later set\n+            should_defer = False\n+            if hasattr(value, '_state') and value._state.adding:\n+                # Check if any of the primary key fields are empty/None\n+                for lh_field, rh_field in self.field.related_fields:\n+                    pk_value = getattr(value, rh_field.attname, None)\n+                    if pk_value in (None, ''):\n+                        should_defer = True\n+                        break\n+            \n+            if should_defer:\n+                # For unsaved objects with empty primary keys, store a special marker\n+                # that indicates the foreign key should be resolved dynamically\n+                for lh_field, rh_field in self.field.related_fields:\n+                    setattr(instance, lh_field.attname, None)\n+            else:\n+                # Normal case: capture the primary key values immediately\n+                for lh_field, rh_field in self.field.related_fields:\n+                    setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n \n         # Set the related instance cache used by __get__ to avoid an SQL query\n         # when accessing the attribute we just set.\n         self.field.set_cached_value(instance, value)\n-\n         # If this is a one-to-one relation, set the reverse accessor cache on\n         # the related object to the current instance to avoid an extra SQL\n         # query if it's accessed later on.\n"
  }
}