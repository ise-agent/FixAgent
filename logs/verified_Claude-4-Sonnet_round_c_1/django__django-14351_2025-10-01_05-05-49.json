{
  "zero_patches": {
    "Location 1 (/root/hy/projects/django/django/db/models/sql/compiler.py lines 697-716)": "\n        result = []\n        if opts is None:\n            opts = self.query.get_meta()\n        only_load = self.deferred_to_columns()\n        start_alias = start_alias or self.query.get_initial_alias()\n        # The 'seen_models' is used to optimize checking the needed parent\n        # alias for a given field. This also includes None -> start_alias to\n        # be used by local fields.\n        seen_models = {None: start_alias}\n\n        # For subqueries used in __in lookups, only select the primary key\n        if getattr(self.query, 'subquery', False) and hasattr(self.query, '_for_in_lookup'):\n            pk_field = opts.pk\n            if pk_field.model._meta.concrete_model == opts.model:\n                model = None\n            else:\n                model = pk_field.model._meta.concrete_model\n            alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n            column = pk_field.get_col(alias)\n            result.append(column)\n            return result\n\n        for field in opts.concrete_fields:\n            model = field.model._meta.concrete_model\n            # A proxy model will have a different model and concrete_model. We\n            # will assign None if the field belongs to this model.\n            if model == opts.model:\n                model = None\n            if from_parent and model is not None and issubclass(\n                    from_parent._meta.concrete_model, model._meta.concrete_model):\n                # Avoid loading data for already loaded parents.\n                # We end up here in the case select_related() resolution\n                # proceeds from parent model to child model. In that case the\n                # parent model data is already present in the SELECT clause,\n                # and we want to avoid reloading the same data again.\n                continue\n            if field.model in only_load and field.attname not in only_load[field.model]:\n                continue\n            alias = self.query.join_parent_model(opts, model, start_alias,\n                                                 seen_models)\n            column = field.get_col(alias)\n            result.append(column)\n",
    "Location 2 (/root/hy/projects/django/django/db/models/sql/compiler.py lines 687-696)": "\n        result = []\n        if opts is None:\n            opts = self.query.get_meta()\n        only_load = self.deferred_to_columns()\n        start_alias = start_alias or self.query.get_initial_alias()\n        # The 'seen_models' is used to optimize checking the needed parent\n        # alias for a given field. This also includes None -> start_alias to\n        # be used by local fields.\n        seen_models = {None: start_alias}\n        \n        # For subqueries used in __in lookups, only select the primary key\n        # to avoid \"subquery must return only one column\" errors\n        is_subquery_for_in = (\n            self.query.subquery and \n            hasattr(self.query, 'default_cols') and \n            self.query.default_cols\n        )\n",
    "Location 3 (/root/hy/projects/django/django/db/models/fields/related_lookups.py lines 89-100)": "\n            if (not getattr(self.rhs, 'has_select_fields', True) and\n                    not getattr(self.lhs.field.target_field, 'primary_key', False)):\n                self.rhs.clear_select_clause()\n                # Check if this is a subquery that needs field limitation\n                if (getattr(self.rhs, 'subquery', False) and \n                        getattr(self.rhs, 'default_cols', False)):\n                    # Force single field selection for subqueries in __in lookups\n                    if (getattr(self.lhs.output_field, 'primary_key', False) and\n                            self.lhs.output_field.model == self.rhs.model):\n                        # A case like Restaurant.objects.filter(place__in=restaurant_qs),\n                        # where place is a OneToOneField and the primary key of\n                        # Restaurant.\n                        target_field = self.lhs.field.name\n                    else:\n                        target_field = self.lhs.field.target_field.name\n                    self.rhs.add_fields([target_field], True)\n                elif (getattr(self.lhs.output_field, 'primary_key', False) and\n                        self.lhs.output_field.model == self.rhs.model):\n                    # A case like Restaurant.objects.filter(place__in=restaurant_qs),\n                    # where place is a OneToOneField and the primary key of\n                    # Restaurant.\n                    target_field = self.lhs.field.name\n                    self.rhs.add_fields([target_field], True)\n                else:\n                    target_field = self.lhs.field.target_field.name\n                    self.rhs.add_fields([target_field], True)\n",
    "Location 4 (/root/hy/projects/django/django/db/models/sql/compiler.py lines 675-686)": "\n    def get_default_columns(self, start_alias=None, opts=None, from_parent=None):\n        \"\"\"\n        Compute the default columns for selecting every field in the base\n        model. Will sometimes be called to pull in related models (e.g. via\n        select_related), in which case \"opts\" and \"start_alias\" will be given\n        to provide a starting point for the traversal.\n\n        Return a list of strings, quoted appropriately for use in SQL\n        directly, as well as a set of aliases used in the select statement (if\n        'as_pairs' is True, return a list of (alias, col_name) pairs instead\n        of strings as the first component and None as the second component).\n        \n        For subqueries used in __in lookups, only return the primary key column\n        to avoid PostgreSQL \"subquery must return only one column\" errors.\n        \"\"\"\n        result = []\n        if opts is None:\n            opts = self.query.get_meta()\n        \n        # Check if this is a subquery that should only return the primary key\n        is_subquery_for_in_lookup = (\n            getattr(self.query, 'subquery', False) and\n            hasattr(self.query, 'default_cols') and\n            self.query.default_cols and\n            not getattr(self.query, 'select_fields', None)\n        )\n        \n        only_load = self.deferred_to_columns()\n        start_alias = start_alias or self.query.get_initial_alias()\n        # The 'seen_models' is used to optimize checking the needed parent\n        # alias for a given field. This also includes None -> start_alias to\n        # be used by local fields.\n        seen_models = {None: start_alias}\n",
    "Location 5 (/root/hy/projects/django/django/db/models/sql/compiler.py lines 688-690)": "\n        if opts is None:\n            opts = self.query.get_meta()\n        \n        # For subqueries used in __in lookups, we should only select the primary key\n        # to avoid PostgreSQL's \"subquery must return only one column\" error\n        if self.query.subquery and hasattr(self.query, 'default_cols') and self.query.default_cols:\n            # Check if this is likely an __in lookup subquery by examining the query context\n            only_load = frozenset([opts.pk.get_col(start_alias or self.query.get_initial_alias())])\n        else:\n            only_load = self.deferred_to_columns()\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/django/django/db/models/sql/compiler.py lines 697-716)": [
      "\n    def get_default_columns(self, start_alias=None, opts=None, from_parent=None):\n        \"\"\"\n        Compute the default columns for selecting every field in the base\n        model. Will sometimes be called to pull in related models (e.g. via\n        select_related), in which case \"opts\" and \"start_alias\" will be given\n        to provide a starting point for the traversal.\n\n        Return a list of strings, quoted appropriately for use in SQL\n        directly, as well as a list of aliases used in the select statement (if\n        'as_pairs' is True, return a list of (alias, col_name) pairs instead\n        of strings as the first component and None as the second component).\n        \"\"\"\n        result = []\n        if opts is None:\n            opts = self.query.get_meta()\n        only_load = self.deferred_to_columns()\n        start_alias = start_alias or self.query.get_initial_alias()\n        # The 'seen_models' is used to optimize checking the needed parent\n        # alias for a given field. This also includes None -> start_alias to\n        # be used by local fields.\n        seen_models = {None: start_alias}\n\n        # For subqueries used in __in lookups, only select the primary key\n        # to avoid \"subquery must return only one column\" error\n        if (self.query.subquery and \n            hasattr(self.query, 'default_cols') and self.query.default_cols):\n            # Only include the primary key field for subqueries\n            pk_field = opts.pk\n            if pk_field.model._meta.concrete_model == opts.model:\n                model = None\n            else:\n                model = pk_field.model._meta.concrete_model\n            \n            if not (from_parent and model is not None and issubclass(\n                    from_parent._meta.concrete_model, model._meta.concrete_model)):\n                if not (pk_field.model in only_load and pk_field.attname not in only_load[pk_field.model]):\n                    alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n                    column = pk_field.get_col(alias)\n                    result.append(column)\n            return result\n\n        for field in opts.concrete_fields:\n            model = field.model._meta.concrete_model\n            # A proxy model will have a different model and concrete_model. We\n            # will assign None if the field belongs to this model.\n            if model == opts.model:\n                model = None\n            if from_parent and model is not None and issubclass(\n                    from_parent._meta.concrete_model, model._meta.concrete_model):\n                # Avoid loading data for already loaded parents.\n                # We end up here in the case select_related() resolution\n                # proceeds from parent model to child model. In that case the\n                # parent model data is already present in the SELECT clause,\n                # and we want to avoid reloading the same data again.\n                continue\n            if field.model in only_load and field.attname not in only_load[field.model]:\n                continue\n            alias = self.query.join_parent_model(opts, model, start_alias,\n                                                 seen_models)\n            column = field.get_col(alias)\n            result.append(column)\n        return result\n",
      "\n        result = []\n        if opts is None:\n            opts = self.query.get_meta()\n        only_load = self.deferred_to_columns()\n        start_alias = start_alias or self.query.get_initial_alias()\n        # The 'seen_models' is used to optimize checking the needed parent\n        # alias for a given field. This also includes None -> start_alias to\n        # be used by local fields.\n        seen_models = {None: start_alias}\n\n        # For subqueries used in __in lookups, only select the primary key\n        # to avoid PostgreSQL's \"subquery must return only one column\" error\n        if self.query.subquery and hasattr(self.query, 'default_cols') and self.query.default_cols:\n            # Only include the primary key field for subqueries\n            pk_field = opts.pk\n            if pk_field.model == opts.model:\n                model = None\n            else:\n                model = pk_field.model._meta.concrete_model\n            \n            alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n            column = pk_field.get_col(alias)\n            result.append(column)\n            return result\n\n        for field in opts.concrete_fields:\n            model = field.model._meta.concrete_model\n            # A proxy model will have a different model and concrete_model. We\n            # will assign None if the field belongs to this model.\n            if model == opts.model:\n                model = None\n            if from_parent and model is not None and issubclass(\n                    from_parent._meta.concrete_model, model._meta.concrete_model):\n                # Avoid loading data for already loaded parents.\n                # We end up here in the case select_related() resolution\n                # proceeds from parent model to child model. In that case the\n                # parent model data is already present in the SELECT clause,\n                # and we want to avoid reloading the same data again.\n                continue\n            if field.model in only_load and field.attname not in only_load[field.model]:\n                continue\n            alias = self.query.join_parent_model(opts, model, start_alias,\n                                                 seen_models)\n            column = field.get_col(alias)\n            result.append(column)\n",
      "\n    def get_default_columns(self, start_alias=None, opts=None, from_parent=None):\n        \"\"\"\n        Compute the default columns for SELECT.\n        \"\"\"\n        result = []\n        if opts is None:\n            opts = self.query.get_meta()\n        only_load = self.deferred_to_columns()\n        start_alias = start_alias or self.query.get_initial_alias()\n        # The 'seen_models' is used to optimize checking the needed parent\n        # alias for a given field. This also includes None -> start_alias to\n        # be used by local fields.\n        seen_models = {None: start_alias}\n\n        # For subqueries used in __in lookups, only select the primary key\n        if getattr(self.query, 'subquery', False) and self.query.default_cols:\n            # Check if this is likely an __in subquery by looking for single model selection\n            if not hasattr(self.query, '_force_all_fields'):\n                pk_field = opts.pk\n                if pk_field.model == opts.model:\n                    model = None\n                else:\n                    model = pk_field.model._meta.concrete_model\n                alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n                column = pk_field.get_col(alias)\n                result.append(column)\n                return result\n\n        for field in opts.concrete_fields:\n            model = field.model._meta.concrete_model\n            # A proxy model will have a different model and concrete_model. We\n            # will assign None if the field belongs to this model.\n            if model == opts.model:\n                model = None\n            if from_parent and model is not None and issubclass(\n                    from_parent._meta.concrete_model, model._meta.concrete_model):\n                # Avoid loading data for already loaded parents.\n                # We end up here in the case select_related() resolution\n                # proceeds from parent model to child model. In that case the\n                # parent model data is already present in the SELECT clause,\n                # and we want to avoid reloading the same data again.\n                continue\n            if field.model in only_load and field.attname not in only_load[field.model]:\n                continue\n            alias = self.query.join_parent_model(opts, model, start_alias,\n                                                 seen_models)\n            column = field.get_col(alias)\n            result.append(column)\n        return result\n",
      "\n        result = []\n        if opts is None:\n            opts = self.query.get_meta()\n        only_load = self.deferred_to_columns()\n        start_alias = start_alias or self.query.get_initial_alias()\n        # The 'seen_models' is used to optimize checking the needed parent\n        # alias for a given field. This also includes None -> start_alias to\n        # be used by local fields.\n        seen_models = {None: start_alias}\n\n        # For subqueries used in __in lookups, only select the primary key\n        # to avoid PostgreSQL's \"subquery must return only one column\" error\n        if getattr(self.query, 'subquery', False) and not hasattr(self.query, 'has_select_fields'):\n            pk_field = opts.pk\n            model = pk_field.model._meta.concrete_model\n            if model == opts.model:\n                model = None\n            alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n            column = pk_field.get_col(alias)\n            result.append(column)\n            return result\n\n        for field in opts.concrete_fields:\n            model = field.model._meta.concrete_model\n            # A proxy model will have a different model and concrete_model. We\n            # will assign None if the field belongs to this model.\n            if model == opts.model:\n                model = None\n            if from_parent and model is not None and issubclass(\n                    from_parent._meta.concrete_model, model._meta.concrete_model):\n                # Avoid loading data for already loaded parents.\n                # We end up here in the case select_related() resolution\n                # proceeds from parent model to child model. In that case the\n                # parent model data is already present in the SELECT clause,\n                # and we want to avoid reloading the same data again.\n                continue\n            if field.model in only_load and field.attname not in only_load[field.model]:\n                continue\n            alias = self.query.join_parent_model(opts, model, start_alias,\n                                                 seen_models)\n            column = field.get_col(alias)\n            result.append(column)\n",
      "\n    def get_default_columns(self, start_alias=None, opts=None, from_parent=None):\n        \"\"\"\n        Compute the default columns for selecting every field in the base\n        model. Will sometimes be called to pull in related models (e.g. via\n        select_related), in which case \"opts\" and \"start_alias\" will be given\n        to provide a starting point for the traversal.\n\n        Return a list of strings, quoted appropriately for use in SQL\n        directly, as well as a list of extras to be added to the select.\n\n        reduce_unnecessary_sql() will remove any unused columns.\n        \"\"\"\n        result = []\n        if opts is None:\n            opts = self.query.get_meta()\n        only_load = self.deferred_to_columns()\n        start_alias = start_alias or self.query.get_initial_alias()\n        # The 'seen_models' is used to optimize checking the needed parent\n        # alias for a given field. This also includes None -> start_alias to\n        # be used by local fields.\n        seen_models = {None: start_alias}\n\n        # For subqueries used in __in lookups, we only need the primary key\n        # to avoid \"subquery must return only one column\" errors\n        if (self.query.subquery and \n            hasattr(self.query, 'default_cols') and \n            self.query.default_cols):\n            # Only select the primary key field for subqueries\n            pk_field = opts.pk\n            if pk_field.model == opts.model:\n                model = None\n            else:\n                model = pk_field.model._meta.concrete_model\n            \n            alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n            column = pk_field.get_col(alias)\n            result.append(column)\n            return result\n\n        for field in opts.concrete_fields:\n            model = field.model._meta.concrete_model\n            # A proxy model will have a different model and concrete_model. We\n            # will assign None if the field belongs to this model.\n            if model == opts.model:\n                model = None\n            if from_parent and model is not None and issubclass(\n                    from_parent._meta.concrete_model, model._meta.concrete_model):\n                # Avoid loading data for already loaded parents.\n                # We end up here in the case select_related() resolution\n                # proceeds from parent model to child model. In that case the\n                # parent model data is already present in the SELECT clause,\n                # and we want to avoid reloading the same data again.\n                continue\n            if field.model in only_load and field.attname not in only_load[field.model]:\n                continue\n            alias = self.query.join_parent_model(opts, model, start_alias,\n                                                 seen_models)\n            column = field.get_col(alias)\n            result.append(column)\n        return result\n",
      "\n    def get_default_columns(self, start_alias=None, opts=None, from_parent=None):\n        \"\"\"\n        Compute the default columns for selecting every field in the base\n        model. Will sometimes be called to pull in related models (e.g. via\n        select_related), in which case \"opts\" and \"start_alias\" will be given\n        to provide a starting point for the traversal.\n\n        Return a list of strings, quoted appropriately for use in SQL\n        directly, as well as a list of aliases used in the select statement (if\n        'as_pairs' is True, return a list of (alias, col_name) pairs instead\n        of strings as the first component and None as the second component).\n        \"\"\"\n        result = []\n        if opts is None:\n            opts = self.query.get_meta()\n        only_load = self.deferred_to_columns()\n        start_alias = start_alias or self.query.get_initial_alias()\n        # The 'seen_models' is used to optimize checking the needed parent\n        # alias for a given field. This also includes None -> start_alias to\n        # be used by local fields.\n        seen_models = {None: start_alias}\n\n        # For subqueries used in __in lookups, only select the primary key\n        if (self.query.subquery and \n            hasattr(self.query, 'default_cols') and \n            self.query.default_cols and\n            not hasattr(self.query, '_forced_pk_only')):\n            # Only include primary key field for subqueries\n            pk_field = opts.pk\n            if pk_field.model._meta.concrete_model == opts.model:\n                model = None\n            else:\n                model = pk_field.model._meta.concrete_model\n            \n            if not (from_parent and model is not None and issubclass(\n                    from_parent._meta.concrete_model, model._meta.concrete_model)):\n                if not (pk_field.model in only_load and pk_field.attname not in only_load[pk_field.model]):\n                    alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n                    column = pk_field.get_col(alias)\n                    result.append(column)\n            return result\n\n        for field in opts.concrete_fields:\n            model = field.model._meta.concrete_model\n            # A proxy model will have a different model and concrete_model. We\n            # will assign None if the field belongs to this model.\n            if model == opts.model:\n                model = None\n            if from_parent and model is not None and issubclass(\n                    from_parent._meta.concrete_model, model._meta.concrete_model):\n                # Avoid loading data for already loaded parents.\n                # We end up here in the case select_related() resolution\n                # proceeds from parent model to child model. In that case the\n                # parent model data is already present in the SELECT clause,\n                # and we want to avoid reloading the same data again.\n                continue\n            if field.model in only_load and field.attname not in only_load[field.model]:\n                continue\n            alias = self.query.join_parent_model(opts, model, start_alias,\n                                                 seen_models)\n            column = field.get_col(alias)\n            result.append(column)\n        return result\n",
      "\n    def get_default_columns(self, start_alias=None, opts=None, from_parent=None):\n        \"\"\"\n        Compute the default columns for SELECT.\n        \"\"\"\n        result = []\n        if opts is None:\n            opts = self.query.get_meta()\n        only_load = self.deferred_to_columns()\n        start_alias = start_alias or self.query.get_initial_alias()\n        # The 'seen_models' is used to optimize checking the needed parent\n        # alias for a given field. This also includes None -> start_alias to\n        # be used by local fields.\n        seen_models = {None: start_alias}\n\n        # For subqueries used in __in lookups, only select the primary key\n        # to avoid PostgreSQL's \"subquery must return only one column\" error\n        if getattr(self.query, 'subquery', False) and not hasattr(self.query, 'annotation_select'):\n            pk_field = opts.pk\n            if pk_field.model == opts.model:\n                model = None\n            else:\n                model = pk_field.model._meta.concrete_model\n            alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n            column = pk_field.get_col(alias)\n            result.append(column)\n            return result\n\n        for field in opts.concrete_fields:\n            model = field.model._meta.concrete_model\n            # A proxy model will have a different model and concrete_model. We\n            # will assign None if the field belongs to this model.\n            if model == opts.model:\n                model = None\n            if from_parent and model is not None and issubclass(\n                    from_parent._meta.concrete_model, model._meta.concrete_model):\n                # Avoid loading data for already loaded parents.\n                # We end up here in the case select_related() resolution\n                # proceeds from parent model to child model. In that case the\n                # parent model data is already present in the SELECT clause,\n                # and we want to avoid reloading the same data again.\n                continue\n            if field.model in only_load and field.attname not in only_load[field.model]:\n                continue\n            alias = self.query.join_parent_model(opts, model, start_alias,\n                                                 seen_models)\n            column = field.get_col(alias)\n            result.append(column)\n",
      "\n        result = []\n        if opts is None:\n            opts = self.query.get_meta()\n        only_load = self.deferred_to_columns()\n        start_alias = start_alias or self.query.get_initial_alias()\n        # The 'seen_models' is used to optimize checking the needed parent\n        # alias for a given field. This also includes None -> start_alias to\n        # be used by local fields.\n        seen_models = {None: start_alias}\n\n        # For subqueries used in __in lookups, only select the primary key\n        # to avoid \"subquery must return only one column\" errors\n        if (self.query.subquery and \n            hasattr(self.query, 'default_cols') and \n            self.query.default_cols and\n            len(opts.concrete_fields) > 1):\n            # Only include the primary key field for subqueries\n            pk_field = opts.pk\n            if from_parent and pk_field.model != opts.model and issubclass(\n                    from_parent._meta.concrete_model, pk_field.model._meta.concrete_model):\n                return result\n            if pk_field.model in only_load and pk_field.attname not in only_load[pk_field.model]:\n                return result\n            model = pk_field.model._meta.concrete_model\n            if model == opts.model:\n                model = None\n            alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n            column = pk_field.get_col(alias)\n            result.append(column)\n            return result\n\n        for field in opts.concrete_fields:\n            model = field.model._meta.concrete_model\n            # A proxy model will have a different model and concrete_model. We\n            # will assign None if the field belongs to this model.\n            if model == opts.model:\n                model = None\n            if from_parent and model is not None and issubclass(\n                    from_parent._meta.concrete_model, model._meta.concrete_model):\n                # Avoid loading data for already loaded parents.\n                # We end up here in the case select_related() resolution\n                # proceeds from parent model to child model. In that case the\n                # parent model data is already present in the SELECT clause,\n                # and we want to avoid reloading the same data again.\n                continue\n            if field.model in only_load and field.attname not in only_load[field.model]:\n                continue\n            alias = self.query.join_parent_model(opts, model, start_alias,\n                                                 seen_models)\n            column = field.get_col(alias)\n            result.append(column)\n"
    ],
    "Location 2 (/root/hy/projects/django/django/db/models/sql/compiler.py lines 687-696)": [
      "\n        result = []\n        if opts is None:\n            opts = self.query.get_meta()\n        only_load = self.deferred_to_columns()\n        start_alias = start_alias or self.query.get_initial_alias()\n        # The 'seen_models' is used to optimize checking the needed parent\n        # alias for a given field. This also includes None -> start_alias to\n        # be used by local fields.\n        seen_models = {None: start_alias}\n        \n        # Check if this is a subquery that should only return the primary key\n        is_subquery_in_lookup = (\n            getattr(self.query, 'subquery', False) and \n            not getattr(self.query, 'has_select_fields', False) and\n            not only_load\n        )\n",
      "\n        result = []\n        if opts is None:\n            opts = self.query.get_meta()\n        only_load = self.deferred_to_columns()\n        start_alias = start_alias or self.query.get_initial_alias()\n        # The 'seen_models' is used to optimize checking the needed parent\n        # alias for a given field. This also includes None -> start_alias to\n        # be used by local fields.\n        seen_models = {None: start_alias}\n        \n        # For subqueries used in __in lookups, only select the primary key\n        # to avoid PostgreSQL's \"subquery must return only one column\" error\n        is_subquery_for_in = getattr(self.query, 'subquery', False)\n",
      "\n        result = []\n        if opts is None:\n            opts = self.query.get_meta()\n        only_load = self.deferred_to_columns()\n        start_alias = start_alias or self.query.get_initial_alias()\n        # The 'seen_models' is used to optimize checking the needed parent\n        # alias for a given field. This also includes None -> start_alias to\n        # be used by local fields.\n        seen_models = {None: start_alias}\n\n        # For subqueries used in __in lookups, only select the primary key\n        # to avoid PostgreSQL \"subquery must return only one column\" error\n        if getattr(self.query, 'subquery', False) and not getattr(self.query, 'has_select_fields', False):\n            pk_field = opts.pk\n            model = pk_field.model._meta.concrete_model\n            if model == opts.model:\n                model = None\n            alias = seen_models.get(model)\n            if alias is None:\n                alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n            column = pk_field.get_col(alias)\n            if as_pairs:\n                result.append((alias, pk_field.column))\n            else:\n                result.append(column.as_sql(self, self.connection)[0])\n            aliases = {alias} if alias else set()\n            return result, aliases\n",
      "\n        result = []\n        if opts is None:\n            opts = self.query.get_meta()\n        only_load = self.deferred_to_columns()\n        start_alias = start_alias or self.query.get_initial_alias()\n        # The 'seen_models' is used to optimize checking the needed parent\n        # alias for a given field. This also includes None -> start_alias to\n        # be used by local fields.\n        seen_models = {None: start_alias}\n        \n        # For subqueries used in __in lookups, only select the primary key\n        if self.query.subquery and getattr(self.query, 'default_cols', False):\n            # Check if this is likely an __in lookup subquery by examining the query context\n            pk_field = opts.pk\n            model = pk_field.model._meta.concrete_model\n            if model == opts.model:\n                model = None\n            if model in seen_models:\n                alias = seen_models[model]\n            else:\n                alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n                seen_models[model] = alias\n            \n            column = pk_field.get_col(alias)\n            if as_pairs:\n                result.append((alias, pk_field.column))\n            else:\n                result.append(column.as_sql(self, self.connection)[0])\n            \n            aliases = {alias}\n            if with_col_aliases:\n                col_aliases = [pk_field.name]\n                return result, aliases, col_aliases\n            return result, aliases\n",
      "\n        result = []\n        if opts is None:\n            opts = self.query.get_meta()\n        only_load = self.deferred_to_columns()\n        start_alias = start_alias or self.query.get_initial_alias()\n        # The 'seen_models' is used to optimize checking the needed parent\n        # alias for a given field. This also includes None -> start_alias to\n        # be used by local fields.\n        seen_models = {None: start_alias}\n\n        # For subqueries used in __in lookups, only select the primary key\n        # to avoid \"subquery must return only one column\" errors\n        if (self.query.subquery and not self.query.select and \n            hasattr(self.query, 'default_cols') and self.query.default_cols):\n            pk_field = opts.pk\n            if pk_field.model == opts.model:\n                model = None\n            else:\n                model = pk_field.model._meta.concrete_model\n            \n            if model in seen_models:\n                alias = seen_models[model]\n            else:\n                alias = self.query.join_parent_model(opts, model, start_alias,\n                                                     seen_models)\n                seen_models[model] = alias\n            \n            column = self.query.resolve_ref(pk_field.name, allow_joins=True, reuse=None, summarize=False)\n            if as_pairs:\n                result.append((alias, column.target.column))\n            else:\n                result.append(column.as_sql(self, self.connection)[0])\n            \n            # For subqueries, we don't need to process all fields\n            return result, {alias}\n",
      "\n        result = []\n        if opts is None:\n            opts = self.query.get_meta()\n        only_load = self.deferred_to_columns()\n        start_alias = start_alias or self.query.get_initial_alias()\n        # The 'seen_models' is used to optimize checking the needed parent\n        # alias for a given field. This also includes None -> start_alias to\n        # be used by local fields.\n        seen_models = {None: start_alias}\n        \n        # Check if this is a subquery that should only select the primary key\n        # This prevents \"subquery must return only one column\" errors in PostgreSQL\n        is_subquery_for_in_lookup = (\n            getattr(self.query, 'subquery', False) and \n            not hasattr(self.query, 'has_select_fields')\n        )\n",
      "\n        result = []\n        if opts is None:\n            opts = self.query.get_meta()\n        only_load = self.deferred_to_columns()\n        start_alias = start_alias or self.query.get_initial_alias()\n        # The 'seen_models' is used to optimize checking the needed parent\n        # alias for a given field. This also includes None -> start_alias to\n        # be used by local fields.\n        seen_models = {None: start_alias}\n        \n        # For subqueries used in __in lookups, only select the primary key\n        # to avoid PostgreSQL's \"subquery must return only one column\" error\n        if self.query.subquery and not from_parent:\n            # Check if this is likely an __in lookup subquery by examining\n            # if we're selecting default columns with no explicit select_fields\n            is_in_lookup_subquery = (\n                getattr(self.query, 'default_cols', False) and\n                not getattr(self.query, 'select', None)\n            )\n            if is_in_lookup_subquery:\n                # Only include the primary key field for __in lookup subqueries\n                pk_field = opts.pk\n                if pk_field.column not in only_load:\n                    alias = seen_models[None]\n                    column = pk_field.column\n                    if as_pairs:\n                        result.append((alias, column))\n                    else:\n                        result.append(self.quote_name_unless_alias(column))\n                return result, set()\n",
      "\n        result = []\n        if opts is None:\n            opts = self.query.get_meta()\n        only_load = self.deferred_to_columns()\n        start_alias = start_alias or self.query.get_initial_alias()\n        # The 'seen_models' is used to optimize checking the needed parent\n        # alias for a given field. This also includes None -> start_alias to\n        # be used by local fields.\n        seen_models = {None: start_alias}\n        \n        # Check if this is a subquery that should only return the primary key\n        # This prevents \"subquery must return only one column\" errors in PostgreSQL\n        is_subquery_for_in_lookup = (\n            getattr(self.query, 'subquery', False) and\n            not getattr(self.query, 'has_select_fields', False) and\n            opts is not None\n        )\n"
    ],
    "Location 3 (/root/hy/projects/django/django/db/models/fields/related_lookups.py lines 89-100)": [
      "\n            if (not getattr(self.rhs, 'has_select_fields', True) and\n                    not getattr(self.lhs.field.target_field, 'primary_key', False)):\n                self.rhs.clear_select_clause()\n                # Check if this is a subquery context where we need to limit fields\n                if (getattr(self.rhs, 'subquery', False) and \n                        getattr(self.rhs, 'default_cols', False)):\n                    # Force single field selection for subqueries in __in lookups\n                    if (getattr(self.lhs.output_field, 'primary_key', False) and\n                            self.lhs.output_field.model == self.rhs.model):\n                        target_field = self.lhs.field.name\n                    else:\n                        target_field = self.lhs.field.target_field.name\n                    self.rhs.add_fields([target_field], True)\n                elif (getattr(self.lhs.output_field, 'primary_key', False) and\n                        self.lhs.output_field.model == self.rhs.model):\n                    # A case like Restaurant.objects.filter(place__in=restaurant_qs),\n                    # where place is a OneToOneField and the primary key of\n                    # Restaurant.\n                    target_field = self.lhs.field.name\n                    self.rhs.add_fields([target_field], True)\n                else:\n                    target_field = self.lhs.field.target_field.name\n                    self.rhs.add_fields([target_field], True)\n",
      "\n            if (not getattr(self.rhs, 'has_select_fields', True) and\n                    not getattr(self.lhs.field.target_field, 'primary_key', False)):\n                self.rhs.clear_select_clause()\n                # Check if we're dealing with a subquery that has default_cols=True\n                # which would cause all fields to be selected instead of just the target field\n                if getattr(self.rhs, 'subquery', False) and getattr(self.rhs, 'default_cols', False):\n                    # Force clearing the select clause to ensure only target field is used\n                    self.rhs.clear_select_clause()\n                \n                if (getattr(self.lhs.output_field, 'primary_key', False) and\n                        self.lhs.output_field.model == self.rhs.model):\n                    # A case like Restaurant.objects.filter(place__in=restaurant_qs),\n                    # where place is a OneToOneField and the primary key of\n                    # Restaurant.\n                    target_field = self.lhs.field.name\n                else:\n                    target_field = self.lhs.field.target_field.name\n                self.rhs.add_fields([target_field], True)\n",
      "\n        else:\n            if (not getattr(self.rhs, 'has_select_fields', True) and\n                    not getattr(self.lhs.field.target_field, 'primary_key', False)):\n                self.rhs.clear_select_clause()\n                # Check if this is a subquery context where we need to limit fields\n                if (hasattr(self.rhs, 'query') and \n                    getattr(self.rhs.query, 'subquery', False) and\n                    getattr(self.rhs.query, 'default_cols', False)):\n                    # Force single column selection for subqueries in __in lookups\n                    self.rhs.query.default_cols = False\n                \n                if (getattr(self.lhs.output_field, 'primary_key', False) and\n                        self.lhs.output_field.model == self.rhs.model):\n                    # A case like Restaurant.objects.filter(place__in=restaurant_qs),\n                    # where place is a OneToOneField and the primary key of\n                    # Restaurant.\n                    target_field = self.lhs.field.name\n                else:\n                    target_field = self.lhs.field.target_field.name\n                self.rhs.add_fields([target_field], True)\n            return super().as_sql(compiler, connection)\n",
      "\n            if (not getattr(self.rhs, 'has_select_fields', True) and\n                    not getattr(self.lhs.field.target_field, 'primary_key', False)):\n                self.rhs.clear_select_clause()\n                # Check if we're in a subquery context that needs field limitation\n                if (getattr(self.rhs, 'subquery', False) and \n                    getattr(self.rhs, 'default_cols', False)):\n                    # Force single column selection for subqueries\n                    if (getattr(self.lhs.output_field, 'primary_key', False) and\n                            self.lhs.output_field.model == self.rhs.model):\n                        target_field = self.lhs.field.name\n                    else:\n                        target_field = self.lhs.field.target_field.name\n                    self.rhs.add_fields([target_field], True)\n                elif (getattr(self.lhs.output_field, 'primary_key', False) and\n                        self.lhs.output_field.model == self.rhs.model):\n                    # A case like Restaurant.objects.filter(place__in=restaurant_qs),\n                    # where place is a OneToOneField and the primary key of\n                    # Restaurant.\n                    target_field = self.lhs.field.name\n                    self.rhs.add_fields([target_field], True)\n                else:\n                    target_field = self.lhs.field.target_field.name\n                    self.rhs.add_fields([target_field], True)\n",
      "\n            if (not getattr(self.rhs, 'has_select_fields', True) and\n                    not getattr(self.lhs.field.target_field, 'primary_key', False)):\n                self.rhs.clear_select_clause()\n                # Check if this is a subquery context where we need to limit fields\n                if (getattr(self.rhs, 'subquery', False) or \n                    (hasattr(self.rhs, 'query') and getattr(self.rhs.query, 'subquery', False))):\n                    # In subquery context, only select the target field\n                    if (getattr(self.lhs.output_field, 'primary_key', False) and\n                            self.lhs.output_field.model == self.rhs.model):\n                        target_field = self.lhs.field.name\n                    else:\n                        target_field = self.lhs.field.target_field.name\n                    self.rhs.add_fields([target_field], True)\n                else:\n                    # Original logic for non-subquery contexts\n                    if (getattr(self.lhs.output_field, 'primary_key', False) and\n                            self.lhs.output_field.model == self.rhs.model):\n                        target_field = self.lhs.field.name\n                    else:\n                        target_field = self.lhs.field.target_field.name\n                    self.rhs.add_fields([target_field], True)\n",
      "\n            if (not getattr(self.rhs, 'has_select_fields', True) and\n                    not getattr(self.lhs.field.target_field, 'primary_key', False)):\n                self.rhs.clear_select_clause()\n                # Check if we're in a subquery context that needs field limiting\n                if (getattr(self.rhs, 'subquery', False) and \n                    getattr(self.rhs, 'default_cols', False)):\n                    # Force single column selection for subqueries\n                    if (getattr(self.lhs.output_field, 'primary_key', False) and\n                            self.lhs.output_field.model == self.rhs.model):\n                        target_field = self.lhs.field.name\n                    else:\n                        target_field = self.lhs.field.target_field.name\n                    self.rhs.add_fields([target_field], True)\n                elif (getattr(self.lhs.output_field, 'primary_key', False) and\n                        self.lhs.output_field.model == self.rhs.model):\n                    # A case like Restaurant.objects.filter(place__in=restaurant_qs),\n                    # where place is a OneToOneField and the primary key of\n                    # Restaurant.\n                    target_field = self.lhs.field.name\n                    self.rhs.add_fields([target_field], True)\n                else:\n                    target_field = self.lhs.field.target_field.name\n                    self.rhs.add_fields([target_field], True)\n",
      "\n            if (not getattr(self.rhs, 'has_select_fields', True) and\n                    not getattr(self.lhs.field.target_field, 'primary_key', False)):\n                self.rhs.clear_select_clause()\n                # Check if we're in a subquery context that needs field limiting\n                if getattr(self.rhs, 'subquery', False) and getattr(self.rhs, 'default_cols', False):\n                    # Force selection of only the target field for subqueries\n                    if (getattr(self.lhs.output_field, 'primary_key', False) and\n                            self.lhs.output_field.model == self.rhs.model):\n                        target_field = self.lhs.field.name\n                    else:\n                        target_field = self.lhs.field.target_field.name\n                    self.rhs.add_fields([target_field], True)\n                elif (getattr(self.lhs.output_field, 'primary_key', False) and\n                        self.lhs.output_field.model == self.rhs.model):\n                    # A case like Restaurant.objects.filter(place__in=restaurant_qs),\n                    # where place is a OneToOneField and the primary key of\n                    # Restaurant.\n                    target_field = self.lhs.field.name\n                    self.rhs.add_fields([target_field], True)\n                else:\n                    target_field = self.lhs.field.target_field.name\n                    self.rhs.add_fields([target_field], True)\n",
      "\n            if (not getattr(self.rhs, 'has_select_fields', True) and\n                    not getattr(self.lhs.field.target_field, 'primary_key', False)):\n                self.rhs.clear_select_clause()\n                # Check if we need to limit fields for subquery context\n                if (getattr(self.rhs, 'subquery', False) and \n                        getattr(self.rhs, 'default_cols', False)):\n                    # In subquery context with default_cols, only select primary key\n                    if (getattr(self.lhs.output_field, 'primary_key', False) and\n                            self.lhs.output_field.model == self.rhs.model):\n                        target_field = self.lhs.field.name\n                    else:\n                        target_field = self.lhs.field.target_field.name\n                    self.rhs.add_fields([target_field], True)\n                elif (getattr(self.lhs.output_field, 'primary_key', False) and\n                        self.lhs.output_field.model == self.rhs.model):\n                    # A case like Restaurant.objects.filter(place__in=restaurant_qs),\n                    # where place is a OneToOneField and the primary key of\n                    # Restaurant.\n                    target_field = self.lhs.field.name\n                    self.rhs.add_fields([target_field], True)\n                else:\n                    target_field = self.lhs.field.target_field.name\n                    self.rhs.add_fields([target_field], True)\n"
    ],
    "Location 4 (/root/hy/projects/django/django/db/models/sql/compiler.py lines 675-686)": [
      "\n    def get_default_columns(self, start_alias=None, opts=None, from_parent=None):\n        \"\"\"\n        Compute the default columns for selecting every field in the base\n        model. Will sometimes be called to pull in related models (e.g. via\n        select_related), in which case \"opts\" and \"start_alias\" will be given\n        to provide a starting point for the traversal.\n\n        Return a list of strings, quoted appropriately for use in SQL\n        directly, as well as a set of aliases used in the select statement (if\n        'as_pairs' is True, return a list of (alias, col_name) pairs instead\n        of strings as the first component and None as the second component).\n        \n        For subqueries used in __in lookups, only returns the primary key field\n        to avoid \"subquery must return only one column\" database errors.\n        \"\"\"\n        result = []\n        if opts is None:\n            opts = self.query.get_meta()\n        only_load = self.deferred_to_columns()\n        start_alias = start_alias or self.query.get_initial_alias()\n        \n        # Check if this is a subquery used in an __in lookup that should only\n        # select the primary key to avoid multi-column subquery errors\n        is_subquery_for_in_lookup = (\n            getattr(self.query, 'subquery', False) and \n            not hasattr(self.query, 'select_fields') and\n            getattr(self.query, 'default_cols', False)\n        )\n        \n        # The 'seen_models' is used to optimize checking the needed parent\n        # alias for a given field. This also includes None -> start_alias to\n        # be used by local fields.\n        seen_models = {None: start_alias}\n",
      "\n    def get_default_columns(self, start_alias=None, opts=None, from_parent=None):\n        \"\"\"\n        Compute the default columns for selecting every field in the base\n        model. Will sometimes be called to pull in related models (e.g. via\n        select_related), in which case \"opts\" and \"start_alias\" will be given\n        to provide a starting point for the traversal.\n\n        Return a list of strings, quoted appropriately for use in SQL\n        directly, as well as a set of aliases used in the select statement (if\n        'as_pairs' is True, return a list of (alias, col_name) pairs instead\n        of strings as the first component and None as the second component).\n        \n        For subqueries used in __in lookups, only the primary key is selected\n        to avoid PostgreSQL's \"subquery must return only one column\" error.\n        \"\"\"\n",
      "\n    def get_default_columns(self, start_alias=None, opts=None, from_parent=None):\n        \"\"\"\n        Compute the default columns for selecting every field in the base\n        model. Will sometimes be called to pull in related models (e.g. via\n        select_related), in which case \"opts\" and \"start_alias\" will be given\n        to provide a starting point for the traversal.\n\n        Return a list of strings, quoted appropriately for use in SQL\n        directly, as well as a set of aliases used in the select statement (if\n        'as_pairs' is True, return a list of (alias, col_name) pairs instead\n        of strings as the first component and None as the second component).\n        \n        In subquery contexts (e.g., __in lookups), only select the primary key\n        to avoid PostgreSQL's \"subquery must return only one column\" error.\n        \"\"\"\n        result = []\n        if opts is None:\n            opts = self.query.get_meta()\n        only_load = self.deferred_to_columns()\n        start_alias = start_alias or self.query.get_initial_alias()\n        \n        # Check if this is a subquery used in an __in lookup context\n        # In such cases, we should only select the primary key field\n        is_subquery_for_in_lookup = (\n            getattr(self.query, 'subquery', False) and \n            not hasattr(self.query, 'select_fields') and\n            getattr(self.query, 'default_cols', False)\n        )\n        \n        # The 'seen_models' is used to optimize checking the needed parent\n        # alias for a given field. This also includes None -> start_alias to\n        # be used by local fields.\n        seen_models = {None: start_alias}\n",
      "\n    def get_default_columns(self, start_alias=None, opts=None, from_parent=None):\n        \"\"\"\n        Compute the default columns for selecting every field in the base\n        model. Will sometimes be called to pull in related models (e.g. via\n        select_related), in which case \"opts\" and \"start_alias\" will be given\n        to provide a starting point for the traversal.\n\n        Return a list of strings, quoted appropriately for use in SQL\n        directly, as well as a set of aliases used in the select statement (if\n        'as_pairs' is True, return a list of (alias, col_name) pairs instead\n        of strings as the first component and None as the second component).\n        \n        For subqueries used in __in lookups, only the primary key is selected\n        to avoid \"subquery must return only one column\" database errors.\n        \"\"\"\n",
      "\n    def get_default_columns(self, start_alias=None, opts=None, from_parent=None):\n        \"\"\"\n        Compute the default columns for selecting every field in the base\n        model. Will sometimes be called to pull in related models (e.g. via\n        select_related), in which case \"opts\" and \"start_alias\" will be given\n        to provide a starting point for the traversal.\n\n        Return a list of strings, quoted appropriately for use in SQL\n        directly, as well as a set of aliases used in the select statement (if\n        'as_pairs' is True, return a list of (alias, col_name) pairs instead\n        of strings as the first component and None as the second component).\n        \n        For subqueries used in __in lookups, only the primary key is selected\n        to avoid PostgreSQL's \"subquery must return only one column\" error.\n        \"\"\"\n        result = []\n        if opts is None:\n            opts = self.query.get_meta()\n        only_load = self.deferred_to_columns()\n        start_alias = start_alias or self.query.get_initial_alias()\n        \n        # Check if this is a subquery that should only return primary key\n        # This prevents \"subquery must return only one column\" errors\n        is_subquery_for_in_lookup = (\n            getattr(self.query, 'subquery', False) and\n            not hasattr(self.query, 'select_fields') and\n            getattr(self.query, 'default_cols', False)\n        )\n        \n        # The 'seen_models' is used to optimize checking the needed parent\n        # alias for a given field. This also includes None -> start_alias to\n        # be used by local fields.\n        seen_models = {None: start_alias}\n",
      "\n    def get_default_columns(self, start_alias=None, opts=None, from_parent=None):\n        \"\"\"\n        Compute the default columns for selecting every field in the base\n        model. Will sometimes be called to pull in related models (e.g. via\n        select_related), in which case \"opts\" and \"start_alias\" will be given\n        to provide a starting point for the traversal.\n\n        Return a list of strings, quoted appropriately for use in SQL\n        directly, as well as a set of aliases used in the select statement (if\n        'as_pairs' is True, return a list of (alias, col_name) pairs instead\n        of strings as the first component and None as the second component).\n        \n        For subqueries used in __in lookups, only the primary key is selected\n        to avoid PostgreSQL's \"subquery must return only one column\" error.\n        \"\"\"\n        result = []\n        if opts is None:\n            opts = self.query.get_meta()\n        only_load = self.deferred_to_columns()\n        start_alias = start_alias or self.query.get_initial_alias()\n        \n        # Check if this is a subquery that should only select the primary key\n        # This handles cases like Q(field__in=subquery) where PostgreSQL requires\n        # exactly one column in the subquery\n        is_subquery_for_in_lookup = (\n            getattr(self.query, 'subquery', False) and \n            not hasattr(self.query, 'select_fields') and\n            not self.query.select and\n            not self.query.annotations\n        )\n        \n        # The 'seen_models' is used to optimize checking the needed parent\n        # alias for a given field. This also includes None -> start_alias to\n        # be used by local fields.\n        seen_models = {None: start_alias}\n",
      "\n    def get_default_columns(self, start_alias=None, opts=None, from_parent=None):\n        \"\"\"\n        Compute the default columns for selecting every field in the base\n        model. Will sometimes be called to pull in related models (e.g. via\n        select_related), in which case \"opts\" and \"start_alias\" will be given\n        to provide a starting point for the traversal.\n\n        Return a list of strings, quoted appropriately for use in SQL\n        directly, as well as a set of aliases used in the select statement (if\n        'as_pairs' is True, return a list of (alias, col_name) pairs instead\n        of strings as the first component and None as the second component).\n        \n        When used in a subquery context (e.g., for __in lookups), only the\n        primary key field will be selected to avoid PostgreSQL's \"subquery\n        must return only one column\" error.\n        \"\"\"\n",
      "\n    def get_default_columns(self, start_alias=None, opts=None, from_parent=None):\n        \"\"\"\n        Compute the default columns for selecting every field in the base\n        model. Will sometimes be called to pull in related models (e.g. via\n        select_related), in which case \"opts\" and \"start_alias\" will be given\n        to provide a starting point for the traversal.\n\n        Return a list of strings, quoted appropriately for use in SQL\n        directly, as well as a set of aliases used in the select statement (if\n        'as_pairs' is True, return a list of (alias, col_name) pairs instead\n        of strings as the first component and None as the second component).\n        \n        For subqueries used in __in lookups, only the primary key is selected\n        to ensure PostgreSQL compatibility.\n        \"\"\"\n        result = []\n        if opts is None:\n            opts = self.query.get_meta()\n        only_load = self.deferred_to_columns()\n        start_alias = start_alias or self.query.get_initial_alias()\n        \n        # Check if this is a subquery that should only return the primary key\n        # This prevents \"subquery must return only one column\" errors in PostgreSQL\n        is_subquery_for_in_lookup = (\n            getattr(self.query, 'subquery', False) and \n            not getattr(self.query, 'has_select_fields', False) and\n            hasattr(self.query, 'default_cols') and \n            self.query.default_cols\n        )\n        \n        # The 'seen_models' is used to optimize checking the needed parent\n        # alias for a given field. This also includes None -> start_alias to\n        # be used by local fields.\n        seen_models = {None: start_alias}\n"
    ],
    "Location 5 (/root/hy/projects/django/django/db/models/sql/compiler.py lines 688-690)": [
      "\n        if opts is None:\n            opts = self.query.get_meta()\n        only_load = self.deferred_to_columns()\n        \n        # For subqueries used in __in lookups, we should only select the primary key\n        # to avoid \"subquery must return only one column\" errors\n        if (self.query.subquery and \n            hasattr(self.query, 'default_cols') and \n            self.query.default_cols and\n            not only_load):\n            # When this is a subquery with default columns, limit to primary key only\n            only_load = {opts.pk.column}\n",
      "\n        result = []\n        if opts is None:\n            opts = self.query.get_meta()\n        only_load = self.deferred_to_columns()\n",
      "\n        if opts is None:\n            opts = self.query.get_meta()\n        # For subqueries used in IN lookups, we should only select the primary key\n        # to avoid PostgreSQL's \"subquery must return only one column\" error\n        if self.query.subquery and hasattr(self.query, 'default_cols') and self.query.default_cols:\n            # Check if this is likely an IN lookup subquery by examining the query context\n            only_load = {opts.pk.name} if opts.pk else set()\n        else:\n            only_load = self.deferred_to_columns()\n",
      "\n        if opts is None:\n            opts = self.query.get_meta()\n        # Check if this is a subquery used in an __in lookup that should only return one column\n        if self.query.subquery and hasattr(self.query, 'default_cols') and self.query.default_cols:\n            # For subqueries in __in lookups, only select the primary key field\n            only_load = self.deferred_to_columns()\n            if not only_load:\n                only_load = {opts.pk.name}\n        else:\n            only_load = self.deferred_to_columns()\n",
      "\n        result = []\n        if opts is None:\n            opts = self.query.get_meta()\n        only_load = self.deferred_to_columns()\n",
      "\n        if opts is None:\n            opts = self.query.get_meta()\n        # For subqueries used in __in lookups, we should only select the primary key\n        # to avoid PostgreSQL's \"subquery must return only one column\" error\n        if getattr(self.query, 'subquery', False) and self.query.default_cols:\n            only_load = set([opts.pk.column])\n        else:\n            only_load = self.deferred_to_columns()\n",
      "\n        if opts is None:\n            opts = self.query.get_meta()\n        # For subqueries used in __in lookups, we should only select the primary key\n        # to avoid PostgreSQL's \"subquery must return only one column\" error\n        if getattr(self.query, 'subquery', False) and as_pairs is None:\n            # Check if this is likely an __in lookup subquery by examining the query structure\n            if (hasattr(self.query, 'where') and self.query.where and \n                not getattr(self.query, 'select', None) and\n                len(opts.concrete_fields) > 1):\n                # Only load the primary key field for __in subqueries\n                only_load = {opts.pk.name: opts.pk}\n            else:\n                only_load = self.deferred_to_columns()\n        else:\n            only_load = self.deferred_to_columns()\n",
      "\n        if opts is None:\n            opts = self.query.get_meta()\n        only_load = self.deferred_to_columns()\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/fields/related_lookups.py b/django/db/models/fields/related_lookups.py\nindex d745ecd5f9..a94adb9945 100644\n--- a/django/db/models/fields/related_lookups.py\n+++ b/django/db/models/fields/related_lookups.py\n@@ -86,8 +86,10 @@ class RelatedIn(In):\n                     AND)\n             return root_constraint.as_sql(compiler, connection)\n         else:\n+\n             if (not getattr(self.rhs, 'has_select_fields', True) and\n-                    not getattr(self.lhs.field.target_field, 'primary_key', False)):\n+                    not getattr(self.lhs.field.target_field, 'primary_key', False)) or \\\n+               (getattr(self.rhs, 'subquery', False) and getattr(self.rhs, 'default_cols', False)):\n                 self.rhs.clear_select_clause()\n                 if (getattr(self.lhs.output_field, 'primary_key', False) and\n                         self.lhs.output_field.model == self.rhs.model):\ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7264929da8..94bb970ae1 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -672,6 +672,7 @@ class SQLCompiler:\n             # Finally do cleanup - get rid of the joins we created above.\n             self.query.reset_refcounts(refcounts_before)\n \n+\n     def get_default_columns(self, start_alias=None, opts=None, from_parent=None):\n         \"\"\"\n         Compute the default columns for selecting every field in the base\n@@ -679,11 +680,15 @@ class SQLCompiler:\n         select_related), in which case \"opts\" and \"start_alias\" will be given\n         to provide a starting point for the traversal.\n \n+        For subqueries used in __in lookups, only the primary key field is\n+        selected to avoid \"subquery must return only one column\" errors.\n+\n         Return a list of strings, quoted appropriately for use in SQL\n         directly, as well as a set of aliases used in the select statement (if\n         'as_pairs' is True, return a list of (alias, col_name) pairs instead\n         of strings as the first component and None as the second component).\n         \"\"\"\n+\n         result = []\n         if opts is None:\n             opts = self.query.get_meta()\n@@ -694,26 +699,39 @@ class SQLCompiler:\n         # be used by local fields.\n         seen_models = {None: start_alias}\n \n-        for field in opts.concrete_fields:\n-            model = field.model._meta.concrete_model\n-            # A proxy model will have a different model and concrete_model. We\n-            # will assign None if the field belongs to this model.\n+\n+        # Check if this is a subquery that should only return primary key for __in lookups\n+        if getattr(self.query, 'subquery', False) and not from_parent:\n+            # Only include primary key field for subqueries to avoid \"must return only one column\" error\n+            pk_field = opts.pk\n+            model = pk_field.model._meta.concrete_model\n             if model == opts.model:\n                 model = None\n-            if from_parent and model is not None and issubclass(\n-                    from_parent._meta.concrete_model, model._meta.concrete_model):\n-                # Avoid loading data for already loaded parents.\n-                # We end up here in the case select_related() resolution\n-                # proceeds from parent model to child model. In that case the\n-                # parent model data is already present in the SELECT clause,\n-                # and we want to avoid reloading the same data again.\n-                continue\n-            if field.model in only_load and field.attname not in only_load[field.model]:\n-                continue\n-            alias = self.query.join_parent_model(opts, model, start_alias,\n-                                                 seen_models)\n-            column = field.get_col(alias)\n+            alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n+            column = pk_field.get_col(alias)\n             result.append(column)\n+        else:\n+            # Original logic for all other cases\n+            for field in opts.concrete_fields:\n+                model = field.model._meta.concrete_model\n+                # A proxy model will have a different model and concrete_model. We\n+                # will assign None if the field belongs to this model.\n+                if model == opts.model:\n+                    model = None\n+                if from_parent and model is not None and issubclass(\n+                        from_parent._meta.concrete_model, model._meta.concrete_model):\n+                    # Avoid loading data for already loaded parents.\n+                    # We end up here in the case select_related() resolution\n+                    # proceeds from parent model to child model. In that case the\n+                    # parent model data is already present in the SELECT clause,\n+                    # and we want to avoid reloading the same data again.\n+                    continue\n+                if field.model in only_load and field.attname not in only_load[field.model]:\n+                    continue\n+                alias = self.query.join_parent_model(opts, model, start_alias,\n+                                                     seen_models)\n+                column = field.get_col(alias)\n+                result.append(column)\n         return result\n \n     def get_distinct(self):\n",
    "variant_0": "diff --git a/django/db/models/fields/related_lookups.py b/django/db/models/fields/related_lookups.py\nindex d745ecd5f9..8cd41b6383 100644\n--- a/django/db/models/fields/related_lookups.py\n+++ b/django/db/models/fields/related_lookups.py\n@@ -86,18 +86,33 @@ class RelatedIn(In):\n                     AND)\n             return root_constraint.as_sql(compiler, connection)\n         else:\n+\n             if (not getattr(self.rhs, 'has_select_fields', True) and\n                     not getattr(self.lhs.field.target_field, 'primary_key', False)):\n                 self.rhs.clear_select_clause()\n-                if (getattr(self.lhs.output_field, 'primary_key', False) and\n+                # Check if this is a subquery that needs field limitation\n+                if (getattr(self.rhs, 'subquery', False) and \n+                        getattr(self.rhs, 'default_cols', False)):\n+                    # Force single field selection for subqueries in __in lookups\n+                    if (getattr(self.lhs.output_field, 'primary_key', False) and\n+                            self.lhs.output_field.model == self.rhs.model):\n+                        # A case like Restaurant.objects.filter(place__in=restaurant_qs),\n+                        # where place is a OneToOneField and the primary key of\n+                        # Restaurant.\n+                        target_field = self.lhs.field.name\n+                    else:\n+                        target_field = self.lhs.field.target_field.name\n+                    self.rhs.add_fields([target_field], True)\n+                elif (getattr(self.lhs.output_field, 'primary_key', False) and\n                         self.lhs.output_field.model == self.rhs.model):\n                     # A case like Restaurant.objects.filter(place__in=restaurant_qs),\n                     # where place is a OneToOneField and the primary key of\n                     # Restaurant.\n                     target_field = self.lhs.field.name\n+                    self.rhs.add_fields([target_field], True)\n                 else:\n                     target_field = self.lhs.field.target_field.name\n-                self.rhs.add_fields([target_field], True)\n+                    self.rhs.add_fields([target_field], True)\n             return super().as_sql(compiler, connection)\n \n \ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7264929da8..24aae72701 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -672,6 +672,7 @@ class SQLCompiler:\n             # Finally do cleanup - get rid of the joins we created above.\n             self.query.reset_refcounts(refcounts_before)\n \n+\n     def get_default_columns(self, start_alias=None, opts=None, from_parent=None):\n         \"\"\"\n         Compute the default columns for selecting every field in the base\n@@ -683,7 +684,55 @@ class SQLCompiler:\n         directly, as well as a set of aliases used in the select statement (if\n         'as_pairs' is True, return a list of (alias, col_name) pairs instead\n         of strings as the first component and None as the second component).\n+        \n+        For subqueries used in __in lookups, only return the primary key column\n+        to avoid PostgreSQL \"subquery must return only one column\" errors.\n         \"\"\"\n+        result = []\n+        if opts is None:\n+            opts = self.query.get_meta()\n+        \n+        # Check if this is a subquery that should only return the primary key\n+        is_subquery_for_in_lookup = (\n+            getattr(self.query, 'subquery', False) and\n+            hasattr(self.query, 'default_cols') and\n+            self.query.default_cols and\n+            not getattr(self.query, 'select_fields', None)\n+        )\n+        \n+        only_load = self.deferred_to_columns()\n+        start_alias = start_alias or self.query.get_initial_alias()\n+        # The 'seen_models' is used to optimize checking the needed parent\n+        # alias for a given field. This also includes None -> start_alias to\n+        # be used by local fields.\n+        seen_models = {None: start_alias}\n+\n+        result = []\n+        if opts is None:\n+            opts = self.query.get_meta()\n+        only_load = self.deferred_to_columns()\n+        start_alias = start_alias or self.query.get_initial_alias()\n+        # The 'seen_models' is used to optimize checking the needed parent\n+        # alias for a given field. This also includes None -> start_alias to\n+        # be used by local fields.\n+        seen_models = {None: start_alias}\n+        \n+        # For subqueries used in __in lookups, only select the primary key\n+        # to avoid \"subquery must return only one column\" errors\n+        is_subquery_for_in = (\n+            self.query.subquery and \n+            hasattr(self.query, 'default_cols') and \n+            self.query.default_cols\n+        )\n+        else:\n+            only_load = self.deferred_to_columns()\n+        start_alias = start_alias or self.query.get_initial_alias()\n+        # The 'seen_models' is used to optimize checking the needed parent\n+        # alias for a given field. This also includes None -> start_alias to\n+        # be used by local fields.\n+        seen_models = {None: start_alias}\n+\n+\n         result = []\n         if opts is None:\n             opts = self.query.get_meta()\n@@ -694,6 +743,18 @@ class SQLCompiler:\n         # be used by local fields.\n         seen_models = {None: start_alias}\n \n+        # For subqueries used in __in lookups, only select the primary key\n+        if getattr(self.query, 'subquery', False) and hasattr(self.query, '_for_in_lookup'):\n+            pk_field = opts.pk\n+            if pk_field.model._meta.concrete_model == opts.model:\n+                model = None\n+            else:\n+                model = pk_field.model._meta.concrete_model\n+            alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n+            column = pk_field.get_col(alias)\n+            result.append(column)\n+            return result\n+\n         for field in opts.concrete_fields:\n             model = field.model._meta.concrete_model\n             # A proxy model will have a different model and concrete_model. We\n",
    "variant_1": "diff --git a/django/db/models/fields/related_lookups.py b/django/db/models/fields/related_lookups.py\nindex d745ecd5f9..4e334b3299 100644\n--- a/django/db/models/fields/related_lookups.py\n+++ b/django/db/models/fields/related_lookups.py\n@@ -86,18 +86,30 @@ class RelatedIn(In):\n                     AND)\n             return root_constraint.as_sql(compiler, connection)\n         else:\n+\n             if (not getattr(self.rhs, 'has_select_fields', True) and\n                     not getattr(self.lhs.field.target_field, 'primary_key', False)):\n                 self.rhs.clear_select_clause()\n-                if (getattr(self.lhs.output_field, 'primary_key', False) and\n+                # Check if this is a subquery context where we need to limit fields\n+                if (getattr(self.rhs, 'subquery', False) and \n+                        getattr(self.rhs, 'default_cols', False)):\n+                    # Force single field selection for subqueries in __in lookups\n+                    if (getattr(self.lhs.output_field, 'primary_key', False) and\n+                            self.lhs.output_field.model == self.rhs.model):\n+                        target_field = self.lhs.field.name\n+                    else:\n+                        target_field = self.lhs.field.target_field.name\n+                    self.rhs.add_fields([target_field], True)\n+                elif (getattr(self.lhs.output_field, 'primary_key', False) and\n                         self.lhs.output_field.model == self.rhs.model):\n                     # A case like Restaurant.objects.filter(place__in=restaurant_qs),\n                     # where place is a OneToOneField and the primary key of\n                     # Restaurant.\n                     target_field = self.lhs.field.name\n+                    self.rhs.add_fields([target_field], True)\n                 else:\n                     target_field = self.lhs.field.target_field.name\n-                self.rhs.add_fields([target_field], True)\n+                    self.rhs.add_fields([target_field], True)\n             return super().as_sql(compiler, connection)\n \n \ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7264929da8..bd014c5095 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -672,6 +672,7 @@ class SQLCompiler:\n             # Finally do cleanup - get rid of the joins we created above.\n             self.query.reset_refcounts(refcounts_before)\n \n+\n     def get_default_columns(self, start_alias=None, opts=None, from_parent=None):\n         \"\"\"\n         Compute the default columns for selecting every field in the base\n@@ -683,6 +684,67 @@ class SQLCompiler:\n         directly, as well as a set of aliases used in the select statement (if\n         'as_pairs' is True, return a list of (alias, col_name) pairs instead\n         of strings as the first component and None as the second component).\n+        \n+        For subqueries used in __in lookups, only returns the primary key field\n+        to avoid \"subquery must return only one column\" database errors.\n+        \"\"\"\n+        result = []\n+        if opts is None:\n+            opts = self.query.get_meta()\n+        only_load = self.deferred_to_columns()\n+        start_alias = start_alias or self.query.get_initial_alias()\n+        \n+        # Check if this is a subquery used in an __in lookup that should only\n+        # select the primary key to avoid multi-column subquery errors\n+        is_subquery_for_in_lookup = (\n+            getattr(self.query, 'subquery', False) and \n+            not hasattr(self.query, 'select_fields') and\n+            getattr(self.query, 'default_cols', False)\n+        )\n+        \n+        # The 'seen_models' is used to optimize checking the needed parent\n+        # alias for a given field. This also includes None -> start_alias to\n+        # be used by local fields.\n+        seen_models = {None: start_alias}\n+\n+        result = []\n+        if opts is None:\n+            opts = self.query.get_meta()\n+        only_load = self.deferred_to_columns()\n+        start_alias = start_alias or self.query.get_initial_alias()\n+        # The 'seen_models' is used to optimize checking the needed parent\n+        # alias for a given field. This also includes None -> start_alias to\n+        # be used by local fields.\n+        seen_models = {None: start_alias}\n+        \n+        # Check if this is a subquery that should only return the primary key\n+        is_subquery_in_lookup = (\n+            getattr(self.query, 'subquery', False) and \n+            not getattr(self.query, 'has_select_fields', False) and\n+            not only_load\n+        )\n+            self.query.default_cols and\n+            not only_load):\n+            # When this is a subquery with default columns, limit to primary key only\n+            only_load = {opts.pk.column}\n+        start_alias = start_alias or self.query.get_initial_alias()\n+        # The 'seen_models' is used to optimize checking the needed parent\n+        # alias for a given field. This also includes None -> start_alias to\n+        # be used by local fields.\n+        seen_models = {None: start_alias}\n+\n+\n+    def get_default_columns(self, start_alias=None, opts=None, from_parent=None):\n+        \"\"\"\n+        Compute the default columns for selecting every field in the base\n+        model. Will sometimes be called to pull in related models (e.g. via\n+        select_related), in which case \"opts\" and \"start_alias\" will be given\n+        to provide a starting point for the traversal.\n+\n+        Return a list of strings, quoted appropriately for use in SQL\n+        directly, as well as a list of aliases used in the select statement (if\n+        'as_pairs' is True, return a list of (alias, col_name) pairs instead\n+        of strings as the first component and None as the second component).\n         \"\"\"\n         result = []\n         if opts is None:\n@@ -694,6 +756,25 @@ class SQLCompiler:\n         # be used by local fields.\n         seen_models = {None: start_alias}\n \n+        # For subqueries used in __in lookups, only select the primary key\n+        # to avoid \"subquery must return only one column\" error\n+        if (self.query.subquery and \n+            hasattr(self.query, 'default_cols') and self.query.default_cols):\n+            # Only include the primary key field for subqueries\n+            pk_field = opts.pk\n+            if pk_field.model._meta.concrete_model == opts.model:\n+                model = None\n+            else:\n+                model = pk_field.model._meta.concrete_model\n+            \n+            if not (from_parent and model is not None and issubclass(\n+                    from_parent._meta.concrete_model, model._meta.concrete_model)):\n+                if not (pk_field.model in only_load and pk_field.attname not in only_load[pk_field.model]):\n+                    alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n+                    column = pk_field.get_col(alias)\n+                    result.append(column)\n+            return result\n+\n         for field in opts.concrete_fields:\n             model = field.model._meta.concrete_model\n             # A proxy model will have a different model and concrete_model. We\n@@ -715,6 +796,7 @@ class SQLCompiler:\n             column = field.get_col(alias)\n             result.append(column)\n         return result\n+        return result\n \n     def get_distinct(self):\n         \"\"\"\n",
    "variant_2": "diff --git a/django/db/models/fields/related_lookups.py b/django/db/models/fields/related_lookups.py\nindex d745ecd5f9..f3bc29004a 100644\n--- a/django/db/models/fields/related_lookups.py\n+++ b/django/db/models/fields/related_lookups.py\n@@ -86,9 +86,16 @@ class RelatedIn(In):\n                     AND)\n             return root_constraint.as_sql(compiler, connection)\n         else:\n+\n             if (not getattr(self.rhs, 'has_select_fields', True) and\n                     not getattr(self.lhs.field.target_field, 'primary_key', False)):\n                 self.rhs.clear_select_clause()\n+                # Check if we're dealing with a subquery that has default_cols=True\n+                # which would cause all fields to be selected instead of just the target field\n+                if getattr(self.rhs, 'subquery', False) and getattr(self.rhs, 'default_cols', False):\n+                    # Force clearing the select clause to ensure only target field is used\n+                    self.rhs.clear_select_clause()\n+                \n                 if (getattr(self.lhs.output_field, 'primary_key', False) and\n                         self.lhs.output_field.model == self.rhs.model):\n                     # A case like Restaurant.objects.filter(place__in=restaurant_qs),\ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7264929da8..6702bb73f3 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -672,6 +672,7 @@ class SQLCompiler:\n             # Finally do cleanup - get rid of the joins we created above.\n             self.query.reset_refcounts(refcounts_before)\n \n+\n     def get_default_columns(self, start_alias=None, opts=None, from_parent=None):\n         \"\"\"\n         Compute the default columns for selecting every field in the base\n@@ -683,7 +684,27 @@ class SQLCompiler:\n         directly, as well as a set of aliases used in the select statement (if\n         'as_pairs' is True, return a list of (alias, col_name) pairs instead\n         of strings as the first component and None as the second component).\n+        \n+        For subqueries used in __in lookups, only the primary key is selected\n+        to avoid PostgreSQL's \"subquery must return only one column\" error.\n         \"\"\"\n+\n+        result = []\n+        if opts is None:\n+            opts = self.query.get_meta()\n+        only_load = self.deferred_to_columns()\n+        start_alias = start_alias or self.query.get_initial_alias()\n+        # The 'seen_models' is used to optimize checking the needed parent\n+        # alias for a given field. This also includes None -> start_alias to\n+        # be used by local fields.\n+        seen_models = {None: start_alias}\n+        \n+        # For subqueries used in __in lookups, only select the primary key\n+        # to avoid PostgreSQL's \"subquery must return only one column\" error\n+        is_subquery_for_in = getattr(self.query, 'subquery', False)\n+        seen_models = {None: start_alias}\n+\n+\n         result = []\n         if opts is None:\n             opts = self.query.get_meta()\n@@ -694,6 +715,21 @@ class SQLCompiler:\n         # be used by local fields.\n         seen_models = {None: start_alias}\n \n+        # For subqueries used in __in lookups, only select the primary key\n+        # to avoid PostgreSQL's \"subquery must return only one column\" error\n+        if self.query.subquery and hasattr(self.query, 'default_cols') and self.query.default_cols:\n+            # Only include the primary key field for subqueries\n+            pk_field = opts.pk\n+            if pk_field.model == opts.model:\n+                model = None\n+            else:\n+                model = pk_field.model._meta.concrete_model\n+            \n+            alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n+            column = pk_field.get_col(alias)\n+            result.append(column)\n+            return result\n+\n         for field in opts.concrete_fields:\n             model = field.model._meta.concrete_model\n             # A proxy model will have a different model and concrete_model. We\n",
    "variant_3": "diff --git a/django/db/models/fields/related_lookups.py b/django/db/models/fields/related_lookups.py\nindex d745ecd5f9..053e85f983 100644\n--- a/django/db/models/fields/related_lookups.py\n+++ b/django/db/models/fields/related_lookups.py\n@@ -85,10 +85,19 @@ class RelatedIn(In):\n                         [source.name for source in self.lhs.sources], self.rhs),\n                     AND)\n             return root_constraint.as_sql(compiler, connection)\n+        else:\n+\n         else:\n             if (not getattr(self.rhs, 'has_select_fields', True) and\n                     not getattr(self.lhs.field.target_field, 'primary_key', False)):\n                 self.rhs.clear_select_clause()\n+                # Check if this is a subquery context where we need to limit fields\n+                if (hasattr(self.rhs, 'query') and \n+                    getattr(self.rhs.query, 'subquery', False) and\n+                    getattr(self.rhs.query, 'default_cols', False)):\n+                    # Force single column selection for subqueries in __in lookups\n+                    self.rhs.query.default_cols = False\n+                \n                 if (getattr(self.lhs.output_field, 'primary_key', False) and\n                         self.lhs.output_field.model == self.rhs.model):\n                     # A case like Restaurant.objects.filter(place__in=restaurant_qs),\n@@ -99,6 +108,7 @@ class RelatedIn(In):\n                     target_field = self.lhs.field.target_field.name\n                 self.rhs.add_fields([target_field], True)\n             return super().as_sql(compiler, connection)\n+            return super().as_sql(compiler, connection)\n \n \n class RelatedLookupMixin:\ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7264929da8..a0574db062 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -672,6 +672,7 @@ class SQLCompiler:\n             # Finally do cleanup - get rid of the joins we created above.\n             self.query.reset_refcounts(refcounts_before)\n \n+\n     def get_default_columns(self, start_alias=None, opts=None, from_parent=None):\n         \"\"\"\n         Compute the default columns for selecting every field in the base\n@@ -683,6 +684,67 @@ class SQLCompiler:\n         directly, as well as a set of aliases used in the select statement (if\n         'as_pairs' is True, return a list of (alias, col_name) pairs instead\n         of strings as the first component and None as the second component).\n+        \n+        In subquery contexts (e.g., __in lookups), only select the primary key\n+        to avoid PostgreSQL's \"subquery must return only one column\" error.\n+        \"\"\"\n+        result = []\n+        if opts is None:\n+            opts = self.query.get_meta()\n+        only_load = self.deferred_to_columns()\n+        start_alias = start_alias or self.query.get_initial_alias()\n+        \n+        # Check if this is a subquery used in an __in lookup context\n+        # In such cases, we should only select the primary key field\n+        is_subquery_for_in_lookup = (\n+            getattr(self.query, 'subquery', False) and \n+            not hasattr(self.query, 'select_fields') and\n+            getattr(self.query, 'default_cols', False)\n+        )\n+        \n+        # The 'seen_models' is used to optimize checking the needed parent\n+        # alias for a given field. This also includes None -> start_alias to\n+        # be used by local fields.\n+        seen_models = {None: start_alias}\n+\n+        result = []\n+        if opts is None:\n+            opts = self.query.get_meta()\n+        only_load = self.deferred_to_columns()\n+        start_alias = start_alias or self.query.get_initial_alias()\n+        # The 'seen_models' is used to optimize checking the needed parent\n+        # alias for a given field. This also includes None -> start_alias to\n+        # be used by local fields.\n+        seen_models = {None: start_alias}\n+\n+        # For subqueries used in __in lookups, only select the primary key\n+        # to avoid PostgreSQL \"subquery must return only one column\" error\n+        if getattr(self.query, 'subquery', False) and not getattr(self.query, 'has_select_fields', False):\n+            pk_field = opts.pk\n+            model = pk_field.model._meta.concrete_model\n+            if model == opts.model:\n+                model = None\n+            alias = seen_models.get(model)\n+            if alias is None:\n+                alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n+            column = pk_field.get_col(alias)\n+            if as_pairs:\n+                result.append((alias, pk_field.column))\n+            else:\n+                result.append(column.as_sql(self, self.connection)[0])\n+            aliases = {alias} if alias else set()\n+            return result, aliases\n+            only_load = self.deferred_to_columns()\n+        start_alias = start_alias or self.query.get_initial_alias()\n+        # The 'seen_models' is used to optimize checking the needed parent\n+        # alias for a given field. This also includes None -> start_alias to\n+        # be used by local fields.\n+        seen_models = {None: start_alias}\n+\n+\n+    def get_default_columns(self, start_alias=None, opts=None, from_parent=None):\n+        \"\"\"\n+        Compute the default columns for SELECT.\n         \"\"\"\n         result = []\n         if opts is None:\n@@ -694,6 +756,20 @@ class SQLCompiler:\n         # be used by local fields.\n         seen_models = {None: start_alias}\n \n+        # For subqueries used in __in lookups, only select the primary key\n+        if getattr(self.query, 'subquery', False) and self.query.default_cols:\n+            # Check if this is likely an __in subquery by looking for single model selection\n+            if not hasattr(self.query, '_force_all_fields'):\n+                pk_field = opts.pk\n+                if pk_field.model == opts.model:\n+                    model = None\n+                else:\n+                    model = pk_field.model._meta.concrete_model\n+                alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n+                column = pk_field.get_col(alias)\n+                result.append(column)\n+                return result\n+\n         for field in opts.concrete_fields:\n             model = field.model._meta.concrete_model\n             # A proxy model will have a different model and concrete_model. We\n@@ -715,6 +791,7 @@ class SQLCompiler:\n             column = field.get_col(alias)\n             result.append(column)\n         return result\n+        return result\n \n     def get_distinct(self):\n         \"\"\"\n",
    "variant_4": "diff --git a/django/db/models/fields/related_lookups.py b/django/db/models/fields/related_lookups.py\nindex d745ecd5f9..d595a3f372 100644\n--- a/django/db/models/fields/related_lookups.py\n+++ b/django/db/models/fields/related_lookups.py\n@@ -86,18 +86,30 @@ class RelatedIn(In):\n                     AND)\n             return root_constraint.as_sql(compiler, connection)\n         else:\n+\n             if (not getattr(self.rhs, 'has_select_fields', True) and\n                     not getattr(self.lhs.field.target_field, 'primary_key', False)):\n                 self.rhs.clear_select_clause()\n-                if (getattr(self.lhs.output_field, 'primary_key', False) and\n+                # Check if we're in a subquery context that needs field limitation\n+                if (getattr(self.rhs, 'subquery', False) and \n+                    getattr(self.rhs, 'default_cols', False)):\n+                    # Force single column selection for subqueries\n+                    if (getattr(self.lhs.output_field, 'primary_key', False) and\n+                            self.lhs.output_field.model == self.rhs.model):\n+                        target_field = self.lhs.field.name\n+                    else:\n+                        target_field = self.lhs.field.target_field.name\n+                    self.rhs.add_fields([target_field], True)\n+                elif (getattr(self.lhs.output_field, 'primary_key', False) and\n                         self.lhs.output_field.model == self.rhs.model):\n                     # A case like Restaurant.objects.filter(place__in=restaurant_qs),\n                     # where place is a OneToOneField and the primary key of\n                     # Restaurant.\n                     target_field = self.lhs.field.name\n+                    self.rhs.add_fields([target_field], True)\n                 else:\n                     target_field = self.lhs.field.target_field.name\n-                self.rhs.add_fields([target_field], True)\n+                    self.rhs.add_fields([target_field], True)\n             return super().as_sql(compiler, connection)\n \n \ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7264929da8..590fe91e66 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -672,6 +672,7 @@ class SQLCompiler:\n             # Finally do cleanup - get rid of the joins we created above.\n             self.query.reset_refcounts(refcounts_before)\n \n+\n     def get_default_columns(self, start_alias=None, opts=None, from_parent=None):\n         \"\"\"\n         Compute the default columns for selecting every field in the base\n@@ -683,7 +684,11 @@ class SQLCompiler:\n         directly, as well as a set of aliases used in the select statement (if\n         'as_pairs' is True, return a list of (alias, col_name) pairs instead\n         of strings as the first component and None as the second component).\n+        \n+        For subqueries used in __in lookups, only the primary key is selected\n+        to avoid \"subquery must return only one column\" database errors.\n         \"\"\"\n+\n         result = []\n         if opts is None:\n             opts = self.query.get_meta()\n@@ -693,6 +698,61 @@ class SQLCompiler:\n         # alias for a given field. This also includes None -> start_alias to\n         # be used by local fields.\n         seen_models = {None: start_alias}\n+        \n+        # For subqueries used in __in lookups, only select the primary key\n+        if self.query.subquery and getattr(self.query, 'default_cols', False):\n+            # Check if this is likely an __in lookup subquery by examining the query context\n+            pk_field = opts.pk\n+            model = pk_field.model._meta.concrete_model\n+            if model == opts.model:\n+                model = None\n+            if model in seen_models:\n+                alias = seen_models[model]\n+            else:\n+                alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n+                seen_models[model] = alias\n+            \n+            column = pk_field.get_col(alias)\n+            if as_pairs:\n+                result.append((alias, pk_field.column))\n+            else:\n+                result.append(column.as_sql(self, self.connection)[0])\n+            \n+            aliases = {alias}\n+            if with_col_aliases:\n+                col_aliases = [pk_field.name]\n+                return result, aliases, col_aliases\n+            return result, aliases\n+        else:\n+            only_load = self.deferred_to_columns()\n+        start_alias = start_alias or self.query.get_initial_alias()\n+        # The 'seen_models' is used to optimize checking the needed parent\n+        # alias for a given field. This also includes None -> start_alias to\n+        # be used by local fields.\n+        seen_models = {None: start_alias}\n+\n+\n+        result = []\n+        if opts is None:\n+            opts = self.query.get_meta()\n+        only_load = self.deferred_to_columns()\n+        start_alias = start_alias or self.query.get_initial_alias()\n+        # The 'seen_models' is used to optimize checking the needed parent\n+        # alias for a given field. This also includes None -> start_alias to\n+        # be used by local fields.\n+        seen_models = {None: start_alias}\n+\n+        # For subqueries used in __in lookups, only select the primary key\n+        # to avoid PostgreSQL's \"subquery must return only one column\" error\n+        if getattr(self.query, 'subquery', False) and not hasattr(self.query, 'has_select_fields'):\n+            pk_field = opts.pk\n+            model = pk_field.model._meta.concrete_model\n+            if model == opts.model:\n+                model = None\n+            alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n+            column = pk_field.get_col(alias)\n+            result.append(column)\n+            return result\n \n         for field in opts.concrete_fields:\n             model = field.model._meta.concrete_model\n",
    "variant_5": "diff --git a/django/db/models/fields/related_lookups.py b/django/db/models/fields/related_lookups.py\nindex d745ecd5f9..483cee8e2e 100644\n--- a/django/db/models/fields/related_lookups.py\n+++ b/django/db/models/fields/related_lookups.py\n@@ -86,18 +86,28 @@ class RelatedIn(In):\n                     AND)\n             return root_constraint.as_sql(compiler, connection)\n         else:\n+\n             if (not getattr(self.rhs, 'has_select_fields', True) and\n                     not getattr(self.lhs.field.target_field, 'primary_key', False)):\n                 self.rhs.clear_select_clause()\n-                if (getattr(self.lhs.output_field, 'primary_key', False) and\n-                        self.lhs.output_field.model == self.rhs.model):\n-                    # A case like Restaurant.objects.filter(place__in=restaurant_qs),\n-                    # where place is a OneToOneField and the primary key of\n-                    # Restaurant.\n-                    target_field = self.lhs.field.name\n+                # Check if this is a subquery context where we need to limit fields\n+                if (getattr(self.rhs, 'subquery', False) or \n+                    (hasattr(self.rhs, 'query') and getattr(self.rhs.query, 'subquery', False))):\n+                    # In subquery context, only select the target field\n+                    if (getattr(self.lhs.output_field, 'primary_key', False) and\n+                            self.lhs.output_field.model == self.rhs.model):\n+                        target_field = self.lhs.field.name\n+                    else:\n+                        target_field = self.lhs.field.target_field.name\n+                    self.rhs.add_fields([target_field], True)\n                 else:\n-                    target_field = self.lhs.field.target_field.name\n-                self.rhs.add_fields([target_field], True)\n+                    # Original logic for non-subquery contexts\n+                    if (getattr(self.lhs.output_field, 'primary_key', False) and\n+                            self.lhs.output_field.model == self.rhs.model):\n+                        target_field = self.lhs.field.name\n+                    else:\n+                        target_field = self.lhs.field.target_field.name\n+                    self.rhs.add_fields([target_field], True)\n             return super().as_sql(compiler, connection)\n \n \ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7264929da8..b351371db0 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -672,6 +672,7 @@ class SQLCompiler:\n             # Finally do cleanup - get rid of the joins we created above.\n             self.query.reset_refcounts(refcounts_before)\n \n+\n     def get_default_columns(self, start_alias=None, opts=None, from_parent=None):\n         \"\"\"\n         Compute the default columns for selecting every field in the base\n@@ -683,6 +684,78 @@ class SQLCompiler:\n         directly, as well as a set of aliases used in the select statement (if\n         'as_pairs' is True, return a list of (alias, col_name) pairs instead\n         of strings as the first component and None as the second component).\n+        \n+        For subqueries used in __in lookups, only the primary key is selected\n+        to avoid PostgreSQL's \"subquery must return only one column\" error.\n+        \"\"\"\n+        result = []\n+        if opts is None:\n+            opts = self.query.get_meta()\n+        only_load = self.deferred_to_columns()\n+        start_alias = start_alias or self.query.get_initial_alias()\n+        \n+        # Check if this is a subquery that should only return primary key\n+        # This prevents \"subquery must return only one column\" errors\n+        is_subquery_for_in_lookup = (\n+            getattr(self.query, 'subquery', False) and\n+            not hasattr(self.query, 'select_fields') and\n+            getattr(self.query, 'default_cols', False)\n+        )\n+        \n+        # The 'seen_models' is used to optimize checking the needed parent\n+        # alias for a given field. This also includes None -> start_alias to\n+        # be used by local fields.\n+        seen_models = {None: start_alias}\n+\n+        result = []\n+        if opts is None:\n+            opts = self.query.get_meta()\n+        only_load = self.deferred_to_columns()\n+        start_alias = start_alias or self.query.get_initial_alias()\n+        # The 'seen_models' is used to optimize checking the needed parent\n+        # alias for a given field. This also includes None -> start_alias to\n+        # be used by local fields.\n+        seen_models = {None: start_alias}\n+\n+        # For subqueries used in __in lookups, only select the primary key\n+        # to avoid \"subquery must return only one column\" errors\n+        if (self.query.subquery and not self.query.select and \n+            hasattr(self.query, 'default_cols') and self.query.default_cols):\n+            pk_field = opts.pk\n+            if pk_field.model == opts.model:\n+                model = None\n+            else:\n+                model = pk_field.model._meta.concrete_model\n+            \n+            if model in seen_models:\n+                alias = seen_models[model]\n+            else:\n+                alias = self.query.join_parent_model(opts, model, start_alias,\n+                                                     seen_models)\n+                seen_models[model] = alias\n+            \n+            column = self.query.resolve_ref(pk_field.name, allow_joins=True, reuse=None, summarize=False)\n+            if as_pairs:\n+                result.append((alias, column.target.column))\n+            else:\n+                result.append(column.as_sql(self, self.connection)[0])\n+            \n+            # For subqueries, we don't need to process all fields\n+            return result, {alias}\n+        seen_models = {None: start_alias}\n+\n+\n+    def get_default_columns(self, start_alias=None, opts=None, from_parent=None):\n+        \"\"\"\n+        Compute the default columns for selecting every field in the base\n+        model. Will sometimes be called to pull in related models (e.g. via\n+        select_related), in which case \"opts\" and \"start_alias\" will be given\n+        to provide a starting point for the traversal.\n+\n+        Return a list of strings, quoted appropriately for use in SQL\n+        directly, as well as a list of extras to be added to the select.\n+\n+        reduce_unnecessary_sql() will remove any unused columns.\n         \"\"\"\n         result = []\n         if opts is None:\n@@ -694,6 +767,23 @@ class SQLCompiler:\n         # be used by local fields.\n         seen_models = {None: start_alias}\n \n+        # For subqueries used in __in lookups, we only need the primary key\n+        # to avoid \"subquery must return only one column\" errors\n+        if (self.query.subquery and \n+            hasattr(self.query, 'default_cols') and \n+            self.query.default_cols):\n+            # Only select the primary key field for subqueries\n+            pk_field = opts.pk\n+            if pk_field.model == opts.model:\n+                model = None\n+            else:\n+                model = pk_field.model._meta.concrete_model\n+            \n+            alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n+            column = pk_field.get_col(alias)\n+            result.append(column)\n+            return result\n+\n         for field in opts.concrete_fields:\n             model = field.model._meta.concrete_model\n             # A proxy model will have a different model and concrete_model. We\n@@ -715,6 +805,7 @@ class SQLCompiler:\n             column = field.get_col(alias)\n             result.append(column)\n         return result\n+        return result\n \n     def get_distinct(self):\n         \"\"\"\n",
    "variant_6": "diff --git a/django/db/models/fields/related_lookups.py b/django/db/models/fields/related_lookups.py\nindex d745ecd5f9..6cec40652b 100644\n--- a/django/db/models/fields/related_lookups.py\n+++ b/django/db/models/fields/related_lookups.py\n@@ -86,18 +86,30 @@ class RelatedIn(In):\n                     AND)\n             return root_constraint.as_sql(compiler, connection)\n         else:\n+\n             if (not getattr(self.rhs, 'has_select_fields', True) and\n                     not getattr(self.lhs.field.target_field, 'primary_key', False)):\n                 self.rhs.clear_select_clause()\n-                if (getattr(self.lhs.output_field, 'primary_key', False) and\n+                # Check if we're in a subquery context that needs field limiting\n+                if (getattr(self.rhs, 'subquery', False) and \n+                    getattr(self.rhs, 'default_cols', False)):\n+                    # Force single column selection for subqueries\n+                    if (getattr(self.lhs.output_field, 'primary_key', False) and\n+                            self.lhs.output_field.model == self.rhs.model):\n+                        target_field = self.lhs.field.name\n+                    else:\n+                        target_field = self.lhs.field.target_field.name\n+                    self.rhs.add_fields([target_field], True)\n+                elif (getattr(self.lhs.output_field, 'primary_key', False) and\n                         self.lhs.output_field.model == self.rhs.model):\n                     # A case like Restaurant.objects.filter(place__in=restaurant_qs),\n                     # where place is a OneToOneField and the primary key of\n                     # Restaurant.\n                     target_field = self.lhs.field.name\n+                    self.rhs.add_fields([target_field], True)\n                 else:\n                     target_field = self.lhs.field.target_field.name\n-                self.rhs.add_fields([target_field], True)\n+                    self.rhs.add_fields([target_field], True)\n             return super().as_sql(compiler, connection)\n \n \ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7264929da8..02ab350c6f 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -672,6 +672,7 @@ class SQLCompiler:\n             # Finally do cleanup - get rid of the joins we created above.\n             self.query.reset_refcounts(refcounts_before)\n \n+\n     def get_default_columns(self, start_alias=None, opts=None, from_parent=None):\n         \"\"\"\n         Compute the default columns for selecting every field in the base\n@@ -683,6 +684,65 @@ class SQLCompiler:\n         directly, as well as a set of aliases used in the select statement (if\n         'as_pairs' is True, return a list of (alias, col_name) pairs instead\n         of strings as the first component and None as the second component).\n+        \n+        For subqueries used in __in lookups, only the primary key is selected\n+        to avoid PostgreSQL's \"subquery must return only one column\" error.\n+        \"\"\"\n+        result = []\n+        if opts is None:\n+            opts = self.query.get_meta()\n+        only_load = self.deferred_to_columns()\n+        start_alias = start_alias or self.query.get_initial_alias()\n+        \n+        # Check if this is a subquery that should only select the primary key\n+        # This handles cases like Q(field__in=subquery) where PostgreSQL requires\n+        # exactly one column in the subquery\n+        is_subquery_for_in_lookup = (\n+            getattr(self.query, 'subquery', False) and \n+            not hasattr(self.query, 'select_fields') and\n+            not self.query.select and\n+            not self.query.annotations\n+        )\n+        \n+        # The 'seen_models' is used to optimize checking the needed parent\n+        # alias for a given field. This also includes None -> start_alias to\n+        # be used by local fields.\n+        seen_models = {None: start_alias}\n+\n+        result = []\n+        if opts is None:\n+            opts = self.query.get_meta()\n+        only_load = self.deferred_to_columns()\n+        start_alias = start_alias or self.query.get_initial_alias()\n+        # The 'seen_models' is used to optimize checking the needed parent\n+        # alias for a given field. This also includes None -> start_alias to\n+        # be used by local fields.\n+        seen_models = {None: start_alias}\n+        \n+        # Check if this is a subquery that should only select the primary key\n+        # This prevents \"subquery must return only one column\" errors in PostgreSQL\n+        is_subquery_for_in_lookup = (\n+            getattr(self.query, 'subquery', False) and \n+            not hasattr(self.query, 'has_select_fields')\n+        )\n+        start_alias = start_alias or self.query.get_initial_alias()\n+        # The 'seen_models' is used to optimize checking the needed parent\n+        # alias for a given field. This also includes None -> start_alias to\n+        # be used by local fields.\n+        seen_models = {None: start_alias}\n+\n+\n+    def get_default_columns(self, start_alias=None, opts=None, from_parent=None):\n+        \"\"\"\n+        Compute the default columns for selecting every field in the base\n+        model. Will sometimes be called to pull in related models (e.g. via\n+        select_related), in which case \"opts\" and \"start_alias\" will be given\n+        to provide a starting point for the traversal.\n+\n+        Return a list of strings, quoted appropriately for use in SQL\n+        directly, as well as a list of aliases used in the select statement (if\n+        'as_pairs' is True, return a list of (alias, col_name) pairs instead\n+        of strings as the first component and None as the second component).\n         \"\"\"\n         result = []\n         if opts is None:\n@@ -694,6 +754,26 @@ class SQLCompiler:\n         # be used by local fields.\n         seen_models = {None: start_alias}\n \n+        # For subqueries used in __in lookups, only select the primary key\n+        if (self.query.subquery and \n+            hasattr(self.query, 'default_cols') and \n+            self.query.default_cols and\n+            not hasattr(self.query, '_forced_pk_only')):\n+            # Only include primary key field for subqueries\n+            pk_field = opts.pk\n+            if pk_field.model._meta.concrete_model == opts.model:\n+                model = None\n+            else:\n+                model = pk_field.model._meta.concrete_model\n+            \n+            if not (from_parent and model is not None and issubclass(\n+                    from_parent._meta.concrete_model, model._meta.concrete_model)):\n+                if not (pk_field.model in only_load and pk_field.attname not in only_load[pk_field.model]):\n+                    alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n+                    column = pk_field.get_col(alias)\n+                    result.append(column)\n+            return result\n+\n         for field in opts.concrete_fields:\n             model = field.model._meta.concrete_model\n             # A proxy model will have a different model and concrete_model. We\n@@ -715,6 +795,7 @@ class SQLCompiler:\n             column = field.get_col(alias)\n             result.append(column)\n         return result\n+        return result\n \n     def get_distinct(self):\n         \"\"\"\n",
    "variant_7": "diff --git a/django/db/models/fields/related_lookups.py b/django/db/models/fields/related_lookups.py\nindex d745ecd5f9..bcc0d7027f 100644\n--- a/django/db/models/fields/related_lookups.py\n+++ b/django/db/models/fields/related_lookups.py\n@@ -86,18 +86,29 @@ class RelatedIn(In):\n                     AND)\n             return root_constraint.as_sql(compiler, connection)\n         else:\n+\n             if (not getattr(self.rhs, 'has_select_fields', True) and\n                     not getattr(self.lhs.field.target_field, 'primary_key', False)):\n                 self.rhs.clear_select_clause()\n-                if (getattr(self.lhs.output_field, 'primary_key', False) and\n+                # Check if we're in a subquery context that needs field limiting\n+                if getattr(self.rhs, 'subquery', False) and getattr(self.rhs, 'default_cols', False):\n+                    # Force selection of only the target field for subqueries\n+                    if (getattr(self.lhs.output_field, 'primary_key', False) and\n+                            self.lhs.output_field.model == self.rhs.model):\n+                        target_field = self.lhs.field.name\n+                    else:\n+                        target_field = self.lhs.field.target_field.name\n+                    self.rhs.add_fields([target_field], True)\n+                elif (getattr(self.lhs.output_field, 'primary_key', False) and\n                         self.lhs.output_field.model == self.rhs.model):\n                     # A case like Restaurant.objects.filter(place__in=restaurant_qs),\n                     # where place is a OneToOneField and the primary key of\n                     # Restaurant.\n                     target_field = self.lhs.field.name\n+                    self.rhs.add_fields([target_field], True)\n                 else:\n                     target_field = self.lhs.field.target_field.name\n-                self.rhs.add_fields([target_field], True)\n+                    self.rhs.add_fields([target_field], True)\n             return super().as_sql(compiler, connection)\n \n \ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7264929da8..26505fbd52 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -672,6 +672,7 @@ class SQLCompiler:\n             # Finally do cleanup - get rid of the joins we created above.\n             self.query.reset_refcounts(refcounts_before)\n \n+\n     def get_default_columns(self, start_alias=None, opts=None, from_parent=None):\n         \"\"\"\n         Compute the default columns for selecting every field in the base\n@@ -683,7 +684,12 @@ class SQLCompiler:\n         directly, as well as a set of aliases used in the select statement (if\n         'as_pairs' is True, return a list of (alias, col_name) pairs instead\n         of strings as the first component and None as the second component).\n+        \n+        When used in a subquery context (e.g., for __in lookups), only the\n+        primary key field will be selected to avoid PostgreSQL's \"subquery\n+        must return only one column\" error.\n         \"\"\"\n+\n         result = []\n         if opts is None:\n             opts = self.query.get_meta()\n@@ -693,6 +699,67 @@ class SQLCompiler:\n         # alias for a given field. This also includes None -> start_alias to\n         # be used by local fields.\n         seen_models = {None: start_alias}\n+        \n+        # For subqueries used in __in lookups, only select the primary key\n+        # to avoid PostgreSQL's \"subquery must return only one column\" error\n+        if self.query.subquery and not from_parent:\n+            # Check if this is likely an __in lookup subquery by examining\n+            # if we're selecting default columns with no explicit select_fields\n+            is_in_lookup_subquery = (\n+                getattr(self.query, 'default_cols', False) and\n+                not getattr(self.query, 'select', None)\n+            )\n+            if is_in_lookup_subquery:\n+                # Only include the primary key field for __in lookup subqueries\n+                pk_field = opts.pk\n+                if pk_field.column not in only_load:\n+                    alias = seen_models[None]\n+                    column = pk_field.column\n+                    if as_pairs:\n+                        result.append((alias, column))\n+                    else:\n+                        result.append(self.quote_name_unless_alias(column))\n+                return result, set()\n+                len(opts.concrete_fields) > 1):\n+                # Only load the primary key field for __in subqueries\n+                only_load = {opts.pk.name: opts.pk}\n+            else:\n+                only_load = self.deferred_to_columns()\n+        else:\n+            only_load = self.deferred_to_columns()\n+        start_alias = start_alias or self.query.get_initial_alias()\n+        # The 'seen_models' is used to optimize checking the needed parent\n+        # alias for a given field. This also includes None -> start_alias to\n+        # be used by local fields.\n+        seen_models = {None: start_alias}\n+\n+\n+    def get_default_columns(self, start_alias=None, opts=None, from_parent=None):\n+        \"\"\"\n+        Compute the default columns for SELECT.\n+        \"\"\"\n+        result = []\n+        if opts is None:\n+            opts = self.query.get_meta()\n+        only_load = self.deferred_to_columns()\n+        start_alias = start_alias or self.query.get_initial_alias()\n+        # The 'seen_models' is used to optimize checking the needed parent\n+        # alias for a given field. This also includes None -> start_alias to\n+        # be used by local fields.\n+        seen_models = {None: start_alias}\n+\n+        # For subqueries used in __in lookups, only select the primary key\n+        # to avoid PostgreSQL's \"subquery must return only one column\" error\n+        if getattr(self.query, 'subquery', False) and not hasattr(self.query, 'annotation_select'):\n+            pk_field = opts.pk\n+            if pk_field.model == opts.model:\n+                model = None\n+            else:\n+                model = pk_field.model._meta.concrete_model\n+            alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n+            column = pk_field.get_col(alias)\n+            result.append(column)\n+            return result\n \n         for field in opts.concrete_fields:\n             model = field.model._meta.concrete_model\n",
    "variant_8": "diff --git a/django/db/models/fields/related_lookups.py b/django/db/models/fields/related_lookups.py\nindex d745ecd5f9..f80f80828d 100644\n--- a/django/db/models/fields/related_lookups.py\n+++ b/django/db/models/fields/related_lookups.py\n@@ -86,18 +86,30 @@ class RelatedIn(In):\n                     AND)\n             return root_constraint.as_sql(compiler, connection)\n         else:\n+\n             if (not getattr(self.rhs, 'has_select_fields', True) and\n                     not getattr(self.lhs.field.target_field, 'primary_key', False)):\n                 self.rhs.clear_select_clause()\n-                if (getattr(self.lhs.output_field, 'primary_key', False) and\n+                # Check if we need to limit fields for subquery context\n+                if (getattr(self.rhs, 'subquery', False) and \n+                        getattr(self.rhs, 'default_cols', False)):\n+                    # In subquery context with default_cols, only select primary key\n+                    if (getattr(self.lhs.output_field, 'primary_key', False) and\n+                            self.lhs.output_field.model == self.rhs.model):\n+                        target_field = self.lhs.field.name\n+                    else:\n+                        target_field = self.lhs.field.target_field.name\n+                    self.rhs.add_fields([target_field], True)\n+                elif (getattr(self.lhs.output_field, 'primary_key', False) and\n                         self.lhs.output_field.model == self.rhs.model):\n                     # A case like Restaurant.objects.filter(place__in=restaurant_qs),\n                     # where place is a OneToOneField and the primary key of\n                     # Restaurant.\n                     target_field = self.lhs.field.name\n+                    self.rhs.add_fields([target_field], True)\n                 else:\n                     target_field = self.lhs.field.target_field.name\n-                self.rhs.add_fields([target_field], True)\n+                    self.rhs.add_fields([target_field], True)\n             return super().as_sql(compiler, connection)\n \n \ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7264929da8..bde4db4316 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -672,6 +672,7 @@ class SQLCompiler:\n             # Finally do cleanup - get rid of the joins we created above.\n             self.query.reset_refcounts(refcounts_before)\n \n+\n     def get_default_columns(self, start_alias=None, opts=None, from_parent=None):\n         \"\"\"\n         Compute the default columns for selecting every field in the base\n@@ -683,7 +684,49 @@ class SQLCompiler:\n         directly, as well as a set of aliases used in the select statement (if\n         'as_pairs' is True, return a list of (alias, col_name) pairs instead\n         of strings as the first component and None as the second component).\n+        \n+        For subqueries used in __in lookups, only the primary key is selected\n+        to ensure PostgreSQL compatibility.\n         \"\"\"\n+        result = []\n+        if opts is None:\n+            opts = self.query.get_meta()\n+        only_load = self.deferred_to_columns()\n+        start_alias = start_alias or self.query.get_initial_alias()\n+        \n+        # Check if this is a subquery that should only return the primary key\n+        # This prevents \"subquery must return only one column\" errors in PostgreSQL\n+        is_subquery_for_in_lookup = (\n+            getattr(self.query, 'subquery', False) and \n+            not getattr(self.query, 'has_select_fields', False) and\n+            hasattr(self.query, 'default_cols') and \n+            self.query.default_cols\n+        )\n+        \n+        # The 'seen_models' is used to optimize checking the needed parent\n+        # alias for a given field. This also includes None -> start_alias to\n+        # be used by local fields.\n+        seen_models = {None: start_alias}\n+\n+        result = []\n+        if opts is None:\n+            opts = self.query.get_meta()\n+        only_load = self.deferred_to_columns()\n+        start_alias = start_alias or self.query.get_initial_alias()\n+        # The 'seen_models' is used to optimize checking the needed parent\n+        # alias for a given field. This also includes None -> start_alias to\n+        # be used by local fields.\n+        seen_models = {None: start_alias}\n+        \n+        # Check if this is a subquery that should only return the primary key\n+        # This prevents \"subquery must return only one column\" errors in PostgreSQL\n+        is_subquery_for_in_lookup = (\n+            getattr(self.query, 'subquery', False) and\n+            not getattr(self.query, 'has_select_fields', False) and\n+            opts is not None\n+        )\n+\n+\n         result = []\n         if opts is None:\n             opts = self.query.get_meta()\n@@ -694,6 +737,27 @@ class SQLCompiler:\n         # be used by local fields.\n         seen_models = {None: start_alias}\n \n+        # For subqueries used in __in lookups, only select the primary key\n+        # to avoid \"subquery must return only one column\" errors\n+        if (self.query.subquery and \n+            hasattr(self.query, 'default_cols') and \n+            self.query.default_cols and\n+            len(opts.concrete_fields) > 1):\n+            # Only include the primary key field for subqueries\n+            pk_field = opts.pk\n+            if from_parent and pk_field.model != opts.model and issubclass(\n+                    from_parent._meta.concrete_model, pk_field.model._meta.concrete_model):\n+                return result\n+            if pk_field.model in only_load and pk_field.attname not in only_load[pk_field.model]:\n+                return result\n+            model = pk_field.model._meta.concrete_model\n+            if model == opts.model:\n+                model = None\n+            alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n+            column = pk_field.get_col(alias)\n+            result.append(column)\n+            return result\n+\n         for field in opts.concrete_fields:\n             model = field.model._meta.concrete_model\n             # A proxy model will have a different model and concrete_model. We\n"
  }
}