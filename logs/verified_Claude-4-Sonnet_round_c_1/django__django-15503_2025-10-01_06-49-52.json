{
  "zero_patches": {
    "Location 1 (/root/hy/projects/django/django/db/models/fields/json.py lines 129-139)": "\ndef compile_json_path(key_transforms, include_root=True):\n    path = [\"$\"] if include_root else []\n    for key_transform in key_transforms:\n        if isinstance(key_transform, int):\n            path.append(\"[%s]\" % key_transform)\n        else:\n            path.append(\".\")\n            path.append(json.dumps(str(key_transform)))\n    return \"\".join(path)\n",
    "Location 2 (/root/hy/projects/django/django/db/models/fields/json.py lines 175-206)": "\ndef compile_json_path(key_transforms, include_root=True):\n    path = [\"$\"] if include_root else []\n    for key_transform in key_transforms:\n        if isinstance(key_transform, int):\n            path.append(\"[%s]\" % key_transform)\n        else:\n            path.append(\".\")\n            path.append(json.dumps(str(key_transform)))\n    return \"\".join(path)\n",
    "Location 3 (/root/hy/projects/django/django/db/models/fields/json.py lines 208-218)": "\ndef as_mysql(self, compiler, connection):\n    return self.as_sql(\n        compiler, connection, template=\"JSON_CONTAINS_PATH(%s, 'one', %%s)\"\n    )\n\ndef as_oracle(self, compiler, connection):\n    sql, params = self.as_sql(\n        compiler, connection, template=\"JSON_EXISTS(%s, '%%s')\"\n    )\n    # Add paths directly into SQL because path expressions cannot be passed\n    # as bind variables on Oracle.\n    return sql % tuple(params), []\n",
    "Location 4 (/root/hy/projects/django/django/db/models/fields/json.py lines 221-231)": "\ndef compile_json_path(key_transforms, include_root=True):\n    path = [\"$\"] if include_root else []\n    for key_transform in key_transforms:\n        # Only treat as array index if it's actually an integer type\n        if isinstance(key_transform, int):\n            path.append(\"[%s]\" % key_transform)\n        else:\n            # For string keys (including numeric strings), treat as object property\n            path.append(\".\")\n            path.append(json.dumps(str(key_transform)))\n    return \"\".join(path)\n",
    "Location 5 (/root/hy/projects/django/tests/model_fields/test_jsonfield.py lines 509-520)": "\ndef test_has_key_numeric_string(self):\n    \"\"\"Test has_key lookup with numeric string keys.\"\"\"\n    obj = NullableJSONModel.objects.create(value={\"1111\": \"bar\", \"0\": \"zero\", \"123\": \"test\"})\n    \n    # Test numeric string keys work as object keys, not array indices\n    self.assertSequenceEqual(\n        NullableJSONModel.objects.filter(value__has_key=\"1111\"),\n        [obj],\n    )\n    self.assertSequenceEqual(\n        NullableJSONModel.objects.filter(value__has_key=\"0\"),\n        [obj],\n    )\n    self.assertSequenceEqual(\n        NullableJSONModel.objects.filter(value__has_key=\"123\"),\n        [obj],\n    )\n    \n    # Verify non-existent numeric string keys return empty\n    self.assertSequenceEqual(\n        NullableJSONModel.objects.filter(value__has_key=\"999\"),\n        [],\n    )\n\ndef test_has_key(self):\n    self.assertSequenceEqual(\n        NullableJSONModel.objects.filter(value__has_key=\"a\"),\n        [self.objs[3], self.objs[4]],\n    )\n\ndef test_has_key_null_value(self):\n    self.assertSequenceEqual(\n        NullableJSONModel.objects.filter(value__has_key=\"j\"),\n        [self.objs[4]],\n    )\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/django/django/db/models/fields/json.py lines 129-139)": [
      "\ndef compile_json_path(key_transforms, include_root=True):\n    path = [\"$\"] if include_root else []\n    for key_transform in key_transforms:\n        if isinstance(key_transform, int):\n            path.append(\"[%s]\" % key_transform)\n        else:\n            path.append(\".\")\n            path.append(json.dumps(str(key_transform)))\n    return \"\".join(path)\n",
      "\ndef compile_json_path(key_transforms, include_root=True):\n    path = [\"$\"] if include_root else []\n    for key_transform in key_transforms:\n        if isinstance(key_transform, int):\n            path.append(\"[%s]\" % key_transform)\n        else:\n            path.append(\".\")\n            path.append(json.dumps(str(key_transform)))\n    return \"\".join(path)\n",
      "\ndef compile_json_path(key_transforms, include_root=True):\n    path = [\"$\"] if include_root else []\n    for key_transform in key_transforms:\n        if isinstance(key_transform, int):\n            path.append(\"[%s]\" % key_transform)\n        else:\n            path.append(\".\")\n            path.append(json.dumps(str(key_transform)))\n    return \"\".join(path)\n",
      "\ndef compile_json_path(key_transforms, include_root=True):\n    path = [\"$\"] if include_root else []\n    for key_transform in key_transforms:\n        if isinstance(key_transform, int):\n            path.append(\"[%s]\" % key_transform)\n        else:\n            path.append(\".\")\n            path.append(json.dumps(str(key_transform)))\n    return \"\".join(path)\n",
      "\ndef compile_json_path(key_transforms, include_root=True):\n    path = [\"$\"] if include_root else []\n    for key_transform in key_transforms:\n        if isinstance(key_transform, int):\n            path.append(\"[%s]\" % key_transform)\n        else:\n            path.append(\".\")\n            path.append(json.dumps(str(key_transform)))\n    return \"\".join(path)\n",
      "\ndef compile_json_path(key_transforms, include_root=True):\n    path = [\"$\"] if include_root else []\n    for key_transform in key_transforms:\n        if isinstance(key_transform, int):\n            path.append(\"[%s]\" % key_transform)\n        else:\n            path.append(\".\")\n            path.append(json.dumps(str(key_transform)))\n    return \"\".join(path)\n",
      "\ndef compile_json_path(key_transforms, include_root=True):\n    path = [\"$\"] if include_root else []\n    for key_transform in key_transforms:\n        if isinstance(key_transform, int):\n            path.append(\"[%s]\" % key_transform)\n        else:\n            path.append(\".\")\n            path.append(json.dumps(str(key_transform)))\n    return \"\".join(path)\n",
      "\ndef compile_json_path(key_transforms, include_root=True):\n    path = [\"$\"] if include_root else []\n    for key_transform in key_transforms:\n        if isinstance(key_transform, int):\n            path.append(\"[%s]\" % key_transform)\n        else:\n            path.append(\".\")\n            path.append(json.dumps(str(key_transform)))\n    return \"\".join(path)\n"
    ],
    "Location 2 (/root/hy/projects/django/django/db/models/fields/json.py lines 175-206)": [
      "\ndef compile_json_path(key_transforms, include_root=True):\n    path = [\"$\"] if include_root else []\n    for key_transform in key_transforms:\n        if isinstance(key_transform, int):\n            path.append(\"[%s]\" % key_transform)\n        else:\n            path.append(\".\")\n            path.append(json.dumps(str(key_transform)))\n    return \"\".join(path)\n",
      "\ndef compile_json_path(key_transforms, include_root=True):\n    path = [\"$\"] if include_root else []\n    for key_transform in key_transforms:\n        if isinstance(key_transform, int):\n            path.append(\"[%s]\" % key_transform)\n        else:\n            path.append(\".\")\n            path.append(json.dumps(str(key_transform)))\n    return \"\".join(path)\n",
      "\n    def as_sql(self, compiler, connection, template=None):\n        # Process JSON path from the left-hand side.\n        if isinstance(self.lhs, KeyTransform):\n            lhs, lhs_params, lhs_key_transforms = self.lhs.preprocess_lhs(\n                compiler, connection\n            )\n            lhs_json_path = compile_json_path(lhs_key_transforms)\n        else:\n            lhs, lhs_params = self.process_lhs(compiler, connection)\n            lhs_json_path = \"$\"\n        sql = template % lhs\n        # Process JSON path from the right-hand side.\n        rhs = self.rhs\n        rhs_params = []\n        if not isinstance(rhs, (list, tuple)):\n            rhs = [rhs]\n        for key in rhs:\n            if isinstance(key, KeyTransform):\n                *_, rhs_key_transforms = key.preprocess_lhs(compiler, connection)\n            else:\n                # Ensure string keys remain as strings, not converted to integers\n                rhs_key_transforms = [str(key)]\n            rhs_params.append(\n                \"%s%s\"\n                % (\n                    lhs_json_path,\n                    compile_json_path(rhs_key_transforms, include_root=False),\n                )\n            )\n        # Add condition for each key.\n        if self.logical_operator:\n            sql = \"(%s)\" % self.logical_operator.join([sql] * len(rhs_params))\n        return sql, tuple(lhs_params) + tuple(rhs_params)\n",
      "\ndef compile_json_path(key_transforms, include_root=True):\n    path = [\"$\"] if include_root else []\n    for key_transform in key_transforms:\n        if isinstance(key_transform, int):\n            path.append(\"[%s]\" % key_transform)\n        else:\n            path.append(\".\")\n            path.append(json.dumps(str(key_transform)))\n    return \"\".join(path)\n",
      "\ndef compile_json_path(key_transforms, include_root=True):\n    path = [\"$\"] if include_root else []\n    for key_transform in key_transforms:\n        if isinstance(key_transform, int):\n            # For actual integer keys, use array index syntax\n            path.append(\"[%s]\" % key_transform)\n        else:\n            # For string keys (including numeric strings), use object property syntax\n            path.append(\".\")\n            path.append(json.dumps(str(key_transform)))\n    return \"\".join(path)\n",
      "\ndef compile_json_path(key_transforms, include_root=True):\n    path = [\"$\"] if include_root else []\n    for key_transform in key_transforms:\n        if isinstance(key_transform, int):\n            path.append(\"[%s]\" % key_transform)\n        else:\n            path.append(\".\")\n            path.append(json.dumps(str(key_transform)))\n    return \"\".join(path)\n",
      "\ndef compile_json_path(key_transforms, include_root=True):\n    path = [\"$\"] if include_root else []\n    for key_transform in key_transforms:\n        if isinstance(key_transform, int):\n            path.append(\"[%s]\" % key_transform)\n        else:\n            path.append(\".\")\n            path.append(json.dumps(str(key_transform)))\n    return \"\".join(path)\n\n\nclass HasKeyLookup(PostgresOperatorLookup):\n    logical_operator = None\n\n    def as_sql(self, compiler, connection, template=None):\n        # Process JSON path from the left-hand side.\n        if isinstance(self.lhs, KeyTransform):\n            lhs, lhs_params, lhs_key_transforms = self.lhs.preprocess_lhs(\n                compiler, connection\n            )\n            lhs_json_path = compile_json_path(lhs_key_transforms)\n        else:\n            lhs, lhs_params = self.process_lhs(compiler, connection)\n            lhs_json_path = \"$\"\n        sql = template % lhs\n        # Process JSON path from the right-hand side.\n        rhs = self.rhs\n        rhs_params = []\n        if not isinstance(rhs, (list, tuple)):\n            rhs = [rhs]\n        for key in rhs:\n            if isinstance(key, KeyTransform):\n                *_, rhs_key_transforms = key.preprocess_lhs(compiler, connection)\n            else:\n                rhs_key_transforms = [key]\n            rhs_params.append(\n                \"%s%s\"\n                % (\n                    lhs_json_path,\n                    compile_json_path(rhs_key_transforms, include_root=False),\n                )\n            )\n        # Add condition for each key.\n        if self.logical_operator:\n            sql = \"(%s)\" % self.logical_operator.join([sql] * len(rhs_params))\n        return sql, tuple(lhs_params) + tuple(rhs_params)\n",
      "\ndef compile_json_path(key_transforms, include_root=True):\n    path = [\"$\"] if include_root else []\n    for key_transform in key_transforms:\n        if isinstance(key_transform, int):\n            path.append(\"[%s]\" % key_transform)\n        else:\n            path.append(\".\")\n            path.append(json.dumps(str(key_transform)))\n    return \"\".join(path)\n"
    ],
    "Location 3 (/root/hy/projects/django/django/db/models/fields/json.py lines 208-218)": [
      "\n    def as_mysql(self, compiler, connection):\n        return self.as_sql(\n            compiler, connection, template=\"JSON_CONTAINS_PATH(%s, 'one', %%s)\"\n        )\n\n    def as_oracle(self, compiler, connection):\n        sql, params = self.as_sql(\n            compiler, connection, template=\"JSON_EXISTS(%s, '%%s')\"\n        )\n        # Add paths directly into SQL because path expressions cannot be passed\n        # as bind variables on Oracle.\n        return sql % tuple(params), []\n",
      "\ndef as_mysql(self, compiler, connection):\n    return self.as_sql(\n        compiler, connection, template=\"JSON_CONTAINS_PATH(%s, 'one', %%s)\"\n    )\n\ndef as_oracle(self, compiler, connection):\n    sql, params = self.as_sql(\n        compiler, connection, template=\"JSON_EXISTS(%s, '%%s')\"\n    )\n    # Add paths directly into SQL because path expressions cannot be passed\n    # as bind variables on Oracle.\n    return sql % tuple(params), []\n",
      "\ndef as_mysql(self, compiler, connection):\n    return self.as_sql(\n        compiler, connection, template=\"JSON_CONTAINS_PATH(%s, 'one', %%s)\"\n    )\n\ndef as_oracle(self, compiler, connection):\n    sql, params = self.as_sql(\n        compiler, connection, template=\"JSON_EXISTS(%s, '%%s')\"\n    )\n    # Add paths directly into SQL because path expressions cannot be passed\n    # as bind variables on Oracle.\n    return sql % tuple(params), []\n",
      "\ndef as_mysql(self, compiler, connection):\n    return self.as_sql(\n        compiler, connection, template=\"JSON_CONTAINS_PATH(%s, 'one', %%s)\"\n    )\n\ndef as_oracle(self, compiler, connection):\n    sql, params = self.as_sql(\n        compiler, connection, template=\"JSON_EXISTS(%s, '%%s')\"\n    )\n    # Add paths directly into SQL because path expressions cannot be passed\n    # as bind variables on Oracle.\n    return sql % tuple(params), []\n",
      "\ndef as_mysql(self, compiler, connection):\n    return self.as_sql(\n        compiler, connection, template=\"JSON_CONTAINS_PATH(%s, 'one', %%s)\"\n    )\n\ndef as_oracle(self, compiler, connection):\n    sql, params = self.as_sql(\n        compiler, connection, template=\"JSON_EXISTS(%s, '%%s')\"\n    )\n    # Add paths directly into SQL because path expressions cannot be passed\n    # as bind variables on Oracle.\n    return sql % tuple(params), []\n",
      "\ndef as_mysql(self, compiler, connection):\n    return self.as_sql(\n        compiler, connection, template=\"JSON_CONTAINS_PATH(%s, 'one', %%s)\"\n    )\n\ndef as_oracle(self, compiler, connection):\n    sql, params = self.as_sql(\n        compiler, connection, template=\"JSON_EXISTS(%s, '%%s')\"\n    )\n    # Add paths directly into SQL because path expressions cannot be passed\n    # as bind variables on Oracle.\n    return sql % tuple(params), []\n",
      "\ndef as_mysql(self, compiler, connection):\n    return self.as_sql(\n        compiler, connection, template=\"JSON_CONTAINS_PATH(%s, 'one', %%s)\"\n    )\n\ndef as_oracle(self, compiler, connection):\n    sql, params = self.as_sql(\n        compiler, connection, template=\"JSON_EXISTS(%s, '%%s')\"\n    )\n    # Add paths directly into SQL because path expressions cannot be passed\n    # as bind variables on Oracle.\n    return sql % tuple(params), []\n",
      "\n    def as_mysql(self, compiler, connection):\n        return self.as_sql(\n            compiler, connection, template=\"JSON_CONTAINS_PATH(%s, 'one', %%s)\"\n        )\n\n    def as_oracle(self, compiler, connection):\n        sql, params = self.as_sql(\n            compiler, connection, template=\"JSON_EXISTS(%s, '%%s')\"\n        )\n        # Add paths directly into SQL because path expressions cannot be passed\n        # as bind variables on Oracle.\n        return sql % tuple(json.dumps(param) for param in params), []\n"
    ],
    "Location 4 (/root/hy/projects/django/django/db/models/fields/json.py lines 221-231)": [
      "\ndef compile_json_path(key_transforms, include_root=True):\n    path = [\"$\"] if include_root else []\n    for key_transform in key_transforms:\n        if isinstance(key_transform, int):\n            path.append(\"[%s]\" % key_transform)\n        else:\n            path.append(\".\")\n            path.append(json.dumps(str(key_transform)))\n    return \"\".join(path)\n",
      "\ndef compile_json_path(key_transforms, include_root=True):\n    path = [\"$\"] if include_root else []\n    for key_transform in key_transforms:\n        if isinstance(key_transform, int):\n            path.append(\"[%s]\" % key_transform)\n        else:\n            path.append(\".\")\n            path.append(json.dumps(str(key_transform)))\n    return \"\".join(path)\n",
      "\ndef compile_json_path(key_transforms, include_root=True):\n    path = [\"$\"] if include_root else []\n    for key_transform in key_transforms:\n        if isinstance(key_transform, int):\n            path.append(\"[%s]\" % key_transform)\n        else:\n            path.append(\".\")\n            path.append(json.dumps(str(key_transform)))\n    return \"\".join(path)\n",
      "\ndef compile_json_path(key_transforms, include_root=True):\n    path = [\"$\"] if include_root else []\n    for key_transform in key_transforms:\n        if isinstance(key_transform, int):\n            path.append(\"[%s]\" % key_transform)\n        else:\n            path.append(\".\")\n            path.append(json.dumps(str(key_transform)))\n    return \"\".join(path)\n",
      "\ndef compile_json_path(key_transforms, include_root=True):\n    path = [\"$\"] if include_root else []\n    for key_transform in key_transforms:\n        if isinstance(key_transform, int):\n            path.append(\"[%s]\" % key_transform)\n        else:\n            path.append(\".\")\n            path.append(json.dumps(str(key_transform)))\n    return \"\".join(path)\n",
      "\ndef compile_json_path(key_transforms, include_root=True):\n    path = [\"$\"] if include_root else []\n    for key_transform in key_transforms:\n        if isinstance(key_transform, int):\n            path.append(\"[%s]\" % key_transform)\n        else:\n            path.append(\".\")\n            path.append(json.dumps(str(key_transform)))\n    return \"\".join(path)\n",
      "\ndef compile_json_path(key_transforms, include_root=True):\n    path = [\"$\"] if include_root else []\n    for key_transform in key_transforms:\n        # Only treat actual integer types as array indices\n        # String keys that happen to contain digits should be treated as object keys\n        if isinstance(key_transform, int):\n            path.append(\"[%s]\" % key_transform)\n        else:\n            path.append(\".\")\n            path.append(json.dumps(str(key_transform)))\n    return \"\".join(path)\n",
      "\ndef compile_json_path(key_transforms, include_root=True):\n    path = [\"$\"] if include_root else []\n    for key_transform in key_transforms:\n        if isinstance(key_transform, int):\n            path.append(\"[%s]\" % key_transform)\n        else:\n            path.append(\".\")\n            path.append(json.dumps(str(key_transform)))\n    return \"\".join(path)\n"
    ],
    "Location 5 (/root/hy/projects/django/tests/model_fields/test_jsonfield.py lines 509-520)": [
      "\ndef test_has_key_numeric_string(self):\n    \"\"\"Test has_key lookup with numeric string keys.\"\"\"\n    obj = NullableJSONModel.objects.create(value={\"1111\": \"bar\", \"0\": \"zero\", \"123\": \"test\"})\n    \n    # Test numeric string keys are treated as object keys, not array indices\n    self.assertEqual(\n        NullableJSONModel.objects.filter(value__has_key=\"1111\").count(), 1\n    )\n    self.assertEqual(\n        NullableJSONModel.objects.filter(value__has_key=\"0\").count(), 1\n    )\n    self.assertEqual(\n        NullableJSONModel.objects.filter(value__has_key=\"123\").count(), 1\n    )\n    \n    # Test that non-existent numeric string keys return empty results\n    self.assertEqual(\n        NullableJSONModel.objects.filter(value__has_key=\"9999\").count(), 0\n    )\n",
      "\ndef test_has_key_numeric_string(self):\n    # Test data with numeric string keys\n    obj = NullableJSONModel.objects.create(value={\"1111\": \"bar\", \"0\": \"zero\", \"123\": \"test\"})\n    \n    # Test each numeric string key\n    self.assertEqual(\n        NullableJSONModel.objects.filter(value__has_key=\"1111\").count(), 1\n    )\n    self.assertEqual(\n        NullableJSONModel.objects.filter(value__has_key=\"0\").count(), 1  \n    )\n    self.assertEqual(\n        NullableJSONModel.objects.filter(value__has_key=\"123\").count(), 1\n    )\n",
      "\ndef test_has_key_numeric_string(self):\n    \"\"\"Test has_key lookup with numeric string keys.\"\"\"\n    obj = NullableJSONModel.objects.create(value={\"1111\": \"bar\", \"0\": \"zero\", \"123\": \"test\"})\n    \n    # Test numeric string keys are treated as object keys, not array indices\n    self.assertSequenceEqual(\n        NullableJSONModel.objects.filter(value__has_key=\"1111\"),\n        [obj],\n    )\n    self.assertSequenceEqual(\n        NullableJSONModel.objects.filter(value__has_key=\"0\"),\n        [obj],\n    )\n    self.assertSequenceEqual(\n        NullableJSONModel.objects.filter(value__has_key=\"123\"),\n        [obj],\n    )\n",
      "\ndef test_has_key(self):\n    self.assertSequenceEqual(\n        NullableJSONModel.objects.filter(value__has_key=\"a\"),\n        [self.objs[3], self.objs[4]],\n    )\n\ndef test_has_key_null_value(self):\n    self.assertSequenceEqual(\n        NullableJSONModel.objects.filter(value__has_key=\"j\"),\n        [self.objs[4]],\n    )\n\ndef test_has_key_numeric_string(self):\n    # Test data with numeric string keys\n    obj = NullableJSONModel.objects.create(value={\"1111\": \"bar\", \"0\": \"zero\", \"123\": \"test\"})\n    \n    # Test each numeric string key\n    self.assertEqual(\n        NullableJSONModel.objects.filter(value__has_key=\"1111\").count(), 1\n    )\n    self.assertEqual(\n        NullableJSONModel.objects.filter(value__has_key=\"0\").count(), 1  \n    )\n    self.assertEqual(\n        NullableJSONModel.objects.filter(value__has_key=\"123\").count(), 1\n    )\n",
      "\ndef test_has_key_numeric_string(self):\n    \"\"\"Test has_key lookup with numeric string keys.\"\"\"\n    obj = NullableJSONModel.objects.create(value={\"1111\": \"bar\", \"0\": \"zero\", \"123\": \"test\"})\n    \n    # Test each numeric string key\n    self.assertEqual(\n        NullableJSONModel.objects.filter(value__has_key=\"1111\").count(), 1\n    )\n    self.assertEqual(\n        NullableJSONModel.objects.filter(value__has_key=\"0\").count(), 1\n    )\n    self.assertEqual(\n        NullableJSONModel.objects.filter(value__has_key=\"123\").count(), 1\n    )\n    \n    # Verify that actual integer keys still work for array access\n    array_obj = NullableJSONModel.objects.create(value=[\"first\", \"second\", \"third\"])\n    self.assertEqual(\n        NullableJSONModel.objects.filter(value__has_key=1).count(), 1\n    )\n\ndef test_has_key_null_value(self):\n    self.assertSequenceEqual(\n        NullableJSONModel.objects.filter(value__has_key=\"j\"),\n        [self.objs[4]],\n    )\n",
      "\ndef test_has_key_numeric_string(self):\n    # Test data with numeric string keys\n    obj = NullableJSONModel.objects.create(value={\"1111\": \"bar\", \"0\": \"zero\", \"123\": \"test\"})\n    \n    # Test each numeric string key\n    self.assertEqual(\n        NullableJSONModel.objects.filter(value__has_key=\"1111\").count(), 1\n    )\n    self.assertEqual(\n        NullableJSONModel.objects.filter(value__has_key=\"0\").count(), 1  \n    )\n    self.assertEqual(\n        NullableJSONModel.objects.filter(value__has_key=\"123\").count(), 1\n    )\n    \n    # Test mixed object with both numeric string keys and array\n    mixed_obj = NullableJSONModel.objects.create(value={\"456\": \"string_key\", \"arr\": [1, 2, 3]})\n    self.assertEqual(\n        NullableJSONModel.objects.filter(value__has_key=\"456\").count(), 1\n    )\n",
      "\ndef test_has_key_numeric_string(self):\n    obj = NullableJSONModel.objects.create(value={\"1111\": \"bar\", \"0\": \"zero\", \"123\": \"test\"})\n    \n    # Test numeric string keys are treated as object keys, not array indices\n    self.assertEqual(\n        NullableJSONModel.objects.filter(value__has_key=\"1111\").count(), 1\n    )\n    self.assertEqual(\n        NullableJSONModel.objects.filter(value__has_key=\"0\").count(), 1\n    )\n    self.assertEqual(\n        NullableJSONModel.objects.filter(value__has_key=\"123\").count(), 1\n    )\n    \n    # Verify the objects are returned correctly\n    self.assertSequenceEqual(\n        NullableJSONModel.objects.filter(value__has_key=\"1111\"),\n        [obj],\n    )\n\ndef test_has_key_mixed_keys(self):\n    # Test object with both numeric string keys and regular string keys\n    obj = NullableJSONModel.objects.create(value={\"1111\": \"numeric\", \"name\": \"string\"})\n    \n    self.assertEqual(\n        NullableJSONModel.objects.filter(value__has_key=\"1111\").count(), 1\n    )\n    self.assertEqual(\n        NullableJSONModel.objects.filter(value__has_key=\"name\").count(), 1\n    )\n",
      "\ndef test_has_key_numeric_string(self):\n    \"\"\"Test has_key lookup with numeric string keys like '1111', '0', '123'.\"\"\"\n    obj = NullableJSONModel.objects.create(value={\"1111\": \"bar\", \"0\": \"zero\", \"123\": \"test\"})\n    \n    # Test numeric string keys are treated as object keys, not array indices\n    self.assertEqual(\n        NullableJSONModel.objects.filter(value__has_key=\"1111\").count(), 1\n    )\n    self.assertEqual(\n        NullableJSONModel.objects.filter(value__has_key=\"0\").count(), 1\n    )\n    self.assertEqual(\n        NullableJSONModel.objects.filter(value__has_key=\"123\").count(), 1\n    )\n    \n    # Verify non-existent numeric string keys return empty results\n    self.assertEqual(\n        NullableJSONModel.objects.filter(value__has_key=\"9999\").count(), 0\n    )\n\ndef test_has_key(self):\n    self.assertSequenceEqual(\n        NullableJSONModel.objects.filter(value__has_key=\"a\"),\n        [self.objs[3], self.objs[4]],\n    )\n\ndef test_has_key_null_value(self):\n    self.assertSequenceEqual(\n        NullableJSONModel.objects.filter(value__has_key=\"j\"),\n        [self.objs[4]],\n    )\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex fdca700c9d..90174d9fe0 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -126,16 +126,15 @@ class JSONField(CheckFieldDefaultMixin, Field):\n         )\n \n \n+\n def compile_json_path(key_transforms, include_root=True):\n     path = [\"$\"] if include_root else []\n     for key_transform in key_transforms:\n-        try:\n-            num = int(key_transform)\n-        except ValueError:  # non-integer\n-            path.append(\".\")\n-            path.append(json.dumps(key_transform))\n+        if isinstance(key_transform, int):\n+            path.append(\"[%s]\" % key_transform)\n         else:\n-            path.append(\"[%s]\" % num)\n+            path.append(\".\")\n+            path.append(json.dumps(str(key_transform)))\n     return \"\".join(path)\n \n \n@@ -172,6 +171,7 @@ class ContainedBy(PostgresOperatorLookup):\n class HasKeyLookup(PostgresOperatorLookup):\n     logical_operator = None\n \n+\n     def as_sql(self, compiler, connection, template=None):\n         # Process JSON path from the left-hand side.\n         if isinstance(self.lhs, KeyTransform):\n@@ -205,6 +205,7 @@ class HasKeyLookup(PostgresOperatorLookup):\n             sql = \"(%s)\" % self.logical_operator.join([sql] * len(rhs_params))\n         return sql, tuple(lhs_params) + tuple(rhs_params)\n \n+\n     def as_mysql(self, compiler, connection):\n         return self.as_sql(\n             compiler, connection, template=\"JSON_CONTAINS_PATH(%s, 'one', %%s)\"\n@@ -218,6 +219,7 @@ class HasKeyLookup(PostgresOperatorLookup):\n         # as bind variables on Oracle.\n         return sql % tuple(params), []\n \n+\n     def as_postgresql(self, compiler, connection):\n         if isinstance(self.rhs, KeyTransform):\n             *_, rhs_key_transforms = self.rhs.preprocess_lhs(compiler, connection)\ndiff --git a/tests/model_fields/test_jsonfield.py b/tests/model_fields/test_jsonfield.py\nindex dfd00f4745..b786f050e7 100644\n--- a/tests/model_fields/test_jsonfield.py\n+++ b/tests/model_fields/test_jsonfield.py\n@@ -506,6 +506,7 @@ class TestQuerying(TestCase):\n             self.objs[3:5],\n         )\n \n+\n     def test_has_key(self):\n         self.assertSequenceEqual(\n             NullableJSONModel.objects.filter(value__has_key=\"a\"),\n@@ -518,6 +519,21 @@ class TestQuerying(TestCase):\n             [self.objs[4]],\n         )\n \n+    def test_has_key_numeric_string(self):\n+        # Test data with numeric string keys to verify the fix for the bug\n+        # where numeric string keys were incorrectly treated as array indices\n+        obj = NullableJSONModel.objects.create(value={\"1111\": \"bar\", \"0\": \"zero\", \"123\": \"test\"})\n+        \n+        # Test each numeric string key\n+        self.assertEqual(\n+            NullableJSONModel.objects.filter(value__has_key=\"1111\").count(), 1\n+        )\n+        self.assertEqual(\n+            NullableJSONModel.objects.filter(value__has_key=\"0\").count(), 1\n+        )\n+        self.assertEqual(\n+            NullableJSONModel.objects.filter(value__has_key=\"123\").count(), 1\n+        )\n     def test_has_key_deep(self):\n         tests = [\n             (Q(value__baz__has_key=\"a\"), self.objs[7]),\n",
    "variant_0": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex fdca700c9d..e9035dd284 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -126,16 +126,15 @@ class JSONField(CheckFieldDefaultMixin, Field):\n         )\n \n \n+\n def compile_json_path(key_transforms, include_root=True):\n     path = [\"$\"] if include_root else []\n     for key_transform in key_transforms:\n-        try:\n-            num = int(key_transform)\n-        except ValueError:  # non-integer\n-            path.append(\".\")\n-            path.append(json.dumps(key_transform))\n+        if isinstance(key_transform, int):\n+            path.append(\"[%s]\" % key_transform)\n         else:\n-            path.append(\"[%s]\" % num)\n+            path.append(\".\")\n+            path.append(json.dumps(str(key_transform)))\n     return \"\".join(path)\n \n \n@@ -172,63 +171,44 @@ class ContainedBy(PostgresOperatorLookup):\n class HasKeyLookup(PostgresOperatorLookup):\n     logical_operator = None\n \n-    def as_sql(self, compiler, connection, template=None):\n-        # Process JSON path from the left-hand side.\n-        if isinstance(self.lhs, KeyTransform):\n-            lhs, lhs_params, lhs_key_transforms = self.lhs.preprocess_lhs(\n-                compiler, connection\n-            )\n-            lhs_json_path = compile_json_path(lhs_key_transforms)\n+\n+def compile_json_path(key_transforms, include_root=True):\n+    path = [\"$\"] if include_root else []\n+    for key_transform in key_transforms:\n+        if isinstance(key_transform, int):\n+            path.append(\"[%s]\" % key_transform)\n         else:\n-            lhs, lhs_params = self.process_lhs(compiler, connection)\n-            lhs_json_path = \"$\"\n-        sql = template % lhs\n-        # Process JSON path from the right-hand side.\n-        rhs = self.rhs\n-        rhs_params = []\n-        if not isinstance(rhs, (list, tuple)):\n-            rhs = [rhs]\n-        for key in rhs:\n-            if isinstance(key, KeyTransform):\n-                *_, rhs_key_transforms = key.preprocess_lhs(compiler, connection)\n-            else:\n-                rhs_key_transforms = [key]\n-            rhs_params.append(\n-                \"%s%s\"\n-                % (\n-                    lhs_json_path,\n-                    compile_json_path(rhs_key_transforms, include_root=False),\n-                )\n-            )\n-        # Add condition for each key.\n-        if self.logical_operator:\n-            sql = \"(%s)\" % self.logical_operator.join([sql] * len(rhs_params))\n-        return sql, tuple(lhs_params) + tuple(rhs_params)\n+            path.append(\".\")\n+            path.append(json.dumps(str(key_transform)))\n+    return \"\".join(path)\n \n-    def as_mysql(self, compiler, connection):\n-        return self.as_sql(\n-            compiler, connection, template=\"JSON_CONTAINS_PATH(%s, 'one', %%s)\"\n-        )\n \n-    def as_oracle(self, compiler, connection):\n-        sql, params = self.as_sql(\n-            compiler, connection, template=\"JSON_EXISTS(%s, '%%s')\"\n-        )\n-        # Add paths directly into SQL because path expressions cannot be passed\n-        # as bind variables on Oracle.\n+def as_mysql(self, compiler, connection):\n+    return self.as_sql(\n+        compiler, connection, template=\"JSON_CONTAINS_PATH(%s, 'one', %%s)\"\n+    )\n+\n+def as_oracle(self, compiler, connection):\n+    sql, params = self.as_sql(\n+        compiler, connection, template=\"JSON_EXISTS(%s, '%%s')\"\n+    )\n+    # Add paths directly into SQL because path expressions cannot be passed\n+    # as bind variables on Oracle.\n+    return sql % tuple(params), []\n         return sql % tuple(params), []\n \n-    def as_postgresql(self, compiler, connection):\n-        if isinstance(self.rhs, KeyTransform):\n-            *_, rhs_key_transforms = self.rhs.preprocess_lhs(compiler, connection)\n-            for key in rhs_key_transforms[:-1]:\n-                self.lhs = KeyTransform(key, self.lhs)\n-            self.rhs = rhs_key_transforms[-1]\n-        return super().as_postgresql(compiler, connection)\n \n-    def as_sqlite(self, compiler, connection):\n-        return self.as_sql(\n-            compiler, connection, template=\"JSON_TYPE(%s, %%s) IS NOT NULL\"\n+def compile_json_path(key_transforms, include_root=True):\n+    path = [\"$\"] if include_root else []\n+    for key_transform in key_transforms:\n+        # Only treat as array index if it's actually an integer type\n+        if isinstance(key_transform, int):\n+            path.append(\"[%s]\" % key_transform)\n+        else:\n+            # For string keys (including numeric strings), treat as object property\n+            path.append(\".\")\n+            path.append(json.dumps(str(key_transform)))\n+    return \"\".join(path)\n         )\n \n \ndiff --git a/tests/model_fields/test_jsonfield.py b/tests/model_fields/test_jsonfield.py\nindex dfd00f4745..6dece8568e 100644\n--- a/tests/model_fields/test_jsonfield.py\n+++ b/tests/model_fields/test_jsonfield.py\n@@ -506,18 +506,42 @@ class TestQuerying(TestCase):\n             self.objs[3:5],\n         )\n \n-    def test_has_key(self):\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__has_key=\"a\"),\n-            [self.objs[3], self.objs[4]],\n-        )\n \n-    def test_has_key_null_value(self):\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__has_key=\"j\"),\n-            [self.objs[4]],\n-        )\n+def test_has_key_numeric_string(self):\n+    \"\"\"Test has_key lookup with numeric string keys.\"\"\"\n+    obj = NullableJSONModel.objects.create(value={\"1111\": \"bar\", \"0\": \"zero\", \"123\": \"test\"})\n+    \n+    # Test numeric string keys work as object keys, not array indices\n+    self.assertSequenceEqual(\n+        NullableJSONModel.objects.filter(value__has_key=\"1111\"),\n+        [obj],\n+    )\n+    self.assertSequenceEqual(\n+        NullableJSONModel.objects.filter(value__has_key=\"0\"),\n+        [obj],\n+    )\n+    self.assertSequenceEqual(\n+        NullableJSONModel.objects.filter(value__has_key=\"123\"),\n+        [obj],\n+    )\n+    \n+    # Verify non-existent numeric string keys return empty\n+    self.assertSequenceEqual(\n+        NullableJSONModel.objects.filter(value__has_key=\"999\"),\n+        [],\n+    )\n \n+def test_has_key(self):\n+    self.assertSequenceEqual(\n+        NullableJSONModel.objects.filter(value__has_key=\"a\"),\n+        [self.objs[3], self.objs[4]],\n+    )\n+\n+def test_has_key_null_value(self):\n+    self.assertSequenceEqual(\n+        NullableJSONModel.objects.filter(value__has_key=\"j\"),\n+        [self.objs[4]],\n+    )\n     def test_has_key_deep(self):\n         tests = [\n             (Q(value__baz__has_key=\"a\"), self.objs[7]),\n",
    "variant_1": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex fdca700c9d..69894b76ef 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -126,16 +126,15 @@ class JSONField(CheckFieldDefaultMixin, Field):\n         )\n \n \n+\n def compile_json_path(key_transforms, include_root=True):\n     path = [\"$\"] if include_root else []\n     for key_transform in key_transforms:\n-        try:\n-            num = int(key_transform)\n-        except ValueError:  # non-integer\n-            path.append(\".\")\n-            path.append(json.dumps(key_transform))\n+        if isinstance(key_transform, int):\n+            path.append(\"[%s]\" % key_transform)\n         else:\n-            path.append(\"[%s]\" % num)\n+            path.append(\".\")\n+            path.append(json.dumps(str(key_transform)))\n     return \"\".join(path)\n \n \n@@ -172,38 +171,17 @@ class ContainedBy(PostgresOperatorLookup):\n class HasKeyLookup(PostgresOperatorLookup):\n     logical_operator = None\n \n-    def as_sql(self, compiler, connection, template=None):\n-        # Process JSON path from the left-hand side.\n-        if isinstance(self.lhs, KeyTransform):\n-            lhs, lhs_params, lhs_key_transforms = self.lhs.preprocess_lhs(\n-                compiler, connection\n-            )\n-            lhs_json_path = compile_json_path(lhs_key_transforms)\n+\n+def compile_json_path(key_transforms, include_root=True):\n+    path = [\"$\"] if include_root else []\n+    for key_transform in key_transforms:\n+        if isinstance(key_transform, int):\n+            path.append(\"[%s]\" % key_transform)\n         else:\n-            lhs, lhs_params = self.process_lhs(compiler, connection)\n-            lhs_json_path = \"$\"\n-        sql = template % lhs\n-        # Process JSON path from the right-hand side.\n-        rhs = self.rhs\n-        rhs_params = []\n-        if not isinstance(rhs, (list, tuple)):\n-            rhs = [rhs]\n-        for key in rhs:\n-            if isinstance(key, KeyTransform):\n-                *_, rhs_key_transforms = key.preprocess_lhs(compiler, connection)\n-            else:\n-                rhs_key_transforms = [key]\n-            rhs_params.append(\n-                \"%s%s\"\n-                % (\n-                    lhs_json_path,\n-                    compile_json_path(rhs_key_transforms, include_root=False),\n-                )\n-            )\n-        # Add condition for each key.\n-        if self.logical_operator:\n-            sql = \"(%s)\" % self.logical_operator.join([sql] * len(rhs_params))\n-        return sql, tuple(lhs_params) + tuple(rhs_params)\n+            path.append(\".\")\n+            path.append(json.dumps(str(key_transform)))\n+    return \"\".join(path)\n+\n \n     def as_mysql(self, compiler, connection):\n         return self.as_sql(\n@@ -217,18 +195,18 @@ class HasKeyLookup(PostgresOperatorLookup):\n         # Add paths directly into SQL because path expressions cannot be passed\n         # as bind variables on Oracle.\n         return sql % tuple(params), []\n+        return sql % tuple(params), []\n \n-    def as_postgresql(self, compiler, connection):\n-        if isinstance(self.rhs, KeyTransform):\n-            *_, rhs_key_transforms = self.rhs.preprocess_lhs(compiler, connection)\n-            for key in rhs_key_transforms[:-1]:\n-                self.lhs = KeyTransform(key, self.lhs)\n-            self.rhs = rhs_key_transforms[-1]\n-        return super().as_postgresql(compiler, connection)\n \n-    def as_sqlite(self, compiler, connection):\n-        return self.as_sql(\n-            compiler, connection, template=\"JSON_TYPE(%s, %%s) IS NOT NULL\"\n+def compile_json_path(key_transforms, include_root=True):\n+    path = [\"$\"] if include_root else []\n+    for key_transform in key_transforms:\n+        if isinstance(key_transform, int):\n+            path.append(\"[%s]\" % key_transform)\n+        else:\n+            path.append(\".\")\n+            path.append(json.dumps(str(key_transform)))\n+    return \"\".join(path)\n         )\n \n \ndiff --git a/tests/model_fields/test_jsonfield.py b/tests/model_fields/test_jsonfield.py\nindex dfd00f4745..41b8f048fa 100644\n--- a/tests/model_fields/test_jsonfield.py\n+++ b/tests/model_fields/test_jsonfield.py\n@@ -506,18 +506,26 @@ class TestQuerying(TestCase):\n             self.objs[3:5],\n         )\n \n-    def test_has_key(self):\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__has_key=\"a\"),\n-            [self.objs[3], self.objs[4]],\n-        )\n-\n-    def test_has_key_null_value(self):\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__has_key=\"j\"),\n-            [self.objs[4]],\n-        )\n \n+def test_has_key_numeric_string(self):\n+    \"\"\"Test has_key lookup with numeric string keys.\"\"\"\n+    obj = NullableJSONModel.objects.create(value={\"1111\": \"bar\", \"0\": \"zero\", \"123\": \"test\"})\n+    \n+    # Test numeric string keys are treated as object keys, not array indices\n+    self.assertEqual(\n+        NullableJSONModel.objects.filter(value__has_key=\"1111\").count(), 1\n+    )\n+    self.assertEqual(\n+        NullableJSONModel.objects.filter(value__has_key=\"0\").count(), 1\n+    )\n+    self.assertEqual(\n+        NullableJSONModel.objects.filter(value__has_key=\"123\").count(), 1\n+    )\n+    \n+    # Test that non-existent numeric string keys return empty results\n+    self.assertEqual(\n+        NullableJSONModel.objects.filter(value__has_key=\"9999\").count(), 0\n+    )\n     def test_has_key_deep(self):\n         tests = [\n             (Q(value__baz__has_key=\"a\"), self.objs[7]),\n",
    "variant_2": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex fdca700c9d..08bf4cef99 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -126,16 +126,15 @@ class JSONField(CheckFieldDefaultMixin, Field):\n         )\n \n \n+\n def compile_json_path(key_transforms, include_root=True):\n     path = [\"$\"] if include_root else []\n     for key_transform in key_transforms:\n-        try:\n-            num = int(key_transform)\n-        except ValueError:  # non-integer\n-            path.append(\".\")\n-            path.append(json.dumps(key_transform))\n+        if isinstance(key_transform, int):\n+            path.append(\"[%s]\" % key_transform)\n         else:\n-            path.append(\"[%s]\" % num)\n+            path.append(\".\")\n+            path.append(json.dumps(str(key_transform)))\n     return \"\".join(path)\n \n \n@@ -172,63 +171,42 @@ class ContainedBy(PostgresOperatorLookup):\n class HasKeyLookup(PostgresOperatorLookup):\n     logical_operator = None\n \n-    def as_sql(self, compiler, connection, template=None):\n-        # Process JSON path from the left-hand side.\n-        if isinstance(self.lhs, KeyTransform):\n-            lhs, lhs_params, lhs_key_transforms = self.lhs.preprocess_lhs(\n-                compiler, connection\n-            )\n-            lhs_json_path = compile_json_path(lhs_key_transforms)\n+\n+def compile_json_path(key_transforms, include_root=True):\n+    path = [\"$\"] if include_root else []\n+    for key_transform in key_transforms:\n+        if isinstance(key_transform, int):\n+            path.append(\"[%s]\" % key_transform)\n         else:\n-            lhs, lhs_params = self.process_lhs(compiler, connection)\n-            lhs_json_path = \"$\"\n-        sql = template % lhs\n-        # Process JSON path from the right-hand side.\n-        rhs = self.rhs\n-        rhs_params = []\n-        if not isinstance(rhs, (list, tuple)):\n-            rhs = [rhs]\n-        for key in rhs:\n-            if isinstance(key, KeyTransform):\n-                *_, rhs_key_transforms = key.preprocess_lhs(compiler, connection)\n-            else:\n-                rhs_key_transforms = [key]\n-            rhs_params.append(\n-                \"%s%s\"\n-                % (\n-                    lhs_json_path,\n-                    compile_json_path(rhs_key_transforms, include_root=False),\n-                )\n-            )\n-        # Add condition for each key.\n-        if self.logical_operator:\n-            sql = \"(%s)\" % self.logical_operator.join([sql] * len(rhs_params))\n-        return sql, tuple(lhs_params) + tuple(rhs_params)\n+            path.append(\".\")\n+            path.append(json.dumps(str(key_transform)))\n+    return \"\".join(path)\n \n-    def as_mysql(self, compiler, connection):\n-        return self.as_sql(\n-            compiler, connection, template=\"JSON_CONTAINS_PATH(%s, 'one', %%s)\"\n-        )\n \n-    def as_oracle(self, compiler, connection):\n-        sql, params = self.as_sql(\n-            compiler, connection, template=\"JSON_EXISTS(%s, '%%s')\"\n-        )\n-        # Add paths directly into SQL because path expressions cannot be passed\n-        # as bind variables on Oracle.\n+def as_mysql(self, compiler, connection):\n+    return self.as_sql(\n+        compiler, connection, template=\"JSON_CONTAINS_PATH(%s, 'one', %%s)\"\n+    )\n+\n+def as_oracle(self, compiler, connection):\n+    sql, params = self.as_sql(\n+        compiler, connection, template=\"JSON_EXISTS(%s, '%%s')\"\n+    )\n+    # Add paths directly into SQL because path expressions cannot be passed\n+    # as bind variables on Oracle.\n+    return sql % tuple(params), []\n         return sql % tuple(params), []\n \n-    def as_postgresql(self, compiler, connection):\n-        if isinstance(self.rhs, KeyTransform):\n-            *_, rhs_key_transforms = self.rhs.preprocess_lhs(compiler, connection)\n-            for key in rhs_key_transforms[:-1]:\n-                self.lhs = KeyTransform(key, self.lhs)\n-            self.rhs = rhs_key_transforms[-1]\n-        return super().as_postgresql(compiler, connection)\n \n-    def as_sqlite(self, compiler, connection):\n-        return self.as_sql(\n-            compiler, connection, template=\"JSON_TYPE(%s, %%s) IS NOT NULL\"\n+def compile_json_path(key_transforms, include_root=True):\n+    path = [\"$\"] if include_root else []\n+    for key_transform in key_transforms:\n+        if isinstance(key_transform, int):\n+            path.append(\"[%s]\" % key_transform)\n+        else:\n+            path.append(\".\")\n+            path.append(json.dumps(str(key_transform)))\n+    return \"\".join(path)\n         )\n \n \ndiff --git a/tests/model_fields/test_jsonfield.py b/tests/model_fields/test_jsonfield.py\nindex dfd00f4745..f1bae7a2b9 100644\n--- a/tests/model_fields/test_jsonfield.py\n+++ b/tests/model_fields/test_jsonfield.py\n@@ -506,18 +506,21 @@ class TestQuerying(TestCase):\n             self.objs[3:5],\n         )\n \n-    def test_has_key(self):\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__has_key=\"a\"),\n-            [self.objs[3], self.objs[4]],\n-        )\n-\n-    def test_has_key_null_value(self):\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__has_key=\"j\"),\n-            [self.objs[4]],\n-        )\n \n+def test_has_key_numeric_string(self):\n+    # Test data with numeric string keys\n+    obj = NullableJSONModel.objects.create(value={\"1111\": \"bar\", \"0\": \"zero\", \"123\": \"test\"})\n+    \n+    # Test each numeric string key\n+    self.assertEqual(\n+        NullableJSONModel.objects.filter(value__has_key=\"1111\").count(), 1\n+    )\n+    self.assertEqual(\n+        NullableJSONModel.objects.filter(value__has_key=\"0\").count(), 1  \n+    )\n+    self.assertEqual(\n+        NullableJSONModel.objects.filter(value__has_key=\"123\").count(), 1\n+    )\n     def test_has_key_deep(self):\n         tests = [\n             (Q(value__baz__has_key=\"a\"), self.objs[7]),\n",
    "variant_3": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex fdca700c9d..6edc8f95d7 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -126,16 +126,15 @@ class JSONField(CheckFieldDefaultMixin, Field):\n         )\n \n \n+\n def compile_json_path(key_transforms, include_root=True):\n     path = [\"$\"] if include_root else []\n     for key_transform in key_transforms:\n-        try:\n-            num = int(key_transform)\n-        except ValueError:  # non-integer\n-            path.append(\".\")\n-            path.append(json.dumps(key_transform))\n+        if isinstance(key_transform, int):\n+            path.append(\"[%s]\" % key_transform)\n         else:\n-            path.append(\"[%s]\" % num)\n+            path.append(\".\")\n+            path.append(json.dumps(str(key_transform)))\n     return \"\".join(path)\n \n \n@@ -172,6 +171,7 @@ class ContainedBy(PostgresOperatorLookup):\n class HasKeyLookup(PostgresOperatorLookup):\n     logical_operator = None\n \n+\n     def as_sql(self, compiler, connection, template=None):\n         # Process JSON path from the left-hand side.\n         if isinstance(self.lhs, KeyTransform):\n@@ -192,7 +192,8 @@ class HasKeyLookup(PostgresOperatorLookup):\n             if isinstance(key, KeyTransform):\n                 *_, rhs_key_transforms = key.preprocess_lhs(compiler, connection)\n             else:\n-                rhs_key_transforms = [key]\n+                # Ensure string keys remain as strings, not converted to integers\n+                rhs_key_transforms = [str(key)]\n             rhs_params.append(\n                 \"%s%s\"\n                 % (\n@@ -205,30 +206,31 @@ class HasKeyLookup(PostgresOperatorLookup):\n             sql = \"(%s)\" % self.logical_operator.join([sql] * len(rhs_params))\n         return sql, tuple(lhs_params) + tuple(rhs_params)\n \n-    def as_mysql(self, compiler, connection):\n-        return self.as_sql(\n-            compiler, connection, template=\"JSON_CONTAINS_PATH(%s, 'one', %%s)\"\n-        )\n \n-    def as_oracle(self, compiler, connection):\n-        sql, params = self.as_sql(\n-            compiler, connection, template=\"JSON_EXISTS(%s, '%%s')\"\n-        )\n-        # Add paths directly into SQL because path expressions cannot be passed\n-        # as bind variables on Oracle.\n+def as_mysql(self, compiler, connection):\n+    return self.as_sql(\n+        compiler, connection, template=\"JSON_CONTAINS_PATH(%s, 'one', %%s)\"\n+    )\n+\n+def as_oracle(self, compiler, connection):\n+    sql, params = self.as_sql(\n+        compiler, connection, template=\"JSON_EXISTS(%s, '%%s')\"\n+    )\n+    # Add paths directly into SQL because path expressions cannot be passed\n+    # as bind variables on Oracle.\n+    return sql % tuple(params), []\n         return sql % tuple(params), []\n \n-    def as_postgresql(self, compiler, connection):\n-        if isinstance(self.rhs, KeyTransform):\n-            *_, rhs_key_transforms = self.rhs.preprocess_lhs(compiler, connection)\n-            for key in rhs_key_transforms[:-1]:\n-                self.lhs = KeyTransform(key, self.lhs)\n-            self.rhs = rhs_key_transforms[-1]\n-        return super().as_postgresql(compiler, connection)\n \n-    def as_sqlite(self, compiler, connection):\n-        return self.as_sql(\n-            compiler, connection, template=\"JSON_TYPE(%s, %%s) IS NOT NULL\"\n+def compile_json_path(key_transforms, include_root=True):\n+    path = [\"$\"] if include_root else []\n+    for key_transform in key_transforms:\n+        if isinstance(key_transform, int):\n+            path.append(\"[%s]\" % key_transform)\n+        else:\n+            path.append(\".\")\n+            path.append(json.dumps(str(key_transform)))\n+    return \"\".join(path)\n         )\n \n \ndiff --git a/tests/model_fields/test_jsonfield.py b/tests/model_fields/test_jsonfield.py\nindex dfd00f4745..63941da27c 100644\n--- a/tests/model_fields/test_jsonfield.py\n+++ b/tests/model_fields/test_jsonfield.py\n@@ -506,18 +506,24 @@ class TestQuerying(TestCase):\n             self.objs[3:5],\n         )\n \n-    def test_has_key(self):\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__has_key=\"a\"),\n-            [self.objs[3], self.objs[4]],\n-        )\n-\n-    def test_has_key_null_value(self):\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__has_key=\"j\"),\n-            [self.objs[4]],\n-        )\n \n+def test_has_key_numeric_string(self):\n+    \"\"\"Test has_key lookup with numeric string keys.\"\"\"\n+    obj = NullableJSONModel.objects.create(value={\"1111\": \"bar\", \"0\": \"zero\", \"123\": \"test\"})\n+    \n+    # Test numeric string keys are treated as object keys, not array indices\n+    self.assertSequenceEqual(\n+        NullableJSONModel.objects.filter(value__has_key=\"1111\"),\n+        [obj],\n+    )\n+    self.assertSequenceEqual(\n+        NullableJSONModel.objects.filter(value__has_key=\"0\"),\n+        [obj],\n+    )\n+    self.assertSequenceEqual(\n+        NullableJSONModel.objects.filter(value__has_key=\"123\"),\n+        [obj],\n+    )\n     def test_has_key_deep(self):\n         tests = [\n             (Q(value__baz__has_key=\"a\"), self.objs[7]),\n",
    "variant_4": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex fdca700c9d..08bf4cef99 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -126,16 +126,15 @@ class JSONField(CheckFieldDefaultMixin, Field):\n         )\n \n \n+\n def compile_json_path(key_transforms, include_root=True):\n     path = [\"$\"] if include_root else []\n     for key_transform in key_transforms:\n-        try:\n-            num = int(key_transform)\n-        except ValueError:  # non-integer\n-            path.append(\".\")\n-            path.append(json.dumps(key_transform))\n+        if isinstance(key_transform, int):\n+            path.append(\"[%s]\" % key_transform)\n         else:\n-            path.append(\"[%s]\" % num)\n+            path.append(\".\")\n+            path.append(json.dumps(str(key_transform)))\n     return \"\".join(path)\n \n \n@@ -172,63 +171,42 @@ class ContainedBy(PostgresOperatorLookup):\n class HasKeyLookup(PostgresOperatorLookup):\n     logical_operator = None\n \n-    def as_sql(self, compiler, connection, template=None):\n-        # Process JSON path from the left-hand side.\n-        if isinstance(self.lhs, KeyTransform):\n-            lhs, lhs_params, lhs_key_transforms = self.lhs.preprocess_lhs(\n-                compiler, connection\n-            )\n-            lhs_json_path = compile_json_path(lhs_key_transforms)\n+\n+def compile_json_path(key_transforms, include_root=True):\n+    path = [\"$\"] if include_root else []\n+    for key_transform in key_transforms:\n+        if isinstance(key_transform, int):\n+            path.append(\"[%s]\" % key_transform)\n         else:\n-            lhs, lhs_params = self.process_lhs(compiler, connection)\n-            lhs_json_path = \"$\"\n-        sql = template % lhs\n-        # Process JSON path from the right-hand side.\n-        rhs = self.rhs\n-        rhs_params = []\n-        if not isinstance(rhs, (list, tuple)):\n-            rhs = [rhs]\n-        for key in rhs:\n-            if isinstance(key, KeyTransform):\n-                *_, rhs_key_transforms = key.preprocess_lhs(compiler, connection)\n-            else:\n-                rhs_key_transforms = [key]\n-            rhs_params.append(\n-                \"%s%s\"\n-                % (\n-                    lhs_json_path,\n-                    compile_json_path(rhs_key_transforms, include_root=False),\n-                )\n-            )\n-        # Add condition for each key.\n-        if self.logical_operator:\n-            sql = \"(%s)\" % self.logical_operator.join([sql] * len(rhs_params))\n-        return sql, tuple(lhs_params) + tuple(rhs_params)\n+            path.append(\".\")\n+            path.append(json.dumps(str(key_transform)))\n+    return \"\".join(path)\n \n-    def as_mysql(self, compiler, connection):\n-        return self.as_sql(\n-            compiler, connection, template=\"JSON_CONTAINS_PATH(%s, 'one', %%s)\"\n-        )\n \n-    def as_oracle(self, compiler, connection):\n-        sql, params = self.as_sql(\n-            compiler, connection, template=\"JSON_EXISTS(%s, '%%s')\"\n-        )\n-        # Add paths directly into SQL because path expressions cannot be passed\n-        # as bind variables on Oracle.\n+def as_mysql(self, compiler, connection):\n+    return self.as_sql(\n+        compiler, connection, template=\"JSON_CONTAINS_PATH(%s, 'one', %%s)\"\n+    )\n+\n+def as_oracle(self, compiler, connection):\n+    sql, params = self.as_sql(\n+        compiler, connection, template=\"JSON_EXISTS(%s, '%%s')\"\n+    )\n+    # Add paths directly into SQL because path expressions cannot be passed\n+    # as bind variables on Oracle.\n+    return sql % tuple(params), []\n         return sql % tuple(params), []\n \n-    def as_postgresql(self, compiler, connection):\n-        if isinstance(self.rhs, KeyTransform):\n-            *_, rhs_key_transforms = self.rhs.preprocess_lhs(compiler, connection)\n-            for key in rhs_key_transforms[:-1]:\n-                self.lhs = KeyTransform(key, self.lhs)\n-            self.rhs = rhs_key_transforms[-1]\n-        return super().as_postgresql(compiler, connection)\n \n-    def as_sqlite(self, compiler, connection):\n-        return self.as_sql(\n-            compiler, connection, template=\"JSON_TYPE(%s, %%s) IS NOT NULL\"\n+def compile_json_path(key_transforms, include_root=True):\n+    path = [\"$\"] if include_root else []\n+    for key_transform in key_transforms:\n+        if isinstance(key_transform, int):\n+            path.append(\"[%s]\" % key_transform)\n+        else:\n+            path.append(\".\")\n+            path.append(json.dumps(str(key_transform)))\n+    return \"\".join(path)\n         )\n \n \ndiff --git a/tests/model_fields/test_jsonfield.py b/tests/model_fields/test_jsonfield.py\nindex dfd00f4745..cbac75eb79 100644\n--- a/tests/model_fields/test_jsonfield.py\n+++ b/tests/model_fields/test_jsonfield.py\n@@ -506,18 +506,33 @@ class TestQuerying(TestCase):\n             self.objs[3:5],\n         )\n \n-    def test_has_key(self):\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__has_key=\"a\"),\n-            [self.objs[3], self.objs[4]],\n-        )\n \n-    def test_has_key_null_value(self):\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__has_key=\"j\"),\n-            [self.objs[4]],\n-        )\n+def test_has_key(self):\n+    self.assertSequenceEqual(\n+        NullableJSONModel.objects.filter(value__has_key=\"a\"),\n+        [self.objs[3], self.objs[4]],\n+    )\n+\n+def test_has_key_null_value(self):\n+    self.assertSequenceEqual(\n+        NullableJSONModel.objects.filter(value__has_key=\"j\"),\n+        [self.objs[4]],\n+    )\n \n+def test_has_key_numeric_string(self):\n+    # Test data with numeric string keys\n+    obj = NullableJSONModel.objects.create(value={\"1111\": \"bar\", \"0\": \"zero\", \"123\": \"test\"})\n+    \n+    # Test each numeric string key\n+    self.assertEqual(\n+        NullableJSONModel.objects.filter(value__has_key=\"1111\").count(), 1\n+    )\n+    self.assertEqual(\n+        NullableJSONModel.objects.filter(value__has_key=\"0\").count(), 1  \n+    )\n+    self.assertEqual(\n+        NullableJSONModel.objects.filter(value__has_key=\"123\").count(), 1\n+    )\n     def test_has_key_deep(self):\n         tests = [\n             (Q(value__baz__has_key=\"a\"), self.objs[7]),\n",
    "variant_5": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex fdca700c9d..a11f7a0c61 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -126,16 +126,15 @@ class JSONField(CheckFieldDefaultMixin, Field):\n         )\n \n \n+\n def compile_json_path(key_transforms, include_root=True):\n     path = [\"$\"] if include_root else []\n     for key_transform in key_transforms:\n-        try:\n-            num = int(key_transform)\n-        except ValueError:  # non-integer\n-            path.append(\".\")\n-            path.append(json.dumps(key_transform))\n+        if isinstance(key_transform, int):\n+            path.append(\"[%s]\" % key_transform)\n         else:\n-            path.append(\"[%s]\" % num)\n+            path.append(\".\")\n+            path.append(json.dumps(str(key_transform)))\n     return \"\".join(path)\n \n \n@@ -172,63 +171,44 @@ class ContainedBy(PostgresOperatorLookup):\n class HasKeyLookup(PostgresOperatorLookup):\n     logical_operator = None\n \n-    def as_sql(self, compiler, connection, template=None):\n-        # Process JSON path from the left-hand side.\n-        if isinstance(self.lhs, KeyTransform):\n-            lhs, lhs_params, lhs_key_transforms = self.lhs.preprocess_lhs(\n-                compiler, connection\n-            )\n-            lhs_json_path = compile_json_path(lhs_key_transforms)\n+\n+def compile_json_path(key_transforms, include_root=True):\n+    path = [\"$\"] if include_root else []\n+    for key_transform in key_transforms:\n+        if isinstance(key_transform, int):\n+            # For actual integer keys, use array index syntax\n+            path.append(\"[%s]\" % key_transform)\n         else:\n-            lhs, lhs_params = self.process_lhs(compiler, connection)\n-            lhs_json_path = \"$\"\n-        sql = template % lhs\n-        # Process JSON path from the right-hand side.\n-        rhs = self.rhs\n-        rhs_params = []\n-        if not isinstance(rhs, (list, tuple)):\n-            rhs = [rhs]\n-        for key in rhs:\n-            if isinstance(key, KeyTransform):\n-                *_, rhs_key_transforms = key.preprocess_lhs(compiler, connection)\n-            else:\n-                rhs_key_transforms = [key]\n-            rhs_params.append(\n-                \"%s%s\"\n-                % (\n-                    lhs_json_path,\n-                    compile_json_path(rhs_key_transforms, include_root=False),\n-                )\n-            )\n-        # Add condition for each key.\n-        if self.logical_operator:\n-            sql = \"(%s)\" % self.logical_operator.join([sql] * len(rhs_params))\n-        return sql, tuple(lhs_params) + tuple(rhs_params)\n+            # For string keys (including numeric strings), use object property syntax\n+            path.append(\".\")\n+            path.append(json.dumps(str(key_transform)))\n+    return \"\".join(path)\n \n-    def as_mysql(self, compiler, connection):\n-        return self.as_sql(\n-            compiler, connection, template=\"JSON_CONTAINS_PATH(%s, 'one', %%s)\"\n-        )\n \n-    def as_oracle(self, compiler, connection):\n-        sql, params = self.as_sql(\n-            compiler, connection, template=\"JSON_EXISTS(%s, '%%s')\"\n-        )\n-        # Add paths directly into SQL because path expressions cannot be passed\n-        # as bind variables on Oracle.\n+def as_mysql(self, compiler, connection):\n+    return self.as_sql(\n+        compiler, connection, template=\"JSON_CONTAINS_PATH(%s, 'one', %%s)\"\n+    )\n+\n+def as_oracle(self, compiler, connection):\n+    sql, params = self.as_sql(\n+        compiler, connection, template=\"JSON_EXISTS(%s, '%%s')\"\n+    )\n+    # Add paths directly into SQL because path expressions cannot be passed\n+    # as bind variables on Oracle.\n+    return sql % tuple(params), []\n         return sql % tuple(params), []\n \n-    def as_postgresql(self, compiler, connection):\n-        if isinstance(self.rhs, KeyTransform):\n-            *_, rhs_key_transforms = self.rhs.preprocess_lhs(compiler, connection)\n-            for key in rhs_key_transforms[:-1]:\n-                self.lhs = KeyTransform(key, self.lhs)\n-            self.rhs = rhs_key_transforms[-1]\n-        return super().as_postgresql(compiler, connection)\n \n-    def as_sqlite(self, compiler, connection):\n-        return self.as_sql(\n-            compiler, connection, template=\"JSON_TYPE(%s, %%s) IS NOT NULL\"\n+def compile_json_path(key_transforms, include_root=True):\n+    path = [\"$\"] if include_root else []\n+    for key_transform in key_transforms:\n+        if isinstance(key_transform, int):\n+            path.append(\"[%s]\" % key_transform)\n+        else:\n+            path.append(\".\")\n+            path.append(json.dumps(str(key_transform)))\n+    return \"\".join(path)\n         )\n \n \ndiff --git a/tests/model_fields/test_jsonfield.py b/tests/model_fields/test_jsonfield.py\nindex dfd00f4745..1fc182c5c7 100644\n--- a/tests/model_fields/test_jsonfield.py\n+++ b/tests/model_fields/test_jsonfield.py\n@@ -506,18 +506,33 @@ class TestQuerying(TestCase):\n             self.objs[3:5],\n         )\n \n-    def test_has_key(self):\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__has_key=\"a\"),\n-            [self.objs[3], self.objs[4]],\n-        )\n \n-    def test_has_key_null_value(self):\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__has_key=\"j\"),\n-            [self.objs[4]],\n-        )\n+def test_has_key_numeric_string(self):\n+    \"\"\"Test has_key lookup with numeric string keys.\"\"\"\n+    obj = NullableJSONModel.objects.create(value={\"1111\": \"bar\", \"0\": \"zero\", \"123\": \"test\"})\n+    \n+    # Test each numeric string key\n+    self.assertEqual(\n+        NullableJSONModel.objects.filter(value__has_key=\"1111\").count(), 1\n+    )\n+    self.assertEqual(\n+        NullableJSONModel.objects.filter(value__has_key=\"0\").count(), 1\n+    )\n+    self.assertEqual(\n+        NullableJSONModel.objects.filter(value__has_key=\"123\").count(), 1\n+    )\n+    \n+    # Verify that actual integer keys still work for array access\n+    array_obj = NullableJSONModel.objects.create(value=[\"first\", \"second\", \"third\"])\n+    self.assertEqual(\n+        NullableJSONModel.objects.filter(value__has_key=1).count(), 1\n+    )\n \n+def test_has_key_null_value(self):\n+    self.assertSequenceEqual(\n+        NullableJSONModel.objects.filter(value__has_key=\"j\"),\n+        [self.objs[4]],\n+    )\n     def test_has_key_deep(self):\n         tests = [\n             (Q(value__baz__has_key=\"a\"), self.objs[7]),\n",
    "variant_6": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex fdca700c9d..08bf4cef99 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -126,16 +126,15 @@ class JSONField(CheckFieldDefaultMixin, Field):\n         )\n \n \n+\n def compile_json_path(key_transforms, include_root=True):\n     path = [\"$\"] if include_root else []\n     for key_transform in key_transforms:\n-        try:\n-            num = int(key_transform)\n-        except ValueError:  # non-integer\n-            path.append(\".\")\n-            path.append(json.dumps(key_transform))\n+        if isinstance(key_transform, int):\n+            path.append(\"[%s]\" % key_transform)\n         else:\n-            path.append(\"[%s]\" % num)\n+            path.append(\".\")\n+            path.append(json.dumps(str(key_transform)))\n     return \"\".join(path)\n \n \n@@ -172,63 +171,42 @@ class ContainedBy(PostgresOperatorLookup):\n class HasKeyLookup(PostgresOperatorLookup):\n     logical_operator = None\n \n-    def as_sql(self, compiler, connection, template=None):\n-        # Process JSON path from the left-hand side.\n-        if isinstance(self.lhs, KeyTransform):\n-            lhs, lhs_params, lhs_key_transforms = self.lhs.preprocess_lhs(\n-                compiler, connection\n-            )\n-            lhs_json_path = compile_json_path(lhs_key_transforms)\n+\n+def compile_json_path(key_transforms, include_root=True):\n+    path = [\"$\"] if include_root else []\n+    for key_transform in key_transforms:\n+        if isinstance(key_transform, int):\n+            path.append(\"[%s]\" % key_transform)\n         else:\n-            lhs, lhs_params = self.process_lhs(compiler, connection)\n-            lhs_json_path = \"$\"\n-        sql = template % lhs\n-        # Process JSON path from the right-hand side.\n-        rhs = self.rhs\n-        rhs_params = []\n-        if not isinstance(rhs, (list, tuple)):\n-            rhs = [rhs]\n-        for key in rhs:\n-            if isinstance(key, KeyTransform):\n-                *_, rhs_key_transforms = key.preprocess_lhs(compiler, connection)\n-            else:\n-                rhs_key_transforms = [key]\n-            rhs_params.append(\n-                \"%s%s\"\n-                % (\n-                    lhs_json_path,\n-                    compile_json_path(rhs_key_transforms, include_root=False),\n-                )\n-            )\n-        # Add condition for each key.\n-        if self.logical_operator:\n-            sql = \"(%s)\" % self.logical_operator.join([sql] * len(rhs_params))\n-        return sql, tuple(lhs_params) + tuple(rhs_params)\n+            path.append(\".\")\n+            path.append(json.dumps(str(key_transform)))\n+    return \"\".join(path)\n \n-    def as_mysql(self, compiler, connection):\n-        return self.as_sql(\n-            compiler, connection, template=\"JSON_CONTAINS_PATH(%s, 'one', %%s)\"\n-        )\n \n-    def as_oracle(self, compiler, connection):\n-        sql, params = self.as_sql(\n-            compiler, connection, template=\"JSON_EXISTS(%s, '%%s')\"\n-        )\n-        # Add paths directly into SQL because path expressions cannot be passed\n-        # as bind variables on Oracle.\n+def as_mysql(self, compiler, connection):\n+    return self.as_sql(\n+        compiler, connection, template=\"JSON_CONTAINS_PATH(%s, 'one', %%s)\"\n+    )\n+\n+def as_oracle(self, compiler, connection):\n+    sql, params = self.as_sql(\n+        compiler, connection, template=\"JSON_EXISTS(%s, '%%s')\"\n+    )\n+    # Add paths directly into SQL because path expressions cannot be passed\n+    # as bind variables on Oracle.\n+    return sql % tuple(params), []\n         return sql % tuple(params), []\n \n-    def as_postgresql(self, compiler, connection):\n-        if isinstance(self.rhs, KeyTransform):\n-            *_, rhs_key_transforms = self.rhs.preprocess_lhs(compiler, connection)\n-            for key in rhs_key_transforms[:-1]:\n-                self.lhs = KeyTransform(key, self.lhs)\n-            self.rhs = rhs_key_transforms[-1]\n-        return super().as_postgresql(compiler, connection)\n \n-    def as_sqlite(self, compiler, connection):\n-        return self.as_sql(\n-            compiler, connection, template=\"JSON_TYPE(%s, %%s) IS NOT NULL\"\n+def compile_json_path(key_transforms, include_root=True):\n+    path = [\"$\"] if include_root else []\n+    for key_transform in key_transforms:\n+        if isinstance(key_transform, int):\n+            path.append(\"[%s]\" % key_transform)\n+        else:\n+            path.append(\".\")\n+            path.append(json.dumps(str(key_transform)))\n+    return \"\".join(path)\n         )\n \n \ndiff --git a/tests/model_fields/test_jsonfield.py b/tests/model_fields/test_jsonfield.py\nindex dfd00f4745..70e54db8f8 100644\n--- a/tests/model_fields/test_jsonfield.py\n+++ b/tests/model_fields/test_jsonfield.py\n@@ -506,18 +506,27 @@ class TestQuerying(TestCase):\n             self.objs[3:5],\n         )\n \n-    def test_has_key(self):\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__has_key=\"a\"),\n-            [self.objs[3], self.objs[4]],\n-        )\n-\n-    def test_has_key_null_value(self):\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__has_key=\"j\"),\n-            [self.objs[4]],\n-        )\n \n+def test_has_key_numeric_string(self):\n+    # Test data with numeric string keys\n+    obj = NullableJSONModel.objects.create(value={\"1111\": \"bar\", \"0\": \"zero\", \"123\": \"test\"})\n+    \n+    # Test each numeric string key\n+    self.assertEqual(\n+        NullableJSONModel.objects.filter(value__has_key=\"1111\").count(), 1\n+    )\n+    self.assertEqual(\n+        NullableJSONModel.objects.filter(value__has_key=\"0\").count(), 1  \n+    )\n+    self.assertEqual(\n+        NullableJSONModel.objects.filter(value__has_key=\"123\").count(), 1\n+    )\n+    \n+    # Test mixed object with both numeric string keys and array\n+    mixed_obj = NullableJSONModel.objects.create(value={\"456\": \"string_key\", \"arr\": [1, 2, 3]})\n+    self.assertEqual(\n+        NullableJSONModel.objects.filter(value__has_key=\"456\").count(), 1\n+    )\n     def test_has_key_deep(self):\n         tests = [\n             (Q(value__baz__has_key=\"a\"), self.objs[7]),\n",
    "variant_7": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex fdca700c9d..9884cde4fe 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -126,16 +126,15 @@ class JSONField(CheckFieldDefaultMixin, Field):\n         )\n \n \n+\n def compile_json_path(key_transforms, include_root=True):\n     path = [\"$\"] if include_root else []\n     for key_transform in key_transforms:\n-        try:\n-            num = int(key_transform)\n-        except ValueError:  # non-integer\n-            path.append(\".\")\n-            path.append(json.dumps(key_transform))\n+        if isinstance(key_transform, int):\n+            path.append(\"[%s]\" % key_transform)\n         else:\n-            path.append(\"[%s]\" % num)\n+            path.append(\".\")\n+            path.append(json.dumps(str(key_transform)))\n     return \"\".join(path)\n \n \n@@ -169,6 +168,21 @@ class ContainedBy(PostgresOperatorLookup):\n         return \"JSON_CONTAINS(%s, %s)\" % (rhs, lhs), params\n \n \n+class HasKeyLookup(PostgresOperatorLookup):\n+    logical_operator = None\n+\n+\n+def compile_json_path(key_transforms, include_root=True):\n+    path = [\"$\"] if include_root else []\n+    for key_transform in key_transforms:\n+        if isinstance(key_transform, int):\n+            path.append(\"[%s]\" % key_transform)\n+        else:\n+            path.append(\".\")\n+            path.append(json.dumps(str(key_transform)))\n+    return \"\".join(path)\n+\n+\n class HasKeyLookup(PostgresOperatorLookup):\n     logical_operator = None\n \n@@ -205,30 +219,33 @@ class HasKeyLookup(PostgresOperatorLookup):\n             sql = \"(%s)\" % self.logical_operator.join([sql] * len(rhs_params))\n         return sql, tuple(lhs_params) + tuple(rhs_params)\n \n-    def as_mysql(self, compiler, connection):\n-        return self.as_sql(\n-            compiler, connection, template=\"JSON_CONTAINS_PATH(%s, 'one', %%s)\"\n-        )\n \n-    def as_oracle(self, compiler, connection):\n-        sql, params = self.as_sql(\n-            compiler, connection, template=\"JSON_EXISTS(%s, '%%s')\"\n-        )\n-        # Add paths directly into SQL because path expressions cannot be passed\n-        # as bind variables on Oracle.\n+def as_mysql(self, compiler, connection):\n+    return self.as_sql(\n+        compiler, connection, template=\"JSON_CONTAINS_PATH(%s, 'one', %%s)\"\n+    )\n+\n+def as_oracle(self, compiler, connection):\n+    sql, params = self.as_sql(\n+        compiler, connection, template=\"JSON_EXISTS(%s, '%%s')\"\n+    )\n+    # Add paths directly into SQL because path expressions cannot be passed\n+    # as bind variables on Oracle.\n+    return sql % tuple(params), []\n         return sql % tuple(params), []\n \n-    def as_postgresql(self, compiler, connection):\n-        if isinstance(self.rhs, KeyTransform):\n-            *_, rhs_key_transforms = self.rhs.preprocess_lhs(compiler, connection)\n-            for key in rhs_key_transforms[:-1]:\n-                self.lhs = KeyTransform(key, self.lhs)\n-            self.rhs = rhs_key_transforms[-1]\n-        return super().as_postgresql(compiler, connection)\n \n-    def as_sqlite(self, compiler, connection):\n-        return self.as_sql(\n-            compiler, connection, template=\"JSON_TYPE(%s, %%s) IS NOT NULL\"\n+def compile_json_path(key_transforms, include_root=True):\n+    path = [\"$\"] if include_root else []\n+    for key_transform in key_transforms:\n+        # Only treat actual integer types as array indices\n+        # String keys that happen to contain digits should be treated as object keys\n+        if isinstance(key_transform, int):\n+            path.append(\"[%s]\" % key_transform)\n+        else:\n+            path.append(\".\")\n+            path.append(json.dumps(str(key_transform)))\n+    return \"\".join(path)\n         )\n \n \ndiff --git a/tests/model_fields/test_jsonfield.py b/tests/model_fields/test_jsonfield.py\nindex dfd00f4745..0b7d04fdd0 100644\n--- a/tests/model_fields/test_jsonfield.py\n+++ b/tests/model_fields/test_jsonfield.py\n@@ -506,18 +506,37 @@ class TestQuerying(TestCase):\n             self.objs[3:5],\n         )\n \n-    def test_has_key(self):\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__has_key=\"a\"),\n-            [self.objs[3], self.objs[4]],\n-        )\n \n-    def test_has_key_null_value(self):\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__has_key=\"j\"),\n-            [self.objs[4]],\n-        )\n+def test_has_key_numeric_string(self):\n+    obj = NullableJSONModel.objects.create(value={\"1111\": \"bar\", \"0\": \"zero\", \"123\": \"test\"})\n+    \n+    # Test numeric string keys are treated as object keys, not array indices\n+    self.assertEqual(\n+        NullableJSONModel.objects.filter(value__has_key=\"1111\").count(), 1\n+    )\n+    self.assertEqual(\n+        NullableJSONModel.objects.filter(value__has_key=\"0\").count(), 1\n+    )\n+    self.assertEqual(\n+        NullableJSONModel.objects.filter(value__has_key=\"123\").count(), 1\n+    )\n+    \n+    # Verify the objects are returned correctly\n+    self.assertSequenceEqual(\n+        NullableJSONModel.objects.filter(value__has_key=\"1111\"),\n+        [obj],\n+    )\n \n+def test_has_key_mixed_keys(self):\n+    # Test object with both numeric string keys and regular string keys\n+    obj = NullableJSONModel.objects.create(value={\"1111\": \"numeric\", \"name\": \"string\"})\n+    \n+    self.assertEqual(\n+        NullableJSONModel.objects.filter(value__has_key=\"1111\").count(), 1\n+    )\n+    self.assertEqual(\n+        NullableJSONModel.objects.filter(value__has_key=\"name\").count(), 1\n+    )\n     def test_has_key_deep(self):\n         tests = [\n             (Q(value__baz__has_key=\"a\"), self.objs[7]),\n",
    "variant_8": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex fdca700c9d..8938b5bdc0 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -126,16 +126,15 @@ class JSONField(CheckFieldDefaultMixin, Field):\n         )\n \n \n+\n def compile_json_path(key_transforms, include_root=True):\n     path = [\"$\"] if include_root else []\n     for key_transform in key_transforms:\n-        try:\n-            num = int(key_transform)\n-        except ValueError:  # non-integer\n-            path.append(\".\")\n-            path.append(json.dumps(key_transform))\n+        if isinstance(key_transform, int):\n+            path.append(\"[%s]\" % key_transform)\n         else:\n-            path.append(\"[%s]\" % num)\n+            path.append(\".\")\n+            path.append(json.dumps(str(key_transform)))\n     return \"\".join(path)\n \n \n@@ -172,38 +171,17 @@ class ContainedBy(PostgresOperatorLookup):\n class HasKeyLookup(PostgresOperatorLookup):\n     logical_operator = None\n \n-    def as_sql(self, compiler, connection, template=None):\n-        # Process JSON path from the left-hand side.\n-        if isinstance(self.lhs, KeyTransform):\n-            lhs, lhs_params, lhs_key_transforms = self.lhs.preprocess_lhs(\n-                compiler, connection\n-            )\n-            lhs_json_path = compile_json_path(lhs_key_transforms)\n+\n+def compile_json_path(key_transforms, include_root=True):\n+    path = [\"$\"] if include_root else []\n+    for key_transform in key_transforms:\n+        if isinstance(key_transform, int):\n+            path.append(\"[%s]\" % key_transform)\n         else:\n-            lhs, lhs_params = self.process_lhs(compiler, connection)\n-            lhs_json_path = \"$\"\n-        sql = template % lhs\n-        # Process JSON path from the right-hand side.\n-        rhs = self.rhs\n-        rhs_params = []\n-        if not isinstance(rhs, (list, tuple)):\n-            rhs = [rhs]\n-        for key in rhs:\n-            if isinstance(key, KeyTransform):\n-                *_, rhs_key_transforms = key.preprocess_lhs(compiler, connection)\n-            else:\n-                rhs_key_transforms = [key]\n-            rhs_params.append(\n-                \"%s%s\"\n-                % (\n-                    lhs_json_path,\n-                    compile_json_path(rhs_key_transforms, include_root=False),\n-                )\n-            )\n-        # Add condition for each key.\n-        if self.logical_operator:\n-            sql = \"(%s)\" % self.logical_operator.join([sql] * len(rhs_params))\n-        return sql, tuple(lhs_params) + tuple(rhs_params)\n+            path.append(\".\")\n+            path.append(json.dumps(str(key_transform)))\n+    return \"\".join(path)\n+\n \n     def as_mysql(self, compiler, connection):\n         return self.as_sql(\n@@ -216,19 +194,19 @@ class HasKeyLookup(PostgresOperatorLookup):\n         )\n         # Add paths directly into SQL because path expressions cannot be passed\n         # as bind variables on Oracle.\n+        return sql % tuple(json.dumps(param) for param in params), []\n         return sql % tuple(params), []\n \n-    def as_postgresql(self, compiler, connection):\n-        if isinstance(self.rhs, KeyTransform):\n-            *_, rhs_key_transforms = self.rhs.preprocess_lhs(compiler, connection)\n-            for key in rhs_key_transforms[:-1]:\n-                self.lhs = KeyTransform(key, self.lhs)\n-            self.rhs = rhs_key_transforms[-1]\n-        return super().as_postgresql(compiler, connection)\n \n-    def as_sqlite(self, compiler, connection):\n-        return self.as_sql(\n-            compiler, connection, template=\"JSON_TYPE(%s, %%s) IS NOT NULL\"\n+def compile_json_path(key_transforms, include_root=True):\n+    path = [\"$\"] if include_root else []\n+    for key_transform in key_transforms:\n+        if isinstance(key_transform, int):\n+            path.append(\"[%s]\" % key_transform)\n+        else:\n+            path.append(\".\")\n+            path.append(json.dumps(str(key_transform)))\n+    return \"\".join(path)\n         )\n \n \ndiff --git a/tests/model_fields/test_jsonfield.py b/tests/model_fields/test_jsonfield.py\nindex dfd00f4745..aaed225ab7 100644\n--- a/tests/model_fields/test_jsonfield.py\n+++ b/tests/model_fields/test_jsonfield.py\n@@ -506,18 +506,38 @@ class TestQuerying(TestCase):\n             self.objs[3:5],\n         )\n \n-    def test_has_key(self):\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__has_key=\"a\"),\n-            [self.objs[3], self.objs[4]],\n-        )\n \n-    def test_has_key_null_value(self):\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__has_key=\"j\"),\n-            [self.objs[4]],\n-        )\n+def test_has_key_numeric_string(self):\n+    \"\"\"Test has_key lookup with numeric string keys like '1111', '0', '123'.\"\"\"\n+    obj = NullableJSONModel.objects.create(value={\"1111\": \"bar\", \"0\": \"zero\", \"123\": \"test\"})\n+    \n+    # Test numeric string keys are treated as object keys, not array indices\n+    self.assertEqual(\n+        NullableJSONModel.objects.filter(value__has_key=\"1111\").count(), 1\n+    )\n+    self.assertEqual(\n+        NullableJSONModel.objects.filter(value__has_key=\"0\").count(), 1\n+    )\n+    self.assertEqual(\n+        NullableJSONModel.objects.filter(value__has_key=\"123\").count(), 1\n+    )\n+    \n+    # Verify non-existent numeric string keys return empty results\n+    self.assertEqual(\n+        NullableJSONModel.objects.filter(value__has_key=\"9999\").count(), 0\n+    )\n \n+def test_has_key(self):\n+    self.assertSequenceEqual(\n+        NullableJSONModel.objects.filter(value__has_key=\"a\"),\n+        [self.objs[3], self.objs[4]],\n+    )\n+\n+def test_has_key_null_value(self):\n+    self.assertSequenceEqual(\n+        NullableJSONModel.objects.filter(value__has_key=\"j\"),\n+        [self.objs[4]],\n+    )\n     def test_has_key_deep(self):\n         tests = [\n             (Q(value__baz__has_key=\"a\"), self.objs[7]),\n"
  }
}