{
  "zero_patches": {
    "Location 1 (/root/hy/projects/django/django/db/models/fields/json.py lines 449-449)": "\n\nclass KeyTransformIn(lookups.In):\n    def process_rhs(self, compiler, connection):\n        rhs, rhs_params = super().process_rhs(compiler, connection)\n        # Ensure we're working with the proper key transform context\n        return rhs, rhs_params\n\n    def as_sql(self, compiler, connection):\n        # For JSON key transforms, we need to ensure proper SQL generation\n        lhs, lhs_params = self.process_lhs(compiler, connection)\n        rhs, rhs_params = self.process_rhs(compiler, connection)\n        params = lhs_params + rhs_params\n        return '%s IN %s' % (lhs, rhs), params\n\n\n",
    "Location 2 (/root/hy/projects/django/django/db/models/fields/json.py lines 496-496)": "\nclass KeyTransformIn(lookups.In):\n    def resolve_expression_parameter(self, compiler, connection, sql, param):\n        sql, params = super().resolve_expression_parameter(compiler, connection, sql, param)\n        return sql, params\n\n    def as_mysql(self, compiler, connection):\n        # For MySQL, we need to extract the JSON key properly in the IN clause\n        lhs, lhs_params = self.process_lhs(compiler, connection)\n        rhs, rhs_params = self.process_rhs(compiler, connection)\n        params = lhs_params + rhs_params\n        return f\"JSON_EXTRACT({lhs}, '$') IN {rhs}\", params\n\n    def as_oracle(self, compiler, connection):\n        # For Oracle, use JSON_VALUE for key extraction in IN clause\n        lhs, lhs_params = self.process_lhs(compiler, connection)\n        rhs, rhs_params = self.process_rhs(compiler, connection)\n        params = lhs_params + rhs_params\n        return f\"JSON_VALUE({lhs}, '$') IN {rhs}\", params\n\n    def as_sqlite(self, compiler, connection):\n        # For SQLite, use JSON_EXTRACT for key extraction in IN clause\n        lhs, lhs_params = self.process_lhs(compiler, connection)\n        rhs, rhs_params = self.process_rhs(compiler, connection)\n        params = lhs_params + rhs_params\n        return f\"JSON_EXTRACT({lhs}, '$') IN {rhs}\", params\n\n\nKeyTransform.register_lookup(KeyTransformIn)\n",
    "Location 3 (/root/hy/projects/django/django/db/models/lookups.py lines 358-421)": "\nclass KeyTransformIn(lookups.In):\n    def as_mysql(self, compiler, connection):\n        lhs, lhs_params = self.process_lhs(compiler, connection)\n        rhs, rhs_params = self.process_rhs(compiler, connection)\n        return 'JSON_EXTRACT(%s, %%s) IN %s' % (lhs, rhs), lhs_params + rhs_params\n\n    def as_oracle(self, compiler, connection):\n        lhs, lhs_params = self.process_lhs(compiler, connection)\n        rhs, rhs_params = self.process_rhs(compiler, connection)\n        return \"JSON_VALUE(%s, '%%s') IN %s\" % (lhs, rhs), lhs_params + rhs_params\n\n    def as_sqlite(self, compiler, connection):\n        lhs, lhs_params = self.process_lhs(compiler, connection)\n        rhs, rhs_params = self.process_rhs(compiler, connection)\n        return 'JSON_EXTRACT(%s, %%s) IN %s' % (lhs, rhs), lhs_params + rhs_params\n",
    "Location 4 (/root/hy/projects/django/django/db/models/fields/json.py lines 482-496)": "\nclass KeyTransformIn(lookups.In):\n    def process_rhs(self, compiler, connection):\n        if not hasattr(self.rhs, '__iter__') or isinstance(self.rhs, (str, bytes)):\n            raise ValueError(\n                'The QuerySet value for an in lookup must be an iterable.'\n            )\n        return super().process_rhs(compiler, connection)\n\n\nKeyTransform.register_lookup(KeyTransformExact)\nKeyTransform.register_lookup(KeyTransformIExact)\nKeyTransform.register_lookup(KeyTransformIsNull)\nKeyTransform.register_lookup(KeyTransformIn)\nKeyTransform.register_lookup(KeyTransformIContains)\nKeyTransform.register_lookup(KeyTransformStartsWith)\nKeyTransform.register_lookup(KeyTransformIStartsWith)\nKeyTransform.register_lookup(KeyTransformEndsWith)\nKeyTransform.register_lookup(KeyTransformIEndsWith)\nKeyTransform.register_lookup(KeyTransformRegex)\nKeyTransform.register_lookup(KeyTransformIRegex)\n\nKeyTransform.register_lookup(KeyTransformLt)\nKeyTransform.register_lookup(KeyTransformLte)\nKeyTransform.register_lookup(KeyTransformGt)\nKeyTransform.register_lookup(KeyTransformGte)\n",
    "Location 5 (/root/hy/projects/django/django/db/models/fields/json.py lines 426-456)": "\nclass KeyTransformIExact(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IExact):\n    pass\n\n\nclass KeyTransformIContains(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IContains):\n    pass\n\n\nclass KeyTransformStartsWith(KeyTransformTextLookupMixin, lookups.StartsWith):\n    pass\n\n\nclass KeyTransformIStartsWith(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IStartsWith):\n    pass\n\n\nclass KeyTransformEndsWith(KeyTransformTextLookupMixin, lookups.EndsWith):\n    pass\n\n\nclass KeyTransformIEndsWith(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IEndsWith):\n    pass\n\n\nclass KeyTransformRegex(KeyTransformTextLookupMixin, lookups.Regex):\n    pass\n\n\nclass KeyTransformIRegex(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IRegex):\n    pass\n\n\nclass KeyTransformIn(lookups.In):\n    def process_rhs(self, compiler, connection):\n        rhs, rhs_params = super().process_rhs(compiler, connection)\n        if not connection.features.has_native_json_field:\n            # For databases without native JSON support, convert values to JSON strings\n            rhs_params = [json.dumps(value) for value in rhs_params]\n        return rhs, rhs_params\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/django/django/db/models/fields/json.py lines 449-449)": [
      "\n\nclass KeyTransformIn(lookups.In):\n    def process_rhs(self, compiler, connection):\n        if not isinstance(self.rhs, (list, tuple)):\n            raise ValueError(\n                'The QuerySet value for an in lookup must be an iterable.'\n            )\n        db_rhs = getattr(self.rhs, '_db', None)\n        if db_rhs is not None and db_rhs != connection.alias:\n            raise ValueError(\n                \"Subqueries aren't allowed across different databases. Found %r \"\n                \"subquery in %r database.\" % (db_rhs, connection.alias)\n            )\n\n        if hasattr(self.rhs, 'resolve_expression'):\n            return super().process_rhs(compiler, connection)\n        else:\n            # Convert each value in the list to the appropriate JSON representation\n            rhs_params = []\n            for val in self.rhs:\n                if hasattr(val, 'resolve_expression'):\n                    rhs_params.append(val)\n                else:\n                    rhs_params.append(self.lhs.target.get_prep_value(val))\n            return rhs_params, []\n\n    def as_sql(self, compiler, connection):\n        # For JSON key extraction, we need to handle the IN clause specially\n        lhs, lhs_params = self.process_lhs(compiler, connection)\n        rhs_params, _ = self.process_rhs(compiler, connection)\n        \n        if not rhs_params:\n            return '0 = 1', []\n        \n        # Build the IN clause with proper parameter placeholders\n        in_clause = ', '.join(['%s'] * len(rhs_params))\n        return f'{lhs} IN ({in_clause})', lhs_params + rhs_params\n\n\n",
      "\n\nclass KeyTransformIn(lookups.In):\n    pass\n",
      "\n\n\nclass KeyTransformIn(lookups.In):\n    def process_rhs(self, compiler, connection):\n        rhs, rhs_params = super().process_rhs(compiler, connection)\n        # For databases that need special handling of JSON key extraction in IN clauses\n        if connection.vendor in ('mysql', 'oracle', 'sqlite'):\n            return rhs, rhs_params\n        return rhs, rhs_params\n\n\n",
      "\n\nclass KeyTransformIn(lookups.In):\n    def process_rhs(self, compiler, connection):\n        rhs, rhs_params = super().process_rhs(compiler, connection)\n        # Ensure the key transform is properly handled for JSON fields\n        return rhs, rhs_params\n",
      "\n\nclass KeyTransformIn(lookups.In):\n    def process_rhs(self, compiler, connection):\n        if not isinstance(self.rhs, (list, tuple)):\n            raise ValueError(\n                'The QuerySet value for an In lookup must be an iterable.'\n            )\n        rhs, rhs_params = super().process_rhs(compiler, connection)\n        # Convert each parameter to string for JSON key comparison\n        converted_params = []\n        for param in rhs_params:\n            if isinstance(param, (list, tuple)):\n                converted_params.extend(str(p) for p in param)\n            else:\n                converted_params.append(str(param))\n        return rhs, converted_params\n\n\n",
      "\n\nclass KeyTransformIn(lookups.In):\n    def process_rhs(self, compiler, connection):\n        if not isinstance(self.rhs, (list, tuple)):\n            raise ValueError(\n                'The QuerySet value for an in lookup must be an iterable.'\n            )\n        db_rhs = getattr(self.rhs, '_db', None)\n        if db_rhs is not None and db_rhs != connection.alias:\n            raise ValueError(\n                \"Subqueries aren't allowed across different databases. Found '%s' \"\n                \"subquery in '%s' database.\" % (db_rhs, connection.alias)\n            )\n\n        if connection.features.supports_json_field_contains:\n            return super().process_rhs(compiler, connection)\n        else:\n            # For databases that don't support native JSON operations,\n            # we need to cast the JSON field to text for comparison\n            rhs, rhs_params = super().process_rhs(compiler, connection)\n            return rhs, rhs_params\n",
      "\n\nclass KeyTransformIn(lookups.In):\n    def process_rhs(self, compiler, connection):\n        if not isinstance(self.rhs, (list, tuple)):\n            raise ValueError(\n                'The QuerySet value for an in lookup must be an iterable.'\n            )\n        if not self.rhs:\n            raise ValueError(\n                'The QuerySet value for an in lookup must not be empty.'\n            )\n        \n        rhs, rhs_params = super().process_rhs(compiler, connection)\n        return rhs, rhs_params\n\n    def as_sql(self, compiler, connection):\n        lhs, lhs_params = self.process_lhs(compiler, connection)\n        rhs, rhs_params = self.process_rhs(compiler, connection)\n        params = lhs_params + rhs_params\n        return '%s IN %s' % (lhs, rhs), params\n\n",
      "\n\nclass KeyTransformIn(lookups.In):\n    def process_rhs(self, compiler, connection):\n        rhs, rhs_params = super().process_rhs(compiler, connection)\n        # For MySQL, Oracle, and SQLite, we need to ensure proper JSON key extraction\n        # The parent In lookup handles the basic IN clause logic\n        return rhs, rhs_params\n"
    ],
    "Location 2 (/root/hy/projects/django/django/db/models/fields/json.py lines 496-496)": [
      "\nclass KeyTransformIn(lookups.In):\n    def process_rhs(self, compiler, connection):\n        rhs, rhs_params = super().process_rhs(compiler, connection)\n        # Handle JSON key extraction for different database backends\n        if connection.vendor in ('mysql', 'oracle', 'sqlite'):\n            return rhs, rhs_params\n        return rhs, rhs_params\n\n    def as_mysql(self, compiler, connection):\n        lhs, lhs_params = self.process_lhs(compiler, connection)\n        rhs, rhs_params = self.process_rhs(compiler, connection)\n        params = lhs_params + rhs_params\n        return f'JSON_EXTRACT({lhs}) IN {rhs}', params\n\n    def as_oracle(self, compiler, connection):\n        lhs, lhs_params = self.process_lhs(compiler, connection)\n        rhs, rhs_params = self.process_rhs(compiler, connection)\n        params = lhs_params + rhs_params\n        return f'JSON_VALUE({lhs}) IN {rhs}', params\n\n    def as_sqlite(self, compiler, connection):\n        lhs, lhs_params = self.process_lhs(compiler, connection)\n        rhs, rhs_params = self.process_rhs(compiler, connection)\n        params = lhs_params + rhs_params\n        return f'JSON_EXTRACT({lhs}) IN {rhs}', params\n\n\nKeyTransform.register_lookup(KeyTransformIn)\n",
      "\nKeyTransform.register_lookup(KeyTransformGte)\n\n\nclass KeyTransformIn(lookups.In):\n    def resolve_expression_parameter(self, compiler, connection, sql, param):\n        sql, params = super().resolve_expression_parameter(compiler, connection, sql, param)\n        return sql, params\n\n\nKeyTransform.register_lookup(KeyTransformIn)\n",
      "\nKeyTransform.register_lookup(KeyTransformGte)\n\n\nclass KeyTransformIn(lookups.In):\n    def resolve_expression_parameter(self, compiler, connection, sql, param):\n        sql, params = super().resolve_expression_parameter(compiler, connection, sql, param)\n        return sql, params\n\n\nKeyTransform.register_lookup(KeyTransformIn)\n",
      "\nclass KeyTransformIn(lookups.In):\n    def as_mysql(self, compiler, connection):\n        lhs, lhs_params = self.process_lhs(compiler, connection)\n        rhs, rhs_params = self.process_rhs(compiler, connection)\n        return f\"JSON_EXTRACT({lhs}, '$') IN {rhs}\", lhs_params + rhs_params\n\n    def as_oracle(self, compiler, connection):\n        lhs, lhs_params = self.process_lhs(compiler, connection)\n        rhs, rhs_params = self.process_rhs(compiler, connection)\n        return f\"JSON_VALUE({lhs}, '$') IN {rhs}\", lhs_params + rhs_params\n\n    def as_sqlite(self, compiler, connection):\n        lhs, lhs_params = self.process_lhs(compiler, connection)\n        rhs, rhs_params = self.process_rhs(compiler, connection)\n        return f\"JSON_EXTRACT({lhs}, '$') IN {rhs}\", lhs_params + rhs_params\n\n\nKeyTransform.register_lookup(KeyTransformIn)\n",
      "\nKeyTransform.register_lookup(KeyTransformGte)\n\n\nclass KeyTransformIn(lookups.In):\n    def process_rhs(self, compiler, connection):\n        if not isinstance(self.rhs, (list, tuple)):\n            raise ValueError(\n                'The QuerySet value for an __in lookup must be a list or tuple.'\n            )\n        \n        rhs, rhs_params = super().process_rhs(compiler, connection)\n        return rhs, rhs_params\n\n\nKeyTransform.register_lookup(KeyTransformIn)\n",
      "\nKeyTransform.register_lookup(KeyTransformGte)\n\n\nclass KeyTransformIn(lookups.In):\n    def process_rhs(self, compiler, connection):\n        rhs, rhs_params = super().process_rhs(compiler, connection)\n        # For JSON key transforms, we need to ensure proper type handling\n        return rhs, rhs_params\n\n\nKeyTransform.register_lookup(KeyTransformIn)\n",
      "\nclass KeyTransformIn(lookups.In):\n    def resolve_expression_parameter(self, compiler, connection, sql, param):\n        sql, params = super().resolve_expression_parameter(compiler, connection, sql, param)\n        return sql, params\n\n    def process_rhs(self, compiler, connection):\n        if not hasattr(self.rhs, '_db_converters'):\n            if self.rhs_is_direct_value():\n                # Handle direct value lists like [1, 2, 3]\n                self.rhs = [self.lhs.target.get_prep_value(val) for val in self.rhs]\n        return super().process_rhs(compiler, connection)\n\n    def as_sql(self, compiler, connection):\n        # For non-PostgreSQL databases, we need to handle JSON key extraction\n        if connection.vendor == 'postgresql':\n            return super().as_sql(compiler, connection)\n        \n        lhs, lhs_params = self.process_lhs(compiler, connection)\n        rhs, rhs_params = self.process_rhs(compiler, connection)\n        \n        if not rhs:\n            raise ValueError(\"The QuerySet value for an exact lookup must not be empty.\")\n        \n        # Use the database-specific JSON extraction with IN clause\n        if connection.vendor in ('mysql', 'oracle', 'sqlite'):\n            # The lhs already contains the proper JSON extraction SQL\n            # from the KeyTransform.as_sql() method\n            return f'{lhs} IN {rhs}', lhs_params + rhs_params\n        \n        return super().as_sql(compiler, connection)\n\n\nKeyTransform.register_lookup(KeyTransformIn)\n",
      "\nKeyTransform.register_lookup(KeyTransformGte)\n\n\nclass KeyTransformIn(lookups.In):\n    def as_mysql(self, compiler, connection):\n        lhs, lhs_params = self.process_lhs(compiler, connection)\n        rhs, rhs_params = self.process_rhs(compiler, connection)\n        return f\"JSON_EXTRACT({lhs}, %s) IN {rhs}\", lhs_params + rhs_params\n\n    def as_oracle(self, compiler, connection):\n        lhs, lhs_params = self.process_lhs(compiler, connection)\n        rhs, rhs_params = self.process_rhs(compiler, connection)\n        return f\"JSON_VALUE({lhs}, %s) IN {rhs}\", lhs_params + rhs_params\n\n    def as_sqlite(self, compiler, connection):\n        lhs, lhs_params = self.process_lhs(compiler, connection)\n        rhs, rhs_params = self.process_rhs(compiler, connection)\n        return f\"JSON_EXTRACT({lhs}, %s) IN {rhs}\", lhs_params + rhs_params\n\n\nKeyTransform.register_lookup(KeyTransformIn)\n"
    ],
    "Location 3 (/root/hy/projects/django/django/db/models/lookups.py lines 358-421)": [
      "\nclass KeyTransformIn(lookups.In):\n    def as_mysql(self, compiler, connection):\n        lhs, lhs_params = self.process_lhs(compiler, connection)\n        rhs, rhs_params = self.process_rhs(compiler, connection)\n        return 'JSON_UNQUOTE(JSON_EXTRACT(%s, %%s)) IN %s' % (lhs, rhs), lhs_params + rhs_params\n\n    def as_oracle(self, compiler, connection):\n        lhs, lhs_params = self.process_lhs(compiler, connection)\n        rhs, rhs_params = self.process_rhs(compiler, connection)\n        return \"JSON_VALUE(%s, '%%s') IN %s\" % (lhs, rhs), lhs_params + rhs_params\n\n    def as_sqlite(self, compiler, connection):\n        lhs, lhs_params = self.process_lhs(compiler, connection)\n        rhs, rhs_params = self.process_rhs(compiler, connection)\n        return 'JSON_EXTRACT(%s, %%s) IN %s' % (lhs, rhs), lhs_params + rhs_params\n\n\nKeyTransform.register_lookup(KeyTransformIn)\n",
      "\n@Field.register_lookup\nclass In(FieldGetDbPrepValueIterableMixin, BuiltinLookup):\n    lookup_name = 'in'\n\n    def process_rhs(self, compiler, connection):\n        db_rhs = getattr(self.rhs, '_db', None)\n        if db_rhs is not None and db_rhs != connection.alias:\n            raise ValueError(\n                \"Subqueries aren't allowed across different databases. Force \"\n                \"the inner query to be evaluated using `list(inner_query)`.\"\n            )\n\n        if self.rhs_is_direct_value():\n            # Remove None from the list as NULL is never equal to anything.\n            try:\n                rhs = OrderedSet(self.rhs)\n                rhs.discard(None)\n            except TypeError:  # Unhashable items in self.rhs\n                rhs = [r for r in self.rhs if r is not None]\n\n            if not rhs:\n                raise EmptyResultSet\n\n            # rhs should be an iterable; use batch_process_rhs() to\n            # prepare/transform those values.\n            sqls, sqls_params = self.batch_process_rhs(compiler, connection, rhs)\n            placeholder = '(' + ', '.join(sqls) + ')'\n            return (placeholder, sqls_params)\n        else:\n            if not getattr(self.rhs, 'has_select_fields', True):\n                self.rhs.clear_select_clause()\n                self.rhs.add_fields(['pk'])\n            return super().process_rhs(compiler, connection)\n\n    def get_rhs_op(self, connection, rhs):\n        return 'IN %s' % rhs\n\n    def as_sql(self, compiler, connection):\n        max_in_list_size = connection.ops.max_in_list_size()\n        if self.rhs_is_direct_value() and max_in_list_size and len(self.rhs) > max_in_list_size:\n            return self.split_parameter_list_as_sql(compiler, connection)\n        return super().as_sql(compiler, connection)\n\n    def split_parameter_list_as_sql(self, compiler, connection):\n        # This is a special case for databases which limit the number of\n        # elements which can appear in an 'IN' clause.\n        max_in_list_size = connection.ops.max_in_list_size()\n        lhs, lhs_params = self.process_lhs(compiler, connection)\n        rhs, rhs_params = self.batch_process_rhs(compiler, connection)\n        in_clause_elements = ['(']\n        params = []\n        for offset in range(0, len(rhs_params), max_in_list_size):\n            if offset > 0:\n                in_clause_elements.append(' OR ')\n            in_clause_elements.append('%s IN (' % lhs)\n            params.extend(lhs_params)\n            sqls = rhs[offset: offset + max_in_list_size]\n            sqls_params = rhs_params[offset: offset + max_in_list_size]\n            param_group = ', '.join(sqls)\n            in_clause_elements.append(param_group)\n            in_clause_elements.append(')')\n            params.extend(sqls_params)\n        in_clause_elements.append(')')\n        return ''.join(in_clause_elements), params\n",
      "\n@Field.register_lookup\nclass In(FieldGetDbPrepValueIterableMixin, BuiltinLookup):\n    lookup_name = 'in'\n\n    def process_rhs(self, compiler, connection):\n        db_rhs = getattr(self.rhs, '_db', None)\n        if db_rhs is not None and db_rhs != connection.alias:\n            raise ValueError(\n                \"Subqueries aren't allowed across different databases. Force \"\n                \"the inner query to be evaluated using `list(inner_query)`.\"\n            )\n\n        if self.rhs_is_direct_value():\n            # Remove None from the list as NULL is never equal to anything.\n            try:\n                rhs = OrderedSet(self.rhs)\n                rhs.discard(None)\n            except TypeError:  # Unhashable items in self.rhs\n                rhs = [r for r in self.rhs if r is not None]\n\n            if not rhs:\n                raise EmptyResultSet\n\n            # rhs should be an iterable; use batch_process_rhs() to\n            # prepare/transform those values.\n            sqls, sqls_params = self.batch_process_rhs(compiler, connection, rhs)\n            placeholder = '(' + ', '.join(sqls) + ')'\n            return (placeholder, sqls_params)\n        else:\n            if not getattr(self.rhs, 'has_select_fields', True):\n                self.rhs.clear_select_clause()\n                self.rhs.add_fields(['pk'])\n            return super().process_rhs(compiler, connection)\n\n    def get_rhs_op(self, connection, rhs):\n        return 'IN %s' % rhs\n\n    def as_sql(self, compiler, connection):\n        max_in_list_size = connection.ops.max_in_list_size()\n        if self.rhs_is_direct_value() and max_in_list_size and len(self.rhs) > max_in_list_size:\n            return self.split_parameter_list_as_sql(compiler, connection)\n        return super().as_sql(compiler, connection)\n\n    def split_parameter_list_as_sql(self, compiler, connection):\n        # This is a special case for databases which limit the number of\n        # elements which can appear in an 'IN' clause.\n        max_in_list_size = connection.ops.max_in_list_size()\n        lhs, lhs_params = self.process_lhs(compiler, connection)\n        rhs, rhs_params = self.batch_process_rhs(compiler, connection)\n        in_clause_elements = ['(']\n        params = []\n        for offset in range(0, len(rhs_params), max_in_list_size):\n            if offset > 0:\n                in_clause_elements.append(' OR ')\n            in_clause_elements.append('%s IN (' % lhs)\n            params.extend(lhs_params)\n            sqls = rhs[offset: offset + max_in_list_size]\n            sqls_params = rhs_params[offset: offset + max_in_list_size]\n            param_group = ', '.join(sqls)\n            in_clause_elements.append(param_group)\n            in_clause_elements.append(')')\n            params.extend(sqls_params)\n        in_clause_elements.append(')')\n        return ''.join(in_clause_elements), params\n",
      "\n@Field.register_lookup\nclass In(FieldGetDbPrepValueIterableMixin, BuiltinLookup):\n    lookup_name = 'in'\n\n    def process_rhs(self, compiler, connection):\n        db_rhs = getattr(self.rhs, '_db', None)\n        if db_rhs is not None and db_rhs != connection.alias:\n            raise ValueError(\n                \"Subqueries aren't allowed across different databases. Force \"\n                \"the inner query to be evaluated using `list(inner_query)`.\"\n            )\n\n        if self.rhs_is_direct_value():\n            # Remove None from the list as NULL is never equal to anything.\n            try:\n                rhs = OrderedSet(self.rhs)\n                rhs.discard(None)\n            except TypeError:  # Unhashable items in self.rhs\n                rhs = [r for r in self.rhs if r is not None]\n\n            if not rhs:\n                raise EmptyResultSet\n\n            # rhs should be an iterable; use batch_process_rhs() to\n            # prepare/transform those values.\n            sqls, sqls_params = self.batch_process_rhs(compiler, connection, rhs)\n            placeholder = '(' + ', '.join(sqls) + ')'\n            return (placeholder, sqls_params)\n        else:\n            if not getattr(self.rhs, 'has_select_fields', True):\n                self.rhs.clear_select_clause()\n                self.rhs.add_fields(['pk'])\n            return super().process_rhs(compiler, connection)\n\n    def get_rhs_op(self, connection, rhs):\n        return 'IN %s' % rhs\n\n    def as_sql(self, compiler, connection):\n        max_in_list_size = connection.ops.max_in_list_size()\n        if self.rhs_is_direct_value() and max_in_list_size and len(self.rhs) > max_in_list_size:\n            return self.split_parameter_list_as_sql(compiler, connection)\n        return super().as_sql(compiler, connection)\n\n    def split_parameter_list_as_sql(self, compiler, connection):\n        # This is a special case for databases which limit the number of\n        # elements which can appear in an 'IN' clause.\n        max_in_list_size = connection.ops.max_in_list_size()\n        lhs, lhs_params = self.process_lhs(compiler, connection)\n        rhs, rhs_params = self.batch_process_rhs(compiler, connection)\n        in_clause_elements = ['(']\n        params = []\n        for offset in range(0, len(rhs_params), max_in_list_size):\n            if offset > 0:\n                in_clause_elements.append(' OR ')\n            in_clause_elements.append('%s IN (' % lhs)\n            params.extend(lhs_params)\n            sqls = rhs[offset: offset + max_in_list_size]\n            sqls_params = rhs_params[offset: offset + max_in_list_size]\n            param_group = ', '.join(sqls)\n            in_clause_elements.append(param_group)\n            in_clause_elements.append(')')\n            params.extend(sqls_params)\n        in_clause_elements.append(')')\n        return ''.join(in_clause_elements), params\n",
      "\n@Field.register_lookup\nclass In(FieldGetDbPrepValueIterableMixin, BuiltinLookup):\n    lookup_name = 'in'\n\n    def process_rhs(self, compiler, connection):\n        db_rhs = getattr(self.rhs, '_db', None)\n        if db_rhs is not None and db_rhs != connection.alias:\n            raise ValueError(\n                \"Subqueries aren't allowed across different databases. Force \"\n                \"the inner query to be evaluated using `list(inner_query)`.\"\n            )\n\n        if self.rhs_is_direct_value():\n            # Remove None from the list as NULL is never equal to anything.\n            try:\n                rhs = OrderedSet(self.rhs)\n                rhs.discard(None)\n            except TypeError:  # Unhashable items in self.rhs\n                rhs = [r for r in self.rhs if r is not None]\n\n            if not rhs:\n                raise EmptyResultSet\n\n            # rhs should be an iterable; use batch_process_rhs() to\n            # prepare/transform those values.\n            sqls, sqls_params = self.batch_process_rhs(compiler, connection, rhs)\n            placeholder = '(' + ', '.join(sqls) + ')'\n            return (placeholder, sqls_params)\n        else:\n            if not getattr(self.rhs, 'has_select_fields', True):\n                self.rhs.clear_select_clause()\n                self.rhs.add_fields(['pk'])\n            return super().process_rhs(compiler, connection)\n\n    def get_rhs_op(self, connection, rhs):\n        return 'IN %s' % rhs\n\n    def as_sql(self, compiler, connection):\n        max_in_list_size = connection.ops.max_in_list_size()\n        if self.rhs_is_direct_value() and max_in_list_size and len(self.rhs) > max_in_list_size:\n            return self.split_parameter_list_as_sql(compiler, connection)\n        return super().as_sql(compiler, connection)\n\n    def split_parameter_list_as_sql(self, compiler, connection):\n        # This is a special case for databases which limit the number of\n        # elements which can appear in an 'IN' clause.\n        max_in_list_size = connection.ops.max_in_list_size()\n        lhs, lhs_params = self.process_lhs(compiler, connection)\n        rhs, rhs_params = self.batch_process_rhs(compiler, connection)\n        in_clause_elements = ['(']\n        params = []\n        for offset in range(0, len(rhs_params), max_in_list_size):\n            if offset > 0:\n                in_clause_elements.append(' OR ')\n            in_clause_elements.append('%s IN (' % lhs)\n            params.extend(lhs_params)\n            sqls = rhs[offset: offset + max_in_list_size]\n            sqls_params = rhs_params[offset: offset + max_in_list_size]\n            param_group = ', '.join(sqls)\n            in_clause_elements.append(param_group)\n            in_clause_elements.append(')')\n            params.extend(sqls_params)\n        in_clause_elements.append(')')\n        return ''.join(in_clause_elements), params\n",
      "\n@Field.register_lookup\nclass In(FieldGetDbPrepValueIterableMixin, BuiltinLookup):\n    lookup_name = 'in'\n\n    def process_rhs(self, compiler, connection):\n        db_rhs = getattr(self.rhs, '_db', None)\n        if db_rhs is not None and db_rhs != connection.alias:\n            raise ValueError(\n                \"Subqueries aren't allowed across different databases. Force \"\n                \"the inner query to be evaluated using `list(inner_query)`.\"\n            )\n\n        if self.rhs_is_direct_value():\n            # Remove None from the list as NULL is never equal to anything.\n            try:\n                rhs = OrderedSet(self.rhs)\n                rhs.discard(None)\n            except TypeError:  # Unhashable items in self.rhs\n                rhs = [r for r in self.rhs if r is not None]\n\n            if not rhs:\n                raise EmptyResultSet\n\n            # rhs should be an iterable; use batch_process_rhs() to\n            # prepare/transform those values.\n            sqls, sqls_params = self.batch_process_rhs(compiler, connection, rhs)\n            placeholder = '(' + ', '.join(sqls) + ')'\n            return (placeholder, sqls_params)\n        else:\n            if not getattr(self.rhs, 'has_select_fields', True):\n                self.rhs.clear_select_clause()\n                self.rhs.add_fields(['pk'])\n            return super().process_rhs(compiler, connection)\n\n    def get_rhs_op(self, connection, rhs):\n        return 'IN %s' % rhs\n\n    def as_sql(self, compiler, connection):\n        max_in_list_size = connection.ops.max_in_list_size()\n        if self.rhs_is_direct_value() and max_in_list_size and len(self.rhs) > max_in_list_size:\n            return self.split_parameter_list_as_sql(compiler, connection)\n        return super().as_sql(compiler, connection)\n\n    def split_parameter_list_as_sql(self, compiler, connection):\n        # This is a special case for databases which limit the number of\n        # elements which can appear in an 'IN' clause.\n        max_in_list_size = connection.ops.max_in_list_size()\n        lhs, lhs_params = self.process_lhs(compiler, connection)\n        rhs, rhs_params = self.batch_process_rhs(compiler, connection)\n        in_clause_elements = ['(']\n        params = []\n        for offset in range(0, len(rhs_params), max_in_list_size):\n            if offset > 0:\n                in_clause_elements.append(' OR ')\n            in_clause_elements.append('%s IN (' % lhs)\n            params.extend(lhs_params)\n            sqls = rhs[offset: offset + max_in_list_size]\n            sqls_params = rhs_params[offset: offset + max_in_list_size]\n            param_group = ', '.join(sqls)\n            in_clause_elements.append(param_group)\n            in_clause_elements.append(')')\n            params.extend(sqls_params)\n        in_clause_elements.append(')')\n        return ''.join(in_clause_elements), params\n",
      "\n@Field.register_lookup\nclass In(FieldGetDbPrepValueIterableMixin, BuiltinLookup):\n    lookup_name = 'in'\n\n    def process_rhs(self, compiler, connection):\n        db_rhs = getattr(self.rhs, '_db', None)\n        if db_rhs is not None and db_rhs != connection.alias:\n            raise ValueError(\n                \"Subqueries aren't allowed across different databases. Force \"\n                \"the inner query to be evaluated using `list(inner_query)`.\"\n            )\n\n        if self.rhs_is_direct_value():\n            # Remove None from the list as NULL is never equal to anything.\n            try:\n                rhs = OrderedSet(self.rhs)\n                rhs.discard(None)\n            except TypeError:  # Unhashable items in self.rhs\n                rhs = [r for r in self.rhs if r is not None]\n\n            if not rhs:\n                raise EmptyResultSet\n\n            # rhs should be an iterable; use batch_process_rhs() to\n            # prepare/transform those values.\n            sqls, sqls_params = self.batch_process_rhs(compiler, connection, rhs)\n            placeholder = '(' + ', '.join(sqls) + ')'\n            return (placeholder, sqls_params)\n        else:\n            if not getattr(self.rhs, 'has_select_fields', True):\n                self.rhs.clear_select_clause()\n                self.rhs.add_fields(['pk'])\n            return super().process_rhs(compiler, connection)\n\n    def get_rhs_op(self, connection, rhs):\n        return 'IN %s' % rhs\n\n    def as_sql(self, compiler, connection):\n        max_in_list_size = connection.ops.max_in_list_size()\n        if self.rhs_is_direct_value() and max_in_list_size and len(self.rhs) > max_in_list_size:\n            return self.split_parameter_list_as_sql(compiler, connection)\n        return super().as_sql(compiler, connection)\n\n    def split_parameter_list_as_sql(self, compiler, connection):\n        # This is a special case for databases which limit the number of\n        # elements which can appear in an 'IN' clause.\n        max_in_list_size = connection.ops.max_in_list_size()\n        lhs, lhs_params = self.process_lhs(compiler, connection)\n        rhs, rhs_params = self.batch_process_rhs(compiler, connection)\n        in_clause_elements = ['(']\n        params = []\n        for offset in range(0, len(rhs_params), max_in_list_size):\n            if offset > 0:\n                in_clause_elements.append(' OR ')\n            in_clause_elements.append('%s IN (' % lhs)\n            params.extend(lhs_params)\n            sqls = rhs[offset: offset + max_in_list_size]\n            sqls_params = rhs_params[offset: offset + max_in_list_size]\n            param_group = ', '.join(sqls)\n            in_clause_elements.append(param_group)\n            in_clause_elements.append(')')\n            params.extend(sqls_params)\n        in_clause_elements.append(')')\n        return ''.join(in_clause_elements), params\n",
      "\nclass KeyTransformIn(lookups.In):\n    def as_mysql(self, compiler, connection):\n        lhs, lhs_params = self.process_lhs(compiler, connection)\n        rhs, rhs_params = self.process_rhs(compiler, connection)\n        return 'JSON_EXTRACT(%s, %%s) IN %s' % (lhs, rhs), lhs_params + rhs_params\n\n    def as_oracle(self, compiler, connection):\n        lhs, lhs_params = self.process_lhs(compiler, connection)\n        rhs, rhs_params = self.process_rhs(compiler, connection)\n        return \"JSON_VALUE(%s, '%%s') IN %s\" % (lhs, rhs), lhs_params + rhs_params\n\n    def as_sqlite(self, compiler, connection):\n        lhs, lhs_params = self.process_lhs(compiler, connection)\n        rhs, rhs_params = self.process_rhs(compiler, connection)\n        return 'JSON_EXTRACT(%s, %%s) IN %s' % (lhs, rhs), lhs_params + rhs_params\n"
    ],
    "Location 4 (/root/hy/projects/django/django/db/models/fields/json.py lines 482-496)": [
      "\nclass KeyTransformIn(lookups.In):\n    def resolve_expression_parameter(self, compiler, connection, sql, param):\n        sql, params = super().resolve_expression_parameter(\n            compiler, connection, sql, param,\n        )\n        if hasattr(param, 'as_sql'):\n            return sql, params\n        else:\n            return sql, [json.dumps(param)]\n\n\nKeyTransform.register_lookup(KeyTransformExact)\nKeyTransform.register_lookup(KeyTransformIExact)\nKeyTransform.register_lookup(KeyTransformIsNull)\nKeyTransform.register_lookup(KeyTransformIn)\nKeyTransform.register_lookup(KeyTransformIContains)\nKeyTransform.register_lookup(KeyTransformStartsWith)\nKeyTransform.register_lookup(KeyTransformIStartsWith)\nKeyTransform.register_lookup(KeyTransformEndsWith)\nKeyTransform.register_lookup(KeyTransformIEndsWith)\nKeyTransform.register_lookup(KeyTransformRegex)\nKeyTransform.register_lookup(KeyTransformIRegex)\n\nKeyTransform.register_lookup(KeyTransformLt)\nKeyTransform.register_lookup(KeyTransformLte)\nKeyTransform.register_lookup(KeyTransformGt)\nKeyTransform.register_lookup(KeyTransformGte)\n",
      "\nclass KeyTransformIn(lookups.In):\n    pass\n\n\nKeyTransform.register_lookup(KeyTransformExact)\nKeyTransform.register_lookup(KeyTransformIExact)\nKeyTransform.register_lookup(KeyTransformIsNull)\nKeyTransform.register_lookup(KeyTransformIn)\nKeyTransform.register_lookup(KeyTransformIContains)\nKeyTransform.register_lookup(KeyTransformStartsWith)\nKeyTransform.register_lookup(KeyTransformIStartsWith)\nKeyTransform.register_lookup(KeyTransformEndsWith)\nKeyTransform.register_lookup(KeyTransformIEndsWith)\nKeyTransform.register_lookup(KeyTransformRegex)\nKeyTransform.register_lookup(KeyTransformIRegex)\n\nKeyTransform.register_lookup(KeyTransformLt)\nKeyTransform.register_lookup(KeyTransformLte)\nKeyTransform.register_lookup(KeyTransformGt)\nKeyTransform.register_lookup(KeyTransformGte)\n",
      "\nclass KeyTransformIn(lookups.In):\n    def resolve_expression_parameter(self, compiler, connection, sql, param):\n        sql, params = super().resolve_expression_parameter(compiler, connection, sql, param)\n        return sql, params\n\n    def process_rhs(self, compiler, connection):\n        if isinstance(self.rhs, (list, tuple)):\n            # Handle list/tuple of values\n            return super().process_rhs(compiler, connection)\n        else:\n            # Handle subquery or other expressions\n            return super().process_rhs(compiler, connection)\n\n\nKeyTransform.register_lookup(KeyTransformExact)\nKeyTransform.register_lookup(KeyTransformIExact)\nKeyTransform.register_lookup(KeyTransformIsNull)\nKeyTransform.register_lookup(KeyTransformIContains)\nKeyTransform.register_lookup(KeyTransformStartsWith)\nKeyTransform.register_lookup(KeyTransformIStartsWith)\nKeyTransform.register_lookup(KeyTransformEndsWith)\nKeyTransform.register_lookup(KeyTransformIEndsWith)\nKeyTransform.register_lookup(KeyTransformRegex)\nKeyTransform.register_lookup(KeyTransformIRegex)\n\nKeyTransform.register_lookup(KeyTransformLt)\nKeyTransform.register_lookup(KeyTransformLte)\nKeyTransform.register_lookup(KeyTransformGt)\nKeyTransform.register_lookup(KeyTransformGte)\nKeyTransform.register_lookup(KeyTransformIn)\n",
      "\nclass KeyTransformIn(lookups.In):\n    pass\n\n\nKeyTransform.register_lookup(KeyTransformExact)\nKeyTransform.register_lookup(KeyTransformIExact)\nKeyTransform.register_lookup(KeyTransformIsNull)\nKeyTransform.register_lookup(KeyTransformIn)\nKeyTransform.register_lookup(KeyTransformIContains)\nKeyTransform.register_lookup(KeyTransformStartsWith)\nKeyTransform.register_lookup(KeyTransformIStartsWith)\nKeyTransform.register_lookup(KeyTransformEndsWith)\nKeyTransform.register_lookup(KeyTransformIEndsWith)\nKeyTransform.register_lookup(KeyTransformRegex)\nKeyTransform.register_lookup(KeyTransformIRegex)\n\nKeyTransform.register_lookup(KeyTransformLt)\nKeyTransform.register_lookup(KeyTransformLte)\nKeyTransform.register_lookup(KeyTransformGt)\nKeyTransform.register_lookup(KeyTransformGte)\n",
      "\nclass KeyTransformIn(lookups.In):\n    def process_rhs(self, compiler, connection):\n        if not hasattr(self.lhs, 'target'):\n            raise ValueError(\n                'Lookup \"%s\" can only be used on a field that has a target.' % self.lookup_name\n            )\n        rhs, rhs_params = super().process_rhs(compiler, connection)\n        return rhs, rhs_params\n\n\nKeyTransform.register_lookup(KeyTransformExact)\nKeyTransform.register_lookup(KeyTransformIExact)\nKeyTransform.register_lookup(KeyTransformIsNull)\nKeyTransform.register_lookup(KeyTransformIn)\nKeyTransform.register_lookup(KeyTransformIContains)\nKeyTransform.register_lookup(KeyTransformStartsWith)\nKeyTransform.register_lookup(KeyTransformIStartsWith)\nKeyTransform.register_lookup(KeyTransformEndsWith)\nKeyTransform.register_lookup(KeyTransformIEndsWith)\nKeyTransform.register_lookup(KeyTransformRegex)\nKeyTransform.register_lookup(KeyTransformIRegex)\n\nKeyTransform.register_lookup(KeyTransformLt)\nKeyTransform.register_lookup(KeyTransformLte)\nKeyTransform.register_lookup(KeyTransformGt)\nKeyTransform.register_lookup(KeyTransformGte)\n",
      "\nclass KeyTransformIn(lookups.In):\n    def process_rhs(self, compiler, connection):\n        if not getattr(self.rhs, '_db', None):\n            self.rhs = self.rhs._clone() if hasattr(self.rhs, '_clone') else self.rhs\n        rhs, rhs_params = super().process_rhs(compiler, connection)\n        return rhs, rhs_params\n\n    def as_sql(self, compiler, connection):\n        lhs, lhs_params = self.process_lhs(compiler, connection)\n        rhs, rhs_params = self.process_rhs(compiler, connection)\n        params = lhs_params + rhs_params\n        return '%s IN %s' % (lhs, rhs), params\n\n\nKeyTransform.register_lookup(KeyTransformExact)\nKeyTransform.register_lookup(KeyTransformIExact)\nKeyTransform.register_lookup(KeyTransformIsNull)\nKeyTransform.register_lookup(KeyTransformIn)\nKeyTransform.register_lookup(KeyTransformIContains)\nKeyTransform.register_lookup(KeyTransformStartsWith)\nKeyTransform.register_lookup(KeyTransformIStartsWith)\nKeyTransform.register_lookup(KeyTransformEndsWith)\nKeyTransform.register_lookup(KeyTransformIEndsWith)\nKeyTransform.register_lookup(KeyTransformRegex)\nKeyTransform.register_lookup(KeyTransformIRegex)\n\nKeyTransform.register_lookup(KeyTransformLt)\nKeyTransform.register_lookup(KeyTransformLte)\nKeyTransform.register_lookup(KeyTransformGt)\nKeyTransform.register_lookup(KeyTransformGte)\n",
      "\nclass KeyTransformIn(lookups.In):\n    def resolve_expression_parameter(self, compiler, connection, sql, param):\n        sql, params = super().resolve_expression_parameter(compiler, connection, sql, param)\n        return sql, params\n\nKeyTransform.register_lookup(KeyTransformExact)\nKeyTransform.register_lookup(KeyTransformIExact)\nKeyTransform.register_lookup(KeyTransformIsNull)\nKeyTransform.register_lookup(KeyTransformIContains)\nKeyTransform.register_lookup(KeyTransformStartsWith)\nKeyTransform.register_lookup(KeyTransformIStartsWith)\nKeyTransform.register_lookup(KeyTransformEndsWith)\nKeyTransform.register_lookup(KeyTransformIEndsWith)\nKeyTransform.register_lookup(KeyTransformRegex)\nKeyTransform.register_lookup(KeyTransformIRegex)\n\nKeyTransform.register_lookup(KeyTransformLt)\nKeyTransform.register_lookup(KeyTransformLte)\nKeyTransform.register_lookup(KeyTransformGt)\nKeyTransform.register_lookup(KeyTransformGte)\nKeyTransform.register_lookup(KeyTransformIn)\n",
      "\nclass KeyTransformIn(lookups.In):\n    def process_rhs(self, compiler, connection):\n        if not isinstance(self.rhs, (list, tuple)):\n            raise ValueError(\n                'The QuerySet value for an __in lookup must be an iterable.'\n            )\n        db_rhs = getattr(self.rhs, '_db', None)\n        if db_rhs is not None and db_rhs != connection.alias:\n            raise ValueError(\n                \"Subqueries aren't allowed across different databases. Found '%s' \"\n                \"subquery in '%s' database.\" % (db_rhs, connection.alias)\n            )\n        \n        if connection.features.has_native_json_field:\n            return super().process_rhs(compiler, connection)\n        else:\n            # For databases without native JSON support, we need to handle\n            # the RHS values specially to ensure proper JSON key extraction\n            rhs, rhs_params = super().process_rhs(compiler, connection)\n            return rhs, rhs_params\n\n\nKeyTransform.register_lookup(KeyTransformExact)\nKeyTransform.register_lookup(KeyTransformIExact)\nKeyTransform.register_lookup(KeyTransformIsNull)\nKeyTransform.register_lookup(KeyTransformIn)\nKeyTransform.register_lookup(KeyTransformIContains)\nKeyTransform.register_lookup(KeyTransformStartsWith)\nKeyTransform.register_lookup(KeyTransformIStartsWith)\nKeyTransform.register_lookup(KeyTransformEndsWith)\nKeyTransform.register_lookup(KeyTransformIEndsWith)\nKeyTransform.register_lookup(KeyTransformRegex)\nKeyTransform.register_lookup(KeyTransformIRegex)\n\nKeyTransform.register_lookup(KeyTransformLt)\nKeyTransform.register_lookup(KeyTransformLte)\nKeyTransform.register_lookup(KeyTransformGt)\nKeyTransform.register_lookup(KeyTransformGte)\n"
    ],
    "Location 5 (/root/hy/projects/django/django/db/models/fields/json.py lines 426-456)": [
      "\nclass KeyTransformIExact(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IExact):\n    pass\n\n\nclass KeyTransformIContains(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IContains):\n    pass\n\n\nclass KeyTransformStartsWith(KeyTransformTextLookupMixin, lookups.StartsWith):\n    pass\n\n\nclass KeyTransformIStartsWith(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IStartsWith):\n    pass\n\n\nclass KeyTransformEndsWith(KeyTransformTextLookupMixin, lookups.EndsWith):\n    pass\n\n\nclass KeyTransformIEndsWith(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IEndsWith):\n    pass\n\n\nclass KeyTransformRegex(KeyTransformTextLookupMixin, lookups.Regex):\n    pass\n\n\nclass KeyTransformIRegex(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IRegex):\n    pass\n\n\nclass KeyTransformIn(lookups.In):\n    pass\n",
      "\nclass KeyTransformIRegex(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IRegex):\n    pass\n\n\nclass KeyTransformIn(lookups.In):\n    def process_rhs(self, compiler, connection):\n        if not connection.features.has_native_json_field:\n            return super(KeyTransformTextLookupMixin, self).process_rhs(compiler, connection)\n        return super().process_rhs(compiler, connection)\n",
      "\nclass KeyTransformIRegex(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IRegex):\n    pass\n\n\nclass KeyTransformIn(lookups.In):\n    def process_rhs(self, compiler, connection):\n        if not connection.features.has_native_json_field:\n            # For databases without native JSON support, we need to handle the RHS values\n            rhs, rhs_params = super().process_rhs(compiler, connection)\n            # Convert parameters to JSON strings for comparison\n            rhs_params = [json.dumps(value) for value in rhs_params]\n            return rhs, rhs_params\n        return super().process_rhs(compiler, connection)\n",
      "\nclass KeyTransformIExact(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IExact):\n    pass\n\n\nclass KeyTransformIContains(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IContains):\n    pass\n\n\nclass KeyTransformStartsWith(KeyTransformTextLookupMixin, lookups.StartsWith):\n    pass\n\n\nclass KeyTransformIStartsWith(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IStartsWith):\n    pass\n\n\nclass KeyTransformEndsWith(KeyTransformTextLookupMixin, lookups.EndsWith):\n    pass\n\n\nclass KeyTransformIEndsWith(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IEndsWith):\n    pass\n\n\nclass KeyTransformRegex(KeyTransformTextLookupMixin, lookups.Regex):\n    pass\n\n\nclass KeyTransformIRegex(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IRegex):\n    pass\n\n\nclass KeyTransformIn(lookups.In):\n    def process_rhs(self, compiler, connection):\n        if not connection.features.has_native_json_field:\n            # For databases without native JSON support, we need to ensure\n            # the RHS values are properly formatted as JSON strings\n            rhs, rhs_params = super().process_rhs(compiler, connection)\n            rhs_params = [json.dumps(value) if not isinstance(value, str) else value for value in rhs_params]\n            return rhs, rhs_params\n        return super().process_rhs(compiler, connection)\n",
      "\nclass KeyTransformIExact(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IExact):\n    pass\n\n\nclass KeyTransformIContains(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IContains):\n    pass\n\n\nclass KeyTransformStartsWith(KeyTransformTextLookupMixin, lookups.StartsWith):\n    pass\n\n\nclass KeyTransformIStartsWith(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IStartsWith):\n    pass\n\n\nclass KeyTransformEndsWith(KeyTransformTextLookupMixin, lookups.EndsWith):\n    pass\n\n\nclass KeyTransformIEndsWith(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IEndsWith):\n    pass\n\n\nclass KeyTransformRegex(KeyTransformTextLookupMixin, lookups.Regex):\n    pass\n\n\nclass KeyTransformIRegex(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IRegex):\n    pass\n\n\nclass KeyTransformIn(lookups.In):\n    def process_rhs(self, compiler, connection):\n        if not connection.features.has_native_json_field:\n            def prep_value(val):\n                return json.dumps(val)\n        else:\n            def prep_value(val):\n                return val\n        \n        rhs, rhs_params = super().process_rhs(compiler, connection)\n        if rhs_params:\n            rhs_params = [prep_value(p) for p in rhs_params]\n        return rhs, rhs_params\n",
      "\nclass KeyTransformIExact(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IExact):\n    pass\n\n\nclass KeyTransformIContains(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IContains):\n    pass\n\n\nclass KeyTransformStartsWith(KeyTransformTextLookupMixin, lookups.StartsWith):\n    pass\n\n\nclass KeyTransformIStartsWith(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IStartsWith):\n    pass\n\n\nclass KeyTransformEndsWith(KeyTransformTextLookupMixin, lookups.EndsWith):\n    pass\n\n\nclass KeyTransformIEndsWith(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IEndsWith):\n    pass\n\n\nclass KeyTransformRegex(KeyTransformTextLookupMixin, lookups.Regex):\n    pass\n\n\nclass KeyTransformIRegex(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IRegex):\n    pass\n\n\nclass KeyTransformIn(lookups.In):\n    def process_rhs(self, compiler, connection):\n        rhs, rhs_params = super().process_rhs(compiler, connection)\n        if not connection.features.has_native_json_field:\n            rhs_params = [json.dumps(value) for value in rhs_params]\n        return rhs, rhs_params\n",
      "\nclass KeyTransformIRegex(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IRegex):\n    pass\n\n\nclass KeyTransformIn(lookups.In):\n    def process_rhs(self, compiler, connection):\n        if not connection.features.has_native_json_field:\n            # For databases without native JSON support, we need to convert\n            # the RHS values to JSON strings for comparison\n            rhs, rhs_params = super().process_rhs(compiler, connection)\n            rhs_params = [json.dumps(value) for value in rhs_params]\n            return rhs, rhs_params\n        return super().process_rhs(compiler, connection)\n",
      "\nclass KeyTransformIn(lookups.In):\n    def process_rhs(self, compiler, connection):\n        rhs, rhs_params = super().process_rhs(compiler, connection)\n        # For databases without native JSON support, we need to handle JSON serialization\n        if not connection.features.has_native_json_field:\n            # Convert parameters to JSON strings for comparison\n            processed_params = []\n            for param in rhs_params:\n                if isinstance(param, (list, dict)):\n                    processed_params.append(json.dumps(param))\n                else:\n                    processed_params.append(param)\n            rhs_params = processed_params\n        return rhs, rhs_params\n\n\nclass KeyTransformIExact(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IExact):\n    pass\n\n\nclass KeyTransformIContains(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IContains):\n    pass\n\n\nclass KeyTransformStartsWith(KeyTransformTextLookupMixin, lookups.StartsWith):\n    pass\n\n\nclass KeyTransformIStartsWith(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IStartsWith):\n    pass\n\n\nclass KeyTransformEndsWith(KeyTransformTextLookupMixin, lookups.EndsWith):\n    pass\n\n\nclass KeyTransformIEndsWith(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IEndsWith):\n    pass\n\n\nclass KeyTransformRegex(KeyTransformTextLookupMixin, lookups.Regex):\n    pass\n\n\nclass KeyTransformIRegex(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IRegex):\n    pass\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex fafc1beee8..e1b91617e0 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -423,6 +423,7 @@ class KeyTransformExact(JSONExact):\n         return super().as_sql(compiler, connection)\n \n \n+\n class KeyTransformIExact(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IExact):\n     pass\n \n@@ -455,6 +456,10 @@ class KeyTransformIRegex(CaseInsensitiveMixin, KeyTransformTextLookupMixin, look\n     pass\n \n \n+class KeyTransformIRegex(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IRegex):\n+    pass\n+\n+\n class KeyTransformNumericLookupMixin:\n     def process_rhs(self, compiler, connection):\n         rhs, rhs_params = super().process_rhs(compiler, connection)\n@@ -479,6 +484,7 @@ class KeyTransformGte(KeyTransformNumericLookupMixin, lookups.GreaterThanOrEqual\n     pass\n \n \n+\n KeyTransform.register_lookup(KeyTransformExact)\n KeyTransform.register_lookup(KeyTransformIExact)\n KeyTransform.register_lookup(KeyTransformIsNull)\n@@ -494,6 +500,8 @@ KeyTransform.register_lookup(KeyTransformLt)\n KeyTransform.register_lookup(KeyTransformLte)\n KeyTransform.register_lookup(KeyTransformGt)\n KeyTransform.register_lookup(KeyTransformGte)\n+KeyTransform.register_lookup(KeyTransformGte)\n+KeyTransform.register_lookup(KeyTransformIn)\n \n \n class KeyTransformFactory:\ndiff --git a/django/db/models/lookups.py b/django/db/models/lookups.py\nindex a4fbb04648..d0a41ecd82 100644\n--- a/django/db/models/lookups.py\n+++ b/django/db/models/lookups.py\n@@ -355,6 +355,7 @@ class IntegerLessThan(IntegerFieldFloatRounding, LessThan):\n     pass\n \n \n+\n @Field.register_lookup\n class In(FieldGetDbPrepValueIterableMixin, BuiltinLookup):\n     lookup_name = 'in'\n",
    "variant_0": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex fafc1beee8..5880919e88 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -423,6 +423,7 @@ class KeyTransformExact(JSONExact):\n         return super().as_sql(compiler, connection)\n \n \n+\n class KeyTransformIExact(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IExact):\n     pass\n \n@@ -455,6 +456,29 @@ class KeyTransformIRegex(CaseInsensitiveMixin, KeyTransformTextLookupMixin, look\n     pass\n \n \n+class KeyTransformIn(lookups.In):\n+    def process_rhs(self, compiler, connection):\n+        rhs, rhs_params = super().process_rhs(compiler, connection)\n+        if not connection.features.has_native_json_field:\n+            # For databases without native JSON support, convert values to JSON strings\n+            rhs_params = [json.dumps(value) for value in rhs_params]\n+        return rhs, rhs_params\n+    def as_sql(self, compiler, connection):\n+        # For JSON key transforms, we need to ensure proper SQL generation\n+        lhs, lhs_params = self.process_lhs(compiler, connection)\n+        rhs, rhs_params = self.process_rhs(compiler, connection)\n+        params = lhs_params + rhs_params\n+        return '%s IN %s' % (lhs, rhs), params\n+\n+\n+class KeyTransformRegex(KeyTransformTextLookupMixin, lookups.Regex):\n+    pass\n+\n+\n+class KeyTransformIRegex(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IRegex):\n+    pass\n+\n+\n class KeyTransformNumericLookupMixin:\n     def process_rhs(self, compiler, connection):\n         rhs, rhs_params = super().process_rhs(compiler, connection)\n@@ -479,9 +503,20 @@ class KeyTransformGte(KeyTransformNumericLookupMixin, lookups.GreaterThanOrEqual\n     pass\n \n \n+\n+class KeyTransformIn(lookups.In):\n+    def process_rhs(self, compiler, connection):\n+        if not hasattr(self.rhs, '__iter__') or isinstance(self.rhs, (str, bytes)):\n+            raise ValueError(\n+                'The QuerySet value for an in lookup must be an iterable.'\n+            )\n+        return super().process_rhs(compiler, connection)\n+\n+\n KeyTransform.register_lookup(KeyTransformExact)\n KeyTransform.register_lookup(KeyTransformIExact)\n KeyTransform.register_lookup(KeyTransformIsNull)\n+KeyTransform.register_lookup(KeyTransformIn)\n KeyTransform.register_lookup(KeyTransformIContains)\n KeyTransform.register_lookup(KeyTransformStartsWith)\n KeyTransform.register_lookup(KeyTransformIStartsWith)\n@@ -494,6 +529,34 @@ KeyTransform.register_lookup(KeyTransformLt)\n KeyTransform.register_lookup(KeyTransformLte)\n KeyTransform.register_lookup(KeyTransformGt)\n KeyTransform.register_lookup(KeyTransformGte)\n+class KeyTransformIn(lookups.In):\n+    def resolve_expression_parameter(self, compiler, connection, sql, param):\n+        sql, params = super().resolve_expression_parameter(compiler, connection, sql, param)\n+        return sql, params\n+\n+    def as_mysql(self, compiler, connection):\n+        # For MySQL, we need to extract the JSON key properly in the IN clause\n+        lhs, lhs_params = self.process_lhs(compiler, connection)\n+        rhs, rhs_params = self.process_rhs(compiler, connection)\n+        params = lhs_params + rhs_params\n+        return f\"JSON_EXTRACT({lhs}, '$') IN {rhs}\", params\n+\n+    def as_oracle(self, compiler, connection):\n+        # For Oracle, use JSON_VALUE for key extraction in IN clause\n+        lhs, lhs_params = self.process_lhs(compiler, connection)\n+        rhs, rhs_params = self.process_rhs(compiler, connection)\n+        params = lhs_params + rhs_params\n+        return f\"JSON_VALUE({lhs}, '$') IN {rhs}\", params\n+\n+    def as_sqlite(self, compiler, connection):\n+        # For SQLite, use JSON_EXTRACT for key extraction in IN clause\n+        lhs, lhs_params = self.process_lhs(compiler, connection)\n+        rhs, rhs_params = self.process_rhs(compiler, connection)\n+        params = lhs_params + rhs_params\n+        return f\"JSON_EXTRACT({lhs}, '$') IN {rhs}\", params\n+\n+\n+KeyTransform.register_lookup(KeyTransformIn)\n \n \n class KeyTransformFactory:\ndiff --git a/django/db/models/lookups.py b/django/db/models/lookups.py\nindex a4fbb04648..522e8cd609 100644\n--- a/django/db/models/lookups.py\n+++ b/django/db/models/lookups.py\n@@ -355,70 +355,22 @@ class IntegerLessThan(IntegerFieldFloatRounding, LessThan):\n     pass\n \n \n-@Field.register_lookup\n-class In(FieldGetDbPrepValueIterableMixin, BuiltinLookup):\n-    lookup_name = 'in'\n \n-    def process_rhs(self, compiler, connection):\n-        db_rhs = getattr(self.rhs, '_db', None)\n-        if db_rhs is not None and db_rhs != connection.alias:\n-            raise ValueError(\n-                \"Subqueries aren't allowed across different databases. Force \"\n-                \"the inner query to be evaluated using `list(inner_query)`.\"\n-            )\n-\n-        if self.rhs_is_direct_value():\n-            # Remove None from the list as NULL is never equal to anything.\n-            try:\n-                rhs = OrderedSet(self.rhs)\n-                rhs.discard(None)\n-            except TypeError:  # Unhashable items in self.rhs\n-                rhs = [r for r in self.rhs if r is not None]\n-\n-            if not rhs:\n-                raise EmptyResultSet\n-\n-            # rhs should be an iterable; use batch_process_rhs() to\n-            # prepare/transform those values.\n-            sqls, sqls_params = self.batch_process_rhs(compiler, connection, rhs)\n-            placeholder = '(' + ', '.join(sqls) + ')'\n-            return (placeholder, sqls_params)\n-        else:\n-            if not getattr(self.rhs, 'has_select_fields', True):\n-                self.rhs.clear_select_clause()\n-                self.rhs.add_fields(['pk'])\n-            return super().process_rhs(compiler, connection)\n-\n-    def get_rhs_op(self, connection, rhs):\n-        return 'IN %s' % rhs\n+class KeyTransformIn(lookups.In):\n+    def as_mysql(self, compiler, connection):\n+        lhs, lhs_params = self.process_lhs(compiler, connection)\n+        rhs, rhs_params = self.process_rhs(compiler, connection)\n+        return 'JSON_EXTRACT(%s, %%s) IN %s' % (lhs, rhs), lhs_params + rhs_params\n \n-    def as_sql(self, compiler, connection):\n-        max_in_list_size = connection.ops.max_in_list_size()\n-        if self.rhs_is_direct_value() and max_in_list_size and len(self.rhs) > max_in_list_size:\n-            return self.split_parameter_list_as_sql(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+    def as_oracle(self, compiler, connection):\n+        lhs, lhs_params = self.process_lhs(compiler, connection)\n+        rhs, rhs_params = self.process_rhs(compiler, connection)\n+        return \"JSON_VALUE(%s, '%%s') IN %s\" % (lhs, rhs), lhs_params + rhs_params\n \n-    def split_parameter_list_as_sql(self, compiler, connection):\n-        # This is a special case for databases which limit the number of\n-        # elements which can appear in an 'IN' clause.\n-        max_in_list_size = connection.ops.max_in_list_size()\n+    def as_sqlite(self, compiler, connection):\n         lhs, lhs_params = self.process_lhs(compiler, connection)\n-        rhs, rhs_params = self.batch_process_rhs(compiler, connection)\n-        in_clause_elements = ['(']\n-        params = []\n-        for offset in range(0, len(rhs_params), max_in_list_size):\n-            if offset > 0:\n-                in_clause_elements.append(' OR ')\n-            in_clause_elements.append('%s IN (' % lhs)\n-            params.extend(lhs_params)\n-            sqls = rhs[offset: offset + max_in_list_size]\n-            sqls_params = rhs_params[offset: offset + max_in_list_size]\n-            param_group = ', '.join(sqls)\n-            in_clause_elements.append(param_group)\n-            in_clause_elements.append(')')\n-            params.extend(sqls_params)\n-        in_clause_elements.append(')')\n-        return ''.join(in_clause_elements), params\n+        rhs, rhs_params = self.process_rhs(compiler, connection)\n+        return 'JSON_EXTRACT(%s, %%s) IN %s' % (lhs, rhs), lhs_params + rhs_params\n \n \n class PatternLookup(BuiltinLookup):\n",
    "variant_1": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex fafc1beee8..6b2dd4a923 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -423,6 +423,7 @@ class KeyTransformExact(JSONExact):\n         return super().as_sql(compiler, connection)\n \n \n+\n class KeyTransformIExact(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IExact):\n     pass\n \n@@ -455,6 +456,48 @@ class KeyTransformIRegex(CaseInsensitiveMixin, KeyTransformTextLookupMixin, look\n     pass\n \n \n+class KeyTransformIn(lookups.In):\n+    pass\n+        db_rhs = getattr(self.rhs, '_db', None)\n+        if db_rhs is not None and db_rhs != connection.alias:\n+            raise ValueError(\n+                \"Subqueries aren't allowed across different databases. Found %r \"\n+                \"subquery in %r database.\" % (db_rhs, connection.alias)\n+            )\n+\n+        if hasattr(self.rhs, 'resolve_expression'):\n+            return super().process_rhs(compiler, connection)\n+        else:\n+            # Convert each value in the list to the appropriate JSON representation\n+            rhs_params = []\n+            for val in self.rhs:\n+                if hasattr(val, 'resolve_expression'):\n+                    rhs_params.append(val)\n+                else:\n+                    rhs_params.append(self.lhs.target.get_prep_value(val))\n+            return rhs_params, []\n+\n+    def as_sql(self, compiler, connection):\n+        # For JSON key extraction, we need to handle the IN clause specially\n+        lhs, lhs_params = self.process_lhs(compiler, connection)\n+        rhs_params, _ = self.process_rhs(compiler, connection)\n+        \n+        if not rhs_params:\n+            return '0 = 1', []\n+        \n+        # Build the IN clause with proper parameter placeholders\n+        in_clause = ', '.join(['%s'] * len(rhs_params))\n+        return f'{lhs} IN ({in_clause})', lhs_params + rhs_params\n+\n+\n+class KeyTransformRegex(KeyTransformTextLookupMixin, lookups.Regex):\n+    pass\n+\n+\n+class KeyTransformIRegex(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IRegex):\n+    pass\n+\n+\n class KeyTransformNumericLookupMixin:\n     def process_rhs(self, compiler, connection):\n         rhs, rhs_params = super().process_rhs(compiler, connection)\n@@ -479,9 +522,22 @@ class KeyTransformGte(KeyTransformNumericLookupMixin, lookups.GreaterThanOrEqual\n     pass\n \n \n+\n+class KeyTransformIn(lookups.In):\n+    def resolve_expression_parameter(self, compiler, connection, sql, param):\n+        sql, params = super().resolve_expression_parameter(\n+            compiler, connection, sql, param,\n+        )\n+        if hasattr(param, 'as_sql'):\n+            return sql, params\n+        else:\n+            return sql, [json.dumps(param)]\n+\n+\n KeyTransform.register_lookup(KeyTransformExact)\n KeyTransform.register_lookup(KeyTransformIExact)\n KeyTransform.register_lookup(KeyTransformIsNull)\n+KeyTransform.register_lookup(KeyTransformIn)\n KeyTransform.register_lookup(KeyTransformIContains)\n KeyTransform.register_lookup(KeyTransformStartsWith)\n KeyTransform.register_lookup(KeyTransformIStartsWith)\n@@ -494,6 +550,34 @@ KeyTransform.register_lookup(KeyTransformLt)\n KeyTransform.register_lookup(KeyTransformLte)\n KeyTransform.register_lookup(KeyTransformGt)\n KeyTransform.register_lookup(KeyTransformGte)\n+class KeyTransformIn(lookups.In):\n+    def process_rhs(self, compiler, connection):\n+        rhs, rhs_params = super().process_rhs(compiler, connection)\n+        # Handle JSON key extraction for different database backends\n+        if connection.vendor in ('mysql', 'oracle', 'sqlite'):\n+            return rhs, rhs_params\n+        return rhs, rhs_params\n+\n+    def as_mysql(self, compiler, connection):\n+        lhs, lhs_params = self.process_lhs(compiler, connection)\n+        rhs, rhs_params = self.process_rhs(compiler, connection)\n+        params = lhs_params + rhs_params\n+        return f'JSON_EXTRACT({lhs}) IN {rhs}', params\n+\n+    def as_oracle(self, compiler, connection):\n+        lhs, lhs_params = self.process_lhs(compiler, connection)\n+        rhs, rhs_params = self.process_rhs(compiler, connection)\n+        params = lhs_params + rhs_params\n+        return f'JSON_VALUE({lhs}) IN {rhs}', params\n+\n+    def as_sqlite(self, compiler, connection):\n+        lhs, lhs_params = self.process_lhs(compiler, connection)\n+        rhs, rhs_params = self.process_rhs(compiler, connection)\n+        params = lhs_params + rhs_params\n+        return f'JSON_EXTRACT({lhs}) IN {rhs}', params\n+\n+\n+KeyTransform.register_lookup(KeyTransformIn)\n \n \n class KeyTransformFactory:\ndiff --git a/django/db/models/lookups.py b/django/db/models/lookups.py\nindex a4fbb04648..3f2510d423 100644\n--- a/django/db/models/lookups.py\n+++ b/django/db/models/lookups.py\n@@ -355,70 +355,25 @@ class IntegerLessThan(IntegerFieldFloatRounding, LessThan):\n     pass\n \n \n-@Field.register_lookup\n-class In(FieldGetDbPrepValueIterableMixin, BuiltinLookup):\n-    lookup_name = 'in'\n \n-    def process_rhs(self, compiler, connection):\n-        db_rhs = getattr(self.rhs, '_db', None)\n-        if db_rhs is not None and db_rhs != connection.alias:\n-            raise ValueError(\n-                \"Subqueries aren't allowed across different databases. Force \"\n-                \"the inner query to be evaluated using `list(inner_query)`.\"\n-            )\n+class KeyTransformIn(lookups.In):\n+    def as_mysql(self, compiler, connection):\n+        lhs, lhs_params = self.process_lhs(compiler, connection)\n+        rhs, rhs_params = self.process_rhs(compiler, connection)\n+        return 'JSON_UNQUOTE(JSON_EXTRACT(%s, %%s)) IN %s' % (lhs, rhs), lhs_params + rhs_params\n \n-        if self.rhs_is_direct_value():\n-            # Remove None from the list as NULL is never equal to anything.\n-            try:\n-                rhs = OrderedSet(self.rhs)\n-                rhs.discard(None)\n-            except TypeError:  # Unhashable items in self.rhs\n-                rhs = [r for r in self.rhs if r is not None]\n-\n-            if not rhs:\n-                raise EmptyResultSet\n-\n-            # rhs should be an iterable; use batch_process_rhs() to\n-            # prepare/transform those values.\n-            sqls, sqls_params = self.batch_process_rhs(compiler, connection, rhs)\n-            placeholder = '(' + ', '.join(sqls) + ')'\n-            return (placeholder, sqls_params)\n-        else:\n-            if not getattr(self.rhs, 'has_select_fields', True):\n-                self.rhs.clear_select_clause()\n-                self.rhs.add_fields(['pk'])\n-            return super().process_rhs(compiler, connection)\n+    def as_oracle(self, compiler, connection):\n+        lhs, lhs_params = self.process_lhs(compiler, connection)\n+        rhs, rhs_params = self.process_rhs(compiler, connection)\n+        return \"JSON_VALUE(%s, '%%s') IN %s\" % (lhs, rhs), lhs_params + rhs_params\n \n-    def get_rhs_op(self, connection, rhs):\n-        return 'IN %s' % rhs\n+    def as_sqlite(self, compiler, connection):\n+        lhs, lhs_params = self.process_lhs(compiler, connection)\n+        rhs, rhs_params = self.process_rhs(compiler, connection)\n+        return 'JSON_EXTRACT(%s, %%s) IN %s' % (lhs, rhs), lhs_params + rhs_params\n \n-    def as_sql(self, compiler, connection):\n-        max_in_list_size = connection.ops.max_in_list_size()\n-        if self.rhs_is_direct_value() and max_in_list_size and len(self.rhs) > max_in_list_size:\n-            return self.split_parameter_list_as_sql(compiler, connection)\n-        return super().as_sql(compiler, connection)\n \n-    def split_parameter_list_as_sql(self, compiler, connection):\n-        # This is a special case for databases which limit the number of\n-        # elements which can appear in an 'IN' clause.\n-        max_in_list_size = connection.ops.max_in_list_size()\n-        lhs, lhs_params = self.process_lhs(compiler, connection)\n-        rhs, rhs_params = self.batch_process_rhs(compiler, connection)\n-        in_clause_elements = ['(']\n-        params = []\n-        for offset in range(0, len(rhs_params), max_in_list_size):\n-            if offset > 0:\n-                in_clause_elements.append(' OR ')\n-            in_clause_elements.append('%s IN (' % lhs)\n-            params.extend(lhs_params)\n-            sqls = rhs[offset: offset + max_in_list_size]\n-            sqls_params = rhs_params[offset: offset + max_in_list_size]\n-            param_group = ', '.join(sqls)\n-            in_clause_elements.append(param_group)\n-            in_clause_elements.append(')')\n-            params.extend(sqls_params)\n-        in_clause_elements.append(')')\n-        return ''.join(in_clause_elements), params\n+KeyTransform.register_lookup(KeyTransformIn)\n \n \n class PatternLookup(BuiltinLookup):\n",
    "variant_2": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex fafc1beee8..e86ca2e3a9 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -423,34 +423,16 @@ class KeyTransformExact(JSONExact):\n         return super().as_sql(compiler, connection)\n \n \n-class KeyTransformIExact(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IExact):\n-    pass\n-\n-\n-class KeyTransformIContains(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IContains):\n-    pass\n-\n-\n-class KeyTransformStartsWith(KeyTransformTextLookupMixin, lookups.StartsWith):\n-    pass\n-\n \n-class KeyTransformIStartsWith(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IStartsWith):\n-    pass\n-\n-\n-class KeyTransformEndsWith(KeyTransformTextLookupMixin, lookups.EndsWith):\n-    pass\n-\n-\n-class KeyTransformIEndsWith(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IEndsWith):\n-    pass\n-\n-\n-class KeyTransformRegex(KeyTransformTextLookupMixin, lookups.Regex):\n+class KeyTransformIRegex(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IRegex):\n     pass\n \n \n+class KeyTransformIn(lookups.In):\n+    def process_rhs(self, compiler, connection):\n+        if not connection.features.has_native_json_field:\n+            return super(KeyTransformTextLookupMixin, self).process_rhs(compiler, connection)\n+        return super().process_rhs(compiler, connection)\n class KeyTransformIRegex(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IRegex):\n     pass\n \n@@ -479,9 +461,15 @@ class KeyTransformGte(KeyTransformNumericLookupMixin, lookups.GreaterThanOrEqual\n     pass\n \n \n+\n+class KeyTransformIn(lookups.In):\n+    pass\n+\n+\n KeyTransform.register_lookup(KeyTransformExact)\n KeyTransform.register_lookup(KeyTransformIExact)\n KeyTransform.register_lookup(KeyTransformIsNull)\n+KeyTransform.register_lookup(KeyTransformIn)\n KeyTransform.register_lookup(KeyTransformIContains)\n KeyTransform.register_lookup(KeyTransformStartsWith)\n KeyTransform.register_lookup(KeyTransformIStartsWith)\n@@ -494,6 +482,16 @@ KeyTransform.register_lookup(KeyTransformLt)\n KeyTransform.register_lookup(KeyTransformLte)\n KeyTransform.register_lookup(KeyTransformGt)\n KeyTransform.register_lookup(KeyTransformGte)\n+KeyTransform.register_lookup(KeyTransformGte)\n+\n+\n+class KeyTransformIn(lookups.In):\n+    def resolve_expression_parameter(self, compiler, connection, sql, param):\n+        sql, params = super().resolve_expression_parameter(compiler, connection, sql, param)\n+        return sql, params\n+\n+\n+KeyTransform.register_lookup(KeyTransformIn)\n \n \n class KeyTransformFactory:\ndiff --git a/django/db/models/lookups.py b/django/db/models/lookups.py\nindex a4fbb04648..d0a41ecd82 100644\n--- a/django/db/models/lookups.py\n+++ b/django/db/models/lookups.py\n@@ -355,6 +355,7 @@ class IntegerLessThan(IntegerFieldFloatRounding, LessThan):\n     pass\n \n \n+\n @Field.register_lookup\n class In(FieldGetDbPrepValueIterableMixin, BuiltinLookup):\n     lookup_name = 'in'\n",
    "variant_3": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex fafc1beee8..4664ee16b2 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -423,28 +423,22 @@ class KeyTransformExact(JSONExact):\n         return super().as_sql(compiler, connection)\n \n \n-class KeyTransformIExact(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IExact):\n-    pass\n-\n-\n-class KeyTransformIContains(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IContains):\n-    pass\n-\n-\n-class KeyTransformStartsWith(KeyTransformTextLookupMixin, lookups.StartsWith):\n-    pass\n \n-\n-class KeyTransformIStartsWith(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IStartsWith):\n-    pass\n-\n-\n-class KeyTransformEndsWith(KeyTransformTextLookupMixin, lookups.EndsWith):\n+class KeyTransformIRegex(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IRegex):\n     pass\n \n \n-class KeyTransformIEndsWith(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IEndsWith):\n-    pass\n+class KeyTransformIn(lookups.In):\n+    def process_rhs(self, compiler, connection):\n+        if not connection.features.has_native_json_field:\n+            # For databases without native JSON support, we need to handle the RHS values\n+            rhs, rhs_params = super().process_rhs(compiler, connection)\n+            # Convert parameters to JSON strings for comparison\n+            rhs_params = [json.dumps(value) for value in rhs_params]\n+            return rhs, rhs_params\n+        return super().process_rhs(compiler, connection)\n+            return rhs, rhs_params\n+        return rhs, rhs_params\n \n \n class KeyTransformRegex(KeyTransformTextLookupMixin, lookups.Regex):\n@@ -479,6 +473,21 @@ class KeyTransformGte(KeyTransformNumericLookupMixin, lookups.GreaterThanOrEqual\n     pass\n \n \n+\n+class KeyTransformIn(lookups.In):\n+    def resolve_expression_parameter(self, compiler, connection, sql, param):\n+        sql, params = super().resolve_expression_parameter(compiler, connection, sql, param)\n+        return sql, params\n+\n+    def process_rhs(self, compiler, connection):\n+        if isinstance(self.rhs, (list, tuple)):\n+            # Handle list/tuple of values\n+            return super().process_rhs(compiler, connection)\n+        else:\n+            # Handle subquery or other expressions\n+            return super().process_rhs(compiler, connection)\n+\n+\n KeyTransform.register_lookup(KeyTransformExact)\n KeyTransform.register_lookup(KeyTransformIExact)\n KeyTransform.register_lookup(KeyTransformIsNull)\n@@ -494,6 +503,17 @@ KeyTransform.register_lookup(KeyTransformLt)\n KeyTransform.register_lookup(KeyTransformLte)\n KeyTransform.register_lookup(KeyTransformGt)\n KeyTransform.register_lookup(KeyTransformGte)\n+KeyTransform.register_lookup(KeyTransformIn)\n+KeyTransform.register_lookup(KeyTransformGte)\n+\n+\n+class KeyTransformIn(lookups.In):\n+    def resolve_expression_parameter(self, compiler, connection, sql, param):\n+        sql, params = super().resolve_expression_parameter(compiler, connection, sql, param)\n+        return sql, params\n+\n+\n+KeyTransform.register_lookup(KeyTransformIn)\n \n \n class KeyTransformFactory:\ndiff --git a/django/db/models/lookups.py b/django/db/models/lookups.py\nindex a4fbb04648..d0a41ecd82 100644\n--- a/django/db/models/lookups.py\n+++ b/django/db/models/lookups.py\n@@ -355,6 +355,7 @@ class IntegerLessThan(IntegerFieldFloatRounding, LessThan):\n     pass\n \n \n+\n @Field.register_lookup\n class In(FieldGetDbPrepValueIterableMixin, BuiltinLookup):\n     lookup_name = 'in'\n",
    "variant_4": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex fafc1beee8..5f8fb8dbcc 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -423,6 +423,7 @@ class KeyTransformExact(JSONExact):\n         return super().as_sql(compiler, connection)\n \n \n+\n class KeyTransformIExact(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IExact):\n     pass\n \n@@ -455,6 +456,22 @@ class KeyTransformIRegex(CaseInsensitiveMixin, KeyTransformTextLookupMixin, look\n     pass\n \n \n+class KeyTransformIn(lookups.In):\n+    def process_rhs(self, compiler, connection):\n+        if not connection.features.has_native_json_field:\n+            # For databases without native JSON support, we need to ensure\n+            # the RHS values are properly formatted as JSON strings\n+            rhs, rhs_params = super().process_rhs(compiler, connection)\n+            rhs_params = [json.dumps(value) if not isinstance(value, str) else value for value in rhs_params]\n+            return rhs, rhs_params\n+        return super().process_rhs(compiler, connection)\n+    pass\n+\n+\n+class KeyTransformIRegex(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IRegex):\n+    pass\n+\n+\n class KeyTransformNumericLookupMixin:\n     def process_rhs(self, compiler, connection):\n         rhs, rhs_params = super().process_rhs(compiler, connection)\n@@ -479,9 +496,15 @@ class KeyTransformGte(KeyTransformNumericLookupMixin, lookups.GreaterThanOrEqual\n     pass\n \n \n+\n+class KeyTransformIn(lookups.In):\n+    pass\n+\n+\n KeyTransform.register_lookup(KeyTransformExact)\n KeyTransform.register_lookup(KeyTransformIExact)\n KeyTransform.register_lookup(KeyTransformIsNull)\n+KeyTransform.register_lookup(KeyTransformIn)\n KeyTransform.register_lookup(KeyTransformIContains)\n KeyTransform.register_lookup(KeyTransformStartsWith)\n KeyTransform.register_lookup(KeyTransformIStartsWith)\n@@ -494,6 +517,24 @@ KeyTransform.register_lookup(KeyTransformLt)\n KeyTransform.register_lookup(KeyTransformLte)\n KeyTransform.register_lookup(KeyTransformGt)\n KeyTransform.register_lookup(KeyTransformGte)\n+class KeyTransformIn(lookups.In):\n+    def as_mysql(self, compiler, connection):\n+        lhs, lhs_params = self.process_lhs(compiler, connection)\n+        rhs, rhs_params = self.process_rhs(compiler, connection)\n+        return f\"JSON_EXTRACT({lhs}, '$') IN {rhs}\", lhs_params + rhs_params\n+\n+    def as_oracle(self, compiler, connection):\n+        lhs, lhs_params = self.process_lhs(compiler, connection)\n+        rhs, rhs_params = self.process_rhs(compiler, connection)\n+        return f\"JSON_VALUE({lhs}, '$') IN {rhs}\", lhs_params + rhs_params\n+\n+    def as_sqlite(self, compiler, connection):\n+        lhs, lhs_params = self.process_lhs(compiler, connection)\n+        rhs, rhs_params = self.process_rhs(compiler, connection)\n+        return f\"JSON_EXTRACT({lhs}, '$') IN {rhs}\", lhs_params + rhs_params\n+\n+\n+KeyTransform.register_lookup(KeyTransformIn)\n \n \n class KeyTransformFactory:\ndiff --git a/django/db/models/lookups.py b/django/db/models/lookups.py\nindex a4fbb04648..d0a41ecd82 100644\n--- a/django/db/models/lookups.py\n+++ b/django/db/models/lookups.py\n@@ -355,6 +355,7 @@ class IntegerLessThan(IntegerFieldFloatRounding, LessThan):\n     pass\n \n \n+\n @Field.register_lookup\n class In(FieldGetDbPrepValueIterableMixin, BuiltinLookup):\n     lookup_name = 'in'\n",
    "variant_5": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex fafc1beee8..3bbeb35978 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -423,6 +423,7 @@ class KeyTransformExact(JSONExact):\n         return super().as_sql(compiler, connection)\n \n \n+\n class KeyTransformIExact(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IExact):\n     pass\n \n@@ -455,6 +456,38 @@ class KeyTransformIRegex(CaseInsensitiveMixin, KeyTransformTextLookupMixin, look\n     pass\n \n \n+class KeyTransformIn(lookups.In):\n+    def process_rhs(self, compiler, connection):\n+        if not connection.features.has_native_json_field:\n+            def prep_value(val):\n+                return json.dumps(val)\n+        else:\n+            def prep_value(val):\n+                return val\n+        \n+        rhs, rhs_params = super().process_rhs(compiler, connection)\n+        if rhs_params:\n+            rhs_params = [prep_value(p) for p in rhs_params]\n+        return rhs, rhs_params\n+        rhs, rhs_params = super().process_rhs(compiler, connection)\n+        # Convert each parameter to string for JSON key comparison\n+        converted_params = []\n+        for param in rhs_params:\n+            if isinstance(param, (list, tuple)):\n+                converted_params.extend(str(p) for p in param)\n+            else:\n+                converted_params.append(str(param))\n+        return rhs, converted_params\n+\n+\n+class KeyTransformRegex(KeyTransformTextLookupMixin, lookups.Regex):\n+    pass\n+\n+\n+class KeyTransformIRegex(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IRegex):\n+    pass\n+\n+\n class KeyTransformNumericLookupMixin:\n     def process_rhs(self, compiler, connection):\n         rhs, rhs_params = super().process_rhs(compiler, connection)\n@@ -479,9 +512,21 @@ class KeyTransformGte(KeyTransformNumericLookupMixin, lookups.GreaterThanOrEqual\n     pass\n \n \n+\n+class KeyTransformIn(lookups.In):\n+    def process_rhs(self, compiler, connection):\n+        if not hasattr(self.lhs, 'target'):\n+            raise ValueError(\n+                'Lookup \"%s\" can only be used on a field that has a target.' % self.lookup_name\n+            )\n+        rhs, rhs_params = super().process_rhs(compiler, connection)\n+        return rhs, rhs_params\n+\n+\n KeyTransform.register_lookup(KeyTransformExact)\n KeyTransform.register_lookup(KeyTransformIExact)\n KeyTransform.register_lookup(KeyTransformIsNull)\n+KeyTransform.register_lookup(KeyTransformIn)\n KeyTransform.register_lookup(KeyTransformIContains)\n KeyTransform.register_lookup(KeyTransformStartsWith)\n KeyTransform.register_lookup(KeyTransformIStartsWith)\n@@ -494,6 +539,21 @@ KeyTransform.register_lookup(KeyTransformLt)\n KeyTransform.register_lookup(KeyTransformLte)\n KeyTransform.register_lookup(KeyTransformGt)\n KeyTransform.register_lookup(KeyTransformGte)\n+KeyTransform.register_lookup(KeyTransformGte)\n+\n+\n+class KeyTransformIn(lookups.In):\n+    def process_rhs(self, compiler, connection):\n+        if not isinstance(self.rhs, (list, tuple)):\n+            raise ValueError(\n+                'The QuerySet value for an __in lookup must be a list or tuple.'\n+            )\n+        \n+        rhs, rhs_params = super().process_rhs(compiler, connection)\n+        return rhs, rhs_params\n+\n+\n+KeyTransform.register_lookup(KeyTransformIn)\n \n \n class KeyTransformFactory:\ndiff --git a/django/db/models/lookups.py b/django/db/models/lookups.py\nindex a4fbb04648..d0a41ecd82 100644\n--- a/django/db/models/lookups.py\n+++ b/django/db/models/lookups.py\n@@ -355,6 +355,7 @@ class IntegerLessThan(IntegerFieldFloatRounding, LessThan):\n     pass\n \n \n+\n @Field.register_lookup\n class In(FieldGetDbPrepValueIterableMixin, BuiltinLookup):\n     lookup_name = 'in'\n",
    "variant_6": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex fafc1beee8..2ba2675f21 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -423,6 +423,7 @@ class KeyTransformExact(JSONExact):\n         return super().as_sql(compiler, connection)\n \n \n+\n class KeyTransformIExact(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IExact):\n     pass\n \n@@ -455,6 +456,34 @@ class KeyTransformIRegex(CaseInsensitiveMixin, KeyTransformTextLookupMixin, look\n     pass\n \n \n+class KeyTransformIn(lookups.In):\n+    def process_rhs(self, compiler, connection):\n+        rhs, rhs_params = super().process_rhs(compiler, connection)\n+        if not connection.features.has_native_json_field:\n+            rhs_params = [json.dumps(value) for value in rhs_params]\n+        return rhs, rhs_params\n+        db_rhs = getattr(self.rhs, '_db', None)\n+        if db_rhs is not None and db_rhs != connection.alias:\n+            raise ValueError(\n+                \"Subqueries aren't allowed across different databases. Found '%s' \"\n+                \"subquery in '%s' database.\" % (db_rhs, connection.alias)\n+            )\n+\n+        if connection.features.supports_json_field_contains:\n+            return super().process_rhs(compiler, connection)\n+        else:\n+            # For databases that don't support native JSON operations,\n+            # we need to cast the JSON field to text for comparison\n+            rhs, rhs_params = super().process_rhs(compiler, connection)\n+            return rhs, rhs_params\n+class KeyTransformRegex(KeyTransformTextLookupMixin, lookups.Regex):\n+    pass\n+\n+\n+class KeyTransformIRegex(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IRegex):\n+    pass\n+\n+\n class KeyTransformNumericLookupMixin:\n     def process_rhs(self, compiler, connection):\n         rhs, rhs_params = super().process_rhs(compiler, connection)\n@@ -479,9 +508,25 @@ class KeyTransformGte(KeyTransformNumericLookupMixin, lookups.GreaterThanOrEqual\n     pass\n \n \n+\n+class KeyTransformIn(lookups.In):\n+    def process_rhs(self, compiler, connection):\n+        if not getattr(self.rhs, '_db', None):\n+            self.rhs = self.rhs._clone() if hasattr(self.rhs, '_clone') else self.rhs\n+        rhs, rhs_params = super().process_rhs(compiler, connection)\n+        return rhs, rhs_params\n+\n+    def as_sql(self, compiler, connection):\n+        lhs, lhs_params = self.process_lhs(compiler, connection)\n+        rhs, rhs_params = self.process_rhs(compiler, connection)\n+        params = lhs_params + rhs_params\n+        return '%s IN %s' % (lhs, rhs), params\n+\n+\n KeyTransform.register_lookup(KeyTransformExact)\n KeyTransform.register_lookup(KeyTransformIExact)\n KeyTransform.register_lookup(KeyTransformIsNull)\n+KeyTransform.register_lookup(KeyTransformIn)\n KeyTransform.register_lookup(KeyTransformIContains)\n KeyTransform.register_lookup(KeyTransformStartsWith)\n KeyTransform.register_lookup(KeyTransformIStartsWith)\n@@ -494,6 +539,17 @@ KeyTransform.register_lookup(KeyTransformLt)\n KeyTransform.register_lookup(KeyTransformLte)\n KeyTransform.register_lookup(KeyTransformGt)\n KeyTransform.register_lookup(KeyTransformGte)\n+KeyTransform.register_lookup(KeyTransformGte)\n+\n+\n+class KeyTransformIn(lookups.In):\n+    def process_rhs(self, compiler, connection):\n+        rhs, rhs_params = super().process_rhs(compiler, connection)\n+        # For JSON key transforms, we need to ensure proper type handling\n+        return rhs, rhs_params\n+\n+\n+KeyTransform.register_lookup(KeyTransformIn)\n \n \n class KeyTransformFactory:\ndiff --git a/django/db/models/lookups.py b/django/db/models/lookups.py\nindex a4fbb04648..d0a41ecd82 100644\n--- a/django/db/models/lookups.py\n+++ b/django/db/models/lookups.py\n@@ -355,6 +355,7 @@ class IntegerLessThan(IntegerFieldFloatRounding, LessThan):\n     pass\n \n \n+\n @Field.register_lookup\n class In(FieldGetDbPrepValueIterableMixin, BuiltinLookup):\n     lookup_name = 'in'\n",
    "variant_7": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex fafc1beee8..51d2091b6f 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -423,29 +423,33 @@ class KeyTransformExact(JSONExact):\n         return super().as_sql(compiler, connection)\n \n \n-class KeyTransformIExact(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IExact):\n-    pass\n-\n-\n-class KeyTransformIContains(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IContains):\n-    pass\n-\n \n-class KeyTransformStartsWith(KeyTransformTextLookupMixin, lookups.StartsWith):\n-    pass\n-\n-\n-class KeyTransformIStartsWith(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IStartsWith):\n-    pass\n-\n-\n-class KeyTransformEndsWith(KeyTransformTextLookupMixin, lookups.EndsWith):\n+class KeyTransformIRegex(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IRegex):\n     pass\n \n \n-class KeyTransformIEndsWith(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IEndsWith):\n-    pass\n+class KeyTransformIn(lookups.In):\n+    def process_rhs(self, compiler, connection):\n+        if not connection.features.has_native_json_field:\n+            # For databases without native JSON support, we need to convert\n+            # the RHS values to JSON strings for comparison\n+            rhs, rhs_params = super().process_rhs(compiler, connection)\n+            rhs_params = [json.dumps(value) for value in rhs_params]\n+            return rhs, rhs_params\n+        return super().process_rhs(compiler, connection)\n+        if not self.rhs:\n+            raise ValueError(\n+                'The QuerySet value for an in lookup must not be empty.'\n+            )\n+        \n+        rhs, rhs_params = super().process_rhs(compiler, connection)\n+        return rhs, rhs_params\n \n+    def as_sql(self, compiler, connection):\n+        lhs, lhs_params = self.process_lhs(compiler, connection)\n+        rhs, rhs_params = self.process_rhs(compiler, connection)\n+        params = lhs_params + rhs_params\n+        return '%s IN %s' % (lhs, rhs), params\n \n class KeyTransformRegex(KeyTransformTextLookupMixin, lookups.Regex):\n     pass\n@@ -479,6 +483,12 @@ class KeyTransformGte(KeyTransformNumericLookupMixin, lookups.GreaterThanOrEqual\n     pass\n \n \n+\n+class KeyTransformIn(lookups.In):\n+    def resolve_expression_parameter(self, compiler, connection, sql, param):\n+        sql, params = super().resolve_expression_parameter(compiler, connection, sql, param)\n+        return sql, params\n+\n KeyTransform.register_lookup(KeyTransformExact)\n KeyTransform.register_lookup(KeyTransformIExact)\n KeyTransform.register_lookup(KeyTransformIsNull)\n@@ -494,6 +504,40 @@ KeyTransform.register_lookup(KeyTransformLt)\n KeyTransform.register_lookup(KeyTransformLte)\n KeyTransform.register_lookup(KeyTransformGt)\n KeyTransform.register_lookup(KeyTransformGte)\n+KeyTransform.register_lookup(KeyTransformIn)\n+class KeyTransformIn(lookups.In):\n+    def resolve_expression_parameter(self, compiler, connection, sql, param):\n+        sql, params = super().resolve_expression_parameter(compiler, connection, sql, param)\n+        return sql, params\n+\n+    def process_rhs(self, compiler, connection):\n+        if not hasattr(self.rhs, '_db_converters'):\n+            if self.rhs_is_direct_value():\n+                # Handle direct value lists like [1, 2, 3]\n+                self.rhs = [self.lhs.target.get_prep_value(val) for val in self.rhs]\n+        return super().process_rhs(compiler, connection)\n+\n+    def as_sql(self, compiler, connection):\n+        # For non-PostgreSQL databases, we need to handle JSON key extraction\n+        if connection.vendor == 'postgresql':\n+            return super().as_sql(compiler, connection)\n+        \n+        lhs, lhs_params = self.process_lhs(compiler, connection)\n+        rhs, rhs_params = self.process_rhs(compiler, connection)\n+        \n+        if not rhs:\n+            raise ValueError(\"The QuerySet value for an exact lookup must not be empty.\")\n+        \n+        # Use the database-specific JSON extraction with IN clause\n+        if connection.vendor in ('mysql', 'oracle', 'sqlite'):\n+            # The lhs already contains the proper JSON extraction SQL\n+            # from the KeyTransform.as_sql() method\n+            return f'{lhs} IN {rhs}', lhs_params + rhs_params\n+        \n+        return super().as_sql(compiler, connection)\n+\n+\n+KeyTransform.register_lookup(KeyTransformIn)\n \n \n class KeyTransformFactory:\ndiff --git a/django/db/models/lookups.py b/django/db/models/lookups.py\nindex a4fbb04648..d0a41ecd82 100644\n--- a/django/db/models/lookups.py\n+++ b/django/db/models/lookups.py\n@@ -355,6 +355,7 @@ class IntegerLessThan(IntegerFieldFloatRounding, LessThan):\n     pass\n \n \n+\n @Field.register_lookup\n class In(FieldGetDbPrepValueIterableMixin, BuiltinLookup):\n     lookup_name = 'in'\n",
    "variant_8": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex fafc1beee8..89d18ca6a3 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -423,6 +423,23 @@ class KeyTransformExact(JSONExact):\n         return super().as_sql(compiler, connection)\n \n \n+\n+class KeyTransformIn(lookups.In):\n+    def process_rhs(self, compiler, connection):\n+        rhs, rhs_params = super().process_rhs(compiler, connection)\n+        # For databases without native JSON support, we need to handle JSON serialization\n+        if not connection.features.has_native_json_field:\n+            # Convert parameters to JSON strings for comparison\n+            processed_params = []\n+            for param in rhs_params:\n+                if isinstance(param, (list, dict)):\n+                    processed_params.append(json.dumps(param))\n+                else:\n+                    processed_params.append(param)\n+            rhs_params = processed_params\n+        return rhs, rhs_params\n+\n+\n class KeyTransformIExact(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IExact):\n     pass\n \n@@ -451,6 +468,12 @@ class KeyTransformRegex(KeyTransformTextLookupMixin, lookups.Regex):\n     pass\n \n \n+class KeyTransformIRegex(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IRegex):\n+    pass\n+class KeyTransformRegex(KeyTransformTextLookupMixin, lookups.Regex):\n+    pass\n+\n+\n class KeyTransformIRegex(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IRegex):\n     pass\n \n@@ -479,9 +502,33 @@ class KeyTransformGte(KeyTransformNumericLookupMixin, lookups.GreaterThanOrEqual\n     pass\n \n \n+\n+class KeyTransformIn(lookups.In):\n+    def process_rhs(self, compiler, connection):\n+        if not isinstance(self.rhs, (list, tuple)):\n+            raise ValueError(\n+                'The QuerySet value for an __in lookup must be an iterable.'\n+            )\n+        db_rhs = getattr(self.rhs, '_db', None)\n+        if db_rhs is not None and db_rhs != connection.alias:\n+            raise ValueError(\n+                \"Subqueries aren't allowed across different databases. Found '%s' \"\n+                \"subquery in '%s' database.\" % (db_rhs, connection.alias)\n+            )\n+        \n+        if connection.features.has_native_json_field:\n+            return super().process_rhs(compiler, connection)\n+        else:\n+            # For databases without native JSON support, we need to handle\n+            # the RHS values specially to ensure proper JSON key extraction\n+            rhs, rhs_params = super().process_rhs(compiler, connection)\n+            return rhs, rhs_params\n+\n+\n KeyTransform.register_lookup(KeyTransformExact)\n KeyTransform.register_lookup(KeyTransformIExact)\n KeyTransform.register_lookup(KeyTransformIsNull)\n+KeyTransform.register_lookup(KeyTransformIn)\n KeyTransform.register_lookup(KeyTransformIContains)\n KeyTransform.register_lookup(KeyTransformStartsWith)\n KeyTransform.register_lookup(KeyTransformIStartsWith)\n@@ -494,6 +541,27 @@ KeyTransform.register_lookup(KeyTransformLt)\n KeyTransform.register_lookup(KeyTransformLte)\n KeyTransform.register_lookup(KeyTransformGt)\n KeyTransform.register_lookup(KeyTransformGte)\n+KeyTransform.register_lookup(KeyTransformGte)\n+\n+\n+class KeyTransformIn(lookups.In):\n+    def as_mysql(self, compiler, connection):\n+        lhs, lhs_params = self.process_lhs(compiler, connection)\n+        rhs, rhs_params = self.process_rhs(compiler, connection)\n+        return f\"JSON_EXTRACT({lhs}, %s) IN {rhs}\", lhs_params + rhs_params\n+\n+    def as_oracle(self, compiler, connection):\n+        lhs, lhs_params = self.process_lhs(compiler, connection)\n+        rhs, rhs_params = self.process_rhs(compiler, connection)\n+        return f\"JSON_VALUE({lhs}, %s) IN {rhs}\", lhs_params + rhs_params\n+\n+    def as_sqlite(self, compiler, connection):\n+        lhs, lhs_params = self.process_lhs(compiler, connection)\n+        rhs, rhs_params = self.process_rhs(compiler, connection)\n+        return f\"JSON_EXTRACT({lhs}, %s) IN {rhs}\", lhs_params + rhs_params\n+\n+\n+KeyTransform.register_lookup(KeyTransformIn)\n \n \n class KeyTransformFactory:\ndiff --git a/django/db/models/lookups.py b/django/db/models/lookups.py\nindex a4fbb04648..522e8cd609 100644\n--- a/django/db/models/lookups.py\n+++ b/django/db/models/lookups.py\n@@ -355,70 +355,22 @@ class IntegerLessThan(IntegerFieldFloatRounding, LessThan):\n     pass\n \n \n-@Field.register_lookup\n-class In(FieldGetDbPrepValueIterableMixin, BuiltinLookup):\n-    lookup_name = 'in'\n \n-    def process_rhs(self, compiler, connection):\n-        db_rhs = getattr(self.rhs, '_db', None)\n-        if db_rhs is not None and db_rhs != connection.alias:\n-            raise ValueError(\n-                \"Subqueries aren't allowed across different databases. Force \"\n-                \"the inner query to be evaluated using `list(inner_query)`.\"\n-            )\n-\n-        if self.rhs_is_direct_value():\n-            # Remove None from the list as NULL is never equal to anything.\n-            try:\n-                rhs = OrderedSet(self.rhs)\n-                rhs.discard(None)\n-            except TypeError:  # Unhashable items in self.rhs\n-                rhs = [r for r in self.rhs if r is not None]\n-\n-            if not rhs:\n-                raise EmptyResultSet\n-\n-            # rhs should be an iterable; use batch_process_rhs() to\n-            # prepare/transform those values.\n-            sqls, sqls_params = self.batch_process_rhs(compiler, connection, rhs)\n-            placeholder = '(' + ', '.join(sqls) + ')'\n-            return (placeholder, sqls_params)\n-        else:\n-            if not getattr(self.rhs, 'has_select_fields', True):\n-                self.rhs.clear_select_clause()\n-                self.rhs.add_fields(['pk'])\n-            return super().process_rhs(compiler, connection)\n-\n-    def get_rhs_op(self, connection, rhs):\n-        return 'IN %s' % rhs\n+class KeyTransformIn(lookups.In):\n+    def as_mysql(self, compiler, connection):\n+        lhs, lhs_params = self.process_lhs(compiler, connection)\n+        rhs, rhs_params = self.process_rhs(compiler, connection)\n+        return 'JSON_EXTRACT(%s, %%s) IN %s' % (lhs, rhs), lhs_params + rhs_params\n \n-    def as_sql(self, compiler, connection):\n-        max_in_list_size = connection.ops.max_in_list_size()\n-        if self.rhs_is_direct_value() and max_in_list_size and len(self.rhs) > max_in_list_size:\n-            return self.split_parameter_list_as_sql(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+    def as_oracle(self, compiler, connection):\n+        lhs, lhs_params = self.process_lhs(compiler, connection)\n+        rhs, rhs_params = self.process_rhs(compiler, connection)\n+        return \"JSON_VALUE(%s, '%%s') IN %s\" % (lhs, rhs), lhs_params + rhs_params\n \n-    def split_parameter_list_as_sql(self, compiler, connection):\n-        # This is a special case for databases which limit the number of\n-        # elements which can appear in an 'IN' clause.\n-        max_in_list_size = connection.ops.max_in_list_size()\n+    def as_sqlite(self, compiler, connection):\n         lhs, lhs_params = self.process_lhs(compiler, connection)\n-        rhs, rhs_params = self.batch_process_rhs(compiler, connection)\n-        in_clause_elements = ['(']\n-        params = []\n-        for offset in range(0, len(rhs_params), max_in_list_size):\n-            if offset > 0:\n-                in_clause_elements.append(' OR ')\n-            in_clause_elements.append('%s IN (' % lhs)\n-            params.extend(lhs_params)\n-            sqls = rhs[offset: offset + max_in_list_size]\n-            sqls_params = rhs_params[offset: offset + max_in_list_size]\n-            param_group = ', '.join(sqls)\n-            in_clause_elements.append(param_group)\n-            in_clause_elements.append(')')\n-            params.extend(sqls_params)\n-        in_clause_elements.append(')')\n-        return ''.join(in_clause_elements), params\n+        rhs, rhs_params = self.process_rhs(compiler, connection)\n+        return 'JSON_EXTRACT(%s, %%s) IN %s' % (lhs, rhs), lhs_params + rhs_params\n \n \n class PatternLookup(BuiltinLookup):\n"
  }
}