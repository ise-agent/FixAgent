{
  "zero_patches": {
    "Location 1 (/root/hy/projects/django/django/db/models/sql/compiler.py lines 1674-1686)": "\n    def as_sql(self):\n        \"\"\"\n        Create the SQL for this query. Return the SQL string and list of\n        parameters.\n        \"\"\"\n        sql, params = [], []\n        for annotation in self.query.annotation_select.values():\n            ann_sql, ann_params = self.compile(annotation)\n            ann_sql, ann_params = annotation.select_format(self, ann_sql, ann_params)\n            sql.append(ann_sql)\n            params.extend(ann_params)\n        self.col_count = len(self.query.annotation_select)\n        \n        # If no annotations but we have aggregates, we need to select the aggregate columns\n        if not sql and hasattr(self.query, 'aggregate_select') and self.query.aggregate_select:\n            for alias in self.query.aggregate_select:\n                sql.append(self.quote_name_unless_alias(alias))\n            self.col_count = len(self.query.aggregate_select)\n        \n        sql = ', '.join(sql)\n        params = tuple(params)\n\n        inner_query_sql, inner_query_params = self.query.inner_query.get_compiler(\n            self.using, elide_empty=self.elide_empty,\n        ).as_sql(with_col_aliases=True)\n        sql = 'SELECT %s FROM (%s) subquery' % (sql, inner_query_sql)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/django/django/db/models/sql/compiler.py lines 1674-1686)": [
      "\n    def as_sql(self):\n        \"\"\"\n        Create the SQL for this query. Return the SQL string and list of\n        parameters.\n        \"\"\"\n        sql, params = [], []\n        for annotation in self.query.annotation_select.values():\n            ann_sql, ann_params = self.compile(annotation)\n            ann_sql, ann_params = annotation.select_format(self, ann_sql, ann_params)\n            sql.append(ann_sql)\n            params.extend(ann_params)\n        self.col_count = len(self.query.annotation_select)\n        \n        # If no annotations but we have aggregates, get column aliases from inner query\n        if not sql and hasattr(self.query, 'inner_query') and self.query.inner_query:\n            inner_compiler = self.query.inner_query.get_compiler(\n                self.using, elide_empty=self.elide_empty,\n            )\n            # Get the annotation select from inner query to find aggregate aliases\n            for alias, annotation in self.query.inner_query.annotation_select.items():\n                sql.append(self.quote_name_unless_alias(alias))\n            self.col_count = len(self.query.inner_query.annotation_select)\n        \n        sql = ', '.join(sql)\n        params = tuple(params)\n\n        inner_query_sql, inner_query_params = self.query.inner_query.get_compiler(\n            self.using, elide_empty=self.elide_empty,\n        ).as_sql(with_col_aliases=True)\n        sql = 'SELECT %s FROM (%s) subquery' % (sql, inner_query_sql)\n",
      "\n    def as_sql(self):\n        \"\"\"\n        Create the SQL for this query. Return the SQL string and list of\n        parameters.\n        \"\"\"\n        sql, params = [], []\n        for annotation in self.query.annotation_select.values():\n            ann_sql, ann_params = self.compile(annotation)\n            ann_sql, ann_params = annotation.select_format(self, ann_sql, ann_params)\n            sql.append(ann_sql)\n            params.extend(ann_params)\n        self.col_count = len(self.query.annotation_select)\n        \n        # If we have no annotations to select, but we have aggregates,\n        # we need to select the aggregate columns from the inner query\n        if not sql and hasattr(self.query, 'inner_query') and self.query.inner_query:\n            # Get the inner query compiler to check for aggregate annotations\n            inner_compiler = self.query.inner_query.get_compiler(\n                self.using, elide_empty=self.elide_empty,\n            )\n            # Extract aggregate column names from inner query annotations\n            for alias, annotation in inner_compiler.query.annotation_select.items():\n                if hasattr(annotation, 'source_expressions') and annotation.source_expressions:\n                    sql.append(self.quote_name_unless_alias(alias))\n            self.col_count = len(sql)\n        \n        sql = ', '.join(sql)\n        params = tuple(params)\n\n        inner_query_sql, inner_query_params = self.query.inner_query.get_compiler(\n            self.using, elide_empty=self.elide_empty,\n        ).as_sql(with_col_aliases=True)\n        sql = 'SELECT %s FROM (%s) subquery' % (sql, inner_query_sql)\n",
      "\n    def as_sql(self):\n        \"\"\"\n        Create the SQL for this query. Return the SQL string and list of\n        parameters.\n        \"\"\"\n        sql, params = [], []\n        for annotation in self.query.annotation_select.values():\n            ann_sql, ann_params = self.compile(annotation)\n            ann_sql, ann_params = annotation.select_format(self, ann_sql, ann_params)\n            sql.append(ann_sql)\n            params.extend(ann_params)\n        self.col_count = len(self.query.annotation_select)\n        \n        # Handle case where annotation_select is empty but we have aggregates\n        if not sql and hasattr(self.query, 'annotations') and self.query.annotations:\n            # Get column aliases for aggregates from the inner query\n            inner_compiler = self.query.inner_query.get_compiler(\n                self.using, elide_empty=self.elide_empty,\n            )\n            # Extract aggregate aliases from inner query's select clause\n            for alias, annotation in self.query.annotations.items():\n                if hasattr(annotation, 'source_expressions'):\n                    sql.append(self.quote_name_unless_alias(alias))\n            self.col_count = len(sql)\n        \n        sql = ', '.join(sql)\n        params = tuple(params)\n\n        inner_query_sql, inner_query_params = self.query.inner_query.get_compiler(\n            self.using, elide_empty=self.elide_empty,\n        ).as_sql(with_col_aliases=True)\n        sql = 'SELECT %s FROM (%s) subquery' % (sql, inner_query_sql)\n",
      "\nclass SQLAggregateCompiler(SQLCompiler):\n    def as_sql(self):\n        \"\"\"\n        Create the SQL for this query. Return the SQL string and list of\n        parameters.\n        \"\"\"\n        sql, params = [], []\n        for annotation in self.query.annotation_select.values():\n            ann_sql, ann_params = self.compile(annotation)\n            ann_sql, ann_params = annotation.select_format(self, ann_sql, ann_params)\n            sql.append(ann_sql)\n            params.extend(ann_params)\n        self.col_count = len(self.query.annotation_select)\n        \n        # If no annotations in outer query but we have aggregates, we need to select them\n        if not sql and hasattr(self.query, 'inner_query'):\n            inner_compiler = self.query.inner_query.get_compiler(\n                self.using, elide_empty=self.elide_empty,\n            )\n            # Get the aggregate aliases from the inner query\n            for alias, annotation in inner_compiler.query.annotations.items():\n                if hasattr(annotation, 'source_expressions'):\n                    sql.append('\"%s\"' % alias)\n            self.col_count = len(sql)\n        \n        sql = ', '.join(sql)\n        params = tuple(params)\n\n        inner_query_sql, inner_query_params = self.query.inner_query.get_compiler(\n            self.using, elide_empty=self.elide_empty,\n        ).as_sql(with_col_aliases=True)\n        sql = 'SELECT %s FROM (%s) subquery' % (sql, inner_query_sql)\n",
      "\nclass SQLAggregateCompiler(SQLCompiler):\n    def as_sql(self):\n        \"\"\"\n        Create the SQL for this query. Return the SQL string and list of\n        parameters.\n        \"\"\"\n        sql, params = [], []\n        for annotation in self.query.annotation_select.values():\n            ann_sql, ann_params = self.compile(annotation)\n            ann_sql, ann_params = annotation.select_format(self, ann_sql, ann_params)\n            sql.append(ann_sql)\n            params.extend(ann_params)\n        self.col_count = len(self.query.annotation_select)\n        \n        inner_query_sql, inner_query_params = self.query.inner_query.get_compiler(\n            self.using, elide_empty=self.elide_empty,\n        ).as_sql(with_col_aliases=True)\n        \n        # If we have no annotations to select but we have aggregates in the inner query,\n        # we need to select the aggregate columns from the subquery\n        if not sql and hasattr(self.query, 'aggregates') and self.query.aggregates:\n            # Get the aggregate aliases from the inner query\n            aggregate_aliases = []\n            for alias in self.query.aggregates.keys():\n                aggregate_aliases.append('\"%s\"' % alias)\n            sql = aggregate_aliases\n            self.col_count = len(aggregate_aliases)\n        \n        sql = ', '.join(sql)\n        params = tuple(params)\n        sql = 'SELECT %s FROM (%s) subquery' % (sql, inner_query_sql)\n        params = params + inner_query_params\n        return sql, params\n",
      "\nclass SQLAggregateCompiler(SQLCompiler):\n    def as_sql(self):\n        \"\"\"\n        Create the SQL for this query. Return the SQL string and list of\n        parameters.\n        \"\"\"\n        sql, params = [], []\n        for annotation in self.query.annotation_select.values():\n            ann_sql, ann_params = self.compile(annotation)\n            ann_sql, ann_params = annotation.select_format(self, ann_sql, ann_params)\n            sql.append(ann_sql)\n            params.extend(ann_params)\n        self.col_count = len(self.query.annotation_select)\n        \n        inner_query_sql, inner_query_params = self.query.inner_query.get_compiler(\n            self.using, elide_empty=self.elide_empty,\n        ).as_sql(with_col_aliases=True)\n        \n        # If annotation_select is empty but we have aggregates, extract column aliases\n        # from the inner query to avoid generating malformed SQL like \"SELECT FROM (...)\"\n        if not sql and hasattr(self.query.inner_query, 'annotation_select'):\n            # Extract aggregate column aliases from inner query annotations\n            for alias, annotation in self.query.inner_query.annotation_select.items():\n                if hasattr(annotation, 'source_expressions') and annotation.source_expressions:\n                    # This is likely an aggregate - add its alias to the outer SELECT\n                    sql.append('\"%s\"' % alias)\n            self.col_count = len(sql)\n        \n        sql = ', '.join(sql) if sql else '*'\n        params = tuple(params)\n        \n        sql = 'SELECT %s FROM (%s) subquery' % (sql, inner_query_sql)\n        params = params + inner_query_params\n        return sql, params\n",
      "\n    def as_sql(self):\n        \"\"\"\n        Create the SQL for this query. Return the SQL string and list of\n        parameters.\n        \"\"\"\n        sql, params = [], []\n        for annotation in self.query.annotation_select.values():\n            ann_sql, ann_params = self.compile(annotation)\n            ann_sql, ann_params = annotation.select_format(self, ann_sql, ann_params)\n            sql.append(ann_sql)\n            params.extend(ann_params)\n        self.col_count = len(self.query.annotation_select)\n        \n        # If no annotations in outer query but we have aggregates, we need to select\n        # the aggregate columns from the inner query\n        if not sql and hasattr(self.query, 'inner_query') and self.query.inner_query:\n            # Get the inner query compiler to determine what columns it selects\n            inner_compiler = self.query.inner_query.get_compiler(\n                self.using, elide_empty=self.elide_empty,\n            )\n            # Extract aggregate column aliases from inner query's annotations\n            for alias, annotation in self.query.inner_query.annotations.items():\n                sql.append(self.quote_name_unless_alias(alias))\n            self.col_count = len(sql)\n        \n        sql = ', '.join(sql)\n        params = tuple(params)\n\n        inner_query_sql, inner_query_params = self.query.inner_query.get_compiler(\n            self.using, elide_empty=self.elide_empty,\n        ).as_sql(with_col_aliases=True)\n        sql = 'SELECT %s FROM (%s) subquery' % (sql, inner_query_sql)\n",
      "\n    def as_sql(self):\n        \"\"\"\n        Create the SQL for this query. Return the SQL string and list of\n        parameters.\n        \"\"\"\n        sql, params = [], []\n        for annotation in self.query.annotation_select.values():\n            ann_sql, ann_params = self.compile(annotation)\n            ann_sql, ann_params = annotation.select_format(self, ann_sql, ann_params)\n            sql.append(ann_sql)\n            params.extend(ann_params)\n        self.col_count = len(self.query.annotation_select)\n        \n        # If annotation_select is empty but we have aggregates, we need to select\n        # the aggregate columns from the inner query\n        if not sql and hasattr(self.query, 'inner_query'):\n            # Get the inner query compiler to access its annotations\n            inner_compiler = self.query.inner_query.get_compiler(\n                self.using, elide_empty=self.elide_empty,\n            )\n            # Extract aggregate column aliases from inner query annotations\n            for alias, annotation in inner_compiler.query.annotations.items():\n                # Only include aggregates, not regular annotations\n                from django.db.models.aggregates import Aggregate\n                if isinstance(annotation, Aggregate):\n                    sql.append(self.quote_name_unless_alias(alias))\n            self.col_count = len(sql)\n        \n        sql = ', '.join(sql)\n        params = tuple(params)\n\n        inner_query_sql, inner_query_params = self.query.inner_query.get_compiler(\n            self.using, elide_empty=self.elide_empty,\n        ).as_sql(with_col_aliases=True)\n        sql = 'SELECT %s FROM (%s) subquery' % (sql, inner_query_sql)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex d405a203ee..775b524f1b 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1671,6 +1671,7 @@ class SQLAggregateCompiler(SQLCompiler):\n         parameters.\n         \"\"\"\n         sql, params = [], []\n+\n         for annotation in self.query.annotation_select.values():\n             ann_sql, ann_params = self.compile(annotation)\n             ann_sql, ann_params = annotation.select_format(self, ann_sql, ann_params)\n@@ -1683,6 +1684,18 @@ class SQLAggregateCompiler(SQLCompiler):\n         inner_query_sql, inner_query_params = self.query.inner_query.get_compiler(\n             self.using, elide_empty=self.elide_empty,\n         ).as_sql(with_col_aliases=True)\n+        \n+        # When annotation_select is empty but we have aggregate columns in the inner query,\n+        # we need to extract the aggregate column aliases from the inner query to use\n+        # in the outer SELECT clause. This occurs when using aggregate() with default.\n+        if not sql and self.query.inner_query.annotations:\n+            # Extract aggregate column aliases from inner query annotations\n+            aggregate_columns = []\n+            for alias, annotation in self.query.inner_query.annotations.items():\n+                # Use the connection's quote_name to properly quote the alias\n+                aggregate_columns.append(self.connection.ops.quote_name(alias))\n+            sql = ', '.join(aggregate_columns)\n+            \n         sql = 'SELECT %s FROM (%s) subquery' % (sql, inner_query_sql)\n         params = params + inner_query_params\n         return sql, params\n",
    "variant_0": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex d405a203ee..e1e3068596 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1665,6 +1665,13 @@ class SQLUpdateCompiler(SQLCompiler):\n \n \n class SQLAggregateCompiler(SQLCompiler):\n+    def as_sql(self):\n+        \"\"\"\n+        Create the SQL for this query. Return the SQL string and list of\n+        parameters.\n+        \"\"\"\n+        sql, params = [], []\n+\n     def as_sql(self):\n         \"\"\"\n         Create the SQL for this query. Return the SQL string and list of\n@@ -1677,6 +1684,13 @@ class SQLAggregateCompiler(SQLCompiler):\n             sql.append(ann_sql)\n             params.extend(ann_params)\n         self.col_count = len(self.query.annotation_select)\n+        \n+        # If no annotations but we have aggregates, we need to select the aggregate columns\n+        if not sql and hasattr(self.query, 'aggregate_select') and self.query.aggregate_select:\n+            for alias in self.query.aggregate_select:\n+                sql.append(self.quote_name_unless_alias(alias))\n+            self.col_count = len(self.query.aggregate_select)\n+        \n         sql = ', '.join(sql)\n         params = tuple(params)\n \n",
    "variant_1": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex d405a203ee..aa57a6cd42 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1665,6 +1665,13 @@ class SQLUpdateCompiler(SQLCompiler):\n \n \n class SQLAggregateCompiler(SQLCompiler):\n+    def as_sql(self):\n+        \"\"\"\n+        Create the SQL for this query. Return the SQL string and list of\n+        parameters.\n+        \"\"\"\n+        sql, params = [], []\n+\n     def as_sql(self):\n         \"\"\"\n         Create the SQL for this query. Return the SQL string and list of\n@@ -1677,6 +1684,17 @@ class SQLAggregateCompiler(SQLCompiler):\n             sql.append(ann_sql)\n             params.extend(ann_params)\n         self.col_count = len(self.query.annotation_select)\n+        \n+        # If no annotations but we have aggregates, get column aliases from inner query\n+        if not sql and hasattr(self.query, 'inner_query') and self.query.inner_query:\n+            inner_compiler = self.query.inner_query.get_compiler(\n+                self.using, elide_empty=self.elide_empty,\n+            )\n+            # Get the annotation select from inner query to find aggregate aliases\n+            for alias, annotation in self.query.inner_query.annotation_select.items():\n+                sql.append(self.quote_name_unless_alias(alias))\n+            self.col_count = len(self.query.inner_query.annotation_select)\n+        \n         sql = ', '.join(sql)\n         params = tuple(params)\n \n",
    "variant_2": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex d405a203ee..4384e23f0b 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1665,6 +1665,13 @@ class SQLUpdateCompiler(SQLCompiler):\n \n \n class SQLAggregateCompiler(SQLCompiler):\n+    def as_sql(self):\n+        \"\"\"\n+        Create the SQL for this query. Return the SQL string and list of\n+        parameters.\n+        \"\"\"\n+        sql, params = [], []\n+\n     def as_sql(self):\n         \"\"\"\n         Create the SQL for this query. Return the SQL string and list of\n@@ -1677,6 +1684,20 @@ class SQLAggregateCompiler(SQLCompiler):\n             sql.append(ann_sql)\n             params.extend(ann_params)\n         self.col_count = len(self.query.annotation_select)\n+        \n+        # If we have no annotations to select, but we have aggregates,\n+        # we need to select the aggregate columns from the inner query\n+        if not sql and hasattr(self.query, 'inner_query') and self.query.inner_query:\n+            # Get the inner query compiler to check for aggregate annotations\n+            inner_compiler = self.query.inner_query.get_compiler(\n+                self.using, elide_empty=self.elide_empty,\n+            )\n+            # Extract aggregate column names from inner query annotations\n+            for alias, annotation in inner_compiler.query.annotation_select.items():\n+                if hasattr(annotation, 'source_expressions') and annotation.source_expressions:\n+                    sql.append(self.quote_name_unless_alias(alias))\n+            self.col_count = len(sql)\n+        \n         sql = ', '.join(sql)\n         params = tuple(params)\n \n",
    "variant_3": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex d405a203ee..6a8f537960 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1665,6 +1665,13 @@ class SQLUpdateCompiler(SQLCompiler):\n \n \n class SQLAggregateCompiler(SQLCompiler):\n+    def as_sql(self):\n+        \"\"\"\n+        Create the SQL for this query. Return the SQL string and list of\n+        parameters.\n+        \"\"\"\n+        sql, params = [], []\n+\n     def as_sql(self):\n         \"\"\"\n         Create the SQL for this query. Return the SQL string and list of\n@@ -1677,6 +1684,19 @@ class SQLAggregateCompiler(SQLCompiler):\n             sql.append(ann_sql)\n             params.extend(ann_params)\n         self.col_count = len(self.query.annotation_select)\n+        \n+        # Handle case where annotation_select is empty but we have aggregates\n+        if not sql and hasattr(self.query, 'annotations') and self.query.annotations:\n+            # Get column aliases for aggregates from the inner query\n+            inner_compiler = self.query.inner_query.get_compiler(\n+                self.using, elide_empty=self.elide_empty,\n+            )\n+            # Extract aggregate aliases from inner query's select clause\n+            for alias, annotation in self.query.annotations.items():\n+                if hasattr(annotation, 'source_expressions'):\n+                    sql.append(self.quote_name_unless_alias(alias))\n+            self.col_count = len(sql)\n+        \n         sql = ', '.join(sql)\n         params = tuple(params)\n \n",
    "variant_4": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex d405a203ee..c5a93ae59b 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1664,6 +1664,14 @@ class SQLUpdateCompiler(SQLCompiler):\n         self.query.reset_refcounts(refcounts_before)\n \n \n+class SQLAggregateCompiler(SQLCompiler):\n+    def as_sql(self):\n+        \"\"\"\n+        Create the SQL for this query. Return the SQL string and list of\n+        parameters.\n+        \"\"\"\n+        sql, params = [], []\n+\n class SQLAggregateCompiler(SQLCompiler):\n     def as_sql(self):\n         \"\"\"\n@@ -1677,6 +1685,18 @@ class SQLAggregateCompiler(SQLCompiler):\n             sql.append(ann_sql)\n             params.extend(ann_params)\n         self.col_count = len(self.query.annotation_select)\n+        \n+        # If no annotations in outer query but we have aggregates, we need to select them\n+        if not sql and hasattr(self.query, 'inner_query'):\n+            inner_compiler = self.query.inner_query.get_compiler(\n+                self.using, elide_empty=self.elide_empty,\n+            )\n+            # Get the aggregate aliases from the inner query\n+            for alias, annotation in inner_compiler.query.annotations.items():\n+                if hasattr(annotation, 'source_expressions'):\n+                    sql.append('\"%s\"' % alias)\n+            self.col_count = len(sql)\n+        \n         sql = ', '.join(sql)\n         params = tuple(params)\n \n",
    "variant_5": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex d405a203ee..1a40b2d79c 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1664,6 +1664,14 @@ class SQLUpdateCompiler(SQLCompiler):\n         self.query.reset_refcounts(refcounts_before)\n \n \n+class SQLAggregateCompiler(SQLCompiler):\n+    def as_sql(self):\n+        \"\"\"\n+        Create the SQL for this query. Return the SQL string and list of\n+        parameters.\n+        \"\"\"\n+        sql, params = [], []\n+\n class SQLAggregateCompiler(SQLCompiler):\n     def as_sql(self):\n         \"\"\"\n@@ -1677,15 +1685,28 @@ class SQLAggregateCompiler(SQLCompiler):\n             sql.append(ann_sql)\n             params.extend(ann_params)\n         self.col_count = len(self.query.annotation_select)\n-        sql = ', '.join(sql)\n-        params = tuple(params)\n-\n+        \n         inner_query_sql, inner_query_params = self.query.inner_query.get_compiler(\n             self.using, elide_empty=self.elide_empty,\n         ).as_sql(with_col_aliases=True)\n+        \n+        # If we have no annotations to select but we have aggregates in the inner query,\n+        # we need to select the aggregate columns from the subquery\n+        if not sql and hasattr(self.query, 'aggregates') and self.query.aggregates:\n+            # Get the aggregate aliases from the inner query\n+            aggregate_aliases = []\n+            for alias in self.query.aggregates.keys():\n+                aggregate_aliases.append('\"%s\"' % alias)\n+            sql = aggregate_aliases\n+            self.col_count = len(aggregate_aliases)\n+        \n+        sql = ', '.join(sql)\n+        params = tuple(params)\n         sql = 'SELECT %s FROM (%s) subquery' % (sql, inner_query_sql)\n         params = params + inner_query_params\n         return sql, params\n+        params = params + inner_query_params\n+        return sql, params\n \n \n def cursor_iter(cursor, sentinel, col_count, itersize):\n",
    "variant_6": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex d405a203ee..df45134e65 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1664,6 +1664,14 @@ class SQLUpdateCompiler(SQLCompiler):\n         self.query.reset_refcounts(refcounts_before)\n \n \n+class SQLAggregateCompiler(SQLCompiler):\n+    def as_sql(self):\n+        \"\"\"\n+        Create the SQL for this query. Return the SQL string and list of\n+        parameters.\n+        \"\"\"\n+        sql, params = [], []\n+\n class SQLAggregateCompiler(SQLCompiler):\n     def as_sql(self):\n         \"\"\"\n@@ -1677,15 +1685,29 @@ class SQLAggregateCompiler(SQLCompiler):\n             sql.append(ann_sql)\n             params.extend(ann_params)\n         self.col_count = len(self.query.annotation_select)\n-        sql = ', '.join(sql)\n-        params = tuple(params)\n-\n+        \n         inner_query_sql, inner_query_params = self.query.inner_query.get_compiler(\n             self.using, elide_empty=self.elide_empty,\n         ).as_sql(with_col_aliases=True)\n+        \n+        # If annotation_select is empty but we have aggregates, extract column aliases\n+        # from the inner query to avoid generating malformed SQL like \"SELECT FROM (...)\"\n+        if not sql and hasattr(self.query.inner_query, 'annotation_select'):\n+            # Extract aggregate column aliases from inner query annotations\n+            for alias, annotation in self.query.inner_query.annotation_select.items():\n+                if hasattr(annotation, 'source_expressions') and annotation.source_expressions:\n+                    # This is likely an aggregate - add its alias to the outer SELECT\n+                    sql.append('\"%s\"' % alias)\n+            self.col_count = len(sql)\n+        \n+        sql = ', '.join(sql) if sql else '*'\n+        params = tuple(params)\n+        \n         sql = 'SELECT %s FROM (%s) subquery' % (sql, inner_query_sql)\n         params = params + inner_query_params\n         return sql, params\n+        params = params + inner_query_params\n+        return sql, params\n \n \n def cursor_iter(cursor, sentinel, col_count, itersize):\n",
    "variant_7": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex d405a203ee..7fee205919 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1665,6 +1665,13 @@ class SQLUpdateCompiler(SQLCompiler):\n \n \n class SQLAggregateCompiler(SQLCompiler):\n+    def as_sql(self):\n+        \"\"\"\n+        Create the SQL for this query. Return the SQL string and list of\n+        parameters.\n+        \"\"\"\n+        sql, params = [], []\n+\n     def as_sql(self):\n         \"\"\"\n         Create the SQL for this query. Return the SQL string and list of\n@@ -1677,6 +1684,19 @@ class SQLAggregateCompiler(SQLCompiler):\n             sql.append(ann_sql)\n             params.extend(ann_params)\n         self.col_count = len(self.query.annotation_select)\n+        \n+        # If no annotations in outer query but we have aggregates, we need to select\n+        # the aggregate columns from the inner query\n+        if not sql and hasattr(self.query, 'inner_query') and self.query.inner_query:\n+            # Get the inner query compiler to determine what columns it selects\n+            inner_compiler = self.query.inner_query.get_compiler(\n+                self.using, elide_empty=self.elide_empty,\n+            )\n+            # Extract aggregate column aliases from inner query's annotations\n+            for alias, annotation in self.query.inner_query.annotations.items():\n+                sql.append(self.quote_name_unless_alias(alias))\n+            self.col_count = len(sql)\n+        \n         sql = ', '.join(sql)\n         params = tuple(params)\n \n",
    "variant_8": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex d405a203ee..eebe3c9e98 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1665,6 +1665,13 @@ class SQLUpdateCompiler(SQLCompiler):\n \n \n class SQLAggregateCompiler(SQLCompiler):\n+    def as_sql(self):\n+        \"\"\"\n+        Create the SQL for this query. Return the SQL string and list of\n+        parameters.\n+        \"\"\"\n+        sql, params = [], []\n+\n     def as_sql(self):\n         \"\"\"\n         Create the SQL for this query. Return the SQL string and list of\n@@ -1677,6 +1684,22 @@ class SQLAggregateCompiler(SQLCompiler):\n             sql.append(ann_sql)\n             params.extend(ann_params)\n         self.col_count = len(self.query.annotation_select)\n+        \n+        # If annotation_select is empty but we have aggregates, we need to select\n+        # the aggregate columns from the inner query\n+        if not sql and hasattr(self.query, 'inner_query'):\n+            # Get the inner query compiler to access its annotations\n+            inner_compiler = self.query.inner_query.get_compiler(\n+                self.using, elide_empty=self.elide_empty,\n+            )\n+            # Extract aggregate column aliases from inner query annotations\n+            for alias, annotation in inner_compiler.query.annotations.items():\n+                # Only include aggregates, not regular annotations\n+                from django.db.models.aggregates import Aggregate\n+                if isinstance(annotation, Aggregate):\n+                    sql.append(self.quote_name_unless_alias(alias))\n+            self.col_count = len(sql)\n+        \n         sql = ', '.join(sql)\n         params = tuple(params)\n \n"
  }
}