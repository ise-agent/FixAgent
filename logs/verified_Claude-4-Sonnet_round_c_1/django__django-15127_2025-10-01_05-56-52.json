{
  "zero_patches": {
    "Location 1 (/root/hy/projects/django/django/contrib/messages/storage/base.py lines 4-4)": "\nfrom django.conf import settings\nfrom django.contrib.messages import constants, utils\n\n\nclass Message:\n    \"\"\"\n    Represent an actual message that can be stored in any of the supported\n    storage classes (typically session- or cookie-based) and rendered in a view\n    or template.\n    \"\"\"\n\n    def __init__(self, level, message, extra_tags=None):\n        self.level = int(level)\n        self.message = message\n        self.extra_tags = extra_tags\n\n    def _prepare(self):\n        \"\"\"\n        Prepare the message for serialization by forcing the ``message``\n        and ``extra_tags`` to str in case they are lazy translations.\n        \"\"\"\n        self.message = str(self.message)\n        self.extra_tags = str(self.extra_tags) if self.extra_tags is not None else None\n\n    def __eq__(self, other):\n        if not isinstance(other, Message):\n            return NotImplemented\n        return self.level == other.level and self.message == other.message\n\n    def __str__(self):\n        return str(self.message)\n\n    @property\n    def tags(self):\n        return ' '.join(tag for tag in [self.extra_tags, self.level_tag] if tag)\n\n    @property\n    def level_tag(self):\n        return utils.get_level_tags().get(self.level, '')\n\n\nclass BaseStorage:\n    \"\"\"\n    This is the base backend for temporary message storage.\n\n    All message storage backends must provide these methods:\n\n    * ``__len__``\n    * ``__iter__``\n    * ``__contains__``\n    * ``add``\n    * ``_get``\n    * ``_store``\n\n    Subclasses should also implement:\n\n    * ``_get`` to retrieve messages from their storage location\n    * ``_store`` to save persistent messages to their storage location\n\n    If the backend is time- or size-limited, subclasses should also implement:\n\n    * ``_prepare_messages`` to clean up messaged before storing in ``_store``\n\n    This backend is not guaranteed to be thread safe.\n    \"\"\"\n    def __init__(self, request, *args, **kwargs):\n        self.request = request\n        self._queued_messages = []\n        self.used = False\n        self.added_new = False\n        super().__init__(*args, **kwargs)\n\n    def __len__(self):\n        return len(self._loaded_messages) + len(self._queued_messages)\n\n    def __iter__(self):\n        self.used = True\n        if self._queued_messages:\n            self._loaded_messages.extend(self._queued_messages)\n            self._queued_messages = []\n        return iter(self._loaded_messages)\n\n    def __contains__(self, item):\n        return item in self._loaded_messages or item in self._queued_messages\n\n    @property\n    def _loaded_messages(self):\n        \"\"\"\n        Return a list of loaded messages, retrieving them first if they have\n        not been loaded yet.\n        \"\"\"\n        if not hasattr(self, '_loaded_data'):\n            messages, all_retrieved = self._get()\n            self._loaded_data = messages or []\n        return self._loaded_data\n\n    def _get(self, *args, **kwargs):\n        \"\"\"\n        Retrieve a list of stored messages. Return a tuple of the messages\n        and a flag indicating whether or not all the messages originally\n        intended to be stored in this storage were, in fact, stored and\n        retrieved; e.g., ``(messages, all_retrieved)``.\n\n        **This method must be implemented by a subclass.**\n\n        If it is possible to tell if the backend was not used (as opposed to\n        just containing no messages) then ``None`` should be returned in\n        place of ``messages``.\n        \"\"\"\n        raise NotImplementedError('subclasses of BaseStorage must provide a _get() method')\n\n    def _store(self, messages, response, *args, **kwargs):\n        \"\"\"\n        Store a list of messages and return a list of any messages which could\n        not be stored.\n\n        One type of object must be able to be stored, ``Message``.\n\n        **This method must be implemented by a subclass.**\n        \"\"\"\n        raise NotImplementedError('subclasses of BaseStorage must provide a _store() method')\n\n    def _prepare_messages(self, messages):\n        \"\"\"\n        Prepare a list of messages for storage.\n        \"\"\"\n        for message in messages:\n            message._prepare()\n\n    def update(self, response):\n        \"\"\"\n        Store all unread messages.\n\n        If the backend has yet to be iterated, store all messages, and return\n        only the messages that could not be stored.\n\n        Otherwise, store any messages that were added after the last iteration\n        and return them.\n        \"\"\"\n        if self.used:\n            return self._store(self._queued_messages, response)\n        elif self.added_new:\n            messages = self._loaded_messages + self._queued_messages\n        else:\n            messages = self._loaded_messages\n\n        self._prepare_messages(messages)\n        return self._store(messages, response)\n\n    def add(self, level, message, extra_tags=''):\n        \"\"\"\n        Queue a message to be stored.\n\n        The message is only queued if it contained something and its level is\n        not less than the recording level (``self.level``).\n        \"\"\"\n        if not message:\n            return\n\n        # Check that the message level is not less than the recording level.\n        level = int(level)\n        if level < self.level:\n            return\n\n        # Add the message.\n        self.added_new = True\n        message = Message(level, message, extra_tags=extra_tags)\n        self._queued_messages.append(message)\n\n    def _get_level(self):\n        \"\"\"\n        Return the minimum recorded level.\n\n        The default level is the ``MESSAGE_LEVEL`` setting. If this is\n        not found, the ``INFO`` level is used.\n        \"\"\"\n        return getattr(settings, 'MESSAGE_LEVEL', constants.INFO)\n\n    def _set_level(self, value=None):\n        \"\"\"\n        Set a custom minimum recorded level.\n\n        If set to ``None``, the default level will be used (see the\n        ``_get_level`` method).\n        \"\"\"\n        if value is None:\n            value = self._get_level()\n        else:\n            value = int(value)\n        self._level = value\n\n    level = property(_get_level, _set_level, doc=\"\"\"\n        The minimum recorded level.\n\n        This can be set to record only messages with a level greater than or\n        equal to this level. See constants for the built-in levels.\n        \"\"\")\n",
    "Location 2 (/root/hy/projects/django/django/contrib/messages/storage/base.py lines 40-41)": "\n    @property\n    def level_tag(self):\n        return utils.get_level_tags().get(self.level, '')\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/django/django/contrib/messages/storage/base.py lines 4-4)": [
      "\nfrom django.conf import settings\nfrom django.contrib.messages import constants, utils\n\n\nclass Message:\n    \"\"\"\n    Represent an actual message that can be stored in any of the supported\n    storage classes (typically session- or cookie-based) and rendered in a view\n    or template.\n    \"\"\"\n\n    def __init__(self, level, message, extra_tags=None):\n        self.level = int(level)\n        self.message = message\n        self.extra_tags = extra_tags\n\n    def _prepare(self):\n        \"\"\"\n        Prepare the message for serialization by forcing the ``message``\n        and ``extra_tags`` to str in case they are lazy translations.\n        \"\"\"\n        self.message = str(self.message)\n        self.extra_tags = str(self.extra_tags) if self.extra_tags is not None else None\n\n    def __eq__(self, other):\n        if not isinstance(other, Message):\n            return NotImplemented\n        return self.level == other.level and self.message == other.message\n\n    def __str__(self):\n        return str(self.message)\n\n    @property\n    def tags(self):\n        return ' '.join(tag for tag in [self.extra_tags, self.level_tag] if tag)\n\n    @property\n    def level_tag(self):\n        return utils.get_level_tags().get(self.level, '')\n\n\nclass BaseStorage:\n    \"\"\"\n    This is the base backend for temporary message storage.\n\n    This is not a complete class; to be a usable storage backend, it must be\n    subclassed and the two methods ``_get`` and ``_store`` overridden.\n    \"\"\"\n\n    def __init__(self, request, *args, **kwargs):\n        self.request = request\n        self._queued_messages = []\n        self.used = False\n        self.added_new = False\n        super().__init__(*args, **kwargs)\n\n    def __len__(self):\n        return len(self._loaded_messages) + len(self._queued_messages)\n\n    def __iter__(self):\n        self.used = True\n        if self._queued_messages:\n            self._loaded_messages.extend(self._queued_messages)\n            self._queued_messages = []\n        return iter(self._loaded_messages)\n\n    def __contains__(self, item):\n        return item in self._loaded_messages or item in self._queued_messages\n\n    @property\n    def _loaded_messages(self):\n        \"\"\"\n        Return a list of loaded messages, retrieving them first if they have\n        not been loaded yet.\n        \"\"\"\n        if not hasattr(self, '_loaded_data'):\n            messages, all_retrieved = self._get()\n            self._loaded_data = messages or []\n        return self._loaded_data\n\n    def _get(self, *args, **kwargs):\n        \"\"\"\n        Retrieve a list of stored messages. Return a tuple of the messages\n        and a flag indicating whether or not all the messages originally\n        intended to be stored in this storage were, in fact, stored and\n        retrieved; e.g., ``(messages, all_retrieved)``.\n\n        **This method must be implemented by a subclass.**\n\n        If it is possible to tell if the backend was not used (as opposed to\n        just containing no messages) then ``None`` should be returned in\n        place of ``messages``.\n        \"\"\"\n        raise NotImplementedError('subclasses of BaseStorage must provide a _get() method')\n\n    def _store(self, messages, response, *args, **kwargs):\n        \"\"\"\n        Store a list of messages and return a list of any messages which could\n        not be stored.\n\n        One type of object must be able to be stored, ``Message``.\n\n        **This method must be implemented by a subclass.**\n        \"\"\"\n        raise NotImplementedError('subclasses of BaseStorage must provide a _store() method')\n\n    def _prepare_messages(self, messages):\n        \"\"\"\n        Prepare a list of messages for storage.\n        \"\"\"\n        for message in messages:\n            message._prepare()\n\n    def update(self, response):\n        \"\"\"\n        Store all unread messages.\n\n        If the backend has yet to be iterated, previously stored messages will\n        be stored again. Otherwise, only messages added after the last\n        iteration will be stored.\n        \"\"\"\n        self._prepare_messages(self._queued_messages)\n        if self.used:\n            return self._store(self._queued_messages, response)\n        elif self.added_new:\n            messages = self._loaded_messages + self._queued_messages\n            return self._store(messages, response)\n\n    def add(self, level, message, extra_tags=''):\n        \"\"\"\n        Queue a message to be stored.\n\n        The message is only queued if it contained something and its level is\n        not less than the recording level (``MESSAGE_LEVEL``).\n        \"\"\"\n        if not message:\n            return\n\n        # Check that the message level is not less than the recording level.\n        level = int(level)\n        if level < getattr(settings, 'MESSAGE_LEVEL', constants.INFO):\n            return\n\n        # Add the message.\n        self.added_new = True\n        message = Message(level, message, extra_tags=extra_tags)\n        self._queued_messages.append(message)\n\n    def _get_level(self):\n        \"\"\"\n        Return the minimum recorded level.\n\n        The default level is the ``MESSAGE_LEVEL`` setting. If this is not\n        found, the ``INFO`` level is used.\n        \"\"\"\n        return getattr(settings, 'MESSAGE_LEVEL', constants.INFO)\n\n    def _set_level(self, value=None):\n        \"\"\"\n        Set a custom minimum recorded level.\n\n        If set to ``None``, the default level will be used (see the\n        ``_get_level`` method).\n        \"\"\"\n        if value is None and hasattr(self, '_level'):\n            del self._level\n        else:\n            self._level = int(value)\n\n    level = property(_get_level, _set_level, _set_level)\n",
      "\nfrom django.conf import settings\nfrom django.contrib.messages import constants, utils\n\n\nclass Message:\n    \"\"\"\n    Represent an actual message that can be stored in any of the supported\n    storage classes (typically session- or cookie-based) and rendered in a view\n    or template.\n    \"\"\"\n\n    def __init__(self, level, message, extra_tags=None):\n        self.level = int(level)\n        self.message = message\n        self.extra_tags = extra_tags\n\n    def _prepare(self):\n        \"\"\"\n        Prepare the message for serialization by forcing the ``message``\n        and ``extra_tags`` to str in case they are lazy translations.\n        \"\"\"\n        self.message = str(self.message)\n        self.extra_tags = str(self.extra_tags) if self.extra_tags is not None else None\n\n    def __eq__(self, other):\n        if not isinstance(other, Message):\n            return NotImplemented\n        return self.level == other.level and self.message == other.message\n\n    def __str__(self):\n        return str(self.message)\n\n    @property\n    def tags(self):\n        return ' '.join(tag for tag in [self.extra_tags, self.level_tag] if tag)\n\n    @property\n    def level_tag(self):\n        return utils.get_level_tags().get(self.level, '')\n\n\nclass BaseStorage:\n    \"\"\"\n    This is the base backend for temporary message storage.\n\n    This is not a complete class; to be a usable storage backend, it must be\n    subclassed and the two methods ``_get`` and ``_store`` overridden.\n    \"\"\"\n\n    def __init__(self, request, *args, **kwargs):\n        self.request = request\n        self._queued_messages = []\n        self.used = False\n        self.added_new = False\n        super().__init__(*args, **kwargs)\n\n    def __len__(self):\n        return len(self._loaded_messages) + len(self._queued_messages)\n\n    def __iter__(self):\n        self.used = True\n        if self._queued_messages:\n            self._loaded_messages.extend(self._queued_messages)\n            self._queued_messages = []\n        return iter(self._loaded_messages)\n\n    def __contains__(self, item):\n        return item in self._loaded_messages or item in self._queued_messages\n\n    @property\n    def _loaded_messages(self):\n        \"\"\"\n        Return a list of loaded messages, retrieving them first if they have\n        not been loaded yet.\n        \"\"\"\n        if not hasattr(self, '_loaded_data'):\n            messages, all_retrieved = self._get()\n            self._loaded_data = messages or []\n        return self._loaded_data\n\n    def _get(self, *args, **kwargs):\n        \"\"\"\n        Retrieve any stored messages. Return a tuple of the messages retrieved\n        and a flag indicating whether or not all the messages originally\n        intended to be stored in this storage were, in fact, stored and\n        retrieved; e.g., ``(messages, all_retrieved)``.\n\n        **This method must be implemented by a subclass.**\n\n        If it is possible to tell if the backend was not used (as opposed to\n        just containing no messages) then ``None`` should be returned in\n        place of ``messages``.\n        \"\"\"\n        raise NotImplementedError('subclasses of BaseStorage must provide a _get() method')\n\n    def _store(self, messages, response, *args, **kwargs):\n        \"\"\"\n        Store a list of messages and return a list of any messages which could\n        not be stored.\n\n        One type of object must be able to be stored, ``Message``.\n\n        **This method must be implemented by a subclass.**\n        \"\"\"\n        raise NotImplementedError('subclasses of BaseStorage must provide a _store() method')\n\n    def _prepare_messages(self, messages):\n        \"\"\"\n        Prepare a list of messages for storage.\n        \"\"\"\n        for message in messages:\n            message._prepare()\n\n    def update(self, response):\n        \"\"\"\n        Store all unread messages.\n\n        If the backend has yet to be iterated, store all queued messages.\n        Otherwise, store any messages added after the last iteration.\n        \"\"\"\n        self._prepare_messages(self._queued_messages)\n        if self.used:\n            return self._store(self._queued_messages, response)\n        elif self.added_new:\n            messages = self._loaded_messages + self._queued_messages\n            return self._store(messages, response)\n\n    def add(self, level, message, extra_tags=''):\n        \"\"\"\n        Queue a message to be stored.\n\n        The message is only queued if it contained something and its level is\n        not less than the recording level (``MESSAGE_LEVEL``).\n        \"\"\"\n        if not message:\n            return\n\n        # Check that the message level is not less than the recording level.\n        level = int(level)\n        if level < getattr(settings, 'MESSAGE_LEVEL', constants.INFO):\n            return\n\n        # Add the message.\n        self.added_new = True\n        message = Message(level, message, extra_tags=extra_tags)\n        self._queued_messages.append(message)\n\n    def _get_level(self):\n        \"\"\"\n        Return the minimum recorded level.\n\n        The default level is the ``MESSAGE_LEVEL`` setting. If this is\n        not found, the ``INFO`` level is used.\n        \"\"\"\n        return getattr(settings, 'MESSAGE_LEVEL', constants.INFO)\n\n    def _set_level(self, value=None):\n        \"\"\"\n        Set a custom minimum recorded level.\n\n        If set to ``None``, the default level will be used (see the\n        ``_get_level`` method).\n        \"\"\"\n        if value is None and hasattr(self, '_level'):\n            del self._level\n        else:\n            self._level = int(value)\n\n    level = property(_get_level, _set_level, _set_level)\n",
      "\nfrom django.conf import settings\nfrom django.contrib.messages import constants, utils\n\n\nclass Message:\n    \"\"\"\n    Represent an actual message that can be stored in any of the supported\n    storage classes (typically session- or cookie-based) and rendered in a view\n    or template.\n    \"\"\"\n\n    def __init__(self, level, message, extra_tags=None):\n        self.level = int(level)\n        self.message = message\n        self.extra_tags = extra_tags\n\n    def _prepare(self):\n        \"\"\"\n        Prepare the message for serialization by forcing the ``message``\n        and ``extra_tags`` to str in case they are lazy translations.\n        \"\"\"\n        self.message = str(self.message)\n        self.extra_tags = str(self.extra_tags) if self.extra_tags is not None else None\n\n    def __eq__(self, other):\n        if not isinstance(other, Message):\n            return NotImplemented\n        return (\n            self.level == other.level and\n            self.message == other.message and\n            self.extra_tags == other.extra_tags\n        )\n\n    def __str__(self):\n        return str(self.message)\n\n    @property\n    def tags(self):\n        return ' '.join(tag for tag in [self.extra_tags, self.level_tag] if tag)\n\n    @property\n    def level_tag(self):\n        return utils.get_level_tags().get(self.level, '')\n\n\nclass BaseStorage:\n    \"\"\"\n    This is the base backend for temporary message storage.\n\n    This is not a complete class; to be a usable storage backend, it must be\n    subclassed and the two methods ``_get`` and ``_store`` overridden.\n    \"\"\"\n\n    def __init__(self, request, *args, **kwargs):\n        self.request = request\n        self._queued_messages = []\n        self.used = False\n        self.added_new = False\n        super().__init__(*args, **kwargs)\n\n    def __len__(self):\n        return len(self._loaded_messages) + len(self._queued_messages)\n\n    def __iter__(self):\n        self.used = True\n        if self._queued_messages:\n            self._loaded_messages.extend(self._queued_messages)\n            self._queued_messages = []\n        return iter(self._loaded_messages)\n\n    def __contains__(self, item):\n        return item in self._loaded_messages or item in self._queued_messages\n\n    @property\n    def _loaded_messages(self):\n        \"\"\"\n        Return a list of loaded messages, retrieving them first if they have\n        not been loaded yet.\n        \"\"\"\n        if not hasattr(self, '_loaded_data'):\n            messages, all_retrieved = self._get()\n            self._loaded_data = messages or []\n        return self._loaded_data\n\n    def _get(self, *args, **kwargs):\n        \"\"\"\n        Retrieve a list of stored messages. Return a tuple of the messages\n        and a flag indicating whether or not all the messages originally\n        intended to be stored in this storage were, in fact, stored and\n        retrieved; e.g., ``(messages, all_retrieved)``.\n\n        **This method must be implemented by a subclass.**\n\n        If it is possible to tell if the backend was not used (as opposed to\n        just containing no messages) then ``None`` should be returned in\n        place of ``messages``.\n        \"\"\"\n        raise NotImplementedError('subclasses of BaseStorage must provide a _get() method')\n\n    def _store(self, messages, response, *args, **kwargs):\n        \"\"\"\n        Store a list of messages and return a list of any messages which could\n        not be stored.\n\n        One type of object must be able to be stored, ``Message``.\n\n        **This method must be implemented by a subclass.**\n        \"\"\"\n        raise NotImplementedError('subclasses of BaseStorage must provide a _store() method')\n\n    def _prepare_messages(self, messages):\n        \"\"\"\n        Prepare a list of messages for storage.\n        \"\"\"\n        for message in messages:\n            message._prepare()\n\n    def update(self, response):\n        \"\"\"\n        Store all unread messages.\n\n        If the backend has yet to be iterated, store all queued messages.\n        Otherwise, store any messages added after the last iteration.\n        \"\"\"\n        self._prepare_messages(self._queued_messages)\n        if self.used:\n            return self._store(self._queued_messages, response)\n        elif self.added_new:\n            messages = self._loaded_messages + self._queued_messages\n            return self._store(messages, response)\n\n    def add(self, level, message, extra_tags=''):\n        \"\"\"\n        Queue a message to be stored.\n\n        The message is only queued if it contained something and its level is\n        not less than the recording level (``MESSAGE_LEVEL``).\n        \"\"\"\n        if not message:\n            return\n\n        # Check that the message level is not less than the recording level.\n        level = int(level)\n        if level < self.level:\n            return\n\n        # Add the message.\n        self.added_new = True\n        message = Message(level, message, extra_tags=extra_tags)\n        self._queued_messages.append(message)\n\n    def _get_level(self):\n        \"\"\"\n        Return the minimum recorded level.\n\n        The default level is the ``MESSAGE_LEVEL`` setting. If this is\n        not found, the ``INFO`` level is used.\n        \"\"\"\n        return getattr(settings, 'MESSAGE_LEVEL', constants.INFO)\n\n    def _set_level(self, value=None):\n        \"\"\"\n        Set a custom minimum recorded level.\n\n        If set to ``None``, the default level will be used (see the\n        ``_get_level`` method).\n        \"\"\"\n        if value is None and hasattr(self, '_level'):\n            del self._level\n        else:\n            self._level = int(value)\n\n    level = property(_get_level, _set_level, _set_level)\n",
      "\nfrom django.conf import settings\nfrom django.contrib.messages import constants, utils\n\n\nclass Message:\n    \"\"\"\n    Represent an actual message that can be stored in any of the supported\n    storage classes (typically session- or cookie-based) and rendered in a view\n    or template.\n    \"\"\"\n\n    def __init__(self, level, message, extra_tags=None):\n        self.level = int(level)\n        self.message = message\n        self.extra_tags = extra_tags\n\n    def _prepare(self):\n        \"\"\"\n        Prepare the message for serialization by forcing the ``message``\n        and ``extra_tags`` to str in case they are lazy translations.\n        \"\"\"\n        self.message = str(self.message)\n        self.extra_tags = str(self.extra_tags) if self.extra_tags is not None else None\n\n    def __eq__(self, other):\n        if not isinstance(other, Message):\n            return NotImplemented\n        return self.level == other.level and self.message == other.message\n\n    def __str__(self):\n        return str(self.message)\n\n    @property\n    def tags(self):\n        return ' '.join(tag for tag in [self.extra_tags, self.level_tag] if tag)\n\n    @property\n    def level_tag(self):\n        return utils.get_level_tags().get(self.level, '')\n\n\nclass BaseStorage:\n    \"\"\"\n    This is the base backend for temporary message storage.\n\n    All message storage backends must provide these methods:\n\n    * add(level, message, extra_tags=None)\n    * _get()\n    * _store(messages, response, *args, **kwargs)\n\n    If the backend is iterating the data without storing anything on the\n    request, then _store() method should do nothing, _get() method\n    shouldn't be implemented (or just return []) and the backend\n    should use _loaded_data attribute to tell whether it has already\n    read the data or not. This is for memory efficiency.\n\n    There are no restrictions as to where a backend may save its data,\n    such as in a database, file, cache, session, or cookie. The backend's\n    storage is not expected to be persistent between requests.\n\n    Each message is stored as an instance of the Message class.\n    \"\"\"\n\n    def __init__(self, request, *args, **kwargs):\n        self.request = request\n        self._queued_messages = []\n        self.used = False\n        self.added_new = False\n\n    def __len__(self):\n        return len(self._get_messages())\n\n    def __iter__(self):\n        self.used = True\n        if self._queued_messages:\n            self._store_messages(self._queued_messages)\n            self._queued_messages = []\n        return iter(self._get_messages())\n\n    def __contains__(self, item):\n        return item in self._get_messages()\n\n    @property\n    def level(self):\n        \"\"\"\n        Return the minimum recorded level.\n\n        The default level is the ``MESSAGE_LEVEL`` setting. If this is not\n        found, the ``INFO`` level is used.\n        \"\"\"\n        if not hasattr(self, '_level'):\n            self._level = getattr(settings, 'MESSAGE_LEVEL', constants.INFO)\n        return self._level\n\n    @level.setter\n    def level(self, value):\n        \"\"\"\n        Set a custom minimum recorded level.\n\n        If set to ``None``, Django's default ``MESSAGE_LEVEL`` will be used.\n        \"\"\"\n        if value is None and hasattr(self, '_level'):\n            del self._level\n        else:\n            self._level = int(value)\n\n    def _get_messages(self):\n        \"\"\"\n        Return a list of messages, marking the storage as used.\n        \"\"\"\n        messages = getattr(self, '_loaded_messages', None)\n        if messages is None:\n            self._loaded_messages = self._get()\n        return self._loaded_messages or []\n\n    def _store_messages(self, messages):\n        \"\"\"\n        Store a list of messages and return a list of any messages which could\n        not be stored.\n\n        One type of object must be able to be stored, ``Message``.\n        \"\"\"\n        raise NotImplementedError('subclasses of BaseStorage must provide a _store() method')\n\n    def _get(self):\n        \"\"\"\n        Retrieve a list of messages stored in this backend.\n        \"\"\"\n        raise NotImplementedError('subclasses of BaseStorage must provide a _get() method')\n\n    def add(self, level, message, extra_tags=''):\n        \"\"\"\n        Queue a message to be stored.\n\n        The message is only queued if it contained something and its level is\n        not less than the recording level (``self.level``).\n        \"\"\"\n        if not message:\n            return\n\n        # Check that the message level is not less than the recording level.\n        level = int(level)\n        if level < self.level:\n            return\n\n        # Add the message.\n        self.added_new = True\n        message = Message(level, message, extra_tags=extra_tags)\n        self._queued_messages.append(message)\n\n    def _prepare_messages(self, messages):\n        \"\"\"\n        Prepare a list of messages for storage.\n        \"\"\"\n        for message in messages:\n            message._prepare()\n\n    def update(self, response):\n        \"\"\"\n        Store all unqueued messages.\n\n        If the backend has yet to be iterated, store all queued messages.\n        Otherwise, only store messages that were added after the last\n        iteration.\n        \"\"\"\n        if self.used:\n            return self._store_messages(self._queued_messages)\n        elif self.added_new:\n            messages = self._loaded_messages or []\n            messages.extend(self._queued_messages)\n            return self._store_messages(messages)\n",
      "\nfrom django.conf import settings\nfrom django.contrib.messages import constants, utils\n\n\nclass Message:\n    \"\"\"\n    Represent an actual message that can be stored in any of the supported\n    storage classes (typically session- or cookie-based) and rendered in a view\n    or template.\n    \"\"\"\n\n    def __init__(self, level, message, extra_tags=None):\n        self.level = int(level)\n        self.message = message\n        self.extra_tags = extra_tags\n\n    def _prepare(self):\n        \"\"\"\n        Prepare the message for serialization by forcing the ``message``\n        and ``extra_tags`` to str in case they are lazy translations.\n        \"\"\"\n        self.message = str(self.message)\n        self.extra_tags = str(self.extra_tags) if self.extra_tags is not None else None\n\n    def __eq__(self, other):\n        if not isinstance(other, Message):\n            return NotImplemented\n        return (\n            self.level == other.level and\n            self.message == other.message and\n            self.extra_tags == other.extra_tags\n        )\n\n    def __str__(self):\n        return str(self.message)\n\n    @property\n    def tags(self):\n        return ' '.join(tag for tag in [self.extra_tags, self.level_tag] if tag)\n\n    @property\n    def level_tag(self):\n        return utils.get_level_tags().get(self.level, '')\n\n\nclass BaseStorage:\n    \"\"\"\n    This is the base backend for temporary message storage.\n\n    For each message, a new instance of the storage backend is created.\n    Then the add() and iteration interface is used. Finally, unused()\n    indicates whether the messages have been iterated over. A storage\n    backend can only be iterated over once because it's designed to be\n    exhausted when rendering the response (otherwise, the REQUEST_METHOD\n    / URL combination could re-trigger the same error message being\n    displayed multiple times).\n    \"\"\"\n\n    def __init__(self, request, *args, **kwargs):\n        self.request = request\n        self._queued_messages = []\n        self.used = False\n        self.added_new = False\n\n    def __len__(self):\n        return len(self._queued_messages)\n\n    def __iter__(self):\n        self.used = True\n        if self._queued_messages:\n            self._prepare_messages(self._queued_messages)\n        return iter(self._queued_messages)\n\n    def __contains__(self, item):\n        return item in self._queued_messages\n\n    @property\n    def level(self):\n        \"\"\"\n        Return the minimum recorded level.\n\n        Default level is 20 (INFO).\n        \"\"\"\n        if self._queued_messages:\n            return min(m.level for m in self._queued_messages)\n        return constants.INFO\n\n    def _prepare_messages(self, messages):\n        \"\"\"\n        Prepare a list of messages for storage.\n        \"\"\"\n        for message in messages:\n            message._prepare()\n\n    def update(self, response):\n        \"\"\"\n        Store all unprocessed messages.\n\n        If the backend has yet to be iterated, store all queued messages.\n        Otherwise, only store messages added after the last iteration.\n        \"\"\"\n        self._store(self._get_messages(), response)\n\n    def add(self, level, message, extra_tags=None):\n        \"\"\"\n        Queue a message to be stored.\n\n        The message is only queued if it contained something and its level is\n        not less than the recording level (``self.level``).\n        \"\"\"\n        if not message:\n            return\n        # Check that the message level is not less than the recording level.\n        level = int(level)\n        if level < self.level:\n            return\n\n        # Add the message.\n        self.added_new = True\n        message = Message(level, message, extra_tags=extra_tags)\n        self._queued_messages.append(message)\n\n    def _get_messages(self):\n        return self._queued_messages\n\n    def _store(self, messages, response, *args, **kwargs):\n        \"\"\"\n        Store a list of messages and return a list of any messages which could\n        not be stored.\n\n        One type of object must be able to be stored, ``Message``.\n\n        **This method must be implemented by a subclass.**\n\n        If it is possible to tell if the backend was not used (i.e., no\n        messages were actually retrieved) then ``None`` should be returned in\n        place of ``[]``.\n        \"\"\"\n        raise NotImplementedError(\n            'subclasses of BaseStorage must provide a _store() method')\n\n    def _delete(self):\n        \"\"\"\n        Delete all stored messages and return a list of messages which could\n        not be deleted.\n\n        **This method must be implemented by a subclass.**\n        \"\"\"\n        raise NotImplementedError(\n            'subclasses of BaseStorage must provide a _delete() method')\n",
      "\nfrom django.conf import settings\nfrom django.contrib.messages import constants, utils\n\n\nclass Message:\n    \"\"\"\n    Represent an actual message that can be stored in any of the supported\n    storage classes (typically session- or cookie-based) and rendered in a view\n    or template.\n    \"\"\"\n\n    def __init__(self, level, message, extra_tags=None):\n",
      "\nfrom django.conf import settings\nfrom django.contrib.messages import constants, utils\n\n\nclass Message:\n    \"\"\"\n    Represent an actual message that can be stored in any of the supported\n    storage classes (typically session- or cookie-based) and rendered in a view\n    or template.\n    \"\"\"\n\n    def __init__(self, level, message, extra_tags=None):\n        self.level = int(level)\n        self.message = message\n        self.extra_tags = extra_tags\n\n    def _prepare(self):\n        \"\"\"\n        Prepare the message for serialization by forcing the ``message``\n        and ``extra_tags`` to str in case they are lazy translations.\n        \"\"\"\n        self.message = str(self.message)\n        self.extra_tags = str(self.extra_tags) if self.extra_tags is not None else None\n\n    def __eq__(self, other):\n        if not isinstance(other, Message):\n            return NotImplemented\n        return self.level == other.level and self.message == other.message\n\n    def __str__(self):\n        return str(self.message)\n\n    @property\n    def tags(self):\n        return ' '.join(tag for tag in [self.extra_tags, self.level_tag] if tag)\n\n    @property\n    def level_tag(self):\n        return utils.get_level_tags().get(self.level, '')\n\n\nclass BaseStorage:\n    \"\"\"\n    This is the base backend for temporary message storage.\n\n    Subclasses must implement the two methods marked as raising\n    NotImplementedError.\n    \"\"\"\n    def __init__(self, request, *args, **kwargs):\n        self.request = request\n        self._queued_messages = []\n        self.used = False\n        self.added_new = False\n\n    def __len__(self):\n        return len(self._queued_messages)\n\n    def __iter__(self):\n        self.used = True\n        if self._queued_messages:\n            self._queued_messages = []\n\n    def __contains__(self, item):\n        return item in self._queued_messages\n\n    def add(self, level, message, extra_tags=''):\n        \"\"\"\n        Queue a message to be stored.\n\n        The message is only queued if it contained something and its level is\n        not less than the recording level (``MESSAGE_LEVEL``).\n        \"\"\"\n        if not message:\n            return\n\n        # Check that the message level is not less than the recording level.\n        level = int(level)\n        if level < self.level:\n            return\n\n        # Add the message.\n        self.added_new = True\n        message = Message(level, message, extra_tags=extra_tags)\n        self._queued_messages.append(message)\n\n    def _get(self, *args, **kwargs):\n        \"\"\"\n        Retrieve a list of stored messages. Return a tuple of the messages\n        and a flag indicating whether or not all the messages originally\n        intended to be stored in this storage were, in fact, stored and\n        retrieved; e.g., ``(messages, all_retrieved)``.\n\n        **This method must be implemented by a subclass.**\n\n        If it is possible to tell if the backend was not used (as opposed to\n        just containing no messages) then ``None`` should be returned in\n        place of ``messages``.\n        \"\"\"\n        raise NotImplementedError('subclasses of BaseStorage must provide a _get() method')\n\n    def _store(self, messages, response, *args, **kwargs):\n        \"\"\"\n        Store a list of messages and return a list of any messages which could\n        not be stored.\n\n        One type of object must be able to be stored, ``Message``.\n\n        **This method must be implemented by a subclass.**\n        \"\"\"\n        raise NotImplementedError('subclasses of BaseStorage must provide a _store() method')\n\n    @property\n    def level(self):\n        \"\"\"\n        Return the minimum recorded level.\n\n        The default level is the ``MESSAGE_LEVEL`` setting. If this is\n        not found, the ``INFO`` level is used.\n        \"\"\"\n        if not hasattr(self, '_level'):\n            self._level = getattr(settings, 'MESSAGE_LEVEL', constants.INFO)\n        return self._level\n\n    @level.setter\n    def level(self, value):\n        self._level = int(value)\n\n    def update(self, response):\n        \"\"\"\n        Store all unprocessed messages.\n\n        If the backend has yet to be iterated, store all queued messages.\n        Otherwise, only store messages added after the last iteration.\n        \"\"\"\n        if self.used:\n            return\n        if self.added_new:\n            self._store(self._queued_messages, response)\n            self.added_new = False\n",
      "\nfrom django.conf import settings\nfrom django.contrib.messages import constants, utils\n\n\nclass Message:\n    \"\"\"\n    Represent an actual message that can be stored in any of the supported\n    storage classes (typically session- or cookie-based) and rendered in a view\n    or template.\n    \"\"\"\n\n    def __init__(self, level, message, extra_tags=None):\n        self.level = int(level)\n        self.message = message\n        self.extra_tags = extra_tags\n\n    def _prepare(self):\n        \"\"\"\n        Prepare the message for serialization by forcing the ``message``\n        and ``extra_tags`` to str in case they are lazy translations.\n        \"\"\"\n        self.message = str(self.message)\n        self.extra_tags = str(self.extra_tags) if self.extra_tags is not None else None\n\n    def __eq__(self, other):\n        if not isinstance(other, Message):\n            return NotImplemented\n        return (\n            self.level == other.level and\n            self.message == other.message and\n            self.extra_tags == other.extra_tags\n        )\n\n    def __str__(self):\n        return str(self.message)\n\n    @property\n    def tags(self):\n        return ' '.join(tag for tag in [self.extra_tags, self.level_tag] if tag)\n\n    @property\n    def level_tag(self):\n        return utils.get_level_tags().get(self.level, '')\n\n\nclass BaseStorage:\n    \"\"\"\n    This is the base backend for temporary message storage.\n\n    This is not a complete class; to be a usable storage backend, it must be\n    subclassed and the two methods ``_get`` and ``_store`` overridden.\n    \"\"\"\n\n    def __init__(self, request, *args, **kwargs):\n        self.request = request\n        self._queued_messages = []\n        self.used = False\n        self.added_new = False\n        super().__init__(*args, **kwargs)\n\n    def __len__(self):\n        return len(self._loaded_messages) + len(self._queued_messages)\n\n    def __iter__(self):\n        self.used = True\n        if self._queued_messages:\n            self._loaded_messages.extend(self._queued_messages)\n            self._queued_messages = []\n        return iter(self._loaded_messages)\n\n    def __contains__(self, item):\n        return item in self._loaded_messages or item in self._queued_messages\n\n    @property\n    def _loaded_messages(self):\n        \"\"\"\n        Return a list of loaded messages, retrieving them first if they have\n        not been loaded yet.\n        \"\"\"\n        if not hasattr(self, '_loaded_data'):\n            messages, all_retrieved = self._get()\n            self._loaded_data = messages or []\n        return self._loaded_data\n\n    def _get(self, *args, **kwargs):\n        \"\"\"\n        Retrieve a list of stored messages. Return a tuple of the messages\n        and a flag indicating whether or not all the messages originally\n        intended to be stored in this storage were, in fact, stored and\n        retrieved; e.g., ``(messages, all_retrieved)``.\n\n        **This method must be implemented by a subclass.**\n\n        If it is possible to tell if the backend was not used (as opposed to\n        just containing no messages) then ``None`` should be returned in\n        place of ``messages``.\n        \"\"\"\n        raise NotImplementedError('subclasses of BaseStorage must provide a _get() method')\n\n    def _store(self, messages, response, *args, **kwargs):\n        \"\"\"\n        Store a list of messages and return a list of any messages which could\n        not be stored.\n\n        One type of object must be able to be stored, ``Message``.\n\n        **This method must be implemented by a subclass.**\n        \"\"\"\n        raise NotImplementedError('subclasses of BaseStorage must provide a _store() method')\n\n    def _prepare_messages(self, messages):\n        \"\"\"\n        Prepare a list of messages for storage.\n        \"\"\"\n        for message in messages:\n            message._prepare()\n\n    def update(self, response):\n        \"\"\"\n        Store all unread messages.\n\n        If the backend has yet to be iterated, store all messages, and return\n        only messages that could not be stored.\n\n        Otherwise, store all messages added after the last iteration.\n        \"\"\"\n        self._prepare_messages(self._queued_messages)\n        if self.used:\n            return self._store(self._queued_messages, response)\n        elif self.added_new:\n            messages = self._loaded_messages + self._queued_messages\n            return self._store(messages, response)\n\n    def add(self, level, message, extra_tags=''):\n        \"\"\"\n        Queue a message to be stored.\n\n        The message is only queued if it contained something and its level is\n        not less than the recording level (``self.level``).\n        \"\"\"\n        if not message:\n            return\n\n        # Check that the message level is not less than the recording level.\n        level = int(level)\n        if level < self.level:\n            return\n\n        # Add the message.\n        self.added_new = True\n        message = Message(level, message, extra_tags=extra_tags)\n        self._queued_messages.append(message)\n\n    def _get_level(self):\n        \"\"\"\n        Return the minimum recorded level.\n\n        The default level is the ``MESSAGE_LEVEL`` setting. If this is\n        not found, the ``INFO`` level is used.\n        \"\"\"\n        return getattr(settings, 'MESSAGE_LEVEL', constants.INFO)\n\n    def _set_level(self, value=None):\n        \"\"\"\n        Set a custom minimum recorded level.\n\n        If set to ``None``, the default level will be used (see the\n        ``_get_level`` method).\n        \"\"\"\n        if value is None:\n            del self.__dict__['level']\n        else:\n            self.__dict__['level'] = int(value)\n\n    level = property(_get_level, _set_level, _set_level)\n"
    ],
    "Location 2 (/root/hy/projects/django/django/contrib/messages/storage/base.py lines 40-41)": [
      "\n@property\ndef level_tag(self):\n    return utils.get_level_tags().get(self.level, '')\n",
      "\n@property\ndef level_tag(self):\n    return utils.get_level_tags().get(self.level, '')\n",
      "\n    @property\n    def level_tag(self):\n        return utils.get_level_tags().get(self.level, '')\n",
      "\n@property\ndef level_tag(self):\n    return utils.get_level_tags().get(self.level, '')\n",
      "\n@property\ndef level_tag(self):\n    return utils.get_level_tags().get(self.level, '')\n",
      "\n    @property\n    def level_tag(self):\n        return utils.get_level_tags().get(self.level, '')\n",
      "\n@property\ndef level_tag(self):\n    return utils.get_level_tags().get(self.level, '')\n",
      "\n@property\ndef level_tag(self):\n    return utils.get_level_tags().get(self.level, '')\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/contrib/messages/storage/base.py b/django/contrib/messages/storage/base.py\nindex 01422066a6..c0293ce838 100644\n--- a/django/contrib/messages/storage/base.py\n+++ b/django/contrib/messages/storage/base.py\n@@ -1,7 +1,8 @@\n from django.conf import settings\n from django.contrib.messages import constants, utils\n \n-LEVEL_TAGS = utils.get_level_tags()\n+\n+\n \n \n class Message:\n@@ -36,9 +37,11 @@ class Message:\n     def tags(self):\n         return ' '.join(tag for tag in [self.extra_tags, self.level_tag] if tag)\n \n+    @property\n+\n     @property\n     def level_tag(self):\n-        return LEVEL_TAGS.get(self.level, '')\n+        return utils.get_level_tags().get(self.level, '')\n \n \n class BaseStorage:\n",
    "variant_0": "diff --git a/django/contrib/messages/storage/base.py b/django/contrib/messages/storage/base.py\nindex 01422066a6..dc1d92aec5 100644\n--- a/django/contrib/messages/storage/base.py\n+++ b/django/contrib/messages/storage/base.py\n@@ -1,7 +1,9 @@\n from django.conf import settings\n from django.contrib.messages import constants, utils\n \n-LEVEL_TAGS = utils.get_level_tags()\n+\n+from django.conf import settings\n+from django.contrib.messages import constants, utils\n \n \n class Message:\n@@ -38,7 +40,204 @@ class Message:\n \n     @property\n     def level_tag(self):\n-        return LEVEL_TAGS.get(self.level, '')\n+        return utils.get_level_tags().get(self.level, '')\n+\n+\n+class BaseStorage:\n+    \"\"\"\n+    This is the base backend for temporary message storage.\n+\n+    All message storage backends must provide these methods:\n+\n+    * ``__len__``\n+    * ``__iter__``\n+    * ``__contains__``\n+    * ``add``\n+    * ``_get``\n+    * ``_store``\n+\n+    Subclasses should also implement:\n+\n+    * ``_get`` to retrieve messages from their storage location\n+    * ``_store`` to save persistent messages to their storage location\n+\n+    If the backend is time- or size-limited, subclasses should also implement:\n+\n+    * ``_prepare_messages`` to clean up messaged before storing in ``_store``\n+\n+    This backend is not guaranteed to be thread safe.\n+    \"\"\"\n+    def __init__(self, request, *args, **kwargs):\n+        self.request = request\n+        self._queued_messages = []\n+        self.used = False\n+        self.added_new = False\n+        super().__init__(*args, **kwargs)\n+\n+    def __len__(self):\n+        return len(self._loaded_messages) + len(self._queued_messages)\n+\n+    def __iter__(self):\n+        self.used = True\n+        if self._queued_messages:\n+            self._loaded_messages.extend(self._queued_messages)\n+            self._queued_messages = []\n+        return iter(self._loaded_messages)\n+\n+    def __contains__(self, item):\n+        return item in self._loaded_messages or item in self._queued_messages\n+\n+    @property\n+    def _loaded_messages(self):\n+        \"\"\"\n+        Return a list of loaded messages, retrieving them first if they have\n+        not been loaded yet.\n+        \"\"\"\n+        if not hasattr(self, '_loaded_data'):\n+            messages, all_retrieved = self._get()\n+            self._loaded_data = messages or []\n+        return self._loaded_data\n+\n+    def _get(self, *args, **kwargs):\n+        \"\"\"\n+        Retrieve a list of stored messages. Return a tuple of the messages\n+        and a flag indicating whether or not all the messages originally\n+        intended to be stored in this storage were, in fact, stored and\n+        retrieved; e.g., ``(messages, all_retrieved)``.\n+\n+        **This method must be implemented by a subclass.**\n+\n+        If it is possible to tell if the backend was not used (as opposed to\n+        just containing no messages) then ``None`` should be returned in\n+        place of ``messages``.\n+        \"\"\"\n+        raise NotImplementedError('subclasses of BaseStorage must provide a _get() method')\n+\n+    def _store(self, messages, response, *args, **kwargs):\n+        \"\"\"\n+        Store a list of messages and return a list of any messages which could\n+        not be stored.\n+\n+        One type of object must be able to be stored, ``Message``.\n+\n+        **This method must be implemented by a subclass.**\n+        \"\"\"\n+        raise NotImplementedError('subclasses of BaseStorage must provide a _store() method')\n+\n+    def _prepare_messages(self, messages):\n+        \"\"\"\n+        Prepare a list of messages for storage.\n+        \"\"\"\n+        for message in messages:\n+            message._prepare()\n+\n+    def update(self, response):\n+        \"\"\"\n+        Store all unread messages.\n+\n+        If the backend has yet to be iterated, store all messages, and return\n+        only the messages that could not be stored.\n+\n+        Otherwise, store any messages that were added after the last iteration\n+        and return them.\n+        \"\"\"\n+        if self.used:\n+            return self._store(self._queued_messages, response)\n+        elif self.added_new:\n+            messages = self._loaded_messages + self._queued_messages\n+        else:\n+            messages = self._loaded_messages\n+\n+        self._prepare_messages(messages)\n+        return self._store(messages, response)\n+\n+    def add(self, level, message, extra_tags=''):\n+        \"\"\"\n+        Queue a message to be stored.\n+\n+        The message is only queued if it contained something and its level is\n+        not less than the recording level (``self.level``).\n+        \"\"\"\n+        if not message:\n+            return\n+\n+        # Check that the message level is not less than the recording level.\n+        level = int(level)\n+        if level < self.level:\n+            return\n+\n+        # Add the message.\n+        self.added_new = True\n+        message = Message(level, message, extra_tags=extra_tags)\n+        self._queued_messages.append(message)\n+\n+    def _get_level(self):\n+        \"\"\"\n+        Return the minimum recorded level.\n+\n+        The default level is the ``MESSAGE_LEVEL`` setting. If this is\n+        not found, the ``INFO`` level is used.\n+        \"\"\"\n+        return getattr(settings, 'MESSAGE_LEVEL', constants.INFO)\n+\n+    def _set_level(self, value=None):\n+        \"\"\"\n+        Set a custom minimum recorded level.\n+\n+        If set to ``None``, the default level will be used (see the\n+        ``_get_level`` method).\n+        \"\"\"\n+        if value is None:\n+            value = self._get_level()\n+        else:\n+            value = int(value)\n+        self._level = value\n+\n+    level = property(_get_level, _set_level, doc=\"\"\"\n+        The minimum recorded level.\n+\n+        This can be set to record only messages with a level greater than or\n+        equal to this level. See constants for the built-in levels.\n+        \"\"\")\n+\n+\n+class Message:\n+    \"\"\"\n+    Represent an actual message that can be stored in any of the supported\n+    storage classes (typically session- or cookie-based) and rendered in a view\n+    or template.\n+    \"\"\"\n+\n+    def __init__(self, level, message, extra_tags=None):\n+        self.level = int(level)\n+        self.message = message\n+        self.extra_tags = extra_tags\n+\n+    def _prepare(self):\n+        \"\"\"\n+        Prepare the message for serialization by forcing the ``message``\n+        and ``extra_tags`` to str in case they are lazy translations.\n+        \"\"\"\n+        self.message = str(self.message)\n+        self.extra_tags = str(self.extra_tags) if self.extra_tags is not None else None\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, Message):\n+            return NotImplemented\n+        return self.level == other.level and self.message == other.message\n+\n+    def __str__(self):\n+        return str(self.message)\n+\n+    @property\n+    def tags(self):\n+        return ' '.join(tag for tag in [self.extra_tags, self.level_tag] if tag)\n+\n+    @property\n+\n+    @property\n+    def level_tag(self):\n+        return utils.get_level_tags().get(self.level, '')\n \n \n class BaseStorage:\n",
    "variant_1": "diff --git a/django/contrib/messages/storage/base.py b/django/contrib/messages/storage/base.py\nindex 01422066a6..55e7ff42f2 100644\n--- a/django/contrib/messages/storage/base.py\n+++ b/django/contrib/messages/storage/base.py\n@@ -1,7 +1,9 @@\n from django.conf import settings\n from django.contrib.messages import constants, utils\n \n-LEVEL_TAGS = utils.get_level_tags()\n+\n+from django.conf import settings\n+from django.contrib.messages import constants, utils\n \n \n class Message:\n@@ -38,7 +40,177 @@ class Message:\n \n     @property\n     def level_tag(self):\n-        return LEVEL_TAGS.get(self.level, '')\n+        return utils.get_level_tags().get(self.level, '')\n+\n+\n+class BaseStorage:\n+    \"\"\"\n+    This is the base backend for temporary message storage.\n+\n+    This is not a complete class; to be a usable storage backend, it must be\n+    subclassed and the two methods ``_get`` and ``_store`` overridden.\n+    \"\"\"\n+\n+    def __init__(self, request, *args, **kwargs):\n+        self.request = request\n+        self._queued_messages = []\n+        self.used = False\n+        self.added_new = False\n+        super().__init__(*args, **kwargs)\n+\n+    def __len__(self):\n+        return len(self._loaded_messages) + len(self._queued_messages)\n+\n+    def __iter__(self):\n+        self.used = True\n+        if self._queued_messages:\n+            self._loaded_messages.extend(self._queued_messages)\n+            self._queued_messages = []\n+        return iter(self._loaded_messages)\n+\n+    def __contains__(self, item):\n+        return item in self._loaded_messages or item in self._queued_messages\n+\n+    @property\n+    def _loaded_messages(self):\n+        \"\"\"\n+        Return a list of loaded messages, retrieving them first if they have\n+        not been loaded yet.\n+        \"\"\"\n+        if not hasattr(self, '_loaded_data'):\n+            messages, all_retrieved = self._get()\n+            self._loaded_data = messages or []\n+        return self._loaded_data\n+\n+    def _get(self, *args, **kwargs):\n+        \"\"\"\n+        Retrieve a list of stored messages. Return a tuple of the messages\n+        and a flag indicating whether or not all the messages originally\n+        intended to be stored in this storage were, in fact, stored and\n+        retrieved; e.g., ``(messages, all_retrieved)``.\n+\n+        **This method must be implemented by a subclass.**\n+\n+        If it is possible to tell if the backend was not used (as opposed to\n+        just containing no messages) then ``None`` should be returned in\n+        place of ``messages``.\n+        \"\"\"\n+        raise NotImplementedError('subclasses of BaseStorage must provide a _get() method')\n+\n+    def _store(self, messages, response, *args, **kwargs):\n+        \"\"\"\n+        Store a list of messages and return a list of any messages which could\n+        not be stored.\n+\n+        One type of object must be able to be stored, ``Message``.\n+\n+        **This method must be implemented by a subclass.**\n+        \"\"\"\n+        raise NotImplementedError('subclasses of BaseStorage must provide a _store() method')\n+\n+    def _prepare_messages(self, messages):\n+        \"\"\"\n+        Prepare a list of messages for storage.\n+        \"\"\"\n+        for message in messages:\n+            message._prepare()\n+\n+    def update(self, response):\n+        \"\"\"\n+        Store all unread messages.\n+\n+        If the backend has yet to be iterated, previously stored messages will\n+        be stored again. Otherwise, only messages added after the last\n+        iteration will be stored.\n+        \"\"\"\n+        self._prepare_messages(self._queued_messages)\n+        if self.used:\n+            return self._store(self._queued_messages, response)\n+        elif self.added_new:\n+            messages = self._loaded_messages + self._queued_messages\n+            return self._store(messages, response)\n+\n+    def add(self, level, message, extra_tags=''):\n+        \"\"\"\n+        Queue a message to be stored.\n+\n+        The message is only queued if it contained something and its level is\n+        not less than the recording level (``MESSAGE_LEVEL``).\n+        \"\"\"\n+        if not message:\n+            return\n+\n+        # Check that the message level is not less than the recording level.\n+        level = int(level)\n+        if level < getattr(settings, 'MESSAGE_LEVEL', constants.INFO):\n+            return\n+\n+        # Add the message.\n+        self.added_new = True\n+        message = Message(level, message, extra_tags=extra_tags)\n+        self._queued_messages.append(message)\n+\n+    def _get_level(self):\n+        \"\"\"\n+        Return the minimum recorded level.\n+\n+        The default level is the ``MESSAGE_LEVEL`` setting. If this is not\n+        found, the ``INFO`` level is used.\n+        \"\"\"\n+        return getattr(settings, 'MESSAGE_LEVEL', constants.INFO)\n+\n+    def _set_level(self, value=None):\n+        \"\"\"\n+        Set a custom minimum recorded level.\n+\n+        If set to ``None``, the default level will be used (see the\n+        ``_get_level`` method).\n+        \"\"\"\n+        if value is None and hasattr(self, '_level'):\n+            del self._level\n+        else:\n+            self._level = int(value)\n+\n+    level = property(_get_level, _set_level, _set_level)\n+\n+\n+class Message:\n+    \"\"\"\n+    Represent an actual message that can be stored in any of the supported\n+    storage classes (typically session- or cookie-based) and rendered in a view\n+    or template.\n+    \"\"\"\n+\n+    def __init__(self, level, message, extra_tags=None):\n+        self.level = int(level)\n+        self.message = message\n+        self.extra_tags = extra_tags\n+\n+    def _prepare(self):\n+        \"\"\"\n+        Prepare the message for serialization by forcing the ``message``\n+        and ``extra_tags`` to str in case they are lazy translations.\n+        \"\"\"\n+        self.message = str(self.message)\n+        self.extra_tags = str(self.extra_tags) if self.extra_tags is not None else None\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, Message):\n+            return NotImplemented\n+        return self.level == other.level and self.message == other.message\n+\n+    def __str__(self):\n+        return str(self.message)\n+\n+    @property\n+    def tags(self):\n+        return ' '.join(tag for tag in [self.extra_tags, self.level_tag] if tag)\n+\n+    @property\n+\n+@property\n+def level_tag(self):\n+    return utils.get_level_tags().get(self.level, '')\n \n \n class BaseStorage:\n",
    "variant_2": "diff --git a/django/contrib/messages/storage/base.py b/django/contrib/messages/storage/base.py\nindex 01422066a6..0a8ffad2fa 100644\n--- a/django/contrib/messages/storage/base.py\n+++ b/django/contrib/messages/storage/base.py\n@@ -1,7 +1,9 @@\n from django.conf import settings\n from django.contrib.messages import constants, utils\n \n-LEVEL_TAGS = utils.get_level_tags()\n+\n+from django.conf import settings\n+from django.contrib.messages import constants, utils\n \n \n class Message:\n@@ -38,7 +40,176 @@ class Message:\n \n     @property\n     def level_tag(self):\n-        return LEVEL_TAGS.get(self.level, '')\n+        return utils.get_level_tags().get(self.level, '')\n+\n+\n+class BaseStorage:\n+    \"\"\"\n+    This is the base backend for temporary message storage.\n+\n+    This is not a complete class; to be a usable storage backend, it must be\n+    subclassed and the two methods ``_get`` and ``_store`` overridden.\n+    \"\"\"\n+\n+    def __init__(self, request, *args, **kwargs):\n+        self.request = request\n+        self._queued_messages = []\n+        self.used = False\n+        self.added_new = False\n+        super().__init__(*args, **kwargs)\n+\n+    def __len__(self):\n+        return len(self._loaded_messages) + len(self._queued_messages)\n+\n+    def __iter__(self):\n+        self.used = True\n+        if self._queued_messages:\n+            self._loaded_messages.extend(self._queued_messages)\n+            self._queued_messages = []\n+        return iter(self._loaded_messages)\n+\n+    def __contains__(self, item):\n+        return item in self._loaded_messages or item in self._queued_messages\n+\n+    @property\n+    def _loaded_messages(self):\n+        \"\"\"\n+        Return a list of loaded messages, retrieving them first if they have\n+        not been loaded yet.\n+        \"\"\"\n+        if not hasattr(self, '_loaded_data'):\n+            messages, all_retrieved = self._get()\n+            self._loaded_data = messages or []\n+        return self._loaded_data\n+\n+    def _get(self, *args, **kwargs):\n+        \"\"\"\n+        Retrieve any stored messages. Return a tuple of the messages retrieved\n+        and a flag indicating whether or not all the messages originally\n+        intended to be stored in this storage were, in fact, stored and\n+        retrieved; e.g., ``(messages, all_retrieved)``.\n+\n+        **This method must be implemented by a subclass.**\n+\n+        If it is possible to tell if the backend was not used (as opposed to\n+        just containing no messages) then ``None`` should be returned in\n+        place of ``messages``.\n+        \"\"\"\n+        raise NotImplementedError('subclasses of BaseStorage must provide a _get() method')\n+\n+    def _store(self, messages, response, *args, **kwargs):\n+        \"\"\"\n+        Store a list of messages and return a list of any messages which could\n+        not be stored.\n+\n+        One type of object must be able to be stored, ``Message``.\n+\n+        **This method must be implemented by a subclass.**\n+        \"\"\"\n+        raise NotImplementedError('subclasses of BaseStorage must provide a _store() method')\n+\n+    def _prepare_messages(self, messages):\n+        \"\"\"\n+        Prepare a list of messages for storage.\n+        \"\"\"\n+        for message in messages:\n+            message._prepare()\n+\n+    def update(self, response):\n+        \"\"\"\n+        Store all unread messages.\n+\n+        If the backend has yet to be iterated, store all queued messages.\n+        Otherwise, store any messages added after the last iteration.\n+        \"\"\"\n+        self._prepare_messages(self._queued_messages)\n+        if self.used:\n+            return self._store(self._queued_messages, response)\n+        elif self.added_new:\n+            messages = self._loaded_messages + self._queued_messages\n+            return self._store(messages, response)\n+\n+    def add(self, level, message, extra_tags=''):\n+        \"\"\"\n+        Queue a message to be stored.\n+\n+        The message is only queued if it contained something and its level is\n+        not less than the recording level (``MESSAGE_LEVEL``).\n+        \"\"\"\n+        if not message:\n+            return\n+\n+        # Check that the message level is not less than the recording level.\n+        level = int(level)\n+        if level < getattr(settings, 'MESSAGE_LEVEL', constants.INFO):\n+            return\n+\n+        # Add the message.\n+        self.added_new = True\n+        message = Message(level, message, extra_tags=extra_tags)\n+        self._queued_messages.append(message)\n+\n+    def _get_level(self):\n+        \"\"\"\n+        Return the minimum recorded level.\n+\n+        The default level is the ``MESSAGE_LEVEL`` setting. If this is\n+        not found, the ``INFO`` level is used.\n+        \"\"\"\n+        return getattr(settings, 'MESSAGE_LEVEL', constants.INFO)\n+\n+    def _set_level(self, value=None):\n+        \"\"\"\n+        Set a custom minimum recorded level.\n+\n+        If set to ``None``, the default level will be used (see the\n+        ``_get_level`` method).\n+        \"\"\"\n+        if value is None and hasattr(self, '_level'):\n+            del self._level\n+        else:\n+            self._level = int(value)\n+\n+    level = property(_get_level, _set_level, _set_level)\n+\n+\n+class Message:\n+    \"\"\"\n+    Represent an actual message that can be stored in any of the supported\n+    storage classes (typically session- or cookie-based) and rendered in a view\n+    or template.\n+    \"\"\"\n+\n+    def __init__(self, level, message, extra_tags=None):\n+        self.level = int(level)\n+        self.message = message\n+        self.extra_tags = extra_tags\n+\n+    def _prepare(self):\n+        \"\"\"\n+        Prepare the message for serialization by forcing the ``message``\n+        and ``extra_tags`` to str in case they are lazy translations.\n+        \"\"\"\n+        self.message = str(self.message)\n+        self.extra_tags = str(self.extra_tags) if self.extra_tags is not None else None\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, Message):\n+            return NotImplemented\n+        return self.level == other.level and self.message == other.message\n+\n+    def __str__(self):\n+        return str(self.message)\n+\n+    @property\n+    def tags(self):\n+        return ' '.join(tag for tag in [self.extra_tags, self.level_tag] if tag)\n+\n+    @property\n+\n+@property\n+def level_tag(self):\n+    return utils.get_level_tags().get(self.level, '')\n \n \n class BaseStorage:\n",
    "variant_3": "diff --git a/django/contrib/messages/storage/base.py b/django/contrib/messages/storage/base.py\nindex 01422066a6..528bd28829 100644\n--- a/django/contrib/messages/storage/base.py\n+++ b/django/contrib/messages/storage/base.py\n@@ -1,7 +1,180 @@\n from django.conf import settings\n from django.contrib.messages import constants, utils\n \n-LEVEL_TAGS = utils.get_level_tags()\n+\n+from django.conf import settings\n+from django.contrib.messages import constants, utils\n+\n+\n+class Message:\n+    \"\"\"\n+    Represent an actual message that can be stored in any of the supported\n+    storage classes (typically session- or cookie-based) and rendered in a view\n+    or template.\n+    \"\"\"\n+\n+    def __init__(self, level, message, extra_tags=None):\n+        self.level = int(level)\n+        self.message = message\n+        self.extra_tags = extra_tags\n+\n+    def _prepare(self):\n+        \"\"\"\n+        Prepare the message for serialization by forcing the ``message``\n+        and ``extra_tags`` to str in case they are lazy translations.\n+        \"\"\"\n+        self.message = str(self.message)\n+        self.extra_tags = str(self.extra_tags) if self.extra_tags is not None else None\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, Message):\n+            return NotImplemented\n+        return (\n+            self.level == other.level and\n+            self.message == other.message and\n+            self.extra_tags == other.extra_tags\n+        )\n+\n+    def __str__(self):\n+        return str(self.message)\n+\n+    @property\n+    def tags(self):\n+        return ' '.join(tag for tag in [self.extra_tags, self.level_tag] if tag)\n+\n+    @property\n+    def level_tag(self):\n+        return utils.get_level_tags().get(self.level, '')\n+\n+\n+class BaseStorage:\n+    \"\"\"\n+    This is the base backend for temporary message storage.\n+\n+    This is not a complete class; to be a usable storage backend, it must be\n+    subclassed and the two methods ``_get`` and ``_store`` overridden.\n+    \"\"\"\n+\n+    def __init__(self, request, *args, **kwargs):\n+        self.request = request\n+        self._queued_messages = []\n+        self.used = False\n+        self.added_new = False\n+        super().__init__(*args, **kwargs)\n+\n+    def __len__(self):\n+        return len(self._loaded_messages) + len(self._queued_messages)\n+\n+    def __iter__(self):\n+        self.used = True\n+        if self._queued_messages:\n+            self._loaded_messages.extend(self._queued_messages)\n+            self._queued_messages = []\n+        return iter(self._loaded_messages)\n+\n+    def __contains__(self, item):\n+        return item in self._loaded_messages or item in self._queued_messages\n+\n+    @property\n+    def _loaded_messages(self):\n+        \"\"\"\n+        Return a list of loaded messages, retrieving them first if they have\n+        not been loaded yet.\n+        \"\"\"\n+        if not hasattr(self, '_loaded_data'):\n+            messages, all_retrieved = self._get()\n+            self._loaded_data = messages or []\n+        return self._loaded_data\n+\n+    def _get(self, *args, **kwargs):\n+        \"\"\"\n+        Retrieve a list of stored messages. Return a tuple of the messages\n+        and a flag indicating whether or not all the messages originally\n+        intended to be stored in this storage were, in fact, stored and\n+        retrieved; e.g., ``(messages, all_retrieved)``.\n+\n+        **This method must be implemented by a subclass.**\n+\n+        If it is possible to tell if the backend was not used (as opposed to\n+        just containing no messages) then ``None`` should be returned in\n+        place of ``messages``.\n+        \"\"\"\n+        raise NotImplementedError('subclasses of BaseStorage must provide a _get() method')\n+\n+    def _store(self, messages, response, *args, **kwargs):\n+        \"\"\"\n+        Store a list of messages and return a list of any messages which could\n+        not be stored.\n+\n+        One type of object must be able to be stored, ``Message``.\n+\n+        **This method must be implemented by a subclass.**\n+        \"\"\"\n+        raise NotImplementedError('subclasses of BaseStorage must provide a _store() method')\n+\n+    def _prepare_messages(self, messages):\n+        \"\"\"\n+        Prepare a list of messages for storage.\n+        \"\"\"\n+        for message in messages:\n+            message._prepare()\n+\n+    def update(self, response):\n+        \"\"\"\n+        Store all unread messages.\n+\n+        If the backend has yet to be iterated, store all queued messages.\n+        Otherwise, store any messages added after the last iteration.\n+        \"\"\"\n+        self._prepare_messages(self._queued_messages)\n+        if self.used:\n+            return self._store(self._queued_messages, response)\n+        elif self.added_new:\n+            messages = self._loaded_messages + self._queued_messages\n+            return self._store(messages, response)\n+\n+    def add(self, level, message, extra_tags=''):\n+        \"\"\"\n+        Queue a message to be stored.\n+\n+        The message is only queued if it contained something and its level is\n+        not less than the recording level (``MESSAGE_LEVEL``).\n+        \"\"\"\n+        if not message:\n+            return\n+\n+        # Check that the message level is not less than the recording level.\n+        level = int(level)\n+        if level < self.level:\n+            return\n+\n+        # Add the message.\n+        self.added_new = True\n+        message = Message(level, message, extra_tags=extra_tags)\n+        self._queued_messages.append(message)\n+\n+    def _get_level(self):\n+        \"\"\"\n+        Return the minimum recorded level.\n+\n+        The default level is the ``MESSAGE_LEVEL`` setting. If this is\n+        not found, the ``INFO`` level is used.\n+        \"\"\"\n+        return getattr(settings, 'MESSAGE_LEVEL', constants.INFO)\n+\n+    def _set_level(self, value=None):\n+        \"\"\"\n+        Set a custom minimum recorded level.\n+\n+        If set to ``None``, the default level will be used (see the\n+        ``_get_level`` method).\n+        \"\"\"\n+        if value is None and hasattr(self, '_level'):\n+            del self._level\n+        else:\n+            self._level = int(value)\n+\n+    level = property(_get_level, _set_level, _set_level)\n \n \n class Message:\n@@ -36,9 +209,11 @@ class Message:\n     def tags(self):\n         return ' '.join(tag for tag in [self.extra_tags, self.level_tag] if tag)\n \n+    @property\n+\n     @property\n     def level_tag(self):\n-        return LEVEL_TAGS.get(self.level, '')\n+        return utils.get_level_tags().get(self.level, '')\n \n \n class BaseStorage:\n",
    "variant_4": "diff --git a/django/contrib/messages/storage/base.py b/django/contrib/messages/storage/base.py\nindex 01422066a6..af0af6867c 100644\n--- a/django/contrib/messages/storage/base.py\n+++ b/django/contrib/messages/storage/base.py\n@@ -1,7 +1,9 @@\n from django.conf import settings\n from django.contrib.messages import constants, utils\n \n-LEVEL_TAGS = utils.get_level_tags()\n+\n+from django.conf import settings\n+from django.contrib.messages import constants, utils\n \n \n class Message:\n@@ -38,7 +40,179 @@ class Message:\n \n     @property\n     def level_tag(self):\n-        return LEVEL_TAGS.get(self.level, '')\n+        return utils.get_level_tags().get(self.level, '')\n+\n+\n+class BaseStorage:\n+    \"\"\"\n+    This is the base backend for temporary message storage.\n+\n+    All message storage backends must provide these methods:\n+\n+    * add(level, message, extra_tags=None)\n+    * _get()\n+    * _store(messages, response, *args, **kwargs)\n+\n+    If the backend is iterating the data without storing anything on the\n+    request, then _store() method should do nothing, _get() method\n+    shouldn't be implemented (or just return []) and the backend\n+    should use _loaded_data attribute to tell whether it has already\n+    read the data or not. This is for memory efficiency.\n+\n+    There are no restrictions as to where a backend may save its data,\n+    such as in a database, file, cache, session, or cookie. The backend's\n+    storage is not expected to be persistent between requests.\n+\n+    Each message is stored as an instance of the Message class.\n+    \"\"\"\n+\n+    def __init__(self, request, *args, **kwargs):\n+        self.request = request\n+        self._queued_messages = []\n+        self.used = False\n+        self.added_new = False\n+\n+    def __len__(self):\n+        return len(self._get_messages())\n+\n+    def __iter__(self):\n+        self.used = True\n+        if self._queued_messages:\n+            self._store_messages(self._queued_messages)\n+            self._queued_messages = []\n+        return iter(self._get_messages())\n+\n+    def __contains__(self, item):\n+        return item in self._get_messages()\n+\n+    @property\n+    def level(self):\n+        \"\"\"\n+        Return the minimum recorded level.\n+\n+        The default level is the ``MESSAGE_LEVEL`` setting. If this is not\n+        found, the ``INFO`` level is used.\n+        \"\"\"\n+        if not hasattr(self, '_level'):\n+            self._level = getattr(settings, 'MESSAGE_LEVEL', constants.INFO)\n+        return self._level\n+\n+    @level.setter\n+    def level(self, value):\n+        \"\"\"\n+        Set a custom minimum recorded level.\n+\n+        If set to ``None``, Django's default ``MESSAGE_LEVEL`` will be used.\n+        \"\"\"\n+        if value is None and hasattr(self, '_level'):\n+            del self._level\n+        else:\n+            self._level = int(value)\n+\n+    def _get_messages(self):\n+        \"\"\"\n+        Return a list of messages, marking the storage as used.\n+        \"\"\"\n+        messages = getattr(self, '_loaded_messages', None)\n+        if messages is None:\n+            self._loaded_messages = self._get()\n+        return self._loaded_messages or []\n+\n+    def _store_messages(self, messages):\n+        \"\"\"\n+        Store a list of messages and return a list of any messages which could\n+        not be stored.\n+\n+        One type of object must be able to be stored, ``Message``.\n+        \"\"\"\n+        raise NotImplementedError('subclasses of BaseStorage must provide a _store() method')\n+\n+    def _get(self):\n+        \"\"\"\n+        Retrieve a list of messages stored in this backend.\n+        \"\"\"\n+        raise NotImplementedError('subclasses of BaseStorage must provide a _get() method')\n+\n+    def add(self, level, message, extra_tags=''):\n+        \"\"\"\n+        Queue a message to be stored.\n+\n+        The message is only queued if it contained something and its level is\n+        not less than the recording level (``self.level``).\n+        \"\"\"\n+        if not message:\n+            return\n+\n+        # Check that the message level is not less than the recording level.\n+        level = int(level)\n+        if level < self.level:\n+            return\n+\n+        # Add the message.\n+        self.added_new = True\n+        message = Message(level, message, extra_tags=extra_tags)\n+        self._queued_messages.append(message)\n+\n+    def _prepare_messages(self, messages):\n+        \"\"\"\n+        Prepare a list of messages for storage.\n+        \"\"\"\n+        for message in messages:\n+            message._prepare()\n+\n+    def update(self, response):\n+        \"\"\"\n+        Store all unqueued messages.\n+\n+        If the backend has yet to be iterated, store all queued messages.\n+        Otherwise, only store messages that were added after the last\n+        iteration.\n+        \"\"\"\n+        if self.used:\n+            return self._store_messages(self._queued_messages)\n+        elif self.added_new:\n+            messages = self._loaded_messages or []\n+            messages.extend(self._queued_messages)\n+            return self._store_messages(messages)\n+\n+\n+class Message:\n+    \"\"\"\n+    Represent an actual message that can be stored in any of the supported\n+    storage classes (typically session- or cookie-based) and rendered in a view\n+    or template.\n+    \"\"\"\n+\n+    def __init__(self, level, message, extra_tags=None):\n+        self.level = int(level)\n+        self.message = message\n+        self.extra_tags = extra_tags\n+\n+    def _prepare(self):\n+        \"\"\"\n+        Prepare the message for serialization by forcing the ``message``\n+        and ``extra_tags`` to str in case they are lazy translations.\n+        \"\"\"\n+        self.message = str(self.message)\n+        self.extra_tags = str(self.extra_tags) if self.extra_tags is not None else None\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, Message):\n+            return NotImplemented\n+        return self.level == other.level and self.message == other.message\n+\n+    def __str__(self):\n+        return str(self.message)\n+\n+    @property\n+    def tags(self):\n+        return ' '.join(tag for tag in [self.extra_tags, self.level_tag] if tag)\n+\n+    @property\n+\n+@property\n+def level_tag(self):\n+    return utils.get_level_tags().get(self.level, '')\n \n \n class BaseStorage:\n",
    "variant_5": "diff --git a/django/contrib/messages/storage/base.py b/django/contrib/messages/storage/base.py\nindex 01422066a6..af7a347971 100644\n--- a/django/contrib/messages/storage/base.py\n+++ b/django/contrib/messages/storage/base.py\n@@ -1,7 +1,9 @@\n from django.conf import settings\n from django.contrib.messages import constants, utils\n \n-LEVEL_TAGS = utils.get_level_tags()\n+\n+from django.conf import settings\n+from django.contrib.messages import constants, utils\n \n \n class Message:\n@@ -27,7 +29,11 @@ class Message:\n     def __eq__(self, other):\n         if not isinstance(other, Message):\n             return NotImplemented\n-        return self.level == other.level and self.message == other.message\n+        return (\n+            self.level == other.level and\n+            self.message == other.message and\n+            self.extra_tags == other.extra_tags\n+        )\n \n     def __str__(self):\n         return str(self.message)\n@@ -38,7 +44,153 @@ class Message:\n \n     @property\n     def level_tag(self):\n-        return LEVEL_TAGS.get(self.level, '')\n+        return utils.get_level_tags().get(self.level, '')\n+\n+\n+class BaseStorage:\n+    \"\"\"\n+    This is the base backend for temporary message storage.\n+\n+    For each message, a new instance of the storage backend is created.\n+    Then the add() and iteration interface is used. Finally, unused()\n+    indicates whether the messages have been iterated over. A storage\n+    backend can only be iterated over once because it's designed to be\n+    exhausted when rendering the response (otherwise, the REQUEST_METHOD\n+    / URL combination could re-trigger the same error message being\n+    displayed multiple times).\n+    \"\"\"\n+\n+    def __init__(self, request, *args, **kwargs):\n+        self.request = request\n+        self._queued_messages = []\n+        self.used = False\n+        self.added_new = False\n+\n+    def __len__(self):\n+        return len(self._queued_messages)\n+\n+    def __iter__(self):\n+        self.used = True\n+        if self._queued_messages:\n+            self._prepare_messages(self._queued_messages)\n+        return iter(self._queued_messages)\n+\n+    def __contains__(self, item):\n+        return item in self._queued_messages\n+\n+    @property\n+    def level(self):\n+        \"\"\"\n+        Return the minimum recorded level.\n+\n+        Default level is 20 (INFO).\n+        \"\"\"\n+        if self._queued_messages:\n+            return min(m.level for m in self._queued_messages)\n+        return constants.INFO\n+\n+    def _prepare_messages(self, messages):\n+        \"\"\"\n+        Prepare a list of messages for storage.\n+        \"\"\"\n+        for message in messages:\n+            message._prepare()\n+\n+    def update(self, response):\n+        \"\"\"\n+        Store all unprocessed messages.\n+\n+        If the backend has yet to be iterated, store all queued messages.\n+        Otherwise, only store messages added after the last iteration.\n+        \"\"\"\n+        self._store(self._get_messages(), response)\n+\n+    def add(self, level, message, extra_tags=None):\n+        \"\"\"\n+        Queue a message to be stored.\n+\n+        The message is only queued if it contained something and its level is\n+        not less than the recording level (``self.level``).\n+        \"\"\"\n+        if not message:\n+            return\n+        # Check that the message level is not less than the recording level.\n+        level = int(level)\n+        if level < self.level:\n+            return\n+\n+        # Add the message.\n+        self.added_new = True\n+        message = Message(level, message, extra_tags=extra_tags)\n+        self._queued_messages.append(message)\n+\n+    def _get_messages(self):\n+        return self._queued_messages\n+\n+    def _store(self, messages, response, *args, **kwargs):\n+        \"\"\"\n+        Store a list of messages and return a list of any messages which could\n+        not be stored.\n+\n+        One type of object must be able to be stored, ``Message``.\n+\n+        **This method must be implemented by a subclass.**\n+\n+        If it is possible to tell if the backend was not used (i.e., no\n+        messages were actually retrieved) then ``None`` should be returned in\n+        place of ``[]``.\n+        \"\"\"\n+        raise NotImplementedError(\n+            'subclasses of BaseStorage must provide a _store() method')\n+\n+    def _delete(self):\n+        \"\"\"\n+        Delete all stored messages and return a list of messages which could\n+        not be deleted.\n+\n+        **This method must be implemented by a subclass.**\n+        \"\"\"\n+        raise NotImplementedError(\n+            'subclasses of BaseStorage must provide a _delete() method')\n+\n+\n+class Message:\n+    \"\"\"\n+    Represent an actual message that can be stored in any of the supported\n+    storage classes (typically session- or cookie-based) and rendered in a view\n+    or template.\n+    \"\"\"\n+\n+    def __init__(self, level, message, extra_tags=None):\n+        self.level = int(level)\n+        self.message = message\n+        self.extra_tags = extra_tags\n+\n+    def _prepare(self):\n+        \"\"\"\n+        Prepare the message for serialization by forcing the ``message``\n+        and ``extra_tags`` to str in case they are lazy translations.\n+        \"\"\"\n+        self.message = str(self.message)\n+        self.extra_tags = str(self.extra_tags) if self.extra_tags is not None else None\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, Message):\n+            return NotImplemented\n+        return self.level == other.level and self.message == other.message\n+\n+    def __str__(self):\n+        return str(self.message)\n+\n+    @property\n+    def tags(self):\n+        return ' '.join(tag for tag in [self.extra_tags, self.level_tag] if tag)\n+\n+    @property\n+\n+@property\n+def level_tag(self):\n+    return utils.get_level_tags().get(self.level, '')\n \n \n class BaseStorage:\n",
    "variant_6": "diff --git a/django/contrib/messages/storage/base.py b/django/contrib/messages/storage/base.py\nindex 01422066a6..0d26bd4241 100644\n--- a/django/contrib/messages/storage/base.py\n+++ b/django/contrib/messages/storage/base.py\n@@ -1,7 +1,19 @@\n from django.conf import settings\n from django.contrib.messages import constants, utils\n \n-LEVEL_TAGS = utils.get_level_tags()\n+\n+from django.conf import settings\n+from django.contrib.messages import constants, utils\n+\n+\n+class Message:\n+    \"\"\"\n+    Represent an actual message that can be stored in any of the supported\n+    storage classes (typically session- or cookie-based) and rendered in a view\n+    or template.\n+    \"\"\"\n+\n+    def __init__(self, level, message, extra_tags=None):\n \n \n class Message:\n@@ -36,9 +48,11 @@ class Message:\n     def tags(self):\n         return ' '.join(tag for tag in [self.extra_tags, self.level_tag] if tag)\n \n+    @property\n+\n     @property\n     def level_tag(self):\n-        return LEVEL_TAGS.get(self.level, '')\n+        return utils.get_level_tags().get(self.level, '')\n \n \n class BaseStorage:\n",
    "variant_7": "diff --git a/django/contrib/messages/storage/base.py b/django/contrib/messages/storage/base.py\nindex 01422066a6..08f20701f9 100644\n--- a/django/contrib/messages/storage/base.py\n+++ b/django/contrib/messages/storage/base.py\n@@ -1,7 +1,9 @@\n from django.conf import settings\n from django.contrib.messages import constants, utils\n \n-LEVEL_TAGS = utils.get_level_tags()\n+\n+from django.conf import settings\n+from django.contrib.messages import constants, utils\n \n \n class Message:\n@@ -38,7 +40,146 @@ class Message:\n \n     @property\n     def level_tag(self):\n-        return LEVEL_TAGS.get(self.level, '')\n+        return utils.get_level_tags().get(self.level, '')\n+\n+\n+class BaseStorage:\n+    \"\"\"\n+    This is the base backend for temporary message storage.\n+\n+    Subclasses must implement the two methods marked as raising\n+    NotImplementedError.\n+    \"\"\"\n+    def __init__(self, request, *args, **kwargs):\n+        self.request = request\n+        self._queued_messages = []\n+        self.used = False\n+        self.added_new = False\n+\n+    def __len__(self):\n+        return len(self._queued_messages)\n+\n+    def __iter__(self):\n+        self.used = True\n+        if self._queued_messages:\n+            self._queued_messages = []\n+\n+    def __contains__(self, item):\n+        return item in self._queued_messages\n+\n+    def add(self, level, message, extra_tags=''):\n+        \"\"\"\n+        Queue a message to be stored.\n+\n+        The message is only queued if it contained something and its level is\n+        not less than the recording level (``MESSAGE_LEVEL``).\n+        \"\"\"\n+        if not message:\n+            return\n+\n+        # Check that the message level is not less than the recording level.\n+        level = int(level)\n+        if level < self.level:\n+            return\n+\n+        # Add the message.\n+        self.added_new = True\n+        message = Message(level, message, extra_tags=extra_tags)\n+        self._queued_messages.append(message)\n+\n+    def _get(self, *args, **kwargs):\n+        \"\"\"\n+        Retrieve a list of stored messages. Return a tuple of the messages\n+        and a flag indicating whether or not all the messages originally\n+        intended to be stored in this storage were, in fact, stored and\n+        retrieved; e.g., ``(messages, all_retrieved)``.\n+\n+        **This method must be implemented by a subclass.**\n+\n+        If it is possible to tell if the backend was not used (as opposed to\n+        just containing no messages) then ``None`` should be returned in\n+        place of ``messages``.\n+        \"\"\"\n+        raise NotImplementedError('subclasses of BaseStorage must provide a _get() method')\n+\n+    def _store(self, messages, response, *args, **kwargs):\n+        \"\"\"\n+        Store a list of messages and return a list of any messages which could\n+        not be stored.\n+\n+        One type of object must be able to be stored, ``Message``.\n+\n+        **This method must be implemented by a subclass.**\n+        \"\"\"\n+        raise NotImplementedError('subclasses of BaseStorage must provide a _store() method')\n+\n+    @property\n+    def level(self):\n+        \"\"\"\n+        Return the minimum recorded level.\n+\n+        The default level is the ``MESSAGE_LEVEL`` setting. If this is\n+        not found, the ``INFO`` level is used.\n+        \"\"\"\n+        if not hasattr(self, '_level'):\n+            self._level = getattr(settings, 'MESSAGE_LEVEL', constants.INFO)\n+        return self._level\n+\n+    @level.setter\n+    def level(self, value):\n+        self._level = int(value)\n+\n+    def update(self, response):\n+        \"\"\"\n+        Store all unprocessed messages.\n+\n+        If the backend has yet to be iterated, store all queued messages.\n+        Otherwise, only store messages added after the last iteration.\n+        \"\"\"\n+        if self.used:\n+            return\n+        if self.added_new:\n+            self._store(self._queued_messages, response)\n+            self.added_new = False\n+\n+\n+class Message:\n+    \"\"\"\n+    Represent an actual message that can be stored in any of the supported\n+    storage classes (typically session- or cookie-based) and rendered in a view\n+    or template.\n+    \"\"\"\n+\n+    def __init__(self, level, message, extra_tags=None):\n+        self.level = int(level)\n+        self.message = message\n+        self.extra_tags = extra_tags\n+\n+    def _prepare(self):\n+        \"\"\"\n+        Prepare the message for serialization by forcing the ``message``\n+        and ``extra_tags`` to str in case they are lazy translations.\n+        \"\"\"\n+        self.message = str(self.message)\n+        self.extra_tags = str(self.extra_tags) if self.extra_tags is not None else None\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, Message):\n+            return NotImplemented\n+        return self.level == other.level and self.message == other.message\n+\n+    def __str__(self):\n+        return str(self.message)\n+\n+    @property\n+    def tags(self):\n+        return ' '.join(tag for tag in [self.extra_tags, self.level_tag] if tag)\n+\n+    @property\n+\n+@property\n+def level_tag(self):\n+    return utils.get_level_tags().get(self.level, '')\n \n \n class BaseStorage:\n",
    "variant_8": "diff --git a/django/contrib/messages/storage/base.py b/django/contrib/messages/storage/base.py\nindex 01422066a6..92886439f5 100644\n--- a/django/contrib/messages/storage/base.py\n+++ b/django/contrib/messages/storage/base.py\n@@ -1,7 +1,9 @@\n from django.conf import settings\n from django.contrib.messages import constants, utils\n \n-LEVEL_TAGS = utils.get_level_tags()\n+\n+from django.conf import settings\n+from django.contrib.messages import constants, utils\n \n \n class Message:\n@@ -27,7 +29,11 @@ class Message:\n     def __eq__(self, other):\n         if not isinstance(other, Message):\n             return NotImplemented\n-        return self.level == other.level and self.message == other.message\n+        return (\n+            self.level == other.level and\n+            self.message == other.message and\n+            self.extra_tags == other.extra_tags\n+        )\n \n     def __str__(self):\n         return str(self.message)\n@@ -38,7 +44,178 @@ class Message:\n \n     @property\n     def level_tag(self):\n-        return LEVEL_TAGS.get(self.level, '')\n+        return utils.get_level_tags().get(self.level, '')\n+\n+\n+class BaseStorage:\n+    \"\"\"\n+    This is the base backend for temporary message storage.\n+\n+    This is not a complete class; to be a usable storage backend, it must be\n+    subclassed and the two methods ``_get`` and ``_store`` overridden.\n+    \"\"\"\n+\n+    def __init__(self, request, *args, **kwargs):\n+        self.request = request\n+        self._queued_messages = []\n+        self.used = False\n+        self.added_new = False\n+        super().__init__(*args, **kwargs)\n+\n+    def __len__(self):\n+        return len(self._loaded_messages) + len(self._queued_messages)\n+\n+    def __iter__(self):\n+        self.used = True\n+        if self._queued_messages:\n+            self._loaded_messages.extend(self._queued_messages)\n+            self._queued_messages = []\n+        return iter(self._loaded_messages)\n+\n+    def __contains__(self, item):\n+        return item in self._loaded_messages or item in self._queued_messages\n+\n+    @property\n+    def _loaded_messages(self):\n+        \"\"\"\n+        Return a list of loaded messages, retrieving them first if they have\n+        not been loaded yet.\n+        \"\"\"\n+        if not hasattr(self, '_loaded_data'):\n+            messages, all_retrieved = self._get()\n+            self._loaded_data = messages or []\n+        return self._loaded_data\n+\n+    def _get(self, *args, **kwargs):\n+        \"\"\"\n+        Retrieve a list of stored messages. Return a tuple of the messages\n+        and a flag indicating whether or not all the messages originally\n+        intended to be stored in this storage were, in fact, stored and\n+        retrieved; e.g., ``(messages, all_retrieved)``.\n+\n+        **This method must be implemented by a subclass.**\n+\n+        If it is possible to tell if the backend was not used (as opposed to\n+        just containing no messages) then ``None`` should be returned in\n+        place of ``messages``.\n+        \"\"\"\n+        raise NotImplementedError('subclasses of BaseStorage must provide a _get() method')\n+\n+    def _store(self, messages, response, *args, **kwargs):\n+        \"\"\"\n+        Store a list of messages and return a list of any messages which could\n+        not be stored.\n+\n+        One type of object must be able to be stored, ``Message``.\n+\n+        **This method must be implemented by a subclass.**\n+        \"\"\"\n+        raise NotImplementedError('subclasses of BaseStorage must provide a _store() method')\n+\n+    def _prepare_messages(self, messages):\n+        \"\"\"\n+        Prepare a list of messages for storage.\n+        \"\"\"\n+        for message in messages:\n+            message._prepare()\n+\n+    def update(self, response):\n+        \"\"\"\n+        Store all unread messages.\n+\n+        If the backend has yet to be iterated, store all messages, and return\n+        only messages that could not be stored.\n+\n+        Otherwise, store all messages added after the last iteration.\n+        \"\"\"\n+        self._prepare_messages(self._queued_messages)\n+        if self.used:\n+            return self._store(self._queued_messages, response)\n+        elif self.added_new:\n+            messages = self._loaded_messages + self._queued_messages\n+            return self._store(messages, response)\n+\n+    def add(self, level, message, extra_tags=''):\n+        \"\"\"\n+        Queue a message to be stored.\n+\n+        The message is only queued if it contained something and its level is\n+        not less than the recording level (``self.level``).\n+        \"\"\"\n+        if not message:\n+            return\n+\n+        # Check that the message level is not less than the recording level.\n+        level = int(level)\n+        if level < self.level:\n+            return\n+\n+        # Add the message.\n+        self.added_new = True\n+        message = Message(level, message, extra_tags=extra_tags)\n+        self._queued_messages.append(message)\n+\n+    def _get_level(self):\n+        \"\"\"\n+        Return the minimum recorded level.\n+\n+        The default level is the ``MESSAGE_LEVEL`` setting. If this is\n+        not found, the ``INFO`` level is used.\n+        \"\"\"\n+        return getattr(settings, 'MESSAGE_LEVEL', constants.INFO)\n+\n+    def _set_level(self, value=None):\n+        \"\"\"\n+        Set a custom minimum recorded level.\n+\n+        If set to ``None``, the default level will be used (see the\n+        ``_get_level`` method).\n+        \"\"\"\n+        if value is None:\n+            del self.__dict__['level']\n+        else:\n+            self.__dict__['level'] = int(value)\n+\n+    level = property(_get_level, _set_level, _set_level)\n+\n+\n+class Message:\n+    \"\"\"\n+    Represent an actual message that can be stored in any of the supported\n+    storage classes (typically session- or cookie-based) and rendered in a view\n+    or template.\n+    \"\"\"\n+\n+    def __init__(self, level, message, extra_tags=None):\n+        self.level = int(level)\n+        self.message = message\n+        self.extra_tags = extra_tags\n+\n+    def _prepare(self):\n+        \"\"\"\n+        Prepare the message for serialization by forcing the ``message``\n+        and ``extra_tags`` to str in case they are lazy translations.\n+        \"\"\"\n+        self.message = str(self.message)\n+        self.extra_tags = str(self.extra_tags) if self.extra_tags is not None else None\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, Message):\n+            return NotImplemented\n+        return self.level == other.level and self.message == other.message\n+\n+    def __str__(self):\n+        return str(self.message)\n+\n+    @property\n+    def tags(self):\n+        return ' '.join(tag for tag in [self.extra_tags, self.level_tag] if tag)\n+\n+    @property\n+\n+@property\n+def level_tag(self):\n+    return utils.get_level_tags().get(self.level, '')\n \n \n class BaseStorage:\n"
  }
}