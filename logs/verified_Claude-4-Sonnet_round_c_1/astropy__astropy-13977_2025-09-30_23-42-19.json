{
  "zero_patches": {
    "Location 1 (/root/hy/projects/astropy/astropy/units/quantity.py lines 667-670)": "\n        # Same for inputs, but here also convert if necessary.\n        arrays = []\n        for input_, converter in zip(inputs, converters):\n            input_ = getattr(input_, \"value\", input_)\n            try:\n                arrays.append(converter(input_) if converter else input_)\n            except ValueError:\n                # If conversion fails (e.g., incompatible duck arrays),\n                # return NotImplemented to allow reflected operations\n                return NotImplemented\n",
    "Location 2 (/root/hy/projects/astropy/astropy/units/core.py lines 2629-2632)": "\n    # If the inputs are not quantity-like, we defer to the input's\n    # __array_ufunc__ method by returning NotImplemented.\n    if method == \"__call__\":\n        # A gufunc's signature always ends in '->', so we can\n        # check if we have a gufunc by checking for this.\n        if ufunc.signature is not None:\n            return self._array_ufunc_comparison_gufunc(\n                ufunc, method, *inputs, **kwargs\n            )\n\n        # Find the inputs that are not Quantities (or subclasses thereof).\n        # This includes ndarray, as well as duck arrays.\n        non_quantity_inputs = []\n        for input_ in inputs:\n            if not isinstance(input_, Quantity):\n                non_quantity_inputs.append(input_)\n\n        # We only support a limited number of ufuncs.  Check if this is a\n        # supported one.\n        if ufunc.__name__ not in self._supported_ufuncs:\n            maybe_raise_for_quantity_subclass(\n                self._supported_ufuncs, ufunc, method, *inputs\n            )\n            return NotImplemented\n\n        # Check whether we support the types of all the non-Quantity inputs.\n        # Numbers are always fine.\n        if not all(\n            can_have_arbitrary_unit(input_) or input_ is None\n            for input_ in non_quantity_inputs\n        ):\n            maybe_raise_for_quantity_subclass(\n                self._supported_ufuncs, ufunc, method, *inputs\n            )\n            return NotImplemented\n\n        # We interact with 2-arg ufuncs at the same level as other duck\n        # arrays.  If we have 2 inputs, one of which is a duck array,\n        # then duck arrays are processed first.\n        if (\n            len(inputs) == 2\n            and len(non_quantity_inputs) == 1\n            and hasattr(non_quantity_inputs[0], \"__array_ufunc__\")\n        ):\n            return NotImplemented\n\n        # Same for if we are a subclass. The subclass's __array_ufunc__\n        # will be called first.\n        if type(self) is not Quantity:\n            return NotImplemented\n\n        # Determine the required conversions for the non-quantity inputs.\n        # By default, they should be dimensionless, i.e., numbers.\n        required_units = len(inputs) * [dimensionless_unscaled]\n        if ufunc in self._unit_ufuncs:\n            required_units = self._unit_ufuncs[ufunc](self.unit, *inputs)\n        elif ufunc in self._comparison_ufuncs:\n            required_units = self._comparison_ufuncs[ufunc](\n                self.unit, *(input_.unit if hasattr(input_, \"unit\") else None for input_ in inputs)\n            )\n\n        # Apply any converters to the non-quantity inputs, as well as to\n        # ourselves if necessary (i.e., this is useful for in-place\n        # operations).\n        converters = [None] * len(inputs)\n        for i, (input_, required_unit) in enumerate(zip(inputs, required_units)):\n            if required_unit is not None:\n                if input_ is self:\n                    # Don't use the private _to_value method since that might\n                    # not work if we're a subclass, or in the case of\n                    # MaskedQuantity.\n                    converters[i] = lambda x: x.to_value(required_unit)\n                else:\n                    try:\n                        converters[i] = self._get_converter(\n                            getattr(input_, \"unit\", dimensionless_unscaled), required_unit\n                        )\n                    except UnitConversionError:\n                        # Don't know how to handle this, so give up.\n                        # But allow non-Quantity inputs to take over.\n                        if not isinstance(input_, Quantity):\n                            return NotImplemented\n                        else:\n                            raise\n\n        # OK, we've validated that we can work with these inputs.\n        # Apply the converters to the inputs.\n        try:\n            for i, converter in enumerate(converters):\n                if converter:\n                    inputs = inputs[:i] + (converter(inputs[i]),) + inputs[i + 1 :]\n        except (ValueError, TypeError):\n            # Conversion failed, likely due to incompatible duck array.\n            # Return NotImplemented to allow duck array's reflected method to handle it.\n            return NotImplemented\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/astropy/astropy/units/quantity.py lines 667-670)": [
      "\n        # Same for inputs, but here also convert if necessary.\n        arrays = []\n        try:\n            for input_, converter in zip(inputs, converters):\n                input_ = getattr(input_, \"value\", input_)\n                arrays.append(converter(input_) if converter else input_)\n        except ValueError:\n            # If conversion fails (e.g., incompatible duck array), return\n            # NotImplemented to allow the other operand's __array_ufunc__ to try.\n            return NotImplemented\n",
      "\n        # Same for inputs, but here also convert if necessary.\n        arrays = []\n        for input_, converter in zip(inputs, converters):\n            input_ = getattr(input_, \"value\", input_)\n            try:\n                arrays.append(converter(input_) if converter else input_)\n            except ValueError:\n                # Conversion failed, likely due to incompatible duck array.\n                # Return NotImplemented to allow reflected operations.\n                return NotImplemented\n",
      "\n        # Same for inputs, but here also convert if necessary.\n        arrays = []\n        for input_, converter in zip(inputs, converters):\n            input_ = getattr(input_, \"value\", input_)\n            try:\n                arrays.append(converter(input_) if converter else input_)\n            except ValueError:\n                # If conversion fails (e.g., incompatible duck arrays),\n                # return NotImplemented to allow reflected operations\n                return NotImplemented\n",
      "\n        # Same for inputs, but here also convert if necessary.\n        arrays = []\n        for input_, converter in zip(inputs, converters):\n            input_ = getattr(input_, \"value\", input_)\n            try:\n                arrays.append(converter(input_) if converter else input_)\n            except ValueError:\n                # If conversion fails (e.g., incompatible duck arrays),\n                # return NotImplemented to allow reflected operations\n                return NotImplemented\n",
      "\n        # Same for inputs, but here also convert if necessary.\n        arrays = []\n        for input_, converter in zip(inputs, converters):\n            input_ = getattr(input_, \"value\", input_)\n            try:\n                arrays.append(converter(input_) if converter else input_)\n            except ValueError:\n                # Converter failed, likely due to incompatible duck array.\n                # Return NotImplemented to allow reflected operations to be tried.\n                return NotImplemented\n",
      "\n        # Same for inputs, but here also convert if necessary.\n        arrays = []\n        for input_, converter in zip(inputs, converters):\n            input_ = getattr(input_, \"value\", input_)\n            try:\n                arrays.append(converter(input_) if converter else input_)\n            except ValueError:\n                # If conversion fails (e.g., incompatible duck arrays),\n                # return NotImplemented to allow reflected operations\n                return NotImplemented\n",
      "\n        # Same for inputs, but here also convert if necessary.\n        arrays = []\n        for input_, converter in zip(inputs, converters):\n            input_ = getattr(input_, \"value\", input_)\n            try:\n                arrays.append(converter(input_) if converter else input_)\n            except ValueError:\n                # If conversion fails (e.g., incompatible duck arrays),\n                # return NotImplemented to allow reflected operations\n                return NotImplemented\n",
      "\n        # Same for inputs, but here also convert if necessary.\n        arrays = []\n        for input_, converter in zip(inputs, converters):\n            input_ = getattr(input_, \"value\", input_)\n            try:\n                arrays.append(converter(input_) if converter else input_)\n            except ValueError:\n                # If conversion fails (e.g., incompatible duck arrays),\n                # return NotImplemented to allow reflected operations\n                return NotImplemented\n"
    ],
    "Location 2 (/root/hy/projects/astropy/astropy/units/core.py lines 2629-2632)": [
      "\n    for converter in converters:\n        try:\n            args = converter(args)\n        except (ValueError, TypeError):\n            # If conversion fails (e.g., incompatible duck arrays),\n            # return NotImplemented to allow reflected operations\n            return NotImplemented\n",
      "\n        # Call the converters to actually do the scaling.\n        for converter in converters:\n            try:\n                args = converter(args)\n            except ValueError:\n                # If conversion fails (e.g., incompatible duck arrays),\n                # return NotImplemented to allow reflected operations\n                return NotImplemented\n",
      "\n            # Apply the converters\n            try:\n                for converter in converters:\n                    args = converter(args)\n                    kwargs = converter(kwargs)\n            except ValueError:\n                # If conversion fails (e.g., incompatible duck arrays),\n                # return NotImplemented to allow reflected operations\n                return NotImplemented\n",
      "\n    # Apply the converters to the inputs.\n    try:\n        arrays = [converter(array) for converter, array in zip(converters, arrays)]\n    except ValueError:\n        # If conversion fails (e.g., incompatible duck arrays), return NotImplemented\n        # to allow the other operand's __array_ufunc__ or reflected methods to handle it\n        return NotImplemented\n",
      "\n    # Apply the converters to the input\n    try:\n        for converter in converters:\n            args = converter(args)\n    except (ValueError, TypeError):\n        # If conversion fails (e.g., incompatible duck arrays),\n        # return NotImplemented to allow reflected operations\n        return NotImplemented\n",
      "\n    # Apply the converters\n    try:\n        for i, converter in enumerate(converters):\n            if converter is not unit_scale_converter:\n                args = args[:i] + (converter(args[i]),) + args[i + 1 :]\n    except ValueError:\n        # If conversion fails (e.g., incompatible duck arrays), \n        # return NotImplemented to allow reflected operations\n        return NotImplemented\n",
      "\n        # Convert the inputs to the expected units.\n        try:\n            for i, converter in enumerate(converters):\n                if converter is not None:\n                    inputs = list(inputs)\n                    inputs[i] = converter(inputs[i])\n                    inputs = tuple(inputs)\n        except (ValueError, TypeError):\n            # If unit conversion fails (e.g., incompatible duck arrays),\n            # return NotImplemented to allow the other operand's\n            # reflected method to handle the operation\n            return NotImplemented\n",
      "\n            # Apply the converters\n            try:\n                for converter in converters:\n                    args = converter(args)\n                    kwargs = converter(kwargs)\n            except (ValueError, TypeError):\n                # If conversion fails (e.g., incompatible duck arrays), \n                # return NotImplemented to allow reflected operations\n                return NotImplemented\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/astropy/units/core.py b/astropy/units/core.py\nindex 8c3204b8b0..ee9896c0d1 100644\n--- a/astropy/units/core.py\n+++ b/astropy/units/core.py\n@@ -2626,6 +2626,7 @@ def _condition_arg(value):\n \n     avalue = np.array(value)\n     if avalue.dtype.kind not in [\"i\", \"f\", \"c\"]:\n+\n         raise ValueError(\n             \"Value not scalar compatible or convertible to \"\n             \"an int, float, or complex array\"\ndiff --git a/astropy/units/quantity.py b/astropy/units/quantity.py\nindex b98abfafb0..c5ff82b344 100644\n--- a/astropy/units/quantity.py\n+++ b/astropy/units/quantity.py\n@@ -664,10 +664,16 @@ class Quantity(np.ndarray):\n             )\n \n         # Same for inputs, but here also convert if necessary.\n+\n         arrays = []\n-        for input_, converter in zip(inputs, converters):\n-            input_ = getattr(input_, \"value\", input_)\n-            arrays.append(converter(input_) if converter else input_)\n+        try:\n+            for input_, converter in zip(inputs, converters):\n+                input_ = getattr(input_, \"value\", input_)\n+                arrays.append(converter(input_) if converter else input_)\n+        except ValueError:\n+            # If conversion fails (e.g., incompatible duck arrays), return\n+            # NotImplemented to allow other objects to handle the operation\n+            return NotImplemented\n \n         # Call our superclass's __array_ufunc__\n         result = super().__array_ufunc__(function, method, *arrays, **kwargs)\n",
    "variant_0": "diff --git a/astropy/units/core.py b/astropy/units/core.py\nindex 8c3204b8b0..f9d675eada 100644\n--- a/astropy/units/core.py\n+++ b/astropy/units/core.py\n@@ -2626,10 +2626,102 @@ def _condition_arg(value):\n \n     avalue = np.array(value)\n     if avalue.dtype.kind not in [\"i\", \"f\", \"c\"]:\n-        raise ValueError(\n-            \"Value not scalar compatible or convertible to \"\n-            \"an int, float, or complex array\"\n-        )\n+\n+    # If the inputs are not quantity-like, we defer to the input's\n+    # __array_ufunc__ method by returning NotImplemented.\n+    if method == \"__call__\":\n+        # A gufunc's signature always ends in '->', so we can\n+        # check if we have a gufunc by checking for this.\n+        if ufunc.signature is not None:\n+            return self._array_ufunc_comparison_gufunc(\n+                ufunc, method, *inputs, **kwargs\n+            )\n+\n+        # Find the inputs that are not Quantities (or subclasses thereof).\n+        # This includes ndarray, as well as duck arrays.\n+        non_quantity_inputs = []\n+        for input_ in inputs:\n+            if not isinstance(input_, Quantity):\n+                non_quantity_inputs.append(input_)\n+\n+        # We only support a limited number of ufuncs.  Check if this is a\n+        # supported one.\n+        if ufunc.__name__ not in self._supported_ufuncs:\n+            maybe_raise_for_quantity_subclass(\n+                self._supported_ufuncs, ufunc, method, *inputs\n+            )\n+            return NotImplemented\n+\n+        # Check whether we support the types of all the non-Quantity inputs.\n+        # Numbers are always fine.\n+        if not all(\n+            can_have_arbitrary_unit(input_) or input_ is None\n+            for input_ in non_quantity_inputs\n+        ):\n+            maybe_raise_for_quantity_subclass(\n+                self._supported_ufuncs, ufunc, method, *inputs\n+            )\n+            return NotImplemented\n+\n+        # We interact with 2-arg ufuncs at the same level as other duck\n+        # arrays.  If we have 2 inputs, one of which is a duck array,\n+        # then duck arrays are processed first.\n+        if (\n+            len(inputs) == 2\n+            and len(non_quantity_inputs) == 1\n+            and hasattr(non_quantity_inputs[0], \"__array_ufunc__\")\n+        ):\n+            return NotImplemented\n+\n+        # Same for if we are a subclass. The subclass's __array_ufunc__\n+        # will be called first.\n+        if type(self) is not Quantity:\n+            return NotImplemented\n+\n+        # Determine the required conversions for the non-quantity inputs.\n+        # By default, they should be dimensionless, i.e., numbers.\n+        required_units = len(inputs) * [dimensionless_unscaled]\n+        if ufunc in self._unit_ufuncs:\n+            required_units = self._unit_ufuncs[ufunc](self.unit, *inputs)\n+        elif ufunc in self._comparison_ufuncs:\n+            required_units = self._comparison_ufuncs[ufunc](\n+                self.unit, *(input_.unit if hasattr(input_, \"unit\") else None for input_ in inputs)\n+            )\n+\n+        # Apply any converters to the non-quantity inputs, as well as to\n+        # ourselves if necessary (i.e., this is useful for in-place\n+        # operations).\n+        converters = [None] * len(inputs)\n+        for i, (input_, required_unit) in enumerate(zip(inputs, required_units)):\n+            if required_unit is not None:\n+                if input_ is self:\n+                    # Don't use the private _to_value method since that might\n+                    # not work if we're a subclass, or in the case of\n+                    # MaskedQuantity.\n+                    converters[i] = lambda x: x.to_value(required_unit)\n+                else:\n+                    try:\n+                        converters[i] = self._get_converter(\n+                            getattr(input_, \"unit\", dimensionless_unscaled), required_unit\n+                        )\n+                    except UnitConversionError:\n+                        # Don't know how to handle this, so give up.\n+                        # But allow non-Quantity inputs to take over.\n+                        if not isinstance(input_, Quantity):\n+                            return NotImplemented\n+                        else:\n+                            raise\n+\n+        # OK, we've validated that we can work with these inputs.\n+        # Apply the converters to the inputs.\n+        try:\n+            for i, converter in enumerate(converters):\n+                if converter:\n+                    inputs = inputs[:i] + (converter(inputs[i]),) + inputs[i + 1 :]\n+        except (ValueError, TypeError):\n+            # Conversion failed, likely due to incompatible duck array.\n+            # Return NotImplemented to allow duck array's reflected method to handle it.\n+            return NotImplemented\n     return avalue\n \n \ndiff --git a/astropy/units/quantity.py b/astropy/units/quantity.py\nindex b98abfafb0..e358966624 100644\n--- a/astropy/units/quantity.py\n+++ b/astropy/units/quantity.py\n@@ -663,11 +663,18 @@ class Quantity(np.ndarray):\n                 kwargs[\"initial\"], check_precision=False, unit=unit\n             )\n \n+        # Same for inputs, but here also convert if necessary.\n+\n         # Same for inputs, but here also convert if necessary.\n         arrays = []\n         for input_, converter in zip(inputs, converters):\n             input_ = getattr(input_, \"value\", input_)\n-            arrays.append(converter(input_) if converter else input_)\n+            try:\n+                arrays.append(converter(input_) if converter else input_)\n+            except ValueError:\n+                # If conversion fails (e.g., incompatible duck arrays),\n+                # return NotImplemented to allow reflected operations\n+                return NotImplemented\n \n         # Call our superclass's __array_ufunc__\n         result = super().__array_ufunc__(function, method, *arrays, **kwargs)\n",
    "variant_1": "diff --git a/astropy/units/core.py b/astropy/units/core.py\nindex 8c3204b8b0..79b08bf071 100644\n--- a/astropy/units/core.py\n+++ b/astropy/units/core.py\n@@ -2626,10 +2626,14 @@ def _condition_arg(value):\n \n     avalue = np.array(value)\n     if avalue.dtype.kind not in [\"i\", \"f\", \"c\"]:\n-        raise ValueError(\n-            \"Value not scalar compatible or convertible to \"\n-            \"an int, float, or complex array\"\n-        )\n+\n+    for converter in converters:\n+        try:\n+            args = converter(args)\n+        except (ValueError, TypeError):\n+            # If conversion fails (e.g., incompatible duck arrays),\n+            # return NotImplemented to allow reflected operations\n+            return NotImplemented\n     return avalue\n \n \ndiff --git a/astropy/units/quantity.py b/astropy/units/quantity.py\nindex b98abfafb0..be8ff806eb 100644\n--- a/astropy/units/quantity.py\n+++ b/astropy/units/quantity.py\n@@ -663,11 +663,18 @@ class Quantity(np.ndarray):\n                 kwargs[\"initial\"], check_precision=False, unit=unit\n             )\n \n+        # Same for inputs, but here also convert if necessary.\n+\n         # Same for inputs, but here also convert if necessary.\n         arrays = []\n-        for input_, converter in zip(inputs, converters):\n-            input_ = getattr(input_, \"value\", input_)\n-            arrays.append(converter(input_) if converter else input_)\n+        try:\n+            for input_, converter in zip(inputs, converters):\n+                input_ = getattr(input_, \"value\", input_)\n+                arrays.append(converter(input_) if converter else input_)\n+        except ValueError:\n+            # If conversion fails (e.g., incompatible duck array), return\n+            # NotImplemented to allow the other operand's __array_ufunc__ to try.\n+            return NotImplemented\n \n         # Call our superclass's __array_ufunc__\n         result = super().__array_ufunc__(function, method, *arrays, **kwargs)\n",
    "variant_2": "diff --git a/astropy/units/core.py b/astropy/units/core.py\nindex 8c3204b8b0..7df2fe54c9 100644\n--- a/astropy/units/core.py\n+++ b/astropy/units/core.py\n@@ -2626,10 +2626,15 @@ def _condition_arg(value):\n \n     avalue = np.array(value)\n     if avalue.dtype.kind not in [\"i\", \"f\", \"c\"]:\n-        raise ValueError(\n-            \"Value not scalar compatible or convertible to \"\n-            \"an int, float, or complex array\"\n-        )\n+\n+        # Call the converters to actually do the scaling.\n+        for converter in converters:\n+            try:\n+                args = converter(args)\n+            except ValueError:\n+                # If conversion fails (e.g., incompatible duck arrays),\n+                # return NotImplemented to allow reflected operations\n+                return NotImplemented\n     return avalue\n \n \ndiff --git a/astropy/units/quantity.py b/astropy/units/quantity.py\nindex b98abfafb0..cd94911069 100644\n--- a/astropy/units/quantity.py\n+++ b/astropy/units/quantity.py\n@@ -663,11 +663,18 @@ class Quantity(np.ndarray):\n                 kwargs[\"initial\"], check_precision=False, unit=unit\n             )\n \n+        # Same for inputs, but here also convert if necessary.\n+\n         # Same for inputs, but here also convert if necessary.\n         arrays = []\n         for input_, converter in zip(inputs, converters):\n             input_ = getattr(input_, \"value\", input_)\n-            arrays.append(converter(input_) if converter else input_)\n+            try:\n+                arrays.append(converter(input_) if converter else input_)\n+            except ValueError:\n+                # Conversion failed, likely due to incompatible duck array.\n+                # Return NotImplemented to allow reflected operations.\n+                return NotImplemented\n \n         # Call our superclass's __array_ufunc__\n         result = super().__array_ufunc__(function, method, *arrays, **kwargs)\n",
    "variant_3": "diff --git a/astropy/units/core.py b/astropy/units/core.py\nindex 8c3204b8b0..9c9111d57f 100644\n--- a/astropy/units/core.py\n+++ b/astropy/units/core.py\n@@ -2626,10 +2626,16 @@ def _condition_arg(value):\n \n     avalue = np.array(value)\n     if avalue.dtype.kind not in [\"i\", \"f\", \"c\"]:\n-        raise ValueError(\n-            \"Value not scalar compatible or convertible to \"\n-            \"an int, float, or complex array\"\n-        )\n+\n+            # Apply the converters\n+            try:\n+                for converter in converters:\n+                    args = converter(args)\n+                    kwargs = converter(kwargs)\n+            except ValueError:\n+                # If conversion fails (e.g., incompatible duck arrays),\n+                # return NotImplemented to allow reflected operations\n+                return NotImplemented\n     return avalue\n \n \ndiff --git a/astropy/units/quantity.py b/astropy/units/quantity.py\nindex b98abfafb0..e358966624 100644\n--- a/astropy/units/quantity.py\n+++ b/astropy/units/quantity.py\n@@ -663,11 +663,18 @@ class Quantity(np.ndarray):\n                 kwargs[\"initial\"], check_precision=False, unit=unit\n             )\n \n+        # Same for inputs, but here also convert if necessary.\n+\n         # Same for inputs, but here also convert if necessary.\n         arrays = []\n         for input_, converter in zip(inputs, converters):\n             input_ = getattr(input_, \"value\", input_)\n-            arrays.append(converter(input_) if converter else input_)\n+            try:\n+                arrays.append(converter(input_) if converter else input_)\n+            except ValueError:\n+                # If conversion fails (e.g., incompatible duck arrays),\n+                # return NotImplemented to allow reflected operations\n+                return NotImplemented\n \n         # Call our superclass's __array_ufunc__\n         result = super().__array_ufunc__(function, method, *arrays, **kwargs)\n",
    "variant_4": "diff --git a/astropy/units/core.py b/astropy/units/core.py\nindex 8c3204b8b0..ae65bb5fca 100644\n--- a/astropy/units/core.py\n+++ b/astropy/units/core.py\n@@ -2626,10 +2626,14 @@ def _condition_arg(value):\n \n     avalue = np.array(value)\n     if avalue.dtype.kind not in [\"i\", \"f\", \"c\"]:\n-        raise ValueError(\n-            \"Value not scalar compatible or convertible to \"\n-            \"an int, float, or complex array\"\n-        )\n+\n+    # Apply the converters to the inputs.\n+    try:\n+        arrays = [converter(array) for converter, array in zip(converters, arrays)]\n+    except ValueError:\n+        # If conversion fails (e.g., incompatible duck arrays), return NotImplemented\n+        # to allow the other operand's __array_ufunc__ or reflected methods to handle it\n+        return NotImplemented\n     return avalue\n \n \ndiff --git a/astropy/units/quantity.py b/astropy/units/quantity.py\nindex b98abfafb0..e358966624 100644\n--- a/astropy/units/quantity.py\n+++ b/astropy/units/quantity.py\n@@ -663,11 +663,18 @@ class Quantity(np.ndarray):\n                 kwargs[\"initial\"], check_precision=False, unit=unit\n             )\n \n+        # Same for inputs, but here also convert if necessary.\n+\n         # Same for inputs, but here also convert if necessary.\n         arrays = []\n         for input_, converter in zip(inputs, converters):\n             input_ = getattr(input_, \"value\", input_)\n-            arrays.append(converter(input_) if converter else input_)\n+            try:\n+                arrays.append(converter(input_) if converter else input_)\n+            except ValueError:\n+                # If conversion fails (e.g., incompatible duck arrays),\n+                # return NotImplemented to allow reflected operations\n+                return NotImplemented\n \n         # Call our superclass's __array_ufunc__\n         result = super().__array_ufunc__(function, method, *arrays, **kwargs)\n",
    "variant_5": "diff --git a/astropy/units/core.py b/astropy/units/core.py\nindex 8c3204b8b0..857ce1e1c4 100644\n--- a/astropy/units/core.py\n+++ b/astropy/units/core.py\n@@ -2626,10 +2626,15 @@ def _condition_arg(value):\n \n     avalue = np.array(value)\n     if avalue.dtype.kind not in [\"i\", \"f\", \"c\"]:\n-        raise ValueError(\n-            \"Value not scalar compatible or convertible to \"\n-            \"an int, float, or complex array\"\n-        )\n+\n+    # Apply the converters to the input\n+    try:\n+        for converter in converters:\n+            args = converter(args)\n+    except (ValueError, TypeError):\n+        # If conversion fails (e.g., incompatible duck arrays),\n+        # return NotImplemented to allow reflected operations\n+        return NotImplemented\n     return avalue\n \n \ndiff --git a/astropy/units/quantity.py b/astropy/units/quantity.py\nindex b98abfafb0..67b878e2f1 100644\n--- a/astropy/units/quantity.py\n+++ b/astropy/units/quantity.py\n@@ -663,11 +663,18 @@ class Quantity(np.ndarray):\n                 kwargs[\"initial\"], check_precision=False, unit=unit\n             )\n \n+        # Same for inputs, but here also convert if necessary.\n+\n         # Same for inputs, but here also convert if necessary.\n         arrays = []\n         for input_, converter in zip(inputs, converters):\n             input_ = getattr(input_, \"value\", input_)\n-            arrays.append(converter(input_) if converter else input_)\n+            try:\n+                arrays.append(converter(input_) if converter else input_)\n+            except ValueError:\n+                # Converter failed, likely due to incompatible duck array.\n+                # Return NotImplemented to allow reflected operations to be tried.\n+                return NotImplemented\n \n         # Call our superclass's __array_ufunc__\n         result = super().__array_ufunc__(function, method, *arrays, **kwargs)\n",
    "variant_6": "diff --git a/astropy/units/core.py b/astropy/units/core.py\nindex 8c3204b8b0..46c2cb8143 100644\n--- a/astropy/units/core.py\n+++ b/astropy/units/core.py\n@@ -2626,10 +2626,16 @@ def _condition_arg(value):\n \n     avalue = np.array(value)\n     if avalue.dtype.kind not in [\"i\", \"f\", \"c\"]:\n-        raise ValueError(\n-            \"Value not scalar compatible or convertible to \"\n-            \"an int, float, or complex array\"\n-        )\n+\n+    # Apply the converters\n+    try:\n+        for i, converter in enumerate(converters):\n+            if converter is not unit_scale_converter:\n+                args = args[:i] + (converter(args[i]),) + args[i + 1 :]\n+    except ValueError:\n+        # If conversion fails (e.g., incompatible duck arrays), \n+        # return NotImplemented to allow reflected operations\n+        return NotImplemented\n     return avalue\n \n \ndiff --git a/astropy/units/quantity.py b/astropy/units/quantity.py\nindex b98abfafb0..e358966624 100644\n--- a/astropy/units/quantity.py\n+++ b/astropy/units/quantity.py\n@@ -663,11 +663,18 @@ class Quantity(np.ndarray):\n                 kwargs[\"initial\"], check_precision=False, unit=unit\n             )\n \n+        # Same for inputs, but here also convert if necessary.\n+\n         # Same for inputs, but here also convert if necessary.\n         arrays = []\n         for input_, converter in zip(inputs, converters):\n             input_ = getattr(input_, \"value\", input_)\n-            arrays.append(converter(input_) if converter else input_)\n+            try:\n+                arrays.append(converter(input_) if converter else input_)\n+            except ValueError:\n+                # If conversion fails (e.g., incompatible duck arrays),\n+                # return NotImplemented to allow reflected operations\n+                return NotImplemented\n \n         # Call our superclass's __array_ufunc__\n         result = super().__array_ufunc__(function, method, *arrays, **kwargs)\n",
    "variant_7": "diff --git a/astropy/units/core.py b/astropy/units/core.py\nindex 8c3204b8b0..6e52ded40c 100644\n--- a/astropy/units/core.py\n+++ b/astropy/units/core.py\n@@ -2626,10 +2626,19 @@ def _condition_arg(value):\n \n     avalue = np.array(value)\n     if avalue.dtype.kind not in [\"i\", \"f\", \"c\"]:\n-        raise ValueError(\n-            \"Value not scalar compatible or convertible to \"\n-            \"an int, float, or complex array\"\n-        )\n+\n+        # Convert the inputs to the expected units.\n+        try:\n+            for i, converter in enumerate(converters):\n+                if converter is not None:\n+                    inputs = list(inputs)\n+                    inputs[i] = converter(inputs[i])\n+                    inputs = tuple(inputs)\n+        except (ValueError, TypeError):\n+            # If unit conversion fails (e.g., incompatible duck arrays),\n+            # return NotImplemented to allow the other operand's\n+            # reflected method to handle the operation\n+            return NotImplemented\n     return avalue\n \n \ndiff --git a/astropy/units/quantity.py b/astropy/units/quantity.py\nindex b98abfafb0..e358966624 100644\n--- a/astropy/units/quantity.py\n+++ b/astropy/units/quantity.py\n@@ -663,11 +663,18 @@ class Quantity(np.ndarray):\n                 kwargs[\"initial\"], check_precision=False, unit=unit\n             )\n \n+        # Same for inputs, but here also convert if necessary.\n+\n         # Same for inputs, but here also convert if necessary.\n         arrays = []\n         for input_, converter in zip(inputs, converters):\n             input_ = getattr(input_, \"value\", input_)\n-            arrays.append(converter(input_) if converter else input_)\n+            try:\n+                arrays.append(converter(input_) if converter else input_)\n+            except ValueError:\n+                # If conversion fails (e.g., incompatible duck arrays),\n+                # return NotImplemented to allow reflected operations\n+                return NotImplemented\n \n         # Call our superclass's __array_ufunc__\n         result = super().__array_ufunc__(function, method, *arrays, **kwargs)\n",
    "variant_8": "diff --git a/astropy/units/core.py b/astropy/units/core.py\nindex 8c3204b8b0..2ee9bdcaf1 100644\n--- a/astropy/units/core.py\n+++ b/astropy/units/core.py\n@@ -2626,10 +2626,16 @@ def _condition_arg(value):\n \n     avalue = np.array(value)\n     if avalue.dtype.kind not in [\"i\", \"f\", \"c\"]:\n-        raise ValueError(\n-            \"Value not scalar compatible or convertible to \"\n-            \"an int, float, or complex array\"\n-        )\n+\n+            # Apply the converters\n+            try:\n+                for converter in converters:\n+                    args = converter(args)\n+                    kwargs = converter(kwargs)\n+            except (ValueError, TypeError):\n+                # If conversion fails (e.g., incompatible duck arrays), \n+                # return NotImplemented to allow reflected operations\n+                return NotImplemented\n     return avalue\n \n \ndiff --git a/astropy/units/quantity.py b/astropy/units/quantity.py\nindex b98abfafb0..e358966624 100644\n--- a/astropy/units/quantity.py\n+++ b/astropy/units/quantity.py\n@@ -663,11 +663,18 @@ class Quantity(np.ndarray):\n                 kwargs[\"initial\"], check_precision=False, unit=unit\n             )\n \n+        # Same for inputs, but here also convert if necessary.\n+\n         # Same for inputs, but here also convert if necessary.\n         arrays = []\n         for input_, converter in zip(inputs, converters):\n             input_ = getattr(input_, \"value\", input_)\n-            arrays.append(converter(input_) if converter else input_)\n+            try:\n+                arrays.append(converter(input_) if converter else input_)\n+            except ValueError:\n+                # If conversion fails (e.g., incompatible duck arrays),\n+                # return NotImplemented to allow reflected operations\n+                return NotImplemented\n \n         # Call our superclass's __array_ufunc__\n         result = super().__array_ufunc__(function, method, *arrays, **kwargs)\n"
  }
}