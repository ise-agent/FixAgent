{
  "zero_patches": {
    "Location 1 (/root/hy/projects/django/django/db/models/sql/query.py lines 1027-1031)": "\n        # Consider filtered_relation in join reuse only when both joins have them\n        reuse_aliases = []\n        for a, j in self.alias_map.items():\n            if reuse is None or a in reuse:\n                # For joins with filtered_relations, require exact match including the filtered_relation\n                if join.filtered_relation is not None and j.filtered_relation is not None:\n                    if j.identity == join.identity:\n                        reuse_aliases.append(a)\n                # For regular joins or mixed cases, use the original logic\n                elif j.equals(join):\n                    reuse_aliases.append(a)\n",
    "Location 2 (/root/hy/projects/django/django/db/models/sql/query.py lines 1032-1040)": "\ndef equals(self, other):\n    # Include filtered_relation in equality check when both joins have them\n    if self.filtered_relation is not None and other.filtered_relation is not None:\n        return self.identity == other.identity\n    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n    return self.identity[:-1] == other.identity[:-1]\n",
    "Location 3 (/root/hy/projects/django/django/db/models/sql/query.py lines 1042-1054)": "\ndef equals(self, other):\n    # Include filtered_relation in equality check when both joins have them\n    if self.filtered_relation is not None and other.filtered_relation is not None:\n        return self.identity == other.identity\n    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n    return self.identity[:-1] == other.identity[:-1]\n",
    "Location 4 (/root/hy/projects/django/django/db/models/sql/query.py lines 1800-1826)": "\ndef equals(self, other):\n    # Include filtered_relation in equality check when both joins have them\n    if self.filtered_relation is not None and other.filtered_relation is not None:\n        return self.identity == other.identity\n    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n    return self.identity[:-1] == other.identity[:-1]\n",
    "Location 5 (/root/hy/projects/django/django/db/models/sql/query.py lines 1572-1601)": "\ndef equals(self, other):\n    # Include filtered_relation in equality check when both joins have them\n    if self.filtered_relation is not None and other.filtered_relation is not None:\n        return self.identity == other.identity\n    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n    return self.identity[:-1] == other.identity[:-1]\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/django/django/db/models/sql/query.py lines 1027-1031)": [
      "\nreuse_aliases = [\n    a\n    for a, j in self.alias_map.items()\n    if (reuse is None or a in reuse) and j.equals(join) and (\n        # For joins with filtered_relation, ensure they have the same conditions\n        j.filtered_relation == join.filtered_relation or\n        # For regular joins without filtered_relation, allow reuse\n        (j.filtered_relation is None and join.filtered_relation is None)\n    )\n]\n",
      "\n        # Only reuse joins that have identical FilteredRelation conditions\n        reuse_aliases = [\n            a\n            for a, j in self.alias_map.items()\n            if (reuse is None or a in reuse) and j.equals(join) and (\n                (j.filtered_relation is None and join.filtered_relation is None) or\n                (j.filtered_relation is not None and join.filtered_relation is not None and\n                 j.filtered_relation.condition == join.filtered_relation.condition)\n            )\n        ]\n",
      "\n        reuse_aliases = [\n            a\n            for a, j in self.alias_map.items()\n            if (reuse is None or a in reuse) and j.equals(join) and (\n                # Don't reuse if filtered_relations differ\n                j.filtered_relation == join.filtered_relation or\n                (j.filtered_relation is None and join.filtered_relation is None)\n            )\n        ]\n",
      "\ndef equals(self, other):\n    # Include filtered_relation in equality check when both joins have filtered relations\n    if (self.filtered_relation is not None and \n        other.filtered_relation is not None):\n        return self.identity == other.identity\n    # For regular joins or mixed scenarios, ignore filtered_relation in comparison\n    return self.identity[:-1] == other.identity[:-1]\n",
      "\n        reuse_aliases = [\n            a\n            for a, j in self.alias_map.items()\n            if (reuse is None or a in reuse) and j.equals(join)\n        ]\n",
      "\n        # Only reuse aliases for joins with identical filtered_relation conditions\n        reuse_aliases = [\n            a\n            for a, j in self.alias_map.items()\n            if (reuse is None or a in reuse) and j.equals(join) and (\n                # Both have same filtered_relation (including None)\n                j.filtered_relation == join.filtered_relation or\n                # Both are None\n                (j.filtered_relation is None and join.filtered_relation is None)\n            )\n        ]\n",
      "\n        # Include filtered_relation in equality check when both joins have FilteredRelations\n        if join.filtered_relation is not None:\n            # For joins with FilteredRelations, require exact match including the condition\n            reuse_aliases = [\n                a\n                for a, j in self.alias_map.items()\n                if (reuse is None or a in reuse) and j.identity == join.identity\n            ]\n        else:\n            # For regular joins, use the existing logic that ignores filtered_relation\n            reuse_aliases = [\n                a\n                for a, j in self.alias_map.items()\n                if (reuse is None or a in reuse) and j.equals(join)\n            ]\n",
      "\n        # Only reuse joins when they are truly equivalent, including filtered_relation\n        reuse_aliases = []\n        for a, j in self.alias_map.items():\n            if (reuse is None or a in reuse) and j.equals(join):\n                # Additional check: if both joins have filtered_relation, they must be the same\n                if (j.filtered_relation is not None and join.filtered_relation is not None and\n                    j.filtered_relation != join.filtered_relation):\n                    continue\n                reuse_aliases.append(a)\n"
    ],
    "Location 2 (/root/hy/projects/django/django/db/models/sql/query.py lines 1032-1040)": [
      "\ndef equals(self, other):\n    # Include filtered_relation in equality check when both joins have filtered_relations\n    if self.filtered_relation is not None and other.filtered_relation is not None:\n        return self.identity == other.identity\n    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n    return self.identity[:-1] == other.identity[:-1]\n",
      "\ndef equals(self, other):\n    # Include filtered_relation in equality check when both joins have them\n    if self.filtered_relation is not None and other.filtered_relation is not None:\n        return self.identity == other.identity\n    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n    return self.identity[:-1] == other.identity[:-1]\n",
      "\ndef equals(self, other):\n    \"\"\"\n    Return True if this join is equivalent to other.\n    \"\"\"\n    if not isinstance(other, self.__class__):\n        return False\n    # Include filtered_relation in equality check when both joins have them\n    if self.filtered_relation is not None and other.filtered_relation is not None:\n        return self.identity == other.identity\n    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n    return self.identity[:-1] == other.identity[:-1]\n",
      "\ndef equals(self, other):\n    # Include filtered_relation in equality check when both joins have them\n    if self.filtered_relation is not None and other.filtered_relation is not None:\n        return self.identity == other.identity\n    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n    return self.identity[:-1] == other.identity[:-1]\n",
      "\ndef equals(self, other):\n    # Include filtered_relation in equality check when both joins have them\n    if self.filtered_relation is not None and other.filtered_relation is not None:\n        return self.identity == other.identity\n    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n    return self.identity[:-1] == other.identity[:-1]\n",
      "\ndef equals(self, other):\n    # Include filtered_relation in equality check when both joins have them\n    if self.filtered_relation is not None and other.filtered_relation is not None:\n        return self.identity == other.identity\n    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n    return self.identity[:-1] == other.identity[:-1]\n",
      "\ndef equals(self, other):\n    # Include filtered_relation in equality check when both joins have them\n    if self.filtered_relation is not None and other.filtered_relation is not None:\n        return self.identity == other.identity\n    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n    return self.identity[:-1] == other.identity[:-1]\n",
      "\ndef equals(self, other):\n    # Include filtered_relation in equality check when both joins have them\n    if self.filtered_relation is not None and other.filtered_relation is not None:\n        return self.identity == other.identity\n    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n    return self.identity[:-1] == other.identity[:-1]\n"
    ],
    "Location 3 (/root/hy/projects/django/django/db/models/sql/query.py lines 1042-1054)": [
      "\n    def equals(self, other):\n        # Include filtered_relation in equality check when both joins have them\n        if self.filtered_relation is not None and other.filtered_relation is not None:\n            return self.identity == other.identity\n        # For regular joins or when only one has filtered_relation, ignore filtered_relation\n        return self.identity[:-1] == other.identity[:-1]\n",
      "\ndef equals(self, other):\n    \"\"\"\n    Return True if this join is equivalent to other.\n    \n    For joins with filtered_relation, both the relation path and the\n    filtered_relation condition must match for the joins to be considered equal.\n    \"\"\"\n    if not isinstance(other, self.__class__):\n        return False\n    \n    # If both joins have filtered_relation, include it in the comparison\n    if self.filtered_relation is not None and other.filtered_relation is not None:\n        return self.identity == other.identity\n    \n    # If neither has filtered_relation or only one has it, compare without filtered_relation\n    # This maintains backward compatibility for regular joins\n    return self.identity[:-1] == other.identity[:-1]\n",
      "\ndef equals(self, other):\n    # Include filtered_relation in equality check when both joins have them\n    if self.filtered_relation is not None and other.filtered_relation is not None:\n        return self.identity == other.identity\n    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n    return self.identity[:-1] == other.identity[:-1]\n",
      "\ndef equals(self, other):\n    # Include filtered_relation in equality check when both joins have them\n    if self.filtered_relation is not None and other.filtered_relation is not None:\n        return self.identity == other.identity\n    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n    return self.identity[:-1] == other.identity[:-1]\n",
      "\ndef equals(self, other):\n    # Include filtered_relation in equality check when both joins have them\n    if self.filtered_relation is not None and other.filtered_relation is not None:\n        return self.identity == other.identity\n    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n    return self.identity[:-1] == other.identity[:-1]\n",
      "\ndef equals(self, other):\n    # Include filtered_relation in equality check when both joins have them\n    if self.filtered_relation is not None and other.filtered_relation is not None:\n        return self.identity == other.identity\n    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n    return self.identity[:-1] == other.identity[:-1]\n",
      "\n    def equals(self, other):\n        # Include filtered_relation in equality check when both joins have them\n        if self.filtered_relation is not None and other.filtered_relation is not None:\n            return self.identity == other.identity\n        # For regular joins or when only one has filtered_relation, ignore filtered_relation\n        return self.identity[:-1] == other.identity[:-1]\n",
      "\ndef equals(self, other):\n    # Include filtered_relation in equality check when both joins have them\n    if self.filtered_relation is not None and other.filtered_relation is not None:\n        return self.identity == other.identity\n    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n    return self.identity[:-1] == other.identity[:-1]\n"
    ],
    "Location 4 (/root/hy/projects/django/django/db/models/sql/query.py lines 1800-1826)": [
      "\n    def equals(self, other):\n        # Include filtered_relation in equality check when both joins have them\n        if self.filtered_relation is not None and other.filtered_relation is not None:\n            return self.identity == other.identity\n        # For regular joins or when only one has filtered_relation, ignore filtered_relation\n        return self.identity[:-1] == other.identity[:-1]\n",
      "\ndef equals(self, other):\n    # Include filtered_relation in equality check when both joins have them\n    if self.filtered_relation is not None and other.filtered_relation is not None:\n        return self.identity == other.identity\n    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n    return self.identity[:-1] == other.identity[:-1]\n",
      "\ndef equals(self, other):\n    # Include filtered_relation in equality check when both joins have them\n    if self.filtered_relation is not None and other.filtered_relation is not None:\n        return self.identity == other.identity\n    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n    return self.identity[:-1] == other.identity[:-1]\n",
      "\ndef equals(self, other):\n    # Include filtered_relation in equality check when both joins have them\n    if self.filtered_relation is not None and other.filtered_relation is not None:\n        return self.identity == other.identity\n    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n    return self.identity[:-1] == other.identity[:-1]\n",
      "\ndef equals(self, other):\n    # Include filtered_relation in equality check when both joins have them\n    if self.filtered_relation is not None and other.filtered_relation is not None:\n        return self.identity == other.identity\n    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n    return self.identity[:-1] == other.identity[:-1]\n",
      "\ndef equals(self, other):\n    # Include filtered_relation in equality check when both joins have them\n    if self.filtered_relation is not None and other.filtered_relation is not None:\n        return self.identity == other.identity\n    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n    return self.identity[:-1] == other.identity[:-1]\n",
      "\ndef equals(self, other):\n    \"\"\"\n    Return True if this join is equivalent to other.\n    \n    Two joins are considered equivalent if they have the same identity,\n    but for filtered relations, we need to compare the full identity\n    including the filtered_relation to distinguish between different\n    filtering conditions on the same relation path.\n    \"\"\"\n    if not isinstance(other, self.__class__):\n        return False\n    \n    # If both joins have filtered_relations, compare full identity\n    # to distinguish between different filtering conditions\n    if self.filtered_relation is not None and other.filtered_relation is not None:\n        return self.identity == other.identity\n    \n    # For regular joins or mixed scenarios, ignore filtered_relation\n    # to maintain backward compatibility\n    return self.identity[:-1] == other.identity[:-1]\n",
      "\ndef equals(self, other):\n    # Include filtered_relation in equality check when both joins have them\n    if self.filtered_relation is not None and other.filtered_relation is not None:\n        return self.identity == other.identity\n    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n    return self.identity[:-1] == other.identity[:-1]\n"
    ],
    "Location 5 (/root/hy/projects/django/django/db/models/sql/query.py lines 1572-1601)": [
      "\ndef equals(self, other):\n    \"\"\"\n    Return True if this join is equivalent to other.\n    \n    When comparing joins with filtered relations, include the filtered_relation\n    in the comparison to ensure joins with different conditions are not reused.\n    \"\"\"\n    if not isinstance(other, self.__class__):\n        return False\n    \n    # If both joins have filtered relations, compare the full identity including filtered_relation\n    if self.filtered_relation is not None and other.filtered_relation is not None:\n        return self.identity == other.identity\n    \n    # For regular joins or mixed cases, exclude filtered_relation from comparison\n    return self.identity[:-1] == other.identity[:-1]\n",
      "\ndef equals(self, other):\n    # Include filtered_relation in equality check when both joins have them\n    if self.filtered_relation is not None and other.filtered_relation is not None:\n        return self.identity == other.identity\n    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n    return self.identity[:-1] == other.identity[:-1]\n",
      "\ndef equals(self, other):\n    # Include filtered_relation in equality check when both joins have them\n    if self.filtered_relation is not None and other.filtered_relation is not None:\n        return self.identity == other.identity\n    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n    return self.identity[:-1] == other.identity[:-1]\n",
      "\ndef equals(self, other):\n    # Include filtered_relation in equality check when both joins have them\n    if self.filtered_relation is not None and other.filtered_relation is not None:\n        return self.identity == other.identity\n    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n    return self.identity[:-1] == other.identity[:-1]\n",
      "\ndef equals(self, other):\n    # Include filtered_relation in equality check when both joins have them\n    if self.filtered_relation is not None and other.filtered_relation is not None:\n        return self.identity == other.identity\n    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n    return self.identity[:-1] == other.identity[:-1]\n",
      "\ndef equals(self, other):\n    # Include filtered_relation in equality check when both joins have them\n    if self.filtered_relation is not None and other.filtered_relation is not None:\n        return self.identity == other.identity\n    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n    return self.identity[:-1] == other.identity[:-1]\n",
      "\ndef equals(self, other):\n    # Include filtered_relation in equality check when both joins have them\n    if self.filtered_relation is not None and other.filtered_relation is not None:\n        return self.identity == other.identity\n    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n    return self.identity[:-1] == other.identity[:-1]\n",
      "\ndef equals(self, other):\n    # Include filtered_relation in equality check when both joins have them\n    if self.filtered_relation is not None and other.filtered_relation is not None:\n        return self.identity == other.identity\n    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n    return self.identity[:-1] == other.identity[:-1]\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 54f3258eac..1257de2eff 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1024,11 +1024,20 @@ class Query(BaseExpression):\n         sure chains like t1 LOUTER t2 INNER t3 aren't generated. All new\n         joins are created as LOUTER if the join is nullable.\n         \"\"\"\n+\n         reuse_aliases = [\n             a\n             for a, j in self.alias_map.items()\n-            if (reuse is None or a in reuse) and j.equals(join)\n+            if (reuse is None or a in reuse) and j.equals(join) and (\n+                # For FilteredRelations, also check that the conditions are the same\n+                join.filtered_relation is None or \n+                j.filtered_relation is None or\n+                (join.filtered_relation is not None and \n+                 j.filtered_relation is not None and\n+                 join.filtered_relation.condition == j.filtered_relation.condition)\n+            )\n         ]\n+\n         if reuse_aliases:\n             if join.table_alias in reuse_aliases:\n                 reuse_alias = join.table_alias\n@@ -1039,6 +1048,7 @@ class Query(BaseExpression):\n             self.ref_alias(reuse_alias)\n             return reuse_alias\n \n+\n         # No reuse is possible, so we need a new alias.\n         alias, _ = self.table_alias(\n             join.table_name, create=True, filtered_relation=join.filtered_relation\n@@ -1569,6 +1579,7 @@ class Query(BaseExpression):\n             target_clause.add(child_clause, connector)\n         return target_clause\n \n+\n     def add_filtered_relation(self, filtered_relation, alias):\n         filtered_relation.alias = alias\n         lookups = dict(get_children_from_q(filtered_relation.condition))\n@@ -1797,6 +1808,7 @@ class Query(BaseExpression):\n         # Then, add the path to the query's joins. Note that we can't trim\n         # joins at this stage - we will need the information about join type\n         # of the trimmed joins.\n+\n         for join in path:\n             if join.filtered_relation:\n                 filtered_relation = join.filtered_relation.clone()\n",
    "variant_0": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 54f3258eac..1e81c997f2 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1024,34 +1024,33 @@ class Query(BaseExpression):\n         sure chains like t1 LOUTER t2 INNER t3 aren't generated. All new\n         joins are created as LOUTER if the join is nullable.\n         \"\"\"\n-        reuse_aliases = [\n-            a\n-            for a, j in self.alias_map.items()\n-            if (reuse is None or a in reuse) and j.equals(join)\n-        ]\n-        if reuse_aliases:\n-            if join.table_alias in reuse_aliases:\n-                reuse_alias = join.table_alias\n-            else:\n-                # Reuse the most recent alias of the joined table\n-                # (a many-to-many relation may be joined multiple times).\n-                reuse_alias = reuse_aliases[-1]\n-            self.ref_alias(reuse_alias)\n-            return reuse_alias\n-\n-        # No reuse is possible, so we need a new alias.\n-        alias, _ = self.table_alias(\n-            join.table_name, create=True, filtered_relation=join.filtered_relation\n-        )\n-        if join.join_type:\n-            if self.alias_map[join.parent_alias].join_type == LOUTER or join.nullable:\n-                join_type = LOUTER\n-            else:\n-                join_type = INNER\n-            join.join_type = join_type\n-        join.table_alias = alias\n-        self.alias_map[alias] = join\n-        return alias\n+\n+        # Consider filtered_relation in join reuse only when both joins have them\n+        reuse_aliases = []\n+        for a, j in self.alias_map.items():\n+            if reuse is None or a in reuse:\n+                # For joins with filtered_relations, require exact match including the filtered_relation\n+                if join.filtered_relation is not None and j.filtered_relation is not None:\n+                    if j.identity == join.identity:\n+                        reuse_aliases.append(a)\n+                # For regular joins or mixed cases, use the original logic\n+                elif j.equals(join):\n+                    reuse_aliases.append(a)\n+\n+def equals(self, other):\n+    # Include filtered_relation in equality check when both joins have them\n+    if self.filtered_relation is not None and other.filtered_relation is not None:\n+        return self.identity == other.identity\n+    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n+    return self.identity[:-1] == other.identity[:-1]\n+\n+\n+def equals(self, other):\n+    # Include filtered_relation in equality check when both joins have them\n+    if self.filtered_relation is not None and other.filtered_relation is not None:\n+        return self.identity == other.identity\n+    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n+    return self.identity[:-1] == other.identity[:-1]\n \n     def join_parent_model(self, opts, model, alias, seen):\n         \"\"\"\n@@ -1569,36 +1568,13 @@ class Query(BaseExpression):\n             target_clause.add(child_clause, connector)\n         return target_clause\n \n-    def add_filtered_relation(self, filtered_relation, alias):\n-        filtered_relation.alias = alias\n-        lookups = dict(get_children_from_q(filtered_relation.condition))\n-        relation_lookup_parts, relation_field_parts, _ = self.solve_lookup_type(\n-            filtered_relation.relation_name\n-        )\n-        if relation_lookup_parts:\n-            raise ValueError(\n-                \"FilteredRelation's relation_name cannot contain lookups \"\n-                \"(got %r).\" % filtered_relation.relation_name\n-            )\n-        for lookup in chain(lookups):\n-            lookup_parts, lookup_field_parts, _ = self.solve_lookup_type(lookup)\n-            shift = 2 if not lookup_parts else 1\n-            lookup_field_path = lookup_field_parts[:-shift]\n-            for idx, lookup_field_part in enumerate(lookup_field_path):\n-                if len(relation_field_parts) > idx:\n-                    if relation_field_parts[idx] != lookup_field_part:\n-                        raise ValueError(\n-                            \"FilteredRelation's condition doesn't support \"\n-                            \"relations outside the %r (got %r).\"\n-                            % (filtered_relation.relation_name, lookup)\n-                        )\n-                else:\n-                    raise ValueError(\n-                        \"FilteredRelation's condition doesn't support nested \"\n-                        \"relations deeper than the relation_name (got %r for \"\n-                        \"%r).\" % (lookup, filtered_relation.relation_name)\n-                    )\n-        self._filtered_relations[filtered_relation.alias] = filtered_relation\n+\n+def equals(self, other):\n+    # Include filtered_relation in equality check when both joins have them\n+    if self.filtered_relation is not None and other.filtered_relation is not None:\n+        return self.identity == other.identity\n+    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n+    return self.identity[:-1] == other.identity[:-1]\n \n     def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n         \"\"\"\n@@ -1797,33 +1773,13 @@ class Query(BaseExpression):\n         # Then, add the path to the query's joins. Note that we can't trim\n         # joins at this stage - we will need the information about join type\n         # of the trimmed joins.\n-        for join in path:\n-            if join.filtered_relation:\n-                filtered_relation = join.filtered_relation.clone()\n-                table_alias = filtered_relation.alias\n-            else:\n-                filtered_relation = None\n-                table_alias = None\n-            opts = join.to_opts\n-            if join.direct:\n-                nullable = self.is_nullable(join.join_field)\n-            else:\n-                nullable = True\n-            connection = self.join_class(\n-                opts.db_table,\n-                alias,\n-                table_alias,\n-                INNER,\n-                join.join_field,\n-                nullable,\n-                filtered_relation=filtered_relation,\n-            )\n-            reuse = can_reuse if join.m2m else None\n-            alias = self.join(connection, reuse=reuse)\n-            joins.append(alias)\n-            if filtered_relation:\n-                filtered_relation.path = joins[:]\n-        return JoinInfo(final_field, targets, opts, joins, path, final_transformer)\n+\n+def equals(self, other):\n+    # Include filtered_relation in equality check when both joins have them\n+    if self.filtered_relation is not None and other.filtered_relation is not None:\n+        return self.identity == other.identity\n+    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n+    return self.identity[:-1] == other.identity[:-1]\n \n     def trim_joins(self, targets, joins, path):\n         \"\"\"\n",
    "variant_1": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 54f3258eac..b45d76a9a7 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1024,34 +1024,32 @@ class Query(BaseExpression):\n         sure chains like t1 LOUTER t2 INNER t3 aren't generated. All new\n         joins are created as LOUTER if the join is nullable.\n         \"\"\"\n-        reuse_aliases = [\n-            a\n-            for a, j in self.alias_map.items()\n-            if (reuse is None or a in reuse) and j.equals(join)\n-        ]\n-        if reuse_aliases:\n-            if join.table_alias in reuse_aliases:\n-                reuse_alias = join.table_alias\n-            else:\n-                # Reuse the most recent alias of the joined table\n-                # (a many-to-many relation may be joined multiple times).\n-                reuse_alias = reuse_aliases[-1]\n-            self.ref_alias(reuse_alias)\n-            return reuse_alias\n-\n-        # No reuse is possible, so we need a new alias.\n-        alias, _ = self.table_alias(\n-            join.table_name, create=True, filtered_relation=join.filtered_relation\n-        )\n-        if join.join_type:\n-            if self.alias_map[join.parent_alias].join_type == LOUTER or join.nullable:\n-                join_type = LOUTER\n-            else:\n-                join_type = INNER\n-            join.join_type = join_type\n-        join.table_alias = alias\n-        self.alias_map[alias] = join\n-        return alias\n+\n+reuse_aliases = [\n+    a\n+    for a, j in self.alias_map.items()\n+    if (reuse is None or a in reuse) and j.equals(join) and (\n+        # For joins with filtered_relation, ensure they have the same conditions\n+        j.filtered_relation == join.filtered_relation or\n+        # For regular joins without filtered_relation, allow reuse\n+        (j.filtered_relation is None and join.filtered_relation is None)\n+    )\n+]\n+\n+def equals(self, other):\n+    # Include filtered_relation in equality check when both joins have filtered_relations\n+    if self.filtered_relation is not None and other.filtered_relation is not None:\n+        return self.identity == other.identity\n+    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n+    return self.identity[:-1] == other.identity[:-1]\n+\n+\n+    def equals(self, other):\n+        # Include filtered_relation in equality check when both joins have them\n+        if self.filtered_relation is not None and other.filtered_relation is not None:\n+            return self.identity == other.identity\n+        # For regular joins or when only one has filtered_relation, ignore filtered_relation\n+        return self.identity[:-1] == other.identity[:-1]\n \n     def join_parent_model(self, opts, model, alias, seen):\n         \"\"\"\n@@ -1569,36 +1567,23 @@ class Query(BaseExpression):\n             target_clause.add(child_clause, connector)\n         return target_clause\n \n-    def add_filtered_relation(self, filtered_relation, alias):\n-        filtered_relation.alias = alias\n-        lookups = dict(get_children_from_q(filtered_relation.condition))\n-        relation_lookup_parts, relation_field_parts, _ = self.solve_lookup_type(\n-            filtered_relation.relation_name\n-        )\n-        if relation_lookup_parts:\n-            raise ValueError(\n-                \"FilteredRelation's relation_name cannot contain lookups \"\n-                \"(got %r).\" % filtered_relation.relation_name\n-            )\n-        for lookup in chain(lookups):\n-            lookup_parts, lookup_field_parts, _ = self.solve_lookup_type(lookup)\n-            shift = 2 if not lookup_parts else 1\n-            lookup_field_path = lookup_field_parts[:-shift]\n-            for idx, lookup_field_part in enumerate(lookup_field_path):\n-                if len(relation_field_parts) > idx:\n-                    if relation_field_parts[idx] != lookup_field_part:\n-                        raise ValueError(\n-                            \"FilteredRelation's condition doesn't support \"\n-                            \"relations outside the %r (got %r).\"\n-                            % (filtered_relation.relation_name, lookup)\n-                        )\n-                else:\n-                    raise ValueError(\n-                        \"FilteredRelation's condition doesn't support nested \"\n-                        \"relations deeper than the relation_name (got %r for \"\n-                        \"%r).\" % (lookup, filtered_relation.relation_name)\n-                    )\n-        self._filtered_relations[filtered_relation.alias] = filtered_relation\n+\n+def equals(self, other):\n+    \"\"\"\n+    Return True if this join is equivalent to other.\n+    \n+    When comparing joins with filtered relations, include the filtered_relation\n+    in the comparison to ensure joins with different conditions are not reused.\n+    \"\"\"\n+    if not isinstance(other, self.__class__):\n+        return False\n+    \n+    # If both joins have filtered relations, compare the full identity including filtered_relation\n+    if self.filtered_relation is not None and other.filtered_relation is not None:\n+        return self.identity == other.identity\n+    \n+    # For regular joins or mixed cases, exclude filtered_relation from comparison\n+    return self.identity[:-1] == other.identity[:-1]\n \n     def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n         \"\"\"\n@@ -1797,33 +1782,13 @@ class Query(BaseExpression):\n         # Then, add the path to the query's joins. Note that we can't trim\n         # joins at this stage - we will need the information about join type\n         # of the trimmed joins.\n-        for join in path:\n-            if join.filtered_relation:\n-                filtered_relation = join.filtered_relation.clone()\n-                table_alias = filtered_relation.alias\n-            else:\n-                filtered_relation = None\n-                table_alias = None\n-            opts = join.to_opts\n-            if join.direct:\n-                nullable = self.is_nullable(join.join_field)\n-            else:\n-                nullable = True\n-            connection = self.join_class(\n-                opts.db_table,\n-                alias,\n-                table_alias,\n-                INNER,\n-                join.join_field,\n-                nullable,\n-                filtered_relation=filtered_relation,\n-            )\n-            reuse = can_reuse if join.m2m else None\n-            alias = self.join(connection, reuse=reuse)\n-            joins.append(alias)\n-            if filtered_relation:\n-                filtered_relation.path = joins[:]\n-        return JoinInfo(final_field, targets, opts, joins, path, final_transformer)\n+\n+    def equals(self, other):\n+        # Include filtered_relation in equality check when both joins have them\n+        if self.filtered_relation is not None and other.filtered_relation is not None:\n+            return self.identity == other.identity\n+        # For regular joins or when only one has filtered_relation, ignore filtered_relation\n+        return self.identity[:-1] == other.identity[:-1]\n \n     def trim_joins(self, targets, joins, path):\n         \"\"\"\n",
    "variant_2": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 54f3258eac..5aee3b5337 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1024,34 +1024,43 @@ class Query(BaseExpression):\n         sure chains like t1 LOUTER t2 INNER t3 aren't generated. All new\n         joins are created as LOUTER if the join is nullable.\n         \"\"\"\n+\n+        # Only reuse joins that have identical FilteredRelation conditions\n         reuse_aliases = [\n             a\n             for a, j in self.alias_map.items()\n-            if (reuse is None or a in reuse) and j.equals(join)\n+            if (reuse is None or a in reuse) and j.equals(join) and (\n+                (j.filtered_relation is None and join.filtered_relation is None) or\n+                (j.filtered_relation is not None and join.filtered_relation is not None and\n+                 j.filtered_relation.condition == join.filtered_relation.condition)\n+            )\n         ]\n-        if reuse_aliases:\n-            if join.table_alias in reuse_aliases:\n-                reuse_alias = join.table_alias\n-            else:\n-                # Reuse the most recent alias of the joined table\n-                # (a many-to-many relation may be joined multiple times).\n-                reuse_alias = reuse_aliases[-1]\n-            self.ref_alias(reuse_alias)\n-            return reuse_alias\n-\n-        # No reuse is possible, so we need a new alias.\n-        alias, _ = self.table_alias(\n-            join.table_name, create=True, filtered_relation=join.filtered_relation\n-        )\n-        if join.join_type:\n-            if self.alias_map[join.parent_alias].join_type == LOUTER or join.nullable:\n-                join_type = LOUTER\n-            else:\n-                join_type = INNER\n-            join.join_type = join_type\n-        join.table_alias = alias\n-        self.alias_map[alias] = join\n-        return alias\n+\n+def equals(self, other):\n+    # Include filtered_relation in equality check when both joins have them\n+    if self.filtered_relation is not None and other.filtered_relation is not None:\n+        return self.identity == other.identity\n+    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n+    return self.identity[:-1] == other.identity[:-1]\n+\n+\n+def equals(self, other):\n+    \"\"\"\n+    Return True if this join is equivalent to other.\n+    \n+    For joins with filtered_relation, both the relation path and the\n+    filtered_relation condition must match for the joins to be considered equal.\n+    \"\"\"\n+    if not isinstance(other, self.__class__):\n+        return False\n+    \n+    # If both joins have filtered_relation, include it in the comparison\n+    if self.filtered_relation is not None and other.filtered_relation is not None:\n+        return self.identity == other.identity\n+    \n+    # If neither has filtered_relation or only one has it, compare without filtered_relation\n+    # This maintains backward compatibility for regular joins\n+    return self.identity[:-1] == other.identity[:-1]\n \n     def join_parent_model(self, opts, model, alias, seen):\n         \"\"\"\n@@ -1569,36 +1578,13 @@ class Query(BaseExpression):\n             target_clause.add(child_clause, connector)\n         return target_clause\n \n-    def add_filtered_relation(self, filtered_relation, alias):\n-        filtered_relation.alias = alias\n-        lookups = dict(get_children_from_q(filtered_relation.condition))\n-        relation_lookup_parts, relation_field_parts, _ = self.solve_lookup_type(\n-            filtered_relation.relation_name\n-        )\n-        if relation_lookup_parts:\n-            raise ValueError(\n-                \"FilteredRelation's relation_name cannot contain lookups \"\n-                \"(got %r).\" % filtered_relation.relation_name\n-            )\n-        for lookup in chain(lookups):\n-            lookup_parts, lookup_field_parts, _ = self.solve_lookup_type(lookup)\n-            shift = 2 if not lookup_parts else 1\n-            lookup_field_path = lookup_field_parts[:-shift]\n-            for idx, lookup_field_part in enumerate(lookup_field_path):\n-                if len(relation_field_parts) > idx:\n-                    if relation_field_parts[idx] != lookup_field_part:\n-                        raise ValueError(\n-                            \"FilteredRelation's condition doesn't support \"\n-                            \"relations outside the %r (got %r).\"\n-                            % (filtered_relation.relation_name, lookup)\n-                        )\n-                else:\n-                    raise ValueError(\n-                        \"FilteredRelation's condition doesn't support nested \"\n-                        \"relations deeper than the relation_name (got %r for \"\n-                        \"%r).\" % (lookup, filtered_relation.relation_name)\n-                    )\n-        self._filtered_relations[filtered_relation.alias] = filtered_relation\n+\n+def equals(self, other):\n+    # Include filtered_relation in equality check when both joins have them\n+    if self.filtered_relation is not None and other.filtered_relation is not None:\n+        return self.identity == other.identity\n+    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n+    return self.identity[:-1] == other.identity[:-1]\n \n     def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n         \"\"\"\n@@ -1797,33 +1783,13 @@ class Query(BaseExpression):\n         # Then, add the path to the query's joins. Note that we can't trim\n         # joins at this stage - we will need the information about join type\n         # of the trimmed joins.\n-        for join in path:\n-            if join.filtered_relation:\n-                filtered_relation = join.filtered_relation.clone()\n-                table_alias = filtered_relation.alias\n-            else:\n-                filtered_relation = None\n-                table_alias = None\n-            opts = join.to_opts\n-            if join.direct:\n-                nullable = self.is_nullable(join.join_field)\n-            else:\n-                nullable = True\n-            connection = self.join_class(\n-                opts.db_table,\n-                alias,\n-                table_alias,\n-                INNER,\n-                join.join_field,\n-                nullable,\n-                filtered_relation=filtered_relation,\n-            )\n-            reuse = can_reuse if join.m2m else None\n-            alias = self.join(connection, reuse=reuse)\n-            joins.append(alias)\n-            if filtered_relation:\n-                filtered_relation.path = joins[:]\n-        return JoinInfo(final_field, targets, opts, joins, path, final_transformer)\n+\n+def equals(self, other):\n+    # Include filtered_relation in equality check when both joins have them\n+    if self.filtered_relation is not None and other.filtered_relation is not None:\n+        return self.identity == other.identity\n+    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n+    return self.identity[:-1] == other.identity[:-1]\n \n     def trim_joins(self, targets, joins, path):\n         \"\"\"\n",
    "variant_3": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 54f3258eac..17e0dcb2fb 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1024,34 +1024,36 @@ class Query(BaseExpression):\n         sure chains like t1 LOUTER t2 INNER t3 aren't generated. All new\n         joins are created as LOUTER if the join is nullable.\n         \"\"\"\n+\n         reuse_aliases = [\n             a\n             for a, j in self.alias_map.items()\n-            if (reuse is None or a in reuse) and j.equals(join)\n+            if (reuse is None or a in reuse) and j.equals(join) and (\n+                # Don't reuse if filtered_relations differ\n+                j.filtered_relation == join.filtered_relation or\n+                (j.filtered_relation is None and join.filtered_relation is None)\n+            )\n         ]\n-        if reuse_aliases:\n-            if join.table_alias in reuse_aliases:\n-                reuse_alias = join.table_alias\n-            else:\n-                # Reuse the most recent alias of the joined table\n-                # (a many-to-many relation may be joined multiple times).\n-                reuse_alias = reuse_aliases[-1]\n-            self.ref_alias(reuse_alias)\n-            return reuse_alias\n-\n-        # No reuse is possible, so we need a new alias.\n-        alias, _ = self.table_alias(\n-            join.table_name, create=True, filtered_relation=join.filtered_relation\n-        )\n-        if join.join_type:\n-            if self.alias_map[join.parent_alias].join_type == LOUTER or join.nullable:\n-                join_type = LOUTER\n-            else:\n-                join_type = INNER\n-            join.join_type = join_type\n-        join.table_alias = alias\n-        self.alias_map[alias] = join\n-        return alias\n+\n+def equals(self, other):\n+    \"\"\"\n+    Return True if this join is equivalent to other.\n+    \"\"\"\n+    if not isinstance(other, self.__class__):\n+        return False\n+    # Include filtered_relation in equality check when both joins have them\n+    if self.filtered_relation is not None and other.filtered_relation is not None:\n+        return self.identity == other.identity\n+    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n+    return self.identity[:-1] == other.identity[:-1]\n+\n+\n+def equals(self, other):\n+    # Include filtered_relation in equality check when both joins have them\n+    if self.filtered_relation is not None and other.filtered_relation is not None:\n+        return self.identity == other.identity\n+    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n+    return self.identity[:-1] == other.identity[:-1]\n \n     def join_parent_model(self, opts, model, alias, seen):\n         \"\"\"\n@@ -1569,36 +1571,13 @@ class Query(BaseExpression):\n             target_clause.add(child_clause, connector)\n         return target_clause\n \n-    def add_filtered_relation(self, filtered_relation, alias):\n-        filtered_relation.alias = alias\n-        lookups = dict(get_children_from_q(filtered_relation.condition))\n-        relation_lookup_parts, relation_field_parts, _ = self.solve_lookup_type(\n-            filtered_relation.relation_name\n-        )\n-        if relation_lookup_parts:\n-            raise ValueError(\n-                \"FilteredRelation's relation_name cannot contain lookups \"\n-                \"(got %r).\" % filtered_relation.relation_name\n-            )\n-        for lookup in chain(lookups):\n-            lookup_parts, lookup_field_parts, _ = self.solve_lookup_type(lookup)\n-            shift = 2 if not lookup_parts else 1\n-            lookup_field_path = lookup_field_parts[:-shift]\n-            for idx, lookup_field_part in enumerate(lookup_field_path):\n-                if len(relation_field_parts) > idx:\n-                    if relation_field_parts[idx] != lookup_field_part:\n-                        raise ValueError(\n-                            \"FilteredRelation's condition doesn't support \"\n-                            \"relations outside the %r (got %r).\"\n-                            % (filtered_relation.relation_name, lookup)\n-                        )\n-                else:\n-                    raise ValueError(\n-                        \"FilteredRelation's condition doesn't support nested \"\n-                        \"relations deeper than the relation_name (got %r for \"\n-                        \"%r).\" % (lookup, filtered_relation.relation_name)\n-                    )\n-        self._filtered_relations[filtered_relation.alias] = filtered_relation\n+\n+def equals(self, other):\n+    # Include filtered_relation in equality check when both joins have them\n+    if self.filtered_relation is not None and other.filtered_relation is not None:\n+        return self.identity == other.identity\n+    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n+    return self.identity[:-1] == other.identity[:-1]\n \n     def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n         \"\"\"\n@@ -1797,33 +1776,13 @@ class Query(BaseExpression):\n         # Then, add the path to the query's joins. Note that we can't trim\n         # joins at this stage - we will need the information about join type\n         # of the trimmed joins.\n-        for join in path:\n-            if join.filtered_relation:\n-                filtered_relation = join.filtered_relation.clone()\n-                table_alias = filtered_relation.alias\n-            else:\n-                filtered_relation = None\n-                table_alias = None\n-            opts = join.to_opts\n-            if join.direct:\n-                nullable = self.is_nullable(join.join_field)\n-            else:\n-                nullable = True\n-            connection = self.join_class(\n-                opts.db_table,\n-                alias,\n-                table_alias,\n-                INNER,\n-                join.join_field,\n-                nullable,\n-                filtered_relation=filtered_relation,\n-            )\n-            reuse = can_reuse if join.m2m else None\n-            alias = self.join(connection, reuse=reuse)\n-            joins.append(alias)\n-            if filtered_relation:\n-                filtered_relation.path = joins[:]\n-        return JoinInfo(final_field, targets, opts, joins, path, final_transformer)\n+\n+def equals(self, other):\n+    # Include filtered_relation in equality check when both joins have them\n+    if self.filtered_relation is not None and other.filtered_relation is not None:\n+        return self.identity == other.identity\n+    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n+    return self.identity[:-1] == other.identity[:-1]\n \n     def trim_joins(self, targets, joins, path):\n         \"\"\"\n",
    "variant_4": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 54f3258eac..507d793bc6 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1024,34 +1024,29 @@ class Query(BaseExpression):\n         sure chains like t1 LOUTER t2 INNER t3 aren't generated. All new\n         joins are created as LOUTER if the join is nullable.\n         \"\"\"\n-        reuse_aliases = [\n-            a\n-            for a, j in self.alias_map.items()\n-            if (reuse is None or a in reuse) and j.equals(join)\n-        ]\n-        if reuse_aliases:\n-            if join.table_alias in reuse_aliases:\n-                reuse_alias = join.table_alias\n-            else:\n-                # Reuse the most recent alias of the joined table\n-                # (a many-to-many relation may be joined multiple times).\n-                reuse_alias = reuse_aliases[-1]\n-            self.ref_alias(reuse_alias)\n-            return reuse_alias\n-\n-        # No reuse is possible, so we need a new alias.\n-        alias, _ = self.table_alias(\n-            join.table_name, create=True, filtered_relation=join.filtered_relation\n-        )\n-        if join.join_type:\n-            if self.alias_map[join.parent_alias].join_type == LOUTER or join.nullable:\n-                join_type = LOUTER\n-            else:\n-                join_type = INNER\n-            join.join_type = join_type\n-        join.table_alias = alias\n-        self.alias_map[alias] = join\n-        return alias\n+\n+def equals(self, other):\n+    # Include filtered_relation in equality check when both joins have filtered relations\n+    if (self.filtered_relation is not None and \n+        other.filtered_relation is not None):\n+        return self.identity == other.identity\n+    # For regular joins or mixed scenarios, ignore filtered_relation in comparison\n+    return self.identity[:-1] == other.identity[:-1]\n+\n+def equals(self, other):\n+    # Include filtered_relation in equality check when both joins have them\n+    if self.filtered_relation is not None and other.filtered_relation is not None:\n+        return self.identity == other.identity\n+    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n+    return self.identity[:-1] == other.identity[:-1]\n+\n+\n+def equals(self, other):\n+    # Include filtered_relation in equality check when both joins have them\n+    if self.filtered_relation is not None and other.filtered_relation is not None:\n+        return self.identity == other.identity\n+    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n+    return self.identity[:-1] == other.identity[:-1]\n \n     def join_parent_model(self, opts, model, alias, seen):\n         \"\"\"\n@@ -1569,36 +1564,13 @@ class Query(BaseExpression):\n             target_clause.add(child_clause, connector)\n         return target_clause\n \n-    def add_filtered_relation(self, filtered_relation, alias):\n-        filtered_relation.alias = alias\n-        lookups = dict(get_children_from_q(filtered_relation.condition))\n-        relation_lookup_parts, relation_field_parts, _ = self.solve_lookup_type(\n-            filtered_relation.relation_name\n-        )\n-        if relation_lookup_parts:\n-            raise ValueError(\n-                \"FilteredRelation's relation_name cannot contain lookups \"\n-                \"(got %r).\" % filtered_relation.relation_name\n-            )\n-        for lookup in chain(lookups):\n-            lookup_parts, lookup_field_parts, _ = self.solve_lookup_type(lookup)\n-            shift = 2 if not lookup_parts else 1\n-            lookup_field_path = lookup_field_parts[:-shift]\n-            for idx, lookup_field_part in enumerate(lookup_field_path):\n-                if len(relation_field_parts) > idx:\n-                    if relation_field_parts[idx] != lookup_field_part:\n-                        raise ValueError(\n-                            \"FilteredRelation's condition doesn't support \"\n-                            \"relations outside the %r (got %r).\"\n-                            % (filtered_relation.relation_name, lookup)\n-                        )\n-                else:\n-                    raise ValueError(\n-                        \"FilteredRelation's condition doesn't support nested \"\n-                        \"relations deeper than the relation_name (got %r for \"\n-                        \"%r).\" % (lookup, filtered_relation.relation_name)\n-                    )\n-        self._filtered_relations[filtered_relation.alias] = filtered_relation\n+\n+def equals(self, other):\n+    # Include filtered_relation in equality check when both joins have them\n+    if self.filtered_relation is not None and other.filtered_relation is not None:\n+        return self.identity == other.identity\n+    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n+    return self.identity[:-1] == other.identity[:-1]\n \n     def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n         \"\"\"\n@@ -1797,33 +1769,13 @@ class Query(BaseExpression):\n         # Then, add the path to the query's joins. Note that we can't trim\n         # joins at this stage - we will need the information about join type\n         # of the trimmed joins.\n-        for join in path:\n-            if join.filtered_relation:\n-                filtered_relation = join.filtered_relation.clone()\n-                table_alias = filtered_relation.alias\n-            else:\n-                filtered_relation = None\n-                table_alias = None\n-            opts = join.to_opts\n-            if join.direct:\n-                nullable = self.is_nullable(join.join_field)\n-            else:\n-                nullable = True\n-            connection = self.join_class(\n-                opts.db_table,\n-                alias,\n-                table_alias,\n-                INNER,\n-                join.join_field,\n-                nullable,\n-                filtered_relation=filtered_relation,\n-            )\n-            reuse = can_reuse if join.m2m else None\n-            alias = self.join(connection, reuse=reuse)\n-            joins.append(alias)\n-            if filtered_relation:\n-                filtered_relation.path = joins[:]\n-        return JoinInfo(final_field, targets, opts, joins, path, final_transformer)\n+\n+def equals(self, other):\n+    # Include filtered_relation in equality check when both joins have them\n+    if self.filtered_relation is not None and other.filtered_relation is not None:\n+        return self.identity == other.identity\n+    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n+    return self.identity[:-1] == other.identity[:-1]\n \n     def trim_joins(self, targets, joins, path):\n         \"\"\"\n",
    "variant_5": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 54f3258eac..de9b2937da 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1024,34 +1024,27 @@ class Query(BaseExpression):\n         sure chains like t1 LOUTER t2 INNER t3 aren't generated. All new\n         joins are created as LOUTER if the join is nullable.\n         \"\"\"\n+\n         reuse_aliases = [\n             a\n             for a, j in self.alias_map.items()\n             if (reuse is None or a in reuse) and j.equals(join)\n         ]\n-        if reuse_aliases:\n-            if join.table_alias in reuse_aliases:\n-                reuse_alias = join.table_alias\n-            else:\n-                # Reuse the most recent alias of the joined table\n-                # (a many-to-many relation may be joined multiple times).\n-                reuse_alias = reuse_aliases[-1]\n-            self.ref_alias(reuse_alias)\n-            return reuse_alias\n-\n-        # No reuse is possible, so we need a new alias.\n-        alias, _ = self.table_alias(\n-            join.table_name, create=True, filtered_relation=join.filtered_relation\n-        )\n-        if join.join_type:\n-            if self.alias_map[join.parent_alias].join_type == LOUTER or join.nullable:\n-                join_type = LOUTER\n-            else:\n-                join_type = INNER\n-            join.join_type = join_type\n-        join.table_alias = alias\n-        self.alias_map[alias] = join\n-        return alias\n+\n+def equals(self, other):\n+    # Include filtered_relation in equality check when both joins have them\n+    if self.filtered_relation is not None and other.filtered_relation is not None:\n+        return self.identity == other.identity\n+    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n+    return self.identity[:-1] == other.identity[:-1]\n+\n+\n+def equals(self, other):\n+    # Include filtered_relation in equality check when both joins have them\n+    if self.filtered_relation is not None and other.filtered_relation is not None:\n+        return self.identity == other.identity\n+    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n+    return self.identity[:-1] == other.identity[:-1]\n \n     def join_parent_model(self, opts, model, alias, seen):\n         \"\"\"\n@@ -1569,36 +1562,13 @@ class Query(BaseExpression):\n             target_clause.add(child_clause, connector)\n         return target_clause\n \n-    def add_filtered_relation(self, filtered_relation, alias):\n-        filtered_relation.alias = alias\n-        lookups = dict(get_children_from_q(filtered_relation.condition))\n-        relation_lookup_parts, relation_field_parts, _ = self.solve_lookup_type(\n-            filtered_relation.relation_name\n-        )\n-        if relation_lookup_parts:\n-            raise ValueError(\n-                \"FilteredRelation's relation_name cannot contain lookups \"\n-                \"(got %r).\" % filtered_relation.relation_name\n-            )\n-        for lookup in chain(lookups):\n-            lookup_parts, lookup_field_parts, _ = self.solve_lookup_type(lookup)\n-            shift = 2 if not lookup_parts else 1\n-            lookup_field_path = lookup_field_parts[:-shift]\n-            for idx, lookup_field_part in enumerate(lookup_field_path):\n-                if len(relation_field_parts) > idx:\n-                    if relation_field_parts[idx] != lookup_field_part:\n-                        raise ValueError(\n-                            \"FilteredRelation's condition doesn't support \"\n-                            \"relations outside the %r (got %r).\"\n-                            % (filtered_relation.relation_name, lookup)\n-                        )\n-                else:\n-                    raise ValueError(\n-                        \"FilteredRelation's condition doesn't support nested \"\n-                        \"relations deeper than the relation_name (got %r for \"\n-                        \"%r).\" % (lookup, filtered_relation.relation_name)\n-                    )\n-        self._filtered_relations[filtered_relation.alias] = filtered_relation\n+\n+def equals(self, other):\n+    # Include filtered_relation in equality check when both joins have them\n+    if self.filtered_relation is not None and other.filtered_relation is not None:\n+        return self.identity == other.identity\n+    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n+    return self.identity[:-1] == other.identity[:-1]\n \n     def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n         \"\"\"\n@@ -1797,33 +1767,13 @@ class Query(BaseExpression):\n         # Then, add the path to the query's joins. Note that we can't trim\n         # joins at this stage - we will need the information about join type\n         # of the trimmed joins.\n-        for join in path:\n-            if join.filtered_relation:\n-                filtered_relation = join.filtered_relation.clone()\n-                table_alias = filtered_relation.alias\n-            else:\n-                filtered_relation = None\n-                table_alias = None\n-            opts = join.to_opts\n-            if join.direct:\n-                nullable = self.is_nullable(join.join_field)\n-            else:\n-                nullable = True\n-            connection = self.join_class(\n-                opts.db_table,\n-                alias,\n-                table_alias,\n-                INNER,\n-                join.join_field,\n-                nullable,\n-                filtered_relation=filtered_relation,\n-            )\n-            reuse = can_reuse if join.m2m else None\n-            alias = self.join(connection, reuse=reuse)\n-            joins.append(alias)\n-            if filtered_relation:\n-                filtered_relation.path = joins[:]\n-        return JoinInfo(final_field, targets, opts, joins, path, final_transformer)\n+\n+def equals(self, other):\n+    # Include filtered_relation in equality check when both joins have them\n+    if self.filtered_relation is not None and other.filtered_relation is not None:\n+        return self.identity == other.identity\n+    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n+    return self.identity[:-1] == other.identity[:-1]\n \n     def trim_joins(self, targets, joins, path):\n         \"\"\"\n",
    "variant_6": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 54f3258eac..1f5136bfb8 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1024,34 +1024,33 @@ class Query(BaseExpression):\n         sure chains like t1 LOUTER t2 INNER t3 aren't generated. All new\n         joins are created as LOUTER if the join is nullable.\n         \"\"\"\n+\n+        # Only reuse aliases for joins with identical filtered_relation conditions\n         reuse_aliases = [\n             a\n             for a, j in self.alias_map.items()\n-            if (reuse is None or a in reuse) and j.equals(join)\n+            if (reuse is None or a in reuse) and j.equals(join) and (\n+                # Both have same filtered_relation (including None)\n+                j.filtered_relation == join.filtered_relation or\n+                # Both are None\n+                (j.filtered_relation is None and join.filtered_relation is None)\n+            )\n         ]\n-        if reuse_aliases:\n-            if join.table_alias in reuse_aliases:\n-                reuse_alias = join.table_alias\n-            else:\n-                # Reuse the most recent alias of the joined table\n-                # (a many-to-many relation may be joined multiple times).\n-                reuse_alias = reuse_aliases[-1]\n-            self.ref_alias(reuse_alias)\n-            return reuse_alias\n-\n-        # No reuse is possible, so we need a new alias.\n-        alias, _ = self.table_alias(\n-            join.table_name, create=True, filtered_relation=join.filtered_relation\n-        )\n-        if join.join_type:\n-            if self.alias_map[join.parent_alias].join_type == LOUTER or join.nullable:\n-                join_type = LOUTER\n-            else:\n-                join_type = INNER\n-            join.join_type = join_type\n-        join.table_alias = alias\n-        self.alias_map[alias] = join\n-        return alias\n+\n+def equals(self, other):\n+    # Include filtered_relation in equality check when both joins have them\n+    if self.filtered_relation is not None and other.filtered_relation is not None:\n+        return self.identity == other.identity\n+    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n+    return self.identity[:-1] == other.identity[:-1]\n+\n+\n+def equals(self, other):\n+    # Include filtered_relation in equality check when both joins have them\n+    if self.filtered_relation is not None and other.filtered_relation is not None:\n+        return self.identity == other.identity\n+    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n+    return self.identity[:-1] == other.identity[:-1]\n \n     def join_parent_model(self, opts, model, alias, seen):\n         \"\"\"\n@@ -1569,36 +1568,13 @@ class Query(BaseExpression):\n             target_clause.add(child_clause, connector)\n         return target_clause\n \n-    def add_filtered_relation(self, filtered_relation, alias):\n-        filtered_relation.alias = alias\n-        lookups = dict(get_children_from_q(filtered_relation.condition))\n-        relation_lookup_parts, relation_field_parts, _ = self.solve_lookup_type(\n-            filtered_relation.relation_name\n-        )\n-        if relation_lookup_parts:\n-            raise ValueError(\n-                \"FilteredRelation's relation_name cannot contain lookups \"\n-                \"(got %r).\" % filtered_relation.relation_name\n-            )\n-        for lookup in chain(lookups):\n-            lookup_parts, lookup_field_parts, _ = self.solve_lookup_type(lookup)\n-            shift = 2 if not lookup_parts else 1\n-            lookup_field_path = lookup_field_parts[:-shift]\n-            for idx, lookup_field_part in enumerate(lookup_field_path):\n-                if len(relation_field_parts) > idx:\n-                    if relation_field_parts[idx] != lookup_field_part:\n-                        raise ValueError(\n-                            \"FilteredRelation's condition doesn't support \"\n-                            \"relations outside the %r (got %r).\"\n-                            % (filtered_relation.relation_name, lookup)\n-                        )\n-                else:\n-                    raise ValueError(\n-                        \"FilteredRelation's condition doesn't support nested \"\n-                        \"relations deeper than the relation_name (got %r for \"\n-                        \"%r).\" % (lookup, filtered_relation.relation_name)\n-                    )\n-        self._filtered_relations[filtered_relation.alias] = filtered_relation\n+\n+def equals(self, other):\n+    # Include filtered_relation in equality check when both joins have them\n+    if self.filtered_relation is not None and other.filtered_relation is not None:\n+        return self.identity == other.identity\n+    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n+    return self.identity[:-1] == other.identity[:-1]\n \n     def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n         \"\"\"\n@@ -1797,33 +1773,13 @@ class Query(BaseExpression):\n         # Then, add the path to the query's joins. Note that we can't trim\n         # joins at this stage - we will need the information about join type\n         # of the trimmed joins.\n-        for join in path:\n-            if join.filtered_relation:\n-                filtered_relation = join.filtered_relation.clone()\n-                table_alias = filtered_relation.alias\n-            else:\n-                filtered_relation = None\n-                table_alias = None\n-            opts = join.to_opts\n-            if join.direct:\n-                nullable = self.is_nullable(join.join_field)\n-            else:\n-                nullable = True\n-            connection = self.join_class(\n-                opts.db_table,\n-                alias,\n-                table_alias,\n-                INNER,\n-                join.join_field,\n-                nullable,\n-                filtered_relation=filtered_relation,\n-            )\n-            reuse = can_reuse if join.m2m else None\n-            alias = self.join(connection, reuse=reuse)\n-            joins.append(alias)\n-            if filtered_relation:\n-                filtered_relation.path = joins[:]\n-        return JoinInfo(final_field, targets, opts, joins, path, final_transformer)\n+\n+def equals(self, other):\n+    # Include filtered_relation in equality check when both joins have them\n+    if self.filtered_relation is not None and other.filtered_relation is not None:\n+        return self.identity == other.identity\n+    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n+    return self.identity[:-1] == other.identity[:-1]\n \n     def trim_joins(self, targets, joins, path):\n         \"\"\"\n",
    "variant_7": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 54f3258eac..3a06b28bbb 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1024,34 +1024,37 @@ class Query(BaseExpression):\n         sure chains like t1 LOUTER t2 INNER t3 aren't generated. All new\n         joins are created as LOUTER if the join is nullable.\n         \"\"\"\n-        reuse_aliases = [\n-            a\n-            for a, j in self.alias_map.items()\n-            if (reuse is None or a in reuse) and j.equals(join)\n-        ]\n-        if reuse_aliases:\n-            if join.table_alias in reuse_aliases:\n-                reuse_alias = join.table_alias\n-            else:\n-                # Reuse the most recent alias of the joined table\n-                # (a many-to-many relation may be joined multiple times).\n-                reuse_alias = reuse_aliases[-1]\n-            self.ref_alias(reuse_alias)\n-            return reuse_alias\n-\n-        # No reuse is possible, so we need a new alias.\n-        alias, _ = self.table_alias(\n-            join.table_name, create=True, filtered_relation=join.filtered_relation\n-        )\n-        if join.join_type:\n-            if self.alias_map[join.parent_alias].join_type == LOUTER or join.nullable:\n-                join_type = LOUTER\n-            else:\n-                join_type = INNER\n-            join.join_type = join_type\n-        join.table_alias = alias\n-        self.alias_map[alias] = join\n-        return alias\n+\n+        # Include filtered_relation in equality check when both joins have FilteredRelations\n+        if join.filtered_relation is not None:\n+            # For joins with FilteredRelations, require exact match including the condition\n+            reuse_aliases = [\n+                a\n+                for a, j in self.alias_map.items()\n+                if (reuse is None or a in reuse) and j.identity == join.identity\n+            ]\n+        else:\n+            # For regular joins, use the existing logic that ignores filtered_relation\n+            reuse_aliases = [\n+                a\n+                for a, j in self.alias_map.items()\n+                if (reuse is None or a in reuse) and j.equals(join)\n+            ]\n+\n+def equals(self, other):\n+    # Include filtered_relation in equality check when both joins have them\n+    if self.filtered_relation is not None and other.filtered_relation is not None:\n+        return self.identity == other.identity\n+    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n+    return self.identity[:-1] == other.identity[:-1]\n+\n+\n+    def equals(self, other):\n+        # Include filtered_relation in equality check when both joins have them\n+        if self.filtered_relation is not None and other.filtered_relation is not None:\n+            return self.identity == other.identity\n+        # For regular joins or when only one has filtered_relation, ignore filtered_relation\n+        return self.identity[:-1] == other.identity[:-1]\n \n     def join_parent_model(self, opts, model, alias, seen):\n         \"\"\"\n@@ -1569,36 +1572,13 @@ class Query(BaseExpression):\n             target_clause.add(child_clause, connector)\n         return target_clause\n \n-    def add_filtered_relation(self, filtered_relation, alias):\n-        filtered_relation.alias = alias\n-        lookups = dict(get_children_from_q(filtered_relation.condition))\n-        relation_lookup_parts, relation_field_parts, _ = self.solve_lookup_type(\n-            filtered_relation.relation_name\n-        )\n-        if relation_lookup_parts:\n-            raise ValueError(\n-                \"FilteredRelation's relation_name cannot contain lookups \"\n-                \"(got %r).\" % filtered_relation.relation_name\n-            )\n-        for lookup in chain(lookups):\n-            lookup_parts, lookup_field_parts, _ = self.solve_lookup_type(lookup)\n-            shift = 2 if not lookup_parts else 1\n-            lookup_field_path = lookup_field_parts[:-shift]\n-            for idx, lookup_field_part in enumerate(lookup_field_path):\n-                if len(relation_field_parts) > idx:\n-                    if relation_field_parts[idx] != lookup_field_part:\n-                        raise ValueError(\n-                            \"FilteredRelation's condition doesn't support \"\n-                            \"relations outside the %r (got %r).\"\n-                            % (filtered_relation.relation_name, lookup)\n-                        )\n-                else:\n-                    raise ValueError(\n-                        \"FilteredRelation's condition doesn't support nested \"\n-                        \"relations deeper than the relation_name (got %r for \"\n-                        \"%r).\" % (lookup, filtered_relation.relation_name)\n-                    )\n-        self._filtered_relations[filtered_relation.alias] = filtered_relation\n+\n+def equals(self, other):\n+    # Include filtered_relation in equality check when both joins have them\n+    if self.filtered_relation is not None and other.filtered_relation is not None:\n+        return self.identity == other.identity\n+    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n+    return self.identity[:-1] == other.identity[:-1]\n \n     def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n         \"\"\"\n@@ -1797,33 +1777,27 @@ class Query(BaseExpression):\n         # Then, add the path to the query's joins. Note that we can't trim\n         # joins at this stage - we will need the information about join type\n         # of the trimmed joins.\n-        for join in path:\n-            if join.filtered_relation:\n-                filtered_relation = join.filtered_relation.clone()\n-                table_alias = filtered_relation.alias\n-            else:\n-                filtered_relation = None\n-                table_alias = None\n-            opts = join.to_opts\n-            if join.direct:\n-                nullable = self.is_nullable(join.join_field)\n-            else:\n-                nullable = True\n-            connection = self.join_class(\n-                opts.db_table,\n-                alias,\n-                table_alias,\n-                INNER,\n-                join.join_field,\n-                nullable,\n-                filtered_relation=filtered_relation,\n-            )\n-            reuse = can_reuse if join.m2m else None\n-            alias = self.join(connection, reuse=reuse)\n-            joins.append(alias)\n-            if filtered_relation:\n-                filtered_relation.path = joins[:]\n-        return JoinInfo(final_field, targets, opts, joins, path, final_transformer)\n+\n+def equals(self, other):\n+    \"\"\"\n+    Return True if this join is equivalent to other.\n+    \n+    Two joins are considered equivalent if they have the same identity,\n+    but for filtered relations, we need to compare the full identity\n+    including the filtered_relation to distinguish between different\n+    filtering conditions on the same relation path.\n+    \"\"\"\n+    if not isinstance(other, self.__class__):\n+        return False\n+    \n+    # If both joins have filtered_relations, compare full identity\n+    # to distinguish between different filtering conditions\n+    if self.filtered_relation is not None and other.filtered_relation is not None:\n+        return self.identity == other.identity\n+    \n+    # For regular joins or mixed scenarios, ignore filtered_relation\n+    # to maintain backward compatibility\n+    return self.identity[:-1] == other.identity[:-1]\n \n     def trim_joins(self, targets, joins, path):\n         \"\"\"\n",
    "variant_8": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 54f3258eac..e5c8b5433d 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1024,34 +1024,31 @@ class Query(BaseExpression):\n         sure chains like t1 LOUTER t2 INNER t3 aren't generated. All new\n         joins are created as LOUTER if the join is nullable.\n         \"\"\"\n-        reuse_aliases = [\n-            a\n-            for a, j in self.alias_map.items()\n-            if (reuse is None or a in reuse) and j.equals(join)\n-        ]\n-        if reuse_aliases:\n-            if join.table_alias in reuse_aliases:\n-                reuse_alias = join.table_alias\n-            else:\n-                # Reuse the most recent alias of the joined table\n-                # (a many-to-many relation may be joined multiple times).\n-                reuse_alias = reuse_aliases[-1]\n-            self.ref_alias(reuse_alias)\n-            return reuse_alias\n-\n-        # No reuse is possible, so we need a new alias.\n-        alias, _ = self.table_alias(\n-            join.table_name, create=True, filtered_relation=join.filtered_relation\n-        )\n-        if join.join_type:\n-            if self.alias_map[join.parent_alias].join_type == LOUTER or join.nullable:\n-                join_type = LOUTER\n-            else:\n-                join_type = INNER\n-            join.join_type = join_type\n-        join.table_alias = alias\n-        self.alias_map[alias] = join\n-        return alias\n+\n+        # Only reuse joins when they are truly equivalent, including filtered_relation\n+        reuse_aliases = []\n+        for a, j in self.alias_map.items():\n+            if (reuse is None or a in reuse) and j.equals(join):\n+                # Additional check: if both joins have filtered_relation, they must be the same\n+                if (j.filtered_relation is not None and join.filtered_relation is not None and\n+                    j.filtered_relation != join.filtered_relation):\n+                    continue\n+                reuse_aliases.append(a)\n+\n+def equals(self, other):\n+    # Include filtered_relation in equality check when both joins have them\n+    if self.filtered_relation is not None and other.filtered_relation is not None:\n+        return self.identity == other.identity\n+    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n+    return self.identity[:-1] == other.identity[:-1]\n+\n+\n+def equals(self, other):\n+    # Include filtered_relation in equality check when both joins have them\n+    if self.filtered_relation is not None and other.filtered_relation is not None:\n+        return self.identity == other.identity\n+    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n+    return self.identity[:-1] == other.identity[:-1]\n \n     def join_parent_model(self, opts, model, alias, seen):\n         \"\"\"\n@@ -1569,36 +1566,13 @@ class Query(BaseExpression):\n             target_clause.add(child_clause, connector)\n         return target_clause\n \n-    def add_filtered_relation(self, filtered_relation, alias):\n-        filtered_relation.alias = alias\n-        lookups = dict(get_children_from_q(filtered_relation.condition))\n-        relation_lookup_parts, relation_field_parts, _ = self.solve_lookup_type(\n-            filtered_relation.relation_name\n-        )\n-        if relation_lookup_parts:\n-            raise ValueError(\n-                \"FilteredRelation's relation_name cannot contain lookups \"\n-                \"(got %r).\" % filtered_relation.relation_name\n-            )\n-        for lookup in chain(lookups):\n-            lookup_parts, lookup_field_parts, _ = self.solve_lookup_type(lookup)\n-            shift = 2 if not lookup_parts else 1\n-            lookup_field_path = lookup_field_parts[:-shift]\n-            for idx, lookup_field_part in enumerate(lookup_field_path):\n-                if len(relation_field_parts) > idx:\n-                    if relation_field_parts[idx] != lookup_field_part:\n-                        raise ValueError(\n-                            \"FilteredRelation's condition doesn't support \"\n-                            \"relations outside the %r (got %r).\"\n-                            % (filtered_relation.relation_name, lookup)\n-                        )\n-                else:\n-                    raise ValueError(\n-                        \"FilteredRelation's condition doesn't support nested \"\n-                        \"relations deeper than the relation_name (got %r for \"\n-                        \"%r).\" % (lookup, filtered_relation.relation_name)\n-                    )\n-        self._filtered_relations[filtered_relation.alias] = filtered_relation\n+\n+def equals(self, other):\n+    # Include filtered_relation in equality check when both joins have them\n+    if self.filtered_relation is not None and other.filtered_relation is not None:\n+        return self.identity == other.identity\n+    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n+    return self.identity[:-1] == other.identity[:-1]\n \n     def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n         \"\"\"\n@@ -1797,33 +1771,13 @@ class Query(BaseExpression):\n         # Then, add the path to the query's joins. Note that we can't trim\n         # joins at this stage - we will need the information about join type\n         # of the trimmed joins.\n-        for join in path:\n-            if join.filtered_relation:\n-                filtered_relation = join.filtered_relation.clone()\n-                table_alias = filtered_relation.alias\n-            else:\n-                filtered_relation = None\n-                table_alias = None\n-            opts = join.to_opts\n-            if join.direct:\n-                nullable = self.is_nullable(join.join_field)\n-            else:\n-                nullable = True\n-            connection = self.join_class(\n-                opts.db_table,\n-                alias,\n-                table_alias,\n-                INNER,\n-                join.join_field,\n-                nullable,\n-                filtered_relation=filtered_relation,\n-            )\n-            reuse = can_reuse if join.m2m else None\n-            alias = self.join(connection, reuse=reuse)\n-            joins.append(alias)\n-            if filtered_relation:\n-                filtered_relation.path = joins[:]\n-        return JoinInfo(final_field, targets, opts, joins, path, final_transformer)\n+\n+def equals(self, other):\n+    # Include filtered_relation in equality check when both joins have them\n+    if self.filtered_relation is not None and other.filtered_relation is not None:\n+        return self.identity == other.identity\n+    # For regular joins or when only one has filtered_relation, ignore filtered_relation\n+    return self.identity[:-1] == other.identity[:-1]\n \n     def trim_joins(self, targets, joins, path):\n         \"\"\"\n"
  }
}