{
  "zero_patches": {
    "Location 1 (/root/hy/projects/django/django/db/models/query.py lines 932-932)": "\ndef _combinator_query(self, combinator, *other_qs, all=False):\n    # Clone the query to inherit the select list and everything\n    clone = self._chain()\n    # Clear limits and ordering so they can be reapplied\n    # Use False to preserve default ordering and prevent state corruption\n    clone.query.clear_ordering(False)\n    clone.query.clear_limits()\n    clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n    clone.query.combinator = combinator\n    clone.query.combinator_all = all\n    return clone\n",
    "Location 2 (/root/hy/projects/django/django/db/models/query.py lines 928-937)": "\n    def _combinator_query(self, combinator, *other_qs, all=False):\n        # Clone the query to inherit the select list and everything\n        clone = self._chain()\n        # Clear limits and ordering so they can be reapplied\n        # Use False to preserve default ordering and avoid state corruption\n        clone.query.clear_ordering(False)\n        clone.query.clear_limits()\n        clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n        clone.query.combinator = combinator\n        clone.query.combinator_all = all\n        return clone\n",
    "Location 3 (/root/hy/projects/django/django/db/models/query.py lines 939-944)": "\ndef union(self, *other_qs, all=False):\n    # If the query is an EmptyQuerySet, combine all nonempty querysets.\n    if isinstance(self, EmptyQuerySet):\n        qs = [q for q in other_qs if not isinstance(q, EmptyQuerySet)]\n        if not qs:\n            return self\n        # Create a deep copy to prevent state corruption\n        first_qs = qs[0]._clone()\n        return first_qs._combinator_query('union', *qs[1:], all=all)\n    return self._combinator_query('union', *other_qs, all=all)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/django/django/db/models/query.py lines 932-932)": [
      "\ndef _combinator_query(self, combinator, *other_qs, all=False):\n    # Clone the query to inherit the select list and everything\n    clone = self._chain()\n    # Clear limits and ordering so they can be reapplied\n    # Use False to preserve default ordering and avoid state corruption\n    clone.query.clear_ordering(False)\n    clone.query.clear_limits()\n    clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n    clone.query.combinator = combinator\n    clone.query.combinator_all = all\n    return clone\n",
      "\ndef _combinator_query(self, combinator, *other_qs, all=False):\n    # Clone the query to inherit the select list and everything\n    clone = self._chain()\n    # Clear limits and ordering so they can be reapplied\n    # Use False to preserve default ordering and prevent state corruption\n    clone.query.clear_ordering(False)\n    clone.query.clear_limits()\n    clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n    clone.query.combinator = combinator\n    clone.query.combinator_all = all\n    return clone\n",
      "\ndef _combinator_query(self, combinator, *other_qs, all=False):\n    # Clone the query to inherit the select list and everything\n    clone = self._chain()\n    # Clear limits and ordering so they can be reapplied\n    # Use False to preserve default ordering and prevent state corruption\n    clone.query.clear_ordering(False)\n    clone.query.clear_limits()\n    clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n    clone.query.combinator = combinator\n    clone.query.combinator_all = all\n    return clone\n",
      "\n    def _combinator_query(self, combinator, *other_qs, all=False):\n        # Clone the query to inherit the select list and everything\n        clone = self._chain()\n        # Clear limits and ordering so they can be reapplied\n        clone.query.clear_ordering(False)\n        clone.query.clear_limits()\n        clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n        clone.query.combinator = combinator\n        clone.query.combinator_all = all\n        return clone\n",
      "\ndef _combinator_query(self, combinator, *other_qs, all=False):\n    # Clone the query to inherit the select list and everything\n    clone = self._chain()\n    # Clear limits and ordering so they can be reapplied\n    # Use False to preserve default ordering and avoid state corruption\n    clone.query.clear_ordering(False)\n    clone.query.clear_limits()\n    clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n    clone.query.combinator = combinator\n    clone.query.combinator_all = all\n    return clone\n",
      "\ndef _combinator_query(self, combinator, *other_qs, all=False):\n    # Clone the query to inherit the select list and everything\n    clone = self._chain()\n    # Clear limits and ordering so they can be reapplied\n    # Use False to preserve default ordering and avoid corrupting queryset state\n    clone.query.clear_ordering(False)\n    clone.query.clear_limits()\n    clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n    clone.query.combinator = combinator\n    clone.query.combinator_all = all\n    return clone\n",
      "\n    def _combinator_query(self, combinator, *other_qs, all=False):\n        # Clone the query to inherit the select list and everything\n        clone = self._chain()\n        # Clear limits and ordering so they can be reapplied\n        clone.query.clear_ordering(False)\n        clone.query.clear_limits()\n        clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n        clone.query.combinator = combinator\n        clone.query.combinator_all = all\n        return clone\n",
      "\ndef _combinator_query(self, combinator, *other_qs, all=False):\n    # Clone the query to inherit the select list and everything\n    clone = self._chain()\n    # Clear limits and ordering so they can be reapplied\n    # Use False to preserve default ordering and prevent state corruption\n    clone.query.clear_ordering(False)\n    clone.query.clear_limits()\n    clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n    clone.query.combinator = combinator\n    clone.query.combinator_all = all\n    return clone\n"
    ],
    "Location 2 (/root/hy/projects/django/django/db/models/query.py lines 928-937)": [
      "\n    def _combinator_query(self, combinator, *other_qs, all=False):\n        # Clone the query to inherit the select list and everything\n        clone = self._chain()\n        # Clear limits and ordering so they can be reapplied\n        # Use False to preserve default ordering and avoid state corruption\n        clone.query.clear_ordering(False)\n        clone.query.clear_limits()\n        clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n        clone.query.combinator = combinator\n        clone.query.combinator_all = all\n        return clone\n",
      "\n    def _combinator_query(self, combinator, *other_qs, all=False):\n        # Clone the query to inherit the select list and everything\n        clone = self._chain()\n        # Clear limits and ordering so they can be reapplied\n        # Use False to preserve default ordering and prevent state corruption\n        clone.query.clear_ordering(False)\n        clone.query.clear_limits()\n        clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n        clone.query.combinator = combinator\n        clone.query.combinator_all = all\n        return clone\n",
      "\n    def _combinator_query(self, combinator, *other_qs, all=False):\n        # Clone the query to inherit the select list and everything\n        clone = self._chain()\n        # Clear limits and ordering so they can be reapplied\n        # Use False to preserve default ordering and avoid state corruption\n        clone.query.clear_ordering(False)\n        clone.query.clear_limits()\n        clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n        clone.query.combinator = combinator\n        clone.query.combinator_all = all\n        return clone\n",
      "\n    def _combinator_query(self, combinator, *other_qs, all=False):\n        # Clone the query to inherit the select list and everything\n        clone = self._chain()\n        # Clear limits and ordering so they can be reapplied\n        # Use False to preserve default ordering and prevent state corruption\n        clone.query.clear_ordering(False)\n        clone.query.clear_limits()\n        clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n        clone.query.combinator = combinator\n        clone.query.combinator_all = all\n        return clone\n",
      "\ndef _combinator_query(self, combinator, *other_qs, all=False):\n    # Clone the query to inherit the select list and everything\n    clone = self._chain()\n    # Clear limits and ordering so they can be reapplied\n    # Use False to preserve default ordering and avoid state corruption\n    clone.query.clear_ordering(False)\n    clone.query.clear_limits()\n    clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n    clone.query.combinator = combinator\n    clone.query.combinator_all = all\n    return clone\n",
      "\n    def _combinator_query(self, combinator, *other_qs, all=False):\n        # Clone the query to inherit the select list and everything\n        clone = self._chain()\n        # Clear limits and ordering so they can be reapplied\n        # Use False to preserve default ordering and prevent state corruption\n        clone.query.clear_ordering(False)\n        clone.query.clear_limits()\n        clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n        clone.query.combinator = combinator\n        clone.query.combinator_all = all\n        return clone\n",
      "\ndef _combinator_query(self, combinator, *other_qs, all=False):\n    # Clone the query to inherit the select list and everything\n    clone = self._chain()\n    # Clear limits and ordering so they can be reapplied\n    # Use False to preserve default ordering and avoid corrupting original queryset\n    clone.query.clear_ordering(False)\n    clone.query.clear_limits()\n    clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n    clone.query.combinator = combinator\n    clone.query.combinator_all = all\n    return clone\n",
      "\n    def _combinator_query(self, combinator, *other_qs, all=False):\n        # Clone the query to inherit the select list and everything\n        clone = self._chain()\n        # Clear limits and ordering so they can be reapplied\n        # Use False to preserve default ordering and prevent state corruption\n        clone.query.clear_ordering(False)\n        clone.query.clear_limits()\n        clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n        clone.query.combinator = combinator\n        clone.query.combinator_all = all\n        return clone\n"
    ],
    "Location 3 (/root/hy/projects/django/django/db/models/query.py lines 939-944)": [
      "\ndef union(self, *other_qs, all=False):\n    # If the query is an EmptyQuerySet, combine all nonempty querysets.\n    if isinstance(self, EmptyQuerySet):\n        qs = [q for q in other_qs if not isinstance(q, EmptyQuerySet)]\n        if not qs:\n            return self\n        # Create a deep copy to prevent state corruption\n        first_qs = qs[0]._chain()\n        return first_qs._combinator_query('union', *qs[1:], all=all)\n    return self._combinator_query('union', *other_qs, all=all)\n",
      "\ndef union(self, *other_qs, all=False):\n    # If the query is an EmptyQuerySet, combine all nonempty querysets.\n    if isinstance(self, EmptyQuerySet):\n        qs = [q for q in other_qs if not isinstance(q, EmptyQuerySet)]\n        if not qs:\n            return self\n        # Create a deep copy to prevent state corruption\n        result = qs[0]._clone()\n        return result._combinator_query('union', *qs[1:], all=all) if len(qs) > 1 else result._combinator_query('union', all=all)\n    return self._combinator_query('union', *other_qs, all=all)\n",
      "\ndef union(self, *other_qs, all=False):\n    # If the query is an EmptyQuerySet, combine all nonempty querysets.\n    if isinstance(self, EmptyQuerySet):\n        qs = [q for q in other_qs if not isinstance(q, EmptyQuerySet)]\n        if not qs:\n            return self\n        # Create a deep copy to prevent state corruption\n        first_qs = qs[0]._clone()\n        return first_qs._combinator_query('union', *qs[1:], all=all)\n    # Create a deep copy to prevent state corruption of the original queryset\n    clone = self._clone()\n    return clone._combinator_query('union', *other_qs, all=all)\n",
      "\ndef union(self, *other_qs, all=False):\n    # If the query is an EmptyQuerySet, combine all nonempty querysets.\n    if isinstance(self, EmptyQuerySet):\n        qs = [q for q in other_qs if not isinstance(q, EmptyQuerySet)]\n        if qs:\n            return qs[0]._combinator_query('union', *qs[1:], all=all)\n        return self\n    return self._combinator_query('union', *other_qs, all=all)\n",
      "\ndef union(self, *other_qs, all=False):\n    # If the query is an EmptyQuerySet, combine all nonempty querysets.\n    if isinstance(self, EmptyQuerySet):\n        qs = [q for q in other_qs if not isinstance(q, EmptyQuerySet)]\n        if not qs:\n            return self\n        # Create a deep copy to prevent state corruption\n        first_qs = qs[0]._chain()\n        return first_qs._combinator_query('union', *qs[1:], all=all)\n    return self._combinator_query('union', *other_qs, all=all)\n",
      "\ndef union(self, *other_qs, all=False):\n    # If the query is an EmptyQuerySet, combine all nonempty querysets.\n    if isinstance(self, EmptyQuerySet):\n        qs = [q for q in other_qs if not isinstance(q, EmptyQuerySet)]\n        if not qs:\n            return self\n        # Create a deep copy of the first queryset to avoid state corruption\n        first_qs = qs[0]._chain()\n        return first_qs._combinator_query('union', *qs[1:], all=all)\n    return self._combinator_query('union', *other_qs, all=all)\n",
      "\ndef union(self, *other_qs, all=False):\n    # If the query is an EmptyQuerySet, combine all nonempty querysets.\n    if isinstance(self, EmptyQuerySet):\n        qs = [q for q in other_qs if not isinstance(q, EmptyQuerySet)]\n        if not qs:\n            return self\n        # Create a deep copy to prevent state corruption\n        first_qs = qs[0]._chain()\n        return first_qs._combinator_query('union', *qs[1:], all=all)\n    return self._combinator_query('union', *other_qs, all=all)\n",
      "\ndef union(self, *other_qs, all=False):\n    # If the query is an EmptyQuerySet, combine all nonempty querysets.\n    if isinstance(self, EmptyQuerySet):\n        qs = [q for q in other_qs if not isinstance(q, EmptyQuerySet)]\n        if not qs:\n            return self\n        # Ensure we don't modify the original queryset when creating the union\n        first_qs = qs[0]._chain()\n        return first_qs._combinator_query('union', *qs[1:], all=all)\n    return self._combinator_query('union', *other_qs, all=all)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 1544beb613..2a8979267b 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -925,16 +925,19 @@ class QuerySet:\n         else:\n             return self._filter_or_exclude(None, **filter_obj)\n \n+\n     def _combinator_query(self, combinator, *other_qs, all=False):\n         # Clone the query to inherit the select list and everything\n         clone = self._chain()\n         # Clear limits and ordering so they can be reapplied\n-        clone.query.clear_ordering(True)\n+        clone.query.clear_ordering(False)\n         clone.query.clear_limits()\n         clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n         clone.query.combinator = combinator\n         clone.query.combinator_all = all\n         return clone\n+        return clone\n+\n \n     def union(self, *other_qs, all=False):\n         # If the query is an EmptyQuerySet, combine all nonempty querysets.\n",
    "variant_0": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 1544beb613..6483ebf6da 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -925,23 +925,41 @@ class QuerySet:\n         else:\n             return self._filter_or_exclude(None, **filter_obj)\n \n+\n     def _combinator_query(self, combinator, *other_qs, all=False):\n         # Clone the query to inherit the select list and everything\n         clone = self._chain()\n         # Clear limits and ordering so they can be reapplied\n-        clone.query.clear_ordering(True)\n+        # Use False to preserve default ordering and avoid state corruption\n+        clone.query.clear_ordering(False)\n+        clone.query.clear_limits()\n+        clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n+        clone.query.combinator = combinator\n+        clone.query.combinator_all = all\n+        return clone\n+    clone.query.clear_ordering(False)\n+    clone.query.clear_limits()\n+    clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n+    clone.query.combinator = combinator\n+    clone.query.combinator_all = all\n+    return clone\n         clone.query.clear_limits()\n         clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n         clone.query.combinator = combinator\n         clone.query.combinator_all = all\n         return clone\n \n-    def union(self, *other_qs, all=False):\n-        # If the query is an EmptyQuerySet, combine all nonempty querysets.\n-        if isinstance(self, EmptyQuerySet):\n-            qs = [q for q in other_qs if not isinstance(q, EmptyQuerySet)]\n-            return qs[0]._combinator_query('union', *qs[1:], all=all) if qs else self\n-        return self._combinator_query('union', *other_qs, all=all)\n+\n+def union(self, *other_qs, all=False):\n+    # If the query is an EmptyQuerySet, combine all nonempty querysets.\n+    if isinstance(self, EmptyQuerySet):\n+        qs = [q for q in other_qs if not isinstance(q, EmptyQuerySet)]\n+        if not qs:\n+            return self\n+        # Create a deep copy to prevent state corruption\n+        first_qs = qs[0]._clone()\n+        return first_qs._combinator_query('union', *qs[1:], all=all)\n+    return self._combinator_query('union', *other_qs, all=all)\n \n     def intersection(self, *other_qs):\n         # If any query is an EmptyQuerySet, return it.\n",
    "variant_1": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 1544beb613..8cf1441717 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -925,23 +925,41 @@ class QuerySet:\n         else:\n             return self._filter_or_exclude(None, **filter_obj)\n \n+\n     def _combinator_query(self, combinator, *other_qs, all=False):\n         # Clone the query to inherit the select list and everything\n         clone = self._chain()\n         # Clear limits and ordering so they can be reapplied\n-        clone.query.clear_ordering(True)\n+        # Use False to preserve default ordering and avoid state corruption\n+        clone.query.clear_ordering(False)\n+        clone.query.clear_limits()\n+        clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n+        clone.query.combinator = combinator\n+        clone.query.combinator_all = all\n+        return clone\n+    clone.query.clear_ordering(False)\n+    clone.query.clear_limits()\n+    clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n+    clone.query.combinator = combinator\n+    clone.query.combinator_all = all\n+    return clone\n         clone.query.clear_limits()\n         clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n         clone.query.combinator = combinator\n         clone.query.combinator_all = all\n         return clone\n \n-    def union(self, *other_qs, all=False):\n-        # If the query is an EmptyQuerySet, combine all nonempty querysets.\n-        if isinstance(self, EmptyQuerySet):\n-            qs = [q for q in other_qs if not isinstance(q, EmptyQuerySet)]\n-            return qs[0]._combinator_query('union', *qs[1:], all=all) if qs else self\n-        return self._combinator_query('union', *other_qs, all=all)\n+\n+def union(self, *other_qs, all=False):\n+    # If the query is an EmptyQuerySet, combine all nonempty querysets.\n+    if isinstance(self, EmptyQuerySet):\n+        qs = [q for q in other_qs if not isinstance(q, EmptyQuerySet)]\n+        if not qs:\n+            return self\n+        # Create a deep copy to prevent state corruption\n+        first_qs = qs[0]._chain()\n+        return first_qs._combinator_query('union', *qs[1:], all=all)\n+    return self._combinator_query('union', *other_qs, all=all)\n \n     def intersection(self, *other_qs):\n         # If any query is an EmptyQuerySet, return it.\n",
    "variant_2": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 1544beb613..e4bd9f8ecc 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -925,23 +925,41 @@ class QuerySet:\n         else:\n             return self._filter_or_exclude(None, **filter_obj)\n \n+\n     def _combinator_query(self, combinator, *other_qs, all=False):\n         # Clone the query to inherit the select list and everything\n         clone = self._chain()\n         # Clear limits and ordering so they can be reapplied\n-        clone.query.clear_ordering(True)\n+        # Use False to preserve default ordering and prevent state corruption\n+        clone.query.clear_ordering(False)\n+        clone.query.clear_limits()\n+        clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n+        clone.query.combinator = combinator\n+        clone.query.combinator_all = all\n+        return clone\n+    clone.query.clear_ordering(False)\n+    clone.query.clear_limits()\n+    clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n+    clone.query.combinator = combinator\n+    clone.query.combinator_all = all\n+    return clone\n         clone.query.clear_limits()\n         clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n         clone.query.combinator = combinator\n         clone.query.combinator_all = all\n         return clone\n \n-    def union(self, *other_qs, all=False):\n-        # If the query is an EmptyQuerySet, combine all nonempty querysets.\n-        if isinstance(self, EmptyQuerySet):\n-            qs = [q for q in other_qs if not isinstance(q, EmptyQuerySet)]\n-            return qs[0]._combinator_query('union', *qs[1:], all=all) if qs else self\n-        return self._combinator_query('union', *other_qs, all=all)\n+\n+def union(self, *other_qs, all=False):\n+    # If the query is an EmptyQuerySet, combine all nonempty querysets.\n+    if isinstance(self, EmptyQuerySet):\n+        qs = [q for q in other_qs if not isinstance(q, EmptyQuerySet)]\n+        if not qs:\n+            return self\n+        # Create a deep copy to prevent state corruption\n+        result = qs[0]._clone()\n+        return result._combinator_query('union', *qs[1:], all=all) if len(qs) > 1 else result._combinator_query('union', all=all)\n+    return self._combinator_query('union', *other_qs, all=all)\n \n     def intersection(self, *other_qs):\n         # If any query is an EmptyQuerySet, return it.\n",
    "variant_3": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 1544beb613..edcf2c58fb 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -925,23 +925,43 @@ class QuerySet:\n         else:\n             return self._filter_or_exclude(None, **filter_obj)\n \n+\n     def _combinator_query(self, combinator, *other_qs, all=False):\n         # Clone the query to inherit the select list and everything\n         clone = self._chain()\n         # Clear limits and ordering so they can be reapplied\n-        clone.query.clear_ordering(True)\n+        # Use False to preserve default ordering and avoid state corruption\n+        clone.query.clear_ordering(False)\n+        clone.query.clear_limits()\n+        clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n+        clone.query.combinator = combinator\n+        clone.query.combinator_all = all\n+        return clone\n+    clone.query.clear_ordering(False)\n+    clone.query.clear_limits()\n+    clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n+    clone.query.combinator = combinator\n+    clone.query.combinator_all = all\n+    return clone\n         clone.query.clear_limits()\n         clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n         clone.query.combinator = combinator\n         clone.query.combinator_all = all\n         return clone\n \n-    def union(self, *other_qs, all=False):\n-        # If the query is an EmptyQuerySet, combine all nonempty querysets.\n-        if isinstance(self, EmptyQuerySet):\n-            qs = [q for q in other_qs if not isinstance(q, EmptyQuerySet)]\n-            return qs[0]._combinator_query('union', *qs[1:], all=all) if qs else self\n-        return self._combinator_query('union', *other_qs, all=all)\n+\n+def union(self, *other_qs, all=False):\n+    # If the query is an EmptyQuerySet, combine all nonempty querysets.\n+    if isinstance(self, EmptyQuerySet):\n+        qs = [q for q in other_qs if not isinstance(q, EmptyQuerySet)]\n+        if not qs:\n+            return self\n+        # Create a deep copy to prevent state corruption\n+        first_qs = qs[0]._clone()\n+        return first_qs._combinator_query('union', *qs[1:], all=all)\n+    # Create a deep copy to prevent state corruption of the original queryset\n+    clone = self._clone()\n+    return clone._combinator_query('union', *other_qs, all=all)\n \n     def intersection(self, *other_qs):\n         # If any query is an EmptyQuerySet, return it.\n",
    "variant_4": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 1544beb613..5113d54f41 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -925,23 +925,38 @@ class QuerySet:\n         else:\n             return self._filter_or_exclude(None, **filter_obj)\n \n+\n     def _combinator_query(self, combinator, *other_qs, all=False):\n         # Clone the query to inherit the select list and everything\n         clone = self._chain()\n         # Clear limits and ordering so they can be reapplied\n-        clone.query.clear_ordering(True)\n+        # Use False to preserve default ordering and prevent state corruption\n+        clone.query.clear_ordering(False)\n+        clone.query.clear_limits()\n+        clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n+        clone.query.combinator = combinator\n+        clone.query.combinator_all = all\n+        return clone\n+        clone.query.clear_limits()\n+        clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n+        clone.query.combinator = combinator\n+        clone.query.combinator_all = all\n+        return clone\n         clone.query.clear_limits()\n         clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n         clone.query.combinator = combinator\n         clone.query.combinator_all = all\n         return clone\n \n-    def union(self, *other_qs, all=False):\n-        # If the query is an EmptyQuerySet, combine all nonempty querysets.\n-        if isinstance(self, EmptyQuerySet):\n-            qs = [q for q in other_qs if not isinstance(q, EmptyQuerySet)]\n-            return qs[0]._combinator_query('union', *qs[1:], all=all) if qs else self\n-        return self._combinator_query('union', *other_qs, all=all)\n+\n+def union(self, *other_qs, all=False):\n+    # If the query is an EmptyQuerySet, combine all nonempty querysets.\n+    if isinstance(self, EmptyQuerySet):\n+        qs = [q for q in other_qs if not isinstance(q, EmptyQuerySet)]\n+        if qs:\n+            return qs[0]._combinator_query('union', *qs[1:], all=all)\n+        return self\n+    return self._combinator_query('union', *other_qs, all=all)\n \n     def intersection(self, *other_qs):\n         # If any query is an EmptyQuerySet, return it.\n",
    "variant_5": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 1544beb613..25403d7f3a 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -925,23 +925,41 @@ class QuerySet:\n         else:\n             return self._filter_or_exclude(None, **filter_obj)\n \n-    def _combinator_query(self, combinator, *other_qs, all=False):\n-        # Clone the query to inherit the select list and everything\n-        clone = self._chain()\n-        # Clear limits and ordering so they can be reapplied\n-        clone.query.clear_ordering(True)\n+\n+def _combinator_query(self, combinator, *other_qs, all=False):\n+    # Clone the query to inherit the select list and everything\n+    clone = self._chain()\n+    # Clear limits and ordering so they can be reapplied\n+    # Use False to preserve default ordering and avoid state corruption\n+    clone.query.clear_ordering(False)\n+    clone.query.clear_limits()\n+    clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n+    clone.query.combinator = combinator\n+    clone.query.combinator_all = all\n+    return clone\n+    clone.query.clear_ordering(False)\n+    clone.query.clear_limits()\n+    clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n+    clone.query.combinator = combinator\n+    clone.query.combinator_all = all\n+    return clone\n         clone.query.clear_limits()\n         clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n         clone.query.combinator = combinator\n         clone.query.combinator_all = all\n         return clone\n \n-    def union(self, *other_qs, all=False):\n-        # If the query is an EmptyQuerySet, combine all nonempty querysets.\n-        if isinstance(self, EmptyQuerySet):\n-            qs = [q for q in other_qs if not isinstance(q, EmptyQuerySet)]\n-            return qs[0]._combinator_query('union', *qs[1:], all=all) if qs else self\n-        return self._combinator_query('union', *other_qs, all=all)\n+\n+def union(self, *other_qs, all=False):\n+    # If the query is an EmptyQuerySet, combine all nonempty querysets.\n+    if isinstance(self, EmptyQuerySet):\n+        qs = [q for q in other_qs if not isinstance(q, EmptyQuerySet)]\n+        if not qs:\n+            return self\n+        # Create a deep copy to prevent state corruption\n+        first_qs = qs[0]._chain()\n+        return first_qs._combinator_query('union', *qs[1:], all=all)\n+    return self._combinator_query('union', *other_qs, all=all)\n \n     def intersection(self, *other_qs):\n         # If any query is an EmptyQuerySet, return it.\n",
    "variant_6": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 1544beb613..df0386fb45 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -925,23 +925,41 @@ class QuerySet:\n         else:\n             return self._filter_or_exclude(None, **filter_obj)\n \n+\n     def _combinator_query(self, combinator, *other_qs, all=False):\n         # Clone the query to inherit the select list and everything\n         clone = self._chain()\n         # Clear limits and ordering so they can be reapplied\n-        clone.query.clear_ordering(True)\n+        # Use False to preserve default ordering and prevent state corruption\n+        clone.query.clear_ordering(False)\n+        clone.query.clear_limits()\n+        clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n+        clone.query.combinator = combinator\n+        clone.query.combinator_all = all\n+        return clone\n+    clone.query.clear_ordering(False)\n+    clone.query.clear_limits()\n+    clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n+    clone.query.combinator = combinator\n+    clone.query.combinator_all = all\n+    return clone\n         clone.query.clear_limits()\n         clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n         clone.query.combinator = combinator\n         clone.query.combinator_all = all\n         return clone\n \n-    def union(self, *other_qs, all=False):\n-        # If the query is an EmptyQuerySet, combine all nonempty querysets.\n-        if isinstance(self, EmptyQuerySet):\n-            qs = [q for q in other_qs if not isinstance(q, EmptyQuerySet)]\n-            return qs[0]._combinator_query('union', *qs[1:], all=all) if qs else self\n-        return self._combinator_query('union', *other_qs, all=all)\n+\n+def union(self, *other_qs, all=False):\n+    # If the query is an EmptyQuerySet, combine all nonempty querysets.\n+    if isinstance(self, EmptyQuerySet):\n+        qs = [q for q in other_qs if not isinstance(q, EmptyQuerySet)]\n+        if not qs:\n+            return self\n+        # Create a deep copy of the first queryset to avoid state corruption\n+        first_qs = qs[0]._chain()\n+        return first_qs._combinator_query('union', *qs[1:], all=all)\n+    return self._combinator_query('union', *other_qs, all=all)\n \n     def intersection(self, *other_qs):\n         # If any query is an EmptyQuerySet, return it.\n",
    "variant_7": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 1544beb613..bbae08f683 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -925,23 +925,40 @@ class QuerySet:\n         else:\n             return self._filter_or_exclude(None, **filter_obj)\n \n-    def _combinator_query(self, combinator, *other_qs, all=False):\n-        # Clone the query to inherit the select list and everything\n-        clone = self._chain()\n-        # Clear limits and ordering so they can be reapplied\n-        clone.query.clear_ordering(True)\n+\n+def _combinator_query(self, combinator, *other_qs, all=False):\n+    # Clone the query to inherit the select list and everything\n+    clone = self._chain()\n+    # Clear limits and ordering so they can be reapplied\n+    # Use False to preserve default ordering and avoid corrupting original queryset\n+    clone.query.clear_ordering(False)\n+    clone.query.clear_limits()\n+    clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n+    clone.query.combinator = combinator\n+    clone.query.combinator_all = all\n+    return clone\n+        clone.query.clear_limits()\n+        clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n+        clone.query.combinator = combinator\n+        clone.query.combinator_all = all\n+        return clone\n         clone.query.clear_limits()\n         clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n         clone.query.combinator = combinator\n         clone.query.combinator_all = all\n         return clone\n \n-    def union(self, *other_qs, all=False):\n-        # If the query is an EmptyQuerySet, combine all nonempty querysets.\n-        if isinstance(self, EmptyQuerySet):\n-            qs = [q for q in other_qs if not isinstance(q, EmptyQuerySet)]\n-            return qs[0]._combinator_query('union', *qs[1:], all=all) if qs else self\n-        return self._combinator_query('union', *other_qs, all=all)\n+\n+def union(self, *other_qs, all=False):\n+    # If the query is an EmptyQuerySet, combine all nonempty querysets.\n+    if isinstance(self, EmptyQuerySet):\n+        qs = [q for q in other_qs if not isinstance(q, EmptyQuerySet)]\n+        if not qs:\n+            return self\n+        # Create a deep copy to prevent state corruption\n+        first_qs = qs[0]._chain()\n+        return first_qs._combinator_query('union', *qs[1:], all=all)\n+    return self._combinator_query('union', *other_qs, all=all)\n \n     def intersection(self, *other_qs):\n         # If any query is an EmptyQuerySet, return it.\n",
    "variant_8": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 1544beb613..93f7a58912 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -925,23 +925,41 @@ class QuerySet:\n         else:\n             return self._filter_or_exclude(None, **filter_obj)\n \n+\n     def _combinator_query(self, combinator, *other_qs, all=False):\n         # Clone the query to inherit the select list and everything\n         clone = self._chain()\n         # Clear limits and ordering so they can be reapplied\n-        clone.query.clear_ordering(True)\n+        # Use False to preserve default ordering and prevent state corruption\n+        clone.query.clear_ordering(False)\n+        clone.query.clear_limits()\n+        clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n+        clone.query.combinator = combinator\n+        clone.query.combinator_all = all\n+        return clone\n+    clone.query.clear_ordering(False)\n+    clone.query.clear_limits()\n+    clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n+    clone.query.combinator = combinator\n+    clone.query.combinator_all = all\n+    return clone\n         clone.query.clear_limits()\n         clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n         clone.query.combinator = combinator\n         clone.query.combinator_all = all\n         return clone\n \n-    def union(self, *other_qs, all=False):\n-        # If the query is an EmptyQuerySet, combine all nonempty querysets.\n-        if isinstance(self, EmptyQuerySet):\n-            qs = [q for q in other_qs if not isinstance(q, EmptyQuerySet)]\n-            return qs[0]._combinator_query('union', *qs[1:], all=all) if qs else self\n-        return self._combinator_query('union', *other_qs, all=all)\n+\n+def union(self, *other_qs, all=False):\n+    # If the query is an EmptyQuerySet, combine all nonempty querysets.\n+    if isinstance(self, EmptyQuerySet):\n+        qs = [q for q in other_qs if not isinstance(q, EmptyQuerySet)]\n+        if not qs:\n+            return self\n+        # Ensure we don't modify the original queryset when creating the union\n+        first_qs = qs[0]._chain()\n+        return first_qs._combinator_query('union', *qs[1:], all=all)\n+    return self._combinator_query('union', *other_qs, all=all)\n \n     def intersection(self, *other_qs):\n         # If any query is an EmptyQuerySet, return it.\n"
  }
}