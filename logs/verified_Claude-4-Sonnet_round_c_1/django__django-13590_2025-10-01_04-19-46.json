{
  "zero_patches": {
    "Location 1 (/root/hy/projects/django/django/db/models/sql/query.py lines 1077-1083)": "\n    def resolve_lookup_value(self, value, can_reuse, allow_joins):\n        if hasattr(value, 'resolve_expression'):\n            value = value.resolve_expression(\n                self, reuse=can_reuse, allow_joins=allow_joins,\n            )\n        elif isinstance(value, (list, tuple)):\n            # The items of the iterable may be expressions and therefore need\n            # to be resolved independently.\n            resolved_values = (\n                self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n                for sub_value in value\n            )\n            # Handle named tuples which require positional arguments\n            if hasattr(value, '_fields'):\n                return type(value)(*resolved_values)\n            else:\n                return type(value)(resolved_values)\n        return value\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/django/django/db/models/sql/query.py lines 1077-1083)": [
      "\n    def resolve_lookup_value(self, value, can_reuse, allow_joins):\n        if hasattr(value, 'resolve_expression'):\n            value = value.resolve_expression(\n                self, reuse=can_reuse, allow_joins=allow_joins,\n            )\n        elif isinstance(value, (list, tuple)):\n            # The items of the iterable may be expressions and therefore need\n            # to be resolved independently.\n            resolved_values = (\n                self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n                for sub_value in value\n            )\n            # Handle named tuples which require positional arguments\n            if hasattr(value, '_fields'):\n                return type(value)(*resolved_values)\n            else:\n                return type(value)(resolved_values)\n        return value\n",
      "\n    def resolve_lookup_value(self, value, can_reuse, allow_joins):\n        if hasattr(value, 'resolve_expression'):\n            value = value.resolve_expression(\n                self, reuse=can_reuse, allow_joins=allow_joins,\n            )\n        elif isinstance(value, (list, tuple)):\n            # The items of the iterable may be expressions and therefore need\n            # to be resolved independently.\n            resolved_values = (\n                self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n                for sub_value in value\n            )\n            # Handle named tuples which require positional arguments\n            if hasattr(value, '_fields'):\n                return type(value)(*resolved_values)\n            else:\n                return type(value)(resolved_values)\n        return value\n",
      "\n        elif isinstance(value, (list, tuple)):\n            # The items of the iterable may be expressions and therefore need\n            # to be resolved independently.\n            resolved_values = (\n                self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n                for sub_value in value\n            )\n            # Handle named tuples which require positional arguments\n            if hasattr(value, '_fields'):\n                return type(value)(*resolved_values)\n            else:\n                return type(value)(resolved_values)\n",
      "\n    def resolve_lookup_value(self, value, can_reuse, allow_joins):\n        if hasattr(value, 'resolve_expression'):\n            value = value.resolve_expression(\n                self, reuse=can_reuse, allow_joins=allow_joins,\n            )\n        elif isinstance(value, (list, tuple)):\n            # The items of the iterable may be expressions and therefore need\n            # to be resolved independently.\n            resolved_values = (\n                self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n                for sub_value in value\n            )\n            # Handle named tuples which require positional arguments\n            if hasattr(value, '_fields'):\n                return type(value)(*resolved_values)\n            else:\n                return type(value)(resolved_values)\n        return value\n",
      "\n    def resolve_lookup_value(self, value, can_reuse, allow_joins):\n        if hasattr(value, 'resolve_expression'):\n            value = value.resolve_expression(\n                self, reuse=can_reuse, allow_joins=allow_joins,\n            )\n        elif isinstance(value, (list, tuple)):\n            # The items of the iterable may be expressions and therefore need\n            # to be resolved independently.\n            resolved_values = (\n                self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n                for sub_value in value\n            )\n            # Handle named tuples which require positional arguments\n            if hasattr(value, '_fields'):\n                return type(value)(*resolved_values)\n            else:\n                return type(value)(resolved_values)\n        return value\n",
      "\n    def resolve_lookup_value(self, value, can_reuse, allow_joins):\n        if hasattr(value, 'resolve_expression'):\n            value = value.resolve_expression(\n                self, reuse=can_reuse, allow_joins=allow_joins,\n            )\n        elif isinstance(value, (list, tuple)):\n            # The items of the iterable may be expressions and therefore need\n            # to be resolved independently.\n            resolved_values = (\n                self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n                for sub_value in value\n            )\n            # Handle named tuples which require positional arguments\n            if hasattr(value, '_fields'):\n                return type(value)(*resolved_values)\n            else:\n                return type(value)(resolved_values)\n        return value\n",
      "\n    def resolve_lookup_value(self, value, can_reuse, allow_joins):\n        if hasattr(value, 'resolve_expression'):\n            value = value.resolve_expression(\n                self, reuse=can_reuse, allow_joins=allow_joins,\n            )\n        elif isinstance(value, (list, tuple)):\n            # The items of the iterable may be expressions and therefore need\n            # to be resolved independently.\n            resolved_values = (\n                self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n                for sub_value in value\n            )\n            # Handle named tuples which require positional arguments\n            if hasattr(value, '_fields'):\n                return type(value)(*resolved_values)\n            else:\n                return type(value)(resolved_values)\n        return value\n",
      "\n    def resolve_lookup_value(self, value, can_reuse, allow_joins):\n        if hasattr(value, 'resolve_expression'):\n            value = value.resolve_expression(\n                self, reuse=can_reuse, allow_joins=allow_joins,\n            )\n        elif isinstance(value, (list, tuple)):\n            # The items of the iterable may be expressions and therefore need\n            # to be resolved independently.\n            resolved_values = (\n                self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n                for sub_value in value\n            )\n            # Handle named tuples which require positional arguments\n            if hasattr(value, '_fields'):\n                return type(value)(*resolved_values)\n            else:\n                return type(value)(resolved_values)\n        return value\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 4648daf395..f1c553dc5d 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1074,13 +1074,19 @@ class Query(BaseExpression):\n             value = value.resolve_expression(\n                 self, reuse=can_reuse, allow_joins=allow_joins,\n             )\n+\n         elif isinstance(value, (list, tuple)):\n             # The items of the iterable may be expressions and therefore need\n             # to be resolved independently.\n-            return type(value)(\n+            resolved_values = (\n                 self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n                 for sub_value in value\n             )\n+            # Handle named tuples which require positional arguments\n+            if hasattr(value, '_fields'):\n+                return type(value)(*resolved_values)\n+            else:\n+                return type(value)(resolved_values)\n         return value\n \n     def solve_lookup_type(self, lookup):\n",
    "variant_0": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 4648daf395..19238c77a7 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1069,6 +1069,12 @@ class Query(BaseExpression):\n             sql = '(%s)' % sql\n         return sql, params\n \n+    def resolve_lookup_value(self, value, can_reuse, allow_joins):\n+        if hasattr(value, 'resolve_expression'):\n+            value = value.resolve_expression(\n+                self, reuse=can_reuse, allow_joins=allow_joins,\n+            )\n+\n     def resolve_lookup_value(self, value, can_reuse, allow_joins):\n         if hasattr(value, 'resolve_expression'):\n             value = value.resolve_expression(\n@@ -1077,10 +1083,16 @@ class Query(BaseExpression):\n         elif isinstance(value, (list, tuple)):\n             # The items of the iterable may be expressions and therefore need\n             # to be resolved independently.\n-            return type(value)(\n+            resolved_values = (\n                 self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n                 for sub_value in value\n             )\n+            # Handle named tuples which require positional arguments\n+            if hasattr(value, '_fields'):\n+                return type(value)(*resolved_values)\n+            else:\n+                return type(value)(resolved_values)\n+        return value\n         return value\n \n     def solve_lookup_type(self, lookup):\n",
    "variant_1": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 4648daf395..19238c77a7 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1069,6 +1069,12 @@ class Query(BaseExpression):\n             sql = '(%s)' % sql\n         return sql, params\n \n+    def resolve_lookup_value(self, value, can_reuse, allow_joins):\n+        if hasattr(value, 'resolve_expression'):\n+            value = value.resolve_expression(\n+                self, reuse=can_reuse, allow_joins=allow_joins,\n+            )\n+\n     def resolve_lookup_value(self, value, can_reuse, allow_joins):\n         if hasattr(value, 'resolve_expression'):\n             value = value.resolve_expression(\n@@ -1077,10 +1083,16 @@ class Query(BaseExpression):\n         elif isinstance(value, (list, tuple)):\n             # The items of the iterable may be expressions and therefore need\n             # to be resolved independently.\n-            return type(value)(\n+            resolved_values = (\n                 self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n                 for sub_value in value\n             )\n+            # Handle named tuples which require positional arguments\n+            if hasattr(value, '_fields'):\n+                return type(value)(*resolved_values)\n+            else:\n+                return type(value)(resolved_values)\n+        return value\n         return value\n \n     def solve_lookup_type(self, lookup):\n",
    "variant_2": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 4648daf395..19238c77a7 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1069,6 +1069,12 @@ class Query(BaseExpression):\n             sql = '(%s)' % sql\n         return sql, params\n \n+    def resolve_lookup_value(self, value, can_reuse, allow_joins):\n+        if hasattr(value, 'resolve_expression'):\n+            value = value.resolve_expression(\n+                self, reuse=can_reuse, allow_joins=allow_joins,\n+            )\n+\n     def resolve_lookup_value(self, value, can_reuse, allow_joins):\n         if hasattr(value, 'resolve_expression'):\n             value = value.resolve_expression(\n@@ -1077,10 +1083,16 @@ class Query(BaseExpression):\n         elif isinstance(value, (list, tuple)):\n             # The items of the iterable may be expressions and therefore need\n             # to be resolved independently.\n-            return type(value)(\n+            resolved_values = (\n                 self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n                 for sub_value in value\n             )\n+            # Handle named tuples which require positional arguments\n+            if hasattr(value, '_fields'):\n+                return type(value)(*resolved_values)\n+            else:\n+                return type(value)(resolved_values)\n+        return value\n         return value\n \n     def solve_lookup_type(self, lookup):\n",
    "variant_3": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 4648daf395..f1c553dc5d 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1074,13 +1074,19 @@ class Query(BaseExpression):\n             value = value.resolve_expression(\n                 self, reuse=can_reuse, allow_joins=allow_joins,\n             )\n+\n         elif isinstance(value, (list, tuple)):\n             # The items of the iterable may be expressions and therefore need\n             # to be resolved independently.\n-            return type(value)(\n+            resolved_values = (\n                 self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n                 for sub_value in value\n             )\n+            # Handle named tuples which require positional arguments\n+            if hasattr(value, '_fields'):\n+                return type(value)(*resolved_values)\n+            else:\n+                return type(value)(resolved_values)\n         return value\n \n     def solve_lookup_type(self, lookup):\n",
    "variant_4": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 4648daf395..19238c77a7 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1069,6 +1069,12 @@ class Query(BaseExpression):\n             sql = '(%s)' % sql\n         return sql, params\n \n+    def resolve_lookup_value(self, value, can_reuse, allow_joins):\n+        if hasattr(value, 'resolve_expression'):\n+            value = value.resolve_expression(\n+                self, reuse=can_reuse, allow_joins=allow_joins,\n+            )\n+\n     def resolve_lookup_value(self, value, can_reuse, allow_joins):\n         if hasattr(value, 'resolve_expression'):\n             value = value.resolve_expression(\n@@ -1077,10 +1083,16 @@ class Query(BaseExpression):\n         elif isinstance(value, (list, tuple)):\n             # The items of the iterable may be expressions and therefore need\n             # to be resolved independently.\n-            return type(value)(\n+            resolved_values = (\n                 self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n                 for sub_value in value\n             )\n+            # Handle named tuples which require positional arguments\n+            if hasattr(value, '_fields'):\n+                return type(value)(*resolved_values)\n+            else:\n+                return type(value)(resolved_values)\n+        return value\n         return value\n \n     def solve_lookup_type(self, lookup):\n",
    "variant_5": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 4648daf395..19238c77a7 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1069,6 +1069,12 @@ class Query(BaseExpression):\n             sql = '(%s)' % sql\n         return sql, params\n \n+    def resolve_lookup_value(self, value, can_reuse, allow_joins):\n+        if hasattr(value, 'resolve_expression'):\n+            value = value.resolve_expression(\n+                self, reuse=can_reuse, allow_joins=allow_joins,\n+            )\n+\n     def resolve_lookup_value(self, value, can_reuse, allow_joins):\n         if hasattr(value, 'resolve_expression'):\n             value = value.resolve_expression(\n@@ -1077,10 +1083,16 @@ class Query(BaseExpression):\n         elif isinstance(value, (list, tuple)):\n             # The items of the iterable may be expressions and therefore need\n             # to be resolved independently.\n-            return type(value)(\n+            resolved_values = (\n                 self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n                 for sub_value in value\n             )\n+            # Handle named tuples which require positional arguments\n+            if hasattr(value, '_fields'):\n+                return type(value)(*resolved_values)\n+            else:\n+                return type(value)(resolved_values)\n+        return value\n         return value\n \n     def solve_lookup_type(self, lookup):\n",
    "variant_6": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 4648daf395..19238c77a7 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1069,6 +1069,12 @@ class Query(BaseExpression):\n             sql = '(%s)' % sql\n         return sql, params\n \n+    def resolve_lookup_value(self, value, can_reuse, allow_joins):\n+        if hasattr(value, 'resolve_expression'):\n+            value = value.resolve_expression(\n+                self, reuse=can_reuse, allow_joins=allow_joins,\n+            )\n+\n     def resolve_lookup_value(self, value, can_reuse, allow_joins):\n         if hasattr(value, 'resolve_expression'):\n             value = value.resolve_expression(\n@@ -1077,10 +1083,16 @@ class Query(BaseExpression):\n         elif isinstance(value, (list, tuple)):\n             # The items of the iterable may be expressions and therefore need\n             # to be resolved independently.\n-            return type(value)(\n+            resolved_values = (\n                 self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n                 for sub_value in value\n             )\n+            # Handle named tuples which require positional arguments\n+            if hasattr(value, '_fields'):\n+                return type(value)(*resolved_values)\n+            else:\n+                return type(value)(resolved_values)\n+        return value\n         return value\n \n     def solve_lookup_type(self, lookup):\n",
    "variant_7": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 4648daf395..19238c77a7 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1069,6 +1069,12 @@ class Query(BaseExpression):\n             sql = '(%s)' % sql\n         return sql, params\n \n+    def resolve_lookup_value(self, value, can_reuse, allow_joins):\n+        if hasattr(value, 'resolve_expression'):\n+            value = value.resolve_expression(\n+                self, reuse=can_reuse, allow_joins=allow_joins,\n+            )\n+\n     def resolve_lookup_value(self, value, can_reuse, allow_joins):\n         if hasattr(value, 'resolve_expression'):\n             value = value.resolve_expression(\n@@ -1077,10 +1083,16 @@ class Query(BaseExpression):\n         elif isinstance(value, (list, tuple)):\n             # The items of the iterable may be expressions and therefore need\n             # to be resolved independently.\n-            return type(value)(\n+            resolved_values = (\n                 self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n                 for sub_value in value\n             )\n+            # Handle named tuples which require positional arguments\n+            if hasattr(value, '_fields'):\n+                return type(value)(*resolved_values)\n+            else:\n+                return type(value)(resolved_values)\n+        return value\n         return value\n \n     def solve_lookup_type(self, lookup):\n",
    "variant_8": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 4648daf395..19238c77a7 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1069,6 +1069,12 @@ class Query(BaseExpression):\n             sql = '(%s)' % sql\n         return sql, params\n \n+    def resolve_lookup_value(self, value, can_reuse, allow_joins):\n+        if hasattr(value, 'resolve_expression'):\n+            value = value.resolve_expression(\n+                self, reuse=can_reuse, allow_joins=allow_joins,\n+            )\n+\n     def resolve_lookup_value(self, value, can_reuse, allow_joins):\n         if hasattr(value, 'resolve_expression'):\n             value = value.resolve_expression(\n@@ -1077,10 +1083,16 @@ class Query(BaseExpression):\n         elif isinstance(value, (list, tuple)):\n             # The items of the iterable may be expressions and therefore need\n             # to be resolved independently.\n-            return type(value)(\n+            resolved_values = (\n                 self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n                 for sub_value in value\n             )\n+            # Handle named tuples which require positional arguments\n+            if hasattr(value, '_fields'):\n+                return type(value)(*resolved_values)\n+            else:\n+                return type(value)(resolved_values)\n+        return value\n         return value\n \n     def solve_lookup_type(self, lookup):\n"
  }
}