{
  "zero_patches": {
    "Location 1 (/root/hy/projects/astropy/astropy/coordinates/sky_coordinate.py lines 898-900)": "\n        # Fail\n        # Check if we're in a property access by inspecting the call stack\n        import inspect\n        frame = inspect.currentframe()\n        try:\n            # Look for property access in the call stack\n            caller_frame = frame.f_back\n            if caller_frame and caller_frame.f_code.co_name.startswith('fget'):\n                # We're likely in a property getter, preserve the original attribute name\n                raise AttributeError(\n                    f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n                )\n            else:\n                # Normal attribute access\n                raise AttributeError(\n                    f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n                )\n        finally:\n            del frame\n",
    "Location 2 (/root/hy/projects/astropy/astropy/coordinates/sky_coordinate.py lines 869-900)": "\n    def __getattr__(self, attr):\n        \"\"\"\n        Overrides getattr to return coordinates that this can be transformed\n        to, based on the alias attr in the primary transform graph.\n        \"\"\"\n        if \"_sky_coord_frame\" in self.__dict__:\n            if self._is_name(attr):\n                return self  # Should this be a deepcopy of self?\n\n            # Anything in the set of all possible frame_attr_names is handled\n            # here. If the attr is relevant for the current frame then delegate\n            # to self.frame otherwise get it from self._<attr>.\n            if attr in frame_transform_graph.frame_attributes:\n                if attr in self.frame.frame_attributes:\n                    return getattr(self.frame, attr)\n                else:\n                    return getattr(self, \"_\" + attr, None)\n\n            # Some attributes might not fall in the above category but still\n            # are available through self._sky_coord_frame.\n            if not attr.startswith(\"_\") and hasattr(self._sky_coord_frame, attr):\n                return getattr(self._sky_coord_frame, attr)\n\n            # Try to interpret as a new frame for transforming.\n            frame_cls = frame_transform_graph.lookup_name(attr)\n            if frame_cls is not None and self.frame.is_transformable_to(frame_cls):\n                return self.transform_to(attr)\n\n        # Fail - check if we're being called from within a property\n        import sys\n        frame = sys._getframe(1)\n        if frame.f_code.co_name == '<lambda>' or (\n            hasattr(self.__class__, frame.f_code.co_name) and \n            isinstance(getattr(self.__class__, frame.f_code.co_name), property)\n        ):\n            # We're being called from a property, preserve the original attribute name\n            raise AttributeError(\n                f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n            )\n        else:\n            # Normal attribute access\n            raise AttributeError(\n                f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n            )\n",
    "Location 3 (/root/hy/projects/astropy/astropy/coordinates/tests/test_sky_coord.py lines 2160-2167)": "\ndef test_skycoord_subclass_property_error_message():\n    \"\"\"Test that error messages from subclass properties show the correct attribute name.\"\"\"\n    \n    class CustomSkyCoord(SkyCoord):\n        @property\n        def custom_property(self):\n            # This should raise an AttributeError for 'nonexistent_attr', not 'custom_property'\n            return self.nonexistent_attr\n    \n    c = CustomSkyCoord(ra=1*u.deg, dec=2*u.deg)\n    \n    # Test that accessing the property gives the correct error message\n    with pytest.raises(AttributeError) as excinfo:\n        c.custom_property\n    \n    # The error should mention 'nonexistent_attr', not 'custom_property'\n    assert 'nonexistent_attr' in str(excinfo.value)\n    assert 'custom_property' not in str(excinfo.value) or 'nonexistent_attr' in str(excinfo.value)\n\n\ndef test_match_to_catalog_cross_frame():\n    # Test for issue #5857. See PR #11449\n    cfk5_default = SkyCoord(\n        [1, 2, 3, 4] * u.degree,\n        [0, 0, 0, 0] * u.degree,\n        distance=[1, 1, 1.5, 1] * u.kpc,\n        frame=\"fk5\",\n    )\n    cfk5_J1950 = cfk5_default.transform_to(FK5(equinox=\"J1950\"))\n\n    idx, angle, quantity = cfk5_J1950.match_to_catalog_3d(cfk5_default)\n    npt.assert_array_equal(idx, [0, 1, 2, 3])\n    assert_allclose(angle, 0 * u.deg, atol=1e-14 * u.deg, rtol=0)\n    assert_allclose(quantity, 0 * u.kpc, atol=1e-14 * u.kpc, rtol=0)\n\n    idx, angle, distance = cfk5_J1950.match_to_catalog_sky(cfk5_default)\n    npt.assert_array_equal(idx, [0, 1, 2, 3])\n    assert_allclose(angle, 0 * u.deg, atol=1e-14 * u.deg, rtol=0)\n    assert_allclose(distance, 0 * u.kpc, atol=1e-14 * u.kpc, rtol=0)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/astropy/astropy/coordinates/sky_coordinate.py lines 898-900)": [
      "\n        # Fail\n        # Check if we're being called from within a property to provide better error messages\n        import inspect\n        frame = inspect.currentframe()\n        try:\n            # Look for property access in the call stack\n            caller_frame = frame.f_back\n            while caller_frame:\n                if caller_frame.f_code.co_name == '__get__':\n                    # We're being called from a property descriptor\n                    # Get the property name from the caller's caller\n                    prop_caller = caller_frame.f_back\n                    if prop_caller and hasattr(prop_caller.f_locals.get('self'), attr):\n                        # The original attribute error should be preserved\n                        break\n                caller_frame = caller_frame.f_back\n        finally:\n            del frame\n        \n        raise AttributeError(\n            f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n        )\n",
      "\n        # Fail\n        # Check if we're being called from within a property to provide better error context\n        import inspect\n        frame = inspect.currentframe()\n        try:\n            # Look up the call stack to see if we're in a property\n            caller_frame = frame.f_back\n            if caller_frame and caller_frame.f_code.co_name.startswith('<') and caller_frame.f_code.co_name.endswith('>'):\n                # We might be in a property getter, check the next frame up\n                property_frame = caller_frame.f_back\n                if property_frame:\n                    # Get the local variables from the property frame to see if 'self' matches\n                    property_locals = property_frame.f_locals\n                    if 'self' in property_locals and property_locals['self'] is self:\n                        # We're definitely in a property of this object\n                        raise AttributeError(\n                            f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n                        )\n        finally:\n            del frame\n            \n        raise AttributeError(\n            f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n        )\n",
      "\n        # Fail\n        import inspect\n        \n        # Check if we're being called from within a property\n        frame = inspect.currentframe()\n        calling_frame = frame.f_back\n        \n        # Look for property access in the call stack\n        original_attr = attr\n        while calling_frame:\n            code = calling_frame.f_code\n            if (code.co_name.startswith('__get') or \n                (hasattr(calling_frame.f_locals.get('self', None), '__class__') and\n                 any(isinstance(getattr(calling_frame.f_locals['self'].__class__, name, None), property)\n                     for name in dir(calling_frame.f_locals['self'].__class__)\n                     if not name.startswith('_')))):\n                # We're likely in a property, keep the original attribute name\n                break\n            calling_frame = calling_frame.f_back\n        \n        raise AttributeError(\n            f\"'{self.__class__.__name__}' object has no attribute '{original_attr}'\"\n        )\n",
      "\n        # Fail\n        import traceback\n        import sys\n        \n        # Check if we're being called from within a property\n        frame = sys._getframe(1)\n        if frame and frame.f_code.co_name.startswith('__get__'):\n            # We're likely in a property getter, look for the property name\n            property_frame = frame\n            while property_frame:\n                if hasattr(property_frame.f_locals.get('self', {}), '__class__'):\n                    obj = property_frame.f_locals['self']\n                    # Look for properties in the class hierarchy\n                    for cls in obj.__class__.__mro__:\n                        for name, value in cls.__dict__.items():\n                            if isinstance(value, property) and value.fget and value.fget.__code__ is property_frame.f_code:\n                                raise AttributeError(\n                                    f\"'{self.__class__.__name__}' object has no attribute '{attr}' \"\n                                    f\"(accessed via property '{name}')\"\n                                )\n                property_frame = property_frame.f_back\n        \n        raise AttributeError(\n            f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n        )\n",
      "\n        # Fail\n        import inspect\n        \n        # Check if we're being called from within a property\n        frame = inspect.currentframe()\n        try:\n            caller_frame = frame.f_back\n            if caller_frame and caller_frame.f_code.co_name.startswith('<lambda>'):\n                # Skip lambda frames (often used in properties)\n                caller_frame = caller_frame.f_back\n            \n            # Look for property access in the call stack\n            original_attr = attr\n            while caller_frame:\n                if (hasattr(caller_frame.f_locals.get('self', None), '__class__') and \n                    caller_frame.f_code.co_name in dir(caller_frame.f_locals.get('self', None).__class__)):\n                    # We're in a method/property of the same class\n                    prop_name = caller_frame.f_code.co_name\n                    if hasattr(type(caller_frame.f_locals['self']), prop_name):\n                        prop_obj = getattr(type(caller_frame.f_locals['self']), prop_name)\n                        if isinstance(prop_obj, property):\n                            # We're being called from within a property\n                            raise AttributeError(\n                                f\"'{self.__class__.__name__}' object has no attribute '{original_attr}' \"\n                                f\"(accessed from property '{prop_name}')\"\n                            )\n                caller_frame = caller_frame.f_back\n        finally:\n            del frame\n        \n        raise AttributeError(\n            f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n        )\n",
      "\n        # Fail\n        # Check if we're in a property access chain by examining the call stack\n        import inspect\n        frame = inspect.currentframe()\n        try:\n            # Look for property access in the call stack\n            caller_frame = frame.f_back\n            while caller_frame:\n                caller_code = caller_frame.f_code\n                # Check if we're being called from a property getter\n                if (caller_code.co_name in dir(self.__class__) and \n                    hasattr(getattr(self.__class__, caller_code.co_name, None), '__get__')):\n                    # We're in a property, so the original attribute error is more informative\n                    raise AttributeError(\n                        f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n                    )\n                caller_frame = caller_frame.f_back\n        finally:\n            del frame\n        \n        raise AttributeError(\n            f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n        )\n",
      "\n        # Fail\n        import inspect\n        \n        # Check if we're being called from within a property\n        frame = inspect.currentframe()\n        try:\n            caller_frame = frame.f_back\n            if caller_frame and caller_frame.f_code.co_name.startswith('<'):\n                # We're likely in a property or descriptor\n                caller_locals = caller_frame.f_locals\n                if 'self' in caller_locals and hasattr(caller_locals['self'].__class__, caller_frame.f_code.co_name.strip('<>')):\n                    # This is a property access, preserve the original attribute name\n                    raise AttributeError(\n                        f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n                    )\n        finally:\n            del frame\n            \n        raise AttributeError(\n            f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n        )\n",
      "\n        # Fail\n        import inspect\n        \n        # Check if we're being called from within a property\n        frame = inspect.currentframe()\n        calling_frame = frame.f_back\n        \n        # Look for property access in the call stack\n        original_attr = attr\n        while calling_frame:\n            code = calling_frame.f_code\n            if (code.co_name == '__get__' and \n                'property' in str(calling_frame.f_locals.get('self', ''))):\n                # We're in a property getter, look for the original attribute name\n                outer_frame = calling_frame.f_back\n                if outer_frame and hasattr(outer_frame, 'f_locals'):\n                    # Try to find the original attribute being accessed\n                    if 'attr' in outer_frame.f_locals:\n                        original_attr = outer_frame.f_locals['attr']\n                break\n            calling_frame = calling_frame.f_back\n        \n        raise AttributeError(\n            f\"'{self.__class__.__name__}' object has no attribute '{original_attr}'\"\n        )\n"
    ],
    "Location 2 (/root/hy/projects/astropy/astropy/coordinates/sky_coordinate.py lines 869-900)": [
      "\n    def __getattr__(self, attr):\n        \"\"\"\n        Overrides getattr to return coordinates that this can be transformed\n        to, based on the alias attr in the primary transform graph.\n        \"\"\"\n        if \"_sky_coord_frame\" in self.__dict__:\n            if self._is_name(attr):\n                return self  # Should this be a deepcopy of self?\n\n            # Anything in the set of all possible frame_attr_names is handled\n            # here. If the attr is relevant for the current frame then delegate\n            # to self.frame otherwise get it from self._<attr>.\n            if attr in frame_transform_graph.frame_attributes:\n                if attr in self.frame.frame_attributes:\n                    return getattr(self.frame, attr)\n                else:\n                    return getattr(self, \"_\" + attr, None)\n\n            # Some attributes might not fall in the above category but still\n            # are available through self._sky_coord_frame.\n            if not attr.startswith(\"_\") and hasattr(self._sky_coord_frame, attr):\n                return getattr(self._sky_coord_frame, attr)\n\n            # Try to interpret as a new frame for transforming.\n            frame_cls = frame_transform_graph.lookup_name(attr)\n            if frame_cls is not None and self.frame.is_transformable_to(frame_cls):\n                return self.transform_to(attr)\n\n        # Check if we're being called from within a property by examining the call stack\n        import inspect\n        frame = inspect.currentframe()\n        try:\n            # Look for property access in the call stack\n            caller_frame = frame.f_back\n            while caller_frame:\n                code = caller_frame.f_code\n                # Check if the caller is a property getter\n                if (hasattr(caller_frame.f_locals.get('self', None), '__class__') and\n                    any(isinstance(getattr(caller_frame.f_locals['self'].__class__, name, None), property)\n                        for name in dir(caller_frame.f_locals['self'].__class__)\n                        if not name.startswith('_'))):\n                    # We're likely in a property, preserve the original attribute error\n                    break\n                caller_frame = caller_frame.f_back\n        finally:\n            del frame\n\n        # Fail\n        raise AttributeError(\n            f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n        )\n",
      "\n    def __getattr__(self, attr):\n        \"\"\"\n        Overrides getattr to return coordinates that this can be transformed\n        to, based on the alias attr in the primary transform graph.\n        \"\"\"\n        if \"_sky_coord_frame\" in self.__dict__:\n            if self._is_name(attr):\n                return self  # Should this be a deepcopy of self?\n\n            # Anything in the set of all possible frame_attr_names is handled\n            # here. If the attr is relevant for the current frame then delegate\n            # to self.frame otherwise get it from self._<attr>.\n            if attr in frame_transform_graph.frame_attributes:\n                if attr in self.frame.frame_attributes:\n                    return getattr(self.frame, attr)\n                else:\n                    return getattr(self, \"_\" + attr, None)\n\n            # Some attributes might not fall in the above category but still\n            # are available through self._sky_coord_frame.\n            if not attr.startswith(\"_\") and hasattr(self._sky_coord_frame, attr):\n                return getattr(self._sky_coord_frame, attr)\n\n            # Try to interpret as a new frame for transforming.\n            frame_cls = frame_transform_graph.lookup_name(attr)\n            if frame_cls is not None and self.frame.is_transformable_to(frame_cls):\n                return self.transform_to(attr)\n\n        # Check if we're being called from a property by inspecting the call stack\n        import inspect\n        frame = inspect.currentframe()\n        try:\n            # Look for property access in the call stack\n            caller_frame = frame.f_back\n            if caller_frame and caller_frame.f_code.co_name.startswith('__get__'):\n                # We're likely being called from a property getter\n                property_name = None\n                # Look further up the stack for the actual property name\n                check_frame = caller_frame.f_back\n                while check_frame:\n                    if hasattr(check_frame.f_locals.get('self'), '__class__'):\n                        # Check if any attribute in the class is a property that might be calling us\n                        for name, obj in check_frame.f_locals.get('self').__class__.__dict__.items():\n                            if isinstance(obj, property):\n                                # This is a heuristic - we found a property, assume it's the one\n                                property_name = name\n                                break\n                        if property_name:\n                            break\n                    check_frame = check_frame.f_back\n                \n                if property_name:\n                    raise AttributeError(\n                        f\"'{self.__class__.__name__}' object has no attribute '{attr}' \"\n                        f\"(accessed from property '{property_name}')\"\n                    )\n        finally:\n            del frame\n\n        # Fail with original error message\n        raise AttributeError(\n            f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n        )\n",
      "\n    def __getattr__(self, attr):\n        \"\"\"\n        Overrides getattr to return coordinates that this can be transformed\n        to, based on the alias attr in the primary transform graph.\n        \"\"\"\n        if \"_sky_coord_frame\" in self.__dict__:\n            if self._is_name(attr):\n                return self  # Should this be a deepcopy of self?\n\n            # Anything in the set of all possible frame_attr_names is handled\n            # here. If the attr is relevant for the current frame then delegate\n            # to self.frame otherwise get it from self._<attr>.\n            if attr in frame_transform_graph.frame_attributes:\n                if attr in self.frame.frame_attributes:\n                    return getattr(self.frame, attr)\n                else:\n                    return getattr(self, \"_\" + attr, None)\n\n            # Some attributes might not fall in the above category but still\n            # are available through self._sky_coord_frame.\n            if not attr.startswith(\"_\") and hasattr(self._sky_coord_frame, attr):\n                return getattr(self._sky_coord_frame, attr)\n\n            # Try to interpret as a new frame for transforming.\n            frame_cls = frame_transform_graph.lookup_name(attr)\n            if frame_cls is not None and self.frame.is_transformable_to(frame_cls):\n                return self.transform_to(attr)\n\n        # Check if we're being called from within a property by examining the call stack\n        import inspect\n        frame = inspect.currentframe()\n        try:\n            # Look at the calling frame to see if it's a property\n            caller_frame = frame.f_back\n            if caller_frame and caller_frame.f_code.co_name != attr:\n                # We're likely being called from within a property or method\n                # The actual missing attribute is 'attr', not the property name\n                caller_name = caller_frame.f_code.co_name\n                # Check if the caller appears to be a property (common property patterns)\n                caller_locals = caller_frame.f_locals\n                if 'self' in caller_locals and hasattr(caller_locals['self'].__class__, caller_name):\n                    class_attr = getattr(caller_locals['self'].__class__, caller_name, None)\n                    if isinstance(class_attr, property):\n                        # We're being called from within a property, preserve the actual missing attr\n                        raise AttributeError(\n                            f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n                        )\n        finally:\n            del frame\n        \n        # Fail with the original attribute name\n        raise AttributeError(\n            f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n        )\n",
      "\n    def __getattr__(self, attr):\n        \"\"\"\n        Overrides getattr to return coordinates that this can be transformed\n        to, based on the alias attr in the primary transform graph.\n        \"\"\"\n        if \"_sky_coord_frame\" in self.__dict__:\n            if self._is_name(attr):\n                return self  # Should this be a deepcopy of self?\n\n            # Anything in the set of all possible frame_attr_names is handled\n            # here. If the attr is relevant for the current frame then delegate\n            # to self.frame otherwise get it from self._<attr>.\n            if attr in frame_transform_graph.frame_attributes:\n                if attr in self.frame.frame_attributes:\n                    return getattr(self.frame, attr)\n                else:\n                    return getattr(self, \"_\" + attr, None)\n\n            # Some attributes might not fall in the above category but still\n            # are available through self._sky_coord_frame.\n            if not attr.startswith(\"_\") and hasattr(self._sky_coord_frame, attr):\n                return getattr(self._sky_coord_frame, attr)\n\n            # Try to interpret as a new frame for transforming.\n            frame_cls = frame_transform_graph.lookup_name(attr)\n            if frame_cls is not None and self.frame.is_transformable_to(frame_cls):\n                return self.transform_to(attr)\n\n        # Check if we're being called from a property by examining the call stack\n        import inspect\n        frame = inspect.currentframe()\n        try:\n            # Look for a property in the call stack\n            caller_frame = frame.f_back\n            while caller_frame:\n                caller_locals = caller_frame.f_locals\n                caller_code = caller_frame.f_code\n                \n                # Check if we're in a property getter\n                if (caller_code.co_name.startswith('__get') or \n                    (caller_locals.get('self') is self and \n                     hasattr(type(self), caller_code.co_name) and\n                     isinstance(getattr(type(self), caller_code.co_name, None), property))):\n                    # We're being called from a property, preserve the original attribute name\n                    raise AttributeError(\n                        f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n                    )\n                caller_frame = caller_frame.f_back\n        finally:\n            del frame\n\n        # Fail\n        raise AttributeError(\n            f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n        )\n",
      "\n    def __getattr__(self, attr):\n        \"\"\"\n        Overrides getattr to return coordinates that this can be transformed\n        to, based on the alias attr in the primary transform graph.\n        \"\"\"\n        if \"_sky_coord_frame\" in self.__dict__:\n            if self._is_name(attr):\n                return self  # Should this be a deepcopy of self?\n\n            # Anything in the set of all possible frame_attr_names is handled\n            # here. If the attr is relevant for the current frame then delegate\n            # to self.frame otherwise get it from self._<attr>.\n            if attr in frame_transform_graph.frame_attributes:\n                if attr in self.frame.frame_attributes:\n                    return getattr(self.frame, attr)\n                else:\n                    return getattr(self, \"_\" + attr, None)\n\n            # Some attributes might not fall in the above category but still\n            # are available through self._sky_coord_frame.\n            if not attr.startswith(\"_\") and hasattr(self._sky_coord_frame, attr):\n                return getattr(self._sky_coord_frame, attr)\n\n            # Try to interpret as a new frame for transforming.\n            frame_cls = frame_transform_graph.lookup_name(attr)\n            if frame_cls is not None and self.frame.is_transformable_to(frame_cls):\n                return self.transform_to(attr)\n\n        # Fail - check if we're being called from a property to preserve context\n        import inspect\n        frame = inspect.currentframe()\n        try:\n            # Look for a property in the call stack\n            caller_frame = frame.f_back\n            while caller_frame:\n                caller_locals = caller_frame.f_locals\n                # Check if we're inside a property getter\n                if (caller_frame.f_code.co_name.startswith('__get__') or \n                    (caller_locals.get('self') is self and \n                     hasattr(type(self), caller_frame.f_code.co_name) and\n                     isinstance(getattr(type(self), caller_frame.f_code.co_name), property))):\n                    # We're in a property, use the original attribute name\n                    raise AttributeError(\n                        f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n                    )\n                caller_frame = caller_frame.f_back\n        finally:\n            del frame\n            \n        raise AttributeError(\n            f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n        )\n",
      "\n    def __getattr__(self, attr):\n        \"\"\"\n        Overrides getattr to return coordinates that this can be transformed\n        to, based on the alias attr in the primary transform graph.\n        \"\"\"\n        if \"_sky_coord_frame\" in self.__dict__:\n            if self._is_name(attr):\n                return self  # Should this be a deepcopy of self?\n\n            # Anything in the set of all possible frame_attr_names is handled\n            # here. If the attr is relevant for the current frame then delegate\n            # to self.frame otherwise get it from self._<attr>.\n            if attr in frame_transform_graph.frame_attributes:\n                if attr in self.frame.frame_attributes:\n                    return getattr(self.frame, attr)\n                else:\n                    return getattr(self, \"_\" + attr, None)\n\n            # Some attributes might not fall in the above category but still\n            # are available through self._sky_coord_frame.\n            if not attr.startswith(\"_\") and hasattr(self._sky_coord_frame, attr):\n                return getattr(self._sky_coord_frame, attr)\n\n            # Try to interpret as a new frame for transforming.\n            frame_cls = frame_transform_graph.lookup_name(attr)\n            if frame_cls is not None and self.frame.is_transformable_to(frame_cls):\n                return self.transform_to(attr)\n\n        # Check if we're being called from within a property\n        import inspect\n        frame = inspect.currentframe()\n        try:\n            # Look through the call stack to see if we're in a property\n            caller_frame = frame.f_back\n            while caller_frame:\n                code = caller_frame.f_code\n                # Check if this frame is a property getter\n                if (code.co_name.startswith('__get__') or \n                    (hasattr(self.__class__, code.co_name) and \n                     isinstance(getattr(self.__class__, code.co_name, None), property))):\n                    # We're being called from within a property, use the original attribute name\n                    raise AttributeError(\n                        f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n                    )\n                caller_frame = caller_frame.f_back\n        finally:\n            del frame\n        \n        # Fail with standard message\n        raise AttributeError(\n            f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n        )\n",
      "\n    def __getattr__(self, attr):\n        \"\"\"\n        Overrides getattr to return coordinates that this can be transformed\n        to, based on the alias attr in the primary transform graph.\n        \"\"\"\n        if \"_sky_coord_frame\" in self.__dict__:\n            if self._is_name(attr):\n                return self  # Should this be a deepcopy of self?\n\n            # Anything in the set of all possible frame_attr_names is handled\n            # here. If the attr is relevant for the current frame then delegate\n            # to self.frame otherwise get it from self._<attr>.\n            if attr in frame_transform_graph.frame_attributes:\n                if attr in self.frame.frame_attributes:\n                    return getattr(self.frame, attr)\n                else:\n                    return getattr(self, \"_\" + attr, None)\n\n            # Some attributes might not fall in the above category but still\n            # are available through self._sky_coord_frame.\n            if not attr.startswith(\"_\") and hasattr(self._sky_coord_frame, attr):\n                return getattr(self._sky_coord_frame, attr)\n\n            # Try to interpret as a new frame for transforming.\n            frame_cls = frame_transform_graph.lookup_name(attr)\n            if frame_cls is not None and self.frame.is_transformable_to(frame_cls):\n                return self.transform_to(attr)\n\n        # Check if we're being called from a property by examining the call stack\n        import inspect\n        frame = inspect.currentframe()\n        try:\n            # Look up the call stack to see if we're in a property\n            caller_frame = frame.f_back\n            if caller_frame and caller_frame.f_code.co_name == '<lambda>':\n                # This might be a property getter, check further up\n                caller_frame = caller_frame.f_back\n                if (caller_frame and \n                    hasattr(caller_frame.f_locals.get('self', None), '__class__') and\n                    caller_frame.f_code.co_name in dir(caller_frame.f_locals['self'].__class__)):\n                    \n                    # We're likely in a property, check if it's actually a property\n                    prop_name = caller_frame.f_code.co_name\n                    cls = caller_frame.f_locals['self'].__class__\n                    if hasattr(cls, prop_name) and isinstance(getattr(cls, prop_name), property):\n                        # We're in a property, provide a more informative error\n                        raise AttributeError(\n                            f\"'{self.__class__.__name__}' object has no attribute '{attr}'. \"\n                            f\"This AttributeError was raised while accessing the '{prop_name}' property.\"\n                        )\n        finally:\n            del frame\n\n        # Fail\n        raise AttributeError(\n            f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n        )\n",
      "\ndef __getattr__(self, attr):\n    \"\"\"\n    Overrides getattr to return coordinates that this can be transformed\n    to, based on the alias attr in the primary transform graph.\n    \"\"\"\n    if \"_sky_coord_frame\" in self.__dict__:\n        if self._is_name(attr):\n            return self  # Should this be a deepcopy of self?\n\n        # Anything in the set of all possible frame_attr_names is handled\n        # here. If the attr is relevant for the current frame then delegate\n        # to self.frame otherwise get it from self._<attr>.\n        if attr in frame_transform_graph.frame_attributes:\n            if attr in self.frame.frame_attributes:\n                return getattr(self.frame, attr)\n            else:\n                return getattr(self, \"_\" + attr, None)\n\n        # Some attributes might not fall in the above category but still\n        # are available through self._sky_coord_frame.\n        if not attr.startswith(\"_\") and hasattr(self._sky_coord_frame, attr):\n            return getattr(self._sky_coord_frame, attr)\n\n        # Try to interpret as a new frame for transforming.\n        frame_cls = frame_transform_graph.lookup_name(attr)\n        if frame_cls is not None and self.frame.is_transformable_to(frame_cls):\n            return self.transform_to(attr)\n\n    # Fail\n    raise AttributeError(\n        f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n    )\n"
    ],
    "Location 3 (/root/hy/projects/astropy/astropy/coordinates/tests/test_sky_coord.py lines 2160-2167)": [
      "\ndef test_skycoord_subclass_property_error_message():\n    \"\"\"Test that error messages from properties show the actual missing attribute.\"\"\"\n    \n    class TestSkyCoord(SkyCoord):\n        @property\n        def prop(self):\n            # This should raise AttributeError for 'random_attr', not 'prop'\n            return self.random_attr\n    \n    c = TestSkyCoord([1, 2] * u.deg, [3, 4] * u.deg)\n    \n    # Test that the error message mentions 'random_attr', not 'prop'\n    with pytest.raises(AttributeError, match=\"'TestSkyCoord' object has no attribute 'random_attr'\"):\n        c.prop\n    \n    # Also test direct attribute access still works as expected\n    with pytest.raises(AttributeError, match=\"'TestSkyCoord' object has no attribute 'nonexistent'\"):\n        c.nonexistent\n",
      "\ndef test_skycoord_subclass_property_error_message():\n    \"\"\"Test that error messages from subclass properties correctly identify missing attributes.\"\"\"\n    \n    class CustomSkyCoord(SkyCoord):\n        @property\n        def custom_prop(self):\n            # This should raise AttributeError for 'nonexistent_attr', not 'custom_prop'\n            return self.nonexistent_attr\n    \n    coord = CustomSkyCoord(ra=1*u.deg, dec=2*u.deg)\n    \n    with pytest.raises(AttributeError) as excinfo:\n        _ = coord.custom_prop\n    \n    # The error should mention the actual missing attribute, not the property name\n    assert \"nonexistent_attr\" in str(excinfo.value)\n    assert \"custom_prop\" not in str(excinfo.value)\n",
      "\ndef test_skycoord_subclass_property_error_message():\n    \"\"\"Test that error messages from SkyCoord subclass properties show the actual missing attribute.\"\"\"\n    \n    class MySkyCoord(SkyCoord):\n        @property\n        def prop(self):\n            return self.random_attr  # This attribute doesn't exist\n    \n    c = MySkyCoord(1 * u.deg, 2 * u.deg)\n    \n    # Test that the error message mentions 'random_attr', not 'prop'\n    with pytest.raises(AttributeError, match=r\"'MySkyCoord' object has no attribute 'random_attr'\"):\n        _ = c.prop\n    \n    # Also test that accessing a non-existent property directly still works as expected\n    with pytest.raises(AttributeError, match=r\"'MySkyCoord' object has no attribute 'nonexistent'\"):\n        _ = c.nonexistent\n\n\ndef test_transform_to_match_catalog():\n    # Test for issue #5857. See PR #11449\n    cfk5_default = SkyCoord(\n        [1, 2, 3, 4] * u.degree,\n        [0, 0, 0, 0] * u.degree,\n        distance=[1, 1, 1.5, 1] * u.kpc,\n        frame=\"fk5\",\n    )\n    cfk5_J1950 = cfk5_default.transform_to(FK5(equinox=\"J1950\"))\n\n    idx, angle, quantity = cfk5_J1950.match_to_catalog_3d(cfk5_default)\n    npt.assert_array_equal(idx, [0, 1, 2, 3])\n    assert_allclose(angle, 0 * u.deg, atol=1e-14 * u.deg, rtol=0)\n    assert_allclose(quantity, 0 * u.kpc, atol=1e-14 * u.kpc, rtol=0)\n\n    idx, angle, distance = cfk5_J1950.match_to_catalog_sky(cfk5_default)\n    npt.assert_array_equal(idx, [0, 1, 2, 3])\n    assert_allclose(angle, 0 * u.deg, atol=1e-14 * u.deg, rtol=0)\n    assert_allclose(distance, 0 * u.kpc, atol=1e-14 * u.kpc, rtol=0)\n",
      "\ndef test_skycoord_subclass_property_error_message():\n    \"\"\"Test that error messages from properties show the actual missing attribute.\"\"\"\n    \n    class CustomSkyCoord(SkyCoord):\n        @property \n        def prop(self):\n            return self.random_attr\n    \n    c = CustomSkyCoord(1 * u.deg, 2 * u.deg)\n    \n    # The error should mention 'random_attr', not 'prop'\n    with pytest.raises(AttributeError, match=\"'CustomSkyCoord' object has no attribute 'random_attr'\"):\n        c.prop\n    \n    # Verify that accessing a truly non-existent property still works correctly\n    with pytest.raises(AttributeError, match=\"'CustomSkyCoord' object has no attribute 'truly_missing'\"):\n        c.truly_missing\n\n    idx, angle, quantity = cfk5_J1950.match_to_catalog_3d(cfk5_default)\n    npt.assert_array_equal(idx, [0, 1, 2, 3])\n    assert_allclose(angle, 0 * u.deg, atol=1e-14 * u.deg, rtol=0)\n    assert_allclose(quantity, 0 * u.kpc, atol=1e-14 * u.kpc, rtol=0)\n\n    idx, angle, distance = cfk5_J1950.match_to_catalog_sky(cfk5_default)\n    npt.assert_array_equal(idx, [0, 1, 2, 3])\n    assert_allclose(angle, 0 * u.deg, atol=1e-14 * u.deg, rtol=0)\n    assert_allclose(distance, 0 * u.kpc, atol=1e-14 * u.kpc, rtol=0)\n",
      "\ndef test_skycoord_subclass_property_error_message():\n    \"\"\"\n    Test that error messages for missing attributes in SkyCoord subclass properties\n    correctly identify the missing attribute, not the property itself.\n    \"\"\"\n    class TestSkyCoord(SkyCoord):\n        @property\n        def prop(self):\n            return self.random_attr  # This attribute doesn't exist\n    \n    c = TestSkyCoord([1, 2] * u.deg, [3, 4] * u.deg)\n    \n    # The error message should mention 'random_attr', not 'prop'\n    with pytest.raises(AttributeError, match=\"'TestSkyCoord' object has no attribute 'random_attr'\"):\n        c.prop\n",
      "\ndef test_skycoord_subclass_property_error_message():\n    \"\"\"Test that error messages for missing attributes in properties are accurate.\"\"\"\n    \n    class TestSkyCoord(SkyCoord):\n        @property\n        def prop(self):\n            # This should raise AttributeError about 'random_attr', not 'prop'\n            return self.random_attr\n    \n    c = TestSkyCoord(ra=1*u.deg, dec=2*u.deg)\n    \n    # Test that the error message mentions the actual missing attribute\n    with pytest.raises(AttributeError) as excinfo:\n        c.prop\n    \n    # The error should mention 'random_attr', not 'prop'\n    assert 'random_attr' in str(excinfo.value)\n    assert 'prop' not in str(excinfo.value) or 'has no attribute' not in str(excinfo.value)\n\n\ndef test_match_to_catalog_fk5():\n    # Test for issue #5857. See PR #11449\n    cfk5_default = SkyCoord(\n        [1, 2, 3, 4] * u.degree,\n        [0, 0, 0, 0] * u.degree,\n        distance=[1, 1, 1.5, 1] * u.kpc,\n        frame=\"fk5\",\n    )\n    cfk5_J1950 = cfk5_default.transform_to(FK5(equinox=\"J1950\"))\n\n    idx, angle, quantity = cfk5_J1950.match_to_catalog_3d(cfk5_default)\n    npt.assert_array_equal(idx, [0, 1, 2, 3])\n    assert_allclose(angle, 0 * u.deg, atol=1e-14 * u.deg, rtol=0)\n    assert_allclose(quantity, 0 * u.kpc, atol=1e-14 * u.kpc, rtol=0)\n\n    idx, angle, distance = cfk5_J1950.match_to_catalog_sky(cfk5_default)\n    npt.assert_array_equal(idx, [0, 1, 2, 3])\n    assert_allclose(angle, 0 * u.deg, atol=1e-14 * u.deg, rtol=0)\n    assert_allclose(distance, 0 * u.kpc, atol=1e-14 * u.kpc, rtol=0)\n",
      "\ndef test_skycoord_subclass_property_error_message():\n    \"\"\"Test that error messages from properties correctly identify the missing attribute.\"\"\"\n    \n    class TestSkyCoord(SkyCoord):\n        @property\n        def prop(self):\n            return self.nonexistent_attr\n    \n    c = TestSkyCoord(1*u.deg, 2*u.deg)\n    \n    # The error should mention 'nonexistent_attr', not 'prop'\n    with pytest.raises(AttributeError) as excinfo:\n        c.prop\n    \n    error_msg = str(excinfo.value)\n    assert 'nonexistent_attr' in error_msg\n    assert \"'TestSkyCoord' object has no attribute 'nonexistent_attr'\" in error_msg\n\n    idx, angle, quantity = cfk5_J1950.match_to_catalog_3d(cfk5_default)\n    npt.assert_array_equal(idx, [0, 1, 2, 3])\n    assert_allclose(angle, 0 * u.deg, atol=1e-14 * u.deg, rtol=0)\n    assert_allclose(quantity, 0 * u.kpc, atol=1e-14 * u.kpc, rtol=0)\n\n    idx, angle, distance = cfk5_J1950.match_to_catalog_sky(cfk5_default)\n    npt.assert_array_equal(idx, [0, 1, 2, 3])\n    assert_allclose(angle, 0 * u.deg, atol=1e-14 * u.deg, rtol=0)\n    assert_allclose(distance, 0 * u.kpc, atol=1e-14 * u.kpc, rtol=0)\n",
      "\ndef test_skycoord_subclass_property_attribute_error():\n    \"\"\"Test that AttributeError from property accessing non-existent attribute is preserved.\"\"\"\n    \n    class CustomSkyCoord(SkyCoord):\n        @property\n        def prop(self):\n            return self.random_attr  # This attribute doesn't exist\n    \n    c = CustomSkyCoord([1, 2] * u.deg, [3, 4] * u.deg)\n    \n    # Should raise AttributeError mentioning 'random_attr', not 'prop'\n    with pytest.raises(AttributeError, match=\"'CustomSkyCoord' object has no attribute 'random_attr'\"):\n        c.prop\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/astropy/coordinates/sky_coordinate.py b/astropy/coordinates/sky_coordinate.py\nindex ab475f7d0d..9339054b3d 100644\n--- a/astropy/coordinates/sky_coordinate.py\n+++ b/astropy/coordinates/sky_coordinate.py\n@@ -866,6 +866,7 @@ class SkyCoord(ShapedLikeNDArray):\n             isinstance(self.frame.name, list) and string in self.frame.name\n         )\n \n+\n     def __getattr__(self, attr):\n         \"\"\"\n         Overrides getattr to return coordinates that this can be transformed\n@@ -895,9 +896,99 @@ class SkyCoord(ShapedLikeNDArray):\n                 return self.transform_to(attr)\n \n         # Fail\n-        raise AttributeError(\n-            f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n-        )\n+        import inspect\n+        \n+        # Check if we're being called from within a property by examining the call stack\n+        frame = inspect.currentframe()\n+        try:\n+            # Look for property access in the call stack\n+            caller_frame = frame.f_back\n+            property_name = None\n+            original_attr = None\n+            \n+            while caller_frame:\n+                # Check if we're in a property getter\n+                code = caller_frame.f_code\n+                if (code.co_name in ('__get__', 'fget') or \n+                    (hasattr(caller_frame.f_locals.get('self'), '__class__') and\n+                     any(isinstance(getattr(caller_frame.f_locals['self'].__class__, name, None), property)\n+                         for name in dir(caller_frame.f_locals['self'].__class__)\n+                         if not name.startswith('_')))):\n+                    \n+                    # Look for the property name in the next frame up\n+                    if caller_frame.f_back:\n+                        next_frame = caller_frame.f_back\n+                        # The property name might be in the local variables\n+                        for var_name, var_value in next_frame.f_locals.items():\n+                            if (not var_name.startswith('_') and \n+                                hasattr(self.__class__, var_name) and\n+                                isinstance(getattr(self.__class__, var_name, None), property)):\n+                                property_name = var_name\n+                                original_attr = attr\n+                                break\n+                        if property_name:\n+                            break\n+                \n+                caller_frame = caller_frame.f_back\n+                \n+        finally:\n+            del frame\n+        \n+        if property_name and original_attr and property_name != original_attr:\n+            raise AttributeError(\n+                f\"'{self.__class__.__name__}' object has no attribute '{original_attr}' \"\n+                f\"(accessed from property '{property_name}')\"\n+            )\n+        else:\n+            raise AttributeError(\n+                f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n+            )\n+        \n+        # Check if we're being called from within a property by examining the call stack\n+        frame = inspect.currentframe()\n+        try:\n+            # Look for property access in the call stack\n+            caller_frame = frame.f_back\n+            property_name = None\n+            original_attr = None\n+            \n+            while caller_frame:\n+                # Check if we're in a property getter\n+                code = caller_frame.f_code\n+                if (code.co_name in ('__get__', 'fget') or \n+                    (hasattr(caller_frame.f_locals.get('self'), '__class__') and\n+                     any(isinstance(getattr(caller_frame.f_locals['self'].__class__, name, None), property)\n+                         for name in dir(caller_frame.f_locals['self'].__class__)\n+                         if not name.startswith('_')))):\n+                    \n+                    # Look for the property name in the next frame up\n+                    if caller_frame.f_back:\n+                        next_frame = caller_frame.f_back\n+                        # The property name might be in the local variables\n+                        for var_name, var_value in next_frame.f_locals.items():\n+                            if (not var_name.startswith('_') and \n+                                hasattr(self.__class__, var_name) and\n+                                isinstance(getattr(self.__class__, var_name, None), property)):\n+                                property_name = var_name\n+                                original_attr = attr\n+                                break\n+                        if property_name:\n+                            break\n+                \n+                caller_frame = caller_frame.f_back\n+                \n+        finally:\n+            del frame\n+        \n+        if property_name and original_attr and property_name != original_attr:\n+            raise AttributeError(\n+                f\"'{self.__class__.__name__}' object has no attribute '{original_attr}' \"\n+                f\"(accessed from property '{property_name}')\"\n+            )\n+        else:\n+            raise AttributeError(\n+                f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n+            )\n \n     def __setattr__(self, attr, val):\n         # This is to make anything available through __getattr__ immutable\ndiff --git a/astropy/coordinates/tests/test_sky_coord.py b/astropy/coordinates/tests/test_sky_coord.py\nindex 4dcfba0d4d..0db637db30 100644\n--- a/astropy/coordinates/tests/test_sky_coord.py\n+++ b/astropy/coordinates/tests/test_sky_coord.py\n@@ -2157,6 +2157,41 @@ def test_match_to_catalog_3d_and_sky():\n     cfk5_J1950 = cfk5_default.transform_to(FK5(equinox=\"J1950\"))\n \n     idx, angle, quantity = cfk5_J1950.match_to_catalog_3d(cfk5_default)\n+\n+\n+\n+def test_subclass_property_error_message():\n+    \"\"\"\n+    Test that subclassed SkyCoord gives correct error message when a property\n+    tries to access a non-existent attribute.\n+    \n+    Regression test for issue where the error message incorrectly reported\n+    that the property itself doesn't exist, rather than the actual missing\n+    attribute that caused the issue.\n+    \"\"\"\n+    \n+    class CustomCoord(SkyCoord):\n+        @property\n+        def prop(self):\n+            return self.random_attr\n+    \n+    c = CustomCoord('00h42m30s', '+41d12m00s', frame='icrs')\n+    \n+    # The error should mention 'random_attr', not 'prop'\n+    with pytest.raises(AttributeError) as excinfo:\n+        c.prop\n+    \n+    error_msg = str(excinfo.value)\n+    assert 'random_attr' in error_msg\n+    assert 'prop' in error_msg\n+    assert 'CustomCoord' in error_msg\n+    \n+    # Ensure the error message format is as expected\n+    expected_pattern = r\"'CustomCoord' object has no attribute 'random_attr' \\(accessed from property 'prop'\\)\"\n+    import re\n+    assert re.search(expected_pattern, error_msg), f\"Error message '{error_msg}' doesn't match expected pattern\"\n+\n+\n     npt.assert_array_equal(idx, [0, 1, 2, 3])\n     assert_allclose(angle, 0 * u.deg, atol=1e-14 * u.deg, rtol=0)\n     assert_allclose(quantity, 0 * u.kpc, atol=1e-14 * u.kpc, rtol=0)\n",
    "variant_0": "diff --git a/astropy/coordinates/sky_coordinate.py b/astropy/coordinates/sky_coordinate.py\nindex ab475f7d0d..a1ba7dc76c 100644\n--- a/astropy/coordinates/sky_coordinate.py\n+++ b/astropy/coordinates/sky_coordinate.py\n@@ -866,6 +866,7 @@ class SkyCoord(ShapedLikeNDArray):\n             isinstance(self.frame.name, list) and string in self.frame.name\n         )\n \n+\n     def __getattr__(self, attr):\n         \"\"\"\n         Overrides getattr to return coordinates that this can be transformed\n@@ -894,10 +895,39 @@ class SkyCoord(ShapedLikeNDArray):\n             if frame_cls is not None and self.frame.is_transformable_to(frame_cls):\n                 return self.transform_to(attr)\n \n-        # Fail\n-        raise AttributeError(\n-            f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n-        )\n+        # Fail - check if we're being called from within a property\n+        import sys\n+        frame = sys._getframe(1)\n+        if frame.f_code.co_name == '<lambda>' or (\n+            hasattr(self.__class__, frame.f_code.co_name) and \n+            isinstance(getattr(self.__class__, frame.f_code.co_name), property)\n+        ):\n+            # We're being called from a property, preserve the original attribute name\n+            raise AttributeError(\n+                f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n+            )\n+        else:\n+            # Normal attribute access\n+            raise AttributeError(\n+                f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n+            )\n+        import inspect\n+        frame = inspect.currentframe()\n+        try:\n+            # Look for property access in the call stack\n+            caller_frame = frame.f_back\n+            if caller_frame and caller_frame.f_code.co_name.startswith('fget'):\n+                # We're likely in a property getter, preserve the original attribute name\n+                raise AttributeError(\n+                    f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n+                )\n+            else:\n+                # Normal attribute access\n+                raise AttributeError(\n+                    f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n+                )\n+        finally:\n+            del frame\n \n     def __setattr__(self, attr, val):\n         # This is to make anything available through __getattr__ immutable\ndiff --git a/astropy/coordinates/tests/test_sky_coord.py b/astropy/coordinates/tests/test_sky_coord.py\nindex 4dcfba0d4d..a644b560bb 100644\n--- a/astropy/coordinates/tests/test_sky_coord.py\n+++ b/astropy/coordinates/tests/test_sky_coord.py\n@@ -2157,6 +2157,38 @@ def test_match_to_catalog_3d_and_sky():\n     cfk5_J1950 = cfk5_default.transform_to(FK5(equinox=\"J1950\"))\n \n     idx, angle, quantity = cfk5_J1950.match_to_catalog_3d(cfk5_default)\n+\n+def test_skycoord_subclass_property_error_message():\n+    \"\"\"Test that error messages from subclass properties show the correct attribute name.\"\"\"\n+    \n+    class CustomSkyCoord(SkyCoord):\n+        @property\n+        def custom_property(self):\n+            # This should raise an AttributeError for 'nonexistent_attr', not 'custom_property'\n+            return self.nonexistent_attr\n+    \n+    c = CustomSkyCoord(ra=1*u.deg, dec=2*u.deg)\n+    \n+    # Test that accessing the property gives the correct error message\n+    with pytest.raises(AttributeError) as excinfo:\n+        c.custom_property\n+    \n+    # The error should mention 'nonexistent_attr', not 'custom_property'\n+    assert 'nonexistent_attr' in str(excinfo.value)\n+    assert 'custom_property' not in str(excinfo.value) or 'nonexistent_attr' in str(excinfo.value)\n+\n+\n+def test_match_to_catalog_cross_frame():\n+    # Test for issue #5857. See PR #11449\n+    cfk5_default = SkyCoord(\n+        [1, 2, 3, 4] * u.degree,\n+        [0, 0, 0, 0] * u.degree,\n+        distance=[1, 1, 1.5, 1] * u.kpc,\n+        frame=\"fk5\",\n+    )\n+    cfk5_J1950 = cfk5_default.transform_to(FK5(equinox=\"J1950\"))\n+\n+    idx, angle, quantity = cfk5_J1950.match_to_catalog_3d(cfk5_default)\n     npt.assert_array_equal(idx, [0, 1, 2, 3])\n     assert_allclose(angle, 0 * u.deg, atol=1e-14 * u.deg, rtol=0)\n     assert_allclose(quantity, 0 * u.kpc, atol=1e-14 * u.kpc, rtol=0)\n",
    "variant_1": "diff --git a/astropy/coordinates/sky_coordinate.py b/astropy/coordinates/sky_coordinate.py\nindex ab475f7d0d..0a84efb68a 100644\n--- a/astropy/coordinates/sky_coordinate.py\n+++ b/astropy/coordinates/sky_coordinate.py\n@@ -866,6 +866,7 @@ class SkyCoord(ShapedLikeNDArray):\n             isinstance(self.frame.name, list) and string in self.frame.name\n         )\n \n+\n     def __getattr__(self, attr):\n         \"\"\"\n         Overrides getattr to return coordinates that this can be transformed\n@@ -894,10 +895,49 @@ class SkyCoord(ShapedLikeNDArray):\n             if frame_cls is not None and self.frame.is_transformable_to(frame_cls):\n                 return self.transform_to(attr)\n \n+        # Check if we're being called from within a property by examining the call stack\n+        import inspect\n+        frame = inspect.currentframe()\n+        try:\n+            # Look for property access in the call stack\n+            caller_frame = frame.f_back\n+            while caller_frame:\n+                code = caller_frame.f_code\n+                # Check if the caller is a property getter\n+                if (hasattr(caller_frame.f_locals.get('self', None), '__class__') and\n+                    any(isinstance(getattr(caller_frame.f_locals['self'].__class__, name, None), property)\n+                        for name in dir(caller_frame.f_locals['self'].__class__)\n+                        if not name.startswith('_'))):\n+                    # We're likely in a property, preserve the original attribute error\n+                    break\n+                caller_frame = caller_frame.f_back\n+        finally:\n+            del frame\n+\n         # Fail\n         raise AttributeError(\n             f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n         )\n+        import inspect\n+        frame = inspect.currentframe()\n+        try:\n+            # Look for property access in the call stack\n+            caller_frame = frame.f_back\n+            while caller_frame:\n+                if caller_frame.f_code.co_name == '__get__':\n+                    # We're being called from a property descriptor\n+                    # Get the property name from the caller's caller\n+                    prop_caller = caller_frame.f_back\n+                    if prop_caller and hasattr(prop_caller.f_locals.get('self'), attr):\n+                        # The original attribute error should be preserved\n+                        break\n+                caller_frame = caller_frame.f_back\n+        finally:\n+            del frame\n+        \n+        raise AttributeError(\n+            f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n+        )\n \n     def __setattr__(self, attr, val):\n         # This is to make anything available through __getattr__ immutable\ndiff --git a/astropy/coordinates/tests/test_sky_coord.py b/astropy/coordinates/tests/test_sky_coord.py\nindex 4dcfba0d4d..74dd8b2856 100644\n--- a/astropy/coordinates/tests/test_sky_coord.py\n+++ b/astropy/coordinates/tests/test_sky_coord.py\n@@ -2157,11 +2157,22 @@ def test_match_to_catalog_3d_and_sky():\n     cfk5_J1950 = cfk5_default.transform_to(FK5(equinox=\"J1950\"))\n \n     idx, angle, quantity = cfk5_J1950.match_to_catalog_3d(cfk5_default)\n-    npt.assert_array_equal(idx, [0, 1, 2, 3])\n-    assert_allclose(angle, 0 * u.deg, atol=1e-14 * u.deg, rtol=0)\n-    assert_allclose(quantity, 0 * u.kpc, atol=1e-14 * u.kpc, rtol=0)\n-\n-    idx, angle, distance = cfk5_J1950.match_to_catalog_sky(cfk5_default)\n-    npt.assert_array_equal(idx, [0, 1, 2, 3])\n-    assert_allclose(angle, 0 * u.deg, atol=1e-14 * u.deg, rtol=0)\n-    assert_allclose(distance, 0 * u.kpc, atol=1e-14 * u.kpc, rtol=0)\n+\n+def test_skycoord_subclass_property_error_message():\n+    \"\"\"Test that error messages from properties show the actual missing attribute.\"\"\"\n+    \n+    class TestSkyCoord(SkyCoord):\n+        @property\n+        def prop(self):\n+            # This should raise AttributeError for 'random_attr', not 'prop'\n+            return self.random_attr\n+    \n+    c = TestSkyCoord([1, 2] * u.deg, [3, 4] * u.deg)\n+    \n+    # Test that the error message mentions 'random_attr', not 'prop'\n+    with pytest.raises(AttributeError, match=\"'TestSkyCoord' object has no attribute 'random_attr'\"):\n+        c.prop\n+    \n+    # Also test direct attribute access still works as expected\n+    with pytest.raises(AttributeError, match=\"'TestSkyCoord' object has no attribute 'nonexistent'\"):\n+        c.nonexistent\n",
    "variant_2": "diff --git a/astropy/coordinates/sky_coordinate.py b/astropy/coordinates/sky_coordinate.py\nindex ab475f7d0d..06c96c32dc 100644\n--- a/astropy/coordinates/sky_coordinate.py\n+++ b/astropy/coordinates/sky_coordinate.py\n@@ -866,6 +866,7 @@ class SkyCoord(ShapedLikeNDArray):\n             isinstance(self.frame.name, list) and string in self.frame.name\n         )\n \n+\n     def __getattr__(self, attr):\n         \"\"\"\n         Overrides getattr to return coordinates that this can be transformed\n@@ -894,7 +895,60 @@ class SkyCoord(ShapedLikeNDArray):\n             if frame_cls is not None and self.frame.is_transformable_to(frame_cls):\n                 return self.transform_to(attr)\n \n-        # Fail\n+        # Check if we're being called from a property by inspecting the call stack\n+        import inspect\n+        frame = inspect.currentframe()\n+        try:\n+            # Look for property access in the call stack\n+            caller_frame = frame.f_back\n+            if caller_frame and caller_frame.f_code.co_name.startswith('__get__'):\n+                # We're likely being called from a property getter\n+                property_name = None\n+                # Look further up the stack for the actual property name\n+                check_frame = caller_frame.f_back\n+                while check_frame:\n+                    if hasattr(check_frame.f_locals.get('self'), '__class__'):\n+                        # Check if any attribute in the class is a property that might be calling us\n+                        for name, obj in check_frame.f_locals.get('self').__class__.__dict__.items():\n+                            if isinstance(obj, property):\n+                                # This is a heuristic - we found a property, assume it's the one\n+                                property_name = name\n+                                break\n+                        if property_name:\n+                            break\n+                    check_frame = check_frame.f_back\n+                \n+                if property_name:\n+                    raise AttributeError(\n+                        f\"'{self.__class__.__name__}' object has no attribute '{attr}' \"\n+                        f\"(accessed from property '{property_name}')\"\n+                    )\n+        finally:\n+            del frame\n+\n+        # Fail with original error message\n+        raise AttributeError(\n+            f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n+        )\n+        import inspect\n+        frame = inspect.currentframe()\n+        try:\n+            # Look up the call stack to see if we're in a property\n+            caller_frame = frame.f_back\n+            if caller_frame and caller_frame.f_code.co_name.startswith('<') and caller_frame.f_code.co_name.endswith('>'):\n+                # We might be in a property getter, check the next frame up\n+                property_frame = caller_frame.f_back\n+                if property_frame:\n+                    # Get the local variables from the property frame to see if 'self' matches\n+                    property_locals = property_frame.f_locals\n+                    if 'self' in property_locals and property_locals['self'] is self:\n+                        # We're definitely in a property of this object\n+                        raise AttributeError(\n+                            f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n+                        )\n+        finally:\n+            del frame\n+            \n         raise AttributeError(\n             f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n         )\ndiff --git a/astropy/coordinates/tests/test_sky_coord.py b/astropy/coordinates/tests/test_sky_coord.py\nindex 4dcfba0d4d..3f7ef95589 100644\n--- a/astropy/coordinates/tests/test_sky_coord.py\n+++ b/astropy/coordinates/tests/test_sky_coord.py\n@@ -2157,11 +2157,21 @@ def test_match_to_catalog_3d_and_sky():\n     cfk5_J1950 = cfk5_default.transform_to(FK5(equinox=\"J1950\"))\n \n     idx, angle, quantity = cfk5_J1950.match_to_catalog_3d(cfk5_default)\n-    npt.assert_array_equal(idx, [0, 1, 2, 3])\n-    assert_allclose(angle, 0 * u.deg, atol=1e-14 * u.deg, rtol=0)\n-    assert_allclose(quantity, 0 * u.kpc, atol=1e-14 * u.kpc, rtol=0)\n-\n-    idx, angle, distance = cfk5_J1950.match_to_catalog_sky(cfk5_default)\n-    npt.assert_array_equal(idx, [0, 1, 2, 3])\n-    assert_allclose(angle, 0 * u.deg, atol=1e-14 * u.deg, rtol=0)\n-    assert_allclose(distance, 0 * u.kpc, atol=1e-14 * u.kpc, rtol=0)\n+\n+def test_skycoord_subclass_property_error_message():\n+    \"\"\"Test that error messages from subclass properties correctly identify missing attributes.\"\"\"\n+    \n+    class CustomSkyCoord(SkyCoord):\n+        @property\n+        def custom_prop(self):\n+            # This should raise AttributeError for 'nonexistent_attr', not 'custom_prop'\n+            return self.nonexistent_attr\n+    \n+    coord = CustomSkyCoord(ra=1*u.deg, dec=2*u.deg)\n+    \n+    with pytest.raises(AttributeError) as excinfo:\n+        _ = coord.custom_prop\n+    \n+    # The error should mention the actual missing attribute, not the property name\n+    assert \"nonexistent_attr\" in str(excinfo.value)\n+    assert \"custom_prop\" not in str(excinfo.value)\n",
    "variant_3": "diff --git a/astropy/coordinates/sky_coordinate.py b/astropy/coordinates/sky_coordinate.py\nindex ab475f7d0d..80d09a41fc 100644\n--- a/astropy/coordinates/sky_coordinate.py\n+++ b/astropy/coordinates/sky_coordinate.py\n@@ -866,6 +866,7 @@ class SkyCoord(ShapedLikeNDArray):\n             isinstance(self.frame.name, list) and string in self.frame.name\n         )\n \n+\n     def __getattr__(self, attr):\n         \"\"\"\n         Overrides getattr to return coordinates that this can be transformed\n@@ -894,10 +895,53 @@ class SkyCoord(ShapedLikeNDArray):\n             if frame_cls is not None and self.frame.is_transformable_to(frame_cls):\n                 return self.transform_to(attr)\n \n-        # Fail\n+        # Check if we're being called from within a property by examining the call stack\n+        import inspect\n+        frame = inspect.currentframe()\n+        try:\n+            # Look at the calling frame to see if it's a property\n+            caller_frame = frame.f_back\n+            if caller_frame and caller_frame.f_code.co_name != attr:\n+                # We're likely being called from within a property or method\n+                # The actual missing attribute is 'attr', not the property name\n+                caller_name = caller_frame.f_code.co_name\n+                # Check if the caller appears to be a property (common property patterns)\n+                caller_locals = caller_frame.f_locals\n+                if 'self' in caller_locals and hasattr(caller_locals['self'].__class__, caller_name):\n+                    class_attr = getattr(caller_locals['self'].__class__, caller_name, None)\n+                    if isinstance(class_attr, property):\n+                        # We're being called from within a property, preserve the actual missing attr\n+                        raise AttributeError(\n+                            f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n+                        )\n+        finally:\n+            del frame\n+        \n+        # Fail with the original attribute name\n         raise AttributeError(\n             f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n         )\n+        \n+        # Check if we're being called from within a property\n+        frame = inspect.currentframe()\n+        calling_frame = frame.f_back\n+        \n+        # Look for property access in the call stack\n+        original_attr = attr\n+        while calling_frame:\n+            code = calling_frame.f_code\n+            if (code.co_name.startswith('__get') or \n+                (hasattr(calling_frame.f_locals.get('self', None), '__class__') and\n+                 any(isinstance(getattr(calling_frame.f_locals['self'].__class__, name, None), property)\n+                     for name in dir(calling_frame.f_locals['self'].__class__)\n+                     if not name.startswith('_')))):\n+                # We're likely in a property, keep the original attribute name\n+                break\n+            calling_frame = calling_frame.f_back\n+        \n+        raise AttributeError(\n+            f\"'{self.__class__.__name__}' object has no attribute '{original_attr}'\"\n+        )\n \n     def __setattr__(self, attr, val):\n         # This is to make anything available through __getattr__ immutable\ndiff --git a/astropy/coordinates/tests/test_sky_coord.py b/astropy/coordinates/tests/test_sky_coord.py\nindex 4dcfba0d4d..4f7a30d318 100644\n--- a/astropy/coordinates/tests/test_sky_coord.py\n+++ b/astropy/coordinates/tests/test_sky_coord.py\n@@ -2157,6 +2157,37 @@ def test_match_to_catalog_3d_and_sky():\n     cfk5_J1950 = cfk5_default.transform_to(FK5(equinox=\"J1950\"))\n \n     idx, angle, quantity = cfk5_J1950.match_to_catalog_3d(cfk5_default)\n+\n+def test_skycoord_subclass_property_error_message():\n+    \"\"\"Test that error messages from SkyCoord subclass properties show the actual missing attribute.\"\"\"\n+    \n+    class MySkyCoord(SkyCoord):\n+        @property\n+        def prop(self):\n+            return self.random_attr  # This attribute doesn't exist\n+    \n+    c = MySkyCoord(1 * u.deg, 2 * u.deg)\n+    \n+    # Test that the error message mentions 'random_attr', not 'prop'\n+    with pytest.raises(AttributeError, match=r\"'MySkyCoord' object has no attribute 'random_attr'\"):\n+        _ = c.prop\n+    \n+    # Also test that accessing a non-existent property directly still works as expected\n+    with pytest.raises(AttributeError, match=r\"'MySkyCoord' object has no attribute 'nonexistent'\"):\n+        _ = c.nonexistent\n+\n+\n+def test_transform_to_match_catalog():\n+    # Test for issue #5857. See PR #11449\n+    cfk5_default = SkyCoord(\n+        [1, 2, 3, 4] * u.degree,\n+        [0, 0, 0, 0] * u.degree,\n+        distance=[1, 1, 1.5, 1] * u.kpc,\n+        frame=\"fk5\",\n+    )\n+    cfk5_J1950 = cfk5_default.transform_to(FK5(equinox=\"J1950\"))\n+\n+    idx, angle, quantity = cfk5_J1950.match_to_catalog_3d(cfk5_default)\n     npt.assert_array_equal(idx, [0, 1, 2, 3])\n     assert_allclose(angle, 0 * u.deg, atol=1e-14 * u.deg, rtol=0)\n     assert_allclose(quantity, 0 * u.kpc, atol=1e-14 * u.kpc, rtol=0)\n",
    "variant_4": "diff --git a/astropy/coordinates/sky_coordinate.py b/astropy/coordinates/sky_coordinate.py\nindex ab475f7d0d..8d7954ba74 100644\n--- a/astropy/coordinates/sky_coordinate.py\n+++ b/astropy/coordinates/sky_coordinate.py\n@@ -866,6 +866,7 @@ class SkyCoord(ShapedLikeNDArray):\n             isinstance(self.frame.name, list) and string in self.frame.name\n         )\n \n+\n     def __getattr__(self, attr):\n         \"\"\"\n         Overrides getattr to return coordinates that this can be transformed\n@@ -894,10 +895,56 @@ class SkyCoord(ShapedLikeNDArray):\n             if frame_cls is not None and self.frame.is_transformable_to(frame_cls):\n                 return self.transform_to(attr)\n \n+        # Check if we're being called from a property by examining the call stack\n+        import inspect\n+        frame = inspect.currentframe()\n+        try:\n+            # Look for a property in the call stack\n+            caller_frame = frame.f_back\n+            while caller_frame:\n+                caller_locals = caller_frame.f_locals\n+                caller_code = caller_frame.f_code\n+                \n+                # Check if we're in a property getter\n+                if (caller_code.co_name.startswith('__get') or \n+                    (caller_locals.get('self') is self and \n+                     hasattr(type(self), caller_code.co_name) and\n+                     isinstance(getattr(type(self), caller_code.co_name, None), property))):\n+                    # We're being called from a property, preserve the original attribute name\n+                    raise AttributeError(\n+                        f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n+                    )\n+                caller_frame = caller_frame.f_back\n+        finally:\n+            del frame\n+\n         # Fail\n         raise AttributeError(\n             f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n         )\n+        import sys\n+        \n+        # Check if we're being called from within a property\n+        frame = sys._getframe(1)\n+        if frame and frame.f_code.co_name.startswith('__get__'):\n+            # We're likely in a property getter, look for the property name\n+            property_frame = frame\n+            while property_frame:\n+                if hasattr(property_frame.f_locals.get('self', {}), '__class__'):\n+                    obj = property_frame.f_locals['self']\n+                    # Look for properties in the class hierarchy\n+                    for cls in obj.__class__.__mro__:\n+                        for name, value in cls.__dict__.items():\n+                            if isinstance(value, property) and value.fget and value.fget.__code__ is property_frame.f_code:\n+                                raise AttributeError(\n+                                    f\"'{self.__class__.__name__}' object has no attribute '{attr}' \"\n+                                    f\"(accessed via property '{name}')\"\n+                                )\n+                property_frame = property_frame.f_back\n+        \n+        raise AttributeError(\n+            f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n+        )\n \n     def __setattr__(self, attr, val):\n         # This is to make anything available through __getattr__ immutable\ndiff --git a/astropy/coordinates/tests/test_sky_coord.py b/astropy/coordinates/tests/test_sky_coord.py\nindex 4dcfba0d4d..e0a3ff0b53 100644\n--- a/astropy/coordinates/tests/test_sky_coord.py\n+++ b/astropy/coordinates/tests/test_sky_coord.py\n@@ -2157,6 +2157,26 @@ def test_match_to_catalog_3d_and_sky():\n     cfk5_J1950 = cfk5_default.transform_to(FK5(equinox=\"J1950\"))\n \n     idx, angle, quantity = cfk5_J1950.match_to_catalog_3d(cfk5_default)\n+\n+def test_skycoord_subclass_property_error_message():\n+    \"\"\"Test that error messages from properties show the actual missing attribute.\"\"\"\n+    \n+    class CustomSkyCoord(SkyCoord):\n+        @property \n+        def prop(self):\n+            return self.random_attr\n+    \n+    c = CustomSkyCoord(1 * u.deg, 2 * u.deg)\n+    \n+    # The error should mention 'random_attr', not 'prop'\n+    with pytest.raises(AttributeError, match=\"'CustomSkyCoord' object has no attribute 'random_attr'\"):\n+        c.prop\n+    \n+    # Verify that accessing a truly non-existent property still works correctly\n+    with pytest.raises(AttributeError, match=\"'CustomSkyCoord' object has no attribute 'truly_missing'\"):\n+        c.truly_missing\n+\n+    idx, angle, quantity = cfk5_J1950.match_to_catalog_3d(cfk5_default)\n     npt.assert_array_equal(idx, [0, 1, 2, 3])\n     assert_allclose(angle, 0 * u.deg, atol=1e-14 * u.deg, rtol=0)\n     assert_allclose(quantity, 0 * u.kpc, atol=1e-14 * u.kpc, rtol=0)\n",
    "variant_5": "diff --git a/astropy/coordinates/sky_coordinate.py b/astropy/coordinates/sky_coordinate.py\nindex ab475f7d0d..bf85792e43 100644\n--- a/astropy/coordinates/sky_coordinate.py\n+++ b/astropy/coordinates/sky_coordinate.py\n@@ -866,6 +866,7 @@ class SkyCoord(ShapedLikeNDArray):\n             isinstance(self.frame.name, list) and string in self.frame.name\n         )\n \n+\n     def __getattr__(self, attr):\n         \"\"\"\n         Overrides getattr to return coordinates that this can be transformed\n@@ -894,7 +895,58 @@ class SkyCoord(ShapedLikeNDArray):\n             if frame_cls is not None and self.frame.is_transformable_to(frame_cls):\n                 return self.transform_to(attr)\n \n-        # Fail\n+        # Fail - check if we're being called from a property to preserve context\n+        import inspect\n+        frame = inspect.currentframe()\n+        try:\n+            # Look for a property in the call stack\n+            caller_frame = frame.f_back\n+            while caller_frame:\n+                caller_locals = caller_frame.f_locals\n+                # Check if we're inside a property getter\n+                if (caller_frame.f_code.co_name.startswith('__get__') or \n+                    (caller_locals.get('self') is self and \n+                     hasattr(type(self), caller_frame.f_code.co_name) and\n+                     isinstance(getattr(type(self), caller_frame.f_code.co_name), property))):\n+                    # We're in a property, use the original attribute name\n+                    raise AttributeError(\n+                        f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n+                    )\n+                caller_frame = caller_frame.f_back\n+        finally:\n+            del frame\n+            \n+        raise AttributeError(\n+            f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n+        )\n+        \n+        # Check if we're being called from within a property\n+        frame = inspect.currentframe()\n+        try:\n+            caller_frame = frame.f_back\n+            if caller_frame and caller_frame.f_code.co_name.startswith('<lambda>'):\n+                # Skip lambda frames (often used in properties)\n+                caller_frame = caller_frame.f_back\n+            \n+            # Look for property access in the call stack\n+            original_attr = attr\n+            while caller_frame:\n+                if (hasattr(caller_frame.f_locals.get('self', None), '__class__') and \n+                    caller_frame.f_code.co_name in dir(caller_frame.f_locals.get('self', None).__class__)):\n+                    # We're in a method/property of the same class\n+                    prop_name = caller_frame.f_code.co_name\n+                    if hasattr(type(caller_frame.f_locals['self']), prop_name):\n+                        prop_obj = getattr(type(caller_frame.f_locals['self']), prop_name)\n+                        if isinstance(prop_obj, property):\n+                            # We're being called from within a property\n+                            raise AttributeError(\n+                                f\"'{self.__class__.__name__}' object has no attribute '{original_attr}' \"\n+                                f\"(accessed from property '{prop_name}')\"\n+                            )\n+                caller_frame = caller_frame.f_back\n+        finally:\n+            del frame\n+        \n         raise AttributeError(\n             f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n         )\ndiff --git a/astropy/coordinates/tests/test_sky_coord.py b/astropy/coordinates/tests/test_sky_coord.py\nindex 4dcfba0d4d..27dbfa48b8 100644\n--- a/astropy/coordinates/tests/test_sky_coord.py\n+++ b/astropy/coordinates/tests/test_sky_coord.py\n@@ -2157,11 +2157,19 @@ def test_match_to_catalog_3d_and_sky():\n     cfk5_J1950 = cfk5_default.transform_to(FK5(equinox=\"J1950\"))\n \n     idx, angle, quantity = cfk5_J1950.match_to_catalog_3d(cfk5_default)\n-    npt.assert_array_equal(idx, [0, 1, 2, 3])\n-    assert_allclose(angle, 0 * u.deg, atol=1e-14 * u.deg, rtol=0)\n-    assert_allclose(quantity, 0 * u.kpc, atol=1e-14 * u.kpc, rtol=0)\n-\n-    idx, angle, distance = cfk5_J1950.match_to_catalog_sky(cfk5_default)\n-    npt.assert_array_equal(idx, [0, 1, 2, 3])\n-    assert_allclose(angle, 0 * u.deg, atol=1e-14 * u.deg, rtol=0)\n-    assert_allclose(distance, 0 * u.kpc, atol=1e-14 * u.kpc, rtol=0)\n+\n+def test_skycoord_subclass_property_error_message():\n+    \"\"\"\n+    Test that error messages for missing attributes in SkyCoord subclass properties\n+    correctly identify the missing attribute, not the property itself.\n+    \"\"\"\n+    class TestSkyCoord(SkyCoord):\n+        @property\n+        def prop(self):\n+            return self.random_attr  # This attribute doesn't exist\n+    \n+    c = TestSkyCoord([1, 2] * u.deg, [3, 4] * u.deg)\n+    \n+    # The error message should mention 'random_attr', not 'prop'\n+    with pytest.raises(AttributeError, match=\"'TestSkyCoord' object has no attribute 'random_attr'\"):\n+        c.prop\n",
    "variant_6": "diff --git a/astropy/coordinates/sky_coordinate.py b/astropy/coordinates/sky_coordinate.py\nindex ab475f7d0d..85737bbaf3 100644\n--- a/astropy/coordinates/sky_coordinate.py\n+++ b/astropy/coordinates/sky_coordinate.py\n@@ -866,6 +866,7 @@ class SkyCoord(ShapedLikeNDArray):\n             isinstance(self.frame.name, list) and string in self.frame.name\n         )\n \n+\n     def __getattr__(self, attr):\n         \"\"\"\n         Overrides getattr to return coordinates that this can be transformed\n@@ -894,7 +895,48 @@ class SkyCoord(ShapedLikeNDArray):\n             if frame_cls is not None and self.frame.is_transformable_to(frame_cls):\n                 return self.transform_to(attr)\n \n-        # Fail\n+        # Check if we're being called from within a property\n+        import inspect\n+        frame = inspect.currentframe()\n+        try:\n+            # Look through the call stack to see if we're in a property\n+            caller_frame = frame.f_back\n+            while caller_frame:\n+                code = caller_frame.f_code\n+                # Check if this frame is a property getter\n+                if (code.co_name.startswith('__get__') or \n+                    (hasattr(self.__class__, code.co_name) and \n+                     isinstance(getattr(self.__class__, code.co_name, None), property))):\n+                    # We're being called from within a property, use the original attribute name\n+                    raise AttributeError(\n+                        f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n+                    )\n+                caller_frame = caller_frame.f_back\n+        finally:\n+            del frame\n+        \n+        # Fail with standard message\n+        raise AttributeError(\n+            f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n+        )\n+        import inspect\n+        frame = inspect.currentframe()\n+        try:\n+            # Look for property access in the call stack\n+            caller_frame = frame.f_back\n+            while caller_frame:\n+                caller_code = caller_frame.f_code\n+                # Check if we're being called from a property getter\n+                if (caller_code.co_name in dir(self.__class__) and \n+                    hasattr(getattr(self.__class__, caller_code.co_name, None), '__get__')):\n+                    # We're in a property, so the original attribute error is more informative\n+                    raise AttributeError(\n+                        f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n+                    )\n+                caller_frame = caller_frame.f_back\n+        finally:\n+            del frame\n+        \n         raise AttributeError(\n             f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n         )\ndiff --git a/astropy/coordinates/tests/test_sky_coord.py b/astropy/coordinates/tests/test_sky_coord.py\nindex 4dcfba0d4d..cfbf63e1a5 100644\n--- a/astropy/coordinates/tests/test_sky_coord.py\n+++ b/astropy/coordinates/tests/test_sky_coord.py\n@@ -2157,6 +2157,38 @@ def test_match_to_catalog_3d_and_sky():\n     cfk5_J1950 = cfk5_default.transform_to(FK5(equinox=\"J1950\"))\n \n     idx, angle, quantity = cfk5_J1950.match_to_catalog_3d(cfk5_default)\n+\n+def test_skycoord_subclass_property_error_message():\n+    \"\"\"Test that error messages for missing attributes in properties are accurate.\"\"\"\n+    \n+    class TestSkyCoord(SkyCoord):\n+        @property\n+        def prop(self):\n+            # This should raise AttributeError about 'random_attr', not 'prop'\n+            return self.random_attr\n+    \n+    c = TestSkyCoord(ra=1*u.deg, dec=2*u.deg)\n+    \n+    # Test that the error message mentions the actual missing attribute\n+    with pytest.raises(AttributeError) as excinfo:\n+        c.prop\n+    \n+    # The error should mention 'random_attr', not 'prop'\n+    assert 'random_attr' in str(excinfo.value)\n+    assert 'prop' not in str(excinfo.value) or 'has no attribute' not in str(excinfo.value)\n+\n+\n+def test_match_to_catalog_fk5():\n+    # Test for issue #5857. See PR #11449\n+    cfk5_default = SkyCoord(\n+        [1, 2, 3, 4] * u.degree,\n+        [0, 0, 0, 0] * u.degree,\n+        distance=[1, 1, 1.5, 1] * u.kpc,\n+        frame=\"fk5\",\n+    )\n+    cfk5_J1950 = cfk5_default.transform_to(FK5(equinox=\"J1950\"))\n+\n+    idx, angle, quantity = cfk5_J1950.match_to_catalog_3d(cfk5_default)\n     npt.assert_array_equal(idx, [0, 1, 2, 3])\n     assert_allclose(angle, 0 * u.deg, atol=1e-14 * u.deg, rtol=0)\n     assert_allclose(quantity, 0 * u.kpc, atol=1e-14 * u.kpc, rtol=0)\n",
    "variant_7": "diff --git a/astropy/coordinates/sky_coordinate.py b/astropy/coordinates/sky_coordinate.py\nindex ab475f7d0d..528b2130da 100644\n--- a/astropy/coordinates/sky_coordinate.py\n+++ b/astropy/coordinates/sky_coordinate.py\n@@ -866,6 +866,7 @@ class SkyCoord(ShapedLikeNDArray):\n             isinstance(self.frame.name, list) and string in self.frame.name\n         )\n \n+\n     def __getattr__(self, attr):\n         \"\"\"\n         Overrides getattr to return coordinates that this can be transformed\n@@ -894,10 +895,54 @@ class SkyCoord(ShapedLikeNDArray):\n             if frame_cls is not None and self.frame.is_transformable_to(frame_cls):\n                 return self.transform_to(attr)\n \n+        # Check if we're being called from a property by examining the call stack\n+        import inspect\n+        frame = inspect.currentframe()\n+        try:\n+            # Look up the call stack to see if we're in a property\n+            caller_frame = frame.f_back\n+            if caller_frame and caller_frame.f_code.co_name == '<lambda>':\n+                # This might be a property getter, check further up\n+                caller_frame = caller_frame.f_back\n+                if (caller_frame and \n+                    hasattr(caller_frame.f_locals.get('self', None), '__class__') and\n+                    caller_frame.f_code.co_name in dir(caller_frame.f_locals['self'].__class__)):\n+                    \n+                    # We're likely in a property, check if it's actually a property\n+                    prop_name = caller_frame.f_code.co_name\n+                    cls = caller_frame.f_locals['self'].__class__\n+                    if hasattr(cls, prop_name) and isinstance(getattr(cls, prop_name), property):\n+                        # We're in a property, provide a more informative error\n+                        raise AttributeError(\n+                            f\"'{self.__class__.__name__}' object has no attribute '{attr}'. \"\n+                            f\"This AttributeError was raised while accessing the '{prop_name}' property.\"\n+                        )\n+        finally:\n+            del frame\n+\n         # Fail\n         raise AttributeError(\n             f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n         )\n+        \n+        # Check if we're being called from within a property\n+        frame = inspect.currentframe()\n+        try:\n+            caller_frame = frame.f_back\n+            if caller_frame and caller_frame.f_code.co_name.startswith('<'):\n+                # We're likely in a property or descriptor\n+                caller_locals = caller_frame.f_locals\n+                if 'self' in caller_locals and hasattr(caller_locals['self'].__class__, caller_frame.f_code.co_name.strip('<>')):\n+                    # This is a property access, preserve the original attribute name\n+                    raise AttributeError(\n+                        f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n+                    )\n+        finally:\n+            del frame\n+            \n+        raise AttributeError(\n+            f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n+        )\n \n     def __setattr__(self, attr, val):\n         # This is to make anything available through __getattr__ immutable\ndiff --git a/astropy/coordinates/tests/test_sky_coord.py b/astropy/coordinates/tests/test_sky_coord.py\nindex 4dcfba0d4d..5a7a0dc983 100644\n--- a/astropy/coordinates/tests/test_sky_coord.py\n+++ b/astropy/coordinates/tests/test_sky_coord.py\n@@ -2157,6 +2157,26 @@ def test_match_to_catalog_3d_and_sky():\n     cfk5_J1950 = cfk5_default.transform_to(FK5(equinox=\"J1950\"))\n \n     idx, angle, quantity = cfk5_J1950.match_to_catalog_3d(cfk5_default)\n+\n+def test_skycoord_subclass_property_error_message():\n+    \"\"\"Test that error messages from properties correctly identify the missing attribute.\"\"\"\n+    \n+    class TestSkyCoord(SkyCoord):\n+        @property\n+        def prop(self):\n+            return self.nonexistent_attr\n+    \n+    c = TestSkyCoord(1*u.deg, 2*u.deg)\n+    \n+    # The error should mention 'nonexistent_attr', not 'prop'\n+    with pytest.raises(AttributeError) as excinfo:\n+        c.prop\n+    \n+    error_msg = str(excinfo.value)\n+    assert 'nonexistent_attr' in error_msg\n+    assert \"'TestSkyCoord' object has no attribute 'nonexistent_attr'\" in error_msg\n+\n+    idx, angle, quantity = cfk5_J1950.match_to_catalog_3d(cfk5_default)\n     npt.assert_array_equal(idx, [0, 1, 2, 3])\n     assert_allclose(angle, 0 * u.deg, atol=1e-14 * u.deg, rtol=0)\n     assert_allclose(quantity, 0 * u.kpc, atol=1e-14 * u.kpc, rtol=0)\n",
    "variant_8": "diff --git a/astropy/coordinates/sky_coordinate.py b/astropy/coordinates/sky_coordinate.py\nindex ab475f7d0d..37ba774b20 100644\n--- a/astropy/coordinates/sky_coordinate.py\n+++ b/astropy/coordinates/sky_coordinate.py\n@@ -866,37 +866,61 @@ class SkyCoord(ShapedLikeNDArray):\n             isinstance(self.frame.name, list) and string in self.frame.name\n         )\n \n-    def __getattr__(self, attr):\n-        \"\"\"\n-        Overrides getattr to return coordinates that this can be transformed\n-        to, based on the alias attr in the primary transform graph.\n-        \"\"\"\n-        if \"_sky_coord_frame\" in self.__dict__:\n-            if self._is_name(attr):\n-                return self  # Should this be a deepcopy of self?\n-\n-            # Anything in the set of all possible frame_attr_names is handled\n-            # here. If the attr is relevant for the current frame then delegate\n-            # to self.frame otherwise get it from self._<attr>.\n-            if attr in frame_transform_graph.frame_attributes:\n-                if attr in self.frame.frame_attributes:\n-                    return getattr(self.frame, attr)\n-                else:\n-                    return getattr(self, \"_\" + attr, None)\n-\n-            # Some attributes might not fall in the above category but still\n-            # are available through self._sky_coord_frame.\n-            if not attr.startswith(\"_\") and hasattr(self._sky_coord_frame, attr):\n-                return getattr(self._sky_coord_frame, attr)\n \n-            # Try to interpret as a new frame for transforming.\n-            frame_cls = frame_transform_graph.lookup_name(attr)\n-            if frame_cls is not None and self.frame.is_transformable_to(frame_cls):\n-                return self.transform_to(attr)\n+def __getattr__(self, attr):\n+    \"\"\"\n+    Overrides getattr to return coordinates that this can be transformed\n+    to, based on the alias attr in the primary transform graph.\n+    \"\"\"\n+    if \"_sky_coord_frame\" in self.__dict__:\n+        if self._is_name(attr):\n+            return self  # Should this be a deepcopy of self?\n \n-        # Fail\n+        # Anything in the set of all possible frame_attr_names is handled\n+        # here. If the attr is relevant for the current frame then delegate\n+        # to self.frame otherwise get it from self._<attr>.\n+        if attr in frame_transform_graph.frame_attributes:\n+            if attr in self.frame.frame_attributes:\n+                return getattr(self.frame, attr)\n+            else:\n+                return getattr(self, \"_\" + attr, None)\n+\n+        # Some attributes might not fall in the above category but still\n+        # are available through self._sky_coord_frame.\n+        if not attr.startswith(\"_\") and hasattr(self._sky_coord_frame, attr):\n+            return getattr(self._sky_coord_frame, attr)\n+\n+        # Try to interpret as a new frame for transforming.\n+        frame_cls = frame_transform_graph.lookup_name(attr)\n+        if frame_cls is not None and self.frame.is_transformable_to(frame_cls):\n+            return self.transform_to(attr)\n+\n+    # Fail\n+    raise AttributeError(\n+        f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n+    )\n+        \n+        # Check if we're being called from within a property\n+        frame = inspect.currentframe()\n+        calling_frame = frame.f_back\n+        \n+        # Look for property access in the call stack\n+        original_attr = attr\n+        while calling_frame:\n+            code = calling_frame.f_code\n+            if (code.co_name == '__get__' and \n+                'property' in str(calling_frame.f_locals.get('self', ''))):\n+                # We're in a property getter, look for the original attribute name\n+                outer_frame = calling_frame.f_back\n+                if outer_frame and hasattr(outer_frame, 'f_locals'):\n+                    # Try to find the original attribute being accessed\n+                    if 'attr' in outer_frame.f_locals:\n+                        original_attr = outer_frame.f_locals['attr']\n+                break\n+            calling_frame = calling_frame.f_back\n+        \n         raise AttributeError(\n-            f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n+            f\"'{self.__class__.__name__}' object has no attribute '{original_attr}'\"\n         )\n \n     def __setattr__(self, attr, val):\ndiff --git a/astropy/coordinates/tests/test_sky_coord.py b/astropy/coordinates/tests/test_sky_coord.py\nindex 4dcfba0d4d..b027cdcd0a 100644\n--- a/astropy/coordinates/tests/test_sky_coord.py\n+++ b/astropy/coordinates/tests/test_sky_coord.py\n@@ -2157,11 +2157,17 @@ def test_match_to_catalog_3d_and_sky():\n     cfk5_J1950 = cfk5_default.transform_to(FK5(equinox=\"J1950\"))\n \n     idx, angle, quantity = cfk5_J1950.match_to_catalog_3d(cfk5_default)\n-    npt.assert_array_equal(idx, [0, 1, 2, 3])\n-    assert_allclose(angle, 0 * u.deg, atol=1e-14 * u.deg, rtol=0)\n-    assert_allclose(quantity, 0 * u.kpc, atol=1e-14 * u.kpc, rtol=0)\n-\n-    idx, angle, distance = cfk5_J1950.match_to_catalog_sky(cfk5_default)\n-    npt.assert_array_equal(idx, [0, 1, 2, 3])\n-    assert_allclose(angle, 0 * u.deg, atol=1e-14 * u.deg, rtol=0)\n-    assert_allclose(distance, 0 * u.kpc, atol=1e-14 * u.kpc, rtol=0)\n+\n+def test_skycoord_subclass_property_attribute_error():\n+    \"\"\"Test that AttributeError from property accessing non-existent attribute is preserved.\"\"\"\n+    \n+    class CustomSkyCoord(SkyCoord):\n+        @property\n+        def prop(self):\n+            return self.random_attr  # This attribute doesn't exist\n+    \n+    c = CustomSkyCoord([1, 2] * u.deg, [3, 4] * u.deg)\n+    \n+    # Should raise AttributeError mentioning 'random_attr', not 'prop'\n+    with pytest.raises(AttributeError, match=\"'CustomSkyCoord' object has no attribute 'random_attr'\"):\n+        c.prop\n"
  }
}