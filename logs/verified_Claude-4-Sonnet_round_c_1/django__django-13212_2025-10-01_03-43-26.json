{
  "zero_patches": {
    "Location 1 (/root/hy/projects/django/django/core/validators.py lines 51-51)": "\n    def __call__(self, value):\n        \"\"\"\n        Validate that the input contains (or does *not* contain, if\n        inverse_match is True) a match for the regular expression.\n        \"\"\"\n        regex_matches = self.regex.search(str(value))\n        invalid_input = regex_matches if self.inverse_match else not regex_matches\n        if invalid_input:\n            raise ValidationError(self.message, code=self.code, params={'value': value})\n",
    "Location 2 (/root/hy/projects/django/django/core/validators.py lines 211-211)": "\n    def __call__(self, value):\n        if not value or '@' not in value:\n            raise ValidationError(self.message, code=self.code, params={'value': value})\n",
    "Location 3 (/root/hy/projects/django/django/core/validators.py lines 216-216)": "\n        if not self.user_regex.match(user_part):\n            raise ValidationError(self.message, code=self.code, params={'value': value})\n",
    "Location 4 (/root/hy/projects/django/django/core/validators.py lines 228-228)": "\n            raise ValidationError(self.message, code=self.code, params={'value': value})\n",
    "Location 5 (/root/hy/projects/django/django/core/validators.py lines 441-441)": "\n    def __call__(self, value):\n        digit_tuple, exponent = value.as_tuple()[1:]\n        if exponent in {'F', 'n', 'N'}:\n            raise ValidationError(self.messages['invalid'], params={'value': value})\n        if exponent >= 0:\n            # A positive exponent adds that many trailing zeros.\n            digits = len(digit_tuple) + exponent\n            decimals = 0\n        else:\n            # If the absolute value of the negative exponent is larger than the\n            # number of digits, then it's the same as the number of digits,\n            # because it'll consume all of the digits in digit_tuple and then\n            # add abs(exponent) - len(digit_tuple) leading zeros after the\n            # decimal point.\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/django/django/core/validators.py lines 51-51)": [
      "\n    def __call__(self, value):\n        \"\"\"\n        Validate that the input contains (or does *not* contain, if\n        inverse_match is True) a match for the regular expression.\n        \"\"\"\n        regex_matches = self.regex.search(str(value))\n        invalid_input = regex_matches if self.inverse_match else not regex_matches\n        if invalid_input:\n            raise ValidationError(self.message, code=self.code, params={'value': value})\n",
      "\n    def __call__(self, value):\n        \"\"\"\n        Validate that the input contains (or does *not* contain, if\n        inverse_match is True) a match for the regular expression.\n        \"\"\"\n        regex_matches = self.regex.search(str(value))\n        invalid_input = regex_matches if self.inverse_match else not regex_matches\n        if invalid_input:\n            raise ValidationError(self.message, code=self.code, params={'value': value})\n",
      "\n    def __call__(self, value):\n        \"\"\"\n        Validate that the input contains (or does *not* contain, if\n        inverse_match is True) a match for the regular expression.\n        \"\"\"\n        regex_matches = self.regex.search(str(value))\n        invalid_input = regex_matches if self.inverse_match else not regex_matches\n        if invalid_input:\n            raise ValidationError(self.message, code=self.code, params={'value': value})\n",
      "\n    def __call__(self, value):\n        \"\"\"\n        Validate that the input contains (or does *not* contain, if\n        inverse_match is True) a match for the regular expression.\n        \"\"\"\n        regex_matches = self.regex.search(str(value))\n        invalid_input = regex_matches if self.inverse_match else not regex_matches\n        if invalid_input:\n            raise ValidationError(self.message, code=self.code, params={'value': value})\n",
      "\n    def __call__(self, value):\n        \"\"\"\n        Validate that the input contains (or does *not* contain, if\n        inverse_match is True) a match for the regular expression.\n        \"\"\"\n        regex_matches = self.regex.search(str(value))\n        invalid_input = regex_matches if self.inverse_match else not regex_matches\n        if invalid_input:\n            raise ValidationError(self.message, code=self.code, params={'value': value})\n",
      "\n    def __call__(self, value):\n        \"\"\"\n        Validate that the input contains (or does *not* contain, if\n        inverse_match is True) a match for the regular expression.\n        \"\"\"\n        regex_matches = self.regex.search(str(value))\n        invalid_input = regex_matches if self.inverse_match else not regex_matches\n        if invalid_input:\n            raise ValidationError(self.message, code=self.code, params={'value': value})\n",
      "\n    def __call__(self, value):\n        \"\"\"\n        Validate that the input contains (or does *not* contain, if\n        inverse_match is True) a match for the regular expression.\n        \"\"\"\n        regex_matches = self.regex.search(str(value))\n        invalid_input = regex_matches if self.inverse_match else not regex_matches\n        if invalid_input:\n            raise ValidationError(self.message, code=self.code, params={'value': value})\n",
      "\n    def __call__(self, value):\n        \"\"\"\n        Validate that the input contains (or does *not* contain, if\n        inverse_match is True) a match for the regular expression.\n        \"\"\"\n        regex_matches = self.regex.search(str(value))\n        invalid_input = regex_matches if self.inverse_match else not regex_matches\n        if invalid_input:\n            raise ValidationError(self.message, code=self.code, params={'value': value})\n"
    ],
    "Location 2 (/root/hy/projects/django/django/core/validators.py lines 211-211)": [
      "\n    def __call__(self, value):\n        if not value or '@' not in value:\n            raise ValidationError(self.message, code=self.code, params={'value': value})\n",
      "\n    def __call__(self, value):\n        if not value or '@' not in value:\n            raise ValidationError(self.message, code=self.code, params={'value': value})\n\n        user_part, domain_part = value.rsplit('@', 1)\n\n        if not self.user_regex.match(user_part):\n            raise ValidationError(self.message, code=self.code, params={'value': value})\n\n        if (domain_part not in self.domain_allowlist and\n                not self.validate_domain_part(domain_part)):\n            # Try for possible IDN domain-part\n            try:\n                domain_part = punycode(domain_part)\n            except UnicodeError:\n                pass\n            else:\n                if self.validate_domain_part(domain_part):\n                    return\n            raise ValidationError(self.message, code=self.code, params={'value': value})\n",
      "\n    def __call__(self, value):\n        if not value or '@' not in value:\n            raise ValidationError(self.message, code=self.code, params={'value': value})\n",
      "\n    def __call__(self, value):\n        if not value or '@' not in value:\n            raise ValidationError(self.message, code=self.code, params={'value': value})\n",
      "\n    def __call__(self, value):\n        if not value or '@' not in value:\n            raise ValidationError(self.message, code=self.code, params={'value': value})\n",
      "\n    def __call__(self, value):\n        if not value or '@' not in value:\n            raise ValidationError(self.message, code=self.code, params={'value': value})\n",
      "\n    def __call__(self, value):\n        if not value or '@' not in value:\n            raise ValidationError(self.message, code=self.code, params={'value': value})\n",
      "\n    def __call__(self, value):\n        if not value or '@' not in value:\n            raise ValidationError(self.message, code=self.code, params={'value': value})\n"
    ],
    "Location 3 (/root/hy/projects/django/django/core/validators.py lines 216-216)": [
      "\n        if not self.user_regex.match(user_part):\n            raise ValidationError(self.message, code=self.code, params={'value': value})\n",
      "\n        if not self.user_regex.match(user_part):\n            raise ValidationError(self.message, code=self.code, params={'value': value})\n",
      "\n        if not self.user_regex.match(user_part):\n            raise ValidationError(self.message, code=self.code, params={'value': value})\n",
      "\n        if not self.user_regex.match(user_part):\n            raise ValidationError(self.message, code=self.code, params={'value': value})\n",
      "\n        if not self.user_regex.match(user_part):\n            raise ValidationError(self.message, code=self.code, params={'value': value})\n",
      "\n        if not self.user_regex.match(user_part):\n            raise ValidationError(self.message, code=self.code, params={'value': value})\n",
      "\n        if not self.user_regex.match(user_part):\n            raise ValidationError(self.message, code=self.code, params={'value': value})\n",
      "\n        if not self.user_regex.match(user_part):\n            raise ValidationError(self.message, code=self.code, params={'value': value})\n"
    ],
    "Location 4 (/root/hy/projects/django/django/core/validators.py lines 228-228)": [
      "\n            raise ValidationError(self.message, code=self.code, params={'value': value})\n",
      "\n            raise ValidationError(self.message, code=self.code, params={'value': value})\n",
      "\n            raise ValidationError(self.message, code=self.code, params={'value': value})\n",
      "\n            raise ValidationError(self.message, code=self.code, params={'value': value})\n",
      "\n            raise ValidationError(self.message, code=self.code, params={'value': value})\n",
      "\n            raise ValidationError(self.message, code=self.code, params={'value': value})\n",
      "\n            raise ValidationError(self.message, code=self.code, params={'value': value})\n",
      "\n            raise ValidationError(self.message, code=self.code, params={'value': value})\n"
    ],
    "Location 5 (/root/hy/projects/django/django/core/validators.py lines 441-441)": [
      "\n    def __call__(self, value):\n        digit_tuple, exponent = value.as_tuple()[1:]\n        if exponent in {'F', 'n', 'N'}:\n            raise ValidationError(self.messages['invalid'], params={'value': value})\n        if exponent >= 0:\n            # A positive exponent adds that many trailing zeros.\n            digits = len(digit_tuple) + exponent\n            decimals = 0\n        else:\n            # If the absolute value of the negative exponent is larger than the\n            # number of digits, then it's the same as the number of digits,\n            # because it'll consume all of the digits in digit_tuple and then\n            # add abs(exponent) - len(digit_tuple) leading zeros after the\n            # decimal point.\n",
      "\n    def __call__(self, value):\n        digit_tuple, exponent = value.as_tuple()[1:]\n        if exponent in {'F', 'n', 'N'}:\n            raise ValidationError(self.messages['invalid'], params={'value': value})\n        if exponent >= 0:\n            # A positive exponent adds that many trailing zeros.\n            digits = len(digit_tuple) + exponent\n            decimals = 0\n        else:\n            # If the absolute value of the negative exponent is larger than the\n            # number of digits, then it's the same as the number of digits,\n            # because it'll consume all of the digits in digit_tuple and then\n            # add abs(exponent) - len(digit_tuple) leading zeros after the\n            # decimal point.\n",
      "\n    def __call__(self, value):\n        digit_tuple, exponent = value.as_tuple()[1:]\n        if exponent in {'F', 'n', 'N'}:\n            raise ValidationError(self.messages['invalid'], params={'value': value})\n        if exponent >= 0:\n            # A positive exponent adds that many trailing zeros.\n            digits = len(digit_tuple) + exponent\n            decimals = 0\n        else:\n            # If the absolute value of the negative exponent is larger than the\n            # number of digits, then it's the same as the number of digits,\n            # because it'll consume all of the digits in digit_tuple and then\n            # add abs(exponent) - len(digit_tuple) leading zeros after the\n            # decimal point.\n",
      "\n    def __call__(self, value):\n        digit_tuple, exponent = value.as_tuple()[1:]\n        if exponent in {'F', 'n', 'N'}:\n            raise ValidationError(self.messages['invalid'], params={'value': value})\n        if exponent >= 0:\n            # A positive exponent adds that many trailing zeros.\n            digits = len(digit_tuple) + exponent\n            decimals = 0\n        else:\n            # If the absolute value of the negative exponent is larger than the\n            # number of digits, then it's the same as the number of digits,\n            # because it'll consume all of the digits in digit_tuple and then\n            # add abs(exponent) - len(digit_tuple) leading zeros after the\n            # decimal point.\n",
      "\n    def __call__(self, value):\n        digit_tuple, exponent = value.as_tuple()[1:]\n        if exponent in {'F', 'n', 'N'}:\n            raise ValidationError(self.messages['invalid'], params={'value': value})\n        if exponent >= 0:\n            # A positive exponent adds that many trailing zeros.\n            digits = len(digit_tuple) + exponent\n            decimals = 0\n        else:\n            # If the absolute value of the negative exponent is larger than the\n            # number of digits, then it's the same as the number of digits,\n            # because it'll consume all of the digits in digit_tuple and then\n            # add abs(exponent) - len(digit_tuple) leading zeros after the\n            # decimal point.\n",
      "\n    def __call__(self, value):\n        digit_tuple, exponent = value.as_tuple()[1:]\n        if exponent in {'F', 'n', 'N'}:\n            raise ValidationError(self.messages['invalid'], params={'value': value})\n        if exponent >= 0:\n            # A positive exponent adds that many trailing zeros.\n            digits = len(digit_tuple) + exponent\n            decimals = 0\n        else:\n            # If the absolute value of the negative exponent is larger than the\n            # number of digits, then it's the same as the number of digits,\n            # because it'll consume all of the digits in digit_tuple and then\n            # add abs(exponent) - len(digit_tuple) leading zeros after the\n            # decimal point.\n",
      "\n    def __call__(self, value):\n        digit_tuple, exponent = value.as_tuple()[1:]\n        if exponent in {'F', 'n', 'N'}:\n            raise ValidationError(self.messages['invalid'], params={'value': value})\n        if exponent >= 0:\n            # A positive exponent adds that many trailing zeros.\n            digits = len(digit_tuple) + exponent\n            decimals = 0\n        else:\n            # If the absolute value of the negative exponent is larger than the\n            # number of digits, then it's the same as the number of digits,\n            # because it'll consume all of the digits in digit_tuple and then\n            # add abs(exponent) - len(digit_tuple) leading zeros after the\n            # decimal point.\n",
      "\n    def __call__(self, value):\n        digit_tuple, exponent = value.as_tuple()[1:]\n        if exponent in {'F', 'n', 'N'}:\n            raise ValidationError(self.messages['invalid'], params={'value': value})\n        if exponent >= 0:\n            # A positive exponent adds that many trailing zeros.\n            digits = len(digit_tuple) + exponent\n            decimals = 0\n        else:\n            # If the absolute value of the negative exponent is larger than the\n            # number of digits, then it's the same as the number of digits,\n            # because it'll consume all of the digits in digit_tuple and then\n            # add abs(exponent) - len(digit_tuple) leading zeros after the\n            # decimal point.\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/core/validators.py b/django/core/validators.py\nindex 84b4f31ec7..c1fbd61311 100644\n--- a/django/core/validators.py\n+++ b/django/core/validators.py\n@@ -48,7 +48,8 @@ class RegexValidator:\n         regex_matches = self.regex.search(str(value))\n         invalid_input = regex_matches if self.inverse_match else not regex_matches\n         if invalid_input:\n-            raise ValidationError(self.message, code=self.code)\n+\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n     def __eq__(self, other):\n         return (\n@@ -208,12 +209,14 @@ class EmailValidator:\n \n     def __call__(self, value):\n         if not value or '@' not in value:\n-            raise ValidationError(self.message, code=self.code)\n+\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n         user_part, domain_part = value.rsplit('@', 1)\n \n         if not self.user_regex.match(user_part):\n-            raise ValidationError(self.message, code=self.code)\n+\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n         if (domain_part not in self.domain_allowlist and\n                 not self.validate_domain_part(domain_part)):\n@@ -225,7 +228,8 @@ class EmailValidator:\n             else:\n                 if self.validate_domain_part(domain_part):\n                     return\n-            raise ValidationError(self.message, code=self.code)\n+\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n     def validate_domain_part(self, domain_part):\n         if self.domain_regex.match(domain_part):\n@@ -438,7 +442,8 @@ class DecimalValidator:\n     def __call__(self, value):\n         digit_tuple, exponent = value.as_tuple()[1:]\n         if exponent in {'F', 'n', 'N'}:\n-            raise ValidationError(self.messages['invalid'])\n+\n+            raise ValidationError(self.messages['invalid'], params={'value': value})\n         if exponent >= 0:\n             # A positive exponent adds that many trailing zeros.\n             digits = len(digit_tuple) + exponent\n",
    "variant_0": "diff --git a/django/core/validators.py b/django/core/validators.py\nindex 84b4f31ec7..f48079c7f0 100644\n--- a/django/core/validators.py\n+++ b/django/core/validators.py\n@@ -48,7 +48,16 @@ class RegexValidator:\n         regex_matches = self.regex.search(str(value))\n         invalid_input = regex_matches if self.inverse_match else not regex_matches\n         if invalid_input:\n-            raise ValidationError(self.message, code=self.code)\n+\n+    def __call__(self, value):\n+        \"\"\"\n+        Validate that the input contains (or does *not* contain, if\n+        inverse_match is True) a match for the regular expression.\n+        \"\"\"\n+        regex_matches = self.regex.search(str(value))\n+        invalid_input = regex_matches if self.inverse_match else not regex_matches\n+        if invalid_input:\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n     def __eq__(self, other):\n         return (\n@@ -208,12 +217,17 @@ class EmailValidator:\n \n     def __call__(self, value):\n         if not value or '@' not in value:\n-            raise ValidationError(self.message, code=self.code)\n+\n+    def __call__(self, value):\n+        if not value or '@' not in value:\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n         user_part, domain_part = value.rsplit('@', 1)\n \n         if not self.user_regex.match(user_part):\n-            raise ValidationError(self.message, code=self.code)\n+\n+        if not self.user_regex.match(user_part):\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n         if (domain_part not in self.domain_allowlist and\n                 not self.validate_domain_part(domain_part)):\n@@ -225,7 +239,8 @@ class EmailValidator:\n             else:\n                 if self.validate_domain_part(domain_part):\n                     return\n-            raise ValidationError(self.message, code=self.code)\n+\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n     def validate_domain_part(self, domain_part):\n         if self.domain_regex.match(domain_part):\n@@ -438,7 +453,21 @@ class DecimalValidator:\n     def __call__(self, value):\n         digit_tuple, exponent = value.as_tuple()[1:]\n         if exponent in {'F', 'n', 'N'}:\n-            raise ValidationError(self.messages['invalid'])\n+\n+    def __call__(self, value):\n+        digit_tuple, exponent = value.as_tuple()[1:]\n+        if exponent in {'F', 'n', 'N'}:\n+            raise ValidationError(self.messages['invalid'], params={'value': value})\n+        if exponent >= 0:\n+            # A positive exponent adds that many trailing zeros.\n+            digits = len(digit_tuple) + exponent\n+            decimals = 0\n+        else:\n+            # If the absolute value of the negative exponent is larger than the\n+            # number of digits, then it's the same as the number of digits,\n+            # because it'll consume all of the digits in digit_tuple and then\n+            # add abs(exponent) - len(digit_tuple) leading zeros after the\n+            # decimal point.\n         if exponent >= 0:\n             # A positive exponent adds that many trailing zeros.\n             digits = len(digit_tuple) + exponent\n",
    "variant_1": "diff --git a/django/core/validators.py b/django/core/validators.py\nindex 84b4f31ec7..f48079c7f0 100644\n--- a/django/core/validators.py\n+++ b/django/core/validators.py\n@@ -48,7 +48,16 @@ class RegexValidator:\n         regex_matches = self.regex.search(str(value))\n         invalid_input = regex_matches if self.inverse_match else not regex_matches\n         if invalid_input:\n-            raise ValidationError(self.message, code=self.code)\n+\n+    def __call__(self, value):\n+        \"\"\"\n+        Validate that the input contains (or does *not* contain, if\n+        inverse_match is True) a match for the regular expression.\n+        \"\"\"\n+        regex_matches = self.regex.search(str(value))\n+        invalid_input = regex_matches if self.inverse_match else not regex_matches\n+        if invalid_input:\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n     def __eq__(self, other):\n         return (\n@@ -208,12 +217,17 @@ class EmailValidator:\n \n     def __call__(self, value):\n         if not value or '@' not in value:\n-            raise ValidationError(self.message, code=self.code)\n+\n+    def __call__(self, value):\n+        if not value or '@' not in value:\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n         user_part, domain_part = value.rsplit('@', 1)\n \n         if not self.user_regex.match(user_part):\n-            raise ValidationError(self.message, code=self.code)\n+\n+        if not self.user_regex.match(user_part):\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n         if (domain_part not in self.domain_allowlist and\n                 not self.validate_domain_part(domain_part)):\n@@ -225,7 +239,8 @@ class EmailValidator:\n             else:\n                 if self.validate_domain_part(domain_part):\n                     return\n-            raise ValidationError(self.message, code=self.code)\n+\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n     def validate_domain_part(self, domain_part):\n         if self.domain_regex.match(domain_part):\n@@ -438,7 +453,21 @@ class DecimalValidator:\n     def __call__(self, value):\n         digit_tuple, exponent = value.as_tuple()[1:]\n         if exponent in {'F', 'n', 'N'}:\n-            raise ValidationError(self.messages['invalid'])\n+\n+    def __call__(self, value):\n+        digit_tuple, exponent = value.as_tuple()[1:]\n+        if exponent in {'F', 'n', 'N'}:\n+            raise ValidationError(self.messages['invalid'], params={'value': value})\n+        if exponent >= 0:\n+            # A positive exponent adds that many trailing zeros.\n+            digits = len(digit_tuple) + exponent\n+            decimals = 0\n+        else:\n+            # If the absolute value of the negative exponent is larger than the\n+            # number of digits, then it's the same as the number of digits,\n+            # because it'll consume all of the digits in digit_tuple and then\n+            # add abs(exponent) - len(digit_tuple) leading zeros after the\n+            # decimal point.\n         if exponent >= 0:\n             # A positive exponent adds that many trailing zeros.\n             digits = len(digit_tuple) + exponent\n",
    "variant_2": "diff --git a/django/core/validators.py b/django/core/validators.py\nindex 84b4f31ec7..38b3216458 100644\n--- a/django/core/validators.py\n+++ b/django/core/validators.py\n@@ -48,7 +48,16 @@ class RegexValidator:\n         regex_matches = self.regex.search(str(value))\n         invalid_input = regex_matches if self.inverse_match else not regex_matches\n         if invalid_input:\n-            raise ValidationError(self.message, code=self.code)\n+\n+    def __call__(self, value):\n+        \"\"\"\n+        Validate that the input contains (or does *not* contain, if\n+        inverse_match is True) a match for the regular expression.\n+        \"\"\"\n+        regex_matches = self.regex.search(str(value))\n+        invalid_input = regex_matches if self.inverse_match else not regex_matches\n+        if invalid_input:\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n     def __eq__(self, other):\n         return (\n@@ -208,12 +217,34 @@ class EmailValidator:\n \n     def __call__(self, value):\n         if not value or '@' not in value:\n-            raise ValidationError(self.message, code=self.code)\n+\n+    def __call__(self, value):\n+        if not value or '@' not in value:\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n         user_part, domain_part = value.rsplit('@', 1)\n \n         if not self.user_regex.match(user_part):\n-            raise ValidationError(self.message, code=self.code)\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n+\n+        if (domain_part not in self.domain_allowlist and\n+                not self.validate_domain_part(domain_part)):\n+            # Try for possible IDN domain-part\n+            try:\n+                domain_part = punycode(domain_part)\n+            except UnicodeError:\n+                pass\n+            else:\n+                if self.validate_domain_part(domain_part):\n+                    return\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n+\n+        user_part, domain_part = value.rsplit('@', 1)\n+\n+        if not self.user_regex.match(user_part):\n+\n+        if not self.user_regex.match(user_part):\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n         if (domain_part not in self.domain_allowlist and\n                 not self.validate_domain_part(domain_part)):\n@@ -225,7 +256,8 @@ class EmailValidator:\n             else:\n                 if self.validate_domain_part(domain_part):\n                     return\n-            raise ValidationError(self.message, code=self.code)\n+\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n     def validate_domain_part(self, domain_part):\n         if self.domain_regex.match(domain_part):\n@@ -438,7 +470,21 @@ class DecimalValidator:\n     def __call__(self, value):\n         digit_tuple, exponent = value.as_tuple()[1:]\n         if exponent in {'F', 'n', 'N'}:\n-            raise ValidationError(self.messages['invalid'])\n+\n+    def __call__(self, value):\n+        digit_tuple, exponent = value.as_tuple()[1:]\n+        if exponent in {'F', 'n', 'N'}:\n+            raise ValidationError(self.messages['invalid'], params={'value': value})\n+        if exponent >= 0:\n+            # A positive exponent adds that many trailing zeros.\n+            digits = len(digit_tuple) + exponent\n+            decimals = 0\n+        else:\n+            # If the absolute value of the negative exponent is larger than the\n+            # number of digits, then it's the same as the number of digits,\n+            # because it'll consume all of the digits in digit_tuple and then\n+            # add abs(exponent) - len(digit_tuple) leading zeros after the\n+            # decimal point.\n         if exponent >= 0:\n             # A positive exponent adds that many trailing zeros.\n             digits = len(digit_tuple) + exponent\n",
    "variant_3": "diff --git a/django/core/validators.py b/django/core/validators.py\nindex 84b4f31ec7..f48079c7f0 100644\n--- a/django/core/validators.py\n+++ b/django/core/validators.py\n@@ -48,7 +48,16 @@ class RegexValidator:\n         regex_matches = self.regex.search(str(value))\n         invalid_input = regex_matches if self.inverse_match else not regex_matches\n         if invalid_input:\n-            raise ValidationError(self.message, code=self.code)\n+\n+    def __call__(self, value):\n+        \"\"\"\n+        Validate that the input contains (or does *not* contain, if\n+        inverse_match is True) a match for the regular expression.\n+        \"\"\"\n+        regex_matches = self.regex.search(str(value))\n+        invalid_input = regex_matches if self.inverse_match else not regex_matches\n+        if invalid_input:\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n     def __eq__(self, other):\n         return (\n@@ -208,12 +217,17 @@ class EmailValidator:\n \n     def __call__(self, value):\n         if not value or '@' not in value:\n-            raise ValidationError(self.message, code=self.code)\n+\n+    def __call__(self, value):\n+        if not value or '@' not in value:\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n         user_part, domain_part = value.rsplit('@', 1)\n \n         if not self.user_regex.match(user_part):\n-            raise ValidationError(self.message, code=self.code)\n+\n+        if not self.user_regex.match(user_part):\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n         if (domain_part not in self.domain_allowlist and\n                 not self.validate_domain_part(domain_part)):\n@@ -225,7 +239,8 @@ class EmailValidator:\n             else:\n                 if self.validate_domain_part(domain_part):\n                     return\n-            raise ValidationError(self.message, code=self.code)\n+\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n     def validate_domain_part(self, domain_part):\n         if self.domain_regex.match(domain_part):\n@@ -438,7 +453,21 @@ class DecimalValidator:\n     def __call__(self, value):\n         digit_tuple, exponent = value.as_tuple()[1:]\n         if exponent in {'F', 'n', 'N'}:\n-            raise ValidationError(self.messages['invalid'])\n+\n+    def __call__(self, value):\n+        digit_tuple, exponent = value.as_tuple()[1:]\n+        if exponent in {'F', 'n', 'N'}:\n+            raise ValidationError(self.messages['invalid'], params={'value': value})\n+        if exponent >= 0:\n+            # A positive exponent adds that many trailing zeros.\n+            digits = len(digit_tuple) + exponent\n+            decimals = 0\n+        else:\n+            # If the absolute value of the negative exponent is larger than the\n+            # number of digits, then it's the same as the number of digits,\n+            # because it'll consume all of the digits in digit_tuple and then\n+            # add abs(exponent) - len(digit_tuple) leading zeros after the\n+            # decimal point.\n         if exponent >= 0:\n             # A positive exponent adds that many trailing zeros.\n             digits = len(digit_tuple) + exponent\n",
    "variant_4": "diff --git a/django/core/validators.py b/django/core/validators.py\nindex 84b4f31ec7..f48079c7f0 100644\n--- a/django/core/validators.py\n+++ b/django/core/validators.py\n@@ -48,7 +48,16 @@ class RegexValidator:\n         regex_matches = self.regex.search(str(value))\n         invalid_input = regex_matches if self.inverse_match else not regex_matches\n         if invalid_input:\n-            raise ValidationError(self.message, code=self.code)\n+\n+    def __call__(self, value):\n+        \"\"\"\n+        Validate that the input contains (or does *not* contain, if\n+        inverse_match is True) a match for the regular expression.\n+        \"\"\"\n+        regex_matches = self.regex.search(str(value))\n+        invalid_input = regex_matches if self.inverse_match else not regex_matches\n+        if invalid_input:\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n     def __eq__(self, other):\n         return (\n@@ -208,12 +217,17 @@ class EmailValidator:\n \n     def __call__(self, value):\n         if not value or '@' not in value:\n-            raise ValidationError(self.message, code=self.code)\n+\n+    def __call__(self, value):\n+        if not value or '@' not in value:\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n         user_part, domain_part = value.rsplit('@', 1)\n \n         if not self.user_regex.match(user_part):\n-            raise ValidationError(self.message, code=self.code)\n+\n+        if not self.user_regex.match(user_part):\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n         if (domain_part not in self.domain_allowlist and\n                 not self.validate_domain_part(domain_part)):\n@@ -225,7 +239,8 @@ class EmailValidator:\n             else:\n                 if self.validate_domain_part(domain_part):\n                     return\n-            raise ValidationError(self.message, code=self.code)\n+\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n     def validate_domain_part(self, domain_part):\n         if self.domain_regex.match(domain_part):\n@@ -438,7 +453,21 @@ class DecimalValidator:\n     def __call__(self, value):\n         digit_tuple, exponent = value.as_tuple()[1:]\n         if exponent in {'F', 'n', 'N'}:\n-            raise ValidationError(self.messages['invalid'])\n+\n+    def __call__(self, value):\n+        digit_tuple, exponent = value.as_tuple()[1:]\n+        if exponent in {'F', 'n', 'N'}:\n+            raise ValidationError(self.messages['invalid'], params={'value': value})\n+        if exponent >= 0:\n+            # A positive exponent adds that many trailing zeros.\n+            digits = len(digit_tuple) + exponent\n+            decimals = 0\n+        else:\n+            # If the absolute value of the negative exponent is larger than the\n+            # number of digits, then it's the same as the number of digits,\n+            # because it'll consume all of the digits in digit_tuple and then\n+            # add abs(exponent) - len(digit_tuple) leading zeros after the\n+            # decimal point.\n         if exponent >= 0:\n             # A positive exponent adds that many trailing zeros.\n             digits = len(digit_tuple) + exponent\n",
    "variant_5": "diff --git a/django/core/validators.py b/django/core/validators.py\nindex 84b4f31ec7..f48079c7f0 100644\n--- a/django/core/validators.py\n+++ b/django/core/validators.py\n@@ -48,7 +48,16 @@ class RegexValidator:\n         regex_matches = self.regex.search(str(value))\n         invalid_input = regex_matches if self.inverse_match else not regex_matches\n         if invalid_input:\n-            raise ValidationError(self.message, code=self.code)\n+\n+    def __call__(self, value):\n+        \"\"\"\n+        Validate that the input contains (or does *not* contain, if\n+        inverse_match is True) a match for the regular expression.\n+        \"\"\"\n+        regex_matches = self.regex.search(str(value))\n+        invalid_input = regex_matches if self.inverse_match else not regex_matches\n+        if invalid_input:\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n     def __eq__(self, other):\n         return (\n@@ -208,12 +217,17 @@ class EmailValidator:\n \n     def __call__(self, value):\n         if not value or '@' not in value:\n-            raise ValidationError(self.message, code=self.code)\n+\n+    def __call__(self, value):\n+        if not value or '@' not in value:\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n         user_part, domain_part = value.rsplit('@', 1)\n \n         if not self.user_regex.match(user_part):\n-            raise ValidationError(self.message, code=self.code)\n+\n+        if not self.user_regex.match(user_part):\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n         if (domain_part not in self.domain_allowlist and\n                 not self.validate_domain_part(domain_part)):\n@@ -225,7 +239,8 @@ class EmailValidator:\n             else:\n                 if self.validate_domain_part(domain_part):\n                     return\n-            raise ValidationError(self.message, code=self.code)\n+\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n     def validate_domain_part(self, domain_part):\n         if self.domain_regex.match(domain_part):\n@@ -438,7 +453,21 @@ class DecimalValidator:\n     def __call__(self, value):\n         digit_tuple, exponent = value.as_tuple()[1:]\n         if exponent in {'F', 'n', 'N'}:\n-            raise ValidationError(self.messages['invalid'])\n+\n+    def __call__(self, value):\n+        digit_tuple, exponent = value.as_tuple()[1:]\n+        if exponent in {'F', 'n', 'N'}:\n+            raise ValidationError(self.messages['invalid'], params={'value': value})\n+        if exponent >= 0:\n+            # A positive exponent adds that many trailing zeros.\n+            digits = len(digit_tuple) + exponent\n+            decimals = 0\n+        else:\n+            # If the absolute value of the negative exponent is larger than the\n+            # number of digits, then it's the same as the number of digits,\n+            # because it'll consume all of the digits in digit_tuple and then\n+            # add abs(exponent) - len(digit_tuple) leading zeros after the\n+            # decimal point.\n         if exponent >= 0:\n             # A positive exponent adds that many trailing zeros.\n             digits = len(digit_tuple) + exponent\n",
    "variant_6": "diff --git a/django/core/validators.py b/django/core/validators.py\nindex 84b4f31ec7..f48079c7f0 100644\n--- a/django/core/validators.py\n+++ b/django/core/validators.py\n@@ -48,7 +48,16 @@ class RegexValidator:\n         regex_matches = self.regex.search(str(value))\n         invalid_input = regex_matches if self.inverse_match else not regex_matches\n         if invalid_input:\n-            raise ValidationError(self.message, code=self.code)\n+\n+    def __call__(self, value):\n+        \"\"\"\n+        Validate that the input contains (or does *not* contain, if\n+        inverse_match is True) a match for the regular expression.\n+        \"\"\"\n+        regex_matches = self.regex.search(str(value))\n+        invalid_input = regex_matches if self.inverse_match else not regex_matches\n+        if invalid_input:\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n     def __eq__(self, other):\n         return (\n@@ -208,12 +217,17 @@ class EmailValidator:\n \n     def __call__(self, value):\n         if not value or '@' not in value:\n-            raise ValidationError(self.message, code=self.code)\n+\n+    def __call__(self, value):\n+        if not value or '@' not in value:\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n         user_part, domain_part = value.rsplit('@', 1)\n \n         if not self.user_regex.match(user_part):\n-            raise ValidationError(self.message, code=self.code)\n+\n+        if not self.user_regex.match(user_part):\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n         if (domain_part not in self.domain_allowlist and\n                 not self.validate_domain_part(domain_part)):\n@@ -225,7 +239,8 @@ class EmailValidator:\n             else:\n                 if self.validate_domain_part(domain_part):\n                     return\n-            raise ValidationError(self.message, code=self.code)\n+\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n     def validate_domain_part(self, domain_part):\n         if self.domain_regex.match(domain_part):\n@@ -438,7 +453,21 @@ class DecimalValidator:\n     def __call__(self, value):\n         digit_tuple, exponent = value.as_tuple()[1:]\n         if exponent in {'F', 'n', 'N'}:\n-            raise ValidationError(self.messages['invalid'])\n+\n+    def __call__(self, value):\n+        digit_tuple, exponent = value.as_tuple()[1:]\n+        if exponent in {'F', 'n', 'N'}:\n+            raise ValidationError(self.messages['invalid'], params={'value': value})\n+        if exponent >= 0:\n+            # A positive exponent adds that many trailing zeros.\n+            digits = len(digit_tuple) + exponent\n+            decimals = 0\n+        else:\n+            # If the absolute value of the negative exponent is larger than the\n+            # number of digits, then it's the same as the number of digits,\n+            # because it'll consume all of the digits in digit_tuple and then\n+            # add abs(exponent) - len(digit_tuple) leading zeros after the\n+            # decimal point.\n         if exponent >= 0:\n             # A positive exponent adds that many trailing zeros.\n             digits = len(digit_tuple) + exponent\n",
    "variant_7": "diff --git a/django/core/validators.py b/django/core/validators.py\nindex 84b4f31ec7..f48079c7f0 100644\n--- a/django/core/validators.py\n+++ b/django/core/validators.py\n@@ -48,7 +48,16 @@ class RegexValidator:\n         regex_matches = self.regex.search(str(value))\n         invalid_input = regex_matches if self.inverse_match else not regex_matches\n         if invalid_input:\n-            raise ValidationError(self.message, code=self.code)\n+\n+    def __call__(self, value):\n+        \"\"\"\n+        Validate that the input contains (or does *not* contain, if\n+        inverse_match is True) a match for the regular expression.\n+        \"\"\"\n+        regex_matches = self.regex.search(str(value))\n+        invalid_input = regex_matches if self.inverse_match else not regex_matches\n+        if invalid_input:\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n     def __eq__(self, other):\n         return (\n@@ -208,12 +217,17 @@ class EmailValidator:\n \n     def __call__(self, value):\n         if not value or '@' not in value:\n-            raise ValidationError(self.message, code=self.code)\n+\n+    def __call__(self, value):\n+        if not value or '@' not in value:\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n         user_part, domain_part = value.rsplit('@', 1)\n \n         if not self.user_regex.match(user_part):\n-            raise ValidationError(self.message, code=self.code)\n+\n+        if not self.user_regex.match(user_part):\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n         if (domain_part not in self.domain_allowlist and\n                 not self.validate_domain_part(domain_part)):\n@@ -225,7 +239,8 @@ class EmailValidator:\n             else:\n                 if self.validate_domain_part(domain_part):\n                     return\n-            raise ValidationError(self.message, code=self.code)\n+\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n     def validate_domain_part(self, domain_part):\n         if self.domain_regex.match(domain_part):\n@@ -438,7 +453,21 @@ class DecimalValidator:\n     def __call__(self, value):\n         digit_tuple, exponent = value.as_tuple()[1:]\n         if exponent in {'F', 'n', 'N'}:\n-            raise ValidationError(self.messages['invalid'])\n+\n+    def __call__(self, value):\n+        digit_tuple, exponent = value.as_tuple()[1:]\n+        if exponent in {'F', 'n', 'N'}:\n+            raise ValidationError(self.messages['invalid'], params={'value': value})\n+        if exponent >= 0:\n+            # A positive exponent adds that many trailing zeros.\n+            digits = len(digit_tuple) + exponent\n+            decimals = 0\n+        else:\n+            # If the absolute value of the negative exponent is larger than the\n+            # number of digits, then it's the same as the number of digits,\n+            # because it'll consume all of the digits in digit_tuple and then\n+            # add abs(exponent) - len(digit_tuple) leading zeros after the\n+            # decimal point.\n         if exponent >= 0:\n             # A positive exponent adds that many trailing zeros.\n             digits = len(digit_tuple) + exponent\n",
    "variant_8": "diff --git a/django/core/validators.py b/django/core/validators.py\nindex 84b4f31ec7..f48079c7f0 100644\n--- a/django/core/validators.py\n+++ b/django/core/validators.py\n@@ -48,7 +48,16 @@ class RegexValidator:\n         regex_matches = self.regex.search(str(value))\n         invalid_input = regex_matches if self.inverse_match else not regex_matches\n         if invalid_input:\n-            raise ValidationError(self.message, code=self.code)\n+\n+    def __call__(self, value):\n+        \"\"\"\n+        Validate that the input contains (or does *not* contain, if\n+        inverse_match is True) a match for the regular expression.\n+        \"\"\"\n+        regex_matches = self.regex.search(str(value))\n+        invalid_input = regex_matches if self.inverse_match else not regex_matches\n+        if invalid_input:\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n     def __eq__(self, other):\n         return (\n@@ -208,12 +217,17 @@ class EmailValidator:\n \n     def __call__(self, value):\n         if not value or '@' not in value:\n-            raise ValidationError(self.message, code=self.code)\n+\n+    def __call__(self, value):\n+        if not value or '@' not in value:\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n         user_part, domain_part = value.rsplit('@', 1)\n \n         if not self.user_regex.match(user_part):\n-            raise ValidationError(self.message, code=self.code)\n+\n+        if not self.user_regex.match(user_part):\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n         if (domain_part not in self.domain_allowlist and\n                 not self.validate_domain_part(domain_part)):\n@@ -225,7 +239,8 @@ class EmailValidator:\n             else:\n                 if self.validate_domain_part(domain_part):\n                     return\n-            raise ValidationError(self.message, code=self.code)\n+\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n     def validate_domain_part(self, domain_part):\n         if self.domain_regex.match(domain_part):\n@@ -438,7 +453,21 @@ class DecimalValidator:\n     def __call__(self, value):\n         digit_tuple, exponent = value.as_tuple()[1:]\n         if exponent in {'F', 'n', 'N'}:\n-            raise ValidationError(self.messages['invalid'])\n+\n+    def __call__(self, value):\n+        digit_tuple, exponent = value.as_tuple()[1:]\n+        if exponent in {'F', 'n', 'N'}:\n+            raise ValidationError(self.messages['invalid'], params={'value': value})\n+        if exponent >= 0:\n+            # A positive exponent adds that many trailing zeros.\n+            digits = len(digit_tuple) + exponent\n+            decimals = 0\n+        else:\n+            # If the absolute value of the negative exponent is larger than the\n+            # number of digits, then it's the same as the number of digits,\n+            # because it'll consume all of the digits in digit_tuple and then\n+            # add abs(exponent) - len(digit_tuple) leading zeros after the\n+            # decimal point.\n         if exponent >= 0:\n             # A positive exponent adds that many trailing zeros.\n             digits = len(digit_tuple) + exponent\n"
  }
}