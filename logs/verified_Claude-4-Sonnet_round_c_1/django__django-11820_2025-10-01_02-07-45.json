{
  "zero_patches": {
    "Location 1 (/root/hy/projects/django/django/db/models/base.py lines 1709-1714)": "\n        # Check related fields.\n        for field in related_fields:\n            _cls = cls\n            fld = None\n            for part in field.split(LOOKUP_SEP):\n                try:\n                    # Skip validation for 'pk' as it's always valid\n                    if part == 'pk':\n                        continue\n                    fld = _cls._meta.get_field(part)\n                    if fld.is_relation:\n                        _cls = fld.get_path_info()[-1].to_opts.model\n                except (FieldDoesNotExist, AttributeError):\n                    # Don't report error if the failed part is 'pk'\n                    if part == 'pk':\n                        continue\n                    if fld is None or fld.get_transform(part) is None:\n                        errors.append(\n                            checks.Error(\n                                \"'ordering' refers to the nonexistent field, \"\n                                \"related field, or lookup '%s'.\" % field,\n                                obj=cls,\n                                id='models.E015',\n                            )\n                        )\n",
    "Location 2 (/root/hy/projects/django/django/db/models/base.py lines 1715-1723)": "\n        # Check related fields.\n        for field in related_fields:\n            _cls = cls\n            fld = None\n            for part in field.split(LOOKUP_SEP):\n                # Skip pk validation for related fields, similar to direct fields\n                if part == 'pk':\n                    continue\n                try:\n                    fld = _cls._meta.get_field(part)\n                    if fld.is_relation:\n                        _cls = fld.get_path_info()[-1].to_opts.model\n                except (FieldDoesNotExist, AttributeError):\n                    if fld is None or fld.get_transform(part) is None:\n                        errors.append(\n                            checks.Error(\n                                \"'ordering' refers to the nonexistent field, \"\n                                \"related field, or lookup '%s'.\" % field,\n                                obj=cls,\n                                id='models.E015',\n                            )\n                        )\n",
    "Location 3 (/root/hy/projects/django/django/db/models/base.py lines 1725-1727)": "\n                # Skip ordering on pk. This is always a valid order_by field\n                # but is an alias and therefore won't be found by opts.get_field.\n                if part == 'pk':\n                    continue\n                    \n                try:\n                    fld = fld.remote_field.model._meta.get_field(part)\n                except FieldDoesNotExist:\n                    if fld is None or fld.get_transform(part) is None:\n                        errors.append(\n                            checks.Error(\n                                \"'ordering' refers to the nonexistent field, \"\n                                \"related field, or lookup '%s'.\" % field,\n                                obj=cls,\n                                id='models.E015',\n                            )\n                        )\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/django/django/db/models/base.py lines 1709-1714)": [
      "\n        # Check related fields.\n        for field in related_fields:\n            _cls = cls\n            fld = None\n            for part in field.split(LOOKUP_SEP):\n                try:\n                    # Skip validation for 'pk' as it's a valid alias\n                    if part == 'pk':\n                        continue\n                    fld = _cls._meta.get_field(part)\n                    if fld.is_relation:\n                        _cls = fld.get_path_info()[-1].to_opts.model\n                except (FieldDoesNotExist, AttributeError):\n                    # Don't error on 'pk' at the end of related field lookups\n                    if part == 'pk':\n                        continue\n                    if fld is None or fld.get_transform(part) is None:\n                        errors.append(\n                            checks.Error(\n                                \"'ordering' refers to the nonexistent field, \"\n                                \"related field, or lookup '%s'.\" % field,\n                                obj=cls,\n                                id='models.E015',\n                            )\n                        )\n",
      "\n        # Check related fields.\n        for field in related_fields:\n            _cls = cls\n            fld = None\n            for part in field.split(LOOKUP_SEP):\n                try:\n                    # Skip validation for 'pk' as it's always valid\n                    if part == 'pk':\n                        continue\n                    fld = _cls._meta.get_field(part)\n                    if fld.is_relation:\n                        _cls = fld.get_path_info()[-1].to_opts.model\n                except (FieldDoesNotExist, AttributeError):\n                    # Don't report error for 'pk' at end of lookup\n                    if part == 'pk':\n                        continue\n                    if fld is None or fld.get_transform(part) is None:\n                        errors.append(\n                            checks.Error(\n                                \"'ordering' refers to the nonexistent field, \"\n                                \"related field, or lookup '%s'.\" % field,\n                                obj=cls,\n                                id='models.E015',\n                            )\n                        )\n",
      "\n        # Check related fields.\n        for field in related_fields:\n            _cls = cls\n            fld = None\n            for part in field.split(LOOKUP_SEP):\n                try:\n                    # Skip validation for 'pk' since it's always valid but won't be found by get_field\n                    if part == 'pk':\n                        continue\n                    fld = _cls._meta.get_field(part)\n                    if fld.is_relation:\n                        _cls = fld.get_path_info()[-1].to_opts.model\n                except (FieldDoesNotExist, AttributeError):\n                    # Don't report error for 'pk' at the end of related field lookups\n                    if part == 'pk':\n                        continue\n                    if fld is None or fld.get_transform(part) is None:\n                        errors.append(\n                            checks.Error(\n                                \"'ordering' refers to the nonexistent field, \"\n                                \"related field, or lookup '%s'.\" % field,\n                                obj=cls,\n                                id='models.E015',\n                            )\n                        )\n",
      "\n        # Check related fields.\n        for field in related_fields:\n            _cls = cls\n            fld = None\n            for part in field.split(LOOKUP_SEP):\n                # Skip pk validation for related fields, similar to direct fields\n                if part == 'pk':\n                    continue\n                try:\n                    fld = _cls._meta.get_field(part)\n                    if fld.is_relation:\n                        _cls = fld.get_path_info()[-1].to_opts.model\n                except (FieldDoesNotExist, AttributeError):\n                    if fld is None or fld.get_transform(part) is None:\n                        errors.append(\n                            checks.Error(\n                                \"'ordering' refers to the nonexistent field, \"\n                                \"related field, or lookup '%s'.\" % field,\n                                obj=cls,\n                                id='models.E015',\n                            )\n                        )\n",
      "\n        # Check related fields.\n        for field in related_fields:\n            _cls = cls\n            fld = None\n            for part in field.split(LOOKUP_SEP):\n                try:\n                    # Skip pk validation as it's always valid\n                    if part == 'pk':\n                        continue\n                    fld = _cls._meta.get_field(part)\n                    if fld.is_relation:\n                        _cls = fld.get_path_info()[-1].to_opts.model\n                except (FieldDoesNotExist, AttributeError):\n                    if fld is None or fld.get_transform(part) is None:\n                        # Don't generate error for pk lookups\n                        if part != 'pk':\n                            errors.append(\n                                checks.Error(\n                                    \"'ordering' refers to the nonexistent field, \"\n                                    \"related field, or lookup '%s'.\" % field,\n                                    obj=cls,\n                                    id='models.E015',\n                                )\n                            )\n",
      "\n        # Check related fields.\n        for field in related_fields:\n            _cls = cls\n            fld = None\n            for part in field.split(LOOKUP_SEP):\n                try:\n                    # Skip validation for 'pk' as it's always valid\n                    if part == 'pk':\n                        continue\n                    fld = _cls._meta.get_field(part)\n                    if fld.is_relation:\n                        _cls = fld.get_path_info()[-1].to_opts.model\n                except (FieldDoesNotExist, AttributeError):\n                    # Don't error on 'pk' at the end of related field lookups\n                    if part == 'pk':\n                        continue\n                    if fld is None or fld.get_transform(part) is None:\n                        errors.append(\n                            checks.Error(\n                                \"'ordering' refers to the nonexistent field, \"\n                                \"related field, or lookup '%s'.\" % field,\n                                obj=cls,\n                                id='models.E015',\n                            )\n                        )\n",
      "\n        # Check related fields.\n        for field in related_fields:\n            _cls = cls\n            fld = None\n            for part in field.split(LOOKUP_SEP):\n                try:\n                    # Skip validation for 'pk' as it's always valid\n                    if part == 'pk':\n                        continue\n                    fld = _cls._meta.get_field(part)\n                    if fld.is_relation:\n                        _cls = fld.get_path_info()[-1].to_opts.model\n                except (FieldDoesNotExist, AttributeError):\n                    if fld is None or fld.get_transform(part) is None:\n                        # Don't error if the failed part is 'pk'\n                        if part != 'pk':\n                            errors.append(\n                                checks.Error(\n                                    \"'ordering' refers to the nonexistent field, \"\n                                    \"related field, or lookup '%s'.\" % field,\n                                    obj=cls,\n                                    id='models.E015',\n                                )\n                            )\n",
      "\n        # Check related fields.\n        for field in related_fields:\n            _cls = cls\n            fld = None\n            for part in field.split(LOOKUP_SEP):\n                try:\n                    # Skip validation for 'pk' as it's always a valid alias\n                    if part == 'pk':\n                        continue\n                    fld = _cls._meta.get_field(part)\n                    if fld.is_relation:\n                        _cls = fld.get_path_info()[-1].to_opts.model\n                except (FieldDoesNotExist, AttributeError):\n                    # Don't report error if the last part is 'pk' (valid alias)\n                    if part == 'pk' and field.endswith('__pk'):\n                        continue\n                    if fld is None or fld.get_transform(part) is None:\n                        errors.append(\n                            checks.Error(\n                                \"'ordering' refers to the nonexistent field, \"\n                                \"related field, or lookup '%s'.\" % field,\n                                obj=cls,\n                                id='models.E015',\n                            )\n                        )\n"
    ],
    "Location 2 (/root/hy/projects/django/django/db/models/base.py lines 1715-1723)": [
      "\n        # Check related fields.\n        for field in related_fields:\n            _cls = cls\n            fld = None\n            for part in field.split(LOOKUP_SEP):\n                # Skip pk validation for related fields, similar to direct fields\n                if part == 'pk':\n                    continue\n                try:\n                    fld = _cls._meta.get_field(part)\n                    if fld.is_relation:\n                        _cls = fld.get_path_info()[-1].to_opts.model\n                except (FieldDoesNotExist, AttributeError):\n                    if fld is None or fld.get_transform(part) is None:\n                        errors.append(\n                            checks.Error(\n                                \"'ordering' refers to the nonexistent field, \"\n                                \"related field, or lookup '%s'.\" % field,\n                                obj=cls,\n                                id='models.E015',\n                            )\n                        )\n",
      "\n        # Check related fields.\n        for field in related_fields:\n            _cls = cls\n            fld = None\n            for part in field.split(LOOKUP_SEP):\n                # Skip validation for 'pk' as it's always a valid alias\n                if part == 'pk':\n                    continue\n                try:\n                    fld = _cls._meta.get_field(part)\n                    if fld.is_relation:\n                        _cls = fld.get_path_info()[-1].to_opts.model\n                except (FieldDoesNotExist, AttributeError):\n                    if fld is None or fld.get_transform(part) is None:\n                        errors.append(\n                            checks.Error(\n                                \"'ordering' refers to the nonexistent field, \"\n                                \"related field, or lookup '%s'.\" % field,\n                                obj=cls,\n                                id='models.E015',\n                            )\n                        )\n",
      "\n        # Check related fields.\n        for field in related_fields:\n            _cls = cls\n            fld = None\n            for part in field.split(LOOKUP_SEP):\n                # Skip pk validation as it's always valid but won't be found by get_field\n                if part == 'pk':\n                    continue\n                try:\n                    fld = _cls._meta.get_field(part)\n                    if fld.is_relation:\n                        _cls = fld.get_path_info()[-1].to_opts.model\n                except (FieldDoesNotExist, AttributeError):\n                    # Don't error on pk at the end of a related field lookup\n                    if part == 'pk':\n                        continue\n                    if fld is None or fld.get_transform(part) is None:\n                        errors.append(\n                            checks.Error(\n                                \"'ordering' refers to the nonexistent field, \"\n                                \"related field, or lookup '%s'.\" % field,\n                                obj=cls,\n                                id='models.E015',\n                            )\n                        )\n",
      "\n        # Check related fields.\n        for field in related_fields:\n            _cls = cls\n            fld = None\n            for part in field.split(LOOKUP_SEP):\n                # Skip pk validation as it's always valid but won't be found by get_field\n                if part == 'pk':\n                    continue\n                try:\n                    fld = _cls._meta.get_field(part)\n                    if fld.is_relation:\n                        _cls = fld.get_path_info()[-1].to_opts.model\n                except (FieldDoesNotExist, AttributeError):\n                    # Don't error on pk at the end of a related field lookup\n                    if part == 'pk':\n                        continue\n                    if fld is None or fld.get_transform(part) is None:\n                        errors.append(\n                            checks.Error(\n                                \"'ordering' refers to the nonexistent field, \"\n                                \"related field, or lookup '%s'.\" % field,\n                                obj=cls,\n                                id='models.E015',\n                            )\n                        )\n",
      "\n        # Check related fields.\n        for field in related_fields:\n            _cls = cls\n            fld = None\n            for part in field.split(LOOKUP_SEP):\n                # Skip pk validation in related field lookups, similar to direct fields\n                if part == 'pk':\n                    continue\n                try:\n                    fld = _cls._meta.get_field(part)\n                    if fld.is_relation:\n                        _cls = fld.get_path_info()[-1].to_opts.model\n                except (FieldDoesNotExist, AttributeError):\n                    if fld is None or fld.get_transform(part) is None:\n                        errors.append(\n                            checks.Error(\n                                \"'ordering' refers to the nonexistent field, \"\n                                \"related field, or lookup '%s'.\" % field,\n                                obj=cls,\n                                id='models.E015',\n                            )\n                        )\n",
      "\n        # Check related fields.\n        for field in related_fields:\n            _cls = cls\n            fld = None\n            for part in field.split(LOOKUP_SEP):\n                # Skip pk validation as it's always valid but is an alias\n                if part == 'pk':\n                    continue\n                try:\n                    fld = _cls._meta.get_field(part)\n                    if fld.is_relation:\n                        _cls = fld.get_path_info()[-1].to_opts.model\n                except (FieldDoesNotExist, AttributeError):\n                    # Check if this is a pk at the end of a related field lookup\n                    if part == 'pk':\n                        continue\n                    if fld is None or fld.get_transform(part) is None:\n                        errors.append(\n                            checks.Error(\n                                \"'ordering' refers to the nonexistent field, \"\n                                \"related field, or lookup '%s'.\" % field,\n                                obj=cls,\n                                id='models.E015',\n                            )\n                        )\n",
      "\n        # Check related fields.\n        for field in related_fields:\n            _cls = cls\n            fld = None\n            for part in field.split(LOOKUP_SEP):\n                # Skip pk validation - it's always valid but is an alias\n                if part == 'pk':\n                    continue\n                try:\n                    fld = _cls._meta.get_field(part)\n                    if fld.is_relation:\n                        _cls = fld.get_path_info()[-1].to_opts.model\n                except (FieldDoesNotExist, AttributeError):\n                    # Check if this is the last part and it's 'pk'\n                    field_parts = field.split(LOOKUP_SEP)\n                    if part == field_parts[-1] and part == 'pk':\n                        continue\n                    if fld is None or fld.get_transform(part) is None:\n                        errors.append(\n                            checks.Error(\n                                \"'ordering' refers to the nonexistent field, \"\n                                \"related field, or lookup '%s'.\" % field,\n                                obj=cls,\n                                id='models.E015',\n                            )\n                        )\n",
      "\n        # Check related fields.\n        for field in related_fields:\n            _cls = cls\n            fld = None\n            for part in field.split(LOOKUP_SEP):\n                # Skip pk validation as it's always valid but is an alias\n                if part == 'pk':\n                    continue\n                try:\n                    fld = _cls._meta.get_field(part)\n                    if fld.is_relation:\n                        _cls = fld.get_path_info()[-1].to_opts.model\n                except (FieldDoesNotExist, AttributeError):\n                    # Check if this is a pk reference at the end of a related field lookup\n                    if part == 'pk':\n                        continue\n                    if fld is None or fld.get_transform(part) is None:\n                        errors.append(\n                            checks.Error(\n                                \"'ordering' refers to the nonexistent field, \"\n                                \"related field, or lookup '%s'.\" % field,\n                                obj=cls,\n                                id='models.E015',\n                            )\n                        )\n"
    ],
    "Location 3 (/root/hy/projects/django/django/db/models/base.py lines 1725-1727)": [
      "\n                # Skip pk lookups as they are always valid but won't be found by get_field\n                if part == 'pk':\n                    continue\n                try:\n                    fld = fld.remote_field.model._meta.get_field(part)\n                except FieldDoesNotExist:\n                    if fld is None or fld.get_transform(part) is None:\n                        errors.append(\n                            checks.Error(\n                                \"'ordering' refers to the nonexistent field, \"\n                                \"related field, or lookup '%s'.\" % field,\n                                obj=cls,\n                                id='models.E015',\n                            )\n                        )\n",
      "\n                    if fld is None or fld.get_transform(part) is None:\n                        # Skip pk lookups as they are always valid but won't be found by get_field\n                        if part == 'pk':\n                            continue\n                        errors.append(\n                            checks.Error(\n                                \"'ordering' refers to the nonexistent field, \"\n                                \"related field, or lookup '%s'.\" % field,\n                                obj=cls,\n                                id='models.E015',\n                            )\n                        )\n",
      "\n                    if part == 'pk':\n                        # Skip validation for 'pk' as it's always a valid field alias\n                        continue\n                    if fld is None or fld.get_transform(part) is None:\n                        errors.append(\n                            checks.Error(\n                                \"'ordering' refers to the nonexistent field, \"\n                                \"related field, or lookup '%s'.\" % field,\n                                obj=cls,\n                                id='models.E015',\n                            )\n                        )\n\n        # Skip ordering on pk. This is always a valid order_by field\n        # but is an alias and therefore won't be found by opts.get_field.\n        fields = {f for f in fields if f != 'pk'}\n",
      "\n                    if part == 'pk':\n                        # Skip validation for 'pk' as it's always a valid alias\n                        continue\n                    try:\n                        fld = fld.get_field(part)\n                    except (FieldDoesNotExist, AttributeError):\n                        if fld is None or fld.get_transform(part) is None:\n                            # Don't generate error for 'pk' at end of lookup chain\n                            if part != 'pk':\n                                errors.append(\n                                    checks.Error(\n                                        \"'ordering' refers to the nonexistent field, \"\n                                        \"related field, or lookup '%s'.\" % field,\n                                        obj=cls,\n                                        id='models.E015',\n                                    )\n                                )\n",
      "\n                    if part == 'pk':\n                        # Skip validation for 'pk' as it's always valid but is an alias\n                        continue\n                    try:\n                        fld = opts.get_field(part)\n                    except FieldDoesNotExist:\n                        return field\n                    if fld.many_to_many:\n                        return field\n                    # For reverse and forward references, use the target model's _meta.\n                    if fld.is_relation:\n                        opts = fld.related_model._meta\n                    else:\n                        opts = None\n                else:\n                    # Last part could be a transform; no need to check it further.\n                    if fld is None or fld.get_transform(part) is None:\n                        # Don't generate error if the last part is 'pk' since it's always valid\n                        if part != 'pk':\n                            errors.append(\n                                checks.Error(\n                                    \"'ordering' refers to the nonexistent field, \"\n                                    \"related field, or lookup '%s'.\" % field,\n                                    obj=cls,\n                                    id='models.E015',\n                                )\n                            )\n",
      "\n                    if fld is None or fld.get_transform(part) is None:\n                        # Skip validation for 'pk' at the end of related field lookups\n                        # since 'pk' is always a valid ordering field alias\n                        if part == 'pk' and i == len(parts) - 1:\n                            continue\n                        errors.append(\n                            checks.Error(\n                                \"'ordering' refers to the nonexistent field, \"\n                                \"related field, or lookup '%s'.\" % field,\n                                obj=cls,\n                                id='models.E015',\n                            )\n                        )\n",
      "\n                    # Skip pk lookups as they are always valid but won't be found by get_field\n                    if part == 'pk':\n                        continue\n                    \n                    try:\n                        fld = fld.get_field(part)\n                    except (FieldDoesNotExist, AttributeError):\n                        if fld is None or fld.get_transform(part) is None:\n                            # Don't error on pk at end of related field lookup\n                            if part == 'pk':\n                                continue\n                            errors.append(\n                                checks.Error(\n                                    \"'ordering' refers to the nonexistent field, \"\n                                    \"related field, or lookup '%s'.\" % field,\n                                    obj=cls,\n                                    id='models.E015',\n                                )\n                            )\n",
      "\n                    if part == 'pk':\n                        # Skip validation for 'pk' as it's always valid but won't be found by get_field\n                        continue\n                    try:\n                        fld = fld.get_field(part)\n                    except (FieldDoesNotExist, AttributeError):\n                        if fld is None or fld.get_transform(part) is None:\n                            errors.append(\n                                checks.Error(\n                                    \"'ordering' refers to the nonexistent field, \"\n                                    \"related field, or lookup '%s'.\" % field,\n                                    obj=cls,\n                                    id='models.E015',\n                                )\n                            )\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 3ce711f3f1..6a5c897c5d 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1706,21 +1706,30 @@ class Model(metaclass=ModelBase):\n         for field in related_fields:\n             _cls = cls\n             fld = None\n+\n             for part in field.split(LOOKUP_SEP):\n+                # Skip ordering on pk. This is always a valid order_by field\n+                # but is an alias and therefore won't be found by opts.get_field.\n+                if part == 'pk':\n+                    continue\n                 try:\n                     fld = _cls._meta.get_field(part)\n                     if fld.is_relation:\n                         _cls = fld.get_path_info()[-1].to_opts.model\n                 except (FieldDoesNotExist, AttributeError):\n+\n                     if fld is None or fld.get_transform(part) is None:\n-                        errors.append(\n-                            checks.Error(\n-                                \"'ordering' refers to the nonexistent field, \"\n-                                \"related field, or lookup '%s'.\" % field,\n-                                obj=cls,\n-                                id='models.E015',\n+                        # Don't raise E015 for 'pk' as it's always a valid ordering field\n+                        if part != 'pk':\n+                            errors.append(\n+                                checks.Error(\n+                                    \"'ordering' refers to the nonexistent field, \"\n+                                    \"related field, or lookup '%s'.\" % field,\n+                                    obj=cls,\n+                                    id='models.E015',\n+                                )\n                             )\n-                        )\n+\n \n         # Skip ordering on pk. This is always a valid order_by field\n         # but is an alias and therefore won't be found by opts.get_field.\n",
    "variant_0": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 3ce711f3f1..ffd10ac078 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1702,11 +1702,45 @@ class Model(metaclass=ModelBase):\n                 _fields.append(f)\n         fields = _fields\n \n+        # Check related fields.\n+        for field in related_fields:\n+            _cls = cls\n+            fld = None\n+\n+        # Check related fields.\n+        for field in related_fields:\n+            _cls = cls\n+            fld = None\n+            for part in field.split(LOOKUP_SEP):\n+                try:\n+                    # Skip validation for 'pk' as it's always valid\n+                    if part == 'pk':\n+                        continue\n+                    fld = _cls._meta.get_field(part)\n+                    if fld.is_relation:\n+                        _cls = fld.get_path_info()[-1].to_opts.model\n+                except (FieldDoesNotExist, AttributeError):\n+                    # Don't report error if the failed part is 'pk'\n+                    if part == 'pk':\n+                        continue\n+                    if fld is None or fld.get_transform(part) is None:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'ordering' refers to the nonexistent field, \"\n+                                \"related field, or lookup '%s'.\" % field,\n+                                obj=cls,\n+                                id='models.E015',\n+                            )\n+                        )\n+\n         # Check related fields.\n         for field in related_fields:\n             _cls = cls\n             fld = None\n             for part in field.split(LOOKUP_SEP):\n+                # Skip pk validation for related fields, similar to direct fields\n+                if part == 'pk':\n+                    continue\n                 try:\n                     fld = _cls._meta.get_field(part)\n                     if fld.is_relation:\n@@ -1722,9 +1756,24 @@ class Model(metaclass=ModelBase):\n                             )\n                         )\n \n-        # Skip ordering on pk. This is always a valid order_by field\n-        # but is an alias and therefore won't be found by opts.get_field.\n-        fields = {f for f in fields if f != 'pk'}\n+\n+                # Skip ordering on pk. This is always a valid order_by field\n+                # but is an alias and therefore won't be found by opts.get_field.\n+                if part == 'pk':\n+                    continue\n+                    \n+                try:\n+                    fld = fld.remote_field.model._meta.get_field(part)\n+                except FieldDoesNotExist:\n+                    if fld is None or fld.get_transform(part) is None:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'ordering' refers to the nonexistent field, \"\n+                                \"related field, or lookup '%s'.\" % field,\n+                                obj=cls,\n+                                id='models.E015',\n+                            )\n+                        )\n \n         # Check for invalid or nonexistent fields in ordering.\n         invalid_fields = []\n",
    "variant_1": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 3ce711f3f1..efac9403d1 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1702,11 +1702,45 @@ class Model(metaclass=ModelBase):\n                 _fields.append(f)\n         fields = _fields\n \n+        # Check related fields.\n+        for field in related_fields:\n+            _cls = cls\n+            fld = None\n+\n+        # Check related fields.\n+        for field in related_fields:\n+            _cls = cls\n+            fld = None\n+            for part in field.split(LOOKUP_SEP):\n+                try:\n+                    # Skip validation for 'pk' as it's a valid alias\n+                    if part == 'pk':\n+                        continue\n+                    fld = _cls._meta.get_field(part)\n+                    if fld.is_relation:\n+                        _cls = fld.get_path_info()[-1].to_opts.model\n+                except (FieldDoesNotExist, AttributeError):\n+                    # Don't error on 'pk' at the end of related field lookups\n+                    if part == 'pk':\n+                        continue\n+                    if fld is None or fld.get_transform(part) is None:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'ordering' refers to the nonexistent field, \"\n+                                \"related field, or lookup '%s'.\" % field,\n+                                obj=cls,\n+                                id='models.E015',\n+                            )\n+                        )\n+\n         # Check related fields.\n         for field in related_fields:\n             _cls = cls\n             fld = None\n             for part in field.split(LOOKUP_SEP):\n+                # Skip pk validation for related fields, similar to direct fields\n+                if part == 'pk':\n+                    continue\n                 try:\n                     fld = _cls._meta.get_field(part)\n                     if fld.is_relation:\n@@ -1722,9 +1756,22 @@ class Model(metaclass=ModelBase):\n                             )\n                         )\n \n-        # Skip ordering on pk. This is always a valid order_by field\n-        # but is an alias and therefore won't be found by opts.get_field.\n-        fields = {f for f in fields if f != 'pk'}\n+\n+                # Skip pk lookups as they are always valid but won't be found by get_field\n+                if part == 'pk':\n+                    continue\n+                try:\n+                    fld = fld.remote_field.model._meta.get_field(part)\n+                except FieldDoesNotExist:\n+                    if fld is None or fld.get_transform(part) is None:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'ordering' refers to the nonexistent field, \"\n+                                \"related field, or lookup '%s'.\" % field,\n+                                obj=cls,\n+                                id='models.E015',\n+                            )\n+                        )\n \n         # Check for invalid or nonexistent fields in ordering.\n         invalid_fields = []\n",
    "variant_2": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 3ce711f3f1..0ba83a9d48 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1702,11 +1702,45 @@ class Model(metaclass=ModelBase):\n                 _fields.append(f)\n         fields = _fields\n \n+        # Check related fields.\n+        for field in related_fields:\n+            _cls = cls\n+            fld = None\n+\n+        # Check related fields.\n+        for field in related_fields:\n+            _cls = cls\n+            fld = None\n+            for part in field.split(LOOKUP_SEP):\n+                try:\n+                    # Skip validation for 'pk' as it's always valid\n+                    if part == 'pk':\n+                        continue\n+                    fld = _cls._meta.get_field(part)\n+                    if fld.is_relation:\n+                        _cls = fld.get_path_info()[-1].to_opts.model\n+                except (FieldDoesNotExist, AttributeError):\n+                    # Don't report error for 'pk' at end of lookup\n+                    if part == 'pk':\n+                        continue\n+                    if fld is None or fld.get_transform(part) is None:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'ordering' refers to the nonexistent field, \"\n+                                \"related field, or lookup '%s'.\" % field,\n+                                obj=cls,\n+                                id='models.E015',\n+                            )\n+                        )\n+\n         # Check related fields.\n         for field in related_fields:\n             _cls = cls\n             fld = None\n             for part in field.split(LOOKUP_SEP):\n+                # Skip validation for 'pk' as it's always a valid alias\n+                if part == 'pk':\n+                    continue\n                 try:\n                     fld = _cls._meta.get_field(part)\n                     if fld.is_relation:\n@@ -1722,9 +1756,19 @@ class Model(metaclass=ModelBase):\n                             )\n                         )\n \n-        # Skip ordering on pk. This is always a valid order_by field\n-        # but is an alias and therefore won't be found by opts.get_field.\n-        fields = {f for f in fields if f != 'pk'}\n+\n+                    if fld is None or fld.get_transform(part) is None:\n+                        # Skip pk lookups as they are always valid but won't be found by get_field\n+                        if part == 'pk':\n+                            continue\n+                        errors.append(\n+                            checks.Error(\n+                                \"'ordering' refers to the nonexistent field, \"\n+                                \"related field, or lookup '%s'.\" % field,\n+                                obj=cls,\n+                                id='models.E015',\n+                            )\n+                        )\n \n         # Check for invalid or nonexistent fields in ordering.\n         invalid_fields = []\n",
    "variant_3": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 3ce711f3f1..8eea2cd5d4 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1702,16 +1702,67 @@ class Model(metaclass=ModelBase):\n                 _fields.append(f)\n         fields = _fields\n \n+        # Check related fields.\n+        for field in related_fields:\n+            _cls = cls\n+            fld = None\n+\n         # Check related fields.\n         for field in related_fields:\n             _cls = cls\n             fld = None\n             for part in field.split(LOOKUP_SEP):\n                 try:\n+                    # Skip validation for 'pk' since it's always valid but won't be found by get_field\n+                    if part == 'pk':\n+                        continue\n                     fld = _cls._meta.get_field(part)\n                     if fld.is_relation:\n                         _cls = fld.get_path_info()[-1].to_opts.model\n                 except (FieldDoesNotExist, AttributeError):\n+                    # Don't report error for 'pk' at the end of related field lookups\n+                    if part == 'pk':\n+                        continue\n+                    if fld is None or fld.get_transform(part) is None:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'ordering' refers to the nonexistent field, \"\n+                                \"related field, or lookup '%s'.\" % field,\n+                                obj=cls,\n+                                id='models.E015',\n+                            )\n+                        )\n+\n+        # Check related fields.\n+        for field in related_fields:\n+            _cls = cls\n+            fld = None\n+            for part in field.split(LOOKUP_SEP):\n+                # Skip pk validation as it's always valid but won't be found by get_field\n+                if part == 'pk':\n+                    continue\n+                try:\n+                    fld = _cls._meta.get_field(part)\n+                    if fld.is_relation:\n+                        _cls = fld.get_path_info()[-1].to_opts.model\n+                except (FieldDoesNotExist, AttributeError):\n+                    # Don't error on pk at the end of a related field lookup\n+                    if part == 'pk':\n+                        continue\n+                    if fld is None or fld.get_transform(part) is None:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'ordering' refers to the nonexistent field, \"\n+                                \"related field, or lookup '%s'.\" % field,\n+                                obj=cls,\n+                                id='models.E015',\n+                            )\n+                        )\n+\n+\n+                    if part == 'pk':\n+                        # Skip validation for 'pk' as it's always a valid field alias\n+                        continue\n                     if fld is None or fld.get_transform(part) is None:\n                         errors.append(\n                             checks.Error(\n",
    "variant_4": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 3ce711f3f1..18f261acfd 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1702,11 +1702,19 @@ class Model(metaclass=ModelBase):\n                 _fields.append(f)\n         fields = _fields\n \n+        # Check related fields.\n+        for field in related_fields:\n+            _cls = cls\n+            fld = None\n+\n         # Check related fields.\n         for field in related_fields:\n             _cls = cls\n             fld = None\n             for part in field.split(LOOKUP_SEP):\n+                # Skip pk validation for related fields, similar to direct fields\n+                if part == 'pk':\n+                    continue\n                 try:\n                     fld = _cls._meta.get_field(part)\n                     if fld.is_relation:\n@@ -1722,9 +1730,50 @@ class Model(metaclass=ModelBase):\n                             )\n                         )\n \n-        # Skip ordering on pk. This is always a valid order_by field\n-        # but is an alias and therefore won't be found by opts.get_field.\n-        fields = {f for f in fields if f != 'pk'}\n+        # Check related fields.\n+        for field in related_fields:\n+            _cls = cls\n+            fld = None\n+            for part in field.split(LOOKUP_SEP):\n+                # Skip pk validation as it's always valid but won't be found by get_field\n+                if part == 'pk':\n+                    continue\n+                try:\n+                    fld = _cls._meta.get_field(part)\n+                    if fld.is_relation:\n+                        _cls = fld.get_path_info()[-1].to_opts.model\n+                except (FieldDoesNotExist, AttributeError):\n+                    # Don't error on pk at the end of a related field lookup\n+                    if part == 'pk':\n+                        continue\n+                    if fld is None or fld.get_transform(part) is None:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'ordering' refers to the nonexistent field, \"\n+                                \"related field, or lookup '%s'.\" % field,\n+                                obj=cls,\n+                                id='models.E015',\n+                            )\n+                        )\n+\n+\n+                    if part == 'pk':\n+                        # Skip validation for 'pk' as it's always a valid alias\n+                        continue\n+                    try:\n+                        fld = fld.get_field(part)\n+                    except (FieldDoesNotExist, AttributeError):\n+                        if fld is None or fld.get_transform(part) is None:\n+                            # Don't generate error for 'pk' at end of lookup chain\n+                            if part != 'pk':\n+                                errors.append(\n+                                    checks.Error(\n+                                        \"'ordering' refers to the nonexistent field, \"\n+                                        \"related field, or lookup '%s'.\" % field,\n+                                        obj=cls,\n+                                        id='models.E015',\n+                                    )\n+                                )\n \n         # Check for invalid or nonexistent fields in ordering.\n         invalid_fields = []\n",
    "variant_5": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 3ce711f3f1..100c8e0b91 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1702,11 +1702,44 @@ class Model(metaclass=ModelBase):\n                 _fields.append(f)\n         fields = _fields\n \n+        # Check related fields.\n+        for field in related_fields:\n+            _cls = cls\n+            fld = None\n+\n+        # Check related fields.\n+        for field in related_fields:\n+            _cls = cls\n+            fld = None\n+            for part in field.split(LOOKUP_SEP):\n+                try:\n+                    # Skip pk validation as it's always valid\n+                    if part == 'pk':\n+                        continue\n+                    fld = _cls._meta.get_field(part)\n+                    if fld.is_relation:\n+                        _cls = fld.get_path_info()[-1].to_opts.model\n+                except (FieldDoesNotExist, AttributeError):\n+                    if fld is None or fld.get_transform(part) is None:\n+                        # Don't generate error for pk lookups\n+                        if part != 'pk':\n+                            errors.append(\n+                                checks.Error(\n+                                    \"'ordering' refers to the nonexistent field, \"\n+                                    \"related field, or lookup '%s'.\" % field,\n+                                    obj=cls,\n+                                    id='models.E015',\n+                                )\n+                            )\n+\n         # Check related fields.\n         for field in related_fields:\n             _cls = cls\n             fld = None\n             for part in field.split(LOOKUP_SEP):\n+                # Skip pk validation in related field lookups, similar to direct fields\n+                if part == 'pk':\n+                    continue\n                 try:\n                     fld = _cls._meta.get_field(part)\n                     if fld.is_relation:\n@@ -1722,9 +1755,34 @@ class Model(metaclass=ModelBase):\n                             )\n                         )\n \n-        # Skip ordering on pk. This is always a valid order_by field\n-        # but is an alias and therefore won't be found by opts.get_field.\n-        fields = {f for f in fields if f != 'pk'}\n+\n+                    if part == 'pk':\n+                        # Skip validation for 'pk' as it's always valid but is an alias\n+                        continue\n+                    try:\n+                        fld = opts.get_field(part)\n+                    except FieldDoesNotExist:\n+                        return field\n+                    if fld.many_to_many:\n+                        return field\n+                    # For reverse and forward references, use the target model's _meta.\n+                    if fld.is_relation:\n+                        opts = fld.related_model._meta\n+                    else:\n+                        opts = None\n+                else:\n+                    # Last part could be a transform; no need to check it further.\n+                    if fld is None or fld.get_transform(part) is None:\n+                        # Don't generate error if the last part is 'pk' since it's always valid\n+                        if part != 'pk':\n+                            errors.append(\n+                                checks.Error(\n+                                    \"'ordering' refers to the nonexistent field, \"\n+                                    \"related field, or lookup '%s'.\" % field,\n+                                    obj=cls,\n+                                    id='models.E015',\n+                                )\n+                            )\n \n         # Check for invalid or nonexistent fields in ordering.\n         invalid_fields = []\n",
    "variant_6": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 3ce711f3f1..96b5fed33b 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1702,16 +1702,27 @@ class Model(metaclass=ModelBase):\n                 _fields.append(f)\n         fields = _fields\n \n+        # Check related fields.\n+        for field in related_fields:\n+            _cls = cls\n+            fld = None\n+\n         # Check related fields.\n         for field in related_fields:\n             _cls = cls\n             fld = None\n             for part in field.split(LOOKUP_SEP):\n                 try:\n+                    # Skip validation for 'pk' as it's always valid\n+                    if part == 'pk':\n+                        continue\n                     fld = _cls._meta.get_field(part)\n                     if fld.is_relation:\n                         _cls = fld.get_path_info()[-1].to_opts.model\n                 except (FieldDoesNotExist, AttributeError):\n+                    # Don't error on 'pk' at the end of related field lookups\n+                    if part == 'pk':\n+                        continue\n                     if fld is None or fld.get_transform(part) is None:\n                         errors.append(\n                             checks.Error(\n@@ -1722,9 +1733,46 @@ class Model(metaclass=ModelBase):\n                             )\n                         )\n \n-        # Skip ordering on pk. This is always a valid order_by field\n-        # but is an alias and therefore won't be found by opts.get_field.\n-        fields = {f for f in fields if f != 'pk'}\n+        # Check related fields.\n+        for field in related_fields:\n+            _cls = cls\n+            fld = None\n+            for part in field.split(LOOKUP_SEP):\n+                # Skip pk validation as it's always valid but is an alias\n+                if part == 'pk':\n+                    continue\n+                try:\n+                    fld = _cls._meta.get_field(part)\n+                    if fld.is_relation:\n+                        _cls = fld.get_path_info()[-1].to_opts.model\n+                except (FieldDoesNotExist, AttributeError):\n+                    # Check if this is a pk at the end of a related field lookup\n+                    if part == 'pk':\n+                        continue\n+                    if fld is None or fld.get_transform(part) is None:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'ordering' refers to the nonexistent field, \"\n+                                \"related field, or lookup '%s'.\" % field,\n+                                obj=cls,\n+                                id='models.E015',\n+                            )\n+                        )\n+\n+\n+                    if fld is None or fld.get_transform(part) is None:\n+                        # Skip validation for 'pk' at the end of related field lookups\n+                        # since 'pk' is always a valid ordering field alias\n+                        if part == 'pk' and i == len(parts) - 1:\n+                            continue\n+                        errors.append(\n+                            checks.Error(\n+                                \"'ordering' refers to the nonexistent field, \"\n+                                \"related field, or lookup '%s'.\" % field,\n+                                obj=cls,\n+                                id='models.E015',\n+                            )\n+                        )\n \n         # Check for invalid or nonexistent fields in ordering.\n         invalid_fields = []\n",
    "variant_7": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 3ce711f3f1..4f3fc929d2 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1702,16 +1702,53 @@ class Model(metaclass=ModelBase):\n                 _fields.append(f)\n         fields = _fields\n \n+        # Check related fields.\n+        for field in related_fields:\n+            _cls = cls\n+            fld = None\n+\n         # Check related fields.\n         for field in related_fields:\n             _cls = cls\n             fld = None\n             for part in field.split(LOOKUP_SEP):\n                 try:\n+                    # Skip validation for 'pk' as it's always valid\n+                    if part == 'pk':\n+                        continue\n                     fld = _cls._meta.get_field(part)\n                     if fld.is_relation:\n                         _cls = fld.get_path_info()[-1].to_opts.model\n                 except (FieldDoesNotExist, AttributeError):\n+                    if fld is None or fld.get_transform(part) is None:\n+                        # Don't error if the failed part is 'pk'\n+                        if part != 'pk':\n+                            errors.append(\n+                                checks.Error(\n+                                    \"'ordering' refers to the nonexistent field, \"\n+                                    \"related field, or lookup '%s'.\" % field,\n+                                    obj=cls,\n+                                    id='models.E015',\n+                                )\n+                            )\n+\n+        # Check related fields.\n+        for field in related_fields:\n+            _cls = cls\n+            fld = None\n+            for part in field.split(LOOKUP_SEP):\n+                # Skip pk validation - it's always valid but is an alias\n+                if part == 'pk':\n+                    continue\n+                try:\n+                    fld = _cls._meta.get_field(part)\n+                    if fld.is_relation:\n+                        _cls = fld.get_path_info()[-1].to_opts.model\n+                except (FieldDoesNotExist, AttributeError):\n+                    # Check if this is the last part and it's 'pk'\n+                    field_parts = field.split(LOOKUP_SEP)\n+                    if part == field_parts[-1] and part == 'pk':\n+                        continue\n                     if fld is None or fld.get_transform(part) is None:\n                         errors.append(\n                             checks.Error(\n@@ -1722,9 +1759,26 @@ class Model(metaclass=ModelBase):\n                             )\n                         )\n \n-        # Skip ordering on pk. This is always a valid order_by field\n-        # but is an alias and therefore won't be found by opts.get_field.\n-        fields = {f for f in fields if f != 'pk'}\n+\n+                    # Skip pk lookups as they are always valid but won't be found by get_field\n+                    if part == 'pk':\n+                        continue\n+                    \n+                    try:\n+                        fld = fld.get_field(part)\n+                    except (FieldDoesNotExist, AttributeError):\n+                        if fld is None or fld.get_transform(part) is None:\n+                            # Don't error on pk at end of related field lookup\n+                            if part == 'pk':\n+                                continue\n+                            errors.append(\n+                                checks.Error(\n+                                    \"'ordering' refers to the nonexistent field, \"\n+                                    \"related field, or lookup '%s'.\" % field,\n+                                    obj=cls,\n+                                    id='models.E015',\n+                                )\n+                            )\n \n         # Check for invalid or nonexistent fields in ordering.\n         invalid_fields = []\n",
    "variant_8": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 3ce711f3f1..f3146352f8 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1702,16 +1702,27 @@ class Model(metaclass=ModelBase):\n                 _fields.append(f)\n         fields = _fields\n \n+        # Check related fields.\n+        for field in related_fields:\n+            _cls = cls\n+            fld = None\n+\n         # Check related fields.\n         for field in related_fields:\n             _cls = cls\n             fld = None\n             for part in field.split(LOOKUP_SEP):\n                 try:\n+                    # Skip validation for 'pk' as it's always a valid alias\n+                    if part == 'pk':\n+                        continue\n                     fld = _cls._meta.get_field(part)\n                     if fld.is_relation:\n                         _cls = fld.get_path_info()[-1].to_opts.model\n                 except (FieldDoesNotExist, AttributeError):\n+                    # Don't report error if the last part is 'pk' (valid alias)\n+                    if part == 'pk' and field.endswith('__pk'):\n+                        continue\n                     if fld is None or fld.get_transform(part) is None:\n                         errors.append(\n                             checks.Error(\n@@ -1722,9 +1733,48 @@ class Model(metaclass=ModelBase):\n                             )\n                         )\n \n-        # Skip ordering on pk. This is always a valid order_by field\n-        # but is an alias and therefore won't be found by opts.get_field.\n-        fields = {f for f in fields if f != 'pk'}\n+        # Check related fields.\n+        for field in related_fields:\n+            _cls = cls\n+            fld = None\n+            for part in field.split(LOOKUP_SEP):\n+                # Skip pk validation as it's always valid but is an alias\n+                if part == 'pk':\n+                    continue\n+                try:\n+                    fld = _cls._meta.get_field(part)\n+                    if fld.is_relation:\n+                        _cls = fld.get_path_info()[-1].to_opts.model\n+                except (FieldDoesNotExist, AttributeError):\n+                    # Check if this is a pk reference at the end of a related field lookup\n+                    if part == 'pk':\n+                        continue\n+                    if fld is None or fld.get_transform(part) is None:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'ordering' refers to the nonexistent field, \"\n+                                \"related field, or lookup '%s'.\" % field,\n+                                obj=cls,\n+                                id='models.E015',\n+                            )\n+                        )\n+\n+\n+                    if part == 'pk':\n+                        # Skip validation for 'pk' as it's always valid but won't be found by get_field\n+                        continue\n+                    try:\n+                        fld = fld.get_field(part)\n+                    except (FieldDoesNotExist, AttributeError):\n+                        if fld is None or fld.get_transform(part) is None:\n+                            errors.append(\n+                                checks.Error(\n+                                    \"'ordering' refers to the nonexistent field, \"\n+                                    \"related field, or lookup '%s'.\" % field,\n+                                    obj=cls,\n+                                    id='models.E015',\n+                                )\n+                            )\n \n         # Check for invalid or nonexistent fields in ordering.\n         invalid_fields = []\n"
  }
}