{
  "zero_patches": {
    "Location 1 (/root/hy/projects/astropy/astropy/io/ascii/html.py lines 430-435)": "\n                        # below for multicolumn elements.  This is purely to\n                        # maintain a reference for these objects during\n                        # subsequent iteration to format column values.  This\n                        # requires that the weakref info._parent be maintained.\n                        new_cols = []\n\n                        # Apply custom formats from the formats argument\n                        self._set_col_formats()\n\n                        for col, col_escaped in zip(cols, cols_escaped):\n                            if len(col.shape) > 1 and self.html['multicol']:\n                                span = col.shape[1]\n                                for i in range(span):\n                                    # Split up multicolumns into separate columns\n                                    new_col = Column([el[i] for el in col])\n\n                                    new_col_iter_str_vals = self.fill_values(\n                                        col, new_col.info.iter_str_vals())\n                                    col_str_iters.append(new_col_iter_str_vals)\n",
    "Location 2 (/root/hy/projects/astropy/astropy/io/ascii/html.py lines 440-441)": "\n                                    # Split up multicolumns into separate columns\n                                    new_col = Column([el[i] for el in col])\n\n                                    new_col_iter_str_vals = self.fill_values(\n                                        col, new_col.info.iter_str_vals())\n                                    col_str_iters.append(new_col_iter_str_vals)\n                                    new_cols_escaped.append(col_escaped)\n                                    new_cols.append(new_col)\n                            else:\n\n                                col_iter_str_vals = self.fill_values(col, col.info.iter_str_vals())\n                                col_str_iters.append(col_iter_str_vals)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/astropy/astropy/io/ascii/html.py lines 430-435)": [
      "\n                        # below for multicolumn elements.  This is purely to\n                        # maintain a reference for these objects during\n                        # subsequent iteration to format column values.  This\n                        # requires that the weakref info._parent be maintained.\n                        new_cols = []\n\n                        # Apply custom formats from the formats argument\n                        self._set_col_formats()\n\n                        for col, col_escaped in zip(cols, cols_escaped):\n                            if len(col.shape) > 1 and self.html['multicol']:\n                                span = col.shape[1]\n                                for i in range(span):\n                                    # Split up multicolumns into separate columns\n                                    new_col = Column([el[i] for el in col])\n\n                                    new_col_iter_str_vals = self.fill_values(\n                                        col, new_col.info.iter_str_vals())\n                                    col_str_iters.append(new_col_iter_str_vals)\n",
      "\n                        # below for multicolumn elements.  This is purely to\n                        # maintain a reference for these objects during\n                        # subsequent iteration to format column values.  This\n                        # requires that the weakref info._parent be maintained.\n                        new_cols = []\n\n                        # Apply custom formats from the formats argument\n                        self._set_col_formats()\n\n                        for col, col_escaped in zip(cols, cols_escaped):\n                            if len(col.shape) > 1 and self.html['multicol']:\n                                span = col.shape[1]\n                                for i in range(span):\n                                    # Split up multicolumns into separate columns\n                                    new_col = Column([el[i] for el in col])\n\n                                    new_col_iter_str_vals = self.fill_values(\n                                        col, new_col.info.iter_str_vals())\n                                    col_str_iters.append(new_col_iter_str_vals)\n",
      "\n                        # below for multicolumn elements.  This is purely to\n                        # maintain a reference for these objects during\n                        # subsequent iteration to format column values.  This\n                        # requires that the weakref info._parent be maintained.\n                        new_cols = []\n\n                        # Apply custom formats from the formats argument\n                        self._set_col_formats()\n\n                        for col, col_escaped in zip(cols, cols_escaped):\n                            if len(col.shape) > 1 and self.html['multicol']:\n                                span = col.shape[1]\n                                for i in range(span):\n                                    # Split up multicolumns into separate columns\n                                    new_col = Column([el[i] for el in col])\n\n                                    new_col_iter_str_vals = self.fill_values(\n                                        col, new_col.info.iter_str_vals())\n                                    col_str_iters.append(new_col_iter_str_vals)\n",
      "\n                        # below for multicolumn elements.  This is purely to\n                        # maintain a reference for these objects during\n                        # subsequent iteration to format column values.  This\n                        # requires that the weakref info._parent be maintained.\n                        new_cols = []\n\n                        # Apply custom formats from the formats argument\n                        self._set_col_formats()\n\n                        for col, col_escaped in zip(cols, cols_escaped):\n                            if len(col.shape) > 1 and self.html['multicol']:\n                                span = col.shape[1]\n                                for i in range(span):\n                                    # Split up multicolumns into separate columns\n                                    new_col = Column([el[i] for el in col])\n\n                                    new_col_iter_str_vals = self.fill_values(\n                                        col, new_col.info.iter_str_vals())\n                                    col_str_iters.append(new_col_iter_str_vals)\n",
      "\n                        # below for multicolumn elements.  This is purely to\n                        # maintain a reference for these objects during\n                        # subsequent iteration to format column values.  This\n                        # requires that the weakref info._parent be maintained.\n                        new_cols = []\n\n                        # Apply custom formats from the formats argument\n                        self._set_col_formats()\n\n                        for col, col_escaped in zip(cols, cols_escaped):\n                            if len(col.shape) > 1 and self.html['multicol']:\n                                span = col.shape[1]\n                                for i in range(span):\n                                    # Split up multicolumns into separate columns\n                                    new_col = Column([el[i] for el in col])\n\n                                    new_col_iter_str_vals = self.fill_values(\n                                        col, new_col.info.iter_str_vals())\n                                    col_str_iters.append(new_col_iter_str_vals)\n",
      "\n                        # below for multicolumn elements.  This is purely to\n                        # maintain a reference for these objects during\n                        # subsequent iteration to format column values.  This\n                        # requires that the weakref info._parent be maintained.\n                        new_cols = []\n\n                        # Apply custom formats from the formats argument\n                        self._set_col_formats()\n\n                        for col, col_escaped in zip(cols, cols_escaped):\n                            if len(col.shape) > 1 and self.html['multicol']:\n                                span = col.shape[1]\n                                for i in range(span):\n                                    # Split up multicolumns into separate columns\n                                    new_col = Column([el[i] for el in col])\n\n                                    new_col_iter_str_vals = self.fill_values(\n                                        col, new_col.info.iter_str_vals())\n                                    col_str_iters.append(new_col_iter_str_vals)\n",
      "\n                        # below for multicolumn elements.  This is purely to\n                        # maintain a reference for these objects during\n                        # subsequent iteration to format column values.  This\n                        # requires that the weakref info._parent be maintained.\n                        new_cols = []\n\n                        # Apply custom formats from the formats argument\n                        self._set_col_formats()\n\n                        for col, col_escaped in zip(cols, cols_escaped):\n                            if len(col.shape) > 1 and self.html['multicol']:\n                                span = col.shape[1]\n                                for i in range(span):\n                                    # Split up multicolumns into separate columns\n                                    new_col = Column([el[i] for el in col])\n\n                                    new_col_iter_str_vals = self.fill_values(\n                                        col, new_col.info.iter_str_vals())\n                                    col_str_iters.append(new_col_iter_str_vals)\n",
      "\n                        # below for multicolumn elements.  This is purely to\n                        # maintain a reference for these objects during\n                        # subsequent iteration to format column values.  This\n                        # requires that the weakref info._parent be maintained.\n                        new_cols = []\n\n                        # Apply custom formats before processing columns\n                        self._set_col_formats()\n\n                        for col, col_escaped in zip(cols, cols_escaped):\n                            if len(col.shape) > 1 and self.html['multicol']:\n                                span = col.shape[1]\n                                for i in range(span):\n                                    # Split up multicolumns into separate columns\n                                    new_col = Column([el[i] for el in col])\n\n                                    new_col_iter_str_vals = self.fill_values(\n                                        col, new_col.info.iter_str_vals())\n                                    col_str_iters.append(new_col_iter_str_vals)\n"
    ],
    "Location 2 (/root/hy/projects/astropy/astropy/io/ascii/html.py lines 440-441)": [
      "\n                                    # Split up multicolumns into separate columns\n                                    new_col = Column([el[i] for el in col])\n\n                                    new_col_iter_str_vals = self.fill_values(\n                                        col, new_col.info.iter_str_vals())\n                                    col_str_iters.append(new_col_iter_str_vals)\n                                    new_cols_escaped.append(col_escaped)\n                                    new_cols.append(new_col)\n                            else:\n\n                                col_iter_str_vals = self.fill_values(col, col.info.iter_str_vals())\n                                col_str_iters.append(col_iter_str_vals)\n",
      "\n                            # Split up multicolumns into separate columns\n                            new_col = Column([el[i] for el in col])\n\n                            new_col_iter_str_vals = self.fill_values(\n                                col, new_col.info.iter_str_vals())\n                            col_str_iters.append(new_col_iter_str_vals)\n                            new_cols_escaped.append(col_escaped)\n                            new_cols.append(new_col)\n                    else:\n\n                        col_iter_str_vals = self.fill_values(col, col.info.iter_str_vals())\n                        col_str_iters.append(col_iter_str_vals)\n\n                        new_cols_escaped.append(col_escaped)\n",
      "\n                                # Split up multicolumns into separate columns\n                                new_col = Column([el[i] for el in col])\n\n                                new_col_iter_str_vals = self.fill_values(\n                                    col, new_col.info.iter_str_vals())\n                                col_str_iters.append(new_col_iter_str_vals)\n                                new_cols_escaped.append(col_escaped)\n                                new_cols.append(new_col)\n                        else:\n\n                            col_iter_str_vals = self.fill_values(col, col.info.iter_str_vals())\n                            col_str_iters.append(col_iter_str_vals)\n\n                            new_cols_escaped.append(col_escaped)\n",
      "\n                                # Split up multicolumns into separate columns\n                                new_col = Column([el[i] for el in col])\n\n                                new_col_iter_str_vals = self.fill_values(\n                                    col, new_col.info.iter_str_vals())\n                                col_str_iters.append(new_col_iter_str_vals)\n                                new_cols_escaped.append(col_escaped)\n                                new_cols.append(new_col)\n                        else:\n\n                            col_iter_str_vals = self.fill_values(col, col.info.iter_str_vals())\n                            col_str_iters.append(col_iter_str_vals)\n\n                            new_cols_escaped.append(col_escaped)\n",
      "\n                                    # Split up multicolumns into separate columns\n                                    new_col = Column([el[i] for el in col])\n\n                                    new_col_iter_str_vals = self.fill_values(\n                                        col, new_col.info.iter_str_vals())\n                                    col_str_iters.append(new_col_iter_str_vals)\n                                    new_cols_escaped.append(col_escaped)\n                                    new_cols.append(new_col)\n                            else:\n\n                                col_iter_str_vals = self.fill_values(col, col.info.iter_str_vals())\n                                col_str_iters.append(col_iter_str_vals)\n",
      "\n                            # Split up multicolumns into separate columns\n                            new_col = Column([el[i] for el in col])\n\n                            new_col_iter_str_vals = self.fill_values(\n                                col, new_col.info.iter_str_vals())\n                            col_str_iters.append(new_col_iter_str_vals)\n                            new_cols_escaped.append(col_escaped)\n                            new_cols.append(new_col)\n                    else:\n\n                        col_iter_str_vals = self.fill_values(col, col.info.iter_str_vals())\n                        col_str_iters.append(col_iter_str_vals)\n\n                        new_cols_escaped.append(col_escaped)\n",
      "\n                            # Split up multicolumns into separate columns\n                            new_col = Column([el[i] for el in col])\n\n                            new_col_iter_str_vals = self.fill_values(\n                                col, new_col.info.iter_str_vals())\n                            col_str_iters.append(new_col_iter_str_vals)\n                            new_cols_escaped.append(col_escaped)\n                            new_cols.append(new_col)\n                    else:\n                        # Apply column formats before extracting string values\n                        self._set_col_formats()\n                        \n                        col_iter_str_vals = self.fill_values(col, col.info.iter_str_vals())\n                        col_str_iters.append(col_iter_str_vals)\n\n                        new_cols_escaped.append(col_escaped)\n",
      "\n                                    # Split up multicolumns into separate columns\n                                    new_col = Column([el[i] for el in col])\n\n                                    new_col_iter_str_vals = self.fill_values(\n                                        col, new_col.info.iter_str_vals())\n                                    col_str_iters.append(new_col_iter_str_vals)\n                                    new_cols_escaped.append(col_escaped)\n                                    new_cols.append(new_col)\n                            else:\n\n                                col_iter_str_vals = self.fill_values(col, col.info.iter_str_vals())\n                                col_str_iters.append(col_iter_str_vals)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/astropy/io/ascii/html.py b/astropy/io/ascii/html.py\nindex 266cf229cc..9078855fc5 100644\n--- a/astropy/io/ascii/html.py\n+++ b/astropy/io/ascii/html.py\n@@ -423,6 +423,21 @@ class HTML(core.BaseReader):\n                         # requires that the weakref info._parent be maintained.\n                         new_cols = []\n \n+                        for col, col_escaped in zip(cols, cols_escaped):\n+                            if len(col.shape) > 1 and self.html['multicol']:\n+                                span = col.shape[1]\n+                                for i in range(span):\n+\n+                        # Make a container to hold any new_col objects created\n+                        # below for multicolumn elements.  This is purely to\n+                        # maintain a reference for these objects during\n+                        # subsequent iteration to format column values.  This\n+                        # requires that the weakref info._parent be maintained.\n+                        new_cols = []\n+\n+                        # Apply custom formats to columns before processing\n+                        self._set_col_formats()\n+\n                         for col, col_escaped in zip(cols, cols_escaped):\n                             if len(col.shape) > 1 and self.html['multicol']:\n                                 span = col.shape[1]\n@@ -437,6 +452,7 @@ class HTML(core.BaseReader):\n                                     new_cols.append(new_col)\n                             else:\n \n+\n                                 col_iter_str_vals = self.fill_values(col, col.info.iter_str_vals())\n                                 col_str_iters.append(col_iter_str_vals)\n \n",
    "variant_0": "diff --git a/astropy/io/ascii/html.py b/astropy/io/ascii/html.py\nindex 266cf229cc..9becd52fb5 100644\n--- a/astropy/io/ascii/html.py\n+++ b/astropy/io/ascii/html.py\n@@ -427,6 +427,31 @@ class HTML(core.BaseReader):\n                             if len(col.shape) > 1 and self.html['multicol']:\n                                 span = col.shape[1]\n                                 for i in range(span):\n+\n+                        # below for multicolumn elements.  This is purely to\n+                        # maintain a reference for these objects during\n+                        # subsequent iteration to format column values.  This\n+                        # requires that the weakref info._parent be maintained.\n+                        new_cols = []\n+\n+                        # Apply custom formats from the formats argument\n+                        self._set_col_formats()\n+\n+                        for col, col_escaped in zip(cols, cols_escaped):\n+                            if len(col.shape) > 1 and self.html['multicol']:\n+                                span = col.shape[1]\n+                                for i in range(span):\n+                                    # Split up multicolumns into separate columns\n+                                    new_col = Column([el[i] for el in col])\n+\n+                                    new_col_iter_str_vals = self.fill_values(\n+                                        col, new_col.info.iter_str_vals())\n+                                    col_str_iters.append(new_col_iter_str_vals)\n+                                    new_cols_escaped.append(col_escaped)\n+                                    new_cols.append(new_col)\n+                            else:\n+\n+\n                                     # Split up multicolumns into separate columns\n                                     new_col = Column([el[i] for el in col])\n \n",
    "variant_1": "diff --git a/astropy/io/ascii/html.py b/astropy/io/ascii/html.py\nindex 266cf229cc..9becd52fb5 100644\n--- a/astropy/io/ascii/html.py\n+++ b/astropy/io/ascii/html.py\n@@ -427,6 +427,31 @@ class HTML(core.BaseReader):\n                             if len(col.shape) > 1 and self.html['multicol']:\n                                 span = col.shape[1]\n                                 for i in range(span):\n+\n+                        # below for multicolumn elements.  This is purely to\n+                        # maintain a reference for these objects during\n+                        # subsequent iteration to format column values.  This\n+                        # requires that the weakref info._parent be maintained.\n+                        new_cols = []\n+\n+                        # Apply custom formats from the formats argument\n+                        self._set_col_formats()\n+\n+                        for col, col_escaped in zip(cols, cols_escaped):\n+                            if len(col.shape) > 1 and self.html['multicol']:\n+                                span = col.shape[1]\n+                                for i in range(span):\n+                                    # Split up multicolumns into separate columns\n+                                    new_col = Column([el[i] for el in col])\n+\n+                                    new_col_iter_str_vals = self.fill_values(\n+                                        col, new_col.info.iter_str_vals())\n+                                    col_str_iters.append(new_col_iter_str_vals)\n+                                    new_cols_escaped.append(col_escaped)\n+                                    new_cols.append(new_col)\n+                            else:\n+\n+\n                                     # Split up multicolumns into separate columns\n                                     new_col = Column([el[i] for el in col])\n \n",
    "variant_2": "diff --git a/astropy/io/ascii/html.py b/astropy/io/ascii/html.py\nindex 266cf229cc..6154308f6c 100644\n--- a/astropy/io/ascii/html.py\n+++ b/astropy/io/ascii/html.py\n@@ -423,6 +423,20 @@ class HTML(core.BaseReader):\n                         # requires that the weakref info._parent be maintained.\n                         new_cols = []\n \n+                        for col, col_escaped in zip(cols, cols_escaped):\n+                            if len(col.shape) > 1 and self.html['multicol']:\n+                                span = col.shape[1]\n+                                for i in range(span):\n+\n+                        # below for multicolumn elements.  This is purely to\n+                        # maintain a reference for these objects during\n+                        # subsequent iteration to format column values.  This\n+                        # requires that the weakref info._parent be maintained.\n+                        new_cols = []\n+\n+                        # Apply custom formats from the formats argument\n+                        self._set_col_formats()\n+\n                         for col, col_escaped in zip(cols, cols_escaped):\n                             if len(col.shape) > 1 and self.html['multicol']:\n                                 span = col.shape[1]\n@@ -437,8 +451,21 @@ class HTML(core.BaseReader):\n                                     new_cols.append(new_col)\n                             else:\n \n-                                col_iter_str_vals = self.fill_values(col, col.info.iter_str_vals())\n-                                col_str_iters.append(col_iter_str_vals)\n+\n+                            # Split up multicolumns into separate columns\n+                            new_col = Column([el[i] for el in col])\n+\n+                            new_col_iter_str_vals = self.fill_values(\n+                                col, new_col.info.iter_str_vals())\n+                            col_str_iters.append(new_col_iter_str_vals)\n+                            new_cols_escaped.append(col_escaped)\n+                            new_cols.append(new_col)\n+                    else:\n+\n+                        col_iter_str_vals = self.fill_values(col, col.info.iter_str_vals())\n+                        col_str_iters.append(col_iter_str_vals)\n+\n+                        new_cols_escaped.append(col_escaped)\n \n                                 new_cols_escaped.append(col_escaped)\n \n",
    "variant_3": "diff --git a/astropy/io/ascii/html.py b/astropy/io/ascii/html.py\nindex 266cf229cc..98bb0b7138 100644\n--- a/astropy/io/ascii/html.py\n+++ b/astropy/io/ascii/html.py\n@@ -423,6 +423,20 @@ class HTML(core.BaseReader):\n                         # requires that the weakref info._parent be maintained.\n                         new_cols = []\n \n+                        for col, col_escaped in zip(cols, cols_escaped):\n+                            if len(col.shape) > 1 and self.html['multicol']:\n+                                span = col.shape[1]\n+                                for i in range(span):\n+\n+                        # below for multicolumn elements.  This is purely to\n+                        # maintain a reference for these objects during\n+                        # subsequent iteration to format column values.  This\n+                        # requires that the weakref info._parent be maintained.\n+                        new_cols = []\n+\n+                        # Apply custom formats from the formats argument\n+                        self._set_col_formats()\n+\n                         for col, col_escaped in zip(cols, cols_escaped):\n                             if len(col.shape) > 1 and self.html['multicol']:\n                                 span = col.shape[1]\n@@ -437,8 +451,21 @@ class HTML(core.BaseReader):\n                                     new_cols.append(new_col)\n                             else:\n \n-                                col_iter_str_vals = self.fill_values(col, col.info.iter_str_vals())\n-                                col_str_iters.append(col_iter_str_vals)\n+\n+                                # Split up multicolumns into separate columns\n+                                new_col = Column([el[i] for el in col])\n+\n+                                new_col_iter_str_vals = self.fill_values(\n+                                    col, new_col.info.iter_str_vals())\n+                                col_str_iters.append(new_col_iter_str_vals)\n+                                new_cols_escaped.append(col_escaped)\n+                                new_cols.append(new_col)\n+                        else:\n+\n+                            col_iter_str_vals = self.fill_values(col, col.info.iter_str_vals())\n+                            col_str_iters.append(col_iter_str_vals)\n+\n+                            new_cols_escaped.append(col_escaped)\n \n                                 new_cols_escaped.append(col_escaped)\n \n",
    "variant_4": "diff --git a/astropy/io/ascii/html.py b/astropy/io/ascii/html.py\nindex 266cf229cc..98bb0b7138 100644\n--- a/astropy/io/ascii/html.py\n+++ b/astropy/io/ascii/html.py\n@@ -423,6 +423,20 @@ class HTML(core.BaseReader):\n                         # requires that the weakref info._parent be maintained.\n                         new_cols = []\n \n+                        for col, col_escaped in zip(cols, cols_escaped):\n+                            if len(col.shape) > 1 and self.html['multicol']:\n+                                span = col.shape[1]\n+                                for i in range(span):\n+\n+                        # below for multicolumn elements.  This is purely to\n+                        # maintain a reference for these objects during\n+                        # subsequent iteration to format column values.  This\n+                        # requires that the weakref info._parent be maintained.\n+                        new_cols = []\n+\n+                        # Apply custom formats from the formats argument\n+                        self._set_col_formats()\n+\n                         for col, col_escaped in zip(cols, cols_escaped):\n                             if len(col.shape) > 1 and self.html['multicol']:\n                                 span = col.shape[1]\n@@ -437,8 +451,21 @@ class HTML(core.BaseReader):\n                                     new_cols.append(new_col)\n                             else:\n \n-                                col_iter_str_vals = self.fill_values(col, col.info.iter_str_vals())\n-                                col_str_iters.append(col_iter_str_vals)\n+\n+                                # Split up multicolumns into separate columns\n+                                new_col = Column([el[i] for el in col])\n+\n+                                new_col_iter_str_vals = self.fill_values(\n+                                    col, new_col.info.iter_str_vals())\n+                                col_str_iters.append(new_col_iter_str_vals)\n+                                new_cols_escaped.append(col_escaped)\n+                                new_cols.append(new_col)\n+                        else:\n+\n+                            col_iter_str_vals = self.fill_values(col, col.info.iter_str_vals())\n+                            col_str_iters.append(col_iter_str_vals)\n+\n+                            new_cols_escaped.append(col_escaped)\n \n                                 new_cols_escaped.append(col_escaped)\n \n",
    "variant_5": "diff --git a/astropy/io/ascii/html.py b/astropy/io/ascii/html.py\nindex 266cf229cc..9becd52fb5 100644\n--- a/astropy/io/ascii/html.py\n+++ b/astropy/io/ascii/html.py\n@@ -427,6 +427,31 @@ class HTML(core.BaseReader):\n                             if len(col.shape) > 1 and self.html['multicol']:\n                                 span = col.shape[1]\n                                 for i in range(span):\n+\n+                        # below for multicolumn elements.  This is purely to\n+                        # maintain a reference for these objects during\n+                        # subsequent iteration to format column values.  This\n+                        # requires that the weakref info._parent be maintained.\n+                        new_cols = []\n+\n+                        # Apply custom formats from the formats argument\n+                        self._set_col_formats()\n+\n+                        for col, col_escaped in zip(cols, cols_escaped):\n+                            if len(col.shape) > 1 and self.html['multicol']:\n+                                span = col.shape[1]\n+                                for i in range(span):\n+                                    # Split up multicolumns into separate columns\n+                                    new_col = Column([el[i] for el in col])\n+\n+                                    new_col_iter_str_vals = self.fill_values(\n+                                        col, new_col.info.iter_str_vals())\n+                                    col_str_iters.append(new_col_iter_str_vals)\n+                                    new_cols_escaped.append(col_escaped)\n+                                    new_cols.append(new_col)\n+                            else:\n+\n+\n                                     # Split up multicolumns into separate columns\n                                     new_col = Column([el[i] for el in col])\n \n",
    "variant_6": "diff --git a/astropy/io/ascii/html.py b/astropy/io/ascii/html.py\nindex 266cf229cc..6154308f6c 100644\n--- a/astropy/io/ascii/html.py\n+++ b/astropy/io/ascii/html.py\n@@ -423,6 +423,20 @@ class HTML(core.BaseReader):\n                         # requires that the weakref info._parent be maintained.\n                         new_cols = []\n \n+                        for col, col_escaped in zip(cols, cols_escaped):\n+                            if len(col.shape) > 1 and self.html['multicol']:\n+                                span = col.shape[1]\n+                                for i in range(span):\n+\n+                        # below for multicolumn elements.  This is purely to\n+                        # maintain a reference for these objects during\n+                        # subsequent iteration to format column values.  This\n+                        # requires that the weakref info._parent be maintained.\n+                        new_cols = []\n+\n+                        # Apply custom formats from the formats argument\n+                        self._set_col_formats()\n+\n                         for col, col_escaped in zip(cols, cols_escaped):\n                             if len(col.shape) > 1 and self.html['multicol']:\n                                 span = col.shape[1]\n@@ -437,8 +451,21 @@ class HTML(core.BaseReader):\n                                     new_cols.append(new_col)\n                             else:\n \n-                                col_iter_str_vals = self.fill_values(col, col.info.iter_str_vals())\n-                                col_str_iters.append(col_iter_str_vals)\n+\n+                            # Split up multicolumns into separate columns\n+                            new_col = Column([el[i] for el in col])\n+\n+                            new_col_iter_str_vals = self.fill_values(\n+                                col, new_col.info.iter_str_vals())\n+                            col_str_iters.append(new_col_iter_str_vals)\n+                            new_cols_escaped.append(col_escaped)\n+                            new_cols.append(new_col)\n+                    else:\n+\n+                        col_iter_str_vals = self.fill_values(col, col.info.iter_str_vals())\n+                        col_str_iters.append(col_iter_str_vals)\n+\n+                        new_cols_escaped.append(col_escaped)\n \n                                 new_cols_escaped.append(col_escaped)\n \n",
    "variant_7": "diff --git a/astropy/io/ascii/html.py b/astropy/io/ascii/html.py\nindex 266cf229cc..301a8bc490 100644\n--- a/astropy/io/ascii/html.py\n+++ b/astropy/io/ascii/html.py\n@@ -423,6 +423,20 @@ class HTML(core.BaseReader):\n                         # requires that the weakref info._parent be maintained.\n                         new_cols = []\n \n+                        for col, col_escaped in zip(cols, cols_escaped):\n+                            if len(col.shape) > 1 and self.html['multicol']:\n+                                span = col.shape[1]\n+                                for i in range(span):\n+\n+                        # below for multicolumn elements.  This is purely to\n+                        # maintain a reference for these objects during\n+                        # subsequent iteration to format column values.  This\n+                        # requires that the weakref info._parent be maintained.\n+                        new_cols = []\n+\n+                        # Apply custom formats from the formats argument\n+                        self._set_col_formats()\n+\n                         for col, col_escaped in zip(cols, cols_escaped):\n                             if len(col.shape) > 1 and self.html['multicol']:\n                                 span = col.shape[1]\n@@ -437,8 +451,23 @@ class HTML(core.BaseReader):\n                                     new_cols.append(new_col)\n                             else:\n \n-                                col_iter_str_vals = self.fill_values(col, col.info.iter_str_vals())\n-                                col_str_iters.append(col_iter_str_vals)\n+\n+                            # Split up multicolumns into separate columns\n+                            new_col = Column([el[i] for el in col])\n+\n+                            new_col_iter_str_vals = self.fill_values(\n+                                col, new_col.info.iter_str_vals())\n+                            col_str_iters.append(new_col_iter_str_vals)\n+                            new_cols_escaped.append(col_escaped)\n+                            new_cols.append(new_col)\n+                    else:\n+                        # Apply column formats before extracting string values\n+                        self._set_col_formats()\n+                        \n+                        col_iter_str_vals = self.fill_values(col, col.info.iter_str_vals())\n+                        col_str_iters.append(col_iter_str_vals)\n+\n+                        new_cols_escaped.append(col_escaped)\n \n                                 new_cols_escaped.append(col_escaped)\n \n",
    "variant_8": "diff --git a/astropy/io/ascii/html.py b/astropy/io/ascii/html.py\nindex 266cf229cc..7c47dfbf85 100644\n--- a/astropy/io/ascii/html.py\n+++ b/astropy/io/ascii/html.py\n@@ -427,6 +427,31 @@ class HTML(core.BaseReader):\n                             if len(col.shape) > 1 and self.html['multicol']:\n                                 span = col.shape[1]\n                                 for i in range(span):\n+\n+                        # below for multicolumn elements.  This is purely to\n+                        # maintain a reference for these objects during\n+                        # subsequent iteration to format column values.  This\n+                        # requires that the weakref info._parent be maintained.\n+                        new_cols = []\n+\n+                        # Apply custom formats before processing columns\n+                        self._set_col_formats()\n+\n+                        for col, col_escaped in zip(cols, cols_escaped):\n+                            if len(col.shape) > 1 and self.html['multicol']:\n+                                span = col.shape[1]\n+                                for i in range(span):\n+                                    # Split up multicolumns into separate columns\n+                                    new_col = Column([el[i] for el in col])\n+\n+                                    new_col_iter_str_vals = self.fill_values(\n+                                        col, new_col.info.iter_str_vals())\n+                                    col_str_iters.append(new_col_iter_str_vals)\n+                                    new_cols_escaped.append(col_escaped)\n+                                    new_cols.append(new_col)\n+                            else:\n+\n+\n                                     # Split up multicolumns into separate columns\n                                     new_col = Column([el[i] for el in col])\n \n"
  }
}