{
  "zero_patches": {
    "Location 1 (/root/hy/projects/django/django/db/models/query.py lines 544-544)": "\n        if not objs:\n            return 0\n",
    "Location 2 (/root/hy/projects/django/django/db/models/query.py lines 566-568)": "\n        total_rows = 0\n        with transaction.atomic(using=self.db, savepoint=False):\n            for pks, update_kwargs in updates:\n                total_rows += self.filter(pk__in=pks).update(**update_kwargs)\n        return total_rows\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/django/django/db/models/query.py lines 544-544)": [
      "\n        if not objs:\n            return 0\n",
      "\n        if not objs:\n            return 0\n",
      "\n        if not objs:\n            return 0\n",
      "\ndef bulk_update(self, objs, fields, batch_size=None):\n    \"\"\"\n    Update the given fields in each of the given objects in the database.\n    \"\"\"\n    if batch_size is not None and batch_size < 0:\n        raise ValueError('Batch size must be a positive integer.')\n    if not fields:\n        raise ValueError('Field names must be given to bulk_update().')\n    objs = tuple(objs)\n    if any(obj.pk is None for obj in objs):\n        raise ValueError('All bulk_update() objects must have a primary key set.')\n    fields = [self.model._meta.get_field(name) for name in fields]\n    if any(not f.concrete or f.many_to_many for f in fields):\n        raise ValueError('bulk_update() can only be used with concrete fields.')\n    if any(f.primary_key for f in fields):\n        raise ValueError('bulk_update() cannot be used with primary key fields.')\n    if not objs:\n        return 0\n    # PK is used twice in the resulting update query, once in the filter\n    # and once in the WHEN. Each field will also have one CAST.\n    max_batch_size = connections[self.db].ops.bulk_batch_size(['pk', 'pk'] + fields, objs)\n    batch_size = min(batch_size, max_batch_size) if batch_size else max_batch_size\n    requires_casting = connections[self.db].features.requires_casted_case_in_updates\n    batches = (objs[i:i + batch_size] for i in range(0, len(objs), batch_size))\n    updates = []\n    for batch_objs in batches:\n        update_kwargs = {}\n        for field in fields:\n            when_stmts = []\n            for obj in batch_objs:\n                attr = getattr(obj, field.attname)\n                if not hasattr(attr, 'resolve_expression'):\n                    attr = Value(attr, output_field=field)\n                when_stmts.append(When(pk=obj.pk, then=attr))\n            case_stmt = Case(*when_stmts, output_field=field)\n            if requires_casting:\n                case_stmt = Cast(case_stmt, output_field=field)\n            update_kwargs[field.attname] = case_stmt\n        updates.append(([obj.pk for obj in batch_objs], update_kwargs))\n    total_rows = 0\n    with transaction.atomic(using=self.db, savepoint=False):\n        for pks, update_kwargs in updates:\n            total_rows += self.filter(pk__in=pks).update(**update_kwargs)\n    return total_rows\n",
      "\n        if not objs:\n            return 0\n",
      "\n            return 0\n",
      "\n            return 0\n",
      "\n            return 0\n"
    ],
    "Location 2 (/root/hy/projects/django/django/db/models/query.py lines 566-568)": [
      "\n        total_rows = 0\n        with transaction.atomic(using=self.db, savepoint=False):\n            for pks, update_kwargs in updates:\n                total_rows += self.filter(pk__in=pks).update(**update_kwargs)\n        return total_rows\n",
      "\n        total_rows = 0\n        with transaction.atomic(using=self.db, savepoint=False):\n            for pks, update_kwargs in updates:\n                total_rows += self.filter(pk__in=pks).update(**update_kwargs)\n        return total_rows\n",
      "\n        total_rows = 0\n        with transaction.atomic(using=self.db, savepoint=False):\n            for pks, update_kwargs in updates:\n                total_rows += self.filter(pk__in=pks).update(**update_kwargs)\n        return total_rows\n",
      "\n        total_rows = 0\n        with transaction.atomic(using=self.db, savepoint=False):\n            for pks, update_kwargs in updates:\n                total_rows += self.filter(pk__in=pks).update(**update_kwargs)\n        return total_rows\n",
      "\n        total_rows = 0\n        with transaction.atomic(using=self.db, savepoint=False):\n            for pks, update_kwargs in updates:\n                total_rows += self.filter(pk__in=pks).update(**update_kwargs)\n        return total_rows\n",
      "\n        total_rows = 0\n        with transaction.atomic(using=self.db, savepoint=False):\n            for pks, update_kwargs in updates:\n                total_rows += self.filter(pk__in=pks).update(**update_kwargs)\n        return total_rows\n",
      "\n        total_rows = 0\n        with transaction.atomic(using=self.db, savepoint=False):\n            for pks, update_kwargs in updates:\n                total_rows += self.filter(pk__in=pks).update(**update_kwargs)\n        return total_rows\n",
      "\n        total_rows = 0\n        with transaction.atomic(using=self.db, savepoint=False):\n            for pks, update_kwargs in updates:\n                total_rows += self.filter(pk__in=pks).update(**update_kwargs)\n        return total_rows\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 387deca527..a0fac55e83 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -541,7 +541,8 @@ class QuerySet:\n         if any(f.primary_key for f in fields):\n             raise ValueError('bulk_update() cannot be used with primary key fields.')\n         if not objs:\n-            return\n+\n+            return 0\n         # PK is used twice in the resulting update query, once in the filter\n         # and once in the WHEN. Each field will also have one CAST.\n         max_batch_size = connections[self.db].ops.bulk_batch_size(['pk', 'pk'] + fields, objs)\n@@ -563,9 +564,12 @@ class QuerySet:\n                     case_statement = Cast(case_statement, output_field=field)\n                 update_kwargs[field.attname] = case_statement\n             updates.append(([obj.pk for obj in batch_objs], update_kwargs))\n+\n+        total_rows = 0\n         with transaction.atomic(using=self.db, savepoint=False):\n             for pks, update_kwargs in updates:\n-                self.filter(pk__in=pks).update(**update_kwargs)\n+                total_rows += self.filter(pk__in=pks).update(**update_kwargs)\n+        return total_rows\n     bulk_update.alters_data = True\n \n     def get_or_create(self, defaults=None, **kwargs):\n",
    "variant_0": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 387deca527..080ccaffc1 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -541,7 +541,9 @@ class QuerySet:\n         if any(f.primary_key for f in fields):\n             raise ValueError('bulk_update() cannot be used with primary key fields.')\n         if not objs:\n-            return\n+\n+        if not objs:\n+            return 0\n         # PK is used twice in the resulting update query, once in the filter\n         # and once in the WHEN. Each field will also have one CAST.\n         max_batch_size = connections[self.db].ops.bulk_batch_size(['pk', 'pk'] + fields, objs)\n@@ -563,9 +565,12 @@ class QuerySet:\n                     case_statement = Cast(case_statement, output_field=field)\n                 update_kwargs[field.attname] = case_statement\n             updates.append(([obj.pk for obj in batch_objs], update_kwargs))\n+\n+        total_rows = 0\n         with transaction.atomic(using=self.db, savepoint=False):\n             for pks, update_kwargs in updates:\n-                self.filter(pk__in=pks).update(**update_kwargs)\n+                total_rows += self.filter(pk__in=pks).update(**update_kwargs)\n+        return total_rows\n     bulk_update.alters_data = True\n \n     def get_or_create(self, defaults=None, **kwargs):\n",
    "variant_1": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 387deca527..080ccaffc1 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -541,7 +541,9 @@ class QuerySet:\n         if any(f.primary_key for f in fields):\n             raise ValueError('bulk_update() cannot be used with primary key fields.')\n         if not objs:\n-            return\n+\n+        if not objs:\n+            return 0\n         # PK is used twice in the resulting update query, once in the filter\n         # and once in the WHEN. Each field will also have one CAST.\n         max_batch_size = connections[self.db].ops.bulk_batch_size(['pk', 'pk'] + fields, objs)\n@@ -563,9 +565,12 @@ class QuerySet:\n                     case_statement = Cast(case_statement, output_field=field)\n                 update_kwargs[field.attname] = case_statement\n             updates.append(([obj.pk for obj in batch_objs], update_kwargs))\n+\n+        total_rows = 0\n         with transaction.atomic(using=self.db, savepoint=False):\n             for pks, update_kwargs in updates:\n-                self.filter(pk__in=pks).update(**update_kwargs)\n+                total_rows += self.filter(pk__in=pks).update(**update_kwargs)\n+        return total_rows\n     bulk_update.alters_data = True\n \n     def get_or_create(self, defaults=None, **kwargs):\n",
    "variant_2": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 387deca527..080ccaffc1 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -541,7 +541,9 @@ class QuerySet:\n         if any(f.primary_key for f in fields):\n             raise ValueError('bulk_update() cannot be used with primary key fields.')\n         if not objs:\n-            return\n+\n+        if not objs:\n+            return 0\n         # PK is used twice in the resulting update query, once in the filter\n         # and once in the WHEN. Each field will also have one CAST.\n         max_batch_size = connections[self.db].ops.bulk_batch_size(['pk', 'pk'] + fields, objs)\n@@ -563,9 +565,12 @@ class QuerySet:\n                     case_statement = Cast(case_statement, output_field=field)\n                 update_kwargs[field.attname] = case_statement\n             updates.append(([obj.pk for obj in batch_objs], update_kwargs))\n+\n+        total_rows = 0\n         with transaction.atomic(using=self.db, savepoint=False):\n             for pks, update_kwargs in updates:\n-                self.filter(pk__in=pks).update(**update_kwargs)\n+                total_rows += self.filter(pk__in=pks).update(**update_kwargs)\n+        return total_rows\n     bulk_update.alters_data = True\n \n     def get_or_create(self, defaults=None, **kwargs):\n",
    "variant_3": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 387deca527..080ccaffc1 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -541,7 +541,9 @@ class QuerySet:\n         if any(f.primary_key for f in fields):\n             raise ValueError('bulk_update() cannot be used with primary key fields.')\n         if not objs:\n-            return\n+\n+        if not objs:\n+            return 0\n         # PK is used twice in the resulting update query, once in the filter\n         # and once in the WHEN. Each field will also have one CAST.\n         max_batch_size = connections[self.db].ops.bulk_batch_size(['pk', 'pk'] + fields, objs)\n@@ -563,9 +565,12 @@ class QuerySet:\n                     case_statement = Cast(case_statement, output_field=field)\n                 update_kwargs[field.attname] = case_statement\n             updates.append(([obj.pk for obj in batch_objs], update_kwargs))\n+\n+        total_rows = 0\n         with transaction.atomic(using=self.db, savepoint=False):\n             for pks, update_kwargs in updates:\n-                self.filter(pk__in=pks).update(**update_kwargs)\n+                total_rows += self.filter(pk__in=pks).update(**update_kwargs)\n+        return total_rows\n     bulk_update.alters_data = True\n \n     def get_or_create(self, defaults=None, **kwargs):\n",
    "variant_4": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 387deca527..3b98299382 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -541,7 +541,51 @@ class QuerySet:\n         if any(f.primary_key for f in fields):\n             raise ValueError('bulk_update() cannot be used with primary key fields.')\n         if not objs:\n-            return\n+\n+def bulk_update(self, objs, fields, batch_size=None):\n+    \"\"\"\n+    Update the given fields in each of the given objects in the database.\n+    \"\"\"\n+    if batch_size is not None and batch_size < 0:\n+        raise ValueError('Batch size must be a positive integer.')\n+    if not fields:\n+        raise ValueError('Field names must be given to bulk_update().')\n+    objs = tuple(objs)\n+    if any(obj.pk is None for obj in objs):\n+        raise ValueError('All bulk_update() objects must have a primary key set.')\n+    fields = [self.model._meta.get_field(name) for name in fields]\n+    if any(not f.concrete or f.many_to_many for f in fields):\n+        raise ValueError('bulk_update() can only be used with concrete fields.')\n+    if any(f.primary_key for f in fields):\n+        raise ValueError('bulk_update() cannot be used with primary key fields.')\n+    if not objs:\n+        return 0\n+    # PK is used twice in the resulting update query, once in the filter\n+    # and once in the WHEN. Each field will also have one CAST.\n+    max_batch_size = connections[self.db].ops.bulk_batch_size(['pk', 'pk'] + fields, objs)\n+    batch_size = min(batch_size, max_batch_size) if batch_size else max_batch_size\n+    requires_casting = connections[self.db].features.requires_casted_case_in_updates\n+    batches = (objs[i:i + batch_size] for i in range(0, len(objs), batch_size))\n+    updates = []\n+    for batch_objs in batches:\n+        update_kwargs = {}\n+        for field in fields:\n+            when_stmts = []\n+            for obj in batch_objs:\n+                attr = getattr(obj, field.attname)\n+                if not hasattr(attr, 'resolve_expression'):\n+                    attr = Value(attr, output_field=field)\n+                when_stmts.append(When(pk=obj.pk, then=attr))\n+            case_stmt = Case(*when_stmts, output_field=field)\n+            if requires_casting:\n+                case_stmt = Cast(case_stmt, output_field=field)\n+            update_kwargs[field.attname] = case_stmt\n+        updates.append(([obj.pk for obj in batch_objs], update_kwargs))\n+    total_rows = 0\n+    with transaction.atomic(using=self.db, savepoint=False):\n+        for pks, update_kwargs in updates:\n+            total_rows += self.filter(pk__in=pks).update(**update_kwargs)\n+    return total_rows\n         # PK is used twice in the resulting update query, once in the filter\n         # and once in the WHEN. Each field will also have one CAST.\n         max_batch_size = connections[self.db].ops.bulk_batch_size(['pk', 'pk'] + fields, objs)\n@@ -563,9 +607,12 @@ class QuerySet:\n                     case_statement = Cast(case_statement, output_field=field)\n                 update_kwargs[field.attname] = case_statement\n             updates.append(([obj.pk for obj in batch_objs], update_kwargs))\n+\n+        total_rows = 0\n         with transaction.atomic(using=self.db, savepoint=False):\n             for pks, update_kwargs in updates:\n-                self.filter(pk__in=pks).update(**update_kwargs)\n+                total_rows += self.filter(pk__in=pks).update(**update_kwargs)\n+        return total_rows\n     bulk_update.alters_data = True\n \n     def get_or_create(self, defaults=None, **kwargs):\n",
    "variant_5": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 387deca527..080ccaffc1 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -541,7 +541,9 @@ class QuerySet:\n         if any(f.primary_key for f in fields):\n             raise ValueError('bulk_update() cannot be used with primary key fields.')\n         if not objs:\n-            return\n+\n+        if not objs:\n+            return 0\n         # PK is used twice in the resulting update query, once in the filter\n         # and once in the WHEN. Each field will also have one CAST.\n         max_batch_size = connections[self.db].ops.bulk_batch_size(['pk', 'pk'] + fields, objs)\n@@ -563,9 +565,12 @@ class QuerySet:\n                     case_statement = Cast(case_statement, output_field=field)\n                 update_kwargs[field.attname] = case_statement\n             updates.append(([obj.pk for obj in batch_objs], update_kwargs))\n+\n+        total_rows = 0\n         with transaction.atomic(using=self.db, savepoint=False):\n             for pks, update_kwargs in updates:\n-                self.filter(pk__in=pks).update(**update_kwargs)\n+                total_rows += self.filter(pk__in=pks).update(**update_kwargs)\n+        return total_rows\n     bulk_update.alters_data = True\n \n     def get_or_create(self, defaults=None, **kwargs):\n",
    "variant_6": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 387deca527..a0fac55e83 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -541,7 +541,8 @@ class QuerySet:\n         if any(f.primary_key for f in fields):\n             raise ValueError('bulk_update() cannot be used with primary key fields.')\n         if not objs:\n-            return\n+\n+            return 0\n         # PK is used twice in the resulting update query, once in the filter\n         # and once in the WHEN. Each field will also have one CAST.\n         max_batch_size = connections[self.db].ops.bulk_batch_size(['pk', 'pk'] + fields, objs)\n@@ -563,9 +564,12 @@ class QuerySet:\n                     case_statement = Cast(case_statement, output_field=field)\n                 update_kwargs[field.attname] = case_statement\n             updates.append(([obj.pk for obj in batch_objs], update_kwargs))\n+\n+        total_rows = 0\n         with transaction.atomic(using=self.db, savepoint=False):\n             for pks, update_kwargs in updates:\n-                self.filter(pk__in=pks).update(**update_kwargs)\n+                total_rows += self.filter(pk__in=pks).update(**update_kwargs)\n+        return total_rows\n     bulk_update.alters_data = True\n \n     def get_or_create(self, defaults=None, **kwargs):\n",
    "variant_7": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 387deca527..a0fac55e83 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -541,7 +541,8 @@ class QuerySet:\n         if any(f.primary_key for f in fields):\n             raise ValueError('bulk_update() cannot be used with primary key fields.')\n         if not objs:\n-            return\n+\n+            return 0\n         # PK is used twice in the resulting update query, once in the filter\n         # and once in the WHEN. Each field will also have one CAST.\n         max_batch_size = connections[self.db].ops.bulk_batch_size(['pk', 'pk'] + fields, objs)\n@@ -563,9 +564,12 @@ class QuerySet:\n                     case_statement = Cast(case_statement, output_field=field)\n                 update_kwargs[field.attname] = case_statement\n             updates.append(([obj.pk for obj in batch_objs], update_kwargs))\n+\n+        total_rows = 0\n         with transaction.atomic(using=self.db, savepoint=False):\n             for pks, update_kwargs in updates:\n-                self.filter(pk__in=pks).update(**update_kwargs)\n+                total_rows += self.filter(pk__in=pks).update(**update_kwargs)\n+        return total_rows\n     bulk_update.alters_data = True\n \n     def get_or_create(self, defaults=None, **kwargs):\n",
    "variant_8": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 387deca527..a0fac55e83 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -541,7 +541,8 @@ class QuerySet:\n         if any(f.primary_key for f in fields):\n             raise ValueError('bulk_update() cannot be used with primary key fields.')\n         if not objs:\n-            return\n+\n+            return 0\n         # PK is used twice in the resulting update query, once in the filter\n         # and once in the WHEN. Each field will also have one CAST.\n         max_batch_size = connections[self.db].ops.bulk_batch_size(['pk', 'pk'] + fields, objs)\n@@ -563,9 +564,12 @@ class QuerySet:\n                     case_statement = Cast(case_statement, output_field=field)\n                 update_kwargs[field.attname] = case_statement\n             updates.append(([obj.pk for obj in batch_objs], update_kwargs))\n+\n+        total_rows = 0\n         with transaction.atomic(using=self.db, savepoint=False):\n             for pks, update_kwargs in updates:\n-                self.filter(pk__in=pks).update(**update_kwargs)\n+                total_rows += self.filter(pk__in=pks).update(**update_kwargs)\n+        return total_rows\n     bulk_update.alters_data = True\n \n     def get_or_create(self, defaults=None, **kwargs):\n"
  }
}