{
  "zero_patches": {
    "Location 1 (/root/hy/projects/django/django/db/models/sql/query.py lines 1232-1238)": "\ndef contains_outerref(expr):\n    \"\"\"Recursively check if expression contains OuterRef instances.\"\"\"\n    from django.db.models.expressions import OuterRef\n    if isinstance(expr, OuterRef):\n        return True\n    if hasattr(expr, 'get_source_expressions'):\n        for source_expr in expr.get_source_expressions():\n            if source_expr and contains_outerref(source_expr):\n                return True\n    return False\n\n        if isinstance(filter_expr, dict):\n            raise FieldError(\"Cannot parse keyword query as dict\")\n        if hasattr(filter_expr, 'resolve_expression') and getattr(filter_expr, 'conditional', False):\n            if not contains_outerref(filter_expr):\n                if connections[DEFAULT_DB_ALIAS].ops.conditional_expression_supported_in_where_clause(filter_expr):\n                    condition = filter_expr.resolve_expression(self)\n                else:\n                    # Expression is not supported in the WHERE clause, add\n                    # comparison with True.\n                    condition = self.build_lookup(['exact'], filter_expr.resolve_expression(self), True)\n                clause = self.where_class()\n                clause.add(condition, AND)\n                return clause, []\n            # Fall through to normal processing for expressions containing OuterRef\n",
    "Location 2 (/root/hy/projects/django/django/db/models/expressions.py lines 565-570)": "\ndef contains_outerref(expr):\n    \"\"\"Recursively check if expression contains OuterRef instances.\"\"\"\n    from django.db.models.expressions import OuterRef\n    if isinstance(expr, OuterRef):\n        return True\n    if hasattr(expr, 'get_source_expressions'):\n        for source_expr in expr.get_source_expressions():\n            if source_expr and contains_outerref(source_expr):\n                return True\n    return False\n\ndef build_filter(self, filter_expr, branch_negated=False, current_negated=False,\n                 can_reuse=None, allow_joins=True, split_subq=True,\n                 check_filterable=True):\n    \"\"\"\n    Build a WHERE clause for a single filter clause. A filter clause can\n    be specified in one of the formats:\n\n    - \"field_name__lookuptype=value\" -> (\"field_name\", \"lookuptype\", value)\n    - (\"field_name__lookuptype\", value) -> (\"field_name\", \"lookuptype\", value)\n    - \"field_name\" -> (\"field_name\", \"exact\", True)\n    - Q()-object\n\n    The 'branch_negated' tells us if the current branch contains any\n    negations. This will be used to determine if subqueries are needed.\n\n    The 'current_negated' is used to determine if the current filter is\n    negated or not and this is used to determine if IS NULL filtering\n    is needed.\n\n    The difference between current_negated and branch_negated is that\n    branch_negated is set on first negation, but current_negated is\n    flipped for each negation.\n\n    Note that add_filter will not do any negating itself, that is done\n    upper in the code by add_q().\n\n    The 'can_reuse' is a set of reusable joins for multijoins.\n\n    The method will create a filter clause that can be added to the current\n    query. However, if the filter isn't added to the query then the caller\n    is responsible for unreferencing all the joins used.\n    \"\"\"\n    if isinstance(filter_expr, dict):\n        raise FieldError(\"Cannot parse keyword query as dict\")\n    if isinstance(filter_expr, Q):\n        return self._add_q(\n            filter_expr,\n            branch_negated=branch_negated,\n            current_negated=current_negated,\n            used_aliases=can_reuse,\n            allow_joins=allow_joins,\n            split_subq=split_subq,\n            check_filterable=check_filterable,\n        )\n    if hasattr(filter_expr, 'resolve_expression'):\n        if getattr(filter_expr, 'conditional', False) and not contains_outerref(filter_expr):\n            if connections[DEFAULT_DB_ALIAS].ops.conditional_expression_supported_in_where_clause(filter_expr):\n                condition = filter_expr.resolve_expression(self)\n            else:\n                condition = self.build_lookup(['exact'], filter_expr.resolve_expression(self), True)\n            clause = self.where_class()\n            clause.add(condition, AND)\n            return clause, []\n        else:\n            filter_expr = self.resolve_expression(filter_expr, allow_joins=allow_joins)\n    try:\n        arg, value = filter_expr\n    except (TypeError, ValueError):\n        raise FieldError(\"Cannot parse remainder of '%s' as a keyword query\" % filter_expr)\n\n    lookups, parts, reffed_expression = self.solve_lookup_type(arg)\n\n    if check_filterable:\n        self.check_filterable(reffed_expression)\n\n    if not allow_joins and len(parts) > 1:\n        raise FieldError(\"Joined field references are not permitted in this query\")\n\n    pre_joins = self.alias_refcount.copy()\n    value = self.resolve_lookup_value(value, can_reuse, allow_joins)\n    used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}\n\n    if check_filterable:\n        self.check_filterable(reffed_expression)\n    clause = self.build_lookup(lookups, reffed_expression, value)\n    return clause, used_joins\n",
    "Location 3 (/root/hy/projects/django/django/db/models/expressions.py lines 546-562)": "\nclass ResolvedOuterRef(F):\n    \"\"\"\n    An object that contains a reference to an outer query.\n\n    In this case, the reference to the outer query has been resolved because\n    the inner query has been used as a subquery.\n    \"\"\"\n    contains_aggregate = False\n\n    def as_sql(self, *args, **kwargs):\n        raise ValueError(\n            'This queryset contains a reference to an outer query and may '\n            'only be used in a subquery.'\n        )\n\n    def relabeled_clone(self, relabels):\n        return self\n",
    "Location 4 (/root/hy/projects/django/django/db/models/query.py lines 896-902)": "\ndef exclude(self, *args, **kwargs):\n    \"\"\"\n    Return a new QuerySet instance with NOT (args) ANDed to the existing\n    set.\n    \"\"\"\n    self._not_support_combined_queries('exclude')\n    return self._filter_or_exclude(True, *args, **kwargs)\n",
    "Location 5 (/root/hy/projects/django/django/db/models/query.py lines 904-914)": "\ndef _filter_or_exclude(self, negate, *args, **kwargs):\n    if args or kwargs:\n        assert not self.query.is_sliced, \\\n            \"Cannot filter a query once a slice has been taken.\"\n\n    clone = self._chain()\n    if negate:\n        clone.query.add_q(~Q(*args, **kwargs))\n    else:\n        clone.query.add_q(Q(*args, **kwargs))\n    return clone\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/django/django/db/models/sql/query.py lines 1232-1238)": [
      "\n    def contains_outerref(expr):\n        \"\"\"Recursively check if expression contains OuterRef instances.\"\"\"\n        from django.db.models.expressions import OuterRef\n        if isinstance(expr, OuterRef):\n            return True\n        if hasattr(expr, 'get_source_expressions'):\n            for source_expr in expr.get_source_expressions():\n                if source_expr and contains_outerref(source_expr):\n                    return True\n        return False\n\n    if isinstance(filter_expr, dict):\n        raise FieldError(\"Cannot parse keyword query as dict\")\n    if hasattr(filter_expr, 'resolve_expression') and getattr(filter_expr, 'conditional', False):\n        if not contains_outerref(filter_expr):\n            if connections[DEFAULT_DB_ALIAS].ops.conditional_expression_supported_in_where_clause(filter_expr):\n                condition = filter_expr.resolve_expression(self)\n            else:\n                # Expression is not supported in the WHERE clause, add\n                # comparison with True.\n                condition = self.build_lookup(['exact'], filter_expr.resolve_expression(self), True)\n            clause = self.where_class()\n            clause.add(condition, AND)\n            return clause, []\n        # Fall through to normal processing for expressions containing OuterRef\n",
      "\ndef contains_outerref(expr):\n    \"\"\"Recursively check if expression contains OuterRef instances.\"\"\"\n    from django.db.models.expressions import OuterRef\n    if isinstance(expr, OuterRef):\n        return True\n    if hasattr(expr, 'get_source_expressions'):\n        for source_expr in expr.get_source_expressions():\n            if source_expr and contains_outerref(source_expr):\n                return True\n    return False\n\n        if isinstance(filter_expr, dict):\n            raise FieldError(\"Cannot parse keyword query as dict\")\n        if hasattr(filter_expr, 'resolve_expression') and getattr(filter_expr, 'conditional', False):\n            if not contains_outerref(filter_expr):\n                if connections[DEFAULT_DB_ALIAS].ops.conditional_expression_supported_in_where_clause(filter_expr):\n                    condition = filter_expr.resolve_expression(self)\n                else:\n                    # Expression is not supported in the WHERE clause, add\n                    # comparison with True.\n                    condition = self.build_lookup(['exact'], filter_expr.resolve_expression(self), True)\n                clause = self.where_class()\n                clause.add(condition, AND)\n                return clause, []\n            # Fall through to normal processing for expressions containing OuterRef\n",
      "\ndef contains_outerref(expr):\n    \"\"\"Recursively check if expression contains OuterRef instances.\"\"\"\n    from django.db.models.expressions import OuterRef\n    if isinstance(expr, OuterRef):\n        return True\n    if hasattr(expr, 'get_source_expressions'):\n        for source_expr in expr.get_source_expressions():\n            if source_expr and contains_outerref(source_expr):\n                return True\n    return False\n\n        if isinstance(filter_expr, dict):\n            raise FieldError(\"Cannot parse keyword query as dict\")\n        if hasattr(filter_expr, 'resolve_expression') and getattr(filter_expr, 'conditional', False):\n            if not contains_outerref(filter_expr):\n                if connections[DEFAULT_DB_ALIAS].ops.conditional_expression_supported_in_where_clause(filter_expr):\n                    condition = filter_expr.resolve_expression(self)\n                else:\n                    # Expression is not supported in the WHERE clause, add\n                    # comparison with True.\n                    condition = self.build_lookup(['exact'], filter_expr.resolve_expression(self), True)\n                clause = self.where_class()\n                clause.add(condition, AND)\n                return clause, []\n            # Fall through to normal processing for expressions containing OuterRef\n",
      "\ndef contains_outerref(expr):\n    \"\"\"Recursively check if expression contains OuterRef instances.\"\"\"\n    from django.db.models.expressions import OuterRef\n    if isinstance(expr, OuterRef):\n        return True\n    if hasattr(expr, 'get_source_expressions'):\n        for source_expr in expr.get_source_expressions():\n            if source_expr and contains_outerref(source_expr):\n                return True\n    return False\n\n        if isinstance(filter_expr, dict):\n            raise FieldError(\"Cannot parse keyword query as dict\")\n        if hasattr(filter_expr, 'resolve_expression') and getattr(filter_expr, 'conditional', False):\n            if not contains_outerref(filter_expr):\n                if connections[DEFAULT_DB_ALIAS].ops.conditional_expression_supported_in_where_clause(filter_expr):\n                    condition = filter_expr.resolve_expression(self)\n                else:\n                    # Expression is not supported in the WHERE clause, add\n                    # comparison with True.\n                    condition = self.build_lookup(['exact'], filter_expr.resolve_expression(self), True)\n                clause = self.where_class()\n                clause.add(condition, AND)\n                return clause, []\n            # Fall through to normal processing for expressions containing OuterRef\n",
      "\ndef build_filter(self, filter_expr, branch_negated=False, current_negated=False,\n                 can_reuse=None, allow_joins=True,\n                 split_subquery=True, reuse_with_filtered_relation=False,\n                 check_filterable=True):\n    \"\"\"\n    Build a WHERE clause for a single filter clause, such as 'foo=1' or\n    'foo__bar__name__contains=\"test\"'. filter_expr can be a Q() object,\n    a python object, or a tuple of (lookup_type, value_list). branch_negated\n    tells us if the current branch contains any negations. This will be used\n    to determine if subqueries are needed.\n\n    current_negated is used to determine if the current filter is negated or not\n    and this is used to determine if IS NULL or IS NOT NULL should be used.\n\n    can_reuse is a set of reusable joins for multijoins.\n\n    The method will create a filter clause that can be added to the current\n    query. However, if the filter isn't added to the query then the caller\n    is responsible for unreffing the joins used.\n    \"\"\"\n    def contains_outerref(expr):\n        \"\"\"Recursively check if expression contains OuterRef instances.\"\"\"\n        from django.db.models.expressions import OuterRef\n        if isinstance(expr, OuterRef):\n            return True\n        if hasattr(expr, 'get_source_expressions'):\n            for source_expr in expr.get_source_expressions():\n                if source_expr and contains_outerref(source_expr):\n                    return True\n        return False\n\n    if isinstance(filter_expr, dict):\n        raise FieldError(\"Cannot parse keyword query as dict\")\n    if hasattr(filter_expr, 'resolve_expression') and getattr(filter_expr, 'conditional', False):\n        if not contains_outerref(filter_expr):\n            if connections[DEFAULT_DB_ALIAS].ops.conditional_expression_supported_in_where_clause(filter_expr):\n                condition = filter_expr.resolve_expression(self)\n            else:\n                # Expression is not supported in the WHERE clause, add\n                # comparison with True.\n                condition = self.build_lookup(['exact'], filter_expr.resolve_expression(self), True)\n            clause = self.where_class()\n            clause.add(condition, AND)\n            return clause, []\n        # Fall through to normal processing for expressions containing OuterRef\n    arg, value = filter_expr\n    if not arg:\n        raise FieldError(\"Cannot parse keyword query %r\" % arg)\n    lookups, parts, reffed_expression = self.solve_lookup_type(arg)\n\n    self.check_filterable(reffed_expression)\n",
      "\ndef contains_outerref(expr):\n    \"\"\"Recursively check if expression contains OuterRef instances.\"\"\"\n    from django.db.models.expressions import OuterRef\n    if isinstance(expr, OuterRef):\n        return True\n    if hasattr(expr, 'get_source_expressions'):\n        for source_expr in expr.get_source_expressions():\n            if source_expr and contains_outerref(source_expr):\n                return True\n    return False\n\n        if isinstance(filter_expr, dict):\n            raise FieldError(\"Cannot parse keyword query as dict\")\n        if hasattr(filter_expr, 'resolve_expression') and getattr(filter_expr, 'conditional', False):\n            if not contains_outerref(filter_expr):\n                if connections[DEFAULT_DB_ALIAS].ops.conditional_expression_supported_in_where_clause(filter_expr):\n                    condition = filter_expr.resolve_expression(self)\n                else:\n                    # Expression is not supported in the WHERE clause, add\n                    # comparison with True.\n                    condition = self.build_lookup(['exact'], filter_expr.resolve_expression(self), True)\n                clause = self.where_class()\n                clause.add(condition, AND)\n                return clause, []\n            # Fall through to normal processing for expressions containing OuterRef\n",
      "\ndef contains_outerref(expr):\n    \"\"\"Recursively check if expression contains OuterRef instances.\"\"\"\n    from django.db.models.expressions import OuterRef\n    if isinstance(expr, OuterRef):\n        return True\n    if hasattr(expr, 'get_source_expressions'):\n        for source_expr in expr.get_source_expressions():\n            if source_expr and contains_outerref(source_expr):\n                return True\n    return False\n\n        if isinstance(filter_expr, dict):\n            raise FieldError(\"Cannot parse keyword query as dict\")\n        if hasattr(filter_expr, 'resolve_expression') and getattr(filter_expr, 'conditional', False):\n            if not contains_outerref(filter_expr):\n                if connections[DEFAULT_DB_ALIAS].ops.conditional_expression_supported_in_where_clause(filter_expr):\n                    condition = filter_expr.resolve_expression(self)\n                else:\n                    # Expression is not supported in the WHERE clause, add\n                    # comparison with True.\n                    condition = self.build_lookup(['exact'], filter_expr.resolve_expression(self), True)\n                clause = self.where_class()\n                clause.add(condition, AND)\n                return clause, []\n            # Fall through to normal processing for expressions containing OuterRef\n",
      "\ndef contains_outerref(expr):\n    \"\"\"Recursively check if expression contains OuterRef instances.\"\"\"\n    from django.db.models.expressions import OuterRef\n    if isinstance(expr, OuterRef):\n        return True\n    if hasattr(expr, 'get_source_expressions'):\n        for source_expr in expr.get_source_expressions():\n            if source_expr and contains_outerref(source_expr):\n                return True\n    return False\n\n        if isinstance(filter_expr, dict):\n            raise FieldError(\"Cannot parse keyword query as dict\")\n        if hasattr(filter_expr, 'resolve_expression') and getattr(filter_expr, 'conditional', False):\n            if not contains_outerref(filter_expr):\n                if connections[DEFAULT_DB_ALIAS].ops.conditional_expression_supported_in_where_clause(filter_expr):\n                    condition = filter_expr.resolve_expression(self)\n                else:\n                    # Expression is not supported in the WHERE clause, add\n                    # comparison with True.\n                    condition = self.build_lookup(['exact'], filter_expr.resolve_expression(self), True)\n                clause = self.where_class()\n                clause.add(condition, AND)\n                return clause, []\n            # Fall through to normal processing for expressions containing OuterRef\n"
    ],
    "Location 2 (/root/hy/projects/django/django/db/models/expressions.py lines 565-570)": [
      "\ndef contains_outerref(expr):\n    \"\"\"Recursively check if expression contains OuterRef instances.\"\"\"\n    from django.db.models.expressions import OuterRef\n    if isinstance(expr, OuterRef):\n        return True\n    if hasattr(expr, 'get_source_expressions'):\n        for source_expr in expr.get_source_expressions():\n            if source_expr and contains_outerref(source_expr):\n                return True\n    return False\n\ndef build_filter(self, filter_expr, branch_negated=False, current_negated=False,\n                 can_reuse=None, allow_joins=True, split_subq=True,\n                 check_filterable=True, summarize=False):\n    \"\"\"\n    Build a WHERE clause for the given filter_expr. filter_expr can be\n    anything that add_q() knows how to deal with (Q-objects, lookups, or\n    expressions), possibly negated; then check_filterable has an effect on\n    only non-Q expressions.\n    \"\"\"\n    if hasattr(filter_expr, 'resolve_expression') and getattr(filter_expr, 'conditional', False):\n        if not contains_outerref(filter_expr):\n            if connections[DEFAULT_DB_ALIAS].ops.conditional_expression_supported_in_where_clause(filter_expr):\n                condition = filter_expr.resolve_expression(self)\n            else:\n                condition = self.build_lookup(['exact'], filter_expr.resolve_expression(self), True)\n            clause = self.where_class()\n            clause.add(condition, AND)\n            return clause, []\n        # Fall through to normal processing for expressions containing OuterRef\n    \n    if isinstance(filter_expr, dict):\n        raise FieldError(\"Cannot parse keyword query as dict\")\n    if isinstance(filter_expr, Q):\n        return self._add_q(\n            filter_expr,\n            branch_negated=branch_negated,\n            current_negated=current_negated,\n            used_aliases=can_reuse,\n            allow_joins=allow_joins,\n            split_subq=split_subq,\n            check_filterable=check_filterable,\n            summarize=summarize,\n        )\n    if hasattr(filter_expr, 'resolve_expression'):\n        if not getattr(filter_expr, 'conditional', False):\n            filter_expr = filter_expr.resolve_expression(\n                self, allow_joins=allow_joins, summarize=summarize\n            )\n    if isinstance(filter_expr, Lookup):\n        filter_expr.check_filterable()\n    return self.build_lookup(\n        filter_expr.children[:-1], filter_expr.children[-1],\n        can_reuse, branch_negated, current_negated, allow_joins,\n        split_subq, check_filterable, summarize,\n    )\n",
      "\nclass OuterRef(F):\n    def resolve_expression(self, query=None, allow_joins=True, reuse=None,\n                           summarize=False, for_save=False, simple_col=False):\n        if isinstance(self.name, self.__class__):\n            return self.name\n        return ResolvedOuterRef(self.name)\n",
      "\nclass OuterRef(F):\n    def resolve_expression(self, query=None, allow_joins=True, reuse=None,\n                           summarize=False, for_save=False, simple_col=False):\n        if isinstance(self.name, self.__class__):\n            return self.name\n        return ResolvedOuterRef(self.name)\n",
      "\ndef contains_outerref(expr):\n    \"\"\"Recursively check if expression contains OuterRef instances.\"\"\"\n    from django.db.models.expressions import OuterRef\n    if isinstance(expr, OuterRef):\n        return True\n    if hasattr(expr, 'get_source_expressions'):\n        for source_expr in expr.get_source_expressions():\n            if source_expr and contains_outerref(source_expr):\n                return True\n    return False\n\ndef build_filter(self, filter_expr, branch_negated=False, current_negated=False,\n                 can_reuse=None, allow_joins=True, split_subq=True,\n                 check_filterable=True):\n    \"\"\"\n    Build a WHERE clause for the given filter_expr. branch_negated tells us if\n    the current branch contains any negations. This will be used to determine\n    if subqueries are needed.\n    \"\"\"\n    if hasattr(filter_expr, 'resolve_expression') and getattr(filter_expr, 'conditional', False):\n        if not contains_outerref(filter_expr):\n            if connections[DEFAULT_DB_ALIAS].ops.conditional_expression_supported_in_where_clause(filter_expr):\n                condition = filter_expr.resolve_expression(self)\n            else:\n                condition = self.build_lookup(['exact'], filter_expr.resolve_expression(self), True)\n            clause = self.where_class()\n            clause.add(condition, AND)\n            return clause, []\n        # Fall through to normal processing for expressions containing OuterRef\n\n    if isinstance(filter_expr, dict):\n        raise FieldError(\"Cannot parse keyword query as dict\")\n    if isinstance(filter_expr, Q):\n        return self._add_q(\n            filter_expr,\n            branch_negated=branch_negated,\n            current_negated=current_negated,\n            used_aliases=can_reuse,\n            allow_joins=allow_joins,\n            split_subq=split_subq,\n            check_filterable=check_filterable,\n        )\n    if hasattr(filter_expr, 'resolve_expression'):\n        if not hasattr(filter_expr, 'conditional'):\n            filter_expr = filter_expr.resolve_expression(self, allow_joins=allow_joins)\n    if isinstance(filter_expr, Lookup):\n        filter_expr.check_filterable()\n    return self.build_lookup(\n        filter_expr.lookup_name, filter_expr.lhs, filter_expr.rhs\n    ) if hasattr(filter_expr, 'lookup_name') else self.build_where(filter_expr)\n",
      "\ndef contains_outerref(expr):\n    \"\"\"Recursively check if expression contains OuterRef instances.\"\"\"\n    from django.db.models.expressions import OuterRef\n    if isinstance(expr, OuterRef):\n        return True\n    if hasattr(expr, 'get_source_expressions'):\n        for source_expr in expr.get_source_expressions():\n            if source_expr and contains_outerref(source_expr):\n                return True\n    return False\n\nclass OuterRef(F):\n    def resolve_expression(self, query=None, allow_joins=True, reuse=None,\n                           summarize=False, for_save=False, simple_col=False):\n        if isinstance(self.name, self.__class__):\n            return self.name\n        return ResolvedOuterRef(self.name)\n",
      "\nclass OuterRef(F):\n    def resolve_expression(self, query=None, allow_joins=True, reuse=None,\n                           summarize=False, for_save=False, simple_col=False):\n        if isinstance(self.name, self.__class__):\n            return self.name\n        return ResolvedOuterRef(self.name)\n",
      "\nclass OuterRef(F):\n    def resolve_expression(self, query=None, allow_joins=True, reuse=None,\n                           summarize=False, for_save=False, simple_col=False):\n        if isinstance(self.name, self.__class__):\n            return self.name\n        return ResolvedOuterRef(self.name)\n",
      "\nclass OuterRef(F):\n    def resolve_expression(self, query=None, allow_joins=True, reuse=None,\n                           summarize=False, for_save=False, simple_col=False):\n        if isinstance(self.name, self.__class__):\n            return self.name\n        return ResolvedOuterRef(self.name)\n"
    ],
    "Location 3 (/root/hy/projects/django/django/db/models/expressions.py lines 546-562)": [
      "\nclass ResolvedOuterRef(F):\n    \"\"\"\n    An object that contains a reference to an outer query.\n\n    In this case, the reference to the outer query has been resolved because\n    the inner query has been used as a subquery.\n    \"\"\"\n    contains_aggregate = False\n\n    def as_sql(self, *args, **kwargs):\n        raise ValueError(\n            'This queryset contains a reference to an outer query and may '\n            'only be used in a subquery.'\n        )\n\n    def relabeled_clone(self, relabels):\n        return self\n",
      "\nclass ResolvedOuterRef(F):\n    \"\"\"\n    An object that contains a reference to an outer query.\n\n    In this case, the reference to the outer query has been resolved because\n    the inner query has been used as a subquery.\n    \"\"\"\n    contains_aggregate = False\n\n    def as_sql(self, *args, **kwargs):\n        raise ValueError(\n            'This queryset contains a reference to an outer query and may '\n            'only be used in a subquery.'\n        )\n\n    def relabeled_clone(self, relabels):\n        return self\n",
      "\nclass ResolvedOuterRef(F):\n    \"\"\"\n    An object that contains a reference to an outer query.\n\n    In this case, the reference to the outer query has been resolved because\n    the inner query has been used as a subquery.\n    \"\"\"\n    contains_aggregate = False\n\n    def as_sql(self, *args, **kwargs):\n        raise ValueError(\n            'This queryset contains a reference to an outer query and may '\n            'only be used in a subquery.'\n        )\n\n    def relabeled_clone(self, relabels):\n        return self\n",
      "\nclass ResolvedOuterRef(F):\n    \"\"\"\n    An object that contains a reference to an outer query.\n\n    In this case, the reference to the outer query has been resolved because\n    the inner query has been used as a subquery.\n    \"\"\"\n    contains_aggregate = False\n\n    def as_sql(self, *args, **kwargs):\n        raise ValueError(\n            'This queryset contains a reference to an outer query and may '\n            'only be used in a subquery.'\n        )\n\n    def relabeled_clone(self, relabels):\n        return self\n",
      "\nclass ResolvedOuterRef(F):\n    \"\"\"\n    An object that contains a reference to an outer query.\n\n    In this case, the reference to the outer query has been resolved because\n    the inner query has been used as a subquery.\n    \"\"\"\n    contains_aggregate = False\n\n    def as_sql(self, *args, **kwargs):\n        raise ValueError(\n            'This queryset contains a reference to an outer query and may '\n            'only be used in a subquery.'\n        )\n\n    def relabeled_clone(self, relabels):\n        return self\n",
      "\nclass ResolvedOuterRef(F):\n    \"\"\"\n    An object that contains a reference to an outer query.\n\n    In this case, the reference to the outer query has been resolved because\n    the inner query has been used as a subquery.\n    \"\"\"\n    contains_aggregate = False\n\n    def as_sql(self, *args, **kwargs):\n        raise ValueError(\n            'This queryset contains a reference to an outer query and may '\n            'only be used in a subquery.'\n        )\n\n    def relabeled_clone(self, relabels):\n        return self\n",
      "\nclass ResolvedOuterRef(F):\n    \"\"\"\n    An object that contains a reference to an outer query.\n\n    In this case, the reference to the outer query has been resolved because\n    the inner query has been used as a subquery.\n    \"\"\"\n    contains_aggregate = False\n\n    def as_sql(self, *args, **kwargs):\n        raise ValueError(\n            'This queryset contains a reference to an outer query and may '\n            'only be used in a subquery.'\n        )\n\n    def relabeled_clone(self, relabels):\n        return self\n",
      "\ndef contains_outerref(expr):\n    \"\"\"Recursively check if expression contains OuterRef instances.\"\"\"\n    from django.db.models.expressions import OuterRef\n    if isinstance(expr, OuterRef):\n        return True\n    if hasattr(expr, 'get_source_expressions'):\n        for source_expr in expr.get_source_expressions():\n            if source_expr and contains_outerref(source_expr):\n                return True\n    return False\n\n\nclass ResolvedOuterRef(F):\n    \"\"\"\n    An object that contains a reference to an outer query.\n\n    In this case, the reference to the outer query has been resolved because\n    the inner query has been used as a subquery.\n    \"\"\"\n    contains_aggregate = False\n\n    def as_sql(self, *args, **kwargs):\n        raise ValueError(\n            'This queryset contains a reference to an outer query and may '\n            'only be used in a subquery.'\n        )\n\n    def relabeled_clone(self, relabels):\n        return self\n"
    ],
    "Location 4 (/root/hy/projects/django/django/db/models/query.py lines 896-902)": [
      "\ndef exclude(self, *args, **kwargs):\n    \"\"\"\n    Return a new QuerySet instance with NOT (args) ANDed to the existing\n    set.\n    \"\"\"\n    self._not_support_combined_queries('exclude')\n    return self._filter_or_exclude(True, *args, **kwargs)\n",
      "\ndef exclude(self, *args, **kwargs):\n    \"\"\"\n    Return a new QuerySet instance with NOT (args) ANDed to the existing\n    set.\n    \"\"\"\n    self._not_support_combined_queries('exclude')\n    return self._filter_or_exclude(True, *args, **kwargs)\n",
      "\n    def exclude(self, *args, **kwargs):\n        \"\"\"\n        Return a new QuerySet instance with NOT (args) ANDed to the existing\n        set.\n        \"\"\"\n        self._not_support_combined_queries('exclude')\n        return self._filter_or_exclude(True, *args, **kwargs)\n",
      "\ndef exclude(self, *args, **kwargs):\n    \"\"\"\n    Return a new QuerySet instance with NOT (args) ANDed to the existing\n    set.\n    \"\"\"\n    self._not_support_combined_queries('exclude')\n    return self._filter_or_exclude(True, *args, **kwargs)\n",
      "\n    def exclude(self, *args, **kwargs):\n        \"\"\"\n        Return a new QuerySet instance with NOT (args) ANDed to the existing\n        set.\n        \"\"\"\n        self._not_support_combined_queries('exclude')\n        return self._filter_or_exclude(True, *args, **kwargs)\n",
      "\ndef exclude(self, *args, **kwargs):\n    \"\"\"\n    Return a new QuerySet instance with NOT (args) ANDed to the existing\n    set.\n    \"\"\"\n    self._not_support_combined_queries('exclude')\n    return self._filter_or_exclude(True, *args, **kwargs)\n",
      "\ndef contains_outerref(expr):\n    \"\"\"Recursively check if expression contains OuterRef instances.\"\"\"\n    from django.db.models.expressions import OuterRef\n    if isinstance(expr, OuterRef):\n        return True\n    if hasattr(expr, 'get_source_expressions'):\n        for source_expr in expr.get_source_expressions():\n            if source_expr and contains_outerref(source_expr):\n                return True\n    return False\n\ndef exclude(self, *args, **kwargs):\n    \"\"\"\n    Return a new QuerySet instance with NOT (args) ANDed to the existing\n    set.\n    \"\"\"\n    self._not_support_combined_queries('exclude')\n    return self._filter_or_exclude(True, *args, **kwargs)\n",
      "\ndef exclude(self, *args, **kwargs):\n    \"\"\"\n    Return a new QuerySet instance with NOT (args) ANDed to the existing\n    set.\n    \"\"\"\n    self._not_support_combined_queries('exclude')\n    return self._filter_or_exclude(True, *args, **kwargs)\n"
    ],
    "Location 5 (/root/hy/projects/django/django/db/models/query.py lines 904-914)": [
      "\ndef _filter_or_exclude(self, negate, *args, **kwargs):\n    if args or kwargs:\n        assert not self.query.is_sliced, \\\n            \"Cannot filter a query once a slice has been taken.\"\n\n    clone = self._chain()\n    if negate:\n        clone.query.add_q(~Q(*args, **kwargs))\n    else:\n        clone.query.add_q(Q(*args, **kwargs))\n    return clone\n",
      "\n    def _filter_or_exclude(self, negate, *args, **kwargs):\n        if args or kwargs:\n            assert not self.query.is_sliced, \\\n                \"Cannot filter a query once a slice has been taken.\"\n\n        clone = self._chain()\n        if negate:\n            clone.query.add_q(~Q(*args, **kwargs))\n        else:\n            clone.query.add_q(Q(*args, **kwargs))\n        return clone\n",
      "\n    def _filter_or_exclude(self, negate, *args, **kwargs):\n        if args or kwargs:\n            assert not self.query.is_sliced, \\\n                \"Cannot filter a query once a slice has been taken.\"\n\n        clone = self._chain()\n        if negate:\n            clone.query.add_q(~Q(*args, **kwargs))\n        else:\n            clone.query.add_q(Q(*args, **kwargs))\n        return clone\n",
      "\n    def _filter_or_exclude(self, negate, *args, **kwargs):\n        if args or kwargs:\n            assert not self.query.is_sliced, \\\n                \"Cannot filter a query once a slice has been taken.\"\n\n        clone = self._chain()\n        if negate:\n            clone.query.add_q(~Q(*args, **kwargs))\n        else:\n            clone.query.add_q(Q(*args, **kwargs))\n        return clone\n",
      "\ndef _filter_or_exclude(self, negate, *args, **kwargs):\n    if args or kwargs:\n        assert not self.query.is_sliced, \\\n            \"Cannot filter a query once a slice has been taken.\"\n\n    clone = self._chain()\n    if negate:\n        clone.query.add_q(~Q(*args, **kwargs))\n    else:\n        clone.query.add_q(Q(*args, **kwargs))\n    return clone\n",
      "\ndef _filter_or_exclude(self, negate, *args, **kwargs):\n    if args or kwargs:\n        assert not self.query.is_sliced, \\\n            \"Cannot filter a query once a slice has been taken.\"\n\n    clone = self._chain()\n    if negate:\n        clone.query.add_q(~Q(*args, **kwargs))\n    else:\n        clone.query.add_q(Q(*args, **kwargs))\n    return clone\n",
      "\ndef contains_outerref(expr):\n    \"\"\"Recursively check if expression contains OuterRef instances.\"\"\"\n    from django.db.models.expressions import OuterRef\n    if isinstance(expr, OuterRef):\n        return True\n    if hasattr(expr, 'get_source_expressions'):\n        for source_expr in expr.get_source_expressions():\n            if source_expr and contains_outerref(source_expr):\n                return True\n    return False\n\ndef _filter_or_exclude(self, negate, *args, **kwargs):\n    if args or kwargs:\n        assert not self.query.is_sliced, \\\n            \"Cannot filter a query once a slice has been taken.\"\n\n    clone = self._chain()\n    if negate:\n        clone.query.add_q(~Q(*args, **kwargs))\n    else:\n        clone.query.add_q(Q(*args, **kwargs))\n    return clone\n",
      "\ndef _filter_or_exclude(self, negate, *args, **kwargs):\n    if args or kwargs:\n        assert not self.query.is_sliced, \\\n            \"Cannot filter a query once a slice has been taken.\"\n\n    clone = self._chain()\n    if negate:\n        clone.query.add_q(~Q(*args, **kwargs))\n    else:\n        clone.query.add_q(Q(*args, **kwargs))\n    return clone\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 2b59dd301a..5e1652935b 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -543,6 +543,7 @@ class F(Combinable):\n         return hash(self.name)\n \n \n+\n class ResolvedOuterRef(F):\n     \"\"\"\n     An object that contains a reference to an outer query.\n@@ -562,6 +563,7 @@ class ResolvedOuterRef(F):\n         return self\n \n \n+\n class OuterRef(F):\n     def resolve_expression(self, query=None, allow_joins=True, reuse=None,\n                            summarize=False, for_save=False, simple_col=False):\ndiff --git a/django/db/models/query.py b/django/db/models/query.py\nindex ab4f3fc534..81c5494fd3 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -893,6 +893,7 @@ class QuerySet:\n         self._not_support_combined_queries('filter')\n         return self._filter_or_exclude(False, *args, **kwargs)\n \n+\n     def exclude(self, *args, **kwargs):\n         \"\"\"\n         Return a new QuerySet instance with NOT (args) ANDed to the existing\n@@ -901,6 +902,7 @@ class QuerySet:\n         self._not_support_combined_queries('exclude')\n         return self._filter_or_exclude(True, *args, **kwargs)\n \n+\n     def _filter_or_exclude(self, negate, *args, **kwargs):\n         if args or kwargs:\n             assert not self.query.is_sliced, \\\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 35f3c5e1ea..66cae6297f 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1229,13 +1229,29 @@ class Query(BaseExpression):\n         \"\"\"\n         if isinstance(filter_expr, dict):\n             raise FieldError(\"Cannot parse keyword query as dict\")\n+\n+        def contains_outerref(expr):\n+            \"\"\"Recursively check if expression contains OuterRef instances.\"\"\"\n+            from django.db.models.expressions import OuterRef\n+            if isinstance(expr, OuterRef):\n+                return True\n+            if hasattr(expr, 'get_source_expressions'):\n+                for source_expr in expr.get_source_expressions():\n+                    if source_expr and contains_outerref(source_expr):\n+                        return True\n+            return False\n+\n         if hasattr(filter_expr, 'resolve_expression') and getattr(filter_expr, 'conditional', False):\n-            if connections[DEFAULT_DB_ALIAS].ops.conditional_expression_supported_in_where_clause(filter_expr):\n-                condition = filter_expr.resolve_expression(self)\n-            else:\n-                # Expression is not supported in the WHERE clause, add\n-                # comparison with True.\n-                condition = self.build_lookup(['exact'], filter_expr.resolve_expression(self), True)\n+            if not contains_outerref(filter_expr):\n+                if connections[DEFAULT_DB_ALIAS].ops.conditional_expression_supported_in_where_clause(filter_expr):\n+                    condition = filter_expr.resolve_expression(self)\n+                else:\n+                    # Expression is not supported in the WHERE clause, add\n+                    # comparison with True.\n+                    condition = self.build_lookup(['exact'], filter_expr.resolve_expression(self), True)\n+                clause = self.where_class()\n+                clause.add(condition, AND)\n+                return clause, []\n             clause = self.where_class()\n             clause.add(condition, AND)\n             return clause, []\n",
    "variant_0": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 2b59dd301a..9495ed82f0 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -543,6 +543,7 @@ class F(Combinable):\n         return hash(self.name)\n \n \n+\n class ResolvedOuterRef(F):\n     \"\"\"\n     An object that contains a reference to an outer query.\n@@ -562,12 +563,94 @@ class ResolvedOuterRef(F):\n         return self\n \n \n-class OuterRef(F):\n-    def resolve_expression(self, query=None, allow_joins=True, reuse=None,\n-                           summarize=False, for_save=False, simple_col=False):\n-        if isinstance(self.name, self.__class__):\n-            return self.name\n-        return ResolvedOuterRef(self.name)\n+\n+def contains_outerref(expr):\n+    \"\"\"Recursively check if expression contains OuterRef instances.\"\"\"\n+    from django.db.models.expressions import OuterRef\n+    if isinstance(expr, OuterRef):\n+        return True\n+    if hasattr(expr, 'get_source_expressions'):\n+        for source_expr in expr.get_source_expressions():\n+            if source_expr and contains_outerref(source_expr):\n+                return True\n+    return False\n+\n+def build_filter(self, filter_expr, branch_negated=False, current_negated=False,\n+                 can_reuse=None, allow_joins=True, split_subq=True,\n+                 check_filterable=True):\n+    \"\"\"\n+    Build a WHERE clause for a single filter clause. A filter clause can\n+    be specified in one of the formats:\n+\n+    - \"field_name__lookuptype=value\" -> (\"field_name\", \"lookuptype\", value)\n+    - (\"field_name__lookuptype\", value) -> (\"field_name\", \"lookuptype\", value)\n+    - \"field_name\" -> (\"field_name\", \"exact\", True)\n+    - Q()-object\n+\n+    The 'branch_negated' tells us if the current branch contains any\n+    negations. This will be used to determine if subqueries are needed.\n+\n+    The 'current_negated' is used to determine if the current filter is\n+    negated or not and this is used to determine if IS NULL filtering\n+    is needed.\n+\n+    The difference between current_negated and branch_negated is that\n+    branch_negated is set on first negation, but current_negated is\n+    flipped for each negation.\n+\n+    Note that add_filter will not do any negating itself, that is done\n+    upper in the code by add_q().\n+\n+    The 'can_reuse' is a set of reusable joins for multijoins.\n+\n+    The method will create a filter clause that can be added to the current\n+    query. However, if the filter isn't added to the query then the caller\n+    is responsible for unreferencing all the joins used.\n+    \"\"\"\n+    if isinstance(filter_expr, dict):\n+        raise FieldError(\"Cannot parse keyword query as dict\")\n+    if isinstance(filter_expr, Q):\n+        return self._add_q(\n+            filter_expr,\n+            branch_negated=branch_negated,\n+            current_negated=current_negated,\n+            used_aliases=can_reuse,\n+            allow_joins=allow_joins,\n+            split_subq=split_subq,\n+            check_filterable=check_filterable,\n+        )\n+    if hasattr(filter_expr, 'resolve_expression'):\n+        if getattr(filter_expr, 'conditional', False) and not contains_outerref(filter_expr):\n+            if connections[DEFAULT_DB_ALIAS].ops.conditional_expression_supported_in_where_clause(filter_expr):\n+                condition = filter_expr.resolve_expression(self)\n+            else:\n+                condition = self.build_lookup(['exact'], filter_expr.resolve_expression(self), True)\n+            clause = self.where_class()\n+            clause.add(condition, AND)\n+            return clause, []\n+        else:\n+            filter_expr = self.resolve_expression(filter_expr, allow_joins=allow_joins)\n+    try:\n+        arg, value = filter_expr\n+    except (TypeError, ValueError):\n+        raise FieldError(\"Cannot parse remainder of '%s' as a keyword query\" % filter_expr)\n+\n+    lookups, parts, reffed_expression = self.solve_lookup_type(arg)\n+\n+    if check_filterable:\n+        self.check_filterable(reffed_expression)\n+\n+    if not allow_joins and len(parts) > 1:\n+        raise FieldError(\"Joined field references are not permitted in this query\")\n+\n+    pre_joins = self.alias_refcount.copy()\n+    value = self.resolve_lookup_value(value, can_reuse, allow_joins)\n+    used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}\n+\n+    if check_filterable:\n+        self.check_filterable(reffed_expression)\n+    clause = self.build_lookup(lookups, reffed_expression, value)\n+    return clause, used_joins\n \n \n class Func(SQLiteNumericMixin, Expression):\ndiff --git a/django/db/models/query.py b/django/db/models/query.py\nindex ab4f3fc534..14ff940b38 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -893,25 +893,27 @@ class QuerySet:\n         self._not_support_combined_queries('filter')\n         return self._filter_or_exclude(False, *args, **kwargs)\n \n-    def exclude(self, *args, **kwargs):\n-        \"\"\"\n-        Return a new QuerySet instance with NOT (args) ANDed to the existing\n-        set.\n-        \"\"\"\n-        self._not_support_combined_queries('exclude')\n-        return self._filter_or_exclude(True, *args, **kwargs)\n \n-    def _filter_or_exclude(self, negate, *args, **kwargs):\n-        if args or kwargs:\n-            assert not self.query.is_sliced, \\\n-                \"Cannot filter a query once a slice has been taken.\"\n+def exclude(self, *args, **kwargs):\n+    \"\"\"\n+    Return a new QuerySet instance with NOT (args) ANDed to the existing\n+    set.\n+    \"\"\"\n+    self._not_support_combined_queries('exclude')\n+    return self._filter_or_exclude(True, *args, **kwargs)\n \n-        clone = self._chain()\n-        if negate:\n-            clone.query.add_q(~Q(*args, **kwargs))\n-        else:\n-            clone.query.add_q(Q(*args, **kwargs))\n-        return clone\n+\n+def _filter_or_exclude(self, negate, *args, **kwargs):\n+    if args or kwargs:\n+        assert not self.query.is_sliced, \\\n+            \"Cannot filter a query once a slice has been taken.\"\n+\n+    clone = self._chain()\n+    if negate:\n+        clone.query.add_q(~Q(*args, **kwargs))\n+    else:\n+        clone.query.add_q(Q(*args, **kwargs))\n+    return clone\n \n     def complex_filter(self, filter_obj):\n         \"\"\"\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 35f3c5e1ea..e6298be7fa 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1229,13 +1229,32 @@ class Query(BaseExpression):\n         \"\"\"\n         if isinstance(filter_expr, dict):\n             raise FieldError(\"Cannot parse keyword query as dict\")\n+\n+def contains_outerref(expr):\n+    \"\"\"Recursively check if expression contains OuterRef instances.\"\"\"\n+    from django.db.models.expressions import OuterRef\n+    if isinstance(expr, OuterRef):\n+        return True\n+    if hasattr(expr, 'get_source_expressions'):\n+        for source_expr in expr.get_source_expressions():\n+            if source_expr and contains_outerref(source_expr):\n+                return True\n+    return False\n+\n+        if isinstance(filter_expr, dict):\n+            raise FieldError(\"Cannot parse keyword query as dict\")\n         if hasattr(filter_expr, 'resolve_expression') and getattr(filter_expr, 'conditional', False):\n-            if connections[DEFAULT_DB_ALIAS].ops.conditional_expression_supported_in_where_clause(filter_expr):\n-                condition = filter_expr.resolve_expression(self)\n-            else:\n-                # Expression is not supported in the WHERE clause, add\n-                # comparison with True.\n-                condition = self.build_lookup(['exact'], filter_expr.resolve_expression(self), True)\n+            if not contains_outerref(filter_expr):\n+                if connections[DEFAULT_DB_ALIAS].ops.conditional_expression_supported_in_where_clause(filter_expr):\n+                    condition = filter_expr.resolve_expression(self)\n+                else:\n+                    # Expression is not supported in the WHERE clause, add\n+                    # comparison with True.\n+                    condition = self.build_lookup(['exact'], filter_expr.resolve_expression(self), True)\n+                clause = self.where_class()\n+                clause.add(condition, AND)\n+                return clause, []\n+            # Fall through to normal processing for expressions containing OuterRef\n             clause = self.where_class()\n             clause.add(condition, AND)\n             return clause, []\n",
    "variant_1": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 2b59dd301a..8dc86cc3b0 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -543,6 +543,7 @@ class F(Combinable):\n         return hash(self.name)\n \n \n+\n class ResolvedOuterRef(F):\n     \"\"\"\n     An object that contains a reference to an outer query.\n@@ -562,12 +563,63 @@ class ResolvedOuterRef(F):\n         return self\n \n \n-class OuterRef(F):\n-    def resolve_expression(self, query=None, allow_joins=True, reuse=None,\n-                           summarize=False, for_save=False, simple_col=False):\n-        if isinstance(self.name, self.__class__):\n-            return self.name\n-        return ResolvedOuterRef(self.name)\n+\n+def contains_outerref(expr):\n+    \"\"\"Recursively check if expression contains OuterRef instances.\"\"\"\n+    from django.db.models.expressions import OuterRef\n+    if isinstance(expr, OuterRef):\n+        return True\n+    if hasattr(expr, 'get_source_expressions'):\n+        for source_expr in expr.get_source_expressions():\n+            if source_expr and contains_outerref(source_expr):\n+                return True\n+    return False\n+\n+def build_filter(self, filter_expr, branch_negated=False, current_negated=False,\n+                 can_reuse=None, allow_joins=True, split_subq=True,\n+                 check_filterable=True, summarize=False):\n+    \"\"\"\n+    Build a WHERE clause for the given filter_expr. filter_expr can be\n+    anything that add_q() knows how to deal with (Q-objects, lookups, or\n+    expressions), possibly negated; then check_filterable has an effect on\n+    only non-Q expressions.\n+    \"\"\"\n+    if hasattr(filter_expr, 'resolve_expression') and getattr(filter_expr, 'conditional', False):\n+        if not contains_outerref(filter_expr):\n+            if connections[DEFAULT_DB_ALIAS].ops.conditional_expression_supported_in_where_clause(filter_expr):\n+                condition = filter_expr.resolve_expression(self)\n+            else:\n+                condition = self.build_lookup(['exact'], filter_expr.resolve_expression(self), True)\n+            clause = self.where_class()\n+            clause.add(condition, AND)\n+            return clause, []\n+        # Fall through to normal processing for expressions containing OuterRef\n+    \n+    if isinstance(filter_expr, dict):\n+        raise FieldError(\"Cannot parse keyword query as dict\")\n+    if isinstance(filter_expr, Q):\n+        return self._add_q(\n+            filter_expr,\n+            branch_negated=branch_negated,\n+            current_negated=current_negated,\n+            used_aliases=can_reuse,\n+            allow_joins=allow_joins,\n+            split_subq=split_subq,\n+            check_filterable=check_filterable,\n+            summarize=summarize,\n+        )\n+    if hasattr(filter_expr, 'resolve_expression'):\n+        if not getattr(filter_expr, 'conditional', False):\n+            filter_expr = filter_expr.resolve_expression(\n+                self, allow_joins=allow_joins, summarize=summarize\n+            )\n+    if isinstance(filter_expr, Lookup):\n+        filter_expr.check_filterable()\n+    return self.build_lookup(\n+        filter_expr.children[:-1], filter_expr.children[-1],\n+        can_reuse, branch_negated, current_negated, allow_joins,\n+        split_subq, check_filterable, summarize,\n+    )\n \n \n class Func(SQLiteNumericMixin, Expression):\ndiff --git a/django/db/models/query.py b/django/db/models/query.py\nindex ab4f3fc534..14ff940b38 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -893,25 +893,27 @@ class QuerySet:\n         self._not_support_combined_queries('filter')\n         return self._filter_or_exclude(False, *args, **kwargs)\n \n-    def exclude(self, *args, **kwargs):\n-        \"\"\"\n-        Return a new QuerySet instance with NOT (args) ANDed to the existing\n-        set.\n-        \"\"\"\n-        self._not_support_combined_queries('exclude')\n-        return self._filter_or_exclude(True, *args, **kwargs)\n \n-    def _filter_or_exclude(self, negate, *args, **kwargs):\n-        if args or kwargs:\n-            assert not self.query.is_sliced, \\\n-                \"Cannot filter a query once a slice has been taken.\"\n+def exclude(self, *args, **kwargs):\n+    \"\"\"\n+    Return a new QuerySet instance with NOT (args) ANDed to the existing\n+    set.\n+    \"\"\"\n+    self._not_support_combined_queries('exclude')\n+    return self._filter_or_exclude(True, *args, **kwargs)\n \n-        clone = self._chain()\n-        if negate:\n-            clone.query.add_q(~Q(*args, **kwargs))\n-        else:\n-            clone.query.add_q(Q(*args, **kwargs))\n-        return clone\n+\n+def _filter_or_exclude(self, negate, *args, **kwargs):\n+    if args or kwargs:\n+        assert not self.query.is_sliced, \\\n+            \"Cannot filter a query once a slice has been taken.\"\n+\n+    clone = self._chain()\n+    if negate:\n+        clone.query.add_q(~Q(*args, **kwargs))\n+    else:\n+        clone.query.add_q(Q(*args, **kwargs))\n+    return clone\n \n     def complex_filter(self, filter_obj):\n         \"\"\"\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 35f3c5e1ea..d97d8e7d32 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1229,7 +1229,22 @@ class Query(BaseExpression):\n         \"\"\"\n         if isinstance(filter_expr, dict):\n             raise FieldError(\"Cannot parse keyword query as dict\")\n-        if hasattr(filter_expr, 'resolve_expression') and getattr(filter_expr, 'conditional', False):\n+\n+    def contains_outerref(expr):\n+        \"\"\"Recursively check if expression contains OuterRef instances.\"\"\"\n+        from django.db.models.expressions import OuterRef\n+        if isinstance(expr, OuterRef):\n+            return True\n+        if hasattr(expr, 'get_source_expressions'):\n+            for source_expr in expr.get_source_expressions():\n+                if source_expr and contains_outerref(source_expr):\n+                    return True\n+        return False\n+\n+    if isinstance(filter_expr, dict):\n+        raise FieldError(\"Cannot parse keyword query as dict\")\n+    if hasattr(filter_expr, 'resolve_expression') and getattr(filter_expr, 'conditional', False):\n+        if not contains_outerref(filter_expr):\n             if connections[DEFAULT_DB_ALIAS].ops.conditional_expression_supported_in_where_clause(filter_expr):\n                 condition = filter_expr.resolve_expression(self)\n             else:\n@@ -1239,6 +1254,10 @@ class Query(BaseExpression):\n             clause = self.where_class()\n             clause.add(condition, AND)\n             return clause, []\n+        # Fall through to normal processing for expressions containing OuterRef\n+            clause = self.where_class()\n+            clause.add(condition, AND)\n+            return clause, []\n         arg, value = filter_expr\n         if not arg:\n             raise FieldError(\"Cannot parse keyword query %r\" % arg)\n",
    "variant_2": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 2b59dd301a..5e1652935b 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -543,6 +543,7 @@ class F(Combinable):\n         return hash(self.name)\n \n \n+\n class ResolvedOuterRef(F):\n     \"\"\"\n     An object that contains a reference to an outer query.\n@@ -562,6 +563,7 @@ class ResolvedOuterRef(F):\n         return self\n \n \n+\n class OuterRef(F):\n     def resolve_expression(self, query=None, allow_joins=True, reuse=None,\n                            summarize=False, for_save=False, simple_col=False):\ndiff --git a/django/db/models/query.py b/django/db/models/query.py\nindex ab4f3fc534..fa7801fe68 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -893,13 +893,15 @@ class QuerySet:\n         self._not_support_combined_queries('filter')\n         return self._filter_or_exclude(False, *args, **kwargs)\n \n-    def exclude(self, *args, **kwargs):\n-        \"\"\"\n-        Return a new QuerySet instance with NOT (args) ANDed to the existing\n-        set.\n-        \"\"\"\n-        self._not_support_combined_queries('exclude')\n-        return self._filter_or_exclude(True, *args, **kwargs)\n+\n+def exclude(self, *args, **kwargs):\n+    \"\"\"\n+    Return a new QuerySet instance with NOT (args) ANDed to the existing\n+    set.\n+    \"\"\"\n+    self._not_support_combined_queries('exclude')\n+    return self._filter_or_exclude(True, *args, **kwargs)\n+\n \n     def _filter_or_exclude(self, negate, *args, **kwargs):\n         if args or kwargs:\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 35f3c5e1ea..e6298be7fa 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1229,13 +1229,32 @@ class Query(BaseExpression):\n         \"\"\"\n         if isinstance(filter_expr, dict):\n             raise FieldError(\"Cannot parse keyword query as dict\")\n+\n+def contains_outerref(expr):\n+    \"\"\"Recursively check if expression contains OuterRef instances.\"\"\"\n+    from django.db.models.expressions import OuterRef\n+    if isinstance(expr, OuterRef):\n+        return True\n+    if hasattr(expr, 'get_source_expressions'):\n+        for source_expr in expr.get_source_expressions():\n+            if source_expr and contains_outerref(source_expr):\n+                return True\n+    return False\n+\n+        if isinstance(filter_expr, dict):\n+            raise FieldError(\"Cannot parse keyword query as dict\")\n         if hasattr(filter_expr, 'resolve_expression') and getattr(filter_expr, 'conditional', False):\n-            if connections[DEFAULT_DB_ALIAS].ops.conditional_expression_supported_in_where_clause(filter_expr):\n-                condition = filter_expr.resolve_expression(self)\n-            else:\n-                # Expression is not supported in the WHERE clause, add\n-                # comparison with True.\n-                condition = self.build_lookup(['exact'], filter_expr.resolve_expression(self), True)\n+            if not contains_outerref(filter_expr):\n+                if connections[DEFAULT_DB_ALIAS].ops.conditional_expression_supported_in_where_clause(filter_expr):\n+                    condition = filter_expr.resolve_expression(self)\n+                else:\n+                    # Expression is not supported in the WHERE clause, add\n+                    # comparison with True.\n+                    condition = self.build_lookup(['exact'], filter_expr.resolve_expression(self), True)\n+                clause = self.where_class()\n+                clause.add(condition, AND)\n+                return clause, []\n+            # Fall through to normal processing for expressions containing OuterRef\n             clause = self.where_class()\n             clause.add(condition, AND)\n             return clause, []\n",
    "variant_3": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 2b59dd301a..5e1652935b 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -543,6 +543,7 @@ class F(Combinable):\n         return hash(self.name)\n \n \n+\n class ResolvedOuterRef(F):\n     \"\"\"\n     An object that contains a reference to an outer query.\n@@ -562,6 +563,7 @@ class ResolvedOuterRef(F):\n         return self\n \n \n+\n class OuterRef(F):\n     def resolve_expression(self, query=None, allow_joins=True, reuse=None,\n                            summarize=False, for_save=False, simple_col=False):\ndiff --git a/django/db/models/query.py b/django/db/models/query.py\nindex ab4f3fc534..81c5494fd3 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -893,6 +893,7 @@ class QuerySet:\n         self._not_support_combined_queries('filter')\n         return self._filter_or_exclude(False, *args, **kwargs)\n \n+\n     def exclude(self, *args, **kwargs):\n         \"\"\"\n         Return a new QuerySet instance with NOT (args) ANDed to the existing\n@@ -901,6 +902,7 @@ class QuerySet:\n         self._not_support_combined_queries('exclude')\n         return self._filter_or_exclude(True, *args, **kwargs)\n \n+\n     def _filter_or_exclude(self, negate, *args, **kwargs):\n         if args or kwargs:\n             assert not self.query.is_sliced, \\\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 35f3c5e1ea..e6298be7fa 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1229,13 +1229,32 @@ class Query(BaseExpression):\n         \"\"\"\n         if isinstance(filter_expr, dict):\n             raise FieldError(\"Cannot parse keyword query as dict\")\n+\n+def contains_outerref(expr):\n+    \"\"\"Recursively check if expression contains OuterRef instances.\"\"\"\n+    from django.db.models.expressions import OuterRef\n+    if isinstance(expr, OuterRef):\n+        return True\n+    if hasattr(expr, 'get_source_expressions'):\n+        for source_expr in expr.get_source_expressions():\n+            if source_expr and contains_outerref(source_expr):\n+                return True\n+    return False\n+\n+        if isinstance(filter_expr, dict):\n+            raise FieldError(\"Cannot parse keyword query as dict\")\n         if hasattr(filter_expr, 'resolve_expression') and getattr(filter_expr, 'conditional', False):\n-            if connections[DEFAULT_DB_ALIAS].ops.conditional_expression_supported_in_where_clause(filter_expr):\n-                condition = filter_expr.resolve_expression(self)\n-            else:\n-                # Expression is not supported in the WHERE clause, add\n-                # comparison with True.\n-                condition = self.build_lookup(['exact'], filter_expr.resolve_expression(self), True)\n+            if not contains_outerref(filter_expr):\n+                if connections[DEFAULT_DB_ALIAS].ops.conditional_expression_supported_in_where_clause(filter_expr):\n+                    condition = filter_expr.resolve_expression(self)\n+                else:\n+                    # Expression is not supported in the WHERE clause, add\n+                    # comparison with True.\n+                    condition = self.build_lookup(['exact'], filter_expr.resolve_expression(self), True)\n+                clause = self.where_class()\n+                clause.add(condition, AND)\n+                return clause, []\n+            # Fall through to normal processing for expressions containing OuterRef\n             clause = self.where_class()\n             clause.add(condition, AND)\n             return clause, []\n",
    "variant_4": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 2b59dd301a..c259d1536d 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -543,6 +543,7 @@ class F(Combinable):\n         return hash(self.name)\n \n \n+\n class ResolvedOuterRef(F):\n     \"\"\"\n     An object that contains a reference to an outer query.\n@@ -562,12 +563,57 @@ class ResolvedOuterRef(F):\n         return self\n \n \n-class OuterRef(F):\n-    def resolve_expression(self, query=None, allow_joins=True, reuse=None,\n-                           summarize=False, for_save=False, simple_col=False):\n-        if isinstance(self.name, self.__class__):\n-            return self.name\n-        return ResolvedOuterRef(self.name)\n+\n+def contains_outerref(expr):\n+    \"\"\"Recursively check if expression contains OuterRef instances.\"\"\"\n+    from django.db.models.expressions import OuterRef\n+    if isinstance(expr, OuterRef):\n+        return True\n+    if hasattr(expr, 'get_source_expressions'):\n+        for source_expr in expr.get_source_expressions():\n+            if source_expr and contains_outerref(source_expr):\n+                return True\n+    return False\n+\n+def build_filter(self, filter_expr, branch_negated=False, current_negated=False,\n+                 can_reuse=None, allow_joins=True, split_subq=True,\n+                 check_filterable=True):\n+    \"\"\"\n+    Build a WHERE clause for the given filter_expr. branch_negated tells us if\n+    the current branch contains any negations. This will be used to determine\n+    if subqueries are needed.\n+    \"\"\"\n+    if hasattr(filter_expr, 'resolve_expression') and getattr(filter_expr, 'conditional', False):\n+        if not contains_outerref(filter_expr):\n+            if connections[DEFAULT_DB_ALIAS].ops.conditional_expression_supported_in_where_clause(filter_expr):\n+                condition = filter_expr.resolve_expression(self)\n+            else:\n+                condition = self.build_lookup(['exact'], filter_expr.resolve_expression(self), True)\n+            clause = self.where_class()\n+            clause.add(condition, AND)\n+            return clause, []\n+        # Fall through to normal processing for expressions containing OuterRef\n+\n+    if isinstance(filter_expr, dict):\n+        raise FieldError(\"Cannot parse keyword query as dict\")\n+    if isinstance(filter_expr, Q):\n+        return self._add_q(\n+            filter_expr,\n+            branch_negated=branch_negated,\n+            current_negated=current_negated,\n+            used_aliases=can_reuse,\n+            allow_joins=allow_joins,\n+            split_subq=split_subq,\n+            check_filterable=check_filterable,\n+        )\n+    if hasattr(filter_expr, 'resolve_expression'):\n+        if not hasattr(filter_expr, 'conditional'):\n+            filter_expr = filter_expr.resolve_expression(self, allow_joins=allow_joins)\n+    if isinstance(filter_expr, Lookup):\n+        filter_expr.check_filterable()\n+    return self.build_lookup(\n+        filter_expr.lookup_name, filter_expr.lhs, filter_expr.rhs\n+    ) if hasattr(filter_expr, 'lookup_name') else self.build_where(filter_expr)\n \n \n class Func(SQLiteNumericMixin, Expression):\ndiff --git a/django/db/models/query.py b/django/db/models/query.py\nindex ab4f3fc534..fa7801fe68 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -893,13 +893,15 @@ class QuerySet:\n         self._not_support_combined_queries('filter')\n         return self._filter_or_exclude(False, *args, **kwargs)\n \n-    def exclude(self, *args, **kwargs):\n-        \"\"\"\n-        Return a new QuerySet instance with NOT (args) ANDed to the existing\n-        set.\n-        \"\"\"\n-        self._not_support_combined_queries('exclude')\n-        return self._filter_or_exclude(True, *args, **kwargs)\n+\n+def exclude(self, *args, **kwargs):\n+    \"\"\"\n+    Return a new QuerySet instance with NOT (args) ANDed to the existing\n+    set.\n+    \"\"\"\n+    self._not_support_combined_queries('exclude')\n+    return self._filter_or_exclude(True, *args, **kwargs)\n+\n \n     def _filter_or_exclude(self, negate, *args, **kwargs):\n         if args or kwargs:\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 35f3c5e1ea..e6298be7fa 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1229,13 +1229,32 @@ class Query(BaseExpression):\n         \"\"\"\n         if isinstance(filter_expr, dict):\n             raise FieldError(\"Cannot parse keyword query as dict\")\n+\n+def contains_outerref(expr):\n+    \"\"\"Recursively check if expression contains OuterRef instances.\"\"\"\n+    from django.db.models.expressions import OuterRef\n+    if isinstance(expr, OuterRef):\n+        return True\n+    if hasattr(expr, 'get_source_expressions'):\n+        for source_expr in expr.get_source_expressions():\n+            if source_expr and contains_outerref(source_expr):\n+                return True\n+    return False\n+\n+        if isinstance(filter_expr, dict):\n+            raise FieldError(\"Cannot parse keyword query as dict\")\n         if hasattr(filter_expr, 'resolve_expression') and getattr(filter_expr, 'conditional', False):\n-            if connections[DEFAULT_DB_ALIAS].ops.conditional_expression_supported_in_where_clause(filter_expr):\n-                condition = filter_expr.resolve_expression(self)\n-            else:\n-                # Expression is not supported in the WHERE clause, add\n-                # comparison with True.\n-                condition = self.build_lookup(['exact'], filter_expr.resolve_expression(self), True)\n+            if not contains_outerref(filter_expr):\n+                if connections[DEFAULT_DB_ALIAS].ops.conditional_expression_supported_in_where_clause(filter_expr):\n+                    condition = filter_expr.resolve_expression(self)\n+                else:\n+                    # Expression is not supported in the WHERE clause, add\n+                    # comparison with True.\n+                    condition = self.build_lookup(['exact'], filter_expr.resolve_expression(self), True)\n+                clause = self.where_class()\n+                clause.add(condition, AND)\n+                return clause, []\n+            # Fall through to normal processing for expressions containing OuterRef\n             clause = self.where_class()\n             clause.add(condition, AND)\n             return clause, []\n",
    "variant_5": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 2b59dd301a..f5c6f157a0 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -543,6 +543,7 @@ class F(Combinable):\n         return hash(self.name)\n \n \n+\n class ResolvedOuterRef(F):\n     \"\"\"\n     An object that contains a reference to an outer query.\n@@ -562,6 +563,18 @@ class ResolvedOuterRef(F):\n         return self\n \n \n+\n+def contains_outerref(expr):\n+    \"\"\"Recursively check if expression contains OuterRef instances.\"\"\"\n+    from django.db.models.expressions import OuterRef\n+    if isinstance(expr, OuterRef):\n+        return True\n+    if hasattr(expr, 'get_source_expressions'):\n+        for source_expr in expr.get_source_expressions():\n+            if source_expr and contains_outerref(source_expr):\n+                return True\n+    return False\n+\n class OuterRef(F):\n     def resolve_expression(self, query=None, allow_joins=True, reuse=None,\n                            summarize=False, for_save=False, simple_col=False):\ndiff --git a/django/db/models/query.py b/django/db/models/query.py\nindex ab4f3fc534..1bb2e46972 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -893,6 +893,7 @@ class QuerySet:\n         self._not_support_combined_queries('filter')\n         return self._filter_or_exclude(False, *args, **kwargs)\n \n+\n     def exclude(self, *args, **kwargs):\n         \"\"\"\n         Return a new QuerySet instance with NOT (args) ANDed to the existing\n@@ -901,17 +902,18 @@ class QuerySet:\n         self._not_support_combined_queries('exclude')\n         return self._filter_or_exclude(True, *args, **kwargs)\n \n-    def _filter_or_exclude(self, negate, *args, **kwargs):\n-        if args or kwargs:\n-            assert not self.query.is_sliced, \\\n-                \"Cannot filter a query once a slice has been taken.\"\n \n-        clone = self._chain()\n-        if negate:\n-            clone.query.add_q(~Q(*args, **kwargs))\n-        else:\n-            clone.query.add_q(Q(*args, **kwargs))\n-        return clone\n+def _filter_or_exclude(self, negate, *args, **kwargs):\n+    if args or kwargs:\n+        assert not self.query.is_sliced, \\\n+            \"Cannot filter a query once a slice has been taken.\"\n+\n+    clone = self._chain()\n+    if negate:\n+        clone.query.add_q(~Q(*args, **kwargs))\n+    else:\n+        clone.query.add_q(Q(*args, **kwargs))\n+    return clone\n \n     def complex_filter(self, filter_obj):\n         \"\"\"\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 35f3c5e1ea..e186d6f513 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1229,7 +1229,42 @@ class Query(BaseExpression):\n         \"\"\"\n         if isinstance(filter_expr, dict):\n             raise FieldError(\"Cannot parse keyword query as dict\")\n-        if hasattr(filter_expr, 'resolve_expression') and getattr(filter_expr, 'conditional', False):\n+\n+def build_filter(self, filter_expr, branch_negated=False, current_negated=False,\n+                 can_reuse=None, allow_joins=True,\n+                 split_subquery=True, reuse_with_filtered_relation=False,\n+                 check_filterable=True):\n+    \"\"\"\n+    Build a WHERE clause for a single filter clause, such as 'foo=1' or\n+    'foo__bar__name__contains=\"test\"'. filter_expr can be a Q() object,\n+    a python object, or a tuple of (lookup_type, value_list). branch_negated\n+    tells us if the current branch contains any negations. This will be used\n+    to determine if subqueries are needed.\n+\n+    current_negated is used to determine if the current filter is negated or not\n+    and this is used to determine if IS NULL or IS NOT NULL should be used.\n+\n+    can_reuse is a set of reusable joins for multijoins.\n+\n+    The method will create a filter clause that can be added to the current\n+    query. However, if the filter isn't added to the query then the caller\n+    is responsible for unreffing the joins used.\n+    \"\"\"\n+    def contains_outerref(expr):\n+        \"\"\"Recursively check if expression contains OuterRef instances.\"\"\"\n+        from django.db.models.expressions import OuterRef\n+        if isinstance(expr, OuterRef):\n+            return True\n+        if hasattr(expr, 'get_source_expressions'):\n+            for source_expr in expr.get_source_expressions():\n+                if source_expr and contains_outerref(source_expr):\n+                    return True\n+        return False\n+\n+    if isinstance(filter_expr, dict):\n+        raise FieldError(\"Cannot parse keyword query as dict\")\n+    if hasattr(filter_expr, 'resolve_expression') and getattr(filter_expr, 'conditional', False):\n+        if not contains_outerref(filter_expr):\n             if connections[DEFAULT_DB_ALIAS].ops.conditional_expression_supported_in_where_clause(filter_expr):\n                 condition = filter_expr.resolve_expression(self)\n             else:\n@@ -1239,6 +1274,16 @@ class Query(BaseExpression):\n             clause = self.where_class()\n             clause.add(condition, AND)\n             return clause, []\n+        # Fall through to normal processing for expressions containing OuterRef\n+    arg, value = filter_expr\n+    if not arg:\n+        raise FieldError(\"Cannot parse keyword query %r\" % arg)\n+    lookups, parts, reffed_expression = self.solve_lookup_type(arg)\n+\n+    self.check_filterable(reffed_expression)\n+            clause = self.where_class()\n+            clause.add(condition, AND)\n+            return clause, []\n         arg, value = filter_expr\n         if not arg:\n             raise FieldError(\"Cannot parse keyword query %r\" % arg)\n",
    "variant_6": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 2b59dd301a..5e1652935b 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -543,6 +543,7 @@ class F(Combinable):\n         return hash(self.name)\n \n \n+\n class ResolvedOuterRef(F):\n     \"\"\"\n     An object that contains a reference to an outer query.\n@@ -562,6 +563,7 @@ class ResolvedOuterRef(F):\n         return self\n \n \n+\n class OuterRef(F):\n     def resolve_expression(self, query=None, allow_joins=True, reuse=None,\n                            summarize=False, for_save=False, simple_col=False):\ndiff --git a/django/db/models/query.py b/django/db/models/query.py\nindex ab4f3fc534..14ff940b38 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -893,25 +893,27 @@ class QuerySet:\n         self._not_support_combined_queries('filter')\n         return self._filter_or_exclude(False, *args, **kwargs)\n \n-    def exclude(self, *args, **kwargs):\n-        \"\"\"\n-        Return a new QuerySet instance with NOT (args) ANDed to the existing\n-        set.\n-        \"\"\"\n-        self._not_support_combined_queries('exclude')\n-        return self._filter_or_exclude(True, *args, **kwargs)\n \n-    def _filter_or_exclude(self, negate, *args, **kwargs):\n-        if args or kwargs:\n-            assert not self.query.is_sliced, \\\n-                \"Cannot filter a query once a slice has been taken.\"\n+def exclude(self, *args, **kwargs):\n+    \"\"\"\n+    Return a new QuerySet instance with NOT (args) ANDed to the existing\n+    set.\n+    \"\"\"\n+    self._not_support_combined_queries('exclude')\n+    return self._filter_or_exclude(True, *args, **kwargs)\n \n-        clone = self._chain()\n-        if negate:\n-            clone.query.add_q(~Q(*args, **kwargs))\n-        else:\n-            clone.query.add_q(Q(*args, **kwargs))\n-        return clone\n+\n+def _filter_or_exclude(self, negate, *args, **kwargs):\n+    if args or kwargs:\n+        assert not self.query.is_sliced, \\\n+            \"Cannot filter a query once a slice has been taken.\"\n+\n+    clone = self._chain()\n+    if negate:\n+        clone.query.add_q(~Q(*args, **kwargs))\n+    else:\n+        clone.query.add_q(Q(*args, **kwargs))\n+    return clone\n \n     def complex_filter(self, filter_obj):\n         \"\"\"\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 35f3c5e1ea..e6298be7fa 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1229,13 +1229,32 @@ class Query(BaseExpression):\n         \"\"\"\n         if isinstance(filter_expr, dict):\n             raise FieldError(\"Cannot parse keyword query as dict\")\n+\n+def contains_outerref(expr):\n+    \"\"\"Recursively check if expression contains OuterRef instances.\"\"\"\n+    from django.db.models.expressions import OuterRef\n+    if isinstance(expr, OuterRef):\n+        return True\n+    if hasattr(expr, 'get_source_expressions'):\n+        for source_expr in expr.get_source_expressions():\n+            if source_expr and contains_outerref(source_expr):\n+                return True\n+    return False\n+\n+        if isinstance(filter_expr, dict):\n+            raise FieldError(\"Cannot parse keyword query as dict\")\n         if hasattr(filter_expr, 'resolve_expression') and getattr(filter_expr, 'conditional', False):\n-            if connections[DEFAULT_DB_ALIAS].ops.conditional_expression_supported_in_where_clause(filter_expr):\n-                condition = filter_expr.resolve_expression(self)\n-            else:\n-                # Expression is not supported in the WHERE clause, add\n-                # comparison with True.\n-                condition = self.build_lookup(['exact'], filter_expr.resolve_expression(self), True)\n+            if not contains_outerref(filter_expr):\n+                if connections[DEFAULT_DB_ALIAS].ops.conditional_expression_supported_in_where_clause(filter_expr):\n+                    condition = filter_expr.resolve_expression(self)\n+                else:\n+                    # Expression is not supported in the WHERE clause, add\n+                    # comparison with True.\n+                    condition = self.build_lookup(['exact'], filter_expr.resolve_expression(self), True)\n+                clause = self.where_class()\n+                clause.add(condition, AND)\n+                return clause, []\n+            # Fall through to normal processing for expressions containing OuterRef\n             clause = self.where_class()\n             clause.add(condition, AND)\n             return clause, []\n",
    "variant_7": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 2b59dd301a..5e1652935b 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -543,6 +543,7 @@ class F(Combinable):\n         return hash(self.name)\n \n \n+\n class ResolvedOuterRef(F):\n     \"\"\"\n     An object that contains a reference to an outer query.\n@@ -562,6 +563,7 @@ class ResolvedOuterRef(F):\n         return self\n \n \n+\n class OuterRef(F):\n     def resolve_expression(self, query=None, allow_joins=True, reuse=None,\n                            summarize=False, for_save=False, simple_col=False):\ndiff --git a/django/db/models/query.py b/django/db/models/query.py\nindex ab4f3fc534..984b0038b5 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -893,25 +893,49 @@ class QuerySet:\n         self._not_support_combined_queries('filter')\n         return self._filter_or_exclude(False, *args, **kwargs)\n \n-    def exclude(self, *args, **kwargs):\n-        \"\"\"\n-        Return a new QuerySet instance with NOT (args) ANDed to the existing\n-        set.\n-        \"\"\"\n-        self._not_support_combined_queries('exclude')\n-        return self._filter_or_exclude(True, *args, **kwargs)\n \n-    def _filter_or_exclude(self, negate, *args, **kwargs):\n-        if args or kwargs:\n-            assert not self.query.is_sliced, \\\n-                \"Cannot filter a query once a slice has been taken.\"\n+def contains_outerref(expr):\n+    \"\"\"Recursively check if expression contains OuterRef instances.\"\"\"\n+    from django.db.models.expressions import OuterRef\n+    if isinstance(expr, OuterRef):\n+        return True\n+    if hasattr(expr, 'get_source_expressions'):\n+        for source_expr in expr.get_source_expressions():\n+            if source_expr and contains_outerref(source_expr):\n+                return True\n+    return False\n+\n+def exclude(self, *args, **kwargs):\n+    \"\"\"\n+    Return a new QuerySet instance with NOT (args) ANDed to the existing\n+    set.\n+    \"\"\"\n+    self._not_support_combined_queries('exclude')\n+    return self._filter_or_exclude(True, *args, **kwargs)\n+\n+\n+def contains_outerref(expr):\n+    \"\"\"Recursively check if expression contains OuterRef instances.\"\"\"\n+    from django.db.models.expressions import OuterRef\n+    if isinstance(expr, OuterRef):\n+        return True\n+    if hasattr(expr, 'get_source_expressions'):\n+        for source_expr in expr.get_source_expressions():\n+            if source_expr and contains_outerref(source_expr):\n+                return True\n+    return False\n+\n+def _filter_or_exclude(self, negate, *args, **kwargs):\n+    if args or kwargs:\n+        assert not self.query.is_sliced, \\\n+            \"Cannot filter a query once a slice has been taken.\"\n \n-        clone = self._chain()\n-        if negate:\n-            clone.query.add_q(~Q(*args, **kwargs))\n-        else:\n-            clone.query.add_q(Q(*args, **kwargs))\n-        return clone\n+    clone = self._chain()\n+    if negate:\n+        clone.query.add_q(~Q(*args, **kwargs))\n+    else:\n+        clone.query.add_q(Q(*args, **kwargs))\n+    return clone\n \n     def complex_filter(self, filter_obj):\n         \"\"\"\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 35f3c5e1ea..e6298be7fa 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1229,13 +1229,32 @@ class Query(BaseExpression):\n         \"\"\"\n         if isinstance(filter_expr, dict):\n             raise FieldError(\"Cannot parse keyword query as dict\")\n+\n+def contains_outerref(expr):\n+    \"\"\"Recursively check if expression contains OuterRef instances.\"\"\"\n+    from django.db.models.expressions import OuterRef\n+    if isinstance(expr, OuterRef):\n+        return True\n+    if hasattr(expr, 'get_source_expressions'):\n+        for source_expr in expr.get_source_expressions():\n+            if source_expr and contains_outerref(source_expr):\n+                return True\n+    return False\n+\n+        if isinstance(filter_expr, dict):\n+            raise FieldError(\"Cannot parse keyword query as dict\")\n         if hasattr(filter_expr, 'resolve_expression') and getattr(filter_expr, 'conditional', False):\n-            if connections[DEFAULT_DB_ALIAS].ops.conditional_expression_supported_in_where_clause(filter_expr):\n-                condition = filter_expr.resolve_expression(self)\n-            else:\n-                # Expression is not supported in the WHERE clause, add\n-                # comparison with True.\n-                condition = self.build_lookup(['exact'], filter_expr.resolve_expression(self), True)\n+            if not contains_outerref(filter_expr):\n+                if connections[DEFAULT_DB_ALIAS].ops.conditional_expression_supported_in_where_clause(filter_expr):\n+                    condition = filter_expr.resolve_expression(self)\n+                else:\n+                    # Expression is not supported in the WHERE clause, add\n+                    # comparison with True.\n+                    condition = self.build_lookup(['exact'], filter_expr.resolve_expression(self), True)\n+                clause = self.where_class()\n+                clause.add(condition, AND)\n+                return clause, []\n+            # Fall through to normal processing for expressions containing OuterRef\n             clause = self.where_class()\n             clause.add(condition, AND)\n             return clause, []\n",
    "variant_8": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 2b59dd301a..0e19c7a914 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -543,6 +543,19 @@ class F(Combinable):\n         return hash(self.name)\n \n \n+\n+def contains_outerref(expr):\n+    \"\"\"Recursively check if expression contains OuterRef instances.\"\"\"\n+    from django.db.models.expressions import OuterRef\n+    if isinstance(expr, OuterRef):\n+        return True\n+    if hasattr(expr, 'get_source_expressions'):\n+        for source_expr in expr.get_source_expressions():\n+            if source_expr and contains_outerref(source_expr):\n+                return True\n+    return False\n+\n+\n class ResolvedOuterRef(F):\n     \"\"\"\n     An object that contains a reference to an outer query.\n@@ -562,6 +575,7 @@ class ResolvedOuterRef(F):\n         return self\n \n \n+\n class OuterRef(F):\n     def resolve_expression(self, query=None, allow_joins=True, reuse=None,\n                            summarize=False, for_save=False, simple_col=False):\ndiff --git a/django/db/models/query.py b/django/db/models/query.py\nindex ab4f3fc534..14ff940b38 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -893,25 +893,27 @@ class QuerySet:\n         self._not_support_combined_queries('filter')\n         return self._filter_or_exclude(False, *args, **kwargs)\n \n-    def exclude(self, *args, **kwargs):\n-        \"\"\"\n-        Return a new QuerySet instance with NOT (args) ANDed to the existing\n-        set.\n-        \"\"\"\n-        self._not_support_combined_queries('exclude')\n-        return self._filter_or_exclude(True, *args, **kwargs)\n \n-    def _filter_or_exclude(self, negate, *args, **kwargs):\n-        if args or kwargs:\n-            assert not self.query.is_sliced, \\\n-                \"Cannot filter a query once a slice has been taken.\"\n+def exclude(self, *args, **kwargs):\n+    \"\"\"\n+    Return a new QuerySet instance with NOT (args) ANDed to the existing\n+    set.\n+    \"\"\"\n+    self._not_support_combined_queries('exclude')\n+    return self._filter_or_exclude(True, *args, **kwargs)\n \n-        clone = self._chain()\n-        if negate:\n-            clone.query.add_q(~Q(*args, **kwargs))\n-        else:\n-            clone.query.add_q(Q(*args, **kwargs))\n-        return clone\n+\n+def _filter_or_exclude(self, negate, *args, **kwargs):\n+    if args or kwargs:\n+        assert not self.query.is_sliced, \\\n+            \"Cannot filter a query once a slice has been taken.\"\n+\n+    clone = self._chain()\n+    if negate:\n+        clone.query.add_q(~Q(*args, **kwargs))\n+    else:\n+        clone.query.add_q(Q(*args, **kwargs))\n+    return clone\n \n     def complex_filter(self, filter_obj):\n         \"\"\"\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 35f3c5e1ea..e6298be7fa 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1229,13 +1229,32 @@ class Query(BaseExpression):\n         \"\"\"\n         if isinstance(filter_expr, dict):\n             raise FieldError(\"Cannot parse keyword query as dict\")\n+\n+def contains_outerref(expr):\n+    \"\"\"Recursively check if expression contains OuterRef instances.\"\"\"\n+    from django.db.models.expressions import OuterRef\n+    if isinstance(expr, OuterRef):\n+        return True\n+    if hasattr(expr, 'get_source_expressions'):\n+        for source_expr in expr.get_source_expressions():\n+            if source_expr and contains_outerref(source_expr):\n+                return True\n+    return False\n+\n+        if isinstance(filter_expr, dict):\n+            raise FieldError(\"Cannot parse keyword query as dict\")\n         if hasattr(filter_expr, 'resolve_expression') and getattr(filter_expr, 'conditional', False):\n-            if connections[DEFAULT_DB_ALIAS].ops.conditional_expression_supported_in_where_clause(filter_expr):\n-                condition = filter_expr.resolve_expression(self)\n-            else:\n-                # Expression is not supported in the WHERE clause, add\n-                # comparison with True.\n-                condition = self.build_lookup(['exact'], filter_expr.resolve_expression(self), True)\n+            if not contains_outerref(filter_expr):\n+                if connections[DEFAULT_DB_ALIAS].ops.conditional_expression_supported_in_where_clause(filter_expr):\n+                    condition = filter_expr.resolve_expression(self)\n+                else:\n+                    # Expression is not supported in the WHERE clause, add\n+                    # comparison with True.\n+                    condition = self.build_lookup(['exact'], filter_expr.resolve_expression(self), True)\n+                clause = self.where_class()\n+                clause.add(condition, AND)\n+                return clause, []\n+            # Fall through to normal processing for expressions containing OuterRef\n             clause = self.where_class()\n             clause.add(condition, AND)\n             return clause, []\n"
  }
}