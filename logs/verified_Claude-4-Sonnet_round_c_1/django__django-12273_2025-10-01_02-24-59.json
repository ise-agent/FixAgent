{
  "zero_patches": {
    "Location 1 (/root/hy/projects/django/django/db/models/base.py lines 817-819)": "\n            # Set the parent's PK value to self.\n            if field:\n                # Only restore the parent's PK if the child's PK wasn't intentionally reset to None\n                # Check if the field was None before we started the parent save process\n                child_pk_before_save = getattr(self, field.attname, None)\n                if child_pk_before_save is not None or not hasattr(self, '_pk_was_reset'):\n                    setattr(self, field.attname, self._get_pk_val(parent._meta))\n",
    "Location 2 (/root/hy/projects/django/django/db/models/base.py lines 807-809)": "\n    def _save_parents(self, cls, using, update_fields):\n        \"\"\"Save all the parents of cls using values from self.\"\"\"\n        meta = cls._meta\n        inserted = False\n        for parent, field in meta.parents.items():\n            # Store original child PK state to detect intentional resets\n            original_child_pk = getattr(self, parent._meta.pk.attname) if field else None\n            child_pk_was_none = original_child_pk is None\n            \n            # Make sure the link fields are synced between parent and self.\n            if (field and getattr(self, parent._meta.pk.attname) is None and\n                    getattr(self, field.attname) is not None):\n                setattr(self, parent._meta.pk.attname, getattr(self, field.attname))\n            parent_inserted = self._save_parents(cls=parent, using=using, update_fields=update_fields)\n            updated = self._save_table(\n                cls=parent, using=using, update_fields=update_fields,\n                force_insert=parent_inserted,\n            )\n            if not updated:\n                inserted = True\n            # Set the parent's PK value to self, but only if child PK wasn't intentionally reset to None\n            if field and not child_pk_was_none:\n                setattr(self, field.attname, self._get_pk_val(parent._meta))\n",
    "Location 3 (/root/hy/projects/django/django/db/models/base.py lines 810-816)": "\n    def _save_parents(self, cls, using, update_fields):\n        \"\"\"Save all the parents of cls using values from self.\"\"\"\n        meta = cls._meta\n        inserted = False\n        # Check if this is an intentional PK reset by storing original PK state\n        original_pk_was_none = self._get_pk_val(meta) is None\n        \n        for parent, field in meta.parents.items():\n            # Make sure the link fields are synced between parent and self.\n            if (field and getattr(self, parent._meta.pk.attname) is None and\n                    getattr(self, field.attname) is not None):\n                setattr(self, parent._meta.pk.attname, getattr(self, field.attname))\n            parent_inserted = self._save_parents(cls=parent, using=using, update_fields=update_fields)\n            updated = self._save_table(\n                cls=parent, using=using, update_fields=update_fields,\n                force_insert=parent_inserted,\n            )\n            if not updated:\n                inserted = True\n            # Set the parent's PK value to self, but only if this wasn't an intentional PK reset\n            if field and not (original_pk_was_none and self._get_pk_val(meta) is None):\n                setattr(self, field.attname, self._get_pk_val(parent._meta))\n                # Since we didn't have an instance of the parent handy set\n                # attname directly, bypassing the descriptor. Invalidate\n                # the related object cache, in case it's been accidentally\n                # populated. A fresh instance will be re-built from the\n                # database if necessary.\n                if field.is_cached(self):\n                    field.delete_cached_value(self)\n",
    "Location 4 (/root/hy/projects/django/django/db/models/base.py lines 842-846)": "\n        pk_val = self._get_pk_val(meta)\n        # Check if PK was intentionally reset to None for creating a new object\n        pk_was_reset = hasattr(self, '_pk_was_reset') and getattr(self, '_pk_was_reset', False)\n        \n        if pk_val is None:\n            pk_val = meta.pk.get_pk_value_on_save(self)\n            setattr(self, meta.pk.attname, pk_val)\n        pk_set = pk_val is not None and not pk_was_reset\n",
    "Location 5 (/root/hy/projects/django/django/db/models/base.py lines 860-866)": "\n        # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.\n        if pk_set and not force_insert:\n            base_qs = cls._base_manager.using(using)\n            values = [(f, None, (getattr(self, f.attname) if raw else f.pre_save(self, False)))\n                      for f in non_pks]\n            forced_update = update_fields or force_update\n            # Check if this is an inheritance scenario where PK was intentionally reset\n            pk_was_reset = getattr(self, '_pk_was_reset', False)\n            if not pk_was_reset:\n                updated = self._do_update(base_qs, using, pk_val, values, update_fields,\n                                          forced_update)\n            else:\n                # Skip UPDATE attempt if PK was intentionally reset for new object creation\n                updated = 0\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/django/django/db/models/base.py lines 817-819)": [
      "\n            # Set the parent's PK value to self.\n            if field:\n                # Only restore parent PK if child PK wasn't intentionally reset to None\n                # Check if the child's PK was None before saving parents and is still None\n                child_pk_before_save = getattr(self, self._meta.pk.attname, None)\n                if child_pk_before_save is not None or not hasattr(self, '_pk_was_reset'):\n                    setattr(self, field.attname, self._get_pk_val(parent._meta))\n                # Since we didn't have an instance of the parent handy set\n                # attname directly, bypassing the descriptor. Invalidate\n                # the related object cache, in case it's been accidentally\n                # populated. A fresh instance will be re-built from the\n                # database if necessary.\n                if field.is_cached(self):\n                    field.delete_cached_value(self)\n",
      "\n            # Set the parent's PK value to self.\n            if field:\n                # Only restore parent PK if child PK wasn't intentionally reset to None\n                # Check if the field was None before _save_parents and is still None\n                current_pk = getattr(self, field.attname)\n                if current_pk is not None or not hasattr(self, '_pk_was_reset'):\n                    setattr(self, field.attname, self._get_pk_val(parent._meta))\n                # Since we didn't have an instance of the parent handy set\n                # attname directly, bypassing the descriptor. Invalidate\n                # the related object cache, in case it's been accidentally\n                # populated. A fresh instance will be re-built from the\n                # database if necessary.\n                if field.is_cached(self):\n                    field.delete_cached_value(self)\n",
      "\n            # Set the parent's PK value to self.\n            if field:\n                # Only restore parent PK if child PK wasn't intentionally reset to None\n                # Check if the field was explicitly set to None before save operation\n                current_pk = getattr(self, field.attname)\n                if current_pk is not None:\n                    setattr(self, field.attname, self._get_pk_val(parent._meta))\n",
      "\n            # Set the parent's PK value to self.\n            if field:\n                # Only restore parent PK if child PK wasn't intentionally reset to None\n                # Check if the field was explicitly set to None before the save operation\n                child_pk_before_save = getattr(self, field.attname, None)\n                if child_pk_before_save is not None or not hasattr(self, '_pk_was_reset'):\n                    setattr(self, field.attname, self._get_pk_val(parent._meta))\n                # Since we didn't have an instance of the parent handy set\n                # attname directly, bypassing the descriptor. Invalidate\n                # the related object cache, in case it's been accidentally\n                # populated. A fresh instance will be re-built from the\n                # database if necessary.\n                if field.is_cached(self):\n                    field.delete_cached_value(self)\n",
      "\n            # Set the parent's PK value to self.\n            if field:\n                # Only restore the parent PK if we didn't intentionally reset our PK to None\n                # This preserves the user's intent when calling reset() followed by save()\n                original_pk = getattr(self, field.attname)\n                if original_pk is not None or not hasattr(self, '_pk_was_reset'):\n                    setattr(self, field.attname, self._get_pk_val(parent._meta))\n",
      "\n            # Set the parent's PK value to self.\n            if field:\n                # Only restore parent PK if child PK wasn't intentionally reset to None\n                # Check if this is a new object creation (force_insert or PK was None before save)\n                child_pk_before_save = getattr(self, self._meta.pk.attname, None)\n                if not (force_insert or child_pk_before_save is None):\n                    setattr(self, field.attname, self._get_pk_val(parent._meta))\n                    # Since we didn't have an instance of the parent handy set\n                    # attname directly, bypassing the descriptor. Invalidate\n                    # the related object cache, in case it's been accidentally\n                    # populated. A fresh instance will be re-built from the\n                    # database if necessary.\n                    if field.is_cached(self):\n                        field.delete_cached_value(self)\n",
      "\n            # Set the parent's PK value to self.\n            if field:\n                # Only restore parent PK if child PK wasn't explicitly reset to None\n                # Check if this is a new object creation (PK was None before save)\n                current_child_pk = getattr(self, self._meta.pk.attname)\n                if current_child_pk is not None:\n                    setattr(self, field.attname, self._get_pk_val(parent._meta))\n                    # Since we didn't have an instance of the parent handy set\n                    # attname directly, bypassing the descriptor. Invalidate\n                    # the related object cache, in case it's been accidentally\n                    # populated. A fresh instance will be re-built from the\n                    # database if necessary.\n                    if field.is_cached(self):\n                        field.delete_cached_value(self)\n",
      "\n            # Set the parent's PK value to self.\n            if field:\n                # Only restore parent PK if child PK wasn't intentionally reset to None\n                # Check if the original PK value was None before saving parents\n                original_pk = getattr(self, self._meta.pk.attname, None)\n                if original_pk is not None:\n                    setattr(self, field.attname, self._get_pk_val(parent._meta))\n"
    ],
    "Location 2 (/root/hy/projects/django/django/db/models/base.py lines 807-809)": [
      "\n    def _save_parents(self, cls, using, update_fields):\n        \"\"\"Save all the parents of cls using values from self.\"\"\"\n        meta = cls._meta\n        inserted = False\n        for parent, field in meta.parents.items():\n            # Make sure the link fields are synced between parent and self.\n            if (field and getattr(self, parent._meta.pk.attname) is None and\n                    getattr(self, field.attname) is not None):\n                setattr(self, parent._meta.pk.attname, getattr(self, field.attname))\n            parent_inserted = self._save_parents(cls=parent, using=using, update_fields=update_fields)\n            updated = self._save_table(\n                cls=parent, using=using, update_fields=update_fields,\n                force_insert=parent_inserted,\n            )\n            if not updated:\n                inserted = True\n            # Set the parent's PK value to self.\n            # Only restore parent PK if child PK wasn't intentionally reset to None\n            if field:\n                child_pk_was_none = getattr(self, field.attname) is None\n                if not child_pk_was_none:\n                    setattr(self, field.attname, self._get_pk_val(parent._meta))\n",
      "\n    def _save_parents(self, cls, using, update_fields):\n        \"\"\"Save all the parents of cls using values from self.\"\"\"\n        meta = cls._meta\n        inserted = False\n        for parent, field in meta.parents.items():\n            # Make sure the link fields are synced between parent and self.\n            if (field and getattr(self, parent._meta.pk.attname) is None and\n                    getattr(self, field.attname) is not None):\n                setattr(self, parent._meta.pk.attname, getattr(self, field.attname))\n            parent_inserted = self._save_parents(cls=parent, using=using, update_fields=update_fields)\n            updated = self._save_table(\n                cls=parent, using=using, update_fields=update_fields,\n                force_insert=parent_inserted,\n            )\n            if not updated:\n                inserted = True\n            # Set the parent's PK value to self, but only if the child's PK wasn't intentionally reset.\n            if field:\n                # Check if this is a new object creation (child PK was None before parent save)\n                child_pk_was_none = getattr(self, field.attname) is None\n                if not child_pk_was_none:\n                    setattr(self, field.attname, self._get_pk_val(parent._meta))\n",
      "\n    def _save_parents(self, cls, using, update_fields):\n        \"\"\"Save all the parents of cls using values from self.\"\"\"\n        meta = cls._meta\n        inserted = False\n        # Track if the primary key was intentionally reset to None\n        pk_was_reset = getattr(self, meta.pk.attname) is None\n        \n        for parent, field in meta.parents.items():\n            # Make sure the link fields are synced between parent and self.\n            if (field and getattr(self, parent._meta.pk.attname) is None and\n                    getattr(self, field.attname) is not None):\n                setattr(self, parent._meta.pk.attname, getattr(self, field.attname))\n            parent_inserted = self._save_parents(cls=parent, using=using, update_fields=update_fields)\n            updated = self._save_table(\n                cls=parent, using=using, update_fields=update_fields,\n                force_insert=parent_inserted,\n            )\n            if not updated:\n                inserted = True\n            # Set the parent's PK value to self, but only if we didn't intentionally reset it\n            if field and not pk_was_reset:\n                setattr(self, field.attname, self._get_pk_val(parent._meta))\n",
      "\n    def _save_parents(self, cls, using, update_fields):\n        \"\"\"Save all the parents of cls using values from self.\"\"\"\n        meta = cls._meta\n        inserted = False\n        for parent, field in meta.parents.items():\n            # Make sure the link fields are synced between parent and self.\n            if (field and getattr(self, parent._meta.pk.attname) is None and\n                    getattr(self, field.attname) is not None):\n                setattr(self, parent._meta.pk.attname, getattr(self, field.attname))\n            parent_inserted = self._save_parents(cls=parent, using=using, update_fields=update_fields)\n            updated = self._save_table(\n                cls=parent, using=using, update_fields=update_fields,\n                force_insert=parent_inserted,\n            )\n            if not updated:\n                inserted = True\n            # Set the parent's PK value to self, but only if child PK wasn't intentionally reset\n            if field:\n                # Check if the child's PK was intentionally set to None for creating a new object\n                child_pk_val = self._get_pk_val(meta)\n                if child_pk_val is not None:\n                    # Only restore parent PK if child PK wasn't reset to None\n                    setattr(self, field.attname, self._get_pk_val(parent._meta))\n",
      "\n    def _save_parents(self, cls, using, update_fields):\n        \"\"\"Save all the parents of cls using values from self.\"\"\"\n        meta = cls._meta\n        inserted = False\n        for parent, field in meta.parents.items():\n            # Make sure the link fields are synced between parent and self.\n            if (field and getattr(self, parent._meta.pk.attname) is None and\n                    getattr(self, field.attname) is not None):\n                setattr(self, parent._meta.pk.attname, getattr(self, field.attname))\n            parent_inserted = self._save_parents(cls=parent, using=using, update_fields=update_fields)\n            updated = self._save_table(\n                cls=parent, using=using, update_fields=update_fields,\n                force_insert=parent_inserted,\n            )\n            if not updated:\n                inserted = True\n            # Set the parent's PK value to self, but only if the child's PK wasn't intentionally reset.\n            if field:\n                child_pk_was_none = getattr(self, field.attname) is None\n                parent_pk_val = self._get_pk_val(parent._meta)\n                # Only restore parent PK if child PK wasn't explicitly set to None for creating new object\n                if not child_pk_was_none or parent_pk_val is None:\n                    setattr(self, field.attname, parent_pk_val)\n",
      "\n    def _save_parents(self, cls, using, update_fields):\n        \"\"\"Save all the parents of cls using values from self.\"\"\"\n        meta = cls._meta\n        inserted = False\n        for parent, field in meta.parents.items():\n            # Make sure the link fields are synced between parent and self.\n            if (field and getattr(self, parent._meta.pk.attname) is None and\n                    getattr(self, field.attname) is not None):\n                setattr(self, parent._meta.pk.attname, getattr(self, field.attname))\n            parent_inserted = self._save_parents(cls=parent, using=using, update_fields=update_fields)\n            updated = self._save_table(\n                cls=parent, using=using, update_fields=update_fields,\n                force_insert=parent_inserted,\n            )\n            if not updated:\n                inserted = True\n            # Set the parent's PK value to self.\n            if field:\n                # Only restore parent PK if child PK wasn't intentionally reset to None\n                child_pk_val = self._get_pk_val(meta)\n                if child_pk_val is not None:\n                    setattr(self, field.attname, self._get_pk_val(parent._meta))\n",
      "\n    def _save_parents(self, cls, using, update_fields):\n        \"\"\"Save all the parents of cls using values from self.\"\"\"\n        meta = cls._meta\n        inserted = False\n        for parent, field in meta.parents.items():\n            # Make sure the link fields are synced between parent and self.\n            if (field and getattr(self, parent._meta.pk.attname) is None and\n                    getattr(self, field.attname) is not None):\n                setattr(self, parent._meta.pk.attname, getattr(self, field.attname))\n            parent_inserted = self._save_parents(cls=parent, using=using, update_fields=update_fields)\n            updated = self._save_table(\n                cls=parent, using=using, update_fields=update_fields,\n                force_insert=parent_inserted,\n            )\n            if not updated:\n                inserted = True\n            # Set the parent's PK value to self.\n            if field:\n                # Only restore parent PK if child PK wasn't explicitly reset to None\n                child_pk_was_none = getattr(self, field.attname) is None\n                parent_pk_val = self._get_pk_val(parent._meta)\n                if not child_pk_was_none or parent_pk_val != getattr(self, field.attname):\n                    setattr(self, field.attname, parent_pk_val)\n",
      "\n    def _save_parents(self, cls, using, update_fields):\n        \"\"\"Save all the parents of cls using values from self.\"\"\"\n        meta = cls._meta\n        inserted = False\n        for parent, field in meta.parents.items():\n            # Make sure the link fields are synced between parent and self.\n            if (field and getattr(self, parent._meta.pk.attname) is None and\n                    getattr(self, field.attname) is not None):\n                setattr(self, parent._meta.pk.attname, getattr(self, field.attname))\n            parent_inserted = self._save_parents(cls=parent, using=using, update_fields=update_fields)\n            updated = self._save_table(\n                cls=parent, using=using, update_fields=update_fields,\n                force_insert=parent_inserted,\n            )\n            if not updated:\n                inserted = True\n            # Set the parent's PK value to self.\n            if field:\n                # Check if the child's PK was intentionally reset to None before save\n                # If so, don't restore the parent's PK as this would prevent new object creation\n                child_pk_was_reset = (\n                    hasattr(self, '_state') and \n                    getattr(self._state, 'adding', False) and\n                    self._get_pk_val() is None\n                )\n                if not child_pk_was_reset:\n                    setattr(self, field.attname, self._get_pk_val(parent._meta))\n"
    ],
    "Location 3 (/root/hy/projects/django/django/db/models/base.py lines 810-816)": [
      "\n    def _save_parents(self, cls, using, update_fields):\n        \"\"\"Save all the parents of cls using values from self.\"\"\"\n        meta = cls._meta\n        inserted = False\n        # Track if the primary key was intentionally reset to None\n        pk_was_reset = getattr(self, '_pk_was_reset', False)\n        for parent, field in meta.parents.items():\n            # Make sure the link fields are synced between parent and self.\n            if (field and getattr(self, parent._meta.pk.attname) is None and\n                    getattr(self, field.attname) is not None):\n                setattr(self, parent._meta.pk.attname, getattr(self, field.attname))\n            parent_inserted = self._save_parents(cls=parent, using=using, update_fields=update_fields)\n            updated = self._save_table(\n                cls=parent, using=using, update_fields=update_fields,\n                force_insert=parent_inserted,\n            )\n            if not updated:\n                inserted = True\n            # Set the parent's PK value to self, but only if PK wasn't intentionally reset\n            if field and not pk_was_reset:\n                setattr(self, field.attname, self._get_pk_val(parent._meta))\n                # Since we didn't have an instance of the parent handy set\n                # attname directly, bypassing the descriptor. Invalidate\n                # the related object cache, in case it's been accidentally\n                # populated. A fresh instance will be re-built from the\n                # database if necessary.\n                if field.is_cached(self):\n                    field.delete_cached_value(self)\n",
      "\n    def _save_parents(self, cls, using, update_fields):\n        \"\"\"Save all the parents of cls using values from self.\"\"\"\n        meta = cls._meta\n        inserted = False\n        # Check if the primary key was intentionally reset to None\n        pk_was_reset = (getattr(self, self._meta.pk.attname) is None and \n                       hasattr(self, '_state') and self._state.adding is False)\n        \n        for parent, field in meta.parents.items():\n            # Make sure the link fields are synced between parent and self.\n            if (field and getattr(self, parent._meta.pk.attname) is None and\n                    getattr(self, field.attname) is not None):\n                setattr(self, parent._meta.pk.attname, getattr(self, field.attname))\n            parent_inserted = self._save_parents(cls=parent, using=using, update_fields=update_fields)\n            updated = self._save_table(\n                cls=parent, using=using, update_fields=update_fields,\n                force_insert=parent_inserted,\n            )\n            if not updated:\n                inserted = True\n            # Set the parent's PK value to self, but only if PK wasn't intentionally reset\n            if field and not pk_was_reset:\n                setattr(self, field.attname, self._get_pk_val(parent._meta))\n                # Since we didn't have an instance of the parent handy set\n                # attname directly, bypassing the descriptor. Invalidate\n                # the related object cache, in case it's been accidentally\n                # populated. A fresh instance will be re-built from the\n                # database if necessary.\n                if field.is_cached(self):\n                    field.delete_cached_value(self)\n",
      "\ndef _save_parents(self, cls, using, update_fields):\n    \"\"\"Save all the parents of cls using values from self.\"\"\"\n    meta = cls._meta\n    inserted = False\n    for parent, field in meta.parents.items():\n        # Make sure the link fields are synced between parent and self.\n        if (field and getattr(self, parent._meta.pk.attname) is None and\n                getattr(self, field.attname) is not None):\n            setattr(self, parent._meta.pk.attname, getattr(self, field.attname))\n        parent_inserted = self._save_parents(cls=parent, using=using, update_fields=update_fields)\n        updated = self._save_table(\n            cls=parent, using=using, update_fields=update_fields,\n            force_insert=parent_inserted,\n        )\n        if not updated:\n            inserted = True\n        # Set the parent's PK value to self, but only if we didn't intentionally reset it\n        if field:\n            # Check if the primary key was intentionally set to None for this save operation\n            pk_was_reset = (hasattr(self, '_state') and \n                           getattr(self._state, 'pk_was_reset', False))\n            if not pk_was_reset:\n                setattr(self, field.attname, self._get_pk_val(parent._meta))\n                # Since we didn't have an instance of the parent handy set\n                # attname directly, bypassing the descriptor. Invalidate\n                # the related object cache, in case it's been accidentally\n                # populated. A fresh instance will be re-built from the\n                # database if necessary.\n                if field.is_cached(self):\n                    field.delete_cached_value(self)\n",
      "\n    def _save_parents(self, cls, using, update_fields):\n        \"\"\"Save all the parents of cls using values from self.\"\"\"\n        meta = cls._meta\n        inserted = False\n        # Track if the primary key was intentionally reset to None\n        pk_was_reset = getattr(self, '_pk_was_reset', False)\n        original_pk = self._get_pk_val()\n        \n        for parent, field in meta.parents.items():\n            # Make sure the link fields are synced between parent and self.\n            if (field and getattr(self, parent._meta.pk.attname) is None and\n                    getattr(self, field.attname) is not None):\n                setattr(self, parent._meta.pk.attname, getattr(self, field.attname))\n            parent_inserted = self._save_parents(cls=parent, using=using, update_fields=update_fields)\n            updated = self._save_table(\n                cls=parent, using=using, update_fields=update_fields,\n                force_insert=parent_inserted,\n            )\n            if not updated:\n                inserted = True\n            # Set the parent's PK value to self only if PK wasn't intentionally reset.\n            if field and not (pk_was_reset and original_pk is None):\n                setattr(self, field.attname, self._get_pk_val(parent._meta))\n                # Since we didn't have an instance of the parent handy set\n                # attname directly, bypassing the descriptor. Invalidate\n                # the related object cache, in case it's been accidentally\n                # populated. A fresh instance will be re-built from the\n                # database if necessary.\n                if field.is_cached(self):\n                    field.delete_cached_value(self)\n",
      "\n    def _save_parents(self, cls, using, update_fields):\n        \"\"\"Save all the parents of cls using values from self.\"\"\"\n        meta = cls._meta\n        inserted = False\n        for parent, field in meta.parents.items():\n            # Make sure the link fields are synced between parent and self.\n            if (field and getattr(self, parent._meta.pk.attname) is None and\n                    getattr(self, field.attname) is not None):\n                setattr(self, parent._meta.pk.attname, getattr(self, field.attname))\n            \n            # Store the current PK value to detect if it was intentionally reset\n            original_pk = getattr(self, meta.pk.attname)\n            \n            parent_inserted = self._save_parents(cls=parent, using=using, update_fields=update_fields)\n            updated = self._save_table(\n                cls=parent, using=using, update_fields=update_fields,\n                force_insert=parent_inserted,\n            )\n            if not updated:\n                inserted = True\n            # Set the parent's PK value to self only if the original PK wasn't intentionally reset to None.\n            if field:\n                # If the original PK was None (indicating a reset for new object creation),\n                # don't restore the parent PK to maintain the intent to create a new object\n                if original_pk is not None:\n                    setattr(self, field.attname, self._get_pk_val(parent._meta))\n                    # Since we didn't have an instance of the parent handy set\n                    # attname directly, bypassing the descriptor. Invalidate\n                    # the related object cache, in case it's been accidentally\n                    # populated. A fresh instance will be re-built from the\n                    # database if necessary.\n                    if field.is_cached(self):\n                        field.delete_cached_value(self)\n",
      "\n    def _save_parents(self, cls, using, update_fields):\n        \"\"\"Save all the parents of cls using values from self.\"\"\"\n        meta = cls._meta\n        inserted = False\n        # Track if this instance's PK was intentionally reset to None\n        pk_was_reset = getattr(self, '_pk_was_reset', False)\n        \n        for parent, field in meta.parents.items():\n            # Make sure the link fields are synced between parent and self.\n            if (field and getattr(self, parent._meta.pk.attname) is None and\n                    getattr(self, field.attname) is not None):\n                setattr(self, parent._meta.pk.attname, getattr(self, field.attname))\n            parent_inserted = self._save_parents(cls=parent, using=using, update_fields=update_fields)\n            updated = self._save_table(\n                cls=parent, using=using, update_fields=update_fields,\n                force_insert=parent_inserted,\n            )\n            if not updated:\n                inserted = True\n            # Set the parent's PK value to self, but only if PK wasn't intentionally reset\n            if field and not pk_was_reset:\n                setattr(self, field.attname, self._get_pk_val(parent._meta))\n                # Since we didn't have an instance of the parent handy set\n                # attname directly, bypassing the descriptor. Invalidate\n                # the related object cache, in case it's been accidentally\n                # populated. A fresh instance will be re-built from the\n                # database if necessary.\n                if field.is_cached(self):\n                    field.delete_cached_value(self)\n",
      "\n    def _save_parents(self, cls, using, update_fields):\n        \"\"\"Save all the parents of cls using values from self.\"\"\"\n        meta = cls._meta\n        inserted = False\n        \n        # Track if the primary key was intentionally reset to None\n        pk_was_reset = getattr(self, '_pk_was_reset', False)\n        original_pk = getattr(self, meta.pk.attname) if not pk_was_reset else None\n        \n        for parent, field in meta.parents.items():\n            # Make sure the link fields are synced between parent and self.\n            if (field and getattr(self, parent._meta.pk.attname) is None and\n                    getattr(self, field.attname) is not None):\n                setattr(self, parent._meta.pk.attname, getattr(self, field.attname))\n            parent_inserted = self._save_parents(cls=parent, using=using, update_fields=update_fields)\n            updated = self._save_table(\n                cls=parent, using=using, update_fields=update_fields,\n                force_insert=parent_inserted,\n            )\n            if not updated:\n                inserted = True\n            # Set the parent's PK value to self, but only if PK wasn't intentionally reset\n            if field and not pk_was_reset:\n                setattr(self, field.attname, self._get_pk_val(parent._meta))\n                # Since we didn't have an instance of the parent handy set\n                # attname directly, bypassing the descriptor. Invalidate\n                # the related object cache, in case it's been accidentally\n                # populated. A fresh instance will be re-built from the\n                # database if necessary.\n                if field.is_cached(self):\n                    field.delete_cached_value(self)\n",
      "\n    def _save_parents(self, cls, using, update_fields):\n        \"\"\"Save all the parents of cls using values from self.\"\"\"\n        meta = cls._meta\n        inserted = False\n        # Remember if the primary key was intentionally set to None for reset\n        pk_was_reset = getattr(self, meta.pk.attname) is None and hasattr(self, '_state') and self._state.adding\n        \n        for parent, field in meta.parents.items():\n            # Make sure the link fields are synced between parent and self.\n            if (field and getattr(self, parent._meta.pk.attname) is None and\n                    getattr(self, field.attname) is not None):\n                setattr(self, parent._meta.pk.attname, getattr(self, field.attname))\n            parent_inserted = self._save_parents(cls=parent, using=using, update_fields=update_fields)\n            updated = self._save_table(\n                cls=parent, using=using, update_fields=update_fields,\n                force_insert=parent_inserted,\n            )\n            if not updated:\n                inserted = True\n            # Set the parent's PK value to self, but only if PK wasn't intentionally reset\n            if field and not pk_was_reset:\n                setattr(self, field.attname, self._get_pk_val(parent._meta))\n                # Since we didn't have an instance of the parent handy set\n                # attname directly, bypassing the descriptor. Invalidate\n                # the related object cache, in case it's been accidentally\n                # populated. A fresh instance will be re-built from the\n                # database if necessary.\n                if field.is_cached(self):\n                    field.delete_cached_value(self)\n"
    ],
    "Location 4 (/root/hy/projects/django/django/db/models/base.py lines 842-846)": [
      "\n        pk_val = self._get_pk_val(meta)\n        # Check if PK was intentionally reset to None for creating a new object\n        pk_was_reset = (pk_val is None and \n                       hasattr(self, '_pk_reset_for_new_object') and \n                       self._pk_reset_for_new_object)\n        \n        if pk_val is None:\n            pk_val = meta.pk.get_pk_value_on_save(self)\n            setattr(self, meta.pk.attname, pk_val)\n        pk_set = pk_val is not None or pk_was_reset\n",
      "\n        pk_val = self._get_pk_val(meta)\n        # Check if PK was intentionally reset to None for creating new object\n        pk_was_reset = (pk_val is None and \n                       hasattr(self, '_pk_reset_for_new_object') and \n                       self._pk_reset_for_new_object)\n        \n        if pk_val is None:\n            pk_val = meta.pk.get_pk_value_on_save(self)\n            setattr(self, meta.pk.attname, pk_val)\n        pk_set = pk_val is not None and not pk_was_reset\n",
      "\n        pk_val = self._get_pk_val(meta)\n        # Check if this is an intentional PK reset for creating a new object\n        pk_was_intentionally_reset = (\n            pk_val is None and \n            hasattr(self, '_pk_reset_for_new_object') and \n            self._pk_reset_for_new_object\n        )\n        \n        if pk_val is None:\n            pk_val = meta.pk.get_pk_value_on_save(self)\n            setattr(self, meta.pk.attname, pk_val)\n        pk_set = pk_val is not None\n",
      "\n        pk_val = self._get_pk_val(meta)\n        # Check if PK was intentionally reset to None for creating a new object\n        pk_was_reset = hasattr(self, '_pk_was_reset') and self._pk_was_reset\n        if pk_val is None:\n            pk_val = meta.pk.get_pk_value_on_save(self)\n            setattr(self, meta.pk.attname, pk_val)\n        # Don't consider PK as set if it was intentionally reset\n        pk_set = pk_val is not None and not pk_was_reset\n",
      "\n        pk_val = self._get_pk_val(meta)\n        # Check if PK was intentionally reset to None for creating a new object\n        pk_was_reset = (pk_val is None and \n                       hasattr(self, '_state') and \n                       not self._state.adding and\n                       getattr(self, '_pk_was_reset', False))\n        \n        if pk_val is None:\n            pk_val = meta.pk.get_pk_value_on_save(self)\n            setattr(self, meta.pk.attname, pk_val)\n        pk_set = pk_val is not None or pk_was_reset\n",
      "\n        pk_val = self._get_pk_val(meta)\n        # Check if PK was intentionally reset to None for creating a new object\n        pk_was_reset = (pk_val is None and \n                       hasattr(self, '_pk_was_reset_for_new_object') and \n                       self._pk_was_reset_for_new_object)\n        \n        if pk_val is None:\n            pk_val = meta.pk.get_pk_value_on_save(self)\n            setattr(self, meta.pk.attname, pk_val)\n        pk_set = pk_val is not None\n",
      "\n        pk_val = self._get_pk_val(meta)\n        # Check if PK was intentionally reset to None for creating a new object\n        pk_was_reset = (pk_val is None and \n                       hasattr(self, '_pk_reset_for_new_object') and \n                       self._pk_reset_for_new_object)\n        \n        if pk_val is None:\n            pk_val = meta.pk.get_pk_value_on_save(self)\n            setattr(self, meta.pk.attname, pk_val)\n        pk_set = pk_val is not None and not pk_was_reset\n",
      "\n        pk_val = self._get_pk_val(meta)\n        # Check if PK was intentionally reset to None for creating a new object\n        pk_was_intentionally_reset = (\n            pk_val is None and \n            hasattr(self, '_pk_reset_for_new_object') and \n            self._pk_reset_for_new_object\n        )\n        \n        if pk_val is None and not pk_was_intentionally_reset:\n            pk_val = meta.pk.get_pk_value_on_save(self)\n            setattr(self, meta.pk.attname, pk_val)\n        pk_set = pk_val is not None and not pk_was_intentionally_reset\n"
    ],
    "Location 5 (/root/hy/projects/django/django/db/models/base.py lines 860-866)": [
      "\n        # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.\n        if pk_set and not force_insert:\n            # Check if this is an inheritance scenario where PK was intentionally reset\n            # by examining if we have parent links and the PK was None before _save_parents\n            is_inheritance_reset = (\n                hasattr(self, '_original_pk_was_none') and \n                getattr(self, '_original_pk_was_none', False) and\n                any(hasattr(self, f.name) for f in meta.parents.values())\n            )\n            \n            if not is_inheritance_reset:\n                base_qs = cls._base_manager.using(using)\n                values = [(f, None, (getattr(self, f.attname) if raw else f.pre_save(self, False)))\n                          for f in non_pks]\n                forced_update = update_fields or force_update\n                updated = self._do_update(base_qs, using, pk_val, values, update_fields,\n                                          forced_update)\n            else:\n                # Force INSERT for inheritance reset scenarios\n                updated = False\n",
      "\n        # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.\n        if pk_set and not force_insert:\n            base_qs = cls._base_manager.using(using)\n            values = [(f, None, (getattr(self, f.attname) if raw else f.pre_save(self, False)))\n                      for f in non_pks]\n            forced_update = update_fields or force_update\n            # Check if this is an inheritance scenario where PK was intentionally reset\n            # In such cases, we should not attempt an UPDATE even if pk_set is True\n            is_inheritance_reset = (\n                hasattr(self, '_state') and \n                getattr(self._state, '_pk_was_reset', False) and\n                self._meta.parents\n            )\n            if not is_inheritance_reset:\n                updated = self._do_update(base_qs, using, pk_val, values, update_fields,\n                                        forced_update)\n            else:\n                updated = False\n",
      "\n        # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.\n        if pk_set and not force_insert:\n            base_qs = cls._base_manager.using(using)\n            values = [(f, None, (getattr(self, f.attname) if raw else f.pre_save(self, False)))\n                      for f in non_pks]\n            forced_update = update_fields or force_update\n            # Check if this is an inheritance scenario where PK was reset\n            # In such cases, we should prefer INSERT over UPDATE\n            if hasattr(self, '_pk_was_reset') and self._pk_was_reset:\n                updated = False\n            else:\n                updated = self._do_update(base_qs, using, pk_val, values, update_fields,\n                                          forced_update)\n",
      "\n        # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.\n        if pk_set and not force_insert:\n            # Check if this is an inheritance scenario where PK was intentionally reset\n            # by examining if we have a parent with a different PK than ours\n            intentional_reset = False\n            if hasattr(self, '_state') and hasattr(self._state, 'adding'):\n                # Check if any parent model has a PK that differs from ours\n                for parent, field in meta.parents.items():\n                    if field and hasattr(self, field.attname):\n                        parent_pk_val = getattr(self, field.attname)\n                        if parent_pk_val != pk_val:\n                            intentional_reset = True\n                            break\n            \n            if not intentional_reset:\n                base_qs = cls._base_manager.using(using)\n                values = [(f, None, (getattr(self, f.attname) if raw else f.pre_save(self, False)))\n                          for f in non_pks]\n                forced_update = update_fields or force_update\n                updated = self._do_update(base_qs, using, pk_val, values, update_fields,\n                                          forced_update)\n            else:\n                updated = False\n",
      "\n        # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.\n        if pk_set and not force_insert:\n            base_qs = cls._base_manager.using(using)\n            values = [(f, None, (getattr(self, f.attname) if raw else f.pre_save(self, False)))\n                      for f in non_pks]\n            forced_update = update_fields or force_update\n            # Check if this is an inheritance scenario where PK was intentionally reset\n            # by comparing the current PK with what we expect after parent saves\n            pk_was_reset = getattr(self._state, '_pk_was_reset', False)\n            if not pk_was_reset:\n                updated = self._do_update(base_qs, using, pk_val, values, update_fields,\n                                          forced_update)\n            else:\n                updated = False\n",
      "\n        # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.\n        if pk_set and not force_insert:\n            # Check if this is an inheritance scenario where PK was intentionally reset\n            # by examining if we have parent links and the original PK state\n            is_inheritance_reset = (\n                hasattr(self, '_original_pk_was_none') and \n                getattr(self, '_original_pk_was_none', False) and\n                any(isinstance(f, OneToOneField) and f.primary_key for f in meta.parents.values())\n            )\n            \n            if not is_inheritance_reset:\n                base_qs = cls._base_manager.using(using)\n                values = [(f, None, (getattr(self, f.attname) if raw else f.pre_save(self, False)))\n                          for f in non_pks]\n                forced_update = update_fields or force_update\n                updated = self._do_update(base_qs, using, pk_val, values, update_fields,\n                                          forced_update)\n            else:\n                # Force INSERT for inheritance PK reset scenarios\n                updated = False\n",
      "\n        # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.\n        if pk_set and not force_insert:\n            # Check if this is an inheritance scenario where PK was intentionally reset\n            # by examining if we have a parent with the same PK value\n            is_pk_reset_scenario = False\n            if hasattr(self, '_state') and self._state.adding:\n                for parent_link in meta.parents.values():\n                    if parent_link and hasattr(self, parent_link.attname):\n                        parent_pk = getattr(self, parent_link.attname)\n                        if parent_pk == pk_val and parent_pk is not None:\n                            # This suggests the PK was restored from parent after being reset\n                            is_pk_reset_scenario = True\n                            break\n            \n            # Skip UPDATE attempt if this appears to be a reset scenario\n            if not is_pk_reset_scenario:\n                base_qs = cls._base_manager.using(using)\n                values = [(f, None, (getattr(self, f.attname) if raw else f.pre_save(self, False)))\n                          for f in non_pks]\n                forced_update = update_fields or force_update\n                updated = self._do_update(base_qs, using, pk_val, values, update_fields,\n                                          forced_update)\n            else:\n                updated = False\n",
      "\n        # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.\n        if pk_set and not force_insert:\n            # Check if this is an inheritance scenario where PK was intentionally reset\n            # If the instance was created with a PK but now has None, it might be a reset\n            pk_was_reset = (\n                hasattr(self, '_original_pk_before_save') and \n                self._original_pk_before_save is not None and \n                pk_val is None\n            )\n            \n            if not pk_was_reset:\n                base_qs = cls._base_manager.using(using)\n                values = [(f, None, (getattr(self, f.attname) if raw else f.pre_save(self, False)))\n                          for f in non_pks]\n                forced_update = update_fields or force_update\n                updated = self._do_update(base_qs, using, pk_val, values, update_fields,\n                                          forced_update)\n            else:\n                updated = False\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 844c01e95e..7ac554e2d6 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -804,9 +804,11 @@ class Model(metaclass=ModelBase):\n         inserted = False\n         for parent, field in meta.parents.items():\n             # Make sure the link fields are synced between parent and self.\n+\n             if (field and getattr(self, parent._meta.pk.attname) is None and\n                     getattr(self, field.attname) is not None):\n                 setattr(self, parent._meta.pk.attname, getattr(self, field.attname))\n+\n             parent_inserted = self._save_parents(cls=parent, using=using, update_fields=update_fields)\n             updated = self._save_table(\n                 cls=parent, using=using, update_fields=update_fields,\n@@ -814,9 +816,14 @@ class Model(metaclass=ModelBase):\n             )\n             if not updated:\n                 inserted = True\n+\n             # Set the parent's PK value to self.\n             if field:\n-                setattr(self, field.attname, self._get_pk_val(parent._meta))\n+                # Only restore parent PK if child PK wasn't intentionally reset to None\n+                # Check if this is a new object creation (child PK was None before parent save)\n+                child_pk_before_save = getattr(self, field.attname, None)\n+                if child_pk_before_save is not None or not inserted:\n+                    setattr(self, field.attname, self._get_pk_val(parent._meta))\n                 # Since we didn't have an instance of the parent handy set\n                 # attname directly, bypassing the descriptor. Invalidate\n                 # the related object cache, in case it's been accidentally\n@@ -839,6 +846,7 @@ class Model(metaclass=ModelBase):\n             non_pks = [f for f in non_pks\n                        if f.name in update_fields or f.attname in update_fields]\n \n+\n         pk_val = self._get_pk_val(meta)\n         if pk_val is None:\n             pk_val = meta.pk.get_pk_value_on_save(self)\n@@ -857,6 +865,7 @@ class Model(metaclass=ModelBase):\n         ):\n             force_insert = True\n         # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.\n+\n         if pk_set and not force_insert:\n             base_qs = cls._base_manager.using(using)\n             values = [(f, None, (getattr(self, f.attname) if raw else f.pre_save(self, False)))\n",
    "variant_0": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 844c01e95e..b835417b3b 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -804,6 +804,17 @@ class Model(metaclass=ModelBase):\n         inserted = False\n         for parent, field in meta.parents.items():\n             # Make sure the link fields are synced between parent and self.\n+\n+    def _save_parents(self, cls, using, update_fields):\n+        \"\"\"Save all the parents of cls using values from self.\"\"\"\n+        meta = cls._meta\n+        inserted = False\n+        for parent, field in meta.parents.items():\n+            # Store original child PK state to detect intentional resets\n+            original_child_pk = getattr(self, parent._meta.pk.attname) if field else None\n+            child_pk_was_none = original_child_pk is None\n+            \n+            # Make sure the link fields are synced between parent and self.\n             if (field and getattr(self, parent._meta.pk.attname) is None and\n                     getattr(self, field.attname) is not None):\n                 setattr(self, parent._meta.pk.attname, getattr(self, field.attname))\n@@ -814,9 +825,47 @@ class Model(metaclass=ModelBase):\n             )\n             if not updated:\n                 inserted = True\n+            # Set the parent's PK value to self, but only if child PK wasn't intentionally reset to None\n+            if field and not child_pk_was_none:\n+                setattr(self, field.attname, self._get_pk_val(parent._meta))\n+\n+    def _save_parents(self, cls, using, update_fields):\n+        \"\"\"Save all the parents of cls using values from self.\"\"\"\n+        meta = cls._meta\n+        inserted = False\n+        # Check if this is an intentional PK reset by storing original PK state\n+        original_pk_was_none = self._get_pk_val(meta) is None\n+        \n+        for parent, field in meta.parents.items():\n+            # Make sure the link fields are synced between parent and self.\n+            if (field and getattr(self, parent._meta.pk.attname) is None and\n+                    getattr(self, field.attname) is not None):\n+                setattr(self, parent._meta.pk.attname, getattr(self, field.attname))\n+            parent_inserted = self._save_parents(cls=parent, using=using, update_fields=update_fields)\n+            updated = self._save_table(\n+                cls=parent, using=using, update_fields=update_fields,\n+                force_insert=parent_inserted,\n+            )\n+            if not updated:\n+                inserted = True\n+            # Set the parent's PK value to self, but only if this wasn't an intentional PK reset\n+            if field and not (original_pk_was_none and self._get_pk_val(meta) is None):\n+                setattr(self, field.attname, self._get_pk_val(parent._meta))\n+                # Since we didn't have an instance of the parent handy set\n+                # attname directly, bypassing the descriptor. Invalidate\n+                # the related object cache, in case it's been accidentally\n+                # populated. A fresh instance will be re-built from the\n+                # database if necessary.\n+                if field.is_cached(self):\n+                    field.delete_cached_value(self)\n+\n             # Set the parent's PK value to self.\n             if field:\n-                setattr(self, field.attname, self._get_pk_val(parent._meta))\n+                # Only restore the parent's PK if the child's PK wasn't intentionally reset to None\n+                # Check if the field was None before we started the parent save process\n+                child_pk_before_save = getattr(self, field.attname, None)\n+                if child_pk_before_save is not None or not hasattr(self, '_pk_was_reset'):\n+                    setattr(self, field.attname, self._get_pk_val(parent._meta))\n                 # Since we didn't have an instance of the parent handy set\n                 # attname directly, bypassing the descriptor. Invalidate\n                 # the related object cache, in case it's been accidentally\n@@ -839,11 +888,15 @@ class Model(metaclass=ModelBase):\n             non_pks = [f for f in non_pks\n                        if f.name in update_fields or f.attname in update_fields]\n \n+\n         pk_val = self._get_pk_val(meta)\n+        # Check if PK was intentionally reset to None for creating a new object\n+        pk_was_reset = hasattr(self, '_pk_was_reset') and getattr(self, '_pk_was_reset', False)\n+        \n         if pk_val is None:\n             pk_val = meta.pk.get_pk_value_on_save(self)\n             setattr(self, meta.pk.attname, pk_val)\n-        pk_set = pk_val is not None\n+        pk_set = pk_val is not None and not pk_was_reset\n         if not pk_set and (force_update or update_fields):\n             raise ValueError(\"Cannot force an update in save() with no primary key.\")\n         updated = False\n@@ -857,13 +910,21 @@ class Model(metaclass=ModelBase):\n         ):\n             force_insert = True\n         # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.\n+\n+        # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.\n         if pk_set and not force_insert:\n             base_qs = cls._base_manager.using(using)\n             values = [(f, None, (getattr(self, f.attname) if raw else f.pre_save(self, False)))\n                       for f in non_pks]\n             forced_update = update_fields or force_update\n-            updated = self._do_update(base_qs, using, pk_val, values, update_fields,\n-                                      forced_update)\n+            # Check if this is an inheritance scenario where PK was intentionally reset\n+            pk_was_reset = getattr(self, '_pk_was_reset', False)\n+            if not pk_was_reset:\n+                updated = self._do_update(base_qs, using, pk_val, values, update_fields,\n+                                          forced_update)\n+            else:\n+                # Skip UPDATE attempt if PK was intentionally reset for new object creation\n+                updated = 0\n             if force_update and not updated:\n                 raise DatabaseError(\"Forced update did not affect any rows.\")\n             if update_fields and not updated:\n",
    "variant_1": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 844c01e95e..32ca9bb0f8 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -798,6 +798,13 @@ class Model(metaclass=ModelBase):\n \n     save_base.alters_data = True\n \n+    def _save_parents(self, cls, using, update_fields):\n+        \"\"\"Save all the parents of cls using values from self.\"\"\"\n+        meta = cls._meta\n+        inserted = False\n+        for parent, field in meta.parents.items():\n+            # Make sure the link fields are synced between parent and self.\n+\n     def _save_parents(self, cls, using, update_fields):\n         \"\"\"Save all the parents of cls using values from self.\"\"\"\n         meta = cls._meta\n@@ -815,7 +822,32 @@ class Model(metaclass=ModelBase):\n             if not updated:\n                 inserted = True\n             # Set the parent's PK value to self.\n+            # Only restore parent PK if child PK wasn't intentionally reset to None\n             if field:\n+                child_pk_was_none = getattr(self, field.attname) is None\n+                if not child_pk_was_none:\n+                    setattr(self, field.attname, self._get_pk_val(parent._meta))\n+\n+    def _save_parents(self, cls, using, update_fields):\n+        \"\"\"Save all the parents of cls using values from self.\"\"\"\n+        meta = cls._meta\n+        inserted = False\n+        # Track if the primary key was intentionally reset to None\n+        pk_was_reset = getattr(self, '_pk_was_reset', False)\n+        for parent, field in meta.parents.items():\n+            # Make sure the link fields are synced between parent and self.\n+            if (field and getattr(self, parent._meta.pk.attname) is None and\n+                    getattr(self, field.attname) is not None):\n+                setattr(self, parent._meta.pk.attname, getattr(self, field.attname))\n+            parent_inserted = self._save_parents(cls=parent, using=using, update_fields=update_fields)\n+            updated = self._save_table(\n+                cls=parent, using=using, update_fields=update_fields,\n+                force_insert=parent_inserted,\n+            )\n+            if not updated:\n+                inserted = True\n+            # Set the parent's PK value to self, but only if PK wasn't intentionally reset\n+            if field and not pk_was_reset:\n                 setattr(self, field.attname, self._get_pk_val(parent._meta))\n                 # Since we didn't have an instance of the parent handy set\n                 # attname directly, bypassing the descriptor. Invalidate\n@@ -824,6 +856,28 @@ class Model(metaclass=ModelBase):\n                 # database if necessary.\n                 if field.is_cached(self):\n                     field.delete_cached_value(self)\n+\n+            # Set the parent's PK value to self.\n+            if field:\n+                # Only restore parent PK if child PK wasn't intentionally reset to None\n+                # Check if the child's PK was None before saving parents and is still None\n+                child_pk_before_save = getattr(self, self._meta.pk.attname, None)\n+                if child_pk_before_save is not None or not hasattr(self, '_pk_was_reset'):\n+                    setattr(self, field.attname, self._get_pk_val(parent._meta))\n+                # Since we didn't have an instance of the parent handy set\n+                # attname directly, bypassing the descriptor. Invalidate\n+                # the related object cache, in case it's been accidentally\n+                # populated. A fresh instance will be re-built from the\n+                # database if necessary.\n+                if field.is_cached(self):\n+                    field.delete_cached_value(self)\n+                # Since we didn't have an instance of the parent handy set\n+                # attname directly, bypassing the descriptor. Invalidate\n+                # the related object cache, in case it's been accidentally\n+                # populated. A fresh instance will be re-built from the\n+                # database if necessary.\n+                if field.is_cached(self):\n+                    field.delete_cached_value(self)\n         return inserted\n \n     def _save_table(self, raw=False, cls=None, force_insert=False,\n@@ -839,11 +893,17 @@ class Model(metaclass=ModelBase):\n             non_pks = [f for f in non_pks\n                        if f.name in update_fields or f.attname in update_fields]\n \n+\n         pk_val = self._get_pk_val(meta)\n+        # Check if PK was intentionally reset to None for creating a new object\n+        pk_was_reset = (pk_val is None and \n+                       hasattr(self, '_pk_reset_for_new_object') and \n+                       self._pk_reset_for_new_object)\n+        \n         if pk_val is None:\n             pk_val = meta.pk.get_pk_value_on_save(self)\n             setattr(self, meta.pk.attname, pk_val)\n-        pk_set = pk_val is not None\n+        pk_set = pk_val is not None or pk_was_reset\n         if not pk_set and (force_update or update_fields):\n             raise ValueError(\"Cannot force an update in save() with no primary key.\")\n         updated = False\n@@ -857,13 +917,27 @@ class Model(metaclass=ModelBase):\n         ):\n             force_insert = True\n         # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.\n+\n+        # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.\n         if pk_set and not force_insert:\n-            base_qs = cls._base_manager.using(using)\n-            values = [(f, None, (getattr(self, f.attname) if raw else f.pre_save(self, False)))\n-                      for f in non_pks]\n-            forced_update = update_fields or force_update\n-            updated = self._do_update(base_qs, using, pk_val, values, update_fields,\n-                                      forced_update)\n+            # Check if this is an inheritance scenario where PK was intentionally reset\n+            # by examining if we have parent links and the PK was None before _save_parents\n+            is_inheritance_reset = (\n+                hasattr(self, '_original_pk_was_none') and \n+                getattr(self, '_original_pk_was_none', False) and\n+                any(hasattr(self, f.name) for f in meta.parents.values())\n+            )\n+            \n+            if not is_inheritance_reset:\n+                base_qs = cls._base_manager.using(using)\n+                values = [(f, None, (getattr(self, f.attname) if raw else f.pre_save(self, False)))\n+                          for f in non_pks]\n+                forced_update = update_fields or force_update\n+                updated = self._do_update(base_qs, using, pk_val, values, update_fields,\n+                                          forced_update)\n+            else:\n+                # Force INSERT for inheritance reset scenarios\n+                updated = False\n             if force_update and not updated:\n                 raise DatabaseError(\"Forced update did not affect any rows.\")\n             if update_fields and not updated:\n",
    "variant_2": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 844c01e95e..597e6f361a 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -798,6 +798,13 @@ class Model(metaclass=ModelBase):\n \n     save_base.alters_data = True\n \n+    def _save_parents(self, cls, using, update_fields):\n+        \"\"\"Save all the parents of cls using values from self.\"\"\"\n+        meta = cls._meta\n+        inserted = False\n+        for parent, field in meta.parents.items():\n+            # Make sure the link fields are synced between parent and self.\n+\n     def _save_parents(self, cls, using, update_fields):\n         \"\"\"Save all the parents of cls using values from self.\"\"\"\n         meta = cls._meta\n@@ -814,8 +821,35 @@ class Model(metaclass=ModelBase):\n             )\n             if not updated:\n                 inserted = True\n-            # Set the parent's PK value to self.\n+            # Set the parent's PK value to self, but only if the child's PK wasn't intentionally reset.\n             if field:\n+                # Check if this is a new object creation (child PK was None before parent save)\n+                child_pk_was_none = getattr(self, field.attname) is None\n+                if not child_pk_was_none:\n+                    setattr(self, field.attname, self._get_pk_val(parent._meta))\n+\n+    def _save_parents(self, cls, using, update_fields):\n+        \"\"\"Save all the parents of cls using values from self.\"\"\"\n+        meta = cls._meta\n+        inserted = False\n+        # Check if the primary key was intentionally reset to None\n+        pk_was_reset = (getattr(self, self._meta.pk.attname) is None and \n+                       hasattr(self, '_state') and self._state.adding is False)\n+        \n+        for parent, field in meta.parents.items():\n+            # Make sure the link fields are synced between parent and self.\n+            if (field and getattr(self, parent._meta.pk.attname) is None and\n+                    getattr(self, field.attname) is not None):\n+                setattr(self, parent._meta.pk.attname, getattr(self, field.attname))\n+            parent_inserted = self._save_parents(cls=parent, using=using, update_fields=update_fields)\n+            updated = self._save_table(\n+                cls=parent, using=using, update_fields=update_fields,\n+                force_insert=parent_inserted,\n+            )\n+            if not updated:\n+                inserted = True\n+            # Set the parent's PK value to self, but only if PK wasn't intentionally reset\n+            if field and not pk_was_reset:\n                 setattr(self, field.attname, self._get_pk_val(parent._meta))\n                 # Since we didn't have an instance of the parent handy set\n                 # attname directly, bypassing the descriptor. Invalidate\n@@ -824,6 +858,28 @@ class Model(metaclass=ModelBase):\n                 # database if necessary.\n                 if field.is_cached(self):\n                     field.delete_cached_value(self)\n+\n+            # Set the parent's PK value to self.\n+            if field:\n+                # Only restore parent PK if child PK wasn't intentionally reset to None\n+                # Check if the field was None before _save_parents and is still None\n+                current_pk = getattr(self, field.attname)\n+                if current_pk is not None or not hasattr(self, '_pk_was_reset'):\n+                    setattr(self, field.attname, self._get_pk_val(parent._meta))\n+                # Since we didn't have an instance of the parent handy set\n+                # attname directly, bypassing the descriptor. Invalidate\n+                # the related object cache, in case it's been accidentally\n+                # populated. A fresh instance will be re-built from the\n+                # database if necessary.\n+                if field.is_cached(self):\n+                    field.delete_cached_value(self)\n+                # Since we didn't have an instance of the parent handy set\n+                # attname directly, bypassing the descriptor. Invalidate\n+                # the related object cache, in case it's been accidentally\n+                # populated. A fresh instance will be re-built from the\n+                # database if necessary.\n+                if field.is_cached(self):\n+                    field.delete_cached_value(self)\n         return inserted\n \n     def _save_table(self, raw=False, cls=None, force_insert=False,\n@@ -839,11 +895,17 @@ class Model(metaclass=ModelBase):\n             non_pks = [f for f in non_pks\n                        if f.name in update_fields or f.attname in update_fields]\n \n+\n         pk_val = self._get_pk_val(meta)\n+        # Check if PK was intentionally reset to None for creating new object\n+        pk_was_reset = (pk_val is None and \n+                       hasattr(self, '_pk_reset_for_new_object') and \n+                       self._pk_reset_for_new_object)\n+        \n         if pk_val is None:\n             pk_val = meta.pk.get_pk_value_on_save(self)\n             setattr(self, meta.pk.attname, pk_val)\n-        pk_set = pk_val is not None\n+        pk_set = pk_val is not None and not pk_was_reset\n         if not pk_set and (force_update or update_fields):\n             raise ValueError(\"Cannot force an update in save() with no primary key.\")\n         updated = False\n@@ -857,13 +919,25 @@ class Model(metaclass=ModelBase):\n         ):\n             force_insert = True\n         # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.\n+\n+        # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.\n         if pk_set and not force_insert:\n             base_qs = cls._base_manager.using(using)\n             values = [(f, None, (getattr(self, f.attname) if raw else f.pre_save(self, False)))\n                       for f in non_pks]\n             forced_update = update_fields or force_update\n-            updated = self._do_update(base_qs, using, pk_val, values, update_fields,\n-                                      forced_update)\n+            # Check if this is an inheritance scenario where PK was intentionally reset\n+            # In such cases, we should not attempt an UPDATE even if pk_set is True\n+            is_inheritance_reset = (\n+                hasattr(self, '_state') and \n+                getattr(self._state, '_pk_was_reset', False) and\n+                self._meta.parents\n+            )\n+            if not is_inheritance_reset:\n+                updated = self._do_update(base_qs, using, pk_val, values, update_fields,\n+                                        forced_update)\n+            else:\n+                updated = False\n             if force_update and not updated:\n                 raise DatabaseError(\"Forced update did not affect any rows.\")\n             if update_fields and not updated:\n",
    "variant_3": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 844c01e95e..f1fab88acd 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -802,6 +802,16 @@ class Model(metaclass=ModelBase):\n         \"\"\"Save all the parents of cls using values from self.\"\"\"\n         meta = cls._meta\n         inserted = False\n+        for parent, field in meta.parents.items():\n+            # Make sure the link fields are synced between parent and self.\n+\n+    def _save_parents(self, cls, using, update_fields):\n+        \"\"\"Save all the parents of cls using values from self.\"\"\"\n+        meta = cls._meta\n+        inserted = False\n+        # Track if the primary key was intentionally reset to None\n+        pk_was_reset = getattr(self, meta.pk.attname) is None\n+        \n         for parent, field in meta.parents.items():\n             # Make sure the link fields are synced between parent and self.\n             if (field and getattr(self, parent._meta.pk.attname) is None and\n@@ -814,9 +824,48 @@ class Model(metaclass=ModelBase):\n             )\n             if not updated:\n                 inserted = True\n+            # Set the parent's PK value to self, but only if we didn't intentionally reset it\n+            if field and not pk_was_reset:\n+                setattr(self, field.attname, self._get_pk_val(parent._meta))\n+\n+def _save_parents(self, cls, using, update_fields):\n+    \"\"\"Save all the parents of cls using values from self.\"\"\"\n+    meta = cls._meta\n+    inserted = False\n+    for parent, field in meta.parents.items():\n+        # Make sure the link fields are synced between parent and self.\n+        if (field and getattr(self, parent._meta.pk.attname) is None and\n+                getattr(self, field.attname) is not None):\n+            setattr(self, parent._meta.pk.attname, getattr(self, field.attname))\n+        parent_inserted = self._save_parents(cls=parent, using=using, update_fields=update_fields)\n+        updated = self._save_table(\n+            cls=parent, using=using, update_fields=update_fields,\n+            force_insert=parent_inserted,\n+        )\n+        if not updated:\n+            inserted = True\n+        # Set the parent's PK value to self, but only if we didn't intentionally reset it\n+        if field:\n+            # Check if the primary key was intentionally set to None for this save operation\n+            pk_was_reset = (hasattr(self, '_state') and \n+                           getattr(self._state, 'pk_was_reset', False))\n+            if not pk_was_reset:\n+                setattr(self, field.attname, self._get_pk_val(parent._meta))\n+                # Since we didn't have an instance of the parent handy set\n+                # attname directly, bypassing the descriptor. Invalidate\n+                # the related object cache, in case it's been accidentally\n+                # populated. A fresh instance will be re-built from the\n+                # database if necessary.\n+                if field.is_cached(self):\n+                    field.delete_cached_value(self)\n+\n             # Set the parent's PK value to self.\n             if field:\n-                setattr(self, field.attname, self._get_pk_val(parent._meta))\n+                # Only restore parent PK if child PK wasn't intentionally reset to None\n+                # Check if the field was explicitly set to None before save operation\n+                current_pk = getattr(self, field.attname)\n+                if current_pk is not None:\n+                    setattr(self, field.attname, self._get_pk_val(parent._meta))\n                 # Since we didn't have an instance of the parent handy set\n                 # attname directly, bypassing the descriptor. Invalidate\n                 # the related object cache, in case it's been accidentally\n@@ -839,7 +888,15 @@ class Model(metaclass=ModelBase):\n             non_pks = [f for f in non_pks\n                        if f.name in update_fields or f.attname in update_fields]\n \n+\n         pk_val = self._get_pk_val(meta)\n+        # Check if this is an intentional PK reset for creating a new object\n+        pk_was_intentionally_reset = (\n+            pk_val is None and \n+            hasattr(self, '_pk_reset_for_new_object') and \n+            self._pk_reset_for_new_object\n+        )\n+        \n         if pk_val is None:\n             pk_val = meta.pk.get_pk_value_on_save(self)\n             setattr(self, meta.pk.attname, pk_val)\n@@ -857,13 +914,20 @@ class Model(metaclass=ModelBase):\n         ):\n             force_insert = True\n         # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.\n+\n+        # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.\n         if pk_set and not force_insert:\n             base_qs = cls._base_manager.using(using)\n             values = [(f, None, (getattr(self, f.attname) if raw else f.pre_save(self, False)))\n                       for f in non_pks]\n             forced_update = update_fields or force_update\n-            updated = self._do_update(base_qs, using, pk_val, values, update_fields,\n-                                      forced_update)\n+            # Check if this is an inheritance scenario where PK was reset\n+            # In such cases, we should prefer INSERT over UPDATE\n+            if hasattr(self, '_pk_was_reset') and self._pk_was_reset:\n+                updated = False\n+            else:\n+                updated = self._do_update(base_qs, using, pk_val, values, update_fields,\n+                                          forced_update)\n             if force_update and not updated:\n                 raise DatabaseError(\"Forced update did not affect any rows.\")\n             if update_fields and not updated:\n",
    "variant_4": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 844c01e95e..0aad734f03 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -798,6 +798,13 @@ class Model(metaclass=ModelBase):\n \n     save_base.alters_data = True\n \n+    def _save_parents(self, cls, using, update_fields):\n+        \"\"\"Save all the parents of cls using values from self.\"\"\"\n+        meta = cls._meta\n+        inserted = False\n+        for parent, field in meta.parents.items():\n+            # Make sure the link fields are synced between parent and self.\n+\n     def _save_parents(self, cls, using, update_fields):\n         \"\"\"Save all the parents of cls using values from self.\"\"\"\n         meta = cls._meta\n@@ -814,8 +821,36 @@ class Model(metaclass=ModelBase):\n             )\n             if not updated:\n                 inserted = True\n-            # Set the parent's PK value to self.\n+            # Set the parent's PK value to self, but only if child PK wasn't intentionally reset\n             if field:\n+                # Check if the child's PK was intentionally set to None for creating a new object\n+                child_pk_val = self._get_pk_val(meta)\n+                if child_pk_val is not None:\n+                    # Only restore parent PK if child PK wasn't reset to None\n+                    setattr(self, field.attname, self._get_pk_val(parent._meta))\n+\n+    def _save_parents(self, cls, using, update_fields):\n+        \"\"\"Save all the parents of cls using values from self.\"\"\"\n+        meta = cls._meta\n+        inserted = False\n+        # Track if the primary key was intentionally reset to None\n+        pk_was_reset = getattr(self, '_pk_was_reset', False)\n+        original_pk = self._get_pk_val()\n+        \n+        for parent, field in meta.parents.items():\n+            # Make sure the link fields are synced between parent and self.\n+            if (field and getattr(self, parent._meta.pk.attname) is None and\n+                    getattr(self, field.attname) is not None):\n+                setattr(self, parent._meta.pk.attname, getattr(self, field.attname))\n+            parent_inserted = self._save_parents(cls=parent, using=using, update_fields=update_fields)\n+            updated = self._save_table(\n+                cls=parent, using=using, update_fields=update_fields,\n+                force_insert=parent_inserted,\n+            )\n+            if not updated:\n+                inserted = True\n+            # Set the parent's PK value to self only if PK wasn't intentionally reset.\n+            if field and not (pk_was_reset and original_pk is None):\n                 setattr(self, field.attname, self._get_pk_val(parent._meta))\n                 # Since we didn't have an instance of the parent handy set\n                 # attname directly, bypassing the descriptor. Invalidate\n@@ -824,6 +859,28 @@ class Model(metaclass=ModelBase):\n                 # database if necessary.\n                 if field.is_cached(self):\n                     field.delete_cached_value(self)\n+\n+            # Set the parent's PK value to self.\n+            if field:\n+                # Only restore parent PK if child PK wasn't intentionally reset to None\n+                # Check if the field was explicitly set to None before the save operation\n+                child_pk_before_save = getattr(self, field.attname, None)\n+                if child_pk_before_save is not None or not hasattr(self, '_pk_was_reset'):\n+                    setattr(self, field.attname, self._get_pk_val(parent._meta))\n+                # Since we didn't have an instance of the parent handy set\n+                # attname directly, bypassing the descriptor. Invalidate\n+                # the related object cache, in case it's been accidentally\n+                # populated. A fresh instance will be re-built from the\n+                # database if necessary.\n+                if field.is_cached(self):\n+                    field.delete_cached_value(self)\n+                # Since we didn't have an instance of the parent handy set\n+                # attname directly, bypassing the descriptor. Invalidate\n+                # the related object cache, in case it's been accidentally\n+                # populated. A fresh instance will be re-built from the\n+                # database if necessary.\n+                if field.is_cached(self):\n+                    field.delete_cached_value(self)\n         return inserted\n \n     def _save_table(self, raw=False, cls=None, force_insert=False,\n@@ -839,11 +896,15 @@ class Model(metaclass=ModelBase):\n             non_pks = [f for f in non_pks\n                        if f.name in update_fields or f.attname in update_fields]\n \n+\n         pk_val = self._get_pk_val(meta)\n+        # Check if PK was intentionally reset to None for creating a new object\n+        pk_was_reset = hasattr(self, '_pk_was_reset') and self._pk_was_reset\n         if pk_val is None:\n             pk_val = meta.pk.get_pk_value_on_save(self)\n             setattr(self, meta.pk.attname, pk_val)\n-        pk_set = pk_val is not None\n+        # Don't consider PK as set if it was intentionally reset\n+        pk_set = pk_val is not None and not pk_was_reset\n         if not pk_set and (force_update or update_fields):\n             raise ValueError(\"Cannot force an update in save() with no primary key.\")\n         updated = False\n@@ -857,13 +918,30 @@ class Model(metaclass=ModelBase):\n         ):\n             force_insert = True\n         # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.\n+\n+        # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.\n         if pk_set and not force_insert:\n-            base_qs = cls._base_manager.using(using)\n-            values = [(f, None, (getattr(self, f.attname) if raw else f.pre_save(self, False)))\n-                      for f in non_pks]\n-            forced_update = update_fields or force_update\n-            updated = self._do_update(base_qs, using, pk_val, values, update_fields,\n-                                      forced_update)\n+            # Check if this is an inheritance scenario where PK was intentionally reset\n+            # by examining if we have a parent with a different PK than ours\n+            intentional_reset = False\n+            if hasattr(self, '_state') and hasattr(self._state, 'adding'):\n+                # Check if any parent model has a PK that differs from ours\n+                for parent, field in meta.parents.items():\n+                    if field and hasattr(self, field.attname):\n+                        parent_pk_val = getattr(self, field.attname)\n+                        if parent_pk_val != pk_val:\n+                            intentional_reset = True\n+                            break\n+            \n+            if not intentional_reset:\n+                base_qs = cls._base_manager.using(using)\n+                values = [(f, None, (getattr(self, f.attname) if raw else f.pre_save(self, False)))\n+                          for f in non_pks]\n+                forced_update = update_fields or force_update\n+                updated = self._do_update(base_qs, using, pk_val, values, update_fields,\n+                                          forced_update)\n+            else:\n+                updated = False\n             if force_update and not updated:\n                 raise DatabaseError(\"Forced update did not affect any rows.\")\n             if update_fields and not updated:\n",
    "variant_5": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 844c01e95e..16f0430623 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -798,6 +798,13 @@ class Model(metaclass=ModelBase):\n \n     save_base.alters_data = True\n \n+    def _save_parents(self, cls, using, update_fields):\n+        \"\"\"Save all the parents of cls using values from self.\"\"\"\n+        meta = cls._meta\n+        inserted = False\n+        for parent, field in meta.parents.items():\n+            # Make sure the link fields are synced between parent and self.\n+\n     def _save_parents(self, cls, using, update_fields):\n         \"\"\"Save all the parents of cls using values from self.\"\"\"\n         meta = cls._meta\n@@ -814,9 +821,55 @@ class Model(metaclass=ModelBase):\n             )\n             if not updated:\n                 inserted = True\n+            # Set the parent's PK value to self, but only if the child's PK wasn't intentionally reset.\n+            if field:\n+                child_pk_was_none = getattr(self, field.attname) is None\n+                parent_pk_val = self._get_pk_val(parent._meta)\n+                # Only restore parent PK if child PK wasn't explicitly set to None for creating new object\n+                if not child_pk_was_none or parent_pk_val is None:\n+                    setattr(self, field.attname, parent_pk_val)\n+\n+    def _save_parents(self, cls, using, update_fields):\n+        \"\"\"Save all the parents of cls using values from self.\"\"\"\n+        meta = cls._meta\n+        inserted = False\n+        for parent, field in meta.parents.items():\n+            # Make sure the link fields are synced between parent and self.\n+            if (field and getattr(self, parent._meta.pk.attname) is None and\n+                    getattr(self, field.attname) is not None):\n+                setattr(self, parent._meta.pk.attname, getattr(self, field.attname))\n+            \n+            # Store the current PK value to detect if it was intentionally reset\n+            original_pk = getattr(self, meta.pk.attname)\n+            \n+            parent_inserted = self._save_parents(cls=parent, using=using, update_fields=update_fields)\n+            updated = self._save_table(\n+                cls=parent, using=using, update_fields=update_fields,\n+                force_insert=parent_inserted,\n+            )\n+            if not updated:\n+                inserted = True\n+            # Set the parent's PK value to self only if the original PK wasn't intentionally reset to None.\n+            if field:\n+                # If the original PK was None (indicating a reset for new object creation),\n+                # don't restore the parent PK to maintain the intent to create a new object\n+                if original_pk is not None:\n+                    setattr(self, field.attname, self._get_pk_val(parent._meta))\n+                    # Since we didn't have an instance of the parent handy set\n+                    # attname directly, bypassing the descriptor. Invalidate\n+                    # the related object cache, in case it's been accidentally\n+                    # populated. A fresh instance will be re-built from the\n+                    # database if necessary.\n+                    if field.is_cached(self):\n+                        field.delete_cached_value(self)\n+\n             # Set the parent's PK value to self.\n             if field:\n-                setattr(self, field.attname, self._get_pk_val(parent._meta))\n+                # Only restore the parent PK if we didn't intentionally reset our PK to None\n+                # This preserves the user's intent when calling reset() followed by save()\n+                original_pk = getattr(self, field.attname)\n+                if original_pk is not None or not hasattr(self, '_pk_was_reset'):\n+                    setattr(self, field.attname, self._get_pk_val(parent._meta))\n                 # Since we didn't have an instance of the parent handy set\n                 # attname directly, bypassing the descriptor. Invalidate\n                 # the related object cache, in case it's been accidentally\n@@ -839,11 +892,18 @@ class Model(metaclass=ModelBase):\n             non_pks = [f for f in non_pks\n                        if f.name in update_fields or f.attname in update_fields]\n \n+\n         pk_val = self._get_pk_val(meta)\n+        # Check if PK was intentionally reset to None for creating a new object\n+        pk_was_reset = (pk_val is None and \n+                       hasattr(self, '_state') and \n+                       not self._state.adding and\n+                       getattr(self, '_pk_was_reset', False))\n+        \n         if pk_val is None:\n             pk_val = meta.pk.get_pk_value_on_save(self)\n             setattr(self, meta.pk.attname, pk_val)\n-        pk_set = pk_val is not None\n+        pk_set = pk_val is not None or pk_was_reset\n         if not pk_set and (force_update or update_fields):\n             raise ValueError(\"Cannot force an update in save() with no primary key.\")\n         updated = False\n@@ -857,13 +917,21 @@ class Model(metaclass=ModelBase):\n         ):\n             force_insert = True\n         # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.\n+\n+        # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.\n         if pk_set and not force_insert:\n             base_qs = cls._base_manager.using(using)\n             values = [(f, None, (getattr(self, f.attname) if raw else f.pre_save(self, False)))\n                       for f in non_pks]\n             forced_update = update_fields or force_update\n-            updated = self._do_update(base_qs, using, pk_val, values, update_fields,\n-                                      forced_update)\n+            # Check if this is an inheritance scenario where PK was intentionally reset\n+            # by comparing the current PK with what we expect after parent saves\n+            pk_was_reset = getattr(self._state, '_pk_was_reset', False)\n+            if not pk_was_reset:\n+                updated = self._do_update(base_qs, using, pk_val, values, update_fields,\n+                                          forced_update)\n+            else:\n+                updated = False\n             if force_update and not updated:\n                 raise DatabaseError(\"Forced update did not affect any rows.\")\n             if update_fields and not updated:\n",
    "variant_6": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 844c01e95e..10699c62a9 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -798,6 +798,13 @@ class Model(metaclass=ModelBase):\n \n     save_base.alters_data = True\n \n+    def _save_parents(self, cls, using, update_fields):\n+        \"\"\"Save all the parents of cls using values from self.\"\"\"\n+        meta = cls._meta\n+        inserted = False\n+        for parent, field in meta.parents.items():\n+            # Make sure the link fields are synced between parent and self.\n+\n     def _save_parents(self, cls, using, update_fields):\n         \"\"\"Save all the parents of cls using values from self.\"\"\"\n         meta = cls._meta\n@@ -816,6 +823,32 @@ class Model(metaclass=ModelBase):\n                 inserted = True\n             # Set the parent's PK value to self.\n             if field:\n+                # Only restore parent PK if child PK wasn't intentionally reset to None\n+                child_pk_val = self._get_pk_val(meta)\n+                if child_pk_val is not None:\n+                    setattr(self, field.attname, self._get_pk_val(parent._meta))\n+\n+    def _save_parents(self, cls, using, update_fields):\n+        \"\"\"Save all the parents of cls using values from self.\"\"\"\n+        meta = cls._meta\n+        inserted = False\n+        # Track if this instance's PK was intentionally reset to None\n+        pk_was_reset = getattr(self, '_pk_was_reset', False)\n+        \n+        for parent, field in meta.parents.items():\n+            # Make sure the link fields are synced between parent and self.\n+            if (field and getattr(self, parent._meta.pk.attname) is None and\n+                    getattr(self, field.attname) is not None):\n+                setattr(self, parent._meta.pk.attname, getattr(self, field.attname))\n+            parent_inserted = self._save_parents(cls=parent, using=using, update_fields=update_fields)\n+            updated = self._save_table(\n+                cls=parent, using=using, update_fields=update_fields,\n+                force_insert=parent_inserted,\n+            )\n+            if not updated:\n+                inserted = True\n+            # Set the parent's PK value to self, but only if PK wasn't intentionally reset\n+            if field and not pk_was_reset:\n                 setattr(self, field.attname, self._get_pk_val(parent._meta))\n                 # Since we didn't have an instance of the parent handy set\n                 # attname directly, bypassing the descriptor. Invalidate\n@@ -824,6 +857,28 @@ class Model(metaclass=ModelBase):\n                 # database if necessary.\n                 if field.is_cached(self):\n                     field.delete_cached_value(self)\n+\n+            # Set the parent's PK value to self.\n+            if field:\n+                # Only restore parent PK if child PK wasn't intentionally reset to None\n+                # Check if this is a new object creation (force_insert or PK was None before save)\n+                child_pk_before_save = getattr(self, self._meta.pk.attname, None)\n+                if not (force_insert or child_pk_before_save is None):\n+                    setattr(self, field.attname, self._get_pk_val(parent._meta))\n+                    # Since we didn't have an instance of the parent handy set\n+                    # attname directly, bypassing the descriptor. Invalidate\n+                    # the related object cache, in case it's been accidentally\n+                    # populated. A fresh instance will be re-built from the\n+                    # database if necessary.\n+                    if field.is_cached(self):\n+                        field.delete_cached_value(self)\n+                # Since we didn't have an instance of the parent handy set\n+                # attname directly, bypassing the descriptor. Invalidate\n+                # the related object cache, in case it's been accidentally\n+                # populated. A fresh instance will be re-built from the\n+                # database if necessary.\n+                if field.is_cached(self):\n+                    field.delete_cached_value(self)\n         return inserted\n \n     def _save_table(self, raw=False, cls=None, force_insert=False,\n@@ -839,7 +894,13 @@ class Model(metaclass=ModelBase):\n             non_pks = [f for f in non_pks\n                        if f.name in update_fields or f.attname in update_fields]\n \n+\n         pk_val = self._get_pk_val(meta)\n+        # Check if PK was intentionally reset to None for creating a new object\n+        pk_was_reset = (pk_val is None and \n+                       hasattr(self, '_pk_was_reset_for_new_object') and \n+                       self._pk_was_reset_for_new_object)\n+        \n         if pk_val is None:\n             pk_val = meta.pk.get_pk_value_on_save(self)\n             setattr(self, meta.pk.attname, pk_val)\n@@ -857,13 +918,27 @@ class Model(metaclass=ModelBase):\n         ):\n             force_insert = True\n         # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.\n+\n+        # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.\n         if pk_set and not force_insert:\n-            base_qs = cls._base_manager.using(using)\n-            values = [(f, None, (getattr(self, f.attname) if raw else f.pre_save(self, False)))\n-                      for f in non_pks]\n-            forced_update = update_fields or force_update\n-            updated = self._do_update(base_qs, using, pk_val, values, update_fields,\n-                                      forced_update)\n+            # Check if this is an inheritance scenario where PK was intentionally reset\n+            # by examining if we have parent links and the original PK state\n+            is_inheritance_reset = (\n+                hasattr(self, '_original_pk_was_none') and \n+                getattr(self, '_original_pk_was_none', False) and\n+                any(isinstance(f, OneToOneField) and f.primary_key for f in meta.parents.values())\n+            )\n+            \n+            if not is_inheritance_reset:\n+                base_qs = cls._base_manager.using(using)\n+                values = [(f, None, (getattr(self, f.attname) if raw else f.pre_save(self, False)))\n+                          for f in non_pks]\n+                forced_update = update_fields or force_update\n+                updated = self._do_update(base_qs, using, pk_val, values, update_fields,\n+                                          forced_update)\n+            else:\n+                # Force INSERT for inheritance PK reset scenarios\n+                updated = False\n             if force_update and not updated:\n                 raise DatabaseError(\"Forced update did not affect any rows.\")\n             if update_fields and not updated:\n",
    "variant_7": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 844c01e95e..4ada8784b7 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -798,6 +798,13 @@ class Model(metaclass=ModelBase):\n \n     save_base.alters_data = True\n \n+    def _save_parents(self, cls, using, update_fields):\n+        \"\"\"Save all the parents of cls using values from self.\"\"\"\n+        meta = cls._meta\n+        inserted = False\n+        for parent, field in meta.parents.items():\n+            # Make sure the link fields are synced between parent and self.\n+\n     def _save_parents(self, cls, using, update_fields):\n         \"\"\"Save all the parents of cls using values from self.\"\"\"\n         meta = cls._meta\n@@ -816,6 +823,35 @@ class Model(metaclass=ModelBase):\n                 inserted = True\n             # Set the parent's PK value to self.\n             if field:\n+                # Only restore parent PK if child PK wasn't explicitly reset to None\n+                child_pk_was_none = getattr(self, field.attname) is None\n+                parent_pk_val = self._get_pk_val(parent._meta)\n+                if not child_pk_was_none or parent_pk_val != getattr(self, field.attname):\n+                    setattr(self, field.attname, parent_pk_val)\n+\n+    def _save_parents(self, cls, using, update_fields):\n+        \"\"\"Save all the parents of cls using values from self.\"\"\"\n+        meta = cls._meta\n+        inserted = False\n+        \n+        # Track if the primary key was intentionally reset to None\n+        pk_was_reset = getattr(self, '_pk_was_reset', False)\n+        original_pk = getattr(self, meta.pk.attname) if not pk_was_reset else None\n+        \n+        for parent, field in meta.parents.items():\n+            # Make sure the link fields are synced between parent and self.\n+            if (field and getattr(self, parent._meta.pk.attname) is None and\n+                    getattr(self, field.attname) is not None):\n+                setattr(self, parent._meta.pk.attname, getattr(self, field.attname))\n+            parent_inserted = self._save_parents(cls=parent, using=using, update_fields=update_fields)\n+            updated = self._save_table(\n+                cls=parent, using=using, update_fields=update_fields,\n+                force_insert=parent_inserted,\n+            )\n+            if not updated:\n+                inserted = True\n+            # Set the parent's PK value to self, but only if PK wasn't intentionally reset\n+            if field and not pk_was_reset:\n                 setattr(self, field.attname, self._get_pk_val(parent._meta))\n                 # Since we didn't have an instance of the parent handy set\n                 # attname directly, bypassing the descriptor. Invalidate\n@@ -824,6 +860,28 @@ class Model(metaclass=ModelBase):\n                 # database if necessary.\n                 if field.is_cached(self):\n                     field.delete_cached_value(self)\n+\n+            # Set the parent's PK value to self.\n+            if field:\n+                # Only restore parent PK if child PK wasn't explicitly reset to None\n+                # Check if this is a new object creation (PK was None before save)\n+                current_child_pk = getattr(self, self._meta.pk.attname)\n+                if current_child_pk is not None:\n+                    setattr(self, field.attname, self._get_pk_val(parent._meta))\n+                    # Since we didn't have an instance of the parent handy set\n+                    # attname directly, bypassing the descriptor. Invalidate\n+                    # the related object cache, in case it's been accidentally\n+                    # populated. A fresh instance will be re-built from the\n+                    # database if necessary.\n+                    if field.is_cached(self):\n+                        field.delete_cached_value(self)\n+                # Since we didn't have an instance of the parent handy set\n+                # attname directly, bypassing the descriptor. Invalidate\n+                # the related object cache, in case it's been accidentally\n+                # populated. A fresh instance will be re-built from the\n+                # database if necessary.\n+                if field.is_cached(self):\n+                    field.delete_cached_value(self)\n         return inserted\n \n     def _save_table(self, raw=False, cls=None, force_insert=False,\n@@ -839,11 +897,17 @@ class Model(metaclass=ModelBase):\n             non_pks = [f for f in non_pks\n                        if f.name in update_fields or f.attname in update_fields]\n \n+\n         pk_val = self._get_pk_val(meta)\n+        # Check if PK was intentionally reset to None for creating a new object\n+        pk_was_reset = (pk_val is None and \n+                       hasattr(self, '_pk_reset_for_new_object') and \n+                       self._pk_reset_for_new_object)\n+        \n         if pk_val is None:\n             pk_val = meta.pk.get_pk_value_on_save(self)\n             setattr(self, meta.pk.attname, pk_val)\n-        pk_set = pk_val is not None\n+        pk_set = pk_val is not None and not pk_was_reset\n         if not pk_set and (force_update or update_fields):\n             raise ValueError(\"Cannot force an update in save() with no primary key.\")\n         updated = False\n@@ -857,13 +921,31 @@ class Model(metaclass=ModelBase):\n         ):\n             force_insert = True\n         # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.\n+\n+        # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.\n         if pk_set and not force_insert:\n-            base_qs = cls._base_manager.using(using)\n-            values = [(f, None, (getattr(self, f.attname) if raw else f.pre_save(self, False)))\n-                      for f in non_pks]\n-            forced_update = update_fields or force_update\n-            updated = self._do_update(base_qs, using, pk_val, values, update_fields,\n-                                      forced_update)\n+            # Check if this is an inheritance scenario where PK was intentionally reset\n+            # by examining if we have a parent with the same PK value\n+            is_pk_reset_scenario = False\n+            if hasattr(self, '_state') and self._state.adding:\n+                for parent_link in meta.parents.values():\n+                    if parent_link and hasattr(self, parent_link.attname):\n+                        parent_pk = getattr(self, parent_link.attname)\n+                        if parent_pk == pk_val and parent_pk is not None:\n+                            # This suggests the PK was restored from parent after being reset\n+                            is_pk_reset_scenario = True\n+                            break\n+            \n+            # Skip UPDATE attempt if this appears to be a reset scenario\n+            if not is_pk_reset_scenario:\n+                base_qs = cls._base_manager.using(using)\n+                values = [(f, None, (getattr(self, f.attname) if raw else f.pre_save(self, False)))\n+                          for f in non_pks]\n+                forced_update = update_fields or force_update\n+                updated = self._do_update(base_qs, using, pk_val, values, update_fields,\n+                                          forced_update)\n+            else:\n+                updated = False\n             if force_update and not updated:\n                 raise DatabaseError(\"Forced update did not affect any rows.\")\n             if update_fields and not updated:\n",
    "variant_8": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 844c01e95e..7c18def455 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -798,6 +798,13 @@ class Model(metaclass=ModelBase):\n \n     save_base.alters_data = True\n \n+    def _save_parents(self, cls, using, update_fields):\n+        \"\"\"Save all the parents of cls using values from self.\"\"\"\n+        meta = cls._meta\n+        inserted = False\n+        for parent, field in meta.parents.items():\n+            # Make sure the link fields are synced between parent and self.\n+\n     def _save_parents(self, cls, using, update_fields):\n         \"\"\"Save all the parents of cls using values from self.\"\"\"\n         meta = cls._meta\n@@ -816,6 +823,37 @@ class Model(metaclass=ModelBase):\n                 inserted = True\n             # Set the parent's PK value to self.\n             if field:\n+                # Check if the child's PK was intentionally reset to None before save\n+                # If so, don't restore the parent's PK as this would prevent new object creation\n+                child_pk_was_reset = (\n+                    hasattr(self, '_state') and \n+                    getattr(self._state, 'adding', False) and\n+                    self._get_pk_val() is None\n+                )\n+                if not child_pk_was_reset:\n+                    setattr(self, field.attname, self._get_pk_val(parent._meta))\n+\n+    def _save_parents(self, cls, using, update_fields):\n+        \"\"\"Save all the parents of cls using values from self.\"\"\"\n+        meta = cls._meta\n+        inserted = False\n+        # Remember if the primary key was intentionally set to None for reset\n+        pk_was_reset = getattr(self, meta.pk.attname) is None and hasattr(self, '_state') and self._state.adding\n+        \n+        for parent, field in meta.parents.items():\n+            # Make sure the link fields are synced between parent and self.\n+            if (field and getattr(self, parent._meta.pk.attname) is None and\n+                    getattr(self, field.attname) is not None):\n+                setattr(self, parent._meta.pk.attname, getattr(self, field.attname))\n+            parent_inserted = self._save_parents(cls=parent, using=using, update_fields=update_fields)\n+            updated = self._save_table(\n+                cls=parent, using=using, update_fields=update_fields,\n+                force_insert=parent_inserted,\n+            )\n+            if not updated:\n+                inserted = True\n+            # Set the parent's PK value to self, but only if PK wasn't intentionally reset\n+            if field and not pk_was_reset:\n                 setattr(self, field.attname, self._get_pk_val(parent._meta))\n                 # Since we didn't have an instance of the parent handy set\n                 # attname directly, bypassing the descriptor. Invalidate\n@@ -824,6 +862,21 @@ class Model(metaclass=ModelBase):\n                 # database if necessary.\n                 if field.is_cached(self):\n                     field.delete_cached_value(self)\n+\n+            # Set the parent's PK value to self.\n+            if field:\n+                # Only restore parent PK if child PK wasn't intentionally reset to None\n+                # Check if the original PK value was None before saving parents\n+                original_pk = getattr(self, self._meta.pk.attname, None)\n+                if original_pk is not None:\n+                    setattr(self, field.attname, self._get_pk_val(parent._meta))\n+                # Since we didn't have an instance of the parent handy set\n+                # attname directly, bypassing the descriptor. Invalidate\n+                # the related object cache, in case it's been accidentally\n+                # populated. A fresh instance will be re-built from the\n+                # database if necessary.\n+                if field.is_cached(self):\n+                    field.delete_cached_value(self)\n         return inserted\n \n     def _save_table(self, raw=False, cls=None, force_insert=False,\n@@ -839,11 +892,19 @@ class Model(metaclass=ModelBase):\n             non_pks = [f for f in non_pks\n                        if f.name in update_fields or f.attname in update_fields]\n \n+\n         pk_val = self._get_pk_val(meta)\n-        if pk_val is None:\n+        # Check if PK was intentionally reset to None for creating a new object\n+        pk_was_intentionally_reset = (\n+            pk_val is None and \n+            hasattr(self, '_pk_reset_for_new_object') and \n+            self._pk_reset_for_new_object\n+        )\n+        \n+        if pk_val is None and not pk_was_intentionally_reset:\n             pk_val = meta.pk.get_pk_value_on_save(self)\n             setattr(self, meta.pk.attname, pk_val)\n-        pk_set = pk_val is not None\n+        pk_set = pk_val is not None and not pk_was_intentionally_reset\n         if not pk_set and (force_update or update_fields):\n             raise ValueError(\"Cannot force an update in save() with no primary key.\")\n         updated = False\n@@ -857,13 +918,26 @@ class Model(metaclass=ModelBase):\n         ):\n             force_insert = True\n         # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.\n+\n+        # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.\n         if pk_set and not force_insert:\n-            base_qs = cls._base_manager.using(using)\n-            values = [(f, None, (getattr(self, f.attname) if raw else f.pre_save(self, False)))\n-                      for f in non_pks]\n-            forced_update = update_fields or force_update\n-            updated = self._do_update(base_qs, using, pk_val, values, update_fields,\n-                                      forced_update)\n+            # Check if this is an inheritance scenario where PK was intentionally reset\n+            # If the instance was created with a PK but now has None, it might be a reset\n+            pk_was_reset = (\n+                hasattr(self, '_original_pk_before_save') and \n+                self._original_pk_before_save is not None and \n+                pk_val is None\n+            )\n+            \n+            if not pk_was_reset:\n+                base_qs = cls._base_manager.using(using)\n+                values = [(f, None, (getattr(self, f.attname) if raw else f.pre_save(self, False)))\n+                          for f in non_pks]\n+                forced_update = update_fields or force_update\n+                updated = self._do_update(base_qs, using, pk_val, values, update_fields,\n+                                          forced_update)\n+            else:\n+                updated = False\n             if force_update and not updated:\n                 raise DatabaseError(\"Forced update did not affect any rows.\")\n             if update_fields and not updated:\n"
  }
}