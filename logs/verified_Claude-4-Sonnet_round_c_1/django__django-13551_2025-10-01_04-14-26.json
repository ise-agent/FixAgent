{
  "zero_patches": {
    "Location 1 (/root/hy/projects/django/django/contrib/auth/tokens.py lines 94-97)": "\n        # Truncate microseconds so that tokens are consistent even if the\n        # database doesn't support microseconds.\n        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n        # Get email field name and value safely\n        email_field = user.get_email_field_name()\n        email = getattr(user, email_field, '') or ''\n        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n",
    "Location 2 (/root/hy/projects/django/django/contrib/auth/tokens.py lines 80-93)": "\n    def _make_hash_value(self, user, timestamp):\n        \"\"\"\n        Hash the user's primary key and some user state that's sure to change\n        after a password reset to produce a token that invalidated when it's\n        used:\n        1. The password field will change upon a password reset (even if the\n           same password is chosen, due to password salting).\n        2. The last_login field will usually be updated very shortly after\n           a password reset.\n        3. The email field will change if the user updates their email address,\n           ensuring tokens become invalid when email changes.\n        Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n        invalidates the token.\n\n        Running this data through salted_hmac() prevents password cracking\n        attempts using the reset token, provided the secret isn't compromised.\n        \"\"\"\n        # Truncate microseconds so that tokens are consistent even if the\n        # database doesn't support microseconds.\n        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n        # Get email field name and value safely\n        email_field = user.get_email_field_name()\n        email = getattr(user, email_field, '') or ''\n        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n",
    "Location 3 (/root/hy/projects/django/tests/auth_tests/test_tokens.py lines 112-112)": "\n    def test_legacy_token_validation(self):\n        # RemovedInDjango40Warning: pre-Django 3.1 tokens will be invalid.\n        user = User.objects.create_user('tokentestuser', 'test2@example.com', 'testpw')\n        p_old_generator = PasswordResetTokenGenerator()\n        p_old_generator.algorithm = 'sha1'\n        p_new_generator = PasswordResetTokenGenerator()\n\n        legacy_token = p_old_generator.make_token(user)\n        self.assertIs(p_old_generator.check_token(user, legacy_token), True)\n        self.assertIs(p_new_generator.check_token(user, legacy_token), True)\n\n    def test_token_invalidated_by_email_change(self):\n        \"\"\"Test that changing email invalidates existing password reset tokens.\"\"\"\n        user = User.objects.create_user('emailtestuser', 'original@example.com', 'testpw')\n        p0 = PasswordResetTokenGenerator()\n        tk1 = p0.make_token(user)\n        \n        # Token should be valid initially\n        self.assertIs(p0.check_token(user, tk1), True)\n        \n        # Change email address\n        user.email = 'changed@example.com'\n        user.save()\n        \n        # Token should now be invalid\n        self.assertIs(p0.check_token(user, tk1), False)\n\n    def test_token_with_no_email_field(self):\n        \"\"\"Test token generation works for users without email field.\"\"\"\n        # This ensures backward compatibility for custom user models without email\n        user = User.objects.create_user('noemailuser', '', 'testpw')\n        p0 = PasswordResetTokenGenerator()\n        tk1 = p0.make_token(user)\n        self.assertIs(p0.check_token(user, tk1), True)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/django/django/contrib/auth/tokens.py lines 94-97)": [
      "\n        # Truncate microseconds so that tokens are consistent even if the\n        # database doesn't support microseconds.\n        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n        # Get email field name and value safely\n        email_field = user.get_email_field_name()\n        email = getattr(user, email_field, '') or ''\n        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n",
      "\n        # Truncate microseconds so that tokens are consistent even if the\n        # database doesn't support microseconds.\n        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n        # Get email field name and value safely\n        email_field = user.get_email_field_name()\n        email = getattr(user, email_field, '') or ''\n        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n",
      "\n        # Truncate microseconds so that tokens are consistent even if the\n        # database doesn't support microseconds.\n        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n        # Get email field name and value safely\n        email_field = user.get_email_field_name()\n        email = getattr(user, email_field, '') or ''\n        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n",
      "\n        # Truncate microseconds so that tokens are consistent even if the\n        # database doesn't support microseconds.\n        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n        # Get email field name and value safely\n        email_field = user.get_email_field_name()\n        email = getattr(user, email_field, '') or ''\n        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n",
      "\n        # Truncate microseconds so that tokens are consistent even if the\n        # database doesn't support microseconds.\n        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n        # Get email field name and value safely\n        email_field = user.get_email_field_name()\n        email = getattr(user, email_field, '') or ''\n        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n",
      "\n        # Truncate microseconds so that tokens are consistent even if the\n        # database doesn't support microseconds.\n        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n        # Get email field name and value safely\n        email_field = user.get_email_field_name()\n        email = getattr(user, email_field, '') or ''\n        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n",
      "\n        # Truncate microseconds so that tokens are consistent even if the\n        # database doesn't support microseconds.\n        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n        # Get email field name and value safely\n        email_field = user.get_email_field_name()\n        email = getattr(user, email_field, '') or ''\n        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n",
      "\n        # Truncate microseconds so that tokens are consistent even if the\n        # database doesn't support microseconds.\n        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n        # Get email field name and value safely\n        email_field = user.get_email_field_name()\n        email = getattr(user, email_field, '') or ''\n        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n"
    ],
    "Location 2 (/root/hy/projects/django/django/contrib/auth/tokens.py lines 80-93)": [
      "\n    def _make_hash_value(self, user, timestamp):\n        \"\"\"\n        Hash the user's primary key and some user state that's sure to change\n        after a password reset to produce a token that invalidated when it's\n        used:\n        1. The password field will change upon a password reset (even if the\n           same password is chosen, due to password salting).\n        2. The last_login field will usually be updated very shortly after\n           a password reset.\n        3. The email field will change if the user updates their email address,\n           ensuring tokens become invalid when email changes.\n        Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n        invalidates the token.\n\n        Running this data through salted_hmac() prevents password cracking\n        attempts using the reset token, provided the secret isn't compromised.\n        \"\"\"\n        # Truncate microseconds so that tokens are consistent even if the\n        # database doesn't support microseconds.\n        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n        # Get email field name and value safely\n        email_field = user.get_email_field_name()\n        email = getattr(user, email_field, '') or ''\n        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n",
      "\n    def _make_hash_value(self, user, timestamp):\n        \"\"\"\n        Hash the user's primary key and some user state that's sure to change\n        after a password reset to produce a token that invalidated when it's\n        used:\n        1. The password field will change upon a password reset (even if the\n           same password is chosen, due to password salting).\n        2. The last_login field will usually be updated very shortly after\n           a password reset.\n        3. The email field will change if the user updates their email address,\n           ensuring tokens become invalid when email changes.\n        Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n        invalidates the token.\n\n        Running this data through salted_hmac() prevents password cracking\n        attempts using the reset token, provided the secret isn't compromised.\n        \"\"\"\n        # Truncate microseconds so that tokens are consistent even if the\n        # database doesn't support microseconds.\n        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n        # Get email field name and value safely\n        email_field = user.get_email_field_name()\n        email = getattr(user, email_field, '') or ''\n        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n",
      "\n    def _make_hash_value(self, user, timestamp):\n        \"\"\"\n        Hash the user's primary key and some user state that's sure to change\n        after a password reset to produce a token that invalidated when it's\n        used:\n        1. The password field will change upon a password reset (even if the\n           same password is chosen, due to password salting).\n        2. The last_login field will usually be updated very shortly after\n           a password reset.\n        3. The email field will change if the user updates their email address,\n           ensuring tokens become invalid when email changes.\n        Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n        invalidates the token.\n\n        Running this data through salted_hmac() prevents password cracking\n        attempts using the reset token, provided the secret isn't compromised.\n        \"\"\"\n        # Truncate microseconds so that tokens are consistent even if the\n        # database doesn't support microseconds.\n        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n        \n        # Get email field name and value safely\n        email_field = user.get_email_field_name()\n        email = getattr(user, email_field, '') or ''\n        \n        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n",
      "\n    def _make_hash_value(self, user, timestamp):\n        \"\"\"\n        Hash the user's primary key and some user state that's sure to change\n        after a password reset to produce a token that invalidated when it's\n        used:\n        1. The password field will change upon a password reset (even if the\n           same password is chosen, due to password salting).\n        2. The last_login field will usually be updated very shortly after\n           a password reset.\n        3. The email field will change if the user updates their email address,\n           ensuring tokens become invalid when email changes.\n        Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n        invalidates the token.\n\n        Running this data through salted_hmac() prevents password cracking\n        attempts using the reset token, provided the secret isn't compromised.\n        \"\"\"\n        # Truncate microseconds so that tokens are consistent even if the\n        # database doesn't support microseconds.\n        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n        # Get email field name and value safely\n        email_field = user.get_email_field_name()\n        email = getattr(user, email_field, '') or ''\n        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n",
      "\n    def _make_hash_value(self, user, timestamp):\n        \"\"\"\n        Hash the user's primary key and some user state that's sure to change\n        after a password reset to produce a token that invalidated when it's\n        used:\n        1. The password field will change upon a password reset (even if the\n           same password is chosen, due to password salting).\n        2. The last_login field will usually be updated very shortly after\n           a password reset.\n        3. The email field will change if the user updates their email address,\n           ensuring tokens become invalid when email changes.\n        Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n        invalidates the token.\n\n        Running this data through salted_hmac() prevents password cracking\n        attempts using the reset token, provided the secret isn't compromised.\n        \"\"\"\n        # Truncate microseconds so that tokens are consistent even if the\n        # database doesn't support microseconds.\n        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n        # Get email field name and value safely\n        email_field = user.get_email_field_name()\n        email = getattr(user, email_field, '') or ''\n        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n",
      "\n    def _make_hash_value(self, user, timestamp):\n        \"\"\"\n        Hash the user's primary key and some user state that's sure to change\n        after a password reset to produce a token that invalidated when it's\n        used:\n        1. The password field will change upon a password reset (even if the\n           same password is chosen, due to password salting).\n        2. The last_login field will usually be updated very shortly after\n           a password reset.\n        3. The email field will change if the user updates their email address,\n           ensuring tokens become invalid when email changes.\n        Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n        invalidates the token.\n\n        Running this data through salted_hmac() prevents password cracking\n        attempts using the reset token, provided the secret isn't compromised.\n        \"\"\"\n        # Truncate microseconds so that tokens are consistent even if the\n        # database doesn't support microseconds.\n        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n        # Get email field name and value safely\n        email_field = user.get_email_field_name()\n        email = getattr(user, email_field, '') or ''\n        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n",
      "\n        \"\"\"\n        Hash the user's primary key and some user state that's sure to change\n        after a password reset to produce a token that invalidated when it's\n        used:\n        1. The password field will change upon a password reset (even if the\n           same password is chosen, due to password salting).\n        2. The last_login field will usually be updated very shortly after\n           a password reset.\n        3. The email field will change if the user updates their email address,\n           ensuring tokens become invalid when email changes.\n        Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n        invalidates the token.\n\n        Running this data through salted_hmac() prevents password cracking\n        attempts using the reset token, provided the secret isn't compromised.\n        \"\"\"\n",
      "\n    def _make_hash_value(self, user, timestamp):\n        \"\"\"\n        Hash the user's primary key and some user state that's sure to change\n        after a password reset to produce a token that invalidated when it's\n        used:\n        1. The password field will change upon a password reset (even if the\n           same password is chosen, due to password salting).\n        2. The last_login field will usually be updated very shortly after\n           a password reset.\n        3. The email field will change if the user updates their email address,\n           ensuring tokens become invalid when email changes.\n        Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n        invalidates the token.\n\n        Running this data through salted_hmac() prevents password cracking\n        attempts using the reset token, provided the secret isn't compromised.\n        \"\"\"\n        # Truncate microseconds so that tokens are consistent even if the\n        # database doesn't support microseconds.\n        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n        # Get email field name and value safely\n        email_field = user.get_email_field_name()\n        email = getattr(user, email_field, '') or ''\n        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n"
    ],
    "Location 3 (/root/hy/projects/django/tests/auth_tests/test_tokens.py lines 112-112)": [
      "\n        def test_token_invalidated_by_email_change(self):\n            \"\"\"Test that changing email invalidates existing password reset tokens.\"\"\"\n            user = User.objects.create_user('emailtestuser', 'original@example.com', 'testpw')\n            p0 = PasswordResetTokenGenerator()\n            tk1 = p0.make_token(user)\n            \n            # Token should be valid initially\n            self.assertIs(p0.check_token(user, tk1), True)\n            \n            # Change email address\n            user.email = 'changed@example.com'\n            user.save()\n            \n            # Token should now be invalid\n            self.assertIs(p0.check_token(user, tk1), False)\n\n        def test_token_with_no_email_field(self):\n            \"\"\"Test token generation works for users without email field.\"\"\"\n            # This ensures backward compatibility for custom user models without email\n            user = User.objects.create_user('noemailuser', '', 'testpw')\n            p0 = PasswordResetTokenGenerator()\n            tk1 = p0.make_token(user)\n            self.assertIs(p0.check_token(user, tk1), True)\n",
      "\n        def test_token_invalidated_by_email_change(self):\n            \"\"\"Test that changing email invalidates existing password reset tokens.\"\"\"\n            user = User.objects.create_user('emailtestuser', 'original@example.com', 'testpw')\n            p0 = PasswordResetTokenGenerator()\n            tk1 = p0.make_token(user)\n            \n            # Token should be valid initially\n            self.assertIs(p0.check_token(user, tk1), True)\n            \n            # Change email address\n            user.email = 'changed@example.com'\n            user.save()\n            \n            # Token should now be invalid\n            self.assertIs(p0.check_token(user, tk1), False)\n\n        def test_token_with_no_email_field(self):\n            \"\"\"Test token generation works for users without email field.\"\"\"\n            # This ensures backward compatibility for custom user models without email\n            user = User.objects.create_user('noemailuser', '', 'testpw')\n            p0 = PasswordResetTokenGenerator()\n            tk1 = p0.make_token(user)\n            self.assertIs(p0.check_token(user, tk1), True)\n",
      "\n        self.assertIs(p_new_generator.check_token(user, legacy_token), True)\n\n    def test_token_invalidated_by_email_change(self):\n        \"\"\"Test that changing email invalidates existing password reset tokens.\"\"\"\n        user = User.objects.create_user('emailtestuser', 'original@example.com', 'testpw')\n        p0 = PasswordResetTokenGenerator()\n        tk1 = p0.make_token(user)\n        \n        # Token should be valid initially\n        self.assertIs(p0.check_token(user, tk1), True)\n        \n        # Change email address\n        user.email = 'changed@example.com'\n        user.save()\n        \n        # Token should now be invalid\n        self.assertIs(p0.check_token(user, tk1), False)\n\n    def test_token_with_no_email_field(self):\n        \"\"\"Test token generation works for users without email field.\"\"\"\n        # This ensures backward compatibility for custom user models without email\n        user = User.objects.create_user('noemailuser', '', 'testpw')\n        p0 = PasswordResetTokenGenerator()\n        tk1 = p0.make_token(user)\n        self.assertIs(p0.check_token(user, tk1), True)\n",
      "\n        self.assertIs(p_new_generator.check_token(user, legacy_token), True)\n\n    def test_token_invalidated_by_email_change(self):\n        \"\"\"Test that changing email invalidates existing password reset tokens.\"\"\"\n        user = User.objects.create_user('emailtestuser', 'original@example.com', 'testpw')\n        p0 = PasswordResetTokenGenerator()\n        tk1 = p0.make_token(user)\n        \n        # Token should be valid initially\n        self.assertIs(p0.check_token(user, tk1), True)\n        \n        # Change email address\n        user.email = 'changed@example.com'\n        user.save()\n        \n        # Token should now be invalid\n        self.assertIs(p0.check_token(user, tk1), False)\n\n    def test_token_with_no_email_field(self):\n        \"\"\"Test token generation works for users without email field.\"\"\"\n        # This ensures backward compatibility for custom user models without email\n        user = User.objects.create_user('noemailuser', '', 'testpw')\n        p0 = PasswordResetTokenGenerator()\n        tk1 = p0.make_token(user)\n        self.assertIs(p0.check_token(user, tk1), True)\n",
      "\n    def test_legacy_token_validation(self):\n        # RemovedInDjango40Warning: pre-Django 3.1 tokens will be invalid.\n        user = User.objects.create_user('tokentestuser', 'test2@example.com', 'testpw')\n        p_old_generator = PasswordResetTokenGenerator()\n        p_old_generator.algorithm = 'sha1'\n        p_new_generator = PasswordResetTokenGenerator()\n\n        legacy_token = p_old_generator.make_token(user)\n        self.assertIs(p_old_generator.check_token(user, legacy_token), True)\n        self.assertIs(p_new_generator.check_token(user, legacy_token), True)\n\n    def test_token_invalidated_by_email_change(self):\n        \"\"\"Test that changing email invalidates existing password reset tokens.\"\"\"\n        user = User.objects.create_user('emailtestuser', 'original@example.com', 'testpw')\n        p0 = PasswordResetTokenGenerator()\n        tk1 = p0.make_token(user)\n        \n        # Token should be valid initially\n        self.assertIs(p0.check_token(user, tk1), True)\n        \n        # Change email address\n        user.email = 'changed@example.com'\n        user.save()\n        \n        # Token should now be invalid\n        self.assertIs(p0.check_token(user, tk1), False)\n\n    def test_token_with_no_email_field(self):\n        \"\"\"Test token generation works for users without email field.\"\"\"\n        # This ensures backward compatibility for custom user models without email\n        user = User.objects.create_user('noemailuser', '', 'testpw')\n        p0 = PasswordResetTokenGenerator()\n        tk1 = p0.make_token(user)\n        self.assertIs(p0.check_token(user, tk1), True)\n",
      "\ndef test_legacy_token_validation(self):\n    # RemovedInDjango40Warning: pre-Django 3.1 tokens will be invalid.\n    user = User.objects.create_user('tokentestuser', 'test2@example.com', 'testpw')\n    p_old_generator = PasswordResetTokenGenerator()\n    p_old_generator.algorithm = 'sha1'\n    p_new_generator = PasswordResetTokenGenerator()\n\n    legacy_token = p_old_generator.make_token(user)\n    self.assertIs(p_old_generator.check_token(user, legacy_token), True)\n    self.assertIs(p_new_generator.check_token(user, legacy_token), True)\n\ndef test_token_invalidated_by_email_change(self):\n    \"\"\"Test that changing email invalidates existing password reset tokens.\"\"\"\n    user = User.objects.create_user('emailtestuser', 'original@example.com', 'testpw')\n    p0 = PasswordResetTokenGenerator()\n    tk1 = p0.make_token(user)\n    \n    # Token should be valid initially\n    self.assertIs(p0.check_token(user, tk1), True)\n    \n    # Change email address\n    user.email = 'changed@example.com'\n    user.save()\n    \n    # Token should now be invalid\n    self.assertIs(p0.check_token(user, tk1), False)\n\ndef test_token_with_no_email_field(self):\n    \"\"\"Test token generation works for users without email field.\"\"\"\n    # This ensures backward compatibility for custom user models without email\n    user = User.objects.create_user('noemailuser', '', 'testpw')\n    p0 = PasswordResetTokenGenerator()\n    tk1 = p0.make_token(user)\n    self.assertIs(p0.check_token(user, tk1), True)\n",
      "\n        self.assertIs(p_new_generator.check_token(user, legacy_token), True)\n\n    def test_token_invalidated_by_email_change(self):\n        \"\"\"Test that changing email invalidates existing password reset tokens.\"\"\"\n        user = User.objects.create_user('emailtestuser', 'original@example.com', 'testpw')\n        p0 = PasswordResetTokenGenerator()\n        tk1 = p0.make_token(user)\n        \n        # Token should be valid initially\n        self.assertIs(p0.check_token(user, tk1), True)\n        \n        # Change email address\n        user.email = 'changed@example.com'\n        user.save()\n        \n        # Token should now be invalid\n        self.assertIs(p0.check_token(user, tk1), False)\n\n    def test_token_with_no_email_field(self):\n        \"\"\"Test token generation works for users without email field.\"\"\"\n        # This ensures backward compatibility for custom user models without email\n        user = User.objects.create_user('noemailuser', '', 'testpw')\n        p0 = PasswordResetTokenGenerator()\n        tk1 = p0.make_token(user)\n        self.assertIs(p0.check_token(user, tk1), True)\n",
      "\n        self.assertIs(p_new_generator.check_token(user, legacy_token), True)\n        \n    def test_token_invalidated_by_email_change(self):\n        \"\"\"Test that changing email invalidates existing password reset tokens.\"\"\"\n        user = User.objects.create_user('emailtestuser', 'original@example.com', 'testpw')\n        p0 = PasswordResetTokenGenerator()\n        tk1 = p0.make_token(user)\n        \n        # Token should be valid initially\n        self.assertIs(p0.check_token(user, tk1), True)\n        \n        # Change email address\n        user.email = 'changed@example.com'\n        user.save()\n        \n        # Token should now be invalid\n        self.assertIs(p0.check_token(user, tk1), False)\n\n    def test_token_with_no_email_field(self):\n        \"\"\"Test token generation works for users without email field.\"\"\"\n        # This ensures backward compatibility for custom user models without email\n        user = User.objects.create_user('noemailuser', '', 'testpw')\n        p0 = PasswordResetTokenGenerator()\n        tk1 = p0.make_token(user)\n        self.assertIs(p0.check_token(user, tk1), True)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/contrib/auth/tokens.py b/django/contrib/auth/tokens.py\nindex 93e2d71af2..ae5c5281c3 100644\n--- a/django/contrib/auth/tokens.py\n+++ b/django/contrib/auth/tokens.py\n@@ -77,6 +77,7 @@ class PasswordResetTokenGenerator:\n         return \"%s-%s\" % (ts_b36, hash_string)\n \n     def _make_hash_value(self, user, timestamp):\n+\n         \"\"\"\n         Hash the user's primary key and some user state that's sure to change\n         after a password reset to produce a token that invalidated when it's\n@@ -85,16 +86,22 @@ class PasswordResetTokenGenerator:\n            same password is chosen, due to password salting).\n         2. The last_login field will usually be updated very shortly after\n            a password reset.\n+        3. The email field will change if the user updates their email address,\n+           ensuring tokens become invalid when email changes.\n         Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n         invalidates the token.\n \n         Running this data through salted_hmac() prevents password cracking\n         attempts using the reset token, provided the secret isn't compromised.\n         \"\"\"\n+\n         # Truncate microseconds so that tokens are consistent even if the\n         # database doesn't support microseconds.\n         login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n-        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp)\n+        # Get email field name and value safely\n+        email_field = user.get_email_field_name()\n+        email = getattr(user, email_field, '') or ''\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n \n     def _num_seconds(self, dt):\n         return int((dt - datetime(2001, 1, 1)).total_seconds())\ndiff --git a/tests/auth_tests/test_tokens.py b/tests/auth_tests/test_tokens.py\nindex bba435be84..05215857de 100644\n--- a/tests/auth_tests/test_tokens.py\n+++ b/tests/auth_tests/test_tokens.py\n@@ -109,4 +109,29 @@ class TokenGeneratorTest(TestCase):\n \n         legacy_token = p_old_generator.make_token(user)\n         self.assertIs(p_old_generator.check_token(user, legacy_token), True)\n+\n         self.assertIs(p_new_generator.check_token(user, legacy_token), True)\n+\n+    def test_token_invalidated_by_email_change(self):\n+        \"\"\"Test that changing email invalidates existing password reset tokens.\"\"\"\n+        user = User.objects.create_user('emailtestuser', 'original@example.com', 'testpw')\n+        p0 = PasswordResetTokenGenerator()\n+        tk1 = p0.make_token(user)\n+        \n+        # Token should be valid initially\n+        self.assertIs(p0.check_token(user, tk1), True)\n+        \n+        # Change email address\n+        user.email = 'changed@example.com'\n+        user.save()\n+        \n+        # Token should now be invalid\n+        self.assertIs(p0.check_token(user, tk1), False)\n+\n+    def test_token_with_no_email_field(self):\n+        \"\"\"Test token generation works for users without email field.\"\"\"\n+        # This ensures backward compatibility for custom user models without email\n+        user = User.objects.create_user('noemailuser', '', 'testpw')\n+        p0 = PasswordResetTokenGenerator()\n+        tk1 = p0.make_token(user)\n+        self.assertIs(p0.check_token(user, tk1), True)\n",
    "variant_0": "diff --git a/django/contrib/auth/tokens.py b/django/contrib/auth/tokens.py\nindex 93e2d71af2..be37d3f97d 100644\n--- a/django/contrib/auth/tokens.py\n+++ b/django/contrib/auth/tokens.py\n@@ -76,6 +76,8 @@ class PasswordResetTokenGenerator:\n         ).hexdigest()[::2]  # Limit to shorten the URL.\n         return \"%s-%s\" % (ts_b36, hash_string)\n \n+    def _make_hash_value(self, user, timestamp):\n+\n     def _make_hash_value(self, user, timestamp):\n         \"\"\"\n         Hash the user's primary key and some user state that's sure to change\n@@ -85,6 +87,8 @@ class PasswordResetTokenGenerator:\n            same password is chosen, due to password salting).\n         2. The last_login field will usually be updated very shortly after\n            a password reset.\n+        3. The email field will change if the user updates their email address,\n+           ensuring tokens become invalid when email changes.\n         Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n         invalidates the token.\n \n@@ -94,7 +98,18 @@ class PasswordResetTokenGenerator:\n         # Truncate microseconds so that tokens are consistent even if the\n         # database doesn't support microseconds.\n         login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n-        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp)\n+        # Get email field name and value safely\n+        email_field = user.get_email_field_name()\n+        email = getattr(user, email_field, '') or ''\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n+\n+        # Truncate microseconds so that tokens are consistent even if the\n+        # database doesn't support microseconds.\n+        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n+        # Get email field name and value safely\n+        email_field = user.get_email_field_name()\n+        email = getattr(user, email_field, '') or ''\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n \n     def _num_seconds(self, dt):\n         return int((dt - datetime(2001, 1, 1)).total_seconds())\ndiff --git a/tests/auth_tests/test_tokens.py b/tests/auth_tests/test_tokens.py\nindex bba435be84..f8f45371cc 100644\n--- a/tests/auth_tests/test_tokens.py\n+++ b/tests/auth_tests/test_tokens.py\n@@ -100,6 +100,16 @@ class TokenGeneratorTest(TestCase):\n             token = generator.make_token(user)\n             self.assertIs(generator.check_token(user, token), True)\n \n+    def test_legacy_token_validation(self):\n+        # RemovedInDjango40Warning: pre-Django 3.1 tokens will be invalid.\n+        user = User.objects.create_user('tokentestuser', 'test2@example.com', 'testpw')\n+        p_old_generator = PasswordResetTokenGenerator()\n+        p_old_generator.algorithm = 'sha1'\n+        p_new_generator = PasswordResetTokenGenerator()\n+\n+        legacy_token = p_old_generator.make_token(user)\n+        self.assertIs(p_old_generator.check_token(user, legacy_token), True)\n+\n     def test_legacy_token_validation(self):\n         # RemovedInDjango40Warning: pre-Django 3.1 tokens will be invalid.\n         user = User.objects.create_user('tokentestuser', 'test2@example.com', 'testpw')\n@@ -110,3 +120,27 @@ class TokenGeneratorTest(TestCase):\n         legacy_token = p_old_generator.make_token(user)\n         self.assertIs(p_old_generator.check_token(user, legacy_token), True)\n         self.assertIs(p_new_generator.check_token(user, legacy_token), True)\n+\n+    def test_token_invalidated_by_email_change(self):\n+        \"\"\"Test that changing email invalidates existing password reset tokens.\"\"\"\n+        user = User.objects.create_user('emailtestuser', 'original@example.com', 'testpw')\n+        p0 = PasswordResetTokenGenerator()\n+        tk1 = p0.make_token(user)\n+        \n+        # Token should be valid initially\n+        self.assertIs(p0.check_token(user, tk1), True)\n+        \n+        # Change email address\n+        user.email = 'changed@example.com'\n+        user.save()\n+        \n+        # Token should now be invalid\n+        self.assertIs(p0.check_token(user, tk1), False)\n+\n+    def test_token_with_no_email_field(self):\n+        \"\"\"Test token generation works for users without email field.\"\"\"\n+        # This ensures backward compatibility for custom user models without email\n+        user = User.objects.create_user('noemailuser', '', 'testpw')\n+        p0 = PasswordResetTokenGenerator()\n+        tk1 = p0.make_token(user)\n+        self.assertIs(p0.check_token(user, tk1), True)\n",
    "variant_1": "diff --git a/django/contrib/auth/tokens.py b/django/contrib/auth/tokens.py\nindex 93e2d71af2..be37d3f97d 100644\n--- a/django/contrib/auth/tokens.py\n+++ b/django/contrib/auth/tokens.py\n@@ -76,6 +76,8 @@ class PasswordResetTokenGenerator:\n         ).hexdigest()[::2]  # Limit to shorten the URL.\n         return \"%s-%s\" % (ts_b36, hash_string)\n \n+    def _make_hash_value(self, user, timestamp):\n+\n     def _make_hash_value(self, user, timestamp):\n         \"\"\"\n         Hash the user's primary key and some user state that's sure to change\n@@ -85,6 +87,8 @@ class PasswordResetTokenGenerator:\n            same password is chosen, due to password salting).\n         2. The last_login field will usually be updated very shortly after\n            a password reset.\n+        3. The email field will change if the user updates their email address,\n+           ensuring tokens become invalid when email changes.\n         Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n         invalidates the token.\n \n@@ -94,7 +98,18 @@ class PasswordResetTokenGenerator:\n         # Truncate microseconds so that tokens are consistent even if the\n         # database doesn't support microseconds.\n         login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n-        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp)\n+        # Get email field name and value safely\n+        email_field = user.get_email_field_name()\n+        email = getattr(user, email_field, '') or ''\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n+\n+        # Truncate microseconds so that tokens are consistent even if the\n+        # database doesn't support microseconds.\n+        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n+        # Get email field name and value safely\n+        email_field = user.get_email_field_name()\n+        email = getattr(user, email_field, '') or ''\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n \n     def _num_seconds(self, dt):\n         return int((dt - datetime(2001, 1, 1)).total_seconds())\ndiff --git a/tests/auth_tests/test_tokens.py b/tests/auth_tests/test_tokens.py\nindex bba435be84..c6e12f7624 100644\n--- a/tests/auth_tests/test_tokens.py\n+++ b/tests/auth_tests/test_tokens.py\n@@ -109,4 +109,27 @@ class TokenGeneratorTest(TestCase):\n \n         legacy_token = p_old_generator.make_token(user)\n         self.assertIs(p_old_generator.check_token(user, legacy_token), True)\n-        self.assertIs(p_new_generator.check_token(user, legacy_token), True)\n+\n+        def test_token_invalidated_by_email_change(self):\n+            \"\"\"Test that changing email invalidates existing password reset tokens.\"\"\"\n+            user = User.objects.create_user('emailtestuser', 'original@example.com', 'testpw')\n+            p0 = PasswordResetTokenGenerator()\n+            tk1 = p0.make_token(user)\n+            \n+            # Token should be valid initially\n+            self.assertIs(p0.check_token(user, tk1), True)\n+            \n+            # Change email address\n+            user.email = 'changed@example.com'\n+            user.save()\n+            \n+            # Token should now be invalid\n+            self.assertIs(p0.check_token(user, tk1), False)\n+\n+        def test_token_with_no_email_field(self):\n+            \"\"\"Test token generation works for users without email field.\"\"\"\n+            # This ensures backward compatibility for custom user models without email\n+            user = User.objects.create_user('noemailuser', '', 'testpw')\n+            p0 = PasswordResetTokenGenerator()\n+            tk1 = p0.make_token(user)\n+            self.assertIs(p0.check_token(user, tk1), True)\n",
    "variant_2": "diff --git a/django/contrib/auth/tokens.py b/django/contrib/auth/tokens.py\nindex 93e2d71af2..be37d3f97d 100644\n--- a/django/contrib/auth/tokens.py\n+++ b/django/contrib/auth/tokens.py\n@@ -76,6 +76,8 @@ class PasswordResetTokenGenerator:\n         ).hexdigest()[::2]  # Limit to shorten the URL.\n         return \"%s-%s\" % (ts_b36, hash_string)\n \n+    def _make_hash_value(self, user, timestamp):\n+\n     def _make_hash_value(self, user, timestamp):\n         \"\"\"\n         Hash the user's primary key and some user state that's sure to change\n@@ -85,6 +87,8 @@ class PasswordResetTokenGenerator:\n            same password is chosen, due to password salting).\n         2. The last_login field will usually be updated very shortly after\n            a password reset.\n+        3. The email field will change if the user updates their email address,\n+           ensuring tokens become invalid when email changes.\n         Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n         invalidates the token.\n \n@@ -94,7 +98,18 @@ class PasswordResetTokenGenerator:\n         # Truncate microseconds so that tokens are consistent even if the\n         # database doesn't support microseconds.\n         login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n-        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp)\n+        # Get email field name and value safely\n+        email_field = user.get_email_field_name()\n+        email = getattr(user, email_field, '') or ''\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n+\n+        # Truncate microseconds so that tokens are consistent even if the\n+        # database doesn't support microseconds.\n+        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n+        # Get email field name and value safely\n+        email_field = user.get_email_field_name()\n+        email = getattr(user, email_field, '') or ''\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n \n     def _num_seconds(self, dt):\n         return int((dt - datetime(2001, 1, 1)).total_seconds())\ndiff --git a/tests/auth_tests/test_tokens.py b/tests/auth_tests/test_tokens.py\nindex bba435be84..c6e12f7624 100644\n--- a/tests/auth_tests/test_tokens.py\n+++ b/tests/auth_tests/test_tokens.py\n@@ -109,4 +109,27 @@ class TokenGeneratorTest(TestCase):\n \n         legacy_token = p_old_generator.make_token(user)\n         self.assertIs(p_old_generator.check_token(user, legacy_token), True)\n-        self.assertIs(p_new_generator.check_token(user, legacy_token), True)\n+\n+        def test_token_invalidated_by_email_change(self):\n+            \"\"\"Test that changing email invalidates existing password reset tokens.\"\"\"\n+            user = User.objects.create_user('emailtestuser', 'original@example.com', 'testpw')\n+            p0 = PasswordResetTokenGenerator()\n+            tk1 = p0.make_token(user)\n+            \n+            # Token should be valid initially\n+            self.assertIs(p0.check_token(user, tk1), True)\n+            \n+            # Change email address\n+            user.email = 'changed@example.com'\n+            user.save()\n+            \n+            # Token should now be invalid\n+            self.assertIs(p0.check_token(user, tk1), False)\n+\n+        def test_token_with_no_email_field(self):\n+            \"\"\"Test token generation works for users without email field.\"\"\"\n+            # This ensures backward compatibility for custom user models without email\n+            user = User.objects.create_user('noemailuser', '', 'testpw')\n+            p0 = PasswordResetTokenGenerator()\n+            tk1 = p0.make_token(user)\n+            self.assertIs(p0.check_token(user, tk1), True)\n",
    "variant_3": "diff --git a/django/contrib/auth/tokens.py b/django/contrib/auth/tokens.py\nindex 93e2d71af2..082b06d2a8 100644\n--- a/django/contrib/auth/tokens.py\n+++ b/django/contrib/auth/tokens.py\n@@ -76,6 +76,8 @@ class PasswordResetTokenGenerator:\n         ).hexdigest()[::2]  # Limit to shorten the URL.\n         return \"%s-%s\" % (ts_b36, hash_string)\n \n+    def _make_hash_value(self, user, timestamp):\n+\n     def _make_hash_value(self, user, timestamp):\n         \"\"\"\n         Hash the user's primary key and some user state that's sure to change\n@@ -85,6 +87,8 @@ class PasswordResetTokenGenerator:\n            same password is chosen, due to password salting).\n         2. The last_login field will usually be updated very shortly after\n            a password reset.\n+        3. The email field will change if the user updates their email address,\n+           ensuring tokens become invalid when email changes.\n         Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n         invalidates the token.\n \n@@ -94,7 +98,20 @@ class PasswordResetTokenGenerator:\n         # Truncate microseconds so that tokens are consistent even if the\n         # database doesn't support microseconds.\n         login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n-        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp)\n+        \n+        # Get email field name and value safely\n+        email_field = user.get_email_field_name()\n+        email = getattr(user, email_field, '') or ''\n+        \n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n+\n+        # Truncate microseconds so that tokens are consistent even if the\n+        # database doesn't support microseconds.\n+        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n+        # Get email field name and value safely\n+        email_field = user.get_email_field_name()\n+        email = getattr(user, email_field, '') or ''\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n \n     def _num_seconds(self, dt):\n         return int((dt - datetime(2001, 1, 1)).total_seconds())\ndiff --git a/tests/auth_tests/test_tokens.py b/tests/auth_tests/test_tokens.py\nindex bba435be84..05215857de 100644\n--- a/tests/auth_tests/test_tokens.py\n+++ b/tests/auth_tests/test_tokens.py\n@@ -109,4 +109,29 @@ class TokenGeneratorTest(TestCase):\n \n         legacy_token = p_old_generator.make_token(user)\n         self.assertIs(p_old_generator.check_token(user, legacy_token), True)\n+\n         self.assertIs(p_new_generator.check_token(user, legacy_token), True)\n+\n+    def test_token_invalidated_by_email_change(self):\n+        \"\"\"Test that changing email invalidates existing password reset tokens.\"\"\"\n+        user = User.objects.create_user('emailtestuser', 'original@example.com', 'testpw')\n+        p0 = PasswordResetTokenGenerator()\n+        tk1 = p0.make_token(user)\n+        \n+        # Token should be valid initially\n+        self.assertIs(p0.check_token(user, tk1), True)\n+        \n+        # Change email address\n+        user.email = 'changed@example.com'\n+        user.save()\n+        \n+        # Token should now be invalid\n+        self.assertIs(p0.check_token(user, tk1), False)\n+\n+    def test_token_with_no_email_field(self):\n+        \"\"\"Test token generation works for users without email field.\"\"\"\n+        # This ensures backward compatibility for custom user models without email\n+        user = User.objects.create_user('noemailuser', '', 'testpw')\n+        p0 = PasswordResetTokenGenerator()\n+        tk1 = p0.make_token(user)\n+        self.assertIs(p0.check_token(user, tk1), True)\n",
    "variant_4": "diff --git a/django/contrib/auth/tokens.py b/django/contrib/auth/tokens.py\nindex 93e2d71af2..be37d3f97d 100644\n--- a/django/contrib/auth/tokens.py\n+++ b/django/contrib/auth/tokens.py\n@@ -76,6 +76,8 @@ class PasswordResetTokenGenerator:\n         ).hexdigest()[::2]  # Limit to shorten the URL.\n         return \"%s-%s\" % (ts_b36, hash_string)\n \n+    def _make_hash_value(self, user, timestamp):\n+\n     def _make_hash_value(self, user, timestamp):\n         \"\"\"\n         Hash the user's primary key and some user state that's sure to change\n@@ -85,6 +87,8 @@ class PasswordResetTokenGenerator:\n            same password is chosen, due to password salting).\n         2. The last_login field will usually be updated very shortly after\n            a password reset.\n+        3. The email field will change if the user updates their email address,\n+           ensuring tokens become invalid when email changes.\n         Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n         invalidates the token.\n \n@@ -94,7 +98,18 @@ class PasswordResetTokenGenerator:\n         # Truncate microseconds so that tokens are consistent even if the\n         # database doesn't support microseconds.\n         login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n-        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp)\n+        # Get email field name and value safely\n+        email_field = user.get_email_field_name()\n+        email = getattr(user, email_field, '') or ''\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n+\n+        # Truncate microseconds so that tokens are consistent even if the\n+        # database doesn't support microseconds.\n+        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n+        # Get email field name and value safely\n+        email_field = user.get_email_field_name()\n+        email = getattr(user, email_field, '') or ''\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n \n     def _num_seconds(self, dt):\n         return int((dt - datetime(2001, 1, 1)).total_seconds())\ndiff --git a/tests/auth_tests/test_tokens.py b/tests/auth_tests/test_tokens.py\nindex bba435be84..05215857de 100644\n--- a/tests/auth_tests/test_tokens.py\n+++ b/tests/auth_tests/test_tokens.py\n@@ -109,4 +109,29 @@ class TokenGeneratorTest(TestCase):\n \n         legacy_token = p_old_generator.make_token(user)\n         self.assertIs(p_old_generator.check_token(user, legacy_token), True)\n+\n         self.assertIs(p_new_generator.check_token(user, legacy_token), True)\n+\n+    def test_token_invalidated_by_email_change(self):\n+        \"\"\"Test that changing email invalidates existing password reset tokens.\"\"\"\n+        user = User.objects.create_user('emailtestuser', 'original@example.com', 'testpw')\n+        p0 = PasswordResetTokenGenerator()\n+        tk1 = p0.make_token(user)\n+        \n+        # Token should be valid initially\n+        self.assertIs(p0.check_token(user, tk1), True)\n+        \n+        # Change email address\n+        user.email = 'changed@example.com'\n+        user.save()\n+        \n+        # Token should now be invalid\n+        self.assertIs(p0.check_token(user, tk1), False)\n+\n+    def test_token_with_no_email_field(self):\n+        \"\"\"Test token generation works for users without email field.\"\"\"\n+        # This ensures backward compatibility for custom user models without email\n+        user = User.objects.create_user('noemailuser', '', 'testpw')\n+        p0 = PasswordResetTokenGenerator()\n+        tk1 = p0.make_token(user)\n+        self.assertIs(p0.check_token(user, tk1), True)\n",
    "variant_5": "diff --git a/django/contrib/auth/tokens.py b/django/contrib/auth/tokens.py\nindex 93e2d71af2..be37d3f97d 100644\n--- a/django/contrib/auth/tokens.py\n+++ b/django/contrib/auth/tokens.py\n@@ -76,6 +76,8 @@ class PasswordResetTokenGenerator:\n         ).hexdigest()[::2]  # Limit to shorten the URL.\n         return \"%s-%s\" % (ts_b36, hash_string)\n \n+    def _make_hash_value(self, user, timestamp):\n+\n     def _make_hash_value(self, user, timestamp):\n         \"\"\"\n         Hash the user's primary key and some user state that's sure to change\n@@ -85,6 +87,8 @@ class PasswordResetTokenGenerator:\n            same password is chosen, due to password salting).\n         2. The last_login field will usually be updated very shortly after\n            a password reset.\n+        3. The email field will change if the user updates their email address,\n+           ensuring tokens become invalid when email changes.\n         Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n         invalidates the token.\n \n@@ -94,7 +98,18 @@ class PasswordResetTokenGenerator:\n         # Truncate microseconds so that tokens are consistent even if the\n         # database doesn't support microseconds.\n         login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n-        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp)\n+        # Get email field name and value safely\n+        email_field = user.get_email_field_name()\n+        email = getattr(user, email_field, '') or ''\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n+\n+        # Truncate microseconds so that tokens are consistent even if the\n+        # database doesn't support microseconds.\n+        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n+        # Get email field name and value safely\n+        email_field = user.get_email_field_name()\n+        email = getattr(user, email_field, '') or ''\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n \n     def _num_seconds(self, dt):\n         return int((dt - datetime(2001, 1, 1)).total_seconds())\ndiff --git a/tests/auth_tests/test_tokens.py b/tests/auth_tests/test_tokens.py\nindex bba435be84..f8f45371cc 100644\n--- a/tests/auth_tests/test_tokens.py\n+++ b/tests/auth_tests/test_tokens.py\n@@ -100,6 +100,16 @@ class TokenGeneratorTest(TestCase):\n             token = generator.make_token(user)\n             self.assertIs(generator.check_token(user, token), True)\n \n+    def test_legacy_token_validation(self):\n+        # RemovedInDjango40Warning: pre-Django 3.1 tokens will be invalid.\n+        user = User.objects.create_user('tokentestuser', 'test2@example.com', 'testpw')\n+        p_old_generator = PasswordResetTokenGenerator()\n+        p_old_generator.algorithm = 'sha1'\n+        p_new_generator = PasswordResetTokenGenerator()\n+\n+        legacy_token = p_old_generator.make_token(user)\n+        self.assertIs(p_old_generator.check_token(user, legacy_token), True)\n+\n     def test_legacy_token_validation(self):\n         # RemovedInDjango40Warning: pre-Django 3.1 tokens will be invalid.\n         user = User.objects.create_user('tokentestuser', 'test2@example.com', 'testpw')\n@@ -110,3 +120,27 @@ class TokenGeneratorTest(TestCase):\n         legacy_token = p_old_generator.make_token(user)\n         self.assertIs(p_old_generator.check_token(user, legacy_token), True)\n         self.assertIs(p_new_generator.check_token(user, legacy_token), True)\n+\n+    def test_token_invalidated_by_email_change(self):\n+        \"\"\"Test that changing email invalidates existing password reset tokens.\"\"\"\n+        user = User.objects.create_user('emailtestuser', 'original@example.com', 'testpw')\n+        p0 = PasswordResetTokenGenerator()\n+        tk1 = p0.make_token(user)\n+        \n+        # Token should be valid initially\n+        self.assertIs(p0.check_token(user, tk1), True)\n+        \n+        # Change email address\n+        user.email = 'changed@example.com'\n+        user.save()\n+        \n+        # Token should now be invalid\n+        self.assertIs(p0.check_token(user, tk1), False)\n+\n+    def test_token_with_no_email_field(self):\n+        \"\"\"Test token generation works for users without email field.\"\"\"\n+        # This ensures backward compatibility for custom user models without email\n+        user = User.objects.create_user('noemailuser', '', 'testpw')\n+        p0 = PasswordResetTokenGenerator()\n+        tk1 = p0.make_token(user)\n+        self.assertIs(p0.check_token(user, tk1), True)\n",
    "variant_6": "diff --git a/django/contrib/auth/tokens.py b/django/contrib/auth/tokens.py\nindex 93e2d71af2..be37d3f97d 100644\n--- a/django/contrib/auth/tokens.py\n+++ b/django/contrib/auth/tokens.py\n@@ -76,6 +76,8 @@ class PasswordResetTokenGenerator:\n         ).hexdigest()[::2]  # Limit to shorten the URL.\n         return \"%s-%s\" % (ts_b36, hash_string)\n \n+    def _make_hash_value(self, user, timestamp):\n+\n     def _make_hash_value(self, user, timestamp):\n         \"\"\"\n         Hash the user's primary key and some user state that's sure to change\n@@ -85,6 +87,8 @@ class PasswordResetTokenGenerator:\n            same password is chosen, due to password salting).\n         2. The last_login field will usually be updated very shortly after\n            a password reset.\n+        3. The email field will change if the user updates their email address,\n+           ensuring tokens become invalid when email changes.\n         Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n         invalidates the token.\n \n@@ -94,7 +98,18 @@ class PasswordResetTokenGenerator:\n         # Truncate microseconds so that tokens are consistent even if the\n         # database doesn't support microseconds.\n         login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n-        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp)\n+        # Get email field name and value safely\n+        email_field = user.get_email_field_name()\n+        email = getattr(user, email_field, '') or ''\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n+\n+        # Truncate microseconds so that tokens are consistent even if the\n+        # database doesn't support microseconds.\n+        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n+        # Get email field name and value safely\n+        email_field = user.get_email_field_name()\n+        email = getattr(user, email_field, '') or ''\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n \n     def _num_seconds(self, dt):\n         return int((dt - datetime(2001, 1, 1)).total_seconds())\ndiff --git a/tests/auth_tests/test_tokens.py b/tests/auth_tests/test_tokens.py\nindex bba435be84..80662f9fd0 100644\n--- a/tests/auth_tests/test_tokens.py\n+++ b/tests/auth_tests/test_tokens.py\n@@ -109,4 +109,38 @@ class TokenGeneratorTest(TestCase):\n \n         legacy_token = p_old_generator.make_token(user)\n         self.assertIs(p_old_generator.check_token(user, legacy_token), True)\n-        self.assertIs(p_new_generator.check_token(user, legacy_token), True)\n+\n+def test_legacy_token_validation(self):\n+    # RemovedInDjango40Warning: pre-Django 3.1 tokens will be invalid.\n+    user = User.objects.create_user('tokentestuser', 'test2@example.com', 'testpw')\n+    p_old_generator = PasswordResetTokenGenerator()\n+    p_old_generator.algorithm = 'sha1'\n+    p_new_generator = PasswordResetTokenGenerator()\n+\n+    legacy_token = p_old_generator.make_token(user)\n+    self.assertIs(p_old_generator.check_token(user, legacy_token), True)\n+    self.assertIs(p_new_generator.check_token(user, legacy_token), True)\n+\n+def test_token_invalidated_by_email_change(self):\n+    \"\"\"Test that changing email invalidates existing password reset tokens.\"\"\"\n+    user = User.objects.create_user('emailtestuser', 'original@example.com', 'testpw')\n+    p0 = PasswordResetTokenGenerator()\n+    tk1 = p0.make_token(user)\n+    \n+    # Token should be valid initially\n+    self.assertIs(p0.check_token(user, tk1), True)\n+    \n+    # Change email address\n+    user.email = 'changed@example.com'\n+    user.save()\n+    \n+    # Token should now be invalid\n+    self.assertIs(p0.check_token(user, tk1), False)\n+\n+def test_token_with_no_email_field(self):\n+    \"\"\"Test token generation works for users without email field.\"\"\"\n+    # This ensures backward compatibility for custom user models without email\n+    user = User.objects.create_user('noemailuser', '', 'testpw')\n+    p0 = PasswordResetTokenGenerator()\n+    tk1 = p0.make_token(user)\n+    self.assertIs(p0.check_token(user, tk1), True)\n",
    "variant_7": "diff --git a/django/contrib/auth/tokens.py b/django/contrib/auth/tokens.py\nindex 93e2d71af2..ae5c5281c3 100644\n--- a/django/contrib/auth/tokens.py\n+++ b/django/contrib/auth/tokens.py\n@@ -77,6 +77,7 @@ class PasswordResetTokenGenerator:\n         return \"%s-%s\" % (ts_b36, hash_string)\n \n     def _make_hash_value(self, user, timestamp):\n+\n         \"\"\"\n         Hash the user's primary key and some user state that's sure to change\n         after a password reset to produce a token that invalidated when it's\n@@ -85,16 +86,22 @@ class PasswordResetTokenGenerator:\n            same password is chosen, due to password salting).\n         2. The last_login field will usually be updated very shortly after\n            a password reset.\n+        3. The email field will change if the user updates their email address,\n+           ensuring tokens become invalid when email changes.\n         Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n         invalidates the token.\n \n         Running this data through salted_hmac() prevents password cracking\n         attempts using the reset token, provided the secret isn't compromised.\n         \"\"\"\n+\n         # Truncate microseconds so that tokens are consistent even if the\n         # database doesn't support microseconds.\n         login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n-        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp)\n+        # Get email field name and value safely\n+        email_field = user.get_email_field_name()\n+        email = getattr(user, email_field, '') or ''\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n \n     def _num_seconds(self, dt):\n         return int((dt - datetime(2001, 1, 1)).total_seconds())\ndiff --git a/tests/auth_tests/test_tokens.py b/tests/auth_tests/test_tokens.py\nindex bba435be84..05215857de 100644\n--- a/tests/auth_tests/test_tokens.py\n+++ b/tests/auth_tests/test_tokens.py\n@@ -109,4 +109,29 @@ class TokenGeneratorTest(TestCase):\n \n         legacy_token = p_old_generator.make_token(user)\n         self.assertIs(p_old_generator.check_token(user, legacy_token), True)\n+\n         self.assertIs(p_new_generator.check_token(user, legacy_token), True)\n+\n+    def test_token_invalidated_by_email_change(self):\n+        \"\"\"Test that changing email invalidates existing password reset tokens.\"\"\"\n+        user = User.objects.create_user('emailtestuser', 'original@example.com', 'testpw')\n+        p0 = PasswordResetTokenGenerator()\n+        tk1 = p0.make_token(user)\n+        \n+        # Token should be valid initially\n+        self.assertIs(p0.check_token(user, tk1), True)\n+        \n+        # Change email address\n+        user.email = 'changed@example.com'\n+        user.save()\n+        \n+        # Token should now be invalid\n+        self.assertIs(p0.check_token(user, tk1), False)\n+\n+    def test_token_with_no_email_field(self):\n+        \"\"\"Test token generation works for users without email field.\"\"\"\n+        # This ensures backward compatibility for custom user models without email\n+        user = User.objects.create_user('noemailuser', '', 'testpw')\n+        p0 = PasswordResetTokenGenerator()\n+        tk1 = p0.make_token(user)\n+        self.assertIs(p0.check_token(user, tk1), True)\n",
    "variant_8": "diff --git a/django/contrib/auth/tokens.py b/django/contrib/auth/tokens.py\nindex 93e2d71af2..be37d3f97d 100644\n--- a/django/contrib/auth/tokens.py\n+++ b/django/contrib/auth/tokens.py\n@@ -76,6 +76,8 @@ class PasswordResetTokenGenerator:\n         ).hexdigest()[::2]  # Limit to shorten the URL.\n         return \"%s-%s\" % (ts_b36, hash_string)\n \n+    def _make_hash_value(self, user, timestamp):\n+\n     def _make_hash_value(self, user, timestamp):\n         \"\"\"\n         Hash the user's primary key and some user state that's sure to change\n@@ -85,6 +87,8 @@ class PasswordResetTokenGenerator:\n            same password is chosen, due to password salting).\n         2. The last_login field will usually be updated very shortly after\n            a password reset.\n+        3. The email field will change if the user updates their email address,\n+           ensuring tokens become invalid when email changes.\n         Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n         invalidates the token.\n \n@@ -94,7 +98,18 @@ class PasswordResetTokenGenerator:\n         # Truncate microseconds so that tokens are consistent even if the\n         # database doesn't support microseconds.\n         login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n-        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp)\n+        # Get email field name and value safely\n+        email_field = user.get_email_field_name()\n+        email = getattr(user, email_field, '') or ''\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n+\n+        # Truncate microseconds so that tokens are consistent even if the\n+        # database doesn't support microseconds.\n+        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n+        # Get email field name and value safely\n+        email_field = user.get_email_field_name()\n+        email = getattr(user, email_field, '') or ''\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n \n     def _num_seconds(self, dt):\n         return int((dt - datetime(2001, 1, 1)).total_seconds())\ndiff --git a/tests/auth_tests/test_tokens.py b/tests/auth_tests/test_tokens.py\nindex bba435be84..bf19c31c59 100644\n--- a/tests/auth_tests/test_tokens.py\n+++ b/tests/auth_tests/test_tokens.py\n@@ -109,4 +109,29 @@ class TokenGeneratorTest(TestCase):\n \n         legacy_token = p_old_generator.make_token(user)\n         self.assertIs(p_old_generator.check_token(user, legacy_token), True)\n+\n         self.assertIs(p_new_generator.check_token(user, legacy_token), True)\n+        \n+    def test_token_invalidated_by_email_change(self):\n+        \"\"\"Test that changing email invalidates existing password reset tokens.\"\"\"\n+        user = User.objects.create_user('emailtestuser', 'original@example.com', 'testpw')\n+        p0 = PasswordResetTokenGenerator()\n+        tk1 = p0.make_token(user)\n+        \n+        # Token should be valid initially\n+        self.assertIs(p0.check_token(user, tk1), True)\n+        \n+        # Change email address\n+        user.email = 'changed@example.com'\n+        user.save()\n+        \n+        # Token should now be invalid\n+        self.assertIs(p0.check_token(user, tk1), False)\n+\n+    def test_token_with_no_email_field(self):\n+        \"\"\"Test token generation works for users without email field.\"\"\"\n+        # This ensures backward compatibility for custom user models without email\n+        user = User.objects.create_user('noemailuser', '', 'testpw')\n+        p0 = PasswordResetTokenGenerator()\n+        tk1 = p0.make_token(user)\n+        self.assertIs(p0.check_token(user, tk1), True)\n"
  }
}