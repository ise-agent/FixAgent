{
  "zero_patches": {
    "Location 1 (/root/hy/projects/django/django/db/models/deletion.py lines 313-315)": "\n            # fast deletes\n            # Group querysets by model to combine queries for the same table\n            fast_deletes_by_model = {}\n            for qs in self.fast_deletes:\n                model = qs.model\n                if model not in fast_deletes_by_model:\n                    fast_deletes_by_model[model] = []\n                fast_deletes_by_model[model].append(qs)\n            \n            # Execute combined queries for each model\n            for model, querysets in fast_deletes_by_model.items():\n                if len(querysets) == 1:\n                    # Single queryset, execute directly\n                    count = querysets[0]._raw_delete(using=self.using)\n                else:\n                    # Multiple querysets for same model, combine with OR\n                    from django.db.models import Q\n                    combined_q = Q()\n                    for qs in querysets:\n                        # Get the WHERE condition from each queryset\n                        if hasattr(qs.query, 'where') and qs.query.where:\n                            combined_q |= Q(pk__in=qs.values_list('pk', flat=True))\n                        else:\n                            # If no WHERE clause, this deletes all records\n                            combined_q = Q()\n                            break\n                    \n                    # Create new queryset with combined conditions\n                    combined_qs = model.objects.filter(combined_q)\n                    count = combined_qs._raw_delete(using=self.using)\n                \n                deleted_counter[model._meta.label] += count\n",
    "Location 2 (/root/hy/projects/django/django/db/models/deletion.py lines 193-194)": "\n        if self.can_fast_delete(objs):\n            # Group fast deletes by model to enable query combination\n            model = objs[0].__class__\n            if model not in self.fast_deletes:\n                self.fast_deletes[model] = []\n            self.fast_deletes[model].append(objs)\n",
    "Location 3 (/root/hy/projects/django/django/db/models/deletion.py lines 227-228)": "\n                if self.can_fast_delete(sub_objs, from_field=field):\n                    # Group querysets by model for potential combination\n                    model = sub_objs.model\n                    if model not in self.fast_deletes:\n                        self.fast_deletes[model] = []\n                    self.fast_deletes[model].append(sub_objs)\n",
    "Location 4 (/root/hy/projects/django/django/db/models/deletion.py lines 70-72)": "\n        # fast_deletes is a dictionary of {model: [querysets]} that can be deleted without\n        # fetching the objects into memory. Multiple querysets for the same model\n        # will be combined using OR conditions to optimize database queries.\n        self.fast_deletes = {}\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/django/django/db/models/deletion.py lines 313-315)": [
      "\n            # fast deletes\n            # Group querysets by model to combine multiple DELETE queries for the same table\n            fast_deletes_by_model = {}\n            for qs in self.fast_deletes:\n                model = qs.model\n                if model not in fast_deletes_by_model:\n                    fast_deletes_by_model[model] = []\n                fast_deletes_by_model[model].append(qs)\n            \n            # Execute combined queries for each model\n            for model, querysets in fast_deletes_by_model.items():\n                if len(querysets) == 1:\n                    # Single queryset, execute directly\n                    count = querysets[0]._raw_delete(using=self.using)\n                    deleted_counter[model._meta.label] += count\n                else:\n                    # Multiple querysets for same model, combine with OR\n                    from django.db.models import Q\n                    combined_q = Q()\n                    for qs in querysets:\n                        # Get the WHERE clause as a Q object\n                        where = qs.query.where\n                        if where.children:\n                            q_obj = Q()\n                            q_obj.add(where, Q.AND)\n                            combined_q |= q_obj\n                    \n                    if combined_q:\n                        # Create a new queryset with combined conditions\n                        combined_qs = model._default_manager.filter(combined_q)\n                        count = combined_qs._raw_delete(using=self.using)\n                        deleted_counter[model._meta.label] += count\n",
      "\n            # fast deletes\n            # Group querysets by model to combine queries for the same table\n            fast_delete_groups = {}\n            for qs in self.fast_deletes:\n                model = qs.model\n                if model not in fast_delete_groups:\n                    fast_delete_groups[model] = []\n                fast_delete_groups[model].append(qs)\n            \n            # Execute combined queries for each model\n            for model, querysets in fast_delete_groups.items():\n                if len(querysets) == 1:\n                    # Single queryset, execute directly\n                    count = querysets[0]._raw_delete(using=self.using)\n                    deleted_counter[model._meta.label] += count\n                else:\n                    # Multiple querysets for same model, combine with OR\n                    from django.db.models import Q\n                    combined_q = Q()\n                    for qs in querysets:\n                        combined_q |= Q(pk__in=qs.values_list('pk', flat=True))\n                    \n                    # Create a new queryset with combined conditions\n                    combined_qs = model._default_manager.using(self.using).filter(combined_q)\n                    count = combined_qs._raw_delete(using=self.using)\n                    deleted_counter[model._meta.label] += count\n",
      "\n            # fast deletes\n            # Group querysets by model to combine them with OR conditions\n            fast_deletes_by_model = {}\n            for qs in self.fast_deletes:\n                model = qs.model\n                if model not in fast_deletes_by_model:\n                    fast_deletes_by_model[model] = []\n                fast_deletes_by_model[model].append(qs)\n            \n            # Execute combined queries for each model\n            for model, querysets in fast_deletes_by_model.items():\n                if len(querysets) == 1:\n                    # Single queryset, execute directly\n                    count = querysets[0]._raw_delete(using=self.using)\n                else:\n                    # Multiple querysets for same model, combine with OR\n                    from django.db.models import Q\n                    combined_q = Q()\n                    for qs in querysets:\n                        # Get the WHERE condition from each queryset\n                        where = qs.query.where\n                        if where:\n                            combined_q |= Q(pk__in=qs.values_list('pk', flat=True))\n                    \n                    if combined_q:\n                        # Create new queryset with combined conditions\n                        combined_qs = model._default_manager.using(self.using).filter(combined_q)\n                        count = combined_qs._raw_delete(using=self.using)\n                    else:\n                        count = 0\n                \n                deleted_counter[model._meta.label] += count\n",
      "\n            # fast deletes\n            # Group querysets by model to combine queries for the same table\n            fast_deletes_by_model = {}\n            for qs in self.fast_deletes:\n                model = qs.model\n                if model not in fast_deletes_by_model:\n                    fast_deletes_by_model[model] = []\n                fast_deletes_by_model[model].append(qs)\n            \n            # Execute combined queries for each model\n            for model, querysets in fast_deletes_by_model.items():\n                if len(querysets) == 1:\n                    # Single queryset, execute directly\n                    count = querysets[0]._raw_delete(using=self.using)\n                    deleted_counter[model._meta.label] += count\n                else:\n                    # Multiple querysets for same model, combine with OR\n                    from django.db.models import Q\n                    combined_q = Q()\n                    for qs in querysets:\n                        combined_q |= Q(pk__in=qs.values_list('pk', flat=True))\n                    \n                    combined_qs = model.objects.filter(combined_q)\n                    count = combined_qs._raw_delete(using=self.using)\n                    deleted_counter[model._meta.label] += count\n",
      "\n            # fast deletes\n            # Group querysets by model to combine DELETE queries\n            fast_deletes_by_model = {}\n            for qs in self.fast_deletes:\n                model = qs.model\n                if model not in fast_deletes_by_model:\n                    fast_deletes_by_model[model] = []\n                fast_deletes_by_model[model].append(qs)\n            \n            # Execute combined queries for each model\n            for model, querysets in fast_deletes_by_model.items():\n                if len(querysets) == 1:\n                    # Single queryset, execute directly\n                    count = querysets[0]._raw_delete(using=self.using)\n                else:\n                    # Multiple querysets for same model, combine with OR\n                    from django.db.models import Q\n                    combined_q = Q()\n                    for qs in querysets:\n                        # Get the WHERE clause from each queryset\n                        where_clause = qs.query.where\n                        if where_clause:\n                            combined_q |= Q(**{pk_field.name + '__in': qs.values_list('pk', flat=True)})\n                        else:\n                            # If no WHERE clause, this deletes all objects\n                            combined_q = Q()\n                            break\n                    \n                    # Create a new queryset with combined conditions\n                    pk_field = model._meta.pk\n                    if combined_q:\n                        combined_qs = model._default_manager.using(self.using).filter(combined_q)\n                    else:\n                        combined_qs = model._default_manager.using(self.using).all()\n                    count = combined_qs._raw_delete(using=self.using)\n                \n                deleted_counter[model._meta.label] += count\n",
      "\n            # fast deletes\n            # Group querysets by model to combine multiple DELETE queries for the same table\n            fast_deletes_by_model = {}\n            for qs in self.fast_deletes:\n                model = qs.model\n                if model not in fast_deletes_by_model:\n                    fast_deletes_by_model[model] = []\n                fast_deletes_by_model[model].append(qs)\n            \n            # Execute combined queries for each model\n            for model, querysets in fast_deletes_by_model.items():\n                if len(querysets) == 1:\n                    # Single queryset, execute directly\n                    count = querysets[0]._raw_delete(using=self.using)\n                    deleted_counter[model._meta.label] += count\n                else:\n                    # Multiple querysets for same model, combine with OR\n                    from django.db.models import Q\n                    combined_q = Q()\n                    for qs in querysets:\n                        combined_q |= Q(pk__in=qs.values_list('pk', flat=True))\n                    \n                    combined_qs = model.objects.filter(combined_q)\n                    count = combined_qs._raw_delete(using=self.using)\n                    deleted_counter[model._meta.label] += count\n",
      "\n            # fast deletes\n            # Group querysets by model to combine queries for the same table\n            fast_deletes_by_model = {}\n            for qs in self.fast_deletes:\n                model = qs.model\n                if model not in fast_deletes_by_model:\n                    fast_deletes_by_model[model] = []\n                fast_deletes_by_model[model].append(qs)\n            \n            # Execute combined queries for each model\n            for model, querysets in fast_deletes_by_model.items():\n                if len(querysets) == 1:\n                    # Single queryset, execute directly\n                    count = querysets[0]._raw_delete(using=self.using)\n                else:\n                    # Multiple querysets for same model, combine with OR\n                    from django.db.models import Q\n                    combined_q = Q()\n                    for qs in querysets:\n                        # Extract the WHERE clause as Q object\n                        if qs.query.where:\n                            combined_q |= Q(pk__in=qs.values_list('pk', flat=True))\n                        else:\n                            # If any queryset has no WHERE clause, it means delete all\n                            combined_q = Q()\n                            break\n                    \n                    # Create new queryset with combined conditions\n                    if combined_q.children or not combined_q:\n                        combined_qs = model._default_manager.filter(combined_q)\n                        count = combined_qs._raw_delete(using=self.using)\n                    else:\n                        # Delete all records for this model\n                        count = model._default_manager.all()._raw_delete(using=self.using)\n                \n                deleted_counter[model._meta.label] += count\n",
      "\n            # fast deletes\n            # Group querysets by model to combine them with OR conditions\n            fast_deletes_by_model = {}\n            for qs in self.fast_deletes:\n                model = qs.model\n                if model not in fast_deletes_by_model:\n                    fast_deletes_by_model[model] = []\n                fast_deletes_by_model[model].append(qs)\n            \n            # Execute combined queries for each model\n            for model, querysets in fast_deletes_by_model.items():\n                if len(querysets) == 1:\n                    # Single queryset, execute directly\n                    count = querysets[0]._raw_delete(using=self.using)\n                else:\n                    # Multiple querysets for same model, combine with OR\n                    from django.db.models import Q\n                    combined_q = Q()\n                    for qs in querysets:\n                        # Get the WHERE clause as a Q object\n                        where_q = Q()\n                        if qs.query.where:\n                            where_q.add(qs.query.where, Q.AND)\n                        combined_q.add(where_q, Q.OR)\n                    \n                    # Create a new queryset with the combined conditions\n                    combined_qs = model._default_manager.filter(combined_q)\n                    count = combined_qs._raw_delete(using=self.using)\n                \n                deleted_counter[model._meta.label] += count\n"
    ],
    "Location 2 (/root/hy/projects/django/django/db/models/deletion.py lines 193-194)": [
      "\n        if self.can_fast_delete(objs):\n            # Group fast deletes by model to enable query combination\n            model = objs[0].__class__\n            if model not in self.fast_deletes:\n                self.fast_deletes[model] = []\n            self.fast_deletes[model].append(objs)\n",
      "\n        if self.can_fast_delete(objs):\n            # Group by model to enable query combination later\n            model = objs[0].__class__ if objs else None\n            if model:\n                if not hasattr(self, '_fast_delete_groups'):\n                    self._fast_delete_groups = {}\n                if model not in self._fast_delete_groups:\n                    self._fast_delete_groups[model] = []\n                self._fast_delete_groups[model].append(objs)\n            self.fast_deletes.append(objs)\n            return\n",
      "\n        if self.can_fast_delete(objs):\n            # Group by model to enable combining multiple DELETE queries for the same table\n            model = objs[0].__class__\n            if model not in self.fast_deletes:\n                self.fast_deletes[model] = []\n            self.fast_deletes[model].append(objs)\n            return\n",
      "\n        if self.can_fast_delete(objs):\n            # Group fast deletes by model to combine queries later\n            model = objs[0].__class__\n            if model not in self.fast_deletes:\n                self.fast_deletes[model] = []\n            self.fast_deletes[model].append(objs)\n",
      "\n        if self.can_fast_delete(objs):\n            # Group by model to enable query combination later\n            model = objs[0].__class__\n            self.fast_deletes.setdefault(model, []).append(objs)\n",
      "\n        if self.can_fast_delete(objs):\n            # Group by model to enable query combination later\n            model = objs[0].__class__\n            if model not in self.fast_deletes:\n                self.fast_deletes[model] = []\n            self.fast_deletes[model].append(objs)\n            return\n",
      "\n        if self.can_fast_delete(objs):\n            # Group fast deletes by model to enable query combination\n            model = objs[0].__class__\n            if model not in self.fast_deletes:\n                self.fast_deletes[model] = []\n            self.fast_deletes[model].append(objs)\n",
      "\n        if self.can_fast_delete(objs):\n            # Group fast deletes by model to enable query combination\n            model = objs[0].__class__\n            if model not in self.fast_deletes:\n                self.fast_deletes[model] = []\n            self.fast_deletes[model].append(objs)\n"
    ],
    "Location 3 (/root/hy/projects/django/django/db/models/deletion.py lines 227-228)": [
      "\n                    if self.can_fast_delete(sub_objs, from_field=field):\n                        # Group by model for potential query combination\n                        model_key = sub_objs.model\n                        if model_key not in self.fast_deletes:\n                            self.fast_deletes[model_key] = []\n                        self.fast_deletes[model_key].append(sub_objs)\n",
      "\n                    if self.can_fast_delete(sub_objs, from_field=field):\n                        # Group by model for potential query combination\n                        model = sub_objs.model\n                        if not hasattr(self, '_fast_delete_groups'):\n                            self._fast_delete_groups = {}\n                        if model not in self._fast_delete_groups:\n                            self._fast_delete_groups[model] = []\n                        self._fast_delete_groups[model].append(sub_objs)\n",
      "\n                    if self.can_fast_delete(sub_objs, from_field=field):\n                        # Group by model for later combination\n                        model = sub_objs.model\n                        if model not in self.fast_deletes:\n                            self.fast_deletes[model] = []\n                        self.fast_deletes[model].append(sub_objs)\n",
      "\n                    if self.can_fast_delete(sub_objs, from_field=field):\n                        # Group by model for potential query combination\n                        model = sub_objs.model\n                        if model not in getattr(self, '_fast_delete_groups', {}):\n                            if not hasattr(self, '_fast_delete_groups'):\n                                self._fast_delete_groups = {}\n                            self._fast_delete_groups[model] = []\n                        self._fast_delete_groups[model].append(sub_objs)\n",
      "\n                    if self.can_fast_delete(sub_objs, from_field=field):\n                        # Group by model for later combination\n                        model = sub_objs.model\n                        if model not in getattr(self, '_fast_delete_groups', {}):\n                            if not hasattr(self, '_fast_delete_groups'):\n                                self._fast_delete_groups = {}\n                            self._fast_delete_groups[model] = []\n                        self._fast_delete_groups[model].append(sub_objs)\n",
      "\n                    if self.can_fast_delete(sub_objs, from_field=field):\n                        # Store both the queryset and the model for later grouping\n                        self.fast_deletes.append((sub_objs, related_model))\n",
      "\n                    if self.can_fast_delete(sub_objs, from_field=field):\n                        # Group fast deletes by model to enable query combination\n                        model = sub_objs.model\n                        if model not in self.fast_deletes:\n                            self.fast_deletes[model] = []\n                        self.fast_deletes[model].append(sub_objs)\n",
      "\n                if self.can_fast_delete(sub_objs, from_field=field):\n                    # Group by model for potential query combination\n                    model_key = sub_objs.model\n                    if model_key not in self.fast_deletes:\n                        self.fast_deletes[model_key] = []\n                    self.fast_deletes[model_key].append(sub_objs)\n"
    ],
    "Location 4 (/root/hy/projects/django/django/db/models/deletion.py lines 70-72)": [
      "\n        # fast_deletes is a dictionary of {model: [querysets]} that can be deleted without\n        # fetching the objects into memory.\n        self.fast_deletes = {}\n",
      "\n        # fast_deletes is a dictionary of {model: [querysets]} that can be deleted without\n        # fetching the objects into memory, grouped by model for query combination.\n        self.fast_deletes = {}\n",
      "\n        # Initially, {model: {instances}}, later values become lists.\n        self.data = {}\n        self.field_updates = {}  # {model: {(field, value): {instances}}}\n        # fast_deletes is a list of queryset-likes that can be deleted without\n        # fetching the objects into memory. These will be grouped by model\n        # and combined using OR conditions to optimize database queries.\n        self.fast_deletes = []\n",
      "\n        # Initially, {model: [querysets]}, later values become combined querysets.\n        self.fast_deletes = {}\n",
      "\n        # fast_deletes is a dictionary that groups queryset-likes by model\n        # so they can be combined into single DELETE queries with OR conditions.\n        self.fast_deletes = {}\n",
      "\n        # fast_deletes is a dict of {model: [querysets]} that can be deleted without\n        # fetching the objects into memory, grouped by model for query combination.\n        self.fast_deletes = {}\n",
      "\n        # fast_deletes is a dict of {model: [querysets]} that can be deleted without\n        # fetching the objects into memory, grouped by model for query combination.\n        self.fast_deletes = {}\n",
      "\n        # Initially, {model: {instances}}, later values become lists.\n        self.data = {}\n        self.field_updates = {}  # {model: {(field, value): {instances}}}\n        # fast_deletes is a list of queryset-likes that can be deleted without\n        # fetching the objects into memory. Will be grouped by model for optimization.\n        self.fast_deletes = []\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex ae82d26340..935110702c 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -67,6 +67,7 @@ class Collector:\n         # Initially, {model: {instances}}, later values become lists.\n         self.data = {}\n         self.field_updates = {}  # {model: {(field, value): {instances}}}\n+\n         # fast_deletes is a list of queryset-likes that can be deleted without\n         # fetching the objects into memory.\n         self.fast_deletes = []\n@@ -190,6 +191,7 @@ class Collector:\n \n         If 'keep_parents' is True, data of parent model's will be not deleted.\n         \"\"\"\n+\n         if self.can_fast_delete(objs):\n             self.fast_deletes.append(objs)\n             return\n@@ -224,6 +226,7 @@ class Collector:\n                 batches = self.get_del_batches(new_objs, field)\n                 for batch in batches:\n                     sub_objs = self.related_objects(related, batch)\n+\n                     if self.can_fast_delete(sub_objs, from_field=field):\n                         self.fast_deletes.append(sub_objs)\n                     else:\n@@ -310,9 +313,34 @@ class Collector:\n                     )\n \n             # fast deletes\n+\n+            # fast deletes\n+            # Group querysets by model to combine queries for the same table\n+            fast_deletes_by_model = {}\n             for qs in self.fast_deletes:\n-                count = qs._raw_delete(using=self.using)\n-                deleted_counter[qs.model._meta.label] += count\n+                model = qs.model\n+                if model not in fast_deletes_by_model:\n+                    fast_deletes_by_model[model] = []\n+                fast_deletes_by_model[model].append(qs)\n+            \n+            # Execute combined queries for each model\n+            for model, querysets in fast_deletes_by_model.items():\n+                if len(querysets) == 1:\n+                    # Single queryset, execute directly\n+                    count = querysets[0]._raw_delete(using=self.using)\n+                    deleted_counter[model._meta.label] += count\n+                else:\n+                    # Multiple querysets for same model, combine with OR\n+                    from django.db.models import Q\n+                    combined_q = Q()\n+                    for qs in querysets:\n+                        # Extract the WHERE conditions from each queryset\n+                        combined_q |= Q(pk__in=qs.values_list('pk', flat=True))\n+                    \n+                    # Create a new queryset with combined conditions\n+                    combined_qs = model._default_manager.using(self.using).filter(combined_q)\n+                    count = combined_qs._raw_delete(using=self.using)\n+                    deleted_counter[model._meta.label] += count\n \n             # update fields\n             for model, instances_for_fieldvalues in self.field_updates.items():\n",
    "variant_0": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex ae82d26340..f3a2781b74 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -67,9 +67,11 @@ class Collector:\n         # Initially, {model: {instances}}, later values become lists.\n         self.data = {}\n         self.field_updates = {}  # {model: {(field, value): {instances}}}\n-        # fast_deletes is a list of queryset-likes that can be deleted without\n-        # fetching the objects into memory.\n-        self.fast_deletes = []\n+\n+        # fast_deletes is a dictionary of {model: [querysets]} that can be deleted without\n+        # fetching the objects into memory. Multiple querysets for the same model\n+        # will be combined using OR conditions to optimize database queries.\n+        self.fast_deletes = {}\n \n         # Tracks deletion-order dependency for databases without transactions\n         # or ability to defer constraint checks. Only concrete model classes\n@@ -190,8 +192,13 @@ class Collector:\n \n         If 'keep_parents' is True, data of parent model's will be not deleted.\n         \"\"\"\n+\n         if self.can_fast_delete(objs):\n-            self.fast_deletes.append(objs)\n+            # Group fast deletes by model to enable query combination\n+            model = objs[0].__class__\n+            if model not in self.fast_deletes:\n+                self.fast_deletes[model] = []\n+            self.fast_deletes[model].append(objs)\n             return\n         new_objs = self.add(objs, source, nullable,\n                             reverse_dependency=reverse_dependency)\n@@ -224,8 +231,13 @@ class Collector:\n                 batches = self.get_del_batches(new_objs, field)\n                 for batch in batches:\n                     sub_objs = self.related_objects(related, batch)\n-                    if self.can_fast_delete(sub_objs, from_field=field):\n-                        self.fast_deletes.append(sub_objs)\n+\n+                if self.can_fast_delete(sub_objs, from_field=field):\n+                    # Group querysets by model for potential combination\n+                    model = sub_objs.model\n+                    if model not in self.fast_deletes:\n+                        self.fast_deletes[model] = []\n+                    self.fast_deletes[model].append(sub_objs)\n                     else:\n                         related_model = related.related_model\n                         # Non-referenced fields can be deferred if no signal\n@@ -310,9 +322,39 @@ class Collector:\n                     )\n \n             # fast deletes\n+\n+            # fast deletes\n+            # Group querysets by model to combine queries for the same table\n+            fast_deletes_by_model = {}\n             for qs in self.fast_deletes:\n-                count = qs._raw_delete(using=self.using)\n-                deleted_counter[qs.model._meta.label] += count\n+                model = qs.model\n+                if model not in fast_deletes_by_model:\n+                    fast_deletes_by_model[model] = []\n+                fast_deletes_by_model[model].append(qs)\n+            \n+            # Execute combined queries for each model\n+            for model, querysets in fast_deletes_by_model.items():\n+                if len(querysets) == 1:\n+                    # Single queryset, execute directly\n+                    count = querysets[0]._raw_delete(using=self.using)\n+                else:\n+                    # Multiple querysets for same model, combine with OR\n+                    from django.db.models import Q\n+                    combined_q = Q()\n+                    for qs in querysets:\n+                        # Get the WHERE condition from each queryset\n+                        if hasattr(qs.query, 'where') and qs.query.where:\n+                            combined_q |= Q(pk__in=qs.values_list('pk', flat=True))\n+                        else:\n+                            # If no WHERE clause, this deletes all records\n+                            combined_q = Q()\n+                            break\n+                    \n+                    # Create new queryset with combined conditions\n+                    combined_qs = model.objects.filter(combined_q)\n+                    count = combined_qs._raw_delete(using=self.using)\n+                \n+                deleted_counter[model._meta.label] += count\n \n             # update fields\n             for model, instances_for_fieldvalues in self.field_updates.items():\n",
    "variant_1": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex ae82d26340..e276b4f801 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -67,9 +67,10 @@ class Collector:\n         # Initially, {model: {instances}}, later values become lists.\n         self.data = {}\n         self.field_updates = {}  # {model: {(field, value): {instances}}}\n-        # fast_deletes is a list of queryset-likes that can be deleted without\n+\n+        # fast_deletes is a dictionary of {model: [querysets]} that can be deleted without\n         # fetching the objects into memory.\n-        self.fast_deletes = []\n+        self.fast_deletes = {}\n \n         # Tracks deletion-order dependency for databases without transactions\n         # or ability to defer constraint checks. Only concrete model classes\n@@ -190,8 +191,13 @@ class Collector:\n \n         If 'keep_parents' is True, data of parent model's will be not deleted.\n         \"\"\"\n+\n         if self.can_fast_delete(objs):\n-            self.fast_deletes.append(objs)\n+            # Group fast deletes by model to enable query combination\n+            model = objs[0].__class__\n+            if model not in self.fast_deletes:\n+                self.fast_deletes[model] = []\n+            self.fast_deletes[model].append(objs)\n             return\n         new_objs = self.add(objs, source, nullable,\n                             reverse_dependency=reverse_dependency)\n@@ -224,8 +230,13 @@ class Collector:\n                 batches = self.get_del_batches(new_objs, field)\n                 for batch in batches:\n                     sub_objs = self.related_objects(related, batch)\n+\n                     if self.can_fast_delete(sub_objs, from_field=field):\n-                        self.fast_deletes.append(sub_objs)\n+                        # Group by model for potential query combination\n+                        model_key = sub_objs.model\n+                        if model_key not in self.fast_deletes:\n+                            self.fast_deletes[model_key] = []\n+                        self.fast_deletes[model_key].append(sub_objs)\n                     else:\n                         related_model = related.related_model\n                         # Non-referenced fields can be deferred if no signal\n@@ -310,9 +321,39 @@ class Collector:\n                     )\n \n             # fast deletes\n+\n+            # fast deletes\n+            # Group querysets by model to combine multiple DELETE queries for the same table\n+            fast_deletes_by_model = {}\n             for qs in self.fast_deletes:\n-                count = qs._raw_delete(using=self.using)\n-                deleted_counter[qs.model._meta.label] += count\n+                model = qs.model\n+                if model not in fast_deletes_by_model:\n+                    fast_deletes_by_model[model] = []\n+                fast_deletes_by_model[model].append(qs)\n+            \n+            # Execute combined queries for each model\n+            for model, querysets in fast_deletes_by_model.items():\n+                if len(querysets) == 1:\n+                    # Single queryset, execute directly\n+                    count = querysets[0]._raw_delete(using=self.using)\n+                    deleted_counter[model._meta.label] += count\n+                else:\n+                    # Multiple querysets for same model, combine with OR\n+                    from django.db.models import Q\n+                    combined_q = Q()\n+                    for qs in querysets:\n+                        # Get the WHERE clause as a Q object\n+                        where = qs.query.where\n+                        if where.children:\n+                            q_obj = Q()\n+                            q_obj.add(where, Q.AND)\n+                            combined_q |= q_obj\n+                    \n+                    if combined_q:\n+                        # Create a new queryset with combined conditions\n+                        combined_qs = model._default_manager.filter(combined_q)\n+                        count = combined_qs._raw_delete(using=self.using)\n+                        deleted_counter[model._meta.label] += count\n \n             # update fields\n             for model, instances_for_fieldvalues in self.field_updates.items():\n",
    "variant_2": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex ae82d26340..c980133dd6 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -67,9 +67,10 @@ class Collector:\n         # Initially, {model: {instances}}, later values become lists.\n         self.data = {}\n         self.field_updates = {}  # {model: {(field, value): {instances}}}\n-        # fast_deletes is a list of queryset-likes that can be deleted without\n-        # fetching the objects into memory.\n-        self.fast_deletes = []\n+\n+        # fast_deletes is a dictionary of {model: [querysets]} that can be deleted without\n+        # fetching the objects into memory, grouped by model for query combination.\n+        self.fast_deletes = {}\n \n         # Tracks deletion-order dependency for databases without transactions\n         # or ability to defer constraint checks. Only concrete model classes\n@@ -190,9 +191,19 @@ class Collector:\n \n         If 'keep_parents' is True, data of parent model's will be not deleted.\n         \"\"\"\n+\n         if self.can_fast_delete(objs):\n+            # Group by model to enable query combination later\n+            model = objs[0].__class__ if objs else None\n+            if model:\n+                if not hasattr(self, '_fast_delete_groups'):\n+                    self._fast_delete_groups = {}\n+                if model not in self._fast_delete_groups:\n+                    self._fast_delete_groups[model] = []\n+                self._fast_delete_groups[model].append(objs)\n             self.fast_deletes.append(objs)\n             return\n+            return\n         new_objs = self.add(objs, source, nullable,\n                             reverse_dependency=reverse_dependency)\n         if not new_objs:\n@@ -224,8 +235,15 @@ class Collector:\n                 batches = self.get_del_batches(new_objs, field)\n                 for batch in batches:\n                     sub_objs = self.related_objects(related, batch)\n+\n                     if self.can_fast_delete(sub_objs, from_field=field):\n-                        self.fast_deletes.append(sub_objs)\n+                        # Group by model for potential query combination\n+                        model = sub_objs.model\n+                        if not hasattr(self, '_fast_delete_groups'):\n+                            self._fast_delete_groups = {}\n+                        if model not in self._fast_delete_groups:\n+                            self._fast_delete_groups[model] = []\n+                        self._fast_delete_groups[model].append(sub_objs)\n                     else:\n                         related_model = related.related_model\n                         # Non-referenced fields can be deferred if no signal\n@@ -310,9 +328,33 @@ class Collector:\n                     )\n \n             # fast deletes\n+\n+            # fast deletes\n+            # Group querysets by model to combine queries for the same table\n+            fast_delete_groups = {}\n             for qs in self.fast_deletes:\n-                count = qs._raw_delete(using=self.using)\n-                deleted_counter[qs.model._meta.label] += count\n+                model = qs.model\n+                if model not in fast_delete_groups:\n+                    fast_delete_groups[model] = []\n+                fast_delete_groups[model].append(qs)\n+            \n+            # Execute combined queries for each model\n+            for model, querysets in fast_delete_groups.items():\n+                if len(querysets) == 1:\n+                    # Single queryset, execute directly\n+                    count = querysets[0]._raw_delete(using=self.using)\n+                    deleted_counter[model._meta.label] += count\n+                else:\n+                    # Multiple querysets for same model, combine with OR\n+                    from django.db.models import Q\n+                    combined_q = Q()\n+                    for qs in querysets:\n+                        combined_q |= Q(pk__in=qs.values_list('pk', flat=True))\n+                    \n+                    # Create a new queryset with combined conditions\n+                    combined_qs = model._default_manager.using(self.using).filter(combined_q)\n+                    count = combined_qs._raw_delete(using=self.using)\n+                    deleted_counter[model._meta.label] += count\n \n             # update fields\n             for model, instances_for_fieldvalues in self.field_updates.items():\n",
    "variant_3": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex ae82d26340..239274d2e8 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -64,11 +64,16 @@ def get_candidate_relations_to_delete(opts):\n class Collector:\n     def __init__(self, using):\n         self.using = using\n+        # Initially, {model: {instances}}, later values become lists.\n+        self.data = {}\n+        self.field_updates = {}  # {model: {(field, value): {instances}}}\n+\n         # Initially, {model: {instances}}, later values become lists.\n         self.data = {}\n         self.field_updates = {}  # {model: {(field, value): {instances}}}\n         # fast_deletes is a list of queryset-likes that can be deleted without\n-        # fetching the objects into memory.\n+        # fetching the objects into memory. These will be grouped by model\n+        # and combined using OR conditions to optimize database queries.\n         self.fast_deletes = []\n \n         # Tracks deletion-order dependency for databases without transactions\n@@ -190,8 +195,14 @@ class Collector:\n \n         If 'keep_parents' is True, data of parent model's will be not deleted.\n         \"\"\"\n+\n         if self.can_fast_delete(objs):\n-            self.fast_deletes.append(objs)\n+            # Group by model to enable combining multiple DELETE queries for the same table\n+            model = objs[0].__class__\n+            if model not in self.fast_deletes:\n+                self.fast_deletes[model] = []\n+            self.fast_deletes[model].append(objs)\n+            return\n             return\n         new_objs = self.add(objs, source, nullable,\n                             reverse_dependency=reverse_dependency)\n@@ -224,8 +235,13 @@ class Collector:\n                 batches = self.get_del_batches(new_objs, field)\n                 for batch in batches:\n                     sub_objs = self.related_objects(related, batch)\n+\n                     if self.can_fast_delete(sub_objs, from_field=field):\n-                        self.fast_deletes.append(sub_objs)\n+                        # Group by model for later combination\n+                        model = sub_objs.model\n+                        if model not in self.fast_deletes:\n+                            self.fast_deletes[model] = []\n+                        self.fast_deletes[model].append(sub_objs)\n                     else:\n                         related_model = related.related_model\n                         # Non-referenced fields can be deferred if no signal\n@@ -310,9 +326,39 @@ class Collector:\n                     )\n \n             # fast deletes\n+\n+            # fast deletes\n+            # Group querysets by model to combine them with OR conditions\n+            fast_deletes_by_model = {}\n             for qs in self.fast_deletes:\n-                count = qs._raw_delete(using=self.using)\n-                deleted_counter[qs.model._meta.label] += count\n+                model = qs.model\n+                if model not in fast_deletes_by_model:\n+                    fast_deletes_by_model[model] = []\n+                fast_deletes_by_model[model].append(qs)\n+            \n+            # Execute combined queries for each model\n+            for model, querysets in fast_deletes_by_model.items():\n+                if len(querysets) == 1:\n+                    # Single queryset, execute directly\n+                    count = querysets[0]._raw_delete(using=self.using)\n+                else:\n+                    # Multiple querysets for same model, combine with OR\n+                    from django.db.models import Q\n+                    combined_q = Q()\n+                    for qs in querysets:\n+                        # Get the WHERE condition from each queryset\n+                        where = qs.query.where\n+                        if where:\n+                            combined_q |= Q(pk__in=qs.values_list('pk', flat=True))\n+                    \n+                    if combined_q:\n+                        # Create new queryset with combined conditions\n+                        combined_qs = model._default_manager.using(self.using).filter(combined_q)\n+                        count = combined_qs._raw_delete(using=self.using)\n+                    else:\n+                        count = 0\n+                \n+                deleted_counter[model._meta.label] += count\n \n             # update fields\n             for model, instances_for_fieldvalues in self.field_updates.items():\n",
    "variant_4": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex ae82d26340..853bb27560 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -67,9 +67,9 @@ class Collector:\n         # Initially, {model: {instances}}, later values become lists.\n         self.data = {}\n         self.field_updates = {}  # {model: {(field, value): {instances}}}\n-        # fast_deletes is a list of queryset-likes that can be deleted without\n-        # fetching the objects into memory.\n-        self.fast_deletes = []\n+\n+        # Initially, {model: [querysets]}, later values become combined querysets.\n+        self.fast_deletes = {}\n \n         # Tracks deletion-order dependency for databases without transactions\n         # or ability to defer constraint checks. Only concrete model classes\n@@ -190,8 +190,13 @@ class Collector:\n \n         If 'keep_parents' is True, data of parent model's will be not deleted.\n         \"\"\"\n+\n         if self.can_fast_delete(objs):\n-            self.fast_deletes.append(objs)\n+            # Group fast deletes by model to combine queries later\n+            model = objs[0].__class__\n+            if model not in self.fast_deletes:\n+                self.fast_deletes[model] = []\n+            self.fast_deletes[model].append(objs)\n             return\n         new_objs = self.add(objs, source, nullable,\n                             reverse_dependency=reverse_dependency)\n@@ -224,8 +229,15 @@ class Collector:\n                 batches = self.get_del_batches(new_objs, field)\n                 for batch in batches:\n                     sub_objs = self.related_objects(related, batch)\n+\n                     if self.can_fast_delete(sub_objs, from_field=field):\n-                        self.fast_deletes.append(sub_objs)\n+                        # Group by model for potential query combination\n+                        model = sub_objs.model\n+                        if model not in getattr(self, '_fast_delete_groups', {}):\n+                            if not hasattr(self, '_fast_delete_groups'):\n+                                self._fast_delete_groups = {}\n+                            self._fast_delete_groups[model] = []\n+                        self._fast_delete_groups[model].append(sub_objs)\n                     else:\n                         related_model = related.related_model\n                         # Non-referenced fields can be deferred if no signal\n@@ -310,9 +322,32 @@ class Collector:\n                     )\n \n             # fast deletes\n+\n+            # fast deletes\n+            # Group querysets by model to combine queries for the same table\n+            fast_deletes_by_model = {}\n             for qs in self.fast_deletes:\n-                count = qs._raw_delete(using=self.using)\n-                deleted_counter[qs.model._meta.label] += count\n+                model = qs.model\n+                if model not in fast_deletes_by_model:\n+                    fast_deletes_by_model[model] = []\n+                fast_deletes_by_model[model].append(qs)\n+            \n+            # Execute combined queries for each model\n+            for model, querysets in fast_deletes_by_model.items():\n+                if len(querysets) == 1:\n+                    # Single queryset, execute directly\n+                    count = querysets[0]._raw_delete(using=self.using)\n+                    deleted_counter[model._meta.label] += count\n+                else:\n+                    # Multiple querysets for same model, combine with OR\n+                    from django.db.models import Q\n+                    combined_q = Q()\n+                    for qs in querysets:\n+                        combined_q |= Q(pk__in=qs.values_list('pk', flat=True))\n+                    \n+                    combined_qs = model.objects.filter(combined_q)\n+                    count = combined_qs._raw_delete(using=self.using)\n+                    deleted_counter[model._meta.label] += count\n \n             # update fields\n             for model, instances_for_fieldvalues in self.field_updates.items():\n",
    "variant_5": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex ae82d26340..d7abab64f0 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -67,9 +67,10 @@ class Collector:\n         # Initially, {model: {instances}}, later values become lists.\n         self.data = {}\n         self.field_updates = {}  # {model: {(field, value): {instances}}}\n-        # fast_deletes is a list of queryset-likes that can be deleted without\n-        # fetching the objects into memory.\n-        self.fast_deletes = []\n+\n+        # fast_deletes is a dictionary that groups queryset-likes by model\n+        # so they can be combined into single DELETE queries with OR conditions.\n+        self.fast_deletes = {}\n \n         # Tracks deletion-order dependency for databases without transactions\n         # or ability to defer constraint checks. Only concrete model classes\n@@ -190,8 +191,11 @@ class Collector:\n \n         If 'keep_parents' is True, data of parent model's will be not deleted.\n         \"\"\"\n+\n         if self.can_fast_delete(objs):\n-            self.fast_deletes.append(objs)\n+            # Group by model to enable query combination later\n+            model = objs[0].__class__\n+            self.fast_deletes.setdefault(model, []).append(objs)\n             return\n         new_objs = self.add(objs, source, nullable,\n                             reverse_dependency=reverse_dependency)\n@@ -224,8 +228,15 @@ class Collector:\n                 batches = self.get_del_batches(new_objs, field)\n                 for batch in batches:\n                     sub_objs = self.related_objects(related, batch)\n+\n                     if self.can_fast_delete(sub_objs, from_field=field):\n-                        self.fast_deletes.append(sub_objs)\n+                        # Group by model for later combination\n+                        model = sub_objs.model\n+                        if model not in getattr(self, '_fast_delete_groups', {}):\n+                            if not hasattr(self, '_fast_delete_groups'):\n+                                self._fast_delete_groups = {}\n+                            self._fast_delete_groups[model] = []\n+                        self._fast_delete_groups[model].append(sub_objs)\n                     else:\n                         related_model = related.related_model\n                         # Non-referenced fields can be deferred if no signal\n@@ -310,9 +321,44 @@ class Collector:\n                     )\n \n             # fast deletes\n+\n+            # fast deletes\n+            # Group querysets by model to combine DELETE queries\n+            fast_deletes_by_model = {}\n             for qs in self.fast_deletes:\n-                count = qs._raw_delete(using=self.using)\n-                deleted_counter[qs.model._meta.label] += count\n+                model = qs.model\n+                if model not in fast_deletes_by_model:\n+                    fast_deletes_by_model[model] = []\n+                fast_deletes_by_model[model].append(qs)\n+            \n+            # Execute combined queries for each model\n+            for model, querysets in fast_deletes_by_model.items():\n+                if len(querysets) == 1:\n+                    # Single queryset, execute directly\n+                    count = querysets[0]._raw_delete(using=self.using)\n+                else:\n+                    # Multiple querysets for same model, combine with OR\n+                    from django.db.models import Q\n+                    combined_q = Q()\n+                    for qs in querysets:\n+                        # Get the WHERE clause from each queryset\n+                        where_clause = qs.query.where\n+                        if where_clause:\n+                            combined_q |= Q(**{pk_field.name + '__in': qs.values_list('pk', flat=True)})\n+                        else:\n+                            # If no WHERE clause, this deletes all objects\n+                            combined_q = Q()\n+                            break\n+                    \n+                    # Create a new queryset with combined conditions\n+                    pk_field = model._meta.pk\n+                    if combined_q:\n+                        combined_qs = model._default_manager.using(self.using).filter(combined_q)\n+                    else:\n+                        combined_qs = model._default_manager.using(self.using).all()\n+                    count = combined_qs._raw_delete(using=self.using)\n+                \n+                deleted_counter[model._meta.label] += count\n \n             # update fields\n             for model, instances_for_fieldvalues in self.field_updates.items():\n",
    "variant_6": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex ae82d26340..e17ecd6d12 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -67,9 +67,10 @@ class Collector:\n         # Initially, {model: {instances}}, later values become lists.\n         self.data = {}\n         self.field_updates = {}  # {model: {(field, value): {instances}}}\n-        # fast_deletes is a list of queryset-likes that can be deleted without\n-        # fetching the objects into memory.\n-        self.fast_deletes = []\n+\n+        # fast_deletes is a dict of {model: [querysets]} that can be deleted without\n+        # fetching the objects into memory, grouped by model for query combination.\n+        self.fast_deletes = {}\n \n         # Tracks deletion-order dependency for databases without transactions\n         # or ability to defer constraint checks. Only concrete model classes\n@@ -190,8 +191,14 @@ class Collector:\n \n         If 'keep_parents' is True, data of parent model's will be not deleted.\n         \"\"\"\n+\n         if self.can_fast_delete(objs):\n-            self.fast_deletes.append(objs)\n+            # Group by model to enable query combination later\n+            model = objs[0].__class__\n+            if model not in self.fast_deletes:\n+                self.fast_deletes[model] = []\n+            self.fast_deletes[model].append(objs)\n+            return\n             return\n         new_objs = self.add(objs, source, nullable,\n                             reverse_dependency=reverse_dependency)\n@@ -224,8 +231,10 @@ class Collector:\n                 batches = self.get_del_batches(new_objs, field)\n                 for batch in batches:\n                     sub_objs = self.related_objects(related, batch)\n+\n                     if self.can_fast_delete(sub_objs, from_field=field):\n-                        self.fast_deletes.append(sub_objs)\n+                        # Store both the queryset and the model for later grouping\n+                        self.fast_deletes.append((sub_objs, related_model))\n                     else:\n                         related_model = related.related_model\n                         # Non-referenced fields can be deferred if no signal\n@@ -310,9 +319,32 @@ class Collector:\n                     )\n \n             # fast deletes\n+\n+            # fast deletes\n+            # Group querysets by model to combine multiple DELETE queries for the same table\n+            fast_deletes_by_model = {}\n             for qs in self.fast_deletes:\n-                count = qs._raw_delete(using=self.using)\n-                deleted_counter[qs.model._meta.label] += count\n+                model = qs.model\n+                if model not in fast_deletes_by_model:\n+                    fast_deletes_by_model[model] = []\n+                fast_deletes_by_model[model].append(qs)\n+            \n+            # Execute combined queries for each model\n+            for model, querysets in fast_deletes_by_model.items():\n+                if len(querysets) == 1:\n+                    # Single queryset, execute directly\n+                    count = querysets[0]._raw_delete(using=self.using)\n+                    deleted_counter[model._meta.label] += count\n+                else:\n+                    # Multiple querysets for same model, combine with OR\n+                    from django.db.models import Q\n+                    combined_q = Q()\n+                    for qs in querysets:\n+                        combined_q |= Q(pk__in=qs.values_list('pk', flat=True))\n+                    \n+                    combined_qs = model.objects.filter(combined_q)\n+                    count = combined_qs._raw_delete(using=self.using)\n+                    deleted_counter[model._meta.label] += count\n \n             # update fields\n             for model, instances_for_fieldvalues in self.field_updates.items():\n",
    "variant_7": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex ae82d26340..f1c6d1a962 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -67,9 +67,10 @@ class Collector:\n         # Initially, {model: {instances}}, later values become lists.\n         self.data = {}\n         self.field_updates = {}  # {model: {(field, value): {instances}}}\n-        # fast_deletes is a list of queryset-likes that can be deleted without\n-        # fetching the objects into memory.\n-        self.fast_deletes = []\n+\n+        # fast_deletes is a dict of {model: [querysets]} that can be deleted without\n+        # fetching the objects into memory, grouped by model for query combination.\n+        self.fast_deletes = {}\n \n         # Tracks deletion-order dependency for databases without transactions\n         # or ability to defer constraint checks. Only concrete model classes\n@@ -190,8 +191,13 @@ class Collector:\n \n         If 'keep_parents' is True, data of parent model's will be not deleted.\n         \"\"\"\n+\n         if self.can_fast_delete(objs):\n-            self.fast_deletes.append(objs)\n+            # Group fast deletes by model to enable query combination\n+            model = objs[0].__class__\n+            if model not in self.fast_deletes:\n+                self.fast_deletes[model] = []\n+            self.fast_deletes[model].append(objs)\n             return\n         new_objs = self.add(objs, source, nullable,\n                             reverse_dependency=reverse_dependency)\n@@ -224,8 +230,13 @@ class Collector:\n                 batches = self.get_del_batches(new_objs, field)\n                 for batch in batches:\n                     sub_objs = self.related_objects(related, batch)\n+\n                     if self.can_fast_delete(sub_objs, from_field=field):\n-                        self.fast_deletes.append(sub_objs)\n+                        # Group fast deletes by model to enable query combination\n+                        model = sub_objs.model\n+                        if model not in self.fast_deletes:\n+                            self.fast_deletes[model] = []\n+                        self.fast_deletes[model].append(sub_objs)\n                     else:\n                         related_model = related.related_model\n                         # Non-referenced fields can be deferred if no signal\n@@ -310,9 +321,43 @@ class Collector:\n                     )\n \n             # fast deletes\n+\n+            # fast deletes\n+            # Group querysets by model to combine queries for the same table\n+            fast_deletes_by_model = {}\n             for qs in self.fast_deletes:\n-                count = qs._raw_delete(using=self.using)\n-                deleted_counter[qs.model._meta.label] += count\n+                model = qs.model\n+                if model not in fast_deletes_by_model:\n+                    fast_deletes_by_model[model] = []\n+                fast_deletes_by_model[model].append(qs)\n+            \n+            # Execute combined queries for each model\n+            for model, querysets in fast_deletes_by_model.items():\n+                if len(querysets) == 1:\n+                    # Single queryset, execute directly\n+                    count = querysets[0]._raw_delete(using=self.using)\n+                else:\n+                    # Multiple querysets for same model, combine with OR\n+                    from django.db.models import Q\n+                    combined_q = Q()\n+                    for qs in querysets:\n+                        # Extract the WHERE clause as Q object\n+                        if qs.query.where:\n+                            combined_q |= Q(pk__in=qs.values_list('pk', flat=True))\n+                        else:\n+                            # If any queryset has no WHERE clause, it means delete all\n+                            combined_q = Q()\n+                            break\n+                    \n+                    # Create new queryset with combined conditions\n+                    if combined_q.children or not combined_q:\n+                        combined_qs = model._default_manager.filter(combined_q)\n+                        count = combined_qs._raw_delete(using=self.using)\n+                    else:\n+                        # Delete all records for this model\n+                        count = model._default_manager.all()._raw_delete(using=self.using)\n+                \n+                deleted_counter[model._meta.label] += count\n \n             # update fields\n             for model, instances_for_fieldvalues in self.field_updates.items():\n",
    "variant_8": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex ae82d26340..0dee6f3c74 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -64,11 +64,15 @@ def get_candidate_relations_to_delete(opts):\n class Collector:\n     def __init__(self, using):\n         self.using = using\n+        # Initially, {model: {instances}}, later values become lists.\n+        self.data = {}\n+        self.field_updates = {}  # {model: {(field, value): {instances}}}\n+\n         # Initially, {model: {instances}}, later values become lists.\n         self.data = {}\n         self.field_updates = {}  # {model: {(field, value): {instances}}}\n         # fast_deletes is a list of queryset-likes that can be deleted without\n-        # fetching the objects into memory.\n+        # fetching the objects into memory. Will be grouped by model for optimization.\n         self.fast_deletes = []\n \n         # Tracks deletion-order dependency for databases without transactions\n@@ -190,8 +194,13 @@ class Collector:\n \n         If 'keep_parents' is True, data of parent model's will be not deleted.\n         \"\"\"\n+\n         if self.can_fast_delete(objs):\n-            self.fast_deletes.append(objs)\n+            # Group fast deletes by model to enable query combination\n+            model = objs[0].__class__\n+            if model not in self.fast_deletes:\n+                self.fast_deletes[model] = []\n+            self.fast_deletes[model].append(objs)\n             return\n         new_objs = self.add(objs, source, nullable,\n                             reverse_dependency=reverse_dependency)\n@@ -224,8 +233,13 @@ class Collector:\n                 batches = self.get_del_batches(new_objs, field)\n                 for batch in batches:\n                     sub_objs = self.related_objects(related, batch)\n-                    if self.can_fast_delete(sub_objs, from_field=field):\n-                        self.fast_deletes.append(sub_objs)\n+\n+                if self.can_fast_delete(sub_objs, from_field=field):\n+                    # Group by model for potential query combination\n+                    model_key = sub_objs.model\n+                    if model_key not in self.fast_deletes:\n+                        self.fast_deletes[model_key] = []\n+                    self.fast_deletes[model_key].append(sub_objs)\n                     else:\n                         related_model = related.related_model\n                         # Non-referenced fields can be deferred if no signal\n@@ -310,9 +324,37 @@ class Collector:\n                     )\n \n             # fast deletes\n+\n+            # fast deletes\n+            # Group querysets by model to combine them with OR conditions\n+            fast_deletes_by_model = {}\n             for qs in self.fast_deletes:\n-                count = qs._raw_delete(using=self.using)\n-                deleted_counter[qs.model._meta.label] += count\n+                model = qs.model\n+                if model not in fast_deletes_by_model:\n+                    fast_deletes_by_model[model] = []\n+                fast_deletes_by_model[model].append(qs)\n+            \n+            # Execute combined queries for each model\n+            for model, querysets in fast_deletes_by_model.items():\n+                if len(querysets) == 1:\n+                    # Single queryset, execute directly\n+                    count = querysets[0]._raw_delete(using=self.using)\n+                else:\n+                    # Multiple querysets for same model, combine with OR\n+                    from django.db.models import Q\n+                    combined_q = Q()\n+                    for qs in querysets:\n+                        # Get the WHERE clause as a Q object\n+                        where_q = Q()\n+                        if qs.query.where:\n+                            where_q.add(qs.query.where, Q.AND)\n+                        combined_q.add(where_q, Q.OR)\n+                    \n+                    # Create a new queryset with the combined conditions\n+                    combined_qs = model._default_manager.filter(combined_q)\n+                    count = combined_qs._raw_delete(using=self.using)\n+                \n+                deleted_counter[model._meta.label] += count\n \n             # update fields\n             for model, instances_for_fieldvalues in self.field_updates.items():\n"
  }
}