{
  "zero_patches": {
    "Location 1 (/root/hy/projects/django/django/db/models/options.py lines 242-257)": "\n        if self.pk is None:\n            if self.parents:\n                # Find the field with explicit parent_link=True, or fall back to first field\n                field = None\n                for parent_field in self.parents.values():\n                    if parent_field and getattr(parent_field.remote_field, 'parent_link', False):\n                        field = parent_field\n                        break\n                \n                # If no explicit parent_link=True found, use the first one (backward compatibility)\n                if field is None:\n                    field = next(iter(self.parents.values()))\n                \n                # Look for a local field with the same name as the\n                # first parent link. If a local field has already been\n                # created, use it instead of promoting the parent\n                already_created = [fld for fld in self.local_fields if fld.name == field.name]\n                if already_created:\n                    field = already_created[0]\n                field.primary_key = True\n                self.setup_pk(field)\n                if not field.remote_field.parent_link:\n                    raise ImproperlyConfigured(\n                        'Add parent_link=True to %s.' % field,\n                    )\n",
    "Location 2 (/root/hy/projects/django/django/db/models/base.py lines 194-207)": "\n        # Collect the parent links for multi-table inheritance.\n        parent_links = {}\n        for base in reversed([new_class] + parents):\n            # Conceptually equivalent to `if base is Model`.\n            if not hasattr(base, '_meta'):\n                continue\n            # Skip concrete parent classes.\n            if base != new_class and not base._meta.abstract:\n                continue\n            # Locate OneToOneField instances.\n            for field in base._meta.local_fields:\n                if isinstance(field, OneToOneField):\n                    related = resolve_relation(new_class, field.remote_field.model)\n                    parent_links[make_model_tuple(related)] = field\n",
    "Location 3 (/root/hy/projects/django/django/db/models/base.py lines 236-268)": "\n    def _prepare(self, model):\n        if self.order_with_respect_to:\n            # The app registry will not be ready at this point, so we cannot\n            # use get_field().\n            query = self.order_with_respect_to\n            try:\n                self.order_with_respect_to = next(\n                    f for f in self._get_fields(reverse=False)\n                    if f.name == query or f.attname == query\n                )\n            except StopIteration:\n                raise FieldDoesNotExist(\"%s has no field named '%s'\" % (self.object_name, query))\n\n        self.ordering = tuple(self.ordering)\n        self.unique_together = normalize_together(self.unique_together)\n        self.index_together = normalize_together(self.index_together)\n        # App label/class name interpolation for names of constraints and\n        # indexes.\n        if not getattr(cls, '_deferred', False):\n            self._make_fields_lazy()\n\n        if self.pk is None:\n            if self.parents:\n                # Find the field with explicit parent_link=True, or fall back to first field\n                field = None\n                for parent_field in self.parents.values():\n                    if parent_field and getattr(parent_field.remote_field, 'parent_link', False):\n                        field = parent_field\n                        break\n                \n                # If no explicit parent_link=True found, use the first one (backward compatibility)\n                if field is None:\n                    field = next(iter(self.parents.values()))\n                \n                if field:\n                    # Promote the parent's primary key to this one.\n                    field.primary_key = True\n                    self.setup_pk(field)\n            else:\n                auto_field = AutoField(verbose_name='ID', primary_key=True, auto_created=True)\n                model.add_to_class('id', auto_field)\n",
    "Location 4 (/root/hy/projects/django/django/db/models/base.py lines 204-207)": "\n        # Collect the parent links for multi-table inheritance.\n        parent_links = {}\n        for base in reversed([new_class] + parents):\n            # Conceptually equivalent to `if base is Model`.\n            if not hasattr(base, '_meta'):\n                continue\n            # Skip concrete parent classes.\n            if base != new_class and not base._meta.abstract:\n                continue\n            # Locate OneToOneField instances.\n            for field in base._meta.local_fields:\n                if isinstance(field, OneToOneField):\n                    related = resolve_relation(new_class, field.remote_field.model)\n                    parent_links[make_model_tuple(related)] = field\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/django/django/db/models/options.py lines 242-257)": [
      "\n        if self.pk is None:\n            if self.parents:\n                # Look for a field with explicit parent_link=True first\n                field = None\n                for parent_field in self.parents.values():\n                    if parent_field and getattr(parent_field.remote_field, 'parent_link', False):\n                        field = parent_field\n                        break\n                \n                # If no explicit parent_link=True found, use the first one (backward compatibility)\n                if field is None:\n                    field = next(iter(self.parents.values()))\n                \n                # Look for a local field with the same name as the\n                # selected parent link. If a local field has already been\n                # created, use it instead of promoting the parent\n                already_created = [fld for fld in self.local_fields if fld.name == field.name]\n                if already_created:\n                    field = already_created[0]\n                field.primary_key = True\n                self.setup_pk(field)\n                if not field.remote_field.parent_link:\n                    raise ImproperlyConfigured(\n                        'Add parent_link=True to %s.' % field,\n                    )\n",
      "\n        if self.pk is None:\n            if self.parents:\n                # Find the field with explicit parent_link=True, or fall back to first field\n                field = None\n                for parent_field in self.parents.values():\n                    if parent_field and getattr(parent_field.remote_field, 'parent_link', False):\n                        field = parent_field\n                        break\n                \n                # If no explicit parent_link=True found, use the first one (backward compatibility)\n                if field is None:\n                    field = next(iter(self.parents.values()))\n                \n                # Look for a local field with the same name as the\n                # first parent link. If a local field has already been\n                # created, use it instead of promoting the parent\n                already_created = [fld for fld in self.local_fields if fld.name == field.name]\n                if already_created:\n                    field = already_created[0]\n                field.primary_key = True\n                self.setup_pk(field)\n                if not field.remote_field.parent_link:\n                    raise ImproperlyConfigured(\n                        'Add parent_link=True to %s.' % field,\n                    )\n",
      "\n        if self.pk is None:\n            if self.parents:\n                # Look for a field with explicit parent_link=True first\n                field = None\n                for parent_field in self.parents.values():\n                    if parent_field and getattr(parent_field.remote_field, 'parent_link', False):\n                        field = parent_field\n                        break\n                \n                # If no explicit parent_link=True found, use the first one (backward compatibility)\n                if field is None:\n                    field = next(iter(self.parents.values()))\n                \n                # Look for a local field with the same name as the\n                # selected parent link. If a local field has already been\n                # created, use it instead of promoting the parent\n                already_created = [fld for fld in self.local_fields if fld.name == field.name]\n                if already_created:\n                    field = already_created[0]\n                field.primary_key = True\n                self.setup_pk(field)\n                if not field.remote_field.parent_link:\n                    raise ImproperlyConfigured(\n                        'Add parent_link=True to %s.' % field,\n                    )\n",
      "\n        if self.pk is None:\n            if self.parents:\n                # Find the field with explicit parent_link=True, or fall back to first field\n                field = None\n                for parent_field in self.parents.values():\n                    if parent_field and getattr(parent_field.remote_field, 'parent_link', False):\n                        field = parent_field\n                        break\n                \n                # If no explicit parent_link=True found, use the first one (backward compatibility)\n                if field is None:\n                    field = next(iter(self.parents.values()))\n                \n                # Look for a local field with the same name as the\n                # selected parent link. If a local field has already been\n                # created, use it instead of promoting the parent\n                already_created = [fld for fld in self.local_fields if fld.name == field.name]\n                if already_created:\n                    field = already_created[0]\n                field.primary_key = True\n                self.setup_pk(field)\n                if not field.remote_field.parent_link:\n                    raise ImproperlyConfigured(\n                        'Add parent_link=True to %s.' % field,\n                    )\n",
      "\n        if self.pk is None:\n            if self.parents:\n                # Find the field with explicit parent_link=True, or fall back to first field\n                field = None\n                for parent_field in self.parents.values():\n                    if parent_field and getattr(parent_field.remote_field, 'parent_link', False):\n                        field = parent_field\n                        break\n                \n                # If no explicit parent_link=True found, use the first one (backward compatibility)\n                if field is None:\n                    field = next(iter(self.parents.values()))\n                \n                # Look for a local field with the same name as the\n                # first parent link. If a local field has already been\n                # created, use it instead of promoting the parent\n                already_created = [fld for fld in self.local_fields if fld.name == field.name]\n                if already_created:\n                    field = already_created[0]\n                field.primary_key = True\n                self.setup_pk(field)\n                if not field.remote_field.parent_link:\n                    raise ImproperlyConfigured(\n                        'Add parent_link=True to %s.' % field,\n                    )\n",
      "\n        if self.pk is None:\n            if self.parents:\n                # Look for a field with explicit parent_link=True first\n                field = None\n                for parent_field in self.parents.values():\n                    if parent_field and getattr(parent_field.remote_field, 'parent_link', False):\n                        field = parent_field\n                        break\n                \n                # If no explicit parent_link=True found, use the first one (backward compatibility)\n                if field is None:\n                    field = next(iter(self.parents.values()))\n                \n                # Look for a local field with the same name as the\n                # selected parent link. If a local field has already been\n                # created, use it instead of promoting the parent\n                already_created = [fld for fld in self.local_fields if fld.name == field.name]\n                if already_created:\n                    field = already_created[0]\n                field.primary_key = True\n                self.setup_pk(field)\n                if not field.remote_field.parent_link:\n                    raise ImproperlyConfigured(\n                        'Add parent_link=True to %s.' % field,\n                    )\n",
      "\n        if self.pk is None:\n            if self.parents:\n                # Look for a field with explicit parent_link=True first\n                field = None\n                for parent_field in self.parents.values():\n                    if parent_field and getattr(parent_field.remote_field, 'parent_link', False):\n                        field = parent_field\n                        break\n                \n                # If no explicit parent_link=True found, use the first one (backward compatibility)\n                if field is None:\n                    field = next(iter(self.parents.values()))\n                \n                # Look for a local field with the same name as the\n                # selected parent link. If a local field has already been\n                # created, use it instead of promoting the parent\n                already_created = [fld for fld in self.local_fields if fld.name == field.name]\n                if already_created:\n                    field = already_created[0]\n                field.primary_key = True\n                self.setup_pk(field)\n                if not field.remote_field.parent_link:\n                    raise ImproperlyConfigured(\n                        'Add parent_link=True to %s.' % field,\n                    )\n",
      "\n        if self.pk is None:\n            if self.parents:\n                # Find the field with explicit parent_link=True, or fall back to first field\n                field = None\n                for parent_field in self.parents.values():\n                    if parent_field and getattr(parent_field.remote_field, 'parent_link', False):\n                        field = parent_field\n                        break\n                \n                # If no explicit parent_link=True found, use the first one (backward compatibility)\n                if field is None:\n                    field = next(iter(self.parents.values()))\n                \n                # Look for a local field with the same name as the\n                # selected parent link. If a local field has already been\n                # created, use it instead of promoting the parent\n                already_created = [fld for fld in self.local_fields if fld.name == field.name]\n                if already_created:\n                    field = already_created[0]\n                field.primary_key = True\n                self.setup_pk(field)\n                if not field.remote_field.parent_link:\n                    raise ImproperlyConfigured(\n                        'Add parent_link=True to %s.' % field,\n                    )\n"
    ],
    "Location 2 (/root/hy/projects/django/django/db/models/base.py lines 194-207)": [
      "\n        # Collect the parent links for multi-table inheritance.\n        parent_links = {}\n        for base in reversed([new_class] + parents):\n            # Conceptually equivalent to `if base is Model`.\n            if not hasattr(base, '_meta'):\n                continue\n            # Skip concrete parent classes.\n            if base != new_class and not base._meta.abstract:\n                continue\n            # Locate OneToOneField instances.\n            for field in base._meta.local_fields:\n                if isinstance(field, OneToOneField):\n                    related = resolve_relation(new_class, field.remote_field.model)\n                    parent_links[make_model_tuple(related)] = field\n",
      "\n        # Collect the parent links for multi-table inheritance.\n        parent_links = {}\n        for base in reversed([new_class] + parents):\n            # Conceptually equivalent to `if base is Model`.\n            if not hasattr(base, '_meta'):\n                continue\n            # Skip concrete parent classes.\n            if base != new_class and not base._meta.abstract:\n                continue\n            # Locate OneToOneField instances.\n            for field in base._meta.local_fields:\n                if isinstance(field, OneToOneField):\n                    related = resolve_relation(new_class, field.remote_field.model)\n                    parent_links[make_model_tuple(related)] = field\n",
      "\n        # Collect the parent links for multi-table inheritance.\n        parent_links = {}\n        for base in reversed([new_class] + parents):\n            # Conceptually equivalent to `if base is Model`.\n            if not hasattr(base, '_meta'):\n                continue\n            # Skip concrete parent classes.\n            if base != new_class and not base._meta.abstract:\n                continue\n            # Locate OneToOneField instances.\n            for field in base._meta.local_fields:\n                if isinstance(field, OneToOneField):\n                    related = resolve_relation(new_class, field.remote_field.model)\n                    parent_links[make_model_tuple(related)] = field\n",
      "\n        # Collect the parent links for multi-table inheritance.\n        parent_links = {}\n        for base in reversed([new_class] + parents):\n            # Conceptually equivalent to `if base is Model`.\n            if not hasattr(base, '_meta'):\n                continue\n            # Skip concrete parent classes.\n            if base != new_class and not base._meta.abstract:\n                continue\n            # Locate OneToOneField instances.\n            for field in base._meta.local_fields:\n                if isinstance(field, OneToOneField):\n                    related = resolve_relation(new_class, field.remote_field.model)\n                    parent_links[make_model_tuple(related)] = field\n",
      "\n        # Collect the parent links for multi-table inheritance.\n        parent_links = {}\n        for base in reversed([new_class] + parents):\n            # Conceptually equivalent to `if base is Model`.\n            if not hasattr(base, '_meta'):\n                continue\n            # Skip concrete parent classes.\n            if base != new_class and not base._meta.abstract:\n                continue\n            # Locate OneToOneField instances.\n            for field in base._meta.local_fields:\n                if isinstance(field, OneToOneField):\n                    related = resolve_relation(new_class, field.remote_field.model)\n                    parent_links[make_model_tuple(related)] = field\n",
      "\n        # Collect the parent links for multi-table inheritance.\n        parent_links = {}\n        for base in reversed([new_class] + parents):\n            # Conceptually equivalent to `if base is Model`.\n            if not hasattr(base, '_meta'):\n                continue\n            # Skip concrete parent classes.\n            if base != new_class and not base._meta.abstract:\n                continue\n            # Locate OneToOneField instances.\n            for field in base._meta.local_fields:\n                if isinstance(field, OneToOneField):\n                    related = resolve_relation(new_class, field.remote_field.model)\n                    parent_links[make_model_tuple(related)] = field\n",
      "\n        # Collect the parent links for multi-table inheritance.\n        parent_links = {}\n        for base in reversed([new_class] + parents):\n            # Conceptually equivalent to `if base is Model`.\n            if not hasattr(base, '_meta'):\n                continue\n            # Skip concrete parent classes.\n            if base != new_class and not base._meta.abstract:\n                continue\n            # Locate OneToOneField instances.\n            for field in base._meta.local_fields:\n                if isinstance(field, OneToOneField):\n                    related = resolve_relation(new_class, field.remote_field.model)\n                    parent_links[make_model_tuple(related)] = field\n",
      "\n        # Collect the parent links for multi-table inheritance.\n        parent_links = {}\n        for base in reversed([new_class] + parents):\n            # Conceptually equivalent to `if base is Model`.\n            if not hasattr(base, '_meta'):\n                continue\n            # Skip concrete parent classes.\n            if base != new_class and not base._meta.abstract:\n                continue\n            # Locate OneToOneField instances.\n            for field in base._meta.local_fields:\n                if isinstance(field, OneToOneField):\n                    related = resolve_relation(new_class, field.remote_field.model)\n                    parent_links[make_model_tuple(related)] = field\n"
    ],
    "Location 3 (/root/hy/projects/django/django/db/models/base.py lines 236-268)": [
      "\n    def _prepare(self, model):\n        if self.order_with_respect_to:\n            # The app registry will not be ready at this point, so we cannot\n            # use get_field().\n            query_name = None\n            try:\n                self.order_with_respect_to.related_model\n            except AttributeError:\n                # order_with_respect_to is a field name\n                if self.order_with_respect_to in self.fields:\n                    query_name = self.get_field(self.order_with_respect_to).related_query_name()\n            else:\n                # order_with_respect_to is a field instance\n                query_name = self.order_with_respect_to.related_query_name()\n            if query_name is not None:\n                model.add_to_class('_order', OrderWrt())\n            else:\n                model.add_to_class('_order', models.IntegerField())\n        if self.pk is None:\n            if self.parents:\n                # Find the field with explicit parent_link=True, or fall back to first field\n                field = None\n                for parent_field in self.parents.values():\n                    if parent_field and getattr(parent_field.remote_field, 'parent_link', False):\n                        field = parent_field\n                        break\n                \n                # If no explicit parent_link=True found, use the first one (backward compatibility)\n                if field is None:\n                    field = next(iter(self.parents.values()))\n                \n                # Promote the primary key of the first parent.\n                self.pk = field\n                self.pk.primary_key = True\n            else:\n                auto = AutoField(verbose_name='ID', primary_key=True, auto_created=True)\n                model.add_to_class('id', auto)\n",
      "\n    def _prepare(self, model):\n        if self.order_with_respect_to:\n            # The app registry will not be ready at this point, so we cannot\n            # use get_field().\n            query = self.order_with_respect_to\n            try:\n                self.order_with_respect_to = next(\n                    f for f in self._get_fields(reverse=False)\n                    if f.name == query or f.attname == query\n                )\n            except StopIteration:\n                raise FieldDoesNotExist('%s has no field named %r' % (self.object_name, query))\n\n        self.pk = self.pk or self.get_field('id')\n\n        if self.pk is None:\n            if self.parents:\n                # Find the field with explicit parent_link=True first, or fall back to first field\n                field = None\n                for parent_field in self.parents.values():\n                    if parent_field and getattr(parent_field.remote_field, 'parent_link', False):\n                        field = parent_field\n                        break\n                \n                # If no explicit parent_link=True found, use the first one (backward compatibility)\n                if field is None:\n                    field = next(iter(self.parents.values()))\n                \n                if field:\n                    self.pk = field\n                else:\n                    self.pk = self._get_pk_field()\n            else:\n                self.pk = self._get_pk_field()\n",
      "\n    def _prepare(self, model):\n        if self.order_with_respect_to:\n            # The app registry will not be ready at this point, so we cannot\n            # use get_field().\n            query = self.order_with_respect_to\n            try:\n                self.order_with_respect_to = next(\n                    f for f in self._get_fields(reverse=False)\n                    if f.name == query or f.attname == query\n                )\n            except StopIteration:\n                raise FieldDoesNotExist('%s has no field named %r' % (self.object_name, query))\n\n        self.pk = self.pk or self.auto_field or self._get_default_pk_class()()\n        self.pk._set_name_with_model(model, self.pk.name)\n\n        self.auto_field = self.auto_field or self.pk\n        if self.pk is None:\n            if self.parents:\n                # Find the field with explicit parent_link=True, or fall back to first field\n                field = None\n                for parent_field in self.parents.values():\n                    if parent_field and getattr(parent_field.remote_field, 'parent_link', False):\n                        field = parent_field\n                        break\n                \n                # If no explicit parent_link=True found, use the first one (backward compatibility)\n                if field is None:\n                    field = next(iter(self.parents.values()))\n                \n                if field:\n                    self.pk = field\n                else:\n                    self.pk = self._get_default_pk_class()()\n            else:\n                self.pk = self._get_default_pk_class()()\n                self.pk._set_name_with_model(model, self.pk.name)\n        self.pk._set_name_with_model(model, self.pk.name)\n",
      "\n    def _prepare(self, model):\n        if self.order_with_respect_to:\n            # The app registry will not be ready at this point, so we cannot\n            # use get_field().\n            query = self.order_with_respect_to\n            try:\n                self.get_field(query)\n            except FieldDoesNotExist:\n                raise FieldError(\n                    \"'%s' has no field named '%s'.\" % (self.object_name, query)\n                )\n\n        self.pk = self.pk or self.get_field(self.pk_name)\n        if self.pk is None:\n            if self.parents:\n                # Find the field with explicit parent_link=True, or fall back to first field\n                field = None\n                for parent_field in self.parents.values():\n                    if parent_field and getattr(parent_field.remote_field, 'parent_link', False):\n                        field = parent_field\n                        break\n                \n                # If no explicit parent_link=True found, use the first one (backward compatibility)\n                if field is None:\n                    field = next(iter(self.parents.values()))\n                \n                if field:\n                    self.pk = field\n                    field.primary_key = True\n                else:\n                    self.pk = self._get_default_pk_class()(\n                        'id',\n                        auto_created=True,\n                        primary_key=True,\n                        serialize=False,\n                        verbose_name='ID',\n                    )\n                    model.add_to_class('id', self.pk)\n            else:\n                self.pk = self._get_default_pk_class()(\n                    'id',\n                    auto_created=True,\n                    primary_key=True,\n                    serialize=False,\n                    verbose_name='ID',\n                )\n                model.add_to_class('id', self.pk)\n        else:\n            self.pk.set_attributes_from_name(self.pk_name)\n\n        self.pk._make_hashable = False\n        self.setup_pk(model)\n",
      "\n    def _prepare(self, model):\n        if self.order_with_respect_to:\n            # The app registry will not be ready at this point, so we cannot\n            # use get_field().\n            query = self.order_with_respect_to\n            try:\n                self.order_with_respect_to = next(\n                    f for f in self._get_fields(reverse=False)\n                    if f.name == query or f.attname == query\n                )\n            except StopIteration:\n                raise FieldDoesNotExist(\"%s has no field named '%s'\" % (self.object_name, query))\n\n        self.pk = self.pk or self.get_field('pk')\n\n        if self.pk is None:\n            if self.parents:\n                # Find the field with explicit parent_link=True, or fall back to first field\n                field = None\n                for parent_field in self.parents.values():\n                    if parent_field and getattr(parent_field.remote_field, 'parent_link', False):\n                        field = parent_field\n                        break\n                \n                # If no explicit parent_link=True found, use the first one (backward compatibility)\n                if field is None:\n                    field = next(iter(self.parents.values()))\n                \n                if field:\n                    # Make the child of the first parent the pk of the child.\n                    field.primary_key = True\n                    self.setup_pk(field)\n                else:\n                    raise ImproperlyConfigured(\n                        'Primary key for %s.%s doesn\\'t exist. If you didn\\'t override '\n                        'the primary key, make sure the table has been created.' %\n                        (self.app_label, self.model_name)\n                    )\n            else:\n                pk = AutoField(verbose_name='ID', primary_key=True, auto_created=True)\n                model.add_to_class('id', pk)\n",
      "\n        if self.pk is None:\n            if self.parents:\n                # Look for a field with explicit parent_link=True first\n                field = None\n                for parent_field in self.parents.values():\n                    if parent_field and getattr(parent_field.remote_field, 'parent_link', False):\n                        field = parent_field\n                        break\n                \n                # If no explicit parent_link=True found, use the first one (backward compatibility)\n                if field is None:\n                    field = next(iter(self.parents.values()))\n                \n                if field:\n                    self.pk = field\n                    field.primary_key = True\n                else:\n                    self.pk = AutoField(verbose_name='ID', primary_key=True, auto_created=True)\n                    self.add_field(self.pk, private=True)\n            else:\n                self.pk = AutoField(verbose_name='ID', primary_key=True, auto_created=True)\n                self.add_field(self.pk, private=True)\n",
      "\ndef _prepare(self, model):\n    if self.order_with_respect_to:\n        # The app registry will not be ready at this point, so we cannot\n        # use get_field().\n        query = self.order_with_respect_to\n        try:\n            self.get_field(query)\n        except FieldDoesNotExist:\n            raise FieldDoesNotExist(\n                \"%s has no field named '%s'.\" % (self.object_name, query)\n            )\n\n    self.pk = self.pk or self.get_field(self.pk_name)\n    if self.pk is None:\n        if self.parents:\n            # Find the field with explicit parent_link=True, or fall back to first field\n            field = None\n            for parent_field in self.parents.values():\n                if parent_field and getattr(parent_field.remote_field, 'parent_link', False):\n                    field = parent_field\n                    break\n            \n            # If no explicit parent_link=True found, use the first one (backward compatibility)\n            if field is None:\n                field = next(iter(self.parents.values()))\n            \n            self.pk = field\n        else:\n            self.pk = self.get_field('id')\n\n    # If the pk is still not found, create an AutoField.\n    if self.pk is None:\n        if self.auto_field:\n            auto = self.auto_field\n        elif isinstance(self.auto_field, type):\n            auto = self.auto_field()\n        else:\n            auto = AutoField(verbose_name='ID', primary_key=True, auto_created=True)\n        model.add_to_class('id', auto)\n        self.pk = auto\n\n    self.setup_pk(model)\n\n    # If the model is a proxy, ensure that the base class\n    # hasn't been swapped out.\n    if self.proxy:\n        if self.proxy_for_model._meta.swapped:\n            raise TypeError(\"%s cannot proxy the swapped model '%s'.\" % (\n                self.object_name, self.proxy_for_model._meta.swapped)\n            )\n\n    self.db_table = truncate_name(\n        self.db_table, connection.ops.max_name_length())\n",
      "\n    def _prepare(self, model):\n        if self.order_with_respect_to:\n            # The app registry will not be ready at this point, so we cannot\n            # use get_field().\n            query = self.order_with_respect_to\n            try:\n                self.order_with_respect_to = next(\n                    f for f in self._get_fields(reverse=False)\n                    if f.name == query or f.attname == query\n                )\n            except StopIteration:\n                raise FieldDoesNotExist('%s has no field named %r' % (self.object_name, query))\n\n        self.pk = self.pk or self.get_field(self.pk_name)\n        if self.pk is None:\n            if self.parents:\n                # Find the field with explicit parent_link=True, or fall back to first field\n                field = None\n                for parent_field in self.parents.values():\n                    if parent_field and getattr(parent_field.remote_field, 'parent_link', False):\n                        field = parent_field\n                        break\n                \n                # If no explicit parent_link=True found, use the first one (backward compatibility)\n                if field is None:\n                    field = next(iter(self.parents.values()))\n                \n                if field:\n                    self.pk = field\n                else:\n                    self.pk = self._get_default_pk_class()(name='id', primary_key=True, auto_created=True)\n                    self.pk.set_attributes_from_name('id')\n            else:\n                self.pk = self._get_default_pk_class()(name='id', primary_key=True, auto_created=True)\n                self.pk.set_attributes_from_name('id')\n"
    ],
    "Location 4 (/root/hy/projects/django/django/db/models/base.py lines 204-207)": [
      "\n        # Collect the parent links for multi-table inheritance.\n        parent_links = {}\n        explicit_parent_links = {}  # Track fields with explicit parent_link=True\n        for base in reversed([new_class] + parents):\n            # Conceptually equivalent to `if base is Model`.\n            if not hasattr(base, '_meta'):\n                continue\n            # Skip concrete parent classes.\n            if base != new_class and not base._meta.abstract:\n                continue\n            # Locate OneToOneField instances.\n            for field in base._meta.local_fields:\n                if isinstance(field, OneToOneField):\n                    related = resolve_relation(new_class, field.remote_field.model)\n                    model_tuple = make_model_tuple(related)\n                    parent_links[model_tuple] = field\n                    # Track fields with explicit parent_link=True\n                    if getattr(field.remote_field, 'parent_link', False):\n                        explicit_parent_links[model_tuple] = field\n",
      "\n        # Collect the parent links for multi-table inheritance.\n        parent_links = {}\n        for base in reversed([new_class] + parents):\n            # Conceptually equivalent to `if base is Model`.\n            if not hasattr(base, '_meta'):\n                continue\n            # Skip concrete parent classes.\n            if base != new_class and not base._meta.abstract:\n                continue\n            # Locate OneToOneField instances.\n            for field in base._meta.local_fields:\n                if isinstance(field, OneToOneField):\n                    related = resolve_relation(new_class, field.remote_field.model)\n                    parent_links[make_model_tuple(related)] = field\n",
      "\n        for field in base._meta.local_fields:\n            if isinstance(field, OneToOneField):\n                related = resolve_relation(new_class, field.remote_field.model)\n                parent_links[make_model_tuple(related)] = field\n",
      "\n        for field in base._meta.local_fields:\n            if isinstance(field, OneToOneField):\n                related = resolve_relation(new_class, field.remote_field.model)\n                parent_links[make_model_tuple(related)] = field\n",
      "\n        # Collect the parent links for multi-table inheritance.\n        parent_links = {}\n        for base in reversed([new_class] + parents):\n            # Conceptually equivalent to `if base is Model`.\n            if not hasattr(base, '_meta'):\n                continue\n            # Skip concrete parent classes.\n            if base != new_class and not base._meta.abstract:\n                continue\n            # Locate OneToOneField instances.\n            for field in base._meta.local_fields:\n                if isinstance(field, OneToOneField):\n                    related = resolve_relation(new_class, field.remote_field.model)\n                    parent_links[make_model_tuple(related)] = field\n",
      "\n        # Collect the parent links for multi-table inheritance.\n        parent_links = {}\n        for base in reversed([new_class] + parents):\n            # Conceptually equivalent to `if base is Model`.\n            if not hasattr(base, '_meta'):\n                continue\n            # Skip concrete parent classes.\n            if base != new_class and not base._meta.abstract:\n                continue\n            # Locate OneToOneField instances.\n            for field in base._meta.local_fields:\n                if isinstance(field, OneToOneField):\n                    related = resolve_relation(new_class, field.remote_field.model)\n                    parent_links[make_model_tuple(related)] = field\n",
      "\n        # Locate OneToOneField instances.\n        for field in base._meta.local_fields:\n            if isinstance(field, OneToOneField):\n                related = resolve_relation(new_class, field.remote_field.model)\n                parent_links[make_model_tuple(related)] = field\n",
      "\n        for field in base._meta.local_fields:\n            if isinstance(field, OneToOneField):\n                related = resolve_relation(new_class, field.remote_field.model)\n                parent_links[make_model_tuple(related)] = field\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..2d91b038a1 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -191,6 +191,7 @@ class ModelBase(type):\n         else:\n             new_class._meta.concrete_model = new_class\n \n+\n         # Collect the parent links for multi-table inheritance.\n         parent_links = {}\n         for base in reversed([new_class] + parents):\n@@ -205,6 +206,7 @@ class ModelBase(type):\n                 if isinstance(field, OneToOneField):\n                     related = resolve_relation(new_class, field.remote_field.model)\n                     parent_links[make_model_tuple(related)] = field\n+                    parent_links[make_model_tuple(related)] = field\n \n         # Track fields inherited from base models.\n         inherited_attributes = set()\n@@ -233,6 +235,7 @@ class ModelBase(type):\n                     else:\n                         inherited_attributes.add(field.name)\n \n+\n                 # Concrete classes...\n                 base = base._meta.concrete_model\n                 base_key = make_model_tuple(base)\ndiff --git a/django/db/models/options.py b/django/db/models/options.py\nindex a375f6ba1d..97eea9cdb4 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -239,12 +239,21 @@ class Options:\n             self.order_with_respect_to = None\n \n         if self.pk is None:\n+\n             if self.parents:\n-                # Promote the first parent link in lieu of adding yet another\n-                # field.\n-                field = next(iter(self.parents.values()))\n+                # Find the field with explicit parent_link=True, or fall back to first field\n+                field = None\n+                for parent_field in self.parents.values():\n+                    if parent_field and getattr(parent_field.remote_field, 'parent_link', False):\n+                        field = parent_field\n+                        break\n+                \n+                # If no explicit parent_link=True found, use the first one (backward compatibility)\n+                if field is None:\n+                    field = next(iter(self.parents.values()))\n+                \n                 # Look for a local field with the same name as the\n-                # first parent link. If a local field has already been\n+                # selected parent link. If a local field has already been\n                 # created, use it instead of promoting the parent\n                 already_created = [fld for fld in self.local_fields if fld.name == field.name]\n                 if already_created:\n",
    "variant_0": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..dad2dfd6b6 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -191,6 +191,7 @@ class ModelBase(type):\n         else:\n             new_class._meta.concrete_model = new_class\n \n+\n         # Collect the parent links for multi-table inheritance.\n         parent_links = {}\n         for base in reversed([new_class] + parents):\n@@ -205,6 +206,17 @@ class ModelBase(type):\n                 if isinstance(field, OneToOneField):\n                     related = resolve_relation(new_class, field.remote_field.model)\n                     parent_links[make_model_tuple(related)] = field\n+            # Conceptually equivalent to `if base is Model`.\n+            if not hasattr(base, '_meta'):\n+                continue\n+            # Skip concrete parent classes.\n+            if base != new_class and not base._meta.abstract:\n+                continue\n+            # Locate OneToOneField instances.\n+            for field in base._meta.local_fields:\n+                if isinstance(field, OneToOneField):\n+                    related = resolve_relation(new_class, field.remote_field.model)\n+                    parent_links[make_model_tuple(related)] = field\n \n         # Track fields inherited from base models.\n         inherited_attributes = set()\n@@ -233,39 +245,48 @@ class ModelBase(type):\n                     else:\n                         inherited_attributes.add(field.name)\n \n-                # Concrete classes...\n-                base = base._meta.concrete_model\n-                base_key = make_model_tuple(base)\n-                if base_key in parent_links:\n-                    field = parent_links[base_key]\n-                elif not is_proxy:\n-                    attr_name = '%s_ptr' % base._meta.model_name\n-                    field = OneToOneField(\n-                        base,\n-                        on_delete=CASCADE,\n-                        name=attr_name,\n-                        auto_created=True,\n-                        parent_link=True,\n-                    )\n \n-                    if attr_name in field_names:\n-                        raise FieldError(\n-                            \"Auto-generated field '%s' in class %r for \"\n-                            \"parent_link to base class %r clashes with \"\n-                            \"declared field of the same name.\" % (\n-                                attr_name,\n-                                name,\n-                                base.__name__,\n-                            )\n-                        )\n+    def _prepare(self, model):\n+        if self.order_with_respect_to:\n+            # The app registry will not be ready at this point, so we cannot\n+            # use get_field().\n+            query = self.order_with_respect_to\n+            try:\n+                self.order_with_respect_to = next(\n+                    f for f in self._get_fields(reverse=False)\n+                    if f.name == query or f.attname == query\n+                )\n+            except StopIteration:\n+                raise FieldDoesNotExist(\"%s has no field named '%s'\" % (self.object_name, query))\n \n-                    # Only add the ptr field if it's not already present;\n-                    # e.g. migrations will already have it specified\n-                    if not hasattr(new_class, attr_name):\n-                        new_class.add_to_class(attr_name, field)\n-                else:\n-                    field = None\n-                new_class._meta.parents[base] = field\n+        self.ordering = tuple(self.ordering)\n+        self.unique_together = normalize_together(self.unique_together)\n+        self.index_together = normalize_together(self.index_together)\n+        # App label/class name interpolation for names of constraints and\n+        # indexes.\n+        if not getattr(cls, '_deferred', False):\n+            self._make_fields_lazy()\n+\n+        if self.pk is None:\n+            if self.parents:\n+                # Find the field with explicit parent_link=True, or fall back to first field\n+                field = None\n+                for parent_field in self.parents.values():\n+                    if parent_field and getattr(parent_field.remote_field, 'parent_link', False):\n+                        field = parent_field\n+                        break\n+                \n+                # If no explicit parent_link=True found, use the first one (backward compatibility)\n+                if field is None:\n+                    field = next(iter(self.parents.values()))\n+                \n+                if field:\n+                    # Promote the parent's primary key to this one.\n+                    field.primary_key = True\n+                    self.setup_pk(field)\n+            else:\n+                auto_field = AutoField(verbose_name='ID', primary_key=True, auto_created=True)\n+                model.add_to_class('id', auto_field)\n             else:\n                 base_parents = base._meta.parents.copy()\n \ndiff --git a/django/db/models/options.py b/django/db/models/options.py\nindex a375f6ba1d..ac47e82444 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -238,11 +238,21 @@ class Options:\n         else:\n             self.order_with_respect_to = None\n \n+        if self.pk is None:\n+\n         if self.pk is None:\n             if self.parents:\n-                # Promote the first parent link in lieu of adding yet another\n-                # field.\n-                field = next(iter(self.parents.values()))\n+                # Find the field with explicit parent_link=True, or fall back to first field\n+                field = None\n+                for parent_field in self.parents.values():\n+                    if parent_field and getattr(parent_field.remote_field, 'parent_link', False):\n+                        field = parent_field\n+                        break\n+                \n+                # If no explicit parent_link=True found, use the first one (backward compatibility)\n+                if field is None:\n+                    field = next(iter(self.parents.values()))\n+                \n                 # Look for a local field with the same name as the\n                 # first parent link. If a local field has already been\n                 # created, use it instead of promoting the parent\n",
    "variant_1": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..20abcda5ea 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -191,6 +191,7 @@ class ModelBase(type):\n         else:\n             new_class._meta.concrete_model = new_class\n \n+\n         # Collect the parent links for multi-table inheritance.\n         parent_links = {}\n         for base in reversed([new_class] + parents):\n@@ -205,6 +206,22 @@ class ModelBase(type):\n                 if isinstance(field, OneToOneField):\n                     related = resolve_relation(new_class, field.remote_field.model)\n                     parent_links[make_model_tuple(related)] = field\n+        for base in reversed([new_class] + parents):\n+            # Conceptually equivalent to `if base is Model`.\n+            if not hasattr(base, '_meta'):\n+                continue\n+            # Skip concrete parent classes.\n+            if base != new_class and not base._meta.abstract:\n+                continue\n+            # Locate OneToOneField instances.\n+            for field in base._meta.local_fields:\n+                if isinstance(field, OneToOneField):\n+                    related = resolve_relation(new_class, field.remote_field.model)\n+                    model_tuple = make_model_tuple(related)\n+                    parent_links[model_tuple] = field\n+                    # Track fields with explicit parent_link=True\n+                    if getattr(field.remote_field, 'parent_link', False):\n+                        explicit_parent_links[model_tuple] = field\n \n         # Track fields inherited from base models.\n         inherited_attributes = set()\n@@ -233,39 +250,44 @@ class ModelBase(type):\n                     else:\n                         inherited_attributes.add(field.name)\n \n-                # Concrete classes...\n-                base = base._meta.concrete_model\n-                base_key = make_model_tuple(base)\n-                if base_key in parent_links:\n-                    field = parent_links[base_key]\n-                elif not is_proxy:\n-                    attr_name = '%s_ptr' % base._meta.model_name\n-                    field = OneToOneField(\n-                        base,\n-                        on_delete=CASCADE,\n-                        name=attr_name,\n-                        auto_created=True,\n-                        parent_link=True,\n-                    )\n \n-                    if attr_name in field_names:\n-                        raise FieldError(\n-                            \"Auto-generated field '%s' in class %r for \"\n-                            \"parent_link to base class %r clashes with \"\n-                            \"declared field of the same name.\" % (\n-                                attr_name,\n-                                name,\n-                                base.__name__,\n-                            )\n-                        )\n-\n-                    # Only add the ptr field if it's not already present;\n-                    # e.g. migrations will already have it specified\n-                    if not hasattr(new_class, attr_name):\n-                        new_class.add_to_class(attr_name, field)\n-                else:\n-                    field = None\n-                new_class._meta.parents[base] = field\n+    def _prepare(self, model):\n+        if self.order_with_respect_to:\n+            # The app registry will not be ready at this point, so we cannot\n+            # use get_field().\n+            query_name = None\n+            try:\n+                self.order_with_respect_to.related_model\n+            except AttributeError:\n+                # order_with_respect_to is a field name\n+                if self.order_with_respect_to in self.fields:\n+                    query_name = self.get_field(self.order_with_respect_to).related_query_name()\n+            else:\n+                # order_with_respect_to is a field instance\n+                query_name = self.order_with_respect_to.related_query_name()\n+            if query_name is not None:\n+                model.add_to_class('_order', OrderWrt())\n+            else:\n+                model.add_to_class('_order', models.IntegerField())\n+        if self.pk is None:\n+            if self.parents:\n+                # Find the field with explicit parent_link=True, or fall back to first field\n+                field = None\n+                for parent_field in self.parents.values():\n+                    if parent_field and getattr(parent_field.remote_field, 'parent_link', False):\n+                        field = parent_field\n+                        break\n+                \n+                # If no explicit parent_link=True found, use the first one (backward compatibility)\n+                if field is None:\n+                    field = next(iter(self.parents.values()))\n+                \n+                # Promote the primary key of the first parent.\n+                self.pk = field\n+                self.pk.primary_key = True\n+            else:\n+                auto = AutoField(verbose_name='ID', primary_key=True, auto_created=True)\n+                model.add_to_class('id', auto)\n             else:\n                 base_parents = base._meta.parents.copy()\n \ndiff --git a/django/db/models/options.py b/django/db/models/options.py\nindex a375f6ba1d..da1dd13a39 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -238,13 +238,23 @@ class Options:\n         else:\n             self.order_with_respect_to = None\n \n+        if self.pk is None:\n+\n         if self.pk is None:\n             if self.parents:\n-                # Promote the first parent link in lieu of adding yet another\n-                # field.\n-                field = next(iter(self.parents.values()))\n+                # Look for a field with explicit parent_link=True first\n+                field = None\n+                for parent_field in self.parents.values():\n+                    if parent_field and getattr(parent_field.remote_field, 'parent_link', False):\n+                        field = parent_field\n+                        break\n+                \n+                # If no explicit parent_link=True found, use the first one (backward compatibility)\n+                if field is None:\n+                    field = next(iter(self.parents.values()))\n+                \n                 # Look for a local field with the same name as the\n-                # first parent link. If a local field has already been\n+                # selected parent link. If a local field has already been\n                 # created, use it instead of promoting the parent\n                 already_created = [fld for fld in self.local_fields if fld.name == field.name]\n                 if already_created:\n",
    "variant_2": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..0ac8586047 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -191,6 +191,7 @@ class ModelBase(type):\n         else:\n             new_class._meta.concrete_model = new_class\n \n+\n         # Collect the parent links for multi-table inheritance.\n         parent_links = {}\n         for base in reversed([new_class] + parents):\n@@ -205,6 +206,17 @@ class ModelBase(type):\n                 if isinstance(field, OneToOneField):\n                     related = resolve_relation(new_class, field.remote_field.model)\n                     parent_links[make_model_tuple(related)] = field\n+            # Conceptually equivalent to `if base is Model`.\n+            if not hasattr(base, '_meta'):\n+                continue\n+            # Skip concrete parent classes.\n+            if base != new_class and not base._meta.abstract:\n+                continue\n+            # Locate OneToOneField instances.\n+            for field in base._meta.local_fields:\n+                if isinstance(field, OneToOneField):\n+                    related = resolve_relation(new_class, field.remote_field.model)\n+                    parent_links[make_model_tuple(related)] = field\n \n         # Track fields inherited from base models.\n         inherited_attributes = set()\n@@ -233,39 +245,41 @@ class ModelBase(type):\n                     else:\n                         inherited_attributes.add(field.name)\n \n-                # Concrete classes...\n-                base = base._meta.concrete_model\n-                base_key = make_model_tuple(base)\n-                if base_key in parent_links:\n-                    field = parent_links[base_key]\n-                elif not is_proxy:\n-                    attr_name = '%s_ptr' % base._meta.model_name\n-                    field = OneToOneField(\n-                        base,\n-                        on_delete=CASCADE,\n-                        name=attr_name,\n-                        auto_created=True,\n-                        parent_link=True,\n-                    )\n \n-                    if attr_name in field_names:\n-                        raise FieldError(\n-                            \"Auto-generated field '%s' in class %r for \"\n-                            \"parent_link to base class %r clashes with \"\n-                            \"declared field of the same name.\" % (\n-                                attr_name,\n-                                name,\n-                                base.__name__,\n-                            )\n-                        )\n+    def _prepare(self, model):\n+        if self.order_with_respect_to:\n+            # The app registry will not be ready at this point, so we cannot\n+            # use get_field().\n+            query = self.order_with_respect_to\n+            try:\n+                self.order_with_respect_to = next(\n+                    f for f in self._get_fields(reverse=False)\n+                    if f.name == query or f.attname == query\n+                )\n+            except StopIteration:\n+                raise FieldDoesNotExist('%s has no field named %r' % (self.object_name, query))\n+\n+        self.pk = self.pk or self.get_field('id')\n \n-                    # Only add the ptr field if it's not already present;\n-                    # e.g. migrations will already have it specified\n-                    if not hasattr(new_class, attr_name):\n-                        new_class.add_to_class(attr_name, field)\n+        if self.pk is None:\n+            if self.parents:\n+                # Find the field with explicit parent_link=True first, or fall back to first field\n+                field = None\n+                for parent_field in self.parents.values():\n+                    if parent_field and getattr(parent_field.remote_field, 'parent_link', False):\n+                        field = parent_field\n+                        break\n+                \n+                # If no explicit parent_link=True found, use the first one (backward compatibility)\n+                if field is None:\n+                    field = next(iter(self.parents.values()))\n+                \n+                if field:\n+                    self.pk = field\n                 else:\n-                    field = None\n-                new_class._meta.parents[base] = field\n+                    self.pk = self._get_pk_field()\n+            else:\n+                self.pk = self._get_pk_field()\n             else:\n                 base_parents = base._meta.parents.copy()\n \ndiff --git a/django/db/models/options.py b/django/db/models/options.py\nindex a375f6ba1d..ac47e82444 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -238,11 +238,21 @@ class Options:\n         else:\n             self.order_with_respect_to = None\n \n+        if self.pk is None:\n+\n         if self.pk is None:\n             if self.parents:\n-                # Promote the first parent link in lieu of adding yet another\n-                # field.\n-                field = next(iter(self.parents.values()))\n+                # Find the field with explicit parent_link=True, or fall back to first field\n+                field = None\n+                for parent_field in self.parents.values():\n+                    if parent_field and getattr(parent_field.remote_field, 'parent_link', False):\n+                        field = parent_field\n+                        break\n+                \n+                # If no explicit parent_link=True found, use the first one (backward compatibility)\n+                if field is None:\n+                    field = next(iter(self.parents.values()))\n+                \n                 # Look for a local field with the same name as the\n                 # first parent link. If a local field has already been\n                 # created, use it instead of promoting the parent\n",
    "variant_3": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..c5573660f6 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -191,6 +191,7 @@ class ModelBase(type):\n         else:\n             new_class._meta.concrete_model = new_class\n \n+\n         # Collect the parent links for multi-table inheritance.\n         parent_links = {}\n         for base in reversed([new_class] + parents):\n@@ -205,6 +206,7 @@ class ModelBase(type):\n                 if isinstance(field, OneToOneField):\n                     related = resolve_relation(new_class, field.remote_field.model)\n                     parent_links[make_model_tuple(related)] = field\n+                parent_links[make_model_tuple(related)] = field\n \n         # Track fields inherited from base models.\n         inherited_attributes = set()\n@@ -233,39 +235,45 @@ class ModelBase(type):\n                     else:\n                         inherited_attributes.add(field.name)\n \n-                # Concrete classes...\n-                base = base._meta.concrete_model\n-                base_key = make_model_tuple(base)\n-                if base_key in parent_links:\n-                    field = parent_links[base_key]\n-                elif not is_proxy:\n-                    attr_name = '%s_ptr' % base._meta.model_name\n-                    field = OneToOneField(\n-                        base,\n-                        on_delete=CASCADE,\n-                        name=attr_name,\n-                        auto_created=True,\n-                        parent_link=True,\n-                    )\n \n-                    if attr_name in field_names:\n-                        raise FieldError(\n-                            \"Auto-generated field '%s' in class %r for \"\n-                            \"parent_link to base class %r clashes with \"\n-                            \"declared field of the same name.\" % (\n-                                attr_name,\n-                                name,\n-                                base.__name__,\n-                            )\n-                        )\n+    def _prepare(self, model):\n+        if self.order_with_respect_to:\n+            # The app registry will not be ready at this point, so we cannot\n+            # use get_field().\n+            query = self.order_with_respect_to\n+            try:\n+                self.order_with_respect_to = next(\n+                    f for f in self._get_fields(reverse=False)\n+                    if f.name == query or f.attname == query\n+                )\n+            except StopIteration:\n+                raise FieldDoesNotExist('%s has no field named %r' % (self.object_name, query))\n \n-                    # Only add the ptr field if it's not already present;\n-                    # e.g. migrations will already have it specified\n-                    if not hasattr(new_class, attr_name):\n-                        new_class.add_to_class(attr_name, field)\n+        self.pk = self.pk or self.auto_field or self._get_default_pk_class()()\n+        self.pk._set_name_with_model(model, self.pk.name)\n+\n+        self.auto_field = self.auto_field or self.pk\n+        if self.pk is None:\n+            if self.parents:\n+                # Find the field with explicit parent_link=True, or fall back to first field\n+                field = None\n+                for parent_field in self.parents.values():\n+                    if parent_field and getattr(parent_field.remote_field, 'parent_link', False):\n+                        field = parent_field\n+                        break\n+                \n+                # If no explicit parent_link=True found, use the first one (backward compatibility)\n+                if field is None:\n+                    field = next(iter(self.parents.values()))\n+                \n+                if field:\n+                    self.pk = field\n                 else:\n-                    field = None\n-                new_class._meta.parents[base] = field\n+                    self.pk = self._get_default_pk_class()()\n+            else:\n+                self.pk = self._get_default_pk_class()()\n+                self.pk._set_name_with_model(model, self.pk.name)\n+        self.pk._set_name_with_model(model, self.pk.name)\n             else:\n                 base_parents = base._meta.parents.copy()\n \ndiff --git a/django/db/models/options.py b/django/db/models/options.py\nindex a375f6ba1d..da1dd13a39 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -238,13 +238,23 @@ class Options:\n         else:\n             self.order_with_respect_to = None\n \n+        if self.pk is None:\n+\n         if self.pk is None:\n             if self.parents:\n-                # Promote the first parent link in lieu of adding yet another\n-                # field.\n-                field = next(iter(self.parents.values()))\n+                # Look for a field with explicit parent_link=True first\n+                field = None\n+                for parent_field in self.parents.values():\n+                    if parent_field and getattr(parent_field.remote_field, 'parent_link', False):\n+                        field = parent_field\n+                        break\n+                \n+                # If no explicit parent_link=True found, use the first one (backward compatibility)\n+                if field is None:\n+                    field = next(iter(self.parents.values()))\n+                \n                 # Look for a local field with the same name as the\n-                # first parent link. If a local field has already been\n+                # selected parent link. If a local field has already been\n                 # created, use it instead of promoting the parent\n                 already_created = [fld for fld in self.local_fields if fld.name == field.name]\n                 if already_created:\n",
    "variant_4": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..387e92b55f 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -191,6 +191,7 @@ class ModelBase(type):\n         else:\n             new_class._meta.concrete_model = new_class\n \n+\n         # Collect the parent links for multi-table inheritance.\n         parent_links = {}\n         for base in reversed([new_class] + parents):\n@@ -205,6 +206,7 @@ class ModelBase(type):\n                 if isinstance(field, OneToOneField):\n                     related = resolve_relation(new_class, field.remote_field.model)\n                     parent_links[make_model_tuple(related)] = field\n+                parent_links[make_model_tuple(related)] = field\n \n         # Track fields inherited from base models.\n         inherited_attributes = set()\n@@ -233,39 +235,59 @@ class ModelBase(type):\n                     else:\n                         inherited_attributes.add(field.name)\n \n-                # Concrete classes...\n-                base = base._meta.concrete_model\n-                base_key = make_model_tuple(base)\n-                if base_key in parent_links:\n-                    field = parent_links[base_key]\n-                elif not is_proxy:\n-                    attr_name = '%s_ptr' % base._meta.model_name\n-                    field = OneToOneField(\n-                        base,\n-                        on_delete=CASCADE,\n-                        name=attr_name,\n-                        auto_created=True,\n-                        parent_link=True,\n-                    )\n \n-                    if attr_name in field_names:\n-                        raise FieldError(\n-                            \"Auto-generated field '%s' in class %r for \"\n-                            \"parent_link to base class %r clashes with \"\n-                            \"declared field of the same name.\" % (\n-                                attr_name,\n-                                name,\n-                                base.__name__,\n-                            )\n-                        )\n+    def _prepare(self, model):\n+        if self.order_with_respect_to:\n+            # The app registry will not be ready at this point, so we cannot\n+            # use get_field().\n+            query = self.order_with_respect_to\n+            try:\n+                self.get_field(query)\n+            except FieldDoesNotExist:\n+                raise FieldError(\n+                    \"'%s' has no field named '%s'.\" % (self.object_name, query)\n+                )\n \n-                    # Only add the ptr field if it's not already present;\n-                    # e.g. migrations will already have it specified\n-                    if not hasattr(new_class, attr_name):\n-                        new_class.add_to_class(attr_name, field)\n+        self.pk = self.pk or self.get_field(self.pk_name)\n+        if self.pk is None:\n+            if self.parents:\n+                # Find the field with explicit parent_link=True, or fall back to first field\n+                field = None\n+                for parent_field in self.parents.values():\n+                    if parent_field and getattr(parent_field.remote_field, 'parent_link', False):\n+                        field = parent_field\n+                        break\n+                \n+                # If no explicit parent_link=True found, use the first one (backward compatibility)\n+                if field is None:\n+                    field = next(iter(self.parents.values()))\n+                \n+                if field:\n+                    self.pk = field\n+                    field.primary_key = True\n                 else:\n-                    field = None\n-                new_class._meta.parents[base] = field\n+                    self.pk = self._get_default_pk_class()(\n+                        'id',\n+                        auto_created=True,\n+                        primary_key=True,\n+                        serialize=False,\n+                        verbose_name='ID',\n+                    )\n+                    model.add_to_class('id', self.pk)\n+            else:\n+                self.pk = self._get_default_pk_class()(\n+                    'id',\n+                    auto_created=True,\n+                    primary_key=True,\n+                    serialize=False,\n+                    verbose_name='ID',\n+                )\n+                model.add_to_class('id', self.pk)\n+        else:\n+            self.pk.set_attributes_from_name(self.pk_name)\n+\n+        self.pk._make_hashable = False\n+        self.setup_pk(model)\n             else:\n                 base_parents = base._meta.parents.copy()\n \ndiff --git a/django/db/models/options.py b/django/db/models/options.py\nindex a375f6ba1d..e8c1599500 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -238,13 +238,23 @@ class Options:\n         else:\n             self.order_with_respect_to = None\n \n+        if self.pk is None:\n+\n         if self.pk is None:\n             if self.parents:\n-                # Promote the first parent link in lieu of adding yet another\n-                # field.\n-                field = next(iter(self.parents.values()))\n+                # Find the field with explicit parent_link=True, or fall back to first field\n+                field = None\n+                for parent_field in self.parents.values():\n+                    if parent_field and getattr(parent_field.remote_field, 'parent_link', False):\n+                        field = parent_field\n+                        break\n+                \n+                # If no explicit parent_link=True found, use the first one (backward compatibility)\n+                if field is None:\n+                    field = next(iter(self.parents.values()))\n+                \n                 # Look for a local field with the same name as the\n-                # first parent link. If a local field has already been\n+                # selected parent link. If a local field has already been\n                 # created, use it instead of promoting the parent\n                 already_created = [fld for fld in self.local_fields if fld.name == field.name]\n                 if already_created:\n",
    "variant_5": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..3143178162 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -191,6 +191,7 @@ class ModelBase(type):\n         else:\n             new_class._meta.concrete_model = new_class\n \n+\n         # Collect the parent links for multi-table inheritance.\n         parent_links = {}\n         for base in reversed([new_class] + parents):\n@@ -205,6 +206,17 @@ class ModelBase(type):\n                 if isinstance(field, OneToOneField):\n                     related = resolve_relation(new_class, field.remote_field.model)\n                     parent_links[make_model_tuple(related)] = field\n+            # Conceptually equivalent to `if base is Model`.\n+            if not hasattr(base, '_meta'):\n+                continue\n+            # Skip concrete parent classes.\n+            if base != new_class and not base._meta.abstract:\n+                continue\n+            # Locate OneToOneField instances.\n+            for field in base._meta.local_fields:\n+                if isinstance(field, OneToOneField):\n+                    related = resolve_relation(new_class, field.remote_field.model)\n+                    parent_links[make_model_tuple(related)] = field\n \n         # Track fields inherited from base models.\n         inherited_attributes = set()\n@@ -233,39 +245,48 @@ class ModelBase(type):\n                     else:\n                         inherited_attributes.add(field.name)\n \n-                # Concrete classes...\n-                base = base._meta.concrete_model\n-                base_key = make_model_tuple(base)\n-                if base_key in parent_links:\n-                    field = parent_links[base_key]\n-                elif not is_proxy:\n-                    attr_name = '%s_ptr' % base._meta.model_name\n-                    field = OneToOneField(\n-                        base,\n-                        on_delete=CASCADE,\n-                        name=attr_name,\n-                        auto_created=True,\n-                        parent_link=True,\n-                    )\n \n-                    if attr_name in field_names:\n-                        raise FieldError(\n-                            \"Auto-generated field '%s' in class %r for \"\n-                            \"parent_link to base class %r clashes with \"\n-                            \"declared field of the same name.\" % (\n-                                attr_name,\n-                                name,\n-                                base.__name__,\n-                            )\n-                        )\n+    def _prepare(self, model):\n+        if self.order_with_respect_to:\n+            # The app registry will not be ready at this point, so we cannot\n+            # use get_field().\n+            query = self.order_with_respect_to\n+            try:\n+                self.order_with_respect_to = next(\n+                    f for f in self._get_fields(reverse=False)\n+                    if f.name == query or f.attname == query\n+                )\n+            except StopIteration:\n+                raise FieldDoesNotExist(\"%s has no field named '%s'\" % (self.object_name, query))\n+\n+        self.pk = self.pk or self.get_field('pk')\n \n-                    # Only add the ptr field if it's not already present;\n-                    # e.g. migrations will already have it specified\n-                    if not hasattr(new_class, attr_name):\n-                        new_class.add_to_class(attr_name, field)\n+        if self.pk is None:\n+            if self.parents:\n+                # Find the field with explicit parent_link=True, or fall back to first field\n+                field = None\n+                for parent_field in self.parents.values():\n+                    if parent_field and getattr(parent_field.remote_field, 'parent_link', False):\n+                        field = parent_field\n+                        break\n+                \n+                # If no explicit parent_link=True found, use the first one (backward compatibility)\n+                if field is None:\n+                    field = next(iter(self.parents.values()))\n+                \n+                if field:\n+                    # Make the child of the first parent the pk of the child.\n+                    field.primary_key = True\n+                    self.setup_pk(field)\n                 else:\n-                    field = None\n-                new_class._meta.parents[base] = field\n+                    raise ImproperlyConfigured(\n+                        'Primary key for %s.%s doesn\\'t exist. If you didn\\'t override '\n+                        'the primary key, make sure the table has been created.' %\n+                        (self.app_label, self.model_name)\n+                    )\n+            else:\n+                pk = AutoField(verbose_name='ID', primary_key=True, auto_created=True)\n+                model.add_to_class('id', pk)\n             else:\n                 base_parents = base._meta.parents.copy()\n \ndiff --git a/django/db/models/options.py b/django/db/models/options.py\nindex a375f6ba1d..ac47e82444 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -238,11 +238,21 @@ class Options:\n         else:\n             self.order_with_respect_to = None\n \n+        if self.pk is None:\n+\n         if self.pk is None:\n             if self.parents:\n-                # Promote the first parent link in lieu of adding yet another\n-                # field.\n-                field = next(iter(self.parents.values()))\n+                # Find the field with explicit parent_link=True, or fall back to first field\n+                field = None\n+                for parent_field in self.parents.values():\n+                    if parent_field and getattr(parent_field.remote_field, 'parent_link', False):\n+                        field = parent_field\n+                        break\n+                \n+                # If no explicit parent_link=True found, use the first one (backward compatibility)\n+                if field is None:\n+                    field = next(iter(self.parents.values()))\n+                \n                 # Look for a local field with the same name as the\n                 # first parent link. If a local field has already been\n                 # created, use it instead of promoting the parent\n",
    "variant_6": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..5f5e7e8981 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -191,6 +191,7 @@ class ModelBase(type):\n         else:\n             new_class._meta.concrete_model = new_class\n \n+\n         # Collect the parent links for multi-table inheritance.\n         parent_links = {}\n         for base in reversed([new_class] + parents):\n@@ -205,6 +206,17 @@ class ModelBase(type):\n                 if isinstance(field, OneToOneField):\n                     related = resolve_relation(new_class, field.remote_field.model)\n                     parent_links[make_model_tuple(related)] = field\n+            # Conceptually equivalent to `if base is Model`.\n+            if not hasattr(base, '_meta'):\n+                continue\n+            # Skip concrete parent classes.\n+            if base != new_class and not base._meta.abstract:\n+                continue\n+            # Locate OneToOneField instances.\n+            for field in base._meta.local_fields:\n+                if isinstance(field, OneToOneField):\n+                    related = resolve_relation(new_class, field.remote_field.model)\n+                    parent_links[make_model_tuple(related)] = field\n \n         # Track fields inherited from base models.\n         inherited_attributes = set()\n@@ -233,39 +245,29 @@ class ModelBase(type):\n                     else:\n                         inherited_attributes.add(field.name)\n \n-                # Concrete classes...\n-                base = base._meta.concrete_model\n-                base_key = make_model_tuple(base)\n-                if base_key in parent_links:\n-                    field = parent_links[base_key]\n-                elif not is_proxy:\n-                    attr_name = '%s_ptr' % base._meta.model_name\n-                    field = OneToOneField(\n-                        base,\n-                        on_delete=CASCADE,\n-                        name=attr_name,\n-                        auto_created=True,\n-                        parent_link=True,\n-                    )\n-\n-                    if attr_name in field_names:\n-                        raise FieldError(\n-                            \"Auto-generated field '%s' in class %r for \"\n-                            \"parent_link to base class %r clashes with \"\n-                            \"declared field of the same name.\" % (\n-                                attr_name,\n-                                name,\n-                                base.__name__,\n-                            )\n-                        )\n \n-                    # Only add the ptr field if it's not already present;\n-                    # e.g. migrations will already have it specified\n-                    if not hasattr(new_class, attr_name):\n-                        new_class.add_to_class(attr_name, field)\n+        if self.pk is None:\n+            if self.parents:\n+                # Look for a field with explicit parent_link=True first\n+                field = None\n+                for parent_field in self.parents.values():\n+                    if parent_field and getattr(parent_field.remote_field, 'parent_link', False):\n+                        field = parent_field\n+                        break\n+                \n+                # If no explicit parent_link=True found, use the first one (backward compatibility)\n+                if field is None:\n+                    field = next(iter(self.parents.values()))\n+                \n+                if field:\n+                    self.pk = field\n+                    field.primary_key = True\n                 else:\n-                    field = None\n-                new_class._meta.parents[base] = field\n+                    self.pk = AutoField(verbose_name='ID', primary_key=True, auto_created=True)\n+                    self.add_field(self.pk, private=True)\n+            else:\n+                self.pk = AutoField(verbose_name='ID', primary_key=True, auto_created=True)\n+                self.add_field(self.pk, private=True)\n             else:\n                 base_parents = base._meta.parents.copy()\n \ndiff --git a/django/db/models/options.py b/django/db/models/options.py\nindex a375f6ba1d..da1dd13a39 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -238,13 +238,23 @@ class Options:\n         else:\n             self.order_with_respect_to = None\n \n+        if self.pk is None:\n+\n         if self.pk is None:\n             if self.parents:\n-                # Promote the first parent link in lieu of adding yet another\n-                # field.\n-                field = next(iter(self.parents.values()))\n+                # Look for a field with explicit parent_link=True first\n+                field = None\n+                for parent_field in self.parents.values():\n+                    if parent_field and getattr(parent_field.remote_field, 'parent_link', False):\n+                        field = parent_field\n+                        break\n+                \n+                # If no explicit parent_link=True found, use the first one (backward compatibility)\n+                if field is None:\n+                    field = next(iter(self.parents.values()))\n+                \n                 # Look for a local field with the same name as the\n-                # first parent link. If a local field has already been\n+                # selected parent link. If a local field has already been\n                 # created, use it instead of promoting the parent\n                 already_created = [fld for fld in self.local_fields if fld.name == field.name]\n                 if already_created:\n",
    "variant_7": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..856aeeb424 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -191,6 +191,7 @@ class ModelBase(type):\n         else:\n             new_class._meta.concrete_model = new_class\n \n+\n         # Collect the parent links for multi-table inheritance.\n         parent_links = {}\n         for base in reversed([new_class] + parents):\n@@ -205,6 +206,8 @@ class ModelBase(type):\n                 if isinstance(field, OneToOneField):\n                     related = resolve_relation(new_class, field.remote_field.model)\n                     parent_links[make_model_tuple(related)] = field\n+                related = resolve_relation(new_class, field.remote_field.model)\n+                parent_links[make_model_tuple(related)] = field\n \n         # Track fields inherited from base models.\n         inherited_attributes = set()\n@@ -233,39 +236,60 @@ class ModelBase(type):\n                     else:\n                         inherited_attributes.add(field.name)\n \n-                # Concrete classes...\n-                base = base._meta.concrete_model\n-                base_key = make_model_tuple(base)\n-                if base_key in parent_links:\n-                    field = parent_links[base_key]\n-                elif not is_proxy:\n-                    attr_name = '%s_ptr' % base._meta.model_name\n-                    field = OneToOneField(\n-                        base,\n-                        on_delete=CASCADE,\n-                        name=attr_name,\n-                        auto_created=True,\n-                        parent_link=True,\n-                    )\n \n-                    if attr_name in field_names:\n-                        raise FieldError(\n-                            \"Auto-generated field '%s' in class %r for \"\n-                            \"parent_link to base class %r clashes with \"\n-                            \"declared field of the same name.\" % (\n-                                attr_name,\n-                                name,\n-                                base.__name__,\n-                            )\n-                        )\n+def _prepare(self, model):\n+    if self.order_with_respect_to:\n+        # The app registry will not be ready at this point, so we cannot\n+        # use get_field().\n+        query = self.order_with_respect_to\n+        try:\n+            self.get_field(query)\n+        except FieldDoesNotExist:\n+            raise FieldDoesNotExist(\n+                \"%s has no field named '%s'.\" % (self.object_name, query)\n+            )\n \n-                    # Only add the ptr field if it's not already present;\n-                    # e.g. migrations will already have it specified\n-                    if not hasattr(new_class, attr_name):\n-                        new_class.add_to_class(attr_name, field)\n-                else:\n-                    field = None\n-                new_class._meta.parents[base] = field\n+    self.pk = self.pk or self.get_field(self.pk_name)\n+    if self.pk is None:\n+        if self.parents:\n+            # Find the field with explicit parent_link=True, or fall back to first field\n+            field = None\n+            for parent_field in self.parents.values():\n+                if parent_field and getattr(parent_field.remote_field, 'parent_link', False):\n+                    field = parent_field\n+                    break\n+            \n+            # If no explicit parent_link=True found, use the first one (backward compatibility)\n+            if field is None:\n+                field = next(iter(self.parents.values()))\n+            \n+            self.pk = field\n+        else:\n+            self.pk = self.get_field('id')\n+\n+    # If the pk is still not found, create an AutoField.\n+    if self.pk is None:\n+        if self.auto_field:\n+            auto = self.auto_field\n+        elif isinstance(self.auto_field, type):\n+            auto = self.auto_field()\n+        else:\n+            auto = AutoField(verbose_name='ID', primary_key=True, auto_created=True)\n+        model.add_to_class('id', auto)\n+        self.pk = auto\n+\n+    self.setup_pk(model)\n+\n+    # If the model is a proxy, ensure that the base class\n+    # hasn't been swapped out.\n+    if self.proxy:\n+        if self.proxy_for_model._meta.swapped:\n+            raise TypeError(\"%s cannot proxy the swapped model '%s'.\" % (\n+                self.object_name, self.proxy_for_model._meta.swapped)\n+            )\n+\n+    self.db_table = truncate_name(\n+        self.db_table, connection.ops.max_name_length())\n             else:\n                 base_parents = base._meta.parents.copy()\n \ndiff --git a/django/db/models/options.py b/django/db/models/options.py\nindex a375f6ba1d..da1dd13a39 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -238,13 +238,23 @@ class Options:\n         else:\n             self.order_with_respect_to = None\n \n+        if self.pk is None:\n+\n         if self.pk is None:\n             if self.parents:\n-                # Promote the first parent link in lieu of adding yet another\n-                # field.\n-                field = next(iter(self.parents.values()))\n+                # Look for a field with explicit parent_link=True first\n+                field = None\n+                for parent_field in self.parents.values():\n+                    if parent_field and getattr(parent_field.remote_field, 'parent_link', False):\n+                        field = parent_field\n+                        break\n+                \n+                # If no explicit parent_link=True found, use the first one (backward compatibility)\n+                if field is None:\n+                    field = next(iter(self.parents.values()))\n+                \n                 # Look for a local field with the same name as the\n-                # first parent link. If a local field has already been\n+                # selected parent link. If a local field has already been\n                 # created, use it instead of promoting the parent\n                 already_created = [fld for fld in self.local_fields if fld.name == field.name]\n                 if already_created:\n",
    "variant_8": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..494bd30b9f 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -191,6 +191,7 @@ class ModelBase(type):\n         else:\n             new_class._meta.concrete_model = new_class\n \n+\n         # Collect the parent links for multi-table inheritance.\n         parent_links = {}\n         for base in reversed([new_class] + parents):\n@@ -205,6 +206,7 @@ class ModelBase(type):\n                 if isinstance(field, OneToOneField):\n                     related = resolve_relation(new_class, field.remote_field.model)\n                     parent_links[make_model_tuple(related)] = field\n+                parent_links[make_model_tuple(related)] = field\n \n         # Track fields inherited from base models.\n         inherited_attributes = set()\n@@ -233,39 +235,42 @@ class ModelBase(type):\n                     else:\n                         inherited_attributes.add(field.name)\n \n-                # Concrete classes...\n-                base = base._meta.concrete_model\n-                base_key = make_model_tuple(base)\n-                if base_key in parent_links:\n-                    field = parent_links[base_key]\n-                elif not is_proxy:\n-                    attr_name = '%s_ptr' % base._meta.model_name\n-                    field = OneToOneField(\n-                        base,\n-                        on_delete=CASCADE,\n-                        name=attr_name,\n-                        auto_created=True,\n-                        parent_link=True,\n-                    )\n \n-                    if attr_name in field_names:\n-                        raise FieldError(\n-                            \"Auto-generated field '%s' in class %r for \"\n-                            \"parent_link to base class %r clashes with \"\n-                            \"declared field of the same name.\" % (\n-                                attr_name,\n-                                name,\n-                                base.__name__,\n-                            )\n-                        )\n+    def _prepare(self, model):\n+        if self.order_with_respect_to:\n+            # The app registry will not be ready at this point, so we cannot\n+            # use get_field().\n+            query = self.order_with_respect_to\n+            try:\n+                self.order_with_respect_to = next(\n+                    f for f in self._get_fields(reverse=False)\n+                    if f.name == query or f.attname == query\n+                )\n+            except StopIteration:\n+                raise FieldDoesNotExist('%s has no field named %r' % (self.object_name, query))\n \n-                    # Only add the ptr field if it's not already present;\n-                    # e.g. migrations will already have it specified\n-                    if not hasattr(new_class, attr_name):\n-                        new_class.add_to_class(attr_name, field)\n+        self.pk = self.pk or self.get_field(self.pk_name)\n+        if self.pk is None:\n+            if self.parents:\n+                # Find the field with explicit parent_link=True, or fall back to first field\n+                field = None\n+                for parent_field in self.parents.values():\n+                    if parent_field and getattr(parent_field.remote_field, 'parent_link', False):\n+                        field = parent_field\n+                        break\n+                \n+                # If no explicit parent_link=True found, use the first one (backward compatibility)\n+                if field is None:\n+                    field = next(iter(self.parents.values()))\n+                \n+                if field:\n+                    self.pk = field\n                 else:\n-                    field = None\n-                new_class._meta.parents[base] = field\n+                    self.pk = self._get_default_pk_class()(name='id', primary_key=True, auto_created=True)\n+                    self.pk.set_attributes_from_name('id')\n+            else:\n+                self.pk = self._get_default_pk_class()(name='id', primary_key=True, auto_created=True)\n+                self.pk.set_attributes_from_name('id')\n             else:\n                 base_parents = base._meta.parents.copy()\n \ndiff --git a/django/db/models/options.py b/django/db/models/options.py\nindex a375f6ba1d..e8c1599500 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -238,13 +238,23 @@ class Options:\n         else:\n             self.order_with_respect_to = None\n \n+        if self.pk is None:\n+\n         if self.pk is None:\n             if self.parents:\n-                # Promote the first parent link in lieu of adding yet another\n-                # field.\n-                field = next(iter(self.parents.values()))\n+                # Find the field with explicit parent_link=True, or fall back to first field\n+                field = None\n+                for parent_field in self.parents.values():\n+                    if parent_field and getattr(parent_field.remote_field, 'parent_link', False):\n+                        field = parent_field\n+                        break\n+                \n+                # If no explicit parent_link=True found, use the first one (backward compatibility)\n+                if field is None:\n+                    field = next(iter(self.parents.values()))\n+                \n                 # Look for a local field with the same name as the\n-                # first parent link. If a local field has already been\n+                # selected parent link. If a local field has already been\n                 # created, use it instead of promoting the parent\n                 already_created = [fld for fld in self.local_fields if fld.name == field.name]\n                 if already_created:\n"
  }
}