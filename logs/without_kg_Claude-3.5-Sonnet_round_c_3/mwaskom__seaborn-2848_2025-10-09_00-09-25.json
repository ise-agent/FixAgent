{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/seaborn/seaborn/axisgrid.py lines 1281-1286)": "\n            # We need hue_order and hue_names because the former is used to control\n            # the order of drawing and the latter is used to control the order of\n            # the legend. hue_names can become string-typed while hue_order must\n            # retain the type of the input data. This is messy but results from\n            # the fact that PairGrid can implement the hue-mapping logic itself\n            # (and was originally written exclusively that way) but now can delegate\n            # to the axes-level functions, while always handling legend creation.\n            # See GH2307\n            hue_names = hue_order = categorical_order(data[hue], hue_order)\n            if dropna:\n                # Filter NA from the list of unique hue names\n                hue_names = list(filter(pd.notnull, hue_names))\n            self.hue_names = hue_names\n            # Filter hue_vals to only include values present in hue_names\n            if hue_order is not None:\n                mask = data[hue].isin(self.hue_names)\n                self.hue_vals = data[hue][mask]\n            else:\n                self.hue_vals = data[hue]\n",
    "Location 2 (/root/hy/projects_3/seaborn/seaborn/_oldcore.py lines 146-165)": "\n        if hue is not None:\n            hue_names = categorical_order(data[hue], hue_order)\n            if dropna:\n                # Filter NA values from hue_names\n                hue_names = list(filter(pd.notna, hue_names))\n            self.hue_names = hue_names\n            if hue_order is not None:\n                # Filter hue_vals to only include values present in hue_order\n                mask = data[hue].isin(self.hue_names)\n                self.hue_vals = data[hue][mask]\n            else:\n                self.hue_vals = data[hue]\n        else:\n            self.hue_names = None\n            self.hue_vals = None\n",
    "Location 3 (/root/hy/projects_3/seaborn/seaborn/_oldcore.py lines 121-126)": "\n        if hue is not None:\n            hue_names = utils.categorical_order(data[hue], hue_order)\n            if dropna:\n                # Filter NA values from hue_names\n                hue_names = [x for x in hue_names if pd.notna(x)]\n            self.hue_names = hue_names\n            # Filter hue_vals to only include values present in hue_names\n            if hue_order is not None:\n                mask = data[hue].isin(self.hue_names)\n                self.hue_vals = data[hue][mask]\n            else:\n                self.hue_vals = data[hue]\n",
    "Location 4 (/root/hy/projects_3/seaborn/seaborn/axisgrid.py lines 1275-1290)": "\n        else:\n            # We need hue_order and hue_names because the former is used to control\n            # the order of drawing and the latter is used to control the order of\n            # the legend. hue_names can become string-typed while hue_order must\n            # retain the type of the input data. This is messy but results from\n            # the fact that PairGrid can implement the hue-mapping logic itself\n            # (and was originally written exclusively that way) but now can delegate\n            # to the axes-level functions, while always handling legend creation.\n            # See GH2307\n            hue_names = hue_order = categorical_order(data[hue], hue_order)\n            if dropna:\n                # Filter NA from the list of unique hue names\n                hue_names = list(filter(pd.notnull, hue_names))\n            self.hue_names = hue_names\n            \n            # Ensure hue_vals only contains values present in hue_names to maintain consistency\n            if hue_order is not None:\n                mask = data[hue].isin(self.hue_names)\n                self.hue_vals = data[hue][mask]\n            else:\n                self.hue_vals = data[hue]\n\n        # Additional dict of kwarg -> list of values for mapping the hue var\n        self.hue_kws = hue_kws if hue_kws is not None else {}\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/seaborn/seaborn/axisgrid.py lines 1281-1286)": [
      "\n        else:\n            # We need hue_order and hue_names because the former is used to control\n            # the order of drawing and the latter is used to control the order of\n            # the legend. hue_names can become string-typed while hue_order must\n            # retain the type of the input data. This is messy but results from\n            # the fact that PairGrid can implement the hue-mapping logic itself\n            # (and was originally written exclusively that way) but now can delegate\n            # to the axes-level functions, while always handling legend creation.\n            # See GH2307\n            hue_names = hue_order = categorical_order(data[hue], hue_order)\n            if dropna:\n                # Filter NA from the list of unique hue names\n                hue_names = list(filter(pd.notnull, hue_names))\n            self.hue_names = hue_names\n            \n            # Filter hue_vals to only include values present in hue_names\n            # This ensures consistency between hue_names and hue_vals\n            if hue_order is not None:\n                mask = data[hue].isin(self.hue_names)\n                self.hue_vals = data[hue][mask]\n            else:\n                self.hue_vals = data[hue]\n",
      "\n            hue_names = hue_order = categorical_order(data[hue], hue_order)\n            if dropna:\n                # Filter NA from the list of unique hue names\n                hue_names = list(filter(pd.notnull, hue_names))\n            self.hue_names = hue_names\n            if hue_order is not None:\n                # Filter hue_vals to only include values present in hue_order\n                mask = data[hue].isin(self.hue_names)\n                self.hue_vals = data[hue][mask]\n            else:\n                self.hue_vals = data[hue]\n",
      "\n        else:\n            # We need hue_order and hue_names because the former is used to control\n            # the order of drawing and the latter is used to control the order of\n            # the legend. hue_names can become string-typed while hue_order must\n            # retain the type of the input data. This is messy but results from\n            # the fact that PairGrid can implement the hue-mapping logic itself\n            # (and was originally written exclusively that way) but now can delegate\n            # to the axes-level functions, while always handling legend creation.\n            # See GH2307\n            hue_names = hue_order = categorical_order(data[hue], hue_order)\n            if dropna:\n                # Filter NA from the list of unique hue names\n                hue_names = list(filter(pd.notnull, hue_names))\n            self.hue_names = hue_names\n            \n            # Filter hue_vals to only include values present in hue_names to maintain consistency\n            if hue_order is not None:\n                mask = data[hue].isin(self.hue_names)\n                self.hue_vals = data[hue][mask]\n            else:\n                self.hue_vals = data[hue]\n",
      "\n            # We need hue_order and hue_names because the former is used to control\n            # the order of drawing and the latter is used to control the order of\n            # the legend. hue_names can become string-typed while hue_order must\n            # retain the type of the input data. This is messy but results from\n            # the fact that PairGrid can implement the hue-mapping logic itself\n            # (and was originally written exclusively that way) but now can delegate\n            # to the axes-level functions, while always handling legend creation.\n            # See GH2307\n            hue_names = hue_order = categorical_order(data[hue], hue_order)\n            if dropna:\n                # Filter NA from the list of unique hue names\n                hue_names = list(filter(pd.notnull, hue_names))\n            self.hue_names = hue_names\n            # Filter hue_vals to only include values present in hue_names\n            if hue_order is not None:\n                mask = data[hue].isin(self.hue_names)\n                self.hue_vals = data[hue][mask]\n            else:\n                self.hue_vals = data[hue]\n",
      "\n            hue_names = hue_order = categorical_order(data[hue], hue_order)\n            if dropna:\n                # Filter NA from the list of unique hue names\n                hue_names = list(filter(pd.notnull, hue_names))\n            self.hue_names = hue_names\n            # Filter hue_vals to only include values present in hue_names\n            if hue_order is not None:\n                mask = data[hue].isin(self.hue_names)\n                self.hue_vals = data[hue][mask]\n            else:\n                self.hue_vals = data[hue]\n",
      "\n            # We need hue_order and hue_names because the former is used to control\n            # the order of drawing and the latter is used to control the order of\n            # the legend. hue_names can become string-typed while hue_order must\n            # retain the type of the input data. This is messy but results from\n            # the fact that PairGrid can implement the hue-mapping logic itself\n            # (and was originally written exclusively that way) but now can delegate\n            # to the axes-level functions, while always handling legend creation.\n            # See GH2307\n            hue_names = hue_order = categorical_order(data[hue], hue_order)\n            if dropna:\n                # Filter NA from the list of unique hue names\n                hue_names = list(filter(pd.notnull, hue_names))\n            self.hue_names = hue_names\n            # Filter hue_vals to only include values present in hue_names to maintain consistency\n            if hue_order is not None:\n                mask = data[hue].isin(self.hue_names)\n                self.hue_vals = data[hue][mask]\n            else:\n                self.hue_vals = data[hue]\n",
      "\n            hue_names = hue_order = categorical_order(data[hue], hue_order)\n            if dropna:\n                # Filter NA from the list of unique hue names\n                hue_names = list(filter(pd.notnull, hue_names))\n            self.hue_names = hue_names\n            \n            # Filter hue_vals to only include values present in hue_names\n            # This ensures consistency between hue_names and hue_vals\n            if hue_order is not None:\n                mask = data[hue].isin(self.hue_names)\n                self.hue_vals = data[hue][mask]\n            else:\n                self.hue_vals = data[hue]\n",
      "\n            # We need hue_order and hue_names because the former is used to control\n            # the order of drawing and the latter is used to control the order of\n            # the legend. hue_names can become string-typed while hue_order must\n            # retain the type of the input data. This is messy but results from\n            # the fact that PairGrid can implement the hue-mapping logic itself\n            # (and was originally written exclusively that way) but now can delegate\n            # to the axes-level functions, while always handling legend creation.\n            # See GH2307\n            hue_names = hue_order = categorical_order(data[hue], hue_order)\n            if dropna:\n                # Filter NA from the list of unique hue names\n                hue_names = list(filter(pd.notnull, hue_names))\n            self.hue_names = hue_names\n            # Filter hue_vals to only include values present in hue_names to maintain consistency\n            if hue_order is not None:\n                mask = data[hue].isin(self.hue_names)\n                self.hue_vals = data[hue][mask]\n            else:\n                self.hue_vals = data[hue]\n"
    ],
    "Location 2 (/root/hy/projects_3/seaborn/seaborn/_oldcore.py lines 146-165)": [
      "\n            if hue is not None:\n                hue_names = categorical_order(data[hue], hue_order)\n                if dropna:\n                    # Filter NA values from hue_names\n                    hue_names = list(filter(pd.notnull, hue_names))\n                self.hue_names = hue_names\n                if hue_order is not None:\n                    # Filter hue_vals to only include values present in hue_order\n                    mask = data[hue].isin(self.hue_names)\n                    self.hue_vals = data[hue][mask]\n                else:\n                    self.hue_vals = data[hue]\n            else:\n                self.hue_names = self.hue_vals = None\n",
      "\n        if hue is not None:\n            hue_names = categorical_order(data[hue], hue_order)\n            if dropna:\n                # Filter NA values from hue_names \n                hue_names = [x for x in hue_names if not pd.isna(x)]\n            self.hue_names = hue_names\n            if hue_order is not None:\n                # Filter hue_vals to only include values present in hue_order\n                mask = data[hue].isin(self.hue_names)\n                self.hue_vals = data[hue][mask]\n            else:\n                self.hue_vals = data[hue]\n",
      "\n        if hue is not None:\n            hue_names = categorical_order(data[hue], hue_order)\n            if dropna:\n                # Filter NA values from hue_names but keep track of the filtering\n                hue_names = list(filter(pd.notnull, hue_names))\n            self.hue_names = hue_names\n            # Filter hue_vals to only include values present in hue_names\n            if hue_order is not None:\n                mask = data[hue].isin(self.hue_names)\n                self.hue_vals = data[hue][mask]\n            else:\n                self.hue_vals = data[hue]\n        else:\n            self.hue_names = None\n            self.hue_vals = None\n",
      "\n        if hue is not None:\n            hue_names = categorical_order(data[hue], hue_order)\n            if dropna:\n                # Filter NA values from hue_names\n                hue_names = list(filter(pd.notnull, hue_names))\n            self.hue_names = hue_names\n            if hue_order is not None:\n                # Filter hue_vals to only include values present in hue_order\n                mask = data[hue].isin(self.hue_names)\n                self.hue_vals = data[hue][mask]\n            else:\n                self.hue_vals = data[hue]\n        else:\n            self.hue_names = None\n            self.hue_vals = None\n",
      "\n        if hue is not None:\n            hue_names = categorical_order(data[hue], hue_order)\n            if dropna:\n                # Filter NA values from hue_names\n                hue_names = list(filter(pd.notnull, hue_names))\n            self.hue_names = hue_names\n            # Filter hue_vals to only include values present in hue_names\n            if hue_order is not None:\n                mask = data[hue].isin(self.hue_names)\n                self.hue_vals = data[hue][mask]\n            else:\n                self.hue_vals = data[hue]\n        else:\n            self.hue_names = None\n            self.hue_vals = None\n",
      "\n        if hue is not None:\n            hue_names = categorical_order(data[hue], hue_order)\n            if dropna:\n                # Filter NA values from hue_names\n                hue_names = list(filter(pd.notna, hue_names))\n            self.hue_names = hue_names\n            # Filter hue_vals to only include values present in hue_names\n            if hue_order is not None:\n                mask = data[hue].isin(self.hue_names)\n                self.hue_vals = data[hue][mask]\n            else:\n                self.hue_vals = data[hue]\n        else:\n            self.hue_names = None\n            self.hue_vals = None\n",
      "\n        if hue is not None:\n            hue_names = categorical_order(data[hue], hue_order)\n            if dropna:\n                # Filter NA values from hue_names\n                hue_names = list(filter(pd.notna, hue_names))\n            self.hue_names = hue_names\n            \n            # Filter hue_vals to only include values present in hue_names\n            if hue_order is not None:\n                mask = data[hue].isin(self.hue_names)\n                self.hue_vals = data[hue][mask]\n            else:\n                self.hue_vals = data[hue]\n        else:\n            self.hue_names = None\n            self.hue_vals = None\n",
      "\n        if hue is not None:\n            hue_names = categorical_order(data[hue], hue_order)\n            if dropna:\n                # Filter NA values from hue_names\n                hue_names = list(filter(pd.notnull, hue_names))\n            self.hue_names = hue_names\n            if hue_order is not None:\n                # Filter hue_vals to only include values present in hue_order\n                mask = data[hue].isin(self.hue_names)\n                self.hue_vals = data[hue][mask]\n            else:\n                self.hue_vals = data[hue]\n        else:\n            self.hue_names = None\n            self.hue_vals = None\n"
    ],
    "Location 3 (/root/hy/projects_3/seaborn/seaborn/_oldcore.py lines 121-126)": [
      "\n        if hue is not None:\n            hue_names = utils.categorical_order(data[hue], hue_order)\n            if dropna:\n                # Filter NA values from hue_names\n                hue_names = [x for x in hue_names if not pd.isna(x)]\n            self.hue_names = hue_names\n            \n            # Filter hue_vals to only include values present in hue_names\n            if hue_order is not None:\n                mask = data[hue].isin(self.hue_names)\n                self.hue_vals = data[hue][mask]\n            else:\n                self.hue_vals = data[hue]\n",
      "\n        if hue is not None:\n            hue_names = categorical_order(data[hue], hue_order)\n            if dropna:\n                # Filter NA values from hue column and corresponding data\n                hue_mask = pd.notnull(data[hue])\n                data = data.loc[hue_mask]\n\n            self.hue_names = hue_names\n            if hue_order is not None:\n                # Filter hue_vals to only include values present in hue_order\n                mask = data[hue].isin(self.hue_names)\n                self.hue_vals = data[hue][mask]\n                # Also filter the main data to maintain consistency\n                data = data[mask]\n            else:\n                self.hue_vals = data[hue]\n        else:\n            self.hue_names = None\n            self.hue_vals = None\n",
      "\n        if hue is not None:\n            hue_names = categorical_order(data[hue], hue_order)\n            if dropna:\n                # Filter NA values from hue names\n                hue_names = [name for name in hue_names if pd.notna(name)]\n            self.hue_names = hue_names\n            \n            # Filter hue_vals to only include values present in hue_names\n            if hue_order is not None:\n                mask = data[hue].isin(self.hue_names)\n                self.hue_vals = data[hue][mask]\n            else:\n                self.hue_vals = data[hue]\n",
      "\n        # Reduce to the subset of data to be drawn on this PairGrid\n        if self._corner:\n            self._corner_grid()\n\n        if self._diag_sharey and diag_kind == \"hist\":\n            self._diag_sharey = False\n\n        # Determine names for each variable\n        if x_vars is None:\n            x_vars = list(data.columns)\n        if y_vars is None:\n            y_vars = list(data.columns)\n\n        if np.isscalar(x_vars):\n            x_vars = [x_vars]\n        if np.isscalar(y_vars):\n            y_vars = [y_vars]\n\n        self.x_vars = x_vars\n        self.y_vars = y_vars\n        self.square_grid = self.x_vars == self.y_vars\n\n        if not dropna:\n            data = data.fillna(\"\")\n\n        # Create the hue mapping\n        if hue is None:\n            self.hue_names = hue_names = None\n            self.hue_vals = None\n        else:\n            hue_names = categorical_order(data[hue], hue_order)\n            if dropna:\n                # Filter NA values from the data\n                not_na = notna(data[hue])\n                data = data[not_na]\n            self.hue_names = hue_names\n            # Filter hue_vals to only include values present in hue_names\n            if hue_order is not None:\n                mask = data[hue].isin(hue_names)\n                data = data[mask]\n                self.hue_vals = data[hue]\n            else:\n                self.hue_vals = data[hue]\n\n        # Additional filtering for non-numeric data\n        if self._corner:\n            data = data.select_dtypes([np.number, \"datetime\"])\n",
      "\n            elif map_type == \"categorical\":\n\n                cmap = norm = None\n                levels, lookup_table = self.categorical_mapping(\n                    data, palette, order,\n                )\n",
      "\n        # Set object attributes\n        if hue is None:\n            self.hue_names = None\n            self.hue_vals = None\n        else:\n            hue_names = categorical_order(data[hue], hue_order)\n            self.hue_names = hue_names\n            if hue_order is not None:\n                # Filter hue_vals to only include values present in hue_order\n                mask = data[hue].isin(self.hue_names)\n                self.hue_vals = data[hue][mask]\n            else:\n                self.hue_vals = data[hue]\n",
      "\n            elif map_type == \"categorical\":\n\n                cmap = norm = None\n                levels, lookup_table = self.categorical_mapping(\n                    data, palette, order,\n                )\n",
      "\n        if hue in data:\n            hue_names = categorical_order(data[hue], hue_order)\n            if dropna:\n                # Filter NA values from hue_names  \n                hue_names = [x for x in hue_names if pd.notna(x)]\n            self.hue_names = hue_names\n            if hue_order is not None:\n                # Filter hue_vals to only include values present in hue_order\n                mask = data[hue].isin(self.hue_names)\n                self.hue_vals = data[hue][mask]\n            else:\n                self.hue_vals = data[hue]\n"
    ],
    "Location 4 (/root/hy/projects_3/seaborn/seaborn/axisgrid.py lines 1275-1290)": [
      "\n        else:\n            # We need hue_order and hue_names because the former is used to control\n            # the order of drawing and the latter is used to control the order of\n            # the legend. hue_names can become string-typed while hue_order must\n            # retain the type of the input data. This is messy but results from\n            # the fact that PairGrid can implement the hue-mapping logic itself\n            # (and was originally written exclusively that way) but now can delegate\n            # to the axes-level functions, while always handling legend creation.\n            # See GH2307\n            hue_names = hue_order = categorical_order(data[hue], hue_order)\n            if dropna:\n                # Filter NA from the list of unique hue names\n                hue_names = list(filter(pd.notnull, hue_names))\n            self.hue_names = hue_names\n            \n            # Filter hue_vals to only include values present in hue_names\n            # to maintain consistency between hue_names and hue_vals\n            if hue_order is not None:\n                mask = data[hue].isin(self.hue_names)\n                self.hue_vals = data[hue][mask]\n            else:\n                self.hue_vals = data[hue]\n\n        # Additional dict of kwarg -> list of values for mapping the hue var\n        self.hue_kws = hue_kws if hue_kws is not None else {}\n",
      "\n        else:\n            # We need hue_order and hue_names because the former is used to control\n            # the order of drawing and the latter is used to control the order of\n            # the legend. hue_names can become string-typed while hue_order must\n            # retain the type of the input data. This is messy but results from\n            # the fact that PairGrid can implement the hue-mapping logic itself\n            # (and was originally written exclusively that way) but now can delegate\n            # to the axes-level functions, while always handling legend creation.\n            # See GH2307\n            hue_names = hue_order = categorical_order(data[hue], hue_order)\n            if dropna:\n                # Filter NA from the list of unique hue names\n                hue_names = list(filter(pd.notnull, hue_names))\n            self.hue_names = hue_names\n            \n            # Filter hue_vals to only include values present in hue_names\n            # This ensures consistency between hue_names and hue_vals\n            if hue_order is not None:\n                mask = data[hue].isin(self.hue_names)\n                self.hue_vals = data[hue][mask]\n            else:\n                self.hue_vals = data[hue]\n\n        # Additional dict of kwarg -> list of values for mapping the hue var\n        self.hue_kws = hue_kws if hue_kws is not None else {}\n",
      "\n        else:\n            # We need hue_order and hue_names because the former is used to control\n            # the order of drawing and the latter is used to control the order of\n            # the legend. hue_names can become string-typed while hue_order must\n            # retain the type of the input data. This is messy but results from\n            # the fact that PairGrid can implement the hue-mapping logic itself\n            # (and was originally written exclusively that way) but now can delegate\n            # to the axes-level functions, while always handling legend creation.\n            # See GH2307\n            hue_names = hue_order = categorical_order(data[hue], hue_order)\n            if dropna:\n                # Filter NA from the list of unique hue names\n                hue_names = list(filter(pd.notnull, hue_names))\n            self.hue_names = hue_names\n            \n            # Filter hue_vals to only include values present in hue_names\n            # to maintain data consistency and prevent color mapping errors\n            if hue_order is not None:\n                mask = data[hue].isin(self.hue_names)\n                self.hue_vals = data[hue][mask]\n            else:\n                self.hue_vals = data[hue]\n\n        # Additional dict of kwarg -> list of values for mapping the hue var\n        self.hue_kws = hue_kws if hue_kws is not None else {}\n",
      "\n        else:\n            # We need hue_order and hue_names because the former is used to control\n            # the order of drawing and the latter is used to control the order of\n            # the legend. hue_names can become string-typed while hue_order must\n            # retain the type of the input data. This is messy but results from\n            # the fact that PairGrid can implement the hue-mapping logic itself\n            # (and was originally written exclusively that way) but now can delegate\n            # to the axes-level functions, while always handling legend creation.\n            # See GH2307\n            hue_names = hue_order = categorical_order(data[hue], hue_order)\n            if dropna:\n                # Filter NA from the list of unique hue names\n                hue_names = list(filter(pd.notnull, hue_names))\n            self.hue_names = hue_names\n            \n            # Ensure hue_vals only contains values present in hue_names to maintain consistency\n            if hue_order is not None:\n                # Filter hue_vals to only include values present in hue_names\n                mask = data[hue].isin(self.hue_names)\n                self.hue_vals = data[hue][mask]\n            else:\n                self.hue_vals = data[hue]\n\n        # Additional dict of kwarg -> list of values for mapping the hue var\n        self.hue_kws = hue_kws if hue_kws is not None else {}\n",
      "\n        else:\n            # We need hue_order and hue_names because the former is used to control\n            # the order of drawing and the latter is used to control the order of\n            # the legend. hue_names can become string-typed while hue_order must\n            # retain the type of the input data. This is messy but results from\n            # the fact that PairGrid can implement the hue-mapping logic itself\n            # (and was originally written exclusively that way) but now can delegate\n            # to the axes-level functions, while always handling legend creation.\n            # See GH2307\n            hue_names = hue_order = categorical_order(data[hue], hue_order)\n            if dropna:\n                # Filter NA from the list of unique hue names\n                hue_names = list(filter(pd.notnull, hue_names))\n            self.hue_names = hue_names\n            \n            # Ensure hue_vals only contains values present in hue_names to maintain consistency\n            if hue_order is not None:\n                mask = data[hue].isin(self.hue_names)\n                self.hue_vals = data[hue][mask]\n            else:\n                self.hue_vals = data[hue]\n\n        # Additional dict of kwarg -> list of values for mapping the hue var\n        self.hue_kws = hue_kws if hue_kws is not None else {}\n",
      "\n        else:\n            # We need hue_order and hue_names because the former is used to control\n            # the order of drawing and the latter is used to control the order of\n            # the legend. hue_names can become string-typed while hue_order must\n            # retain the type of the input data. This is messy but results from\n            # the fact that PairGrid can implement the hue-mapping logic itself\n            # (and was originally written exclusively that way) but now can delegate\n            # to the axes-level functions, while always handling legend creation.\n            # See GH2307\n            hue_names = hue_order = categorical_order(data[hue], hue_order)\n            if dropna:\n                # Filter NA from the list of unique hue names\n                hue_names = list(filter(pd.notnull, hue_names))\n            self.hue_names = hue_names\n            \n            # Filter hue_vals to only include values present in hue_names\n            # This ensures consistency between hue_names and hue_vals\n            if hue_order is not None:\n                mask = data[hue].isin(self.hue_names)\n                self.hue_vals = data[hue][mask]\n            else:\n                self.hue_vals = data[hue]\n\n        # Additional dict of kwarg -> list of values for mapping the hue var\n        self.hue_kws = hue_kws if hue_kws is not None else {}\n",
      "\n        else:\n            # We need hue_order and hue_names because the former is used to control\n            # the order of drawing and the latter is used to control the order of\n            # the legend. hue_names can become string-typed while hue_order must\n            # retain the type of the input data. This is messy but results from\n            # the fact that PairGrid can implement the hue-mapping logic itself\n            # (and was originally written exclusively that way) but now can delegate\n            # to the axes-level functions, while always handling legend creation.\n            # See GH2307\n            hue_names = hue_order = categorical_order(data[hue], hue_order)\n            if dropna:\n                # Filter NA from the list of unique hue names\n                hue_names = list(filter(pd.notnull, hue_names))\n            self.hue_names = hue_names\n            \n            # Filter hue_vals to only include values present in hue_names\n            # This ensures consistency between hue_names and hue_vals\n            if hue_order is not None:\n                mask = data[hue].isin(self.hue_names)\n                self.hue_vals = data[hue][mask]\n            else:\n                self.hue_vals = data[hue]\n\n        # Additional dict of kwarg -> list of values for mapping the hue var\n        self.hue_kws = hue_kws if hue_kws is not None else {}\n",
      "\n        else:\n            # We need hue_order and hue_names because the former is used to control\n            # the order of drawing and the latter is used to control the order of\n            # the legend. hue_names can become string-typed while hue_order must\n            # retain the type of the input data. This is messy but results from\n            # the fact that PairGrid can implement the hue-mapping logic itself\n            # (and was originally written exclusively that way) but now can delegate\n            # to the axes-level functions, while always handling legend creation.\n            # See GH2307\n            hue_names = hue_order = categorical_order(data[hue], hue_order)\n            if dropna:\n                # Filter NA from the list of unique hue names\n                hue_names = list(filter(pd.notnull, hue_names))\n            self.hue_names = hue_names\n            \n            # Filter hue_vals to only include values present in hue_names\n            # to maintain consistency with the filtered hue_names list\n            if hue_order is not None:\n                mask = data[hue].isin(self.hue_names)\n                self.hue_vals = data[hue][mask]\n            else:\n                self.hue_vals = data[hue]\n\n        # Additional dict of kwarg -> list of values for mapping the hue var\n        self.hue_kws = hue_kws if hue_kws is not None else {}\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/seaborn/_oldcore.py b/seaborn/_oldcore.py\nindex c9218c1f..908dbb25 100644\n--- a/seaborn/_oldcore.py\n+++ b/seaborn/_oldcore.py\n@@ -118,6 +118,7 @@ class HueMapping(SemanticMapping):\n \n             # --- Option 2: categorical mapping using seaborn palette\n \n+\n             elif map_type == \"categorical\":\n \n                 cmap = norm = None\n@@ -143,6 +144,7 @@ class HueMapping(SemanticMapping):\n             self.norm = norm\n             self.cmap = cmap\n \n+\n     def _lookup_single(self, key):\n         \"\"\"Get the color for a single value, using colormap to interpolate.\"\"\"\n         try:\n@@ -154,10 +156,14 @@ class HueMapping(SemanticMapping):\n             try:\n                 normed = self.norm(key)\n             except TypeError as err:\n-                if np.isnan(key):\n+                try:\n+                    if np.isnan(key):\n+                        value = (0, 0, 0, 0)\n+                    else:\n+                        raise err\n+                except (TypeError, ValueError):\n+                    # Handle mixed types that can't be processed by np.isnan\n                     value = (0, 0, 0, 0)\n-                else:\n-                    raise err\n             else:\n                 if np.ma.is_masked(normed):\n                     normed = np.nan\ndiff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 8526f44b..8202a29f 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1272,6 +1272,7 @@ class PairGrid(Grid):\n         else:\n             # We need hue_order and hue_names because the former is used to control\n             # the order of drawing and the latter is used to control the order of\n+\n             # the legend. hue_names can become string-typed while hue_order must\n             # retain the type of the input data. This is messy but results from\n             # the fact that PairGrid can implement the hue-mapping logic itself\n@@ -1283,7 +1284,19 @@ class PairGrid(Grid):\n                 # Filter NA from the list of unique hue names\n                 hue_names = list(filter(pd.notnull, hue_names))\n             self.hue_names = hue_names\n-            self.hue_vals = data[hue]\n+            # Filter hue_vals to only include values present in hue_names\n+            # This ensures data consistency and prevents downstream color mapping failures\n+            if hue_order is not None:\n+                mask = data[hue].isin(self.hue_names)\n+                self.hue_vals = data[hue][mask]\n+            else:\n+                self.hue_vals = data[hue]\n+\n+        # Additional dict of kwarg -> list of values for mapping the hue var\n+        self.hue_kws = hue_kws if hue_kws is not None else {}\n+                self.hue_vals = data[hue][mask]\n+            else:\n+                self.hue_vals = data[hue]\n \n         # Additional dict of kwarg -> list of values for mapping the hue var\n         self.hue_kws = hue_kws if hue_kws is not None else {}\n",
    "variant_0": "diff --git a/seaborn/_oldcore.py b/seaborn/_oldcore.py\nindex c9218c1f..17c6428c 100644\n--- a/seaborn/_oldcore.py\n+++ b/seaborn/_oldcore.py\n@@ -118,12 +118,19 @@ class HueMapping(SemanticMapping):\n \n             # --- Option 2: categorical mapping using seaborn palette\n \n-            elif map_type == \"categorical\":\n \n-                cmap = norm = None\n-                levels, lookup_table = self.categorical_mapping(\n-                    data, palette, order,\n-                )\n+        if hue is not None:\n+            hue_names = utils.categorical_order(data[hue], hue_order)\n+            if dropna:\n+                # Filter NA values from hue_names\n+                hue_names = [x for x in hue_names if pd.notna(x)]\n+            self.hue_names = hue_names\n+            # Filter hue_vals to only include values present in hue_names\n+            if hue_order is not None:\n+                mask = data[hue].isin(self.hue_names)\n+                self.hue_vals = data[hue][mask]\n+            else:\n+                self.hue_vals = data[hue]\n \n             # --- Option 3: datetime mapping\n \n@@ -143,26 +150,22 @@ class HueMapping(SemanticMapping):\n             self.norm = norm\n             self.cmap = cmap\n \n-    def _lookup_single(self, key):\n-        \"\"\"Get the color for a single value, using colormap to interpolate.\"\"\"\n-        try:\n-            # Use a value that's in the original data vector\n-            value = self.lookup_table[key]\n-        except KeyError:\n-            # Use the colormap to interpolate between existing datapoints\n-            # (e.g. in the context of making a continuous legend)\n-            try:\n-                normed = self.norm(key)\n-            except TypeError as err:\n-                if np.isnan(key):\n-                    value = (0, 0, 0, 0)\n-                else:\n-                    raise err\n+\n+        if hue is not None:\n+            hue_names = categorical_order(data[hue], hue_order)\n+            if dropna:\n+                # Filter NA values from hue_names\n+                hue_names = list(filter(pd.notna, hue_names))\n+            self.hue_names = hue_names\n+            if hue_order is not None:\n+                # Filter hue_vals to only include values present in hue_order\n+                mask = data[hue].isin(self.hue_names)\n+                self.hue_vals = data[hue][mask]\n             else:\n-                if np.ma.is_masked(normed):\n-                    normed = np.nan\n-                value = self.cmap(normed)\n-        return value\n+                self.hue_vals = data[hue]\n+        else:\n+            self.hue_names = None\n+            self.hue_vals = None\n \n     def infer_map_type(self, palette, norm, input_format, var_type):\n         \"\"\"Determine how to implement the mapping.\"\"\"\ndiff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 8526f44b..f1112c26 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1269,6 +1269,10 @@ class PairGrid(Grid):\n             self.hue_names = hue_order = [\"_nolegend_\"]\n             self.hue_vals = pd.Series([\"_nolegend_\"] * len(data),\n                                       index=data.index)\n+        else:\n+            # We need hue_order and hue_names because the former is used to control\n+            # the order of drawing and the latter is used to control the order of\n+\n         else:\n             # We need hue_order and hue_names because the former is used to control\n             # the order of drawing and the latter is used to control the order of\n@@ -1283,7 +1287,26 @@ class PairGrid(Grid):\n                 # Filter NA from the list of unique hue names\n                 hue_names = list(filter(pd.notnull, hue_names))\n             self.hue_names = hue_names\n-            self.hue_vals = data[hue]\n+            \n+            # Ensure hue_vals only contains values present in hue_names to maintain consistency\n+            if hue_order is not None:\n+                mask = data[hue].isin(self.hue_names)\n+                self.hue_vals = data[hue][mask]\n+            else:\n+                self.hue_vals = data[hue]\n+\n+        # Additional dict of kwarg -> list of values for mapping the hue var\n+        self.hue_kws = hue_kws if hue_kws is not None else {}\n+            if dropna:\n+                # Filter NA from the list of unique hue names\n+                hue_names = list(filter(pd.notnull, hue_names))\n+            self.hue_names = hue_names\n+            # Filter hue_vals to only include values present in hue_names\n+            if hue_order is not None:\n+                mask = data[hue].isin(self.hue_names)\n+                self.hue_vals = data[hue][mask]\n+            else:\n+                self.hue_vals = data[hue]\n \n         # Additional dict of kwarg -> list of values for mapping the hue var\n         self.hue_kws = hue_kws if hue_kws is not None else {}\n",
    "variant_1": "diff --git a/seaborn/_oldcore.py b/seaborn/_oldcore.py\nindex c9218c1f..cabf06b7 100644\n--- a/seaborn/_oldcore.py\n+++ b/seaborn/_oldcore.py\n@@ -118,12 +118,20 @@ class HueMapping(SemanticMapping):\n \n             # --- Option 2: categorical mapping using seaborn palette\n \n-            elif map_type == \"categorical\":\n \n-                cmap = norm = None\n-                levels, lookup_table = self.categorical_mapping(\n-                    data, palette, order,\n-                )\n+        if hue is not None:\n+            hue_names = utils.categorical_order(data[hue], hue_order)\n+            if dropna:\n+                # Filter NA values from hue_names\n+                hue_names = [x for x in hue_names if not pd.isna(x)]\n+            self.hue_names = hue_names\n+            \n+            # Filter hue_vals to only include values present in hue_names\n+            if hue_order is not None:\n+                mask = data[hue].isin(self.hue_names)\n+                self.hue_vals = data[hue][mask]\n+            else:\n+                self.hue_vals = data[hue]\n \n             # --- Option 3: datetime mapping\n \n@@ -143,26 +151,21 @@ class HueMapping(SemanticMapping):\n             self.norm = norm\n             self.cmap = cmap\n \n-    def _lookup_single(self, key):\n-        \"\"\"Get the color for a single value, using colormap to interpolate.\"\"\"\n-        try:\n-            # Use a value that's in the original data vector\n-            value = self.lookup_table[key]\n-        except KeyError:\n-            # Use the colormap to interpolate between existing datapoints\n-            # (e.g. in the context of making a continuous legend)\n-            try:\n-                normed = self.norm(key)\n-            except TypeError as err:\n-                if np.isnan(key):\n-                    value = (0, 0, 0, 0)\n+\n+            if hue is not None:\n+                hue_names = categorical_order(data[hue], hue_order)\n+                if dropna:\n+                    # Filter NA values from hue_names\n+                    hue_names = list(filter(pd.notnull, hue_names))\n+                self.hue_names = hue_names\n+                if hue_order is not None:\n+                    # Filter hue_vals to only include values present in hue_order\n+                    mask = data[hue].isin(self.hue_names)\n+                    self.hue_vals = data[hue][mask]\n                 else:\n-                    raise err\n+                    self.hue_vals = data[hue]\n             else:\n-                if np.ma.is_masked(normed):\n-                    normed = np.nan\n-                value = self.cmap(normed)\n-        return value\n+                self.hue_names = self.hue_vals = None\n \n     def infer_map_type(self, palette, norm, input_format, var_type):\n         \"\"\"Determine how to implement the mapping.\"\"\"\ndiff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 8526f44b..ae26bf69 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1269,6 +1269,10 @@ class PairGrid(Grid):\n             self.hue_names = hue_order = [\"_nolegend_\"]\n             self.hue_vals = pd.Series([\"_nolegend_\"] * len(data),\n                                       index=data.index)\n+        else:\n+            # We need hue_order and hue_names because the former is used to control\n+            # the order of drawing and the latter is used to control the order of\n+\n         else:\n             # We need hue_order and hue_names because the former is used to control\n             # the order of drawing and the latter is used to control the order of\n@@ -1283,7 +1287,30 @@ class PairGrid(Grid):\n                 # Filter NA from the list of unique hue names\n                 hue_names = list(filter(pd.notnull, hue_names))\n             self.hue_names = hue_names\n-            self.hue_vals = data[hue]\n+            \n+            # Filter hue_vals to only include values present in hue_names\n+            # to maintain consistency between hue_names and hue_vals\n+            if hue_order is not None:\n+                mask = data[hue].isin(self.hue_names)\n+                self.hue_vals = data[hue][mask]\n+            else:\n+                self.hue_vals = data[hue]\n+\n+        # Additional dict of kwarg -> list of values for mapping the hue var\n+        self.hue_kws = hue_kws if hue_kws is not None else {}\n+            hue_names = hue_order = categorical_order(data[hue], hue_order)\n+            if dropna:\n+                # Filter NA from the list of unique hue names\n+                hue_names = list(filter(pd.notnull, hue_names))\n+            self.hue_names = hue_names\n+            \n+            # Filter hue_vals to only include values present in hue_names\n+            # This ensures consistency between hue_names and hue_vals\n+            if hue_order is not None:\n+                mask = data[hue].isin(self.hue_names)\n+                self.hue_vals = data[hue][mask]\n+            else:\n+                self.hue_vals = data[hue]\n \n         # Additional dict of kwarg -> list of values for mapping the hue var\n         self.hue_kws = hue_kws if hue_kws is not None else {}\n",
    "variant_2": "diff --git a/seaborn/_oldcore.py b/seaborn/_oldcore.py\nindex c9218c1f..839f81c3 100644\n--- a/seaborn/_oldcore.py\n+++ b/seaborn/_oldcore.py\n@@ -118,12 +118,26 @@ class HueMapping(SemanticMapping):\n \n             # --- Option 2: categorical mapping using seaborn palette\n \n-            elif map_type == \"categorical\":\n \n-                cmap = norm = None\n-                levels, lookup_table = self.categorical_mapping(\n-                    data, palette, order,\n-                )\n+        if hue is not None:\n+            hue_names = categorical_order(data[hue], hue_order)\n+            if dropna:\n+                # Filter NA values from hue column and corresponding data\n+                hue_mask = pd.notnull(data[hue])\n+                data = data.loc[hue_mask]\n+\n+            self.hue_names = hue_names\n+            if hue_order is not None:\n+                # Filter hue_vals to only include values present in hue_order\n+                mask = data[hue].isin(self.hue_names)\n+                self.hue_vals = data[hue][mask]\n+                # Also filter the main data to maintain consistency\n+                data = data[mask]\n+            else:\n+                self.hue_vals = data[hue]\n+        else:\n+            self.hue_names = None\n+            self.hue_vals = None\n \n             # --- Option 3: datetime mapping\n \n@@ -143,26 +157,19 @@ class HueMapping(SemanticMapping):\n             self.norm = norm\n             self.cmap = cmap\n \n-    def _lookup_single(self, key):\n-        \"\"\"Get the color for a single value, using colormap to interpolate.\"\"\"\n-        try:\n-            # Use a value that's in the original data vector\n-            value = self.lookup_table[key]\n-        except KeyError:\n-            # Use the colormap to interpolate between existing datapoints\n-            # (e.g. in the context of making a continuous legend)\n-            try:\n-                normed = self.norm(key)\n-            except TypeError as err:\n-                if np.isnan(key):\n-                    value = (0, 0, 0, 0)\n-                else:\n-                    raise err\n+\n+        if hue is not None:\n+            hue_names = categorical_order(data[hue], hue_order)\n+            if dropna:\n+                # Filter NA values from hue_names \n+                hue_names = [x for x in hue_names if not pd.isna(x)]\n+            self.hue_names = hue_names\n+            if hue_order is not None:\n+                # Filter hue_vals to only include values present in hue_order\n+                mask = data[hue].isin(self.hue_names)\n+                self.hue_vals = data[hue][mask]\n             else:\n-                if np.ma.is_masked(normed):\n-                    normed = np.nan\n-                value = self.cmap(normed)\n-        return value\n+                self.hue_vals = data[hue]\n \n     def infer_map_type(self, palette, norm, input_format, var_type):\n         \"\"\"Determine how to implement the mapping.\"\"\"\ndiff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 8526f44b..d137811d 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1269,6 +1269,10 @@ class PairGrid(Grid):\n             self.hue_names = hue_order = [\"_nolegend_\"]\n             self.hue_vals = pd.Series([\"_nolegend_\"] * len(data),\n                                       index=data.index)\n+        else:\n+            # We need hue_order and hue_names because the former is used to control\n+            # the order of drawing and the latter is used to control the order of\n+\n         else:\n             # We need hue_order and hue_names because the former is used to control\n             # the order of drawing and the latter is used to control the order of\n@@ -1283,7 +1287,19 @@ class PairGrid(Grid):\n                 # Filter NA from the list of unique hue names\n                 hue_names = list(filter(pd.notnull, hue_names))\n             self.hue_names = hue_names\n-            self.hue_vals = data[hue]\n+            \n+            # Filter hue_vals to only include values present in hue_names\n+            # This ensures consistency between hue_names and hue_vals\n+            if hue_order is not None:\n+                mask = data[hue].isin(self.hue_names)\n+                self.hue_vals = data[hue][mask]\n+            else:\n+                self.hue_vals = data[hue]\n+\n+        # Additional dict of kwarg -> list of values for mapping the hue var\n+        self.hue_kws = hue_kws if hue_kws is not None else {}\n+            else:\n+                self.hue_vals = data[hue]\n \n         # Additional dict of kwarg -> list of values for mapping the hue var\n         self.hue_kws = hue_kws if hue_kws is not None else {}\n",
    "variant_3": "diff --git a/seaborn/_oldcore.py b/seaborn/_oldcore.py\nindex c9218c1f..b34cfc86 100644\n--- a/seaborn/_oldcore.py\n+++ b/seaborn/_oldcore.py\n@@ -118,12 +118,20 @@ class HueMapping(SemanticMapping):\n \n             # --- Option 2: categorical mapping using seaborn palette\n \n-            elif map_type == \"categorical\":\n \n-                cmap = norm = None\n-                levels, lookup_table = self.categorical_mapping(\n-                    data, palette, order,\n-                )\n+        if hue is not None:\n+            hue_names = categorical_order(data[hue], hue_order)\n+            if dropna:\n+                # Filter NA values from hue names\n+                hue_names = [name for name in hue_names if pd.notna(name)]\n+            self.hue_names = hue_names\n+            \n+            # Filter hue_vals to only include values present in hue_names\n+            if hue_order is not None:\n+                mask = data[hue].isin(self.hue_names)\n+                self.hue_vals = data[hue][mask]\n+            else:\n+                self.hue_vals = data[hue]\n \n             # --- Option 3: datetime mapping\n \n@@ -143,26 +151,22 @@ class HueMapping(SemanticMapping):\n             self.norm = norm\n             self.cmap = cmap\n \n-    def _lookup_single(self, key):\n-        \"\"\"Get the color for a single value, using colormap to interpolate.\"\"\"\n-        try:\n-            # Use a value that's in the original data vector\n-            value = self.lookup_table[key]\n-        except KeyError:\n-            # Use the colormap to interpolate between existing datapoints\n-            # (e.g. in the context of making a continuous legend)\n-            try:\n-                normed = self.norm(key)\n-            except TypeError as err:\n-                if np.isnan(key):\n-                    value = (0, 0, 0, 0)\n-                else:\n-                    raise err\n+\n+        if hue is not None:\n+            hue_names = categorical_order(data[hue], hue_order)\n+            if dropna:\n+                # Filter NA values from hue_names but keep track of the filtering\n+                hue_names = list(filter(pd.notnull, hue_names))\n+            self.hue_names = hue_names\n+            # Filter hue_vals to only include values present in hue_names\n+            if hue_order is not None:\n+                mask = data[hue].isin(self.hue_names)\n+                self.hue_vals = data[hue][mask]\n             else:\n-                if np.ma.is_masked(normed):\n-                    normed = np.nan\n-                value = self.cmap(normed)\n-        return value\n+                self.hue_vals = data[hue]\n+        else:\n+            self.hue_names = None\n+            self.hue_vals = None\n \n     def infer_map_type(self, palette, norm, input_format, var_type):\n         \"\"\"Determine how to implement the mapping.\"\"\"\ndiff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 8526f44b..92602284 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1269,6 +1269,10 @@ class PairGrid(Grid):\n             self.hue_names = hue_order = [\"_nolegend_\"]\n             self.hue_vals = pd.Series([\"_nolegend_\"] * len(data),\n                                       index=data.index)\n+        else:\n+            # We need hue_order and hue_names because the former is used to control\n+            # the order of drawing and the latter is used to control the order of\n+\n         else:\n             # We need hue_order and hue_names because the former is used to control\n             # the order of drawing and the latter is used to control the order of\n@@ -1283,7 +1287,29 @@ class PairGrid(Grid):\n                 # Filter NA from the list of unique hue names\n                 hue_names = list(filter(pd.notnull, hue_names))\n             self.hue_names = hue_names\n-            self.hue_vals = data[hue]\n+            \n+            # Filter hue_vals to only include values present in hue_names\n+            # to maintain data consistency and prevent color mapping errors\n+            if hue_order is not None:\n+                mask = data[hue].isin(self.hue_names)\n+                self.hue_vals = data[hue][mask]\n+            else:\n+                self.hue_vals = data[hue]\n+\n+        # Additional dict of kwarg -> list of values for mapping the hue var\n+        self.hue_kws = hue_kws if hue_kws is not None else {}\n+            hue_names = hue_order = categorical_order(data[hue], hue_order)\n+            if dropna:\n+                # Filter NA from the list of unique hue names\n+                hue_names = list(filter(pd.notnull, hue_names))\n+            self.hue_names = hue_names\n+            \n+            # Filter hue_vals to only include values present in hue_names to maintain consistency\n+            if hue_order is not None:\n+                mask = data[hue].isin(self.hue_names)\n+                self.hue_vals = data[hue][mask]\n+            else:\n+                self.hue_vals = data[hue]\n \n         # Additional dict of kwarg -> list of values for mapping the hue var\n         self.hue_kws = hue_kws if hue_kws is not None else {}\n",
    "variant_4": "diff --git a/seaborn/_oldcore.py b/seaborn/_oldcore.py\nindex c9218c1f..1bdc55fc 100644\n--- a/seaborn/_oldcore.py\n+++ b/seaborn/_oldcore.py\n@@ -118,12 +118,54 @@ class HueMapping(SemanticMapping):\n \n             # --- Option 2: categorical mapping using seaborn palette\n \n-            elif map_type == \"categorical\":\n \n-                cmap = norm = None\n-                levels, lookup_table = self.categorical_mapping(\n-                    data, palette, order,\n-                )\n+        # Reduce to the subset of data to be drawn on this PairGrid\n+        if self._corner:\n+            self._corner_grid()\n+\n+        if self._diag_sharey and diag_kind == \"hist\":\n+            self._diag_sharey = False\n+\n+        # Determine names for each variable\n+        if x_vars is None:\n+            x_vars = list(data.columns)\n+        if y_vars is None:\n+            y_vars = list(data.columns)\n+\n+        if np.isscalar(x_vars):\n+            x_vars = [x_vars]\n+        if np.isscalar(y_vars):\n+            y_vars = [y_vars]\n+\n+        self.x_vars = x_vars\n+        self.y_vars = y_vars\n+        self.square_grid = self.x_vars == self.y_vars\n+\n+        if not dropna:\n+            data = data.fillna(\"\")\n+\n+        # Create the hue mapping\n+        if hue is None:\n+            self.hue_names = hue_names = None\n+            self.hue_vals = None\n+        else:\n+            hue_names = categorical_order(data[hue], hue_order)\n+            if dropna:\n+                # Filter NA values from the data\n+                not_na = notna(data[hue])\n+                data = data[not_na]\n+            self.hue_names = hue_names\n+            # Filter hue_vals to only include values present in hue_names\n+            if hue_order is not None:\n+                mask = data[hue].isin(hue_names)\n+                data = data[mask]\n+                self.hue_vals = data[hue]\n+            else:\n+                self.hue_vals = data[hue]\n+\n+        # Additional filtering for non-numeric data\n+        if self._corner:\n+            data = data.select_dtypes([np.number, \"datetime\"])\n \n             # --- Option 3: datetime mapping\n \n@@ -143,26 +185,22 @@ class HueMapping(SemanticMapping):\n             self.norm = norm\n             self.cmap = cmap\n \n-    def _lookup_single(self, key):\n-        \"\"\"Get the color for a single value, using colormap to interpolate.\"\"\"\n-        try:\n-            # Use a value that's in the original data vector\n-            value = self.lookup_table[key]\n-        except KeyError:\n-            # Use the colormap to interpolate between existing datapoints\n-            # (e.g. in the context of making a continuous legend)\n-            try:\n-                normed = self.norm(key)\n-            except TypeError as err:\n-                if np.isnan(key):\n-                    value = (0, 0, 0, 0)\n-                else:\n-                    raise err\n+\n+        if hue is not None:\n+            hue_names = categorical_order(data[hue], hue_order)\n+            if dropna:\n+                # Filter NA values from hue_names\n+                hue_names = list(filter(pd.notnull, hue_names))\n+            self.hue_names = hue_names\n+            if hue_order is not None:\n+                # Filter hue_vals to only include values present in hue_order\n+                mask = data[hue].isin(self.hue_names)\n+                self.hue_vals = data[hue][mask]\n             else:\n-                if np.ma.is_masked(normed):\n-                    normed = np.nan\n-                value = self.cmap(normed)\n-        return value\n+                self.hue_vals = data[hue]\n+        else:\n+            self.hue_names = None\n+            self.hue_vals = None\n \n     def infer_map_type(self, palette, norm, input_format, var_type):\n         \"\"\"Determine how to implement the mapping.\"\"\"\ndiff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 8526f44b..d7fe255a 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1269,6 +1269,10 @@ class PairGrid(Grid):\n             self.hue_names = hue_order = [\"_nolegend_\"]\n             self.hue_vals = pd.Series([\"_nolegend_\"] * len(data),\n                                       index=data.index)\n+        else:\n+            # We need hue_order and hue_names because the former is used to control\n+            # the order of drawing and the latter is used to control the order of\n+\n         else:\n             # We need hue_order and hue_names because the former is used to control\n             # the order of drawing and the latter is used to control the order of\n@@ -1283,7 +1287,27 @@ class PairGrid(Grid):\n                 # Filter NA from the list of unique hue names\n                 hue_names = list(filter(pd.notnull, hue_names))\n             self.hue_names = hue_names\n-            self.hue_vals = data[hue]\n+            \n+            # Ensure hue_vals only contains values present in hue_names to maintain consistency\n+            if hue_order is not None:\n+                # Filter hue_vals to only include values present in hue_names\n+                mask = data[hue].isin(self.hue_names)\n+                self.hue_vals = data[hue][mask]\n+            else:\n+                self.hue_vals = data[hue]\n+\n+        # Additional dict of kwarg -> list of values for mapping the hue var\n+        self.hue_kws = hue_kws if hue_kws is not None else {}\n+            if dropna:\n+                # Filter NA from the list of unique hue names\n+                hue_names = list(filter(pd.notnull, hue_names))\n+            self.hue_names = hue_names\n+            # Filter hue_vals to only include values present in hue_names\n+            if hue_order is not None:\n+                mask = data[hue].isin(self.hue_names)\n+                self.hue_vals = data[hue][mask]\n+            else:\n+                self.hue_vals = data[hue]\n \n         # Additional dict of kwarg -> list of values for mapping the hue var\n         self.hue_kws = hue_kws if hue_kws is not None else {}\n",
    "variant_5": "diff --git a/seaborn/_oldcore.py b/seaborn/_oldcore.py\nindex c9218c1f..0f473a16 100644\n--- a/seaborn/_oldcore.py\n+++ b/seaborn/_oldcore.py\n@@ -118,6 +118,7 @@ class HueMapping(SemanticMapping):\n \n             # --- Option 2: categorical mapping using seaborn palette\n \n+\n             elif map_type == \"categorical\":\n \n                 cmap = norm = None\n@@ -143,26 +144,22 @@ class HueMapping(SemanticMapping):\n             self.norm = norm\n             self.cmap = cmap\n \n-    def _lookup_single(self, key):\n-        \"\"\"Get the color for a single value, using colormap to interpolate.\"\"\"\n-        try:\n-            # Use a value that's in the original data vector\n-            value = self.lookup_table[key]\n-        except KeyError:\n-            # Use the colormap to interpolate between existing datapoints\n-            # (e.g. in the context of making a continuous legend)\n-            try:\n-                normed = self.norm(key)\n-            except TypeError as err:\n-                if np.isnan(key):\n-                    value = (0, 0, 0, 0)\n-                else:\n-                    raise err\n+\n+        if hue is not None:\n+            hue_names = categorical_order(data[hue], hue_order)\n+            if dropna:\n+                # Filter NA values from hue_names\n+                hue_names = list(filter(pd.notnull, hue_names))\n+            self.hue_names = hue_names\n+            # Filter hue_vals to only include values present in hue_names\n+            if hue_order is not None:\n+                mask = data[hue].isin(self.hue_names)\n+                self.hue_vals = data[hue][mask]\n             else:\n-                if np.ma.is_masked(normed):\n-                    normed = np.nan\n-                value = self.cmap(normed)\n-        return value\n+                self.hue_vals = data[hue]\n+        else:\n+            self.hue_names = None\n+            self.hue_vals = None\n \n     def infer_map_type(self, palette, norm, input_format, var_type):\n         \"\"\"Determine how to implement the mapping.\"\"\"\ndiff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 8526f44b..61fed02f 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1269,6 +1269,10 @@ class PairGrid(Grid):\n             self.hue_names = hue_order = [\"_nolegend_\"]\n             self.hue_vals = pd.Series([\"_nolegend_\"] * len(data),\n                                       index=data.index)\n+        else:\n+            # We need hue_order and hue_names because the former is used to control\n+            # the order of drawing and the latter is used to control the order of\n+\n         else:\n             # We need hue_order and hue_names because the former is used to control\n             # the order of drawing and the latter is used to control the order of\n@@ -1283,7 +1287,18 @@ class PairGrid(Grid):\n                 # Filter NA from the list of unique hue names\n                 hue_names = list(filter(pd.notnull, hue_names))\n             self.hue_names = hue_names\n-            self.hue_vals = data[hue]\n+            \n+            # Ensure hue_vals only contains values present in hue_names to maintain consistency\n+            if hue_order is not None:\n+                mask = data[hue].isin(self.hue_names)\n+                self.hue_vals = data[hue][mask]\n+            else:\n+                self.hue_vals = data[hue]\n+\n+        # Additional dict of kwarg -> list of values for mapping the hue var\n+        self.hue_kws = hue_kws if hue_kws is not None else {}\n+            else:\n+                self.hue_vals = data[hue]\n \n         # Additional dict of kwarg -> list of values for mapping the hue var\n         self.hue_kws = hue_kws if hue_kws is not None else {}\n",
    "variant_6": "diff --git a/seaborn/_oldcore.py b/seaborn/_oldcore.py\nindex c9218c1f..47bad3a4 100644\n--- a/seaborn/_oldcore.py\n+++ b/seaborn/_oldcore.py\n@@ -118,12 +118,20 @@ class HueMapping(SemanticMapping):\n \n             # --- Option 2: categorical mapping using seaborn palette\n \n-            elif map_type == \"categorical\":\n \n-                cmap = norm = None\n-                levels, lookup_table = self.categorical_mapping(\n-                    data, palette, order,\n-                )\n+        # Set object attributes\n+        if hue is None:\n+            self.hue_names = None\n+            self.hue_vals = None\n+        else:\n+            hue_names = categorical_order(data[hue], hue_order)\n+            self.hue_names = hue_names\n+            if hue_order is not None:\n+                # Filter hue_vals to only include values present in hue_order\n+                mask = data[hue].isin(self.hue_names)\n+                self.hue_vals = data[hue][mask]\n+            else:\n+                self.hue_vals = data[hue]\n \n             # --- Option 3: datetime mapping\n \n@@ -143,26 +151,22 @@ class HueMapping(SemanticMapping):\n             self.norm = norm\n             self.cmap = cmap\n \n-    def _lookup_single(self, key):\n-        \"\"\"Get the color for a single value, using colormap to interpolate.\"\"\"\n-        try:\n-            # Use a value that's in the original data vector\n-            value = self.lookup_table[key]\n-        except KeyError:\n-            # Use the colormap to interpolate between existing datapoints\n-            # (e.g. in the context of making a continuous legend)\n-            try:\n-                normed = self.norm(key)\n-            except TypeError as err:\n-                if np.isnan(key):\n-                    value = (0, 0, 0, 0)\n-                else:\n-                    raise err\n+\n+        if hue is not None:\n+            hue_names = categorical_order(data[hue], hue_order)\n+            if dropna:\n+                # Filter NA values from hue_names\n+                hue_names = list(filter(pd.notna, hue_names))\n+            self.hue_names = hue_names\n+            # Filter hue_vals to only include values present in hue_names\n+            if hue_order is not None:\n+                mask = data[hue].isin(self.hue_names)\n+                self.hue_vals = data[hue][mask]\n             else:\n-                if np.ma.is_masked(normed):\n-                    normed = np.nan\n-                value = self.cmap(normed)\n-        return value\n+                self.hue_vals = data[hue]\n+        else:\n+            self.hue_names = None\n+            self.hue_vals = None\n \n     def infer_map_type(self, palette, norm, input_format, var_type):\n         \"\"\"Determine how to implement the mapping.\"\"\"\ndiff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 8526f44b..8364c9f1 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1269,6 +1269,10 @@ class PairGrid(Grid):\n             self.hue_names = hue_order = [\"_nolegend_\"]\n             self.hue_vals = pd.Series([\"_nolegend_\"] * len(data),\n                                       index=data.index)\n+        else:\n+            # We need hue_order and hue_names because the former is used to control\n+            # the order of drawing and the latter is used to control the order of\n+\n         else:\n             # We need hue_order and hue_names because the former is used to control\n             # the order of drawing and the latter is used to control the order of\n@@ -1283,7 +1287,27 @@ class PairGrid(Grid):\n                 # Filter NA from the list of unique hue names\n                 hue_names = list(filter(pd.notnull, hue_names))\n             self.hue_names = hue_names\n-            self.hue_vals = data[hue]\n+            \n+            # Filter hue_vals to only include values present in hue_names\n+            # This ensures consistency between hue_names and hue_vals\n+            if hue_order is not None:\n+                mask = data[hue].isin(self.hue_names)\n+                self.hue_vals = data[hue][mask]\n+            else:\n+                self.hue_vals = data[hue]\n+\n+        # Additional dict of kwarg -> list of values for mapping the hue var\n+        self.hue_kws = hue_kws if hue_kws is not None else {}\n+            if dropna:\n+                # Filter NA from the list of unique hue names\n+                hue_names = list(filter(pd.notnull, hue_names))\n+            self.hue_names = hue_names\n+            # Filter hue_vals to only include values present in hue_names to maintain consistency\n+            if hue_order is not None:\n+                mask = data[hue].isin(self.hue_names)\n+                self.hue_vals = data[hue][mask]\n+            else:\n+                self.hue_vals = data[hue]\n \n         # Additional dict of kwarg -> list of values for mapping the hue var\n         self.hue_kws = hue_kws if hue_kws is not None else {}\n",
    "variant_7": "diff --git a/seaborn/_oldcore.py b/seaborn/_oldcore.py\nindex c9218c1f..1f9235e3 100644\n--- a/seaborn/_oldcore.py\n+++ b/seaborn/_oldcore.py\n@@ -118,6 +118,7 @@ class HueMapping(SemanticMapping):\n \n             # --- Option 2: categorical mapping using seaborn palette\n \n+\n             elif map_type == \"categorical\":\n \n                 cmap = norm = None\n@@ -143,26 +144,23 @@ class HueMapping(SemanticMapping):\n             self.norm = norm\n             self.cmap = cmap\n \n-    def _lookup_single(self, key):\n-        \"\"\"Get the color for a single value, using colormap to interpolate.\"\"\"\n-        try:\n-            # Use a value that's in the original data vector\n-            value = self.lookup_table[key]\n-        except KeyError:\n-            # Use the colormap to interpolate between existing datapoints\n-            # (e.g. in the context of making a continuous legend)\n-            try:\n-                normed = self.norm(key)\n-            except TypeError as err:\n-                if np.isnan(key):\n-                    value = (0, 0, 0, 0)\n-                else:\n-                    raise err\n+\n+        if hue is not None:\n+            hue_names = categorical_order(data[hue], hue_order)\n+            if dropna:\n+                # Filter NA values from hue_names\n+                hue_names = list(filter(pd.notna, hue_names))\n+            self.hue_names = hue_names\n+            \n+            # Filter hue_vals to only include values present in hue_names\n+            if hue_order is not None:\n+                mask = data[hue].isin(self.hue_names)\n+                self.hue_vals = data[hue][mask]\n             else:\n-                if np.ma.is_masked(normed):\n-                    normed = np.nan\n-                value = self.cmap(normed)\n-        return value\n+                self.hue_vals = data[hue]\n+        else:\n+            self.hue_names = None\n+            self.hue_vals = None\n \n     def infer_map_type(self, palette, norm, input_format, var_type):\n         \"\"\"Determine how to implement the mapping.\"\"\"\ndiff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 8526f44b..ca32dcdf 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1269,6 +1269,10 @@ class PairGrid(Grid):\n             self.hue_names = hue_order = [\"_nolegend_\"]\n             self.hue_vals = pd.Series([\"_nolegend_\"] * len(data),\n                                       index=data.index)\n+        else:\n+            # We need hue_order and hue_names because the former is used to control\n+            # the order of drawing and the latter is used to control the order of\n+\n         else:\n             # We need hue_order and hue_names because the former is used to control\n             # the order of drawing and the latter is used to control the order of\n@@ -1283,7 +1287,21 @@ class PairGrid(Grid):\n                 # Filter NA from the list of unique hue names\n                 hue_names = list(filter(pd.notnull, hue_names))\n             self.hue_names = hue_names\n-            self.hue_vals = data[hue]\n+            \n+            # Filter hue_vals to only include values present in hue_names\n+            # This ensures consistency between hue_names and hue_vals\n+            if hue_order is not None:\n+                mask = data[hue].isin(self.hue_names)\n+                self.hue_vals = data[hue][mask]\n+            else:\n+                self.hue_vals = data[hue]\n+\n+        # Additional dict of kwarg -> list of values for mapping the hue var\n+        self.hue_kws = hue_kws if hue_kws is not None else {}\n+                mask = data[hue].isin(self.hue_names)\n+                self.hue_vals = data[hue][mask]\n+            else:\n+                self.hue_vals = data[hue]\n \n         # Additional dict of kwarg -> list of values for mapping the hue var\n         self.hue_kws = hue_kws if hue_kws is not None else {}\n",
    "variant_8": "diff --git a/seaborn/_oldcore.py b/seaborn/_oldcore.py\nindex c9218c1f..691b88ef 100644\n--- a/seaborn/_oldcore.py\n+++ b/seaborn/_oldcore.py\n@@ -118,12 +118,19 @@ class HueMapping(SemanticMapping):\n \n             # --- Option 2: categorical mapping using seaborn palette\n \n-            elif map_type == \"categorical\":\n \n-                cmap = norm = None\n-                levels, lookup_table = self.categorical_mapping(\n-                    data, palette, order,\n-                )\n+        if hue in data:\n+            hue_names = categorical_order(data[hue], hue_order)\n+            if dropna:\n+                # Filter NA values from hue_names  \n+                hue_names = [x for x in hue_names if pd.notna(x)]\n+            self.hue_names = hue_names\n+            if hue_order is not None:\n+                # Filter hue_vals to only include values present in hue_order\n+                mask = data[hue].isin(self.hue_names)\n+                self.hue_vals = data[hue][mask]\n+            else:\n+                self.hue_vals = data[hue]\n \n             # --- Option 3: datetime mapping\n \n@@ -143,26 +150,22 @@ class HueMapping(SemanticMapping):\n             self.norm = norm\n             self.cmap = cmap\n \n-    def _lookup_single(self, key):\n-        \"\"\"Get the color for a single value, using colormap to interpolate.\"\"\"\n-        try:\n-            # Use a value that's in the original data vector\n-            value = self.lookup_table[key]\n-        except KeyError:\n-            # Use the colormap to interpolate between existing datapoints\n-            # (e.g. in the context of making a continuous legend)\n-            try:\n-                normed = self.norm(key)\n-            except TypeError as err:\n-                if np.isnan(key):\n-                    value = (0, 0, 0, 0)\n-                else:\n-                    raise err\n+\n+        if hue is not None:\n+            hue_names = categorical_order(data[hue], hue_order)\n+            if dropna:\n+                # Filter NA values from hue_names\n+                hue_names = list(filter(pd.notnull, hue_names))\n+            self.hue_names = hue_names\n+            if hue_order is not None:\n+                # Filter hue_vals to only include values present in hue_order\n+                mask = data[hue].isin(self.hue_names)\n+                self.hue_vals = data[hue][mask]\n             else:\n-                if np.ma.is_masked(normed):\n-                    normed = np.nan\n-                value = self.cmap(normed)\n-        return value\n+                self.hue_vals = data[hue]\n+        else:\n+            self.hue_names = None\n+            self.hue_vals = None\n \n     def infer_map_type(self, palette, norm, input_format, var_type):\n         \"\"\"Determine how to implement the mapping.\"\"\"\ndiff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 8526f44b..49d3b4fe 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1269,6 +1269,10 @@ class PairGrid(Grid):\n             self.hue_names = hue_order = [\"_nolegend_\"]\n             self.hue_vals = pd.Series([\"_nolegend_\"] * len(data),\n                                       index=data.index)\n+        else:\n+            # We need hue_order and hue_names because the former is used to control\n+            # the order of drawing and the latter is used to control the order of\n+\n         else:\n             # We need hue_order and hue_names because the former is used to control\n             # the order of drawing and the latter is used to control the order of\n@@ -1283,7 +1287,27 @@ class PairGrid(Grid):\n                 # Filter NA from the list of unique hue names\n                 hue_names = list(filter(pd.notnull, hue_names))\n             self.hue_names = hue_names\n-            self.hue_vals = data[hue]\n+            \n+            # Filter hue_vals to only include values present in hue_names\n+            # to maintain consistency with the filtered hue_names list\n+            if hue_order is not None:\n+                mask = data[hue].isin(self.hue_names)\n+                self.hue_vals = data[hue][mask]\n+            else:\n+                self.hue_vals = data[hue]\n+\n+        # Additional dict of kwarg -> list of values for mapping the hue var\n+        self.hue_kws = hue_kws if hue_kws is not None else {}\n+            if dropna:\n+                # Filter NA from the list of unique hue names\n+                hue_names = list(filter(pd.notnull, hue_names))\n+            self.hue_names = hue_names\n+            # Filter hue_vals to only include values present in hue_names to maintain consistency\n+            if hue_order is not None:\n+                mask = data[hue].isin(self.hue_names)\n+                self.hue_vals = data[hue][mask]\n+            else:\n+                self.hue_vals = data[hue]\n \n         # Additional dict of kwarg -> list of values for mapping the hue var\n         self.hue_kws = hue_kws if hue_kws is not None else {}\n"
  }
}