{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/django/django/db/models/sql/compiler.py lines 1277-1278)": "\n            def remote_setter(name, obj, from_obj):\n                # For FilteredRelations, we need to properly set the cached value\n                # using the field's caching mechanism instead of generic setattr\n                if hasattr(from_obj, '_state') and hasattr(from_obj._state, 'fields_cache'):\n                    from_obj._state.fields_cache[name] = obj\n                else:\n                    setattr(from_obj, name, obj)\n",
    "Location 2 (/root/hy/projects_3/django/django/db/models/sql/compiler.py lines 1294-1302)": "\n                    klass_info = {\n                        \"model\": model,\n                        \"field\": final_field,\n                        \"reverse\": True,\n                        \"local_setter\": partial(local_setter, final_field),\n                        \"remote_setter\": partial(remote_setter, name, final_field),\n                        \"from_parent\": from_parent,\n                    }\n                    related_klass_infos.append(klass_info)\n",
    "Location 3 (/root/hy/projects_3/django/django/db/models/sql/compiler.py lines 1284-1288)": "\n            for name in list(requested):\n                # Filtered relations work only on the topmost level.\n                if cur_depth > 1:\n                    break\n                if name in self.query._filtered_relations:\n                    fields_found.add(name)\n                    filtered_relation = self.query._filtered_relations[name]\n                    final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n                        [name], opts, root_alias\n                    )\n                    # Store the FilteredRelation for proper caching context\n                    if hasattr(final_field, '_filtered_relation'):\n                        final_field._filtered_relation = filtered_relation\n",
    "Location 4 (/root/hy/projects_3/django/django/db/models/sql/compiler.py lines 1316-1319)": "\n                    next_klass_infos = self.get_related_selections(\n                        select,\n                        field_select_mask,\n                        opts=model._meta,\n                        root_alias=alias,\n                        cur_depth=cur_depth + 1,\n                        requested=next_requested,\n                        restricted=restricted,\n                    )\n",
    "Location 5 (/root/hy/projects_3/django/django/db/models/sql/compiler.py lines 1272-1275)": "\n            def local_setter(final_field, obj, from_obj):\n                # Set a reverse fk object when relation is non-empty.\n                if from_obj:\n                    final_field.remote_field.set_cached_value(from_obj, obj)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/django/django/db/models/sql/compiler.py lines 1277-1278)": [
      "\n            def remote_setter(name, obj, from_obj):\n                # For FilteredRelations, we need to properly set the cached value\n                # using the field's caching mechanism instead of generic setattr\n                if hasattr(from_obj, '_state') and hasattr(from_obj._state, 'fields_cache'):\n                    from_obj._state.fields_cache[name] = obj\n                else:\n                    setattr(from_obj, name, obj)\n",
      "\n            def remote_setter(name, obj, from_obj):\n                # For FilteredRelations, we need to properly set the cached value\n                # using the field's caching mechanism instead of generic setattr\n                if hasattr(from_obj, '_state') and hasattr(from_obj._state, 'fields_cache'):\n                    from_obj._state.fields_cache[name] = obj\n                else:\n                    setattr(from_obj, name, obj)\n",
      "\n            def remote_setter(name, obj, from_obj):\n                # For FilteredRelations, we need to properly set the cached value\n                # using the field's caching mechanism instead of generic setattr\n                if hasattr(from_obj, '_state') and hasattr(from_obj._state, 'fields_cache'):\n                    from_obj._state.fields_cache[name] = obj\n                else:\n                    setattr(from_obj, name, obj)\n",
      "\ndef remote_setter(name, obj, from_obj):\n    # For FilteredRelations, we need to properly set the cached value\n    # using the field's caching mechanism instead of generic setattr\n    if hasattr(from_obj, '_state') and hasattr(from_obj._state, 'fields_cache'):\n        from_obj._state.fields_cache[name] = obj\n    else:\n        setattr(from_obj, name, obj)\n",
      "\n            def remote_setter(name, obj, from_obj):\n                # For FilteredRelations, we need to properly set the cached value\n                # using the field's caching mechanism instead of generic setattr\n                if hasattr(from_obj, '_state') and hasattr(from_obj._state, 'fields_cache'):\n                    from_obj._state.fields_cache[name] = obj\n                else:\n                    setattr(from_obj, name, obj)\n",
      "\n            def remote_setter(name, obj, from_obj):\n                # For FilteredRelations, we need to properly set the cached value\n                # using the field's caching mechanism instead of generic setattr\n                if hasattr(from_obj, '_state') and hasattr(from_obj._state, 'fields_cache'):\n                    from_obj._state.fields_cache[name] = obj\n                else:\n                    setattr(from_obj, name, obj)\n",
      "\ndef remote_setter(name, obj, from_obj):\n    # For FilteredRelations, we need to properly set the cached value\n    # using the field's caching mechanism instead of generic setattr\n    if hasattr(from_obj, '_state') and hasattr(from_obj._state, 'fields_cache'):\n        from_obj._state.fields_cache[name] = obj\n    else:\n        setattr(from_obj, name, obj)\n",
      "\ndef remote_setter(name, obj, from_obj):\n    # For FilteredRelations, we need to properly set the cached value\n    # using the field's caching mechanism instead of generic setattr\n    if hasattr(from_obj, '_state') and hasattr(from_obj._state, 'fields_cache'):\n        from_obj._state.fields_cache[name] = obj\n    else:\n        setattr(from_obj, name, obj)\n"
    ],
    "Location 2 (/root/hy/projects_3/django/django/db/models/sql/compiler.py lines 1294-1302)": [
      "\n                    klass_info = {\n                        \"model\": model,\n                        \"field\": final_field,\n                        \"reverse\": True,\n                        \"local_setter\": partial(local_setter, final_field),\n                        \"remote_setter\": partial(remote_setter, name) if final_field is None else final_field.set_cached_value,\n                        \"from_parent\": from_parent,\n                    }\n                    related_klass_infos.append(klass_info)\n",
      "\n                    klass_info = {\n                        \"model\": model,\n                        \"field\": final_field,\n                        \"reverse\": True,\n                        \"local_setter\": partial(local_setter, final_field),\n                        \"remote_setter\": partial(remote_setter, name, final_field),\n                        \"from_parent\": from_parent,\n                    }\n                    related_klass_infos.append(klass_info)\n",
      "\n                    klass_info = {\n                        \"model\": model,\n                        \"field\": final_field,\n                        \"reverse\": True,\n                        \"local_setter\": partial(local_setter, final_field),\n                        \"remote_setter\": partial(remote_setter, name, final_field),\n                        \"from_parent\": from_parent,\n                    }\n                    related_klass_infos.append(klass_info)\n",
      "\n                    klass_info = {\n                        \"model\": model,\n                        \"field\": final_field,\n                        \"reverse\": True,\n                        \"local_setter\": partial(local_setter, final_field),\n                        \"remote_setter\": partial(remote_setter, name, final_field),\n                        \"from_parent\": from_parent,\n                    }\n                    related_klass_infos.append(klass_info)\n",
      "\n                    klass_info = {\n                        \"model\": model,\n                        \"field\": final_field,\n                        \"reverse\": True,\n                        \"local_setter\": partial(local_setter, final_field),\n                        \"remote_setter\": partial(remote_setter, name, final_field),\n                        \"from_parent\": from_parent,\n                    }\n                    related_klass_infos.append(klass_info)\n",
      "\n                    klass_info = {\n                        \"model\": model,\n                        \"field\": final_field,\n                        \"reverse\": True,\n                        \"local_setter\": partial(local_setter, final_field),\n                        \"remote_setter\": partial(remote_setter, name) if final_field is None else final_field.set_cached_value,\n                        \"from_parent\": from_parent,\n                    }\n                    related_klass_infos.append(klass_info)\n",
      "\n                    klass_info = {\n                        \"model\": model,\n                        \"field\": final_field,\n                        \"reverse\": True,\n                        \"local_setter\": partial(local_setter, final_field),\n                        \"remote_setter\": partial(remote_setter, name, final_field),\n                        \"from_parent\": from_parent,\n                    }\n                    related_klass_infos.append(klass_info)\n",
      "\n                    klass_info = {\n                        \"model\": model,\n                        \"field\": final_field,\n                        \"reverse\": True,\n                        \"local_setter\": partial(local_setter, final_field),\n                        \"remote_setter\": partial(remote_setter, name, final_field),\n                        \"from_parent\": from_parent,\n                    }\n                    related_klass_infos.append(klass_info)\n"
    ],
    "Location 3 (/root/hy/projects_3/django/django/db/models/sql/compiler.py lines 1284-1288)": [
      "\n            for name in list(requested):\n                # Filtered relations work only on the topmost level.\n                if cur_depth > 1:\n                    break\n                if name in self.query._filtered_relations:\n                    fields_found.add(name)\n                    filtered_relation = self.query._filtered_relations[name]\n                    final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n                        [name], opts, root_alias\n                    )\n                    # Store the FilteredRelation for proper field caching context\n                    if hasattr(final_field, 'remote_field') and final_field.remote_field:\n                        final_field.remote_field._filtered_relation = filtered_relation\n",
      "\n            for name in list(requested):\n                # Filtered relations work only on the topmost level.\n                if cur_depth > 1:\n                    break\n                if name in self.query._filtered_relations:\n                    fields_found.add(name)\n                    filtered_relation = self.query._filtered_relations[name]\n                    final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n                        [name], opts, root_alias\n                    )\n                    # Store the FilteredRelation for proper field caching context\n                    if hasattr(final_field, '_filtered_relation_info'):\n                        final_field._filtered_relation_info = filtered_relation\n",
      "\n            for name in list(requested):\n                # Filtered relations work only on the topmost level.\n                if cur_depth > 1:\n                    break\n                if name in self.query._filtered_relations:\n                    fields_found.add(name)\n                    filtered_relation = self.query._filtered_relations[name]\n                    final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n                        [name], opts, root_alias\n                    )\n                    # Store the FilteredRelation for proper caching context\n                    if hasattr(final_field, '_filtered_relation'):\n                        final_field._filtered_relation = filtered_relation\n",
      "\n            for name in list(requested):\n                # Filtered relations work only on the topmost level.\n                if cur_depth > 1:\n                    break\n                if name in self.query._filtered_relations:\n                    fields_found.add(name)\n                    filtered_relation = self.query._filtered_relations[name]\n                    final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n                        [name], opts, root_alias\n                    )\n                    # Store the FilteredRelation for proper caching context\n                    if hasattr(final_field, 'remote_field') and final_field.remote_field:\n                        final_field.remote_field._filtered_relation = filtered_relation\n",
      "\n            for name in list(requested):\n                # Filtered relations work only on the topmost level.\n                if cur_depth > 1:\n                    break\n                if name in self.query._filtered_relations:\n                    fields_found.add(name)\n                    filtered_relation = self.query._filtered_relations[name]\n                    final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n                        [name], opts, root_alias\n                    )\n                    # Store the FilteredRelation for proper field caching context\n                    if hasattr(final_field, 'remote_field') and final_field.remote_field:\n                        final_field.remote_field._filtered_relation = filtered_relation\n",
      "\n            for name in list(requested):\n                # Filtered relations work only on the topmost level.\n                if cur_depth > 1:\n                    break\n                if name in self.query._filtered_relations:\n                    fields_found.add(name)\n                    filtered_relation = self.query._filtered_relations[name]\n                    final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n                        [name], opts, root_alias\n                    )\n",
      "\n            for name in list(requested):\n                # Filtered relations work only on the topmost level.\n                if cur_depth > 1:\n                    break\n                if name in self.query._filtered_relations:\n                    fields_found.add(name)\n                    filtered_relation = self.query._filtered_relations[name]\n                    final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n                        [name], opts, root_alias\n                    )\n                    # Store the FilteredRelation for proper field caching context\n                    if hasattr(final_field, 'remote_field') and final_field.remote_field:\n                        final_field._filtered_relation = filtered_relation\n",
      "\n            for name in list(requested):\n                # Filtered relations work only on the topmost level.\n                if cur_depth > 1:\n                    break\n                if name in self.query._filtered_relations:\n                    fields_found.add(name)\n                    filtered_relation = self.query._filtered_relations[name]\n                    final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n                        [name], opts, root_alias\n                    )\n                    # Store the FilteredRelation for proper field relationship handling\n                    if hasattr(final_field, 'remote_field') and final_field.remote_field:\n                        final_field.remote_field._filtered_relation = filtered_relation\n"
    ],
    "Location 4 (/root/hy/projects_3/django/django/db/models/sql/compiler.py lines 1316-1319)": [
      "\n                    next_klass_infos = self.get_related_selections(\n                        select,\n                        field_select_mask,\n                        opts=model._meta,\n                        root_alias=alias,\n                        cur_depth=cur_depth + 1,\n                        requested=next_requested,\n                        restricted=restricted,\n                    )\n",
      "\n                next_klass_infos = self.get_related_selections(\n                    select,\n                    field_select_mask,\n                    opts=model._meta,\n                    root_alias=alias,\n                    cur_depth=cur_depth + 1,\n                    requested=next_requested,\n                    restricted=restricted,\n                )\n",
      "\n                    next_klass_infos = self.get_related_selections(\n                        select,\n                        field_select_mask,\n                        opts=model._meta,\n                        root_alias=alias,\n                        cur_depth=cur_depth + 1,\n                        requested=next_requested,\n                        restricted=restricted,\n                    )\n",
      "\n                    next_klass_infos = self.get_related_selections(\n                        select,\n                        field_select_mask,\n                        opts=model._meta,\n                        root_alias=alias,\n                        cur_depth=cur_depth + 1,\n                        requested=next_requested,\n                        restricted=restricted,\n                    )\n",
      "\n                    next_klass_infos = self.get_related_selections(\n                        select,\n                        field_select_mask,\n                        opts=model._meta,\n                        root_alias=alias,\n                        cur_depth=cur_depth + 1,\n                        requested=next_requested,\n                        restricted=restricted,\n                    )\n",
      "\n                    next_klass_infos = self.get_related_selections(\n                        select,\n                        field_select_mask,\n                        opts=model._meta,\n                        root_alias=alias,\n                        cur_depth=cur_depth + 1,\n                        requested=next_requested,\n                        restricted=restricted,\n                    )\n",
      "\n                    next_klass_infos = self.get_related_selections(\n                        select,\n                        field_select_mask,\n                        opts=model._meta,\n                        root_alias=alias,\n                        cur_depth=cur_depth + 1,\n                        requested=next_requested,\n                        restricted=restricted,\n                    )\n",
      "\n                    next_klass_infos = self.get_related_selections(\n                        select,\n                        field_select_mask,\n                        opts=model._meta,\n                        root_alias=alias,\n                        cur_depth=cur_depth + 1,\n                        requested=next_requested,\n                        restricted=restricted,\n                    )\n"
    ],
    "Location 5 (/root/hy/projects_3/django/django/db/models/sql/compiler.py lines 1272-1275)": [
      "\n            def local_setter(final_field, obj, from_obj):\n                # Set a reverse fk object when relation is non-empty.\n                if from_obj:\n                    final_field.remote_field.set_cached_value(from_obj, obj)\n",
      "\n            def local_setter(final_field, obj, from_obj):\n                # Set a reverse fk object when relation is non-empty.\n                if from_obj:\n                    final_field.remote_field.set_cached_value(from_obj, obj)\n",
      "\n            def local_setter(final_field, obj, from_obj):\n                # Set a reverse fk object when relation is non-empty.\n                if from_obj:\n                    final_field.remote_field.set_cached_value(from_obj, obj)\n",
      "\n            def local_setter(final_field, obj, from_obj):\n                # Set a reverse fk object when relation is non-empty.\n                if from_obj:\n                    final_field.remote_field.set_cached_value(from_obj, obj)\n",
      "\n            def local_setter(final_field, obj, from_obj):\n                # Set a reverse fk object when relation is non-empty.\n                if from_obj:\n                    final_field.remote_field.set_cached_value(from_obj, obj)\n",
      "\ndef local_setter(final_field, obj, from_obj):\n    # Set a reverse fk object when relation is non-empty.\n    if from_obj:\n        final_field.remote_field.set_cached_value(from_obj, obj)\n",
      "\n            def local_setter(final_field, obj, from_obj):\n                # Set a reverse fk object when relation is non-empty.\n                if from_obj:\n                    final_field.remote_field.set_cached_value(from_obj, obj)\n",
      "\n            def local_setter(final_field, obj, from_obj):\n                # Set a reverse fk object when relation is non-empty.\n                if from_obj:\n                    final_field.remote_field.set_cached_value(from_obj, obj)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7c433b3f06..e763f828c5 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1269,18 +1269,26 @@ class SQLCompiler:\n                 )\n                 get_related_klass_infos(klass_info, next_klass_infos)\n \n+\n             def local_setter(final_field, obj, from_obj):\n                 # Set a reverse fk object when relation is non-empty.\n                 if from_obj:\n                     final_field.remote_field.set_cached_value(from_obj, obj)\n \n+\n             def remote_setter(name, obj, from_obj):\n-                setattr(from_obj, name, obj)\n+                # For FilteredRelations, use proper field caching mechanism\n+                # instead of generic setattr to avoid wrong object caching\n+                if hasattr(from_obj, '_state') and hasattr(from_obj._state, 'fields_cache'):\n+                    from_obj._state.fields_cache[name] = obj\n+                else:\n+                    setattr(from_obj, name, obj)\n \n             for name in list(requested):\n                 # Filtered relations work only on the topmost level.\n                 if cur_depth > 1:\n                     break\n+\n                 if name in self.query._filtered_relations:\n                     fields_found.add(name)\n                     final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n@@ -1291,6 +1299,7 @@ class SQLCompiler:\n                     from_parent = (\n                         issubclass(model, opts.model) and model is not opts.model\n                     )\n+\n                     klass_info = {\n                         \"model\": model,\n                         \"field\": final_field,\n@@ -1313,6 +1322,7 @@ class SQLCompiler:\n                         select.append((col, None))\n                     klass_info[\"select_fields\"] = select_fields\n                     next_requested = requested.get(name, {})\n+\n                     next_klass_infos = self.get_related_selections(\n                         select,\n                         field_select_mask,\n",
    "variant_0": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7c433b3f06..36ed5a1d61 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1269,13 +1269,25 @@ class SQLCompiler:\n                 )\n                 get_related_klass_infos(klass_info, next_klass_infos)\n \n+\n             def local_setter(final_field, obj, from_obj):\n                 # Set a reverse fk object when relation is non-empty.\n                 if from_obj:\n                     final_field.remote_field.set_cached_value(from_obj, obj)\n \n+\n             def remote_setter(name, obj, from_obj):\n-                setattr(from_obj, name, obj)\n+                # For FilteredRelations, we need to properly set the cached value\n+                # using the field's caching mechanism instead of generic setattr\n+                if hasattr(from_obj, '_state') and hasattr(from_obj._state, 'fields_cache'):\n+                    from_obj._state.fields_cache[name] = obj\n+                else:\n+                    setattr(from_obj, name, obj)\n+\n+            for name in list(requested):\n+                # Filtered relations work only on the topmost level.\n+                if cur_depth > 1:\n+                    break\n \n             for name in list(requested):\n                 # Filtered relations work only on the topmost level.\n@@ -1283,20 +1295,25 @@ class SQLCompiler:\n                     break\n                 if name in self.query._filtered_relations:\n                     fields_found.add(name)\n+                    filtered_relation = self.query._filtered_relations[name]\n                     final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n                         [name], opts, root_alias\n                     )\n+                    # Store the FilteredRelation for proper caching context\n+                    if hasattr(final_field, '_filtered_relation'):\n+                        final_field._filtered_relation = filtered_relation\n                     model = join_opts.model\n                     alias = joins[-1]\n                     from_parent = (\n                         issubclass(model, opts.model) and model is not opts.model\n                     )\n+\n                     klass_info = {\n                         \"model\": model,\n                         \"field\": final_field,\n                         \"reverse\": True,\n                         \"local_setter\": partial(local_setter, final_field),\n-                        \"remote_setter\": partial(remote_setter, name),\n+                        \"remote_setter\": partial(remote_setter, name, final_field),\n                         \"from_parent\": from_parent,\n                     }\n                     related_klass_infos.append(klass_info)\n@@ -1313,6 +1330,7 @@ class SQLCompiler:\n                         select.append((col, None))\n                     klass_info[\"select_fields\"] = select_fields\n                     next_requested = requested.get(name, {})\n+\n                     next_klass_infos = self.get_related_selections(\n                         select,\n                         field_select_mask,\n@@ -1321,6 +1339,11 @@ class SQLCompiler:\n                         cur_depth=cur_depth + 1,\n                         requested=next_requested,\n                         restricted=restricted,\n+                    )\n+                        root_alias=alias,\n+                        cur_depth=cur_depth + 1,\n+                        requested=next_requested,\n+                        restricted=restricted,\n                     )\n                     get_related_klass_infos(klass_info, next_klass_infos)\n             fields_not_found = set(requested).difference(fields_found)\n",
    "variant_1": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7c433b3f06..cece5ffa33 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1269,13 +1269,25 @@ class SQLCompiler:\n                 )\n                 get_related_klass_infos(klass_info, next_klass_infos)\n \n+\n             def local_setter(final_field, obj, from_obj):\n                 # Set a reverse fk object when relation is non-empty.\n                 if from_obj:\n                     final_field.remote_field.set_cached_value(from_obj, obj)\n \n+\n             def remote_setter(name, obj, from_obj):\n-                setattr(from_obj, name, obj)\n+                # For FilteredRelations, we need to properly set the cached value\n+                # using the field's caching mechanism instead of generic setattr\n+                if hasattr(from_obj, '_state') and hasattr(from_obj._state, 'fields_cache'):\n+                    from_obj._state.fields_cache[name] = obj\n+                else:\n+                    setattr(from_obj, name, obj)\n+\n+            for name in list(requested):\n+                # Filtered relations work only on the topmost level.\n+                if cur_depth > 1:\n+                    break\n \n             for name in list(requested):\n                 # Filtered relations work only on the topmost level.\n@@ -1283,20 +1295,25 @@ class SQLCompiler:\n                     break\n                 if name in self.query._filtered_relations:\n                     fields_found.add(name)\n+                    filtered_relation = self.query._filtered_relations[name]\n                     final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n                         [name], opts, root_alias\n                     )\n+                    # Store the FilteredRelation for proper field caching context\n+                    if hasattr(final_field, 'remote_field') and final_field.remote_field:\n+                        final_field.remote_field._filtered_relation = filtered_relation\n                     model = join_opts.model\n                     alias = joins[-1]\n                     from_parent = (\n                         issubclass(model, opts.model) and model is not opts.model\n                     )\n+\n                     klass_info = {\n                         \"model\": model,\n                         \"field\": final_field,\n                         \"reverse\": True,\n                         \"local_setter\": partial(local_setter, final_field),\n-                        \"remote_setter\": partial(remote_setter, name),\n+                        \"remote_setter\": partial(remote_setter, name) if final_field is None else final_field.set_cached_value,\n                         \"from_parent\": from_parent,\n                     }\n                     related_klass_infos.append(klass_info)\n@@ -1313,6 +1330,7 @@ class SQLCompiler:\n                         select.append((col, None))\n                     klass_info[\"select_fields\"] = select_fields\n                     next_requested = requested.get(name, {})\n+\n                     next_klass_infos = self.get_related_selections(\n                         select,\n                         field_select_mask,\n@@ -1321,6 +1339,11 @@ class SQLCompiler:\n                         cur_depth=cur_depth + 1,\n                         requested=next_requested,\n                         restricted=restricted,\n+                    )\n+                        root_alias=alias,\n+                        cur_depth=cur_depth + 1,\n+                        requested=next_requested,\n+                        restricted=restricted,\n                     )\n                     get_related_klass_infos(klass_info, next_klass_infos)\n             fields_not_found = set(requested).difference(fields_found)\n",
    "variant_2": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7c433b3f06..96ebf71a40 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1269,13 +1269,25 @@ class SQLCompiler:\n                 )\n                 get_related_klass_infos(klass_info, next_klass_infos)\n \n+\n             def local_setter(final_field, obj, from_obj):\n                 # Set a reverse fk object when relation is non-empty.\n                 if from_obj:\n                     final_field.remote_field.set_cached_value(from_obj, obj)\n \n+\n             def remote_setter(name, obj, from_obj):\n-                setattr(from_obj, name, obj)\n+                # For FilteredRelations, we need to properly set the cached value\n+                # using the field's caching mechanism instead of generic setattr\n+                if hasattr(from_obj, '_state') and hasattr(from_obj._state, 'fields_cache'):\n+                    from_obj._state.fields_cache[name] = obj\n+                else:\n+                    setattr(from_obj, name, obj)\n+\n+            for name in list(requested):\n+                # Filtered relations work only on the topmost level.\n+                if cur_depth > 1:\n+                    break\n \n             for name in list(requested):\n                 # Filtered relations work only on the topmost level.\n@@ -1283,20 +1295,25 @@ class SQLCompiler:\n                     break\n                 if name in self.query._filtered_relations:\n                     fields_found.add(name)\n+                    filtered_relation = self.query._filtered_relations[name]\n                     final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n                         [name], opts, root_alias\n                     )\n+                    # Store the FilteredRelation for proper field caching context\n+                    if hasattr(final_field, '_filtered_relation_info'):\n+                        final_field._filtered_relation_info = filtered_relation\n                     model = join_opts.model\n                     alias = joins[-1]\n                     from_parent = (\n                         issubclass(model, opts.model) and model is not opts.model\n                     )\n+\n                     klass_info = {\n                         \"model\": model,\n                         \"field\": final_field,\n                         \"reverse\": True,\n                         \"local_setter\": partial(local_setter, final_field),\n-                        \"remote_setter\": partial(remote_setter, name),\n+                        \"remote_setter\": partial(remote_setter, name, final_field),\n                         \"from_parent\": from_parent,\n                     }\n                     related_klass_infos.append(klass_info)\n@@ -1313,10 +1330,16 @@ class SQLCompiler:\n                         select.append((col, None))\n                     klass_info[\"select_fields\"] = select_fields\n                     next_requested = requested.get(name, {})\n-                    next_klass_infos = self.get_related_selections(\n-                        select,\n-                        field_select_mask,\n-                        opts=model._meta,\n+\n+                next_klass_infos = self.get_related_selections(\n+                    select,\n+                    field_select_mask,\n+                    opts=model._meta,\n+                    root_alias=alias,\n+                    cur_depth=cur_depth + 1,\n+                    requested=next_requested,\n+                    restricted=restricted,\n+                )\n                         root_alias=alias,\n                         cur_depth=cur_depth + 1,\n                         requested=next_requested,\n",
    "variant_3": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7c433b3f06..36ed5a1d61 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1269,13 +1269,25 @@ class SQLCompiler:\n                 )\n                 get_related_klass_infos(klass_info, next_klass_infos)\n \n+\n             def local_setter(final_field, obj, from_obj):\n                 # Set a reverse fk object when relation is non-empty.\n                 if from_obj:\n                     final_field.remote_field.set_cached_value(from_obj, obj)\n \n+\n             def remote_setter(name, obj, from_obj):\n-                setattr(from_obj, name, obj)\n+                # For FilteredRelations, we need to properly set the cached value\n+                # using the field's caching mechanism instead of generic setattr\n+                if hasattr(from_obj, '_state') and hasattr(from_obj._state, 'fields_cache'):\n+                    from_obj._state.fields_cache[name] = obj\n+                else:\n+                    setattr(from_obj, name, obj)\n+\n+            for name in list(requested):\n+                # Filtered relations work only on the topmost level.\n+                if cur_depth > 1:\n+                    break\n \n             for name in list(requested):\n                 # Filtered relations work only on the topmost level.\n@@ -1283,20 +1295,25 @@ class SQLCompiler:\n                     break\n                 if name in self.query._filtered_relations:\n                     fields_found.add(name)\n+                    filtered_relation = self.query._filtered_relations[name]\n                     final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n                         [name], opts, root_alias\n                     )\n+                    # Store the FilteredRelation for proper caching context\n+                    if hasattr(final_field, '_filtered_relation'):\n+                        final_field._filtered_relation = filtered_relation\n                     model = join_opts.model\n                     alias = joins[-1]\n                     from_parent = (\n                         issubclass(model, opts.model) and model is not opts.model\n                     )\n+\n                     klass_info = {\n                         \"model\": model,\n                         \"field\": final_field,\n                         \"reverse\": True,\n                         \"local_setter\": partial(local_setter, final_field),\n-                        \"remote_setter\": partial(remote_setter, name),\n+                        \"remote_setter\": partial(remote_setter, name, final_field),\n                         \"from_parent\": from_parent,\n                     }\n                     related_klass_infos.append(klass_info)\n@@ -1313,6 +1330,7 @@ class SQLCompiler:\n                         select.append((col, None))\n                     klass_info[\"select_fields\"] = select_fields\n                     next_requested = requested.get(name, {})\n+\n                     next_klass_infos = self.get_related_selections(\n                         select,\n                         field_select_mask,\n@@ -1321,6 +1339,11 @@ class SQLCompiler:\n                         cur_depth=cur_depth + 1,\n                         requested=next_requested,\n                         restricted=restricted,\n+                    )\n+                        root_alias=alias,\n+                        cur_depth=cur_depth + 1,\n+                        requested=next_requested,\n+                        restricted=restricted,\n                     )\n                     get_related_klass_infos(klass_info, next_klass_infos)\n             fields_not_found = set(requested).difference(fields_found)\n",
    "variant_4": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7c433b3f06..02f847363d 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1269,13 +1269,25 @@ class SQLCompiler:\n                 )\n                 get_related_klass_infos(klass_info, next_klass_infos)\n \n+\n             def local_setter(final_field, obj, from_obj):\n                 # Set a reverse fk object when relation is non-empty.\n                 if from_obj:\n                     final_field.remote_field.set_cached_value(from_obj, obj)\n \n-            def remote_setter(name, obj, from_obj):\n-                setattr(from_obj, name, obj)\n+\n+def remote_setter(name, obj, from_obj):\n+    # For FilteredRelations, we need to properly set the cached value\n+    # using the field's caching mechanism instead of generic setattr\n+    if hasattr(from_obj, '_state') and hasattr(from_obj._state, 'fields_cache'):\n+        from_obj._state.fields_cache[name] = obj\n+    else:\n+        setattr(from_obj, name, obj)\n+\n+            for name in list(requested):\n+                # Filtered relations work only on the topmost level.\n+                if cur_depth > 1:\n+                    break\n \n             for name in list(requested):\n                 # Filtered relations work only on the topmost level.\n@@ -1283,20 +1295,25 @@ class SQLCompiler:\n                     break\n                 if name in self.query._filtered_relations:\n                     fields_found.add(name)\n+                    filtered_relation = self.query._filtered_relations[name]\n                     final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n                         [name], opts, root_alias\n                     )\n+                    # Store the FilteredRelation for proper caching context\n+                    if hasattr(final_field, 'remote_field') and final_field.remote_field:\n+                        final_field.remote_field._filtered_relation = filtered_relation\n                     model = join_opts.model\n                     alias = joins[-1]\n                     from_parent = (\n                         issubclass(model, opts.model) and model is not opts.model\n                     )\n+\n                     klass_info = {\n                         \"model\": model,\n                         \"field\": final_field,\n                         \"reverse\": True,\n                         \"local_setter\": partial(local_setter, final_field),\n-                        \"remote_setter\": partial(remote_setter, name),\n+                        \"remote_setter\": partial(remote_setter, name, final_field),\n                         \"from_parent\": from_parent,\n                     }\n                     related_klass_infos.append(klass_info)\n@@ -1313,6 +1330,7 @@ class SQLCompiler:\n                         select.append((col, None))\n                     klass_info[\"select_fields\"] = select_fields\n                     next_requested = requested.get(name, {})\n+\n                     next_klass_infos = self.get_related_selections(\n                         select,\n                         field_select_mask,\n@@ -1321,6 +1339,11 @@ class SQLCompiler:\n                         cur_depth=cur_depth + 1,\n                         requested=next_requested,\n                         restricted=restricted,\n+                    )\n+                        root_alias=alias,\n+                        cur_depth=cur_depth + 1,\n+                        requested=next_requested,\n+                        restricted=restricted,\n                     )\n                     get_related_klass_infos(klass_info, next_klass_infos)\n             fields_not_found = set(requested).difference(fields_found)\n",
    "variant_5": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7c433b3f06..b0f0937192 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1269,13 +1269,25 @@ class SQLCompiler:\n                 )\n                 get_related_klass_infos(klass_info, next_klass_infos)\n \n+\n             def local_setter(final_field, obj, from_obj):\n                 # Set a reverse fk object when relation is non-empty.\n                 if from_obj:\n                     final_field.remote_field.set_cached_value(from_obj, obj)\n \n+\n             def remote_setter(name, obj, from_obj):\n-                setattr(from_obj, name, obj)\n+                # For FilteredRelations, we need to properly set the cached value\n+                # using the field's caching mechanism instead of generic setattr\n+                if hasattr(from_obj, '_state') and hasattr(from_obj._state, 'fields_cache'):\n+                    from_obj._state.fields_cache[name] = obj\n+                else:\n+                    setattr(from_obj, name, obj)\n+\n+            for name in list(requested):\n+                # Filtered relations work only on the topmost level.\n+                if cur_depth > 1:\n+                    break\n \n             for name in list(requested):\n                 # Filtered relations work only on the topmost level.\n@@ -1283,20 +1295,25 @@ class SQLCompiler:\n                     break\n                 if name in self.query._filtered_relations:\n                     fields_found.add(name)\n+                    filtered_relation = self.query._filtered_relations[name]\n                     final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n                         [name], opts, root_alias\n                     )\n+                    # Store the FilteredRelation for proper field caching context\n+                    if hasattr(final_field, 'remote_field') and final_field.remote_field:\n+                        final_field.remote_field._filtered_relation = filtered_relation\n                     model = join_opts.model\n                     alias = joins[-1]\n                     from_parent = (\n                         issubclass(model, opts.model) and model is not opts.model\n                     )\n+\n                     klass_info = {\n                         \"model\": model,\n                         \"field\": final_field,\n                         \"reverse\": True,\n                         \"local_setter\": partial(local_setter, final_field),\n-                        \"remote_setter\": partial(remote_setter, name),\n+                        \"remote_setter\": partial(remote_setter, name, final_field),\n                         \"from_parent\": from_parent,\n                     }\n                     related_klass_infos.append(klass_info)\n@@ -1313,6 +1330,7 @@ class SQLCompiler:\n                         select.append((col, None))\n                     klass_info[\"select_fields\"] = select_fields\n                     next_requested = requested.get(name, {})\n+\n                     next_klass_infos = self.get_related_selections(\n                         select,\n                         field_select_mask,\n@@ -1321,6 +1339,11 @@ class SQLCompiler:\n                         cur_depth=cur_depth + 1,\n                         requested=next_requested,\n                         restricted=restricted,\n+                    )\n+                        root_alias=alias,\n+                        cur_depth=cur_depth + 1,\n+                        requested=next_requested,\n+                        restricted=restricted,\n                     )\n                     get_related_klass_infos(klass_info, next_klass_infos)\n             fields_not_found = set(requested).difference(fields_found)\n",
    "variant_6": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7c433b3f06..fb77f770d6 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1269,13 +1269,25 @@ class SQLCompiler:\n                 )\n                 get_related_klass_infos(klass_info, next_klass_infos)\n \n-            def local_setter(final_field, obj, from_obj):\n-                # Set a reverse fk object when relation is non-empty.\n-                if from_obj:\n-                    final_field.remote_field.set_cached_value(from_obj, obj)\n+\n+def local_setter(final_field, obj, from_obj):\n+    # Set a reverse fk object when relation is non-empty.\n+    if from_obj:\n+        final_field.remote_field.set_cached_value(from_obj, obj)\n+\n \n             def remote_setter(name, obj, from_obj):\n-                setattr(from_obj, name, obj)\n+                # For FilteredRelations, we need to properly set the cached value\n+                # using the field's caching mechanism instead of generic setattr\n+                if hasattr(from_obj, '_state') and hasattr(from_obj._state, 'fields_cache'):\n+                    from_obj._state.fields_cache[name] = obj\n+                else:\n+                    setattr(from_obj, name, obj)\n+\n+            for name in list(requested):\n+                # Filtered relations work only on the topmost level.\n+                if cur_depth > 1:\n+                    break\n \n             for name in list(requested):\n                 # Filtered relations work only on the topmost level.\n@@ -1283,6 +1295,7 @@ class SQLCompiler:\n                     break\n                 if name in self.query._filtered_relations:\n                     fields_found.add(name)\n+                    filtered_relation = self.query._filtered_relations[name]\n                     final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n                         [name], opts, root_alias\n                     )\n@@ -1291,12 +1304,13 @@ class SQLCompiler:\n                     from_parent = (\n                         issubclass(model, opts.model) and model is not opts.model\n                     )\n+\n                     klass_info = {\n                         \"model\": model,\n                         \"field\": final_field,\n                         \"reverse\": True,\n                         \"local_setter\": partial(local_setter, final_field),\n-                        \"remote_setter\": partial(remote_setter, name),\n+                        \"remote_setter\": partial(remote_setter, name) if final_field is None else final_field.set_cached_value,\n                         \"from_parent\": from_parent,\n                     }\n                     related_klass_infos.append(klass_info)\n@@ -1313,6 +1327,7 @@ class SQLCompiler:\n                         select.append((col, None))\n                     klass_info[\"select_fields\"] = select_fields\n                     next_requested = requested.get(name, {})\n+\n                     next_klass_infos = self.get_related_selections(\n                         select,\n                         field_select_mask,\n@@ -1321,6 +1336,11 @@ class SQLCompiler:\n                         cur_depth=cur_depth + 1,\n                         requested=next_requested,\n                         restricted=restricted,\n+                    )\n+                        root_alias=alias,\n+                        cur_depth=cur_depth + 1,\n+                        requested=next_requested,\n+                        restricted=restricted,\n                     )\n                     get_related_klass_infos(klass_info, next_klass_infos)\n             fields_not_found = set(requested).difference(fields_found)\n",
    "variant_7": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7c433b3f06..a75c881899 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1269,13 +1269,25 @@ class SQLCompiler:\n                 )\n                 get_related_klass_infos(klass_info, next_klass_infos)\n \n+\n             def local_setter(final_field, obj, from_obj):\n                 # Set a reverse fk object when relation is non-empty.\n                 if from_obj:\n                     final_field.remote_field.set_cached_value(from_obj, obj)\n \n-            def remote_setter(name, obj, from_obj):\n-                setattr(from_obj, name, obj)\n+\n+def remote_setter(name, obj, from_obj):\n+    # For FilteredRelations, we need to properly set the cached value\n+    # using the field's caching mechanism instead of generic setattr\n+    if hasattr(from_obj, '_state') and hasattr(from_obj._state, 'fields_cache'):\n+        from_obj._state.fields_cache[name] = obj\n+    else:\n+        setattr(from_obj, name, obj)\n+\n+            for name in list(requested):\n+                # Filtered relations work only on the topmost level.\n+                if cur_depth > 1:\n+                    break\n \n             for name in list(requested):\n                 # Filtered relations work only on the topmost level.\n@@ -1283,20 +1295,25 @@ class SQLCompiler:\n                     break\n                 if name in self.query._filtered_relations:\n                     fields_found.add(name)\n+                    filtered_relation = self.query._filtered_relations[name]\n                     final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n                         [name], opts, root_alias\n                     )\n+                    # Store the FilteredRelation for proper field caching context\n+                    if hasattr(final_field, 'remote_field') and final_field.remote_field:\n+                        final_field._filtered_relation = filtered_relation\n                     model = join_opts.model\n                     alias = joins[-1]\n                     from_parent = (\n                         issubclass(model, opts.model) and model is not opts.model\n                     )\n+\n                     klass_info = {\n                         \"model\": model,\n                         \"field\": final_field,\n                         \"reverse\": True,\n                         \"local_setter\": partial(local_setter, final_field),\n-                        \"remote_setter\": partial(remote_setter, name),\n+                        \"remote_setter\": partial(remote_setter, name, final_field),\n                         \"from_parent\": from_parent,\n                     }\n                     related_klass_infos.append(klass_info)\n@@ -1313,6 +1330,7 @@ class SQLCompiler:\n                         select.append((col, None))\n                     klass_info[\"select_fields\"] = select_fields\n                     next_requested = requested.get(name, {})\n+\n                     next_klass_infos = self.get_related_selections(\n                         select,\n                         field_select_mask,\n@@ -1321,6 +1339,11 @@ class SQLCompiler:\n                         cur_depth=cur_depth + 1,\n                         requested=next_requested,\n                         restricted=restricted,\n+                    )\n+                        root_alias=alias,\n+                        cur_depth=cur_depth + 1,\n+                        requested=next_requested,\n+                        restricted=restricted,\n                     )\n                     get_related_klass_infos(klass_info, next_klass_infos)\n             fields_not_found = set(requested).difference(fields_found)\n",
    "variant_8": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7c433b3f06..f4d7118d89 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1269,13 +1269,25 @@ class SQLCompiler:\n                 )\n                 get_related_klass_infos(klass_info, next_klass_infos)\n \n+\n             def local_setter(final_field, obj, from_obj):\n                 # Set a reverse fk object when relation is non-empty.\n                 if from_obj:\n                     final_field.remote_field.set_cached_value(from_obj, obj)\n \n-            def remote_setter(name, obj, from_obj):\n-                setattr(from_obj, name, obj)\n+\n+def remote_setter(name, obj, from_obj):\n+    # For FilteredRelations, we need to properly set the cached value\n+    # using the field's caching mechanism instead of generic setattr\n+    if hasattr(from_obj, '_state') and hasattr(from_obj._state, 'fields_cache'):\n+        from_obj._state.fields_cache[name] = obj\n+    else:\n+        setattr(from_obj, name, obj)\n+\n+            for name in list(requested):\n+                # Filtered relations work only on the topmost level.\n+                if cur_depth > 1:\n+                    break\n \n             for name in list(requested):\n                 # Filtered relations work only on the topmost level.\n@@ -1283,20 +1295,25 @@ class SQLCompiler:\n                     break\n                 if name in self.query._filtered_relations:\n                     fields_found.add(name)\n+                    filtered_relation = self.query._filtered_relations[name]\n                     final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n                         [name], opts, root_alias\n                     )\n+                    # Store the FilteredRelation for proper field relationship handling\n+                    if hasattr(final_field, 'remote_field') and final_field.remote_field:\n+                        final_field.remote_field._filtered_relation = filtered_relation\n                     model = join_opts.model\n                     alias = joins[-1]\n                     from_parent = (\n                         issubclass(model, opts.model) and model is not opts.model\n                     )\n+\n                     klass_info = {\n                         \"model\": model,\n                         \"field\": final_field,\n                         \"reverse\": True,\n                         \"local_setter\": partial(local_setter, final_field),\n-                        \"remote_setter\": partial(remote_setter, name),\n+                        \"remote_setter\": partial(remote_setter, name, final_field),\n                         \"from_parent\": from_parent,\n                     }\n                     related_klass_infos.append(klass_info)\n@@ -1313,6 +1330,7 @@ class SQLCompiler:\n                         select.append((col, None))\n                     klass_info[\"select_fields\"] = select_fields\n                     next_requested = requested.get(name, {})\n+\n                     next_klass_infos = self.get_related_selections(\n                         select,\n                         field_select_mask,\n@@ -1321,6 +1339,11 @@ class SQLCompiler:\n                         cur_depth=cur_depth + 1,\n                         requested=next_requested,\n                         restricted=restricted,\n+                    )\n+                        root_alias=alias,\n+                        cur_depth=cur_depth + 1,\n+                        requested=next_requested,\n+                        restricted=restricted,\n                     )\n                     get_related_klass_infos(klass_info, next_klass_infos)\n             fields_not_found = set(requested).difference(fields_found)\n"
  }
}