{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/django/django/views/debug.py lines 88-97)": "\n    def cleanse_setting(self, key, value):\n        \"\"\"\n        Cleanse an individual setting key/value of sensitive content. If the\n        value is a dictionary, recursively cleanse the keys in that dictionary.\n        For other iterables (lists, tuples, sets), recursively cleanse their contents.\n        \"\"\"\n        try:\n            if self.hidden_settings.search(key):\n                cleansed = self.cleansed_substitute\n            elif isinstance(value, dict):\n                cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n            elif isinstance(value, (list, tuple)):\n                # Handle lists and tuples, preserving original type\n                cleansed_items = [self.cleanse_setting('', item) for item in value]\n                cleansed = type(value)(cleansed_items)\n            elif isinstance(value, set):\n                # Handle sets\n                cleansed = {self.cleanse_setting('', item) for item in value}\n            else:\n                cleansed = value\n        except TypeError:\n            # If the key isn't regex-able, just return as-is.\n            cleansed = value\n",
    "Location 2 (/root/hy/projects_3/django/django/views/debug.py lines 84-87)": "\n    def cleanse_setting(self, key, value):\n        \"\"\"\n        Cleanse an individual setting key/value of sensitive content. If the\n        value is a dictionary, recursively cleanse the keys in that dictionary.\n        For other iterables (lists, tuples, sets), recursively cleanse their contents.\n        \"\"\"\n        try:\n            if self.hidden_settings.search(key):\n                cleansed = self.cleansed_substitute\n            elif isinstance(value, dict):\n                cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n            elif isinstance(value, (list, tuple)):\n                # Handle lists and tuples, preserving original type\n                cleansed_items = [self.cleanse_setting('', item) for item in value]\n                cleansed = type(value)(cleansed_items)\n            elif isinstance(value, set):\n                # Handle sets\n                cleansed = {self.cleanse_setting('', item) for item in value}\n            else:\n                cleansed = value\n        except TypeError:\n            # If the key isn't regex-able, just return as-is.\n            cleansed = value\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/django/django/views/debug.py lines 88-97)": [
      "\ndef cleanse_setting(self, key, value):\n    \"\"\"\n    Cleanse an individual setting key/value of sensitive content. If the\n    value is a dictionary, recursively cleanse the keys in that dictionary.\n    For other iterables (lists, tuples, sets), recursively cleanse their contents.\n    \"\"\"\n    try:\n        if self.hidden_settings.search(key):\n            cleansed = self.cleansed_substitute\n        elif isinstance(value, dict):\n            cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n        elif isinstance(value, (list, tuple)):\n            # Handle lists and tuples, preserving original type\n            cleansed_items = [self.cleanse_setting('', item) for item in value]\n            cleansed = type(value)(cleansed_items)\n        elif isinstance(value, set):\n            # Handle sets\n            cleansed = {self.cleanse_setting('', item) for item in value}\n        else:\n            cleansed = value\n    except TypeError:\n        # If the key isn't regex-able, just return as-is.\n        cleansed = value\n",
      "\ndef cleanse_setting(self, key, value):\n    \"\"\"\n    Cleanse an individual setting key/value of sensitive content. If the\n    value is a dictionary, recursively cleanse the keys in that dictionary.\n    For other iterables (lists, tuples, sets), recursively cleanse their contents.\n    \"\"\"\n    try:\n        if self.hidden_settings.search(key):\n            cleansed = self.cleansed_substitute\n        elif isinstance(value, dict):\n            cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n        elif isinstance(value, (list, tuple)):\n            # Handle lists and tuples, preserving original type\n            cleansed_items = [self.cleanse_setting('', item) for item in value]\n            cleansed = type(value)(cleansed_items)\n        elif isinstance(value, set):\n            # Handle sets\n            cleansed = {self.cleanse_setting('', item) for item in value}\n        else:\n            cleansed = value\n    except TypeError:\n        # If the key isn't regex-able, just return as-is.\n        cleansed = value\n",
      "\ndef cleanse_setting(self, key, value):\n    \"\"\"\n    Cleanse an individual setting key/value of sensitive content. If the\n    value is a dictionary, recursively cleanse the keys in that dictionary.\n    For other iterables (lists, tuples, sets), recursively cleanse their contents.\n    \"\"\"\n    try:\n        if self.hidden_settings.search(key):\n            cleansed = self.cleansed_substitute\n        elif isinstance(value, dict):\n            cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n        elif isinstance(value, (list, tuple)):\n            # Handle lists and tuples, preserving original type\n            cleansed_items = [self.cleanse_setting('', item) for item in value]\n            cleansed = type(value)(cleansed_items)\n        elif isinstance(value, set):\n            # Handle sets\n            cleansed = {self.cleanse_setting('', item) for item in value}\n        else:\n            cleansed = value\n    except TypeError:\n        # If the key isn't regex-able, just return as-is.\n        cleansed = value\n",
      "\n    def cleanse_setting(self, key, value):\n        \"\"\"\n        Cleanse an individual setting key/value of sensitive content. If the\n        value is a dictionary, recursively cleanse the keys in that dictionary.\n        For other iterables (lists, tuples, sets), recursively cleanse their contents.\n        \"\"\"\n        try:\n            if self.hidden_settings.search(key):\n                cleansed = self.cleansed_substitute\n            elif isinstance(value, dict):\n                cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n            elif isinstance(value, (list, tuple)):\n                # Handle lists and tuples, preserving original type\n                cleansed_items = [self.cleanse_setting('', item) for item in value]\n                cleansed = type(value)(cleansed_items)\n            elif isinstance(value, set):\n                # Handle sets\n                cleansed = {self.cleanse_setting('', item) for item in value}\n            else:\n                cleansed = value\n        except TypeError:\n            # If the key isn't regex-able, just return as-is.\n            cleansed = value\n",
      "\n    def cleanse_setting(self, key, value):\n        \"\"\"\n        Cleanse an individual setting key/value of sensitive content. If the\n        value is a dictionary, recursively cleanse the keys in that dictionary.\n        For other iterables (lists, tuples, sets), recursively cleanse their contents.\n        \"\"\"\n        try:\n            if self.hidden_settings.search(key):\n                cleansed = self.cleansed_substitute\n            elif isinstance(value, dict):\n                cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n            elif isinstance(value, (list, tuple)):\n                # Handle lists and tuples, preserving original type\n                cleansed_items = [self.cleanse_setting('', item) for item in value]\n                cleansed = type(value)(cleansed_items)\n            elif isinstance(value, set):\n                # Handle sets\n                cleansed = {self.cleanse_setting('', item) for item in value}\n            else:\n                cleansed = value\n        except TypeError:\n            # If the key isn't regex-able, just return as-is.\n            cleansed = value\n",
      "\n    def cleanse_setting(self, key, value):\n        \"\"\"\n        Cleanse an individual setting key/value of sensitive content. If the\n        value is a dictionary, recursively cleanse the keys in that dictionary.\n        For other iterables (lists, tuples, sets), recursively cleanse their contents.\n        \"\"\"\n        try:\n            if self.hidden_settings.search(key):\n                cleansed = self.cleansed_substitute\n            elif isinstance(value, dict):\n                cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n            elif isinstance(value, (list, tuple)):\n                # Handle lists and tuples, preserving original type\n                cleansed_items = [self.cleanse_setting('', item) for item in value]\n                cleansed = type(value)(cleansed_items)\n            elif isinstance(value, set):\n                # Handle sets\n                cleansed = {self.cleanse_setting('', item) for item in value}\n            else:\n                cleansed = value\n        except TypeError:\n            # If the key isn't regex-able, just return as-is.\n            cleansed = value\n",
      "\n    def cleanse_setting(self, key, value):\n        \"\"\"\n        Cleanse an individual setting key/value of sensitive content. If the\n        value is a dictionary, recursively cleanse the keys in that dictionary.\n        For other iterables (lists, tuples, sets), recursively cleanse their contents.\n        \"\"\"\n        try:\n            if self.hidden_settings.search(key):\n                cleansed = self.cleansed_substitute\n            elif isinstance(value, dict):\n                cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n            elif isinstance(value, (list, tuple)):\n                # Handle lists and tuples, preserving original type\n                cleansed_items = [self.cleanse_setting('', item) for item in value]\n                cleansed = type(value)(cleansed_items)\n            elif isinstance(value, set):\n                # Handle sets\n                cleansed = {self.cleanse_setting('', item) for item in value}\n            else:\n                cleansed = value\n        except TypeError:\n            # If the key isn't regex-able, just return as-is.\n            cleansed = value\n",
      "\n    def cleanse_setting(self, key, value):\n        \"\"\"\n        Cleanse an individual setting key/value of sensitive content. If the\n        value is a dictionary, recursively cleanse the keys in that dictionary.\n        For other iterables (lists, tuples, sets), recursively cleanse their contents.\n        \"\"\"\n        try:\n            if self.hidden_settings.search(key):\n                cleansed = self.cleansed_substitute\n            elif isinstance(value, dict):\n                cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n            elif isinstance(value, (list, tuple)):\n                # Handle lists and tuples, preserving original type\n                cleansed_items = [self.cleanse_setting('', item) for item in value]\n                cleansed = type(value)(cleansed_items)\n            elif isinstance(value, set):\n                # Handle sets\n                cleansed = {self.cleanse_setting('', item) for item in value}\n            else:\n                cleansed = value\n        except TypeError:\n            # If the key isn't regex-able, just return as-is.\n            cleansed = value\n"
    ],
    "Location 2 (/root/hy/projects_3/django/django/views/debug.py lines 84-87)": [
      "\n    def cleanse_setting(self, key, value):\n        \"\"\"\n        Cleanse an individual setting key/value of sensitive content. If the\n        value is a dictionary, recursively cleanse the keys in that dictionary.\n        For other iterables (lists, tuples, sets), recursively cleanse their contents.\n        \"\"\"\n        try:\n            if self.hidden_settings.search(key):\n                cleansed = self.cleansed_substitute\n            elif isinstance(value, dict):\n                cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n            elif isinstance(value, (list, tuple)):\n                # Handle lists and tuples, preserving original type\n                cleansed_items = [self.cleanse_setting('', item) for item in value]\n                cleansed = type(value)(cleansed_items)\n            elif isinstance(value, set):\n                # Handle sets\n                cleansed = {self.cleanse_setting('', item) for item in value}\n            else:\n                cleansed = value\n        except TypeError:\n            # If the key isn't regex-able, just return as-is.\n            cleansed = value\n",
      "\n    def cleanse_setting(self, key, value):\n        \"\"\"\n        Cleanse an individual setting key/value of sensitive content. If the\n        value is a dictionary, recursively cleanse the keys in that dictionary.\n        For other iterables (lists, tuples, sets), recursively cleanse their contents.\n        \"\"\"\n        try:\n            if self.hidden_settings.search(key):\n                cleansed = self.cleansed_substitute\n            elif isinstance(value, dict):\n                cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n            elif isinstance(value, (list, tuple)):\n                # Handle lists and tuples, preserving original type\n                cleansed_items = [self.cleanse_setting('', item) for item in value]\n                cleansed = type(value)(cleansed_items)\n            elif isinstance(value, set):\n                # Handle sets\n                cleansed = {self.cleanse_setting('', item) for item in value}\n            else:\n                cleansed = value\n        except TypeError:\n            # If the key isn't regex-able, just return as-is.\n            cleansed = value\n",
      "\n    def cleanse_setting(self, key, value):\n        \"\"\"\n        Cleanse an individual setting key/value of sensitive content. If the\n        value is a dictionary, recursively cleanse the keys in that dictionary.\n        For other iterables (lists, tuples, sets), recursively cleanse their contents.\n        \"\"\"\n        try:\n            if self.hidden_settings.search(key):\n                cleansed = self.cleansed_substitute\n            elif isinstance(value, dict):\n                cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n            elif isinstance(value, (list, tuple)):\n                # Handle lists and tuples, preserving original type\n                cleansed_items = [self.cleanse_setting('', item) for item in value]\n                cleansed = type(value)(cleansed_items)\n            elif isinstance(value, set):\n                # Handle sets\n                cleansed = {self.cleanse_setting('', item) for item in value}\n            else:\n                cleansed = value\n        except TypeError:\n            # If the key isn't regex-able, just return as-is.\n            cleansed = value\n",
      "\n    def cleanse_setting(self, key, value):\n        \"\"\"\n        Cleanse an individual setting key/value of sensitive content. If the\n        value is a dictionary, recursively cleanse the keys in that dictionary.\n        For other iterables (lists, tuples, sets), recursively cleanse their contents.\n        \"\"\"\n        try:\n            if self.hidden_settings.search(key):\n                cleansed = self.cleansed_substitute\n            elif isinstance(value, dict):\n                cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n            elif isinstance(value, (list, tuple)):\n                # Handle lists and tuples, preserving original type\n                cleansed_items = [self.cleanse_setting('', item) for item in value]\n                cleansed = type(value)(cleansed_items)\n            elif isinstance(value, set):\n                # Handle sets\n                cleansed = {self.cleanse_setting('', item) for item in value}\n            else:\n                cleansed = value\n        except TypeError:\n            # If the key isn't regex-able, just return as-is.\n            cleansed = value\n",
      "\n    def cleanse_setting(self, key, value):\n        \"\"\"\n        Cleanse an individual setting key/value of sensitive content. If the\n        value is a dictionary, recursively cleanse the keys in that dictionary.\n        For other iterables (lists, tuples, sets), recursively cleanse their contents.\n        \"\"\"\n        try:\n            if self.hidden_settings.search(key):\n                cleansed = self.cleansed_substitute\n            elif isinstance(value, dict):\n                cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n            elif isinstance(value, (list, tuple)):\n                # Handle lists and tuples, preserving original type\n                cleansed_items = [self.cleanse_setting('', item) for item in value]\n                cleansed = type(value)(cleansed_items)\n            elif isinstance(value, set):\n                # Handle sets\n                cleansed = {self.cleanse_setting('', item) for item in value}\n            else:\n                cleansed = value\n        except TypeError:\n            # If the key isn't regex-able, just return as-is.\n            cleansed = value\n",
      "\n    def cleanse_setting(self, key, value):\n        \"\"\"\n        Cleanse an individual setting key/value of sensitive content. If the\n        value is a dictionary, recursively cleanse the keys in that dictionary.\n        For other iterables (lists, tuples, sets), recursively cleanse their contents.\n        \"\"\"\n        try:\n            if self.hidden_settings.search(key):\n                cleansed = self.cleansed_substitute\n            elif isinstance(value, dict):\n                cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n            elif isinstance(value, (list, tuple)):\n                # Handle lists and tuples, preserving original type\n                cleansed_items = [self.cleanse_setting('', item) for item in value]\n                cleansed = type(value)(cleansed_items)\n            elif isinstance(value, set):\n                # Handle sets\n                cleansed = {self.cleanse_setting('', item) for item in value}\n            else:\n                cleansed = value\n        except TypeError:\n            # If the key isn't regex-able, just return as-is.\n            cleansed = value\n",
      "\n    def cleanse_setting(self, key, value):\n        \"\"\"\n        Cleanse an individual setting key/value of sensitive content. If the\n        value is a dictionary, recursively cleanse the keys in that dictionary.\n        For other iterables (lists, tuples, sets), recursively cleanse their contents.\n        \"\"\"\n        try:\n            if self.hidden_settings.search(key):\n                cleansed = self.cleansed_substitute\n            elif isinstance(value, dict):\n                cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n            elif isinstance(value, (list, tuple)):\n                # Handle lists and tuples, preserving original type\n                cleansed_items = [self.cleanse_setting('', item) for item in value]\n                cleansed = type(value)(cleansed_items)\n            elif isinstance(value, set):\n                # Handle sets\n                cleansed = {self.cleanse_setting('', item) for item in value}\n            else:\n                cleansed = value\n        except TypeError:\n            # If the key isn't regex-able, just return as-is.\n            cleansed = value\n        return cleansed\n",
      "\n    def cleanse_setting(self, key, value):\n        \"\"\"\n        Cleanse an individual setting key/value of sensitive content. If the\n        value is a dictionary, recursively cleanse the keys in that dictionary.\n        For other iterables (lists, tuples, sets), recursively cleanse their contents.\n        \"\"\"\n        try:\n            if self.hidden_settings.search(key):\n                cleansed = self.cleansed_substitute\n            elif isinstance(value, dict):\n                cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n            elif isinstance(value, (list, tuple)):\n                # Handle lists and tuples, preserving original type\n                cleansed_items = [self.cleanse_setting('', item) for item in value]\n                cleansed = type(value)(cleansed_items)\n            elif isinstance(value, set):\n                # Handle sets\n                cleansed = {self.cleanse_setting('', item) for item in value}\n            else:\n                cleansed = value\n        except TypeError:\n            # If the key isn't regex-able, just return as-is.\n            cleansed = value\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/views/debug.py b/django/views/debug.py\nindex e6b7d4d821..b3a1482d98 100644\n--- a/django/views/debug.py\n+++ b/django/views/debug.py\n@@ -81,15 +81,25 @@ class SafeExceptionReporterFilter:\n     hidden_settings = _lazy_re_compile('API|TOKEN|KEY|SECRET|PASS|SIGNATURE', flags=re.I)\n \n     def cleanse_setting(self, key, value):\n+\n         \"\"\"\n         Cleanse an individual setting key/value of sensitive content. If the\n         value is a dictionary, recursively cleanse the keys in that dictionary.\n+        For other iterables (lists, tuples, sets), recursively cleanse their contents.\n         \"\"\"\n+\n         try:\n             if self.hidden_settings.search(key):\n                 cleansed = self.cleansed_substitute\n             elif isinstance(value, dict):\n                 cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n+            elif isinstance(value, (list, tuple)):\n+                # Handle lists and tuples, preserving original type\n+                cleansed_items = [self.cleanse_setting('', item) for item in value]\n+                cleansed = type(value)(cleansed_items)\n+            elif isinstance(value, set):\n+                # Handle sets\n+                cleansed = {self.cleanse_setting('', item) for item in value}\n             else:\n                 cleansed = value\n         except TypeError:\n",
    "variant_0": "diff --git a/django/views/debug.py b/django/views/debug.py\nindex e6b7d4d821..0b44819ffa 100644\n--- a/django/views/debug.py\n+++ b/django/views/debug.py\n@@ -80,16 +80,50 @@ class SafeExceptionReporterFilter:\n     cleansed_substitute = '********************'\n     hidden_settings = _lazy_re_compile('API|TOKEN|KEY|SECRET|PASS|SIGNATURE', flags=re.I)\n \n+    def cleanse_setting(self, key, value):\n+\n+    def cleanse_setting(self, key, value):\n+        \"\"\"\n+        Cleanse an individual setting key/value of sensitive content. If the\n+        value is a dictionary, recursively cleanse the keys in that dictionary.\n+        For other iterables (lists, tuples, sets), recursively cleanse their contents.\n+        \"\"\"\n+        try:\n+            if self.hidden_settings.search(key):\n+                cleansed = self.cleansed_substitute\n+            elif isinstance(value, dict):\n+                cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n+            elif isinstance(value, (list, tuple)):\n+                # Handle lists and tuples, preserving original type\n+                cleansed_items = [self.cleanse_setting('', item) for item in value]\n+                cleansed = type(value)(cleansed_items)\n+            elif isinstance(value, set):\n+                # Handle sets\n+                cleansed = {self.cleanse_setting('', item) for item in value}\n+            else:\n+                cleansed = value\n+        except TypeError:\n+            # If the key isn't regex-able, just return as-is.\n+            cleansed = value\n+\n     def cleanse_setting(self, key, value):\n         \"\"\"\n         Cleanse an individual setting key/value of sensitive content. If the\n         value is a dictionary, recursively cleanse the keys in that dictionary.\n+        For other iterables (lists, tuples, sets), recursively cleanse their contents.\n         \"\"\"\n         try:\n             if self.hidden_settings.search(key):\n                 cleansed = self.cleansed_substitute\n             elif isinstance(value, dict):\n                 cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n+            elif isinstance(value, (list, tuple)):\n+                # Handle lists and tuples, preserving original type\n+                cleansed_items = [self.cleanse_setting('', item) for item in value]\n+                cleansed = type(value)(cleansed_items)\n+            elif isinstance(value, set):\n+                # Handle sets\n+                cleansed = {self.cleanse_setting('', item) for item in value}\n             else:\n                 cleansed = value\n         except TypeError:\n",
    "variant_1": "diff --git a/django/views/debug.py b/django/views/debug.py\nindex e6b7d4d821..bd79263851 100644\n--- a/django/views/debug.py\n+++ b/django/views/debug.py\n@@ -80,22 +80,56 @@ class SafeExceptionReporterFilter:\n     cleansed_substitute = '********************'\n     hidden_settings = _lazy_re_compile('API|TOKEN|KEY|SECRET|PASS|SIGNATURE', flags=re.I)\n \n+    def cleanse_setting(self, key, value):\n+\n     def cleanse_setting(self, key, value):\n         \"\"\"\n         Cleanse an individual setting key/value of sensitive content. If the\n         value is a dictionary, recursively cleanse the keys in that dictionary.\n+        For other iterables (lists, tuples, sets), recursively cleanse their contents.\n         \"\"\"\n         try:\n             if self.hidden_settings.search(key):\n                 cleansed = self.cleansed_substitute\n             elif isinstance(value, dict):\n                 cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n+            elif isinstance(value, (list, tuple)):\n+                # Handle lists and tuples, preserving original type\n+                cleansed_items = [self.cleanse_setting('', item) for item in value]\n+                cleansed = type(value)(cleansed_items)\n+            elif isinstance(value, set):\n+                # Handle sets\n+                cleansed = {self.cleanse_setting('', item) for item in value}\n             else:\n                 cleansed = value\n         except TypeError:\n             # If the key isn't regex-able, just return as-is.\n             cleansed = value\n \n+def cleanse_setting(self, key, value):\n+    \"\"\"\n+    Cleanse an individual setting key/value of sensitive content. If the\n+    value is a dictionary, recursively cleanse the keys in that dictionary.\n+    For other iterables (lists, tuples, sets), recursively cleanse their contents.\n+    \"\"\"\n+    try:\n+        if self.hidden_settings.search(key):\n+            cleansed = self.cleansed_substitute\n+        elif isinstance(value, dict):\n+            cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n+        elif isinstance(value, (list, tuple)):\n+            # Handle lists and tuples, preserving original type\n+            cleansed_items = [self.cleanse_setting('', item) for item in value]\n+            cleansed = type(value)(cleansed_items)\n+        elif isinstance(value, set):\n+            # Handle sets\n+            cleansed = {self.cleanse_setting('', item) for item in value}\n+        else:\n+            cleansed = value\n+    except TypeError:\n+        # If the key isn't regex-able, just return as-is.\n+        cleansed = value\n+\n         if callable(cleansed):\n             cleansed = CallableSettingWrapper(cleansed)\n \n",
    "variant_2": "diff --git a/django/views/debug.py b/django/views/debug.py\nindex e6b7d4d821..bd79263851 100644\n--- a/django/views/debug.py\n+++ b/django/views/debug.py\n@@ -80,22 +80,56 @@ class SafeExceptionReporterFilter:\n     cleansed_substitute = '********************'\n     hidden_settings = _lazy_re_compile('API|TOKEN|KEY|SECRET|PASS|SIGNATURE', flags=re.I)\n \n+    def cleanse_setting(self, key, value):\n+\n     def cleanse_setting(self, key, value):\n         \"\"\"\n         Cleanse an individual setting key/value of sensitive content. If the\n         value is a dictionary, recursively cleanse the keys in that dictionary.\n+        For other iterables (lists, tuples, sets), recursively cleanse their contents.\n         \"\"\"\n         try:\n             if self.hidden_settings.search(key):\n                 cleansed = self.cleansed_substitute\n             elif isinstance(value, dict):\n                 cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n+            elif isinstance(value, (list, tuple)):\n+                # Handle lists and tuples, preserving original type\n+                cleansed_items = [self.cleanse_setting('', item) for item in value]\n+                cleansed = type(value)(cleansed_items)\n+            elif isinstance(value, set):\n+                # Handle sets\n+                cleansed = {self.cleanse_setting('', item) for item in value}\n             else:\n                 cleansed = value\n         except TypeError:\n             # If the key isn't regex-able, just return as-is.\n             cleansed = value\n \n+def cleanse_setting(self, key, value):\n+    \"\"\"\n+    Cleanse an individual setting key/value of sensitive content. If the\n+    value is a dictionary, recursively cleanse the keys in that dictionary.\n+    For other iterables (lists, tuples, sets), recursively cleanse their contents.\n+    \"\"\"\n+    try:\n+        if self.hidden_settings.search(key):\n+            cleansed = self.cleansed_substitute\n+        elif isinstance(value, dict):\n+            cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n+        elif isinstance(value, (list, tuple)):\n+            # Handle lists and tuples, preserving original type\n+            cleansed_items = [self.cleanse_setting('', item) for item in value]\n+            cleansed = type(value)(cleansed_items)\n+        elif isinstance(value, set):\n+            # Handle sets\n+            cleansed = {self.cleanse_setting('', item) for item in value}\n+        else:\n+            cleansed = value\n+    except TypeError:\n+        # If the key isn't regex-able, just return as-is.\n+        cleansed = value\n+\n         if callable(cleansed):\n             cleansed = CallableSettingWrapper(cleansed)\n \n",
    "variant_3": "diff --git a/django/views/debug.py b/django/views/debug.py\nindex e6b7d4d821..bd79263851 100644\n--- a/django/views/debug.py\n+++ b/django/views/debug.py\n@@ -80,22 +80,56 @@ class SafeExceptionReporterFilter:\n     cleansed_substitute = '********************'\n     hidden_settings = _lazy_re_compile('API|TOKEN|KEY|SECRET|PASS|SIGNATURE', flags=re.I)\n \n+    def cleanse_setting(self, key, value):\n+\n     def cleanse_setting(self, key, value):\n         \"\"\"\n         Cleanse an individual setting key/value of sensitive content. If the\n         value is a dictionary, recursively cleanse the keys in that dictionary.\n+        For other iterables (lists, tuples, sets), recursively cleanse their contents.\n         \"\"\"\n         try:\n             if self.hidden_settings.search(key):\n                 cleansed = self.cleansed_substitute\n             elif isinstance(value, dict):\n                 cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n+            elif isinstance(value, (list, tuple)):\n+                # Handle lists and tuples, preserving original type\n+                cleansed_items = [self.cleanse_setting('', item) for item in value]\n+                cleansed = type(value)(cleansed_items)\n+            elif isinstance(value, set):\n+                # Handle sets\n+                cleansed = {self.cleanse_setting('', item) for item in value}\n             else:\n                 cleansed = value\n         except TypeError:\n             # If the key isn't regex-able, just return as-is.\n             cleansed = value\n \n+def cleanse_setting(self, key, value):\n+    \"\"\"\n+    Cleanse an individual setting key/value of sensitive content. If the\n+    value is a dictionary, recursively cleanse the keys in that dictionary.\n+    For other iterables (lists, tuples, sets), recursively cleanse their contents.\n+    \"\"\"\n+    try:\n+        if self.hidden_settings.search(key):\n+            cleansed = self.cleansed_substitute\n+        elif isinstance(value, dict):\n+            cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n+        elif isinstance(value, (list, tuple)):\n+            # Handle lists and tuples, preserving original type\n+            cleansed_items = [self.cleanse_setting('', item) for item in value]\n+            cleansed = type(value)(cleansed_items)\n+        elif isinstance(value, set):\n+            # Handle sets\n+            cleansed = {self.cleanse_setting('', item) for item in value}\n+        else:\n+            cleansed = value\n+    except TypeError:\n+        # If the key isn't regex-able, just return as-is.\n+        cleansed = value\n+\n         if callable(cleansed):\n             cleansed = CallableSettingWrapper(cleansed)\n \n",
    "variant_4": "diff --git a/django/views/debug.py b/django/views/debug.py\nindex e6b7d4d821..0b44819ffa 100644\n--- a/django/views/debug.py\n+++ b/django/views/debug.py\n@@ -80,16 +80,50 @@ class SafeExceptionReporterFilter:\n     cleansed_substitute = '********************'\n     hidden_settings = _lazy_re_compile('API|TOKEN|KEY|SECRET|PASS|SIGNATURE', flags=re.I)\n \n+    def cleanse_setting(self, key, value):\n+\n+    def cleanse_setting(self, key, value):\n+        \"\"\"\n+        Cleanse an individual setting key/value of sensitive content. If the\n+        value is a dictionary, recursively cleanse the keys in that dictionary.\n+        For other iterables (lists, tuples, sets), recursively cleanse their contents.\n+        \"\"\"\n+        try:\n+            if self.hidden_settings.search(key):\n+                cleansed = self.cleansed_substitute\n+            elif isinstance(value, dict):\n+                cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n+            elif isinstance(value, (list, tuple)):\n+                # Handle lists and tuples, preserving original type\n+                cleansed_items = [self.cleanse_setting('', item) for item in value]\n+                cleansed = type(value)(cleansed_items)\n+            elif isinstance(value, set):\n+                # Handle sets\n+                cleansed = {self.cleanse_setting('', item) for item in value}\n+            else:\n+                cleansed = value\n+        except TypeError:\n+            # If the key isn't regex-able, just return as-is.\n+            cleansed = value\n+\n     def cleanse_setting(self, key, value):\n         \"\"\"\n         Cleanse an individual setting key/value of sensitive content. If the\n         value is a dictionary, recursively cleanse the keys in that dictionary.\n+        For other iterables (lists, tuples, sets), recursively cleanse their contents.\n         \"\"\"\n         try:\n             if self.hidden_settings.search(key):\n                 cleansed = self.cleansed_substitute\n             elif isinstance(value, dict):\n                 cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n+            elif isinstance(value, (list, tuple)):\n+                # Handle lists and tuples, preserving original type\n+                cleansed_items = [self.cleanse_setting('', item) for item in value]\n+                cleansed = type(value)(cleansed_items)\n+            elif isinstance(value, set):\n+                # Handle sets\n+                cleansed = {self.cleanse_setting('', item) for item in value}\n             else:\n                 cleansed = value\n         except TypeError:\n",
    "variant_5": "diff --git a/django/views/debug.py b/django/views/debug.py\nindex e6b7d4d821..0b44819ffa 100644\n--- a/django/views/debug.py\n+++ b/django/views/debug.py\n@@ -80,16 +80,50 @@ class SafeExceptionReporterFilter:\n     cleansed_substitute = '********************'\n     hidden_settings = _lazy_re_compile('API|TOKEN|KEY|SECRET|PASS|SIGNATURE', flags=re.I)\n \n+    def cleanse_setting(self, key, value):\n+\n+    def cleanse_setting(self, key, value):\n+        \"\"\"\n+        Cleanse an individual setting key/value of sensitive content. If the\n+        value is a dictionary, recursively cleanse the keys in that dictionary.\n+        For other iterables (lists, tuples, sets), recursively cleanse their contents.\n+        \"\"\"\n+        try:\n+            if self.hidden_settings.search(key):\n+                cleansed = self.cleansed_substitute\n+            elif isinstance(value, dict):\n+                cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n+            elif isinstance(value, (list, tuple)):\n+                # Handle lists and tuples, preserving original type\n+                cleansed_items = [self.cleanse_setting('', item) for item in value]\n+                cleansed = type(value)(cleansed_items)\n+            elif isinstance(value, set):\n+                # Handle sets\n+                cleansed = {self.cleanse_setting('', item) for item in value}\n+            else:\n+                cleansed = value\n+        except TypeError:\n+            # If the key isn't regex-able, just return as-is.\n+            cleansed = value\n+\n     def cleanse_setting(self, key, value):\n         \"\"\"\n         Cleanse an individual setting key/value of sensitive content. If the\n         value is a dictionary, recursively cleanse the keys in that dictionary.\n+        For other iterables (lists, tuples, sets), recursively cleanse their contents.\n         \"\"\"\n         try:\n             if self.hidden_settings.search(key):\n                 cleansed = self.cleansed_substitute\n             elif isinstance(value, dict):\n                 cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n+            elif isinstance(value, (list, tuple)):\n+                # Handle lists and tuples, preserving original type\n+                cleansed_items = [self.cleanse_setting('', item) for item in value]\n+                cleansed = type(value)(cleansed_items)\n+            elif isinstance(value, set):\n+                # Handle sets\n+                cleansed = {self.cleanse_setting('', item) for item in value}\n             else:\n                 cleansed = value\n         except TypeError:\n",
    "variant_6": "diff --git a/django/views/debug.py b/django/views/debug.py\nindex e6b7d4d821..0b44819ffa 100644\n--- a/django/views/debug.py\n+++ b/django/views/debug.py\n@@ -80,16 +80,50 @@ class SafeExceptionReporterFilter:\n     cleansed_substitute = '********************'\n     hidden_settings = _lazy_re_compile('API|TOKEN|KEY|SECRET|PASS|SIGNATURE', flags=re.I)\n \n+    def cleanse_setting(self, key, value):\n+\n+    def cleanse_setting(self, key, value):\n+        \"\"\"\n+        Cleanse an individual setting key/value of sensitive content. If the\n+        value is a dictionary, recursively cleanse the keys in that dictionary.\n+        For other iterables (lists, tuples, sets), recursively cleanse their contents.\n+        \"\"\"\n+        try:\n+            if self.hidden_settings.search(key):\n+                cleansed = self.cleansed_substitute\n+            elif isinstance(value, dict):\n+                cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n+            elif isinstance(value, (list, tuple)):\n+                # Handle lists and tuples, preserving original type\n+                cleansed_items = [self.cleanse_setting('', item) for item in value]\n+                cleansed = type(value)(cleansed_items)\n+            elif isinstance(value, set):\n+                # Handle sets\n+                cleansed = {self.cleanse_setting('', item) for item in value}\n+            else:\n+                cleansed = value\n+        except TypeError:\n+            # If the key isn't regex-able, just return as-is.\n+            cleansed = value\n+\n     def cleanse_setting(self, key, value):\n         \"\"\"\n         Cleanse an individual setting key/value of sensitive content. If the\n         value is a dictionary, recursively cleanse the keys in that dictionary.\n+        For other iterables (lists, tuples, sets), recursively cleanse their contents.\n         \"\"\"\n         try:\n             if self.hidden_settings.search(key):\n                 cleansed = self.cleansed_substitute\n             elif isinstance(value, dict):\n                 cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n+            elif isinstance(value, (list, tuple)):\n+                # Handle lists and tuples, preserving original type\n+                cleansed_items = [self.cleanse_setting('', item) for item in value]\n+                cleansed = type(value)(cleansed_items)\n+            elif isinstance(value, set):\n+                # Handle sets\n+                cleansed = {self.cleanse_setting('', item) for item in value}\n             else:\n                 cleansed = value\n         except TypeError:\n",
    "variant_7": "diff --git a/django/views/debug.py b/django/views/debug.py\nindex e6b7d4d821..87141f428f 100644\n--- a/django/views/debug.py\n+++ b/django/views/debug.py\n@@ -80,16 +80,51 @@ class SafeExceptionReporterFilter:\n     cleansed_substitute = '********************'\n     hidden_settings = _lazy_re_compile('API|TOKEN|KEY|SECRET|PASS|SIGNATURE', flags=re.I)\n \n+    def cleanse_setting(self, key, value):\n+\n+    def cleanse_setting(self, key, value):\n+        \"\"\"\n+        Cleanse an individual setting key/value of sensitive content. If the\n+        value is a dictionary, recursively cleanse the keys in that dictionary.\n+        For other iterables (lists, tuples, sets), recursively cleanse their contents.\n+        \"\"\"\n+        try:\n+            if self.hidden_settings.search(key):\n+                cleansed = self.cleansed_substitute\n+            elif isinstance(value, dict):\n+                cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n+            elif isinstance(value, (list, tuple)):\n+                # Handle lists and tuples, preserving original type\n+                cleansed_items = [self.cleanse_setting('', item) for item in value]\n+                cleansed = type(value)(cleansed_items)\n+            elif isinstance(value, set):\n+                # Handle sets\n+                cleansed = {self.cleanse_setting('', item) for item in value}\n+            else:\n+                cleansed = value\n+        except TypeError:\n+            # If the key isn't regex-able, just return as-is.\n+            cleansed = value\n+        return cleansed\n+\n     def cleanse_setting(self, key, value):\n         \"\"\"\n         Cleanse an individual setting key/value of sensitive content. If the\n         value is a dictionary, recursively cleanse the keys in that dictionary.\n+        For other iterables (lists, tuples, sets), recursively cleanse their contents.\n         \"\"\"\n         try:\n             if self.hidden_settings.search(key):\n                 cleansed = self.cleansed_substitute\n             elif isinstance(value, dict):\n                 cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n+            elif isinstance(value, (list, tuple)):\n+                # Handle lists and tuples, preserving original type\n+                cleansed_items = [self.cleanse_setting('', item) for item in value]\n+                cleansed = type(value)(cleansed_items)\n+            elif isinstance(value, set):\n+                # Handle sets\n+                cleansed = {self.cleanse_setting('', item) for item in value}\n             else:\n                 cleansed = value\n         except TypeError:\n",
    "variant_8": "diff --git a/django/views/debug.py b/django/views/debug.py\nindex e6b7d4d821..0b44819ffa 100644\n--- a/django/views/debug.py\n+++ b/django/views/debug.py\n@@ -80,16 +80,50 @@ class SafeExceptionReporterFilter:\n     cleansed_substitute = '********************'\n     hidden_settings = _lazy_re_compile('API|TOKEN|KEY|SECRET|PASS|SIGNATURE', flags=re.I)\n \n+    def cleanse_setting(self, key, value):\n+\n+    def cleanse_setting(self, key, value):\n+        \"\"\"\n+        Cleanse an individual setting key/value of sensitive content. If the\n+        value is a dictionary, recursively cleanse the keys in that dictionary.\n+        For other iterables (lists, tuples, sets), recursively cleanse their contents.\n+        \"\"\"\n+        try:\n+            if self.hidden_settings.search(key):\n+                cleansed = self.cleansed_substitute\n+            elif isinstance(value, dict):\n+                cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n+            elif isinstance(value, (list, tuple)):\n+                # Handle lists and tuples, preserving original type\n+                cleansed_items = [self.cleanse_setting('', item) for item in value]\n+                cleansed = type(value)(cleansed_items)\n+            elif isinstance(value, set):\n+                # Handle sets\n+                cleansed = {self.cleanse_setting('', item) for item in value}\n+            else:\n+                cleansed = value\n+        except TypeError:\n+            # If the key isn't regex-able, just return as-is.\n+            cleansed = value\n+\n     def cleanse_setting(self, key, value):\n         \"\"\"\n         Cleanse an individual setting key/value of sensitive content. If the\n         value is a dictionary, recursively cleanse the keys in that dictionary.\n+        For other iterables (lists, tuples, sets), recursively cleanse their contents.\n         \"\"\"\n         try:\n             if self.hidden_settings.search(key):\n                 cleansed = self.cleansed_substitute\n             elif isinstance(value, dict):\n                 cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n+            elif isinstance(value, (list, tuple)):\n+                # Handle lists and tuples, preserving original type\n+                cleansed_items = [self.cleanse_setting('', item) for item in value]\n+                cleansed = type(value)(cleansed_items)\n+            elif isinstance(value, set):\n+                # Handle sets\n+                cleansed = {self.cleanse_setting('', item) for item in value}\n             else:\n                 cleansed = value\n         except TypeError:\n"
  }
}