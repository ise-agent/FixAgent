{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/django/django/db/models/deletion.py lines 392-398)": "\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                if count == 0:\n                    return count, {}\n                return count, {model._meta.label: count}\n",
    "Location 2 (/root/hy/projects_3/django/django/db/models/deletion.py lines 439-445)": "\n        # update collected instances\n        for instances_for_fieldvalues in self.field_updates.values():\n            for (field, value), instances in instances_for_fieldvalues.items():\n                for obj in instances:\n                    setattr(obj, field.attname, value)\n        for model, instances in self.data.items():\n            for instance in instances:\n                setattr(instance, model._meta.pk.attname, None)\n        \n        # Ensure all models in self.data have entries in deleted_counter, even with 0 count\n        for model in self.data:\n            if model._meta.label not in deleted_counter:\n                deleted_counter[model._meta.label] = 0\n        \n        return sum(deleted_counter.values()), dict(deleted_counter)\n",
    "Location 3 (/root/hy/projects_3/django/django/db/models/deletion.py lines 388-390)": "\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        \n        # Initialize counter with all models that will be processed\n        for model in self.data:\n            deleted_counter[model._meta.label] = 0\n",
    "Location 4 (/root/hy/projects_3/django/django/db/models/deletion.py lines 165-199)": "\n    def can_fast_delete(self, objs, from_field=None):\n        \"\"\"\n        Determine if the objects in the given queryset-like or single object\n        can be fast-deleted. This can be done if there are no cascades, no\n        parents and no signal listeners for the object class.\n\n        The 'from_field' tells where we are coming from - we need this to\n        determine if the objects are in fact to be deleted. Allow also\n        skipping parent -> child -> parent chain preventing fast delete of\n        the child.\n        \"\"\"\n        if from_field and from_field.remote_field.on_delete is not CASCADE:\n            return False\n        if hasattr(objs, '_meta'):\n            model = objs._meta.model\n        elif hasattr(objs, 'model') and hasattr(objs, '_raw_delete'):\n            model = objs.model\n        else:\n            return False\n        if self._has_signal_listeners(model):\n            return False\n        # The use of from_field comes from the need to avoid cascade back to\n        # parent when parent delete is cascading to child.\n        opts = model._meta\n        return (\n            all(link == from_field for link in opts.concrete_model._meta.parents.values()) and\n            # Foreign keys pointing to this model.\n            all(\n                related.field.remote_field.on_delete is DO_NOTHING\n                for related in get_candidate_relations_to_delete(opts)\n            ) and (\n                # Something like generic foreign key.\n                not any(hasattr(field, 'bulk_related_objects') for field in opts.private_fields)\n            )\n        )\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/django/django/db/models/deletion.py lines 392-398)": [
      "\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                if count:\n                    return count, {model._meta.label: count}\n                else:\n                    return count, {}\n",
      "\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                if count == 0:\n                    return count, {}\n                return count, {model._meta.label: count}\n",
      "\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                if count == 0:\n                    return count, {}\n                return count, {model._meta.label: count}\n",
      "\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                if count == 0:\n                    return count, {}\n                return count, {model._meta.label: count}\n",
      "\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                if count == 0:\n                    return count, {}\n                return count, {model._meta.label: count}\n",
      "\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                if count == 0:\n                    return count, {}\n                return count, {model._meta.label: count}\n",
      "\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                if count == 0:\n                    return count, {}\n                return count, {model._meta.label: count}\n",
      "\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                if count == 0:\n                    return count, {}\n                return count, {model._meta.label: count}\n"
    ],
    "Location 2 (/root/hy/projects_3/django/django/db/models/deletion.py lines 439-445)": [
      "\n        # update collected instances\n        for instances_for_fieldvalues in self.field_updates.values():\n            for (field, value), instances in instances_for_fieldvalues.items():\n                for obj in instances:\n                    setattr(obj, field.attname, value)\n        for model, instances in self.data.items():\n            for instance in instances:\n                setattr(instance, model._meta.pk.attname, None)\n        \n        # Ensure all models in self.data are represented in the counter\n        for model in self.data:\n            if model._meta.label not in deleted_counter:\n                deleted_counter[model._meta.label] = 0\n                \n        return sum(deleted_counter.values()), dict(deleted_counter)\n",
      "\n        # update collected instances\n        for instances_for_fieldvalues in self.field_updates.values():\n            for (field, value), instances in instances_for_fieldvalues.items():\n                for obj in instances:\n                    setattr(obj, field.attname, value)\n        for model, instances in self.data.items():\n            for instance in instances:\n                setattr(instance, model._meta.pk.attname, None)\n        \n        # Ensure all models in self.data are represented in deleted_counter\n        for model in self.data:\n            if model._meta.label not in deleted_counter:\n                deleted_counter[model._meta.label] = 0\n        \n        return sum(deleted_counter.values()), dict(deleted_counter)\n",
      "\n        # update collected instances\n        for instances_for_fieldvalues in self.field_updates.values():\n            for (field, value), instances in instances_for_fieldvalues.items():\n                for obj in instances:\n                    setattr(obj, field.attname, value)\n        for model, instances in self.data.items():\n            for instance in instances:\n                setattr(instance, model._meta.pk.attname, None)\n        \n        # Ensure all processed models are included in the counter, even with zero deletions\n        for model in self.data.keys():\n            if model._meta.label not in deleted_counter:\n                deleted_counter[model._meta.label] = 0\n        \n        return sum(deleted_counter.values()), dict(deleted_counter)\n",
      "\n        # update collected instances\n        for instances_for_fieldvalues in self.field_updates.values():\n            for (field, value), instances in instances_for_fieldvalues.items():\n                for obj in instances:\n                    setattr(obj, field.attname, value)\n        for model, instances in self.data.items():\n            for instance in instances:\n                setattr(instance, model._meta.pk.attname, None)\n        \n        # Ensure all processed models are included in the counter, even with zero deletions\n        for model in self.data.keys():\n            if model._meta.label not in deleted_counter:\n                deleted_counter[model._meta.label] = 0\n                \n        return sum(deleted_counter.values()), dict(deleted_counter)\n",
      "\n        # update collected instances\n        for instances_for_fieldvalues in self.field_updates.values():\n            for (field, value), instances in instances_for_fieldvalues.items():\n                for obj in instances:\n                    setattr(obj, field.attname, value)\n        for model, instances in self.data.items():\n            for instance in instances:\n                setattr(instance, model._meta.pk.attname, None)\n        \n        # Ensure all models in self.data have entries in deleted_counter, even with 0 count\n        for model in self.data:\n            if model._meta.label not in deleted_counter:\n                deleted_counter[model._meta.label] = 0\n        \n        return sum(deleted_counter.values()), dict(deleted_counter)\n",
      "\n        # update collected instances\n        for instances_for_fieldvalues in self.field_updates.values():\n            for (field, value), instances in instances_for_fieldvalues.items():\n                for obj in instances:\n                    setattr(obj, field.attname, value)\n        for model, instances in self.data.items():\n            for instance in instances:\n                setattr(instance, model._meta.pk.attname, None)\n        \n        # Ensure all models in self.data are represented in deleted_counter\n        for model in self.data:\n            if model._meta.label not in deleted_counter:\n                deleted_counter[model._meta.label] = 0\n        \n        return sum(deleted_counter.values()), dict(deleted_counter)\n",
      "\n        # update collected instances\n        for instances_for_fieldvalues in self.field_updates.values():\n            for (field, value), instances in instances_for_fieldvalues.items():\n                for obj in instances:\n                    setattr(obj, field.attname, value)\n        for model, instances in self.data.items():\n            for instance in instances:\n                setattr(instance, model._meta.pk.attname, None)\n        \n        # Ensure all models in self.data are represented in deleted_counter\n        # even if they had zero deletions\n        for model in self.data:\n            if model._meta.label not in deleted_counter:\n                deleted_counter[model._meta.label] = 0\n        \n        return sum(deleted_counter.values()), dict(deleted_counter)\n",
      "\n        # update collected instances\n        for instances_for_fieldvalues in self.field_updates.values():\n            for (field, value), instances in instances_for_fieldvalues.items():\n                for obj in instances:\n                    setattr(obj, field.attname, value)\n        for model, instances in self.data.items():\n            for instance in instances:\n                setattr(instance, model._meta.pk.attname, None)\n        \n        # Ensure all processed models appear in the counter, even with zero deletions\n        for model in self.data:\n            if model._meta.label not in deleted_counter:\n                deleted_counter[model._meta.label] = 0\n                \n        return sum(deleted_counter.values()), dict(deleted_counter)\n"
    ],
    "Location 3 (/root/hy/projects_3/django/django/db/models/deletion.py lines 388-390)": [
      "\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        \n        # Initialize counter with all models that will be processed\n        for model in self.data:\n            deleted_counter[model._meta.label] = 0\n",
      "\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        \n        # Initialize counter with all models to ensure consistent return format\n        for model in self.data:\n            deleted_counter[model._meta.label] = 0\n",
      "\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        \n        # Initialize counter with all models to ensure consistent return format\n        for model in self.data.keys():\n            deleted_counter[model._meta.label] = 0\n",
      "\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        \n        # Initialize counter with all models that will be processed\n        for model in self.data:\n            deleted_counter[model._meta.label] = 0\n",
      "\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        \n        # Initialize counter with all models that will be processed\n        for model in self.data:\n            deleted_counter[model._meta.label] = 0\n",
      "\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        # Initialize counter with all models to ensure consistent return format\n        for model in self.data:\n            deleted_counter[model._meta.label] = 0\n",
      "\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        \n        # Initialize counter with all models to ensure consistent return format\n        for model in self.data:\n            deleted_counter[model._meta.label] = 0\n",
      "\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n        \n        # Initialize counter with all models to ensure consistent return format\n        for model in self.data:\n            deleted_counter[model._meta.label] = 0\n"
    ],
    "Location 4 (/root/hy/projects_3/django/django/db/models/deletion.py lines 165-199)": [
      "\n    def can_fast_delete(self, objs, from_field=None):\n        \"\"\"\n        Determine if the objects in the given queryset-like or single object\n        can be fast-deleted. This can be done if there are no cascades, no\n        parents and no signal listeners for the object class.\n\n        The 'from_field' tells where we are coming from - we need this to\n        determine if the objects are in fact to be deleted. Allow also\n        skipping parent -> child -> parent chain preventing fast delete of\n        the child.\n        \"\"\"\n        if from_field and from_field.remote_field.on_delete is not CASCADE:\n            return False\n        if hasattr(objs, '_meta'):\n            model = objs._meta.model\n        elif hasattr(objs, 'model') and hasattr(objs, '_raw_delete'):\n            model = objs.model\n        else:\n            return False\n        if self._has_signal_listeners(model):\n            return False\n        # The use of from_field comes from the need to avoid cascade back to\n        # parent when parent delete is cascading to child.\n        opts = model._meta\n        return (\n            all(link == from_field for link in opts.concrete_model._meta.parents.values()) and\n            # Foreign keys pointing to this model.\n            all(\n                related.field.remote_field.on_delete is DO_NOTHING\n                for related in get_candidate_relations_to_delete(opts)\n            ) and (\n                # Something like generic foreign key.\n                not any(hasattr(field, 'bulk_related_objects') for field in opts.private_fields)\n            )\n        )\n",
      "\n    def can_fast_delete(self, objs, from_field=None):\n        \"\"\"\n        Determine if the objects in the given queryset-like or single object\n        can be fast-deleted. This can be done if there are no cascades, no\n        parents and no signal listeners for the object class.\n\n        The 'from_field' tells where we are coming from - we need this to\n        determine if the objects are in fact to be deleted. Allow also\n        skipping parent -> child -> parent chain preventing fast delete of\n        the child.\n        \"\"\"\n        if from_field and from_field.remote_field.on_delete is not CASCADE:\n            return False\n        if hasattr(objs, '_meta'):\n            model = objs._meta.model\n        elif hasattr(objs, 'model') and hasattr(objs, '_raw_delete'):\n            model = objs.model\n        else:\n            return False\n        if self._has_signal_listeners(model):\n            return False\n        # The use of from_field comes from the need to avoid cascade back to\n        # parent when parent delete is cascading to child.\n        opts = model._meta\n        return (\n            all(link == from_field for link in opts.concrete_model._meta.parents.values()) and\n            # Foreign keys pointing to this model.\n            all(\n                related.field.remote_field.on_delete is DO_NOTHING\n                for related in get_candidate_relations_to_delete(opts)\n            ) and (\n                # Something like generic foreign key.\n                not any(hasattr(field, 'bulk_related_objects') for field in opts.private_fields)\n            )\n        )\n",
      "\n    def can_fast_delete(self, objs, from_field=None):\n        \"\"\"\n        Determine if the objects in the given queryset-like or single object\n        can be fast-deleted. This can be done if there are no cascades, no\n        parents and no signal listeners for the object class.\n\n        The 'from_field' tells where we are coming from - we need this to\n        determine if the objects are in fact to be deleted. Allow also\n        skipping parent -> child -> parent chain preventing fast delete of\n        the child.\n        \"\"\"\n        if from_field and from_field.remote_field.on_delete is not CASCADE:\n            return False\n        if hasattr(objs, '_meta'):\n            model = objs._meta.model\n        elif hasattr(objs, 'model') and hasattr(objs, '_raw_delete'):\n            model = objs.model\n        else:\n            return False\n        if self._has_signal_listeners(model):\n            return False\n        # The use of from_field comes from the need to avoid cascade back to\n        # parent when parent delete is cascading to child.\n        opts = model._meta\n        return (\n            all(link == from_field for link in opts.concrete_model._meta.parents.values()) and\n            # Foreign keys pointing to this model.\n            all(\n                related.field.remote_field.on_delete is DO_NOTHING\n                for related in get_candidate_relations_to_delete(opts)\n            ) and (\n                # Something like generic foreign key.\n                not any(hasattr(field, 'bulk_related_objects') for field in opts.private_fields)\n            )\n        )\n",
      "\n    def can_fast_delete(self, objs, from_field=None):\n        \"\"\"\n        Determine if the objects in the given queryset-like or single object\n        can be fast-deleted. This can be done if there are no cascades, no\n        parents and no signal listeners for the object class.\n\n        The 'from_field' tells where we are coming from - we need this to\n        determine if the objects are in fact to be deleted. Allow also\n        skipping parent -> child -> parent chain preventing fast delete of\n        the child.\n        \"\"\"\n        if from_field and from_field.remote_field.on_delete is not CASCADE:\n            return False\n        if hasattr(objs, '_meta'):\n            model = objs._meta.model\n        elif hasattr(objs, 'model') and hasattr(objs, '_raw_delete'):\n            model = objs.model\n        else:\n            return False\n        if self._has_signal_listeners(model):\n            return False\n        # The use of from_field comes from the need to avoid cascade back to\n        # parent when parent delete is cascading to child.\n        opts = model._meta\n        return (\n            all(link == from_field for link in opts.concrete_model._meta.parents.values()) and\n            # Foreign keys pointing to this model.\n            all(\n                related.field.remote_field.on_delete is DO_NOTHING\n                for related in get_candidate_relations_to_delete(opts)\n            ) and (\n                # Something like generic foreign key.\n                not any(hasattr(field, 'bulk_related_objects') for field in opts.private_fields)\n            )\n        )\n",
      "\n    def can_fast_delete(self, objs, from_field=None):\n        \"\"\"\n        Determine if the objects in the given queryset-like or single object\n        can be fast-deleted. This can be done if there are no cascades, no\n        parents and no signal listeners for the object class.\n\n        The 'from_field' tells where we are coming from - we need this to\n        determine if the objects are in fact to be deleted. Allow also\n        skipping parent -> child -> parent chain preventing fast delete of\n        the child.\n        \"\"\"\n        if from_field and from_field.remote_field.on_delete is not CASCADE:\n            return False\n        if hasattr(objs, '_meta'):\n            model = objs._meta.model\n        elif hasattr(objs, 'model') and hasattr(objs, '_raw_delete'):\n            model = objs.model\n        else:\n            return False\n        if self._has_signal_listeners(model):\n            return False\n        # The use of from_field comes from the need to avoid cascade back to\n        # parent when parent delete is cascading to child.\n        opts = model._meta\n        return (\n            all(link == from_field for link in opts.concrete_model._meta.parents.values()) and\n            # Foreign keys pointing to this model.\n            all(\n                related.field.remote_field.on_delete is DO_NOTHING\n                for related in get_candidate_relations_to_delete(opts)\n            ) and (\n                # Something like generic foreign key.\n                not any(hasattr(field, 'bulk_related_objects') for field in opts.private_fields)\n            )\n        )\n",
      "\n    def can_fast_delete(self, objs, from_field=None):\n        \"\"\"\n        Determine if the objects in the given queryset-like or single object\n        can be fast-deleted. This can be done if there are no cascades, no\n        parents and no signal listeners for the object class.\n\n        The 'from_field' tells where we are coming from - we need this to\n        determine if the objects are in fact to be deleted. Allow also\n        skipping parent -> child -> parent chain preventing fast delete of\n        the child.\n        \"\"\"\n        if from_field and from_field.remote_field.on_delete is not CASCADE:\n            return False\n        if hasattr(objs, '_meta'):\n            model = objs._meta.model\n        elif hasattr(objs, 'model') and hasattr(objs, '_raw_delete'):\n            model = objs.model\n        else:\n            return False\n        if self._has_signal_listeners(model):\n            return False\n        # The use of from_field comes from the need to avoid cascade back to\n        # parent when parent delete is cascading to child.\n        opts = model._meta\n        return (\n            all(link == from_field for link in opts.concrete_model._meta.parents.values()) and\n            # Foreign keys pointing to this model.\n            all(\n                related.field.remote_field.on_delete is DO_NOTHING\n                for related in get_candidate_relations_to_delete(opts)\n            ) and (\n                # Something like generic foreign key.\n                not any(hasattr(field, 'bulk_related_objects') for field in opts.private_fields)\n            )\n        )\n",
      "\n    def can_fast_delete(self, objs, from_field=None):\n        \"\"\"\n        Determine if the objects in the given queryset-like or single object\n        can be fast-deleted. This can be done if there are no cascades, no\n        parents and no signal listeners for the object class.\n\n        The 'from_field' tells where we are coming from - we need this to\n        determine if the objects are in fact to be deleted. Allow also\n        skipping parent -> child -> parent chain preventing fast delete of\n        the child.\n        \"\"\"\n        if from_field and from_field.remote_field.on_delete is not CASCADE:\n            return False\n        if hasattr(objs, '_meta'):\n            model = objs._meta.model\n        elif hasattr(objs, 'model') and hasattr(objs, '_raw_delete'):\n            model = objs.model\n        else:\n            return False\n        if self._has_signal_listeners(model):\n            return False\n        # The use of from_field comes from the need to avoid cascade back to\n        # parent when parent delete is cascading to child.\n        opts = model._meta\n        return (\n            all(link == from_field for link in opts.concrete_model._meta.parents.values()) and\n            # Foreign keys pointing to this model.\n            all(\n                related.field.remote_field.on_delete is DO_NOTHING\n                for related in get_candidate_relations_to_delete(opts)\n            ) and (\n                # Something like generic foreign key.\n                not any(hasattr(field, 'bulk_related_objects') for field in opts.private_fields)\n            )\n        )\n",
      "\n    def can_fast_delete(self, objs, from_field=None):\n        \"\"\"\n        Determine if the objects in the given queryset-like or single object\n        can be fast-deleted. This can be done if there are no cascades, no\n        parents and no signal listeners for the object class.\n\n        The 'from_field' tells where we are coming from - we need this to\n        determine if the objects are in fact to be deleted. Allow also\n        skipping parent -> child -> parent chain preventing fast delete of\n        the child.\n        \"\"\"\n        if from_field and from_field.remote_field.on_delete is not CASCADE:\n            return False\n        if hasattr(objs, '_meta'):\n            model = objs._meta.model\n        elif hasattr(objs, 'model') and hasattr(objs, '_raw_delete'):\n            model = objs.model\n        else:\n            return False\n        if self._has_signal_listeners(model):\n            return False\n        # The use of from_field comes from the need to avoid cascade back to\n        # parent when parent delete is cascading to child.\n        opts = model._meta\n        return (\n            all(link == from_field for link in opts.concrete_model._meta.parents.values()) and\n            # Foreign keys pointing to this model.\n            all(\n                related.field.remote_field.on_delete is DO_NOTHING\n                for related in get_candidate_relations_to_delete(opts)\n            ) and (\n                # Something like generic foreign key.\n                not any(hasattr(field, 'bulk_related_objects') for field in opts.private_fields)\n            )\n        )\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 16dff6a1cd..44b7652a75 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -162,6 +162,7 @@ class Collector:\n             signals.post_delete.has_listeners(model)\n         )\n \n+\n     def can_fast_delete(self, objs, from_field=None):\n         \"\"\"\n         Determine if the objects in the given queryset-like or single object\n@@ -385,10 +386,14 @@ class Collector:\n         # don't support transactions or cannot defer constraint checks until the\n         # end of a transaction.\n         self.sort()\n+\n         # number of objects deleted for each model label\n         deleted_counter = Counter()\n-\n+        # Initialize counter with all models to ensure consistent return format\n+        for model in self.data:\n+            deleted_counter[model._meta.label] = 0\n         # Optimize for the case with a single obj and no dependencies\n+\n         if len(self.data) == 1 and len(instances) == 1:\n             instance = list(instances)[0]\n             if self.can_fast_delete(instance):\n@@ -436,6 +441,7 @@ class Collector:\n \n         # update collected instances\n         for instances_for_fieldvalues in self.field_updates.values():\n+\n             for (field, value), instances in instances_for_fieldvalues.items():\n                 for obj in instances:\n                     setattr(obj, field.attname, value)\n",
    "variant_0": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 16dff6a1cd..67efc98b7c 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -162,6 +162,7 @@ class Collector:\n             signals.post_delete.has_listeners(model)\n         )\n \n+\n     def can_fast_delete(self, objs, from_field=None):\n         \"\"\"\n         Determine if the objects in the given queryset-like or single object\n@@ -385,8 +386,14 @@ class Collector:\n         # don't support transactions or cannot defer constraint checks until the\n         # end of a transaction.\n         self.sort()\n+\n         # number of objects deleted for each model label\n         deleted_counter = Counter()\n+        \n+        # Initialize counter with all models that will be processed\n+        for model in self.data:\n+            deleted_counter[model._meta.label] = 0\n+        # Optimize for the case with a single obj and no dependencies\n \n         # Optimize for the case with a single obj and no dependencies\n         if len(self.data) == 1 and len(instances) == 1:\n@@ -395,6 +402,8 @@ class Collector:\n                 with transaction.mark_for_rollback_on_error():\n                     count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                 setattr(instance, model._meta.pk.attname, None)\n+                if count == 0:\n+                    return count, {}\n                 return count, {model._meta.label: count}\n \n         with transaction.atomic(using=self.using, savepoint=False):\n@@ -434,6 +443,9 @@ class Collector:\n                             sender=model, instance=obj, using=self.using\n                         )\n \n+        # update collected instances\n+        for instances_for_fieldvalues in self.field_updates.values():\n+\n         # update collected instances\n         for instances_for_fieldvalues in self.field_updates.values():\n             for (field, value), instances in instances_for_fieldvalues.items():\n@@ -442,4 +454,10 @@ class Collector:\n         for model, instances in self.data.items():\n             for instance in instances:\n                 setattr(instance, model._meta.pk.attname, None)\n+        \n+        # Ensure all models in self.data have entries in deleted_counter, even with 0 count\n+        for model in self.data:\n+            if model._meta.label not in deleted_counter:\n+                deleted_counter[model._meta.label] = 0\n+        \n         return sum(deleted_counter.values()), dict(deleted_counter)\n",
    "variant_1": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 16dff6a1cd..e95f53d722 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -162,6 +162,7 @@ class Collector:\n             signals.post_delete.has_listeners(model)\n         )\n \n+\n     def can_fast_delete(self, objs, from_field=None):\n         \"\"\"\n         Determine if the objects in the given queryset-like or single object\n@@ -385,8 +386,14 @@ class Collector:\n         # don't support transactions or cannot defer constraint checks until the\n         # end of a transaction.\n         self.sort()\n+\n         # number of objects deleted for each model label\n         deleted_counter = Counter()\n+        \n+        # Initialize counter with all models that will be processed\n+        for model in self.data:\n+            deleted_counter[model._meta.label] = 0\n+        # Optimize for the case with a single obj and no dependencies\n \n         # Optimize for the case with a single obj and no dependencies\n         if len(self.data) == 1 and len(instances) == 1:\n@@ -395,7 +402,10 @@ class Collector:\n                 with transaction.mark_for_rollback_on_error():\n                     count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                 setattr(instance, model._meta.pk.attname, None)\n-                return count, {model._meta.label: count}\n+                if count:\n+                    return count, {model._meta.label: count}\n+                else:\n+                    return count, {}\n \n         with transaction.atomic(using=self.using, savepoint=False):\n             # send pre_delete signals\n@@ -434,6 +444,9 @@ class Collector:\n                             sender=model, instance=obj, using=self.using\n                         )\n \n+        # update collected instances\n+        for instances_for_fieldvalues in self.field_updates.values():\n+\n         # update collected instances\n         for instances_for_fieldvalues in self.field_updates.values():\n             for (field, value), instances in instances_for_fieldvalues.items():\n@@ -442,4 +455,10 @@ class Collector:\n         for model, instances in self.data.items():\n             for instance in instances:\n                 setattr(instance, model._meta.pk.attname, None)\n+        \n+        # Ensure all models in self.data are represented in the counter\n+        for model in self.data:\n+            if model._meta.label not in deleted_counter:\n+                deleted_counter[model._meta.label] = 0\n+                \n         return sum(deleted_counter.values()), dict(deleted_counter)\n",
    "variant_2": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 16dff6a1cd..ae24cf06f6 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -162,6 +162,7 @@ class Collector:\n             signals.post_delete.has_listeners(model)\n         )\n \n+\n     def can_fast_delete(self, objs, from_field=None):\n         \"\"\"\n         Determine if the objects in the given queryset-like or single object\n@@ -385,8 +386,14 @@ class Collector:\n         # don't support transactions or cannot defer constraint checks until the\n         # end of a transaction.\n         self.sort()\n+\n         # number of objects deleted for each model label\n         deleted_counter = Counter()\n+        \n+        # Initialize counter with all models to ensure consistent return format\n+        for model in self.data:\n+            deleted_counter[model._meta.label] = 0\n+        # Optimize for the case with a single obj and no dependencies\n \n         # Optimize for the case with a single obj and no dependencies\n         if len(self.data) == 1 and len(instances) == 1:\n@@ -395,6 +402,8 @@ class Collector:\n                 with transaction.mark_for_rollback_on_error():\n                     count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                 setattr(instance, model._meta.pk.attname, None)\n+                if count == 0:\n+                    return count, {}\n                 return count, {model._meta.label: count}\n \n         with transaction.atomic(using=self.using, savepoint=False):\n@@ -434,6 +443,9 @@ class Collector:\n                             sender=model, instance=obj, using=self.using\n                         )\n \n+        # update collected instances\n+        for instances_for_fieldvalues in self.field_updates.values():\n+\n         # update collected instances\n         for instances_for_fieldvalues in self.field_updates.values():\n             for (field, value), instances in instances_for_fieldvalues.items():\n@@ -442,4 +454,10 @@ class Collector:\n         for model, instances in self.data.items():\n             for instance in instances:\n                 setattr(instance, model._meta.pk.attname, None)\n+        \n+        # Ensure all models in self.data are represented in deleted_counter\n+        for model in self.data:\n+            if model._meta.label not in deleted_counter:\n+                deleted_counter[model._meta.label] = 0\n+        \n         return sum(deleted_counter.values()), dict(deleted_counter)\n",
    "variant_3": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 16dff6a1cd..d93833e51c 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -162,6 +162,7 @@ class Collector:\n             signals.post_delete.has_listeners(model)\n         )\n \n+\n     def can_fast_delete(self, objs, from_field=None):\n         \"\"\"\n         Determine if the objects in the given queryset-like or single object\n@@ -385,8 +386,14 @@ class Collector:\n         # don't support transactions or cannot defer constraint checks until the\n         # end of a transaction.\n         self.sort()\n+\n         # number of objects deleted for each model label\n         deleted_counter = Counter()\n+        \n+        # Initialize counter with all models to ensure consistent return format\n+        for model in self.data.keys():\n+            deleted_counter[model._meta.label] = 0\n+        # Optimize for the case with a single obj and no dependencies\n \n         # Optimize for the case with a single obj and no dependencies\n         if len(self.data) == 1 and len(instances) == 1:\n@@ -395,6 +402,8 @@ class Collector:\n                 with transaction.mark_for_rollback_on_error():\n                     count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                 setattr(instance, model._meta.pk.attname, None)\n+                if count == 0:\n+                    return count, {}\n                 return count, {model._meta.label: count}\n \n         with transaction.atomic(using=self.using, savepoint=False):\n@@ -434,6 +443,9 @@ class Collector:\n                             sender=model, instance=obj, using=self.using\n                         )\n \n+        # update collected instances\n+        for instances_for_fieldvalues in self.field_updates.values():\n+\n         # update collected instances\n         for instances_for_fieldvalues in self.field_updates.values():\n             for (field, value), instances in instances_for_fieldvalues.items():\n@@ -442,4 +454,10 @@ class Collector:\n         for model, instances in self.data.items():\n             for instance in instances:\n                 setattr(instance, model._meta.pk.attname, None)\n+        \n+        # Ensure all processed models are included in the counter, even with zero deletions\n+        for model in self.data.keys():\n+            if model._meta.label not in deleted_counter:\n+                deleted_counter[model._meta.label] = 0\n+        \n         return sum(deleted_counter.values()), dict(deleted_counter)\n",
    "variant_4": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 16dff6a1cd..48f8b3cb66 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -162,6 +162,7 @@ class Collector:\n             signals.post_delete.has_listeners(model)\n         )\n \n+\n     def can_fast_delete(self, objs, from_field=None):\n         \"\"\"\n         Determine if the objects in the given queryset-like or single object\n@@ -385,8 +386,14 @@ class Collector:\n         # don't support transactions or cannot defer constraint checks until the\n         # end of a transaction.\n         self.sort()\n+\n         # number of objects deleted for each model label\n         deleted_counter = Counter()\n+        \n+        # Initialize counter with all models that will be processed\n+        for model in self.data:\n+            deleted_counter[model._meta.label] = 0\n+        # Optimize for the case with a single obj and no dependencies\n \n         # Optimize for the case with a single obj and no dependencies\n         if len(self.data) == 1 and len(instances) == 1:\n@@ -395,6 +402,8 @@ class Collector:\n                 with transaction.mark_for_rollback_on_error():\n                     count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                 setattr(instance, model._meta.pk.attname, None)\n+                if count == 0:\n+                    return count, {}\n                 return count, {model._meta.label: count}\n \n         with transaction.atomic(using=self.using, savepoint=False):\n@@ -434,6 +443,9 @@ class Collector:\n                             sender=model, instance=obj, using=self.using\n                         )\n \n+        # update collected instances\n+        for instances_for_fieldvalues in self.field_updates.values():\n+\n         # update collected instances\n         for instances_for_fieldvalues in self.field_updates.values():\n             for (field, value), instances in instances_for_fieldvalues.items():\n@@ -442,4 +454,10 @@ class Collector:\n         for model, instances in self.data.items():\n             for instance in instances:\n                 setattr(instance, model._meta.pk.attname, None)\n+        \n+        # Ensure all processed models are included in the counter, even with zero deletions\n+        for model in self.data.keys():\n+            if model._meta.label not in deleted_counter:\n+                deleted_counter[model._meta.label] = 0\n+                \n         return sum(deleted_counter.values()), dict(deleted_counter)\n",
    "variant_5": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 16dff6a1cd..67efc98b7c 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -162,6 +162,7 @@ class Collector:\n             signals.post_delete.has_listeners(model)\n         )\n \n+\n     def can_fast_delete(self, objs, from_field=None):\n         \"\"\"\n         Determine if the objects in the given queryset-like or single object\n@@ -385,8 +386,14 @@ class Collector:\n         # don't support transactions or cannot defer constraint checks until the\n         # end of a transaction.\n         self.sort()\n+\n         # number of objects deleted for each model label\n         deleted_counter = Counter()\n+        \n+        # Initialize counter with all models that will be processed\n+        for model in self.data:\n+            deleted_counter[model._meta.label] = 0\n+        # Optimize for the case with a single obj and no dependencies\n \n         # Optimize for the case with a single obj and no dependencies\n         if len(self.data) == 1 and len(instances) == 1:\n@@ -395,6 +402,8 @@ class Collector:\n                 with transaction.mark_for_rollback_on_error():\n                     count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                 setattr(instance, model._meta.pk.attname, None)\n+                if count == 0:\n+                    return count, {}\n                 return count, {model._meta.label: count}\n \n         with transaction.atomic(using=self.using, savepoint=False):\n@@ -434,6 +443,9 @@ class Collector:\n                             sender=model, instance=obj, using=self.using\n                         )\n \n+        # update collected instances\n+        for instances_for_fieldvalues in self.field_updates.values():\n+\n         # update collected instances\n         for instances_for_fieldvalues in self.field_updates.values():\n             for (field, value), instances in instances_for_fieldvalues.items():\n@@ -442,4 +454,10 @@ class Collector:\n         for model, instances in self.data.items():\n             for instance in instances:\n                 setattr(instance, model._meta.pk.attname, None)\n+        \n+        # Ensure all models in self.data have entries in deleted_counter, even with 0 count\n+        for model in self.data:\n+            if model._meta.label not in deleted_counter:\n+                deleted_counter[model._meta.label] = 0\n+        \n         return sum(deleted_counter.values()), dict(deleted_counter)\n",
    "variant_6": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 16dff6a1cd..d84daf4ec6 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -162,6 +162,7 @@ class Collector:\n             signals.post_delete.has_listeners(model)\n         )\n \n+\n     def can_fast_delete(self, objs, from_field=None):\n         \"\"\"\n         Determine if the objects in the given queryset-like or single object\n@@ -385,8 +386,13 @@ class Collector:\n         # don't support transactions or cannot defer constraint checks until the\n         # end of a transaction.\n         self.sort()\n+\n         # number of objects deleted for each model label\n         deleted_counter = Counter()\n+        # Initialize counter with all models to ensure consistent return format\n+        for model in self.data:\n+            deleted_counter[model._meta.label] = 0\n+        # Optimize for the case with a single obj and no dependencies\n \n         # Optimize for the case with a single obj and no dependencies\n         if len(self.data) == 1 and len(instances) == 1:\n@@ -395,6 +401,8 @@ class Collector:\n                 with transaction.mark_for_rollback_on_error():\n                     count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                 setattr(instance, model._meta.pk.attname, None)\n+                if count == 0:\n+                    return count, {}\n                 return count, {model._meta.label: count}\n \n         with transaction.atomic(using=self.using, savepoint=False):\n@@ -434,6 +442,9 @@ class Collector:\n                             sender=model, instance=obj, using=self.using\n                         )\n \n+        # update collected instances\n+        for instances_for_fieldvalues in self.field_updates.values():\n+\n         # update collected instances\n         for instances_for_fieldvalues in self.field_updates.values():\n             for (field, value), instances in instances_for_fieldvalues.items():\n@@ -442,4 +453,10 @@ class Collector:\n         for model, instances in self.data.items():\n             for instance in instances:\n                 setattr(instance, model._meta.pk.attname, None)\n+        \n+        # Ensure all models in self.data are represented in deleted_counter\n+        for model in self.data:\n+            if model._meta.label not in deleted_counter:\n+                deleted_counter[model._meta.label] = 0\n+        \n         return sum(deleted_counter.values()), dict(deleted_counter)\n",
    "variant_7": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 16dff6a1cd..ebe3fd992c 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -162,6 +162,7 @@ class Collector:\n             signals.post_delete.has_listeners(model)\n         )\n \n+\n     def can_fast_delete(self, objs, from_field=None):\n         \"\"\"\n         Determine if the objects in the given queryset-like or single object\n@@ -385,8 +386,14 @@ class Collector:\n         # don't support transactions or cannot defer constraint checks until the\n         # end of a transaction.\n         self.sort()\n+\n         # number of objects deleted for each model label\n         deleted_counter = Counter()\n+        \n+        # Initialize counter with all models to ensure consistent return format\n+        for model in self.data:\n+            deleted_counter[model._meta.label] = 0\n+        # Optimize for the case with a single obj and no dependencies\n \n         # Optimize for the case with a single obj and no dependencies\n         if len(self.data) == 1 and len(instances) == 1:\n@@ -395,6 +402,8 @@ class Collector:\n                 with transaction.mark_for_rollback_on_error():\n                     count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                 setattr(instance, model._meta.pk.attname, None)\n+                if count == 0:\n+                    return count, {}\n                 return count, {model._meta.label: count}\n \n         with transaction.atomic(using=self.using, savepoint=False):\n@@ -434,6 +443,9 @@ class Collector:\n                             sender=model, instance=obj, using=self.using\n                         )\n \n+        # update collected instances\n+        for instances_for_fieldvalues in self.field_updates.values():\n+\n         # update collected instances\n         for instances_for_fieldvalues in self.field_updates.values():\n             for (field, value), instances in instances_for_fieldvalues.items():\n@@ -442,4 +454,11 @@ class Collector:\n         for model, instances in self.data.items():\n             for instance in instances:\n                 setattr(instance, model._meta.pk.attname, None)\n+        \n+        # Ensure all models in self.data are represented in deleted_counter\n+        # even if they had zero deletions\n+        for model in self.data:\n+            if model._meta.label not in deleted_counter:\n+                deleted_counter[model._meta.label] = 0\n+        \n         return sum(deleted_counter.values()), dict(deleted_counter)\n",
    "variant_8": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 16dff6a1cd..71a3d1802f 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -162,6 +162,7 @@ class Collector:\n             signals.post_delete.has_listeners(model)\n         )\n \n+\n     def can_fast_delete(self, objs, from_field=None):\n         \"\"\"\n         Determine if the objects in the given queryset-like or single object\n@@ -385,8 +386,14 @@ class Collector:\n         # don't support transactions or cannot defer constraint checks until the\n         # end of a transaction.\n         self.sort()\n+\n         # number of objects deleted for each model label\n         deleted_counter = Counter()\n+        \n+        # Initialize counter with all models to ensure consistent return format\n+        for model in self.data:\n+            deleted_counter[model._meta.label] = 0\n+        # Optimize for the case with a single obj and no dependencies\n \n         # Optimize for the case with a single obj and no dependencies\n         if len(self.data) == 1 and len(instances) == 1:\n@@ -395,6 +402,8 @@ class Collector:\n                 with transaction.mark_for_rollback_on_error():\n                     count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                 setattr(instance, model._meta.pk.attname, None)\n+                if count == 0:\n+                    return count, {}\n                 return count, {model._meta.label: count}\n \n         with transaction.atomic(using=self.using, savepoint=False):\n@@ -434,6 +443,9 @@ class Collector:\n                             sender=model, instance=obj, using=self.using\n                         )\n \n+        # update collected instances\n+        for instances_for_fieldvalues in self.field_updates.values():\n+\n         # update collected instances\n         for instances_for_fieldvalues in self.field_updates.values():\n             for (field, value), instances in instances_for_fieldvalues.items():\n@@ -442,4 +454,10 @@ class Collector:\n         for model, instances in self.data.items():\n             for instance in instances:\n                 setattr(instance, model._meta.pk.attname, None)\n+        \n+        # Ensure all processed models appear in the counter, even with zero deletions\n+        for model in self.data:\n+            if model._meta.label not in deleted_counter:\n+                deleted_counter[model._meta.label] = 0\n+                \n         return sum(deleted_counter.values()), dict(deleted_counter)\n"
  }
}