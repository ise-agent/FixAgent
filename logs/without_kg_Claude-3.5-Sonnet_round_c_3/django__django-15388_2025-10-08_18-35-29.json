{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/django/django/template/autoreload.py lines 43-46)": "\n@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\ndef watch_for_template_changes(sender, **kwargs):\n    for directory in get_template_directories():\n        # Use specific template file patterns instead of watching all files\n        # to prevent overwhelming the file watcher when large directories are added\n        template_patterns = ['**/*.html', '**/*.txt', '**/*.xml', '**/*.css', '**/*.js']\n        for pattern in template_patterns:\n            sender.watch_dir(directory, pattern)\n",
    "Location 2 (/root/hy/projects_3/django/django/template/autoreload.py lines 12-32)": "\ndef get_template_directories():\n    # Iterate through each template backend and find\n    # any template_loader that has a 'get_dirs' method.\n    # Collect the directories, filtering out Django templates.\n    cwd = Path.cwd()\n    items = set()\n    for backend in engines.all():\n        if not isinstance(backend, DjangoTemplates):\n            continue\n\n        # Filter out directories that are likely project roots to prevent\n        # overly broad file watching that can break auto-reload\n        for dir_path in backend.engine.dirs:\n            full_path = cwd / to_path(dir_path)\n            # Skip if this directory contains Django project indicators\n            # which suggests it's a project root rather than a template directory\n            if not _is_likely_project_root(full_path):\n                items.add(full_path)\n\n        for loader in backend.engine.template_loaders:\n            if not hasattr(loader, 'get_dirs'):\n                continue\n            for directory in loader.get_dirs():\n                if not is_django_path(directory):\n                    full_path = cwd / to_path(directory)\n                    # Skip if this directory contains Django project indicators\n                    if not _is_likely_project_root(full_path):\n                        items.add(full_path)\n    return items\n\n\ndef _is_likely_project_root(path):\n    \"\"\"\n    Check if a directory is likely a Django project root by looking for\n    common Django project files. Project roots should not be watched\n    recursively as they contain too many non-template files.\n    \"\"\"\n    try:\n        path = Path(path)\n        # Check for common Django project indicators\n        django_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n        for indicator in django_indicators:\n            if (path / indicator).exists():\n                return True\n        # Also check for settings directory\n        if (path / 'settings').is_dir():\n            return True\n        return False\n    except (OSError, ValueError):\n        return False\n",
    "Location 3 (/root/hy/projects_3/django/django/template/backends/base.py lines 58-66)": "\n@cached_property\ndef template_dirs(self):\n    \"\"\"\n    Return a list of directories to search for templates.\n    \"\"\"\n    # Immutable return value because it's cached and shared by callers.\n    template_dirs = tuple(self.dirs)\n    if self.app_dirs:\n        template_dirs += get_app_template_dirs(self.app_dirname)\n    \n    # Warn about potentially problematic template directories\n    import warnings\n    import os\n    for template_dir in template_dirs:\n        if os.path.exists(os.path.join(template_dir, 'manage.py')):\n            warnings.warn(\n                f\"Template directory '{template_dir}' appears to be a Django project root. \"\n                \"This may cause performance issues with auto-reload. Consider using a \"\n                \"subdirectory like 'templates/' instead.\",\n                UserWarning,\n                stacklevel=2\n            )\n    \n    return template_dirs\n",
    "Location 4 (/root/hy/projects_3/django/django/utils/autoreload.py lines 166-200)": "\n@functools.lru_cache(maxsize=1)\ndef common_roots(paths):\n    \"\"\"\n    Return a tuple of common roots that are shared between the given paths.\n    File system watchers operate on directories and aren't cheap to create.\n    Try to find the minimum set of directories to watch that encompass all of\n    the files that need to be watched.\n    \"\"\"\n    # Inspired from Werkzeug:\n    # https://github.com/pallets/werkzeug/blob/7477be2853df70a022d9613e765581b9411c3c39/werkzeug/_reloader.py\n    # Create a sorted list of the path components, longest first.\n    path_parts = sorted([x.parts for x in paths], key=len, reverse=True)\n    tree = {}\n    for chunks in path_parts:\n        node = tree\n        # Add each part of the path to the tree.\n        for chunk in chunks:\n            node = node.setdefault(chunk, {})\n        # Clear the last leaf in the tree.\n        node.clear()\n\n    # Turn the tree into a list of Path instances.\n    def _walk(node, path):\n        for prefix, child in node.items():\n            yield from _walk(child, path + (prefix,))\n        if not node:\n            candidate_path = Path(*path)\n            # Skip directories that are likely to be too broad for efficient watching\n            # Check if this directory contains Django project indicators\n            if _is_likely_project_root(candidate_path):\n                # If it's a project root, don't watch it as a common root\n                # Instead, let individual files be watched directly\n                continue\n            yield candidate_path\n\n    return tuple(_walk(tree, ()))\n\n\ndef _is_likely_project_root(path):\n    \"\"\"\n    Check if a directory is likely a Django project root that would be\n    too broad to watch efficiently.\n    \"\"\"\n    try:\n        # Check for common Django project files\n        project_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n        django_files = any((path / indicator).exists() for indicator in project_indicators)\n        \n        # Check for common project structure directories\n        common_dirs = ['static', 'media', 'templates', 'locale', 'apps']\n        has_multiple_dirs = sum(1 for d in common_dirs if (path / d).is_dir()) >= 2\n        \n        return django_files and has_multiple_dirs\n    except (OSError, PermissionError):\n        return False\n\n\ndef sys_path_directories():\n    \"\"\"\n    Yield absolute directories from sys.path, ignoring entries that don't\n    exist.\n    \"\"\"\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/django/django/template/autoreload.py lines 43-46)": [
      "\n@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\ndef watch_for_template_changes(sender, **kwargs):\n    for directory in get_template_directories():\n        # Only watch specific template file patterns to avoid overwhelming\n        # the file watcher when large directories (like BASE_DIR) are included\n        template_patterns = ['**/*.html', '**/*.txt', '**/*.xml', '**/*.css', '**/*.js']\n        for pattern in template_patterns:\n            sender.watch_dir(directory, pattern)\n",
      "\n@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\ndef watch_for_template_changes(sender, **kwargs):\n    for directory in get_template_directories():\n        # Use specific template file patterns instead of watching all files\n        # to prevent overwhelming the file watcher with large directories\n        template_patterns = ['**/*.html', '**/*.txt', '**/*.xml', '**/*.json']\n        for pattern in template_patterns:\n            sender.watch_dir(directory, pattern)\n",
      "\n@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\ndef watch_for_template_changes(sender, **kwargs):\n    for directory in get_template_directories():\n        # Watch only template files to prevent overwhelming the file watcher\n        # when template directories include project root or large directories\n        template_patterns = ['**/*.html', '**/*.txt', '**/*.xml', '**/*.htm']\n        for pattern in template_patterns:\n            sender.watch_dir(directory, pattern)\n",
      "\n@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\ndef watch_for_template_changes(sender, **kwargs):\n    for directory in get_template_directories():\n        # Only watch template files, not all files, to prevent overwhelming\n        # the file watcher when large directories like BASE_DIR are included\n        sender.watch_dir(directory, '**/*.html')\n        sender.watch_dir(directory, '**/*.txt')\n        sender.watch_dir(directory, '**/*.xml')\n",
      "\n@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\ndef watch_for_template_changes(sender, **kwargs):\n    for directory in get_template_directories():\n        # Use specific template file patterns instead of watching all files\n        # to prevent overwhelming the file watcher when large directories are included\n        template_patterns = ['**/*.html', '**/*.txt', '**/*.xml', '**/*.htm']\n        for pattern in template_patterns:\n            sender.watch_dir(directory, pattern)\n",
      "\n@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\ndef watch_for_template_changes(sender, **kwargs):\n    for directory in get_template_directories():\n        # Use specific template file patterns instead of watching all files\n        # to prevent overwhelming the file watcher when template dirs include project root\n        template_patterns = ['**/*.html', '**/*.txt', '**/*.xml', '**/*.json']\n        for pattern in template_patterns:\n            sender.watch_dir(directory, pattern)\n",
      "\n@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\ndef watch_for_template_changes(sender, **kwargs):\n    for directory in get_template_directories():\n        # Use specific template file patterns instead of watching all files\n        # to prevent overwhelming the file watcher when large directories are included\n        template_patterns = ['**/*.html', '**/*.txt', '**/*.xml', '**/*.htm']\n        for pattern in template_patterns:\n            sender.watch_dir(directory, pattern)\n",
      "\n@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\ndef watch_for_template_changes(sender, **kwargs):\n    for directory in get_template_directories():\n        # Use specific template file patterns instead of watching all files\n        # to prevent overwhelming the file watcher when template dirs include\n        # project root or other large directories\n        for pattern in ['**/*.html', '**/*.txt', '**/*.xml', '**/*.htm']:\n            sender.watch_dir(directory, pattern)\n"
    ],
    "Location 2 (/root/hy/projects_3/django/django/template/autoreload.py lines 12-32)": [
      "\ndef get_template_directories():\n    # Iterate through each template backend and find\n    # any template_loader that has a 'get_dirs' method.\n    # Collect the directories, filtering out Django templates.\n    cwd = Path.cwd()\n    items = set()\n    for backend in engines.all():\n        if not isinstance(backend, DjangoTemplates):\n            continue\n\n        # Check for overly broad template directories that could be project roots\n        for dir_path in backend.engine.dirs:\n            resolved_dir = cwd / to_path(dir_path)\n            # Skip directories that appear to be project roots to prevent\n            # overwhelming the file watcher system\n            if _is_likely_project_root(resolved_dir):\n                continue\n            items.add(resolved_dir)\n\n        for loader in backend.engine.template_loaders:\n            if not hasattr(loader, 'get_dirs'):\n                continue\n            for directory in loader.get_dirs():\n                if is_django_path(directory):\n                    continue\n                resolved_dir = cwd / to_path(directory)\n                # Skip directories that appear to be project roots\n                if _is_likely_project_root(resolved_dir):\n                    continue\n                items.add(resolved_dir)\n    return items\n\n\ndef _is_likely_project_root(path):\n    \"\"\"\n    Check if a directory appears to be a Django project root by looking\n    for common project files. Project roots should not be watched entirely\n    as template directories as this can overwhelm the file watcher.\n    \"\"\"\n    try:\n        path = Path(path)\n        if not path.is_dir():\n            return False\n        \n        # Check for common Django project root indicators\n        project_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n        django_files_found = sum(1 for indicator in project_indicators \n                               if (path / indicator).exists() or \n                                  any((path / subdir / indicator).exists() \n                                      for subdir in path.iterdir() \n                                      if subdir.is_dir()))\n        \n        # If we find multiple Django project indicators, likely a project root\n        return django_files_found >= 2\n    except (OSError, PermissionError):\n        return False\n",
      "\ndef get_template_directories():\n    # Iterate through each template backend and find\n    # any template_loader that has a 'get_dirs' method.\n    # Collect the directories, filtering out Django templates.\n    cwd = Path.cwd()\n    items = set()\n    for backend in engines.all():\n        if not isinstance(backend, DjangoTemplates):\n            continue\n\n        # Filter out directories that are likely project roots to prevent\n        # excessive file watching that can break auto-reload\n        for dir_path in backend.engine.dirs:\n            abs_dir = cwd / to_path(dir_path)\n            # Skip if this directory is the project root or contains project files\n            if not _is_project_root_directory(abs_dir):\n                items.add(abs_dir)\n\n        for loader in backend.engine.template_loaders:\n            if not hasattr(loader, 'get_dirs'):\n                continue\n            for directory in loader.get_dirs():\n                if not is_django_path(directory):\n                    abs_dir = cwd / to_path(directory)\n                    # Skip if this directory is the project root or contains project files\n                    if not _is_project_root_directory(abs_dir):\n                        items.add(abs_dir)\n    return items\n\n\ndef _is_project_root_directory(path):\n    \"\"\"\n    Check if a directory appears to be a Django project root.\n    Project roots typically contain manage.py, settings files, or other\n    Django project indicators that suggest this directory is too broad\n    to watch for template changes.\n    \"\"\"\n    try:\n        path = Path(path)\n        if not path.is_dir():\n            return False\n        \n        # Check for common Django project files that indicate this is a project root\n        project_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n        for indicator in project_indicators:\n            if (path / indicator).exists():\n                return True\n                \n        # Check for settings directory (common Django project structure)\n        for item in path.iterdir():\n            if item.is_dir() and (item / 'settings.py').exists():\n                return True\n                \n        return False\n    except (OSError, PermissionError):\n        # If we can't access the directory, assume it's not a project root\n        return False\n",
      "\ndef get_template_directories():\n    # Iterate through each template backend and find\n    # any template_loader that has a 'get_dirs' method.\n    # Collect the directories, filtering out Django templates.\n    cwd = Path.cwd()\n    items = set()\n    for backend in engines.all():\n        if not isinstance(backend, DjangoTemplates):\n            continue\n\n        for dir_path in backend.engine.dirs:\n            resolved_dir = cwd / to_path(dir_path)\n            # Skip directories that are too broad (like project root)\n            if not _is_overly_broad_directory(resolved_dir, cwd):\n                items.add(resolved_dir)\n\n        for loader in backend.engine.template_loaders:\n            if not hasattr(loader, 'get_dirs'):\n                continue\n            for directory in loader.get_dirs():\n                if is_django_path(directory):\n                    continue\n                resolved_dir = cwd / to_path(directory)\n                # Skip directories that are too broad (like project root)\n                if not _is_overly_broad_directory(resolved_dir, cwd):\n                    items.add(resolved_dir)\n    return items\n\n\ndef _is_overly_broad_directory(directory, cwd):\n    \"\"\"\n    Check if a directory is too broad to watch efficiently.\n    Returns True for project root or other overly broad directories.\n    \"\"\"\n    try:\n        resolved_dir = directory.resolve()\n        resolved_cwd = cwd.resolve()\n        \n        # If the directory is the project root or a parent of it\n        if resolved_dir == resolved_cwd or resolved_cwd.is_relative_to(resolved_dir):\n            # Check for Django project indicators\n            django_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n            if any((resolved_dir / indicator).exists() for indicator in django_indicators):\n                return True\n    except (OSError, ValueError):\n        # If we can't resolve paths, err on the side of caution\n        return False\n    \n    return False\n",
      "\ndef get_template_directories():\n    # Iterate through each template backend and find\n    # any template_loader that has a 'get_dirs' method.\n    # Collect the directories, filtering out Django templates.\n    cwd = Path.cwd()\n    items = set()\n    for backend in engines.all():\n        if not isinstance(backend, DjangoTemplates):\n            continue\n\n        # Filter out directories that are project roots to prevent recursive watching issues\n        filtered_dirs = []\n        for dir_path in backend.engine.dirs:\n            resolved_dir = cwd / to_path(dir_path)\n            # Skip if directory contains Django project indicators (manage.py, settings files)\n            if not _is_project_root_directory(resolved_dir):\n                filtered_dirs.append(dir_path)\n        \n        items.update(cwd / to_path(dir) for dir in filtered_dirs)\n\n        for loader in backend.engine.template_loaders:\n            if not hasattr(loader, 'get_dirs'):\n                continue\n            filtered_loader_dirs = [\n                directory for directory in loader.get_dirs()\n                if not is_django_path(directory) and not _is_project_root_directory(cwd / to_path(directory))\n            ]\n            items.update(\n                cwd / to_path(directory)\n                for directory in filtered_loader_dirs\n            )\n    return items\n\n\ndef _is_project_root_directory(directory):\n    \"\"\"Check if a directory appears to be a Django project root.\"\"\"\n    try:\n        directory = Path(directory)\n        if not directory.is_dir():\n            return False\n        \n        # Check for common Django project root indicators\n        project_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n        \n        # Check direct files\n        for indicator in project_indicators:\n            if (directory / indicator).exists():\n                return True\n                \n        # Check for settings module directory structure\n        for item in directory.iterdir():\n            if item.is_dir() and (item / 'settings.py').exists():\n                return True\n                \n        return False\n    except (OSError, PermissionError):\n        return False\n",
      "\ndef get_template_directories():\n    # Iterate through each template backend and find\n    # any template_loader that has a 'get_dirs' method.\n    # Collect the directories, filtering out Django templates.\n    cwd = Path.cwd()\n    items = set()\n    for backend in engines.all():\n        if not isinstance(backend, DjangoTemplates):\n            continue\n\n        for dir_path in backend.engine.dirs:\n            resolved_dir = cwd / to_path(dir_path)\n            # Skip directories that are likely project roots to prevent\n            # watching entire project trees which can overwhelm the file watcher\n            if not _is_likely_project_root(resolved_dir):\n                items.add(resolved_dir)\n\n        for loader in backend.engine.template_loaders:\n            if not hasattr(loader, 'get_dirs'):\n                continue\n            for directory in loader.get_dirs():\n                if not is_django_path(directory):\n                    resolved_dir = cwd / to_path(directory)\n                    # Skip directories that are likely project roots\n                    if not _is_likely_project_root(resolved_dir):\n                        items.add(resolved_dir)\n    return items\n\n\ndef _is_likely_project_root(path):\n    \"\"\"\n    Check if a directory is likely a Django project root by looking for\n    common project files. Watching project roots can overwhelm the file watcher.\n    \"\"\"\n    try:\n        path = Path(path)\n        if not path.is_dir():\n            return False\n        \n        # Check for common Django project indicators\n        project_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n        django_files = sum(1 for indicator in project_indicators if (path / indicator).exists())\n        \n        # If multiple Django project files exist, it's likely a project root\n        if django_files >= 2:\n            return True\n            \n        # Also check for common project structure indicators\n        common_dirs = ['static', 'media', 'templates', 'locale']\n        common_dir_count = sum(1 for dirname in common_dirs if (path / dirname).is_dir())\n        \n        # If it has manage.py and multiple common directories, likely project root\n        if (path / 'manage.py').exists() and common_dir_count >= 2:\n            return True\n            \n        return False\n    except (OSError, PermissionError):\n        return False\n",
      "\ndef get_template_directories():\n    # Iterate through each template backend and find\n    # any template_loader that has a 'get_dirs' method.\n    # Collect the directories, filtering out Django templates.\n    cwd = Path.cwd()\n    items = set()\n    for backend in engines.all():\n        if not isinstance(backend, DjangoTemplates):\n            continue\n\n        # Filter out directories that are too broad (like project root)\n        for dir_path in backend.engine.dirs:\n            resolved_dir = cwd / to_path(dir_path)\n            # Skip if this directory contains manage.py (likely project root)\n            if not (resolved_dir / 'manage.py').exists():\n                items.add(resolved_dir)\n\n        for loader in backend.engine.template_loaders:\n            if not hasattr(loader, 'get_dirs'):\n                continue\n            for directory in loader.get_dirs():\n                if is_django_path(directory):\n                    continue\n                resolved_dir = cwd / to_path(directory)\n                # Skip if this directory contains manage.py (likely project root)\n                if not (resolved_dir / 'manage.py').exists():\n                    items.add(resolved_dir)\n    return items\n",
      "\ndef watch_for_template_changes():\n    for directory in get_template_directories():\n        # Only watch for template file extensions to avoid overwhelming\n        # the file watcher when template directories include large trees\n        template_patterns = ['**/*.html', '**/*.txt', '**/*.xml', '**/*.htm']\n        for pattern in template_patterns:\n            watch_file(directory / pattern)\n",
      "\ndef get_template_directories():\n    # Iterate through each template backend and find\n    # any template_loader that has a 'get_dirs' method.\n    # Collect the directories, filtering out Django templates.\n    cwd = Path.cwd()\n    items = set()\n    for backend in engines.all():\n        if not isinstance(backend, DjangoTemplates):\n            continue\n\n        # Filter out directories that are likely project roots to prevent\n        # excessive file watching that can break auto-reload\n        for dir in backend.engine.dirs:\n            dir_path = cwd / to_path(dir)\n            # Skip directories that contain Django project markers (likely project root)\n            if not _is_project_root(dir_path):\n                items.add(dir_path)\n\n        for loader in backend.engine.template_loaders:\n            if not hasattr(loader, 'get_dirs'):\n                continue\n            items.update(\n                cwd / to_path(directory)\n                for directory in loader.get_dirs()\n                if not is_django_path(directory) and not _is_project_root(cwd / to_path(directory))\n            )\n    return items\n\n\ndef _is_project_root(path):\n    \"\"\"Check if a directory is likely a Django project root.\"\"\"\n    try:\n        path = Path(path)\n        if not path.is_dir():\n            return False\n        # Check for common Django project files\n        django_markers = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n        return any((path / marker).exists() for marker in django_markers)\n    except (OSError, ValueError):\n        return False\n"
    ],
    "Location 3 (/root/hy/projects_3/django/django/template/backends/base.py lines 58-66)": [
      "\n@cached_property\ndef template_dirs(self):\n    \"\"\"\n    Return a list of directories to search for templates.\n    \"\"\"\n    # Immutable return value because it's cached and shared by callers.\n    template_dirs = tuple(self.dirs)\n    if self.app_dirs:\n        template_dirs += get_app_template_dirs(self.app_dirname)\n    \n    # Validate template directories to prevent performance issues\n    validated_dirs = []\n    for template_dir in template_dirs:\n        # Check if directory contains Django project files (likely project root)\n        if self._is_likely_project_root(template_dir):\n            import warnings\n            warnings.warn(\n                f\"Template directory '{template_dir}' appears to be a Django project root. \"\n                f\"This may cause performance issues with auto-reload. Consider using a \"\n                f\"subdirectory like '{template_dir}/templates' instead.\",\n                UserWarning,\n                stacklevel=2\n            )\n        validated_dirs.append(template_dir)\n    \n    return tuple(validated_dirs)\n\ndef _is_likely_project_root(self, directory):\n    \"\"\"\n    Check if a directory is likely a Django project root by looking for\n    common Django project files.\n    \"\"\"\n    import os\n    if not os.path.isdir(directory):\n        return False\n    \n    project_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n    files_in_dir = set()\n    \n    try:\n        # Check files in the directory\n        for item in os.listdir(directory):\n            item_path = os.path.join(directory, item)\n            if os.path.isfile(item_path):\n                files_in_dir.add(item)\n            elif os.path.isdir(item_path):\n                # Check for settings.py in subdirectories (common Django structure)\n                try:\n                    subdir_files = os.listdir(item_path)\n                    if 'settings.py' in subdir_files:\n                        return True\n                except (OSError, PermissionError):\n                    continue\n    except (OSError, PermissionError):\n        return False\n    \n    # If we find manage.py or multiple Django indicators, it's likely a project root\n    return 'manage.py' in files_in_dir or len([f for f in project_indicators if f in files_in_dir]) >= 2\n",
      "\n@cached_property\ndef template_dirs(self):\n    \"\"\"\n    Return a list of directories to search for templates.\n    \"\"\"\n    # Immutable return value because it's cached and shared by callers.\n    template_dirs = tuple(self.dirs)\n    if self.app_dirs:\n        template_dirs += get_app_template_dirs(self.app_dirname)\n    \n    # Warn about potentially problematic template directories\n    for template_dir in template_dirs:\n        if self._is_project_root_directory(template_dir):\n            import warnings\n            warnings.warn(\n                f\"Template directory '{template_dir}' appears to be a project root directory. \"\n                \"This may cause performance issues with auto-reload functionality. \"\n                \"Consider using a more specific subdirectory for templates.\",\n                RuntimeWarning,\n                stacklevel=2\n            )\n    \n    return template_dirs\n\ndef _is_project_root_directory(self, directory):\n    \"\"\"\n    Check if a directory appears to be a Django project root directory.\n    \"\"\"\n    import os\n    try:\n        files_in_dir = os.listdir(directory)\n        # Common Django project root indicators\n        project_indicators = {'manage.py', 'settings.py', 'wsgi.py', 'asgi.py', 'requirements.txt'}\n        return bool(project_indicators.intersection(files_in_dir))\n    except (OSError, TypeError):\n        return False\n",
      "\n    @cached_property\n    def template_dirs(self):\n        \"\"\"\n        Return a list of directories to search for templates.\n        \"\"\"\n        # Immutable return value because it's cached and shared by callers.\n        template_dirs = tuple(self.dirs)\n        if self.app_dirs:\n            template_dirs += get_app_template_dirs(self.app_dirname)\n        \n        # Validate template directories to prevent performance issues\n        import os\n        import warnings\n        validated_dirs = []\n        for template_dir in template_dirs:\n            # Check if directory contains Django project indicators\n            if os.path.isdir(template_dir):\n                project_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n                if any(os.path.exists(os.path.join(template_dir, indicator)) \n                       for indicator in project_indicators):\n                    warnings.warn(\n                        f\"Template directory '{template_dir}' appears to be a Django \"\n                        f\"project root directory. This may cause performance issues \"\n                        f\"with auto-reload. Consider using a subdirectory instead.\",\n                        UserWarning,\n                        stacklevel=2\n                    )\n            validated_dirs.append(template_dir)\n        \n        return tuple(validated_dirs)\n",
      "\n@cached_property\ndef template_dirs(self):\n    \"\"\"\n    Return a list of directories to search for templates.\n    \"\"\"\n    # Immutable return value because it's cached and shared by callers.\n    template_dirs = tuple(self.dirs)\n    if self.app_dirs:\n        template_dirs += get_app_template_dirs(self.app_dirname)\n    \n    # Warn about potentially problematic template directories\n    for template_dir in template_dirs:\n        # Check if this directory contains Django project files\n        if template_dir and any(\n            (Path(template_dir) / filename).exists()\n            for filename in ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n        ):\n            import warnings\n            warnings.warn(\n                f\"Template directory '{template_dir}' appears to be a Django project root. \"\n                \"This can cause performance issues and disable auto-reload functionality. \"\n                \"Consider using a subdirectory like 'templates/' instead.\",\n                UserWarning,\n                stacklevel=2\n            )\n    \n    return template_dirs\n",
      "\n@cached_property\ndef template_dirs(self):\n    \"\"\"\n    Return a list of directories to search for templates.\n    \"\"\"\n    # Immutable return value because it's cached and shared by callers.\n    template_dirs = tuple(self.dirs)\n    if self.app_dirs:\n        template_dirs += get_app_template_dirs(self.app_dirname)\n    \n    # Warn about potentially problematic template directories\n    for template_dir in template_dirs:\n        # Check if this directory contains Django project indicators\n        if self._is_project_root(template_dir):\n            import warnings\n            warnings.warn(\n                f\"Template directory '{template_dir}' appears to be a Django project root. \"\n                \"This may cause performance issues with auto-reload. Consider using a \"\n                \"subdirectory like 'templates/' instead.\",\n                UserWarning,\n                stacklevel=2\n            )\n    \n    return template_dirs\n\ndef _is_project_root(self, path):\n    \"\"\"Check if a path appears to be a Django project root directory.\"\"\"\n    try:\n        from pathlib import Path\n        path_obj = Path(path)\n        if not path_obj.is_dir():\n            return False\n        \n        # Check for common Django project files\n        project_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n        for indicator in project_indicators:\n            if (path_obj / indicator).exists():\n                return True\n        \n        # Check for settings module directory structure\n        for item in path_obj.iterdir():\n            if item.is_dir() and (item / 'settings.py').exists():\n                return True\n                \n        return False\n    except (OSError, PermissionError):\n        return False\n",
      "\n@cached_property\ndef template_dirs(self):\n    \"\"\"\n    Return a list of directories to search for templates.\n    \"\"\"\n    # Immutable return value because it's cached and shared by callers.\n    template_dirs = tuple(self.dirs)\n    if self.app_dirs:\n        template_dirs += get_app_template_dirs(self.app_dirname)\n    \n    # Validate template directories to warn about potential performance issues\n    validated_dirs = []\n    for template_dir in template_dirs:\n        # Check if this directory looks like a Django project root\n        if self._is_likely_project_root(template_dir):\n            import warnings\n            warnings.warn(\n                f\"Template directory '{template_dir}' appears to be a Django project root. \"\n                \"This may cause performance issues with auto-reload. Consider using a \"\n                \"specific subdirectory for templates instead.\",\n                UserWarning,\n                stacklevel=2\n            )\n        validated_dirs.append(template_dir)\n    \n    return tuple(validated_dirs)\n\ndef _is_likely_project_root(self, directory):\n    \"\"\"\n    Check if a directory is likely a Django project root by looking for\n    common Django project files.\n    \"\"\"\n    import os\n    if not os.path.isdir(directory):\n        return False\n    \n    project_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n    for indicator in project_indicators:\n        if os.path.exists(os.path.join(directory, indicator)):\n            return True\n    \n    # Also check for settings module in subdirectories\n    try:\n        for item in os.listdir(directory):\n            item_path = os.path.join(directory, item)\n            if os.path.isdir(item_path):\n                settings_path = os.path.join(item_path, 'settings.py')\n                if os.path.exists(settings_path):\n                    return True\n    except (OSError, PermissionError):\n        pass\n    \n    return False\n",
      "\n@cached_property\ndef template_dirs(self):\n    \"\"\"\n    Return a list of directories to search for templates.\n    \"\"\"\n    # Immutable return value because it's cached and shared by callers.\n    template_dirs = tuple(self.dirs)\n    if self.app_dirs:\n        template_dirs += get_app_template_dirs(self.app_dirname)\n    \n    # Warn if project root directories are included in template dirs\n    # as this can cause performance issues with auto-reload\n    import os\n    import warnings\n    for template_dir in template_dirs:\n        if os.path.isdir(template_dir):\n            # Check if this directory contains Django project indicators\n            potential_project_files = ['manage.py', 'settings.py', 'wsgi.py']\n            if any(os.path.exists(os.path.join(template_dir, f)) for f in potential_project_files):\n                warnings.warn(\n                    f\"Template directory '{template_dir}' appears to be a Django project root. \"\n                    f\"This may cause performance issues with auto-reload. Consider using a \"\n                    f\"subdirectory like '{os.path.join(template_dir, 'templates')}' instead.\",\n                    RuntimeWarning,\n                    stacklevel=2\n                )\n    \n    return template_dirs\n",
      "\n@cached_property\ndef template_dirs(self):\n    \"\"\"\n    Return a list of directories to search for templates.\n    \"\"\"\n    # Immutable return value because it's cached and shared by callers.\n    template_dirs = tuple(self.dirs)\n    if self.app_dirs:\n        template_dirs += get_app_template_dirs(self.app_dirname)\n    \n    # Validate template directories to prevent performance issues\n    validated_dirs = []\n    for template_dir in template_dirs:\n        # Check if directory looks like a Django project root\n        if self._is_likely_project_root(template_dir):\n            import warnings\n            warnings.warn(\n                f\"Template directory '{template_dir}' appears to be a Django project root. \"\n                \"This may cause performance issues with auto-reload. Consider using a \"\n                \"subdirectory like 'templates/' instead.\",\n                UserWarning,\n                stacklevel=2\n            )\n        validated_dirs.append(template_dir)\n    \n    return tuple(validated_dirs)\n\ndef _is_likely_project_root(self, directory):\n    \"\"\"\n    Check if a directory is likely a Django project root by looking for common files.\n    \"\"\"\n    try:\n        import os\n        common_files = ['manage.py', 'settings.py']\n        common_dirs = ['static', 'media', 'templates']\n        \n        files_in_dir = os.listdir(directory)\n        has_manage = 'manage.py' in files_in_dir\n        has_settings = any(f for f in files_in_dir if f.endswith('settings.py'))\n        has_common_dirs = sum(1 for d in common_dirs if d in files_in_dir) >= 2\n        \n        return has_manage or (has_settings and has_common_dirs)\n    except (OSError, TypeError):\n        return False\n"
    ],
    "Location 4 (/root/hy/projects_3/django/django/utils/autoreload.py lines 166-200)": [
      "\n@functools.lru_cache(maxsize=1)\ndef common_roots(paths):\n    \"\"\"\n    Return a tuple of common roots that are shared between the given paths.\n    File system watchers operate on directories and aren't cheap to create.\n    Try to find the minimum set of directories to watch that encompass all of\n    the files that need to be watched.\n    \"\"\"\n    # Inspired from Werkzeug:\n    # https://github.com/pallets/werkzeug/blob/7477be2853df70a022d9613e765581b9411c3c39/werkzeug/_reloader.py\n    # Create a sorted list of the path components, longest first.\n    path_parts = sorted([x.parts for x in paths], key=len, reverse=True)\n    tree = {}\n    for chunks in path_parts:\n        node = tree\n        # Add each part of the path to the tree.\n        for chunk in chunks:\n            node = node.setdefault(chunk, {})\n        # Clear the last leaf in the tree.\n        node.clear()\n\n    # Turn the tree into a list of Path instances.\n    def _walk(node, path):\n        for prefix, child in node.items():\n            yield from _walk(child, path + (prefix,))\n        if not node:\n            # Check if this path would be too broad to watch efficiently\n            potential_path = Path(*path)\n            if _is_project_root(potential_path):\n                # For project roots, yield individual subdirectories instead\n                try:\n                    for subdir in potential_path.iterdir():\n                        if subdir.is_dir() and not subdir.name.startswith('.') and subdir.name not in {'__pycache__', 'node_modules', '.git'}:\n                            yield subdir\n                except (OSError, PermissionError):\n                    # Fallback to the original path if we can't iterate\n                    yield potential_path\n            else:\n                yield potential_path\n\n    def _is_project_root(path):\n        \"\"\"Check if a path appears to be a Django project root directory.\"\"\"\n        try:\n            # Common indicators of a Django project root\n            indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n            path_contents = [item.name for item in path.iterdir() if item.is_file()]\n            \n            # If it contains manage.py or multiple Django indicators, likely a project root\n            if 'manage.py' in path_contents:\n                return True\n            if sum(1 for indicator in indicators if indicator in path_contents) >= 2:\n                return True\n            \n            # Also check for common Django directory structure\n            subdirs = [item.name for item in path.iterdir() if item.is_dir()]\n            django_subdirs = ['templates', 'static', 'media', 'apps']\n            if sum(1 for subdir in django_subdirs if subdir in subdirs) >= 2:\n                return True\n                \n        except (OSError, PermissionError):\n            pass\n        return False\n\n    return tuple(_walk(tree, ()))\n",
      "\n@functools.lru_cache(maxsize=1)\ndef common_roots(paths):\n    \"\"\"\n    Return a tuple of common roots that are shared between the given paths.\n    File system watchers operate on directories and aren't cheap to create.\n    Try to find the minimum set of directories to watch that encompass all of\n    the files that need to be watched.\n    \"\"\"\n    # Inspired from Werkzeug:\n    # https://github.com/pallets/werkzeug/blob/7477be2853df70a022d9613e765581b9411c3c39/werkzeug/_reloader.py\n    # Create a sorted list of the path components, longest first.\n    path_parts = sorted([x.parts for x in paths], key=len, reverse=True)\n    tree = {}\n    for chunks in path_parts:\n        node = tree\n        # Add each part of the path to the tree.\n        for chunk in chunks:\n            node = node.setdefault(chunk, {})\n        # Clear the last leaf in the tree.\n        node.clear()\n\n    # Turn the tree into a list of Path instances.\n    def _walk(node, path):\n        for prefix, child in node.items():\n            yield from _walk(child, path + (prefix,))\n        if not node:\n            candidate_path = Path(*path)\n            # Skip watching directories that are too broad to prevent system overload\n            # Check if this directory contains common Django project indicators\n            if _is_likely_project_root(candidate_path):\n                logger.debug('Skipping overly broad directory for watching: %s', candidate_path)\n                continue\n            yield candidate_path\n\n    return tuple(_walk(tree, ()))\n\n\ndef _is_likely_project_root(path):\n    \"\"\"\n    Check if a directory is likely a Django project root by looking for\n    common project files that indicate it's too broad to watch recursively.\n    \"\"\"\n    try:\n        if not path.is_dir():\n            return False\n        \n        # Check for common Django project indicators\n        project_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n        for indicator in project_indicators:\n            if (path / indicator).exists():\n                return True\n                \n        # Check for common Python project indicators\n        python_indicators = ['setup.py', 'pyproject.toml', 'requirements.txt', '.git']\n        indicator_count = sum(1 for indicator in python_indicators if (path / indicator).exists())\n        \n        # If multiple indicators are present, likely a project root\n        return indicator_count >= 2\n        \n    except (OSError, PermissionError):\n        # If we can't read the directory, assume it's safe to watch\n        return False\n\n\ndef sys_path_directories():\n    \"\"\"\n    Yield absolute directories from sys.path, ignoring entries that don't\n    exist.\n    \"\"\"\n",
      "\n@functools.lru_cache(maxsize=1)\ndef common_roots(paths):\n    \"\"\"\n    Return a tuple of common roots that are shared between the given paths.\n    File system watchers operate on directories and aren't cheap to create.\n    Try to find the minimum set of directories to watch that encompass all of\n    the files that need to be watched.\n    \"\"\"\n    # Inspired from Werkzeug:\n    # https://github.com/pallets/werkzeug/blob/7477be2853df70a022d9613e765581b9411c3c39/werkzeug/_reloader.py\n    # Create a sorted list of the path components, longest first.\n    path_parts = sorted([x.parts for x in paths], key=len, reverse=True)\n    tree = {}\n    for chunks in path_parts:\n        node = tree\n        # Add each part of the path to the tree.\n        for chunk in chunks:\n            node = node.setdefault(chunk, {})\n        # Clear the last leaf in the tree.\n        node.clear()\n\n    # Turn the tree into a list of Path instances.\n    def _walk(node, path):\n        for prefix, child in node.items():\n            yield from _walk(child, path + (prefix,))\n        if not node:\n            root_path = Path(*path)\n            # Skip directories that are likely to be too broad for efficient watching\n            # Check if this looks like a project root directory that would cause\n            # excessive file watching when used as a template directory\n            if _is_likely_project_root(root_path):\n                logger.debug('Skipping potentially problematic root directory: %s', root_path)\n                continue\n            yield root_path\n\n    return tuple(_walk(tree, ()))\n\n\ndef _is_likely_project_root(path):\n    \"\"\"\n    Check if a path is likely a Django project root that shouldn't be watched entirely.\n    \"\"\"\n    try:\n        # Check for common Django project files that indicate this is a project root\n        django_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n        python_indicators = ['setup.py', 'pyproject.toml', 'requirements.txt', '.git']\n        \n        path_contents = set()\n        if path.is_dir():\n            try:\n                path_contents = {p.name for p in path.iterdir() if p.is_file() or p.name.startswith('.')}\n            except (OSError, PermissionError):\n                return False\n        \n        # If it contains Django project files, it's likely a project root\n        django_matches = sum(1 for indicator in django_indicators if indicator in path_contents)\n        python_matches = sum(1 for indicator in python_indicators if indicator in path_contents)\n        \n        # Consider it a project root if it has multiple Django indicators or\n        # at least one Django indicator plus other Python project indicators\n        return django_matches >= 2 or (django_matches >= 1 and python_matches >= 1)\n    except Exception:\n        return False\n",
      "\n@functools.lru_cache(maxsize=1)\ndef common_roots(paths):\n    \"\"\"\n    Return a tuple of common roots that are shared between the given paths.\n    File system watchers operate on directories and aren't cheap to create.\n    Try to find the minimum set of directories to watch that encompass all of\n    the files that need to be watched.\n    \"\"\"\n    # Inspired from Werkzeug:\n    # https://github.com/pallets/werkzeug/blob/7477be2853df70a022d9613e765581b9411c3c39/werkzeug/_reloader.py\n    # Create a sorted list of the path components, longest first.\n    path_parts = sorted([x.parts for x in paths], key=len, reverse=True)\n    tree = {}\n    for chunks in path_parts:\n        node = tree\n        # Add each part of the path to the tree.\n        for chunk in chunks:\n            node = node.setdefault(chunk, {})\n        # Clear the last leaf in the tree.\n        node.clear()\n\n    # Turn the tree into a list of Path instances.\n    def _walk(node, path):\n        for prefix, child in node.items():\n            yield from _walk(child, path + (prefix,))\n        if not node:\n            root_path = Path(*path)\n            # Skip directories that are likely to be too broad for efficient watching\n            if _is_overly_broad_directory(root_path):\n                logger.debug('Skipping overly broad directory for watching: %s', root_path)\n                continue\n            yield root_path\n\n    return tuple(_walk(tree, ()))\n\n\ndef _is_overly_broad_directory(path):\n    \"\"\"\n    Check if a directory is too broad to watch efficiently.\n    This helps prevent watching entire project roots that could contain\n    thousands of files and cause performance issues.\n    \"\"\"\n    try:\n        # Check if this looks like a Django project root\n        if (path / 'manage.py').exists():\n            return True\n        \n        # Check if this is a common development directory structure\n        common_project_indicators = [\n            'settings.py', 'wsgi.py', 'asgi.py', '.git', '.gitignore',\n            'requirements.txt', 'setup.py', 'pyproject.toml'\n        ]\n        \n        indicator_count = sum(1 for indicator in common_project_indicators \n                             if (path / indicator).exists())\n        \n        # If multiple project indicators are present, likely a project root\n        if indicator_count >= 2:\n            return True\n            \n        # Check directory size heuristic - if too many immediate subdirectories\n        try:\n            subdirs = [p for p in path.iterdir() if p.is_dir()]\n            if len(subdirs) > 20:  # Arbitrary threshold for \"too many\" directories\n                return True\n        except (OSError, PermissionError):\n            # If we can't read the directory, assume it's safe to watch\n            pass\n            \n    except (OSError, PermissionError):\n        # If we can't access the path, assume it's safe to watch\n        pass\n    \n    return False\n",
      "\n@functools.lru_cache(maxsize=1)\ndef common_roots(paths):\n    \"\"\"\n    Return a tuple of common roots that are shared between the given paths.\n    File system watchers operate on directories and aren't cheap to create.\n    Try to find the minimum set of directories to watch that encompass all of\n    the files that need to be watched.\n    \"\"\"\n    # Inspired from Werkzeug:\n    # https://github.com/pallets/werkzeug/blob/7477be2853df70a022d9613e765581b9411c3c39/werkzeug/_reloader.py\n    # Create a sorted list of the path components, longest first.\n    path_parts = sorted([x.parts for x in paths], key=len, reverse=True)\n    tree = {}\n    for chunks in path_parts:\n        node = tree\n        # Add each part of the path to the tree.\n        for chunk in chunks:\n            node = node.setdefault(chunk, {})\n        # Clear the last leaf in the tree.\n        node.clear()\n\n    # Turn the tree into a list of Path instances.\n    def _walk(node, path):\n        for prefix, child in node.items():\n            yield from _walk(child, path + (prefix,))\n        if not node:\n            candidate_path = Path(*path)\n            # Skip directories that are too broad to watch efficiently\n            if _is_overly_broad_directory(candidate_path):\n                logger.debug('Skipping overly broad directory for watching: %s', candidate_path)\n                continue\n            yield candidate_path\n\n    return tuple(_walk(tree, ()))\n\n\ndef _is_overly_broad_directory(path):\n    \"\"\"\n    Check if a directory is too broad to watch efficiently.\n    Returns True for directories that are likely project roots or contain\n    excessive numbers of files that would overwhelm the file watcher.\n    \"\"\"\n    try:\n        # Check if this looks like a Django project root\n        if (path / 'manage.py').exists() or (path / 'settings.py').exists():\n            return True\n        \n        # Check if directory contains common project root indicators\n        project_indicators = {'__pycache__', '.git', '.venv', 'venv', 'node_modules', '.tox'}\n        if any((path / indicator).exists() for indicator in project_indicators):\n            return True\n            \n        # Quick check for directories with too many immediate children\n        try:\n            children = list(path.iterdir())\n            if len(children) > 100:  # Arbitrary threshold for \"too many files\"\n                return True\n        except (OSError, PermissionError):\n            # If we can't read the directory, it's probably not safe to watch\n            return True\n            \n    except (OSError, PermissionError):\n        # If we can't access the path, skip it\n        return True\n        \n    return False\n",
      "\n@functools.lru_cache(maxsize=1)\ndef common_roots(paths):\n    \"\"\"\n    Return a tuple of common roots that are shared between the given paths.\n    File system watchers operate on directories and aren't cheap to create.\n    Try to find the minimum set of directories to watch that encompass all of\n    the files that need to be watched.\n    \"\"\"\n    # Inspired from Werkzeug:\n    # https://github.com/pallets/werkzeug/blob/7477be2853df70a022d9613e765581b9411c3c39/werkzeug/_reloader.py\n    # Create a sorted list of the path components, longest first.\n    path_parts = sorted([x.parts for x in paths], key=len, reverse=True)\n    tree = {}\n    for chunks in path_parts:\n        node = tree\n        # Add each part of the path to the tree.\n        for chunk in chunks:\n            node = node.setdefault(chunk, {})\n        # Clear the last leaf in the tree.\n        node.clear()\n\n    # Turn the tree into a list of Path instances.\n    def _walk(node, path):\n        for prefix, child in node.items():\n            yield from _walk(child, path + (prefix,))\n        if not node:\n            candidate_path = Path(*path)\n            # Skip directories that might be too broad to watch efficiently\n            # Check if this looks like a project root by detecting common Django files\n            if _is_project_root_directory(candidate_path):\n                # For project roots, only yield if there are no more specific paths\n                # This prevents watching entire project directories when more specific\n                # template directories are available\n                has_more_specific = any(\n                    other_path != candidate_path and candidate_path in other_path.parents\n                    for other_path in paths\n                )\n                if not has_more_specific:\n                    yield candidate_path\n            else:\n                yield candidate_path\n\n    return tuple(_walk(tree, ()))\n\n\ndef _is_project_root_directory(path):\n    \"\"\"\n    Check if a directory looks like a Django project root.\n    Project roots typically contain manage.py, settings files, or other Django markers.\n    \"\"\"\n    if not path.is_dir():\n        return False\n    \n    # Check for common Django project files\n    django_markers = ['manage.py', 'wsgi.py', 'asgi.py']\n    settings_patterns = ['settings.py', 'settings']\n    \n    try:\n        dir_contents = [item.name for item in path.iterdir()]\n        \n        # Look for manage.py or other Django markers\n        if any(marker in dir_contents for marker in django_markers):\n            return True\n            \n        # Look for settings files/directories\n        if any(pattern in dir_contents for pattern in settings_patterns):\n            return True\n            \n        # Check if this directory has many subdirectories (characteristic of project root)\n        subdirs = [item for item in path.iterdir() if item.is_dir()]\n        if len(subdirs) > 5:  # Arbitrary threshold for \"many\" directories\n            return True\n            \n    except (OSError, PermissionError):\n        # If we can't read the directory, assume it's not a project root\n        pass\n        \n    return False\n",
      "\n@functools.lru_cache(maxsize=1)\ndef common_roots(paths):\n    \"\"\"\n    Return a tuple of common roots that are shared between the given paths.\n    File system watchers operate on directories and aren't cheap to create.\n    Try to find the minimum set of directories to watch that encompass all of\n    the files that need to be watched.\n    \"\"\"\n    # Inspired from Werkzeug:\n    # https://github.com/pallets/werkzeug/blob/7477be2853df70a022d9613e765581b9411c3c39/werkzeug/_reloader.py\n    # Create a sorted list of the path components, longest first.\n    path_parts = sorted([x.parts for x in paths], key=len, reverse=True)\n    tree = {}\n    for chunks in path_parts:\n        node = tree\n        # Add each part of the path to the tree.\n        for chunk in chunks:\n            node = node.setdefault(chunk, {})\n        # Clear the last leaf in the tree.\n        node.clear()\n\n    # Turn the tree into a list of Path instances.\n    def _walk(node, path):\n        for prefix, child in node.items():\n            yield from _walk(child, path + (prefix,))\n        if not node:\n            root_path = Path(*path)\n            # Skip directories that are likely to be too broad for efficient watching\n            if _is_overly_broad_directory(root_path):\n                logger.debug('Skipping overly broad directory for watching: %s', root_path)\n                continue\n            yield root_path\n\n    return tuple(_walk(tree, ()))\n\n\ndef _is_overly_broad_directory(path):\n    \"\"\"\n    Check if a directory is likely to contain too many files for efficient watching.\n    This helps prevent watching project root directories that would overwhelm the file watcher.\n    \"\"\"\n    try:\n        # Check if this looks like a Django project root\n        if (path / 'manage.py').exists() or (path / 'settings.py').exists():\n            return True\n        \n        # Check if directory has an excessive number of immediate subdirectories\n        # This is a heuristic to avoid watching directories with many subdirectories\n        subdir_count = sum(1 for item in path.iterdir() if item.is_dir())\n        if subdir_count > 50:  # Arbitrary threshold\n            return True\n            \n    except (OSError, PermissionError):\n        # If we can't read the directory, it's safer to skip it\n        return True\n    \n    return False\n",
      "\n@functools.lru_cache(maxsize=1)\ndef common_roots(paths):\n    \"\"\"\n    Return a tuple of common roots that are shared between the given paths.\n    File system watchers operate on directories and aren't cheap to create.\n    Try to find the minimum set of directories to watch that encompass all of\n    the files that need to be watched.\n    \"\"\"\n    # Inspired from Werkzeug:\n    # https://github.com/pallets/werkzeug/blob/7477be2853df70a022d9613e765581b9411c3c39/werkzeug/_reloader.py\n    # Create a sorted list of the path components, longest first.\n    path_parts = sorted([x.parts for x in paths], key=len, reverse=True)\n    tree = {}\n    for chunks in path_parts:\n        node = tree\n        # Add each part of the path to the tree.\n        for chunk in chunks:\n            node = node.setdefault(chunk, {})\n        # Clear the last leaf in the tree.\n        node.clear()\n\n    # Turn the tree into a list of Path instances.\n    def _walk(node, path):\n        for prefix, child in node.items():\n            yield from _walk(child, path + (prefix,))\n        if not node:\n            candidate_path = Path(*path)\n            # Skip directories that are likely to be project roots or too broad\n            # Check if this directory contains Django project indicators\n            if _is_likely_project_root(candidate_path):\n                # If it's a project root, don't watch it as a common root\n                # Instead, let individual files/subdirs be watched separately\n                return\n            yield candidate_path\n\n    def _is_likely_project_root(path):\n        \"\"\"Check if a directory appears to be a Django project root.\"\"\"\n        try:\n            # Common Django project files that indicate a project root\n            django_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n            common_dirs = ['static', 'media', 'templates', 'locale']\n            \n            # Check for Django project indicators\n            for indicator in django_indicators:\n                if (path / indicator).exists():\n                    return True\n                    \n            # Check if it contains multiple common Django directories\n            found_dirs = sum(1 for d in common_dirs if (path / d).exists())\n            if found_dirs >= 2:\n                return True\n                \n            # Check if the path has an excessive number of subdirectories\n            # This prevents watching very broad directory trees\n            try:\n                subdir_count = sum(1 for item in path.iterdir() if item.is_dir())\n                if subdir_count > 20:  # Arbitrary threshold for \"too many subdirs\"\n                    return True\n            except (OSError, PermissionError):\n                # If we can't read the directory, it's safer to skip it\n                return True\n                \n        except (OSError, PermissionError):\n            # If we can't access the path, err on the side of caution\n            return True\n            \n        return False\n\n    return tuple(_walk(tree, ()))\n\n\ndef sys_path_directories():\n    \"\"\"\n    Yield absolute directories from sys.path, ignoring entries that don't\n    exist.\n    \"\"\"\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/template/autoreload.py b/django/template/autoreload.py\nindex cf1b20ba95..f4321f5dc0 100644\n--- a/django/template/autoreload.py\n+++ b/django/template/autoreload.py\n@@ -9,6 +9,7 @@ from django.utils.autoreload import (\n )\n \n \n+\n def get_template_directories():\n     # Iterate through each template backend and find\n     # any template_loader that has a 'get_dirs' method.\n@@ -19,7 +20,19 @@ def get_template_directories():\n         if not isinstance(backend, DjangoTemplates):\n             continue\n \n-        items.update(cwd / to_path(dir) for dir in backend.engine.dirs)\n+        # Filter out directories that are likely project roots to prevent\n+        # performance issues with file watching\n+        filtered_dirs = []\n+        for dir in backend.engine.dirs:\n+            dir_path = cwd / to_path(dir)\n+            # Check if directory contains common Django project files\n+            # which indicates it's likely a project root\n+            if (dir_path / 'manage.py').exists() or (dir_path / 'settings.py').exists():\n+                # Skip project root directories as they cause file watcher overload\n+                continue\n+            filtered_dirs.append(dir)\n+        \n+        items.update(cwd / to_path(dir) for dir in filtered_dirs)\n \n         for loader in backend.engine.template_loaders:\n             if not hasattr(loader, 'get_dirs'):\n@@ -40,10 +53,22 @@ def reset_loaders():\n             loader.reset()\n \n \n+\n @receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n def watch_for_template_changes(sender, **kwargs):\n     for directory in get_template_directories():\n-        sender.watch_dir(directory, '**/*')\n+        # Watch common template file extensions instead of all files\n+        # to prevent overwhelming the file watcher when large directories\n+        # like BASE_DIR are included in template directories\n+        template_patterns = [\n+            '**/*.html',\n+            '**/*.htm', \n+            '**/*.txt',\n+            '**/*.xml',\n+            '**/*.json',\n+        ]\n+        for pattern in template_patterns:\n+            sender.watch_dir(directory, pattern)\n \n \n @receiver(file_changed, dispatch_uid='template_loaders_file_changed')\ndiff --git a/django/template/backends/base.py b/django/template/backends/base.py\nindex f1fa142362..c6c8b165ff 100644\n--- a/django/template/backends/base.py\n+++ b/django/template/backends/base.py\n@@ -55,6 +55,7 @@ class BaseEngine:\n     #                  security issues in third-party backends.\n \n     @cached_property\n+\n     def template_dirs(self):\n         \"\"\"\n         Return a list of directories to search for templates.\ndiff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 583c2be647..4e9a1ceab2 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -163,6 +163,7 @@ def iter_modules_and_files(modules, extra_files):\n \n \n @functools.lru_cache(maxsize=1)\n+\n def common_roots(paths):\n     \"\"\"\n     Return a tuple of common roots that are shared between the given paths.\n",
    "variant_0": "diff --git a/django/template/autoreload.py b/django/template/autoreload.py\nindex cf1b20ba95..e6e7dfc559 100644\n--- a/django/template/autoreload.py\n+++ b/django/template/autoreload.py\n@@ -9,6 +9,7 @@ from django.utils.autoreload import (\n )\n \n \n+\n def get_template_directories():\n     # Iterate through each template backend and find\n     # any template_loader that has a 'get_dirs' method.\n@@ -19,19 +20,48 @@ def get_template_directories():\n         if not isinstance(backend, DjangoTemplates):\n             continue\n \n-        items.update(cwd / to_path(dir) for dir in backend.engine.dirs)\n+        # Filter out directories that are likely project roots to prevent\n+        # overly broad file watching that can break auto-reload\n+        for dir_path in backend.engine.dirs:\n+            full_path = cwd / to_path(dir_path)\n+            # Skip if this directory contains Django project indicators\n+            # which suggests it's a project root rather than a template directory\n+            if not _is_likely_project_root(full_path):\n+                items.add(full_path)\n \n         for loader in backend.engine.template_loaders:\n             if not hasattr(loader, 'get_dirs'):\n                 continue\n-            items.update(\n-                cwd / to_path(directory)\n-                for directory in loader.get_dirs()\n-                if not is_django_path(directory)\n-            )\n+            for directory in loader.get_dirs():\n+                if not is_django_path(directory):\n+                    full_path = cwd / to_path(directory)\n+                    # Skip if this directory contains Django project indicators\n+                    if not _is_likely_project_root(full_path):\n+                        items.add(full_path)\n     return items\n \n \n+def _is_likely_project_root(path):\n+    \"\"\"\n+    Check if a directory is likely a Django project root by looking for\n+    common Django project files. Project roots should not be watched\n+    recursively as they contain too many non-template files.\n+    \"\"\"\n+    try:\n+        path = Path(path)\n+        # Check for common Django project indicators\n+        django_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n+        for indicator in django_indicators:\n+            if (path / indicator).exists():\n+                return True\n+        # Also check for settings directory\n+        if (path / 'settings').is_dir():\n+            return True\n+        return False\n+    except (OSError, ValueError):\n+        return False\n+\n+\n def reset_loaders():\n     for backend in engines.all():\n         if not isinstance(backend, DjangoTemplates):\n@@ -40,10 +70,15 @@ def reset_loaders():\n             loader.reset()\n \n \n+\n @receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n def watch_for_template_changes(sender, **kwargs):\n     for directory in get_template_directories():\n-        sender.watch_dir(directory, '**/*')\n+        # Use specific template file patterns instead of watching all files\n+        # to prevent overwhelming the file watcher when large directories are added\n+        template_patterns = ['**/*.html', '**/*.txt', '**/*.xml', '**/*.css', '**/*.js']\n+        for pattern in template_patterns:\n+            sender.watch_dir(directory, pattern)\n \n \n @receiver(file_changed, dispatch_uid='template_loaders_file_changed')\ndiff --git a/django/template/backends/base.py b/django/template/backends/base.py\nindex f1fa142362..d9443bcf1a 100644\n--- a/django/template/backends/base.py\n+++ b/django/template/backends/base.py\n@@ -55,15 +55,31 @@ class BaseEngine:\n     #                  security issues in third-party backends.\n \n     @cached_property\n-    def template_dirs(self):\n-        \"\"\"\n-        Return a list of directories to search for templates.\n-        \"\"\"\n-        # Immutable return value because it's cached and shared by callers.\n-        template_dirs = tuple(self.dirs)\n-        if self.app_dirs:\n-            template_dirs += get_app_template_dirs(self.app_dirname)\n-        return template_dirs\n+\n+@cached_property\n+def template_dirs(self):\n+    \"\"\"\n+    Return a list of directories to search for templates.\n+    \"\"\"\n+    # Immutable return value because it's cached and shared by callers.\n+    template_dirs = tuple(self.dirs)\n+    if self.app_dirs:\n+        template_dirs += get_app_template_dirs(self.app_dirname)\n+    \n+    # Warn about potentially problematic template directories\n+    import warnings\n+    import os\n+    for template_dir in template_dirs:\n+        if os.path.exists(os.path.join(template_dir, 'manage.py')):\n+            warnings.warn(\n+                f\"Template directory '{template_dir}' appears to be a Django project root. \"\n+                \"This may cause performance issues with auto-reload. Consider using a \"\n+                \"subdirectory like 'templates/' instead.\",\n+                UserWarning,\n+                stacklevel=2\n+            )\n+    \n+    return template_dirs\n \n     def iter_template_filenames(self, template_name):\n         \"\"\"\ndiff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 583c2be647..23fc25969e 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -162,6 +162,8 @@ def iter_modules_and_files(modules, extra_files):\n     return frozenset(results)\n \n \n+@functools.lru_cache(maxsize=1)\n+\n @functools.lru_cache(maxsize=1)\n def common_roots(paths):\n     \"\"\"\n@@ -188,11 +190,37 @@ def common_roots(paths):\n         for prefix, child in node.items():\n             yield from _walk(child, path + (prefix,))\n         if not node:\n-            yield Path(*path)\n+            candidate_path = Path(*path)\n+            # Skip directories that are likely to be too broad for efficient watching\n+            # Check if this directory contains Django project indicators\n+            if _is_likely_project_root(candidate_path):\n+                # If it's a project root, don't watch it as a common root\n+                # Instead, let individual files be watched directly\n+                continue\n+            yield candidate_path\n \n     return tuple(_walk(tree, ()))\n \n \n+def _is_likely_project_root(path):\n+    \"\"\"\n+    Check if a directory is likely a Django project root that would be\n+    too broad to watch efficiently.\n+    \"\"\"\n+    try:\n+        # Check for common Django project files\n+        project_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n+        django_files = any((path / indicator).exists() for indicator in project_indicators)\n+        \n+        # Check for common project structure directories\n+        common_dirs = ['static', 'media', 'templates', 'locale', 'apps']\n+        has_multiple_dirs = sum(1 for d in common_dirs if (path / d).is_dir()) >= 2\n+        \n+        return django_files and has_multiple_dirs\n+    except (OSError, PermissionError):\n+        return False\n+\n+\n def sys_path_directories():\n     \"\"\"\n     Yield absolute directories from sys.path, ignoring entries that don't\n",
    "variant_1": "diff --git a/django/template/autoreload.py b/django/template/autoreload.py\nindex cf1b20ba95..d335a41460 100644\n--- a/django/template/autoreload.py\n+++ b/django/template/autoreload.py\n@@ -9,6 +9,7 @@ from django.utils.autoreload import (\n )\n \n \n+\n def get_template_directories():\n     # Iterate through each template backend and find\n     # any template_loader that has a 'get_dirs' method.\n@@ -19,19 +20,54 @@ def get_template_directories():\n         if not isinstance(backend, DjangoTemplates):\n             continue\n \n-        items.update(cwd / to_path(dir) for dir in backend.engine.dirs)\n+        # Check for overly broad template directories that could be project roots\n+        for dir_path in backend.engine.dirs:\n+            resolved_dir = cwd / to_path(dir_path)\n+            # Skip directories that appear to be project roots to prevent\n+            # overwhelming the file watcher system\n+            if _is_likely_project_root(resolved_dir):\n+                continue\n+            items.add(resolved_dir)\n \n         for loader in backend.engine.template_loaders:\n             if not hasattr(loader, 'get_dirs'):\n                 continue\n-            items.update(\n-                cwd / to_path(directory)\n-                for directory in loader.get_dirs()\n-                if not is_django_path(directory)\n-            )\n+            for directory in loader.get_dirs():\n+                if is_django_path(directory):\n+                    continue\n+                resolved_dir = cwd / to_path(directory)\n+                # Skip directories that appear to be project roots\n+                if _is_likely_project_root(resolved_dir):\n+                    continue\n+                items.add(resolved_dir)\n     return items\n \n \n+def _is_likely_project_root(path):\n+    \"\"\"\n+    Check if a directory appears to be a Django project root by looking\n+    for common project files. Project roots should not be watched entirely\n+    as template directories as this can overwhelm the file watcher.\n+    \"\"\"\n+    try:\n+        path = Path(path)\n+        if not path.is_dir():\n+            return False\n+        \n+        # Check for common Django project root indicators\n+        project_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n+        django_files_found = sum(1 for indicator in project_indicators \n+                               if (path / indicator).exists() or \n+                                  any((path / subdir / indicator).exists() \n+                                      for subdir in path.iterdir() \n+                                      if subdir.is_dir()))\n+        \n+        # If we find multiple Django project indicators, likely a project root\n+        return django_files_found >= 2\n+    except (OSError, PermissionError):\n+        return False\n+\n+\n def reset_loaders():\n     for backend in engines.all():\n         if not isinstance(backend, DjangoTemplates):\n@@ -40,10 +76,15 @@ def reset_loaders():\n             loader.reset()\n \n \n+\n @receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n def watch_for_template_changes(sender, **kwargs):\n     for directory in get_template_directories():\n-        sender.watch_dir(directory, '**/*')\n+        # Only watch specific template file patterns to avoid overwhelming\n+        # the file watcher when large directories (like BASE_DIR) are included\n+        template_patterns = ['**/*.html', '**/*.txt', '**/*.xml', '**/*.css', '**/*.js']\n+        for pattern in template_patterns:\n+            sender.watch_dir(directory, pattern)\n \n \n @receiver(file_changed, dispatch_uid='template_loaders_file_changed')\ndiff --git a/django/template/backends/base.py b/django/template/backends/base.py\nindex f1fa142362..317a6f03b2 100644\n--- a/django/template/backends/base.py\n+++ b/django/template/backends/base.py\n@@ -55,15 +55,65 @@ class BaseEngine:\n     #                  security issues in third-party backends.\n \n     @cached_property\n-    def template_dirs(self):\n-        \"\"\"\n-        Return a list of directories to search for templates.\n-        \"\"\"\n-        # Immutable return value because it's cached and shared by callers.\n-        template_dirs = tuple(self.dirs)\n-        if self.app_dirs:\n-            template_dirs += get_app_template_dirs(self.app_dirname)\n-        return template_dirs\n+\n+@cached_property\n+def template_dirs(self):\n+    \"\"\"\n+    Return a list of directories to search for templates.\n+    \"\"\"\n+    # Immutable return value because it's cached and shared by callers.\n+    template_dirs = tuple(self.dirs)\n+    if self.app_dirs:\n+        template_dirs += get_app_template_dirs(self.app_dirname)\n+    \n+    # Validate template directories to prevent performance issues\n+    validated_dirs = []\n+    for template_dir in template_dirs:\n+        # Check if directory contains Django project files (likely project root)\n+        if self._is_likely_project_root(template_dir):\n+            import warnings\n+            warnings.warn(\n+                f\"Template directory '{template_dir}' appears to be a Django project root. \"\n+                f\"This may cause performance issues with auto-reload. Consider using a \"\n+                f\"subdirectory like '{template_dir}/templates' instead.\",\n+                UserWarning,\n+                stacklevel=2\n+            )\n+        validated_dirs.append(template_dir)\n+    \n+    return tuple(validated_dirs)\n+\n+def _is_likely_project_root(self, directory):\n+    \"\"\"\n+    Check if a directory is likely a Django project root by looking for\n+    common Django project files.\n+    \"\"\"\n+    import os\n+    if not os.path.isdir(directory):\n+        return False\n+    \n+    project_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n+    files_in_dir = set()\n+    \n+    try:\n+        # Check files in the directory\n+        for item in os.listdir(directory):\n+            item_path = os.path.join(directory, item)\n+            if os.path.isfile(item_path):\n+                files_in_dir.add(item)\n+            elif os.path.isdir(item_path):\n+                # Check for settings.py in subdirectories (common Django structure)\n+                try:\n+                    subdir_files = os.listdir(item_path)\n+                    if 'settings.py' in subdir_files:\n+                        return True\n+                except (OSError, PermissionError):\n+                    continue\n+    except (OSError, PermissionError):\n+        return False\n+    \n+    # If we find manage.py or multiple Django indicators, it's likely a project root\n+    return 'manage.py' in files_in_dir or len([f for f in project_indicators if f in files_in_dir]) >= 2\n \n     def iter_template_filenames(self, template_name):\n         \"\"\"\ndiff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 583c2be647..4d761e3fe0 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -162,6 +162,8 @@ def iter_modules_and_files(modules, extra_files):\n     return frozenset(results)\n \n \n+@functools.lru_cache(maxsize=1)\n+\n @functools.lru_cache(maxsize=1)\n def common_roots(paths):\n     \"\"\"\n@@ -188,16 +190,44 @@ def common_roots(paths):\n         for prefix, child in node.items():\n             yield from _walk(child, path + (prefix,))\n         if not node:\n-            yield Path(*path)\n-\n-    return tuple(_walk(tree, ()))\n+            # Check if this path would be too broad to watch efficiently\n+            potential_path = Path(*path)\n+            if _is_project_root(potential_path):\n+                # For project roots, yield individual subdirectories instead\n+                try:\n+                    for subdir in potential_path.iterdir():\n+                        if subdir.is_dir() and not subdir.name.startswith('.') and subdir.name not in {'__pycache__', 'node_modules', '.git'}:\n+                            yield subdir\n+                except (OSError, PermissionError):\n+                    # Fallback to the original path if we can't iterate\n+                    yield potential_path\n+            else:\n+                yield potential_path\n \n+    def _is_project_root(path):\n+        \"\"\"Check if a path appears to be a Django project root directory.\"\"\"\n+        try:\n+            # Common indicators of a Django project root\n+            indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n+            path_contents = [item.name for item in path.iterdir() if item.is_file()]\n+            \n+            # If it contains manage.py or multiple Django indicators, likely a project root\n+            if 'manage.py' in path_contents:\n+                return True\n+            if sum(1 for indicator in indicators if indicator in path_contents) >= 2:\n+                return True\n+            \n+            # Also check for common Django directory structure\n+            subdirs = [item.name for item in path.iterdir() if item.is_dir()]\n+            django_subdirs = ['templates', 'static', 'media', 'apps']\n+            if sum(1 for subdir in django_subdirs if subdir in subdirs) >= 2:\n+                return True\n+                \n+        except (OSError, PermissionError):\n+            pass\n+        return False\n \n-def sys_path_directories():\n-    \"\"\"\n-    Yield absolute directories from sys.path, ignoring entries that don't\n-    exist.\n-    \"\"\"\n+    return tuple(_walk(tree, ()))\n     for path in sys.path:\n         path = Path(path)\n         if not path.exists():\n",
    "variant_2": "diff --git a/django/template/autoreload.py b/django/template/autoreload.py\nindex cf1b20ba95..6eec985f20 100644\n--- a/django/template/autoreload.py\n+++ b/django/template/autoreload.py\n@@ -9,6 +9,7 @@ from django.utils.autoreload import (\n )\n \n \n+\n def get_template_directories():\n     # Iterate through each template backend and find\n     # any template_loader that has a 'get_dirs' method.\n@@ -19,19 +20,55 @@ def get_template_directories():\n         if not isinstance(backend, DjangoTemplates):\n             continue\n \n-        items.update(cwd / to_path(dir) for dir in backend.engine.dirs)\n+        # Filter out directories that are likely project roots to prevent\n+        # excessive file watching that can break auto-reload\n+        for dir_path in backend.engine.dirs:\n+            abs_dir = cwd / to_path(dir_path)\n+            # Skip if this directory is the project root or contains project files\n+            if not _is_project_root_directory(abs_dir):\n+                items.add(abs_dir)\n \n         for loader in backend.engine.template_loaders:\n             if not hasattr(loader, 'get_dirs'):\n                 continue\n-            items.update(\n-                cwd / to_path(directory)\n-                for directory in loader.get_dirs()\n-                if not is_django_path(directory)\n-            )\n+            for directory in loader.get_dirs():\n+                if not is_django_path(directory):\n+                    abs_dir = cwd / to_path(directory)\n+                    # Skip if this directory is the project root or contains project files\n+                    if not _is_project_root_directory(abs_dir):\n+                        items.add(abs_dir)\n     return items\n \n \n+def _is_project_root_directory(path):\n+    \"\"\"\n+    Check if a directory appears to be a Django project root.\n+    Project roots typically contain manage.py, settings files, or other\n+    Django project indicators that suggest this directory is too broad\n+    to watch for template changes.\n+    \"\"\"\n+    try:\n+        path = Path(path)\n+        if not path.is_dir():\n+            return False\n+        \n+        # Check for common Django project files that indicate this is a project root\n+        project_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n+        for indicator in project_indicators:\n+            if (path / indicator).exists():\n+                return True\n+                \n+        # Check for settings directory (common Django project structure)\n+        for item in path.iterdir():\n+            if item.is_dir() and (item / 'settings.py').exists():\n+                return True\n+                \n+        return False\n+    except (OSError, PermissionError):\n+        # If we can't access the directory, assume it's not a project root\n+        return False\n+\n+\n def reset_loaders():\n     for backend in engines.all():\n         if not isinstance(backend, DjangoTemplates):\n@@ -40,10 +77,15 @@ def reset_loaders():\n             loader.reset()\n \n \n+\n @receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n def watch_for_template_changes(sender, **kwargs):\n     for directory in get_template_directories():\n-        sender.watch_dir(directory, '**/*')\n+        # Use specific template file patterns instead of watching all files\n+        # to prevent overwhelming the file watcher with large directories\n+        template_patterns = ['**/*.html', '**/*.txt', '**/*.xml', '**/*.json']\n+        for pattern in template_patterns:\n+            sender.watch_dir(directory, pattern)\n \n \n @receiver(file_changed, dispatch_uid='template_loaders_file_changed')\ndiff --git a/django/template/backends/base.py b/django/template/backends/base.py\nindex f1fa142362..4ebf315434 100644\n--- a/django/template/backends/base.py\n+++ b/django/template/backends/base.py\n@@ -55,15 +55,43 @@ class BaseEngine:\n     #                  security issues in third-party backends.\n \n     @cached_property\n-    def template_dirs(self):\n-        \"\"\"\n-        Return a list of directories to search for templates.\n-        \"\"\"\n-        # Immutable return value because it's cached and shared by callers.\n-        template_dirs = tuple(self.dirs)\n-        if self.app_dirs:\n-            template_dirs += get_app_template_dirs(self.app_dirname)\n-        return template_dirs\n+\n+@cached_property\n+def template_dirs(self):\n+    \"\"\"\n+    Return a list of directories to search for templates.\n+    \"\"\"\n+    # Immutable return value because it's cached and shared by callers.\n+    template_dirs = tuple(self.dirs)\n+    if self.app_dirs:\n+        template_dirs += get_app_template_dirs(self.app_dirname)\n+    \n+    # Warn about potentially problematic template directories\n+    for template_dir in template_dirs:\n+        if self._is_project_root_directory(template_dir):\n+            import warnings\n+            warnings.warn(\n+                f\"Template directory '{template_dir}' appears to be a project root directory. \"\n+                \"This may cause performance issues with auto-reload functionality. \"\n+                \"Consider using a more specific subdirectory for templates.\",\n+                RuntimeWarning,\n+                stacklevel=2\n+            )\n+    \n+    return template_dirs\n+\n+def _is_project_root_directory(self, directory):\n+    \"\"\"\n+    Check if a directory appears to be a Django project root directory.\n+    \"\"\"\n+    import os\n+    try:\n+        files_in_dir = os.listdir(directory)\n+        # Common Django project root indicators\n+        project_indicators = {'manage.py', 'settings.py', 'wsgi.py', 'asgi.py', 'requirements.txt'}\n+        return bool(project_indicators.intersection(files_in_dir))\n+    except (OSError, TypeError):\n+        return False\n \n     def iter_template_filenames(self, template_name):\n         \"\"\"\ndiff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 583c2be647..dffedb1bb0 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -162,6 +162,8 @@ def iter_modules_and_files(modules, extra_files):\n     return frozenset(results)\n \n \n+@functools.lru_cache(maxsize=1)\n+\n @functools.lru_cache(maxsize=1)\n def common_roots(paths):\n     \"\"\"\n@@ -188,11 +190,44 @@ def common_roots(paths):\n         for prefix, child in node.items():\n             yield from _walk(child, path + (prefix,))\n         if not node:\n-            yield Path(*path)\n+            candidate_path = Path(*path)\n+            # Skip watching directories that are too broad to prevent system overload\n+            # Check if this directory contains common Django project indicators\n+            if _is_likely_project_root(candidate_path):\n+                logger.debug('Skipping overly broad directory for watching: %s', candidate_path)\n+                continue\n+            yield candidate_path\n \n     return tuple(_walk(tree, ()))\n \n \n+def _is_likely_project_root(path):\n+    \"\"\"\n+    Check if a directory is likely a Django project root by looking for\n+    common project files that indicate it's too broad to watch recursively.\n+    \"\"\"\n+    try:\n+        if not path.is_dir():\n+            return False\n+        \n+        # Check for common Django project indicators\n+        project_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n+        for indicator in project_indicators:\n+            if (path / indicator).exists():\n+                return True\n+                \n+        # Check for common Python project indicators\n+        python_indicators = ['setup.py', 'pyproject.toml', 'requirements.txt', '.git']\n+        indicator_count = sum(1 for indicator in python_indicators if (path / indicator).exists())\n+        \n+        # If multiple indicators are present, likely a project root\n+        return indicator_count >= 2\n+        \n+    except (OSError, PermissionError):\n+        # If we can't read the directory, assume it's safe to watch\n+        return False\n+\n+\n def sys_path_directories():\n     \"\"\"\n     Yield absolute directories from sys.path, ignoring entries that don't\n",
    "variant_3": "diff --git a/django/template/autoreload.py b/django/template/autoreload.py\nindex cf1b20ba95..d5f13b43dc 100644\n--- a/django/template/autoreload.py\n+++ b/django/template/autoreload.py\n@@ -9,6 +9,7 @@ from django.utils.autoreload import (\n )\n \n \n+\n def get_template_directories():\n     # Iterate through each template backend and find\n     # any template_loader that has a 'get_dirs' method.\n@@ -19,19 +20,47 @@ def get_template_directories():\n         if not isinstance(backend, DjangoTemplates):\n             continue\n \n-        items.update(cwd / to_path(dir) for dir in backend.engine.dirs)\n+        for dir_path in backend.engine.dirs:\n+            resolved_dir = cwd / to_path(dir_path)\n+            # Skip directories that are too broad (like project root)\n+            if not _is_overly_broad_directory(resolved_dir, cwd):\n+                items.add(resolved_dir)\n \n         for loader in backend.engine.template_loaders:\n             if not hasattr(loader, 'get_dirs'):\n                 continue\n-            items.update(\n-                cwd / to_path(directory)\n-                for directory in loader.get_dirs()\n-                if not is_django_path(directory)\n-            )\n+            for directory in loader.get_dirs():\n+                if is_django_path(directory):\n+                    continue\n+                resolved_dir = cwd / to_path(directory)\n+                # Skip directories that are too broad (like project root)\n+                if not _is_overly_broad_directory(resolved_dir, cwd):\n+                    items.add(resolved_dir)\n     return items\n \n \n+def _is_overly_broad_directory(directory, cwd):\n+    \"\"\"\n+    Check if a directory is too broad to watch efficiently.\n+    Returns True for project root or other overly broad directories.\n+    \"\"\"\n+    try:\n+        resolved_dir = directory.resolve()\n+        resolved_cwd = cwd.resolve()\n+        \n+        # If the directory is the project root or a parent of it\n+        if resolved_dir == resolved_cwd or resolved_cwd.is_relative_to(resolved_dir):\n+            # Check for Django project indicators\n+            django_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n+            if any((resolved_dir / indicator).exists() for indicator in django_indicators):\n+                return True\n+    except (OSError, ValueError):\n+        # If we can't resolve paths, err on the side of caution\n+        return False\n+    \n+    return False\n+\n+\n def reset_loaders():\n     for backend in engines.all():\n         if not isinstance(backend, DjangoTemplates):\n@@ -40,10 +69,15 @@ def reset_loaders():\n             loader.reset()\n \n \n+\n @receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n def watch_for_template_changes(sender, **kwargs):\n     for directory in get_template_directories():\n-        sender.watch_dir(directory, '**/*')\n+        # Watch only template files to prevent overwhelming the file watcher\n+        # when template directories include project root or large directories\n+        template_patterns = ['**/*.html', '**/*.txt', '**/*.xml', '**/*.htm']\n+        for pattern in template_patterns:\n+            sender.watch_dir(directory, pattern)\n \n \n @receiver(file_changed, dispatch_uid='template_loaders_file_changed')\ndiff --git a/django/template/backends/base.py b/django/template/backends/base.py\nindex f1fa142362..b1ebc93879 100644\n--- a/django/template/backends/base.py\n+++ b/django/template/backends/base.py\n@@ -54,6 +54,8 @@ class BaseEngine:\n     # Utility methods: they are provided to minimize code duplication and\n     #                  security issues in third-party backends.\n \n+    @cached_property\n+\n     @cached_property\n     def template_dirs(self):\n         \"\"\"\n@@ -63,7 +65,27 @@ class BaseEngine:\n         template_dirs = tuple(self.dirs)\n         if self.app_dirs:\n             template_dirs += get_app_template_dirs(self.app_dirname)\n-        return template_dirs\n+        \n+        # Validate template directories to prevent performance issues\n+        import os\n+        import warnings\n+        validated_dirs = []\n+        for template_dir in template_dirs:\n+            # Check if directory contains Django project indicators\n+            if os.path.isdir(template_dir):\n+                project_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n+                if any(os.path.exists(os.path.join(template_dir, indicator)) \n+                       for indicator in project_indicators):\n+                    warnings.warn(\n+                        f\"Template directory '{template_dir}' appears to be a Django \"\n+                        f\"project root directory. This may cause performance issues \"\n+                        f\"with auto-reload. Consider using a subdirectory instead.\",\n+                        UserWarning,\n+                        stacklevel=2\n+                    )\n+            validated_dirs.append(template_dir)\n+        \n+        return tuple(validated_dirs)\n \n     def iter_template_filenames(self, template_name):\n         \"\"\"\ndiff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 583c2be647..d96113c022 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -162,6 +162,8 @@ def iter_modules_and_files(modules, extra_files):\n     return frozenset(results)\n \n \n+@functools.lru_cache(maxsize=1)\n+\n @functools.lru_cache(maxsize=1)\n def common_roots(paths):\n     \"\"\"\n@@ -188,16 +190,43 @@ def common_roots(paths):\n         for prefix, child in node.items():\n             yield from _walk(child, path + (prefix,))\n         if not node:\n-            yield Path(*path)\n+            root_path = Path(*path)\n+            # Skip directories that are likely to be too broad for efficient watching\n+            # Check if this looks like a project root directory that would cause\n+            # excessive file watching when used as a template directory\n+            if _is_likely_project_root(root_path):\n+                logger.debug('Skipping potentially problematic root directory: %s', root_path)\n+                continue\n+            yield root_path\n \n     return tuple(_walk(tree, ()))\n \n \n-def sys_path_directories():\n+def _is_likely_project_root(path):\n     \"\"\"\n-    Yield absolute directories from sys.path, ignoring entries that don't\n-    exist.\n+    Check if a path is likely a Django project root that shouldn't be watched entirely.\n     \"\"\"\n+    try:\n+        # Check for common Django project files that indicate this is a project root\n+        django_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n+        python_indicators = ['setup.py', 'pyproject.toml', 'requirements.txt', '.git']\n+        \n+        path_contents = set()\n+        if path.is_dir():\n+            try:\n+                path_contents = {p.name for p in path.iterdir() if p.is_file() or p.name.startswith('.')}\n+            except (OSError, PermissionError):\n+                return False\n+        \n+        # If it contains Django project files, it's likely a project root\n+        django_matches = sum(1 for indicator in django_indicators if indicator in path_contents)\n+        python_matches = sum(1 for indicator in python_indicators if indicator in path_contents)\n+        \n+        # Consider it a project root if it has multiple Django indicators or\n+        # at least one Django indicator plus other Python project indicators\n+        return django_matches >= 2 or (django_matches >= 1 and python_matches >= 1)\n+    except Exception:\n+        return False\n     for path in sys.path:\n         path = Path(path)\n         if not path.exists():\n",
    "variant_4": "diff --git a/django/template/autoreload.py b/django/template/autoreload.py\nindex cf1b20ba95..c052c4fad3 100644\n--- a/django/template/autoreload.py\n+++ b/django/template/autoreload.py\n@@ -9,6 +9,7 @@ from django.utils.autoreload import (\n )\n \n \n+\n def get_template_directories():\n     # Iterate through each template backend and find\n     # any template_loader that has a 'get_dirs' method.\n@@ -19,19 +20,55 @@ def get_template_directories():\n         if not isinstance(backend, DjangoTemplates):\n             continue\n \n-        items.update(cwd / to_path(dir) for dir in backend.engine.dirs)\n+        # Filter out directories that are project roots to prevent recursive watching issues\n+        filtered_dirs = []\n+        for dir_path in backend.engine.dirs:\n+            resolved_dir = cwd / to_path(dir_path)\n+            # Skip if directory contains Django project indicators (manage.py, settings files)\n+            if not _is_project_root_directory(resolved_dir):\n+                filtered_dirs.append(dir_path)\n+        \n+        items.update(cwd / to_path(dir) for dir in filtered_dirs)\n \n         for loader in backend.engine.template_loaders:\n             if not hasattr(loader, 'get_dirs'):\n                 continue\n+            filtered_loader_dirs = [\n+                directory for directory in loader.get_dirs()\n+                if not is_django_path(directory) and not _is_project_root_directory(cwd / to_path(directory))\n+            ]\n             items.update(\n                 cwd / to_path(directory)\n-                for directory in loader.get_dirs()\n-                if not is_django_path(directory)\n+                for directory in filtered_loader_dirs\n             )\n     return items\n \n \n+def _is_project_root_directory(directory):\n+    \"\"\"Check if a directory appears to be a Django project root.\"\"\"\n+    try:\n+        directory = Path(directory)\n+        if not directory.is_dir():\n+            return False\n+        \n+        # Check for common Django project root indicators\n+        project_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n+        \n+        # Check direct files\n+        for indicator in project_indicators:\n+            if (directory / indicator).exists():\n+                return True\n+                \n+        # Check for settings module directory structure\n+        for item in directory.iterdir():\n+            if item.is_dir() and (item / 'settings.py').exists():\n+                return True\n+                \n+        return False\n+    except (OSError, PermissionError):\n+        return False\n+\n+\n def reset_loaders():\n     for backend in engines.all():\n         if not isinstance(backend, DjangoTemplates):\n@@ -40,10 +77,15 @@ def reset_loaders():\n             loader.reset()\n \n \n+\n @receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n def watch_for_template_changes(sender, **kwargs):\n     for directory in get_template_directories():\n-        sender.watch_dir(directory, '**/*')\n+        # Only watch template files, not all files, to prevent overwhelming\n+        # the file watcher when large directories like BASE_DIR are included\n+        sender.watch_dir(directory, '**/*.html')\n+        sender.watch_dir(directory, '**/*.txt')\n+        sender.watch_dir(directory, '**/*.xml')\n \n \n @receiver(file_changed, dispatch_uid='template_loaders_file_changed')\ndiff --git a/django/template/backends/base.py b/django/template/backends/base.py\nindex f1fa142362..6b46d1ba4b 100644\n--- a/django/template/backends/base.py\n+++ b/django/template/backends/base.py\n@@ -55,15 +55,34 @@ class BaseEngine:\n     #                  security issues in third-party backends.\n \n     @cached_property\n-    def template_dirs(self):\n-        \"\"\"\n-        Return a list of directories to search for templates.\n-        \"\"\"\n-        # Immutable return value because it's cached and shared by callers.\n-        template_dirs = tuple(self.dirs)\n-        if self.app_dirs:\n-            template_dirs += get_app_template_dirs(self.app_dirname)\n-        return template_dirs\n+\n+@cached_property\n+def template_dirs(self):\n+    \"\"\"\n+    Return a list of directories to search for templates.\n+    \"\"\"\n+    # Immutable return value because it's cached and shared by callers.\n+    template_dirs = tuple(self.dirs)\n+    if self.app_dirs:\n+        template_dirs += get_app_template_dirs(self.app_dirname)\n+    \n+    # Warn about potentially problematic template directories\n+    for template_dir in template_dirs:\n+        # Check if this directory contains Django project files\n+        if template_dir and any(\n+            (Path(template_dir) / filename).exists()\n+            for filename in ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n+        ):\n+            import warnings\n+            warnings.warn(\n+                f\"Template directory '{template_dir}' appears to be a Django project root. \"\n+                \"This can cause performance issues and disable auto-reload functionality. \"\n+                \"Consider using a subdirectory like 'templates/' instead.\",\n+                UserWarning,\n+                stacklevel=2\n+            )\n+    \n+    return template_dirs\n \n     def iter_template_filenames(self, template_name):\n         \"\"\"\ndiff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 583c2be647..1dd6b7b59a 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -162,6 +162,8 @@ def iter_modules_and_files(modules, extra_files):\n     return frozenset(results)\n \n \n+@functools.lru_cache(maxsize=1)\n+\n @functools.lru_cache(maxsize=1)\n def common_roots(paths):\n     \"\"\"\n@@ -188,16 +190,54 @@ def common_roots(paths):\n         for prefix, child in node.items():\n             yield from _walk(child, path + (prefix,))\n         if not node:\n-            yield Path(*path)\n+            root_path = Path(*path)\n+            # Skip directories that are likely to be too broad for efficient watching\n+            if _is_overly_broad_directory(root_path):\n+                logger.debug('Skipping overly broad directory for watching: %s', root_path)\n+                continue\n+            yield root_path\n \n     return tuple(_walk(tree, ()))\n \n \n-def sys_path_directories():\n+def _is_overly_broad_directory(path):\n     \"\"\"\n-    Yield absolute directories from sys.path, ignoring entries that don't\n-    exist.\n+    Check if a directory is too broad to watch efficiently.\n+    This helps prevent watching entire project roots that could contain\n+    thousands of files and cause performance issues.\n     \"\"\"\n+    try:\n+        # Check if this looks like a Django project root\n+        if (path / 'manage.py').exists():\n+            return True\n+        \n+        # Check if this is a common development directory structure\n+        common_project_indicators = [\n+            'settings.py', 'wsgi.py', 'asgi.py', '.git', '.gitignore',\n+            'requirements.txt', 'setup.py', 'pyproject.toml'\n+        ]\n+        \n+        indicator_count = sum(1 for indicator in common_project_indicators \n+                             if (path / indicator).exists())\n+        \n+        # If multiple project indicators are present, likely a project root\n+        if indicator_count >= 2:\n+            return True\n+            \n+        # Check directory size heuristic - if too many immediate subdirectories\n+        try:\n+            subdirs = [p for p in path.iterdir() if p.is_dir()]\n+            if len(subdirs) > 20:  # Arbitrary threshold for \"too many\" directories\n+                return True\n+        except (OSError, PermissionError):\n+            # If we can't read the directory, assume it's safe to watch\n+            pass\n+            \n+    except (OSError, PermissionError):\n+        # If we can't access the path, assume it's safe to watch\n+        pass\n+    \n+    return False\n     for path in sys.path:\n         path = Path(path)\n         if not path.exists():\n",
    "variant_5": "diff --git a/django/template/autoreload.py b/django/template/autoreload.py\nindex cf1b20ba95..2d379c206a 100644\n--- a/django/template/autoreload.py\n+++ b/django/template/autoreload.py\n@@ -9,6 +9,7 @@ from django.utils.autoreload import (\n )\n \n \n+\n def get_template_directories():\n     # Iterate through each template backend and find\n     # any template_loader that has a 'get_dirs' method.\n@@ -19,19 +20,56 @@ def get_template_directories():\n         if not isinstance(backend, DjangoTemplates):\n             continue\n \n-        items.update(cwd / to_path(dir) for dir in backend.engine.dirs)\n+        for dir_path in backend.engine.dirs:\n+            resolved_dir = cwd / to_path(dir_path)\n+            # Skip directories that are likely project roots to prevent\n+            # watching entire project trees which can overwhelm the file watcher\n+            if not _is_likely_project_root(resolved_dir):\n+                items.add(resolved_dir)\n \n         for loader in backend.engine.template_loaders:\n             if not hasattr(loader, 'get_dirs'):\n                 continue\n-            items.update(\n-                cwd / to_path(directory)\n-                for directory in loader.get_dirs()\n-                if not is_django_path(directory)\n-            )\n+            for directory in loader.get_dirs():\n+                if not is_django_path(directory):\n+                    resolved_dir = cwd / to_path(directory)\n+                    # Skip directories that are likely project roots\n+                    if not _is_likely_project_root(resolved_dir):\n+                        items.add(resolved_dir)\n     return items\n \n \n+def _is_likely_project_root(path):\n+    \"\"\"\n+    Check if a directory is likely a Django project root by looking for\n+    common project files. Watching project roots can overwhelm the file watcher.\n+    \"\"\"\n+    try:\n+        path = Path(path)\n+        if not path.is_dir():\n+            return False\n+        \n+        # Check for common Django project indicators\n+        project_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n+        django_files = sum(1 for indicator in project_indicators if (path / indicator).exists())\n+        \n+        # If multiple Django project files exist, it's likely a project root\n+        if django_files >= 2:\n+            return True\n+            \n+        # Also check for common project structure indicators\n+        common_dirs = ['static', 'media', 'templates', 'locale']\n+        common_dir_count = sum(1 for dirname in common_dirs if (path / dirname).is_dir())\n+        \n+        # If it has manage.py and multiple common directories, likely project root\n+        if (path / 'manage.py').exists() and common_dir_count >= 2:\n+            return True\n+            \n+        return False\n+    except (OSError, PermissionError):\n+        return False\n+\n+\n def reset_loaders():\n     for backend in engines.all():\n         if not isinstance(backend, DjangoTemplates):\n@@ -40,10 +78,15 @@ def reset_loaders():\n             loader.reset()\n \n \n+\n @receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n def watch_for_template_changes(sender, **kwargs):\n     for directory in get_template_directories():\n-        sender.watch_dir(directory, '**/*')\n+        # Use specific template file patterns instead of watching all files\n+        # to prevent overwhelming the file watcher when large directories are included\n+        template_patterns = ['**/*.html', '**/*.txt', '**/*.xml', '**/*.htm']\n+        for pattern in template_patterns:\n+            sender.watch_dir(directory, pattern)\n \n \n @receiver(file_changed, dispatch_uid='template_loaders_file_changed')\ndiff --git a/django/template/backends/base.py b/django/template/backends/base.py\nindex f1fa142362..8d0780a8e4 100644\n--- a/django/template/backends/base.py\n+++ b/django/template/backends/base.py\n@@ -55,15 +55,54 @@ class BaseEngine:\n     #                  security issues in third-party backends.\n \n     @cached_property\n-    def template_dirs(self):\n-        \"\"\"\n-        Return a list of directories to search for templates.\n-        \"\"\"\n-        # Immutable return value because it's cached and shared by callers.\n-        template_dirs = tuple(self.dirs)\n-        if self.app_dirs:\n-            template_dirs += get_app_template_dirs(self.app_dirname)\n-        return template_dirs\n+\n+@cached_property\n+def template_dirs(self):\n+    \"\"\"\n+    Return a list of directories to search for templates.\n+    \"\"\"\n+    # Immutable return value because it's cached and shared by callers.\n+    template_dirs = tuple(self.dirs)\n+    if self.app_dirs:\n+        template_dirs += get_app_template_dirs(self.app_dirname)\n+    \n+    # Warn about potentially problematic template directories\n+    for template_dir in template_dirs:\n+        # Check if this directory contains Django project indicators\n+        if self._is_project_root(template_dir):\n+            import warnings\n+            warnings.warn(\n+                f\"Template directory '{template_dir}' appears to be a Django project root. \"\n+                \"This may cause performance issues with auto-reload. Consider using a \"\n+                \"subdirectory like 'templates/' instead.\",\n+                UserWarning,\n+                stacklevel=2\n+            )\n+    \n+    return template_dirs\n+\n+def _is_project_root(self, path):\n+    \"\"\"Check if a path appears to be a Django project root directory.\"\"\"\n+    try:\n+        from pathlib import Path\n+        path_obj = Path(path)\n+        if not path_obj.is_dir():\n+            return False\n+        \n+        # Check for common Django project files\n+        project_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n+        for indicator in project_indicators:\n+            if (path_obj / indicator).exists():\n+                return True\n+        \n+        # Check for settings module directory structure\n+        for item in path_obj.iterdir():\n+            if item.is_dir() and (item / 'settings.py').exists():\n+                return True\n+                \n+        return False\n+    except (OSError, PermissionError):\n+        return False\n \n     def iter_template_filenames(self, template_name):\n         \"\"\"\ndiff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 583c2be647..227efaae1e 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -162,6 +162,8 @@ def iter_modules_and_files(modules, extra_files):\n     return frozenset(results)\n \n \n+@functools.lru_cache(maxsize=1)\n+\n @functools.lru_cache(maxsize=1)\n def common_roots(paths):\n     \"\"\"\n@@ -188,16 +190,46 @@ def common_roots(paths):\n         for prefix, child in node.items():\n             yield from _walk(child, path + (prefix,))\n         if not node:\n-            yield Path(*path)\n+            candidate_path = Path(*path)\n+            # Skip directories that are too broad to watch efficiently\n+            if _is_overly_broad_directory(candidate_path):\n+                logger.debug('Skipping overly broad directory for watching: %s', candidate_path)\n+                continue\n+            yield candidate_path\n \n     return tuple(_walk(tree, ()))\n \n \n-def sys_path_directories():\n+def _is_overly_broad_directory(path):\n     \"\"\"\n-    Yield absolute directories from sys.path, ignoring entries that don't\n-    exist.\n+    Check if a directory is too broad to watch efficiently.\n+    Returns True for directories that are likely project roots or contain\n+    excessive numbers of files that would overwhelm the file watcher.\n     \"\"\"\n+    try:\n+        # Check if this looks like a Django project root\n+        if (path / 'manage.py').exists() or (path / 'settings.py').exists():\n+            return True\n+        \n+        # Check if directory contains common project root indicators\n+        project_indicators = {'__pycache__', '.git', '.venv', 'venv', 'node_modules', '.tox'}\n+        if any((path / indicator).exists() for indicator in project_indicators):\n+            return True\n+            \n+        # Quick check for directories with too many immediate children\n+        try:\n+            children = list(path.iterdir())\n+            if len(children) > 100:  # Arbitrary threshold for \"too many files\"\n+                return True\n+        except (OSError, PermissionError):\n+            # If we can't read the directory, it's probably not safe to watch\n+            return True\n+            \n+    except (OSError, PermissionError):\n+        # If we can't access the path, skip it\n+        return True\n+        \n+    return False\n     for path in sys.path:\n         path = Path(path)\n         if not path.exists():\n",
    "variant_6": "diff --git a/django/template/autoreload.py b/django/template/autoreload.py\nindex cf1b20ba95..fae3ce36c2 100644\n--- a/django/template/autoreload.py\n+++ b/django/template/autoreload.py\n@@ -9,6 +9,7 @@ from django.utils.autoreload import (\n )\n \n \n+\n def get_template_directories():\n     # Iterate through each template backend and find\n     # any template_loader that has a 'get_dirs' method.\n@@ -19,16 +20,23 @@ def get_template_directories():\n         if not isinstance(backend, DjangoTemplates):\n             continue\n \n-        items.update(cwd / to_path(dir) for dir in backend.engine.dirs)\n+        # Filter out directories that are too broad (like project root)\n+        for dir_path in backend.engine.dirs:\n+            resolved_dir = cwd / to_path(dir_path)\n+            # Skip if this directory contains manage.py (likely project root)\n+            if not (resolved_dir / 'manage.py').exists():\n+                items.add(resolved_dir)\n \n         for loader in backend.engine.template_loaders:\n             if not hasattr(loader, 'get_dirs'):\n                 continue\n-            items.update(\n-                cwd / to_path(directory)\n-                for directory in loader.get_dirs()\n-                if not is_django_path(directory)\n-            )\n+            for directory in loader.get_dirs():\n+                if is_django_path(directory):\n+                    continue\n+                resolved_dir = cwd / to_path(directory)\n+                # Skip if this directory contains manage.py (likely project root)\n+                if not (resolved_dir / 'manage.py').exists():\n+                    items.add(resolved_dir)\n     return items\n \n \n@@ -40,10 +48,15 @@ def reset_loaders():\n             loader.reset()\n \n \n+\n @receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n def watch_for_template_changes(sender, **kwargs):\n     for directory in get_template_directories():\n-        sender.watch_dir(directory, '**/*')\n+        # Use specific template file patterns instead of watching all files\n+        # to prevent overwhelming the file watcher when template dirs include project root\n+        template_patterns = ['**/*.html', '**/*.txt', '**/*.xml', '**/*.json']\n+        for pattern in template_patterns:\n+            sender.watch_dir(directory, pattern)\n \n \n @receiver(file_changed, dispatch_uid='template_loaders_file_changed')\ndiff --git a/django/template/backends/base.py b/django/template/backends/base.py\nindex f1fa142362..426c2395f8 100644\n--- a/django/template/backends/base.py\n+++ b/django/template/backends/base.py\n@@ -55,15 +55,60 @@ class BaseEngine:\n     #                  security issues in third-party backends.\n \n     @cached_property\n-    def template_dirs(self):\n-        \"\"\"\n-        Return a list of directories to search for templates.\n-        \"\"\"\n-        # Immutable return value because it's cached and shared by callers.\n-        template_dirs = tuple(self.dirs)\n-        if self.app_dirs:\n-            template_dirs += get_app_template_dirs(self.app_dirname)\n-        return template_dirs\n+\n+@cached_property\n+def template_dirs(self):\n+    \"\"\"\n+    Return a list of directories to search for templates.\n+    \"\"\"\n+    # Immutable return value because it's cached and shared by callers.\n+    template_dirs = tuple(self.dirs)\n+    if self.app_dirs:\n+        template_dirs += get_app_template_dirs(self.app_dirname)\n+    \n+    # Validate template directories to warn about potential performance issues\n+    validated_dirs = []\n+    for template_dir in template_dirs:\n+        # Check if this directory looks like a Django project root\n+        if self._is_likely_project_root(template_dir):\n+            import warnings\n+            warnings.warn(\n+                f\"Template directory '{template_dir}' appears to be a Django project root. \"\n+                \"This may cause performance issues with auto-reload. Consider using a \"\n+                \"specific subdirectory for templates instead.\",\n+                UserWarning,\n+                stacklevel=2\n+            )\n+        validated_dirs.append(template_dir)\n+    \n+    return tuple(validated_dirs)\n+\n+def _is_likely_project_root(self, directory):\n+    \"\"\"\n+    Check if a directory is likely a Django project root by looking for\n+    common Django project files.\n+    \"\"\"\n+    import os\n+    if not os.path.isdir(directory):\n+        return False\n+    \n+    project_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n+    for indicator in project_indicators:\n+        if os.path.exists(os.path.join(directory, indicator)):\n+            return True\n+    \n+    # Also check for settings module in subdirectories\n+    try:\n+        for item in os.listdir(directory):\n+            item_path = os.path.join(directory, item)\n+            if os.path.isdir(item_path):\n+                settings_path = os.path.join(item_path, 'settings.py')\n+                if os.path.exists(settings_path):\n+                    return True\n+    except (OSError, PermissionError):\n+        pass\n+    \n+    return False\n \n     def iter_template_filenames(self, template_name):\n         \"\"\"\ndiff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 583c2be647..9f1de751ca 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -162,6 +162,8 @@ def iter_modules_and_files(modules, extra_files):\n     return frozenset(results)\n \n \n+@functools.lru_cache(maxsize=1)\n+\n @functools.lru_cache(maxsize=1)\n def common_roots(paths):\n     \"\"\"\n@@ -188,16 +190,58 @@ def common_roots(paths):\n         for prefix, child in node.items():\n             yield from _walk(child, path + (prefix,))\n         if not node:\n-            yield Path(*path)\n+            candidate_path = Path(*path)\n+            # Skip directories that might be too broad to watch efficiently\n+            # Check if this looks like a project root by detecting common Django files\n+            if _is_project_root_directory(candidate_path):\n+                # For project roots, only yield if there are no more specific paths\n+                # This prevents watching entire project directories when more specific\n+                # template directories are available\n+                has_more_specific = any(\n+                    other_path != candidate_path and candidate_path in other_path.parents\n+                    for other_path in paths\n+                )\n+                if not has_more_specific:\n+                    yield candidate_path\n+            else:\n+                yield candidate_path\n \n     return tuple(_walk(tree, ()))\n \n \n-def sys_path_directories():\n+def _is_project_root_directory(path):\n     \"\"\"\n-    Yield absolute directories from sys.path, ignoring entries that don't\n-    exist.\n+    Check if a directory looks like a Django project root.\n+    Project roots typically contain manage.py, settings files, or other Django markers.\n     \"\"\"\n+    if not path.is_dir():\n+        return False\n+    \n+    # Check for common Django project files\n+    django_markers = ['manage.py', 'wsgi.py', 'asgi.py']\n+    settings_patterns = ['settings.py', 'settings']\n+    \n+    try:\n+        dir_contents = [item.name for item in path.iterdir()]\n+        \n+        # Look for manage.py or other Django markers\n+        if any(marker in dir_contents for marker in django_markers):\n+            return True\n+            \n+        # Look for settings files/directories\n+        if any(pattern in dir_contents for pattern in settings_patterns):\n+            return True\n+            \n+        # Check if this directory has many subdirectories (characteristic of project root)\n+        subdirs = [item for item in path.iterdir() if item.is_dir()]\n+        if len(subdirs) > 5:  # Arbitrary threshold for \"many\" directories\n+            return True\n+            \n+    except (OSError, PermissionError):\n+        # If we can't read the directory, assume it's not a project root\n+        pass\n+        \n+    return False\n     for path in sys.path:\n         path = Path(path)\n         if not path.exists():\n",
    "variant_7": "diff --git a/django/template/autoreload.py b/django/template/autoreload.py\nindex cf1b20ba95..9bf001a256 100644\n--- a/django/template/autoreload.py\n+++ b/django/template/autoreload.py\n@@ -9,27 +9,14 @@ from django.utils.autoreload import (\n )\n \n \n-def get_template_directories():\n-    # Iterate through each template backend and find\n-    # any template_loader that has a 'get_dirs' method.\n-    # Collect the directories, filtering out Django templates.\n-    cwd = Path.cwd()\n-    items = set()\n-    for backend in engines.all():\n-        if not isinstance(backend, DjangoTemplates):\n-            continue\n-\n-        items.update(cwd / to_path(dir) for dir in backend.engine.dirs)\n \n-        for loader in backend.engine.template_loaders:\n-            if not hasattr(loader, 'get_dirs'):\n-                continue\n-            items.update(\n-                cwd / to_path(directory)\n-                for directory in loader.get_dirs()\n-                if not is_django_path(directory)\n-            )\n-    return items\n+def watch_for_template_changes():\n+    for directory in get_template_directories():\n+        # Only watch for template file extensions to avoid overwhelming\n+        # the file watcher when template directories include large trees\n+        template_patterns = ['**/*.html', '**/*.txt', '**/*.xml', '**/*.htm']\n+        for pattern in template_patterns:\n+            watch_file(directory / pattern)\n \n \n def reset_loaders():\n@@ -40,10 +27,15 @@ def reset_loaders():\n             loader.reset()\n \n \n+\n @receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n def watch_for_template_changes(sender, **kwargs):\n     for directory in get_template_directories():\n-        sender.watch_dir(directory, '**/*')\n+        # Use specific template file patterns instead of watching all files\n+        # to prevent overwhelming the file watcher when large directories are included\n+        template_patterns = ['**/*.html', '**/*.txt', '**/*.xml', '**/*.htm']\n+        for pattern in template_patterns:\n+            sender.watch_dir(directory, pattern)\n \n \n @receiver(file_changed, dispatch_uid='template_loaders_file_changed')\ndiff --git a/django/template/backends/base.py b/django/template/backends/base.py\nindex f1fa142362..65c28efd09 100644\n--- a/django/template/backends/base.py\n+++ b/django/template/backends/base.py\n@@ -55,15 +55,35 @@ class BaseEngine:\n     #                  security issues in third-party backends.\n \n     @cached_property\n-    def template_dirs(self):\n-        \"\"\"\n-        Return a list of directories to search for templates.\n-        \"\"\"\n-        # Immutable return value because it's cached and shared by callers.\n-        template_dirs = tuple(self.dirs)\n-        if self.app_dirs:\n-            template_dirs += get_app_template_dirs(self.app_dirname)\n-        return template_dirs\n+\n+@cached_property\n+def template_dirs(self):\n+    \"\"\"\n+    Return a list of directories to search for templates.\n+    \"\"\"\n+    # Immutable return value because it's cached and shared by callers.\n+    template_dirs = tuple(self.dirs)\n+    if self.app_dirs:\n+        template_dirs += get_app_template_dirs(self.app_dirname)\n+    \n+    # Warn if project root directories are included in template dirs\n+    # as this can cause performance issues with auto-reload\n+    import os\n+    import warnings\n+    for template_dir in template_dirs:\n+        if os.path.isdir(template_dir):\n+            # Check if this directory contains Django project indicators\n+            potential_project_files = ['manage.py', 'settings.py', 'wsgi.py']\n+            if any(os.path.exists(os.path.join(template_dir, f)) for f in potential_project_files):\n+                warnings.warn(\n+                    f\"Template directory '{template_dir}' appears to be a Django project root. \"\n+                    f\"This may cause performance issues with auto-reload. Consider using a \"\n+                    f\"subdirectory like '{os.path.join(template_dir, 'templates')}' instead.\",\n+                    RuntimeWarning,\n+                    stacklevel=2\n+                )\n+    \n+    return template_dirs\n \n     def iter_template_filenames(self, template_name):\n         \"\"\"\ndiff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 583c2be647..113287501f 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -162,6 +162,8 @@ def iter_modules_and_files(modules, extra_files):\n     return frozenset(results)\n \n \n+@functools.lru_cache(maxsize=1)\n+\n @functools.lru_cache(maxsize=1)\n def common_roots(paths):\n     \"\"\"\n@@ -188,16 +190,37 @@ def common_roots(paths):\n         for prefix, child in node.items():\n             yield from _walk(child, path + (prefix,))\n         if not node:\n-            yield Path(*path)\n+            root_path = Path(*path)\n+            # Skip directories that are likely to be too broad for efficient watching\n+            if _is_overly_broad_directory(root_path):\n+                logger.debug('Skipping overly broad directory for watching: %s', root_path)\n+                continue\n+            yield root_path\n \n     return tuple(_walk(tree, ()))\n \n \n-def sys_path_directories():\n+def _is_overly_broad_directory(path):\n     \"\"\"\n-    Yield absolute directories from sys.path, ignoring entries that don't\n-    exist.\n+    Check if a directory is likely to contain too many files for efficient watching.\n+    This helps prevent watching project root directories that would overwhelm the file watcher.\n     \"\"\"\n+    try:\n+        # Check if this looks like a Django project root\n+        if (path / 'manage.py').exists() or (path / 'settings.py').exists():\n+            return True\n+        \n+        # Check if directory has an excessive number of immediate subdirectories\n+        # This is a heuristic to avoid watching directories with many subdirectories\n+        subdir_count = sum(1 for item in path.iterdir() if item.is_dir())\n+        if subdir_count > 50:  # Arbitrary threshold\n+            return True\n+            \n+    except (OSError, PermissionError):\n+        # If we can't read the directory, it's safer to skip it\n+        return True\n+    \n+    return False\n     for path in sys.path:\n         path = Path(path)\n         if not path.exists():\n",
    "variant_8": "diff --git a/django/template/autoreload.py b/django/template/autoreload.py\nindex cf1b20ba95..7c40a75c59 100644\n--- a/django/template/autoreload.py\n+++ b/django/template/autoreload.py\n@@ -9,6 +9,7 @@ from django.utils.autoreload import (\n )\n \n \n+\n def get_template_directories():\n     # Iterate through each template backend and find\n     # any template_loader that has a 'get_dirs' method.\n@@ -19,7 +20,13 @@ def get_template_directories():\n         if not isinstance(backend, DjangoTemplates):\n             continue\n \n-        items.update(cwd / to_path(dir) for dir in backend.engine.dirs)\n+        # Filter out directories that are likely project roots to prevent\n+        # excessive file watching that can break auto-reload\n+        for dir in backend.engine.dirs:\n+            dir_path = cwd / to_path(dir)\n+            # Skip directories that contain Django project markers (likely project root)\n+            if not _is_project_root(dir_path):\n+                items.add(dir_path)\n \n         for loader in backend.engine.template_loaders:\n             if not hasattr(loader, 'get_dirs'):\n@@ -27,11 +34,24 @@ def get_template_directories():\n             items.update(\n                 cwd / to_path(directory)\n                 for directory in loader.get_dirs()\n-                if not is_django_path(directory)\n+                if not is_django_path(directory) and not _is_project_root(cwd / to_path(directory))\n             )\n     return items\n \n \n+def _is_project_root(path):\n+    \"\"\"Check if a directory is likely a Django project root.\"\"\"\n+    try:\n+        path = Path(path)\n+        if not path.is_dir():\n+            return False\n+        # Check for common Django project files\n+        django_markers = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n+        return any((path / marker).exists() for marker in django_markers)\n+    except (OSError, ValueError):\n+        return False\n+\n+\n def reset_loaders():\n     for backend in engines.all():\n         if not isinstance(backend, DjangoTemplates):\n@@ -40,10 +60,15 @@ def reset_loaders():\n             loader.reset()\n \n \n+\n @receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n def watch_for_template_changes(sender, **kwargs):\n     for directory in get_template_directories():\n-        sender.watch_dir(directory, '**/*')\n+        # Use specific template file patterns instead of watching all files\n+        # to prevent overwhelming the file watcher when template dirs include\n+        # project root or other large directories\n+        for pattern in ['**/*.html', '**/*.txt', '**/*.xml', '**/*.htm']:\n+            sender.watch_dir(directory, pattern)\n \n \n @receiver(file_changed, dispatch_uid='template_loaders_file_changed')\ndiff --git a/django/template/backends/base.py b/django/template/backends/base.py\nindex f1fa142362..496dcb26a0 100644\n--- a/django/template/backends/base.py\n+++ b/django/template/backends/base.py\n@@ -55,15 +55,51 @@ class BaseEngine:\n     #                  security issues in third-party backends.\n \n     @cached_property\n-    def template_dirs(self):\n-        \"\"\"\n-        Return a list of directories to search for templates.\n-        \"\"\"\n-        # Immutable return value because it's cached and shared by callers.\n-        template_dirs = tuple(self.dirs)\n-        if self.app_dirs:\n-            template_dirs += get_app_template_dirs(self.app_dirname)\n-        return template_dirs\n+\n+@cached_property\n+def template_dirs(self):\n+    \"\"\"\n+    Return a list of directories to search for templates.\n+    \"\"\"\n+    # Immutable return value because it's cached and shared by callers.\n+    template_dirs = tuple(self.dirs)\n+    if self.app_dirs:\n+        template_dirs += get_app_template_dirs(self.app_dirname)\n+    \n+    # Validate template directories to prevent performance issues\n+    validated_dirs = []\n+    for template_dir in template_dirs:\n+        # Check if directory looks like a Django project root\n+        if self._is_likely_project_root(template_dir):\n+            import warnings\n+            warnings.warn(\n+                f\"Template directory '{template_dir}' appears to be a Django project root. \"\n+                \"This may cause performance issues with auto-reload. Consider using a \"\n+                \"subdirectory like 'templates/' instead.\",\n+                UserWarning,\n+                stacklevel=2\n+            )\n+        validated_dirs.append(template_dir)\n+    \n+    return tuple(validated_dirs)\n+\n+def _is_likely_project_root(self, directory):\n+    \"\"\"\n+    Check if a directory is likely a Django project root by looking for common files.\n+    \"\"\"\n+    try:\n+        import os\n+        common_files = ['manage.py', 'settings.py']\n+        common_dirs = ['static', 'media', 'templates']\n+        \n+        files_in_dir = os.listdir(directory)\n+        has_manage = 'manage.py' in files_in_dir\n+        has_settings = any(f for f in files_in_dir if f.endswith('settings.py'))\n+        has_common_dirs = sum(1 for d in common_dirs if d in files_in_dir) >= 2\n+        \n+        return has_manage or (has_settings and has_common_dirs)\n+    except (OSError, TypeError):\n+        return False\n \n     def iter_template_filenames(self, template_name):\n         \"\"\"\ndiff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 583c2be647..4a1824df50 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -162,6 +162,8 @@ def iter_modules_and_files(modules, extra_files):\n     return frozenset(results)\n \n \n+@functools.lru_cache(maxsize=1)\n+\n @functools.lru_cache(maxsize=1)\n def common_roots(paths):\n     \"\"\"\n@@ -188,7 +190,47 @@ def common_roots(paths):\n         for prefix, child in node.items():\n             yield from _walk(child, path + (prefix,))\n         if not node:\n-            yield Path(*path)\n+            candidate_path = Path(*path)\n+            # Skip directories that are likely to be project roots or too broad\n+            # Check if this directory contains Django project indicators\n+            if _is_likely_project_root(candidate_path):\n+                # If it's a project root, don't watch it as a common root\n+                # Instead, let individual files/subdirs be watched separately\n+                return\n+            yield candidate_path\n+\n+    def _is_likely_project_root(path):\n+        \"\"\"Check if a directory appears to be a Django project root.\"\"\"\n+        try:\n+            # Common Django project files that indicate a project root\n+            django_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n+            common_dirs = ['static', 'media', 'templates', 'locale']\n+            \n+            # Check for Django project indicators\n+            for indicator in django_indicators:\n+                if (path / indicator).exists():\n+                    return True\n+                    \n+            # Check if it contains multiple common Django directories\n+            found_dirs = sum(1 for d in common_dirs if (path / d).exists())\n+            if found_dirs >= 2:\n+                return True\n+                \n+            # Check if the path has an excessive number of subdirectories\n+            # This prevents watching very broad directory trees\n+            try:\n+                subdir_count = sum(1 for item in path.iterdir() if item.is_dir())\n+                if subdir_count > 20:  # Arbitrary threshold for \"too many subdirs\"\n+                    return True\n+            except (OSError, PermissionError):\n+                # If we can't read the directory, it's safer to skip it\n+                return True\n+                \n+        except (OSError, PermissionError):\n+            # If we can't access the path, err on the side of caution\n+            return True\n+            \n+        return False\n \n     return tuple(_walk(tree, ()))\n \n"
  }
}