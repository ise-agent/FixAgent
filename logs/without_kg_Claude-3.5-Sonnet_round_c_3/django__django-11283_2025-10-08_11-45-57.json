{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/django/django/contrib/auth/migrations/0011_update_proxy_permissions.py lines 27-30)": "\n        # Find permissions that would conflict with the target content_type\n        conflicting_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        )\n        \n        # Delete conflicting permissions to avoid unique constraint violation\n        conflicting_permissions.delete()\n        \n        # Now safely update the remaining permissions\n        Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        ).update(content_type=new_content_type)\n",
    "Location 2 (/root/hy/projects_3/django/django/contrib/auth/migrations/0011_update_proxy_permissions.py lines 23-26)": "\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that need to be updated\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Find conflicting permissions that already exist for new_content_type\n        conflicting_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        )\n        \n        # Delete conflicting permissions to avoid unique constraint violation\n        conflicting_permissions.delete()\n        \n        # Now safely update the remaining permissions\n        permissions_to_update.update(content_type=new_content_type)\n",
    "Location 3 (/root/hy/projects_3/django/django/contrib/auth/migrations/0011_update_proxy_permissions.py lines 20-22)": "\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            if codename and name:\n                permissions_query = permissions_query | Q(codename=codename, name=name)\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Find permissions that would cause conflicts after update\n        conflicting_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        )\n        \n        # Delete conflicting permissions to avoid unique constraint violation\n        conflicting_permissions.delete()\n        \n        # Now safely update the remaining permissions\n        Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        ).update(content_type=new_content_type)\n",
    "Location 4 (/root/hy/projects_3/django/django/contrib/auth/models.py lines 69-69)": "\n        unique_together = (('content_type', 'codename'),)\n",
    "Location 5 (/root/hy/projects_3/django/tests/auth_tests/test_migrations.py lines 26-26)": "\n        Permission.objects.filter(content_type__in=[self.concrete_content_type]).delete()\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/django/django/contrib/auth/migrations/0011_update_proxy_permissions.py lines 27-30)": [
      "\n        # Handle potential conflicts by deleting existing permissions for target content type\n        conflicting_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        )\n        conflicting_permissions.delete()\n        \n        # Now safely update the remaining permissions\n        Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        ).update(content_type=new_content_type)\n",
      "\n        # Find conflicting permissions that already exist for new_content_type\n        conflicting_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        )\n        \n        # Delete conflicting permissions to avoid unique constraint violation\n        conflicting_permissions.delete()\n        \n        # Now safely update the remaining permissions\n        Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        ).update(content_type=new_content_type)\n",
      "\n        # Find conflicting permissions that already exist for new_content_type\n        conflicting_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        )\n        \n        # Delete conflicting permissions to avoid unique constraint violation\n        conflicting_permissions.delete()\n        \n        # Now safely update the remaining permissions\n        Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        ).update(content_type=new_content_type)\n",
      "\n        # Find conflicting permissions that already exist for new_content_type\n        conflicting_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        )\n        \n        # Delete conflicting permissions to avoid unique constraint violation\n        conflicting_permissions.delete()\n        \n        # Now safely update the remaining permissions\n        Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        ).update(content_type=new_content_type)\n",
      "\n        # Find permissions that would conflict after the update\n        conflicting_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        )\n        \n        # Delete conflicting permissions to avoid unique constraint violation\n        conflicting_permissions.delete()\n        \n        # Now safely update the remaining permissions\n        Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        ).update(content_type=new_content_type)\n",
      "\n        # Find permissions that would conflict if updated\n        conflicting_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        )\n        \n        # Delete conflicting permissions to avoid unique constraint violation\n        conflicting_permissions.delete()\n        \n        # Now safely update the remaining permissions\n        Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        ).update(content_type=new_content_type)\n",
      "\n        # Find permissions that would conflict after the update\n        conflicting_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        )\n        \n        # Delete conflicting permissions to avoid unique constraint violation\n        conflicting_permissions.delete()\n        \n        # Now safely update the remaining permissions\n        Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        ).update(content_type=new_content_type)\n",
      "\n        # Find permissions that would conflict after the update\n        conflicting_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        )\n        \n        # Delete conflicting permissions to avoid unique constraint violation\n        conflicting_permissions.delete()\n        \n        # Now safely update the remaining permissions\n        Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        ).update(content_type=new_content_type)\n"
    ],
    "Location 2 (/root/hy/projects_3/django/django/contrib/auth/migrations/0011_update_proxy_permissions.py lines 23-26)": [
      "\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that need to be updated\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Find and delete conflicting permissions that already exist for new_content_type\n        conflicting_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        )\n        conflicting_permissions.delete()\n        \n        # Now safely update the remaining permissions\n        permissions_to_update.update(content_type=new_content_type)\n",
      "\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that need to be updated\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Find and delete conflicting permissions that already exist for new_content_type\n        # to avoid unique constraint violation on (content_type, codename)\n        conflicting_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        )\n        conflicting_permissions.delete()\n        \n        # Now safely update the remaining permissions\n        permissions_to_update.update(content_type=new_content_type)\n",
      "\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions to update\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Find and delete conflicting permissions that already exist for new_content_type\n        # to avoid unique constraint violation on (content_type, codename)\n        conflicting_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        )\n        conflicting_permissions.delete()\n        \n        # Now safely update the remaining permissions\n        permissions_to_update.update(content_type=new_content_type)\n",
      "\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that need to be updated\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Find and delete conflicting permissions that already exist for new_content_type\n        # to avoid unique constraint violation on (content_type, codename)\n        conflicting_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        )\n        conflicting_permissions.delete()\n        \n        # Now safely update the remaining permissions\n        permissions_to_update.update(content_type=new_content_type)\n",
      "\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that need to be updated\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Find and delete conflicting permissions that already exist for new_content_type\n        conflicting_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        )\n        conflicting_permissions.delete()\n        \n        # Now safely update the remaining permissions\n        permissions_to_update.update(content_type=new_content_type)\n",
      "\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that need to be updated\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Find conflicting permissions that already exist for new_content_type\n        conflicting_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        )\n        \n        # Delete conflicting permissions to avoid unique constraint violation\n        conflicting_permissions.delete()\n        \n        # Now safely update the remaining permissions\n        permissions_to_update.update(content_type=new_content_type)\n",
      "\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that need to be updated\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Find conflicting permissions that already exist for new_content_type\n        conflicting_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        )\n        \n        # Delete conflicting permissions to avoid unique constraint violation\n        conflicting_permissions.delete()\n        \n        # Now safely update the remaining permissions\n        permissions_to_update.update(content_type=new_content_type)\n",
      "\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that need to be updated\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Find and delete conflicting permissions that already exist for new_content_type\n        # to avoid unique constraint violation on (content_type, codename)\n        conflicting_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        )\n        conflicting_permissions.delete()\n        \n        # Now safely update the remaining permissions\n        permissions_to_update.update(content_type=new_content_type)\n"
    ],
    "Location 3 (/root/hy/projects_3/django/django/contrib/auth/migrations/0011_update_proxy_permissions.py lines 20-22)": [
      "\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            if codename and name:\n                permissions_query = permissions_query | Q(codename=codename, name=name)\n        \n        try:\n            concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n            proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        except ContentType.DoesNotExist:\n            continue\n            \n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Find permissions that would cause conflicts and delete them first\n        conflicting_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        )\n        conflicting_permissions.delete()\n        \n        # Now safely update the remaining permissions\n        Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        ).update(content_type=new_content_type)\n",
      "\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            if codename and name:\n                permissions_query = permissions_query | Q(codename=codename, name=name)\n        \n        try:\n            concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n            proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        except ContentType.DoesNotExist:\n            continue\n            \n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Find conflicting permissions that already exist for new_content_type\n        conflicting_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        )\n        \n        # Delete conflicting permissions to avoid unique constraint violation\n        conflicting_permissions.delete()\n        \n        # Now safely update the remaining permissions\n        Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        ).update(content_type=new_content_type)\n",
      "\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            if codename and name:\n                permissions_query = permissions_query | Q(codename=codename, name=name)\n        \n        try:\n            concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n            proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        except ContentType.DoesNotExist:\n            continue\n            \n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        conflicting_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        )\n        \n        conflicting_permissions.delete()\n        permissions_to_update.update(content_type=new_content_type)\n",
      "\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            if codename and name:\n                permissions_query = permissions_query | Q(codename=codename, name=name)\n        \n        try:\n            concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n            proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        except ContentType.DoesNotExist:\n            continue\n            \n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Find permissions to update\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Find and delete conflicting permissions that already exist for new_content_type\n        conflicting_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        )\n        conflicting_permissions.delete()\n        \n        # Now safely update the remaining permissions\n        permissions_to_update.update(content_type=new_content_type)\n",
      "\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            if codename and name:\n                permissions_query = permissions_query | Q(codename=codename, name=name)\n        \n        try:\n            concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n            proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        except ContentType.DoesNotExist:\n            continue\n            \n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Find permissions that would cause conflicts and delete them first\n        conflicting_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        )\n        conflicting_permissions.delete()\n        \n        # Now safely update the remaining permissions\n        Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        ).update(content_type=new_content_type)\n",
      "\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            if codename and name:\n                permissions_query = permissions_query | Q(codename=codename, name=name)\n        \n        try:\n            concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n            proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        except ContentType.DoesNotExist:\n            continue\n            \n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Find permissions that would cause conflicts after update\n        conflicting_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        )\n        \n        # Delete conflicting permissions to avoid unique constraint violation\n        conflicting_permissions.delete()\n        \n        # Now safely update the remaining permissions\n        Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        ).update(content_type=new_content_type)\n",
      "\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            if codename and name:\n                permissions_query = permissions_query | Q(codename=codename, name=name)\n",
      "\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            if codename and name:\n                permissions_query = permissions_query | Q(codename=codename, name=name)\n        \n        try:\n            concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n            proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        except ContentType.DoesNotExist:\n            continue\n            \n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Find permissions to update\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Find conflicting permissions that already exist for new_content_type\n        conflicting_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        )\n        \n        # Delete conflicting permissions to avoid unique constraint violation\n        conflicting_permissions.delete()\n        \n        # Now safely update the remaining permissions\n        permissions_to_update.update(content_type=new_content_type)\n"
    ],
    "Location 4 (/root/hy/projects_3/django/django/contrib/auth/models.py lines 69-69)": [
      "\n        unique_together = (('content_type', 'codename'),)\n",
      "\n        unique_together = [['content_type', 'codename']]\n",
      "\n        unique_together = [('content_type', 'codename')]\n",
      "\n        unique_together = [['content_type', 'codename']]\n",
      "\n        unique_together = (('content_type', 'codename'),)\n",
      "\n        unique_together = (('content_type', 'codename'),)\n",
      "\n        unique_together = (('content_type', 'codename'),)\n",
      "\n        unique_together = (('content_type', 'codename'),)\n"
    ],
    "Location 5 (/root/hy/projects_3/django/tests/auth_tests/test_migrations.py lines 26-26)": [
      "\n        Permission.objects.filter(\n            content_type=ContentType.objects.get_for_model(UserProxy, for_concrete_model=False),\n            codename='add_userproxy'\n        ).delete()\n",
      "\n        Permission.objects.filter(\n            content_type=ContentType.objects.get_for_model(UserProxy, for_concrete_model=False)\n        ).delete()\n",
      "\n        Permission.objects.filter(\n            content_type=ContentType.objects.get_for_model(UserProxy, for_concrete_model=False)\n        ).delete()\n",
      "\n        Permission.objects.filter(\n            content_type=ContentType.objects.get_for_model(UserProxy, for_concrete_model=False)\n        ).delete()\n",
      "\n        Permission.objects.filter(\n            content_type__in=ContentType.objects.filter(\n                app_label='auth_tests',\n                model='userproxy'\n            )\n        ).delete()\n",
      "\n        Permission.objects.filter(\n            content_type=ContentType.objects.get_for_model(UserProxy, for_concrete_model=False)\n        ).delete()\n",
      "\n        Permission.objects.filter(\n            content_type=ContentType.objects.get_for_model(UserProxy, for_concrete_model=False),\n            codename='add_userproxy'\n        ).delete()\n",
      "\n        Permission.objects.filter(\n            content_type=ContentType.objects.get_for_model(UserProxy, for_concrete_model=False)\n        ).delete()\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/contrib/auth/migrations/0011_update_proxy_permissions.py b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\nindex 0e66649695..9874489d51 100644\n--- a/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n+++ b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n@@ -17,17 +17,39 @@ def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n             '%s_%s' % (action, opts.model_name)\n             for action in opts.default_permissions\n         ]\n+\n         permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n         for codename, name in opts.permissions:\n-            permissions_query = permissions_query | Q(codename=codename, name=name)\n-        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n-        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n+            # Ensure we only process valid permission combinations\n+            if codename and name:\n+                permissions_query = permissions_query | Q(codename=codename, name=name)\n+\n+        try:\n+            concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n+            proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n+        except ContentType.DoesNotExist:\n+            # Skip if ContentTypes are not properly configured\n+            continue\n         old_content_type = proxy_content_type if reverse else concrete_content_type\n         new_content_type = concrete_content_type if reverse else proxy_content_type\n-        Permission.objects.filter(\n+\n+        # Handle conflicting permissions to avoid unique constraint violation\n+        permissions_to_update = Permission.objects.filter(\n             permissions_query,\n             content_type=old_content_type,\n-        ).update(content_type=new_content_type)\n+        )\n+\n+        # Find conflicting permissions that already exist for new_content_type\n+        conflicting_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        )\n+\n+        # Delete conflicting permissions to avoid unique constraint violation\n+        conflicting_permissions.delete()\n+\n+        # Now safely update the remaining permissions\n+        permissions_to_update.update(content_type=new_content_type)\n \n \n def revert_proxy_model_permissions(apps, schema_editor):\ndiff --git a/django/contrib/auth/models.py b/django/contrib/auth/models.py\nindex 324faa6f3e..2c8e8bb02f 100644\n--- a/django/contrib/auth/models.py\n+++ b/django/contrib/auth/models.py\n@@ -66,6 +66,7 @@ class Permission(models.Model):\n     class Meta:\n         verbose_name = _('permission')\n         verbose_name_plural = _('permissions')\n+\n         unique_together = (('content_type', 'codename'),)\n         ordering = ('content_type__app_label', 'content_type__model',\n                     'codename')\ndiff --git a/tests/auth_tests/test_migrations.py b/tests/auth_tests/test_migrations.py\nindex 5ff2f6b4b3..219360f741 100644\n--- a/tests/auth_tests/test_migrations.py\n+++ b/tests/auth_tests/test_migrations.py\n@@ -23,7 +23,28 @@ class ProxyModelWithDifferentAppLabelTests(TestCase):\n         rather than the proxy model (as they were before Django 2.2 and\n         migration 11).\n         \"\"\"\n+\n         Permission.objects.all().delete()\n+        \n+    def test_migration_with_existing_proxy_permissions(self):\n+        \"\"\"Test migration when permissions already exist for both concrete and proxy models.\"\"\"\n+        # Don't delete existing permissions - test the real scenario\n+        proxy_content_type = ContentType.objects.get_for_model(UserProxy, for_concrete_model=False)\n+        \n+        # Create conflicting permission that already exists for proxy model\n+        Permission.objects.create(\n+            content_type=proxy_content_type,\n+            codename='add_userproxy',\n+            name='Can add userproxy',\n+        )\n+        \n+        # This should not fail with IntegrityError\n+        update_proxy_permissions.update_proxy_model_permissions(apps, None)\n+        \n+        # Verify the migration handled the conflict correctly\n+        remaining_permissions = Permission.objects.filter(codename='add_userproxy')\n+        self.assertEqual(remaining_permissions.count(), 1)\n+        self.assertEqual(remaining_permissions.first().content_type, proxy_content_type)\n         self.concrete_content_type = ContentType.objects.get_for_model(UserProxy)\n         self.default_permission = Permission.objects.create(\n             content_type=self.concrete_content_type,\n",
    "variant_0": "diff --git a/django/contrib/auth/migrations/0011_update_proxy_permissions.py b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\nindex 0e66649695..57a673cb86 100644\n--- a/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n+++ b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n@@ -17,13 +17,64 @@ def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n             '%s_%s' % (action, opts.model_name)\n             for action in opts.default_permissions\n         ]\n+\n         permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n         for codename, name in opts.permissions:\n-            permissions_query = permissions_query | Q(codename=codename, name=name)\n+            if codename and name:\n+                permissions_query = permissions_query | Q(codename=codename, name=name)\n+        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n+        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n+        old_content_type = proxy_content_type if reverse else concrete_content_type\n+        new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Find permissions that would cause conflicts after update\n+        conflicting_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        )\n+        \n+        # Delete conflicting permissions to avoid unique constraint violation\n+        conflicting_permissions.delete()\n+        \n+        # Now safely update the remaining permissions\n+        Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        ).update(content_type=new_content_type)\n+\n         concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n         proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n         old_content_type = proxy_content_type if reverse else concrete_content_type\n         new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions that need to be updated\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Find conflicting permissions that already exist for new_content_type\n+        conflicting_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        )\n+        \n+        # Delete conflicting permissions to avoid unique constraint violation\n+        conflicting_permissions.delete()\n+        \n+        # Now safely update the remaining permissions\n+        permissions_to_update.update(content_type=new_content_type)\n+\n+        # Find permissions that would conflict with the target content_type\n+        conflicting_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        )\n+        \n+        # Delete conflicting permissions to avoid unique constraint violation\n+        conflicting_permissions.delete()\n+        \n+        # Now safely update the remaining permissions\n         Permission.objects.filter(\n             permissions_query,\n             content_type=old_content_type,\ndiff --git a/django/contrib/auth/models.py b/django/contrib/auth/models.py\nindex 324faa6f3e..2c8e8bb02f 100644\n--- a/django/contrib/auth/models.py\n+++ b/django/contrib/auth/models.py\n@@ -66,6 +66,7 @@ class Permission(models.Model):\n     class Meta:\n         verbose_name = _('permission')\n         verbose_name_plural = _('permissions')\n+\n         unique_together = (('content_type', 'codename'),)\n         ordering = ('content_type__app_label', 'content_type__model',\n                     'codename')\ndiff --git a/tests/auth_tests/test_migrations.py b/tests/auth_tests/test_migrations.py\nindex 5ff2f6b4b3..8fb02e8131 100644\n--- a/tests/auth_tests/test_migrations.py\n+++ b/tests/auth_tests/test_migrations.py\n@@ -23,7 +23,8 @@ class ProxyModelWithDifferentAppLabelTests(TestCase):\n         rather than the proxy model (as they were before Django 2.2 and\n         migration 11).\n         \"\"\"\n-        Permission.objects.all().delete()\n+\n+        Permission.objects.filter(content_type__in=[self.concrete_content_type]).delete()\n         self.concrete_content_type = ContentType.objects.get_for_model(UserProxy)\n         self.default_permission = Permission.objects.create(\n             content_type=self.concrete_content_type,\n",
    "variant_1": "diff --git a/django/contrib/auth/migrations/0011_update_proxy_permissions.py b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\nindex 0e66649695..d344f37af4 100644\n--- a/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n+++ b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n@@ -17,13 +17,63 @@ def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n             '%s_%s' % (action, opts.model_name)\n             for action in opts.default_permissions\n         ]\n+\n         permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n         for codename, name in opts.permissions:\n-            permissions_query = permissions_query | Q(codename=codename, name=name)\n+            if codename and name:\n+                permissions_query = permissions_query | Q(codename=codename, name=name)\n+        \n+        try:\n+            concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n+            proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n+        except ContentType.DoesNotExist:\n+            continue\n+            \n+        old_content_type = proxy_content_type if reverse else concrete_content_type\n+        new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Find permissions that would cause conflicts and delete them first\n+        conflicting_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        )\n+        conflicting_permissions.delete()\n+        \n+        # Now safely update the remaining permissions\n+        Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        ).update(content_type=new_content_type)\n+\n         concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n         proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n         old_content_type = proxy_content_type if reverse else concrete_content_type\n         new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions that need to be updated\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Find and delete conflicting permissions that already exist for new_content_type\n+        conflicting_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        )\n+        conflicting_permissions.delete()\n+        \n+        # Now safely update the remaining permissions\n+        permissions_to_update.update(content_type=new_content_type)\n+\n+        # Handle potential conflicts by deleting existing permissions for target content type\n+        conflicting_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        )\n+        conflicting_permissions.delete()\n+        \n+        # Now safely update the remaining permissions\n         Permission.objects.filter(\n             permissions_query,\n             content_type=old_content_type,\ndiff --git a/django/contrib/auth/models.py b/django/contrib/auth/models.py\nindex 324faa6f3e..2c8e8bb02f 100644\n--- a/django/contrib/auth/models.py\n+++ b/django/contrib/auth/models.py\n@@ -66,6 +66,7 @@ class Permission(models.Model):\n     class Meta:\n         verbose_name = _('permission')\n         verbose_name_plural = _('permissions')\n+\n         unique_together = (('content_type', 'codename'),)\n         ordering = ('content_type__app_label', 'content_type__model',\n                     'codename')\ndiff --git a/tests/auth_tests/test_migrations.py b/tests/auth_tests/test_migrations.py\nindex 5ff2f6b4b3..46eb4d8777 100644\n--- a/tests/auth_tests/test_migrations.py\n+++ b/tests/auth_tests/test_migrations.py\n@@ -23,7 +23,11 @@ class ProxyModelWithDifferentAppLabelTests(TestCase):\n         rather than the proxy model (as they were before Django 2.2 and\n         migration 11).\n         \"\"\"\n-        Permission.objects.all().delete()\n+\n+        Permission.objects.filter(\n+            content_type=ContentType.objects.get_for_model(UserProxy, for_concrete_model=False),\n+            codename='add_userproxy'\n+        ).delete()\n         self.concrete_content_type = ContentType.objects.get_for_model(UserProxy)\n         self.default_permission = Permission.objects.create(\n             content_type=self.concrete_content_type,\n",
    "variant_2": "diff --git a/django/contrib/auth/migrations/0011_update_proxy_permissions.py b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\nindex 0e66649695..fb7f76cc52 100644\n--- a/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n+++ b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n@@ -17,13 +17,68 @@ def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n             '%s_%s' % (action, opts.model_name)\n             for action in opts.default_permissions\n         ]\n+\n         permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n         for codename, name in opts.permissions:\n-            permissions_query = permissions_query | Q(codename=codename, name=name)\n+            if codename and name:\n+                permissions_query = permissions_query | Q(codename=codename, name=name)\n+        \n+        try:\n+            concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n+            proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n+        except ContentType.DoesNotExist:\n+            continue\n+            \n+        old_content_type = proxy_content_type if reverse else concrete_content_type\n+        new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Find conflicting permissions that already exist for new_content_type\n+        conflicting_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        )\n+        \n+        # Delete conflicting permissions to avoid unique constraint violation\n+        conflicting_permissions.delete()\n+        \n+        # Now safely update the remaining permissions\n+        Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        ).update(content_type=new_content_type)\n+\n         concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n         proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n         old_content_type = proxy_content_type if reverse else concrete_content_type\n         new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions that need to be updated\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Find and delete conflicting permissions that already exist for new_content_type\n+        # to avoid unique constraint violation on (content_type, codename)\n+        conflicting_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        )\n+        conflicting_permissions.delete()\n+        \n+        # Now safely update the remaining permissions\n+        permissions_to_update.update(content_type=new_content_type)\n+\n+        # Find conflicting permissions that already exist for new_content_type\n+        conflicting_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        )\n+        \n+        # Delete conflicting permissions to avoid unique constraint violation\n+        conflicting_permissions.delete()\n+        \n+        # Now safely update the remaining permissions\n         Permission.objects.filter(\n             permissions_query,\n             content_type=old_content_type,\ndiff --git a/django/contrib/auth/models.py b/django/contrib/auth/models.py\nindex 324faa6f3e..384ccbd388 100644\n--- a/django/contrib/auth/models.py\n+++ b/django/contrib/auth/models.py\n@@ -66,7 +66,8 @@ class Permission(models.Model):\n     class Meta:\n         verbose_name = _('permission')\n         verbose_name_plural = _('permissions')\n-        unique_together = (('content_type', 'codename'),)\n+\n+        unique_together = [['content_type', 'codename']]\n         ordering = ('content_type__app_label', 'content_type__model',\n                     'codename')\n \ndiff --git a/tests/auth_tests/test_migrations.py b/tests/auth_tests/test_migrations.py\nindex 5ff2f6b4b3..ea7c0b28ae 100644\n--- a/tests/auth_tests/test_migrations.py\n+++ b/tests/auth_tests/test_migrations.py\n@@ -23,7 +23,10 @@ class ProxyModelWithDifferentAppLabelTests(TestCase):\n         rather than the proxy model (as they were before Django 2.2 and\n         migration 11).\n         \"\"\"\n-        Permission.objects.all().delete()\n+\n+        Permission.objects.filter(\n+            content_type=ContentType.objects.get_for_model(UserProxy, for_concrete_model=False)\n+        ).delete()\n         self.concrete_content_type = ContentType.objects.get_for_model(UserProxy)\n         self.default_permission = Permission.objects.create(\n             content_type=self.concrete_content_type,\n",
    "variant_3": "diff --git a/django/contrib/auth/migrations/0011_update_proxy_permissions.py b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\nindex 0e66649695..b5afba722a 100644\n--- a/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n+++ b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n@@ -17,13 +17,66 @@ def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n             '%s_%s' % (action, opts.model_name)\n             for action in opts.default_permissions\n         ]\n+\n         permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n         for codename, name in opts.permissions:\n-            permissions_query = permissions_query | Q(codename=codename, name=name)\n+            if codename and name:\n+                permissions_query = permissions_query | Q(codename=codename, name=name)\n+        \n+        try:\n+            concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n+            proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n+        except ContentType.DoesNotExist:\n+            continue\n+            \n+        old_content_type = proxy_content_type if reverse else concrete_content_type\n+        new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        conflicting_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        )\n+        \n+        conflicting_permissions.delete()\n+        permissions_to_update.update(content_type=new_content_type)\n+\n         concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n         proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n         old_content_type = proxy_content_type if reverse else concrete_content_type\n         new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions to update\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Find and delete conflicting permissions that already exist for new_content_type\n+        # to avoid unique constraint violation on (content_type, codename)\n+        conflicting_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        )\n+        conflicting_permissions.delete()\n+        \n+        # Now safely update the remaining permissions\n+        permissions_to_update.update(content_type=new_content_type)\n+\n+        # Find conflicting permissions that already exist for new_content_type\n+        conflicting_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        )\n+        \n+        # Delete conflicting permissions to avoid unique constraint violation\n+        conflicting_permissions.delete()\n+        \n+        # Now safely update the remaining permissions\n         Permission.objects.filter(\n             permissions_query,\n             content_type=old_content_type,\ndiff --git a/django/contrib/auth/models.py b/django/contrib/auth/models.py\nindex 324faa6f3e..e6bcfb3246 100644\n--- a/django/contrib/auth/models.py\n+++ b/django/contrib/auth/models.py\n@@ -66,7 +66,8 @@ class Permission(models.Model):\n     class Meta:\n         verbose_name = _('permission')\n         verbose_name_plural = _('permissions')\n-        unique_together = (('content_type', 'codename'),)\n+\n+        unique_together = [('content_type', 'codename')]\n         ordering = ('content_type__app_label', 'content_type__model',\n                     'codename')\n \ndiff --git a/tests/auth_tests/test_migrations.py b/tests/auth_tests/test_migrations.py\nindex 5ff2f6b4b3..ea7c0b28ae 100644\n--- a/tests/auth_tests/test_migrations.py\n+++ b/tests/auth_tests/test_migrations.py\n@@ -23,7 +23,10 @@ class ProxyModelWithDifferentAppLabelTests(TestCase):\n         rather than the proxy model (as they were before Django 2.2 and\n         migration 11).\n         \"\"\"\n-        Permission.objects.all().delete()\n+\n+        Permission.objects.filter(\n+            content_type=ContentType.objects.get_for_model(UserProxy, for_concrete_model=False)\n+        ).delete()\n         self.concrete_content_type = ContentType.objects.get_for_model(UserProxy)\n         self.default_permission = Permission.objects.create(\n             content_type=self.concrete_content_type,\n",
    "variant_4": "diff --git a/django/contrib/auth/migrations/0011_update_proxy_permissions.py b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\nindex 0e66649695..bf903294f3 100644\n--- a/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n+++ b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n@@ -17,13 +17,69 @@ def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n             '%s_%s' % (action, opts.model_name)\n             for action in opts.default_permissions\n         ]\n+\n         permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n         for codename, name in opts.permissions:\n-            permissions_query = permissions_query | Q(codename=codename, name=name)\n+            if codename and name:\n+                permissions_query = permissions_query | Q(codename=codename, name=name)\n+        \n+        try:\n+            concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n+            proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n+        except ContentType.DoesNotExist:\n+            continue\n+            \n+        old_content_type = proxy_content_type if reverse else concrete_content_type\n+        new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Find permissions to update\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Find and delete conflicting permissions that already exist for new_content_type\n+        conflicting_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        )\n+        conflicting_permissions.delete()\n+        \n+        # Now safely update the remaining permissions\n+        permissions_to_update.update(content_type=new_content_type)\n+\n         concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n         proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n         old_content_type = proxy_content_type if reverse else concrete_content_type\n         new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions that need to be updated\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Find and delete conflicting permissions that already exist for new_content_type\n+        # to avoid unique constraint violation on (content_type, codename)\n+        conflicting_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        )\n+        conflicting_permissions.delete()\n+        \n+        # Now safely update the remaining permissions\n+        permissions_to_update.update(content_type=new_content_type)\n+\n+        # Find conflicting permissions that already exist for new_content_type\n+        conflicting_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        )\n+        \n+        # Delete conflicting permissions to avoid unique constraint violation\n+        conflicting_permissions.delete()\n+        \n+        # Now safely update the remaining permissions\n         Permission.objects.filter(\n             permissions_query,\n             content_type=old_content_type,\ndiff --git a/django/contrib/auth/models.py b/django/contrib/auth/models.py\nindex 324faa6f3e..384ccbd388 100644\n--- a/django/contrib/auth/models.py\n+++ b/django/contrib/auth/models.py\n@@ -66,7 +66,8 @@ class Permission(models.Model):\n     class Meta:\n         verbose_name = _('permission')\n         verbose_name_plural = _('permissions')\n-        unique_together = (('content_type', 'codename'),)\n+\n+        unique_together = [['content_type', 'codename']]\n         ordering = ('content_type__app_label', 'content_type__model',\n                     'codename')\n \ndiff --git a/tests/auth_tests/test_migrations.py b/tests/auth_tests/test_migrations.py\nindex 5ff2f6b4b3..ea7c0b28ae 100644\n--- a/tests/auth_tests/test_migrations.py\n+++ b/tests/auth_tests/test_migrations.py\n@@ -23,7 +23,10 @@ class ProxyModelWithDifferentAppLabelTests(TestCase):\n         rather than the proxy model (as they were before Django 2.2 and\n         migration 11).\n         \"\"\"\n-        Permission.objects.all().delete()\n+\n+        Permission.objects.filter(\n+            content_type=ContentType.objects.get_for_model(UserProxy, for_concrete_model=False)\n+        ).delete()\n         self.concrete_content_type = ContentType.objects.get_for_model(UserProxy)\n         self.default_permission = Permission.objects.create(\n             content_type=self.concrete_content_type,\n",
    "variant_5": "diff --git a/django/contrib/auth/migrations/0011_update_proxy_permissions.py b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\nindex 0e66649695..de8b5b187a 100644\n--- a/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n+++ b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n@@ -17,13 +17,65 @@ def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n             '%s_%s' % (action, opts.model_name)\n             for action in opts.default_permissions\n         ]\n+\n         permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n         for codename, name in opts.permissions:\n-            permissions_query = permissions_query | Q(codename=codename, name=name)\n+            if codename and name:\n+                permissions_query = permissions_query | Q(codename=codename, name=name)\n+        \n+        try:\n+            concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n+            proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n+        except ContentType.DoesNotExist:\n+            continue\n+            \n+        old_content_type = proxy_content_type if reverse else concrete_content_type\n+        new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Find permissions that would cause conflicts and delete them first\n+        conflicting_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        )\n+        conflicting_permissions.delete()\n+        \n+        # Now safely update the remaining permissions\n+        Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        ).update(content_type=new_content_type)\n+\n         concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n         proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n         old_content_type = proxy_content_type if reverse else concrete_content_type\n         new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions that need to be updated\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Find and delete conflicting permissions that already exist for new_content_type\n+        conflicting_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        )\n+        conflicting_permissions.delete()\n+        \n+        # Now safely update the remaining permissions\n+        permissions_to_update.update(content_type=new_content_type)\n+\n+        # Find permissions that would conflict after the update\n+        conflicting_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        )\n+        \n+        # Delete conflicting permissions to avoid unique constraint violation\n+        conflicting_permissions.delete()\n+        \n+        # Now safely update the remaining permissions\n         Permission.objects.filter(\n             permissions_query,\n             content_type=old_content_type,\ndiff --git a/django/contrib/auth/models.py b/django/contrib/auth/models.py\nindex 324faa6f3e..2c8e8bb02f 100644\n--- a/django/contrib/auth/models.py\n+++ b/django/contrib/auth/models.py\n@@ -66,6 +66,7 @@ class Permission(models.Model):\n     class Meta:\n         verbose_name = _('permission')\n         verbose_name_plural = _('permissions')\n+\n         unique_together = (('content_type', 'codename'),)\n         ordering = ('content_type__app_label', 'content_type__model',\n                     'codename')\ndiff --git a/tests/auth_tests/test_migrations.py b/tests/auth_tests/test_migrations.py\nindex 5ff2f6b4b3..444572e8fb 100644\n--- a/tests/auth_tests/test_migrations.py\n+++ b/tests/auth_tests/test_migrations.py\n@@ -23,7 +23,13 @@ class ProxyModelWithDifferentAppLabelTests(TestCase):\n         rather than the proxy model (as they were before Django 2.2 and\n         migration 11).\n         \"\"\"\n-        Permission.objects.all().delete()\n+\n+        Permission.objects.filter(\n+            content_type__in=ContentType.objects.filter(\n+                app_label='auth_tests',\n+                model='userproxy'\n+            )\n+        ).delete()\n         self.concrete_content_type = ContentType.objects.get_for_model(UserProxy)\n         self.default_permission = Permission.objects.create(\n             content_type=self.concrete_content_type,\n",
    "variant_6": "diff --git a/django/contrib/auth/migrations/0011_update_proxy_permissions.py b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\nindex 0e66649695..698c5c2efb 100644\n--- a/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n+++ b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n@@ -17,13 +17,69 @@ def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n             '%s_%s' % (action, opts.model_name)\n             for action in opts.default_permissions\n         ]\n+\n         permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n         for codename, name in opts.permissions:\n-            permissions_query = permissions_query | Q(codename=codename, name=name)\n+            if codename and name:\n+                permissions_query = permissions_query | Q(codename=codename, name=name)\n+        \n+        try:\n+            concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n+            proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n+        except ContentType.DoesNotExist:\n+            continue\n+            \n+        old_content_type = proxy_content_type if reverse else concrete_content_type\n+        new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Find permissions that would cause conflicts after update\n+        conflicting_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        )\n+        \n+        # Delete conflicting permissions to avoid unique constraint violation\n+        conflicting_permissions.delete()\n+        \n+        # Now safely update the remaining permissions\n+        Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        ).update(content_type=new_content_type)\n+\n         concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n         proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n         old_content_type = proxy_content_type if reverse else concrete_content_type\n         new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions that need to be updated\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Find conflicting permissions that already exist for new_content_type\n+        conflicting_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        )\n+        \n+        # Delete conflicting permissions to avoid unique constraint violation\n+        conflicting_permissions.delete()\n+        \n+        # Now safely update the remaining permissions\n+        permissions_to_update.update(content_type=new_content_type)\n+\n+        # Find permissions that would conflict if updated\n+        conflicting_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        )\n+        \n+        # Delete conflicting permissions to avoid unique constraint violation\n+        conflicting_permissions.delete()\n+        \n+        # Now safely update the remaining permissions\n         Permission.objects.filter(\n             permissions_query,\n             content_type=old_content_type,\ndiff --git a/django/contrib/auth/models.py b/django/contrib/auth/models.py\nindex 324faa6f3e..2c8e8bb02f 100644\n--- a/django/contrib/auth/models.py\n+++ b/django/contrib/auth/models.py\n@@ -66,6 +66,7 @@ class Permission(models.Model):\n     class Meta:\n         verbose_name = _('permission')\n         verbose_name_plural = _('permissions')\n+\n         unique_together = (('content_type', 'codename'),)\n         ordering = ('content_type__app_label', 'content_type__model',\n                     'codename')\ndiff --git a/tests/auth_tests/test_migrations.py b/tests/auth_tests/test_migrations.py\nindex 5ff2f6b4b3..ea7c0b28ae 100644\n--- a/tests/auth_tests/test_migrations.py\n+++ b/tests/auth_tests/test_migrations.py\n@@ -23,7 +23,10 @@ class ProxyModelWithDifferentAppLabelTests(TestCase):\n         rather than the proxy model (as they were before Django 2.2 and\n         migration 11).\n         \"\"\"\n-        Permission.objects.all().delete()\n+\n+        Permission.objects.filter(\n+            content_type=ContentType.objects.get_for_model(UserProxy, for_concrete_model=False)\n+        ).delete()\n         self.concrete_content_type = ContentType.objects.get_for_model(UserProxy)\n         self.default_permission = Permission.objects.create(\n             content_type=self.concrete_content_type,\n",
    "variant_7": "diff --git a/django/contrib/auth/migrations/0011_update_proxy_permissions.py b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\nindex 0e66649695..7158230ce0 100644\n--- a/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n+++ b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n@@ -17,13 +17,45 @@ def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n             '%s_%s' % (action, opts.model_name)\n             for action in opts.default_permissions\n         ]\n+\n         permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n         for codename, name in opts.permissions:\n-            permissions_query = permissions_query | Q(codename=codename, name=name)\n+            if codename and name:\n+                permissions_query = permissions_query | Q(codename=codename, name=name)\n+\n         concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n         proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n         old_content_type = proxy_content_type if reverse else concrete_content_type\n         new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions that need to be updated\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Find conflicting permissions that already exist for new_content_type\n+        conflicting_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        )\n+        \n+        # Delete conflicting permissions to avoid unique constraint violation\n+        conflicting_permissions.delete()\n+        \n+        # Now safely update the remaining permissions\n+        permissions_to_update.update(content_type=new_content_type)\n+\n+        # Find permissions that would conflict after the update\n+        conflicting_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        )\n+        \n+        # Delete conflicting permissions to avoid unique constraint violation\n+        conflicting_permissions.delete()\n+        \n+        # Now safely update the remaining permissions\n         Permission.objects.filter(\n             permissions_query,\n             content_type=old_content_type,\ndiff --git a/django/contrib/auth/models.py b/django/contrib/auth/models.py\nindex 324faa6f3e..2c8e8bb02f 100644\n--- a/django/contrib/auth/models.py\n+++ b/django/contrib/auth/models.py\n@@ -66,6 +66,7 @@ class Permission(models.Model):\n     class Meta:\n         verbose_name = _('permission')\n         verbose_name_plural = _('permissions')\n+\n         unique_together = (('content_type', 'codename'),)\n         ordering = ('content_type__app_label', 'content_type__model',\n                     'codename')\ndiff --git a/tests/auth_tests/test_migrations.py b/tests/auth_tests/test_migrations.py\nindex 5ff2f6b4b3..46eb4d8777 100644\n--- a/tests/auth_tests/test_migrations.py\n+++ b/tests/auth_tests/test_migrations.py\n@@ -23,7 +23,11 @@ class ProxyModelWithDifferentAppLabelTests(TestCase):\n         rather than the proxy model (as they were before Django 2.2 and\n         migration 11).\n         \"\"\"\n-        Permission.objects.all().delete()\n+\n+        Permission.objects.filter(\n+            content_type=ContentType.objects.get_for_model(UserProxy, for_concrete_model=False),\n+            codename='add_userproxy'\n+        ).delete()\n         self.concrete_content_type = ContentType.objects.get_for_model(UserProxy)\n         self.default_permission = Permission.objects.create(\n             content_type=self.concrete_content_type,\n",
    "variant_8": "diff --git a/django/contrib/auth/migrations/0011_update_proxy_permissions.py b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\nindex 0e66649695..ab2912ebe1 100644\n--- a/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n+++ b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n@@ -17,13 +17,71 @@ def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n             '%s_%s' % (action, opts.model_name)\n             for action in opts.default_permissions\n         ]\n+\n         permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n         for codename, name in opts.permissions:\n-            permissions_query = permissions_query | Q(codename=codename, name=name)\n+            if codename and name:\n+                permissions_query = permissions_query | Q(codename=codename, name=name)\n+        \n+        try:\n+            concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n+            proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n+        except ContentType.DoesNotExist:\n+            continue\n+            \n+        old_content_type = proxy_content_type if reverse else concrete_content_type\n+        new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Find permissions to update\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Find conflicting permissions that already exist for new_content_type\n+        conflicting_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        )\n+        \n+        # Delete conflicting permissions to avoid unique constraint violation\n+        conflicting_permissions.delete()\n+        \n+        # Now safely update the remaining permissions\n+        permissions_to_update.update(content_type=new_content_type)\n+\n         concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n         proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n         old_content_type = proxy_content_type if reverse else concrete_content_type\n         new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions that need to be updated\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Find and delete conflicting permissions that already exist for new_content_type\n+        # to avoid unique constraint violation on (content_type, codename)\n+        conflicting_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        )\n+        conflicting_permissions.delete()\n+        \n+        # Now safely update the remaining permissions\n+        permissions_to_update.update(content_type=new_content_type)\n+\n+        # Find permissions that would conflict after the update\n+        conflicting_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        )\n+        \n+        # Delete conflicting permissions to avoid unique constraint violation\n+        conflicting_permissions.delete()\n+        \n+        # Now safely update the remaining permissions\n         Permission.objects.filter(\n             permissions_query,\n             content_type=old_content_type,\ndiff --git a/django/contrib/auth/models.py b/django/contrib/auth/models.py\nindex 324faa6f3e..2c8e8bb02f 100644\n--- a/django/contrib/auth/models.py\n+++ b/django/contrib/auth/models.py\n@@ -66,6 +66,7 @@ class Permission(models.Model):\n     class Meta:\n         verbose_name = _('permission')\n         verbose_name_plural = _('permissions')\n+\n         unique_together = (('content_type', 'codename'),)\n         ordering = ('content_type__app_label', 'content_type__model',\n                     'codename')\ndiff --git a/tests/auth_tests/test_migrations.py b/tests/auth_tests/test_migrations.py\nindex 5ff2f6b4b3..ea7c0b28ae 100644\n--- a/tests/auth_tests/test_migrations.py\n+++ b/tests/auth_tests/test_migrations.py\n@@ -23,7 +23,10 @@ class ProxyModelWithDifferentAppLabelTests(TestCase):\n         rather than the proxy model (as they were before Django 2.2 and\n         migration 11).\n         \"\"\"\n-        Permission.objects.all().delete()\n+\n+        Permission.objects.filter(\n+            content_type=ContentType.objects.get_for_model(UserProxy, for_concrete_model=False)\n+        ).delete()\n         self.concrete_content_type = ContentType.objects.get_for_model(UserProxy)\n         self.default_permission = Permission.objects.create(\n             content_type=self.concrete_content_type,\n"
  }
}