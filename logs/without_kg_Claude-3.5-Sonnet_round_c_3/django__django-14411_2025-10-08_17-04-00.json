{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/django/django/contrib/auth/forms.py lines 33-36)": "\nclass ReadOnlyPasswordHashWidget(forms.Widget):\n    template_name = 'auth/widgets/read_only_password_hash.html'\n    read_only = True\n\n    def id_for_label(self, id_):\n        return None\n",
    "Location 2 (/root/hy/projects_3/django/django/forms/widgets.py lines 268-278)": "\n    def id_for_label(self, id_):\n        \"\"\"\n        Return the HTML ID attribute of this Widget for use by a <label>,\n        given the ID of the field. Return None if no ID is available.\n\n        This hook is necessary because some widgets have multiple HTML\n        elements and, thus, multiple IDs. In that case, this method should\n        return an ID value that corresponds to the first ID in the widget's\n        tags.\n        \"\"\"\n        return id_\n",
    "Location 3 (/root/hy/projects_3/django/django/forms/boundfield.py lines 154-157)": "\nclass ReadOnlyPasswordHashWidget(forms.Widget):\n    template_name = 'auth/widgets/read_only_password_hash.html'\n    read_only = True\n\n    def get_context(self, name, value, attrs):\n        context = super().get_context(name, value, attrs)\n        summary = []\n        if not value or value.startswith(UNUSABLE_PASSWORD_PREFIX):\n            summary.append({'label': gettext(\"No password set.\")})\n        else:\n            try:\n                hasher = identify_hasher(value)\n            except ValueError:\n                summary.append({'label': gettext(\"Invalid password format or unknown hashing algorithm.\")})\n            else:\n                for key, value_ in hasher.safe_summary(value).items():\n                    summary.append({'label': gettext(key), 'value': value_})\n        context['summary'] = summary\n        return context\n\n    def id_for_label(self, id_):\n        return None\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/django/django/contrib/auth/forms.py lines 33-36)": [
      "\nclass ReadOnlyPasswordHashWidget(forms.Widget):\n    template_name = 'auth/widgets/read_only_password_hash.html'\n    read_only = True\n\n    def id_for_label(self, id_):\n        return None\n",
      "\nclass ReadOnlyPasswordHashWidget(forms.Widget):\n    template_name = 'auth/widgets/read_only_password_hash.html'\n    read_only = True\n\n    def id_for_label(self, id_):\n        return None\n",
      "\nclass ReadOnlyPasswordHashWidget(forms.Widget):\n    template_name = 'auth/widgets/read_only_password_hash.html'\n    read_only = True\n\n    def id_for_label(self, id_):\n        return None\n",
      "\nclass ReadOnlyPasswordHashWidget(forms.Widget):\n    template_name = 'auth/widgets/read_only_password_hash.html'\n    read_only = True\n\n    def id_for_label(self, id_):\n        return None\n",
      "\nclass ReadOnlyPasswordHashWidget(forms.Widget):\n    template_name = 'auth/widgets/read_only_password_hash.html'\n    read_only = True\n\n    def id_for_label(self, id_):\n        return None\n",
      "\nclass ReadOnlyPasswordHashWidget(forms.Widget):\n    template_name = 'auth/widgets/read_only_password_hash.html'\n    read_only = True\n\n    def id_for_label(self, id_):\n        return None\n",
      "\nclass ReadOnlyPasswordHashWidget(forms.Widget):\n    template_name = 'auth/widgets/read_only_password_hash.html'\n    read_only = True\n\n    def id_for_label(self, id_):\n        return None\n",
      "\nclass ReadOnlyPasswordHashWidget(forms.Widget):\n    template_name = 'auth/widgets/read_only_password_hash.html'\n    read_only = True\n\n    def id_for_label(self, id_):\n        return None\n"
    ],
    "Location 2 (/root/hy/projects_3/django/django/forms/widgets.py lines 268-278)": [
      "\n    def id_for_label(self, id_):\n        \"\"\"\n        Return the HTML ID attribute of this Widget for use by a <label>,\n        given the ID of the field. Return None if no ID is available.\n\n        This hook is necessary because some widgets have multiple HTML\n        elements and, thus, multiple IDs. In that case, this method should\n        return an ID value that corresponds to the first ID in the widget's\n        tags.\n        \"\"\"\n        return id_\n",
      "\n    def id_for_label(self, id_):\n        \"\"\"\n        Return the HTML ID attribute of this Widget for use by a <label>,\n        given the ID of the field. Return None if no ID is available.\n\n        This hook is necessary because some widgets have multiple HTML\n        elements and, thus, multiple IDs. In that case, this method should\n        return an ID value that corresponds to the first ID in the widget's\n        tags.\n        \"\"\"\n        return id_\n",
      "\n    def id_for_label(self, id_):\n        \"\"\"\n        Return the HTML ID attribute of this Widget for use by a <label>,\n        given the ID of the field. Return None if no ID is available.\n\n        This hook is necessary because some widgets have multiple HTML\n        elements and, thus, multiple IDs. In that case, this method should\n        return an ID value that corresponds to the first ID in the widget's\n        tags.\n        \"\"\"\n        return id_\n",
      "\n    def id_for_label(self, id_):\n        \"\"\"\n        Return the HTML ID attribute of this Widget for use by a <label>,\n        given the ID of the field. Return None if no ID is available.\n\n        This hook is necessary because some widgets have multiple HTML\n        elements and, thus, multiple IDs. In that case, this method should\n        return an ID value that corresponds to the first ID in the widget's\n        tags.\n        \"\"\"\n        return id_\n",
      "\n    def id_for_label(self, id_):\n        \"\"\"\n        Return the HTML ID attribute of this Widget for use by a <label>,\n        given the ID of the field. Return None if no ID is available.\n\n        This hook is necessary because some widgets have multiple HTML\n        elements and, thus, multiple IDs. In that case, this method should\n        return an ID value that corresponds to the first ID in the widget's\n        tags.\n        \"\"\"\n        return id_\n",
      "\n    def id_for_label(self, id_):\n        \"\"\"\n        Return the HTML ID attribute of this Widget for use by a <label>,\n        given the ID of the field. Return None if no ID is available.\n\n        This hook is necessary because some widgets have multiple HTML\n        elements and, thus, multiple IDs. In that case, this method should\n        return an ID value that corresponds to the first ID in the widget's\n        tags.\n        \"\"\"\n        return id_\n",
      "\n    def id_for_label(self, id_):\n        \"\"\"\n        Return the HTML ID attribute of this Widget for use by a <label>,\n        given the ID of the field. Return None if no ID is available.\n\n        This hook is necessary because some widgets have multiple HTML\n        elements and, thus, multiple IDs. In that case, this method should\n        return an ID value that corresponds to the first ID in the widget's\n        tags.\n        \"\"\"\n        return id_\n",
      "\n    def id_for_label(self, id_):\n        \"\"\"\n        Return the HTML ID attribute of this Widget for use by a <label>,\n        given the ID of the field. Return None if no ID is available.\n\n        This hook is necessary because some widgets have multiple HTML\n        elements and, thus, multiple IDs. In that case, this method should\n        return an ID value that corresponds to the first ID in the widget's\n        tags.\n        \"\"\"\n        return id_\n"
    ],
    "Location 3 (/root/hy/projects_3/django/django/forms/boundfield.py lines 154-157)": [
      "\n    def render(self, name, value, attrs=None, renderer=None):\n        return format_html_join('',\n                                \"<strong>{}</strong>\",\n                                ((line,) for line in value),\n                                )\n\n    def id_for_label(self, id_):\n        return None\n",
      "\nclass ReadOnlyPasswordHashWidget(forms.Widget):\n    template_name = 'auth/widgets/read_only_password_hash.html'\n    read_only = True\n\n    def get_context(self, name, value, attrs):\n        context = super().get_context(name, value, attrs)\n        summary = []\n        if not value or value.startswith(UNUSABLE_PASSWORD_PREFIX):\n            summary.append({'label': gettext(\"No password set.\")})\n        else:\n            try:\n                hasher = identify_hasher(value)\n            except ValueError:\n                summary.append({'label': gettext(\"Invalid password format or unknown hashing algorithm.\")})\n            else:\n                for key, value_ in hasher.safe_summary(value).items():\n                    summary.append({'label': gettext(key), 'value': value_})\n        context['summary'] = summary\n        return context\n\n    def id_for_label(self, id_):\n        return None\n",
      "\n    def render(self, name, value, attrs=None, renderer=None):\n        return format_html_join('',\n                                \"<strong>{}</strong>\",\n                                ((line,) for line in value.split('\\n'))\n                                ) if value else ''\n\n    def id_for_label(self, id_):\n        return None\n",
      "\nclass ReadOnlyPasswordHashWidget(forms.Widget):\n    template_name = 'auth/widgets/read_only_password_hash.html'\n    read_only = True\n\n    def get_context(self, name, value, attrs):\n        context = super().get_context(name, value, attrs)\n        summary = []\n        if not value or value.startswith(UNUSABLE_PASSWORD_PREFIX):\n            summary.append({'label': gettext(\"No password set.\")})\n        else:\n            try:\n                hasher = identify_hasher(value)\n            except ValueError:\n                summary.append({'label': gettext(\"Invalid password format or unknown hashing algorithm.\")})\n            else:\n                for key, value_ in hasher.safe_summary(value).items():\n                    summary.append({'label': gettext(key), 'value': value_})\n        context['summary'] = summary\n        return context\n\n    def id_for_label(self, id_):\n        return None\n",
      "\nclass ReadOnlyPasswordHashWidget(forms.Widget):\n    template_name = 'auth/widgets/read_only_password_hash.html'\n    read_only = True\n\n    def get_context(self, name, value, attrs):\n        context = super().get_context(name, value, attrs)\n        summary = []\n        if not value or value.startswith(UNUSABLE_PASSWORD_PREFIX):\n            summary.append({'label': gettext(\"No password set.\")})\n        else:\n            try:\n                hasher = identify_hasher(value)\n            except ValueError:\n                summary.append({'label': gettext(\"Invalid password format or unknown hashing algorithm.\")})\n            else:\n                for key, value_ in hasher.safe_summary(value).items():\n                    summary.append({'label': gettext(key), 'value': value_})\n        context['summary'] = summary\n        return context\n\n    def id_for_label(self, id_):\n        return None\n",
      "\n    def id_for_label(self, id_):\n        return None\n",
      "\n    def render(self, name, value, attrs=None, renderer=None):\n        return format_html_join('',\n                                \"<strong>{}</strong>\",\n                                ((line,) for line in value.split('\\n'))) if value else ''\n\n    def id_for_label(self, id_):\n        return None\n",
      "\nclass ReadOnlyPasswordHashWidget(forms.Widget):\n    template_name = 'auth/widgets/read_only_password_hash.html'\n    read_only = True\n\n    def get_context(self, name, value, attrs):\n        context = super().get_context(name, value, attrs)\n        summary = []\n        if not value or value.startswith(UNUSABLE_PASSWORD_PREFIX):\n            summary.append({'label': gettext(\"No password set.\")})\n        else:\n            try:\n                hasher = identify_hasher(value)\n            except ValueError:\n                summary.append({'label': gettext(\"Invalid password format or unknown hashing algorithm.\")})\n            else:\n                for key, value_ in hasher.safe_summary(value).items():\n                    summary.append({'label': gettext(key), 'value': value_})\n        context['summary'] = summary\n        return context\n\n    def id_for_label(self, id_):\n        return None\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/contrib/auth/forms.py b/django/contrib/auth/forms.py\nindex 20d8922799..2806d88b2e 100644\n--- a/django/contrib/auth/forms.py\n+++ b/django/contrib/auth/forms.py\n@@ -30,10 +30,16 @@ def _unicode_ci_compare(s1, s2):\n     return unicodedata.normalize('NFKC', s1).casefold() == unicodedata.normalize('NFKC', s2).casefold()\n \n \n+\n class ReadOnlyPasswordHashWidget(forms.Widget):\n     template_name = 'auth/widgets/read_only_password_hash.html'\n     read_only = True\n \n+    def id_for_label(self, id_):\n+        \"\"\"\n+        Return None since this widget renders no labelable elements.\n+        \"\"\"\n+        return None\n     def get_context(self, name, value, attrs):\n         context = super().get_context(name, value, attrs)\n         summary = []\ndiff --git a/django/forms/boundfield.py b/django/forms/boundfield.py\nindex 66d065c9c8..dfe5108426 100644\n--- a/django/forms/boundfield.py\n+++ b/django/forms/boundfield.py\n@@ -151,6 +151,7 @@ class BoundField:\n             contents = format_html('{}{}', contents, label_suffix)\n         widget = self.field.widget\n         id_ = widget.attrs.get('id') or self.auto_id\n+\n         if id_:\n             id_for_label = widget.id_for_label(id_)\n             if id_for_label:\ndiff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex 0a24e924a5..49ea638648 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -265,6 +265,7 @@ class Widget(metaclass=MediaDefiningClass):\n     def value_omitted_from_data(self, data, files, name):\n         return name not in data\n \n+\n     def id_for_label(self, id_):\n         \"\"\"\n         Return the HTML ID attribute of this Widget for use by a <label>,\n",
    "variant_0": "diff --git a/django/contrib/auth/forms.py b/django/contrib/auth/forms.py\nindex 20d8922799..e43cf80e47 100644\n--- a/django/contrib/auth/forms.py\n+++ b/django/contrib/auth/forms.py\n@@ -30,10 +30,13 @@ def _unicode_ci_compare(s1, s2):\n     return unicodedata.normalize('NFKC', s1).casefold() == unicodedata.normalize('NFKC', s2).casefold()\n \n \n+\n class ReadOnlyPasswordHashWidget(forms.Widget):\n     template_name = 'auth/widgets/read_only_password_hash.html'\n     read_only = True\n \n+    def id_for_label(self, id_):\n+        return None\n     def get_context(self, name, value, attrs):\n         context = super().get_context(name, value, attrs)\n         summary = []\ndiff --git a/django/forms/boundfield.py b/django/forms/boundfield.py\nindex 66d065c9c8..a7381f6455 100644\n--- a/django/forms/boundfield.py\n+++ b/django/forms/boundfield.py\n@@ -151,10 +151,29 @@ class BoundField:\n             contents = format_html('{}{}', contents, label_suffix)\n         widget = self.field.widget\n         id_ = widget.attrs.get('id') or self.auto_id\n-        if id_:\n-            id_for_label = widget.id_for_label(id_)\n-            if id_for_label:\n-                attrs = {**(attrs or {}), 'for': id_for_label}\n+\n+class ReadOnlyPasswordHashWidget(forms.Widget):\n+    template_name = 'auth/widgets/read_only_password_hash.html'\n+    read_only = True\n+\n+    def get_context(self, name, value, attrs):\n+        context = super().get_context(name, value, attrs)\n+        summary = []\n+        if not value or value.startswith(UNUSABLE_PASSWORD_PREFIX):\n+            summary.append({'label': gettext(\"No password set.\")})\n+        else:\n+            try:\n+                hasher = identify_hasher(value)\n+            except ValueError:\n+                summary.append({'label': gettext(\"Invalid password format or unknown hashing algorithm.\")})\n+            else:\n+                for key, value_ in hasher.safe_summary(value).items():\n+                    summary.append({'label': gettext(key), 'value': value_})\n+        context['summary'] = summary\n+        return context\n+\n+    def id_for_label(self, id_):\n+        return None\n             if self.field.required and hasattr(self.form, 'required_css_class'):\n                 attrs = attrs or {}\n                 if 'class' in attrs:\ndiff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex 0a24e924a5..49ea638648 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -265,6 +265,7 @@ class Widget(metaclass=MediaDefiningClass):\n     def value_omitted_from_data(self, data, files, name):\n         return name not in data\n \n+\n     def id_for_label(self, id_):\n         \"\"\"\n         Return the HTML ID attribute of this Widget for use by a <label>,\n",
    "variant_1": "diff --git a/django/contrib/auth/forms.py b/django/contrib/auth/forms.py\nindex 20d8922799..e43cf80e47 100644\n--- a/django/contrib/auth/forms.py\n+++ b/django/contrib/auth/forms.py\n@@ -30,10 +30,13 @@ def _unicode_ci_compare(s1, s2):\n     return unicodedata.normalize('NFKC', s1).casefold() == unicodedata.normalize('NFKC', s2).casefold()\n \n \n+\n class ReadOnlyPasswordHashWidget(forms.Widget):\n     template_name = 'auth/widgets/read_only_password_hash.html'\n     read_only = True\n \n+    def id_for_label(self, id_):\n+        return None\n     def get_context(self, name, value, attrs):\n         context = super().get_context(name, value, attrs)\n         summary = []\ndiff --git a/django/forms/boundfield.py b/django/forms/boundfield.py\nindex 66d065c9c8..0342138b48 100644\n--- a/django/forms/boundfield.py\n+++ b/django/forms/boundfield.py\n@@ -151,10 +151,15 @@ class BoundField:\n             contents = format_html('{}{}', contents, label_suffix)\n         widget = self.field.widget\n         id_ = widget.attrs.get('id') or self.auto_id\n-        if id_:\n-            id_for_label = widget.id_for_label(id_)\n-            if id_for_label:\n-                attrs = {**(attrs or {}), 'for': id_for_label}\n+\n+    def render(self, name, value, attrs=None, renderer=None):\n+        return format_html_join('',\n+                                \"<strong>{}</strong>\",\n+                                ((line,) for line in value),\n+                                )\n+\n+    def id_for_label(self, id_):\n+        return None\n             if self.field.required and hasattr(self.form, 'required_css_class'):\n                 attrs = attrs or {}\n                 if 'class' in attrs:\ndiff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex 0a24e924a5..49ea638648 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -265,6 +265,7 @@ class Widget(metaclass=MediaDefiningClass):\n     def value_omitted_from_data(self, data, files, name):\n         return name not in data\n \n+\n     def id_for_label(self, id_):\n         \"\"\"\n         Return the HTML ID attribute of this Widget for use by a <label>,\n",
    "variant_2": "diff --git a/django/contrib/auth/forms.py b/django/contrib/auth/forms.py\nindex 20d8922799..e43cf80e47 100644\n--- a/django/contrib/auth/forms.py\n+++ b/django/contrib/auth/forms.py\n@@ -30,10 +30,13 @@ def _unicode_ci_compare(s1, s2):\n     return unicodedata.normalize('NFKC', s1).casefold() == unicodedata.normalize('NFKC', s2).casefold()\n \n \n+\n class ReadOnlyPasswordHashWidget(forms.Widget):\n     template_name = 'auth/widgets/read_only_password_hash.html'\n     read_only = True\n \n+    def id_for_label(self, id_):\n+        return None\n     def get_context(self, name, value, attrs):\n         context = super().get_context(name, value, attrs)\n         summary = []\ndiff --git a/django/forms/boundfield.py b/django/forms/boundfield.py\nindex 66d065c9c8..a7381f6455 100644\n--- a/django/forms/boundfield.py\n+++ b/django/forms/boundfield.py\n@@ -151,10 +151,29 @@ class BoundField:\n             contents = format_html('{}{}', contents, label_suffix)\n         widget = self.field.widget\n         id_ = widget.attrs.get('id') or self.auto_id\n-        if id_:\n-            id_for_label = widget.id_for_label(id_)\n-            if id_for_label:\n-                attrs = {**(attrs or {}), 'for': id_for_label}\n+\n+class ReadOnlyPasswordHashWidget(forms.Widget):\n+    template_name = 'auth/widgets/read_only_password_hash.html'\n+    read_only = True\n+\n+    def get_context(self, name, value, attrs):\n+        context = super().get_context(name, value, attrs)\n+        summary = []\n+        if not value or value.startswith(UNUSABLE_PASSWORD_PREFIX):\n+            summary.append({'label': gettext(\"No password set.\")})\n+        else:\n+            try:\n+                hasher = identify_hasher(value)\n+            except ValueError:\n+                summary.append({'label': gettext(\"Invalid password format or unknown hashing algorithm.\")})\n+            else:\n+                for key, value_ in hasher.safe_summary(value).items():\n+                    summary.append({'label': gettext(key), 'value': value_})\n+        context['summary'] = summary\n+        return context\n+\n+    def id_for_label(self, id_):\n+        return None\n             if self.field.required and hasattr(self.form, 'required_css_class'):\n                 attrs = attrs or {}\n                 if 'class' in attrs:\ndiff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex 0a24e924a5..49ea638648 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -265,6 +265,7 @@ class Widget(metaclass=MediaDefiningClass):\n     def value_omitted_from_data(self, data, files, name):\n         return name not in data\n \n+\n     def id_for_label(self, id_):\n         \"\"\"\n         Return the HTML ID attribute of this Widget for use by a <label>,\n",
    "variant_3": "diff --git a/django/contrib/auth/forms.py b/django/contrib/auth/forms.py\nindex 20d8922799..e43cf80e47 100644\n--- a/django/contrib/auth/forms.py\n+++ b/django/contrib/auth/forms.py\n@@ -30,10 +30,13 @@ def _unicode_ci_compare(s1, s2):\n     return unicodedata.normalize('NFKC', s1).casefold() == unicodedata.normalize('NFKC', s2).casefold()\n \n \n+\n class ReadOnlyPasswordHashWidget(forms.Widget):\n     template_name = 'auth/widgets/read_only_password_hash.html'\n     read_only = True\n \n+    def id_for_label(self, id_):\n+        return None\n     def get_context(self, name, value, attrs):\n         context = super().get_context(name, value, attrs)\n         summary = []\ndiff --git a/django/forms/boundfield.py b/django/forms/boundfield.py\nindex 66d065c9c8..091a09b503 100644\n--- a/django/forms/boundfield.py\n+++ b/django/forms/boundfield.py\n@@ -151,10 +151,15 @@ class BoundField:\n             contents = format_html('{}{}', contents, label_suffix)\n         widget = self.field.widget\n         id_ = widget.attrs.get('id') or self.auto_id\n-        if id_:\n-            id_for_label = widget.id_for_label(id_)\n-            if id_for_label:\n-                attrs = {**(attrs or {}), 'for': id_for_label}\n+\n+    def render(self, name, value, attrs=None, renderer=None):\n+        return format_html_join('',\n+                                \"<strong>{}</strong>\",\n+                                ((line,) for line in value.split('\\n'))\n+                                ) if value else ''\n+\n+    def id_for_label(self, id_):\n+        return None\n             if self.field.required and hasattr(self.form, 'required_css_class'):\n                 attrs = attrs or {}\n                 if 'class' in attrs:\ndiff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex 0a24e924a5..49ea638648 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -265,6 +265,7 @@ class Widget(metaclass=MediaDefiningClass):\n     def value_omitted_from_data(self, data, files, name):\n         return name not in data\n \n+\n     def id_for_label(self, id_):\n         \"\"\"\n         Return the HTML ID attribute of this Widget for use by a <label>,\n",
    "variant_4": "diff --git a/django/contrib/auth/forms.py b/django/contrib/auth/forms.py\nindex 20d8922799..e43cf80e47 100644\n--- a/django/contrib/auth/forms.py\n+++ b/django/contrib/auth/forms.py\n@@ -30,10 +30,13 @@ def _unicode_ci_compare(s1, s2):\n     return unicodedata.normalize('NFKC', s1).casefold() == unicodedata.normalize('NFKC', s2).casefold()\n \n \n+\n class ReadOnlyPasswordHashWidget(forms.Widget):\n     template_name = 'auth/widgets/read_only_password_hash.html'\n     read_only = True\n \n+    def id_for_label(self, id_):\n+        return None\n     def get_context(self, name, value, attrs):\n         context = super().get_context(name, value, attrs)\n         summary = []\ndiff --git a/django/forms/boundfield.py b/django/forms/boundfield.py\nindex 66d065c9c8..a7381f6455 100644\n--- a/django/forms/boundfield.py\n+++ b/django/forms/boundfield.py\n@@ -151,10 +151,29 @@ class BoundField:\n             contents = format_html('{}{}', contents, label_suffix)\n         widget = self.field.widget\n         id_ = widget.attrs.get('id') or self.auto_id\n-        if id_:\n-            id_for_label = widget.id_for_label(id_)\n-            if id_for_label:\n-                attrs = {**(attrs or {}), 'for': id_for_label}\n+\n+class ReadOnlyPasswordHashWidget(forms.Widget):\n+    template_name = 'auth/widgets/read_only_password_hash.html'\n+    read_only = True\n+\n+    def get_context(self, name, value, attrs):\n+        context = super().get_context(name, value, attrs)\n+        summary = []\n+        if not value or value.startswith(UNUSABLE_PASSWORD_PREFIX):\n+            summary.append({'label': gettext(\"No password set.\")})\n+        else:\n+            try:\n+                hasher = identify_hasher(value)\n+            except ValueError:\n+                summary.append({'label': gettext(\"Invalid password format or unknown hashing algorithm.\")})\n+            else:\n+                for key, value_ in hasher.safe_summary(value).items():\n+                    summary.append({'label': gettext(key), 'value': value_})\n+        context['summary'] = summary\n+        return context\n+\n+    def id_for_label(self, id_):\n+        return None\n             if self.field.required and hasattr(self.form, 'required_css_class'):\n                 attrs = attrs or {}\n                 if 'class' in attrs:\ndiff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex 0a24e924a5..49ea638648 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -265,6 +265,7 @@ class Widget(metaclass=MediaDefiningClass):\n     def value_omitted_from_data(self, data, files, name):\n         return name not in data\n \n+\n     def id_for_label(self, id_):\n         \"\"\"\n         Return the HTML ID attribute of this Widget for use by a <label>,\n",
    "variant_5": "diff --git a/django/contrib/auth/forms.py b/django/contrib/auth/forms.py\nindex 20d8922799..e43cf80e47 100644\n--- a/django/contrib/auth/forms.py\n+++ b/django/contrib/auth/forms.py\n@@ -30,10 +30,13 @@ def _unicode_ci_compare(s1, s2):\n     return unicodedata.normalize('NFKC', s1).casefold() == unicodedata.normalize('NFKC', s2).casefold()\n \n \n+\n class ReadOnlyPasswordHashWidget(forms.Widget):\n     template_name = 'auth/widgets/read_only_password_hash.html'\n     read_only = True\n \n+    def id_for_label(self, id_):\n+        return None\n     def get_context(self, name, value, attrs):\n         context = super().get_context(name, value, attrs)\n         summary = []\ndiff --git a/django/forms/boundfield.py b/django/forms/boundfield.py\nindex 66d065c9c8..a7381f6455 100644\n--- a/django/forms/boundfield.py\n+++ b/django/forms/boundfield.py\n@@ -151,10 +151,29 @@ class BoundField:\n             contents = format_html('{}{}', contents, label_suffix)\n         widget = self.field.widget\n         id_ = widget.attrs.get('id') or self.auto_id\n-        if id_:\n-            id_for_label = widget.id_for_label(id_)\n-            if id_for_label:\n-                attrs = {**(attrs or {}), 'for': id_for_label}\n+\n+class ReadOnlyPasswordHashWidget(forms.Widget):\n+    template_name = 'auth/widgets/read_only_password_hash.html'\n+    read_only = True\n+\n+    def get_context(self, name, value, attrs):\n+        context = super().get_context(name, value, attrs)\n+        summary = []\n+        if not value or value.startswith(UNUSABLE_PASSWORD_PREFIX):\n+            summary.append({'label': gettext(\"No password set.\")})\n+        else:\n+            try:\n+                hasher = identify_hasher(value)\n+            except ValueError:\n+                summary.append({'label': gettext(\"Invalid password format or unknown hashing algorithm.\")})\n+            else:\n+                for key, value_ in hasher.safe_summary(value).items():\n+                    summary.append({'label': gettext(key), 'value': value_})\n+        context['summary'] = summary\n+        return context\n+\n+    def id_for_label(self, id_):\n+        return None\n             if self.field.required and hasattr(self.form, 'required_css_class'):\n                 attrs = attrs or {}\n                 if 'class' in attrs:\ndiff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex 0a24e924a5..49ea638648 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -265,6 +265,7 @@ class Widget(metaclass=MediaDefiningClass):\n     def value_omitted_from_data(self, data, files, name):\n         return name not in data\n \n+\n     def id_for_label(self, id_):\n         \"\"\"\n         Return the HTML ID attribute of this Widget for use by a <label>,\n",
    "variant_6": "diff --git a/django/contrib/auth/forms.py b/django/contrib/auth/forms.py\nindex 20d8922799..e43cf80e47 100644\n--- a/django/contrib/auth/forms.py\n+++ b/django/contrib/auth/forms.py\n@@ -30,10 +30,13 @@ def _unicode_ci_compare(s1, s2):\n     return unicodedata.normalize('NFKC', s1).casefold() == unicodedata.normalize('NFKC', s2).casefold()\n \n \n+\n class ReadOnlyPasswordHashWidget(forms.Widget):\n     template_name = 'auth/widgets/read_only_password_hash.html'\n     read_only = True\n \n+    def id_for_label(self, id_):\n+        return None\n     def get_context(self, name, value, attrs):\n         context = super().get_context(name, value, attrs)\n         summary = []\ndiff --git a/django/forms/boundfield.py b/django/forms/boundfield.py\nindex 66d065c9c8..52e1d631c0 100644\n--- a/django/forms/boundfield.py\n+++ b/django/forms/boundfield.py\n@@ -151,10 +151,9 @@ class BoundField:\n             contents = format_html('{}{}', contents, label_suffix)\n         widget = self.field.widget\n         id_ = widget.attrs.get('id') or self.auto_id\n-        if id_:\n-            id_for_label = widget.id_for_label(id_)\n-            if id_for_label:\n-                attrs = {**(attrs or {}), 'for': id_for_label}\n+\n+    def id_for_label(self, id_):\n+        return None\n             if self.field.required and hasattr(self.form, 'required_css_class'):\n                 attrs = attrs or {}\n                 if 'class' in attrs:\ndiff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex 0a24e924a5..49ea638648 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -265,6 +265,7 @@ class Widget(metaclass=MediaDefiningClass):\n     def value_omitted_from_data(self, data, files, name):\n         return name not in data\n \n+\n     def id_for_label(self, id_):\n         \"\"\"\n         Return the HTML ID attribute of this Widget for use by a <label>,\n",
    "variant_7": "diff --git a/django/contrib/auth/forms.py b/django/contrib/auth/forms.py\nindex 20d8922799..e43cf80e47 100644\n--- a/django/contrib/auth/forms.py\n+++ b/django/contrib/auth/forms.py\n@@ -30,10 +30,13 @@ def _unicode_ci_compare(s1, s2):\n     return unicodedata.normalize('NFKC', s1).casefold() == unicodedata.normalize('NFKC', s2).casefold()\n \n \n+\n class ReadOnlyPasswordHashWidget(forms.Widget):\n     template_name = 'auth/widgets/read_only_password_hash.html'\n     read_only = True\n \n+    def id_for_label(self, id_):\n+        return None\n     def get_context(self, name, value, attrs):\n         context = super().get_context(name, value, attrs)\n         summary = []\ndiff --git a/django/forms/boundfield.py b/django/forms/boundfield.py\nindex 66d065c9c8..2f34c700c7 100644\n--- a/django/forms/boundfield.py\n+++ b/django/forms/boundfield.py\n@@ -151,10 +151,14 @@ class BoundField:\n             contents = format_html('{}{}', contents, label_suffix)\n         widget = self.field.widget\n         id_ = widget.attrs.get('id') or self.auto_id\n-        if id_:\n-            id_for_label = widget.id_for_label(id_)\n-            if id_for_label:\n-                attrs = {**(attrs or {}), 'for': id_for_label}\n+\n+    def render(self, name, value, attrs=None, renderer=None):\n+        return format_html_join('',\n+                                \"<strong>{}</strong>\",\n+                                ((line,) for line in value.split('\\n'))) if value else ''\n+\n+    def id_for_label(self, id_):\n+        return None\n             if self.field.required and hasattr(self.form, 'required_css_class'):\n                 attrs = attrs or {}\n                 if 'class' in attrs:\ndiff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex 0a24e924a5..49ea638648 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -265,6 +265,7 @@ class Widget(metaclass=MediaDefiningClass):\n     def value_omitted_from_data(self, data, files, name):\n         return name not in data\n \n+\n     def id_for_label(self, id_):\n         \"\"\"\n         Return the HTML ID attribute of this Widget for use by a <label>,\n",
    "variant_8": "diff --git a/django/contrib/auth/forms.py b/django/contrib/auth/forms.py\nindex 20d8922799..e43cf80e47 100644\n--- a/django/contrib/auth/forms.py\n+++ b/django/contrib/auth/forms.py\n@@ -30,10 +30,13 @@ def _unicode_ci_compare(s1, s2):\n     return unicodedata.normalize('NFKC', s1).casefold() == unicodedata.normalize('NFKC', s2).casefold()\n \n \n+\n class ReadOnlyPasswordHashWidget(forms.Widget):\n     template_name = 'auth/widgets/read_only_password_hash.html'\n     read_only = True\n \n+    def id_for_label(self, id_):\n+        return None\n     def get_context(self, name, value, attrs):\n         context = super().get_context(name, value, attrs)\n         summary = []\ndiff --git a/django/forms/boundfield.py b/django/forms/boundfield.py\nindex 66d065c9c8..a7381f6455 100644\n--- a/django/forms/boundfield.py\n+++ b/django/forms/boundfield.py\n@@ -151,10 +151,29 @@ class BoundField:\n             contents = format_html('{}{}', contents, label_suffix)\n         widget = self.field.widget\n         id_ = widget.attrs.get('id') or self.auto_id\n-        if id_:\n-            id_for_label = widget.id_for_label(id_)\n-            if id_for_label:\n-                attrs = {**(attrs or {}), 'for': id_for_label}\n+\n+class ReadOnlyPasswordHashWidget(forms.Widget):\n+    template_name = 'auth/widgets/read_only_password_hash.html'\n+    read_only = True\n+\n+    def get_context(self, name, value, attrs):\n+        context = super().get_context(name, value, attrs)\n+        summary = []\n+        if not value or value.startswith(UNUSABLE_PASSWORD_PREFIX):\n+            summary.append({'label': gettext(\"No password set.\")})\n+        else:\n+            try:\n+                hasher = identify_hasher(value)\n+            except ValueError:\n+                summary.append({'label': gettext(\"Invalid password format or unknown hashing algorithm.\")})\n+            else:\n+                for key, value_ in hasher.safe_summary(value).items():\n+                    summary.append({'label': gettext(key), 'value': value_})\n+        context['summary'] = summary\n+        return context\n+\n+    def id_for_label(self, id_):\n+        return None\n             if self.field.required and hasattr(self.form, 'required_css_class'):\n                 attrs = attrs or {}\n                 if 'class' in attrs:\ndiff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex 0a24e924a5..49ea638648 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -265,6 +265,7 @@ class Widget(metaclass=MediaDefiningClass):\n     def value_omitted_from_data(self, data, files, name):\n         return name not in data\n \n+\n     def id_for_label(self, id_):\n         \"\"\"\n         Return the HTML ID attribute of this Widget for use by a <label>,\n"
  }
}