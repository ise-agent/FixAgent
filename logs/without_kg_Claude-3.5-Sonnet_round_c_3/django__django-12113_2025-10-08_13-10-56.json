{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/django/tests/admin_views/test_multidb.py lines 37-44)": "\n    @classmethod\n    def setUpTestData(cls):\n        cls.superusers = {}\n        cls.test_book_ids = {}\n        for db in connections:\n            Router.target_db = db\n            \n            # Retry mechanism for SQLite locking issues\n            max_retries = 3\n            base_delay = 0.1\n            \n            # Create superuser with retry logic\n            for attempt in range(max_retries):\n                try:\n                    cls.superusers[db] = User.objects.create_superuser(\n                        username='admin', password='something', email='test@test.org',\n                    )\n                    break\n                except Exception as e:\n                    if attempt == max_retries - 1:\n                        raise\n                    if 'database is locked' in str(e).lower():\n                        import time\n                        time.sleep(base_delay * (2 ** attempt))\n                    else:\n                        raise\n            \n            # Create book with retry logic\n            for attempt in range(max_retries):\n                try:\n                    b = Book(name='Test Book')\n                    b.save(using=db)\n                    cls.test_book_ids[db] = b.id\n                    break\n                except Exception as e:\n                    if attempt == max_retries - 1:\n                        raise\n                    if 'database is locked' in str(e).lower():\n                        import time\n                        time.sleep(base_delay * (2 ** attempt))\n                    else:\n                        raise\n            \n            # Ensure connection is properly closed before next iteration\n            connections[db].close()\n",
    "Location 2 (/root/hy/projects_3/django/tests/admin_views/test_multidb.py lines 39-41)": "\n    @classmethod\n    def setUpTestData(cls):\n        cls.superusers = {}\n        cls.test_book_ids = {}\n        for db in connections:\n            Router.target_db = db\n            \n            # Create superuser with retry logic for SQLite lock issues\n            max_retries = 3\n            for attempt in range(max_retries):\n                try:\n                    cls.superusers[db] = User.objects.create_superuser(\n                        username='admin', password='something', email='test@test.org',\n                    )\n                    break\n                except Exception as e:\n                    if attempt == max_retries - 1:\n                        raise\n                    if 'database is locked' in str(e).lower():\n                        import time\n                        time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n                    else:\n                        raise\n            \n            b = Book(name='Test Book')\n            b.save(using=db)\n            cls.test_book_ids[db] = b.id\n            \n            # Close connection to release SQLite file locks\n            connections[db].close()\n",
    "Location 3 (/root/hy/projects_3/django/tests/admin_views/test_multidb.py lines 42-43)": "\n    @classmethod\n    def setUpTestData(cls):\n        cls.superusers = {}\n        cls.test_book_ids = {}\n        for db in connections:\n            Router.target_db = db\n            cls.superusers[db] = User.objects.create_superuser(\n                username='admin', password='something', email='test@test.org',\n            )\n            b = Book(name='Test Book')\n            b.save(using=db)\n            cls.test_book_ids[db] = b.id\n            # Close connection to release SQLite file locks\n            connections[db].close()\n",
    "Location 4 (/root/hy/projects_3/django/tests/admin_views/test_multidb.py lines 47-50)": "\n    @mock.patch('django.contrib.admin.options.transaction')\n    def test_add_view(self, mock):\n        for db in connections:\n            with self.subTest(db=db):\n                Router.target_db = db\n                # Ensure clean connection state for SQLite\n                try:\n                    connections[db].close()\n                except Exception:\n                    pass\n                self.client.force_login(self.superusers[db])\n                self.client.post(\n                    reverse('test_adminsite:admin_views_book_add'),\n                    {'name': 'Foobar: 5th edition'},\n                )\n                mock.atomic.assert_called_with(using=db)\n",
    "Location 5 (/root/hy/projects_3/django/django/db/backends/sqlite3/base.py lines 261-267)": "\n    @async_unsafe\n    def close(self):\n        self.validate_thread_sharing()\n        # If database is in memory, closing the connection destroys the\n        # database. To prevent accidental data loss, ignore close requests on\n        # an in-memory db.\n        if not self.is_in_memory_db():\n            BaseDatabaseWrapper.close(self)\n            # Add a small delay for persistent SQLite databases to ensure\n            # file locks are fully released at the OS level\n            import time\n            time.sleep(0.05)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/django/tests/admin_views/test_multidb.py lines 37-44)": [
      "\n    @classmethod\n    def setUpTestData(cls):\n        cls.superusers = {}\n        cls.test_book_ids = {}\n        for db in connections:\n            Router.target_db = db\n            \n            # Retry mechanism for SQLite lock handling\n            max_retries = 3\n            retry_count = 0\n            while retry_count < max_retries:\n                try:\n                    cls.superusers[db] = User.objects.create_superuser(\n                        username='admin', password='something', email='test@test.org',\n                    )\n                    b = Book(name='Test Book')\n                    b.save(using=db)\n                    cls.test_book_ids[db] = b.id\n                    break\n                except Exception as e:\n                    if \"database is locked\" in str(e) and retry_count < max_retries - 1:\n                        retry_count += 1\n                        import time\n                        time.sleep(0.1 * (2 ** (retry_count - 1)))  # Exponential backoff\n                    else:\n                        raise\n            \n            # Close connection to release SQLite file locks\n            connections[db].close()\n",
      "\n    @classmethod\n    def setUpTestData(cls):\n        cls.superusers = {}\n        cls.test_book_ids = {}\n        for db in connections:\n            Router.target_db = db\n            \n            # Retry mechanism for SQLite lock handling\n            max_retries = 3\n            for attempt in range(max_retries):\n                try:\n                    cls.superusers[db] = User.objects.create_superuser(\n                        username='admin', password='something', email='test@test.org',\n                    )\n                    break\n                except Exception as e:\n                    if 'database is locked' in str(e) and attempt < max_retries - 1:\n                        import time\n                        time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n                        continue\n                    raise\n            \n            # Retry mechanism for Book creation\n            for attempt in range(max_retries):\n                try:\n                    b = Book(name='Test Book')\n                    b.save(using=db)\n                    cls.test_book_ids[db] = b.id\n                    break\n                except Exception as e:\n                    if 'database is locked' in str(e) and attempt < max_retries - 1:\n                        import time\n                        time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n                        continue\n                    raise\n            \n            # Close connection to release SQLite file locks\n            connections[db].close()\n",
      "\n    @classmethod\n    def setUpTestData(cls):\n        cls.superusers = {}\n        cls.test_book_ids = {}\n        for db in connections:\n            Router.target_db = db\n            \n            # Retry mechanism for SQLite database lock issues\n            max_retries = 3\n            for attempt in range(max_retries):\n                try:\n                    cls.superusers[db] = User.objects.create_superuser(\n                        username='admin', password='something', email='test@test.org',\n                    )\n                    break\n                except Exception as e:\n                    if attempt == max_retries - 1:\n                        raise\n                    import time\n                    time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n            \n            # Retry mechanism for book creation\n            for attempt in range(max_retries):\n                try:\n                    b = Book(name='Test Book')\n                    b.save(using=db)\n                    cls.test_book_ids[db] = b.id\n                    break\n                except Exception as e:\n                    if attempt == max_retries - 1:\n                        raise\n                    import time\n                    time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n            \n            # Close connection to release SQLite file locks\n            connections[db].close()\n",
      "\n    @classmethod\n    def setUpTestData(cls):\n        cls.superusers = {}\n        cls.test_book_ids = {}\n        for db in connections:\n            Router.target_db = db\n            \n            # Retry mechanism for SQLite lock handling\n            max_retries = 3\n            retry_delay = 0.1\n            \n            for attempt in range(max_retries):\n                try:\n                    cls.superusers[db] = User.objects.create_superuser(\n                        username='admin', password='something', email='test@test.org',\n                    )\n                    break\n                except Exception as e:\n                    if attempt == max_retries - 1:\n                        raise\n                    if 'database is locked' in str(e).lower():\n                        import time\n                        time.sleep(retry_delay * (2 ** attempt))\n                    else:\n                        raise\n            \n            for attempt in range(max_retries):\n                try:\n                    b = Book(name='Test Book')\n                    b.save(using=db)\n                    cls.test_book_ids[db] = b.id\n                    break\n                except Exception as e:\n                    if attempt == max_retries - 1:\n                        raise\n                    if 'database is locked' in str(e).lower():\n                        import time\n                        time.sleep(retry_delay * (2 ** attempt))\n                    else:\n                        raise\n            \n            # Close connection to release SQLite file locks\n            connections[db].close()\n",
      "\n    @classmethod\n    def setUpTestData(cls):\n        cls.superusers = {}\n        cls.test_book_ids = {}\n        for db in connections:\n            Router.target_db = db\n            \n            # Create superuser with retry logic for SQLite locking\n            max_retries = 3\n            for attempt in range(max_retries):\n                try:\n                    cls.superusers[db] = User.objects.create_superuser(\n                        username='admin', password='something', email='test@test.org',\n                    )\n                    break\n                except Exception as e:\n                    if attempt == max_retries - 1:\n                        raise\n                    import time\n                    time.sleep(0.1 * (2 ** attempt))\n            \n            # Create book with retry logic for SQLite locking\n            for attempt in range(max_retries):\n                try:\n                    b = Book(name='Test Book')\n                    b.save(using=db)\n                    cls.test_book_ids[db] = b.id\n                    break\n                except Exception as e:\n                    if attempt == max_retries - 1:\n                        raise\n                    import time\n                    time.sleep(0.1 * (2 ** attempt))\n            \n            # Close connection to release SQLite file locks\n            connections[db].close()\n",
      "\n    @classmethod\n    def setUpTestData(cls):\n        cls.superusers = {}\n        cls.test_book_ids = {}\n        for db in connections:\n            Router.target_db = db\n            \n            # Retry logic for SQLite database lock issues\n            max_retries = 3\n            for attempt in range(max_retries):\n                try:\n                    cls.superusers[db] = User.objects.create_superuser(\n                        username='admin', password='something', email='test@test.org',\n                    )\n                    break\n                except Exception as e:\n                    if attempt < max_retries - 1 and 'database is locked' in str(e):\n                        import time\n                        time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n                        continue\n                    raise\n            \n            # Retry logic for Book creation\n            for attempt in range(max_retries):\n                try:\n                    b = Book(name='Test Book')\n                    b.save(using=db)\n                    cls.test_book_ids[db] = b.id\n                    break\n                except Exception as e:\n                    if attempt < max_retries - 1 and 'database is locked' in str(e):\n                        import time\n                        time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n                        continue\n                    raise\n            \n            # Clean up connection to release SQLite file locks\n            connections[db].close()\n",
      "\n    @classmethod\n    def setUpTestData(cls):\n        cls.superusers = {}\n        cls.test_book_ids = {}\n        for db in connections:\n            Router.target_db = db\n            \n            # Create superuser with retry logic for SQLite locks\n            max_retries = 3\n            for attempt in range(max_retries):\n                try:\n                    cls.superusers[db] = User.objects.create_superuser(\n                        username='admin', password='something', email='test@test.org',\n                    )\n                    break\n                except Exception as e:\n                    if attempt < max_retries - 1 and 'database is locked' in str(e):\n                        import time\n                        time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n                        continue\n                    raise\n            \n            # Create book with retry logic for SQLite locks\n            for attempt in range(max_retries):\n                try:\n                    b = Book(name='Test Book')\n                    b.save(using=db)\n                    cls.test_book_ids[db] = b.id\n                    break\n                except Exception as e:\n                    if attempt < max_retries - 1 and 'database is locked' in str(e):\n                        import time\n                        time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n                        continue\n                    raise\n            \n            # Close connection to release SQLite file locks\n            connections[db].close()\n",
      "\n    @classmethod\n    def setUpTestData(cls):\n        cls.superusers = {}\n        cls.test_book_ids = {}\n        for db in connections:\n            Router.target_db = db\n            \n            # Retry logic for SQLite database lock issues\n            max_retries = 3\n            for attempt in range(max_retries):\n                try:\n                    cls.superusers[db] = User.objects.create_superuser(\n                        username='admin', password='something', email='test@test.org',\n                    )\n                    break\n                except Exception as e:\n                    if attempt == max_retries - 1:\n                        raise\n                    import time\n                    time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n            \n            # Retry logic for book creation\n            for attempt in range(max_retries):\n                try:\n                    b = Book(name='Test Book')\n                    b.save(using=db)\n                    cls.test_book_ids[db] = b.id\n                    break\n                except Exception as e:\n                    if attempt == max_retries - 1:\n                        raise\n                    import time\n                    time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n            \n            # Close connection to release SQLite file locks\n            connections[db].close()\n"
    ],
    "Location 2 (/root/hy/projects_3/django/tests/admin_views/test_multidb.py lines 39-41)": [
      "\n    @classmethod\n    def setUpTestData(cls):\n        cls.superusers = {}\n        cls.test_book_ids = {}\n        for db in connections:\n            Router.target_db = db\n            \n            # Retry mechanism for SQLite locking issues\n            max_retries = 3\n            for attempt in range(max_retries):\n                try:\n                    cls.superusers[db] = User.objects.create_superuser(\n                        username='admin', password='something', email='test@test.org',\n                    )\n                    break\n                except Exception as e:\n                    if attempt < max_retries - 1 and \"database is locked\" in str(e):\n                        import time\n                        time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n                        continue\n                    raise\n            \n            b = Book(name='Test Book')\n            \n            # Retry mechanism for book save operation\n            for attempt in range(max_retries):\n                try:\n                    b.save(using=db)\n                    break\n                except Exception as e:\n                    if attempt < max_retries - 1 and \"database is locked\" in str(e):\n                        import time\n                        time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n                        continue\n                    raise\n            \n            cls.test_book_ids[db] = b.id\n            \n            # Close connection to release SQLite file locks\n            connections[db].close()\n",
      "\n    @classmethod\n    def setUpTestData(cls):\n        cls.superusers = {}\n        cls.test_book_ids = {}\n        for db in connections:\n            Router.target_db = db\n            \n            # Create superuser with retry logic for SQLite locking issues\n            max_retries = 3\n            for attempt in range(max_retries):\n                try:\n                    cls.superusers[db] = User.objects.create_superuser(\n                        username='admin', password='something', email='test@test.org',\n                    )\n                    break\n                except Exception as e:\n                    if attempt == max_retries - 1:\n                        raise\n                    if 'database is locked' in str(e).lower():\n                        import time\n                        time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n                    else:\n                        raise\n            \n            b = Book(name='Test Book')\n            b.save(using=db)\n            cls.test_book_ids[db] = b.id\n            \n            # Close connection to release SQLite file locks\n            connections[db].close()\n",
      "\n    @classmethod\n    def setUpTestData(cls):\n        cls.superusers = {}\n        cls.test_book_ids = {}\n        for db in connections:\n            Router.target_db = db\n            # Create superuser with retry logic for SQLite lock issues\n            max_retries = 3\n            for attempt in range(max_retries):\n                try:\n                    cls.superusers[db] = User.objects.create_superuser(\n                        username='admin', password='something', email='test@test.org',\n                    )\n                    break\n                except Exception as e:\n                    if 'database is locked' in str(e) and attempt < max_retries - 1:\n                        import time\n                        time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n                        continue\n                    raise\n            \n            # Create book with retry logic\n            for attempt in range(max_retries):\n                try:\n                    b = Book(name='Test Book')\n                    b.save(using=db)\n                    cls.test_book_ids[db] = b.id\n                    break\n                except Exception as e:\n                    if 'database is locked' in str(e) and attempt < max_retries - 1:\n                        import time\n                        time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n                        continue\n                    raise\n            \n            # Close connection to release SQLite file locks\n            connections[db].close()\n",
      "\n    @classmethod\n    def setUpTestData(cls):\n        cls.superusers = {}\n        cls.test_book_ids = {}\n        for db in connections:\n            Router.target_db = db\n            # Retry mechanism for SQLite lock handling\n            max_retries = 3\n            for attempt in range(max_retries):\n                try:\n                    cls.superusers[db] = User.objects.create_superuser(\n                        username='admin', password='something', email='test@test.org',\n                    )\n                    break\n                except Exception as e:\n                    if attempt == max_retries - 1:\n                        raise\n                    if 'database is locked' in str(e).lower():\n                        import time\n                        time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n                    else:\n                        raise\n            b = Book(name='Test Book')\n            b.save(using=db)\n            cls.test_book_ids[db] = b.id\n            # Close connection to release SQLite file locks\n            connections[db].close()\n",
      "\n    @classmethod\n    def setUpTestData(cls):\n        cls.superusers = {}\n        cls.test_book_ids = {}\n        for db in connections:\n            Router.target_db = db\n            # Retry mechanism for SQLite lock handling\n            max_retries = 3\n            for attempt in range(max_retries):\n                try:\n                    cls.superusers[db] = User.objects.create_superuser(\n                        username='admin', password='something', email='test@test.org',\n                    )\n                    break\n                except Exception as e:\n                    if attempt < max_retries - 1 and 'database is locked' in str(e):\n                        import time\n                        time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n                        continue\n                    raise\n            b = Book(name='Test Book')\n            b.save(using=db)\n            cls.test_book_ids[db] = b.id\n            # Close connection to release SQLite file locks\n            connections[db].close()\n",
      "\n    @classmethod\n    def setUpTestData(cls):\n        cls.superusers = {}\n        cls.test_book_ids = {}\n        for db in connections:\n            Router.target_db = db\n            \n            # Create superuser with retry logic for SQLite lock issues\n            max_retries = 3\n            for attempt in range(max_retries):\n                try:\n                    cls.superusers[db] = User.objects.create_superuser(\n                        username='admin', password='something', email='test@test.org',\n                    )\n                    break\n                except Exception as e:\n                    if attempt == max_retries - 1:\n                        raise\n                    if 'database is locked' in str(e).lower():\n                        import time\n                        time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n                    else:\n                        raise\n            \n            b = Book(name='Test Book')\n            b.save(using=db)\n            cls.test_book_ids[db] = b.id\n            \n            # Close connection to release SQLite file locks\n            connections[db].close()\n",
      "\n    @classmethod\n    def setUpTestData(cls):\n        cls.superusers = {}\n        cls.test_book_ids = {}\n        for db in connections:\n            Router.target_db = db\n            # Retry mechanism for SQLite locking issues\n            max_retries = 3\n            for attempt in range(max_retries):\n                try:\n                    cls.superusers[db] = User.objects.create_superuser(\n                        username='admin', password='something', email='test@test.org',\n                    )\n                    break\n                except Exception as e:\n                    if attempt == max_retries - 1:\n                        raise\n                    import time\n                    time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n            \n            # Retry mechanism for Book creation\n            for attempt in range(max_retries):\n                try:\n                    b = Book(name='Test Book')\n                    b.save(using=db)\n                    cls.test_book_ids[db] = b.id\n                    break\n                except Exception as e:\n                    if attempt == max_retries - 1:\n                        raise\n                    import time\n                    time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n            \n            # Close connection to release SQLite file locks\n            connections[db].close()\n",
      "\n    @classmethod\n    def setUpTestData(cls):\n        cls.superusers = {}\n        cls.test_book_ids = {}\n        for db in connections:\n            Router.target_db = db\n            \n            # Retry mechanism for SQLite lock issues\n            max_retries = 3\n            for attempt in range(max_retries):\n                try:\n                    cls.superusers[db] = User.objects.create_superuser(\n                        username='admin', password='something', email='test@test.org',\n                    )\n                    break\n                except Exception as e:\n                    if attempt < max_retries - 1 and \"database is locked\" in str(e).lower():\n                        import time\n                        time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n                        continue\n                    raise\n            \n            b = Book(name='Test Book')\n            \n            # Retry mechanism for book save operation\n            for attempt in range(max_retries):\n                try:\n                    b.save(using=db)\n                    break\n                except Exception as e:\n                    if attempt < max_retries - 1 and \"database is locked\" in str(e).lower():\n                        import time\n                        time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n                        continue\n                    raise\n                    \n            cls.test_book_ids[db] = b.id\n            \n            # Close connection to release SQLite file locks\n            connections[db].close()\n"
    ],
    "Location 3 (/root/hy/projects_3/django/tests/admin_views/test_multidb.py lines 42-43)": [
      "\n        for db in connections:\n            Router.target_db = db\n            cls.superusers[db] = User.objects.create_superuser(\n                username='admin', password='something', email='test@test.org',\n            )\n            b = Book(name='Test Book')\n            b.save(using=db)\n            cls.test_book_ids[db] = b.id\n            # Close connection to release SQLite file locks\n            connections[db].close()\n",
      "\n    @classmethod\n    def setUpTestData(cls):\n        cls.superusers = {}\n        cls.test_book_ids = {}\n        for db in connections:\n            Router.target_db = db\n            cls.superusers[db] = User.objects.create_superuser(\n                username='admin', password='something', email='test@test.org',\n            )\n            b = Book(name='Test Book')\n            b.save(using=db)\n            cls.test_book_ids[db] = b.id\n            # Close connection to release SQLite file locks\n            connections[db].close()\n",
      "\n        for db in connections:\n            Router.target_db = db\n            cls.superusers[db] = User.objects.create_superuser(\n                username='admin', password='something', email='test@test.org',\n            )\n            b = Book(name='Test Book')\n            b.save(using=db)\n            cls.test_book_ids[db] = b.id\n            # Close connection to release SQLite file locks\n            connections[db].close()\n",
      "\n        for db in connections:\n            Router.target_db = db\n            cls.superusers[db] = User.objects.create_superuser(\n                username='admin', password='something', email='test@test.org',\n            )\n            b = Book(name='Test Book')\n            b.save(using=db)\n            cls.test_book_ids[db] = b.id\n            # Close connection to release SQLite file locks\n            connections[db].close()\n",
      "\n        for db in connections:\n            Router.target_db = db\n            cls.superusers[db] = User.objects.create_superuser(\n                username='admin', password='something', email='test@test.org',\n            )\n            b = Book(name='Test Book')\n            b.save(using=db)\n            cls.test_book_ids[db] = b.id\n            # Close connection to release SQLite file locks\n            connections[db].close()\n",
      "\n    @classmethod\n    def setUpTestData(cls):\n        cls.superusers = {}\n        cls.test_book_ids = {}\n        for db in connections:\n            Router.target_db = db\n            cls.superusers[db] = User.objects.create_superuser(\n                username='admin', password='something', email='test@test.org',\n            )\n            b = Book(name='Test Book')\n            b.save(using=db)\n            cls.test_book_ids[db] = b.id\n            # Close connection to release SQLite file locks before next iteration\n            connections[db].close()\n",
      "\n    @classmethod\n    def setUpTestData(cls):\n        cls.superusers = {}\n        cls.test_book_ids = {}\n        for db in connections:\n            Router.target_db = db\n            cls.superusers[db] = User.objects.create_superuser(\n                username='admin', password='something', email='test@test.org',\n            )\n            b = Book(name='Test Book')\n            b.save(using=db)\n            cls.test_book_ids[db] = b.id\n            # Close connection to release SQLite file locks\n            connections[db].close()\n",
      "\n        for db in connections:\n            Router.target_db = db\n            cls.superusers[db] = User.objects.create_superuser(\n                username='admin', password='something', email='test@test.org',\n            )\n            b = Book(name='Test Book')\n            b.save(using=db)\n            cls.test_book_ids[db] = b.id\n            # Close connection to release SQLite file locks\n            connections[db].close()\n"
    ],
    "Location 4 (/root/hy/projects_3/django/tests/admin_views/test_multidb.py lines 47-50)": [
      "\n    @mock.patch('django.contrib.admin.options.transaction')\n    def test_add_view(self, mock):\n        for db in connections:\n            with self.subTest(db=db):\n                Router.target_db = db\n                # Ensure clean connection state before test\n                connections[db].close()\n                self.client.force_login(self.superusers[db])\n                self.client.post(\n                    reverse('test_adminsite:admin_views_book_add'),\n                    {'name': 'Foobar: 5th edition'},\n                )\n                mock.atomic.assert_called_with(using=db)\n                # Clean up connection after each subtest\n                connections[db].close()\n",
      "\n    @mock.patch('django.contrib.admin.options.transaction')\n    def test_add_view(self, mock):\n        for db in connections:\n            with self.subTest(db=db):\n                Router.target_db = db\n                self.client.force_login(self.superusers[db])\n                self.client.post(\n                    reverse('test_adminsite:admin_views_book_add'),\n                    {'name': 'Foobar: 5th edition'},\n                )\n                mock.atomic.assert_called_with(using=db)\n                # Close connection to release SQLite file locks\n                connections[db].close()\n",
      "\n    @mock.patch('django.contrib.admin.options.transaction')\n    def test_add_view(self, mock):\n        for db in connections:\n            with self.subTest(db=db):\n                Router.target_db = db\n                try:\n                    self.client.force_login(self.superusers[db])\n                    self.client.post(\n                        reverse('test_adminsite:admin_views_book_add'),\n                        {'name': 'Foobar: 5th edition'},\n                    )\n                    mock.atomic.assert_called_with(using=db)\n                finally:\n                    # Close connection to release SQLite file locks\n                    connections[db].close()\n",
      "\n    @mock.patch('django.contrib.admin.options.transaction')\n    def test_add_view(self, mock):\n        for db in connections:\n            with self.subTest(db=db):\n                Router.target_db = db\n                try:\n                    self.client.force_login(self.superusers[db])\n                    self.client.post(\n                        reverse('test_adminsite:admin_views_book_add'),\n                        {'name': 'Foobar: 5th edition'},\n                    )\n                    mock.atomic.assert_called_with(using=db)\n                finally:\n                    # Close connection to release SQLite file locks\n                    connections[db].close()\n",
      "\n    @mock.patch('django.contrib.admin.options.transaction')\n    def test_add_view(self, mock):\n        for db in connections:\n            with self.subTest(db=db):\n                Router.target_db = db\n                try:\n                    self.client.force_login(self.superusers[db])\n                    self.client.post(\n                        reverse('test_adminsite:admin_views_book_add'),\n                        {'name': 'Foobar: 5th edition'},\n                    )\n                    mock.atomic.assert_called_with(using=db)\n                finally:\n                    # Ensure connection is closed to release SQLite file locks\n                    connections[db].close()\n",
      "\n    @mock.patch('django.contrib.admin.options.transaction')\n    def test_add_view(self, mock):\n        for db in connections:\n            with self.subTest(db=db):\n                Router.target_db = db\n                # Close connection to release SQLite file locks\n                connections[db].close()\n                self.client.force_login(self.superusers[db])\n                self.client.post(\n                    reverse('test_adminsite:admin_views_book_add'),\n                    {'name': 'Foobar: 5th edition'},\n                )\n                mock.atomic.assert_called_with(using=db)\n",
      "\n    @mock.patch('django.contrib.admin.options.transaction')\n    def test_add_view(self, mock):\n        for db in connections:\n            with self.subTest(db=db):\n                Router.target_db = db\n                try:\n                    self.client.force_login(self.superusers[db])\n                    self.client.post(\n                        reverse('test_adminsite:admin_views_book_add'),\n                        {'name': 'Foobar: 5th edition'},\n                    )\n                    mock.atomic.assert_called_with(using=db)\n                finally:\n                    # Ensure connection is properly closed to release SQLite locks\n                    connections[db].close()\n",
      "\n    @mock.patch('django.contrib.admin.options.transaction')\n    def test_add_view(self, mock):\n        for db in connections:\n            with self.subTest(db=db):\n                Router.target_db = db\n                try:\n                    self.client.force_login(self.superusers[db])\n                    self.client.post(\n                        reverse('test_adminsite:admin_views_book_add'),\n                        {'name': 'Foobar: 5th edition'},\n                    )\n                    mock.atomic.assert_called_with(using=db)\n                finally:\n                    # Clean up connection to prevent SQLite file locks\n                    connections[db].close()\n"
    ],
    "Location 5 (/root/hy/projects_3/django/django/db/backends/sqlite3/base.py lines 261-267)": [
      "\n    @async_unsafe\n    def close(self):\n        self.validate_thread_sharing()\n        # If database is in memory, closing the connection destroys the\n        # database. To prevent accidental data loss, ignore close requests on\n        # an in-memory db.\n        if not self.is_in_memory_db():\n            BaseDatabaseWrapper.close(self)\n            # Add a small delay for persistent SQLite databases to ensure\n            # file locks are fully released at the OS level\n            import time\n            time.sleep(0.05)\n",
      "\n    @async_unsafe\n    def close(self):\n        self.validate_thread_sharing()\n        # If database is in memory, closing the connection destroys the\n        # database. To prevent accidental data loss, ignore close requests on\n        # an in-memory db.\n        if not self.is_in_memory_db():\n            BaseDatabaseWrapper.close(self)\n            # Add a small delay to ensure SQLite file handle is fully released\n            # This helps prevent \"database is locked\" errors in multi-database scenarios\n            import time\n            time.sleep(0.05)\n",
      "\n    @async_unsafe\n    def close(self):\n        self.validate_thread_sharing()\n        # If database is in memory, closing the connection destroys the\n        # database. To prevent accidental data loss, ignore close requests on\n        # an in-memory db.\n        if not self.is_in_memory_db():\n            BaseDatabaseWrapper.close(self)\n            # Add a small delay for persistent SQLite databases to ensure\n            # file locks are fully released at the OS level\n            import time\n            time.sleep(0.05)\n",
      "\n    @async_unsafe\n    def close(self):\n        self.validate_thread_sharing()\n        # If database is in memory, closing the connection destroys the\n        # database. To prevent accidental data loss, ignore close requests on\n        # an in-memory db.\n        if not self.is_in_memory_db():\n            BaseDatabaseWrapper.close(self)\n            # Add a small delay for persistent SQLite databases to ensure\n            # file handles are fully released at the OS level\n            import time\n            time.sleep(0.05)\n",
      "\n    @async_unsafe\n    def close(self):\n        self.validate_thread_sharing()\n        # If database is in memory, closing the connection destroys the\n        # database. To prevent accidental data loss, ignore close requests on\n        # an in-memory db.\n        if not self.is_in_memory_db():\n            BaseDatabaseWrapper.close(self)\n            # Add a small delay for persistent SQLite databases to ensure\n            # file locks are fully released at the OS level\n            import time\n            time.sleep(0.05)\n",
      "\n    @async_unsafe\n    def close(self):\n        self.validate_thread_sharing()\n        # If database is in memory, closing the connection destroys the\n        # database. To prevent accidental data loss, ignore close requests on\n        # an in-memory db.\n        if not self.is_in_memory_db():\n            BaseDatabaseWrapper.close(self)\n            # Add a small delay to ensure SQLite file handle is fully released\n            # at the OS level, preventing lock issues with persistent databases\n            import time\n            time.sleep(0.05)\n",
      "\n    @async_unsafe\n    def close(self):\n        self.validate_thread_sharing()\n        # If database is in memory, closing the connection destroys the\n        # database. To prevent accidental data loss, ignore close requests on\n        # an in-memory db.\n        if not self.is_in_memory_db():\n            BaseDatabaseWrapper.close(self)\n            # Add a small delay for persistent SQLite databases to ensure\n            # file locks are properly released at the OS level\n            import time\n            time.sleep(0.05)\n",
      "\n    @async_unsafe\n    def close(self):\n        self.validate_thread_sharing()\n        # If database is in memory, closing the connection destroys the\n        # database. To prevent accidental data loss, ignore close requests on\n        # an in-memory db.\n        if not self.is_in_memory_db():\n            BaseDatabaseWrapper.close(self)\n            # Add a small delay for persistent SQLite databases to ensure\n            # file locks are fully released at the OS level\n            import time\n            time.sleep(0.05)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/backends/sqlite3/base.py b/django/db/backends/sqlite3/base.py\nindex a3ae1f048e..5b0ca37661 100644\n--- a/django/db/backends/sqlite3/base.py\n+++ b/django/db/backends/sqlite3/base.py\n@@ -258,6 +258,7 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n         return self.connection.cursor(factory=SQLiteCursorWrapper)\n \n     @async_unsafe\n+\n     def close(self):\n         self.validate_thread_sharing()\n         # If database is in memory, closing the connection destroys the\n@@ -265,6 +266,9 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n         # an in-memory db.\n         if not self.is_in_memory_db():\n             BaseDatabaseWrapper.close(self)\n+            # Add small delay to ensure SQLite file handle is fully released\n+            import time\n+            time.sleep(0.05)\n \n     def _savepoint_allowed(self):\n         # When 'isolation_level' is not None, sqlite3 commits before each\ndiff --git a/tests/admin_views/test_multidb.py b/tests/admin_views/test_multidb.py\nindex a02b637d34..22ab4063fb 100644\n--- a/tests/admin_views/test_multidb.py\n+++ b/tests/admin_views/test_multidb.py\n@@ -34,6 +34,7 @@ class MultiDatabaseTests(TestCase):\n     def setUpTestData(cls):\n         cls.superusers = {}\n         cls.test_book_ids = {}\n+\n         for db in connections:\n             Router.target_db = db\n             cls.superusers[db] = User.objects.create_superuser(\n@@ -42,8 +43,13 @@ class MultiDatabaseTests(TestCase):\n             b = Book(name='Test Book')\n             b.save(using=db)\n             cls.test_book_ids[db] = b.id\n+            # Close connection to release SQLite file locks for persistent databases\n+            connections[db].close()\n+            b.save(using=db)\n+            cls.test_book_ids[db] = b.id\n \n     @mock.patch('django.contrib.admin.options.transaction')\n+\n     def test_add_view(self, mock):\n         for db in connections:\n             with self.subTest(db=db):\n",
    "variant_0": "diff --git a/django/db/backends/sqlite3/base.py b/django/db/backends/sqlite3/base.py\nindex a3ae1f048e..4496136117 100644\n--- a/django/db/backends/sqlite3/base.py\n+++ b/django/db/backends/sqlite3/base.py\n@@ -257,6 +257,8 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n     def create_cursor(self, name=None):\n         return self.connection.cursor(factory=SQLiteCursorWrapper)\n \n+    @async_unsafe\n+\n     @async_unsafe\n     def close(self):\n         self.validate_thread_sharing()\n@@ -265,6 +267,10 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n         # an in-memory db.\n         if not self.is_in_memory_db():\n             BaseDatabaseWrapper.close(self)\n+            # Add a small delay for persistent SQLite databases to ensure\n+            # file locks are fully released at the OS level\n+            import time\n+            time.sleep(0.05)\n \n     def _savepoint_allowed(self):\n         # When 'isolation_level' is not None, sqlite3 commits before each\ndiff --git a/tests/admin_views/test_multidb.py b/tests/admin_views/test_multidb.py\nindex a02b637d34..feeaad2f39 100644\n--- a/tests/admin_views/test_multidb.py\n+++ b/tests/admin_views/test_multidb.py\n@@ -30,6 +30,82 @@ urlpatterns = [\n class MultiDatabaseTests(TestCase):\n     databases = {'default', 'other'}\n \n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.superusers = {}\n+        cls.test_book_ids = {}\n+\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.superusers = {}\n+        cls.test_book_ids = {}\n+        for db in connections:\n+            Router.target_db = db\n+            \n+            # Retry mechanism for SQLite locking issues\n+            max_retries = 3\n+            base_delay = 0.1\n+            \n+            # Create superuser with retry logic\n+            for attempt in range(max_retries):\n+                try:\n+                    cls.superusers[db] = User.objects.create_superuser(\n+                        username='admin', password='something', email='test@test.org',\n+                    )\n+                    break\n+                except Exception as e:\n+                    if attempt == max_retries - 1:\n+                        raise\n+                    if 'database is locked' in str(e).lower():\n+                        import time\n+                        time.sleep(base_delay * (2 ** attempt))\n+                    else:\n+                        raise\n+            \n+            # Create book with retry logic\n+            for attempt in range(max_retries):\n+                try:\n+                    b = Book(name='Test Book')\n+                    b.save(using=db)\n+                    cls.test_book_ids[db] = b.id\n+                    break\n+                except Exception as e:\n+                    if attempt == max_retries - 1:\n+                        raise\n+                    if 'database is locked' in str(e).lower():\n+                        import time\n+                        time.sleep(base_delay * (2 ** attempt))\n+                    else:\n+                        raise\n+            \n+            # Ensure connection is properly closed before next iteration\n+            connections[db].close()\n+            Router.target_db = db\n+            \n+            # Create superuser with retry logic for SQLite lock issues\n+            max_retries = 3\n+            for attempt in range(max_retries):\n+                try:\n+                    cls.superusers[db] = User.objects.create_superuser(\n+                        username='admin', password='something', email='test@test.org',\n+                    )\n+                    break\n+                except Exception as e:\n+                    if attempt == max_retries - 1:\n+                        raise\n+                    if 'database is locked' in str(e).lower():\n+                        import time\n+                        time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n+                    else:\n+                        raise\n+            \n+            b = Book(name='Test Book')\n+            b.save(using=db)\n+            cls.test_book_ids[db] = b.id\n+            \n+            # Close connection to release SQLite file locks\n+            connections[db].close()\n+\n     @classmethod\n     def setUpTestData(cls):\n         cls.superusers = {}\n@@ -42,12 +118,28 @@ class MultiDatabaseTests(TestCase):\n             b = Book(name='Test Book')\n             b.save(using=db)\n             cls.test_book_ids[db] = b.id\n+            # Close connection to release SQLite file locks\n+            connections[db].close()\n+            cls.test_book_ids[db] = b.id\n+\n+    @mock.patch('django.contrib.admin.options.transaction')\n \n     @mock.patch('django.contrib.admin.options.transaction')\n     def test_add_view(self, mock):\n         for db in connections:\n             with self.subTest(db=db):\n                 Router.target_db = db\n+                # Ensure clean connection state for SQLite\n+                try:\n+                    connections[db].close()\n+                except Exception:\n+                    pass\n+                self.client.force_login(self.superusers[db])\n+                self.client.post(\n+                    reverse('test_adminsite:admin_views_book_add'),\n+                    {'name': 'Foobar: 5th edition'},\n+                )\n+                mock.atomic.assert_called_with(using=db)\n                 self.client.force_login(self.superusers[db])\n                 self.client.post(\n                     reverse('test_adminsite:admin_views_book_add'),\n",
    "variant_1": "diff --git a/django/db/backends/sqlite3/base.py b/django/db/backends/sqlite3/base.py\nindex a3ae1f048e..4496136117 100644\n--- a/django/db/backends/sqlite3/base.py\n+++ b/django/db/backends/sqlite3/base.py\n@@ -257,6 +257,8 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n     def create_cursor(self, name=None):\n         return self.connection.cursor(factory=SQLiteCursorWrapper)\n \n+    @async_unsafe\n+\n     @async_unsafe\n     def close(self):\n         self.validate_thread_sharing()\n@@ -265,6 +267,10 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n         # an in-memory db.\n         if not self.is_in_memory_db():\n             BaseDatabaseWrapper.close(self)\n+            # Add a small delay for persistent SQLite databases to ensure\n+            # file locks are fully released at the OS level\n+            import time\n+            time.sleep(0.05)\n \n     def _savepoint_allowed(self):\n         # When 'isolation_level' is not None, sqlite3 commits before each\ndiff --git a/tests/admin_views/test_multidb.py b/tests/admin_views/test_multidb.py\nindex a02b637d34..6bf9949b9a 100644\n--- a/tests/admin_views/test_multidb.py\n+++ b/tests/admin_views/test_multidb.py\n@@ -34,6 +34,72 @@ class MultiDatabaseTests(TestCase):\n     def setUpTestData(cls):\n         cls.superusers = {}\n         cls.test_book_ids = {}\n+\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.superusers = {}\n+        cls.test_book_ids = {}\n+        for db in connections:\n+            Router.target_db = db\n+            \n+            # Retry mechanism for SQLite lock handling\n+            max_retries = 3\n+            retry_count = 0\n+            while retry_count < max_retries:\n+                try:\n+                    cls.superusers[db] = User.objects.create_superuser(\n+                        username='admin', password='something', email='test@test.org',\n+                    )\n+                    b = Book(name='Test Book')\n+                    b.save(using=db)\n+                    cls.test_book_ids[db] = b.id\n+                    break\n+                except Exception as e:\n+                    if \"database is locked\" in str(e) and retry_count < max_retries - 1:\n+                        retry_count += 1\n+                        import time\n+                        time.sleep(0.1 * (2 ** (retry_count - 1)))  # Exponential backoff\n+                    else:\n+                        raise\n+            \n+            # Close connection to release SQLite file locks\n+            connections[db].close()\n+            Router.target_db = db\n+            \n+            # Retry mechanism for SQLite locking issues\n+            max_retries = 3\n+            for attempt in range(max_retries):\n+                try:\n+                    cls.superusers[db] = User.objects.create_superuser(\n+                        username='admin', password='something', email='test@test.org',\n+                    )\n+                    break\n+                except Exception as e:\n+                    if attempt < max_retries - 1 and \"database is locked\" in str(e):\n+                        import time\n+                        time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n+                        continue\n+                    raise\n+            \n+            b = Book(name='Test Book')\n+            \n+            # Retry mechanism for book save operation\n+            for attempt in range(max_retries):\n+                try:\n+                    b.save(using=db)\n+                    break\n+                except Exception as e:\n+                    if attempt < max_retries - 1 and \"database is locked\" in str(e):\n+                        import time\n+                        time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n+                        continue\n+                    raise\n+            \n+            cls.test_book_ids[db] = b.id\n+            \n+            # Close connection to release SQLite file locks\n+            connections[db].close()\n+\n         for db in connections:\n             Router.target_db = db\n             cls.superusers[db] = User.objects.create_superuser(\n@@ -42,12 +108,27 @@ class MultiDatabaseTests(TestCase):\n             b = Book(name='Test Book')\n             b.save(using=db)\n             cls.test_book_ids[db] = b.id\n+            # Close connection to release SQLite file locks\n+            connections[db].close()\n+            cls.test_book_ids[db] = b.id\n+\n+    @mock.patch('django.contrib.admin.options.transaction')\n \n     @mock.patch('django.contrib.admin.options.transaction')\n     def test_add_view(self, mock):\n         for db in connections:\n             with self.subTest(db=db):\n                 Router.target_db = db\n+                # Ensure clean connection state before test\n+                connections[db].close()\n+                self.client.force_login(self.superusers[db])\n+                self.client.post(\n+                    reverse('test_adminsite:admin_views_book_add'),\n+                    {'name': 'Foobar: 5th edition'},\n+                )\n+                mock.atomic.assert_called_with(using=db)\n+                # Clean up connection after each subtest\n+                connections[db].close()\n                 self.client.force_login(self.superusers[db])\n                 self.client.post(\n                     reverse('test_adminsite:admin_views_book_add'),\n",
    "variant_2": "diff --git a/django/db/backends/sqlite3/base.py b/django/db/backends/sqlite3/base.py\nindex a3ae1f048e..f2b0f6cb88 100644\n--- a/django/db/backends/sqlite3/base.py\n+++ b/django/db/backends/sqlite3/base.py\n@@ -257,6 +257,8 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n     def create_cursor(self, name=None):\n         return self.connection.cursor(factory=SQLiteCursorWrapper)\n \n+    @async_unsafe\n+\n     @async_unsafe\n     def close(self):\n         self.validate_thread_sharing()\n@@ -265,6 +267,10 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n         # an in-memory db.\n         if not self.is_in_memory_db():\n             BaseDatabaseWrapper.close(self)\n+            # Add a small delay to ensure SQLite file handle is fully released\n+            # This helps prevent \"database is locked\" errors in multi-database scenarios\n+            import time\n+            time.sleep(0.05)\n \n     def _savepoint_allowed(self):\n         # When 'isolation_level' is not None, sqlite3 commits before each\ndiff --git a/tests/admin_views/test_multidb.py b/tests/admin_views/test_multidb.py\nindex a02b637d34..a1644874da 100644\n--- a/tests/admin_views/test_multidb.py\n+++ b/tests/admin_views/test_multidb.py\n@@ -30,6 +30,75 @@ urlpatterns = [\n class MultiDatabaseTests(TestCase):\n     databases = {'default', 'other'}\n \n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.superusers = {}\n+        cls.test_book_ids = {}\n+\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.superusers = {}\n+        cls.test_book_ids = {}\n+        for db in connections:\n+            Router.target_db = db\n+            \n+            # Retry mechanism for SQLite lock handling\n+            max_retries = 3\n+            for attempt in range(max_retries):\n+                try:\n+                    cls.superusers[db] = User.objects.create_superuser(\n+                        username='admin', password='something', email='test@test.org',\n+                    )\n+                    break\n+                except Exception as e:\n+                    if 'database is locked' in str(e) and attempt < max_retries - 1:\n+                        import time\n+                        time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n+                        continue\n+                    raise\n+            \n+            # Retry mechanism for Book creation\n+            for attempt in range(max_retries):\n+                try:\n+                    b = Book(name='Test Book')\n+                    b.save(using=db)\n+                    cls.test_book_ids[db] = b.id\n+                    break\n+                except Exception as e:\n+                    if 'database is locked' in str(e) and attempt < max_retries - 1:\n+                        import time\n+                        time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n+                        continue\n+                    raise\n+            \n+            # Close connection to release SQLite file locks\n+            connections[db].close()\n+            Router.target_db = db\n+            \n+            # Create superuser with retry logic for SQLite locking issues\n+            max_retries = 3\n+            for attempt in range(max_retries):\n+                try:\n+                    cls.superusers[db] = User.objects.create_superuser(\n+                        username='admin', password='something', email='test@test.org',\n+                    )\n+                    break\n+                except Exception as e:\n+                    if attempt == max_retries - 1:\n+                        raise\n+                    if 'database is locked' in str(e).lower():\n+                        import time\n+                        time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n+                    else:\n+                        raise\n+            \n+            b = Book(name='Test Book')\n+            b.save(using=db)\n+            cls.test_book_ids[db] = b.id\n+            \n+            # Close connection to release SQLite file locks\n+            connections[db].close()\n+\n     @classmethod\n     def setUpTestData(cls):\n         cls.superusers = {}\n@@ -42,6 +111,11 @@ class MultiDatabaseTests(TestCase):\n             b = Book(name='Test Book')\n             b.save(using=db)\n             cls.test_book_ids[db] = b.id\n+            # Close connection to release SQLite file locks\n+            connections[db].close()\n+            cls.test_book_ids[db] = b.id\n+\n+    @mock.patch('django.contrib.admin.options.transaction')\n \n     @mock.patch('django.contrib.admin.options.transaction')\n     def test_add_view(self, mock):\n@@ -54,6 +128,14 @@ class MultiDatabaseTests(TestCase):\n                     {'name': 'Foobar: 5th edition'},\n                 )\n                 mock.atomic.assert_called_with(using=db)\n+                # Close connection to release SQLite file locks\n+                connections[db].close()\n+                self.client.force_login(self.superusers[db])\n+                self.client.post(\n+                    reverse('test_adminsite:admin_views_book_add'),\n+                    {'name': 'Foobar: 5th edition'},\n+                )\n+                mock.atomic.assert_called_with(using=db)\n \n     @mock.patch('django.contrib.admin.options.transaction')\n     def test_change_view(self, mock):\n",
    "variant_3": "diff --git a/django/db/backends/sqlite3/base.py b/django/db/backends/sqlite3/base.py\nindex a3ae1f048e..4496136117 100644\n--- a/django/db/backends/sqlite3/base.py\n+++ b/django/db/backends/sqlite3/base.py\n@@ -257,6 +257,8 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n     def create_cursor(self, name=None):\n         return self.connection.cursor(factory=SQLiteCursorWrapper)\n \n+    @async_unsafe\n+\n     @async_unsafe\n     def close(self):\n         self.validate_thread_sharing()\n@@ -265,6 +267,10 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n         # an in-memory db.\n         if not self.is_in_memory_db():\n             BaseDatabaseWrapper.close(self)\n+            # Add a small delay for persistent SQLite databases to ensure\n+            # file locks are fully released at the OS level\n+            import time\n+            time.sleep(0.05)\n \n     def _savepoint_allowed(self):\n         # When 'isolation_level' is not None, sqlite3 commits before each\ndiff --git a/tests/admin_views/test_multidb.py b/tests/admin_views/test_multidb.py\nindex a02b637d34..dbe7bbc656 100644\n--- a/tests/admin_views/test_multidb.py\n+++ b/tests/admin_views/test_multidb.py\n@@ -34,6 +34,76 @@ class MultiDatabaseTests(TestCase):\n     def setUpTestData(cls):\n         cls.superusers = {}\n         cls.test_book_ids = {}\n+\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.superusers = {}\n+        cls.test_book_ids = {}\n+        for db in connections:\n+            Router.target_db = db\n+            \n+            # Retry mechanism for SQLite database lock issues\n+            max_retries = 3\n+            for attempt in range(max_retries):\n+                try:\n+                    cls.superusers[db] = User.objects.create_superuser(\n+                        username='admin', password='something', email='test@test.org',\n+                    )\n+                    break\n+                except Exception as e:\n+                    if attempt == max_retries - 1:\n+                        raise\n+                    import time\n+                    time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n+            \n+            # Retry mechanism for book creation\n+            for attempt in range(max_retries):\n+                try:\n+                    b = Book(name='Test Book')\n+                    b.save(using=db)\n+                    cls.test_book_ids[db] = b.id\n+                    break\n+                except Exception as e:\n+                    if attempt == max_retries - 1:\n+                        raise\n+                    import time\n+                    time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n+            \n+            # Close connection to release SQLite file locks\n+            connections[db].close()\n+            Router.target_db = db\n+            # Create superuser with retry logic for SQLite lock issues\n+            max_retries = 3\n+            for attempt in range(max_retries):\n+                try:\n+                    cls.superusers[db] = User.objects.create_superuser(\n+                        username='admin', password='something', email='test@test.org',\n+                    )\n+                    break\n+                except Exception as e:\n+                    if 'database is locked' in str(e) and attempt < max_retries - 1:\n+                        import time\n+                        time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n+                        continue\n+                    raise\n+            \n+            # Create book with retry logic\n+            for attempt in range(max_retries):\n+                try:\n+                    b = Book(name='Test Book')\n+                    b.save(using=db)\n+                    cls.test_book_ids[db] = b.id\n+                    break\n+                except Exception as e:\n+                    if 'database is locked' in str(e) and attempt < max_retries - 1:\n+                        import time\n+                        time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n+                        continue\n+                    raise\n+            \n+            # Close connection to release SQLite file locks\n+            connections[db].close()\n+\n         for db in connections:\n             Router.target_db = db\n             cls.superusers[db] = User.objects.create_superuser(\n@@ -42,12 +112,27 @@ class MultiDatabaseTests(TestCase):\n             b = Book(name='Test Book')\n             b.save(using=db)\n             cls.test_book_ids[db] = b.id\n+            # Close connection to release SQLite file locks\n+            connections[db].close()\n+            cls.test_book_ids[db] = b.id\n+\n+    @mock.patch('django.contrib.admin.options.transaction')\n \n     @mock.patch('django.contrib.admin.options.transaction')\n     def test_add_view(self, mock):\n         for db in connections:\n             with self.subTest(db=db):\n                 Router.target_db = db\n+                try:\n+                    self.client.force_login(self.superusers[db])\n+                    self.client.post(\n+                        reverse('test_adminsite:admin_views_book_add'),\n+                        {'name': 'Foobar: 5th edition'},\n+                    )\n+                    mock.atomic.assert_called_with(using=db)\n+                finally:\n+                    # Close connection to release SQLite file locks\n+                    connections[db].close()\n                 self.client.force_login(self.superusers[db])\n                 self.client.post(\n                     reverse('test_adminsite:admin_views_book_add'),\n",
    "variant_4": "diff --git a/django/db/backends/sqlite3/base.py b/django/db/backends/sqlite3/base.py\nindex a3ae1f048e..843062e7ca 100644\n--- a/django/db/backends/sqlite3/base.py\n+++ b/django/db/backends/sqlite3/base.py\n@@ -257,6 +257,8 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n     def create_cursor(self, name=None):\n         return self.connection.cursor(factory=SQLiteCursorWrapper)\n \n+    @async_unsafe\n+\n     @async_unsafe\n     def close(self):\n         self.validate_thread_sharing()\n@@ -265,6 +267,10 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n         # an in-memory db.\n         if not self.is_in_memory_db():\n             BaseDatabaseWrapper.close(self)\n+            # Add a small delay for persistent SQLite databases to ensure\n+            # file handles are fully released at the OS level\n+            import time\n+            time.sleep(0.05)\n \n     def _savepoint_allowed(self):\n         # When 'isolation_level' is not None, sqlite3 commits before each\ndiff --git a/tests/admin_views/test_multidb.py b/tests/admin_views/test_multidb.py\nindex a02b637d34..89a56ac19e 100644\n--- a/tests/admin_views/test_multidb.py\n+++ b/tests/admin_views/test_multidb.py\n@@ -30,10 +30,77 @@ urlpatterns = [\n class MultiDatabaseTests(TestCase):\n     databases = {'default', 'other'}\n \n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.superusers = {}\n+        cls.test_book_ids = {}\n+\n     @classmethod\n     def setUpTestData(cls):\n         cls.superusers = {}\n         cls.test_book_ids = {}\n+        for db in connections:\n+            Router.target_db = db\n+            \n+            # Retry mechanism for SQLite lock handling\n+            max_retries = 3\n+            retry_delay = 0.1\n+            \n+            for attempt in range(max_retries):\n+                try:\n+                    cls.superusers[db] = User.objects.create_superuser(\n+                        username='admin', password='something', email='test@test.org',\n+                    )\n+                    break\n+                except Exception as e:\n+                    if attempt == max_retries - 1:\n+                        raise\n+                    if 'database is locked' in str(e).lower():\n+                        import time\n+                        time.sleep(retry_delay * (2 ** attempt))\n+                    else:\n+                        raise\n+            \n+            for attempt in range(max_retries):\n+                try:\n+                    b = Book(name='Test Book')\n+                    b.save(using=db)\n+                    cls.test_book_ids[db] = b.id\n+                    break\n+                except Exception as e:\n+                    if attempt == max_retries - 1:\n+                        raise\n+                    if 'database is locked' in str(e).lower():\n+                        import time\n+                        time.sleep(retry_delay * (2 ** attempt))\n+                    else:\n+                        raise\n+            \n+            # Close connection to release SQLite file locks\n+            connections[db].close()\n+            Router.target_db = db\n+            # Retry mechanism for SQLite lock handling\n+            max_retries = 3\n+            for attempt in range(max_retries):\n+                try:\n+                    cls.superusers[db] = User.objects.create_superuser(\n+                        username='admin', password='something', email='test@test.org',\n+                    )\n+                    break\n+                except Exception as e:\n+                    if attempt == max_retries - 1:\n+                        raise\n+                    if 'database is locked' in str(e).lower():\n+                        import time\n+                        time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n+                    else:\n+                        raise\n+            b = Book(name='Test Book')\n+            b.save(using=db)\n+            cls.test_book_ids[db] = b.id\n+            # Close connection to release SQLite file locks\n+            connections[db].close()\n+\n         for db in connections:\n             Router.target_db = db\n             cls.superusers[db] = User.objects.create_superuser(\n@@ -42,12 +109,27 @@ class MultiDatabaseTests(TestCase):\n             b = Book(name='Test Book')\n             b.save(using=db)\n             cls.test_book_ids[db] = b.id\n+            # Close connection to release SQLite file locks\n+            connections[db].close()\n+            cls.test_book_ids[db] = b.id\n+\n+    @mock.patch('django.contrib.admin.options.transaction')\n \n     @mock.patch('django.contrib.admin.options.transaction')\n     def test_add_view(self, mock):\n         for db in connections:\n             with self.subTest(db=db):\n                 Router.target_db = db\n+                try:\n+                    self.client.force_login(self.superusers[db])\n+                    self.client.post(\n+                        reverse('test_adminsite:admin_views_book_add'),\n+                        {'name': 'Foobar: 5th edition'},\n+                    )\n+                    mock.atomic.assert_called_with(using=db)\n+                finally:\n+                    # Close connection to release SQLite file locks\n+                    connections[db].close()\n                 self.client.force_login(self.superusers[db])\n                 self.client.post(\n                     reverse('test_adminsite:admin_views_book_add'),\n",
    "variant_5": "diff --git a/django/db/backends/sqlite3/base.py b/django/db/backends/sqlite3/base.py\nindex a3ae1f048e..4496136117 100644\n--- a/django/db/backends/sqlite3/base.py\n+++ b/django/db/backends/sqlite3/base.py\n@@ -257,6 +257,8 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n     def create_cursor(self, name=None):\n         return self.connection.cursor(factory=SQLiteCursorWrapper)\n \n+    @async_unsafe\n+\n     @async_unsafe\n     def close(self):\n         self.validate_thread_sharing()\n@@ -265,6 +267,10 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n         # an in-memory db.\n         if not self.is_in_memory_db():\n             BaseDatabaseWrapper.close(self)\n+            # Add a small delay for persistent SQLite databases to ensure\n+            # file locks are fully released at the OS level\n+            import time\n+            time.sleep(0.05)\n \n     def _savepoint_allowed(self):\n         # When 'isolation_level' is not None, sqlite3 commits before each\ndiff --git a/tests/admin_views/test_multidb.py b/tests/admin_views/test_multidb.py\nindex a02b637d34..eb6caaa1ad 100644\n--- a/tests/admin_views/test_multidb.py\n+++ b/tests/admin_views/test_multidb.py\n@@ -30,10 +30,68 @@ urlpatterns = [\n class MultiDatabaseTests(TestCase):\n     databases = {'default', 'other'}\n \n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.superusers = {}\n+        cls.test_book_ids = {}\n+\n     @classmethod\n     def setUpTestData(cls):\n         cls.superusers = {}\n         cls.test_book_ids = {}\n+        for db in connections:\n+            Router.target_db = db\n+            \n+            # Create superuser with retry logic for SQLite locking\n+            max_retries = 3\n+            for attempt in range(max_retries):\n+                try:\n+                    cls.superusers[db] = User.objects.create_superuser(\n+                        username='admin', password='something', email='test@test.org',\n+                    )\n+                    break\n+                except Exception as e:\n+                    if attempt == max_retries - 1:\n+                        raise\n+                    import time\n+                    time.sleep(0.1 * (2 ** attempt))\n+            \n+            # Create book with retry logic for SQLite locking\n+            for attempt in range(max_retries):\n+                try:\n+                    b = Book(name='Test Book')\n+                    b.save(using=db)\n+                    cls.test_book_ids[db] = b.id\n+                    break\n+                except Exception as e:\n+                    if attempt == max_retries - 1:\n+                        raise\n+                    import time\n+                    time.sleep(0.1 * (2 ** attempt))\n+            \n+            # Close connection to release SQLite file locks\n+            connections[db].close()\n+            Router.target_db = db\n+            # Retry mechanism for SQLite lock handling\n+            max_retries = 3\n+            for attempt in range(max_retries):\n+                try:\n+                    cls.superusers[db] = User.objects.create_superuser(\n+                        username='admin', password='something', email='test@test.org',\n+                    )\n+                    break\n+                except Exception as e:\n+                    if attempt < max_retries - 1 and 'database is locked' in str(e):\n+                        import time\n+                        time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n+                        continue\n+                    raise\n+            b = Book(name='Test Book')\n+            b.save(using=db)\n+            cls.test_book_ids[db] = b.id\n+            # Close connection to release SQLite file locks\n+            connections[db].close()\n+\n         for db in connections:\n             Router.target_db = db\n             cls.superusers[db] = User.objects.create_superuser(\n@@ -42,12 +100,27 @@ class MultiDatabaseTests(TestCase):\n             b = Book(name='Test Book')\n             b.save(using=db)\n             cls.test_book_ids[db] = b.id\n+            # Close connection to release SQLite file locks\n+            connections[db].close()\n+            cls.test_book_ids[db] = b.id\n+\n+    @mock.patch('django.contrib.admin.options.transaction')\n \n     @mock.patch('django.contrib.admin.options.transaction')\n     def test_add_view(self, mock):\n         for db in connections:\n             with self.subTest(db=db):\n                 Router.target_db = db\n+                try:\n+                    self.client.force_login(self.superusers[db])\n+                    self.client.post(\n+                        reverse('test_adminsite:admin_views_book_add'),\n+                        {'name': 'Foobar: 5th edition'},\n+                    )\n+                    mock.atomic.assert_called_with(using=db)\n+                finally:\n+                    # Ensure connection is closed to release SQLite file locks\n+                    connections[db].close()\n                 self.client.force_login(self.superusers[db])\n                 self.client.post(\n                     reverse('test_adminsite:admin_views_book_add'),\n",
    "variant_6": "diff --git a/django/db/backends/sqlite3/base.py b/django/db/backends/sqlite3/base.py\nindex a3ae1f048e..935ddb2290 100644\n--- a/django/db/backends/sqlite3/base.py\n+++ b/django/db/backends/sqlite3/base.py\n@@ -257,6 +257,8 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n     def create_cursor(self, name=None):\n         return self.connection.cursor(factory=SQLiteCursorWrapper)\n \n+    @async_unsafe\n+\n     @async_unsafe\n     def close(self):\n         self.validate_thread_sharing()\n@@ -265,6 +267,10 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n         # an in-memory db.\n         if not self.is_in_memory_db():\n             BaseDatabaseWrapper.close(self)\n+            # Add a small delay to ensure SQLite file handle is fully released\n+            # at the OS level, preventing lock issues with persistent databases\n+            import time\n+            time.sleep(0.05)\n \n     def _savepoint_allowed(self):\n         # When 'isolation_level' is not None, sqlite3 commits before each\ndiff --git a/tests/admin_views/test_multidb.py b/tests/admin_views/test_multidb.py\nindex a02b637d34..ef569b64ff 100644\n--- a/tests/admin_views/test_multidb.py\n+++ b/tests/admin_views/test_multidb.py\n@@ -30,6 +30,75 @@ urlpatterns = [\n class MultiDatabaseTests(TestCase):\n     databases = {'default', 'other'}\n \n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.superusers = {}\n+        cls.test_book_ids = {}\n+\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.superusers = {}\n+        cls.test_book_ids = {}\n+        for db in connections:\n+            Router.target_db = db\n+            \n+            # Retry logic for SQLite database lock issues\n+            max_retries = 3\n+            for attempt in range(max_retries):\n+                try:\n+                    cls.superusers[db] = User.objects.create_superuser(\n+                        username='admin', password='something', email='test@test.org',\n+                    )\n+                    break\n+                except Exception as e:\n+                    if attempt < max_retries - 1 and 'database is locked' in str(e):\n+                        import time\n+                        time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n+                        continue\n+                    raise\n+            \n+            # Retry logic for Book creation\n+            for attempt in range(max_retries):\n+                try:\n+                    b = Book(name='Test Book')\n+                    b.save(using=db)\n+                    cls.test_book_ids[db] = b.id\n+                    break\n+                except Exception as e:\n+                    if attempt < max_retries - 1 and 'database is locked' in str(e):\n+                        import time\n+                        time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n+                        continue\n+                    raise\n+            \n+            # Clean up connection to release SQLite file locks\n+            connections[db].close()\n+            Router.target_db = db\n+            \n+            # Create superuser with retry logic for SQLite lock issues\n+            max_retries = 3\n+            for attempt in range(max_retries):\n+                try:\n+                    cls.superusers[db] = User.objects.create_superuser(\n+                        username='admin', password='something', email='test@test.org',\n+                    )\n+                    break\n+                except Exception as e:\n+                    if attempt == max_retries - 1:\n+                        raise\n+                    if 'database is locked' in str(e).lower():\n+                        import time\n+                        time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n+                    else:\n+                        raise\n+            \n+            b = Book(name='Test Book')\n+            b.save(using=db)\n+            cls.test_book_ids[db] = b.id\n+            \n+            # Close connection to release SQLite file locks\n+            connections[db].close()\n+\n     @classmethod\n     def setUpTestData(cls):\n         cls.superusers = {}\n@@ -42,12 +111,25 @@ class MultiDatabaseTests(TestCase):\n             b = Book(name='Test Book')\n             b.save(using=db)\n             cls.test_book_ids[db] = b.id\n+            # Close connection to release SQLite file locks before next iteration\n+            connections[db].close()\n+            cls.test_book_ids[db] = b.id\n+\n+    @mock.patch('django.contrib.admin.options.transaction')\n \n     @mock.patch('django.contrib.admin.options.transaction')\n     def test_add_view(self, mock):\n         for db in connections:\n             with self.subTest(db=db):\n                 Router.target_db = db\n+                # Close connection to release SQLite file locks\n+                connections[db].close()\n+                self.client.force_login(self.superusers[db])\n+                self.client.post(\n+                    reverse('test_adminsite:admin_views_book_add'),\n+                    {'name': 'Foobar: 5th edition'},\n+                )\n+                mock.atomic.assert_called_with(using=db)\n                 self.client.force_login(self.superusers[db])\n                 self.client.post(\n                     reverse('test_adminsite:admin_views_book_add'),\n",
    "variant_7": "diff --git a/django/db/backends/sqlite3/base.py b/django/db/backends/sqlite3/base.py\nindex a3ae1f048e..779f54cbfa 100644\n--- a/django/db/backends/sqlite3/base.py\n+++ b/django/db/backends/sqlite3/base.py\n@@ -257,6 +257,8 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n     def create_cursor(self, name=None):\n         return self.connection.cursor(factory=SQLiteCursorWrapper)\n \n+    @async_unsafe\n+\n     @async_unsafe\n     def close(self):\n         self.validate_thread_sharing()\n@@ -265,6 +267,10 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n         # an in-memory db.\n         if not self.is_in_memory_db():\n             BaseDatabaseWrapper.close(self)\n+            # Add a small delay for persistent SQLite databases to ensure\n+            # file locks are properly released at the OS level\n+            import time\n+            time.sleep(0.05)\n \n     def _savepoint_allowed(self):\n         # When 'isolation_level' is not None, sqlite3 commits before each\ndiff --git a/tests/admin_views/test_multidb.py b/tests/admin_views/test_multidb.py\nindex a02b637d34..8fbcfe90ff 100644\n--- a/tests/admin_views/test_multidb.py\n+++ b/tests/admin_views/test_multidb.py\n@@ -30,6 +30,80 @@ urlpatterns = [\n class MultiDatabaseTests(TestCase):\n     databases = {'default', 'other'}\n \n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.superusers = {}\n+        cls.test_book_ids = {}\n+\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.superusers = {}\n+        cls.test_book_ids = {}\n+        for db in connections:\n+            Router.target_db = db\n+            \n+            # Create superuser with retry logic for SQLite locks\n+            max_retries = 3\n+            for attempt in range(max_retries):\n+                try:\n+                    cls.superusers[db] = User.objects.create_superuser(\n+                        username='admin', password='something', email='test@test.org',\n+                    )\n+                    break\n+                except Exception as e:\n+                    if attempt < max_retries - 1 and 'database is locked' in str(e):\n+                        import time\n+                        time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n+                        continue\n+                    raise\n+            \n+            # Create book with retry logic for SQLite locks\n+            for attempt in range(max_retries):\n+                try:\n+                    b = Book(name='Test Book')\n+                    b.save(using=db)\n+                    cls.test_book_ids[db] = b.id\n+                    break\n+                except Exception as e:\n+                    if attempt < max_retries - 1 and 'database is locked' in str(e):\n+                        import time\n+                        time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n+                        continue\n+                    raise\n+            \n+            # Close connection to release SQLite file locks\n+            connections[db].close()\n+            Router.target_db = db\n+            # Retry mechanism for SQLite locking issues\n+            max_retries = 3\n+            for attempt in range(max_retries):\n+                try:\n+                    cls.superusers[db] = User.objects.create_superuser(\n+                        username='admin', password='something', email='test@test.org',\n+                    )\n+                    break\n+                except Exception as e:\n+                    if attempt == max_retries - 1:\n+                        raise\n+                    import time\n+                    time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n+            \n+            # Retry mechanism for Book creation\n+            for attempt in range(max_retries):\n+                try:\n+                    b = Book(name='Test Book')\n+                    b.save(using=db)\n+                    cls.test_book_ids[db] = b.id\n+                    break\n+                except Exception as e:\n+                    if attempt == max_retries - 1:\n+                        raise\n+                    import time\n+                    time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n+            \n+            # Close connection to release SQLite file locks\n+            connections[db].close()\n+\n     @classmethod\n     def setUpTestData(cls):\n         cls.superusers = {}\n@@ -42,12 +116,27 @@ class MultiDatabaseTests(TestCase):\n             b = Book(name='Test Book')\n             b.save(using=db)\n             cls.test_book_ids[db] = b.id\n+            # Close connection to release SQLite file locks\n+            connections[db].close()\n+            cls.test_book_ids[db] = b.id\n+\n+    @mock.patch('django.contrib.admin.options.transaction')\n \n     @mock.patch('django.contrib.admin.options.transaction')\n     def test_add_view(self, mock):\n         for db in connections:\n             with self.subTest(db=db):\n                 Router.target_db = db\n+                try:\n+                    self.client.force_login(self.superusers[db])\n+                    self.client.post(\n+                        reverse('test_adminsite:admin_views_book_add'),\n+                        {'name': 'Foobar: 5th edition'},\n+                    )\n+                    mock.atomic.assert_called_with(using=db)\n+                finally:\n+                    # Ensure connection is properly closed to release SQLite locks\n+                    connections[db].close()\n                 self.client.force_login(self.superusers[db])\n                 self.client.post(\n                     reverse('test_adminsite:admin_views_book_add'),\n",
    "variant_8": "diff --git a/django/db/backends/sqlite3/base.py b/django/db/backends/sqlite3/base.py\nindex a3ae1f048e..4496136117 100644\n--- a/django/db/backends/sqlite3/base.py\n+++ b/django/db/backends/sqlite3/base.py\n@@ -257,6 +257,8 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n     def create_cursor(self, name=None):\n         return self.connection.cursor(factory=SQLiteCursorWrapper)\n \n+    @async_unsafe\n+\n     @async_unsafe\n     def close(self):\n         self.validate_thread_sharing()\n@@ -265,6 +267,10 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n         # an in-memory db.\n         if not self.is_in_memory_db():\n             BaseDatabaseWrapper.close(self)\n+            # Add a small delay for persistent SQLite databases to ensure\n+            # file locks are fully released at the OS level\n+            import time\n+            time.sleep(0.05)\n \n     def _savepoint_allowed(self):\n         # When 'isolation_level' is not None, sqlite3 commits before each\ndiff --git a/tests/admin_views/test_multidb.py b/tests/admin_views/test_multidb.py\nindex a02b637d34..28de5a0abe 100644\n--- a/tests/admin_views/test_multidb.py\n+++ b/tests/admin_views/test_multidb.py\n@@ -34,6 +34,79 @@ class MultiDatabaseTests(TestCase):\n     def setUpTestData(cls):\n         cls.superusers = {}\n         cls.test_book_ids = {}\n+\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.superusers = {}\n+        cls.test_book_ids = {}\n+        for db in connections:\n+            Router.target_db = db\n+            \n+            # Retry logic for SQLite database lock issues\n+            max_retries = 3\n+            for attempt in range(max_retries):\n+                try:\n+                    cls.superusers[db] = User.objects.create_superuser(\n+                        username='admin', password='something', email='test@test.org',\n+                    )\n+                    break\n+                except Exception as e:\n+                    if attempt == max_retries - 1:\n+                        raise\n+                    import time\n+                    time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n+            \n+            # Retry logic for book creation\n+            for attempt in range(max_retries):\n+                try:\n+                    b = Book(name='Test Book')\n+                    b.save(using=db)\n+                    cls.test_book_ids[db] = b.id\n+                    break\n+                except Exception as e:\n+                    if attempt == max_retries - 1:\n+                        raise\n+                    import time\n+                    time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n+            \n+            # Close connection to release SQLite file locks\n+            connections[db].close()\n+            Router.target_db = db\n+            \n+            # Retry mechanism for SQLite lock issues\n+            max_retries = 3\n+            for attempt in range(max_retries):\n+                try:\n+                    cls.superusers[db] = User.objects.create_superuser(\n+                        username='admin', password='something', email='test@test.org',\n+                    )\n+                    break\n+                except Exception as e:\n+                    if attempt < max_retries - 1 and \"database is locked\" in str(e).lower():\n+                        import time\n+                        time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n+                        continue\n+                    raise\n+            \n+            b = Book(name='Test Book')\n+            \n+            # Retry mechanism for book save operation\n+            for attempt in range(max_retries):\n+                try:\n+                    b.save(using=db)\n+                    break\n+                except Exception as e:\n+                    if attempt < max_retries - 1 and \"database is locked\" in str(e).lower():\n+                        import time\n+                        time.sleep(0.1 * (2 ** attempt))  # Exponential backoff\n+                        continue\n+                    raise\n+                    \n+            cls.test_book_ids[db] = b.id\n+            \n+            # Close connection to release SQLite file locks\n+            connections[db].close()\n+\n         for db in connections:\n             Router.target_db = db\n             cls.superusers[db] = User.objects.create_superuser(\n@@ -42,12 +115,27 @@ class MultiDatabaseTests(TestCase):\n             b = Book(name='Test Book')\n             b.save(using=db)\n             cls.test_book_ids[db] = b.id\n+            # Close connection to release SQLite file locks\n+            connections[db].close()\n+            cls.test_book_ids[db] = b.id\n+\n+    @mock.patch('django.contrib.admin.options.transaction')\n \n     @mock.patch('django.contrib.admin.options.transaction')\n     def test_add_view(self, mock):\n         for db in connections:\n             with self.subTest(db=db):\n                 Router.target_db = db\n+                try:\n+                    self.client.force_login(self.superusers[db])\n+                    self.client.post(\n+                        reverse('test_adminsite:admin_views_book_add'),\n+                        {'name': 'Foobar: 5th edition'},\n+                    )\n+                    mock.atomic.assert_called_with(using=db)\n+                finally:\n+                    # Clean up connection to prevent SQLite file locks\n+                    connections[db].close()\n                 self.client.force_login(self.superusers[db])\n                 self.client.post(\n                     reverse('test_adminsite:admin_views_book_add'),\n"
  }
}