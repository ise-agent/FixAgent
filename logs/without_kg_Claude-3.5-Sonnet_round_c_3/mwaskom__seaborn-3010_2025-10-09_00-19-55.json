{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/seaborn/seaborn/_stats/regression.py lines 24-32)": "\n    def _fit_predict(self, data):\n\n        x = data[\"x\"]\n        y = data[\"y\"]\n        \n        # Filter out missing values\n        valid = x.notna() & y.notna()\n        x_clean = x[valid]\n        y_clean = y[valid]\n        \n        if x_clean.nunique() <= self.order:\n            # TODO warn?\n            xx = yy = []\n        else:\n            p = np.polyfit(x_clean, y_clean, self.order)\n            xx = np.linspace(x_clean.min(), x_clean.max(), self.gridsize)\n            yy = np.polyval(p, xx)\n\n        return pd.DataFrame(dict(x=xx, y=yy))\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/seaborn/seaborn/_stats/regression.py lines 24-32)": [
      "\n    def _fit_predict(self, data):\n\n        x = data[\"x\"]\n        y = data[\"y\"]\n        \n        # Filter out missing values\n        valid = x.notna() & y.notna()\n        x_clean = x[valid]\n        y_clean = y[valid]\n        \n        if x_clean.nunique() <= self.order:\n            # TODO warn?\n            xx = yy = []\n        else:\n            p = np.polyfit(x_clean, y_clean, self.order)\n            xx = np.linspace(x_clean.min(), x_clean.max(), self.gridsize)\n            yy = np.polyval(p, xx)\n\n        return pd.DataFrame(dict(x=xx, y=yy))\n",
      "\n    def _fit_predict(self, data):\n\n        x = data[\"x\"]\n        y = data[\"y\"]\n        \n        # Filter out missing values\n        valid_mask = x.notna() & y.notna()\n        x_clean = x[valid_mask]\n        y_clean = y[valid_mask]\n        \n        if x_clean.nunique() <= self.order or len(x_clean) <= self.order:\n            # TODO warn?\n            xx = yy = []\n        else:\n            p = np.polyfit(x_clean, y_clean, self.order)\n            xx = np.linspace(x_clean.min(), x_clean.max(), self.gridsize)\n            yy = np.polyval(p, xx)\n\n        return pd.DataFrame(dict(x=xx, y=yy))\n",
      "\n    def _fit_predict(self, data):\n\n        x = data[\"x\"]\n        y = data[\"y\"]\n        \n        # Filter out missing values\n        valid = x.notna() & y.notna()\n        x_valid = x[valid]\n        y_valid = y[valid]\n        \n        if x_valid.nunique() <= self.order:\n            # TODO warn?\n            xx = yy = []\n        else:\n            p = np.polyfit(x_valid, y_valid, self.order)\n            xx = np.linspace(x_valid.min(), x_valid.max(), self.gridsize)\n            yy = np.polyval(p, xx)\n\n        return pd.DataFrame(dict(x=xx, y=yy))\n",
      "\n    def _fit_predict(self, data):\n\n        x = data[\"x\"]\n        y = data[\"y\"]\n        \n        # Filter out missing data\n        valid_mask = x.notna() & y.notna()\n        x_clean = x[valid_mask]\n        y_clean = y[valid_mask]\n        \n        if x_clean.nunique() <= self.order:\n            # TODO warn?\n            xx = yy = []\n        else:\n            p = np.polyfit(x_clean, y_clean, self.order)\n            xx = np.linspace(x_clean.min(), x_clean.max(), self.gridsize)\n            yy = np.polyval(p, xx)\n",
      "\n    def _fit_predict(self, data):\n\n        x = data[\"x\"]\n        y = data[\"y\"]\n        \n        # Filter out missing data\n        valid_mask = x.notna() & y.notna()\n        x_valid = x[valid_mask]\n        y_valid = y[valid_mask]\n        \n        if x_valid.nunique() <= self.order:\n            # TODO warn?\n            xx = yy = []\n        else:\n            p = np.polyfit(x_valid, y_valid, self.order)\n            xx = np.linspace(x_valid.min(), x_valid.max(), self.gridsize)\n            yy = np.polyval(p, xx)\n\n        return pd.DataFrame(dict(x=xx, y=yy))\n",
      "\n    def _fit_predict(self, data):\n\n        x = data[\"x\"]\n        y = data[\"y\"]\n        \n        # Filter out missing data\n        valid_mask = x.notna() & y.notna()\n        x_clean = x[valid_mask]\n        y_clean = y[valid_mask]\n        \n        if x_clean.nunique() <= self.order:\n            # TODO warn?\n            xx = yy = []\n        else:\n            p = np.polyfit(x_clean, y_clean, self.order)\n            xx = np.linspace(x_clean.min(), x_clean.max(), self.gridsize)\n            yy = np.polyval(p, xx)\n\n        return pd.DataFrame(dict(x=xx, y=yy))\n",
      "\n    def _fit_predict(self, data):\n\n        x = data[\"x\"]\n        y = data[\"y\"]\n        \n        # Filter out missing data\n        valid_mask = x.notna() & y.notna()\n        x_clean = x[valid_mask]\n        y_clean = y[valid_mask]\n        \n        if x_clean.nunique() <= self.order:\n            # TODO warn?\n            xx = yy = []\n        else:\n            p = np.polyfit(x_clean, y_clean, self.order)\n            xx = np.linspace(x_clean.min(), x_clean.max(), self.gridsize)\n            yy = np.polyval(p, xx)\n\n        return pd.DataFrame(dict(x=xx, y=yy))\n",
      "\n    def _fit_predict(self, data):\n\n        x = data[\"x\"]\n        y = data[\"y\"]\n        \n        # Filter out missing values\n        valid = x.notna() & y.notna()\n        x_valid = x[valid]\n        y_valid = y[valid]\n        \n        if x_valid.nunique() <= self.order:\n            # TODO warn?\n            xx = yy = []\n        else:\n            p = np.polyfit(x_valid, y_valid, self.order)\n            xx = np.linspace(x_valid.min(), x_valid.max(), self.gridsize)\n            yy = np.polyval(p, xx)\n\n        return pd.DataFrame(dict(x=xx, y=yy))\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/seaborn/_stats/regression.py b/seaborn/_stats/regression.py\nindex 7b7ddc8d..7542d870 100644\n--- a/seaborn/_stats/regression.py\n+++ b/seaborn/_stats/regression.py\n@@ -21,14 +21,21 @@ class PolyFit(Stat):\n \n     def _fit_predict(self, data):\n \n+\n         x = data[\"x\"]\n         y = data[\"y\"]\n-        if x.nunique() <= self.order:\n+        \n+        # Filter out missing data to prevent LinAlgError in np.polyfit\n+        valid_mask = x.notna() & y.notna()\n+        x_clean = x[valid_mask]\n+        y_clean = y[valid_mask]\n+        \n+        if len(x_clean) <= self.order or x_clean.nunique() <= self.order:\n             # TODO warn?\n             xx = yy = []\n         else:\n-            p = np.polyfit(x, y, self.order)\n-            xx = np.linspace(x.min(), x.max(), self.gridsize)\n+            p = np.polyfit(x_clean, y_clean, self.order)\n+            xx = np.linspace(x_clean.min(), x_clean.max(), self.gridsize)\n             yy = np.polyval(p, xx)\n \n         return pd.DataFrame(dict(x=xx, y=yy))\n",
    "variant_0": "diff --git a/seaborn/_stats/regression.py b/seaborn/_stats/regression.py\nindex 7b7ddc8d..28c9f3b7 100644\n--- a/seaborn/_stats/regression.py\n+++ b/seaborn/_stats/regression.py\n@@ -19,20 +19,31 @@ class PolyFit(Stat):\n     order: int = 2\n     gridsize: int = 100\n \n+    def _fit_predict(self, data):\n+\n+\n     def _fit_predict(self, data):\n \n         x = data[\"x\"]\n         y = data[\"y\"]\n-        if x.nunique() <= self.order:\n+        \n+        # Filter out missing values\n+        valid = x.notna() & y.notna()\n+        x_clean = x[valid]\n+        y_clean = y[valid]\n+        \n+        if x_clean.nunique() <= self.order:\n             # TODO warn?\n             xx = yy = []\n         else:\n-            p = np.polyfit(x, y, self.order)\n-            xx = np.linspace(x.min(), x.max(), self.gridsize)\n+            p = np.polyfit(x_clean, y_clean, self.order)\n+            xx = np.linspace(x_clean.min(), x_clean.max(), self.gridsize)\n             yy = np.polyval(p, xx)\n \n         return pd.DataFrame(dict(x=xx, y=yy))\n \n+        return pd.DataFrame(dict(x=xx, y=yy))\n+\n     # TODO we should have a way of identifying the method that will be applied\n     # and then only define __call__ on a base-class of stats with this pattern\n \n",
    "variant_1": "diff --git a/seaborn/_stats/regression.py b/seaborn/_stats/regression.py\nindex 7b7ddc8d..28c9f3b7 100644\n--- a/seaborn/_stats/regression.py\n+++ b/seaborn/_stats/regression.py\n@@ -19,20 +19,31 @@ class PolyFit(Stat):\n     order: int = 2\n     gridsize: int = 100\n \n+    def _fit_predict(self, data):\n+\n+\n     def _fit_predict(self, data):\n \n         x = data[\"x\"]\n         y = data[\"y\"]\n-        if x.nunique() <= self.order:\n+        \n+        # Filter out missing values\n+        valid = x.notna() & y.notna()\n+        x_clean = x[valid]\n+        y_clean = y[valid]\n+        \n+        if x_clean.nunique() <= self.order:\n             # TODO warn?\n             xx = yy = []\n         else:\n-            p = np.polyfit(x, y, self.order)\n-            xx = np.linspace(x.min(), x.max(), self.gridsize)\n+            p = np.polyfit(x_clean, y_clean, self.order)\n+            xx = np.linspace(x_clean.min(), x_clean.max(), self.gridsize)\n             yy = np.polyval(p, xx)\n \n         return pd.DataFrame(dict(x=xx, y=yy))\n \n+        return pd.DataFrame(dict(x=xx, y=yy))\n+\n     # TODO we should have a way of identifying the method that will be applied\n     # and then only define __call__ on a base-class of stats with this pattern\n \n",
    "variant_2": "diff --git a/seaborn/_stats/regression.py b/seaborn/_stats/regression.py\nindex 7b7ddc8d..cdf8723b 100644\n--- a/seaborn/_stats/regression.py\n+++ b/seaborn/_stats/regression.py\n@@ -19,20 +19,31 @@ class PolyFit(Stat):\n     order: int = 2\n     gridsize: int = 100\n \n+    def _fit_predict(self, data):\n+\n+\n     def _fit_predict(self, data):\n \n         x = data[\"x\"]\n         y = data[\"y\"]\n-        if x.nunique() <= self.order:\n+        \n+        # Filter out missing values\n+        valid_mask = x.notna() & y.notna()\n+        x_clean = x[valid_mask]\n+        y_clean = y[valid_mask]\n+        \n+        if x_clean.nunique() <= self.order or len(x_clean) <= self.order:\n             # TODO warn?\n             xx = yy = []\n         else:\n-            p = np.polyfit(x, y, self.order)\n-            xx = np.linspace(x.min(), x.max(), self.gridsize)\n+            p = np.polyfit(x_clean, y_clean, self.order)\n+            xx = np.linspace(x_clean.min(), x_clean.max(), self.gridsize)\n             yy = np.polyval(p, xx)\n \n         return pd.DataFrame(dict(x=xx, y=yy))\n \n+        return pd.DataFrame(dict(x=xx, y=yy))\n+\n     # TODO we should have a way of identifying the method that will be applied\n     # and then only define __call__ on a base-class of stats with this pattern\n \n",
    "variant_3": "diff --git a/seaborn/_stats/regression.py b/seaborn/_stats/regression.py\nindex 7b7ddc8d..a797ec26 100644\n--- a/seaborn/_stats/regression.py\n+++ b/seaborn/_stats/regression.py\n@@ -19,20 +19,31 @@ class PolyFit(Stat):\n     order: int = 2\n     gridsize: int = 100\n \n+    def _fit_predict(self, data):\n+\n+\n     def _fit_predict(self, data):\n \n         x = data[\"x\"]\n         y = data[\"y\"]\n-        if x.nunique() <= self.order:\n+        \n+        # Filter out missing values\n+        valid = x.notna() & y.notna()\n+        x_valid = x[valid]\n+        y_valid = y[valid]\n+        \n+        if x_valid.nunique() <= self.order:\n             # TODO warn?\n             xx = yy = []\n         else:\n-            p = np.polyfit(x, y, self.order)\n-            xx = np.linspace(x.min(), x.max(), self.gridsize)\n+            p = np.polyfit(x_valid, y_valid, self.order)\n+            xx = np.linspace(x_valid.min(), x_valid.max(), self.gridsize)\n             yy = np.polyval(p, xx)\n \n         return pd.DataFrame(dict(x=xx, y=yy))\n \n+        return pd.DataFrame(dict(x=xx, y=yy))\n+\n     # TODO we should have a way of identifying the method that will be applied\n     # and then only define __call__ on a base-class of stats with this pattern\n \n",
    "variant_4": "diff --git a/seaborn/_stats/regression.py b/seaborn/_stats/regression.py\nindex 7b7ddc8d..5a2d3d69 100644\n--- a/seaborn/_stats/regression.py\n+++ b/seaborn/_stats/regression.py\n@@ -19,16 +19,25 @@ class PolyFit(Stat):\n     order: int = 2\n     gridsize: int = 100\n \n+    def _fit_predict(self, data):\n+\n+\n     def _fit_predict(self, data):\n \n         x = data[\"x\"]\n         y = data[\"y\"]\n-        if x.nunique() <= self.order:\n+        \n+        # Filter out missing data\n+        valid_mask = x.notna() & y.notna()\n+        x_clean = x[valid_mask]\n+        y_clean = y[valid_mask]\n+        \n+        if x_clean.nunique() <= self.order:\n             # TODO warn?\n             xx = yy = []\n         else:\n-            p = np.polyfit(x, y, self.order)\n-            xx = np.linspace(x.min(), x.max(), self.gridsize)\n+            p = np.polyfit(x_clean, y_clean, self.order)\n+            xx = np.linspace(x_clean.min(), x_clean.max(), self.gridsize)\n             yy = np.polyval(p, xx)\n \n         return pd.DataFrame(dict(x=xx, y=yy))\n",
    "variant_5": "diff --git a/seaborn/_stats/regression.py b/seaborn/_stats/regression.py\nindex 7b7ddc8d..1fa139e3 100644\n--- a/seaborn/_stats/regression.py\n+++ b/seaborn/_stats/regression.py\n@@ -19,20 +19,31 @@ class PolyFit(Stat):\n     order: int = 2\n     gridsize: int = 100\n \n+    def _fit_predict(self, data):\n+\n+\n     def _fit_predict(self, data):\n \n         x = data[\"x\"]\n         y = data[\"y\"]\n-        if x.nunique() <= self.order:\n+        \n+        # Filter out missing data\n+        valid_mask = x.notna() & y.notna()\n+        x_valid = x[valid_mask]\n+        y_valid = y[valid_mask]\n+        \n+        if x_valid.nunique() <= self.order:\n             # TODO warn?\n             xx = yy = []\n         else:\n-            p = np.polyfit(x, y, self.order)\n-            xx = np.linspace(x.min(), x.max(), self.gridsize)\n+            p = np.polyfit(x_valid, y_valid, self.order)\n+            xx = np.linspace(x_valid.min(), x_valid.max(), self.gridsize)\n             yy = np.polyval(p, xx)\n \n         return pd.DataFrame(dict(x=xx, y=yy))\n \n+        return pd.DataFrame(dict(x=xx, y=yy))\n+\n     # TODO we should have a way of identifying the method that will be applied\n     # and then only define __call__ on a base-class of stats with this pattern\n \n",
    "variant_6": "diff --git a/seaborn/_stats/regression.py b/seaborn/_stats/regression.py\nindex 7b7ddc8d..f55841cc 100644\n--- a/seaborn/_stats/regression.py\n+++ b/seaborn/_stats/regression.py\n@@ -19,20 +19,31 @@ class PolyFit(Stat):\n     order: int = 2\n     gridsize: int = 100\n \n+    def _fit_predict(self, data):\n+\n+\n     def _fit_predict(self, data):\n \n         x = data[\"x\"]\n         y = data[\"y\"]\n-        if x.nunique() <= self.order:\n+        \n+        # Filter out missing data\n+        valid_mask = x.notna() & y.notna()\n+        x_clean = x[valid_mask]\n+        y_clean = y[valid_mask]\n+        \n+        if x_clean.nunique() <= self.order:\n             # TODO warn?\n             xx = yy = []\n         else:\n-            p = np.polyfit(x, y, self.order)\n-            xx = np.linspace(x.min(), x.max(), self.gridsize)\n+            p = np.polyfit(x_clean, y_clean, self.order)\n+            xx = np.linspace(x_clean.min(), x_clean.max(), self.gridsize)\n             yy = np.polyval(p, xx)\n \n         return pd.DataFrame(dict(x=xx, y=yy))\n \n+        return pd.DataFrame(dict(x=xx, y=yy))\n+\n     # TODO we should have a way of identifying the method that will be applied\n     # and then only define __call__ on a base-class of stats with this pattern\n \n",
    "variant_7": "diff --git a/seaborn/_stats/regression.py b/seaborn/_stats/regression.py\nindex 7b7ddc8d..f55841cc 100644\n--- a/seaborn/_stats/regression.py\n+++ b/seaborn/_stats/regression.py\n@@ -19,20 +19,31 @@ class PolyFit(Stat):\n     order: int = 2\n     gridsize: int = 100\n \n+    def _fit_predict(self, data):\n+\n+\n     def _fit_predict(self, data):\n \n         x = data[\"x\"]\n         y = data[\"y\"]\n-        if x.nunique() <= self.order:\n+        \n+        # Filter out missing data\n+        valid_mask = x.notna() & y.notna()\n+        x_clean = x[valid_mask]\n+        y_clean = y[valid_mask]\n+        \n+        if x_clean.nunique() <= self.order:\n             # TODO warn?\n             xx = yy = []\n         else:\n-            p = np.polyfit(x, y, self.order)\n-            xx = np.linspace(x.min(), x.max(), self.gridsize)\n+            p = np.polyfit(x_clean, y_clean, self.order)\n+            xx = np.linspace(x_clean.min(), x_clean.max(), self.gridsize)\n             yy = np.polyval(p, xx)\n \n         return pd.DataFrame(dict(x=xx, y=yy))\n \n+        return pd.DataFrame(dict(x=xx, y=yy))\n+\n     # TODO we should have a way of identifying the method that will be applied\n     # and then only define __call__ on a base-class of stats with this pattern\n \n",
    "variant_8": "diff --git a/seaborn/_stats/regression.py b/seaborn/_stats/regression.py\nindex 7b7ddc8d..a797ec26 100644\n--- a/seaborn/_stats/regression.py\n+++ b/seaborn/_stats/regression.py\n@@ -19,20 +19,31 @@ class PolyFit(Stat):\n     order: int = 2\n     gridsize: int = 100\n \n+    def _fit_predict(self, data):\n+\n+\n     def _fit_predict(self, data):\n \n         x = data[\"x\"]\n         y = data[\"y\"]\n-        if x.nunique() <= self.order:\n+        \n+        # Filter out missing values\n+        valid = x.notna() & y.notna()\n+        x_valid = x[valid]\n+        y_valid = y[valid]\n+        \n+        if x_valid.nunique() <= self.order:\n             # TODO warn?\n             xx = yy = []\n         else:\n-            p = np.polyfit(x, y, self.order)\n-            xx = np.linspace(x.min(), x.max(), self.gridsize)\n+            p = np.polyfit(x_valid, y_valid, self.order)\n+            xx = np.linspace(x_valid.min(), x_valid.max(), self.gridsize)\n             yy = np.polyval(p, xx)\n \n         return pd.DataFrame(dict(x=xx, y=yy))\n \n+        return pd.DataFrame(dict(x=xx, y=yy))\n+\n     # TODO we should have a way of identifying the method that will be applied\n     # and then only define __call__ on a base-class of stats with this pattern\n \n"
  }
}