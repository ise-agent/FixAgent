{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/django/django/db/models/fields/related.py lines 1210-1217)": "\n    def check(self, **kwargs):\n        return [\n            *super().check(**kwargs),\n            *self._check_unique(**kwargs),\n            *self._check_relationship_model(**kwargs),\n            *self._check_ignored_options(**kwargs),\n            *self._check_table_uniqueness(**kwargs),\n            *self._check_symmetrical_related_name(**kwargs),\n        ]\n",
    "Location 2 (/root/hy/projects_3/django/django/db/models/fields/related.py lines 1262-1280)": "\n    def _check_symmetrical_related_name(self, **kwargs):\n        \"\"\"\n        Check that related_name is not specified for symmetrical ManyToManyFields.\n        \"\"\"\n        errors = []\n        \n        if (self.remote_field.symmetrical and \n            self.remote_field.related_name is not None):\n            errors.append(\n                checks.Error(\n                    \"ManyToManyField cannot specify a related_name when \"\n                    \"symmetrical=True. Symmetrical fields do not create a \"\n                    \"reverse relation.\",\n                    obj=self,\n                    id='fields.E332',\n                )\n            )\n        \n        return errors\n\n    def _check_relationship_model(self, from_model=None, **kwargs):\n        if hasattr(self.remote_field.through, '_meta'):\n            qualified_model_name = \"%s.%s\" % (\n                self.remote_field.through._meta.app_label, self.remote_field.through.__name__)\n        else:\n            qualified_model_name = self.remote_field.through\n\n        errors = []\n\n        if self.remote_field.through not in self.opts.apps.get_models(include_auto_created=True):\n            # The relationship model is not installed.\n            errors.append(\n                checks.Error(\n                    \"Field specifies a many-to-many relation through model \"\n                    \"'%s', which has not been installed.\" % qualified_model_name,\n                    obj=self,\n                    id='fields.E331',\n                )\n            )\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/django/django/db/models/fields/related.py lines 1210-1217)": [
      "\n    def check(self, **kwargs):\n        return [\n            *super().check(**kwargs),\n            *self._check_unique(**kwargs),\n            *self._check_relationship_model(**kwargs),\n            *self._check_ignored_options(**kwargs),\n            *self._check_table_uniqueness(**kwargs),\n            *self._check_symmetrical_related_name(**kwargs),\n        ]\n",
      "\n    def check(self, **kwargs):\n        return [\n            *super().check(**kwargs),\n            *self._check_unique(**kwargs),\n            *self._check_relationship_model(**kwargs),\n            *self._check_ignored_options(**kwargs),\n            *self._check_table_uniqueness(**kwargs),\n            *self._check_symmetrical_related_name(**kwargs),\n        ]\n",
      "\n    def check(self, **kwargs):\n        return [\n            *super().check(**kwargs),\n            *self._check_unique(**kwargs),\n            *self._check_relationship_model(**kwargs),\n            *self._check_ignored_options(**kwargs),\n            *self._check_table_uniqueness(**kwargs),\n            *self._check_symmetrical_related_name(**kwargs),\n        ]\n",
      "\n    def check(self, **kwargs):\n        return [\n            *super().check(**kwargs),\n            *self._check_unique(**kwargs),\n            *self._check_relationship_model(**kwargs),\n            *self._check_ignored_options(**kwargs),\n            *self._check_table_uniqueness(**kwargs),\n            *self._check_symmetrical_related_name(**kwargs),\n        ]\n",
      "\n    def check(self, **kwargs):\n        return [\n            *super().check(**kwargs),\n            *self._check_unique(**kwargs),\n            *self._check_relationship_model(**kwargs),\n            *self._check_ignored_options(**kwargs),\n            *self._check_table_uniqueness(**kwargs),\n            *self._check_symmetrical_related_name(**kwargs),\n        ]\n",
      "\n    def check(self, **kwargs):\n        return [\n            *super().check(**kwargs),\n            *self._check_unique(**kwargs),\n            *self._check_relationship_model(**kwargs),\n            *self._check_ignored_options(**kwargs),\n            *self._check_table_uniqueness(**kwargs),\n            *self._check_symmetrical_related_name(**kwargs),\n        ]\n",
      "\n    def check(self, **kwargs):\n        return [\n            *super().check(**kwargs),\n            *self._check_unique(**kwargs),\n            *self._check_relationship_model(**kwargs),\n            *self._check_ignored_options(**kwargs),\n            *self._check_table_uniqueness(**kwargs),\n            *self._check_symmetrical_related_name(**kwargs),\n        ]\n",
      "\n    def check(self, **kwargs):\n        return [\n            *super().check(**kwargs),\n            *self._check_unique(**kwargs),\n            *self._check_relationship_model(**kwargs),\n            *self._check_ignored_options(**kwargs),\n            *self._check_table_uniqueness(**kwargs),\n            *self._check_symmetrical_related_name(**kwargs),\n        ]\n"
    ],
    "Location 2 (/root/hy/projects_3/django/django/db/models/fields/related.py lines 1262-1280)": [
      "\n    def _check_symmetrical_related_name(self, **kwargs):\n        \"\"\"\n        Check that related_name is not specified on symmetrical ManyToManyFields.\n        \"\"\"\n        if self.remote_field.symmetrical and self.remote_field.related_name is not None:\n            return [\n                checks.Error(\n                    'ManyToManyField cannot specify a related_name when '\n                    'symmetrical=True, since no reverse relation is created.',\n                    obj=self,\n                    id='fields.E332',\n                )\n            ]\n        return []\n\n    def _check_relationship_model(self, from_model=None, **kwargs):\n        if hasattr(self.remote_field.through, '_meta'):\n            qualified_model_name = \"%s.%s\" % (\n                self.remote_field.through._meta.app_label, self.remote_field.through.__name__)\n        else:\n            qualified_model_name = self.remote_field.through\n\n        errors = []\n\n        if self.remote_field.through not in self.opts.apps.get_models(include_auto_created=True):\n            # The relationship model is not installed.\n            errors.append(\n                checks.Error(\n                    \"Field specifies a many-to-many relation through model \"\n                    \"'%s', which has not been installed.\" % qualified_model_name,\n                    obj=self,\n                    id='fields.E331',\n                )\n            )\n",
      "\n    def _check_symmetrical_related_name(self, **kwargs):\n        \"\"\"\n        Check that related_name is not specified for symmetrical ManyToManyFields.\n        \"\"\"\n        if self.remote_field.symmetrical and self.remote_field.related_name is not None:\n            return [\n                checks.Error(\n                    \"Cannot set related_name on a symmetrical ManyToManyField. \"\n                    \"Symmetrical ManyToManyFields do not create a reverse relation.\",\n                    obj=self,\n                    id='fields.E332',\n                )\n            ]\n        return []\n\n    def _check_relationship_model(self, from_model=None, **kwargs):\n        if hasattr(self.remote_field.through, '_meta'):\n            qualified_model_name = \"%s.%s\" % (\n                self.remote_field.through._meta.app_label, self.remote_field.through.__name__)\n        else:\n            qualified_model_name = self.remote_field.through\n\n        errors = []\n\n        if self.remote_field.through not in self.opts.apps.get_models(include_auto_created=True):\n            # The relationship model is not installed.\n            errors.append(\n                checks.Error(\n                    \"Field specifies a many-to-many relation through model \"\n                    \"'%s', which has not been installed.\" % qualified_model_name,\n                    obj=self,\n                    id='fields.E331',\n                )\n            )\n",
      "\n    def _check_symmetrical_related_name(self, **kwargs):\n        \"\"\"\n        Check that related_name is not specified for symmetrical ManyToManyFields.\n        \"\"\"\n        if self.remote_field.symmetrical and self.remote_field.related_name is not None:\n            return [\n                checks.Error(\n                    \"ManyToManyField cannot specify a related_name when \"\n                    \"symmetrical=True. Symmetrical fields do not create a \"\n                    \"reverse relation.\",\n                    obj=self,\n                    id='fields.E332',\n                )\n            ]\n        return []\n\n    def _check_relationship_model(self, from_model=None, **kwargs):\n        if hasattr(self.remote_field.through, '_meta'):\n            qualified_model_name = \"%s.%s\" % (\n                self.remote_field.through._meta.app_label, self.remote_field.through.__name__)\n        else:\n            qualified_model_name = self.remote_field.through\n\n        errors = []\n\n        if self.remote_field.through not in self.opts.apps.get_models(include_auto_created=True):\n            # The relationship model is not installed.\n            errors.append(\n                checks.Error(\n                    \"Field specifies a many-to-many relation through model \"\n                    \"'%s', which has not been installed.\" % qualified_model_name,\n                    obj=self,\n                    id='fields.E331',\n                )\n            )\n",
      "\n    def _check_relationship_model(self, from_model=None, **kwargs):\n        if hasattr(self.remote_field.through, '_meta'):\n            qualified_model_name = \"%s.%s\" % (\n                self.remote_field.through._meta.app_label, self.remote_field.through.__name__)\n        else:\n            qualified_model_name = self.remote_field.through\n\n        errors = []\n\n        if self.remote_field.through not in self.opts.apps.get_models(include_auto_created=True):\n            # The relationship model is not installed.\n            errors.append(\n                checks.Error(\n                    \"Field specifies a many-to-many relation through model \"\n                    \"'%s', which has not been installed.\" % qualified_model_name,\n                    obj=self,\n                    id='fields.E331',\n                )\n            )\n\n    def _check_symmetrical_related_name(self, **kwargs):\n        \"\"\"\n        Check that related_name is not specified on symmetrical ManyToManyFields.\n        \"\"\"\n        if self.remote_field.symmetrical and self.remote_field.related_name is not None:\n            return [\n                checks.Error(\n                    \"ManyToManyField cannot specify a 'related_name' when \"\n                    \"symmetrical=True because no reverse relation is created.\",\n                    obj=self,\n                    id='fields.E332',\n                )\n            ]\n        return []\n",
      "\n    def _check_relationship_model(self, from_model=None, **kwargs):\n        if hasattr(self.remote_field.through, '_meta'):\n            qualified_model_name = \"%s.%s\" % (\n                self.remote_field.through._meta.app_label, self.remote_field.through.__name__)\n        else:\n            qualified_model_name = self.remote_field.through\n\n        errors = []\n\n        if self.remote_field.through not in self.opts.apps.get_models(include_auto_created=True):\n            # The relationship model is not installed.\n            errors.append(\n                checks.Error(\n                    \"Field specifies a many-to-many relation through model \"\n                    \"'%s', which has not been installed.\" % qualified_model_name,\n                    obj=self,\n                    id='fields.E331',\n                )\n            )\n\n    def _check_symmetrical_related_name(self, **kwargs):\n        \"\"\"\n        Check that related_name is not specified for symmetrical ManyToManyFields.\n        \"\"\"\n        errors = []\n        \n        if (self.remote_field.symmetrical and \n            self.remote_field.related_name is not None):\n            errors.append(\n                checks.Error(\n                    \"ManyToManyField cannot specify a related_name when symmetrical=True.\",\n                    hint=\"Remove the related_name argument or set symmetrical=False.\",\n                    obj=self,\n                    id='fields.E332',\n                )\n            )\n        \n        return errors\n",
      "\n    def _check_symmetrical_related_name(self, **kwargs):\n        \"\"\"\n        Check that related_name is not specified for symmetrical ManyToManyFields.\n        \"\"\"\n        errors = []\n        \n        if (self.remote_field.symmetrical and \n            self.remote_field.related_name is not None):\n            errors.append(\n                checks.Error(\n                    \"ManyToManyField cannot specify a related_name \"\n                    \"when symmetrical=True, since no reverse relation is created.\",\n                    obj=self,\n                    id='fields.E332',\n                )\n            )\n        \n        return errors\n\n    def _check_relationship_model(self, from_model=None, **kwargs):\n        if hasattr(self.remote_field.through, '_meta'):\n            qualified_model_name = \"%s.%s\" % (\n                self.remote_field.through._meta.app_label, self.remote_field.through.__name__)\n        else:\n            qualified_model_name = self.remote_field.through\n\n        errors = []\n\n        if self.remote_field.through not in self.opts.apps.get_models(include_auto_created=True):\n            # The relationship model is not installed.\n            errors.append(\n                checks.Error(\n                    \"Field specifies a many-to-many relation through model \"\n                    \"'%s', which has not been installed.\" % qualified_model_name,\n                    obj=self,\n                    id='fields.E331',\n                )\n            )\n",
      "\n    def _check_symmetrical_related_name(self, **kwargs):\n        \"\"\"\n        Check that related_name is not specified for symmetrical ManyToManyFields.\n        \"\"\"\n        if self.remote_field.symmetrical and self.remote_field.related_name is not None:\n            return [\n                checks.Error(\n                    \"ManyToManyField cannot specify a related_name when \"\n                    \"symmetrical=True, because it would have no effect. \"\n                    \"Symmetrical ManyToManyFields do not create a reverse relation.\",\n                    obj=self,\n                    id='fields.E332',\n                )\n            ]\n        return []\n\n    def _check_relationship_model(self, from_model=None, **kwargs):\n        if hasattr(self.remote_field.through, '_meta'):\n            qualified_model_name = \"%s.%s\" % (\n                self.remote_field.through._meta.app_label, self.remote_field.through.__name__)\n        else:\n            qualified_model_name = self.remote_field.through\n\n        errors = []\n\n        if self.remote_field.through not in self.opts.apps.get_models(include_auto_created=True):\n            # The relationship model is not installed.\n            errors.append(\n                checks.Error(\n                    \"Field specifies a many-to-many relation through model \"\n                    \"'%s', which has not been installed.\" % qualified_model_name,\n                    obj=self,\n                    id='fields.E331',\n                )\n            )\n",
      "\n    def _check_symmetrical_related_name(self, **kwargs):\n        \"\"\"\n        Check that related_name is not specified for symmetrical ManyToManyFields.\n        \"\"\"\n        if self.remote_field.symmetrical and self.remote_field.related_name is not None:\n            return [\n                checks.Error(\n                    'related_name has no effect on ManyToManyField with symmetrical=True. '\n                    'Use symmetrical=False to allow specifying a related_name.',\n                    obj=self,\n                    id='fields.E332',\n                )\n            ]\n        return []\n\n    def _check_relationship_model(self, from_model=None, **kwargs):\n        if hasattr(self.remote_field.through, '_meta'):\n            qualified_model_name = \"%s.%s\" % (\n                self.remote_field.through._meta.app_label, self.remote_field.through.__name__)\n        else:\n            qualified_model_name = self.remote_field.through\n\n        errors = []\n\n        if self.remote_field.through not in self.opts.apps.get_models(include_auto_created=True):\n            # The relationship model is not installed.\n            errors.append(\n                checks.Error(\n                    \"Field specifies a many-to-many relation through model \"\n                    \"'%s', which has not been installed.\" % qualified_model_name,\n                    obj=self,\n                    id='fields.E331',\n                )\n            )\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex febaadbb5b..5f55109377 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -1207,6 +1207,7 @@ class ManyToManyField(RelatedField):\n         self.db_table = db_table\n         self.swappable = swappable\n \n+\n     def check(self, **kwargs):\n         return [\n             *super().check(**kwargs),\n@@ -1214,6 +1215,7 @@ class ManyToManyField(RelatedField):\n             *self._check_relationship_model(**kwargs),\n             *self._check_ignored_options(**kwargs),\n             *self._check_table_uniqueness(**kwargs),\n+            *self._check_symmetrical_related_name(**kwargs),\n         ]\n \n     def _check_unique(self, **kwargs):\n@@ -1260,6 +1262,21 @@ class ManyToManyField(RelatedField):\n \n         return warnings\n \n+    def _check_symmetrical_related_name(self, **kwargs):\n+        \"\"\"\n+        Check that symmetrical ManyToManyFields don't define a related_name.\n+        \"\"\"\n+        if self.remote_field.symmetrical and self.remote_field.related_name is not None:\n+            return [\n+                checks.Error(\n+                    \"ManyToManyFields with symmetrical=True cannot specify a \"\n+                    \"related_name because no reverse relation is created.\",\n+                    obj=self,\n+                    id='fields.E332',\n+                )\n+            ]\n+        return []\n+\n     def _check_relationship_model(self, from_model=None, **kwargs):\n         if hasattr(self.remote_field.through, '_meta'):\n             qualified_model_name = \"%s.%s\" % (\n",
    "variant_0": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex febaadbb5b..049cf1ea23 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -1207,6 +1207,7 @@ class ManyToManyField(RelatedField):\n         self.db_table = db_table\n         self.swappable = swappable\n \n+\n     def check(self, **kwargs):\n         return [\n             *super().check(**kwargs),\n@@ -1214,6 +1215,7 @@ class ManyToManyField(RelatedField):\n             *self._check_relationship_model(**kwargs),\n             *self._check_ignored_options(**kwargs),\n             *self._check_table_uniqueness(**kwargs),\n+            *self._check_symmetrical_related_name(**kwargs),\n         ]\n \n     def _check_unique(self, **kwargs):\n@@ -1260,6 +1262,26 @@ class ManyToManyField(RelatedField):\n \n         return warnings\n \n+    def _check_symmetrical_related_name(self, **kwargs):\n+        \"\"\"\n+        Check that related_name is not specified for symmetrical ManyToManyFields.\n+        \"\"\"\n+        errors = []\n+        \n+        if (self.remote_field.symmetrical and \n+            self.remote_field.related_name is not None):\n+            errors.append(\n+                checks.Error(\n+                    \"ManyToManyField cannot specify a related_name when \"\n+                    \"symmetrical=True. Symmetrical fields do not create a \"\n+                    \"reverse relation.\",\n+                    obj=self,\n+                    id='fields.E332',\n+                )\n+            )\n+        \n+        return errors\n+\n     def _check_relationship_model(self, from_model=None, **kwargs):\n         if hasattr(self.remote_field.through, '_meta'):\n             qualified_model_name = \"%s.%s\" % (\n@@ -1279,6 +1301,7 @@ class ManyToManyField(RelatedField):\n                     id='fields.E331',\n                 )\n             )\n+            )\n \n         else:\n             assert from_model is not None, (\n",
    "variant_1": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex febaadbb5b..0a595c3aa6 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -1207,6 +1207,7 @@ class ManyToManyField(RelatedField):\n         self.db_table = db_table\n         self.swappable = swappable\n \n+\n     def check(self, **kwargs):\n         return [\n             *super().check(**kwargs),\n@@ -1214,6 +1215,7 @@ class ManyToManyField(RelatedField):\n             *self._check_relationship_model(**kwargs),\n             *self._check_ignored_options(**kwargs),\n             *self._check_table_uniqueness(**kwargs),\n+            *self._check_symmetrical_related_name(**kwargs),\n         ]\n \n     def _check_unique(self, **kwargs):\n@@ -1260,6 +1262,21 @@ class ManyToManyField(RelatedField):\n \n         return warnings\n \n+    def _check_symmetrical_related_name(self, **kwargs):\n+        \"\"\"\n+        Check that related_name is not specified on symmetrical ManyToManyFields.\n+        \"\"\"\n+        if self.remote_field.symmetrical and self.remote_field.related_name is not None:\n+            return [\n+                checks.Error(\n+                    'ManyToManyField cannot specify a related_name when '\n+                    'symmetrical=True, since no reverse relation is created.',\n+                    obj=self,\n+                    id='fields.E332',\n+                )\n+            ]\n+        return []\n+\n     def _check_relationship_model(self, from_model=None, **kwargs):\n         if hasattr(self.remote_field.through, '_meta'):\n             qualified_model_name = \"%s.%s\" % (\n@@ -1279,6 +1296,7 @@ class ManyToManyField(RelatedField):\n                     id='fields.E331',\n                 )\n             )\n+            )\n \n         else:\n             assert from_model is not None, (\n",
    "variant_2": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex febaadbb5b..0fa1fc5da3 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -1207,6 +1207,7 @@ class ManyToManyField(RelatedField):\n         self.db_table = db_table\n         self.swappable = swappable\n \n+\n     def check(self, **kwargs):\n         return [\n             *super().check(**kwargs),\n@@ -1214,6 +1215,7 @@ class ManyToManyField(RelatedField):\n             *self._check_relationship_model(**kwargs),\n             *self._check_ignored_options(**kwargs),\n             *self._check_table_uniqueness(**kwargs),\n+            *self._check_symmetrical_related_name(**kwargs),\n         ]\n \n     def _check_unique(self, **kwargs):\n@@ -1260,6 +1262,21 @@ class ManyToManyField(RelatedField):\n \n         return warnings\n \n+    def _check_symmetrical_related_name(self, **kwargs):\n+        \"\"\"\n+        Check that related_name is not specified for symmetrical ManyToManyFields.\n+        \"\"\"\n+        if self.remote_field.symmetrical and self.remote_field.related_name is not None:\n+            return [\n+                checks.Error(\n+                    \"Cannot set related_name on a symmetrical ManyToManyField. \"\n+                    \"Symmetrical ManyToManyFields do not create a reverse relation.\",\n+                    obj=self,\n+                    id='fields.E332',\n+                )\n+            ]\n+        return []\n+\n     def _check_relationship_model(self, from_model=None, **kwargs):\n         if hasattr(self.remote_field.through, '_meta'):\n             qualified_model_name = \"%s.%s\" % (\n@@ -1279,6 +1296,7 @@ class ManyToManyField(RelatedField):\n                     id='fields.E331',\n                 )\n             )\n+            )\n \n         else:\n             assert from_model is not None, (\n",
    "variant_3": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex febaadbb5b..1f3c7fdad9 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -1207,6 +1207,7 @@ class ManyToManyField(RelatedField):\n         self.db_table = db_table\n         self.swappable = swappable\n \n+\n     def check(self, **kwargs):\n         return [\n             *super().check(**kwargs),\n@@ -1214,6 +1215,7 @@ class ManyToManyField(RelatedField):\n             *self._check_relationship_model(**kwargs),\n             *self._check_ignored_options(**kwargs),\n             *self._check_table_uniqueness(**kwargs),\n+            *self._check_symmetrical_related_name(**kwargs),\n         ]\n \n     def _check_unique(self, **kwargs):\n@@ -1260,6 +1262,22 @@ class ManyToManyField(RelatedField):\n \n         return warnings\n \n+    def _check_symmetrical_related_name(self, **kwargs):\n+        \"\"\"\n+        Check that related_name is not specified for symmetrical ManyToManyFields.\n+        \"\"\"\n+        if self.remote_field.symmetrical and self.remote_field.related_name is not None:\n+            return [\n+                checks.Error(\n+                    \"ManyToManyField cannot specify a related_name when \"\n+                    \"symmetrical=True. Symmetrical fields do not create a \"\n+                    \"reverse relation.\",\n+                    obj=self,\n+                    id='fields.E332',\n+                )\n+            ]\n+        return []\n+\n     def _check_relationship_model(self, from_model=None, **kwargs):\n         if hasattr(self.remote_field.through, '_meta'):\n             qualified_model_name = \"%s.%s\" % (\n@@ -1279,6 +1297,7 @@ class ManyToManyField(RelatedField):\n                     id='fields.E331',\n                 )\n             )\n+            )\n \n         else:\n             assert from_model is not None, (\n",
    "variant_4": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex febaadbb5b..a15fa8e156 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -1207,6 +1207,7 @@ class ManyToManyField(RelatedField):\n         self.db_table = db_table\n         self.swappable = swappable\n \n+\n     def check(self, **kwargs):\n         return [\n             *super().check(**kwargs),\n@@ -1214,6 +1215,7 @@ class ManyToManyField(RelatedField):\n             *self._check_relationship_model(**kwargs),\n             *self._check_ignored_options(**kwargs),\n             *self._check_table_uniqueness(**kwargs),\n+            *self._check_symmetrical_related_name(**kwargs),\n         ]\n \n     def _check_unique(self, **kwargs):\n@@ -1280,6 +1282,22 @@ class ManyToManyField(RelatedField):\n                 )\n             )\n \n+    def _check_symmetrical_related_name(self, **kwargs):\n+        \"\"\"\n+        Check that related_name is not specified on symmetrical ManyToManyFields.\n+        \"\"\"\n+        if self.remote_field.symmetrical and self.remote_field.related_name is not None:\n+            return [\n+                checks.Error(\n+                    \"ManyToManyField cannot specify a 'related_name' when \"\n+                    \"symmetrical=True because no reverse relation is created.\",\n+                    obj=self,\n+                    id='fields.E332',\n+                )\n+            ]\n+        return []\n+            )\n+\n         else:\n             assert from_model is not None, (\n                 \"ManyToManyField with intermediate \"\n",
    "variant_5": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex febaadbb5b..af9b99f597 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -1207,6 +1207,7 @@ class ManyToManyField(RelatedField):\n         self.db_table = db_table\n         self.swappable = swappable\n \n+\n     def check(self, **kwargs):\n         return [\n             *super().check(**kwargs),\n@@ -1214,6 +1215,7 @@ class ManyToManyField(RelatedField):\n             *self._check_relationship_model(**kwargs),\n             *self._check_ignored_options(**kwargs),\n             *self._check_table_uniqueness(**kwargs),\n+            *self._check_symmetrical_related_name(**kwargs),\n         ]\n \n     def _check_unique(self, **kwargs):\n@@ -1280,6 +1282,26 @@ class ManyToManyField(RelatedField):\n                 )\n             )\n \n+    def _check_symmetrical_related_name(self, **kwargs):\n+        \"\"\"\n+        Check that related_name is not specified for symmetrical ManyToManyFields.\n+        \"\"\"\n+        errors = []\n+        \n+        if (self.remote_field.symmetrical and \n+            self.remote_field.related_name is not None):\n+            errors.append(\n+                checks.Error(\n+                    \"ManyToManyField cannot specify a related_name when symmetrical=True.\",\n+                    hint=\"Remove the related_name argument or set symmetrical=False.\",\n+                    obj=self,\n+                    id='fields.E332',\n+                )\n+            )\n+        \n+        return errors\n+            )\n+\n         else:\n             assert from_model is not None, (\n                 \"ManyToManyField with intermediate \"\n",
    "variant_6": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex febaadbb5b..5e2e4cf332 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -1207,6 +1207,7 @@ class ManyToManyField(RelatedField):\n         self.db_table = db_table\n         self.swappable = swappable\n \n+\n     def check(self, **kwargs):\n         return [\n             *super().check(**kwargs),\n@@ -1214,6 +1215,7 @@ class ManyToManyField(RelatedField):\n             *self._check_relationship_model(**kwargs),\n             *self._check_ignored_options(**kwargs),\n             *self._check_table_uniqueness(**kwargs),\n+            *self._check_symmetrical_related_name(**kwargs),\n         ]\n \n     def _check_unique(self, **kwargs):\n@@ -1260,6 +1262,25 @@ class ManyToManyField(RelatedField):\n \n         return warnings\n \n+    def _check_symmetrical_related_name(self, **kwargs):\n+        \"\"\"\n+        Check that related_name is not specified for symmetrical ManyToManyFields.\n+        \"\"\"\n+        errors = []\n+        \n+        if (self.remote_field.symmetrical and \n+            self.remote_field.related_name is not None):\n+            errors.append(\n+                checks.Error(\n+                    \"ManyToManyField cannot specify a related_name \"\n+                    \"when symmetrical=True, since no reverse relation is created.\",\n+                    obj=self,\n+                    id='fields.E332',\n+                )\n+            )\n+        \n+        return errors\n+\n     def _check_relationship_model(self, from_model=None, **kwargs):\n         if hasattr(self.remote_field.through, '_meta'):\n             qualified_model_name = \"%s.%s\" % (\n@@ -1279,6 +1300,7 @@ class ManyToManyField(RelatedField):\n                     id='fields.E331',\n                 )\n             )\n+            )\n \n         else:\n             assert from_model is not None, (\n",
    "variant_7": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex febaadbb5b..68b357fe90 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -1207,6 +1207,7 @@ class ManyToManyField(RelatedField):\n         self.db_table = db_table\n         self.swappable = swappable\n \n+\n     def check(self, **kwargs):\n         return [\n             *super().check(**kwargs),\n@@ -1214,6 +1215,7 @@ class ManyToManyField(RelatedField):\n             *self._check_relationship_model(**kwargs),\n             *self._check_ignored_options(**kwargs),\n             *self._check_table_uniqueness(**kwargs),\n+            *self._check_symmetrical_related_name(**kwargs),\n         ]\n \n     def _check_unique(self, **kwargs):\n@@ -1260,6 +1262,22 @@ class ManyToManyField(RelatedField):\n \n         return warnings\n \n+    def _check_symmetrical_related_name(self, **kwargs):\n+        \"\"\"\n+        Check that related_name is not specified for symmetrical ManyToManyFields.\n+        \"\"\"\n+        if self.remote_field.symmetrical and self.remote_field.related_name is not None:\n+            return [\n+                checks.Error(\n+                    \"ManyToManyField cannot specify a related_name when \"\n+                    \"symmetrical=True, because it would have no effect. \"\n+                    \"Symmetrical ManyToManyFields do not create a reverse relation.\",\n+                    obj=self,\n+                    id='fields.E332',\n+                )\n+            ]\n+        return []\n+\n     def _check_relationship_model(self, from_model=None, **kwargs):\n         if hasattr(self.remote_field.through, '_meta'):\n             qualified_model_name = \"%s.%s\" % (\n@@ -1279,6 +1297,7 @@ class ManyToManyField(RelatedField):\n                     id='fields.E331',\n                 )\n             )\n+            )\n \n         else:\n             assert from_model is not None, (\n",
    "variant_8": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex febaadbb5b..0c226dac7e 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -1207,6 +1207,7 @@ class ManyToManyField(RelatedField):\n         self.db_table = db_table\n         self.swappable = swappable\n \n+\n     def check(self, **kwargs):\n         return [\n             *super().check(**kwargs),\n@@ -1214,6 +1215,7 @@ class ManyToManyField(RelatedField):\n             *self._check_relationship_model(**kwargs),\n             *self._check_ignored_options(**kwargs),\n             *self._check_table_uniqueness(**kwargs),\n+            *self._check_symmetrical_related_name(**kwargs),\n         ]\n \n     def _check_unique(self, **kwargs):\n@@ -1260,6 +1262,21 @@ class ManyToManyField(RelatedField):\n \n         return warnings\n \n+    def _check_symmetrical_related_name(self, **kwargs):\n+        \"\"\"\n+        Check that related_name is not specified for symmetrical ManyToManyFields.\n+        \"\"\"\n+        if self.remote_field.symmetrical and self.remote_field.related_name is not None:\n+            return [\n+                checks.Error(\n+                    'related_name has no effect on ManyToManyField with symmetrical=True. '\n+                    'Use symmetrical=False to allow specifying a related_name.',\n+                    obj=self,\n+                    id='fields.E332',\n+                )\n+            ]\n+        return []\n+\n     def _check_relationship_model(self, from_model=None, **kwargs):\n         if hasattr(self.remote_field.through, '_meta'):\n             qualified_model_name = \"%s.%s\" % (\n@@ -1279,6 +1296,7 @@ class ManyToManyField(RelatedField):\n                     id='fields.E331',\n                 )\n             )\n+            )\n \n         else:\n             assert from_model is not None, (\n"
  }
}