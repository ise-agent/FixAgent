{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/django/django/db/backends/base/schema.py lines 402-416)": "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # If we're looking for index constraints, exclude unique constraints\n        # If we're looking for unique constraints, exclude index constraints\n        exclude_names = meta_constraint_names | meta_index_names\n        if constraint_kwargs.get('index') and not constraint_kwargs.get('unique'):\n            # When deleting index_together, exclude unique constraints\n            unique_constraint_names = self._constraint_names(\n                model, columns, unique=True, exclude=exclude_names\n            )\n            exclude_names = exclude_names | set(unique_constraint_names)\n        elif constraint_kwargs.get('unique') and not constraint_kwargs.get('index'):\n            # When deleting unique_together, exclude index constraints\n            index_constraint_names = self._constraint_names(\n                model, columns, index=True, exclude=exclude_names\n            )\n            exclude_names = exclude_names | set(index_constraint_names)\n        \n        constraint_names = self._constraint_names(\n            model, columns, exclude=exclude_names,\n            **constraint_kwargs\n        )\n        if len(constraint_names) != 1:\n            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                len(constraint_names),\n                model._meta.db_table,\n                \", \".join(columns),\n            ))\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
    "Location 2 (/root/hy/projects_3/django/django/db/backends/base/schema.py lines 406-409)": "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # Filter constraint names based on the specific constraint type we're looking for\n        if constraint_kwargs.get('unique'):\n            # When deleting unique constraints, exclude regular indexes\n            constraint_names = self._constraint_names(\n                model, columns, exclude=meta_constraint_names | meta_index_names,\n                **constraint_kwargs\n            )\n        elif constraint_kwargs.get('index'):\n            # When deleting index constraints, exclude unique constraints\n            # Get all matching constraints first\n            all_constraint_names = self._constraint_names(\n                model, columns, exclude=meta_constraint_names | meta_index_names\n            )\n            # Filter out unique constraints by checking constraint properties\n            constraint_names = []\n            for name in all_constraint_names:\n                # Check if this is a unique constraint by attempting to find it with unique=True\n                unique_names = self._constraint_names(\n                    model, columns, exclude=meta_constraint_names | meta_index_names,\n                    unique=True\n                )\n                if name not in unique_names:\n                    constraint_names.append(name)\n        else:\n            # Default behavior for other constraint types\n            constraint_names = self._constraint_names(\n                model, columns, exclude=meta_constraint_names | meta_index_names,\n                **constraint_kwargs\n            )\n            \n        if len(constraint_names) != 1:\n            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                len(constraint_names),\n                model._meta.db_table,\n                \", \".join(columns),\n            ))\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/django/django/db/backends/base/schema.py lines 402-416)": [
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # Get all constraint names matching the fields\n        all_constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n        )\n        \n        # Filter constraint names based on the constraint type we're looking for\n        if constraint_kwargs.get('unique'):\n            # For unique constraints, filter to only unique constraints\n            constraint_names = self._constraint_names(\n                model, columns, exclude=meta_constraint_names | meta_index_names,\n                unique=True, index=False\n            )\n        elif constraint_kwargs.get('index'):\n            # For index constraints, filter to only non-unique indexes\n            constraint_names = self._constraint_names(\n                model, columns, exclude=meta_constraint_names | meta_index_names,\n                unique=False, index=True\n            )\n        else:\n            # Fallback to original behavior for other constraint types\n            constraint_names = all_constraint_names\n        \n        if len(constraint_names) != 1:\n            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                len(constraint_names),\n                model._meta.db_table,\n                \", \".join(columns),\n            ))\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # When deleting index_together, exclude unique constraints to avoid conflicts\n        exclude_names = meta_constraint_names | meta_index_names\n        if constraint_kwargs.get('index'):\n            # For index deletion, also exclude unique constraints from introspection\n            constraint_kwargs = constraint_kwargs.copy()\n            constraint_kwargs['unique'] = False\n            \n        constraint_names = self._constraint_names(\n            model, columns, exclude=exclude_names,\n            **constraint_kwargs\n        )\n        if len(constraint_names) != 1:\n            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                len(constraint_names),\n                model._meta.db_table,\n                \", \".join(columns),\n            ))\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # Determine if we're looking for a unique constraint or index constraint\n        is_unique_constraint = constraint_kwargs.get('unique', False)\n        is_index_constraint = constraint_kwargs.get('index', False)\n        \n        # Get all constraint names first\n        all_constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        \n        # Filter constraint names based on the type we're looking for\n        constraint_names = []\n        for name in all_constraint_names:\n            # Check if this constraint is unique by querying the database\n            if is_unique_constraint:\n                # Only include unique constraints\n                if self._is_unique_constraint(model, name):\n                    constraint_names.append(name)\n            elif is_index_constraint:\n                # Only include non-unique index constraints\n                if not self._is_unique_constraint(model, name):\n                    constraint_names.append(name)\n            else:\n                # Default behavior - include all constraints\n                constraint_names.append(name)\n        \n        if len(constraint_names) != 1:\n            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                len(constraint_names),\n                model._meta.db_table,\n                \", \".join(columns),\n            ))\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # When looking for index constraints, exclude unique constraints and vice versa\n        exclude_names = meta_constraint_names | meta_index_names\n        if constraint_kwargs.get('index') and not constraint_kwargs.get('unique'):\n            # For index_together deletion, exclude unique constraints\n            unique_constraint_names = self._constraint_names(\n                model, columns, unique=True, exclude=exclude_names\n            )\n            exclude_names |= set(unique_constraint_names)\n        elif constraint_kwargs.get('unique') and not constraint_kwargs.get('index'):\n            # For unique_together deletion, exclude index constraints  \n            index_constraint_names = self._constraint_names(\n                model, columns, index=True, exclude=exclude_names\n            )\n            exclude_names |= set(index_constraint_names)\n            \n        constraint_names = self._constraint_names(\n            model, columns, exclude=exclude_names,\n            **constraint_kwargs\n        )\n        if len(constraint_names) != 1:\n            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                len(constraint_names),\n                model._meta.db_table,\n                \", \".join(columns),\n            ))\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\ndef _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n    meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n    meta_index_names = {constraint.name for constraint in model._meta.indexes}\n    columns = [model._meta.get_field(field).column for field in fields]\n    \n    # Determine what type of constraint we're looking for\n    is_looking_for_unique = constraint_kwargs.get('unique', False)\n    is_looking_for_index = constraint_kwargs.get('index', False)\n    \n    # Get all constraint names first\n    all_constraint_names = self._constraint_names(\n        model, columns, exclude=meta_constraint_names | meta_index_names,\n        **constraint_kwargs\n    )\n    \n    # Filter constraint names based on what we're actually looking for\n    constraint_names = []\n    if all_constraint_names:\n        # Get constraint info to distinguish between unique and index constraints\n        for constraint_name in all_constraint_names:\n            constraint_info = self._get_constraint_info(model, constraint_name, columns)\n            if is_looking_for_unique and constraint_info.get('unique', False):\n                constraint_names.append(constraint_name)\n            elif is_looking_for_index and not constraint_info.get('unique', False):\n                constraint_names.append(constraint_name)\n            elif not is_looking_for_unique and not is_looking_for_index:\n                # Fallback to original behavior if constraint type not specified\n                constraint_names.append(constraint_name)\n    \n    # If we still have multiple constraints, prefer the one that matches our intent\n    if len(constraint_names) > 1:\n        # Try to get a unique constraint info to help filter\n        unique_constraints = []\n        index_constraints = []\n        for constraint_name in constraint_names:\n            constraint_info = self._get_constraint_info(model, constraint_name, columns)\n            if constraint_info.get('unique', False):\n                unique_constraints.append(constraint_name)\n            else:\n                index_constraints.append(constraint_name)\n        \n        if is_looking_for_unique and unique_constraints:\n            constraint_names = unique_constraints[:1]\n        elif is_looking_for_index and index_constraints:\n            constraint_names = index_constraints[:1]\n        elif unique_constraints and not is_looking_for_index:\n            constraint_names = unique_constraints[:1]\n        elif index_constraints and not is_looking_for_unique:\n            constraint_names = index_constraints[:1]\n    \n    if len(constraint_names) != 1:\n        raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n            len(constraint_names),\n            model._meta.db_table,\n            \", \".join(columns),\n        ))\n    self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n\ndef _get_constraint_info(self, model, constraint_name, columns):\n    \"\"\"Helper method to get constraint information.\"\"\"\n    # Get constraint info from the database\n    with self.connection.cursor() as cursor:\n        constraints = self.connection.introspection.get_constraints(cursor, model._meta.db_table)\n    \n    if constraint_name in constraints:\n        return constraints[constraint_name]\n    return {}\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # When deleting index constraints, exclude unique constraints and vice versa\n        exclude_names = meta_constraint_names | meta_index_names\n        if constraint_kwargs.get('index', False):\n            # For index deletion, also exclude unique constraints\n            unique_constraint_names = self._constraint_names(\n                model, columns, unique=True, exclude=exclude_names\n            )\n            exclude_names |= set(unique_constraint_names)\n        elif constraint_kwargs.get('unique', False):\n            # For unique deletion, also exclude index constraints  \n            index_constraint_names = self._constraint_names(\n                model, columns, index=True, exclude=exclude_names\n            )\n            exclude_names |= set(index_constraint_names)\n            \n        constraint_names = self._constraint_names(\n            model, columns, exclude=exclude_names,\n            **constraint_kwargs\n        )\n        if len(constraint_names) != 1:\n            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                len(constraint_names),\n                model._meta.db_table,\n                \", \".join(columns),\n            ))\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # Determine if we're looking for a unique constraint or an index\n        is_unique = constraint_kwargs.get('unique', False)\n        is_index = constraint_kwargs.get('index', False)\n        \n        # Get all constraint names first\n        all_constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        \n        # Filter constraint names based on what we're actually looking for\n        constraint_names = []\n        for name in all_constraint_names:\n            # Check if this constraint is unique or index by querying database\n            constraint_info = self._get_constraint_info(model, name)\n            if is_unique and constraint_info.get('unique', False):\n                constraint_names.append(name)\n            elif is_index and not constraint_info.get('unique', False):\n                constraint_names.append(name)\n            elif not is_unique and not is_index:\n                # Fallback for backward compatibility\n                constraint_names.append(name)\n        \n        if len(constraint_names) != 1:\n            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                len(constraint_names),\n                model._meta.db_table,\n                \", \".join(columns),\n            ))\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # When looking for index constraints, exclude unique constraints and vice versa\n        if constraint_kwargs.get('index'):\n            # For index deletion, exclude unique constraints\n            constraint_names = self._constraint_names(\n                model, columns, exclude=meta_constraint_names | meta_index_names,\n                unique=False, **constraint_kwargs\n            )\n        elif constraint_kwargs.get('unique'):\n            # For unique constraint deletion, exclude regular indexes\n            constraint_names = self._constraint_names(\n                model, columns, exclude=meta_constraint_names | meta_index_names,\n                index=False, **constraint_kwargs\n            )\n        else:\n            # Default behavior for other constraint types\n            constraint_names = self._constraint_names(\n                model, columns, exclude=meta_constraint_names | meta_index_names,\n                **constraint_kwargs\n            )\n            \n        if len(constraint_names) != 1:\n            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                len(constraint_names),\n                model._meta.db_table,\n                \", \".join(columns),\n            ))\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n"
    ],
    "Location 2 (/root/hy/projects_3/django/django/db/backends/base/schema.py lines 406-409)": [
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # When looking for index constraints to delete, exclude unique constraints\n        # When looking for unique constraints to delete, exclude index constraints\n        exclude_names = meta_constraint_names | meta_index_names\n        if constraint_kwargs.get('index') and not constraint_kwargs.get('unique'):\n            # Looking for index constraints only, exclude unique constraints\n            constraint_names = self._constraint_names(\n                model, columns, exclude=exclude_names, unique=False,\n                **constraint_kwargs\n            )\n        elif constraint_kwargs.get('unique') and not constraint_kwargs.get('index'):\n            # Looking for unique constraints only, exclude index constraints  \n            constraint_names = self._constraint_names(\n                model, columns, exclude=exclude_names, index=False,\n                **constraint_kwargs\n            )\n        else:\n            # Default behavior for other constraint types\n            constraint_names = self._constraint_names(\n                model, columns, exclude=exclude_names,\n                **constraint_kwargs\n            )\n            \n        if len(constraint_names) != 1:\n            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                len(constraint_names),\n                model._meta.db_table,\n                \", \".join(columns),\n            ))\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # When looking for index constraints, exclude unique constraints to avoid conflicts\n        exclude_names = meta_constraint_names | meta_index_names\n        if constraint_kwargs.get('index') and not constraint_kwargs.get('unique'):\n            # For index_together deletion, also exclude unique constraints from results\n            constraint_names = self._constraint_names(\n                model, columns, exclude=exclude_names, unique=False,\n                **constraint_kwargs\n            )\n        else:\n            constraint_names = self._constraint_names(\n                model, columns, exclude=exclude_names,\n                **constraint_kwargs\n            )\n            \n        if len(constraint_names) != 1:\n            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                len(constraint_names),\n                model._meta.db_table,\n                \", \".join(columns),\n            ))\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\ndef _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n    meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n    meta_index_names = {constraint.name for constraint in model._meta.indexes}\n    columns = [model._meta.get_field(field).column for field in fields]\n    \n    # Determine if we're looking for unique or index constraints\n    is_unique_constraint = constraint_kwargs.get('unique', False)\n    is_index_constraint = constraint_kwargs.get('index', False)\n    \n    # Build exclusion set based on constraint type\n    exclude = meta_constraint_names | meta_index_names\n    \n    constraint_names = self._constraint_names(\n        model, columns, exclude=exclude, **constraint_kwargs\n    )\n    \n    # Filter out conflicting constraint types if both unique and index exist\n    if len(constraint_names) > 1 and (is_unique_constraint or is_index_constraint):\n        # Get all constraints on these columns\n        all_constraint_names = self._constraint_names(model, columns)\n        \n        # Filter based on constraint type\n        filtered_names = []\n        for name in constraint_names:\n            if is_unique_constraint:\n                # Check if this is actually a unique constraint\n                unique_constraints = self._constraint_names(\n                    model, columns, unique=True, exclude=exclude\n                )\n                if name in unique_constraints:\n                    filtered_names.append(name)\n            elif is_index_constraint:\n                # Check if this is actually an index constraint (not unique)\n                index_constraints = self._constraint_names(\n                    model, columns, index=True, unique=False, exclude=exclude\n                )\n                if name in index_constraints:\n                    filtered_names.append(name)\n        \n        constraint_names = filtered_names\n    \n    if len(constraint_names) != 1:\n        raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n            len(constraint_names),\n            model._meta.db_table,\n            \", \".join(columns),\n        ))\n    self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # When looking for index constraints, exclude unique constraints to avoid conflicts\n        exclude_names = meta_constraint_names | meta_index_names\n        if constraint_kwargs.get('index') and not constraint_kwargs.get('unique'):\n            # For index_together deletion, also exclude unique constraints from results\n            constraint_names = self._constraint_names(\n                model, columns, exclude=exclude_names, unique=False,\n                **constraint_kwargs\n            )\n        else:\n            constraint_names = self._constraint_names(\n                model, columns, exclude=exclude_names,\n                **constraint_kwargs\n            )\n        \n        if len(constraint_names) != 1:\n            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                len(constraint_names),\n                model._meta.db_table,\n                \", \".join(columns),\n            ))\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\ndef _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n    meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n    meta_index_names = {constraint.name for constraint in model._meta.indexes}\n    columns = [model._meta.get_field(field).column for field in fields]\n    \n    # When looking for index constraints, exclude unique constraints\n    # When looking for unique constraints, exclude index-only constraints\n    if constraint_kwargs.get('index') and not constraint_kwargs.get('unique'):\n        # Looking for index-only constraints, exclude unique constraints\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            unique=False, **constraint_kwargs\n        )\n    elif constraint_kwargs.get('unique') and not constraint_kwargs.get('index'):\n        # Looking for unique constraints, exclude index-only constraints  \n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            index=False, **constraint_kwargs\n        )\n    else:\n        # Original behavior for other cases\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n    \n    if len(constraint_names) != 1:\n        raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n            len(constraint_names),\n            model._meta.db_table,\n            \", \".join(columns),\n        ))\n    self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # Filter constraint names based on the specific constraint type being deleted\n        # If we're looking for index constraints, exclude unique constraints\n        # If we're looking for unique constraints, exclude index-only constraints\n        exclude_names = meta_constraint_names | meta_index_names\n        if constraint_kwargs.get('index') and not constraint_kwargs.get('unique'):\n            # Looking for index-only constraints, exclude unique constraints\n            unique_constraint_names = self._constraint_names(\n                model, columns, unique=True, exclude=exclude_names\n            )\n            exclude_names = exclude_names | set(unique_constraint_names)\n        elif constraint_kwargs.get('unique') and not constraint_kwargs.get('index'):\n            # Looking for unique constraints, exclude index-only constraints\n            index_constraint_names = self._constraint_names(\n                model, columns, index=True, exclude=exclude_names\n            )\n            exclude_names = exclude_names | set(index_constraint_names)\n        \n        constraint_names = self._constraint_names(\n            model, columns, exclude=exclude_names,\n            **constraint_kwargs\n        )\n        if len(constraint_names) != 1:\n            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                len(constraint_names),\n                model._meta.db_table,\n                \", \".join(columns),\n            ))\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # Filter constraint names based on the specific constraint type we're looking for\n        if constraint_kwargs.get('unique'):\n            # When looking for unique constraints, exclude regular indexes\n            constraint_names = self._constraint_names(\n                model, columns, exclude=meta_constraint_names | meta_index_names,\n                **constraint_kwargs\n            )\n        elif constraint_kwargs.get('index'):\n            # When looking for index constraints, exclude unique constraints\n            # Get all constraints first, then filter out unique ones\n            all_constraint_names = self._constraint_names(\n                model, columns, exclude=meta_constraint_names | meta_index_names\n            )\n            # Filter out unique constraints by checking if they have unique=True\n            constraint_names = []\n            for name in all_constraint_names:\n                unique_names = self._constraint_names(\n                    model, columns, exclude=meta_constraint_names | meta_index_names,\n                    unique=True\n                )\n                if name not in unique_names:\n                    constraint_names.append(name)\n        else:\n            # Default behavior for other constraint types\n            constraint_names = self._constraint_names(\n                model, columns, exclude=meta_constraint_names | meta_index_names,\n                **constraint_kwargs\n            )\n        \n        if len(constraint_names) != 1:\n            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                len(constraint_names),\n                model._meta.db_table,\n                \", \".join(columns),\n            ))\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # Filter constraint names based on the specific constraint type we're looking for\n        if constraint_kwargs.get('unique'):\n            # When looking for unique constraints, exclude index-only constraints\n            constraint_names = self._constraint_names(\n                model, columns, exclude=meta_constraint_names | meta_index_names,\n                **constraint_kwargs\n            )\n        elif constraint_kwargs.get('index'):\n            # When looking for index constraints, exclude unique constraints\n            # by adding unique=False to ensure we only get index constraints\n            modified_kwargs = constraint_kwargs.copy()\n            modified_kwargs['unique'] = False\n            constraint_names = self._constraint_names(\n                model, columns, exclude=meta_constraint_names | meta_index_names,\n                **modified_kwargs\n            )\n        else:\n            # Default behavior for other constraint types\n            constraint_names = self._constraint_names(\n                model, columns, exclude=meta_constraint_names | meta_index_names,\n                **constraint_kwargs\n            )\n            \n        if len(constraint_names) != 1:\n            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                len(constraint_names),\n                model._meta.db_table,\n                \", \".join(columns),\n            ))\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..d2845c3070 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -399,13 +399,36 @@ class BaseDatabaseSchemaEditor:\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n \n+\n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n+        \n+        # Make constraint filtering more specific to avoid conflicts between\n+        # unique and index constraints on the same fields\n+        filter_kwargs = constraint_kwargs.copy()\n+        if constraint_kwargs.get('index') and not constraint_kwargs.get('unique'):\n+            # When looking for index constraints, exclude unique constraints\n+            filter_kwargs['unique'] = False\n+        elif constraint_kwargs.get('unique') and not constraint_kwargs.get('index'):\n+            # When looking for unique constraints, exclude non-unique indexes\n+            filter_kwargs['index'] = False\n+            \n+        constraint_names = self._constraint_names(\n+            model, columns, exclude=meta_constraint_names | meta_index_names,\n+            **filter_kwargs\n+        )\n+        if len(constraint_names) != 1:\n+            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+                len(constraint_names),\n+                model._meta.db_table,\n+                \", \".join(columns),\n+            ))\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n         constraint_names = self._constraint_names(\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n-            **constraint_kwargs\n+            **filter_kwargs\n         )\n         if len(constraint_names) != 1:\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n",
    "variant_0": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..bdc72fd856 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -399,14 +399,71 @@ class BaseDatabaseSchemaEditor:\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n \n+\n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n+        \n+        # If we're looking for index constraints, exclude unique constraints\n+        # If we're looking for unique constraints, exclude index constraints\n+        exclude_names = meta_constraint_names | meta_index_names\n+        if constraint_kwargs.get('index') and not constraint_kwargs.get('unique'):\n+            # When deleting index_together, exclude unique constraints\n+            unique_constraint_names = self._constraint_names(\n+                model, columns, unique=True, exclude=exclude_names\n+            )\n+            exclude_names = exclude_names | set(unique_constraint_names)\n+        elif constraint_kwargs.get('unique') and not constraint_kwargs.get('index'):\n+            # When deleting unique_together, exclude index constraints\n+            index_constraint_names = self._constraint_names(\n+                model, columns, index=True, exclude=exclude_names\n+            )\n+            exclude_names = exclude_names | set(index_constraint_names)\n+        \n         constraint_names = self._constraint_names(\n-            model, columns, exclude=meta_constraint_names | meta_index_names,\n+            model, columns, exclude=exclude_names,\n             **constraint_kwargs\n         )\n+        if len(constraint_names) != 1:\n+            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+                len(constraint_names),\n+                model._meta.db_table,\n+                \", \".join(columns),\n+            ))\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+                **constraint_kwargs\n+            )\n+        elif constraint_kwargs.get('index'):\n+            # When deleting index constraints, exclude unique constraints\n+            # Get all matching constraints first\n+            all_constraint_names = self._constraint_names(\n+                model, columns, exclude=meta_constraint_names | meta_index_names\n+            )\n+            # Filter out unique constraints by checking constraint properties\n+            constraint_names = []\n+            for name in all_constraint_names:\n+                # Check if this is a unique constraint by attempting to find it with unique=True\n+                unique_names = self._constraint_names(\n+                    model, columns, exclude=meta_constraint_names | meta_index_names,\n+                    unique=True\n+                )\n+                if name not in unique_names:\n+                    constraint_names.append(name)\n+        else:\n+            # Default behavior for other constraint types\n+            constraint_names = self._constraint_names(\n+                model, columns, exclude=meta_constraint_names | meta_index_names,\n+                **constraint_kwargs\n+            )\n+            \n+        if len(constraint_names) != 1:\n+            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+                len(constraint_names),\n+                model._meta.db_table,\n+                \", \".join(columns),\n+            ))\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n         if len(constraint_names) != 1:\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                 len(constraint_names),\n",
    "variant_1": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..728cb82e60 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -399,14 +399,65 @@ class BaseDatabaseSchemaEditor:\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n \n+\n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n-        constraint_names = self._constraint_names(\n+        \n+        # Get all constraint names matching the fields\n+        all_constraint_names = self._constraint_names(\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n-            **constraint_kwargs\n         )\n+        \n+        # Filter constraint names based on the constraint type we're looking for\n+        if constraint_kwargs.get('unique'):\n+            # For unique constraints, filter to only unique constraints\n+            constraint_names = self._constraint_names(\n+                model, columns, exclude=meta_constraint_names | meta_index_names,\n+                unique=True, index=False\n+            )\n+        elif constraint_kwargs.get('index'):\n+            # For index constraints, filter to only non-unique indexes\n+            constraint_names = self._constraint_names(\n+                model, columns, exclude=meta_constraint_names | meta_index_names,\n+                unique=False, index=True\n+            )\n+        else:\n+            # Fallback to original behavior for other constraint types\n+            constraint_names = all_constraint_names\n+        \n+        if len(constraint_names) != 1:\n+            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+                len(constraint_names),\n+                model._meta.db_table,\n+                \", \".join(columns),\n+            ))\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+            constraint_names = self._constraint_names(\n+                model, columns, exclude=exclude_names, unique=False,\n+                **constraint_kwargs\n+            )\n+        elif constraint_kwargs.get('unique') and not constraint_kwargs.get('index'):\n+            # Looking for unique constraints only, exclude index constraints  \n+            constraint_names = self._constraint_names(\n+                model, columns, exclude=exclude_names, index=False,\n+                **constraint_kwargs\n+            )\n+        else:\n+            # Default behavior for other constraint types\n+            constraint_names = self._constraint_names(\n+                model, columns, exclude=exclude_names,\n+                **constraint_kwargs\n+            )\n+            \n+        if len(constraint_names) != 1:\n+            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+                len(constraint_names),\n+                model._meta.db_table,\n+                \", \".join(columns),\n+            ))\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n         if len(constraint_names) != 1:\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                 len(constraint_names),\n",
    "variant_2": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..de4d37783f 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -399,14 +399,46 @@ class BaseDatabaseSchemaEditor:\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n \n+\n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n+        \n+        # When deleting index_together, exclude unique constraints to avoid conflicts\n+        exclude_names = meta_constraint_names | meta_index_names\n+        if constraint_kwargs.get('index'):\n+            # For index deletion, also exclude unique constraints from introspection\n+            constraint_kwargs = constraint_kwargs.copy()\n+            constraint_kwargs['unique'] = False\n+            \n         constraint_names = self._constraint_names(\n-            model, columns, exclude=meta_constraint_names | meta_index_names,\n+            model, columns, exclude=exclude_names,\n             **constraint_kwargs\n         )\n+        if len(constraint_names) != 1:\n+            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+                len(constraint_names),\n+                model._meta.db_table,\n+                \", \".join(columns),\n+            ))\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+                model, columns, exclude=exclude_names, unique=False,\n+                **constraint_kwargs\n+            )\n+        else:\n+            constraint_names = self._constraint_names(\n+                model, columns, exclude=exclude_names,\n+                **constraint_kwargs\n+            )\n+            \n+        if len(constraint_names) != 1:\n+            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+                len(constraint_names),\n+                model._meta.db_table,\n+                \", \".join(columns),\n+            ))\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n         if len(constraint_names) != 1:\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                 len(constraint_names),\n",
    "variant_3": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..49dd7e8a42 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -399,14 +399,83 @@ class BaseDatabaseSchemaEditor:\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n \n+\n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n-        constraint_names = self._constraint_names(\n+        \n+        # Determine if we're looking for a unique constraint or index constraint\n+        is_unique_constraint = constraint_kwargs.get('unique', False)\n+        is_index_constraint = constraint_kwargs.get('index', False)\n+        \n+        # Get all constraint names first\n+        all_constraint_names = self._constraint_names(\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n             **constraint_kwargs\n         )\n+        \n+        # Filter constraint names based on the type we're looking for\n+        constraint_names = []\n+        for name in all_constraint_names:\n+            # Check if this constraint is unique by querying the database\n+            if is_unique_constraint:\n+                # Only include unique constraints\n+                if self._is_unique_constraint(model, name):\n+                    constraint_names.append(name)\n+            elif is_index_constraint:\n+                # Only include non-unique index constraints\n+                if not self._is_unique_constraint(model, name):\n+                    constraint_names.append(name)\n+            else:\n+                # Default behavior - include all constraints\n+                constraint_names.append(name)\n+        \n+        if len(constraint_names) != 1:\n+            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+                len(constraint_names),\n+                model._meta.db_table,\n+                \", \".join(columns),\n+            ))\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+    exclude = meta_constraint_names | meta_index_names\n+    \n+    constraint_names = self._constraint_names(\n+        model, columns, exclude=exclude, **constraint_kwargs\n+    )\n+    \n+    # Filter out conflicting constraint types if both unique and index exist\n+    if len(constraint_names) > 1 and (is_unique_constraint or is_index_constraint):\n+        # Get all constraints on these columns\n+        all_constraint_names = self._constraint_names(model, columns)\n+        \n+        # Filter based on constraint type\n+        filtered_names = []\n+        for name in constraint_names:\n+            if is_unique_constraint:\n+                # Check if this is actually a unique constraint\n+                unique_constraints = self._constraint_names(\n+                    model, columns, unique=True, exclude=exclude\n+                )\n+                if name in unique_constraints:\n+                    filtered_names.append(name)\n+            elif is_index_constraint:\n+                # Check if this is actually an index constraint (not unique)\n+                index_constraints = self._constraint_names(\n+                    model, columns, index=True, unique=False, exclude=exclude\n+                )\n+                if name in index_constraints:\n+                    filtered_names.append(name)\n+        \n+        constraint_names = filtered_names\n+    \n+    if len(constraint_names) != 1:\n+        raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+            len(constraint_names),\n+            model._meta.db_table,\n+            \", \".join(columns),\n+        ))\n+    self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n         if len(constraint_names) != 1:\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                 len(constraint_names),\n",
    "variant_4": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..c97156bf22 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -399,14 +399,54 @@ class BaseDatabaseSchemaEditor:\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n \n+\n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n+        \n+        # When looking for index constraints, exclude unique constraints and vice versa\n+        exclude_names = meta_constraint_names | meta_index_names\n+        if constraint_kwargs.get('index') and not constraint_kwargs.get('unique'):\n+            # For index_together deletion, exclude unique constraints\n+            unique_constraint_names = self._constraint_names(\n+                model, columns, unique=True, exclude=exclude_names\n+            )\n+            exclude_names |= set(unique_constraint_names)\n+        elif constraint_kwargs.get('unique') and not constraint_kwargs.get('index'):\n+            # For unique_together deletion, exclude index constraints  \n+            index_constraint_names = self._constraint_names(\n+                model, columns, index=True, exclude=exclude_names\n+            )\n+            exclude_names |= set(index_constraint_names)\n+            \n         constraint_names = self._constraint_names(\n-            model, columns, exclude=meta_constraint_names | meta_index_names,\n+            model, columns, exclude=exclude_names,\n             **constraint_kwargs\n         )\n+        if len(constraint_names) != 1:\n+            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+                len(constraint_names),\n+                model._meta.db_table,\n+                \", \".join(columns),\n+            ))\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+                model, columns, exclude=exclude_names, unique=False,\n+                **constraint_kwargs\n+            )\n+        else:\n+            constraint_names = self._constraint_names(\n+                model, columns, exclude=exclude_names,\n+                **constraint_kwargs\n+            )\n+        \n+        if len(constraint_names) != 1:\n+            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+                len(constraint_names),\n+                model._meta.db_table,\n+                \", \".join(columns),\n+            ))\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n         if len(constraint_names) != 1:\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                 len(constraint_names),\n",
    "variant_5": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..6f77c5437b 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -399,14 +399,97 @@ class BaseDatabaseSchemaEditor:\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n \n-    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n-        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n-        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n-        columns = [model._meta.get_field(field).column for field in fields]\n+\n+def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+    meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n+    meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+    columns = [model._meta.get_field(field).column for field in fields]\n+    \n+    # Determine what type of constraint we're looking for\n+    is_looking_for_unique = constraint_kwargs.get('unique', False)\n+    is_looking_for_index = constraint_kwargs.get('index', False)\n+    \n+    # Get all constraint names first\n+    all_constraint_names = self._constraint_names(\n+        model, columns, exclude=meta_constraint_names | meta_index_names,\n+        **constraint_kwargs\n+    )\n+    \n+    # Filter constraint names based on what we're actually looking for\n+    constraint_names = []\n+    if all_constraint_names:\n+        # Get constraint info to distinguish between unique and index constraints\n+        for constraint_name in all_constraint_names:\n+            constraint_info = self._get_constraint_info(model, constraint_name, columns)\n+            if is_looking_for_unique and constraint_info.get('unique', False):\n+                constraint_names.append(constraint_name)\n+            elif is_looking_for_index and not constraint_info.get('unique', False):\n+                constraint_names.append(constraint_name)\n+            elif not is_looking_for_unique and not is_looking_for_index:\n+                # Fallback to original behavior if constraint type not specified\n+                constraint_names.append(constraint_name)\n+    \n+    # If we still have multiple constraints, prefer the one that matches our intent\n+    if len(constraint_names) > 1:\n+        # Try to get a unique constraint info to help filter\n+        unique_constraints = []\n+        index_constraints = []\n+        for constraint_name in constraint_names:\n+            constraint_info = self._get_constraint_info(model, constraint_name, columns)\n+            if constraint_info.get('unique', False):\n+                unique_constraints.append(constraint_name)\n+            else:\n+                index_constraints.append(constraint_name)\n+        \n+        if is_looking_for_unique and unique_constraints:\n+            constraint_names = unique_constraints[:1]\n+        elif is_looking_for_index and index_constraints:\n+            constraint_names = index_constraints[:1]\n+        elif unique_constraints and not is_looking_for_index:\n+            constraint_names = unique_constraints[:1]\n+        elif index_constraints and not is_looking_for_unique:\n+            constraint_names = index_constraints[:1]\n+    \n+    if len(constraint_names) != 1:\n+        raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+            len(constraint_names),\n+            model._meta.db_table,\n+            \", \".join(columns),\n+        ))\n+    self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+\n+def _get_constraint_info(self, model, constraint_name, columns):\n+    \"\"\"Helper method to get constraint information.\"\"\"\n+    # Get constraint info from the database\n+    with self.connection.cursor() as cursor:\n+        constraints = self.connection.introspection.get_constraints(cursor, model._meta.db_table)\n+    \n+    if constraint_name in constraints:\n+        return constraints[constraint_name]\n+    return {}\n+            model, columns, exclude=meta_constraint_names | meta_index_names,\n+            unique=False, **constraint_kwargs\n+        )\n+    elif constraint_kwargs.get('unique') and not constraint_kwargs.get('index'):\n+        # Looking for unique constraints, exclude index-only constraints  \n+        constraint_names = self._constraint_names(\n+            model, columns, exclude=meta_constraint_names | meta_index_names,\n+            index=False, **constraint_kwargs\n+        )\n+    else:\n+        # Original behavior for other cases\n         constraint_names = self._constraint_names(\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n             **constraint_kwargs\n         )\n+    \n+    if len(constraint_names) != 1:\n+        raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+            len(constraint_names),\n+            model._meta.db_table,\n+            \", \".join(columns),\n+        ))\n+    self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n         if len(constraint_names) != 1:\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                 len(constraint_names),\n",
    "variant_6": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..baf4b79a39 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -399,12 +399,52 @@ class BaseDatabaseSchemaEditor:\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n \n+\n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n+        \n+        # When deleting index constraints, exclude unique constraints and vice versa\n+        exclude_names = meta_constraint_names | meta_index_names\n+        if constraint_kwargs.get('index', False):\n+            # For index deletion, also exclude unique constraints\n+            unique_constraint_names = self._constraint_names(\n+                model, columns, unique=True, exclude=exclude_names\n+            )\n+            exclude_names |= set(unique_constraint_names)\n+        elif constraint_kwargs.get('unique', False):\n+            # For unique deletion, also exclude index constraints  \n+            index_constraint_names = self._constraint_names(\n+                model, columns, index=True, exclude=exclude_names\n+            )\n+            exclude_names |= set(index_constraint_names)\n+            \n+        constraint_names = self._constraint_names(\n+            model, columns, exclude=exclude_names,\n+            **constraint_kwargs\n+        )\n+        if len(constraint_names) != 1:\n+            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+                len(constraint_names),\n+                model._meta.db_table,\n+                \", \".join(columns),\n+            ))\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+            # Looking for index-only constraints, exclude unique constraints\n+            unique_constraint_names = self._constraint_names(\n+                model, columns, unique=True, exclude=exclude_names\n+            )\n+            exclude_names = exclude_names | set(unique_constraint_names)\n+        elif constraint_kwargs.get('unique') and not constraint_kwargs.get('index'):\n+            # Looking for unique constraints, exclude index-only constraints\n+            index_constraint_names = self._constraint_names(\n+                model, columns, index=True, exclude=exclude_names\n+            )\n+            exclude_names = exclude_names | set(index_constraint_names)\n+        \n         constraint_names = self._constraint_names(\n-            model, columns, exclude=meta_constraint_names | meta_index_names,\n+            model, columns, exclude=exclude_names,\n             **constraint_kwargs\n         )\n         if len(constraint_names) != 1:\n@@ -414,6 +454,13 @@ class BaseDatabaseSchemaEditor:\n                 \", \".join(columns),\n             ))\n         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+        if len(constraint_names) != 1:\n+            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+                len(constraint_names),\n+                model._meta.db_table,\n+                \", \".join(columns),\n+            ))\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def alter_db_table(self, model, old_db_table, new_db_table):\n         \"\"\"Rename the table a model points to.\"\"\"\n",
    "variant_7": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..26c275b899 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -399,14 +399,73 @@ class BaseDatabaseSchemaEditor:\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n \n+\n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n-        constraint_names = self._constraint_names(\n+        \n+        # Determine if we're looking for a unique constraint or an index\n+        is_unique = constraint_kwargs.get('unique', False)\n+        is_index = constraint_kwargs.get('index', False)\n+        \n+        # Get all constraint names first\n+        all_constraint_names = self._constraint_names(\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n             **constraint_kwargs\n         )\n+        \n+        # Filter constraint names based on what we're actually looking for\n+        constraint_names = []\n+        for name in all_constraint_names:\n+            # Check if this constraint is unique or index by querying database\n+            constraint_info = self._get_constraint_info(model, name)\n+            if is_unique and constraint_info.get('unique', False):\n+                constraint_names.append(name)\n+            elif is_index and not constraint_info.get('unique', False):\n+                constraint_names.append(name)\n+            elif not is_unique and not is_index:\n+                # Fallback for backward compatibility\n+                constraint_names.append(name)\n+        \n+        if len(constraint_names) != 1:\n+            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+                len(constraint_names),\n+                model._meta.db_table,\n+                \", \".join(columns),\n+            ))\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+                **constraint_kwargs\n+            )\n+        elif constraint_kwargs.get('index'):\n+            # When looking for index constraints, exclude unique constraints\n+            # Get all constraints first, then filter out unique ones\n+            all_constraint_names = self._constraint_names(\n+                model, columns, exclude=meta_constraint_names | meta_index_names\n+            )\n+            # Filter out unique constraints by checking if they have unique=True\n+            constraint_names = []\n+            for name in all_constraint_names:\n+                unique_names = self._constraint_names(\n+                    model, columns, exclude=meta_constraint_names | meta_index_names,\n+                    unique=True\n+                )\n+                if name not in unique_names:\n+                    constraint_names.append(name)\n+        else:\n+            # Default behavior for other constraint types\n+            constraint_names = self._constraint_names(\n+                model, columns, exclude=meta_constraint_names | meta_index_names,\n+                **constraint_kwargs\n+            )\n+        \n+        if len(constraint_names) != 1:\n+            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+                len(constraint_names),\n+                model._meta.db_table,\n+                \", \".join(columns),\n+            ))\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n         if len(constraint_names) != 1:\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                 len(constraint_names),\n",
    "variant_8": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..94e780d8e7 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -399,14 +399,64 @@ class BaseDatabaseSchemaEditor:\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n \n+\n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n-        constraint_names = self._constraint_names(\n-            model, columns, exclude=meta_constraint_names | meta_index_names,\n-            **constraint_kwargs\n-        )\n+        \n+        # When looking for index constraints, exclude unique constraints and vice versa\n+        if constraint_kwargs.get('index'):\n+            # For index deletion, exclude unique constraints\n+            constraint_names = self._constraint_names(\n+                model, columns, exclude=meta_constraint_names | meta_index_names,\n+                unique=False, **constraint_kwargs\n+            )\n+        elif constraint_kwargs.get('unique'):\n+            # For unique constraint deletion, exclude regular indexes\n+            constraint_names = self._constraint_names(\n+                model, columns, exclude=meta_constraint_names | meta_index_names,\n+                index=False, **constraint_kwargs\n+            )\n+        else:\n+            # Default behavior for other constraint types\n+            constraint_names = self._constraint_names(\n+                model, columns, exclude=meta_constraint_names | meta_index_names,\n+                **constraint_kwargs\n+            )\n+            \n+        if len(constraint_names) != 1:\n+            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+                len(constraint_names),\n+                model._meta.db_table,\n+                \", \".join(columns),\n+            ))\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+                **constraint_kwargs\n+            )\n+        elif constraint_kwargs.get('index'):\n+            # When looking for index constraints, exclude unique constraints\n+            # by adding unique=False to ensure we only get index constraints\n+            modified_kwargs = constraint_kwargs.copy()\n+            modified_kwargs['unique'] = False\n+            constraint_names = self._constraint_names(\n+                model, columns, exclude=meta_constraint_names | meta_index_names,\n+                **modified_kwargs\n+            )\n+        else:\n+            # Default behavior for other constraint types\n+            constraint_names = self._constraint_names(\n+                model, columns, exclude=meta_constraint_names | meta_index_names,\n+                **constraint_kwargs\n+            )\n+            \n+        if len(constraint_names) != 1:\n+            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+                len(constraint_names),\n+                model._meta.db_table,\n+                \", \".join(columns),\n+            ))\n+        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n         if len(constraint_names) != 1:\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                 len(constraint_names),\n"
  }
}