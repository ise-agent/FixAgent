{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/django/django/db/backends/base/schema.py lines 562-594)": "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, old_model=None):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        # Use old_model for column lookup if provided, otherwise use current model\n        source_model = old_model if old_model else model\n        columns = [source_model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs,\n        )\n        if (\n            constraint_kwargs.get(\"unique\") is True\n            and constraint_names\n            and self.connection.features.allows_multiple_constraints_on_same_fields\n        ):\n            # Constraint matching the unique_together name.\n            default_name = str(\n                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n            )\n            if default_name in constraint_names:\n                constraint_names = [default_name]\n        if len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
    "Location 2 (/root/hy/projects_3/django/django/db/migrations/operations/models.py lines 560-569)": "\n    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n        new_model = to_state.apps.get_model(app_label, self.name)\n        if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n            old_model = from_state.apps.get_model(app_label, self.name)\n            alter_together = getattr(schema_editor, \"alter_%s\" % self.option_name)\n            alter_together(\n                new_model,\n                getattr(old_model._meta, self.option_name, set()),\n                getattr(new_model._meta, self.option_name, set()),\n                old_model=old_model,\n            )\n",
    "Location 3 (/root/hy/projects_3/django/django/db/backends/base/schema.py lines 520-540)": "\n    def alter_unique_together(self, model, old_unique_together, new_unique_together, old_model=None):\n        \"\"\"\n        Deal with a model changing its unique_together. The input\n        unique_togethers must be doubly-nested, not the single-nested\n        [\"foo\", \"bar\"] format.\n        \"\"\"\n        olds = {tuple(fields) for fields in old_unique_together}\n        news = {tuple(fields) for fields in new_unique_together}\n        # Deleted uniques\n        for fields in olds.difference(news):\n            self._delete_composed_index(\n                model,\n                fields,\n                {\"unique\": True, \"primary_key\": False},\n                self.sql_delete_unique,\n                old_model=old_model,\n            )\n        # Created uniques\n        for field_names in news.difference(olds):\n            fields = [model._meta.get_field(field) for field in field_names]\n            self.execute(self._create_unique_sql(model, fields))\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/django/django/db/backends/base/schema.py lines 562-594)": [
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, old_model=None):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        # Use old_model for column lookup if provided, otherwise use current model\n        lookup_model = old_model if old_model else model\n        columns = [lookup_model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs,\n        )\n        if (\n            constraint_kwargs.get(\"unique\") is True\n            and constraint_names\n            and self.connection.features.allows_multiple_constraints_on_same_fields\n        ):\n            # Constraint matching the unique_together name.\n            default_name = str(\n                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n            )\n            if default_name in constraint_names:\n                constraint_names = [default_name]\n        if len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, old_model=None):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        # Use old_model for column lookup if provided, otherwise use current model\n        model_for_columns = old_model if old_model else model\n        columns = [model_for_columns._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs,\n        )\n        if (\n            constraint_kwargs.get(\"unique\") is True\n            and constraint_names\n            and self.connection.features.allows_multiple_constraints_on_same_fields\n        ):\n            # Constraint matching the unique_together name.\n            default_name = str(\n                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n            )\n            if default_name in constraint_names:\n                constraint_names = [default_name]\n        if len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, old_model=None):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        # Use old_model for column lookup if provided, otherwise use current model\n        source_model = old_model if old_model else model\n        columns = [source_model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs,\n        )\n        if (\n            constraint_kwargs.get(\"unique\") is True\n            and constraint_names\n            and self.connection.features.allows_multiple_constraints_on_same_fields\n        ):\n            # Constraint matching the unique_together name.\n            default_name = str(\n                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n            )\n            if default_name in constraint_names:\n                constraint_names = [default_name]\n        if len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, old_model=None):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        # Use old_model for column lookup if provided, otherwise use current model\n        if old_model:\n            columns = [old_model._meta.get_field(field).column for field in fields]\n        else:\n            columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs,\n        )\n        if (\n            constraint_kwargs.get(\"unique\") is True\n            and constraint_names\n            and self.connection.features.allows_multiple_constraints_on_same_fields\n        ):\n            # Constraint matching the unique_together name.\n            default_name = str(\n                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n            )\n            if default_name in constraint_names:\n                constraint_names = [default_name]\n        if len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, old_model=None):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        # Use old_model for column lookup if provided, otherwise use current model\n        model_for_columns = old_model if old_model else model\n        columns = [model_for_columns._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs,\n        )\n        if (\n            constraint_kwargs.get(\"unique\") is True\n            and constraint_names\n            and self.connection.features.allows_multiple_constraints_on_same_fields\n        ):\n            # Constraint matching the unique_together name.\n            default_name = str(\n                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n            )\n            if default_name in constraint_names:\n                constraint_names = [default_name]\n        if len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, old_model=None):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        # Use old_model for column lookup when deleting constraints to handle field type changes\n        source_model = old_model if old_model else model\n        columns = [source_model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs,\n        )\n        if (\n            constraint_kwargs.get(\"unique\") is True\n            and constraint_names\n            and self.connection.features.allows_multiple_constraints_on_same_fields\n        ):\n            # Constraint matching the unique_together name.\n            default_name = str(\n                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n            )\n            if default_name in constraint_names:\n                constraint_names = [default_name]\n        if len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, old_model=None):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        # Use old_model for column lookup if provided, otherwise use current model\n        lookup_model = old_model if old_model else model\n        columns = [lookup_model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs,\n        )\n        if (\n            constraint_kwargs.get(\"unique\") is True\n            and constraint_names\n            and self.connection.features.allows_multiple_constraints_on_same_fields\n        ):\n            # Constraint matching the unique_together name.\n            default_name = str(\n                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n            )\n            if default_name in constraint_names:\n                constraint_names = [default_name]\n        if len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, old_model=None):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        # Use old_model for column lookup if provided, otherwise use current model\n        lookup_model = old_model if old_model else model\n        columns = [lookup_model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs,\n        )\n        if (\n            constraint_kwargs.get(\"unique\") is True\n            and constraint_names\n            and self.connection.features.allows_multiple_constraints_on_same_fields\n        ):\n            # Constraint matching the unique_together name.\n            default_name = str(\n                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n            )\n            if default_name in constraint_names:\n                constraint_names = [default_name]\n        if len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n"
    ],
    "Location 2 (/root/hy/projects_3/django/django/db/migrations/operations/models.py lines 560-569)": [
      "\n    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n        new_model = to_state.apps.get_model(app_label, self.name)\n        if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n            old_model = from_state.apps.get_model(app_label, self.name)\n            alter_together = getattr(schema_editor, \"alter_%s\" % self.option_name)\n            alter_together(\n                new_model,\n                getattr(old_model._meta, self.option_name, set()),\n                getattr(new_model._meta, self.option_name, set()),\n                old_model,\n            )\n",
      "\n    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n        new_model = to_state.apps.get_model(app_label, self.name)\n        if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n            old_model = from_state.apps.get_model(app_label, self.name)\n            alter_together = getattr(schema_editor, \"alter_%s\" % self.option_name)\n            alter_together(\n                new_model,\n                getattr(old_model._meta, self.option_name, set()),\n                getattr(new_model._meta, self.option_name, set()),\n                old_model=old_model,\n            )\n",
      "\n    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n        new_model = to_state.apps.get_model(app_label, self.name)\n        if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n            old_model = from_state.apps.get_model(app_label, self.name)\n            alter_together = getattr(schema_editor, \"alter_%s\" % self.option_name)\n            alter_together(\n                new_model,\n                getattr(old_model._meta, self.option_name, set()),\n                getattr(new_model._meta, self.option_name, set()),\n                old_model=old_model,\n            )\n",
      "\n    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n        new_model = to_state.apps.get_model(app_label, self.name)\n        if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n            old_model = from_state.apps.get_model(app_label, self.name)\n            alter_together = getattr(schema_editor, \"alter_%s\" % self.option_name)\n            alter_together(\n                new_model,\n                getattr(old_model._meta, self.option_name, set()),\n                getattr(new_model._meta, self.option_name, set()),\n                old_model,\n            )\n",
      "\n    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n        new_model = to_state.apps.get_model(app_label, self.name)\n        if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n            old_model = from_state.apps.get_model(app_label, self.name)\n            alter_together = getattr(schema_editor, \"alter_%s\" % self.option_name)\n            alter_together(\n                new_model,\n                getattr(old_model._meta, self.option_name, set()),\n                getattr(new_model._meta, self.option_name, set()),\n                old_model,\n            )\n",
      "\n    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n        new_model = to_state.apps.get_model(app_label, self.name)\n        if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n            old_model = from_state.apps.get_model(app_label, self.name)\n            alter_together = getattr(schema_editor, \"alter_%s\" % self.option_name)\n            alter_together(\n                new_model,\n                getattr(old_model._meta, self.option_name, set()),\n                getattr(new_model._meta, self.option_name, set()),\n                old_model=old_model,\n            )\n",
      "\n    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n        new_model = to_state.apps.get_model(app_label, self.name)\n        if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n            old_model = from_state.apps.get_model(app_label, self.name)\n            alter_together = getattr(schema_editor, \"alter_%s\" % self.option_name)\n            alter_together(\n                new_model,\n                getattr(old_model._meta, self.option_name, set()),\n                getattr(new_model._meta, self.option_name, set()),\n                old_model=old_model,\n            )\n",
      "\n    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n        new_model = to_state.apps.get_model(app_label, self.name)\n        if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n            old_model = from_state.apps.get_model(app_label, self.name)\n            alter_together = getattr(schema_editor, \"alter_%s\" % self.option_name)\n            alter_together(\n                new_model,\n                getattr(old_model._meta, self.option_name, set()),\n                getattr(new_model._meta, self.option_name, set()),\n                old_model=old_model,\n            )\n"
    ],
    "Location 3 (/root/hy/projects_3/django/django/db/backends/base/schema.py lines 520-540)": [
      "\n    def alter_unique_together(self, model, old_unique_together, new_unique_together, old_model=None):\n        \"\"\"\n        Deal with a model changing its unique_together. The input\n        unique_togethers must be doubly-nested, not the single-nested\n        [\"foo\", \"bar\"] format.\n        \"\"\"\n        olds = {tuple(fields) for fields in old_unique_together}\n        news = {tuple(fields) for fields in new_unique_together}\n        # Deleted uniques\n        for fields in olds.difference(news):\n            self._delete_composed_index(\n                model,\n                fields,\n                {\"unique\": True, \"primary_key\": False},\n                self.sql_delete_unique,\n                old_model=old_model,\n            )\n        # Created uniques\n        for field_names in news.difference(olds):\n            fields = [model._meta.get_field(field) for field in field_names]\n            self.execute(self._create_unique_sql(model, fields))\n",
      "\n    def alter_unique_together(self, model, old_unique_together, new_unique_together, old_model=None):\n        \"\"\"\n        Deal with a model changing its unique_together. The input\n        unique_togethers must be doubly-nested, not the single-nested\n        [\"foo\", \"bar\"] format.\n        \"\"\"\n        olds = {tuple(fields) for fields in old_unique_together}\n        news = {tuple(fields) for fields in new_unique_together}\n        # Deleted uniques\n        for fields in olds.difference(news):\n            self._delete_composed_index(\n                model,\n                fields,\n                {\"unique\": True, \"primary_key\": False},\n                self.sql_delete_unique,\n                old_model=old_model,\n            )\n        # Created uniques\n        for field_names in news.difference(olds):\n            fields = [model._meta.get_field(field) for field in field_names]\n            self.execute(self._create_unique_sql(model, fields))\n",
      "\n    def alter_unique_together(self, model, old_unique_together, new_unique_together, old_model=None):\n        \"\"\"\n        Deal with a model changing its unique_together. The input\n        unique_togethers must be doubly-nested, not the single-nested\n        [\"foo\", \"bar\"] format.\n        \"\"\"\n        olds = {tuple(fields) for fields in old_unique_together}\n        news = {tuple(fields) for fields in new_unique_together}\n        # Deleted uniques\n        for fields in olds.difference(news):\n            self._delete_composed_index(\n                model,\n                fields,\n                {\"unique\": True, \"primary_key\": False},\n                self.sql_delete_unique,\n                old_model=old_model,\n            )\n        # Created uniques\n        for field_names in news.difference(olds):\n            fields = [model._meta.get_field(field) for field in field_names]\n            self.execute(self._create_unique_sql(model, fields))\n",
      "\n    def alter_unique_together(self, model, old_unique_together, new_unique_together, old_model=None):\n        \"\"\"\n        Deal with a model changing its unique_together. The input\n        unique_togethers must be doubly-nested, not the single-nested\n        [\"foo\", \"bar\"] format.\n        \"\"\"\n        olds = {tuple(fields) for fields in old_unique_together}\n        news = {tuple(fields) for fields in new_unique_together}\n        # Deleted uniques\n        for fields in olds.difference(news):\n            self._delete_composed_index(\n                model,\n                fields,\n                {\"unique\": True, \"primary_key\": False},\n                self.sql_delete_unique,\n                old_model=old_model,\n            )\n        # Created uniques\n        for field_names in news.difference(olds):\n            fields = [model._meta.get_field(field) for field in field_names]\n            self.execute(self._create_unique_sql(model, fields))\n",
      "\n    def alter_unique_together(self, model, old_unique_together, new_unique_together, old_model=None):\n        \"\"\"\n        Deal with a model changing its unique_together. The input\n        unique_togethers must be doubly-nested, not the single-nested\n        [\"foo\", \"bar\"] format.\n        \"\"\"\n        olds = {tuple(fields) for fields in old_unique_together}\n        news = {tuple(fields) for fields in new_unique_together}\n        # Deleted uniques\n        for fields in olds.difference(news):\n            self._delete_composed_index(\n                model,\n                fields,\n                {\"unique\": True, \"primary_key\": False},\n                self.sql_delete_unique,\n                old_model=old_model,\n            )\n        # Created uniques\n        for field_names in news.difference(olds):\n            fields = [model._meta.get_field(field) for field in field_names]\n            self.execute(self._create_unique_sql(model, fields))\n",
      "\ndef alter_unique_together(self, model, old_unique_together, new_unique_together, old_model=None):\n    \"\"\"\n    Deal with a model changing its unique_together. The input\n    unique_togethers must be doubly-nested, not the single-nested\n    [\"foo\", \"bar\"] format.\n    \"\"\"\n    olds = {tuple(fields) for fields in old_unique_together}\n    news = {tuple(fields) for fields in new_unique_together}\n    # Deleted uniques\n    for fields in olds.difference(news):\n        self._delete_composed_index(\n            model,\n            fields,\n            {\"unique\": True, \"primary_key\": False},\n            self.sql_delete_unique,\n            old_model=old_model,\n        )\n    # Created uniques\n    for field_names in news.difference(olds):\n        fields = [model._meta.get_field(field) for field in field_names]\n        self.execute(self._create_unique_sql(model, fields))\n",
      "\n    def alter_unique_together(self, model, old_unique_together, new_unique_together, old_model=None):\n        \"\"\"\n        Deal with a model changing its unique_together. The input\n        unique_togethers must be doubly-nested, not the single-nested\n        [\"foo\", \"bar\"] format.\n        \"\"\"\n        olds = {tuple(fields) for fields in old_unique_together}\n        news = {tuple(fields) for fields in new_unique_together}\n        # Deleted uniques\n        for fields in olds.difference(news):\n            self._delete_composed_index(\n                model,\n                fields,\n                {\"unique\": True, \"primary_key\": False},\n                self.sql_delete_unique,\n                old_model=old_model,\n            )\n        # Created uniques\n        for field_names in news.difference(olds):\n            fields = [model._meta.get_field(field) for field in field_names]\n            self.execute(self._create_unique_sql(model, fields))\n",
      "\n    def alter_unique_together(self, model, old_unique_together, new_unique_together, old_model=None):\n        \"\"\"\n        Deal with a model changing its unique_together. The input\n        unique_togethers must be doubly-nested, not the single-nested\n        [\"foo\", \"bar\"] format.\n        \"\"\"\n        olds = {tuple(fields) for fields in old_unique_together}\n        news = {tuple(fields) for fields in new_unique_together}\n        # Deleted uniques\n        for fields in olds.difference(news):\n            self._delete_composed_index(\n                model,\n                fields,\n                {\"unique\": True, \"primary_key\": False},\n                self.sql_delete_unique,\n                old_model=old_model,\n            )\n        # Created uniques\n        for field_names in news.difference(olds):\n            fields = [model._meta.get_field(field) for field in field_names]\n            self.execute(self._create_unique_sql(model, fields))\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 03f0f11507..c805fef041 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -517,7 +517,8 @@ class BaseDatabaseSchemaEditor:\n         if sql:\n             self.execute(sql)\n \n-    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n+\n+    def alter_unique_together(self, model, old_unique_together, new_unique_together, old_model=None):\n         \"\"\"\n         Deal with a model changing its unique_together. The input\n         unique_togethers must be doubly-nested, not the single-nested\n@@ -532,12 +533,12 @@ class BaseDatabaseSchemaEditor:\n                 fields,\n                 {\"unique\": True, \"primary_key\": False},\n                 self.sql_delete_unique,\n+                old_model,\n             )\n         # Created uniques\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_unique_sql(model, fields))\n-\n     def alter_index_together(self, model, old_index_together, new_index_together):\n         \"\"\"\n         Deal with a model changing its index_together. The input\n@@ -559,12 +560,15 @@ class BaseDatabaseSchemaEditor:\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields=fields, suffix=\"_idx\"))\n \n-    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, old_model=None):\n         meta_constraint_names = {\n             constraint.name for constraint in model._meta.constraints\n         }\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n-        columns = [model._meta.get_field(field).column for field in fields]\n+        # Use old_model for column lookup when deleting constraints to handle field type changes\n+        source_model = old_model if old_model else model\n+        columns = [source_model._meta.get_field(field).column for field in fields]\n         constraint_names = self._constraint_names(\n             model,\n             columns,\ndiff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex 75a3b8b030..da5b07609a 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -557,6 +557,7 @@ class AlterTogetherOptionOperation(ModelOptionOperation):\n             {self.option_name: self.option_value},\n         )\n \n+\n     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n         new_model = to_state.apps.get_model(app_label, self.name)\n         if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n@@ -566,6 +567,7 @@ class AlterTogetherOptionOperation(ModelOptionOperation):\n                 new_model,\n                 getattr(old_model._meta, self.option_name, set()),\n                 getattr(new_model._meta, self.option_name, set()),\n+                old_model,\n             )\n \n     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n",
    "variant_0": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 03f0f11507..eac94974f3 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -517,7 +517,8 @@ class BaseDatabaseSchemaEditor:\n         if sql:\n             self.execute(sql)\n \n-    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n+\n+    def alter_unique_together(self, model, old_unique_together, new_unique_together, old_model=None):\n         \"\"\"\n         Deal with a model changing its unique_together. The input\n         unique_togethers must be doubly-nested, not the single-nested\n@@ -532,12 +533,12 @@ class BaseDatabaseSchemaEditor:\n                 fields,\n                 {\"unique\": True, \"primary_key\": False},\n                 self.sql_delete_unique,\n+                old_model=old_model,\n             )\n         # Created uniques\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_unique_sql(model, fields))\n-\n     def alter_index_together(self, model, old_index_together, new_index_together):\n         \"\"\"\n         Deal with a model changing its index_together. The input\n@@ -559,12 +560,15 @@ class BaseDatabaseSchemaEditor:\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields=fields, suffix=\"_idx\"))\n \n-    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, old_model=None):\n         meta_constraint_names = {\n             constraint.name for constraint in model._meta.constraints\n         }\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n-        columns = [model._meta.get_field(field).column for field in fields]\n+        # Use old_model for column lookup if provided, otherwise use current model\n+        source_model = old_model if old_model else model\n+        columns = [source_model._meta.get_field(field).column for field in fields]\n         constraint_names = self._constraint_names(\n             model,\n             columns,\ndiff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex 75a3b8b030..7af95f9f0c 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -557,6 +557,7 @@ class AlterTogetherOptionOperation(ModelOptionOperation):\n             {self.option_name: self.option_value},\n         )\n \n+\n     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n         new_model = to_state.apps.get_model(app_label, self.name)\n         if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n@@ -566,6 +567,7 @@ class AlterTogetherOptionOperation(ModelOptionOperation):\n                 new_model,\n                 getattr(old_model._meta, self.option_name, set()),\n                 getattr(new_model._meta, self.option_name, set()),\n+                old_model=old_model,\n             )\n \n     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n",
    "variant_1": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 03f0f11507..3606f9cba7 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -517,7 +517,8 @@ class BaseDatabaseSchemaEditor:\n         if sql:\n             self.execute(sql)\n \n-    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n+\n+    def alter_unique_together(self, model, old_unique_together, new_unique_together, old_model=None):\n         \"\"\"\n         Deal with a model changing its unique_together. The input\n         unique_togethers must be doubly-nested, not the single-nested\n@@ -532,12 +533,12 @@ class BaseDatabaseSchemaEditor:\n                 fields,\n                 {\"unique\": True, \"primary_key\": False},\n                 self.sql_delete_unique,\n+                old_model=old_model,\n             )\n         # Created uniques\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_unique_sql(model, fields))\n-\n     def alter_index_together(self, model, old_index_together, new_index_together):\n         \"\"\"\n         Deal with a model changing its index_together. The input\n@@ -559,12 +560,15 @@ class BaseDatabaseSchemaEditor:\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields=fields, suffix=\"_idx\"))\n \n-    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, old_model=None):\n         meta_constraint_names = {\n             constraint.name for constraint in model._meta.constraints\n         }\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n-        columns = [model._meta.get_field(field).column for field in fields]\n+        # Use old_model for column lookup if provided, otherwise use current model\n+        lookup_model = old_model if old_model else model\n+        columns = [lookup_model._meta.get_field(field).column for field in fields]\n         constraint_names = self._constraint_names(\n             model,\n             columns,\ndiff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex 75a3b8b030..da5b07609a 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -557,6 +557,7 @@ class AlterTogetherOptionOperation(ModelOptionOperation):\n             {self.option_name: self.option_value},\n         )\n \n+\n     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n         new_model = to_state.apps.get_model(app_label, self.name)\n         if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n@@ -566,6 +567,7 @@ class AlterTogetherOptionOperation(ModelOptionOperation):\n                 new_model,\n                 getattr(old_model._meta, self.option_name, set()),\n                 getattr(new_model._meta, self.option_name, set()),\n+                old_model,\n             )\n \n     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n",
    "variant_2": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 03f0f11507..6d6c151127 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -517,7 +517,8 @@ class BaseDatabaseSchemaEditor:\n         if sql:\n             self.execute(sql)\n \n-    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n+\n+    def alter_unique_together(self, model, old_unique_together, new_unique_together, old_model=None):\n         \"\"\"\n         Deal with a model changing its unique_together. The input\n         unique_togethers must be doubly-nested, not the single-nested\n@@ -532,12 +533,12 @@ class BaseDatabaseSchemaEditor:\n                 fields,\n                 {\"unique\": True, \"primary_key\": False},\n                 self.sql_delete_unique,\n+                old_model=old_model,\n             )\n         # Created uniques\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_unique_sql(model, fields))\n-\n     def alter_index_together(self, model, old_index_together, new_index_together):\n         \"\"\"\n         Deal with a model changing its index_together. The input\n@@ -559,12 +560,15 @@ class BaseDatabaseSchemaEditor:\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields=fields, suffix=\"_idx\"))\n \n-    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, old_model=None):\n         meta_constraint_names = {\n             constraint.name for constraint in model._meta.constraints\n         }\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n-        columns = [model._meta.get_field(field).column for field in fields]\n+        # Use old_model for column lookup if provided, otherwise use current model\n+        model_for_columns = old_model if old_model else model\n+        columns = [model_for_columns._meta.get_field(field).column for field in fields]\n         constraint_names = self._constraint_names(\n             model,\n             columns,\ndiff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex 75a3b8b030..7af95f9f0c 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -557,6 +557,7 @@ class AlterTogetherOptionOperation(ModelOptionOperation):\n             {self.option_name: self.option_value},\n         )\n \n+\n     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n         new_model = to_state.apps.get_model(app_label, self.name)\n         if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n@@ -566,6 +567,7 @@ class AlterTogetherOptionOperation(ModelOptionOperation):\n                 new_model,\n                 getattr(old_model._meta, self.option_name, set()),\n                 getattr(new_model._meta, self.option_name, set()),\n+                old_model=old_model,\n             )\n \n     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n",
    "variant_3": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 03f0f11507..eac94974f3 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -517,7 +517,8 @@ class BaseDatabaseSchemaEditor:\n         if sql:\n             self.execute(sql)\n \n-    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n+\n+    def alter_unique_together(self, model, old_unique_together, new_unique_together, old_model=None):\n         \"\"\"\n         Deal with a model changing its unique_together. The input\n         unique_togethers must be doubly-nested, not the single-nested\n@@ -532,12 +533,12 @@ class BaseDatabaseSchemaEditor:\n                 fields,\n                 {\"unique\": True, \"primary_key\": False},\n                 self.sql_delete_unique,\n+                old_model=old_model,\n             )\n         # Created uniques\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_unique_sql(model, fields))\n-\n     def alter_index_together(self, model, old_index_together, new_index_together):\n         \"\"\"\n         Deal with a model changing its index_together. The input\n@@ -559,12 +560,15 @@ class BaseDatabaseSchemaEditor:\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields=fields, suffix=\"_idx\"))\n \n-    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, old_model=None):\n         meta_constraint_names = {\n             constraint.name for constraint in model._meta.constraints\n         }\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n-        columns = [model._meta.get_field(field).column for field in fields]\n+        # Use old_model for column lookup if provided, otherwise use current model\n+        source_model = old_model if old_model else model\n+        columns = [source_model._meta.get_field(field).column for field in fields]\n         constraint_names = self._constraint_names(\n             model,\n             columns,\ndiff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex 75a3b8b030..7af95f9f0c 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -557,6 +557,7 @@ class AlterTogetherOptionOperation(ModelOptionOperation):\n             {self.option_name: self.option_value},\n         )\n \n+\n     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n         new_model = to_state.apps.get_model(app_label, self.name)\n         if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n@@ -566,6 +567,7 @@ class AlterTogetherOptionOperation(ModelOptionOperation):\n                 new_model,\n                 getattr(old_model._meta, self.option_name, set()),\n                 getattr(new_model._meta, self.option_name, set()),\n+                old_model=old_model,\n             )\n \n     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n",
    "variant_4": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 03f0f11507..4f640efa06 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -517,7 +517,8 @@ class BaseDatabaseSchemaEditor:\n         if sql:\n             self.execute(sql)\n \n-    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n+\n+    def alter_unique_together(self, model, old_unique_together, new_unique_together, old_model=None):\n         \"\"\"\n         Deal with a model changing its unique_together. The input\n         unique_togethers must be doubly-nested, not the single-nested\n@@ -532,12 +533,12 @@ class BaseDatabaseSchemaEditor:\n                 fields,\n                 {\"unique\": True, \"primary_key\": False},\n                 self.sql_delete_unique,\n+                old_model=old_model,\n             )\n         # Created uniques\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_unique_sql(model, fields))\n-\n     def alter_index_together(self, model, old_index_together, new_index_together):\n         \"\"\"\n         Deal with a model changing its index_together. The input\n@@ -559,12 +560,17 @@ class BaseDatabaseSchemaEditor:\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields=fields, suffix=\"_idx\"))\n \n-    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, old_model=None):\n         meta_constraint_names = {\n             constraint.name for constraint in model._meta.constraints\n         }\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n-        columns = [model._meta.get_field(field).column for field in fields]\n+        # Use old_model for column lookup if provided, otherwise use current model\n+        if old_model:\n+            columns = [old_model._meta.get_field(field).column for field in fields]\n+        else:\n+            columns = [model._meta.get_field(field).column for field in fields]\n         constraint_names = self._constraint_names(\n             model,\n             columns,\ndiff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex 75a3b8b030..da5b07609a 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -557,6 +557,7 @@ class AlterTogetherOptionOperation(ModelOptionOperation):\n             {self.option_name: self.option_value},\n         )\n \n+\n     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n         new_model = to_state.apps.get_model(app_label, self.name)\n         if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n@@ -566,6 +567,7 @@ class AlterTogetherOptionOperation(ModelOptionOperation):\n                 new_model,\n                 getattr(old_model._meta, self.option_name, set()),\n                 getattr(new_model._meta, self.option_name, set()),\n+                old_model,\n             )\n \n     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n",
    "variant_5": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 03f0f11507..6d6c151127 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -517,7 +517,8 @@ class BaseDatabaseSchemaEditor:\n         if sql:\n             self.execute(sql)\n \n-    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n+\n+    def alter_unique_together(self, model, old_unique_together, new_unique_together, old_model=None):\n         \"\"\"\n         Deal with a model changing its unique_together. The input\n         unique_togethers must be doubly-nested, not the single-nested\n@@ -532,12 +533,12 @@ class BaseDatabaseSchemaEditor:\n                 fields,\n                 {\"unique\": True, \"primary_key\": False},\n                 self.sql_delete_unique,\n+                old_model=old_model,\n             )\n         # Created uniques\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_unique_sql(model, fields))\n-\n     def alter_index_together(self, model, old_index_together, new_index_together):\n         \"\"\"\n         Deal with a model changing its index_together. The input\n@@ -559,12 +560,15 @@ class BaseDatabaseSchemaEditor:\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields=fields, suffix=\"_idx\"))\n \n-    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, old_model=None):\n         meta_constraint_names = {\n             constraint.name for constraint in model._meta.constraints\n         }\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n-        columns = [model._meta.get_field(field).column for field in fields]\n+        # Use old_model for column lookup if provided, otherwise use current model\n+        model_for_columns = old_model if old_model else model\n+        columns = [model_for_columns._meta.get_field(field).column for field in fields]\n         constraint_names = self._constraint_names(\n             model,\n             columns,\ndiff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex 75a3b8b030..da5b07609a 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -557,6 +557,7 @@ class AlterTogetherOptionOperation(ModelOptionOperation):\n             {self.option_name: self.option_value},\n         )\n \n+\n     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n         new_model = to_state.apps.get_model(app_label, self.name)\n         if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n@@ -566,6 +567,7 @@ class AlterTogetherOptionOperation(ModelOptionOperation):\n                 new_model,\n                 getattr(old_model._meta, self.option_name, set()),\n                 getattr(new_model._meta, self.option_name, set()),\n+                old_model,\n             )\n \n     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n",
    "variant_6": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 03f0f11507..e8d12b1b91 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -517,27 +517,28 @@ class BaseDatabaseSchemaEditor:\n         if sql:\n             self.execute(sql)\n \n-    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n-        \"\"\"\n-        Deal with a model changing its unique_together. The input\n-        unique_togethers must be doubly-nested, not the single-nested\n-        [\"foo\", \"bar\"] format.\n-        \"\"\"\n-        olds = {tuple(fields) for fields in old_unique_together}\n-        news = {tuple(fields) for fields in new_unique_together}\n-        # Deleted uniques\n-        for fields in olds.difference(news):\n-            self._delete_composed_index(\n-                model,\n-                fields,\n-                {\"unique\": True, \"primary_key\": False},\n-                self.sql_delete_unique,\n-            )\n-        # Created uniques\n-        for field_names in news.difference(olds):\n-            fields = [model._meta.get_field(field) for field in field_names]\n-            self.execute(self._create_unique_sql(model, fields))\n \n+def alter_unique_together(self, model, old_unique_together, new_unique_together, old_model=None):\n+    \"\"\"\n+    Deal with a model changing its unique_together. The input\n+    unique_togethers must be doubly-nested, not the single-nested\n+    [\"foo\", \"bar\"] format.\n+    \"\"\"\n+    olds = {tuple(fields) for fields in old_unique_together}\n+    news = {tuple(fields) for fields in new_unique_together}\n+    # Deleted uniques\n+    for fields in olds.difference(news):\n+        self._delete_composed_index(\n+            model,\n+            fields,\n+            {\"unique\": True, \"primary_key\": False},\n+            self.sql_delete_unique,\n+            old_model=old_model,\n+        )\n+    # Created uniques\n+    for field_names in news.difference(olds):\n+        fields = [model._meta.get_field(field) for field in field_names]\n+        self.execute(self._create_unique_sql(model, fields))\n     def alter_index_together(self, model, old_index_together, new_index_together):\n         \"\"\"\n         Deal with a model changing its index_together. The input\n@@ -559,12 +560,15 @@ class BaseDatabaseSchemaEditor:\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields=fields, suffix=\"_idx\"))\n \n-    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, old_model=None):\n         meta_constraint_names = {\n             constraint.name for constraint in model._meta.constraints\n         }\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n-        columns = [model._meta.get_field(field).column for field in fields]\n+        # Use old_model for column lookup when deleting constraints to handle field type changes\n+        source_model = old_model if old_model else model\n+        columns = [source_model._meta.get_field(field).column for field in fields]\n         constraint_names = self._constraint_names(\n             model,\n             columns,\ndiff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex 75a3b8b030..7af95f9f0c 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -557,6 +557,7 @@ class AlterTogetherOptionOperation(ModelOptionOperation):\n             {self.option_name: self.option_value},\n         )\n \n+\n     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n         new_model = to_state.apps.get_model(app_label, self.name)\n         if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n@@ -566,6 +567,7 @@ class AlterTogetherOptionOperation(ModelOptionOperation):\n                 new_model,\n                 getattr(old_model._meta, self.option_name, set()),\n                 getattr(new_model._meta, self.option_name, set()),\n+                old_model=old_model,\n             )\n \n     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n",
    "variant_7": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 03f0f11507..3606f9cba7 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -517,7 +517,8 @@ class BaseDatabaseSchemaEditor:\n         if sql:\n             self.execute(sql)\n \n-    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n+\n+    def alter_unique_together(self, model, old_unique_together, new_unique_together, old_model=None):\n         \"\"\"\n         Deal with a model changing its unique_together. The input\n         unique_togethers must be doubly-nested, not the single-nested\n@@ -532,12 +533,12 @@ class BaseDatabaseSchemaEditor:\n                 fields,\n                 {\"unique\": True, \"primary_key\": False},\n                 self.sql_delete_unique,\n+                old_model=old_model,\n             )\n         # Created uniques\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_unique_sql(model, fields))\n-\n     def alter_index_together(self, model, old_index_together, new_index_together):\n         \"\"\"\n         Deal with a model changing its index_together. The input\n@@ -559,12 +560,15 @@ class BaseDatabaseSchemaEditor:\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields=fields, suffix=\"_idx\"))\n \n-    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, old_model=None):\n         meta_constraint_names = {\n             constraint.name for constraint in model._meta.constraints\n         }\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n-        columns = [model._meta.get_field(field).column for field in fields]\n+        # Use old_model for column lookup if provided, otherwise use current model\n+        lookup_model = old_model if old_model else model\n+        columns = [lookup_model._meta.get_field(field).column for field in fields]\n         constraint_names = self._constraint_names(\n             model,\n             columns,\ndiff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex 75a3b8b030..7af95f9f0c 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -557,6 +557,7 @@ class AlterTogetherOptionOperation(ModelOptionOperation):\n             {self.option_name: self.option_value},\n         )\n \n+\n     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n         new_model = to_state.apps.get_model(app_label, self.name)\n         if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n@@ -566,6 +567,7 @@ class AlterTogetherOptionOperation(ModelOptionOperation):\n                 new_model,\n                 getattr(old_model._meta, self.option_name, set()),\n                 getattr(new_model._meta, self.option_name, set()),\n+                old_model=old_model,\n             )\n \n     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n",
    "variant_8": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 03f0f11507..3606f9cba7 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -517,7 +517,8 @@ class BaseDatabaseSchemaEditor:\n         if sql:\n             self.execute(sql)\n \n-    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n+\n+    def alter_unique_together(self, model, old_unique_together, new_unique_together, old_model=None):\n         \"\"\"\n         Deal with a model changing its unique_together. The input\n         unique_togethers must be doubly-nested, not the single-nested\n@@ -532,12 +533,12 @@ class BaseDatabaseSchemaEditor:\n                 fields,\n                 {\"unique\": True, \"primary_key\": False},\n                 self.sql_delete_unique,\n+                old_model=old_model,\n             )\n         # Created uniques\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_unique_sql(model, fields))\n-\n     def alter_index_together(self, model, old_index_together, new_index_together):\n         \"\"\"\n         Deal with a model changing its index_together. The input\n@@ -559,12 +560,15 @@ class BaseDatabaseSchemaEditor:\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields=fields, suffix=\"_idx\"))\n \n-    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, old_model=None):\n         meta_constraint_names = {\n             constraint.name for constraint in model._meta.constraints\n         }\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n-        columns = [model._meta.get_field(field).column for field in fields]\n+        # Use old_model for column lookup if provided, otherwise use current model\n+        lookup_model = old_model if old_model else model\n+        columns = [lookup_model._meta.get_field(field).column for field in fields]\n         constraint_names = self._constraint_names(\n             model,\n             columns,\ndiff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex 75a3b8b030..7af95f9f0c 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -557,6 +557,7 @@ class AlterTogetherOptionOperation(ModelOptionOperation):\n             {self.option_name: self.option_value},\n         )\n \n+\n     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n         new_model = to_state.apps.get_model(app_label, self.name)\n         if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n@@ -566,6 +567,7 @@ class AlterTogetherOptionOperation(ModelOptionOperation):\n                 new_model,\n                 getattr(old_model._meta, self.option_name, set()),\n                 getattr(new_model._meta, self.option_name, set()),\n+                old_model=old_model,\n             )\n \n     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n"
  }
}