{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/matplotlib/lib/matplotlib/colors.py lines 727-732)": "\n        if xa.dtype.kind == \"f\":\n            with np.errstate(invalid=\"ignore\"):\n                xa *= self.N\n                # Negative values are out of range, but astype(int) would\n                # truncate them towards zero.\n                xa[xa < 0] = -1\n                # xa == 1 (== N after multiplication) is not out of range.\n                xa[xa == self.N] = self.N - 1\n                # Avoid converting large positive values to negative integers.\n                np.clip(xa, -1, self.N, out=xa)\n                xa = xa.astype(int)\n        # Ensure xa can hold special index values for integer arrays\n        elif xa.dtype.kind in \"ui\":\n            if xa.dtype.itemsize < np.dtype(int).itemsize or not np.can_cast(self._i_bad, xa.dtype):\n                xa = xa.astype(int)\n        # Set the over-range indices before the under-range;\n        # otherwise the under-range values get converted to over-range.\n        xa[xa > self.N - 1] = self._i_over\n        xa[xa < 0] = self._i_under\n        xa[mask_bad] = self._i_bad\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/matplotlib/lib/matplotlib/colors.py lines 727-732)": [
      "\n        if xa.dtype.kind == \"f\":\n            with np.errstate(invalid=\"ignore\"):\n                xa *= self.N\n                # Negative values are out of range, but astype(int) would\n                # truncate them towards zero.\n                xa[xa < 0] = -1\n                # xa == 1 (== N after multiplication) is not out of range.\n                xa[xa == self.N] = self.N - 1\n                # Avoid converting large positive values to negative integers.\n                np.clip(xa, -1, self.N, out=xa)\n                xa = xa.astype(int)\n        # Ensure xa can hold special index values for integer arrays\n        if xa.dtype.kind in \"ui\" and not np.can_cast(self._i_bad, xa.dtype):\n            xa = xa.astype(int)\n        # Set the over-range indices before the under-range;\n        # otherwise the under-range values get converted to over-range.\n        xa[xa > self.N - 1] = self._i_over\n        xa[xa < 0] = self._i_under\n        xa[mask_bad] = self._i_bad\n",
      "\n        if xa.dtype.kind == \"f\":\n            with np.errstate(invalid=\"ignore\"):\n                xa *= self.N\n                # Negative values are out of range, but astype(int) would\n                # truncate them towards zero.\n                xa[xa < 0] = -1\n                # xa == 1 (== N after multiplication) is not out of range.\n                xa[xa == self.N] = self.N - 1\n                # Avoid converting large positive values to negative integers.\n                np.clip(xa, -1, self.N, out=xa)\n                xa = xa.astype(int)\n        # Ensure xa can hold special index values for all integer types\n        if xa.dtype.kind in \"ui\" and not np.can_cast(self._i_bad, xa.dtype):\n            xa = xa.astype(int)\n        # Set the over-range indices before the under-range;\n        # otherwise the under-range values get converted to over-range.\n        xa[xa > self.N - 1] = self._i_over\n        xa[xa < 0] = self._i_under\n        xa[mask_bad] = self._i_bad\n",
      "\n        if xa.dtype.kind == \"f\":\n            with np.errstate(invalid=\"ignore\"):\n                xa *= self.N\n                # Negative values are out of range, but astype(int) would\n                # truncate them towards zero.\n                xa[xa < 0] = -1\n                # xa == 1 (== N after multiplication) is not out of range.\n                xa[xa == self.N] = self.N - 1\n                # Avoid converting large positive values to negative integers.\n                np.clip(xa, -1, self.N, out=xa)\n                xa = xa.astype(int)\n        # Ensure xa can hold special index values for integer arrays\n        elif xa.dtype.kind in \"iu\" and not np.can_cast(self._i_bad, xa.dtype):\n            xa = xa.astype(int)\n        # Set the over-range indices before the under-range;\n        # otherwise the under-range values get converted to over-range.\n        xa[xa > self.N - 1] = self._i_over\n        xa[xa < 0] = self._i_under\n        xa[mask_bad] = self._i_bad\n",
      "\n        if xa.dtype.kind == \"f\":\n            with np.errstate(invalid=\"ignore\"):\n                xa *= self.N\n                # Negative values are out of range, but astype(int) would\n                # truncate them towards zero.\n                xa[xa < 0] = -1\n                # xa == 1 (== N after multiplication) is not out of range.\n                xa[xa == self.N] = self.N - 1\n                # Avoid converting large positive values to negative integers.\n                np.clip(xa, -1, self.N, out=xa)\n                xa = xa.astype(int)\n        # Ensure xa can hold special index values for integer arrays\n        if xa.dtype.kind in \"ui\" and (xa.dtype.itemsize < np.dtype(int).itemsize or not np.can_cast(self._i_bad, xa.dtype)):\n            xa = xa.astype(int)\n        # Set the over-range indices before the under-range;\n        # otherwise the under-range values get converted to over-range.\n        xa[xa > self.N - 1] = self._i_over\n        xa[xa < 0] = self._i_under\n        xa[mask_bad] = self._i_bad\n",
      "\n        if xa.dtype.kind == \"f\":\n            with np.errstate(invalid=\"ignore\"):\n                xa *= self.N\n                # Negative values are out of range, but astype(int) would\n                # truncate them towards zero.\n                xa[xa < 0] = -1\n                # xa == 1 (== N after multiplication) is not out of range.\n                xa[xa == self.N] = self.N - 1\n                # Avoid converting large positive values to negative integers.\n                np.clip(xa, -1, self.N, out=xa)\n                xa = xa.astype(int)\n        \n        # Ensure xa can hold special index values for integer arrays\n        if xa.dtype.kind in \"ui\" and (xa.dtype.itemsize < np.dtype(int).itemsize or \n                                      not np.can_cast(self._i_bad, xa.dtype)):\n            xa = xa.astype(int)\n            \n        # Set the over-range indices before the under-range;\n        # otherwise the under-range values get converted to over-range.\n        xa[xa > self.N - 1] = self._i_over\n        xa[xa < 0] = self._i_under\n        xa[mask_bad] = self._i_bad\n",
      "\n        if xa.dtype.kind == \"f\":\n            with np.errstate(invalid=\"ignore\"):\n                xa *= self.N\n                # Negative values are out of range, but astype(int) would\n                # truncate them towards zero.\n                xa[xa < 0] = -1\n                # xa == 1 (== N after multiplication) is not out of range.\n                xa[xa == self.N] = self.N - 1\n                # Avoid converting large positive values to negative integers.\n                np.clip(xa, -1, self.N, out=xa)\n                xa = xa.astype(int)\n        # Ensure xa can hold special index values for all integer types\n        if xa.dtype.kind == \"i\" and (xa.dtype.itemsize < np.dtype(int).itemsize or not np.can_cast(self._i_bad, xa.dtype)):\n            xa = xa.astype(int)\n        # Set the over-range indices before the under-range;\n        # otherwise the under-range values get converted to over-range.\n        xa[xa > self.N - 1] = self._i_over\n        xa[xa < 0] = self._i_under\n        xa[mask_bad] = self._i_bad\n",
      "\n        if xa.dtype.kind == \"f\":\n            with np.errstate(invalid=\"ignore\"):\n                xa *= self.N\n                # Negative values are out of range, but astype(int) would\n                # truncate them towards zero.\n                xa[xa < 0] = -1\n                # xa == 1 (== N after multiplication) is not out of range.\n                xa[xa == self.N] = self.N - 1\n                # Avoid converting large positive values to negative integers.\n                np.clip(xa, -1, self.N, out=xa)\n                xa = xa.astype(int)\n        # Ensure xa can hold special index values for integer arrays\n        if xa.dtype.kind == \"i\" and (xa.dtype.itemsize < np.dtype(int).itemsize or not np.can_cast(self._i_bad, xa.dtype)):\n            xa = xa.astype(int)\n        # Set the over-range indices before the under-range;\n        # otherwise the under-range values get converted to over-range.\n        xa[xa > self.N - 1] = self._i_over\n        xa[xa < 0] = self._i_under\n        xa[mask_bad] = self._i_bad\n",
      "\n        if xa.dtype.kind == \"f\":\n            with np.errstate(invalid=\"ignore\"):\n                xa *= self.N\n                # Negative values are out of range, but astype(int) would\n                # truncate them towards zero.\n                xa[xa < 0] = -1\n                # xa == 1 (== N after multiplication) is not out of range.\n                xa[xa == self.N] = self.N - 1\n                # Avoid converting large positive values to negative integers.\n                np.clip(xa, -1, self.N, out=xa)\n                xa = xa.astype(int)\n        \n        # Ensure xa can hold special index values for integer arrays\n        if xa.dtype.kind in \"ui\" and (xa.dtype.itemsize < np.dtype(int).itemsize or \n                                      not np.can_cast(self._i_bad, xa.dtype)):\n            xa = xa.astype(int)\n            \n        # Set the over-range indices before the under-range;\n        # otherwise the under-range values get converted to over-range.\n        xa[xa > self.N - 1] = self._i_over\n        xa[xa < 0] = self._i_under\n        xa[mask_bad] = self._i_bad\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2d3072da04..e35d8c0ed3 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -724,6 +724,12 @@ class Colormap:\n                 xa[xa == self.N] = self.N - 1\n                 # Avoid converting large positive values to negative integers.\n                 np.clip(xa, -1, self.N, out=xa)\n+\n+                xa = xa.astype(int)\n+        # Ensure xa can hold special index values for integer arrays\n+        elif xa.dtype.kind in \"ui\":  # unsigned or signed integer\n+            # Check if xa can hold the special index values (self._i_bad = self.N + 2)\n+            if not np.can_cast(self._i_bad, xa.dtype):\n                 xa = xa.astype(int)\n         # Set the over-range indices before the under-range;\n         # otherwise the under-range values get converted to over-range.\n",
    "variant_0": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2d3072da04..0e543800e5 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -724,6 +724,21 @@ class Colormap:\n                 xa[xa == self.N] = self.N - 1\n                 # Avoid converting large positive values to negative integers.\n                 np.clip(xa, -1, self.N, out=xa)\n+\n+        if xa.dtype.kind == \"f\":\n+            with np.errstate(invalid=\"ignore\"):\n+                xa *= self.N\n+                # Negative values are out of range, but astype(int) would\n+                # truncate them towards zero.\n+                xa[xa < 0] = -1\n+                # xa == 1 (== N after multiplication) is not out of range.\n+                xa[xa == self.N] = self.N - 1\n+                # Avoid converting large positive values to negative integers.\n+                np.clip(xa, -1, self.N, out=xa)\n+                xa = xa.astype(int)\n+        # Ensure xa can hold special index values for integer arrays\n+        elif xa.dtype.kind in \"ui\":\n+            if xa.dtype.itemsize < np.dtype(int).itemsize or not np.can_cast(self._i_bad, xa.dtype):\n                 xa = xa.astype(int)\n         # Set the over-range indices before the under-range;\n         # otherwise the under-range values get converted to over-range.\n",
    "variant_1": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2d3072da04..d4823dde11 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -714,6 +714,17 @@ class Colormap:\n             mask_bad = np.isnan(xa)\n         if not xa.dtype.isnative:\n             xa = xa.byteswap().newbyteorder()  # Native byteorder is faster.\n+        if xa.dtype.kind == \"f\":\n+            with np.errstate(invalid=\"ignore\"):\n+                xa *= self.N\n+                # Negative values are out of range, but astype(int) would\n+                # truncate them towards zero.\n+                xa[xa < 0] = -1\n+                # xa == 1 (== N after multiplication) is not out of range.\n+                xa[xa == self.N] = self.N - 1\n+                # Avoid converting large positive values to negative integers.\n+                np.clip(xa, -1, self.N, out=xa)\n+\n         if xa.dtype.kind == \"f\":\n             with np.errstate(invalid=\"ignore\"):\n                 xa *= self.N\n@@ -725,6 +736,9 @@ class Colormap:\n                 # Avoid converting large positive values to negative integers.\n                 np.clip(xa, -1, self.N, out=xa)\n                 xa = xa.astype(int)\n+        # Ensure xa can hold special index values for integer arrays\n+        if xa.dtype.kind in \"ui\" and not np.can_cast(self._i_bad, xa.dtype):\n+            xa = xa.astype(int)\n         # Set the over-range indices before the under-range;\n         # otherwise the under-range values get converted to over-range.\n         xa[xa > self.N - 1] = self._i_over\n",
    "variant_2": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2d3072da04..343f94e650 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -714,6 +714,17 @@ class Colormap:\n             mask_bad = np.isnan(xa)\n         if not xa.dtype.isnative:\n             xa = xa.byteswap().newbyteorder()  # Native byteorder is faster.\n+        if xa.dtype.kind == \"f\":\n+            with np.errstate(invalid=\"ignore\"):\n+                xa *= self.N\n+                # Negative values are out of range, but astype(int) would\n+                # truncate them towards zero.\n+                xa[xa < 0] = -1\n+                # xa == 1 (== N after multiplication) is not out of range.\n+                xa[xa == self.N] = self.N - 1\n+                # Avoid converting large positive values to negative integers.\n+                np.clip(xa, -1, self.N, out=xa)\n+\n         if xa.dtype.kind == \"f\":\n             with np.errstate(invalid=\"ignore\"):\n                 xa *= self.N\n@@ -725,6 +736,9 @@ class Colormap:\n                 # Avoid converting large positive values to negative integers.\n                 np.clip(xa, -1, self.N, out=xa)\n                 xa = xa.astype(int)\n+        # Ensure xa can hold special index values for all integer types\n+        if xa.dtype.kind in \"ui\" and not np.can_cast(self._i_bad, xa.dtype):\n+            xa = xa.astype(int)\n         # Set the over-range indices before the under-range;\n         # otherwise the under-range values get converted to over-range.\n         xa[xa > self.N - 1] = self._i_over\n",
    "variant_3": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2d3072da04..7246658bbd 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -714,6 +714,17 @@ class Colormap:\n             mask_bad = np.isnan(xa)\n         if not xa.dtype.isnative:\n             xa = xa.byteswap().newbyteorder()  # Native byteorder is faster.\n+        if xa.dtype.kind == \"f\":\n+            with np.errstate(invalid=\"ignore\"):\n+                xa *= self.N\n+                # Negative values are out of range, but astype(int) would\n+                # truncate them towards zero.\n+                xa[xa < 0] = -1\n+                # xa == 1 (== N after multiplication) is not out of range.\n+                xa[xa == self.N] = self.N - 1\n+                # Avoid converting large positive values to negative integers.\n+                np.clip(xa, -1, self.N, out=xa)\n+\n         if xa.dtype.kind == \"f\":\n             with np.errstate(invalid=\"ignore\"):\n                 xa *= self.N\n@@ -725,6 +736,9 @@ class Colormap:\n                 # Avoid converting large positive values to negative integers.\n                 np.clip(xa, -1, self.N, out=xa)\n                 xa = xa.astype(int)\n+        # Ensure xa can hold special index values for integer arrays\n+        elif xa.dtype.kind in \"iu\" and not np.can_cast(self._i_bad, xa.dtype):\n+            xa = xa.astype(int)\n         # Set the over-range indices before the under-range;\n         # otherwise the under-range values get converted to over-range.\n         xa[xa > self.N - 1] = self._i_over\n",
    "variant_4": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2d3072da04..23f3f7f909 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -714,6 +714,17 @@ class Colormap:\n             mask_bad = np.isnan(xa)\n         if not xa.dtype.isnative:\n             xa = xa.byteswap().newbyteorder()  # Native byteorder is faster.\n+        if xa.dtype.kind == \"f\":\n+            with np.errstate(invalid=\"ignore\"):\n+                xa *= self.N\n+                # Negative values are out of range, but astype(int) would\n+                # truncate them towards zero.\n+                xa[xa < 0] = -1\n+                # xa == 1 (== N after multiplication) is not out of range.\n+                xa[xa == self.N] = self.N - 1\n+                # Avoid converting large positive values to negative integers.\n+                np.clip(xa, -1, self.N, out=xa)\n+\n         if xa.dtype.kind == \"f\":\n             with np.errstate(invalid=\"ignore\"):\n                 xa *= self.N\n@@ -725,6 +736,9 @@ class Colormap:\n                 # Avoid converting large positive values to negative integers.\n                 np.clip(xa, -1, self.N, out=xa)\n                 xa = xa.astype(int)\n+        # Ensure xa can hold special index values for integer arrays\n+        if xa.dtype.kind in \"ui\" and (xa.dtype.itemsize < np.dtype(int).itemsize or not np.can_cast(self._i_bad, xa.dtype)):\n+            xa = xa.astype(int)\n         # Set the over-range indices before the under-range;\n         # otherwise the under-range values get converted to over-range.\n         xa[xa > self.N - 1] = self._i_over\n",
    "variant_5": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2d3072da04..f33d854128 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -714,6 +714,17 @@ class Colormap:\n             mask_bad = np.isnan(xa)\n         if not xa.dtype.isnative:\n             xa = xa.byteswap().newbyteorder()  # Native byteorder is faster.\n+        if xa.dtype.kind == \"f\":\n+            with np.errstate(invalid=\"ignore\"):\n+                xa *= self.N\n+                # Negative values are out of range, but astype(int) would\n+                # truncate them towards zero.\n+                xa[xa < 0] = -1\n+                # xa == 1 (== N after multiplication) is not out of range.\n+                xa[xa == self.N] = self.N - 1\n+                # Avoid converting large positive values to negative integers.\n+                np.clip(xa, -1, self.N, out=xa)\n+\n         if xa.dtype.kind == \"f\":\n             with np.errstate(invalid=\"ignore\"):\n                 xa *= self.N\n@@ -725,6 +736,12 @@ class Colormap:\n                 # Avoid converting large positive values to negative integers.\n                 np.clip(xa, -1, self.N, out=xa)\n                 xa = xa.astype(int)\n+        \n+        # Ensure xa can hold special index values for integer arrays\n+        if xa.dtype.kind in \"ui\" and (xa.dtype.itemsize < np.dtype(int).itemsize or \n+                                      not np.can_cast(self._i_bad, xa.dtype)):\n+            xa = xa.astype(int)\n+            \n         # Set the over-range indices before the under-range;\n         # otherwise the under-range values get converted to over-range.\n         xa[xa > self.N - 1] = self._i_over\n",
    "variant_6": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2d3072da04..cb1921b2e8 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -714,6 +714,17 @@ class Colormap:\n             mask_bad = np.isnan(xa)\n         if not xa.dtype.isnative:\n             xa = xa.byteswap().newbyteorder()  # Native byteorder is faster.\n+        if xa.dtype.kind == \"f\":\n+            with np.errstate(invalid=\"ignore\"):\n+                xa *= self.N\n+                # Negative values are out of range, but astype(int) would\n+                # truncate them towards zero.\n+                xa[xa < 0] = -1\n+                # xa == 1 (== N after multiplication) is not out of range.\n+                xa[xa == self.N] = self.N - 1\n+                # Avoid converting large positive values to negative integers.\n+                np.clip(xa, -1, self.N, out=xa)\n+\n         if xa.dtype.kind == \"f\":\n             with np.errstate(invalid=\"ignore\"):\n                 xa *= self.N\n@@ -725,6 +736,9 @@ class Colormap:\n                 # Avoid converting large positive values to negative integers.\n                 np.clip(xa, -1, self.N, out=xa)\n                 xa = xa.astype(int)\n+        # Ensure xa can hold special index values for all integer types\n+        if xa.dtype.kind == \"i\" and (xa.dtype.itemsize < np.dtype(int).itemsize or not np.can_cast(self._i_bad, xa.dtype)):\n+            xa = xa.astype(int)\n         # Set the over-range indices before the under-range;\n         # otherwise the under-range values get converted to over-range.\n         xa[xa > self.N - 1] = self._i_over\n",
    "variant_7": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2d3072da04..f37a82fad8 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -714,6 +714,17 @@ class Colormap:\n             mask_bad = np.isnan(xa)\n         if not xa.dtype.isnative:\n             xa = xa.byteswap().newbyteorder()  # Native byteorder is faster.\n+        if xa.dtype.kind == \"f\":\n+            with np.errstate(invalid=\"ignore\"):\n+                xa *= self.N\n+                # Negative values are out of range, but astype(int) would\n+                # truncate them towards zero.\n+                xa[xa < 0] = -1\n+                # xa == 1 (== N after multiplication) is not out of range.\n+                xa[xa == self.N] = self.N - 1\n+                # Avoid converting large positive values to negative integers.\n+                np.clip(xa, -1, self.N, out=xa)\n+\n         if xa.dtype.kind == \"f\":\n             with np.errstate(invalid=\"ignore\"):\n                 xa *= self.N\n@@ -725,6 +736,9 @@ class Colormap:\n                 # Avoid converting large positive values to negative integers.\n                 np.clip(xa, -1, self.N, out=xa)\n                 xa = xa.astype(int)\n+        # Ensure xa can hold special index values for integer arrays\n+        if xa.dtype.kind == \"i\" and (xa.dtype.itemsize < np.dtype(int).itemsize or not np.can_cast(self._i_bad, xa.dtype)):\n+            xa = xa.astype(int)\n         # Set the over-range indices before the under-range;\n         # otherwise the under-range values get converted to over-range.\n         xa[xa > self.N - 1] = self._i_over\n",
    "variant_8": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2d3072da04..f33d854128 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -714,6 +714,17 @@ class Colormap:\n             mask_bad = np.isnan(xa)\n         if not xa.dtype.isnative:\n             xa = xa.byteswap().newbyteorder()  # Native byteorder is faster.\n+        if xa.dtype.kind == \"f\":\n+            with np.errstate(invalid=\"ignore\"):\n+                xa *= self.N\n+                # Negative values are out of range, but astype(int) would\n+                # truncate them towards zero.\n+                xa[xa < 0] = -1\n+                # xa == 1 (== N after multiplication) is not out of range.\n+                xa[xa == self.N] = self.N - 1\n+                # Avoid converting large positive values to negative integers.\n+                np.clip(xa, -1, self.N, out=xa)\n+\n         if xa.dtype.kind == \"f\":\n             with np.errstate(invalid=\"ignore\"):\n                 xa *= self.N\n@@ -725,6 +736,12 @@ class Colormap:\n                 # Avoid converting large positive values to negative integers.\n                 np.clip(xa, -1, self.N, out=xa)\n                 xa = xa.astype(int)\n+        \n+        # Ensure xa can hold special index values for integer arrays\n+        if xa.dtype.kind in \"ui\" and (xa.dtype.itemsize < np.dtype(int).itemsize or \n+                                      not np.can_cast(self._i_bad, xa.dtype)):\n+            xa = xa.astype(int)\n+            \n         # Set the over-range indices before the under-range;\n         # otherwise the under-range values get converted to over-range.\n         xa[xa > self.N - 1] = self._i_over\n"
  }
}