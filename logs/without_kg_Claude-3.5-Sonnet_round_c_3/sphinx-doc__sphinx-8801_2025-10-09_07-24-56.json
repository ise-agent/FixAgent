{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/sphinx/sphinx/ext/autodoc/__init__.py lines 761-770)": "\n            elif (namespace, membername) in attr_docs:\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep documented attributes\n                    keep = True\n                isattr = True\n            elif self._has_inherited_attr_doc(membername, attr_docs):\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep inherited documented attributes\n                    keep = True\n                isattr = True\n",
    "Location 2 (/root/hy/projects_3/sphinx/sphinx/ext/autodoc/__init__.py lines 697-703)": "\ndef find_inherited_attr_doc(self, membername: str, attr_docs: Dict[Tuple[str, str], List[str]]) -> bool:\n    \"\"\"Check if an annotation-only member has documentation in any superclass.\"\"\"\n    if not self.objpath:\n        return False\n    \n    # Check current class first\n    current_namespace = '.'.join(self.objpath)\n    if (current_namespace, membername) in attr_docs:\n        return True\n    \n    # Check superclasses for annotation-only documentation\n    try:\n        cls = self.object\n        if inspect.isclass(cls):\n            for base in inspect.getmro(cls)[1:]:  # Skip the class itself\n                base_module = getattr(base, '__module__', None)\n                base_qualname = getattr(base, '__qualname__', None)\n                if base_module and base_qualname:\n                    base_namespace = f\"{base_module}.{base_qualname}\"\n                    if (base_namespace, membername) in attr_docs:\n                        return True\n    except (AttributeError, TypeError):\n        pass\n    \n    return False\n\n# search for members in source code too\nnamespace = '.'.join(self.objpath)  # will be empty for modules\n\nif self.analyzer:\n    attr_docs = self.analyzer.find_attr_docs()\nelse:\n    attr_docs = {}\n",
    "Location 3 (/root/hy/projects_3/sphinx/sphinx/ext/autodoc/__init__.py lines 785-787)": "\n                else:\n                    # ignore undocumented members if :undoc-members: is not given\n                    # but first check if this member has inherited annotation-only documentation\n                    inherited_doc = False\n                    if not has_doc and self.options.inherited_members:\n                        # Check for annotation-only documentation in superclasses\n                        for base_class in inspect.getmro(self.object)[1:]:\n                            base_namespace = '.'.join([base_class.__module__, base_class.__qualname__])\n                            if (base_namespace, membername) in attr_docs:\n                                inherited_doc = True\n                                break\n                    keep = has_doc or inherited_doc or self.options.undoc_members\n",
    "Location 4 (/root/hy/projects_3/sphinx/sphinx/ext/autodoc/__init__.py lines 679-692)": "\n        def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n            if inspect.isclass(self.object):\n                for cls in self.object.__mro__:\n                    if cls.__name__ == self.options.inherited_members and cls != self.object:\n                        # given member is a member of specified *super class*\n                        return True\n                    elif name in cls.__dict__:\n                        return False\n                    elif name in self.get_attr(cls, '__annotations__', {}):\n                        return False\n                    elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n                        return False\n\n            return False\n\n        def find_inherited_attr_doc(name: str) -> bool:\n            \"\"\"Check if an annotation-only member has documentation in any superclass.\"\"\"\n            if inspect.isclass(self.object):\n                for cls in self.object.__mro__[1:]:  # Skip self.object, check superclasses\n                    cls_namespace = '.'.join(self.objpath[:-1] + [cls.__name__]) if self.objpath else cls.__name__\n                    if (cls_namespace, name) in attr_docs:\n                        return True\n            return False\n",
    "Location 5 (/root/hy/projects_3/sphinx/sphinx/ext/autodoc/__init__.py lines 727-731)": "\n            if isinstance(obj, ObjectMember) and obj.docstring:\n                # hack for ClassDocumenter to inject docstring via ObjectMember\n                doc = obj.docstring\n            elif not doc and hasattr(self, 'analyzer') and self.analyzer:\n                # Check for inherited annotation-only documentation\n                for cls in inspect.getmro(self.object):\n                    cls_namespace = '.'.join([cls.__module__, cls.__qualname__])\n                    if (cls_namespace, membername) in self.analyzer.attr_docs:\n                        doc = '\\n'.join(self.analyzer.attr_docs[(cls_namespace, membername)])\n                        break\n\n            has_doc = bool(doc)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/sphinx/sphinx/ext/autodoc/__init__.py lines 761-770)": [
      "\n            elif (namespace, membername) in attr_docs:\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep documented attributes\n                    keep = True\n                isattr = True\n            elif self._find_inherited_attr_doc(membername, attr_docs):\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep inherited documented attributes\n                    keep = True\n                isattr = True\n",
      "\n            elif (namespace, membername) in attr_docs:\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep documented attributes\n                    keep = True\n                isattr = True\n            elif self._find_inherited_attr_doc(membername, attr_docs):\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep inherited annotation-only documented attributes\n                    keep = True\n                isattr = True\n",
      "\n            elif (namespace, membername) in attr_docs:\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep documented attributes\n                    keep = True\n                isattr = True\n            elif self._find_inherited_attr_doc(membername, attr_docs):\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep inherited annotation-only documented attributes\n                    keep = True\n                isattr = True\n",
      "\n            elif (namespace, membername) in attr_docs:\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep documented attributes\n                    keep = True\n                isattr = True\n            elif self._find_inherited_attr_doc(membername, attr_docs):\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep inherited documented attributes\n                    keep = True\n                isattr = True\n",
      "\n            elif (namespace, membername) in attr_docs:\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep documented attributes\n                    keep = True\n                isattr = True\n            elif self._find_inherited_attr_doc(membername, attr_docs):\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep inherited annotation-only documented attributes\n                    keep = True\n                isattr = True\n",
      "\n            elif (namespace, membername) in attr_docs:\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep documented attributes\n                    keep = True\n                isattr = True\n            elif self._find_inherited_attr_doc(membername, attr_docs):\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep inherited annotation-only documented attributes\n                    keep = True\n                isattr = True\n",
      "\n            elif (namespace, membername) in attr_docs or self._find_inherited_attr_doc(membername, attr_docs):\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep documented attributes\n                    keep = True\n                isattr = True\n",
      "\n            elif (namespace, membername) in attr_docs:\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep documented attributes\n                    keep = True\n                isattr = True\n            elif self._find_inherited_attr_doc(membername, attr_docs):\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep inherited annotation-only documented attributes\n                    keep = True\n                isattr = True\n"
    ],
    "Location 2 (/root/hy/projects_3/sphinx/sphinx/ext/autodoc/__init__.py lines 697-703)": [
      "\n        # search for members in source code too\n        namespace = '.'.join(self.objpath)  # will be empty for modules\n\n        if self.analyzer:\n            attr_docs = self.analyzer.find_attr_docs()\n        else:\n            attr_docs = {}\n\n        def find_inherited_attr_doc(membername):\n            \"\"\"Find annotation-only documentation in superclass namespaces.\"\"\"\n            # First check current class namespace\n            if (namespace, membername) in attr_docs:\n                return True\n            \n            # For inherited members, check superclass namespaces\n            if hasattr(self.object, '__mro__'):\n                for cls in self.object.__mro__[1:]:  # Skip self.object (first in MRO)\n                    cls_path = f\"{cls.__module__}.{cls.__qualname__}\"\n                    if (cls_path, membername) in attr_docs:\n                        return True\n            \n            return False\n",
      "\ndef find_inherited_attr_doc(self, membername: str, attr_docs: Dict[Tuple[str, str], List[str]]) -> bool:\n    \"\"\"Check if an annotation-only member has documentation in any superclass.\"\"\"\n    if not self.objpath:\n        return False\n    \n    # Get the class object to traverse its MRO\n    try:\n        cls = self.object\n        if not inspect.isclass(cls):\n            return False\n        \n        # Check each class in the MRO for annotation-only documentation\n        for base_cls in cls.__mro__[1:]:  # Skip self (index 0)\n            # Construct the namespace for this base class\n            base_module = getattr(base_cls, '__module__', '')\n            base_qualname = getattr(base_cls, '__qualname__', base_cls.__name__)\n            \n            if base_module:\n                base_namespace = f\"{base_module}.{base_qualname}\"\n            else:\n                base_namespace = base_qualname\n            \n            # Check if this member has annotation-only documentation in this base class\n            if (base_namespace, membername) in attr_docs:\n                return True\n                \n    except (AttributeError, TypeError):\n        pass\n    \n    return False\n\n# search for members in source code too\nnamespace = '.'.join(self.objpath)  # will be empty for modules\n\nif self.analyzer:\n    attr_docs = self.analyzer.find_attr_docs()\nelse:\n    attr_docs = {}\n",
      "\ndef find_inherited_attr_doc(self, membername: str, attr_docs: Dict[Tuple[str, str], List[str]]) -> bool:\n    \"\"\"Check if an annotation-only member has documentation in any superclass.\"\"\"\n    if not self.objpath:\n        return False\n    \n    # Get the class object to traverse its MRO\n    try:\n        cls = self.object\n        if not inspect.isclass(cls):\n            return False\n        \n        # Check each class in the MRO for annotation-only documentation\n        for base_cls in cls.__mro__[1:]:  # Skip the current class\n            base_module = getattr(base_cls, '__module__', None)\n            base_qualname = getattr(base_cls, '__qualname__', None)\n            \n            if base_module and base_qualname:\n                # Construct the namespace for the base class\n                base_namespace = f\"{base_module}.{base_qualname}\"\n                if (base_namespace, membername) in attr_docs:\n                    return True\n    except (AttributeError, TypeError):\n        pass\n    \n    return False\n\n# search for members in source code too\nnamespace = '.'.join(self.objpath)  # will be empty for modules\n\nif self.analyzer:\n    attr_docs = self.analyzer.find_attr_docs()\nelse:\n    attr_docs = {}\n",
      "\n        # search for members in source code too\n        namespace = '.'.join(self.objpath)  # will be empty for modules\n\n        if self.analyzer:\n            attr_docs = self.analyzer.find_attr_docs()\n        else:\n            attr_docs = {}\n\n        def find_inherited_attr_doc(membername: str) -> bool:\n            \"\"\"Check if membername has annotation-only documentation in current class or superclasses.\"\"\"\n            # First check current class\n            if (namespace, membername) in attr_docs:\n                return True\n            \n            # For inherited members, check superclass namespaces\n            if hasattr(self.object, '__mro__'):\n                for cls in self.object.__mro__[1:]:  # Skip self.object (index 0)\n                    cls_namespace = f\"{cls.__module__}.{cls.__qualname__}\"\n                    if (cls_namespace, membername) in attr_docs:\n                        return True\n            \n            return False\n",
      "\n    def filter_members(self, members: List[Tuple[str, Any]], want_all: bool\n                      ) -> List[Tuple[str, Any, bool]]:\n        \"\"\"Filter the given member list.\n\n        Members are skipped if\n\n        - they are private (except if given explicitly or the private-members\n          option is set)\n        - they are special methods (except if given explicitly or the\n          special-members option is set)\n        - they are undocumented (except if the undoc-members option is set)\n\n        The user can override the skipping decision by connecting to the\n        ``autodoc-skip-member`` event.\n        \"\"\"\n        def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n            if inspect.isclass(self.object):\n                for cls in self.object.__mro__:\n                    if cls.__name__ == self.object.__name__:\n                        continue\n                    elif name in self.get_attr(cls, '__dict__', {}):\n                        return True\n                    elif name in self.get_attr(cls, '__slots__', []):\n                        return True\n                    elif name in self.get_attr(cls, '__annotations__', {}):\n                        return False\n                    elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n                        return False\n\n            return False\n\n        def find_inherited_attr_doc(name: str) -> bool:\n            \"\"\"Check if an annotation-only member has documentation in any superclass.\"\"\"\n            if not inspect.isclass(self.object) or not self.analyzer:\n                return False\n            \n            for cls in self.object.__mro__:\n                if cls.__name__ == self.object.__name__:\n                    continue\n                cls_namespace = '.'.join(self.objpath[:-1] + [cls.__name__])\n                if (cls_namespace, name) in attr_docs:\n                    return True\n            return False\n\n        ret = []\n\n        # search for members in source code too\n        namespace = '.'.join(self.objpath)  # will be empty for modules\n\n        if self.analyzer:\n            attr_docs = self.analyzer.find_attr_docs()\n        else:\n            attr_docs = {}\n\n        # process members and determine which to skip\n        for obj in members:\n            membername, member = obj\n            # if isattr is True, the member is documented as an attribute\n            if member is INSTANCEATTR:\n                isattr = True\n            else:\n                isattr = False\n\n            doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n                         self.object, membername)\n            if not isinstance(doc, str):\n                # Ignore non-string __doc__\n                doc = None\n\n            # if the member __doc__ is the same as self's __doc__, it's just\n            # inherited and therefore not the member's doc\n            cls = self.get_attr(member, '__objclass__', None)\n            if cls:\n                cls_doc = self.get_attr(cls, '__doc__', None)\n                if cls_doc == doc:\n                    doc = None\n\n            if isinstance(obj, ObjectMember) and obj.docstring:\n                doc_from_definition = obj.docstring\n            else:\n                doc_from_definition = None\n\n            has_doc = (doc is not None or\n                       doc_from_definition is not None or\n                       (namespace, membername) in attr_docs or\n                       find_inherited_attr_doc(membername))\n\n            keep = False\n            if safe_getattr(member, '__sphinx_mock__', False):\n                # mocked module or object\n                pass\n            elif self.options.exclude_members and membername in self.options.exclude_members:\n                # remove members given by exclude-members\n                keep = False\n            elif want_all and special_member_re.match(membername):\n                # special __methods__\n                if self.options.special_members is ALL:\n                    if membername != '__doc__':\n                        keep = has_doc or self.options.undoc_members\n                elif self.options.special_members:\n                    if membername in self.options.special_members:\n                        keep = has_doc or self.options.undoc_members\n            elif (namespace, membername) in attr_docs or find_inherited_attr_doc(membername):\n                if want_all and membername.startswith('_'):\n                    # ignore members whose name starts with _ by default\n                    keep = self.options.private_members\n                else:\n                    # keep documented attributes\n                    keep = True\n                isattr = True\n            elif want_all and membername.startswith('_'):\n                # ignore members whose name starts with _ by default\n                keep = self.options.private_members and \\\n                       (has_doc or self.options.undoc_members)\n            else:\n                if self.options.members is ALL and is_filtered_inherited_member(membername, member):\n                    keep = False\n                else:\n                    # ignore undocumented members if :undoc-members: is not given\n                    keep = has_doc or self.options.undoc_members or find_inherited_attr_doc(membername)\n\n            if isinstance(obj, ObjectMember) and obj.skipped:\n                # forcedly skipped member (ex. a module attribute not defined in __all__)\n                keep = False\n\n            # give the user a chance to decide whether this member should be skipped\n            if self.env.app:\n                # let extensions preprocess docstrings\n                try:\n                    skip_user = self.env.app.emit_firstresult(\n                        'autodoc-skip-member', self.objtype, membername, member,\n                        not keep, self.options)\n                    if skip_user is not None:\n                        keep = not skip_user\n                except Exception as exc:\n                    logger.warning(__('autodoc: failed to determine %r to be documented, '\n                                      'the following exception was raised:\\n%s'),\n                                   membername, exc, type='autodoc')\n                    keep = False\n\n            if keep:\n                ret.append((membername, member, isattr))\n\n        return ret\n",
      "\n        # search for members in source code too\n        namespace = '.'.join(self.objpath)  # will be empty for modules\n\n        if self.analyzer:\n            attr_docs = self.analyzer.find_attr_docs()\n        else:\n            attr_docs = {}\n\n        def find_inherited_attr_doc(membername):\n            \"\"\"Find annotation-only documentation in inheritance chain.\"\"\"\n            # First check current class\n            if (namespace, membername) in attr_docs:\n                return True\n            \n            # For inherited members, check superclass namespaces\n            if hasattr(self.object, '__mro__'):\n                for cls in self.object.__mro__[1:]:  # Skip self.object\n                    cls_namespace = f\"{cls.__module__}.{cls.__qualname__}\"\n                    if (cls_namespace, membername) in attr_docs:\n                        return True\n            return False\n",
      "\n        # search for members in source code too\n        namespace = '.'.join(self.objpath)  # will be empty for modules\n\n        if self.analyzer:\n            attr_docs = self.analyzer.find_attr_docs()\n        else:\n            attr_docs = {}\n\n        def find_inherited_attr_doc(membername: str) -> bool:\n            \"\"\"Check if a member has annotation-only documentation in this class or superclasses.\"\"\"\n            # First check current class\n            if (namespace, membername) in attr_docs:\n                return True\n            \n            # For inherited members, check superclass namespaces\n            if hasattr(self.object, '__mro__'):\n                for base_cls in self.object.__mro__[1:]:  # Skip self.object\n                    base_namespace = base_cls.__module__ + '.' + base_cls.__qualname__\n                    if (base_namespace, membername) in attr_docs:\n                        return True\n            \n            return False\n",
      "\n        namespace = '.'.join(self.objpath)  # will be empty for modules\n\n        if self.analyzer:\n            attr_docs = self.analyzer.find_attr_docs()\n        else:\n            attr_docs = {}\n\n        def find_inherited_attr_doc(membername):\n            \"\"\"Find annotation-only documentation in superclass namespaces.\"\"\"\n            if (namespace, membername) in attr_docs:\n                return True\n            \n            # Check superclass namespaces for inherited annotation-only members\n            if hasattr(self.object, '__mro__'):\n                for cls in self.object.__mro__[1:]:  # Skip self.object\n                    cls_namespace = '.'.join(self.objpath[:-1] + [cls.__name__])\n                    if (cls_namespace, membername) in attr_docs:\n                        return True\n            \n            return False\n"
    ],
    "Location 3 (/root/hy/projects_3/sphinx/sphinx/ext/autodoc/__init__.py lines 785-787)": [
      "\n                else:\n                    # Check for inherited annotation-only documentation\n                    inherited_doc = False\n                    if self.options.inherited_members and hasattr(self.object, '__mro__'):\n                        for base_cls in self.object.__mro__[1:]:  # Skip self\n                            base_namespace = '.'.join([base_cls.__module__, base_cls.__qualname__])\n                            if (base_namespace, membername) in attr_docs:\n                                inherited_doc = True\n                                break\n                    \n                    # ignore undocumented members if :undoc-members: is not given\n                    keep = has_doc or inherited_doc or self.options.undoc_members\n",
      "\n                else:\n                    # Check for inherited annotation-only documentation\n                    inherited_doc = False\n                    if isinstance(obj, ObjectMember) and obj.class_:\n                        # Search through MRO for annotation-only documentation\n                        for base in obj.class_.__mro__[1:]:  # Skip self\n                            base_namespace = '.'.join([base.__module__, base.__qualname__])\n                            if (base_namespace, membername) in attr_docs:\n                                inherited_doc = True\n                                break\n                    \n                    # ignore undocumented members if :undoc-members: is not given\n                    keep = has_doc or inherited_doc or self.options.undoc_members\n",
      "\n                else:\n                    # Check for inherited annotation-only documentation\n                    inherited_doc = False\n                    if isinstance(obj, ObjectMember) and obj.class_:\n                        # Search through MRO for annotation-only documentation\n                        for base_cls in inspect.getmro(obj.class_)[1:]:  # Skip self\n                            base_namespace = '.'.join([base_cls.__module__, base_cls.__qualname__])\n                            if (base_namespace, membername) in attr_docs:\n                                inherited_doc = True\n                                break\n                    \n                    # ignore undocumented members if :undoc-members: is not given\n                    keep = has_doc or inherited_doc or self.options.undoc_members\n",
      "\n                else:\n                    # Check for inherited annotation-only documentation\n                    inherited_doc = False\n                    if hasattr(self, 'parent') and self.parent:\n                        # Search through MRO for annotation-only documentation\n                        for cls in inspect.getmro(self.parent):\n                            cls_namespace = '.'.join([cls.__module__, cls.__qualname__])\n                            if (cls_namespace, membername) in attr_docs:\n                                inherited_doc = True\n                                break\n                    \n                    # ignore undocumented members if :undoc-members: is not given\n                    keep = has_doc or inherited_doc or self.options.undoc_members\n",
      "\n                else:\n                    # For inherited annotation-only members, check superclass attr_docs\n                    inherited_attr_doc = False\n                    if self.options.inherited_members and hasattr(self.object, '__mro__'):\n                        for base_cls in self.object.__mro__[1:]:  # Skip self.object\n                            base_namespace = '.'.join([base_cls.__module__, base_cls.__qualname__])\n                            if (base_namespace, membername) in attr_docs:\n                                inherited_attr_doc = True\n                                break\n                    \n                    # ignore undocumented members if :undoc-members: is not given\n                    keep = has_doc or inherited_attr_doc or self.options.undoc_members\n",
      "\n                else:\n                    # Check for inherited annotation-only documentation\n                    inherited_doc_found = False\n                    if isinstance(obj, ObjectMember) and obj.class_:\n                        # Search through MRO for annotation-only documentation\n                        for base_cls in inspect.getmro(obj.class_)[1:]:  # Skip self\n                            base_namespace = '.'.join([base_cls.__module__, base_cls.__qualname__])\n                            if (base_namespace, membername) in attr_docs:\n                                inherited_doc_found = True\n                                break\n                    \n                    # ignore undocumented members if :undoc-members: is not given\n                    keep = has_doc or inherited_doc_found or self.options.undoc_members\n",
      "\n                else:\n                    # ignore undocumented members if :undoc-members: is not given\n                    # Check for inherited annotation-only documentation\n                    has_inherited_attr_doc = False\n                    if isinstance(obj, ObjectMember) and obj.parent:\n                        for cls in inspect.getmro(obj.parent):\n                            cls_namespace = cls.__module__ + '.' + cls.__qualname__\n                            if (cls_namespace, membername) in attr_docs:\n                                has_inherited_attr_doc = True\n                                break\n                    keep = has_doc or has_inherited_attr_doc or self.options.undoc_members\n",
      "\n                else:\n                    # ignore undocumented members if :undoc-members: is not given\n                    # Check for inherited annotation-only documentation\n                    has_inherited_attr_doc = False\n                    if isinstance(obj, ObjectMember) and obj.parent:\n                        for cls in inspect.getmro(obj.parent):\n                            cls_namespace = '.'.join([cls.__module__, cls.__qualname__])\n                            if (cls_namespace, membername) in attr_docs:\n                                has_inherited_attr_doc = True\n                                break\n                    keep = has_doc or has_inherited_attr_doc or self.options.undoc_members\n"
    ],
    "Location 4 (/root/hy/projects_3/sphinx/sphinx/ext/autodoc/__init__.py lines 679-692)": [
      "\ndef is_filtered_inherited_member(name: str, obj: Any) -> bool:\n    if inspect.isclass(self.object):\n        for cls in self.object.__mro__:\n            if cls.__name__ == self.options.inherited_members and cls != self.object:\n                # given member is a member of specified *super class*\n                return True\n            elif name in cls.__dict__:\n                return False\n            elif name in self.get_attr(cls, '__annotations__', {}):\n                return False\n            elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n                return False\n\n    return False\n\ndef find_inherited_attr_doc(name: str) -> bool:\n    \"\"\"Check if an annotation-only member has documentation in any superclass.\"\"\"\n    if inspect.isclass(self.object):\n        for cls in self.object.__mro__[1:]:  # Skip self.object (first in MRO)\n            cls_namespace = '.'.join(self.objpath[:-1] + [cls.__name__])\n            if (cls_namespace, name) in attr_docs:\n                return True\n    return False\n",
      "\n        def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n            if inspect.isclass(self.object):\n                for cls in self.object.__mro__:\n                    if cls.__name__ == self.options.inherited_members and cls != self.object:\n                        # given member is a member of specified *super class*\n                        return True\n                    elif name in cls.__dict__:\n                        return False\n                    elif name in self.get_attr(cls, '__annotations__', {}):\n                        return False\n                    elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n                        return False\n\n            return False\n\n        def find_inherited_attr_doc(name: str) -> bool:\n            \"\"\"Check if an annotation-only member has documentation in any superclass.\"\"\"\n            if inspect.isclass(self.object):\n                for cls in self.object.__mro__[1:]:  # Skip self.object (index 0)\n                    cls_namespace = '.'.join(self.objpath[:-1] + [cls.__name__]) if self.objpath else cls.__name__\n                    if (cls_namespace, name) in attr_docs:\n                        # Check if it's actually an annotation-only member in the superclass\n                        if name in self.get_attr(cls, '__annotations__', {}) and name not in cls.__dict__:\n                            return True\n            return False\n",
      "\ndef is_filtered_inherited_member(name: str, obj: Any) -> bool:\n    if inspect.isclass(self.object):\n        for cls in self.object.__mro__:\n            if cls.__name__ == self.options.inherited_members and cls != self.object:\n                # given member is a member of specified *super class*\n                return True\n            elif name in cls.__dict__:\n                return False\n            elif name in self.get_attr(cls, '__annotations__', {}):\n                return False\n            elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n                return False\n\n    return False\n\ndef find_inherited_attr_doc(name: str) -> bool:\n    \"\"\"Check if annotation-only documentation exists in superclasses.\"\"\"\n    if inspect.isclass(self.object):\n        for cls in self.object.__mro__[1:]:  # Skip self.object\n            cls_namespace = cls.__module__ + '.' + cls.__qualname__\n            if (cls_namespace, name) in attr_docs:\n                return True\n    return False\n",
      "\n        def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n            if inspect.isclass(self.object):\n                for cls in self.object.__mro__:\n                    if cls.__name__ == self.options.inherited_members and cls != self.object:\n                        # given member is a member of specified *super class*\n                        return True\n                    elif name in cls.__dict__:\n                        return False\n                    elif name in self.get_attr(cls, '__annotations__', {}):\n                        return False\n                    elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n                        return False\n\n            return False\n\n        def find_inherited_attr_doc(name: str) -> bool:\n            \"\"\"Check if an annotation-only member has documentation in superclasses.\"\"\"\n            if inspect.isclass(self.object) and self.analyzer:\n                for cls in self.object.__mro__[1:]:  # Skip self.object\n                    cls_namespace = '.'.join([self.modname, cls.__qualname__])\n                    if (cls_namespace, name) in attr_docs:\n                        return True\n            return False\n",
      "\n        def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n            if inspect.isclass(self.object):\n                for cls in self.object.__mro__:\n                    if cls.__name__ == self.options.inherited_members and cls != self.object:\n                        # given member is a member of specified *super class*\n                        return True\n                    elif name in cls.__dict__:\n                        return False\n                    elif name in self.get_attr(cls, '__annotations__', {}):\n                        return False\n                    elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n                        return False\n\n            return False\n\n        def find_inherited_attr_doc(name: str) -> bool:\n            \"\"\"Check if an annotation-only member has documentation in any superclass.\"\"\"\n            if inspect.isclass(self.object) and self.analyzer:\n                for cls in self.object.__mro__[1:]:  # Skip self.object (current class)\n                    cls_namespace = '.'.join(self.objpath[:-1] + [cls.__name__]) if self.objpath else cls.__name__\n                    if (cls_namespace, name) in attr_docs:\n                        return True\n            return False\n",
      "\n        def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n            if inspect.isclass(self.object):\n                for cls in self.object.__mro__:\n                    if cls.__name__ == self.options.inherited_members and cls != self.object:\n                        # given member is a member of specified *super class*\n                        return True\n                    elif name in cls.__dict__:\n                        return False\n                    elif name in self.get_attr(cls, '__annotations__', {}):\n                        return False\n                    elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n                        return False\n\n            return False\n\n        def find_inherited_attr_doc(name: str) -> bool:\n            \"\"\"Check if an annotation-only member has documentation in any superclass.\"\"\"\n            if inspect.isclass(self.object):\n                for cls in self.object.__mro__[1:]:  # Skip self.object\n                    cls_namespace = '.'.join(self.objpath[:-1] + [cls.__name__])\n                    if (cls_namespace, name) in attr_docs:\n                        return True\n            return False\n",
      "\ndef is_filtered_inherited_member(name: str, obj: Any) -> bool:\n    if inspect.isclass(self.object):\n        for cls in self.object.__mro__:\n            if cls.__name__ == self.options.inherited_members and cls != self.object:\n                # given member is a member of specified *super class*\n                return True\n            elif name in cls.__dict__:\n                return False\n            elif name in self.get_attr(cls, '__annotations__', {}):\n                return False\n            elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n                return False\n\n    return False\n\ndef find_inherited_attr_doc(name: str) -> bool:\n    \"\"\"Check if an annotation-only member has documentation in any superclass.\"\"\"\n    if inspect.isclass(self.object) and self.analyzer:\n        for cls in self.object.__mro__[1:]:  # Skip self.object\n            cls_namespace = cls.__module__ + '.' + cls.__qualname__\n            if (cls_namespace, name) in attr_docs:\n                return True\n    return False\n",
      "\ndef is_filtered_inherited_member(name: str, obj: Any) -> bool:\n    if inspect.isclass(self.object):\n        for cls in self.object.__mro__:\n            if cls.__name__ == self.options.inherited_members and cls != self.object:\n                # given member is a member of specified *super class*\n                return True\n            elif name in cls.__dict__:\n                return False\n            elif name in self.get_attr(cls, '__annotations__', {}):\n                return False\n            elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n                return False\n\n    return False\n\ndef find_inherited_attr_doc(name: str) -> bool:\n    \"\"\"Check if annotation-only documentation exists for member in inheritance chain.\"\"\"\n    if not inspect.isclass(self.object):\n        return False\n    \n    for cls in self.object.__mro__[1:]:  # Skip self.object, check superclasses\n        cls_namespace = '.'.join(self.objpath[:-1] + [cls.__name__]) if self.objpath else cls.__name__\n        if (cls_namespace, name) in attr_docs:\n            return True\n    return False\n"
    ],
    "Location 5 (/root/hy/projects_3/sphinx/sphinx/ext/autodoc/__init__.py lines 727-731)": [
      "\n            if isinstance(obj, ObjectMember) and obj.docstring:\n                # hack for ClassDocumenter to inject docstring via ObjectMember\n                doc = obj.docstring\n            elif not doc and hasattr(self, 'analyzer') and self.analyzer:\n                # Check for inherited annotation-only documentation\n                for cls in inspect.getmro(self.object):\n                    cls_namespace = '.'.join([cls.__module__, cls.__qualname__])\n                    if (cls_namespace, membername) in attr_docs:\n                        doc = attr_docs[(cls_namespace, membername)]\n                        break\n\n            has_doc = bool(doc)\n",
      "\n            if isinstance(obj, ObjectMember) and obj.docstring:\n                # hack for ClassDocumenter to inject docstring via ObjectMember\n                doc = obj.docstring\n            elif not doc and self.analyzer:\n                # Check for inherited annotation-only documentation\n                for cls in inspect.getmro(self.object):\n                    cls_namespace = '.'.join([cls.__module__, cls.__qualname__])\n                    if (cls_namespace, membername) in attr_docs:\n                        doc = attr_docs[(cls_namespace, membername)]\n                        break\n\n            has_doc = bool(doc)\n",
      "\n            if isinstance(obj, ObjectMember) and obj.docstring:\n                # hack for ClassDocumenter to inject docstring via ObjectMember\n                doc = obj.docstring\n            elif not doc and isinstance(self, ClassDocumenter):\n                # Check for inherited annotation-only documentation\n                for base_cls in inspect.getmro(self.object)[1:]:\n                    base_namespace = '.'.join([base_cls.__module__, base_cls.__qualname__])\n                    if (base_namespace, membername) in attr_docs:\n                        doc = attr_docs[(base_namespace, membername)]\n                        break\n\n            has_doc = bool(doc)\n",
      "\n            # check for attribute docs, from class or module\n            try:\n                analyzer = ModuleAnalyzer.for_module(self.modname)\n                attr_docs = analyzer.find_attr_docs()\n            except PycodeError:\n                attr_docs = {}\n\n            def find_inherited_attr_doc(membername, namespace):\n                \"\"\"Find annotation-only documentation in inheritance chain.\"\"\"\n                # First check current namespace\n                if (namespace, membername) in attr_docs:\n                    return True\n                \n                # Check superclass namespaces for inherited annotation-only docs\n                if hasattr(self.object, '__mro__'):\n                    for base in self.object.__mro__[1:]:  # Skip self\n                        base_namespace = f\"{base.__module__}.{base.__qualname__}\"\n                        if (base_namespace, membername) in attr_docs:\n                            return True\n                return False\n\n            if isinstance(obj, ObjectMember) and obj.docstring:\n                # hack for ClassDocumenter to inject docstring via ObjectMember\n                doc = obj.docstring\n\n            has_doc = bool(doc) or find_inherited_attr_doc(membername, namespace)\n",
      "\ndef find_inherited_attr_doc(self, namespace: str, membername: str, attr_docs: Dict[Tuple[str, str], List[str]]) -> Optional[List[str]]:\n    \"\"\"Find annotation-only documentation for a member in superclasses.\"\"\"\n    if (namespace, membername) in attr_docs:\n        return attr_docs[(namespace, membername)]\n    \n    # Check superclasses for annotation-only documentation\n    if hasattr(self, 'object') and hasattr(self.object, '__mro__'):\n        for base_cls in self.object.__mro__[1:]:  # Skip self\n            base_namespace = base_cls.__module__ + '.' + base_cls.__qualname__\n            if (base_namespace, membername) in attr_docs:\n                return attr_docs[(base_namespace, membername)]\n    \n    return None\n\nif isinstance(obj, ObjectMember) and obj.docstring:\n    # hack for ClassDocumenter to inject docstring via ObjectMember\n    doc = obj.docstring\nelif not doc:\n    # Check for inherited annotation-only documentation\n    inherited_doc = self.find_inherited_attr_doc(namespace, membername, attr_docs)\n    if inherited_doc:\n        doc = '\\n'.join(inherited_doc)\n\nhas_doc = bool(doc)\n",
      "\n            if isinstance(obj, ObjectMember) and obj.docstring:\n                # hack for ClassDocumenter to inject docstring via ObjectMember\n                doc = obj.docstring\n            elif not doc and hasattr(self, 'analyzer') and self.analyzer:\n                # Check for inherited annotation-only documentation\n                for cls in inspect.getmro(self.object):\n                    cls_namespace = '.'.join([cls.__module__, cls.__qualname__])\n                    if (cls_namespace, membername) in attr_docs:\n                        doc = attr_docs[(cls_namespace, membername)]\n                        break\n\n            has_doc = bool(doc)\n",
      "\n            if isinstance(obj, ObjectMember) and obj.docstring:\n                # hack for ClassDocumenter to inject docstring via ObjectMember\n                doc = obj.docstring\n            elif not doc and hasattr(self, 'analyzer') and self.analyzer:\n                # Check for inherited annotation-only documentation\n                for base_cls in inspect.getmro(self.object)[1:]:  # Skip self.object\n                    base_namespace = '.'.join([base_cls.__module__, base_cls.__qualname__])\n                    if (base_namespace, membername) in self.analyzer.attr_docs:\n                        doc = '\\n'.join(self.analyzer.attr_docs[(base_namespace, membername)])\n                        break\n\n            has_doc = bool(doc)\n",
      "\n            if isinstance(obj, ObjectMember) and obj.docstring:\n                # hack for ClassDocumenter to inject docstring via ObjectMember\n                doc = obj.docstring\n            elif not doc and self.analyzer:\n                # Check for inherited annotation-only documentation\n                for cls in inspect.getmro(self.object):\n                    cls_namespace = '.'.join([cls.__module__, cls.__qualname__])\n                    if (cls_namespace, membername) in attr_docs:\n                        doc = attr_docs[(cls_namespace, membername)]\n                        break\n\n            has_doc = bool(doc)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex dc413b5c2..ce4336de1 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -676,6 +676,7 @@ class Documenter:\n         The user can override the skipping decision by connecting to the\n         ``autodoc-skip-member`` event.\n         \"\"\"\n+\n         def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n             if inspect.isclass(self.object):\n                 for cls in self.object.__mro__:\n@@ -691,9 +692,21 @@ class Documenter:\n \n             return False\n \n+        def _find_inherited_attr_doc(membername: str, attr_docs: Dict[Tuple[str, str], List[str]]) -> bool:\n+            \"\"\"Find annotation-only documentation in superclass namespaces.\"\"\"\n+            if not inspect.isclass(self.object):\n+                return False\n+            \n+            for cls in self.object.__mro__[1:]:  # Skip self.object (current class)\n+                cls_namespace = '.'.join(self.objpath[:-1] + [cls.__name__])\n+                if (cls_namespace, membername) in attr_docs:\n+                    return True\n+            return False\n+\n         ret = []\n \n         # search for members in source code too\n+\n         namespace = '.'.join(self.objpath)  # will be empty for modules\n \n         if self.analyzer:\n@@ -701,6 +714,16 @@ class Documenter:\n         else:\n             attr_docs = {}\n \n+        def _find_inherited_attr_doc(self, membername: str, attr_docs: Dict[Tuple[str, str], List[str]]) -> bool:\n+            \"\"\"Find annotation-only documentation in superclass namespaces.\"\"\"\n+            if not inspect.isclass(self.object):\n+                return False\n+            \n+            for cls in self.object.__mro__[1:]:  # Skip self.object (current class)\n+                cls_namespace = '.'.join(self.objpath[:-1] + [cls.__name__])\n+                if (cls_namespace, membername) in attr_docs:\n+                    return True\n+            return False\n         # process members and determine which to skip\n         for obj in members:\n             membername, member = obj\n@@ -724,11 +747,14 @@ class Documenter:\n                 if cls_doc == doc:\n                     doc = None\n \n+\n             if isinstance(obj, ObjectMember) and obj.docstring:\n                 # hack for ClassDocumenter to inject docstring via ObjectMember\n                 doc = obj.docstring\n \n-            has_doc = bool(doc)\n+            # Check for inherited annotation-only documentation\n+            has_inherited_attr_doc = self._find_inherited_attr_doc(membername, attr_docs) if hasattr(self, '_find_inherited_attr_doc') else False\n+            has_doc = bool(doc) or has_inherited_attr_doc\n \n             metadata = extract_metadata(doc)\n             if 'private' in metadata:\n@@ -758,7 +784,8 @@ class Documenter:\n                         keep = has_doc or self.options.undoc_members\n                 else:\n                     keep = False\n-            elif (namespace, membername) in attr_docs:\n+\n+            elif (namespace, membername) in attr_docs or self._find_inherited_attr_doc(membername, attr_docs):\n                 if want_all and isprivate:\n                     if self.options.private_members is None:\n                         keep = False\n@@ -782,9 +809,12 @@ class Documenter:\n                 if (self.options.members is ALL and\n                         is_filtered_inherited_member(membername, obj)):\n                     keep = False\n+\n                 else:\n                     # ignore undocumented members if :undoc-members: is not given\n-                    keep = has_doc or self.options.undoc_members\n+                    # but check for inherited annotation-only documentation first\n+                    has_inherited_attr_doc = self._find_inherited_attr_doc(membername, attr_docs) if hasattr(self, '_find_inherited_attr_doc') else False\n+                    keep = has_doc or has_inherited_attr_doc or self.options.undoc_members\n \n             if isinstance(obj, ObjectMember) and obj.skipped:\n                 # forcedly skipped member (ex. a module attribute not defined in __all__)\n",
    "variant_0": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex dc413b5c2..df6966282 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -676,6 +676,7 @@ class Documenter:\n         The user can override the skipping decision by connecting to the\n         ``autodoc-skip-member`` event.\n         \"\"\"\n+\n         def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n             if inspect.isclass(self.object):\n                 for cls in self.object.__mro__:\n@@ -691,16 +692,52 @@ class Documenter:\n \n             return False\n \n+        def find_inherited_attr_doc(name: str) -> bool:\n+            \"\"\"Check if an annotation-only member has documentation in any superclass.\"\"\"\n+            if inspect.isclass(self.object):\n+                for cls in self.object.__mro__[1:]:  # Skip self.object, check superclasses\n+                    cls_namespace = '.'.join(self.objpath[:-1] + [cls.__name__]) if self.objpath else cls.__name__\n+                    if (cls_namespace, name) in attr_docs:\n+                        return True\n+            return False\n+\n         ret = []\n \n         # search for members in source code too\n-        namespace = '.'.join(self.objpath)  # will be empty for modules\n \n-        if self.analyzer:\n-            attr_docs = self.analyzer.find_attr_docs()\n-        else:\n-            attr_docs = {}\n+def find_inherited_attr_doc(self, membername: str, attr_docs: Dict[Tuple[str, str], List[str]]) -> bool:\n+    \"\"\"Check if an annotation-only member has documentation in any superclass.\"\"\"\n+    if not self.objpath:\n+        return False\n+    \n+    # Check current class first\n+    current_namespace = '.'.join(self.objpath)\n+    if (current_namespace, membername) in attr_docs:\n+        return True\n+    \n+    # Check superclasses for annotation-only documentation\n+    try:\n+        cls = self.object\n+        if inspect.isclass(cls):\n+            for base in inspect.getmro(cls)[1:]:  # Skip the class itself\n+                base_module = getattr(base, '__module__', None)\n+                base_qualname = getattr(base, '__qualname__', None)\n+                if base_module and base_qualname:\n+                    base_namespace = f\"{base_module}.{base_qualname}\"\n+                    if (base_namespace, membername) in attr_docs:\n+                        return True\n+    except (AttributeError, TypeError):\n+        pass\n+    \n+    return False\n \n+# search for members in source code too\n+namespace = '.'.join(self.objpath)  # will be empty for modules\n+\n+if self.analyzer:\n+    attr_docs = self.analyzer.find_attr_docs()\n+else:\n+    attr_docs = {}\n         # process members and determine which to skip\n         for obj in members:\n             membername, member = obj\n@@ -724,9 +761,17 @@ class Documenter:\n                 if cls_doc == doc:\n                     doc = None\n \n+\n             if isinstance(obj, ObjectMember) and obj.docstring:\n                 # hack for ClassDocumenter to inject docstring via ObjectMember\n                 doc = obj.docstring\n+            elif not doc and hasattr(self, 'analyzer') and self.analyzer:\n+                # Check for inherited annotation-only documentation\n+                for cls in inspect.getmro(self.object):\n+                    cls_namespace = '.'.join([cls.__module__, cls.__qualname__])\n+                    if (cls_namespace, membername) in self.analyzer.attr_docs:\n+                        doc = '\\n'.join(self.analyzer.attr_docs[(cls_namespace, membername)])\n+                        break\n \n             has_doc = bool(doc)\n \n@@ -758,6 +803,7 @@ class Documenter:\n                         keep = has_doc or self.options.undoc_members\n                 else:\n                     keep = False\n+\n             elif (namespace, membername) in attr_docs:\n                 if want_all and isprivate:\n                     if self.options.private_members is None:\n@@ -768,6 +814,16 @@ class Documenter:\n                     # keep documented attributes\n                     keep = True\n                 isattr = True\n+            elif self._has_inherited_attr_doc(membername, attr_docs):\n+                if want_all and isprivate:\n+                    if self.options.private_members is None:\n+                        keep = False\n+                    else:\n+                        keep = membername in self.options.private_members\n+                else:\n+                    # keep inherited documented attributes\n+                    keep = True\n+                isattr = True\n             elif want_all and isprivate:\n                 if has_doc or self.options.undoc_members:\n                     if self.options.private_members is None:\n@@ -782,9 +838,19 @@ class Documenter:\n                 if (self.options.members is ALL and\n                         is_filtered_inherited_member(membername, obj)):\n                     keep = False\n+\n                 else:\n                     # ignore undocumented members if :undoc-members: is not given\n-                    keep = has_doc or self.options.undoc_members\n+                    # but first check if this member has inherited annotation-only documentation\n+                    inherited_doc = False\n+                    if not has_doc and self.options.inherited_members:\n+                        # Check for annotation-only documentation in superclasses\n+                        for base_class in inspect.getmro(self.object)[1:]:\n+                            base_namespace = '.'.join([base_class.__module__, base_class.__qualname__])\n+                            if (base_namespace, membername) in attr_docs:\n+                                inherited_doc = True\n+                                break\n+                    keep = has_doc or inherited_doc or self.options.undoc_members\n \n             if isinstance(obj, ObjectMember) and obj.skipped:\n                 # forcedly skipped member (ex. a module attribute not defined in __all__)\n",
    "variant_1": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex dc413b5c2..d22b016d0 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -676,23 +676,35 @@ class Documenter:\n         The user can override the skipping decision by connecting to the\n         ``autodoc-skip-member`` event.\n         \"\"\"\n-        def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n-            if inspect.isclass(self.object):\n-                for cls in self.object.__mro__:\n-                    if cls.__name__ == self.options.inherited_members and cls != self.object:\n-                        # given member is a member of specified *super class*\n-                        return True\n-                    elif name in cls.__dict__:\n-                        return False\n-                    elif name in self.get_attr(cls, '__annotations__', {}):\n-                        return False\n-                    elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n-                        return False\n \n-            return False\n+def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n+    if inspect.isclass(self.object):\n+        for cls in self.object.__mro__:\n+            if cls.__name__ == self.options.inherited_members and cls != self.object:\n+                # given member is a member of specified *super class*\n+                return True\n+            elif name in cls.__dict__:\n+                return False\n+            elif name in self.get_attr(cls, '__annotations__', {}):\n+                return False\n+            elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n+                return False\n+\n+    return False\n+\n+def find_inherited_attr_doc(name: str) -> bool:\n+    \"\"\"Check if an annotation-only member has documentation in any superclass.\"\"\"\n+    if inspect.isclass(self.object):\n+        for cls in self.object.__mro__[1:]:  # Skip self.object (first in MRO)\n+            cls_namespace = '.'.join(self.objpath[:-1] + [cls.__name__])\n+            if (cls_namespace, name) in attr_docs:\n+                return True\n+    return False\n \n         ret = []\n \n+        # search for members in source code too\n+\n         # search for members in source code too\n         namespace = '.'.join(self.objpath)  # will be empty for modules\n \n@@ -701,6 +713,20 @@ class Documenter:\n         else:\n             attr_docs = {}\n \n+        def find_inherited_attr_doc(membername):\n+            \"\"\"Find annotation-only documentation in superclass namespaces.\"\"\"\n+            # First check current class namespace\n+            if (namespace, membername) in attr_docs:\n+                return True\n+            \n+            # For inherited members, check superclass namespaces\n+            if hasattr(self.object, '__mro__'):\n+                for cls in self.object.__mro__[1:]:  # Skip self.object (first in MRO)\n+                    cls_path = f\"{cls.__module__}.{cls.__qualname__}\"\n+                    if (cls_path, membername) in attr_docs:\n+                        return True\n+            \n+            return False\n         # process members and determine which to skip\n         for obj in members:\n             membername, member = obj\n@@ -724,9 +750,17 @@ class Documenter:\n                 if cls_doc == doc:\n                     doc = None\n \n+\n             if isinstance(obj, ObjectMember) and obj.docstring:\n                 # hack for ClassDocumenter to inject docstring via ObjectMember\n                 doc = obj.docstring\n+            elif not doc and hasattr(self, 'analyzer') and self.analyzer:\n+                # Check for inherited annotation-only documentation\n+                for cls in inspect.getmro(self.object):\n+                    cls_namespace = '.'.join([cls.__module__, cls.__qualname__])\n+                    if (cls_namespace, membername) in attr_docs:\n+                        doc = attr_docs[(cls_namespace, membername)]\n+                        break\n \n             has_doc = bool(doc)\n \n@@ -758,6 +792,7 @@ class Documenter:\n                         keep = has_doc or self.options.undoc_members\n                 else:\n                     keep = False\n+\n             elif (namespace, membername) in attr_docs:\n                 if want_all and isprivate:\n                     if self.options.private_members is None:\n@@ -768,6 +803,16 @@ class Documenter:\n                     # keep documented attributes\n                     keep = True\n                 isattr = True\n+            elif self._find_inherited_attr_doc(membername, attr_docs):\n+                if want_all and isprivate:\n+                    if self.options.private_members is None:\n+                        keep = False\n+                    else:\n+                        keep = membername in self.options.private_members\n+                else:\n+                    # keep inherited documented attributes\n+                    keep = True\n+                isattr = True\n             elif want_all and isprivate:\n                 if has_doc or self.options.undoc_members:\n                     if self.options.private_members is None:\n@@ -782,9 +827,19 @@ class Documenter:\n                 if (self.options.members is ALL and\n                         is_filtered_inherited_member(membername, obj)):\n                     keep = False\n+\n                 else:\n+                    # Check for inherited annotation-only documentation\n+                    inherited_doc = False\n+                    if self.options.inherited_members and hasattr(self.object, '__mro__'):\n+                        for base_cls in self.object.__mro__[1:]:  # Skip self\n+                            base_namespace = '.'.join([base_cls.__module__, base_cls.__qualname__])\n+                            if (base_namespace, membername) in attr_docs:\n+                                inherited_doc = True\n+                                break\n+                    \n                     # ignore undocumented members if :undoc-members: is not given\n-                    keep = has_doc or self.options.undoc_members\n+                    keep = has_doc or inherited_doc or self.options.undoc_members\n \n             if isinstance(obj, ObjectMember) and obj.skipped:\n                 # forcedly skipped member (ex. a module attribute not defined in __all__)\n",
    "variant_2": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex dc413b5c2..2fcea8923 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -676,6 +676,7 @@ class Documenter:\n         The user can override the skipping decision by connecting to the\n         ``autodoc-skip-member`` event.\n         \"\"\"\n+\n         def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n             if inspect.isclass(self.object):\n                 for cls in self.object.__mro__:\n@@ -691,16 +692,59 @@ class Documenter:\n \n             return False\n \n+        def find_inherited_attr_doc(name: str) -> bool:\n+            \"\"\"Check if an annotation-only member has documentation in any superclass.\"\"\"\n+            if inspect.isclass(self.object):\n+                for cls in self.object.__mro__[1:]:  # Skip self.object (index 0)\n+                    cls_namespace = '.'.join(self.objpath[:-1] + [cls.__name__]) if self.objpath else cls.__name__\n+                    if (cls_namespace, name) in attr_docs:\n+                        # Check if it's actually an annotation-only member in the superclass\n+                        if name in self.get_attr(cls, '__annotations__', {}) and name not in cls.__dict__:\n+                            return True\n+            return False\n+\n         ret = []\n \n         # search for members in source code too\n-        namespace = '.'.join(self.objpath)  # will be empty for modules\n \n-        if self.analyzer:\n-            attr_docs = self.analyzer.find_attr_docs()\n-        else:\n-            attr_docs = {}\n+def find_inherited_attr_doc(self, membername: str, attr_docs: Dict[Tuple[str, str], List[str]]) -> bool:\n+    \"\"\"Check if an annotation-only member has documentation in any superclass.\"\"\"\n+    if not self.objpath:\n+        return False\n+    \n+    # Get the class object to traverse its MRO\n+    try:\n+        cls = self.object\n+        if not inspect.isclass(cls):\n+            return False\n+        \n+        # Check each class in the MRO for annotation-only documentation\n+        for base_cls in cls.__mro__[1:]:  # Skip self (index 0)\n+            # Construct the namespace for this base class\n+            base_module = getattr(base_cls, '__module__', '')\n+            base_qualname = getattr(base_cls, '__qualname__', base_cls.__name__)\n+            \n+            if base_module:\n+                base_namespace = f\"{base_module}.{base_qualname}\"\n+            else:\n+                base_namespace = base_qualname\n+            \n+            # Check if this member has annotation-only documentation in this base class\n+            if (base_namespace, membername) in attr_docs:\n+                return True\n+                \n+    except (AttributeError, TypeError):\n+        pass\n+    \n+    return False\n \n+# search for members in source code too\n+namespace = '.'.join(self.objpath)  # will be empty for modules\n+\n+if self.analyzer:\n+    attr_docs = self.analyzer.find_attr_docs()\n+else:\n+    attr_docs = {}\n         # process members and determine which to skip\n         for obj in members:\n             membername, member = obj\n@@ -724,9 +768,17 @@ class Documenter:\n                 if cls_doc == doc:\n                     doc = None\n \n+\n             if isinstance(obj, ObjectMember) and obj.docstring:\n                 # hack for ClassDocumenter to inject docstring via ObjectMember\n                 doc = obj.docstring\n+            elif not doc and self.analyzer:\n+                # Check for inherited annotation-only documentation\n+                for cls in inspect.getmro(self.object):\n+                    cls_namespace = '.'.join([cls.__module__, cls.__qualname__])\n+                    if (cls_namespace, membername) in attr_docs:\n+                        doc = attr_docs[(cls_namespace, membername)]\n+                        break\n \n             has_doc = bool(doc)\n \n@@ -758,6 +810,7 @@ class Documenter:\n                         keep = has_doc or self.options.undoc_members\n                 else:\n                     keep = False\n+\n             elif (namespace, membername) in attr_docs:\n                 if want_all and isprivate:\n                     if self.options.private_members is None:\n@@ -768,6 +821,16 @@ class Documenter:\n                     # keep documented attributes\n                     keep = True\n                 isattr = True\n+            elif self._find_inherited_attr_doc(membername, attr_docs):\n+                if want_all and isprivate:\n+                    if self.options.private_members is None:\n+                        keep = False\n+                    else:\n+                        keep = membername in self.options.private_members\n+                else:\n+                    # keep inherited annotation-only documented attributes\n+                    keep = True\n+                isattr = True\n             elif want_all and isprivate:\n                 if has_doc or self.options.undoc_members:\n                     if self.options.private_members is None:\n@@ -782,9 +845,20 @@ class Documenter:\n                 if (self.options.members is ALL and\n                         is_filtered_inherited_member(membername, obj)):\n                     keep = False\n+\n                 else:\n+                    # Check for inherited annotation-only documentation\n+                    inherited_doc = False\n+                    if isinstance(obj, ObjectMember) and obj.class_:\n+                        # Search through MRO for annotation-only documentation\n+                        for base in obj.class_.__mro__[1:]:  # Skip self\n+                            base_namespace = '.'.join([base.__module__, base.__qualname__])\n+                            if (base_namespace, membername) in attr_docs:\n+                                inherited_doc = True\n+                                break\n+                    \n                     # ignore undocumented members if :undoc-members: is not given\n-                    keep = has_doc or self.options.undoc_members\n+                    keep = has_doc or inherited_doc or self.options.undoc_members\n \n             if isinstance(obj, ObjectMember) and obj.skipped:\n                 # forcedly skipped member (ex. a module attribute not defined in __all__)\n",
    "variant_3": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex dc413b5c2..e2d6cba4b 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -676,31 +676,68 @@ class Documenter:\n         The user can override the skipping decision by connecting to the\n         ``autodoc-skip-member`` event.\n         \"\"\"\n-        def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n-            if inspect.isclass(self.object):\n-                for cls in self.object.__mro__:\n-                    if cls.__name__ == self.options.inherited_members and cls != self.object:\n-                        # given member is a member of specified *super class*\n-                        return True\n-                    elif name in cls.__dict__:\n-                        return False\n-                    elif name in self.get_attr(cls, '__annotations__', {}):\n-                        return False\n-                    elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n-                        return False\n \n-            return False\n+def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n+    if inspect.isclass(self.object):\n+        for cls in self.object.__mro__:\n+            if cls.__name__ == self.options.inherited_members and cls != self.object:\n+                # given member is a member of specified *super class*\n+                return True\n+            elif name in cls.__dict__:\n+                return False\n+            elif name in self.get_attr(cls, '__annotations__', {}):\n+                return False\n+            elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n+                return False\n+\n+    return False\n+\n+def find_inherited_attr_doc(name: str) -> bool:\n+    \"\"\"Check if annotation-only documentation exists in superclasses.\"\"\"\n+    if inspect.isclass(self.object):\n+        for cls in self.object.__mro__[1:]:  # Skip self.object\n+            cls_namespace = cls.__module__ + '.' + cls.__qualname__\n+            if (cls_namespace, name) in attr_docs:\n+                return True\n+    return False\n \n         ret = []\n \n         # search for members in source code too\n-        namespace = '.'.join(self.objpath)  # will be empty for modules\n \n-        if self.analyzer:\n-            attr_docs = self.analyzer.find_attr_docs()\n-        else:\n-            attr_docs = {}\n+def find_inherited_attr_doc(self, membername: str, attr_docs: Dict[Tuple[str, str], List[str]]) -> bool:\n+    \"\"\"Check if an annotation-only member has documentation in any superclass.\"\"\"\n+    if not self.objpath:\n+        return False\n+    \n+    # Get the class object to traverse its MRO\n+    try:\n+        cls = self.object\n+        if not inspect.isclass(cls):\n+            return False\n+        \n+        # Check each class in the MRO for annotation-only documentation\n+        for base_cls in cls.__mro__[1:]:  # Skip the current class\n+            base_module = getattr(base_cls, '__module__', None)\n+            base_qualname = getattr(base_cls, '__qualname__', None)\n+            \n+            if base_module and base_qualname:\n+                # Construct the namespace for the base class\n+                base_namespace = f\"{base_module}.{base_qualname}\"\n+                if (base_namespace, membername) in attr_docs:\n+                    return True\n+    except (AttributeError, TypeError):\n+        pass\n+    \n+    return False\n \n+# search for members in source code too\n+namespace = '.'.join(self.objpath)  # will be empty for modules\n+\n+if self.analyzer:\n+    attr_docs = self.analyzer.find_attr_docs()\n+else:\n+    attr_docs = {}\n         # process members and determine which to skip\n         for obj in members:\n             membername, member = obj\n@@ -724,9 +761,17 @@ class Documenter:\n                 if cls_doc == doc:\n                     doc = None\n \n+\n             if isinstance(obj, ObjectMember) and obj.docstring:\n                 # hack for ClassDocumenter to inject docstring via ObjectMember\n                 doc = obj.docstring\n+            elif not doc and isinstance(self, ClassDocumenter):\n+                # Check for inherited annotation-only documentation\n+                for base_cls in inspect.getmro(self.object)[1:]:\n+                    base_namespace = '.'.join([base_cls.__module__, base_cls.__qualname__])\n+                    if (base_namespace, membername) in attr_docs:\n+                        doc = attr_docs[(base_namespace, membername)]\n+                        break\n \n             has_doc = bool(doc)\n \n@@ -758,6 +803,7 @@ class Documenter:\n                         keep = has_doc or self.options.undoc_members\n                 else:\n                     keep = False\n+\n             elif (namespace, membername) in attr_docs:\n                 if want_all and isprivate:\n                     if self.options.private_members is None:\n@@ -768,6 +814,16 @@ class Documenter:\n                     # keep documented attributes\n                     keep = True\n                 isattr = True\n+            elif self._find_inherited_attr_doc(membername, attr_docs):\n+                if want_all and isprivate:\n+                    if self.options.private_members is None:\n+                        keep = False\n+                    else:\n+                        keep = membername in self.options.private_members\n+                else:\n+                    # keep inherited annotation-only documented attributes\n+                    keep = True\n+                isattr = True\n             elif want_all and isprivate:\n                 if has_doc or self.options.undoc_members:\n                     if self.options.private_members is None:\n@@ -782,9 +838,20 @@ class Documenter:\n                 if (self.options.members is ALL and\n                         is_filtered_inherited_member(membername, obj)):\n                     keep = False\n+\n                 else:\n+                    # Check for inherited annotation-only documentation\n+                    inherited_doc = False\n+                    if isinstance(obj, ObjectMember) and obj.class_:\n+                        # Search through MRO for annotation-only documentation\n+                        for base_cls in inspect.getmro(obj.class_)[1:]:  # Skip self\n+                            base_namespace = '.'.join([base_cls.__module__, base_cls.__qualname__])\n+                            if (base_namespace, membername) in attr_docs:\n+                                inherited_doc = True\n+                                break\n+                    \n                     # ignore undocumented members if :undoc-members: is not given\n-                    keep = has_doc or self.options.undoc_members\n+                    keep = has_doc or inherited_doc or self.options.undoc_members\n \n             if isinstance(obj, ObjectMember) and obj.skipped:\n                 # forcedly skipped member (ex. a module attribute not defined in __all__)\n",
    "variant_4": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex dc413b5c2..1fa95512e 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -676,6 +676,7 @@ class Documenter:\n         The user can override the skipping decision by connecting to the\n         ``autodoc-skip-member`` event.\n         \"\"\"\n+\n         def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n             if inspect.isclass(self.object):\n                 for cls in self.object.__mro__:\n@@ -691,8 +692,19 @@ class Documenter:\n \n             return False\n \n+        def find_inherited_attr_doc(name: str) -> bool:\n+            \"\"\"Check if an annotation-only member has documentation in superclasses.\"\"\"\n+            if inspect.isclass(self.object) and self.analyzer:\n+                for cls in self.object.__mro__[1:]:  # Skip self.object\n+                    cls_namespace = '.'.join([self.modname, cls.__qualname__])\n+                    if (cls_namespace, name) in attr_docs:\n+                        return True\n+            return False\n+\n         ret = []\n \n+        # search for members in source code too\n+\n         # search for members in source code too\n         namespace = '.'.join(self.objpath)  # will be empty for modules\n \n@@ -701,6 +713,20 @@ class Documenter:\n         else:\n             attr_docs = {}\n \n+        def find_inherited_attr_doc(membername: str) -> bool:\n+            \"\"\"Check if membername has annotation-only documentation in current class or superclasses.\"\"\"\n+            # First check current class\n+            if (namespace, membername) in attr_docs:\n+                return True\n+            \n+            # For inherited members, check superclass namespaces\n+            if hasattr(self.object, '__mro__'):\n+                for cls in self.object.__mro__[1:]:  # Skip self.object (index 0)\n+                    cls_namespace = f\"{cls.__module__}.{cls.__qualname__}\"\n+                    if (cls_namespace, membername) in attr_docs:\n+                        return True\n+            \n+            return False\n         # process members and determine which to skip\n         for obj in members:\n             membername, member = obj\n@@ -724,11 +750,33 @@ class Documenter:\n                 if cls_doc == doc:\n                     doc = None\n \n+\n+            # check for attribute docs, from class or module\n+            try:\n+                analyzer = ModuleAnalyzer.for_module(self.modname)\n+                attr_docs = analyzer.find_attr_docs()\n+            except PycodeError:\n+                attr_docs = {}\n+\n+            def find_inherited_attr_doc(membername, namespace):\n+                \"\"\"Find annotation-only documentation in inheritance chain.\"\"\"\n+                # First check current namespace\n+                if (namespace, membername) in attr_docs:\n+                    return True\n+                \n+                # Check superclass namespaces for inherited annotation-only docs\n+                if hasattr(self.object, '__mro__'):\n+                    for base in self.object.__mro__[1:]:  # Skip self\n+                        base_namespace = f\"{base.__module__}.{base.__qualname__}\"\n+                        if (base_namespace, membername) in attr_docs:\n+                            return True\n+                return False\n+\n             if isinstance(obj, ObjectMember) and obj.docstring:\n                 # hack for ClassDocumenter to inject docstring via ObjectMember\n                 doc = obj.docstring\n \n-            has_doc = bool(doc)\n+            has_doc = bool(doc) or find_inherited_attr_doc(membername, namespace)\n \n             metadata = extract_metadata(doc)\n             if 'private' in metadata:\n@@ -758,6 +806,7 @@ class Documenter:\n                         keep = has_doc or self.options.undoc_members\n                 else:\n                     keep = False\n+\n             elif (namespace, membername) in attr_docs:\n                 if want_all and isprivate:\n                     if self.options.private_members is None:\n@@ -768,6 +817,16 @@ class Documenter:\n                     # keep documented attributes\n                     keep = True\n                 isattr = True\n+            elif self._find_inherited_attr_doc(membername, attr_docs):\n+                if want_all and isprivate:\n+                    if self.options.private_members is None:\n+                        keep = False\n+                    else:\n+                        keep = membername in self.options.private_members\n+                else:\n+                    # keep inherited documented attributes\n+                    keep = True\n+                isattr = True\n             elif want_all and isprivate:\n                 if has_doc or self.options.undoc_members:\n                     if self.options.private_members is None:\n@@ -782,9 +841,20 @@ class Documenter:\n                 if (self.options.members is ALL and\n                         is_filtered_inherited_member(membername, obj)):\n                     keep = False\n+\n                 else:\n+                    # Check for inherited annotation-only documentation\n+                    inherited_doc = False\n+                    if hasattr(self, 'parent') and self.parent:\n+                        # Search through MRO for annotation-only documentation\n+                        for cls in inspect.getmro(self.parent):\n+                            cls_namespace = '.'.join([cls.__module__, cls.__qualname__])\n+                            if (cls_namespace, membername) in attr_docs:\n+                                inherited_doc = True\n+                                break\n+                    \n                     # ignore undocumented members if :undoc-members: is not given\n-                    keep = has_doc or self.options.undoc_members\n+                    keep = has_doc or inherited_doc or self.options.undoc_members\n \n             if isinstance(obj, ObjectMember) and obj.skipped:\n                 # forcedly skipped member (ex. a module attribute not defined in __all__)\n",
    "variant_5": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex dc413b5c2..216bbdb61 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -676,6 +676,7 @@ class Documenter:\n         The user can override the skipping decision by connecting to the\n         ``autodoc-skip-member`` event.\n         \"\"\"\n+\n         def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n             if inspect.isclass(self.object):\n                 for cls in self.object.__mro__:\n@@ -691,6 +692,63 @@ class Documenter:\n \n             return False\n \n+        def find_inherited_attr_doc(name: str) -> bool:\n+            \"\"\"Check if an annotation-only member has documentation in any superclass.\"\"\"\n+            if inspect.isclass(self.object) and self.analyzer:\n+                for cls in self.object.__mro__[1:]:  # Skip self.object (current class)\n+                    cls_namespace = '.'.join(self.objpath[:-1] + [cls.__name__]) if self.objpath else cls.__name__\n+                    if (cls_namespace, name) in attr_docs:\n+                        return True\n+            return False\n+\n+        ret = []\n+\n+        # search for members in source code too\n+\n+    def filter_members(self, members: List[Tuple[str, Any]], want_all: bool\n+                      ) -> List[Tuple[str, Any, bool]]:\n+        \"\"\"Filter the given member list.\n+\n+        Members are skipped if\n+\n+        - they are private (except if given explicitly or the private-members\n+          option is set)\n+        - they are special methods (except if given explicitly or the\n+          special-members option is set)\n+        - they are undocumented (except if the undoc-members option is set)\n+\n+        The user can override the skipping decision by connecting to the\n+        ``autodoc-skip-member`` event.\n+        \"\"\"\n+        def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n+            if inspect.isclass(self.object):\n+                for cls in self.object.__mro__:\n+                    if cls.__name__ == self.object.__name__:\n+                        continue\n+                    elif name in self.get_attr(cls, '__dict__', {}):\n+                        return True\n+                    elif name in self.get_attr(cls, '__slots__', []):\n+                        return True\n+                    elif name in self.get_attr(cls, '__annotations__', {}):\n+                        return False\n+                    elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n+                        return False\n+\n+            return False\n+\n+        def find_inherited_attr_doc(name: str) -> bool:\n+            \"\"\"Check if an annotation-only member has documentation in any superclass.\"\"\"\n+            if not inspect.isclass(self.object) or not self.analyzer:\n+                return False\n+            \n+            for cls in self.object.__mro__:\n+                if cls.__name__ == self.object.__name__:\n+                    continue\n+                cls_namespace = '.'.join(self.objpath[:-1] + [cls.__name__])\n+                if (cls_namespace, name) in attr_docs:\n+                    return True\n+            return False\n+\n         ret = []\n \n         # search for members in source code too\n@@ -701,6 +759,96 @@ class Documenter:\n         else:\n             attr_docs = {}\n \n+        # process members and determine which to skip\n+        for obj in members:\n+            membername, member = obj\n+            # if isattr is True, the member is documented as an attribute\n+            if member is INSTANCEATTR:\n+                isattr = True\n+            else:\n+                isattr = False\n+\n+            doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n+                         self.object, membername)\n+            if not isinstance(doc, str):\n+                # Ignore non-string __doc__\n+                doc = None\n+\n+            # if the member __doc__ is the same as self's __doc__, it's just\n+            # inherited and therefore not the member's doc\n+            cls = self.get_attr(member, '__objclass__', None)\n+            if cls:\n+                cls_doc = self.get_attr(cls, '__doc__', None)\n+                if cls_doc == doc:\n+                    doc = None\n+\n+            if isinstance(obj, ObjectMember) and obj.docstring:\n+                doc_from_definition = obj.docstring\n+            else:\n+                doc_from_definition = None\n+\n+            has_doc = (doc is not None or\n+                       doc_from_definition is not None or\n+                       (namespace, membername) in attr_docs or\n+                       find_inherited_attr_doc(membername))\n+\n+            keep = False\n+            if safe_getattr(member, '__sphinx_mock__', False):\n+                # mocked module or object\n+                pass\n+            elif self.options.exclude_members and membername in self.options.exclude_members:\n+                # remove members given by exclude-members\n+                keep = False\n+            elif want_all and special_member_re.match(membername):\n+                # special __methods__\n+                if self.options.special_members is ALL:\n+                    if membername != '__doc__':\n+                        keep = has_doc or self.options.undoc_members\n+                elif self.options.special_members:\n+                    if membername in self.options.special_members:\n+                        keep = has_doc or self.options.undoc_members\n+            elif (namespace, membername) in attr_docs or find_inherited_attr_doc(membername):\n+                if want_all and membername.startswith('_'):\n+                    # ignore members whose name starts with _ by default\n+                    keep = self.options.private_members\n+                else:\n+                    # keep documented attributes\n+                    keep = True\n+                isattr = True\n+            elif want_all and membername.startswith('_'):\n+                # ignore members whose name starts with _ by default\n+                keep = self.options.private_members and \\\n+                       (has_doc or self.options.undoc_members)\n+            else:\n+                if self.options.members is ALL and is_filtered_inherited_member(membername, member):\n+                    keep = False\n+                else:\n+                    # ignore undocumented members if :undoc-members: is not given\n+                    keep = has_doc or self.options.undoc_members or find_inherited_attr_doc(membername)\n+\n+            if isinstance(obj, ObjectMember) and obj.skipped:\n+                # forcedly skipped member (ex. a module attribute not defined in __all__)\n+                keep = False\n+\n+            # give the user a chance to decide whether this member should be skipped\n+            if self.env.app:\n+                # let extensions preprocess docstrings\n+                try:\n+                    skip_user = self.env.app.emit_firstresult(\n+                        'autodoc-skip-member', self.objtype, membername, member,\n+                        not keep, self.options)\n+                    if skip_user is not None:\n+                        keep = not skip_user\n+                except Exception as exc:\n+                    logger.warning(__('autodoc: failed to determine %r to be documented, '\n+                                      'the following exception was raised:\\n%s'),\n+                                   membername, exc, type='autodoc')\n+                    keep = False\n+\n+            if keep:\n+                ret.append((membername, member, isattr))\n+\n+        return ret\n         # process members and determine which to skip\n         for obj in members:\n             membername, member = obj\n@@ -724,11 +872,31 @@ class Documenter:\n                 if cls_doc == doc:\n                     doc = None\n \n-            if isinstance(obj, ObjectMember) and obj.docstring:\n-                # hack for ClassDocumenter to inject docstring via ObjectMember\n-                doc = obj.docstring\n \n-            has_doc = bool(doc)\n+def find_inherited_attr_doc(self, namespace: str, membername: str, attr_docs: Dict[Tuple[str, str], List[str]]) -> Optional[List[str]]:\n+    \"\"\"Find annotation-only documentation for a member in superclasses.\"\"\"\n+    if (namespace, membername) in attr_docs:\n+        return attr_docs[(namespace, membername)]\n+    \n+    # Check superclasses for annotation-only documentation\n+    if hasattr(self, 'object') and hasattr(self.object, '__mro__'):\n+        for base_cls in self.object.__mro__[1:]:  # Skip self\n+            base_namespace = base_cls.__module__ + '.' + base_cls.__qualname__\n+            if (base_namespace, membername) in attr_docs:\n+                return attr_docs[(base_namespace, membername)]\n+    \n+    return None\n+\n+if isinstance(obj, ObjectMember) and obj.docstring:\n+    # hack for ClassDocumenter to inject docstring via ObjectMember\n+    doc = obj.docstring\n+elif not doc:\n+    # Check for inherited annotation-only documentation\n+    inherited_doc = self.find_inherited_attr_doc(namespace, membername, attr_docs)\n+    if inherited_doc:\n+        doc = '\\n'.join(inherited_doc)\n+\n+has_doc = bool(doc)\n \n             metadata = extract_metadata(doc)\n             if 'private' in metadata:\n@@ -758,6 +926,7 @@ class Documenter:\n                         keep = has_doc or self.options.undoc_members\n                 else:\n                     keep = False\n+\n             elif (namespace, membername) in attr_docs:\n                 if want_all and isprivate:\n                     if self.options.private_members is None:\n@@ -768,6 +937,16 @@ class Documenter:\n                     # keep documented attributes\n                     keep = True\n                 isattr = True\n+            elif self._find_inherited_attr_doc(membername, attr_docs):\n+                if want_all and isprivate:\n+                    if self.options.private_members is None:\n+                        keep = False\n+                    else:\n+                        keep = membername in self.options.private_members\n+                else:\n+                    # keep inherited annotation-only documented attributes\n+                    keep = True\n+                isattr = True\n             elif want_all and isprivate:\n                 if has_doc or self.options.undoc_members:\n                     if self.options.private_members is None:\n@@ -782,9 +961,19 @@ class Documenter:\n                 if (self.options.members is ALL and\n                         is_filtered_inherited_member(membername, obj)):\n                     keep = False\n+\n                 else:\n+                    # For inherited annotation-only members, check superclass attr_docs\n+                    inherited_attr_doc = False\n+                    if self.options.inherited_members and hasattr(self.object, '__mro__'):\n+                        for base_cls in self.object.__mro__[1:]:  # Skip self.object\n+                            base_namespace = '.'.join([base_cls.__module__, base_cls.__qualname__])\n+                            if (base_namespace, membername) in attr_docs:\n+                                inherited_attr_doc = True\n+                                break\n+                    \n                     # ignore undocumented members if :undoc-members: is not given\n-                    keep = has_doc or self.options.undoc_members\n+                    keep = has_doc or inherited_attr_doc or self.options.undoc_members\n \n             if isinstance(obj, ObjectMember) and obj.skipped:\n                 # forcedly skipped member (ex. a module attribute not defined in __all__)\n",
    "variant_6": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex dc413b5c2..d001c1550 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -676,6 +676,7 @@ class Documenter:\n         The user can override the skipping decision by connecting to the\n         ``autodoc-skip-member`` event.\n         \"\"\"\n+\n         def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n             if inspect.isclass(self.object):\n                 for cls in self.object.__mro__:\n@@ -691,8 +692,19 @@ class Documenter:\n \n             return False\n \n+        def find_inherited_attr_doc(name: str) -> bool:\n+            \"\"\"Check if an annotation-only member has documentation in any superclass.\"\"\"\n+            if inspect.isclass(self.object):\n+                for cls in self.object.__mro__[1:]:  # Skip self.object\n+                    cls_namespace = '.'.join(self.objpath[:-1] + [cls.__name__])\n+                    if (cls_namespace, name) in attr_docs:\n+                        return True\n+            return False\n+\n         ret = []\n \n+        # search for members in source code too\n+\n         # search for members in source code too\n         namespace = '.'.join(self.objpath)  # will be empty for modules\n \n@@ -701,6 +713,19 @@ class Documenter:\n         else:\n             attr_docs = {}\n \n+        def find_inherited_attr_doc(membername):\n+            \"\"\"Find annotation-only documentation in inheritance chain.\"\"\"\n+            # First check current class\n+            if (namespace, membername) in attr_docs:\n+                return True\n+            \n+            # For inherited members, check superclass namespaces\n+            if hasattr(self.object, '__mro__'):\n+                for cls in self.object.__mro__[1:]:  # Skip self.object\n+                    cls_namespace = f\"{cls.__module__}.{cls.__qualname__}\"\n+                    if (cls_namespace, membername) in attr_docs:\n+                        return True\n+            return False\n         # process members and determine which to skip\n         for obj in members:\n             membername, member = obj\n@@ -724,9 +749,17 @@ class Documenter:\n                 if cls_doc == doc:\n                     doc = None\n \n+\n             if isinstance(obj, ObjectMember) and obj.docstring:\n                 # hack for ClassDocumenter to inject docstring via ObjectMember\n                 doc = obj.docstring\n+            elif not doc and hasattr(self, 'analyzer') and self.analyzer:\n+                # Check for inherited annotation-only documentation\n+                for cls in inspect.getmro(self.object):\n+                    cls_namespace = '.'.join([cls.__module__, cls.__qualname__])\n+                    if (cls_namespace, membername) in attr_docs:\n+                        doc = attr_docs[(cls_namespace, membername)]\n+                        break\n \n             has_doc = bool(doc)\n \n@@ -758,6 +791,7 @@ class Documenter:\n                         keep = has_doc or self.options.undoc_members\n                 else:\n                     keep = False\n+\n             elif (namespace, membername) in attr_docs:\n                 if want_all and isprivate:\n                     if self.options.private_members is None:\n@@ -768,6 +802,16 @@ class Documenter:\n                     # keep documented attributes\n                     keep = True\n                 isattr = True\n+            elif self._find_inherited_attr_doc(membername, attr_docs):\n+                if want_all and isprivate:\n+                    if self.options.private_members is None:\n+                        keep = False\n+                    else:\n+                        keep = membername in self.options.private_members\n+                else:\n+                    # keep inherited annotation-only documented attributes\n+                    keep = True\n+                isattr = True\n             elif want_all and isprivate:\n                 if has_doc or self.options.undoc_members:\n                     if self.options.private_members is None:\n@@ -782,9 +826,20 @@ class Documenter:\n                 if (self.options.members is ALL and\n                         is_filtered_inherited_member(membername, obj)):\n                     keep = False\n+\n                 else:\n+                    # Check for inherited annotation-only documentation\n+                    inherited_doc_found = False\n+                    if isinstance(obj, ObjectMember) and obj.class_:\n+                        # Search through MRO for annotation-only documentation\n+                        for base_cls in inspect.getmro(obj.class_)[1:]:  # Skip self\n+                            base_namespace = '.'.join([base_cls.__module__, base_cls.__qualname__])\n+                            if (base_namespace, membername) in attr_docs:\n+                                inherited_doc_found = True\n+                                break\n+                    \n                     # ignore undocumented members if :undoc-members: is not given\n-                    keep = has_doc or self.options.undoc_members\n+                    keep = has_doc or inherited_doc_found or self.options.undoc_members\n \n             if isinstance(obj, ObjectMember) and obj.skipped:\n                 # forcedly skipped member (ex. a module attribute not defined in __all__)\n",
    "variant_7": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex dc413b5c2..4a779e2cd 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -676,23 +676,35 @@ class Documenter:\n         The user can override the skipping decision by connecting to the\n         ``autodoc-skip-member`` event.\n         \"\"\"\n-        def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n-            if inspect.isclass(self.object):\n-                for cls in self.object.__mro__:\n-                    if cls.__name__ == self.options.inherited_members and cls != self.object:\n-                        # given member is a member of specified *super class*\n-                        return True\n-                    elif name in cls.__dict__:\n-                        return False\n-                    elif name in self.get_attr(cls, '__annotations__', {}):\n-                        return False\n-                    elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n-                        return False\n \n-            return False\n+def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n+    if inspect.isclass(self.object):\n+        for cls in self.object.__mro__:\n+            if cls.__name__ == self.options.inherited_members and cls != self.object:\n+                # given member is a member of specified *super class*\n+                return True\n+            elif name in cls.__dict__:\n+                return False\n+            elif name in self.get_attr(cls, '__annotations__', {}):\n+                return False\n+            elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n+                return False\n+\n+    return False\n+\n+def find_inherited_attr_doc(name: str) -> bool:\n+    \"\"\"Check if an annotation-only member has documentation in any superclass.\"\"\"\n+    if inspect.isclass(self.object) and self.analyzer:\n+        for cls in self.object.__mro__[1:]:  # Skip self.object\n+            cls_namespace = cls.__module__ + '.' + cls.__qualname__\n+            if (cls_namespace, name) in attr_docs:\n+                return True\n+    return False\n \n         ret = []\n \n+        # search for members in source code too\n+\n         # search for members in source code too\n         namespace = '.'.join(self.objpath)  # will be empty for modules\n \n@@ -701,6 +713,20 @@ class Documenter:\n         else:\n             attr_docs = {}\n \n+        def find_inherited_attr_doc(membername: str) -> bool:\n+            \"\"\"Check if a member has annotation-only documentation in this class or superclasses.\"\"\"\n+            # First check current class\n+            if (namespace, membername) in attr_docs:\n+                return True\n+            \n+            # For inherited members, check superclass namespaces\n+            if hasattr(self.object, '__mro__'):\n+                for base_cls in self.object.__mro__[1:]:  # Skip self.object\n+                    base_namespace = base_cls.__module__ + '.' + base_cls.__qualname__\n+                    if (base_namespace, membername) in attr_docs:\n+                        return True\n+            \n+            return False\n         # process members and determine which to skip\n         for obj in members:\n             membername, member = obj\n@@ -724,9 +750,17 @@ class Documenter:\n                 if cls_doc == doc:\n                     doc = None\n \n+\n             if isinstance(obj, ObjectMember) and obj.docstring:\n                 # hack for ClassDocumenter to inject docstring via ObjectMember\n                 doc = obj.docstring\n+            elif not doc and hasattr(self, 'analyzer') and self.analyzer:\n+                # Check for inherited annotation-only documentation\n+                for base_cls in inspect.getmro(self.object)[1:]:  # Skip self.object\n+                    base_namespace = '.'.join([base_cls.__module__, base_cls.__qualname__])\n+                    if (base_namespace, membername) in self.analyzer.attr_docs:\n+                        doc = '\\n'.join(self.analyzer.attr_docs[(base_namespace, membername)])\n+                        break\n \n             has_doc = bool(doc)\n \n@@ -758,7 +792,8 @@ class Documenter:\n                         keep = has_doc or self.options.undoc_members\n                 else:\n                     keep = False\n-            elif (namespace, membername) in attr_docs:\n+\n+            elif (namespace, membername) in attr_docs or self._find_inherited_attr_doc(membername, attr_docs):\n                 if want_all and isprivate:\n                     if self.options.private_members is None:\n                         keep = False\n@@ -782,9 +817,18 @@ class Documenter:\n                 if (self.options.members is ALL and\n                         is_filtered_inherited_member(membername, obj)):\n                     keep = False\n+\n                 else:\n                     # ignore undocumented members if :undoc-members: is not given\n-                    keep = has_doc or self.options.undoc_members\n+                    # Check for inherited annotation-only documentation\n+                    has_inherited_attr_doc = False\n+                    if isinstance(obj, ObjectMember) and obj.parent:\n+                        for cls in inspect.getmro(obj.parent):\n+                            cls_namespace = cls.__module__ + '.' + cls.__qualname__\n+                            if (cls_namespace, membername) in attr_docs:\n+                                has_inherited_attr_doc = True\n+                                break\n+                    keep = has_doc or has_inherited_attr_doc or self.options.undoc_members\n \n             if isinstance(obj, ObjectMember) and obj.skipped:\n                 # forcedly skipped member (ex. a module attribute not defined in __all__)\n",
    "variant_8": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex dc413b5c2..be43c537b 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -676,24 +676,37 @@ class Documenter:\n         The user can override the skipping decision by connecting to the\n         ``autodoc-skip-member`` event.\n         \"\"\"\n-        def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n-            if inspect.isclass(self.object):\n-                for cls in self.object.__mro__:\n-                    if cls.__name__ == self.options.inherited_members and cls != self.object:\n-                        # given member is a member of specified *super class*\n-                        return True\n-                    elif name in cls.__dict__:\n-                        return False\n-                    elif name in self.get_attr(cls, '__annotations__', {}):\n-                        return False\n-                    elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n-                        return False\n \n-            return False\n+def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n+    if inspect.isclass(self.object):\n+        for cls in self.object.__mro__:\n+            if cls.__name__ == self.options.inherited_members and cls != self.object:\n+                # given member is a member of specified *super class*\n+                return True\n+            elif name in cls.__dict__:\n+                return False\n+            elif name in self.get_attr(cls, '__annotations__', {}):\n+                return False\n+            elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n+                return False\n+\n+    return False\n+\n+def find_inherited_attr_doc(name: str) -> bool:\n+    \"\"\"Check if annotation-only documentation exists for member in inheritance chain.\"\"\"\n+    if not inspect.isclass(self.object):\n+        return False\n+    \n+    for cls in self.object.__mro__[1:]:  # Skip self.object, check superclasses\n+        cls_namespace = '.'.join(self.objpath[:-1] + [cls.__name__]) if self.objpath else cls.__name__\n+        if (cls_namespace, name) in attr_docs:\n+            return True\n+    return False\n \n         ret = []\n \n         # search for members in source code too\n+\n         namespace = '.'.join(self.objpath)  # will be empty for modules\n \n         if self.analyzer:\n@@ -701,6 +714,19 @@ class Documenter:\n         else:\n             attr_docs = {}\n \n+        def find_inherited_attr_doc(membername):\n+            \"\"\"Find annotation-only documentation in superclass namespaces.\"\"\"\n+            if (namespace, membername) in attr_docs:\n+                return True\n+            \n+            # Check superclass namespaces for inherited annotation-only members\n+            if hasattr(self.object, '__mro__'):\n+                for cls in self.object.__mro__[1:]:  # Skip self.object\n+                    cls_namespace = '.'.join(self.objpath[:-1] + [cls.__name__])\n+                    if (cls_namespace, membername) in attr_docs:\n+                        return True\n+            \n+            return False\n         # process members and determine which to skip\n         for obj in members:\n             membername, member = obj\n@@ -724,9 +750,17 @@ class Documenter:\n                 if cls_doc == doc:\n                     doc = None\n \n+\n             if isinstance(obj, ObjectMember) and obj.docstring:\n                 # hack for ClassDocumenter to inject docstring via ObjectMember\n                 doc = obj.docstring\n+            elif not doc and self.analyzer:\n+                # Check for inherited annotation-only documentation\n+                for cls in inspect.getmro(self.object):\n+                    cls_namespace = '.'.join([cls.__module__, cls.__qualname__])\n+                    if (cls_namespace, membername) in attr_docs:\n+                        doc = attr_docs[(cls_namespace, membername)]\n+                        break\n \n             has_doc = bool(doc)\n \n@@ -758,6 +792,7 @@ class Documenter:\n                         keep = has_doc or self.options.undoc_members\n                 else:\n                     keep = False\n+\n             elif (namespace, membername) in attr_docs:\n                 if want_all and isprivate:\n                     if self.options.private_members is None:\n@@ -768,6 +803,16 @@ class Documenter:\n                     # keep documented attributes\n                     keep = True\n                 isattr = True\n+            elif self._find_inherited_attr_doc(membername, attr_docs):\n+                if want_all and isprivate:\n+                    if self.options.private_members is None:\n+                        keep = False\n+                    else:\n+                        keep = membername in self.options.private_members\n+                else:\n+                    # keep inherited annotation-only documented attributes\n+                    keep = True\n+                isattr = True\n             elif want_all and isprivate:\n                 if has_doc or self.options.undoc_members:\n                     if self.options.private_members is None:\n@@ -782,9 +827,18 @@ class Documenter:\n                 if (self.options.members is ALL and\n                         is_filtered_inherited_member(membername, obj)):\n                     keep = False\n+\n                 else:\n                     # ignore undocumented members if :undoc-members: is not given\n-                    keep = has_doc or self.options.undoc_members\n+                    # Check for inherited annotation-only documentation\n+                    has_inherited_attr_doc = False\n+                    if isinstance(obj, ObjectMember) and obj.parent:\n+                        for cls in inspect.getmro(obj.parent):\n+                            cls_namespace = '.'.join([cls.__module__, cls.__qualname__])\n+                            if (cls_namespace, membername) in attr_docs:\n+                                has_inherited_attr_doc = True\n+                                break\n+                    keep = has_doc or has_inherited_attr_doc or self.options.undoc_members\n \n             if isinstance(obj, ObjectMember) and obj.skipped:\n                 # forcedly skipped member (ex. a module attribute not defined in __all__)\n"
  }
}