{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/matplotlib/lib/matplotlib/__init__.py lines 1170-1178)": "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    # Use _get_backend_or_none to avoid triggering backend resolution\n    # which can cause side effects like clearing figures\n    backend = rcParams._get_backend_or_none()\n    if backend is not None:\n        return backend\n    \n    # If no backend is set, return the default without triggering resolution\n    # This prevents the cascade of backend switching that clears figures\n    return rcsetup._auto_backend_sentinel\n",
    "Location 2 (/root/hy/projects_3/matplotlib/lib/matplotlib/pyplot.py lines 209-225)": "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    # Use _get_backend_or_none to avoid triggering backend resolution\n    # and potential figure clearing in pyplot.switch_backend\n    backend = _get_backend_or_none()\n    if backend is not None:\n        return backend\n    \n    # If backend is None, we need to resolve it, but do so carefully\n    # to avoid triggering pyplot.switch_backend unnecessarily\n    if rcParams['backend'] is rcsetup._auto_backend_sentinel:\n        # Let the normal resolution happen through rcParams access\n        return rcParams['backend']\n    else:\n        # Backend is explicitly set, return it directly\n        return rcParams['backend']\n",
    "Location 3 (/root/hy/projects_3/matplotlib/lib/matplotlib/__init__.py lines 1138-1152)": "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    # Use _get_backend_or_none() to avoid triggering backend resolution\n    # which can cause unwanted side effects like figure clearing\n    backend = rcParams._get_backend_or_none()\n    if backend is None:\n        # If backend is not set, return the default without triggering resolution\n        return rcsetup._auto_backend_sentinel\n    return backend\n",
    "Location 4 (/root/hy/projects_3/matplotlib/lib/matplotlib/__init__.py lines 681-684)": "\n    def _get_backend_or_none(self):\n        \"\"\"Get the requested backend, if any, without triggering resolution.\"\"\"\n        backend = dict.__getitem__(self, \"backend\")\n        return None if backend is rcsetup._auto_backend_sentinel else backend\n",
    "Location 5 (/root/hy/projects_3/matplotlib/lib/matplotlib/__init__.py lines 1057-1098)": "\n@contextlib.contextmanager\ndef rc_context(rc=None, fname=None):\n    \"\"\"\n    Return a context manager for temporarily changing rcParams.\n\n    Parameters\n    ----------\n    rc : dict\n        The rcParams to temporarily set.\n    fname : str or path-like\n        A file with Matplotlib rc settings. If both *fname* and *rc* are given,\n        settings from *rc* take precedence.\n\n    See Also\n    --------\n    :ref:`customizing-with-matplotlibrc-files`\n\n    Examples\n    --------\n    Passing explicit values via a dict::\n\n        with mpl.rc_context({'interactive': False}):\n            fig, ax = plt.subplots()\n            ax.plot(range(3), range(3))\n            fig.savefig('example.png')\n            plt.close(fig)\n\n    Loading settings from a file::\n\n         with mpl.rc_context(fname='print.rc'):\n             plt.plot(x, y)  # uses 'print.rc'\n\n    \"\"\"\n    # Store the original backend state to avoid inconsistencies\n    orig_backend = rcParams._get_backend_or_none()\n    orig = rcParams.copy()\n    try:\n        if fname:\n            rc_file(fname)\n        if rc:\n            rcParams.update(rc)\n        yield\n    finally:\n        # Restore original state without triggering backend switching\n        rcParams.clear()\n        rcParams.update(orig)\n        # Explicitly restore backend state if it was set\n        if orig_backend is not None:\n            rcParams._set_backend_or_none(orig_backend)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/matplotlib/lib/matplotlib/__init__.py lines 1170-1178)": [
      "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    # Use _get_backend_or_none() to avoid triggering backend resolution\n    # which can cause side effects like clearing figures\n    backend = rcParams._get_backend_or_none()\n    if backend is not None:\n        return backend\n    # If backend is None, fall back to the default without triggering resolution\n    return rcParams._get_backend_or_none() or rcsetup._auto_backend_sentinel\n",
      "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    # Use _get_backend_or_none() to avoid triggering backend resolution\n    # which can cause side effects like closing figures\n    backend = rcParams._get_backend_or_none()\n    if backend is not None:\n        return backend\n    \n    # If backend is None, we need to resolve it, but we should do so\n    # without triggering the full backend switching machinery\n    # that can close existing figures\n    from matplotlib import pyplot as plt\n    if hasattr(plt, '_backend_mod') and plt._backend_mod is not None:\n        # If pyplot already has a backend loaded, use that\n        return plt._backend_mod.__name__.split('.')[-1]\n    \n    # Fall back to the rcParams value, which will trigger resolution\n    # This is the original behavior as a last resort\n    return rcParams['backend']\n",
      "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    return rcParams._get_backend_or_none() or 'Agg'\n",
      "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    # Use _get_backend_or_none() to avoid triggering backend resolution\n    # which can cause figure clearing in certain contexts\n    backend = rcParams._get_backend_or_none()\n    if backend is not None:\n        return backend\n    # If backend is None, we need to resolve it, but do so carefully\n    # to avoid side effects during context manager operations\n    return rcParams['backend']\n",
      "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    # Use _get_backend_or_none to avoid triggering backend resolution\n    # which can cause unwanted side effects like clearing figures\n    backend = rcParams._get_backend_or_none()\n    if backend is not None:\n        return backend\n    \n    # If no backend is set, return the default without triggering resolution\n    # This prevents the cascade of backend switching that clears figures\n    return rcsetup._auto_backend_sentinel\n",
      "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    # Use _get_backend_or_none to avoid triggering backend resolution\n    # which can cause side effects like figure clearing\n    backend = rcParams._get_backend_or_none()\n    if backend is not None:\n        return backend\n    # If no backend is set, return the default without triggering resolution\n    return rcParams.get('backend', 'Agg')\n",
      "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    # Use _get_backend_or_none() to avoid triggering backend resolution\n    # which can cause unwanted side effects like clearing figures\n    backend = rcParams._get_backend_or_none()\n    if backend is not None:\n        return backend\n    \n    # If backend is None, we need to resolve it, but we should do so\n    # without triggering the full backend switching machinery\n    # that could clear existing figures\n    if rcParams._get('backend') == 'auto':\n        # Return the auto-detected backend without setting it permanently\n        from matplotlib.backends import backend_registry\n        return backend_registry.resolve_backend_or_none() or 'Agg'\n    \n    return rcParams['backend']\n",
      "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    return rcParams._get_backend_or_none() or rcParams['backend']\n"
    ],
    "Location 2 (/root/hy/projects_3/matplotlib/lib/matplotlib/pyplot.py lines 209-225)": [
      "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    # Use _get_backend_or_none() to avoid triggering backend resolution\n    # which can cause unwanted side effects like closing figures\n    backend = _get_backend_or_none()\n    if backend is not None:\n        return backend\n    \n    # Only resolve backend if absolutely necessary and no backend module exists\n    if _backend_mod is None:\n        # Use dict.__getitem__ to avoid fallback logic that could trigger pyplot import\n        backend = dict.__getitem__(rcParams, \"backend\")\n        if backend is not rcsetup._auto_backend_sentinel:\n            return backend\n    \n    # If we have a backend module, return its name\n    if _backend_mod is not None:\n        return _backend_mod.__name__[len(\"matplotlib.backends.\"):]\n    \n    # Final fallback - return the rcParam value directly\n    return rcParams[\"backend\"]\n",
      "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    # Use _get_backend_or_none() to avoid triggering backend resolution\n    # which can cause unwanted side effects like closing figures\n    backend = _get_backend_or_none()\n    if backend is not None:\n        return backend\n    \n    # Only if backend is truly None, fall back to rcParams access\n    # This preserves the original behavior for cases where backend\n    # resolution is actually needed\n    return rcParams['backend']\n",
      "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    # Use _get_backend_or_none to avoid triggering backend resolution\n    # which can cause unwanted side effects like clearing figures\n    backend = _get_backend_or_none()\n    if backend is not None:\n        return backend\n    \n    # Only fall back to rcParams access if no backend is set\n    # This avoids the auto-resolution cascade that can clear figures\n    return rcParams.get(\"backend\", rcsetup._auto_backend_sentinel)\n",
      "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    # Use _get_backend_or_none() to avoid triggering backend resolution\n    # which can cause unwanted side effects like clearing figures\n    backend = _get_backend_or_none()\n    if backend is not None:\n        return backend\n    \n    # Only fall back to rcParams access if we don't have a backend yet\n    # This preserves the original behavior while avoiding side effects\n    # when the backend is in an auto-detection state\n    return rcParams['backend']\n",
      "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    # Use _get_backend_or_none() to avoid triggering backend resolution\n    # which could cause figure clearing side effects\n    backend = _get_backend_or_none()\n    if backend is not None:\n        return backend\n    \n    # If backend is None, we need to resolve it, but do so carefully\n    # to avoid the side effects that come from accessing rcParams['backend']\n    # during backend resolution\n    if rcParams['backend'] is rcsetup._auto_backend_sentinel:\n        # Let the backend resolution happen through normal channels\n        # but don't trigger it ourselves\n        return str(rcsetup._auto_backend_sentinel)\n    else:\n        return rcParams['backend']\n",
      "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    # Use _get_backend_or_none() to avoid triggering backend resolution\n    # when the backend is in auto-detection state, preventing unwanted\n    # side effects like figure clearing\n    backend = _get_backend_or_none()\n    if backend is None:\n        # Only resolve backend if absolutely necessary\n        backend = rcParams['backend']\n    return backend\n",
      "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    # Use _get_backend_or_none() to avoid triggering backend resolution\n    # which could cause unwanted side effects like closing figures\n    backend = _get_backend_or_none()\n    if backend is None:\n        # If no backend is set, return the default from rcParams without\n        # triggering backend switching logic\n        return rcParams._get('backend', rcsetup._auto_backend_sentinel)\n    return backend\n",
      "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    # Use _get_backend_or_none() to avoid side effects that could trigger\n    # backend switching and figure clearing\n    backend = _get_backend_or_none()\n    if backend is not None:\n        return backend\n    \n    # If backend is None, we need to resolve it, but do so carefully\n    # to avoid unnecessary figure clearing\n    current_backend = rcParams['backend']\n    if current_backend is rcsetup._auto_backend_sentinel:\n        # Only resolve auto backend if we haven't already initialized\n        if _backend_mod is None:\n            # This will trigger backend resolution but is necessary\n            return rcParams['backend']\n        else:\n            # We already have a backend module, return its name\n            return _backend_mod.__name__.split('.')[-1]\n    \n    return current_backend\n"
    ],
    "Location 3 (/root/hy/projects_3/matplotlib/lib/matplotlib/__init__.py lines 1138-1152)": [
      "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    # Use _get_backend_or_none to avoid triggering backend resolution\n    # which can cause side effects like figure clearing\n    backend = rcParams._get_backend_or_none()\n    if backend is not None:\n        return backend\n    \n    # If backend is None (auto), we need to resolve it but do so carefully\n    # to avoid triggering unnecessary backend switching\n    current_backend = rcParams['backend']\n    return current_backend\n",
      "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    # Use _get_backend_or_none to avoid triggering backend resolution\n    # which can cause unwanted side effects like figure clearing\n    backend = rcParams._get_backend_or_none()\n    if backend is None:\n        # Only resolve backend if absolutely necessary\n        # This preserves the original behavior while avoiding side effects\n        # when backend is in auto-detection state\n        return rcParams['backend']\n    return backend\n",
      "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    # Use _get_backend_or_none() to avoid triggering backend resolution\n    # which can cause unwanted side effects like figure clearing\n    backend = rcParams._get_backend_or_none()\n    if backend is None:\n        # If backend is still None (auto-detection state), \n        # we need to resolve it, but do so carefully\n        backend = rcParams['backend']\n    return backend\n",
      "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    # Use _get_backend_or_none to avoid triggering backend resolution\n    # which can cause side effects like figure clearing\n    backend = rcParams._get_backend_or_none()\n    if backend is None:\n        # If no backend is explicitly set, return the default\n        # without triggering resolution\n        return rcsetup._auto_backend_sentinel\n    return backend\n",
      "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    # Use _get_backend_or_none() to avoid triggering backend resolution\n    # which can cause side effects like closing figures\n    backend = rcParams._get_backend_or_none()\n    if backend is None:\n        # Only resolve backend if absolutely necessary\n        # This maintains backward compatibility while avoiding side effects\n        backend = rcParams['backend']\n    return backend\n",
      "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    :ref:`backends`\n    matplotlib.use\n    \"\"\"\n    # Use _get_backend_or_none() to avoid triggering backend resolution\n    # which can cause side effects like closing figures\n    backend = rcParams._get_backend_or_none()\n    if backend is None:\n        # If backend is None (auto), we need to resolve it but should do so\n        # without side effects. Get the default backend without triggering\n        # the full backend switching machinery.\n        backend = rcParams._get_backend_or_none() or rcsetup._auto_backend_sentinel\n        if backend == rcsetup._auto_backend_sentinel:\n            # Fall back to getting the resolved backend value, but only if\n            # we absolutely must\n            backend = rcParams['backend']\n    return backend\n",
      "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    # Use _get_backend_or_none to avoid triggering backend resolution\n    # which can cause side effects like closing figures\n    backend = rcParams._get_backend_or_none()\n    if backend is None:\n        # If backend is still None (auto), resolve it without side effects\n        # by directly accessing the validated backend name\n        backend = rcParams._get('backend')\n    return backend\n",
      "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    :ref:`backends`\n    matplotlib.use\n    \"\"\"\n    # Use _get_backend_or_none() to avoid triggering backend resolution\n    # which can cause side effects like closing figures\n    backend = rcParams._get_backend_or_none()\n    if backend is None:\n        # If no backend is set, return the default without triggering resolution\n        return rcsetup._auto_backend_sentinel\n    return backend\n"
    ],
    "Location 4 (/root/hy/projects_3/matplotlib/lib/matplotlib/__init__.py lines 681-684)": [
      "\n    def _get_backend_or_none(self):\n        \"\"\"Get the requested backend, if any, without triggering resolution.\"\"\"\n        backend = dict.__getitem__(self, \"backend\")\n        return None if backend is rcsetup._auto_backend_sentinel else backend\n",
      "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    # Use _get_backend_or_none to avoid triggering backend resolution\n    backend = rcParams._get_backend_or_none()\n    if backend is None:\n        # If backend is auto-sentinel, get the actual backend without side effects\n        # by temporarily accessing the resolved value\n        from matplotlib import pyplot as plt\n        # Get the current backend without triggering switch_backend\n        if hasattr(plt.get_backend, '_called'):\n            return plt.get_backend()\n        else:\n            # Fallback to direct access if pyplot backend is already resolved\n            return dict.__getitem__(rcParams, \"backend\")\n    return backend\n",
      "\n    def get_backend():\n        \"\"\"\n        Return the name of the current backend.\n\n        See Also\n        --------\n        matplotlib.use\n        \"\"\"\n        # Use _get_backend_or_none to avoid triggering backend resolution\n        # which can cause side effects like figure clearing\n        backend = rcParams._get_backend_or_none()\n        if backend is None:\n            # Only trigger resolution if we absolutely need to\n            return rcParams['backend']\n        return backend\n",
      "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    # Use _get_backend_or_none to avoid triggering backend resolution\n    backend = rcParams._get_backend_or_none()\n    if backend is None:\n        # If backend is still auto-sentinel, resolve it without side effects\n        # by accessing the resolved backend from pyplot if it exists\n        import matplotlib.pyplot as plt\n        if hasattr(plt, '_backend_mod') and plt._backend_mod is not None:\n            return plt.get_backend()\n        # Fall back to the sentinel value to avoid triggering resolution\n        return rcsetup._auto_backend_sentinel\n    return backend\n",
      "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    # Use _get_backend_or_none to avoid triggering backend resolution\n    backend = rcParams._get_backend_or_none()\n    if backend is None:\n        # Only resolve backend if we absolutely need to, but avoid side effects\n        # by checking if we're in a context where resolution is safe\n        return rcsetup._auto_backend_sentinel\n    return backend\n",
      "\n    def _get_backend_or_none(self):\n        \"\"\"Get the requested backend, if any, without triggering resolution.\"\"\"\n        backend = dict.__getitem__(self, \"backend\")\n        return None if backend is rcsetup._auto_backend_sentinel else backend\n",
      "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    # Use _get_backend_or_none to avoid triggering backend resolution\n    backend = rcParams._get_backend_or_none()\n    if backend is None:\n        # Only resolve backend if we haven't already done so\n        return rcParams['backend']\n    return backend\n",
      "\ndef get_backend():\n    \"\"\"\n    Return the name of the current backend.\n\n    See Also\n    --------\n    matplotlib.use\n    \"\"\"\n    # Use _get_backend_or_none to avoid triggering backend resolution\n    backend = rcParams._get_backend_or_none()\n    if backend is None:\n        # Backend is in auto-detection state, resolve it without side effects\n        return rcsetup._auto_backend_sentinel\n    return backend\n"
    ],
    "Location 5 (/root/hy/projects_3/matplotlib/lib/matplotlib/__init__.py lines 1057-1098)": [
      "\n@contextlib.contextmanager\ndef rc_context(rc=None, fname=None):\n    \"\"\"\n    Return a context manager for temporarily changing rcParams.\n\n    Parameters\n    ----------\n    rc : dict\n        The rcParams to temporarily set.\n    fname : str or path-like\n        A file with Matplotlib rc settings. If both *fname* and *rc* are given,\n        settings from *rc* take precedence.\n\n    See Also\n    --------\n    :ref:`customizing-with-matplotlibrc-files`\n\n    Examples\n    --------\n    Passing explicit values via a dict::\n\n        with mpl.rc_context({'interactive': False}):\n            fig, ax = plt.subplots()\n            ax.plot(range(3), range(3))\n            fig.savefig('example.png')\n            plt.close(fig)\n\n    Loading settings from a file::\n\n         with mpl.rc_context(fname='print.rc'):\n             plt.plot(x, y)  # uses 'print.rc'\n\n    \"\"\"\n    orig = rcParams.copy()\n    # Store the original backend state to avoid inconsistencies\n    orig_backend_or_none = rcParams._get_backend_or_none()\n    try:\n        if fname:\n            rc_file(fname)\n        if rc:\n            rcParams.update(rc)\n        yield\n    finally:\n        dict.update(rcParams, orig)  # Revert to the original rcs.\n        # Restore the original backend state if it was None\n        if orig_backend_or_none is None:\n            rcParams._set_backend_or_none(None)\n",
      "\n@contextlib.contextmanager\ndef rc_context(rc=None, fname=None):\n    \"\"\"\n    Return a context manager for temporarily changing rcParams.\n\n    Parameters\n    ----------\n    rc : dict\n        The rcParams to temporarily set.\n    fname : str or path-like\n        A file with Matplotlib rc settings. If both *fname* and *rc* are given,\n        settings from *rc* take precedence.\n\n    See Also\n    --------\n    :ref:`customizing-with-matplotlibrc-files`\n\n    Examples\n    --------\n    Passing explicit values via a dict::\n\n        with mpl.rc_context({'interactive': False}):\n            fig, ax = plt.subplots()\n            ax.plot(range(3), range(3))\n            fig.savefig('example.png')\n            plt.close(fig)\n\n    Loading settings from a file::\n\n         with mpl.rc_context(fname='print.rc'):\n             plt.plot(x, y)  # uses 'print.rc'\n\n    \"\"\"\n    orig = rcParams.copy()\n    # Store the original backend state to prevent inconsistencies\n    orig_backend_fallback = getattr(rcParams, '_backend_fallback', None)\n    try:\n        if fname:\n            rc_file(fname)\n        if rc:\n            rcParams.update(rc)\n        yield\n    finally:\n        # Restore original backend state before updating rcParams\n        if hasattr(rcParams, '_backend_fallback'):\n            rcParams._backend_fallback = orig_backend_fallback\n        dict.update(rcParams, orig)  # Revert to the original rcs.\n",
      "\n@contextlib.contextmanager\ndef rc_context(rc=None, fname=None):\n    \"\"\"\n    Return a context manager for temporarily changing rcParams.\n\n    Parameters\n    ----------\n    rc : dict\n        The rcParams to temporarily set.\n    fname : str or path-like\n        A file with Matplotlib rc settings. If both *fname* and *rc* are given,\n        settings from *rc* take precedence.\n\n    See Also\n    --------\n    :ref:`customizing-with-matplotlibrc-files`\n\n    Examples\n    --------\n    Passing explicit values via a dict::\n\n        with mpl.rc_context({'interactive': False}):\n            fig, ax = plt.subplots()\n            ax.plot(range(3), range(3))\n            fig.savefig('example.png')\n            plt.close(fig)\n\n    Loading settings from a file::\n\n         with mpl.rc_context(fname='print.rc'):\n             plt.plot(x, y)  # uses 'print.rc'\n\n    \"\"\"\n    orig = rcParams.copy()\n    try:\n        if fname:\n            rc_file(fname)\n        if rc:\n            rcParams.update(rc)\n        yield\n    finally:\n        # Clear the dict first, then update with original values to ensure\n        # proper restoration and avoid triggering backend switching\n        rcParams.clear()\n        rcParams.update(orig)\n",
      "\n@contextlib.contextmanager\ndef rc_context(rc=None, fname=None):\n    \"\"\"\n    Return a context manager for temporarily changing rcParams.\n\n    Parameters\n    ----------\n    rc : dict\n        The rcParams to temporarily set.\n    fname : str or path-like\n        A file with Matplotlib rc settings. If both *fname* and *rc* are given,\n        settings from *rc* take precedence.\n\n    See Also\n    --------\n    :ref:`customizing-with-matplotlibrc-files`\n\n    Examples\n    --------\n    Passing explicit values via a dict::\n\n        with mpl.rc_context({'interactive': False}):\n            fig, ax = plt.subplots()\n            ax.plot(range(3), range(3))\n            fig.savefig('example.png')\n            plt.close(fig)\n\n    Loading settings from a file::\n\n         with mpl.rc_context(fname='print.rc'):\n             plt.plot(x, y)  # uses 'print.rc'\n\n    \"\"\"\n    orig = rcParams.copy()\n    try:\n        if fname:\n            rc_file(fname)\n        if rc:\n            rcParams.update(rc)\n        yield\n    finally:\n        # Preserve backend state to avoid triggering unwanted backend switches\n        current_backend = rcParams.get('backend', None)\n        dict.update(rcParams, orig)  # Revert to the original rcs.\n        # If the backend was explicitly set during the context and differs\n        # from the original, maintain the current backend to avoid side effects\n        if current_backend and current_backend != orig.get('backend'):\n            rcParams['backend'] = current_backend\n",
      "\n@contextlib.contextmanager\ndef rc_context(rc=None, fname=None):\n    \"\"\"\n    Return a context manager for temporarily changing rcParams.\n\n    Parameters\n    ----------\n    rc : dict\n        The rcParams to temporarily set.\n    fname : str or path-like\n        A file with Matplotlib rc settings. If both *fname* and *rc* are given,\n        settings from *rc* take precedence.\n\n    See Also\n    --------\n    :ref:`customizing-with-matplotlibrc-files`\n\n    Examples\n    --------\n    Passing explicit values via a dict::\n\n        with mpl.rc_context({'interactive': False}):\n            fig, ax = plt.subplots()\n            ax.plot(range(3), range(3))\n            fig.savefig('example.png')\n            plt.close(fig)\n\n    Loading settings from a file::\n\n         with mpl.rc_context(fname='print.rc'):\n             plt.plot(x, y)  # uses 'print.rc'\n\n    \"\"\"\n    orig = rcParams.copy()\n    # Store the original backend state to prevent side effects during context exit\n    orig_backend_module = sys.modules.get('matplotlib.backends', None)\n    orig_backend_mod = getattr(orig_backend_module, '_backend_mod', None) if orig_backend_module else None\n    \n    try:\n        if fname:\n            rc_file(fname)\n        if rc:\n            rcParams.update(rc)\n        yield\n    finally:\n        # Restore backend module state before updating rcParams to prevent\n        # backend switching side effects during context cleanup\n        if orig_backend_module and hasattr(orig_backend_module, '_backend_mod'):\n            orig_backend_module._backend_mod = orig_backend_mod\n        dict.update(rcParams, orig)  # Revert to the original rcs.\n",
      "\n@contextlib.contextmanager\ndef rc_context(rc=None, fname=None):\n    \"\"\"\n    Return a context manager for temporarily changing rcParams.\n\n    Parameters\n    ----------\n    rc : dict\n        The rcParams to temporarily set.\n    fname : str or path-like\n        A file with Matplotlib rc settings. If both *fname* and *rc* are given,\n        settings from *rc* take precedence.\n\n    See Also\n    --------\n    :ref:`customizing-with-matplotlibrc-files`\n\n    Examples\n    --------\n    Passing explicit values via a dict::\n\n        with mpl.rc_context({'interactive': False}):\n            fig, ax = plt.subplots()\n            ax.plot(range(3), range(3))\n            fig.savefig('example.png')\n            plt.close(fig)\n\n    Loading settings from a file::\n\n         with mpl.rc_context(fname='print.rc'):\n             plt.plot(x, y)  # uses 'print.rc'\n\n    \"\"\"\n    orig = rcParams.copy()\n    # Store the original backend state to prevent inconsistencies\n    orig_backend_or_none = rcParams._get_backend_or_none()\n    try:\n        if fname:\n            rc_file(fname)\n        if rc:\n            rcParams.update(rc)\n        yield\n    finally:\n        # Restore original state more carefully to prevent backend switching\n        dict.update(rcParams, orig)\n        # Ensure backend state consistency is maintained\n        if orig_backend_or_none is None:\n            rcParams._set_backend_or_none(None)\n",
      "\n@contextlib.contextmanager\ndef rc_context(rc=None, fname=None):\n    \"\"\"\n    Return a context manager for temporarily changing rcParams.\n\n    Parameters\n    ----------\n    rc : dict\n        The rcParams to temporarily set.\n    fname : str or path-like\n        A file with Matplotlib rc settings. If both *fname* and *rc* are given,\n        settings from *rc* take precedence.\n\n    See Also\n    --------\n    :ref:`customizing-with-matplotlibrc-files`\n\n    Examples\n    --------\n    Passing explicit values via a dict::\n\n        with mpl.rc_context({'interactive': False}):\n            fig, ax = plt.subplots()\n            ax.plot(range(3), range(3))\n            fig.savefig('example.png')\n            plt.close(fig)\n\n    Loading settings from a file::\n\n         with mpl.rc_context(fname='print.rc'):\n             plt.plot(x, y)  # uses 'print.rc'\n\n    \"\"\"\n    # Store original rcParams state including backend resolution state\n    orig = rcParams.copy()\n    orig_backend_or_none = rcParams._get_backend_or_none()\n    try:\n        if fname:\n            rc_file(fname)\n        if rc:\n            rcParams.update(rc)\n        yield\n    finally:\n        # Restore original state without triggering backend switching\n        dict.clear(rcParams)\n        dict.update(rcParams, orig)\n        # Restore backend resolution state to prevent inconsistencies\n        if orig_backend_or_none is None and 'backend' in orig:\n            rcParams._set_backend_or_none(None)\n",
      "\n@contextlib.contextmanager\ndef rc_context(rc=None, fname=None):\n    \"\"\"\n    Return a context manager for temporarily changing rcParams.\n\n    Parameters\n    ----------\n    rc : dict\n        The rcParams to temporarily set.\n    fname : str or path-like\n        A file with Matplotlib rc settings. If both *fname* and *rc* are given,\n        settings from *rc* take precedence.\n\n    See Also\n    --------\n    :ref:`customizing-with-matplotlibrc-files`\n\n    Examples\n    --------\n    Passing explicit values via a dict::\n\n        with mpl.rc_context({'interactive': False}):\n            fig, ax = plt.subplots()\n            ax.plot(range(3), range(3))\n            fig.savefig('example.png')\n            plt.close(fig)\n\n    Loading settings from a file::\n\n         with mpl.rc_context(fname='print.rc'):\n             plt.plot(x, y)  # uses 'print.rc'\n\n    \"\"\"\n    # Store the original rcParams state, including any backend auto-detection state\n    orig = rcParams.copy()\n    orig_backend_fallback = getattr(rcParams, '_backend_fallback', None)\n    \n    try:\n        if fname:\n            rc_file(fname)\n        if rc:\n            rcParams.update(rc)\n        yield\n    finally:\n        # Clear rcParams and restore original state completely\n        rcParams.clear()\n        rcParams.update(orig)\n        # Restore backend auto-detection state if it existed\n        if orig_backend_fallback is not None:\n            rcParams._backend_fallback = orig_backend_fallback\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex c268a56724..25484a5bac 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -678,6 +678,7 @@ class RcParams(MutableMapping, dict):\n \n         return dict.__getitem__(self, key)\n \n+\n     def _get_backend_or_none(self):\n         \"\"\"Get the requested backend, if any, without triggering resolution.\"\"\"\n         backend = dict.__getitem__(self, \"backend\")\n@@ -1054,6 +1055,7 @@ def rc_file(fname, *, use_default_template=True):\n                          if k not in STYLE_BLACKLIST})\n \n \n+\n @contextlib.contextmanager\n def rc_context(rc=None, fname=None):\n     \"\"\"\n@@ -1135,6 +1137,7 @@ def use(backend, *, force=True):\n     \"\"\"\n     name = validate_backend(backend)\n     # don't (prematurely) resolve the \"auto\" backend setting\n+\n     if rcParams._get_backend_or_none() == name:\n         # Nothing to do if the requested backend is already set\n         pass\n@@ -1167,6 +1170,7 @@ if os.environ.get('MPLBACKEND'):\n     rcParams['backend'] = os.environ.get('MPLBACKEND')\n \n \n+\n def get_backend():\n     \"\"\"\n     Return the name of the current backend.\n@@ -1175,7 +1179,20 @@ def get_backend():\n     --------\n     matplotlib.use\n     \"\"\"\n-    return rcParams['backend']\n+    # Use side-effect-free access to avoid triggering backend switching\n+    # when the backend is in auto-detection state\n+    backend = rcParams._get_backend_or_none()\n+    if backend is None:\n+        # If backend is auto-sentinel, we need to resolve it, but we should\n+        # do so without triggering figure clearing\n+        backend = dict.__getitem__(rcParams, \"backend\")\n+        if backend is rcsetup._auto_backend_sentinel:\n+            # Import here to avoid circular imports\n+            from matplotlib import pyplot as plt\n+            # Get the resolved backend without switching\n+            plt._get_backend_mod()\n+            backend = dict.__getitem__(rcParams, \"backend\")\n+    return backend\n \n \n def interactive(b):\ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex e3c66ea67c..4d0a1ee7ce 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -206,6 +206,7 @@ def _get_backend_mod():\n     return _backend_mod\n \n \n+\n def switch_backend(newbackend):\n     \"\"\"\n     Close all open figures and set the Matplotlib backend.\n",
    "variant_0": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex c268a56724..b50224a516 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -678,6 +678,7 @@ class RcParams(MutableMapping, dict):\n \n         return dict.__getitem__(self, key)\n \n+\n     def _get_backend_or_none(self):\n         \"\"\"Get the requested backend, if any, without triggering resolution.\"\"\"\n         backend = dict.__getitem__(self, \"backend\")\n@@ -1054,6 +1055,7 @@ def rc_file(fname, *, use_default_template=True):\n                          if k not in STYLE_BLACKLIST})\n \n \n+\n @contextlib.contextmanager\n def rc_context(rc=None, fname=None):\n     \"\"\"\n@@ -1087,6 +1089,8 @@ def rc_context(rc=None, fname=None):\n              plt.plot(x, y)  # uses 'print.rc'\n \n     \"\"\"\n+    # Store the original backend state to avoid inconsistencies\n+    orig_backend = rcParams._get_backend_or_none()\n     orig = rcParams.copy()\n     try:\n         if fname:\n@@ -1095,7 +1099,12 @@ def rc_context(rc=None, fname=None):\n             rcParams.update(rc)\n         yield\n     finally:\n-        dict.update(rcParams, orig)  # Revert to the original rcs.\n+        # Restore original state without triggering backend switching\n+        rcParams.clear()\n+        rcParams.update(orig)\n+        # Explicitly restore backend state if it was set\n+        if orig_backend is not None:\n+            rcParams._set_backend_or_none(orig_backend)\n \n \n def use(backend, *, force=True):\n@@ -1135,21 +1144,22 @@ def use(backend, *, force=True):\n     \"\"\"\n     name = validate_backend(backend)\n     # don't (prematurely) resolve the \"auto\" backend setting\n-    if rcParams._get_backend_or_none() == name:\n-        # Nothing to do if the requested backend is already set\n-        pass\n-    else:\n-        # if pyplot is not already imported, do not import it.  Doing\n-        # so may trigger a `plt.switch_backend` to the _default_ backend\n-        # before we get a chance to change to the one the user just requested\n-        plt = sys.modules.get('matplotlib.pyplot')\n-        # if pyplot is imported, then try to change backends\n-        if plt is not None:\n-            try:\n-                # we need this import check here to re-raise if the\n-                # user does not have the libraries to support their\n-                # chosen backend installed.\n-                plt.switch_backend(name)\n+\n+def get_backend():\n+    \"\"\"\n+    Return the name of the current backend.\n+\n+    See Also\n+    --------\n+    matplotlib.use\n+    \"\"\"\n+    # Use _get_backend_or_none() to avoid triggering backend resolution\n+    # which can cause unwanted side effects like figure clearing\n+    backend = rcParams._get_backend_or_none()\n+    if backend is None:\n+        # If backend is not set, return the default without triggering resolution\n+        return rcsetup._auto_backend_sentinel\n+    return backend\n             except ImportError:\n                 if force:\n                     raise\n@@ -1167,6 +1177,7 @@ if os.environ.get('MPLBACKEND'):\n     rcParams['backend'] = os.environ.get('MPLBACKEND')\n \n \n+\n def get_backend():\n     \"\"\"\n     Return the name of the current backend.\n@@ -1175,7 +1186,15 @@ def get_backend():\n     --------\n     matplotlib.use\n     \"\"\"\n-    return rcParams['backend']\n+    # Use _get_backend_or_none to avoid triggering backend resolution\n+    # which can cause side effects like clearing figures\n+    backend = rcParams._get_backend_or_none()\n+    if backend is not None:\n+        return backend\n+    \n+    # If no backend is set, return the default without triggering resolution\n+    # This prevents the cascade of backend switching that clears figures\n+    return rcsetup._auto_backend_sentinel\n \n \n def interactive(b):\ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex e3c66ea67c..6ad4cde831 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -206,23 +206,29 @@ def _get_backend_mod():\n     return _backend_mod\n \n \n-def switch_backend(newbackend):\n-    \"\"\"\n-    Close all open figures and set the Matplotlib backend.\n-\n-    The argument is case-insensitive.  Switching to an interactive backend is\n-    possible only if no event loop for another interactive backend has started.\n-    Switching to and from non-interactive backends is always possible.\n \n-    Parameters\n-    ----------\n-    newbackend : str\n-        The name of the backend to use.\n+def get_backend():\n     \"\"\"\n-    global _backend_mod\n-    # make sure the init is pulled up so we can assign to it later\n-    import matplotlib.backends\n-    close(\"all\")\n+    Return the name of the current backend.\n+\n+    See Also\n+    --------\n+    matplotlib.use\n+    \"\"\"\n+    # Use _get_backend_or_none to avoid triggering backend resolution\n+    # and potential figure clearing in pyplot.switch_backend\n+    backend = _get_backend_or_none()\n+    if backend is not None:\n+        return backend\n+    \n+    # If backend is None, we need to resolve it, but do so carefully\n+    # to avoid triggering pyplot.switch_backend unnecessarily\n+    if rcParams['backend'] is rcsetup._auto_backend_sentinel:\n+        # Let the normal resolution happen through rcParams access\n+        return rcParams['backend']\n+    else:\n+        # Backend is explicitly set, return it directly\n+        return rcParams['backend']\n \n     if newbackend is rcsetup._auto_backend_sentinel:\n         current_framework = cbook._get_running_interactive_framework()\n",
    "variant_1": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex c268a56724..d85587f00a 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -678,6 +678,7 @@ class RcParams(MutableMapping, dict):\n \n         return dict.__getitem__(self, key)\n \n+\n     def _get_backend_or_none(self):\n         \"\"\"Get the requested backend, if any, without triggering resolution.\"\"\"\n         backend = dict.__getitem__(self, \"backend\")\n@@ -1054,6 +1055,7 @@ def rc_file(fname, *, use_default_template=True):\n                          if k not in STYLE_BLACKLIST})\n \n \n+\n @contextlib.contextmanager\n def rc_context(rc=None, fname=None):\n     \"\"\"\n@@ -1088,6 +1090,8 @@ def rc_context(rc=None, fname=None):\n \n     \"\"\"\n     orig = rcParams.copy()\n+    # Store the original backend state to avoid inconsistencies\n+    orig_backend_or_none = rcParams._get_backend_or_none()\n     try:\n         if fname:\n             rc_file(fname)\n@@ -1096,6 +1100,9 @@ def rc_context(rc=None, fname=None):\n         yield\n     finally:\n         dict.update(rcParams, orig)  # Revert to the original rcs.\n+        # Restore the original backend state if it was None\n+        if orig_backend_or_none is None:\n+            rcParams._set_backend_or_none(None)\n \n \n def use(backend, *, force=True):\n@@ -1135,21 +1142,25 @@ def use(backend, *, force=True):\n     \"\"\"\n     name = validate_backend(backend)\n     # don't (prematurely) resolve the \"auto\" backend setting\n-    if rcParams._get_backend_or_none() == name:\n-        # Nothing to do if the requested backend is already set\n-        pass\n-    else:\n-        # if pyplot is not already imported, do not import it.  Doing\n-        # so may trigger a `plt.switch_backend` to the _default_ backend\n-        # before we get a chance to change to the one the user just requested\n-        plt = sys.modules.get('matplotlib.pyplot')\n-        # if pyplot is imported, then try to change backends\n-        if plt is not None:\n-            try:\n-                # we need this import check here to re-raise if the\n-                # user does not have the libraries to support their\n-                # chosen backend installed.\n-                plt.switch_backend(name)\n+\n+def get_backend():\n+    \"\"\"\n+    Return the name of the current backend.\n+\n+    See Also\n+    --------\n+    matplotlib.use\n+    \"\"\"\n+    # Use _get_backend_or_none to avoid triggering backend resolution\n+    # which can cause side effects like figure clearing\n+    backend = rcParams._get_backend_or_none()\n+    if backend is not None:\n+        return backend\n+    \n+    # If backend is None (auto), we need to resolve it but do so carefully\n+    # to avoid triggering unnecessary backend switching\n+    current_backend = rcParams['backend']\n+    return current_backend\n             except ImportError:\n                 if force:\n                     raise\n@@ -1167,6 +1178,7 @@ if os.environ.get('MPLBACKEND'):\n     rcParams['backend'] = os.environ.get('MPLBACKEND')\n \n \n+\n def get_backend():\n     \"\"\"\n     Return the name of the current backend.\n@@ -1175,7 +1187,13 @@ def get_backend():\n     --------\n     matplotlib.use\n     \"\"\"\n-    return rcParams['backend']\n+    # Use _get_backend_or_none() to avoid triggering backend resolution\n+    # which can cause side effects like clearing figures\n+    backend = rcParams._get_backend_or_none()\n+    if backend is not None:\n+        return backend\n+    # If backend is None, fall back to the default without triggering resolution\n+    return rcParams._get_backend_or_none() or rcsetup._auto_backend_sentinel\n \n \n def interactive(b):\ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex e3c66ea67c..ab28fc4d45 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -206,23 +206,34 @@ def _get_backend_mod():\n     return _backend_mod\n \n \n-def switch_backend(newbackend):\n-    \"\"\"\n-    Close all open figures and set the Matplotlib backend.\n-\n-    The argument is case-insensitive.  Switching to an interactive backend is\n-    possible only if no event loop for another interactive backend has started.\n-    Switching to and from non-interactive backends is always possible.\n \n-    Parameters\n-    ----------\n-    newbackend : str\n-        The name of the backend to use.\n+def get_backend():\n     \"\"\"\n-    global _backend_mod\n-    # make sure the init is pulled up so we can assign to it later\n-    import matplotlib.backends\n-    close(\"all\")\n+    Return the name of the current backend.\n+\n+    See Also\n+    --------\n+    matplotlib.use\n+    \"\"\"\n+    # Use _get_backend_or_none() to avoid triggering backend resolution\n+    # which can cause unwanted side effects like closing figures\n+    backend = _get_backend_or_none()\n+    if backend is not None:\n+        return backend\n+    \n+    # Only resolve backend if absolutely necessary and no backend module exists\n+    if _backend_mod is None:\n+        # Use dict.__getitem__ to avoid fallback logic that could trigger pyplot import\n+        backend = dict.__getitem__(rcParams, \"backend\")\n+        if backend is not rcsetup._auto_backend_sentinel:\n+            return backend\n+    \n+    # If we have a backend module, return its name\n+    if _backend_mod is not None:\n+        return _backend_mod.__name__[len(\"matplotlib.backends.\"):]\n+    \n+    # Final fallback - return the rcParam value directly\n+    return rcParams[\"backend\"]\n \n     if newbackend is rcsetup._auto_backend_sentinel:\n         current_framework = cbook._get_running_interactive_framework()\n",
    "variant_2": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex c268a56724..f9539159b5 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -678,10 +678,28 @@ class RcParams(MutableMapping, dict):\n \n         return dict.__getitem__(self, key)\n \n-    def _get_backend_or_none(self):\n-        \"\"\"Get the requested backend, if any, without triggering resolution.\"\"\"\n-        backend = dict.__getitem__(self, \"backend\")\n-        return None if backend is rcsetup._auto_backend_sentinel else backend\n+\n+def get_backend():\n+    \"\"\"\n+    Return the name of the current backend.\n+\n+    See Also\n+    --------\n+    matplotlib.use\n+    \"\"\"\n+    # Use _get_backend_or_none to avoid triggering backend resolution\n+    backend = rcParams._get_backend_or_none()\n+    if backend is None:\n+        # If backend is auto-sentinel, get the actual backend without side effects\n+        # by temporarily accessing the resolved value\n+        from matplotlib import pyplot as plt\n+        # Get the current backend without triggering switch_backend\n+        if hasattr(plt.get_backend, '_called'):\n+            return plt.get_backend()\n+        else:\n+            # Fallback to direct access if pyplot backend is already resolved\n+            return dict.__getitem__(rcParams, \"backend\")\n+    return backend\n \n     def __repr__(self):\n         class_name = self.__class__.__name__\n@@ -1054,6 +1072,7 @@ def rc_file(fname, *, use_default_template=True):\n                          if k not in STYLE_BLACKLIST})\n \n \n+\n @contextlib.contextmanager\n def rc_context(rc=None, fname=None):\n     \"\"\"\n@@ -1088,6 +1107,8 @@ def rc_context(rc=None, fname=None):\n \n     \"\"\"\n     orig = rcParams.copy()\n+    # Store the original backend state to prevent inconsistencies\n+    orig_backend_fallback = getattr(rcParams, '_backend_fallback', None)\n     try:\n         if fname:\n             rc_file(fname)\n@@ -1095,6 +1116,9 @@ def rc_context(rc=None, fname=None):\n             rcParams.update(rc)\n         yield\n     finally:\n+        # Restore original backend state before updating rcParams\n+        if hasattr(rcParams, '_backend_fallback'):\n+            rcParams._backend_fallback = orig_backend_fallback\n         dict.update(rcParams, orig)  # Revert to the original rcs.\n \n \n@@ -1135,21 +1159,24 @@ def use(backend, *, force=True):\n     \"\"\"\n     name = validate_backend(backend)\n     # don't (prematurely) resolve the \"auto\" backend setting\n-    if rcParams._get_backend_or_none() == name:\n-        # Nothing to do if the requested backend is already set\n-        pass\n-    else:\n-        # if pyplot is not already imported, do not import it.  Doing\n-        # so may trigger a `plt.switch_backend` to the _default_ backend\n-        # before we get a chance to change to the one the user just requested\n-        plt = sys.modules.get('matplotlib.pyplot')\n-        # if pyplot is imported, then try to change backends\n-        if plt is not None:\n-            try:\n-                # we need this import check here to re-raise if the\n-                # user does not have the libraries to support their\n-                # chosen backend installed.\n-                plt.switch_backend(name)\n+\n+def get_backend():\n+    \"\"\"\n+    Return the name of the current backend.\n+\n+    See Also\n+    --------\n+    matplotlib.use\n+    \"\"\"\n+    # Use _get_backend_or_none to avoid triggering backend resolution\n+    # which can cause unwanted side effects like figure clearing\n+    backend = rcParams._get_backend_or_none()\n+    if backend is None:\n+        # Only resolve backend if absolutely necessary\n+        # This preserves the original behavior while avoiding side effects\n+        # when backend is in auto-detection state\n+        return rcParams['backend']\n+    return backend\n             except ImportError:\n                 if force:\n                     raise\n@@ -1167,6 +1194,7 @@ if os.environ.get('MPLBACKEND'):\n     rcParams['backend'] = os.environ.get('MPLBACKEND')\n \n \n+\n def get_backend():\n     \"\"\"\n     Return the name of the current backend.\n@@ -1175,6 +1203,22 @@ def get_backend():\n     --------\n     matplotlib.use\n     \"\"\"\n+    # Use _get_backend_or_none() to avoid triggering backend resolution\n+    # which can cause side effects like closing figures\n+    backend = rcParams._get_backend_or_none()\n+    if backend is not None:\n+        return backend\n+    \n+    # If backend is None, we need to resolve it, but we should do so\n+    # without triggering the full backend switching machinery\n+    # that can close existing figures\n+    from matplotlib import pyplot as plt\n+    if hasattr(plt, '_backend_mod') and plt._backend_mod is not None:\n+        # If pyplot already has a backend loaded, use that\n+        return plt._backend_mod.__name__.split('.')[-1]\n+    \n+    # Fall back to the rcParams value, which will trigger resolution\n+    # This is the original behavior as a last resort\n     return rcParams['backend']\n \n \ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex e3c66ea67c..cfcbdba0b3 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -206,23 +206,25 @@ def _get_backend_mod():\n     return _backend_mod\n \n \n-def switch_backend(newbackend):\n-    \"\"\"\n-    Close all open figures and set the Matplotlib backend.\n-\n-    The argument is case-insensitive.  Switching to an interactive backend is\n-    possible only if no event loop for another interactive backend has started.\n-    Switching to and from non-interactive backends is always possible.\n \n-    Parameters\n-    ----------\n-    newbackend : str\n-        The name of the backend to use.\n+def get_backend():\n     \"\"\"\n-    global _backend_mod\n-    # make sure the init is pulled up so we can assign to it later\n-    import matplotlib.backends\n-    close(\"all\")\n+    Return the name of the current backend.\n+\n+    See Also\n+    --------\n+    matplotlib.use\n+    \"\"\"\n+    # Use _get_backend_or_none() to avoid triggering backend resolution\n+    # which can cause unwanted side effects like closing figures\n+    backend = _get_backend_or_none()\n+    if backend is not None:\n+        return backend\n+    \n+    # Only if backend is truly None, fall back to rcParams access\n+    # This preserves the original behavior for cases where backend\n+    # resolution is actually needed\n+    return rcParams['backend']\n \n     if newbackend is rcsetup._auto_backend_sentinel:\n         current_framework = cbook._get_running_interactive_framework()\n",
    "variant_3": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex c268a56724..d391fe255c 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -678,10 +678,22 @@ class RcParams(MutableMapping, dict):\n \n         return dict.__getitem__(self, key)\n \n-    def _get_backend_or_none(self):\n-        \"\"\"Get the requested backend, if any, without triggering resolution.\"\"\"\n-        backend = dict.__getitem__(self, \"backend\")\n-        return None if backend is rcsetup._auto_backend_sentinel else backend\n+\n+    def get_backend():\n+        \"\"\"\n+        Return the name of the current backend.\n+\n+        See Also\n+        --------\n+        matplotlib.use\n+        \"\"\"\n+        # Use _get_backend_or_none to avoid triggering backend resolution\n+        # which can cause side effects like figure clearing\n+        backend = rcParams._get_backend_or_none()\n+        if backend is None:\n+            # Only trigger resolution if we absolutely need to\n+            return rcParams['backend']\n+        return backend\n \n     def __repr__(self):\n         class_name = self.__class__.__name__\n@@ -1054,6 +1066,7 @@ def rc_file(fname, *, use_default_template=True):\n                          if k not in STYLE_BLACKLIST})\n \n \n+\n @contextlib.contextmanager\n def rc_context(rc=None, fname=None):\n     \"\"\"\n@@ -1095,7 +1108,10 @@ def rc_context(rc=None, fname=None):\n             rcParams.update(rc)\n         yield\n     finally:\n-        dict.update(rcParams, orig)  # Revert to the original rcs.\n+        # Clear the dict first, then update with original values to ensure\n+        # proper restoration and avoid triggering backend switching\n+        rcParams.clear()\n+        rcParams.update(orig)\n \n \n def use(backend, *, force=True):\n@@ -1135,21 +1151,23 @@ def use(backend, *, force=True):\n     \"\"\"\n     name = validate_backend(backend)\n     # don't (prematurely) resolve the \"auto\" backend setting\n-    if rcParams._get_backend_or_none() == name:\n-        # Nothing to do if the requested backend is already set\n-        pass\n-    else:\n-        # if pyplot is not already imported, do not import it.  Doing\n-        # so may trigger a `plt.switch_backend` to the _default_ backend\n-        # before we get a chance to change to the one the user just requested\n-        plt = sys.modules.get('matplotlib.pyplot')\n-        # if pyplot is imported, then try to change backends\n-        if plt is not None:\n-            try:\n-                # we need this import check here to re-raise if the\n-                # user does not have the libraries to support their\n-                # chosen backend installed.\n-                plt.switch_backend(name)\n+\n+def get_backend():\n+    \"\"\"\n+    Return the name of the current backend.\n+\n+    See Also\n+    --------\n+    matplotlib.use\n+    \"\"\"\n+    # Use _get_backend_or_none() to avoid triggering backend resolution\n+    # which can cause unwanted side effects like figure clearing\n+    backend = rcParams._get_backend_or_none()\n+    if backend is None:\n+        # If backend is still None (auto-detection state), \n+        # we need to resolve it, but do so carefully\n+        backend = rcParams['backend']\n+    return backend\n             except ImportError:\n                 if force:\n                     raise\n@@ -1167,6 +1185,7 @@ if os.environ.get('MPLBACKEND'):\n     rcParams['backend'] = os.environ.get('MPLBACKEND')\n \n \n+\n def get_backend():\n     \"\"\"\n     Return the name of the current backend.\n@@ -1175,7 +1194,7 @@ def get_backend():\n     --------\n     matplotlib.use\n     \"\"\"\n-    return rcParams['backend']\n+    return rcParams._get_backend_or_none() or 'Agg'\n \n \n def interactive(b):\ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex e3c66ea67c..c44c80f403 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -206,23 +206,24 @@ def _get_backend_mod():\n     return _backend_mod\n \n \n-def switch_backend(newbackend):\n-    \"\"\"\n-    Close all open figures and set the Matplotlib backend.\n-\n-    The argument is case-insensitive.  Switching to an interactive backend is\n-    possible only if no event loop for another interactive backend has started.\n-    Switching to and from non-interactive backends is always possible.\n \n-    Parameters\n-    ----------\n-    newbackend : str\n-        The name of the backend to use.\n+def get_backend():\n     \"\"\"\n-    global _backend_mod\n-    # make sure the init is pulled up so we can assign to it later\n-    import matplotlib.backends\n-    close(\"all\")\n+    Return the name of the current backend.\n+\n+    See Also\n+    --------\n+    matplotlib.use\n+    \"\"\"\n+    # Use _get_backend_or_none to avoid triggering backend resolution\n+    # which can cause unwanted side effects like clearing figures\n+    backend = _get_backend_or_none()\n+    if backend is not None:\n+        return backend\n+    \n+    # Only fall back to rcParams access if no backend is set\n+    # This avoids the auto-resolution cascade that can clear figures\n+    return rcParams.get(\"backend\", rcsetup._auto_backend_sentinel)\n \n     if newbackend is rcsetup._auto_backend_sentinel:\n         current_framework = cbook._get_running_interactive_framework()\n",
    "variant_4": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex c268a56724..5e61853497 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -678,10 +678,26 @@ class RcParams(MutableMapping, dict):\n \n         return dict.__getitem__(self, key)\n \n-    def _get_backend_or_none(self):\n-        \"\"\"Get the requested backend, if any, without triggering resolution.\"\"\"\n-        backend = dict.__getitem__(self, \"backend\")\n-        return None if backend is rcsetup._auto_backend_sentinel else backend\n+\n+def get_backend():\n+    \"\"\"\n+    Return the name of the current backend.\n+\n+    See Also\n+    --------\n+    matplotlib.use\n+    \"\"\"\n+    # Use _get_backend_or_none to avoid triggering backend resolution\n+    backend = rcParams._get_backend_or_none()\n+    if backend is None:\n+        # If backend is still auto-sentinel, resolve it without side effects\n+        # by accessing the resolved backend from pyplot if it exists\n+        import matplotlib.pyplot as plt\n+        if hasattr(plt, '_backend_mod') and plt._backend_mod is not None:\n+            return plt.get_backend()\n+        # Fall back to the sentinel value to avoid triggering resolution\n+        return rcsetup._auto_backend_sentinel\n+    return backend\n \n     def __repr__(self):\n         class_name = self.__class__.__name__\n@@ -1054,6 +1070,7 @@ def rc_file(fname, *, use_default_template=True):\n                          if k not in STYLE_BLACKLIST})\n \n \n+\n @contextlib.contextmanager\n def rc_context(rc=None, fname=None):\n     \"\"\"\n@@ -1095,7 +1112,13 @@ def rc_context(rc=None, fname=None):\n             rcParams.update(rc)\n         yield\n     finally:\n+        # Preserve backend state to avoid triggering unwanted backend switches\n+        current_backend = rcParams.get('backend', None)\n         dict.update(rcParams, orig)  # Revert to the original rcs.\n+        # If the backend was explicitly set during the context and differs\n+        # from the original, maintain the current backend to avoid side effects\n+        if current_backend and current_backend != orig.get('backend'):\n+            rcParams['backend'] = current_backend\n \n \n def use(backend, *, force=True):\n@@ -1135,21 +1158,23 @@ def use(backend, *, force=True):\n     \"\"\"\n     name = validate_backend(backend)\n     # don't (prematurely) resolve the \"auto\" backend setting\n-    if rcParams._get_backend_or_none() == name:\n-        # Nothing to do if the requested backend is already set\n-        pass\n-    else:\n-        # if pyplot is not already imported, do not import it.  Doing\n-        # so may trigger a `plt.switch_backend` to the _default_ backend\n-        # before we get a chance to change to the one the user just requested\n-        plt = sys.modules.get('matplotlib.pyplot')\n-        # if pyplot is imported, then try to change backends\n-        if plt is not None:\n-            try:\n-                # we need this import check here to re-raise if the\n-                # user does not have the libraries to support their\n-                # chosen backend installed.\n-                plt.switch_backend(name)\n+\n+def get_backend():\n+    \"\"\"\n+    Return the name of the current backend.\n+\n+    See Also\n+    --------\n+    matplotlib.use\n+    \"\"\"\n+    # Use _get_backend_or_none to avoid triggering backend resolution\n+    # which can cause side effects like figure clearing\n+    backend = rcParams._get_backend_or_none()\n+    if backend is None:\n+        # If no backend is explicitly set, return the default\n+        # without triggering resolution\n+        return rcsetup._auto_backend_sentinel\n+    return backend\n             except ImportError:\n                 if force:\n                     raise\n@@ -1167,6 +1192,7 @@ if os.environ.get('MPLBACKEND'):\n     rcParams['backend'] = os.environ.get('MPLBACKEND')\n \n \n+\n def get_backend():\n     \"\"\"\n     Return the name of the current backend.\n@@ -1175,6 +1201,13 @@ def get_backend():\n     --------\n     matplotlib.use\n     \"\"\"\n+    # Use _get_backend_or_none() to avoid triggering backend resolution\n+    # which can cause figure clearing in certain contexts\n+    backend = rcParams._get_backend_or_none()\n+    if backend is not None:\n+        return backend\n+    # If backend is None, we need to resolve it, but do so carefully\n+    # to avoid side effects during context manager operations\n     return rcParams['backend']\n \n \ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex e3c66ea67c..1f4d0d36c3 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -206,23 +206,25 @@ def _get_backend_mod():\n     return _backend_mod\n \n \n-def switch_backend(newbackend):\n-    \"\"\"\n-    Close all open figures and set the Matplotlib backend.\n-\n-    The argument is case-insensitive.  Switching to an interactive backend is\n-    possible only if no event loop for another interactive backend has started.\n-    Switching to and from non-interactive backends is always possible.\n \n-    Parameters\n-    ----------\n-    newbackend : str\n-        The name of the backend to use.\n+def get_backend():\n     \"\"\"\n-    global _backend_mod\n-    # make sure the init is pulled up so we can assign to it later\n-    import matplotlib.backends\n-    close(\"all\")\n+    Return the name of the current backend.\n+\n+    See Also\n+    --------\n+    matplotlib.use\n+    \"\"\"\n+    # Use _get_backend_or_none() to avoid triggering backend resolution\n+    # which can cause unwanted side effects like clearing figures\n+    backend = _get_backend_or_none()\n+    if backend is not None:\n+        return backend\n+    \n+    # Only fall back to rcParams access if we don't have a backend yet\n+    # This preserves the original behavior while avoiding side effects\n+    # when the backend is in an auto-detection state\n+    return rcParams['backend']\n \n     if newbackend is rcsetup._auto_backend_sentinel:\n         current_framework = cbook._get_running_interactive_framework()\n",
    "variant_5": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex c268a56724..2c46e63e09 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -678,10 +678,22 @@ class RcParams(MutableMapping, dict):\n \n         return dict.__getitem__(self, key)\n \n-    def _get_backend_or_none(self):\n-        \"\"\"Get the requested backend, if any, without triggering resolution.\"\"\"\n-        backend = dict.__getitem__(self, \"backend\")\n-        return None if backend is rcsetup._auto_backend_sentinel else backend\n+\n+def get_backend():\n+    \"\"\"\n+    Return the name of the current backend.\n+\n+    See Also\n+    --------\n+    matplotlib.use\n+    \"\"\"\n+    # Use _get_backend_or_none to avoid triggering backend resolution\n+    backend = rcParams._get_backend_or_none()\n+    if backend is None:\n+        # Only resolve backend if we absolutely need to, but avoid side effects\n+        # by checking if we're in a context where resolution is safe\n+        return rcsetup._auto_backend_sentinel\n+    return backend\n \n     def __repr__(self):\n         class_name = self.__class__.__name__\n@@ -1054,6 +1066,7 @@ def rc_file(fname, *, use_default_template=True):\n                          if k not in STYLE_BLACKLIST})\n \n \n+\n @contextlib.contextmanager\n def rc_context(rc=None, fname=None):\n     \"\"\"\n@@ -1088,6 +1101,10 @@ def rc_context(rc=None, fname=None):\n \n     \"\"\"\n     orig = rcParams.copy()\n+    # Store the original backend state to prevent side effects during context exit\n+    orig_backend_module = sys.modules.get('matplotlib.backends', None)\n+    orig_backend_mod = getattr(orig_backend_module, '_backend_mod', None) if orig_backend_module else None\n+    \n     try:\n         if fname:\n             rc_file(fname)\n@@ -1095,6 +1112,10 @@ def rc_context(rc=None, fname=None):\n             rcParams.update(rc)\n         yield\n     finally:\n+        # Restore backend module state before updating rcParams to prevent\n+        # backend switching side effects during context cleanup\n+        if orig_backend_module and hasattr(orig_backend_module, '_backend_mod'):\n+            orig_backend_module._backend_mod = orig_backend_mod\n         dict.update(rcParams, orig)  # Revert to the original rcs.\n \n \n@@ -1135,21 +1156,23 @@ def use(backend, *, force=True):\n     \"\"\"\n     name = validate_backend(backend)\n     # don't (prematurely) resolve the \"auto\" backend setting\n-    if rcParams._get_backend_or_none() == name:\n-        # Nothing to do if the requested backend is already set\n-        pass\n-    else:\n-        # if pyplot is not already imported, do not import it.  Doing\n-        # so may trigger a `plt.switch_backend` to the _default_ backend\n-        # before we get a chance to change to the one the user just requested\n-        plt = sys.modules.get('matplotlib.pyplot')\n-        # if pyplot is imported, then try to change backends\n-        if plt is not None:\n-            try:\n-                # we need this import check here to re-raise if the\n-                # user does not have the libraries to support their\n-                # chosen backend installed.\n-                plt.switch_backend(name)\n+\n+def get_backend():\n+    \"\"\"\n+    Return the name of the current backend.\n+\n+    See Also\n+    --------\n+    matplotlib.use\n+    \"\"\"\n+    # Use _get_backend_or_none() to avoid triggering backend resolution\n+    # which can cause side effects like closing figures\n+    backend = rcParams._get_backend_or_none()\n+    if backend is None:\n+        # Only resolve backend if absolutely necessary\n+        # This maintains backward compatibility while avoiding side effects\n+        backend = rcParams['backend']\n+    return backend\n             except ImportError:\n                 if force:\n                     raise\n@@ -1167,6 +1190,7 @@ if os.environ.get('MPLBACKEND'):\n     rcParams['backend'] = os.environ.get('MPLBACKEND')\n \n \n+\n def get_backend():\n     \"\"\"\n     Return the name of the current backend.\n@@ -1175,7 +1199,15 @@ def get_backend():\n     --------\n     matplotlib.use\n     \"\"\"\n-    return rcParams['backend']\n+    # Use _get_backend_or_none to avoid triggering backend resolution\n+    # which can cause unwanted side effects like clearing figures\n+    backend = rcParams._get_backend_or_none()\n+    if backend is not None:\n+        return backend\n+    \n+    # If no backend is set, return the default without triggering resolution\n+    # This prevents the cascade of backend switching that clears figures\n+    return rcsetup._auto_backend_sentinel\n \n \n def interactive(b):\ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex e3c66ea67c..c993e49eae 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -206,23 +206,30 @@ def _get_backend_mod():\n     return _backend_mod\n \n \n-def switch_backend(newbackend):\n-    \"\"\"\n-    Close all open figures and set the Matplotlib backend.\n-\n-    The argument is case-insensitive.  Switching to an interactive backend is\n-    possible only if no event loop for another interactive backend has started.\n-    Switching to and from non-interactive backends is always possible.\n \n-    Parameters\n-    ----------\n-    newbackend : str\n-        The name of the backend to use.\n+def get_backend():\n     \"\"\"\n-    global _backend_mod\n-    # make sure the init is pulled up so we can assign to it later\n-    import matplotlib.backends\n-    close(\"all\")\n+    Return the name of the current backend.\n+\n+    See Also\n+    --------\n+    matplotlib.use\n+    \"\"\"\n+    # Use _get_backend_or_none() to avoid triggering backend resolution\n+    # which could cause figure clearing side effects\n+    backend = _get_backend_or_none()\n+    if backend is not None:\n+        return backend\n+    \n+    # If backend is None, we need to resolve it, but do so carefully\n+    # to avoid the side effects that come from accessing rcParams['backend']\n+    # during backend resolution\n+    if rcParams['backend'] is rcsetup._auto_backend_sentinel:\n+        # Let the backend resolution happen through normal channels\n+        # but don't trigger it ourselves\n+        return str(rcsetup._auto_backend_sentinel)\n+    else:\n+        return rcParams['backend']\n \n     if newbackend is rcsetup._auto_backend_sentinel:\n         current_framework = cbook._get_running_interactive_framework()\n",
    "variant_6": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex c268a56724..f48b3a1839 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -678,6 +678,7 @@ class RcParams(MutableMapping, dict):\n \n         return dict.__getitem__(self, key)\n \n+\n     def _get_backend_or_none(self):\n         \"\"\"Get the requested backend, if any, without triggering resolution.\"\"\"\n         backend = dict.__getitem__(self, \"backend\")\n@@ -1054,6 +1055,7 @@ def rc_file(fname, *, use_default_template=True):\n                          if k not in STYLE_BLACKLIST})\n \n \n+\n @contextlib.contextmanager\n def rc_context(rc=None, fname=None):\n     \"\"\"\n@@ -1088,6 +1090,8 @@ def rc_context(rc=None, fname=None):\n \n     \"\"\"\n     orig = rcParams.copy()\n+    # Store the original backend state to prevent inconsistencies\n+    orig_backend_or_none = rcParams._get_backend_or_none()\n     try:\n         if fname:\n             rc_file(fname)\n@@ -1095,7 +1099,11 @@ def rc_context(rc=None, fname=None):\n             rcParams.update(rc)\n         yield\n     finally:\n-        dict.update(rcParams, orig)  # Revert to the original rcs.\n+        # Restore original state more carefully to prevent backend switching\n+        dict.update(rcParams, orig)\n+        # Ensure backend state consistency is maintained\n+        if orig_backend_or_none is None:\n+            rcParams._set_backend_or_none(None)\n \n \n def use(backend, *, force=True):\n@@ -1135,21 +1143,29 @@ def use(backend, *, force=True):\n     \"\"\"\n     name = validate_backend(backend)\n     # don't (prematurely) resolve the \"auto\" backend setting\n-    if rcParams._get_backend_or_none() == name:\n-        # Nothing to do if the requested backend is already set\n-        pass\n-    else:\n-        # if pyplot is not already imported, do not import it.  Doing\n-        # so may trigger a `plt.switch_backend` to the _default_ backend\n-        # before we get a chance to change to the one the user just requested\n-        plt = sys.modules.get('matplotlib.pyplot')\n-        # if pyplot is imported, then try to change backends\n-        if plt is not None:\n-            try:\n-                # we need this import check here to re-raise if the\n-                # user does not have the libraries to support their\n-                # chosen backend installed.\n-                plt.switch_backend(name)\n+\n+def get_backend():\n+    \"\"\"\n+    Return the name of the current backend.\n+\n+    See Also\n+    --------\n+    :ref:`backends`\n+    matplotlib.use\n+    \"\"\"\n+    # Use _get_backend_or_none() to avoid triggering backend resolution\n+    # which can cause side effects like closing figures\n+    backend = rcParams._get_backend_or_none()\n+    if backend is None:\n+        # If backend is None (auto), we need to resolve it but should do so\n+        # without side effects. Get the default backend without triggering\n+        # the full backend switching machinery.\n+        backend = rcParams._get_backend_or_none() or rcsetup._auto_backend_sentinel\n+        if backend == rcsetup._auto_backend_sentinel:\n+            # Fall back to getting the resolved backend value, but only if\n+            # we absolutely must\n+            backend = rcParams['backend']\n+    return backend\n             except ImportError:\n                 if force:\n                     raise\n@@ -1167,6 +1183,7 @@ if os.environ.get('MPLBACKEND'):\n     rcParams['backend'] = os.environ.get('MPLBACKEND')\n \n \n+\n def get_backend():\n     \"\"\"\n     Return the name of the current backend.\n@@ -1175,7 +1192,13 @@ def get_backend():\n     --------\n     matplotlib.use\n     \"\"\"\n-    return rcParams['backend']\n+    # Use _get_backend_or_none to avoid triggering backend resolution\n+    # which can cause side effects like figure clearing\n+    backend = rcParams._get_backend_or_none()\n+    if backend is not None:\n+        return backend\n+    # If no backend is set, return the default without triggering resolution\n+    return rcParams.get('backend', 'Agg')\n \n \n def interactive(b):\ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex e3c66ea67c..351393d83f 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -206,23 +206,23 @@ def _get_backend_mod():\n     return _backend_mod\n \n \n-def switch_backend(newbackend):\n-    \"\"\"\n-    Close all open figures and set the Matplotlib backend.\n-\n-    The argument is case-insensitive.  Switching to an interactive backend is\n-    possible only if no event loop for another interactive backend has started.\n-    Switching to and from non-interactive backends is always possible.\n \n-    Parameters\n-    ----------\n-    newbackend : str\n-        The name of the backend to use.\n+def get_backend():\n     \"\"\"\n-    global _backend_mod\n-    # make sure the init is pulled up so we can assign to it later\n-    import matplotlib.backends\n-    close(\"all\")\n+    Return the name of the current backend.\n+\n+    See Also\n+    --------\n+    matplotlib.use\n+    \"\"\"\n+    # Use _get_backend_or_none() to avoid triggering backend resolution\n+    # when the backend is in auto-detection state, preventing unwanted\n+    # side effects like figure clearing\n+    backend = _get_backend_or_none()\n+    if backend is None:\n+        # Only resolve backend if absolutely necessary\n+        backend = rcParams['backend']\n+    return backend\n \n     if newbackend is rcsetup._auto_backend_sentinel:\n         current_framework = cbook._get_running_interactive_framework()\n",
    "variant_7": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex c268a56724..6726569727 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -678,10 +678,21 @@ class RcParams(MutableMapping, dict):\n \n         return dict.__getitem__(self, key)\n \n-    def _get_backend_or_none(self):\n-        \"\"\"Get the requested backend, if any, without triggering resolution.\"\"\"\n-        backend = dict.__getitem__(self, \"backend\")\n-        return None if backend is rcsetup._auto_backend_sentinel else backend\n+\n+def get_backend():\n+    \"\"\"\n+    Return the name of the current backend.\n+\n+    See Also\n+    --------\n+    matplotlib.use\n+    \"\"\"\n+    # Use _get_backend_or_none to avoid triggering backend resolution\n+    backend = rcParams._get_backend_or_none()\n+    if backend is None:\n+        # Only resolve backend if we haven't already done so\n+        return rcParams['backend']\n+    return backend\n \n     def __repr__(self):\n         class_name = self.__class__.__name__\n@@ -1054,6 +1065,7 @@ def rc_file(fname, *, use_default_template=True):\n                          if k not in STYLE_BLACKLIST})\n \n \n+\n @contextlib.contextmanager\n def rc_context(rc=None, fname=None):\n     \"\"\"\n@@ -1087,7 +1099,9 @@ def rc_context(rc=None, fname=None):\n              plt.plot(x, y)  # uses 'print.rc'\n \n     \"\"\"\n+    # Store original rcParams state including backend resolution state\n     orig = rcParams.copy()\n+    orig_backend_or_none = rcParams._get_backend_or_none()\n     try:\n         if fname:\n             rc_file(fname)\n@@ -1095,7 +1109,12 @@ def rc_context(rc=None, fname=None):\n             rcParams.update(rc)\n         yield\n     finally:\n-        dict.update(rcParams, orig)  # Revert to the original rcs.\n+        # Restore original state without triggering backend switching\n+        dict.clear(rcParams)\n+        dict.update(rcParams, orig)\n+        # Restore backend resolution state to prevent inconsistencies\n+        if orig_backend_or_none is None and 'backend' in orig:\n+            rcParams._set_backend_or_none(None)\n \n \n def use(backend, *, force=True):\n@@ -1135,21 +1154,23 @@ def use(backend, *, force=True):\n     \"\"\"\n     name = validate_backend(backend)\n     # don't (prematurely) resolve the \"auto\" backend setting\n-    if rcParams._get_backend_or_none() == name:\n-        # Nothing to do if the requested backend is already set\n-        pass\n-    else:\n-        # if pyplot is not already imported, do not import it.  Doing\n-        # so may trigger a `plt.switch_backend` to the _default_ backend\n-        # before we get a chance to change to the one the user just requested\n-        plt = sys.modules.get('matplotlib.pyplot')\n-        # if pyplot is imported, then try to change backends\n-        if plt is not None:\n-            try:\n-                # we need this import check here to re-raise if the\n-                # user does not have the libraries to support their\n-                # chosen backend installed.\n-                plt.switch_backend(name)\n+\n+def get_backend():\n+    \"\"\"\n+    Return the name of the current backend.\n+\n+    See Also\n+    --------\n+    matplotlib.use\n+    \"\"\"\n+    # Use _get_backend_or_none to avoid triggering backend resolution\n+    # which can cause side effects like closing figures\n+    backend = rcParams._get_backend_or_none()\n+    if backend is None:\n+        # If backend is still None (auto), resolve it without side effects\n+        # by directly accessing the validated backend name\n+        backend = rcParams._get('backend')\n+    return backend\n             except ImportError:\n                 if force:\n                     raise\n@@ -1167,6 +1188,7 @@ if os.environ.get('MPLBACKEND'):\n     rcParams['backend'] = os.environ.get('MPLBACKEND')\n \n \n+\n def get_backend():\n     \"\"\"\n     Return the name of the current backend.\n@@ -1175,6 +1197,20 @@ def get_backend():\n     --------\n     matplotlib.use\n     \"\"\"\n+    # Use _get_backend_or_none() to avoid triggering backend resolution\n+    # which can cause unwanted side effects like clearing figures\n+    backend = rcParams._get_backend_or_none()\n+    if backend is not None:\n+        return backend\n+    \n+    # If backend is None, we need to resolve it, but we should do so\n+    # without triggering the full backend switching machinery\n+    # that could clear existing figures\n+    if rcParams._get('backend') == 'auto':\n+        # Return the auto-detected backend without setting it permanently\n+        from matplotlib.backends import backend_registry\n+        return backend_registry.resolve_backend_or_none() or 'Agg'\n+    \n     return rcParams['backend']\n \n \ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex e3c66ea67c..3a0d289a2d 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -206,23 +206,23 @@ def _get_backend_mod():\n     return _backend_mod\n \n \n-def switch_backend(newbackend):\n-    \"\"\"\n-    Close all open figures and set the Matplotlib backend.\n-\n-    The argument is case-insensitive.  Switching to an interactive backend is\n-    possible only if no event loop for another interactive backend has started.\n-    Switching to and from non-interactive backends is always possible.\n \n-    Parameters\n-    ----------\n-    newbackend : str\n-        The name of the backend to use.\n+def get_backend():\n     \"\"\"\n-    global _backend_mod\n-    # make sure the init is pulled up so we can assign to it later\n-    import matplotlib.backends\n-    close(\"all\")\n+    Return the name of the current backend.\n+\n+    See Also\n+    --------\n+    matplotlib.use\n+    \"\"\"\n+    # Use _get_backend_or_none() to avoid triggering backend resolution\n+    # which could cause unwanted side effects like closing figures\n+    backend = _get_backend_or_none()\n+    if backend is None:\n+        # If no backend is set, return the default from rcParams without\n+        # triggering backend switching logic\n+        return rcParams._get('backend', rcsetup._auto_backend_sentinel)\n+    return backend\n \n     if newbackend is rcsetup._auto_backend_sentinel:\n         current_framework = cbook._get_running_interactive_framework()\n",
    "variant_8": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex c268a56724..f3a1c3f57a 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -678,10 +678,21 @@ class RcParams(MutableMapping, dict):\n \n         return dict.__getitem__(self, key)\n \n-    def _get_backend_or_none(self):\n-        \"\"\"Get the requested backend, if any, without triggering resolution.\"\"\"\n-        backend = dict.__getitem__(self, \"backend\")\n-        return None if backend is rcsetup._auto_backend_sentinel else backend\n+\n+def get_backend():\n+    \"\"\"\n+    Return the name of the current backend.\n+\n+    See Also\n+    --------\n+    matplotlib.use\n+    \"\"\"\n+    # Use _get_backend_or_none to avoid triggering backend resolution\n+    backend = rcParams._get_backend_or_none()\n+    if backend is None:\n+        # Backend is in auto-detection state, resolve it without side effects\n+        return rcsetup._auto_backend_sentinel\n+    return backend\n \n     def __repr__(self):\n         class_name = self.__class__.__name__\n@@ -1054,6 +1065,7 @@ def rc_file(fname, *, use_default_template=True):\n                          if k not in STYLE_BLACKLIST})\n \n \n+\n @contextlib.contextmanager\n def rc_context(rc=None, fname=None):\n     \"\"\"\n@@ -1087,7 +1099,10 @@ def rc_context(rc=None, fname=None):\n              plt.plot(x, y)  # uses 'print.rc'\n \n     \"\"\"\n+    # Store the original rcParams state, including any backend auto-detection state\n     orig = rcParams.copy()\n+    orig_backend_fallback = getattr(rcParams, '_backend_fallback', None)\n+    \n     try:\n         if fname:\n             rc_file(fname)\n@@ -1095,7 +1110,12 @@ def rc_context(rc=None, fname=None):\n             rcParams.update(rc)\n         yield\n     finally:\n-        dict.update(rcParams, orig)  # Revert to the original rcs.\n+        # Clear rcParams and restore original state completely\n+        rcParams.clear()\n+        rcParams.update(orig)\n+        # Restore backend auto-detection state if it existed\n+        if orig_backend_fallback is not None:\n+            rcParams._backend_fallback = orig_backend_fallback\n \n \n def use(backend, *, force=True):\n@@ -1135,21 +1155,23 @@ def use(backend, *, force=True):\n     \"\"\"\n     name = validate_backend(backend)\n     # don't (prematurely) resolve the \"auto\" backend setting\n-    if rcParams._get_backend_or_none() == name:\n-        # Nothing to do if the requested backend is already set\n-        pass\n-    else:\n-        # if pyplot is not already imported, do not import it.  Doing\n-        # so may trigger a `plt.switch_backend` to the _default_ backend\n-        # before we get a chance to change to the one the user just requested\n-        plt = sys.modules.get('matplotlib.pyplot')\n-        # if pyplot is imported, then try to change backends\n-        if plt is not None:\n-            try:\n-                # we need this import check here to re-raise if the\n-                # user does not have the libraries to support their\n-                # chosen backend installed.\n-                plt.switch_backend(name)\n+\n+def get_backend():\n+    \"\"\"\n+    Return the name of the current backend.\n+\n+    See Also\n+    --------\n+    :ref:`backends`\n+    matplotlib.use\n+    \"\"\"\n+    # Use _get_backend_or_none() to avoid triggering backend resolution\n+    # which can cause side effects like closing figures\n+    backend = rcParams._get_backend_or_none()\n+    if backend is None:\n+        # If no backend is set, return the default without triggering resolution\n+        return rcsetup._auto_backend_sentinel\n+    return backend\n             except ImportError:\n                 if force:\n                     raise\n@@ -1167,6 +1189,7 @@ if os.environ.get('MPLBACKEND'):\n     rcParams['backend'] = os.environ.get('MPLBACKEND')\n \n \n+\n def get_backend():\n     \"\"\"\n     Return the name of the current backend.\n@@ -1175,7 +1198,7 @@ def get_backend():\n     --------\n     matplotlib.use\n     \"\"\"\n-    return rcParams['backend']\n+    return rcParams._get_backend_or_none() or rcParams['backend']\n \n \n def interactive(b):\ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex e3c66ea67c..1610d9a806 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -206,23 +206,34 @@ def _get_backend_mod():\n     return _backend_mod\n \n \n-def switch_backend(newbackend):\n-    \"\"\"\n-    Close all open figures and set the Matplotlib backend.\n-\n-    The argument is case-insensitive.  Switching to an interactive backend is\n-    possible only if no event loop for another interactive backend has started.\n-    Switching to and from non-interactive backends is always possible.\n \n-    Parameters\n-    ----------\n-    newbackend : str\n-        The name of the backend to use.\n+def get_backend():\n     \"\"\"\n-    global _backend_mod\n-    # make sure the init is pulled up so we can assign to it later\n-    import matplotlib.backends\n-    close(\"all\")\n+    Return the name of the current backend.\n+\n+    See Also\n+    --------\n+    matplotlib.use\n+    \"\"\"\n+    # Use _get_backend_or_none() to avoid side effects that could trigger\n+    # backend switching and figure clearing\n+    backend = _get_backend_or_none()\n+    if backend is not None:\n+        return backend\n+    \n+    # If backend is None, we need to resolve it, but do so carefully\n+    # to avoid unnecessary figure clearing\n+    current_backend = rcParams['backend']\n+    if current_backend is rcsetup._auto_backend_sentinel:\n+        # Only resolve auto backend if we haven't already initialized\n+        if _backend_mod is None:\n+            # This will trigger backend resolution but is necessary\n+            return rcParams['backend']\n+        else:\n+            # We already have a backend module, return its name\n+            return _backend_mod.__name__.split('.')[-1]\n+    \n+    return current_backend\n \n     if newbackend is rcsetup._auto_backend_sentinel:\n         current_framework = cbook._get_running_interactive_framework()\n"
  }
}