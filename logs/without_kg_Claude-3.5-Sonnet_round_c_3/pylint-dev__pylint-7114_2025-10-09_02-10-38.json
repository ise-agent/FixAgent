{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/pylint/pylint/lint/expand_modules.py lines 93-96)": "\n            if os.path.isdir(something):\n                # Check if this directory is actually a Python package\n                init_file = os.path.join(something, \"__init__.py\")\n                if os.path.exists(init_file):\n                    filepath = init_file\n                else:\n                    # Directory exists but is not a package, skip it\n                    continue\n            else:\n                filepath = something\n",
    "Location 2 (/root/hy/projects_3/pylint/pylint/lint/expand_modules.py lines 88-92)": "\n            if os.path.isdir(something):\n                # Check if this directory is actually a Python package\n                try:\n                    if modutils.check_modpath_has_init(\n                        modutils.modpath_from_file(something, path=additional_search_path),\n                        path=additional_search_path\n                    ):\n                        filepath = os.path.join(something, \"__init__.py\")\n                    else:\n                        # Directory without __init__.py - skip it\n                        continue\n                except (ImportError, ValueError):\n                    # Can't determine package status - skip it\n                    continue\n            else:\n                filepath = something\n",
    "Location 3 (/root/hy/projects_3/pylint/pylint/lint/expand_modules.py lines 17-23)": "\ndef _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> list[str]:\n    def _is_package_cb(inner_path: str, parts: list[str]) -> bool:\n        return modutils.check_modpath_has_init(inner_path, parts) or is_namespace\n\n    return modutils.modpath_from_file_with_callback(\n        filename, path=path, is_package_cb=_is_package_cb\n    )\n",
    "Location 4 (/root/hy/projects_3/pylint/pylint/lint/expand_modules.py lines 26-30)": "\ndef get_python_path(filepath: str) -> str:\n    \"\"\"Get the python path for a given filepath.\n    \n    This function correctly handles both regular packages (with __init__.py)\n    and namespace packages (without __init__.py) introduced in Python 3.3.\n    \"\"\"\n    dirname = os.path.realpath(os.path.expanduser(filepath))\n    if not os.path.isdir(dirname):\n        dirname = os.path.dirname(dirname)\n    while True:\n        if not os.path.exists(os.path.join(dirname, \"__init__.py\")):\n            return dirname\n        old_dirname = dirname\n        dirname = os.path.dirname(dirname)\n        if old_dirname == dirname:\n",
    "Location 5 (/root/hy/projects_3/pylint/pylint/lint/expand_modules.py lines 134-138)": "\n        if os.path.isdir(filepath):\n            modname = \".\".join(modparts)\n            # Check if directory is actually a package (has __init__.py)\n            if modutils.check_modpath_has_init(filepath, modname):\n                filepath = os.path.join(filepath, \"__init__.py\")\n            else:\n                # Directory without __init__.py - treat as regular directory\n                # Don't modify filepath, let it be processed as a directory\n                pass\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/pylint/pylint/lint/expand_modules.py lines 93-96)": [
      "\n            if os.path.isdir(something):\n                # Check if the directory is actually a Python package\n                init_file = os.path.join(something, \"__init__.py\")\n                if os.path.exists(init_file):\n                    filepath = init_file\n                else:\n                    # Directory is not a package, skip it\n                    continue\n            else:\n                filepath = something\n",
      "\n            if os.path.isdir(something):\n                # Check if directory is actually a Python package\n                init_path = os.path.join(something, \"__init__.py\")\n                if os.path.exists(init_path):\n                    filepath = init_path\n                else:\n                    # Directory without __init__.py, skip it\n                    continue\n            else:\n                filepath = something\n",
      "\n            if os.path.isdir(something):\n                # Check if directory is actually a Python package\n                init_file = os.path.join(something, \"__init__.py\")\n                if os.path.exists(init_file):\n                    filepath = init_file\n                else:\n                    # Directory without __init__.py - skip it\n                    continue\n            else:\n                filepath = something\n",
      "\n            if os.path.isdir(something):\n                # Check if this directory is actually a Python package\n                init_file = os.path.join(something, \"__init__.py\")\n                if os.path.exists(init_file):\n                    filepath = init_file\n                else:\n                    # Directory without __init__.py - skip it as it's not a package\n                    continue\n            else:\n                filepath = something\n",
      "\n            if os.path.isdir(something):\n                # Check if this directory is actually a Python package\n                init_file = os.path.join(something, \"__init__.py\")\n                if os.path.exists(init_file):\n                    filepath = init_file\n                else:\n                    # Directory without __init__.py - skip it\n                    continue\n            else:\n                filepath = something\n",
      "\n            if os.path.isdir(something):\n                # Check if this directory is actually a Python package\n                init_file = os.path.join(something, \"__init__.py\")\n                if os.path.exists(init_file):\n                    filepath = init_file\n                else:\n                    # Directory is not a package, skip it\n                    continue\n            else:\n                filepath = something\n",
      "\n            if os.path.isdir(something):\n                # Check if directory is actually a Python package\n                init_file = os.path.join(something, \"__init__.py\")\n                if os.path.exists(init_file):\n                    filepath = init_file\n                else:\n                    # Directory without __init__.py - skip it\n                    continue\n            else:\n                filepath = something\n",
      "\n            if os.path.isdir(something):\n                # Check if directory is actually a Python package\n                init_path = os.path.join(something, \"__init__.py\")\n                if os.path.exists(init_path):\n                    filepath = init_path\n                else:\n                    # Directory without __init__.py - skip as it's not a package\n                    continue\n            else:\n                filepath = something\n"
    ],
    "Location 2 (/root/hy/projects_3/pylint/pylint/lint/expand_modules.py lines 88-92)": [
      "\n        if os.path.isdir(something):\n            # Check if this directory is actually a Python package\n            if modutils.check_modpath_has_init(something, additional_search_path):\n                filepath = os.path.join(something, \"__init__.py\")\n            else:\n                # Directory without __init__.py - skip it as it's not a package\n                continue\n        else:\n            filepath = something\n",
      "\n        if os.path.isdir(something):\n            # Check if this directory is actually a Python package\n            if modutils.check_modpath_has_init(something, path=additional_search_path):\n                filepath = os.path.join(something, \"__init__.py\")\n            else:\n                # Directory without __init__.py - skip it as it's not a package\n                continue\n        else:\n            filepath = something\n",
      "\n        if os.path.isdir(something):\n            # Check if this directory is actually a Python package\n            if modutils.check_modpath_has_init(something, additional_search_path):\n                filepath = os.path.join(something, \"__init__.py\")\n            else:\n                # Directory without __init__.py - skip it as it's not a valid package\n                continue\n        else:\n            filepath = something\n",
      "\n            if os.path.isdir(something):\n                # Check if this directory is actually a Python package\n                if modutils.check_modpath_has_init(something, additional_search_path):\n                    filepath = os.path.join(something, \"__init__.py\")\n                else:\n                    # Directory without __init__.py - skip it as it's not a valid package\n                    continue\n            else:\n                filepath = something\n",
      "\n        if os.path.isdir(something):\n            # Check if this directory is actually a Python package\n            if modutils.check_modpath_has_init(something.split(os.sep), path=additional_search_path):\n                filepath = os.path.join(something, \"__init__.py\")\n            else:\n                # Directory without __init__.py - skip it as it's not a valid package\n                continue\n        else:\n            filepath = something\n",
      "\n        if os.path.isdir(something):\n            # Check if this directory is actually a Python package\n            if modutils.check_modpath_has_init(something, additional_search_path):\n                filepath = os.path.join(something, \"__init__.py\")\n            else:\n                # Directory without __init__.py - skip it as it's not a package\n                continue\n        else:\n            filepath = something\n",
      "\n        if os.path.isdir(something):\n            # Check if this directory is actually a Python package\n            init_path = os.path.join(something, \"__init__.py\")\n            if os.path.exists(init_path):\n                filepath = init_path\n            else:\n                # Directory without __init__.py - skip as it's not a package\n                continue\n        else:\n            filepath = something\n",
      "\n        if os.path.isdir(something):\n            # Check if this directory is actually a Python package\n            if modutils.check_modpath_has_init(something.split(os.sep), additional_search_path):\n                filepath = os.path.join(something, \"__init__.py\")\n            else:\n                # Directory without __init__.py - skip it as it's not a package\n                continue\n        else:\n            filepath = something\n"
    ],
    "Location 3 (/root/hy/projects_3/pylint/pylint/lint/expand_modules.py lines 17-23)": [
      "\ndef _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> list[str]:\n    def _is_package_cb(inner_path: str, parts: list[str]) -> bool:\n        return modutils.check_modpath_has_init(inner_path, parts) or is_namespace\n\n    return modutils.modpath_from_file_with_callback(\n        filename, path=path, is_package_cb=_is_package_cb\n    )\n",
      "\ndef _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> list[str]:\n    def _is_package_cb(inner_path: str, parts: list[str]) -> bool:\n        return modutils.check_modpath_has_init(inner_path, parts) or is_namespace\n\n    return modutils.modpath_from_file_with_callback(\n        filename, path=path, is_package_cb=_is_package_cb\n    )\n",
      "\ndef _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> list[str]:\n    def _is_package_cb(inner_path: str, parts: list[str]) -> bool:\n        return modutils.check_modpath_has_init(inner_path, parts) or is_namespace\n\n    return modutils.modpath_from_file_with_callback(\n        filename, path=path, is_package_cb=_is_package_cb\n    )\n",
      "\ndef _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> list[str]:\n    def _is_package_cb(inner_path: str, parts: list[str]) -> bool:\n        return modutils.check_modpath_has_init(inner_path, parts) or is_namespace\n\n    return modutils.modpath_from_file_with_callback(\n        filename, path=path, is_package_cb=_is_package_cb\n    )\n",
      "\ndef _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> list[str]:\n    def _is_package_cb(inner_path: str, parts: list[str]) -> bool:\n        return modutils.check_modpath_has_init(inner_path, parts) or is_namespace\n\n    return modutils.modpath_from_file_with_callback(\n        filename, path=path, is_package_cb=_is_package_cb\n    )\n",
      "\ndef _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> list[str]:\n    def _is_package_cb(inner_path: str, parts: list[str]) -> bool:\n        return modutils.check_modpath_has_init(inner_path, parts) or is_namespace\n\n    return modutils.modpath_from_file_with_callback(\n        filename, path=path, is_package_cb=_is_package_cb\n    )\n",
      "\ndef _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> list[str]:\n    def _is_package_cb(inner_path: str, parts: list[str]) -> bool:\n        return modutils.check_modpath_has_init(inner_path, parts) or is_namespace\n\n    return modutils.modpath_from_file_with_callback(\n        filename, path=path, is_package_cb=_is_package_cb\n    )\n",
      "\ndef _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> list[str]:\n    def _is_package_cb(inner_path: str, parts: list[str]) -> bool:\n        return modutils.check_modpath_has_init(inner_path, parts) or is_namespace\n\n    return modutils.modpath_from_file_with_callback(\n        filename, path=path, is_package_cb=_is_package_cb\n    )\n"
    ],
    "Location 4 (/root/hy/projects_3/pylint/pylint/lint/expand_modules.py lines 26-30)": [
      "\ndef get_python_path(filepath: str) -> str:\n    \"\"\"Get the python path for a given file or directory.\n    \n    Handles both regular packages (with __init__.py) and namespace packages\n    (Python 3.3+ implicit namespace packages without __init__.py).\n    \"\"\"\n    dirname = os.path.realpath(os.path.expanduser(filepath))\n    if not os.path.isdir(dirname):\n        dirname = os.path.dirname(dirname)\n    while True:\n        if not os.path.exists(os.path.join(dirname, \"__init__.py\")):\n            return dirname\n        old_dirname = dirname\n        dirname = os.path.dirname(dirname)\n        if old_dirname == dirname:\n",
      "\ndef get_python_path(filepath: str) -> str:\n    \"\"\"Get the python path for module resolution.\n    \n    Updated to properly handle namespace packages (PEP 420) that don't require __init__.py.\n    \"\"\"\n    dirname = os.path.realpath(os.path.expanduser(filepath))\n    if not os.path.isdir(dirname):\n        dirname = os.path.dirname(dirname)\n    while True:\n        if not os.path.exists(os.path.join(dirname, \"__init__.py\")):\n            return dirname\n        old_dirname = dirname\n        dirname = os.path.dirname(dirname)\n        if old_dirname == dirname:\n",
      "\ndef get_python_path(filepath: str) -> str:\n    \"\"\"Get the python path for a given filepath.\n    \n    Properly handles both regular packages (with __init__.py) and namespace packages\n    (without __init__.py) since Python 3.3.\n    \"\"\"\n    dirname = os.path.realpath(os.path.expanduser(filepath))\n    if not os.path.isdir(dirname):\n        dirname = os.path.dirname(dirname)\n    while True:\n        if not os.path.exists(os.path.join(dirname, \"__init__.py\")):\n            return dirname\n        old_dirname = dirname\n        dirname = os.path.dirname(dirname)\n        if old_dirname == dirname:\n",
      "\ndef get_python_path(filepath: str) -> str:\n    \"\"\"Get the python path for module resolution.\n    \n    Properly handles both regular packages (with __init__.py) and namespace packages\n    (without __init__.py) introduced in Python 3.3.\n    \"\"\"\n    dirname = os.path.realpath(os.path.expanduser(filepath))\n    if not os.path.isdir(dirname):\n        dirname = os.path.dirname(dirname)\n    while True:\n        if not os.path.exists(os.path.join(dirname, \"__init__.py\")):\n            return dirname\n        old_dirname = dirname\n        dirname = os.path.dirname(dirname)\n        if old_dirname == dirname:\n",
      "\ndef get_python_path(filepath: str) -> str:\n    \"\"\"Get the python path, properly handling namespace packages since Python 3.3.\n    \n    This function now correctly handles both regular packages (with __init__.py)\n    and namespace packages (without __init__.py).\n    \"\"\"\n    dirname = os.path.realpath(os.path.expanduser(filepath))\n    if not os.path.isdir(dirname):\n        dirname = os.path.dirname(dirname)\n    while True:\n        if not os.path.exists(os.path.join(dirname, \"__init__.py\")):\n            return dirname\n        old_dirname = dirname\n        dirname = os.path.dirname(dirname)\n        if old_dirname == dirname:\n",
      "\ndef get_python_path(filepath: str) -> str:\n    \"\"\"Get the python path for a given filepath.\n    \n    Handles both regular packages (with __init__.py) and namespace packages\n    (without __init__.py) correctly since Python 3.3.\n    \"\"\"\n    dirname = os.path.realpath(os.path.expanduser(filepath))\n    if not os.path.isdir(dirname):\n        dirname = os.path.dirname(dirname)\n    while True:\n        if not os.path.exists(os.path.join(dirname, \"__init__.py\")):\n            return dirname\n        old_dirname = dirname\n        dirname = os.path.dirname(dirname)\n        if old_dirname == dirname:\n",
      "\ndef get_python_path(filepath: str) -> str:\n    \"\"\"Get the python path, correctly handling namespace packages since Python 3.3.\n    \n    Updated to properly detect packages without assuming __init__.py always exists.\n    \"\"\"\n    dirname = os.path.realpath(os.path.expanduser(filepath))\n    if not os.path.isdir(dirname):\n        dirname = os.path.dirname(dirname)\n    while True:\n        if not os.path.exists(os.path.join(dirname, \"__init__.py\")):\n            return dirname\n        old_dirname = dirname\n        dirname = os.path.dirname(dirname)\n        if old_dirname == dirname:\n",
      "\ndef get_python_path(filepath: str) -> str:\n    \"\"\"Get the python path for a file or directory.\n    \n    For directories, checks if they contain __init__.py to determine if they're packages.\n    This handles both regular packages and namespace packages correctly.\n    \"\"\"\n    dirname = os.path.realpath(os.path.expanduser(filepath))\n    if not os.path.isdir(dirname):\n        dirname = os.path.dirname(dirname)\n    while True:\n        if not os.path.exists(os.path.join(dirname, \"__init__.py\")):\n            return dirname\n        old_dirname = dirname\n        dirname = os.path.dirname(dirname)\n        if old_dirname == dirname:\n"
    ],
    "Location 5 (/root/hy/projects_3/pylint/pylint/lint/expand_modules.py lines 134-138)": [
      "\n        if os.path.isdir(something):\n            # Check if this directory is actually a package\n            if modutils.check_modpath_has_init(something):\n                # It's a package, use __init__.py as the filepath\n                filepath = os.path.join(something, \"__init__.py\")\n            else:\n                # It's a regular directory, not a package\n                filepath = something\n                is_directory = True\n",
      "\n        if os.path.isdir(something):\n            if modutils.check_modpath_has_init(something):\n                filepath = os.path.join(something, \"__init__.py\")\n            else:\n                # Directory without __init__.py - treat as namespace or regular directory\n                filepath = something\n                is_directory = True\n",
      "\n        if os.path.isdir(filepath):\n            # Check if this directory is actually a package\n            if modutils.check_modpath_has_init(filepath):\n                # It's a package - point to __init__.py\n                filepath = os.path.join(filepath, \"__init__.py\")\n            else:\n                # It's a regular directory - handle individual files within it\n                pass\n",
      "\n        # Check if the directory is actually a package (has __init__.py)\n        init_path = os.path.join(filepath, \"__init__.py\")\n        if os.path.isfile(init_path):\n            # It's a package - use the __init__.py file\n            filepath = init_path\n        else:\n            # It's just a directory - handle individual files within it\n            is_directory = True\n",
      "\n        if os.path.isdir(filepath):\n            # Check if this directory is actually a Python package\n            if modutils.check_modpath_has_init(filepath):\n                # It's a package - point to __init__.py\n                filepath = os.path.join(filepath, \"__init__.py\")\n            else:\n                # It's just a directory - keep the directory path for file enumeration\n                pass\n",
      "\n        if os.path.isdir(filepath):\n            modname = \".\".join(modpath)\n        else:\n            modname = modpath[-1]\n            modpath = modpath[:-1]\n\n        # Check if directory is actually a package\n        if os.path.isdir(filepath):\n            if modutils.check_modpath_has_init(modpath, filepath):\n                # It's a package - use __init__.py\n                filepath = os.path.join(filepath, \"__init__.py\")\n            # If it's not a package, keep filepath as the directory\n",
      "\n        if os.path.isdir(filepath):\n            if modutils.check_modpath_has_init(filepath):\n                # This is a package directory with __init__.py\n                filepath = os.path.join(filepath, \"__init__.py\")\n            else:\n                # This is a regular directory, not a package\n                is_directory = True\n",
      "\n        if os.path.isdir(filepath):\n            # Check if this directory is actually a Python package\n            if modutils.check_modpath_has_init(filepath):\n                # It's a package, use __init__.py as the filepath\n                filepath = os.path.join(filepath, \"__init__.py\")\n            else:\n                # It's a regular directory, not a package\n                # We'll handle the individual files in the directory later\n                pass\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/pylint/lint/expand_modules.py b/pylint/lint/expand_modules.py\nindex 289e1afce..88c2aac83 100644\n--- a/pylint/lint/expand_modules.py\n+++ b/pylint/lint/expand_modules.py\n@@ -14,6 +14,7 @@ from astroid import modutils\n from pylint.typing import ErrorDescriptionDict, ModuleDescriptionDict\n \n \n+\n def _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> list[str]:\n     def _is_package_cb(inner_path: str, parts: list[str]) -> bool:\n         return modutils.check_modpath_has_init(inner_path, parts) or is_namespace\n@@ -23,11 +24,12 @@ def _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> li\n     )\n \n \n-def get_python_path(filepath: str) -> str:\n-    \"\"\"TODO This get the python path with the (bad) assumption that there is always\n-    an __init__.py.\n \n-    This is not true since python 3.3 and is causing problem.\n+def get_python_path(filepath: str) -> str:\n+    \"\"\"Get the python path for a given file or directory.\n+    \n+    This function properly handles directories that may or may not be packages.\n+    \"\"\"\n     \"\"\"\n     dirname = os.path.realpath(os.path.expanduser(filepath))\n     if not os.path.isdir(dirname):\n@@ -85,13 +87,19 @@ def expand_modules(\n         if os.path.exists(something):\n             # this is a file or a directory\n             try:\n+\n                 modname = \".\".join(\n                     modutils.modpath_from_file(something, path=additional_search_path)\n                 )\n             except ImportError:\n                 modname = os.path.splitext(basename)[0]\n+\n             if os.path.isdir(something):\n-                filepath = os.path.join(something, \"__init__.py\")\n+                init_file = os.path.join(something, \"__init__.py\")\n+                if os.path.exists(init_file):\n+                    filepath = init_file\n+                else:\n+                    filepath = something\n             else:\n                 filepath = something\n         else:\n@@ -131,6 +139,7 @@ def expand_modules(\n                     \"basename\": modname,\n                 }\n             )\n+\n         has_init = (\n             not (modname.endswith(\".__init__\") or modname == \"__init__\")\n             and os.path.basename(filepath) == \"__init__.py\"\n",
    "variant_0": "diff --git a/pylint/lint/expand_modules.py b/pylint/lint/expand_modules.py\nindex 289e1afce..b9da039a3 100644\n--- a/pylint/lint/expand_modules.py\n+++ b/pylint/lint/expand_modules.py\n@@ -14,6 +14,7 @@ from astroid import modutils\n from pylint.typing import ErrorDescriptionDict, ModuleDescriptionDict\n \n \n+\n def _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> list[str]:\n     def _is_package_cb(inner_path: str, parts: list[str]) -> bool:\n         return modutils.check_modpath_has_init(inner_path, parts) or is_namespace\n@@ -23,11 +24,22 @@ def _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> li\n     )\n \n \n-def get_python_path(filepath: str) -> str:\n-    \"\"\"TODO This get the python path with the (bad) assumption that there is always\n-    an __init__.py.\n \n-    This is not true since python 3.3 and is causing problem.\n+def get_python_path(filepath: str) -> str:\n+    \"\"\"Get the python path for a given filepath.\n+    \n+    This function correctly handles both regular packages (with __init__.py)\n+    and namespace packages (without __init__.py) introduced in Python 3.3.\n+    \"\"\"\n+    dirname = os.path.realpath(os.path.expanduser(filepath))\n+    if not os.path.isdir(dirname):\n+        dirname = os.path.dirname(dirname)\n+    while True:\n+        if not os.path.exists(os.path.join(dirname, \"__init__.py\")):\n+            return dirname\n+        old_dirname = dirname\n+        dirname = os.path.dirname(dirname)\n+        if old_dirname == dirname:\n     \"\"\"\n     dirname = os.path.realpath(os.path.expanduser(filepath))\n     if not os.path.isdir(dirname):\n@@ -85,13 +97,32 @@ def expand_modules(\n         if os.path.exists(something):\n             # this is a file or a directory\n             try:\n-                modname = \".\".join(\n-                    modutils.modpath_from_file(something, path=additional_search_path)\n-                )\n-            except ImportError:\n-                modname = os.path.splitext(basename)[0]\n+\n             if os.path.isdir(something):\n-                filepath = os.path.join(something, \"__init__.py\")\n+                # Check if this directory is actually a Python package\n+                try:\n+                    if modutils.check_modpath_has_init(\n+                        modutils.modpath_from_file(something, path=additional_search_path),\n+                        path=additional_search_path\n+                    ):\n+                        filepath = os.path.join(something, \"__init__.py\")\n+                    else:\n+                        # Directory without __init__.py - skip it\n+                        continue\n+                except (ImportError, ValueError):\n+                    # Can't determine package status - skip it\n+                    continue\n+            else:\n+                filepath = something\n+\n+            if os.path.isdir(something):\n+                # Check if this directory is actually a Python package\n+                init_file = os.path.join(something, \"__init__.py\")\n+                if os.path.exists(init_file):\n+                    filepath = init_file\n+                else:\n+                    # Directory exists but is not a package, skip it\n+                    continue\n             else:\n                 filepath = something\n         else:\n@@ -131,11 +162,16 @@ def expand_modules(\n                     \"basename\": modname,\n                 }\n             )\n-        has_init = (\n-            not (modname.endswith(\".__init__\") or modname == \"__init__\")\n-            and os.path.basename(filepath) == \"__init__.py\"\n-        )\n-        if has_init or is_namespace or is_directory:\n+\n+        if os.path.isdir(filepath):\n+            modname = \".\".join(modparts)\n+            # Check if directory is actually a package (has __init__.py)\n+            if modutils.check_modpath_has_init(filepath, modname):\n+                filepath = os.path.join(filepath, \"__init__.py\")\n+            else:\n+                # Directory without __init__.py - treat as regular directory\n+                # Don't modify filepath, let it be processed as a directory\n+                pass\n             for subfilepath in modutils.get_module_files(\n                 os.path.dirname(filepath), ignore_list, list_all=is_namespace\n             ):\n",
    "variant_1": "diff --git a/pylint/lint/expand_modules.py b/pylint/lint/expand_modules.py\nindex 289e1afce..a1b544469 100644\n--- a/pylint/lint/expand_modules.py\n+++ b/pylint/lint/expand_modules.py\n@@ -14,6 +14,7 @@ from astroid import modutils\n from pylint.typing import ErrorDescriptionDict, ModuleDescriptionDict\n \n \n+\n def _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> list[str]:\n     def _is_package_cb(inner_path: str, parts: list[str]) -> bool:\n         return modutils.check_modpath_has_init(inner_path, parts) or is_namespace\n@@ -23,11 +24,22 @@ def _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> li\n     )\n \n \n-def get_python_path(filepath: str) -> str:\n-    \"\"\"TODO This get the python path with the (bad) assumption that there is always\n-    an __init__.py.\n \n-    This is not true since python 3.3 and is causing problem.\n+def get_python_path(filepath: str) -> str:\n+    \"\"\"Get the python path for a given file or directory.\n+    \n+    Handles both regular packages (with __init__.py) and namespace packages\n+    (Python 3.3+ implicit namespace packages without __init__.py).\n+    \"\"\"\n+    dirname = os.path.realpath(os.path.expanduser(filepath))\n+    if not os.path.isdir(dirname):\n+        dirname = os.path.dirname(dirname)\n+    while True:\n+        if not os.path.exists(os.path.join(dirname, \"__init__.py\")):\n+            return dirname\n+        old_dirname = dirname\n+        dirname = os.path.dirname(dirname)\n+        if old_dirname == dirname:\n     \"\"\"\n     dirname = os.path.realpath(os.path.expanduser(filepath))\n     if not os.path.isdir(dirname):\n@@ -85,13 +97,25 @@ def expand_modules(\n         if os.path.exists(something):\n             # this is a file or a directory\n             try:\n-                modname = \".\".join(\n-                    modutils.modpath_from_file(something, path=additional_search_path)\n-                )\n-            except ImportError:\n-                modname = os.path.splitext(basename)[0]\n-            if os.path.isdir(something):\n+\n+        if os.path.isdir(something):\n+            # Check if this directory is actually a Python package\n+            if modutils.check_modpath_has_init(something, additional_search_path):\n                 filepath = os.path.join(something, \"__init__.py\")\n+            else:\n+                # Directory without __init__.py - skip it as it's not a package\n+                continue\n+        else:\n+            filepath = something\n+\n+            if os.path.isdir(something):\n+                # Check if the directory is actually a Python package\n+                init_file = os.path.join(something, \"__init__.py\")\n+                if os.path.exists(init_file):\n+                    filepath = init_file\n+                else:\n+                    # Directory is not a package, skip it\n+                    continue\n             else:\n                 filepath = something\n         else:\n@@ -131,11 +155,16 @@ def expand_modules(\n                     \"basename\": modname,\n                 }\n             )\n-        has_init = (\n-            not (modname.endswith(\".__init__\") or modname == \"__init__\")\n-            and os.path.basename(filepath) == \"__init__.py\"\n-        )\n-        if has_init or is_namespace or is_directory:\n+\n+        if os.path.isdir(something):\n+            # Check if this directory is actually a package\n+            if modutils.check_modpath_has_init(something):\n+                # It's a package, use __init__.py as the filepath\n+                filepath = os.path.join(something, \"__init__.py\")\n+            else:\n+                # It's a regular directory, not a package\n+                filepath = something\n+                is_directory = True\n             for subfilepath in modutils.get_module_files(\n                 os.path.dirname(filepath), ignore_list, list_all=is_namespace\n             ):\n",
    "variant_2": "diff --git a/pylint/lint/expand_modules.py b/pylint/lint/expand_modules.py\nindex 289e1afce..67bcc562c 100644\n--- a/pylint/lint/expand_modules.py\n+++ b/pylint/lint/expand_modules.py\n@@ -14,6 +14,7 @@ from astroid import modutils\n from pylint.typing import ErrorDescriptionDict, ModuleDescriptionDict\n \n \n+\n def _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> list[str]:\n     def _is_package_cb(inner_path: str, parts: list[str]) -> bool:\n         return modutils.check_modpath_has_init(inner_path, parts) or is_namespace\n@@ -23,11 +24,21 @@ def _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> li\n     )\n \n \n-def get_python_path(filepath: str) -> str:\n-    \"\"\"TODO This get the python path with the (bad) assumption that there is always\n-    an __init__.py.\n \n-    This is not true since python 3.3 and is causing problem.\n+def get_python_path(filepath: str) -> str:\n+    \"\"\"Get the python path for module resolution.\n+    \n+    Updated to properly handle namespace packages (PEP 420) that don't require __init__.py.\n+    \"\"\"\n+    dirname = os.path.realpath(os.path.expanduser(filepath))\n+    if not os.path.isdir(dirname):\n+        dirname = os.path.dirname(dirname)\n+    while True:\n+        if not os.path.exists(os.path.join(dirname, \"__init__.py\")):\n+            return dirname\n+        old_dirname = dirname\n+        dirname = os.path.dirname(dirname)\n+        if old_dirname == dirname:\n     \"\"\"\n     dirname = os.path.realpath(os.path.expanduser(filepath))\n     if not os.path.isdir(dirname):\n@@ -85,13 +96,25 @@ def expand_modules(\n         if os.path.exists(something):\n             # this is a file or a directory\n             try:\n-                modname = \".\".join(\n-                    modutils.modpath_from_file(something, path=additional_search_path)\n-                )\n-            except ImportError:\n-                modname = os.path.splitext(basename)[0]\n-            if os.path.isdir(something):\n+\n+        if os.path.isdir(something):\n+            # Check if this directory is actually a Python package\n+            if modutils.check_modpath_has_init(something, path=additional_search_path):\n                 filepath = os.path.join(something, \"__init__.py\")\n+            else:\n+                # Directory without __init__.py - skip it as it's not a package\n+                continue\n+        else:\n+            filepath = something\n+\n+            if os.path.isdir(something):\n+                # Check if directory is actually a Python package\n+                init_path = os.path.join(something, \"__init__.py\")\n+                if os.path.exists(init_path):\n+                    filepath = init_path\n+                else:\n+                    # Directory without __init__.py, skip it\n+                    continue\n             else:\n                 filepath = something\n         else:\n@@ -131,11 +154,14 @@ def expand_modules(\n                     \"basename\": modname,\n                 }\n             )\n-        has_init = (\n-            not (modname.endswith(\".__init__\") or modname == \"__init__\")\n-            and os.path.basename(filepath) == \"__init__.py\"\n-        )\n-        if has_init or is_namespace or is_directory:\n+\n+        if os.path.isdir(something):\n+            if modutils.check_modpath_has_init(something):\n+                filepath = os.path.join(something, \"__init__.py\")\n+            else:\n+                # Directory without __init__.py - treat as namespace or regular directory\n+                filepath = something\n+                is_directory = True\n             for subfilepath in modutils.get_module_files(\n                 os.path.dirname(filepath), ignore_list, list_all=is_namespace\n             ):\n",
    "variant_3": "diff --git a/pylint/lint/expand_modules.py b/pylint/lint/expand_modules.py\nindex 289e1afce..ae2ca0c50 100644\n--- a/pylint/lint/expand_modules.py\n+++ b/pylint/lint/expand_modules.py\n@@ -14,6 +14,7 @@ from astroid import modutils\n from pylint.typing import ErrorDescriptionDict, ModuleDescriptionDict\n \n \n+\n def _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> list[str]:\n     def _is_package_cb(inner_path: str, parts: list[str]) -> bool:\n         return modutils.check_modpath_has_init(inner_path, parts) or is_namespace\n@@ -23,11 +24,22 @@ def _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> li\n     )\n \n \n-def get_python_path(filepath: str) -> str:\n-    \"\"\"TODO This get the python path with the (bad) assumption that there is always\n-    an __init__.py.\n \n-    This is not true since python 3.3 and is causing problem.\n+def get_python_path(filepath: str) -> str:\n+    \"\"\"Get the python path for a given filepath.\n+    \n+    Properly handles both regular packages (with __init__.py) and namespace packages\n+    (without __init__.py) since Python 3.3.\n+    \"\"\"\n+    dirname = os.path.realpath(os.path.expanduser(filepath))\n+    if not os.path.isdir(dirname):\n+        dirname = os.path.dirname(dirname)\n+    while True:\n+        if not os.path.exists(os.path.join(dirname, \"__init__.py\")):\n+            return dirname\n+        old_dirname = dirname\n+        dirname = os.path.dirname(dirname)\n+        if old_dirname == dirname:\n     \"\"\"\n     dirname = os.path.realpath(os.path.expanduser(filepath))\n     if not os.path.isdir(dirname):\n@@ -85,13 +97,25 @@ def expand_modules(\n         if os.path.exists(something):\n             # this is a file or a directory\n             try:\n-                modname = \".\".join(\n-                    modutils.modpath_from_file(something, path=additional_search_path)\n-                )\n-            except ImportError:\n-                modname = os.path.splitext(basename)[0]\n-            if os.path.isdir(something):\n+\n+        if os.path.isdir(something):\n+            # Check if this directory is actually a Python package\n+            if modutils.check_modpath_has_init(something, additional_search_path):\n                 filepath = os.path.join(something, \"__init__.py\")\n+            else:\n+                # Directory without __init__.py - skip it as it's not a valid package\n+                continue\n+        else:\n+            filepath = something\n+\n+            if os.path.isdir(something):\n+                # Check if directory is actually a Python package\n+                init_file = os.path.join(something, \"__init__.py\")\n+                if os.path.exists(init_file):\n+                    filepath = init_file\n+                else:\n+                    # Directory without __init__.py - skip it\n+                    continue\n             else:\n                 filepath = something\n         else:\n@@ -131,11 +155,15 @@ def expand_modules(\n                     \"basename\": modname,\n                 }\n             )\n-        has_init = (\n-            not (modname.endswith(\".__init__\") or modname == \"__init__\")\n-            and os.path.basename(filepath) == \"__init__.py\"\n-        )\n-        if has_init or is_namespace or is_directory:\n+\n+        if os.path.isdir(filepath):\n+            # Check if this directory is actually a package\n+            if modutils.check_modpath_has_init(filepath):\n+                # It's a package - point to __init__.py\n+                filepath = os.path.join(filepath, \"__init__.py\")\n+            else:\n+                # It's a regular directory - handle individual files within it\n+                pass\n             for subfilepath in modutils.get_module_files(\n                 os.path.dirname(filepath), ignore_list, list_all=is_namespace\n             ):\n",
    "variant_4": "diff --git a/pylint/lint/expand_modules.py b/pylint/lint/expand_modules.py\nindex 289e1afce..6766bca02 100644\n--- a/pylint/lint/expand_modules.py\n+++ b/pylint/lint/expand_modules.py\n@@ -14,6 +14,7 @@ from astroid import modutils\n from pylint.typing import ErrorDescriptionDict, ModuleDescriptionDict\n \n \n+\n def _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> list[str]:\n     def _is_package_cb(inner_path: str, parts: list[str]) -> bool:\n         return modutils.check_modpath_has_init(inner_path, parts) or is_namespace\n@@ -23,11 +24,22 @@ def _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> li\n     )\n \n \n-def get_python_path(filepath: str) -> str:\n-    \"\"\"TODO This get the python path with the (bad) assumption that there is always\n-    an __init__.py.\n \n-    This is not true since python 3.3 and is causing problem.\n+def get_python_path(filepath: str) -> str:\n+    \"\"\"Get the python path for module resolution.\n+    \n+    Properly handles both regular packages (with __init__.py) and namespace packages\n+    (without __init__.py) introduced in Python 3.3.\n+    \"\"\"\n+    dirname = os.path.realpath(os.path.expanduser(filepath))\n+    if not os.path.isdir(dirname):\n+        dirname = os.path.dirname(dirname)\n+    while True:\n+        if not os.path.exists(os.path.join(dirname, \"__init__.py\")):\n+            return dirname\n+        old_dirname = dirname\n+        dirname = os.path.dirname(dirname)\n+        if old_dirname == dirname:\n     \"\"\"\n     dirname = os.path.realpath(os.path.expanduser(filepath))\n     if not os.path.isdir(dirname):\n@@ -85,13 +97,25 @@ def expand_modules(\n         if os.path.exists(something):\n             # this is a file or a directory\n             try:\n-                modname = \".\".join(\n-                    modutils.modpath_from_file(something, path=additional_search_path)\n-                )\n-            except ImportError:\n-                modname = os.path.splitext(basename)[0]\n+\n             if os.path.isdir(something):\n-                filepath = os.path.join(something, \"__init__.py\")\n+                # Check if this directory is actually a Python package\n+                if modutils.check_modpath_has_init(something, additional_search_path):\n+                    filepath = os.path.join(something, \"__init__.py\")\n+                else:\n+                    # Directory without __init__.py - skip it as it's not a valid package\n+                    continue\n+            else:\n+                filepath = something\n+\n+            if os.path.isdir(something):\n+                # Check if this directory is actually a Python package\n+                init_file = os.path.join(something, \"__init__.py\")\n+                if os.path.exists(init_file):\n+                    filepath = init_file\n+                else:\n+                    # Directory without __init__.py - skip it as it's not a package\n+                    continue\n             else:\n                 filepath = something\n         else:\n@@ -131,11 +155,15 @@ def expand_modules(\n                     \"basename\": modname,\n                 }\n             )\n-        has_init = (\n-            not (modname.endswith(\".__init__\") or modname == \"__init__\")\n-            and os.path.basename(filepath) == \"__init__.py\"\n-        )\n-        if has_init or is_namespace or is_directory:\n+\n+        # Check if the directory is actually a package (has __init__.py)\n+        init_path = os.path.join(filepath, \"__init__.py\")\n+        if os.path.isfile(init_path):\n+            # It's a package - use the __init__.py file\n+            filepath = init_path\n+        else:\n+            # It's just a directory - handle individual files within it\n+            is_directory = True\n             for subfilepath in modutils.get_module_files(\n                 os.path.dirname(filepath), ignore_list, list_all=is_namespace\n             ):\n",
    "variant_5": "diff --git a/pylint/lint/expand_modules.py b/pylint/lint/expand_modules.py\nindex 289e1afce..2e3452c56 100644\n--- a/pylint/lint/expand_modules.py\n+++ b/pylint/lint/expand_modules.py\n@@ -14,6 +14,7 @@ from astroid import modutils\n from pylint.typing import ErrorDescriptionDict, ModuleDescriptionDict\n \n \n+\n def _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> list[str]:\n     def _is_package_cb(inner_path: str, parts: list[str]) -> bool:\n         return modutils.check_modpath_has_init(inner_path, parts) or is_namespace\n@@ -23,11 +24,22 @@ def _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> li\n     )\n \n \n-def get_python_path(filepath: str) -> str:\n-    \"\"\"TODO This get the python path with the (bad) assumption that there is always\n-    an __init__.py.\n \n-    This is not true since python 3.3 and is causing problem.\n+def get_python_path(filepath: str) -> str:\n+    \"\"\"Get the python path, properly handling namespace packages since Python 3.3.\n+    \n+    This function now correctly handles both regular packages (with __init__.py)\n+    and namespace packages (without __init__.py).\n+    \"\"\"\n+    dirname = os.path.realpath(os.path.expanduser(filepath))\n+    if not os.path.isdir(dirname):\n+        dirname = os.path.dirname(dirname)\n+    while True:\n+        if not os.path.exists(os.path.join(dirname, \"__init__.py\")):\n+            return dirname\n+        old_dirname = dirname\n+        dirname = os.path.dirname(dirname)\n+        if old_dirname == dirname:\n     \"\"\"\n     dirname = os.path.realpath(os.path.expanduser(filepath))\n     if not os.path.isdir(dirname):\n@@ -85,13 +97,25 @@ def expand_modules(\n         if os.path.exists(something):\n             # this is a file or a directory\n             try:\n-                modname = \".\".join(\n-                    modutils.modpath_from_file(something, path=additional_search_path)\n-                )\n-            except ImportError:\n-                modname = os.path.splitext(basename)[0]\n-            if os.path.isdir(something):\n+\n+        if os.path.isdir(something):\n+            # Check if this directory is actually a Python package\n+            if modutils.check_modpath_has_init(something.split(os.sep), path=additional_search_path):\n                 filepath = os.path.join(something, \"__init__.py\")\n+            else:\n+                # Directory without __init__.py - skip it as it's not a valid package\n+                continue\n+        else:\n+            filepath = something\n+\n+            if os.path.isdir(something):\n+                # Check if this directory is actually a Python package\n+                init_file = os.path.join(something, \"__init__.py\")\n+                if os.path.exists(init_file):\n+                    filepath = init_file\n+                else:\n+                    # Directory without __init__.py - skip it\n+                    continue\n             else:\n                 filepath = something\n         else:\n@@ -131,11 +155,15 @@ def expand_modules(\n                     \"basename\": modname,\n                 }\n             )\n-        has_init = (\n-            not (modname.endswith(\".__init__\") or modname == \"__init__\")\n-            and os.path.basename(filepath) == \"__init__.py\"\n-        )\n-        if has_init or is_namespace or is_directory:\n+\n+        if os.path.isdir(filepath):\n+            # Check if this directory is actually a Python package\n+            if modutils.check_modpath_has_init(filepath):\n+                # It's a package - point to __init__.py\n+                filepath = os.path.join(filepath, \"__init__.py\")\n+            else:\n+                # It's just a directory - keep the directory path for file enumeration\n+                pass\n             for subfilepath in modutils.get_module_files(\n                 os.path.dirname(filepath), ignore_list, list_all=is_namespace\n             ):\n",
    "variant_6": "diff --git a/pylint/lint/expand_modules.py b/pylint/lint/expand_modules.py\nindex 289e1afce..a6a141760 100644\n--- a/pylint/lint/expand_modules.py\n+++ b/pylint/lint/expand_modules.py\n@@ -14,6 +14,7 @@ from astroid import modutils\n from pylint.typing import ErrorDescriptionDict, ModuleDescriptionDict\n \n \n+\n def _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> list[str]:\n     def _is_package_cb(inner_path: str, parts: list[str]) -> bool:\n         return modutils.check_modpath_has_init(inner_path, parts) or is_namespace\n@@ -23,11 +24,22 @@ def _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> li\n     )\n \n \n-def get_python_path(filepath: str) -> str:\n-    \"\"\"TODO This get the python path with the (bad) assumption that there is always\n-    an __init__.py.\n \n-    This is not true since python 3.3 and is causing problem.\n+def get_python_path(filepath: str) -> str:\n+    \"\"\"Get the python path for a given filepath.\n+    \n+    Handles both regular packages (with __init__.py) and namespace packages\n+    (without __init__.py) correctly since Python 3.3.\n+    \"\"\"\n+    dirname = os.path.realpath(os.path.expanduser(filepath))\n+    if not os.path.isdir(dirname):\n+        dirname = os.path.dirname(dirname)\n+    while True:\n+        if not os.path.exists(os.path.join(dirname, \"__init__.py\")):\n+            return dirname\n+        old_dirname = dirname\n+        dirname = os.path.dirname(dirname)\n+        if old_dirname == dirname:\n     \"\"\"\n     dirname = os.path.realpath(os.path.expanduser(filepath))\n     if not os.path.isdir(dirname):\n@@ -85,13 +97,25 @@ def expand_modules(\n         if os.path.exists(something):\n             # this is a file or a directory\n             try:\n-                modname = \".\".join(\n-                    modutils.modpath_from_file(something, path=additional_search_path)\n-                )\n-            except ImportError:\n-                modname = os.path.splitext(basename)[0]\n-            if os.path.isdir(something):\n+\n+        if os.path.isdir(something):\n+            # Check if this directory is actually a Python package\n+            if modutils.check_modpath_has_init(something, additional_search_path):\n                 filepath = os.path.join(something, \"__init__.py\")\n+            else:\n+                # Directory without __init__.py - skip it as it's not a package\n+                continue\n+        else:\n+            filepath = something\n+\n+            if os.path.isdir(something):\n+                # Check if this directory is actually a Python package\n+                init_file = os.path.join(something, \"__init__.py\")\n+                if os.path.exists(init_file):\n+                    filepath = init_file\n+                else:\n+                    # Directory is not a package, skip it\n+                    continue\n             else:\n                 filepath = something\n         else:\n@@ -131,11 +155,19 @@ def expand_modules(\n                     \"basename\": modname,\n                 }\n             )\n-        has_init = (\n-            not (modname.endswith(\".__init__\") or modname == \"__init__\")\n-            and os.path.basename(filepath) == \"__init__.py\"\n-        )\n-        if has_init or is_namespace or is_directory:\n+\n+        if os.path.isdir(filepath):\n+            modname = \".\".join(modpath)\n+        else:\n+            modname = modpath[-1]\n+            modpath = modpath[:-1]\n+\n+        # Check if directory is actually a package\n+        if os.path.isdir(filepath):\n+            if modutils.check_modpath_has_init(modpath, filepath):\n+                # It's a package - use __init__.py\n+                filepath = os.path.join(filepath, \"__init__.py\")\n+            # If it's not a package, keep filepath as the directory\n             for subfilepath in modutils.get_module_files(\n                 os.path.dirname(filepath), ignore_list, list_all=is_namespace\n             ):\n",
    "variant_7": "diff --git a/pylint/lint/expand_modules.py b/pylint/lint/expand_modules.py\nindex 289e1afce..fb1ce696f 100644\n--- a/pylint/lint/expand_modules.py\n+++ b/pylint/lint/expand_modules.py\n@@ -14,6 +14,7 @@ from astroid import modutils\n from pylint.typing import ErrorDescriptionDict, ModuleDescriptionDict\n \n \n+\n def _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> list[str]:\n     def _is_package_cb(inner_path: str, parts: list[str]) -> bool:\n         return modutils.check_modpath_has_init(inner_path, parts) or is_namespace\n@@ -23,11 +24,21 @@ def _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> li\n     )\n \n \n-def get_python_path(filepath: str) -> str:\n-    \"\"\"TODO This get the python path with the (bad) assumption that there is always\n-    an __init__.py.\n \n-    This is not true since python 3.3 and is causing problem.\n+def get_python_path(filepath: str) -> str:\n+    \"\"\"Get the python path, correctly handling namespace packages since Python 3.3.\n+    \n+    Updated to properly detect packages without assuming __init__.py always exists.\n+    \"\"\"\n+    dirname = os.path.realpath(os.path.expanduser(filepath))\n+    if not os.path.isdir(dirname):\n+        dirname = os.path.dirname(dirname)\n+    while True:\n+        if not os.path.exists(os.path.join(dirname, \"__init__.py\")):\n+            return dirname\n+        old_dirname = dirname\n+        dirname = os.path.dirname(dirname)\n+        if old_dirname == dirname:\n     \"\"\"\n     dirname = os.path.realpath(os.path.expanduser(filepath))\n     if not os.path.isdir(dirname):\n@@ -85,13 +96,26 @@ def expand_modules(\n         if os.path.exists(something):\n             # this is a file or a directory\n             try:\n-                modname = \".\".join(\n-                    modutils.modpath_from_file(something, path=additional_search_path)\n-                )\n-            except ImportError:\n-                modname = os.path.splitext(basename)[0]\n+\n+        if os.path.isdir(something):\n+            # Check if this directory is actually a Python package\n+            init_path = os.path.join(something, \"__init__.py\")\n+            if os.path.exists(init_path):\n+                filepath = init_path\n+            else:\n+                # Directory without __init__.py - skip as it's not a package\n+                continue\n+        else:\n+            filepath = something\n+\n             if os.path.isdir(something):\n-                filepath = os.path.join(something, \"__init__.py\")\n+                # Check if directory is actually a Python package\n+                init_file = os.path.join(something, \"__init__.py\")\n+                if os.path.exists(init_file):\n+                    filepath = init_file\n+                else:\n+                    # Directory without __init__.py - skip it\n+                    continue\n             else:\n                 filepath = something\n         else:\n@@ -131,11 +155,14 @@ def expand_modules(\n                     \"basename\": modname,\n                 }\n             )\n-        has_init = (\n-            not (modname.endswith(\".__init__\") or modname == \"__init__\")\n-            and os.path.basename(filepath) == \"__init__.py\"\n-        )\n-        if has_init or is_namespace or is_directory:\n+\n+        if os.path.isdir(filepath):\n+            if modutils.check_modpath_has_init(filepath):\n+                # This is a package directory with __init__.py\n+                filepath = os.path.join(filepath, \"__init__.py\")\n+            else:\n+                # This is a regular directory, not a package\n+                is_directory = True\n             for subfilepath in modutils.get_module_files(\n                 os.path.dirname(filepath), ignore_list, list_all=is_namespace\n             ):\n",
    "variant_8": "diff --git a/pylint/lint/expand_modules.py b/pylint/lint/expand_modules.py\nindex 289e1afce..66c7b7c66 100644\n--- a/pylint/lint/expand_modules.py\n+++ b/pylint/lint/expand_modules.py\n@@ -14,6 +14,7 @@ from astroid import modutils\n from pylint.typing import ErrorDescriptionDict, ModuleDescriptionDict\n \n \n+\n def _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> list[str]:\n     def _is_package_cb(inner_path: str, parts: list[str]) -> bool:\n         return modutils.check_modpath_has_init(inner_path, parts) or is_namespace\n@@ -23,11 +24,22 @@ def _modpath_from_file(filename: str, is_namespace: bool, path: list[str]) -> li\n     )\n \n \n-def get_python_path(filepath: str) -> str:\n-    \"\"\"TODO This get the python path with the (bad) assumption that there is always\n-    an __init__.py.\n \n-    This is not true since python 3.3 and is causing problem.\n+def get_python_path(filepath: str) -> str:\n+    \"\"\"Get the python path for a file or directory.\n+    \n+    For directories, checks if they contain __init__.py to determine if they're packages.\n+    This handles both regular packages and namespace packages correctly.\n+    \"\"\"\n+    dirname = os.path.realpath(os.path.expanduser(filepath))\n+    if not os.path.isdir(dirname):\n+        dirname = os.path.dirname(dirname)\n+    while True:\n+        if not os.path.exists(os.path.join(dirname, \"__init__.py\")):\n+            return dirname\n+        old_dirname = dirname\n+        dirname = os.path.dirname(dirname)\n+        if old_dirname == dirname:\n     \"\"\"\n     dirname = os.path.realpath(os.path.expanduser(filepath))\n     if not os.path.isdir(dirname):\n@@ -85,13 +97,25 @@ def expand_modules(\n         if os.path.exists(something):\n             # this is a file or a directory\n             try:\n-                modname = \".\".join(\n-                    modutils.modpath_from_file(something, path=additional_search_path)\n-                )\n-            except ImportError:\n-                modname = os.path.splitext(basename)[0]\n-            if os.path.isdir(something):\n+\n+        if os.path.isdir(something):\n+            # Check if this directory is actually a Python package\n+            if modutils.check_modpath_has_init(something.split(os.sep), additional_search_path):\n                 filepath = os.path.join(something, \"__init__.py\")\n+            else:\n+                # Directory without __init__.py - skip it as it's not a package\n+                continue\n+        else:\n+            filepath = something\n+\n+            if os.path.isdir(something):\n+                # Check if directory is actually a Python package\n+                init_path = os.path.join(something, \"__init__.py\")\n+                if os.path.exists(init_path):\n+                    filepath = init_path\n+                else:\n+                    # Directory without __init__.py - skip as it's not a package\n+                    continue\n             else:\n                 filepath = something\n         else:\n@@ -131,11 +155,16 @@ def expand_modules(\n                     \"basename\": modname,\n                 }\n             )\n-        has_init = (\n-            not (modname.endswith(\".__init__\") or modname == \"__init__\")\n-            and os.path.basename(filepath) == \"__init__.py\"\n-        )\n-        if has_init or is_namespace or is_directory:\n+\n+        if os.path.isdir(filepath):\n+            # Check if this directory is actually a Python package\n+            if modutils.check_modpath_has_init(filepath):\n+                # It's a package, use __init__.py as the filepath\n+                filepath = os.path.join(filepath, \"__init__.py\")\n+            else:\n+                # It's a regular directory, not a package\n+                # We'll handle the individual files in the directory later\n+                pass\n             for subfilepath in modutils.get_module_files(\n                 os.path.dirname(filepath), ignore_list, list_all=is_namespace\n             ):\n"
  }
}