{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/django/django/db/models/query_utils.py lines 71-73)": "\n    def __and__(self, other):\n        return self._combine(other, self.AND)\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n            return Q(other) & self\n        raise TypeError(other)\n\n    def __invert__(self):\n        obj = type(self)()\n        obj.add(self, self.AND)\n        obj.negate()\n        return obj\n",
    "Location 2 (/root/hy/projects_3/django/django/db/models/query_utils.py lines 91-93)": "\n    def __and__(self, other):\n        return self._combine(other, self.AND)\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n            return Q(other) & self\n        raise TypeError(other)\n\n    def __or__(self, other):\n        return self._combine(other, self.OR)\n",
    "Location 3 (/root/hy/projects_3/django/django/db/models/expressions.py lines 92-95)": "\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n            return Q(other) & self\n        raise TypeError(\n            \"Cannot combine Q object with %r. Use bitwise operators (&, |, ~) for Q objects.\" % type(other)\n        )\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/django/django/db/models/query_utils.py lines 71-73)": [
      "\n    def __and__(self, other):\n        return self._combine(other, self.AND)\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n            return Q(other) & self\n        raise TypeError(other)\n\n    def __invert__(self):\n        obj = type(self)()\n        obj.add(self, self.AND)\n        obj.negate()\n        return obj\n",
      "\n    def __and__(self, other):\n        return self._combine(other, self.AND)\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n            return Q(other) & self\n        raise TypeError(other)\n\n    def __invert__(self):\n        obj = type(self)()\n        obj.add(self, self.AND)\n        obj.negate()\n        return obj\n",
      "\n    def __and__(self, other):\n        return self._combine(other, self.AND)\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n            return Q(other) & self\n        raise TypeError(other)\n\n    def __invert__(self):\n        obj = type(self)()\n        obj.add(self, self.AND)\n        obj.negate()\n        return obj\n",
      "\n    def __and__(self, other):\n        return self._combine(other, self.AND)\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n            return Q(other) & self\n        raise TypeError(other)\n\n    def __invert__(self):\n        obj = type(self)()\n        obj.add(self, self.AND)\n        obj.negate()\n        return obj\n",
      "\n    def __and__(self, other):\n        return self._combine(other, self.AND)\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n            return Q(other) & self\n        raise TypeError(other)\n\n    def __invert__(self):\n        obj = type(self)()\n        obj.add(self, self.AND)\n        obj.negate()\n        return obj\n",
      "\n    def __and__(self, other):\n        return self._combine(other, self.AND)\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n            return Q(other) & self\n        raise TypeError(other)\n",
      "\n    def __and__(self, other):\n        return self._combine(other, self.AND)\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n            return Q(other) & self\n        raise TypeError(other)\n\n    def __invert__(self):\n        obj = type(self)()\n        obj.add(self, self.AND)\n        obj.negate()\n        return obj\n",
      "\n    def __and__(self, other):\n        return self._combine(other, self.AND)\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n            return Q(other) & self\n        raise TypeError(other)\n\n    def __invert__(self):\n        obj = type(self)()\n        obj.add(self, self.AND)\n        obj.negate()\n        return obj\n"
    ],
    "Location 2 (/root/hy/projects_3/django/django/db/models/query_utils.py lines 91-93)": [
      "\n    def __and__(self, other):\n        return self._combine(other, self.AND)\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n            return Q(other) & self\n        raise TypeError(other)\n\n    def __or__(self, other):\n        return self._combine(other, self.OR)\n",
      "\n    def __and__(self, other):\n        return self._combine(other, self.AND)\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n            return Q(other) & self\n        raise TypeError(other)\n",
      "\n    def __and__(self, other):\n        return self._combine(other, self.AND)\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n            return Q(other) & self\n        raise TypeError(other)\n\n    def __or__(self, other):\n        return self._combine(other, self.OR)\n",
      "\n    def __and__(self, other):\n        return self._combine(other, self.AND)\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n            return Q(other) & self\n        raise TypeError(other)\n\n    def __or__(self, other):\n",
      "\n    def __and__(self, other):\n        return self._combine(other, self.AND)\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n            return Q(other) & self\n        raise TypeError(other)\n\n    def __or__(self, other):\n        return self._combine(other, self.OR)\n",
      "\n    def __and__(self, other):\n        return self._combine(other, self.AND)\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n            return Q(other) & self\n        raise TypeError(other)\n\n    def __or__(self, other):\n",
      "\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n            return Q(other) & self\n        raise TypeError(other)\n",
      "\n    def __and__(self, other):\n        return self._combine(other, self.AND)\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n            return Q(other) & self\n        raise TypeError(other)\n\n    def __or__(self, other):\n        return self._combine(other, self.OR)\n"
    ],
    "Location 3 (/root/hy/projects_3/django/django/db/models/expressions.py lines 92-95)": [
      "\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n            return Q(other) & self\n        return NotImplemented\n",
      "\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n            return Q(other) & self\n        raise TypeError(\n            \"Cannot combine Q object with non-conditional expression. \"\n            \"Use Q() wrapper or ensure the other object has conditional=True.\"\n        )\n",
      "\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n            return Q(other) & self\n        raise TypeError(\n            \"Cannot combine Q object with non-conditional expression. Use Q() to wrap the expression.\"\n        )\n",
      "\n    def __and__(self, other):\n        return self._combine(other, self.AND)\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n            return Q(other) & self\n        raise TypeError(other)\n\n    def __or__(self, other):\n        return self._combine(other, self.OR)\n",
      "\n    def __and__(self, other):\n        return self._combine(other, self.AND)\n\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n            return Q(other) & self\n        raise TypeError(other)\n\n    def __or__(self, other):\n        return self._combine(other, self.OR)\n",
      "\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n            return Q(other) & self\n        raise TypeError(\n            \"Cannot combine Q and non-Q objects. Use .filter() or Q() to wrap expressions.\"\n        )\n",
      "\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n            return Q(other) & self\n        raise TypeError(other)\n",
      "\n    def __rand__(self, other):\n        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n            return Q(other) & self\n        raise TypeError(\n            \"Cannot combine '%s' with '%s'.\" % (type(other).__name__, type(self).__name__)\n        )\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex ffc3a7fda5..d7a0f71133 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -89,6 +89,7 @@ class Combinable:\n     def __pow__(self, other):\n         return self._combine(other, self.POW, False)\n \n+\n     def __and__(self, other):\n         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n             return Q(self) & Q(other)\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex c957ffa564..ca386de9d9 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -68,8 +68,14 @@ class Q(tree.Node):\n         obj = type(self)()\n         obj.add(self, self.AND)\n         obj.negate()\n+\n         return obj\n \n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n+            return Q(other) & self\n+        raise TypeError(other)\n+\n     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n         # We must promote any new joins to left outer joins so that when Q is\n         # used as an expression, rows aren't filtered due to joins.\n@@ -88,6 +94,7 @@ class Q(tree.Node):\n         if len(self.children) == 1 and not isinstance(self.children[0], Q):\n             child = self.children[0]\n             kwargs = {child[0]: child[1]}\n+\n         else:\n             args = tuple(self.children)\n             if self.connector != self.default:\n",
    "variant_0": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex ffc3a7fda5..d5163a37f2 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -89,10 +89,13 @@ class Combinable:\n     def __pow__(self, other):\n         return self._combine(other, self.POW, False)\n \n-    def __and__(self, other):\n-        if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n-            return Q(self) & Q(other)\n-        raise NotImplementedError(\n+\n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n+            return Q(other) & self\n+        raise TypeError(\n+            \"Cannot combine Q object with %r. Use bitwise operators (&, |, ~) for Q objects.\" % type(other)\n+        )\n             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n         )\n \ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex c957ffa564..27abd8109e 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -68,9 +68,20 @@ class Q(tree.Node):\n         obj = type(self)()\n         obj.add(self, self.AND)\n         obj.negate()\n-        return obj\n \n-    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n+    def __and__(self, other):\n+        return self._combine(other, self.AND)\n+\n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n+            return Q(other) & self\n+        raise TypeError(other)\n+\n+    def __invert__(self):\n+        obj = type(self)()\n+        obj.add(self, self.AND)\n+        obj.negate()\n+        return obj\n         # We must promote any new joins to left outer joins so that when Q is\n         # used as an expression, rows aren't filtered due to joins.\n         clause, joins = query._add_q(\n@@ -88,9 +99,17 @@ class Q(tree.Node):\n         if len(self.children) == 1 and not isinstance(self.children[0], Q):\n             child = self.children[0]\n             kwargs = {child[0]: child[1]}\n-        else:\n-            args = tuple(self.children)\n-            if self.connector != self.default:\n+\n+    def __and__(self, other):\n+        return self._combine(other, self.AND)\n+\n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n+            return Q(other) & self\n+        raise TypeError(other)\n+\n+    def __or__(self, other):\n+        return self._combine(other, self.OR)\n                 kwargs = {'_connector': self.connector}\n         if self.negated:\n             kwargs['_negated'] = True\n",
    "variant_1": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex ffc3a7fda5..063ba4e793 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -89,10 +89,11 @@ class Combinable:\n     def __pow__(self, other):\n         return self._combine(other, self.POW, False)\n \n-    def __and__(self, other):\n-        if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n-            return Q(self) & Q(other)\n-        raise NotImplementedError(\n+\n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n+            return Q(other) & self\n+        return NotImplemented\n             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n         )\n \ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex c957ffa564..27abd8109e 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -68,9 +68,20 @@ class Q(tree.Node):\n         obj = type(self)()\n         obj.add(self, self.AND)\n         obj.negate()\n-        return obj\n \n-    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n+    def __and__(self, other):\n+        return self._combine(other, self.AND)\n+\n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n+            return Q(other) & self\n+        raise TypeError(other)\n+\n+    def __invert__(self):\n+        obj = type(self)()\n+        obj.add(self, self.AND)\n+        obj.negate()\n+        return obj\n         # We must promote any new joins to left outer joins so that when Q is\n         # used as an expression, rows aren't filtered due to joins.\n         clause, joins = query._add_q(\n@@ -88,9 +99,17 @@ class Q(tree.Node):\n         if len(self.children) == 1 and not isinstance(self.children[0], Q):\n             child = self.children[0]\n             kwargs = {child[0]: child[1]}\n-        else:\n-            args = tuple(self.children)\n-            if self.connector != self.default:\n+\n+    def __and__(self, other):\n+        return self._combine(other, self.AND)\n+\n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n+            return Q(other) & self\n+        raise TypeError(other)\n+\n+    def __or__(self, other):\n+        return self._combine(other, self.OR)\n                 kwargs = {'_connector': self.connector}\n         if self.negated:\n             kwargs['_negated'] = True\n",
    "variant_2": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex ffc3a7fda5..999d4a24e8 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -89,10 +89,14 @@ class Combinable:\n     def __pow__(self, other):\n         return self._combine(other, self.POW, False)\n \n-    def __and__(self, other):\n-        if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n-            return Q(self) & Q(other)\n-        raise NotImplementedError(\n+\n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n+            return Q(other) & self\n+        raise TypeError(\n+            \"Cannot combine Q object with non-conditional expression. \"\n+            \"Use Q() wrapper or ensure the other object has conditional=True.\"\n+        )\n             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n         )\n \ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex c957ffa564..3837408ca9 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -68,9 +68,20 @@ class Q(tree.Node):\n         obj = type(self)()\n         obj.add(self, self.AND)\n         obj.negate()\n-        return obj\n \n-    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n+    def __and__(self, other):\n+        return self._combine(other, self.AND)\n+\n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n+            return Q(other) & self\n+        raise TypeError(other)\n+\n+    def __invert__(self):\n+        obj = type(self)()\n+        obj.add(self, self.AND)\n+        obj.negate()\n+        return obj\n         # We must promote any new joins to left outer joins so that when Q is\n         # used as an expression, rows aren't filtered due to joins.\n         clause, joins = query._add_q(\n@@ -88,9 +99,14 @@ class Q(tree.Node):\n         if len(self.children) == 1 and not isinstance(self.children[0], Q):\n             child = self.children[0]\n             kwargs = {child[0]: child[1]}\n-        else:\n-            args = tuple(self.children)\n-            if self.connector != self.default:\n+\n+    def __and__(self, other):\n+        return self._combine(other, self.AND)\n+\n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n+            return Q(other) & self\n+        raise TypeError(other)\n                 kwargs = {'_connector': self.connector}\n         if self.negated:\n             kwargs['_negated'] = True\n",
    "variant_3": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex ffc3a7fda5..9aba1c4624 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -89,10 +89,13 @@ class Combinable:\n     def __pow__(self, other):\n         return self._combine(other, self.POW, False)\n \n-    def __and__(self, other):\n-        if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n-            return Q(self) & Q(other)\n-        raise NotImplementedError(\n+\n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n+            return Q(other) & self\n+        raise TypeError(\n+            \"Cannot combine Q object with non-conditional expression. Use Q() to wrap the expression.\"\n+        )\n             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n         )\n \ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex c957ffa564..27abd8109e 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -68,9 +68,20 @@ class Q(tree.Node):\n         obj = type(self)()\n         obj.add(self, self.AND)\n         obj.negate()\n-        return obj\n \n-    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n+    def __and__(self, other):\n+        return self._combine(other, self.AND)\n+\n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n+            return Q(other) & self\n+        raise TypeError(other)\n+\n+    def __invert__(self):\n+        obj = type(self)()\n+        obj.add(self, self.AND)\n+        obj.negate()\n+        return obj\n         # We must promote any new joins to left outer joins so that when Q is\n         # used as an expression, rows aren't filtered due to joins.\n         clause, joins = query._add_q(\n@@ -88,9 +99,17 @@ class Q(tree.Node):\n         if len(self.children) == 1 and not isinstance(self.children[0], Q):\n             child = self.children[0]\n             kwargs = {child[0]: child[1]}\n-        else:\n-            args = tuple(self.children)\n-            if self.connector != self.default:\n+\n+    def __and__(self, other):\n+        return self._combine(other, self.AND)\n+\n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n+            return Q(other) & self\n+        raise TypeError(other)\n+\n+    def __or__(self, other):\n+        return self._combine(other, self.OR)\n                 kwargs = {'_connector': self.connector}\n         if self.negated:\n             kwargs['_negated'] = True\n",
    "variant_4": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex ffc3a7fda5..532c95fae2 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -89,10 +89,17 @@ class Combinable:\n     def __pow__(self, other):\n         return self._combine(other, self.POW, False)\n \n+\n     def __and__(self, other):\n-        if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n-            return Q(self) & Q(other)\n-        raise NotImplementedError(\n+        return self._combine(other, self.AND)\n+\n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n+            return Q(other) & self\n+        raise TypeError(other)\n+\n+    def __or__(self, other):\n+        return self._combine(other, self.OR)\n             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n         )\n \ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex c957ffa564..4f45620309 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -68,9 +68,20 @@ class Q(tree.Node):\n         obj = type(self)()\n         obj.add(self, self.AND)\n         obj.negate()\n-        return obj\n \n-    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n+    def __and__(self, other):\n+        return self._combine(other, self.AND)\n+\n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n+            return Q(other) & self\n+        raise TypeError(other)\n+\n+    def __invert__(self):\n+        obj = type(self)()\n+        obj.add(self, self.AND)\n+        obj.negate()\n+        return obj\n         # We must promote any new joins to left outer joins so that when Q is\n         # used as an expression, rows aren't filtered due to joins.\n         clause, joins = query._add_q(\n@@ -88,9 +99,16 @@ class Q(tree.Node):\n         if len(self.children) == 1 and not isinstance(self.children[0], Q):\n             child = self.children[0]\n             kwargs = {child[0]: child[1]}\n-        else:\n-            args = tuple(self.children)\n-            if self.connector != self.default:\n+\n+    def __and__(self, other):\n+        return self._combine(other, self.AND)\n+\n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n+            return Q(other) & self\n+        raise TypeError(other)\n+\n+    def __or__(self, other):\n                 kwargs = {'_connector': self.connector}\n         if self.negated:\n             kwargs['_negated'] = True\n",
    "variant_5": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex ffc3a7fda5..532c95fae2 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -89,10 +89,17 @@ class Combinable:\n     def __pow__(self, other):\n         return self._combine(other, self.POW, False)\n \n+\n     def __and__(self, other):\n-        if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n-            return Q(self) & Q(other)\n-        raise NotImplementedError(\n+        return self._combine(other, self.AND)\n+\n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n+            return Q(other) & self\n+        raise TypeError(other)\n+\n+    def __or__(self, other):\n+        return self._combine(other, self.OR)\n             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n         )\n \ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex c957ffa564..27abd8109e 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -68,9 +68,20 @@ class Q(tree.Node):\n         obj = type(self)()\n         obj.add(self, self.AND)\n         obj.negate()\n-        return obj\n \n-    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n+    def __and__(self, other):\n+        return self._combine(other, self.AND)\n+\n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n+            return Q(other) & self\n+        raise TypeError(other)\n+\n+    def __invert__(self):\n+        obj = type(self)()\n+        obj.add(self, self.AND)\n+        obj.negate()\n+        return obj\n         # We must promote any new joins to left outer joins so that when Q is\n         # used as an expression, rows aren't filtered due to joins.\n         clause, joins = query._add_q(\n@@ -88,9 +99,17 @@ class Q(tree.Node):\n         if len(self.children) == 1 and not isinstance(self.children[0], Q):\n             child = self.children[0]\n             kwargs = {child[0]: child[1]}\n-        else:\n-            args = tuple(self.children)\n-            if self.connector != self.default:\n+\n+    def __and__(self, other):\n+        return self._combine(other, self.AND)\n+\n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n+            return Q(other) & self\n+        raise TypeError(other)\n+\n+    def __or__(self, other):\n+        return self._combine(other, self.OR)\n                 kwargs = {'_connector': self.connector}\n         if self.negated:\n             kwargs['_negated'] = True\n",
    "variant_6": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex ffc3a7fda5..3d3fa0ef43 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -89,10 +89,13 @@ class Combinable:\n     def __pow__(self, other):\n         return self._combine(other, self.POW, False)\n \n-    def __and__(self, other):\n-        if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n-            return Q(self) & Q(other)\n-        raise NotImplementedError(\n+\n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n+            return Q(other) & self\n+        raise TypeError(\n+            \"Cannot combine Q and non-Q objects. Use .filter() or Q() to wrap expressions.\"\n+        )\n             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n         )\n \ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex c957ffa564..8c265f5c9e 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -68,9 +68,14 @@ class Q(tree.Node):\n         obj = type(self)()\n         obj.add(self, self.AND)\n         obj.negate()\n-        return obj\n \n-    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n+    def __and__(self, other):\n+        return self._combine(other, self.AND)\n+\n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n+            return Q(other) & self\n+        raise TypeError(other)\n         # We must promote any new joins to left outer joins so that when Q is\n         # used as an expression, rows aren't filtered due to joins.\n         clause, joins = query._add_q(\n@@ -88,9 +93,16 @@ class Q(tree.Node):\n         if len(self.children) == 1 and not isinstance(self.children[0], Q):\n             child = self.children[0]\n             kwargs = {child[0]: child[1]}\n-        else:\n-            args = tuple(self.children)\n-            if self.connector != self.default:\n+\n+    def __and__(self, other):\n+        return self._combine(other, self.AND)\n+\n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n+            return Q(other) & self\n+        raise TypeError(other)\n+\n+    def __or__(self, other):\n                 kwargs = {'_connector': self.connector}\n         if self.negated:\n             kwargs['_negated'] = True\n",
    "variant_7": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex ffc3a7fda5..b25b154e32 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -89,10 +89,11 @@ class Combinable:\n     def __pow__(self, other):\n         return self._combine(other, self.POW, False)\n \n-    def __and__(self, other):\n-        if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n-            return Q(self) & Q(other)\n-        raise NotImplementedError(\n+\n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n+            return Q(other) & self\n+        raise TypeError(other)\n             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n         )\n \ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex c957ffa564..4ce6e91ad1 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -68,9 +68,20 @@ class Q(tree.Node):\n         obj = type(self)()\n         obj.add(self, self.AND)\n         obj.negate()\n-        return obj\n \n-    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n+    def __and__(self, other):\n+        return self._combine(other, self.AND)\n+\n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n+            return Q(other) & self\n+        raise TypeError(other)\n+\n+    def __invert__(self):\n+        obj = type(self)()\n+        obj.add(self, self.AND)\n+        obj.negate()\n+        return obj\n         # We must promote any new joins to left outer joins so that when Q is\n         # used as an expression, rows aren't filtered due to joins.\n         clause, joins = query._add_q(\n@@ -88,9 +99,11 @@ class Q(tree.Node):\n         if len(self.children) == 1 and not isinstance(self.children[0], Q):\n             child = self.children[0]\n             kwargs = {child[0]: child[1]}\n-        else:\n-            args = tuple(self.children)\n-            if self.connector != self.default:\n+\n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n+            return Q(other) & self\n+        raise TypeError(other)\n                 kwargs = {'_connector': self.connector}\n         if self.negated:\n             kwargs['_negated'] = True\n",
    "variant_8": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex ffc3a7fda5..70f3b54bad 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -89,10 +89,13 @@ class Combinable:\n     def __pow__(self, other):\n         return self._combine(other, self.POW, False)\n \n-    def __and__(self, other):\n-        if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n-            return Q(self) & Q(other)\n-        raise NotImplementedError(\n+\n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n+            return Q(other) & self\n+        raise TypeError(\n+            \"Cannot combine '%s' with '%s'.\" % (type(other).__name__, type(self).__name__)\n+        )\n             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n         )\n \ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex c957ffa564..27abd8109e 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -68,9 +68,20 @@ class Q(tree.Node):\n         obj = type(self)()\n         obj.add(self, self.AND)\n         obj.negate()\n-        return obj\n \n-    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n+    def __and__(self, other):\n+        return self._combine(other, self.AND)\n+\n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n+            return Q(other) & self\n+        raise TypeError(other)\n+\n+    def __invert__(self):\n+        obj = type(self)()\n+        obj.add(self, self.AND)\n+        obj.negate()\n+        return obj\n         # We must promote any new joins to left outer joins so that when Q is\n         # used as an expression, rows aren't filtered due to joins.\n         clause, joins = query._add_q(\n@@ -88,9 +99,17 @@ class Q(tree.Node):\n         if len(self.children) == 1 and not isinstance(self.children[0], Q):\n             child = self.children[0]\n             kwargs = {child[0]: child[1]}\n-        else:\n-            args = tuple(self.children)\n-            if self.connector != self.default:\n+\n+    def __and__(self, other):\n+        return self._combine(other, self.AND)\n+\n+    def __rand__(self, other):\n+        if getattr(other, 'conditional', False) and getattr(self, 'conditional', False):\n+            return Q(other) & self\n+        raise TypeError(other)\n+\n+    def __or__(self, other):\n+        return self._combine(other, self.OR)\n                 kwargs = {'_connector': self.connector}\n         if self.negated:\n             kwargs['_negated'] = True\n"
  }
}