{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/sphinx/sphinx/domains/std.py lines 46-46)": "\n# RE for option descriptions\noption_desc_re = re.compile(r'((?:/|--|-|\\+)?[^\\s=]+)(=?\\s*.*)')\n",
    "Location 2 (/root/hy/projects_3/sphinx/sphinx/domains/std.py lines 190-198)": "\nclass Cmdoption(ObjectDescription):\n    \"\"\"\n    Description of a command-line option (.. option).\n    \"\"\"\n\n    def handle_signature(self, sig: str, signode: desc_signature) -> str:\n        \"\"\"Transform an option description into RST nodes.\"\"\"\n        count = 0\n        firstname = ''\n        for potential_option in sig.split(', '):\n            potential_option = potential_option.strip()\n            if not potential_option:\n                continue\n            m = option_desc_re.match(potential_option)\n            if not m:\n                # Fallback: accept any non-empty string as a valid option\n                # Split on first whitespace or equals sign to separate option from args\n                parts = potential_option.split(None, 1)\n                if '=' in parts[0]:\n                    eq_parts = parts[0].split('=', 1)\n                    optname = eq_parts[0]\n                    args = '=' + eq_parts[1] + (' ' + parts[1] if len(parts) > 1 else '')\n                else:\n                    optname = parts[0]\n                    args = ' ' + parts[1] if len(parts) > 1 else ''\n            else:\n                optname, args = m.groups()\n            \n            if count:\n                signode += addnodes.desc_addname(', ', ', ')\n            signode += addnodes.desc_name(optname, optname)\n            signode += addnodes.desc_addname(args, args)\n            if not count:\n                firstname = optname\n                signode['allnames'] = [optname]\n            else:\n                signode['allnames'].append(optname)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/sphinx/sphinx/domains/std.py lines 46-46)": [
      "\n# RE for option descriptions\noption_desc_re = re.compile(r'((?:/|--|-|\\+)?[^\\s=]+)(=?\\s*.*)')\n",
      "\n# RE for option descriptions\noption_desc_re = re.compile(r'((?:/|--|-|\\+)?[^\\s=]+)(=?\\s*.*)')\n",
      "\n# RE for option descriptions\noption_desc_re = re.compile(r'((?:/|--|-|\\+)?[^\\s=]+)(=?\\s*.*)')\n",
      "\n# RE for option descriptions\noption_desc_re = re.compile(r'((?:/|--|-|\\+)?[^\\s=]+)(=?\\s*.*)')\n",
      "\n# RE for option descriptions\noption_desc_re = re.compile(r'((?:/|--|-|\\+)?[^\\s=]+)(=?\\s*.*)')\n",
      "\n# RE for option descriptions\noption_desc_re = re.compile(r'((?:/|--|-|\\+)?[^\\s=]+)(=?\\s*.*)')\n",
      "\n# RE for option descriptions\noption_desc_re = re.compile(r'((?:/|--|-|\\+)?[^\\s=]+)(=?\\s*.*)')\n",
      "\n# RE for option descriptions\noption_desc_re = re.compile(r'((?:/|--|-|\\+)?[^\\s=]+)(=?\\s*.*)')\n"
    ],
    "Location 2 (/root/hy/projects_3/sphinx/sphinx/domains/std.py lines 190-198)": [
      "\ndef handle_signature(self, sig: str, signode: desc_signature) -> str:\n    \"\"\"Transform an option description into RST nodes.\"\"\"\n    count = 0\n    firstname = ''\n    for potential_option in sig.split(', '):\n        potential_option = potential_option.strip()\n        m = option_desc_re.match(potential_option)\n        if not m:\n            # Fall back to accepting any non-empty string to be more permissive\n            if potential_option:\n                # Treat the entire string as the option name with no arguments\n                optname = potential_option\n                args = ''\n            else:\n                logger.warning(__('Malformed option description %r, should '\n                                  'look like \"opt\", \"-opt args\", \"--opt args\", '\n                                  '\"/opt args\" or \"+opt args\"'), potential_option,\n                               location=signode)\n                continue\n        else:\n            optname, args = m.groups()\n        \n        if count:\n            signode += addnodes.desc_addname(', ', ', ')\n        signode += addnodes.desc_name(optname, optname)\n        signode += addnodes.desc_addname(args, args)\n        if not count:\n            firstname = optname\n            signode['allnames'] = [optname]\n        else:\n            signode['allnames'].append(optname)\n",
      "\ndef handle_signature(self, sig: str, signode: desc_signature) -> str:\n    \"\"\"Transform an option description into RST nodes.\"\"\"\n    count = 0\n    firstname = ''\n    for potential_option in sig.split(', '):\n        potential_option = potential_option.strip()\n        m = option_desc_re.match(potential_option)\n        if not m:\n            # Fallback: accept any non-empty string to be more permissive\n            if potential_option:\n                # Treat the entire string as option name with no args\n                optname = potential_option\n                args = ''\n            else:\n                logger.warning(__('Malformed option description %r, should '\n                                  'look like \"opt\", \"-opt args\", \"--opt args\", '\n                                  '\"/opt args\" or \"+opt args\"'), potential_option,\n                               location=signode)\n                continue\n        else:\n            optname, args = m.groups()\n        \n        if count:\n            signode += addnodes.desc_addname(', ', ', ')\n        signode += addnodes.desc_name(optname, optname)\n        signode += addnodes.desc_addname(args, args)\n        if not count:\n            firstname = optname\n            signode['allnames'] = [optname]\n        else:\n            signode['allnames'].append(optname)\n",
      "\nclass Cmdoption(ObjectDescription):\n    \"\"\"\n    Description of a command-line option (.. option).\n    \"\"\"\n\n    def handle_signature(self, sig: str, signode: desc_signature) -> str:\n        \"\"\"Transform an option description into RST nodes.\"\"\"\n        count = 0\n        firstname = ''\n        for potential_option in sig.split(', '):\n            potential_option = potential_option.strip()\n            if not potential_option:\n                continue\n            m = option_desc_re.match(potential_option)\n            if not m:\n                # Fallback: accept any non-empty string as a valid option\n                # Split on first whitespace or equals to separate option name from args\n                parts = potential_option.split(None, 1)\n                if '=' in parts[0]:\n                    optname, rest = parts[0].split('=', 1)\n                    args = '=' + rest + (' ' + parts[1] if len(parts) > 1 else '')\n                else:\n                    optname = parts[0]\n                    args = ' ' + parts[1] if len(parts) > 1 else ''\n            else:\n                optname, args = m.groups()\n            \n            if count:\n                signode += addnodes.desc_addname(', ', ', ')\n            signode += addnodes.desc_name(optname, optname)\n            signode += addnodes.desc_addname(args, args)\n            if not count:\n                firstname = optname\n                signode['allnames'] = [optname]\n            else:\n                signode['allnames'].append(optname)\n",
      "\ndef handle_signature(self, sig: str, signode: desc_signature) -> str:\n    \"\"\"Transform an option description into RST nodes.\"\"\"\n    count = 0\n    firstname = ''\n    for potential_option in sig.split(', '):\n        potential_option = potential_option.strip()\n        m = option_desc_re.match(potential_option)\n        if not m:\n            # Fallback: accept any non-empty string after stripping whitespace\n            if potential_option:\n                # Split on first '=' or space to separate option name from args\n                if '=' in potential_option:\n                    optname, args = potential_option.split('=', 1)\n                    args = '=' + args\n                elif ' ' in potential_option:\n                    optname, args = potential_option.split(' ', 1)\n                    args = ' ' + args\n                else:\n                    optname, args = potential_option, ''\n            else:\n                logger.warning(__('Malformed option description %r, should '\n                                  'look like \"opt\", \"-opt args\", \"--opt args\", '\n                                  '\"/opt args\" or \"+opt args\"'), potential_option,\n                               location=signode)\n                continue\n        else:\n            optname, args = m.groups()\n        \n        if count:\n            signode += addnodes.desc_addname(', ', ', ')\n        signode += addnodes.desc_name(optname, optname)\n        signode += addnodes.desc_addname(args, args)\n        if not count:\n            firstname = optname\n            signode['allnames'] = [optname]\n        else:\n            signode['allnames'].append(optname)\n",
      "\nclass Cmdoption(ObjectDescription):\n    \"\"\"\n    Description of a command-line option (.. option).\n    \"\"\"\n\n    def handle_signature(self, sig: str, signode: desc_signature) -> str:\n        \"\"\"Transform an option description into RST nodes.\"\"\"\n        count = 0\n        firstname = ''\n        for potential_option in sig.split(', '):\n            potential_option = potential_option.strip()\n            if not potential_option:\n                continue\n            m = option_desc_re.match(potential_option)\n            if not m:\n                # Fallback: accept any non-empty string as a valid option\n                # Split on first whitespace to separate option name from args\n                parts = potential_option.split(None, 1)\n                optname = parts[0]\n                args = ' ' + parts[1] if len(parts) > 1 else ''\n            else:\n                optname, args = m.groups()\n            \n            if count:\n                signode += addnodes.desc_addname(', ', ', ')\n            signode += addnodes.desc_name(optname, optname)\n            signode += addnodes.desc_addname(args, args)\n            if not count:\n                firstname = optname\n                signode['allnames'] = [optname]\n            else:\n                signode['allnames'].append(optname)\n",
      "\nclass Cmdoption(ObjectDescription):\n    \"\"\"\n    Description of a command-line option (.. option).\n    \"\"\"\n\n    def handle_signature(self, sig: str, signode: desc_signature) -> str:\n        \"\"\"Transform an option description into RST nodes.\"\"\"\n        count = 0\n        firstname = ''\n        for potential_option in sig.split(', '):\n            potential_option = potential_option.strip()\n            if not potential_option:\n                continue\n            m = option_desc_re.match(potential_option)\n            if not m:\n                # Fallback: accept any non-empty string as a valid option\n                optname = potential_option.split()[0] if potential_option.split() else potential_option\n                args = potential_option[len(optname):] if len(potential_option) > len(optname) else ''\n            else:\n                optname, args = m.groups()\n            \n            if count:\n                signode += addnodes.desc_addname(', ', ', ')\n            signode += addnodes.desc_name(optname, optname)\n            signode += addnodes.desc_addname(args, args)\n            if not count:\n                firstname = optname\n                signode['allnames'] = [optname]\n            else:\n                signode['allnames'].append(optname)\n",
      "\nclass Cmdoption(ObjectDescription):\n    \"\"\"\n    Description of a command-line option (.. option).\n    \"\"\"\n\n    def handle_signature(self, sig: str, signode: desc_signature) -> str:\n        \"\"\"Transform an option description into RST nodes.\"\"\"\n        count = 0\n        firstname = ''\n        for potential_option in sig.split(', '):\n            potential_option = potential_option.strip()\n            if not potential_option:\n                continue\n            m = option_desc_re.match(potential_option)\n            if not m:\n                # Fallback: accept any non-empty string as a valid option\n                optname = potential_option.split()[0] if potential_option.split() else potential_option\n                args = potential_option[len(optname):] if len(potential_option) > len(optname) else ''\n            else:\n                optname, args = m.groups()\n            \n            if count:\n                signode += addnodes.desc_addname(', ', ', ')\n            signode += addnodes.desc_name(optname, optname)\n            signode += addnodes.desc_addname(args, args)\n            if not count:\n                firstname = optname\n                signode['allnames'] = [optname]\n            else:\n                signode['allnames'].append(optname)\n",
      "\nclass Cmdoption(ObjectDescription):\n    \"\"\"\n    Description of a command-line option (.. option).\n    \"\"\"\n\n    def handle_signature(self, sig: str, signode: desc_signature) -> str:\n        \"\"\"Transform an option description into RST nodes.\"\"\"\n        count = 0\n        firstname = ''\n        for potential_option in sig.split(', '):\n            potential_option = potential_option.strip()\n            if not potential_option:\n                continue\n            m = option_desc_re.match(potential_option)\n            if not m:\n                # Fallback: accept any non-empty string as a valid option\n                # Split on first whitespace to separate option name from args\n                parts = potential_option.split(None, 1)\n                optname = parts[0]\n                args = ' ' + parts[1] if len(parts) > 1 else ''\n            else:\n                optname, args = m.groups()\n            \n            if count:\n                signode += addnodes.desc_addname(', ', ', ')\n            signode += addnodes.desc_name(optname, optname)\n            signode += addnodes.desc_addname(args, args)\n            if not count:\n                firstname = optname\n                signode['allnames'] = [optname]\n            else:\n                signode['allnames'].append(optname)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sphinx/domains/std.py b/sphinx/domains/std.py\nindex c87217c56..16fb72c98 100644\n--- a/sphinx/domains/std.py\n+++ b/sphinx/domains/std.py\n@@ -43,7 +43,8 @@ logger = logging.getLogger(__name__)\n \n \n # RE for option descriptions\n-option_desc_re = re.compile(r'((?:/|--|-|\\+)?[^\\s=[]+)(=?\\s*.*)')\n+\n+option_desc_re = re.compile(r'((?:/|--|-|\\+)?[^\\s=]+)(=?\\s*.*)')\n # RE for grammar tokens\n token_re = re.compile(r'`(\\w+)`', re.U)\n \n@@ -187,14 +188,27 @@ class Cmdoption(ObjectDescription):\n         \"\"\"Transform an option description into RST nodes.\"\"\"\n         count = 0\n         firstname = ''\n+\n         for potential_option in sig.split(', '):\n             potential_option = potential_option.strip()\n             m = option_desc_re.match(potential_option)\n             if not m:\n-                logger.warning(__('Malformed option description %r, should '\n-                                  'look like \"opt\", \"-opt args\", \"--opt args\", '\n-                                  '\"/opt args\" or \"+opt args\"'), potential_option,\n-                               location=signode)\n+                # Fallback: accept any non-empty string to be more permissive\n+                # with diverse option syntaxes from different programs and OSes\n+                if potential_option.strip():\n+                    # Treat the entire string as the option name with no args\n+                    optname = potential_option\n+                    args = ''\n+                    if count:\n+                        signode += addnodes.desc_addname(', ', ', ')\n+                    signode += addnodes.desc_name(optname, optname)\n+                    signode += addnodes.desc_addname(args, args)\n+                    if not count:\n+                        firstname = optname\n+                        signode['allnames'] = [optname]\n+                    else:\n+                        signode['allnames'].append(optname)\n+                    count += 1\n                 continue\n             optname, args = m.groups()\n             if count:\n",
    "variant_0": "diff --git a/sphinx/domains/std.py b/sphinx/domains/std.py\nindex c87217c56..31c75e677 100644\n--- a/sphinx/domains/std.py\n+++ b/sphinx/domains/std.py\n@@ -43,7 +43,9 @@ logger = logging.getLogger(__name__)\n \n \n # RE for option descriptions\n-option_desc_re = re.compile(r'((?:/|--|-|\\+)?[^\\s=[]+)(=?\\s*.*)')\n+\n+# RE for option descriptions\n+option_desc_re = re.compile(r'((?:/|--|-|\\+)?[^\\s=]+)(=?\\s*.*)')\n # RE for grammar tokens\n token_re = re.compile(r'`(\\w+)`', re.U)\n \n@@ -178,6 +180,16 @@ class Target(SphinxDirective):\n         return self.name + '-' + name\n \n \n+class Cmdoption(ObjectDescription):\n+    \"\"\"\n+    Description of a command-line option (.. option).\n+    \"\"\"\n+\n+    def handle_signature(self, sig: str, signode: desc_signature) -> str:\n+        \"\"\"Transform an option description into RST nodes.\"\"\"\n+        count = 0\n+        firstname = ''\n+\n class Cmdoption(ObjectDescription):\n     \"\"\"\n     Description of a command-line option (.. option).\n@@ -189,13 +201,32 @@ class Cmdoption(ObjectDescription):\n         firstname = ''\n         for potential_option in sig.split(', '):\n             potential_option = potential_option.strip()\n+            if not potential_option:\n+                continue\n             m = option_desc_re.match(potential_option)\n             if not m:\n-                logger.warning(__('Malformed option description %r, should '\n-                                  'look like \"opt\", \"-opt args\", \"--opt args\", '\n-                                  '\"/opt args\" or \"+opt args\"'), potential_option,\n-                               location=signode)\n-                continue\n+                # Fallback: accept any non-empty string as a valid option\n+                # Split on first whitespace or equals sign to separate option from args\n+                parts = potential_option.split(None, 1)\n+                if '=' in parts[0]:\n+                    eq_parts = parts[0].split('=', 1)\n+                    optname = eq_parts[0]\n+                    args = '=' + eq_parts[1] + (' ' + parts[1] if len(parts) > 1 else '')\n+                else:\n+                    optname = parts[0]\n+                    args = ' ' + parts[1] if len(parts) > 1 else ''\n+            else:\n+                optname, args = m.groups()\n+            \n+            if count:\n+                signode += addnodes.desc_addname(', ', ', ')\n+            signode += addnodes.desc_name(optname, optname)\n+            signode += addnodes.desc_addname(args, args)\n+            if not count:\n+                firstname = optname\n+                signode['allnames'] = [optname]\n+            else:\n+                signode['allnames'].append(optname)\n             optname, args = m.groups()\n             if count:\n                 signode += addnodes.desc_addname(', ', ', ')\n",
    "variant_1": "diff --git a/sphinx/domains/std.py b/sphinx/domains/std.py\nindex c87217c56..5c4fd1cc2 100644\n--- a/sphinx/domains/std.py\n+++ b/sphinx/domains/std.py\n@@ -43,7 +43,9 @@ logger = logging.getLogger(__name__)\n \n \n # RE for option descriptions\n-option_desc_re = re.compile(r'((?:/|--|-|\\+)?[^\\s=[]+)(=?\\s*.*)')\n+\n+# RE for option descriptions\n+option_desc_re = re.compile(r'((?:/|--|-|\\+)?[^\\s=]+)(=?\\s*.*)')\n # RE for grammar tokens\n token_re = re.compile(r'`(\\w+)`', re.U)\n \n@@ -187,15 +189,38 @@ class Cmdoption(ObjectDescription):\n         \"\"\"Transform an option description into RST nodes.\"\"\"\n         count = 0\n         firstname = ''\n-        for potential_option in sig.split(', '):\n-            potential_option = potential_option.strip()\n-            m = option_desc_re.match(potential_option)\n-            if not m:\n+\n+def handle_signature(self, sig: str, signode: desc_signature) -> str:\n+    \"\"\"Transform an option description into RST nodes.\"\"\"\n+    count = 0\n+    firstname = ''\n+    for potential_option in sig.split(', '):\n+        potential_option = potential_option.strip()\n+        m = option_desc_re.match(potential_option)\n+        if not m:\n+            # Fall back to accepting any non-empty string to be more permissive\n+            if potential_option:\n+                # Treat the entire string as the option name with no arguments\n+                optname = potential_option\n+                args = ''\n+            else:\n                 logger.warning(__('Malformed option description %r, should '\n                                   'look like \"opt\", \"-opt args\", \"--opt args\", '\n                                   '\"/opt args\" or \"+opt args\"'), potential_option,\n                                location=signode)\n                 continue\n+        else:\n+            optname, args = m.groups()\n+        \n+        if count:\n+            signode += addnodes.desc_addname(', ', ', ')\n+        signode += addnodes.desc_name(optname, optname)\n+        signode += addnodes.desc_addname(args, args)\n+        if not count:\n+            firstname = optname\n+            signode['allnames'] = [optname]\n+        else:\n+            signode['allnames'].append(optname)\n             optname, args = m.groups()\n             if count:\n                 signode += addnodes.desc_addname(', ', ', ')\n",
    "variant_2": "diff --git a/sphinx/domains/std.py b/sphinx/domains/std.py\nindex c87217c56..b06edaf9d 100644\n--- a/sphinx/domains/std.py\n+++ b/sphinx/domains/std.py\n@@ -43,7 +43,9 @@ logger = logging.getLogger(__name__)\n \n \n # RE for option descriptions\n-option_desc_re = re.compile(r'((?:/|--|-|\\+)?[^\\s=[]+)(=?\\s*.*)')\n+\n+# RE for option descriptions\n+option_desc_re = re.compile(r'((?:/|--|-|\\+)?[^\\s=]+)(=?\\s*.*)')\n # RE for grammar tokens\n token_re = re.compile(r'`(\\w+)`', re.U)\n \n@@ -187,15 +189,38 @@ class Cmdoption(ObjectDescription):\n         \"\"\"Transform an option description into RST nodes.\"\"\"\n         count = 0\n         firstname = ''\n-        for potential_option in sig.split(', '):\n-            potential_option = potential_option.strip()\n-            m = option_desc_re.match(potential_option)\n-            if not m:\n+\n+def handle_signature(self, sig: str, signode: desc_signature) -> str:\n+    \"\"\"Transform an option description into RST nodes.\"\"\"\n+    count = 0\n+    firstname = ''\n+    for potential_option in sig.split(', '):\n+        potential_option = potential_option.strip()\n+        m = option_desc_re.match(potential_option)\n+        if not m:\n+            # Fallback: accept any non-empty string to be more permissive\n+            if potential_option:\n+                # Treat the entire string as option name with no args\n+                optname = potential_option\n+                args = ''\n+            else:\n                 logger.warning(__('Malformed option description %r, should '\n                                   'look like \"opt\", \"-opt args\", \"--opt args\", '\n                                   '\"/opt args\" or \"+opt args\"'), potential_option,\n                                location=signode)\n                 continue\n+        else:\n+            optname, args = m.groups()\n+        \n+        if count:\n+            signode += addnodes.desc_addname(', ', ', ')\n+        signode += addnodes.desc_name(optname, optname)\n+        signode += addnodes.desc_addname(args, args)\n+        if not count:\n+            firstname = optname\n+            signode['allnames'] = [optname]\n+        else:\n+            signode['allnames'].append(optname)\n             optname, args = m.groups()\n             if count:\n                 signode += addnodes.desc_addname(', ', ', ')\n",
    "variant_3": "diff --git a/sphinx/domains/std.py b/sphinx/domains/std.py\nindex c87217c56..cc1498909 100644\n--- a/sphinx/domains/std.py\n+++ b/sphinx/domains/std.py\n@@ -43,7 +43,9 @@ logger = logging.getLogger(__name__)\n \n \n # RE for option descriptions\n-option_desc_re = re.compile(r'((?:/|--|-|\\+)?[^\\s=[]+)(=?\\s*.*)')\n+\n+# RE for option descriptions\n+option_desc_re = re.compile(r'((?:/|--|-|\\+)?[^\\s=]+)(=?\\s*.*)')\n # RE for grammar tokens\n token_re = re.compile(r'`(\\w+)`', re.U)\n \n@@ -178,6 +180,16 @@ class Target(SphinxDirective):\n         return self.name + '-' + name\n \n \n+class Cmdoption(ObjectDescription):\n+    \"\"\"\n+    Description of a command-line option (.. option).\n+    \"\"\"\n+\n+    def handle_signature(self, sig: str, signode: desc_signature) -> str:\n+        \"\"\"Transform an option description into RST nodes.\"\"\"\n+        count = 0\n+        firstname = ''\n+\n class Cmdoption(ObjectDescription):\n     \"\"\"\n     Description of a command-line option (.. option).\n@@ -189,13 +201,31 @@ class Cmdoption(ObjectDescription):\n         firstname = ''\n         for potential_option in sig.split(', '):\n             potential_option = potential_option.strip()\n+            if not potential_option:\n+                continue\n             m = option_desc_re.match(potential_option)\n             if not m:\n-                logger.warning(__('Malformed option description %r, should '\n-                                  'look like \"opt\", \"-opt args\", \"--opt args\", '\n-                                  '\"/opt args\" or \"+opt args\"'), potential_option,\n-                               location=signode)\n-                continue\n+                # Fallback: accept any non-empty string as a valid option\n+                # Split on first whitespace or equals to separate option name from args\n+                parts = potential_option.split(None, 1)\n+                if '=' in parts[0]:\n+                    optname, rest = parts[0].split('=', 1)\n+                    args = '=' + rest + (' ' + parts[1] if len(parts) > 1 else '')\n+                else:\n+                    optname = parts[0]\n+                    args = ' ' + parts[1] if len(parts) > 1 else ''\n+            else:\n+                optname, args = m.groups()\n+            \n+            if count:\n+                signode += addnodes.desc_addname(', ', ', ')\n+            signode += addnodes.desc_name(optname, optname)\n+            signode += addnodes.desc_addname(args, args)\n+            if not count:\n+                firstname = optname\n+                signode['allnames'] = [optname]\n+            else:\n+                signode['allnames'].append(optname)\n             optname, args = m.groups()\n             if count:\n                 signode += addnodes.desc_addname(', ', ', ')\n",
    "variant_4": "diff --git a/sphinx/domains/std.py b/sphinx/domains/std.py\nindex c87217c56..ce07b8296 100644\n--- a/sphinx/domains/std.py\n+++ b/sphinx/domains/std.py\n@@ -43,7 +43,9 @@ logger = logging.getLogger(__name__)\n \n \n # RE for option descriptions\n-option_desc_re = re.compile(r'((?:/|--|-|\\+)?[^\\s=[]+)(=?\\s*.*)')\n+\n+# RE for option descriptions\n+option_desc_re = re.compile(r'((?:/|--|-|\\+)?[^\\s=]+)(=?\\s*.*)')\n # RE for grammar tokens\n token_re = re.compile(r'`(\\w+)`', re.U)\n \n@@ -187,15 +189,44 @@ class Cmdoption(ObjectDescription):\n         \"\"\"Transform an option description into RST nodes.\"\"\"\n         count = 0\n         firstname = ''\n-        for potential_option in sig.split(', '):\n-            potential_option = potential_option.strip()\n-            m = option_desc_re.match(potential_option)\n-            if not m:\n+\n+def handle_signature(self, sig: str, signode: desc_signature) -> str:\n+    \"\"\"Transform an option description into RST nodes.\"\"\"\n+    count = 0\n+    firstname = ''\n+    for potential_option in sig.split(', '):\n+        potential_option = potential_option.strip()\n+        m = option_desc_re.match(potential_option)\n+        if not m:\n+            # Fallback: accept any non-empty string after stripping whitespace\n+            if potential_option:\n+                # Split on first '=' or space to separate option name from args\n+                if '=' in potential_option:\n+                    optname, args = potential_option.split('=', 1)\n+                    args = '=' + args\n+                elif ' ' in potential_option:\n+                    optname, args = potential_option.split(' ', 1)\n+                    args = ' ' + args\n+                else:\n+                    optname, args = potential_option, ''\n+            else:\n                 logger.warning(__('Malformed option description %r, should '\n                                   'look like \"opt\", \"-opt args\", \"--opt args\", '\n                                   '\"/opt args\" or \"+opt args\"'), potential_option,\n                                location=signode)\n                 continue\n+        else:\n+            optname, args = m.groups()\n+        \n+        if count:\n+            signode += addnodes.desc_addname(', ', ', ')\n+        signode += addnodes.desc_name(optname, optname)\n+        signode += addnodes.desc_addname(args, args)\n+        if not count:\n+            firstname = optname\n+            signode['allnames'] = [optname]\n+        else:\n+            signode['allnames'].append(optname)\n             optname, args = m.groups()\n             if count:\n                 signode += addnodes.desc_addname(', ', ', ')\n",
    "variant_5": "diff --git a/sphinx/domains/std.py b/sphinx/domains/std.py\nindex c87217c56..7eef7bd29 100644\n--- a/sphinx/domains/std.py\n+++ b/sphinx/domains/std.py\n@@ -43,7 +43,9 @@ logger = logging.getLogger(__name__)\n \n \n # RE for option descriptions\n-option_desc_re = re.compile(r'((?:/|--|-|\\+)?[^\\s=[]+)(=?\\s*.*)')\n+\n+# RE for option descriptions\n+option_desc_re = re.compile(r'((?:/|--|-|\\+)?[^\\s=]+)(=?\\s*.*)')\n # RE for grammar tokens\n token_re = re.compile(r'`(\\w+)`', re.U)\n \n@@ -178,6 +180,16 @@ class Target(SphinxDirective):\n         return self.name + '-' + name\n \n \n+class Cmdoption(ObjectDescription):\n+    \"\"\"\n+    Description of a command-line option (.. option).\n+    \"\"\"\n+\n+    def handle_signature(self, sig: str, signode: desc_signature) -> str:\n+        \"\"\"Transform an option description into RST nodes.\"\"\"\n+        count = 0\n+        firstname = ''\n+\n class Cmdoption(ObjectDescription):\n     \"\"\"\n     Description of a command-line option (.. option).\n@@ -189,13 +201,27 @@ class Cmdoption(ObjectDescription):\n         firstname = ''\n         for potential_option in sig.split(', '):\n             potential_option = potential_option.strip()\n+            if not potential_option:\n+                continue\n             m = option_desc_re.match(potential_option)\n             if not m:\n-                logger.warning(__('Malformed option description %r, should '\n-                                  'look like \"opt\", \"-opt args\", \"--opt args\", '\n-                                  '\"/opt args\" or \"+opt args\"'), potential_option,\n-                               location=signode)\n-                continue\n+                # Fallback: accept any non-empty string as a valid option\n+                # Split on first whitespace to separate option name from args\n+                parts = potential_option.split(None, 1)\n+                optname = parts[0]\n+                args = ' ' + parts[1] if len(parts) > 1 else ''\n+            else:\n+                optname, args = m.groups()\n+            \n+            if count:\n+                signode += addnodes.desc_addname(', ', ', ')\n+            signode += addnodes.desc_name(optname, optname)\n+            signode += addnodes.desc_addname(args, args)\n+            if not count:\n+                firstname = optname\n+                signode['allnames'] = [optname]\n+            else:\n+                signode['allnames'].append(optname)\n             optname, args = m.groups()\n             if count:\n                 signode += addnodes.desc_addname(', ', ', ')\n",
    "variant_6": "diff --git a/sphinx/domains/std.py b/sphinx/domains/std.py\nindex c87217c56..4a540ad1b 100644\n--- a/sphinx/domains/std.py\n+++ b/sphinx/domains/std.py\n@@ -43,7 +43,9 @@ logger = logging.getLogger(__name__)\n \n \n # RE for option descriptions\n-option_desc_re = re.compile(r'((?:/|--|-|\\+)?[^\\s=[]+)(=?\\s*.*)')\n+\n+# RE for option descriptions\n+option_desc_re = re.compile(r'((?:/|--|-|\\+)?[^\\s=]+)(=?\\s*.*)')\n # RE for grammar tokens\n token_re = re.compile(r'`(\\w+)`', re.U)\n \n@@ -178,6 +180,16 @@ class Target(SphinxDirective):\n         return self.name + '-' + name\n \n \n+class Cmdoption(ObjectDescription):\n+    \"\"\"\n+    Description of a command-line option (.. option).\n+    \"\"\"\n+\n+    def handle_signature(self, sig: str, signode: desc_signature) -> str:\n+        \"\"\"Transform an option description into RST nodes.\"\"\"\n+        count = 0\n+        firstname = ''\n+\n class Cmdoption(ObjectDescription):\n     \"\"\"\n     Description of a command-line option (.. option).\n@@ -189,13 +201,25 @@ class Cmdoption(ObjectDescription):\n         firstname = ''\n         for potential_option in sig.split(', '):\n             potential_option = potential_option.strip()\n+            if not potential_option:\n+                continue\n             m = option_desc_re.match(potential_option)\n             if not m:\n-                logger.warning(__('Malformed option description %r, should '\n-                                  'look like \"opt\", \"-opt args\", \"--opt args\", '\n-                                  '\"/opt args\" or \"+opt args\"'), potential_option,\n-                               location=signode)\n-                continue\n+                # Fallback: accept any non-empty string as a valid option\n+                optname = potential_option.split()[0] if potential_option.split() else potential_option\n+                args = potential_option[len(optname):] if len(potential_option) > len(optname) else ''\n+            else:\n+                optname, args = m.groups()\n+            \n+            if count:\n+                signode += addnodes.desc_addname(', ', ', ')\n+            signode += addnodes.desc_name(optname, optname)\n+            signode += addnodes.desc_addname(args, args)\n+            if not count:\n+                firstname = optname\n+                signode['allnames'] = [optname]\n+            else:\n+                signode['allnames'].append(optname)\n             optname, args = m.groups()\n             if count:\n                 signode += addnodes.desc_addname(', ', ', ')\n",
    "variant_7": "diff --git a/sphinx/domains/std.py b/sphinx/domains/std.py\nindex c87217c56..4a540ad1b 100644\n--- a/sphinx/domains/std.py\n+++ b/sphinx/domains/std.py\n@@ -43,7 +43,9 @@ logger = logging.getLogger(__name__)\n \n \n # RE for option descriptions\n-option_desc_re = re.compile(r'((?:/|--|-|\\+)?[^\\s=[]+)(=?\\s*.*)')\n+\n+# RE for option descriptions\n+option_desc_re = re.compile(r'((?:/|--|-|\\+)?[^\\s=]+)(=?\\s*.*)')\n # RE for grammar tokens\n token_re = re.compile(r'`(\\w+)`', re.U)\n \n@@ -178,6 +180,16 @@ class Target(SphinxDirective):\n         return self.name + '-' + name\n \n \n+class Cmdoption(ObjectDescription):\n+    \"\"\"\n+    Description of a command-line option (.. option).\n+    \"\"\"\n+\n+    def handle_signature(self, sig: str, signode: desc_signature) -> str:\n+        \"\"\"Transform an option description into RST nodes.\"\"\"\n+        count = 0\n+        firstname = ''\n+\n class Cmdoption(ObjectDescription):\n     \"\"\"\n     Description of a command-line option (.. option).\n@@ -189,13 +201,25 @@ class Cmdoption(ObjectDescription):\n         firstname = ''\n         for potential_option in sig.split(', '):\n             potential_option = potential_option.strip()\n+            if not potential_option:\n+                continue\n             m = option_desc_re.match(potential_option)\n             if not m:\n-                logger.warning(__('Malformed option description %r, should '\n-                                  'look like \"opt\", \"-opt args\", \"--opt args\", '\n-                                  '\"/opt args\" or \"+opt args\"'), potential_option,\n-                               location=signode)\n-                continue\n+                # Fallback: accept any non-empty string as a valid option\n+                optname = potential_option.split()[0] if potential_option.split() else potential_option\n+                args = potential_option[len(optname):] if len(potential_option) > len(optname) else ''\n+            else:\n+                optname, args = m.groups()\n+            \n+            if count:\n+                signode += addnodes.desc_addname(', ', ', ')\n+            signode += addnodes.desc_name(optname, optname)\n+            signode += addnodes.desc_addname(args, args)\n+            if not count:\n+                firstname = optname\n+                signode['allnames'] = [optname]\n+            else:\n+                signode['allnames'].append(optname)\n             optname, args = m.groups()\n             if count:\n                 signode += addnodes.desc_addname(', ', ', ')\n",
    "variant_8": "diff --git a/sphinx/domains/std.py b/sphinx/domains/std.py\nindex c87217c56..7eef7bd29 100644\n--- a/sphinx/domains/std.py\n+++ b/sphinx/domains/std.py\n@@ -43,7 +43,9 @@ logger = logging.getLogger(__name__)\n \n \n # RE for option descriptions\n-option_desc_re = re.compile(r'((?:/|--|-|\\+)?[^\\s=[]+)(=?\\s*.*)')\n+\n+# RE for option descriptions\n+option_desc_re = re.compile(r'((?:/|--|-|\\+)?[^\\s=]+)(=?\\s*.*)')\n # RE for grammar tokens\n token_re = re.compile(r'`(\\w+)`', re.U)\n \n@@ -178,6 +180,16 @@ class Target(SphinxDirective):\n         return self.name + '-' + name\n \n \n+class Cmdoption(ObjectDescription):\n+    \"\"\"\n+    Description of a command-line option (.. option).\n+    \"\"\"\n+\n+    def handle_signature(self, sig: str, signode: desc_signature) -> str:\n+        \"\"\"Transform an option description into RST nodes.\"\"\"\n+        count = 0\n+        firstname = ''\n+\n class Cmdoption(ObjectDescription):\n     \"\"\"\n     Description of a command-line option (.. option).\n@@ -189,13 +201,27 @@ class Cmdoption(ObjectDescription):\n         firstname = ''\n         for potential_option in sig.split(', '):\n             potential_option = potential_option.strip()\n+            if not potential_option:\n+                continue\n             m = option_desc_re.match(potential_option)\n             if not m:\n-                logger.warning(__('Malformed option description %r, should '\n-                                  'look like \"opt\", \"-opt args\", \"--opt args\", '\n-                                  '\"/opt args\" or \"+opt args\"'), potential_option,\n-                               location=signode)\n-                continue\n+                # Fallback: accept any non-empty string as a valid option\n+                # Split on first whitespace to separate option name from args\n+                parts = potential_option.split(None, 1)\n+                optname = parts[0]\n+                args = ' ' + parts[1] if len(parts) > 1 else ''\n+            else:\n+                optname, args = m.groups()\n+            \n+            if count:\n+                signode += addnodes.desc_addname(', ', ', ')\n+            signode += addnodes.desc_name(optname, optname)\n+            signode += addnodes.desc_addname(args, args)\n+            if not count:\n+                firstname = optname\n+                signode['allnames'] = [optname]\n+            else:\n+                signode['allnames'].append(optname)\n             optname, args = m.groups()\n             if count:\n                 signode += addnodes.desc_addname(', ', ', ')\n"
  }
}