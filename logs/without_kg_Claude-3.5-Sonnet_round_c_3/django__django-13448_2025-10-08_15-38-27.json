{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/django/django/db/backends/base/creation.py lines 77-78)": "\n        if serialize:\n            # Only serialize if migrations were run, otherwise skip to avoid querying non-existent tables\n            migrate_setting = self.connection.settings_dict.get('TEST', {}).get('MIGRATE', True)\n            if migrate_setting is not False:\n                self.connection._test_serialized_contents = self.serialize_db_to_string()\n            else:\n                self.connection._test_serialized_contents = None\n",
    "Location 2 (/root/hy/projects_3/django/django/db/backends/base/creation.py lines 94-122)": "\ndef serialize_db_to_string(self):\n    \"\"\"\n    Serialize all data in the database into a JSON string.\n    Designed only for test runner usage; will not handle large\n    amounts of data.\n    \"\"\"\n    # Check if migrations were run by verifying core Django tables exist\n    try:\n        with self.connection.cursor() as cursor:\n            cursor.execute(\"SELECT 1 FROM django_migrations LIMIT 1\")\n    except Exception:\n        # If django_migrations table doesn't exist, migrations weren't run\n        # Return empty serialization instead of crashing\n        return '[]'\n    \n    # Iteratively return every object for all models to serialize.\n    def get_objects():\n        from django.db.migrations.loader import MigrationLoader\n        loader = MigrationLoader(self.connection)\n        for app_config in apps.get_app_configs():\n            if (\n                app_config.models_module is not None and\n                app_config.label in loader.migrated_apps and\n                app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n            ):\n                for model in app_config.get_models():\n                    if (\n                        model._meta.can_migrate(self.connection) and\n                        router.allow_migrate_model(self.connection.alias, model)\n                    ):\n                        try:\n                            queryset = model._default_manager.using(\n                                self.connection.alias,\n                            ).order_by(model._meta.pk.name)\n                            yield from queryset.iterator()\n                        except Exception:\n                            # Skip models whose tables don't exist (e.g., when MIGRATE=False)\n                            continue\n    # Serialize to a string\n    out = StringIO()\n    serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n    return out.getvalue()\n",
    "Location 3 (/root/hy/projects_3/django/django/db/backends/base/creation.py lines 100-118)": "\ndef create_test_db(self, verbosity=1, autoclobber=False, serialize=True, keepdb=False):\n    \"\"\"\n    Create a test database, prompting the user for confirmation if the\n    database already exists. Return the name of the test database created.\n    \"\"\"\n    # Don't import django.core.management if it isn't needed.\n    from django.core.management import call_command\n\n    test_database_name = self._get_test_db_name()\n\n    if verbosity >= 1:\n        action = 'Creating'\n        if keepdb:\n            action = 'Using existing'\n\n        self.log('%s test database for alias %s (%r)...' % (\n            action,\n            self.connection.alias,\n            test_database_name,\n        ))\n\n    # We could skip this call if keepdb is True, but we instead\n    # give it the keepdb param. This is to handle the case\n    # where the test DB doesn't exist, in which case we need to\n    # create it, then just not destroy it. If we instead skip\n    # this, we will get an exception.\n    self._create_test_db(test_database_name, verbosity, keepdb)\n\n    self.connection.close()\n    settings_dict = self.connection.settings_dict.copy()\n    settings_dict['NAME'] = test_database_name\n    # conn.settings_dict references the same dictionary as the\n    # settings_dict local variable.\n    self.connection.settings_dict['NAME'] = test_database_name\n\n    try:\n        self.connection.ensure_connection()\n        if not keepdb:\n            # Check if migrations should be run before deciding to serialize\n            test_settings = settings_dict.get('TEST', {})\n            should_migrate = test_settings.get('MIGRATE', True)\n            \n            # Only serialize if migrations are being run\n            if serialize and should_migrate:\n                self.connection.ops.disable_constraint_checking()\n                for app_config in apps.get_app_configs():\n                    if (\n                        app_config.models_module is not None and\n                        app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n                    ):\n                        for model in app_config.get_models():\n                            if model._meta.can_migrate(self.connection):\n                                management.call_command(\n                                    'loaddata',\n                                    verbosity=verbosity,\n                                    database=self.connection.alias,\n                                )\n                                break\n                self.connection.ops.enable_constraint_checking()\n            if serialize and should_migrate:\n                self.connection._test_serialized_contents = self.serialize_db_to_string()\n    except Exception:\n        if not keepdb:\n            try:\n                self.destroy_test_db(test_database_name, verbosity, keepdb=True)\n            except Exception as e:\n                self.log('Got an error destroying the test database: %s' % e)\n        raise\n    return test_database_name\n",
    "Location 4 (/root/hy/projects_3/django/django/test/utils.py lines 183-183)": "\n                serialize=connection.settings_dict['TEST'].get('SERIALIZE', True) and connection.settings_dict['TEST'].get('MIGRATE', True),\n",
    "Location 5 (/root/hy/projects_3/django/django/test/utils.py lines 179-184)": "\n                connection.creation.create_test_db(\n                    verbosity=verbosity,\n                    autoclobber=not interactive,\n                    keepdb=keepdb,\n                    serialize=connection.settings_dict['TEST'].get('SERIALIZE', True) and connection.settings_dict['TEST'].get('MIGRATE', True),\n                )\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/django/django/db/backends/base/creation.py lines 77-78)": [
      "\n        if serialize:\n            # Check if migrations were run by verifying TEST MIGRATE setting\n            test_settings = self.connection.settings_dict.get('TEST', {})\n            migrate_enabled = test_settings.get('MIGRATE', True)\n            \n            if migrate_enabled:\n                self.connection._test_serialized_contents = self.serialize_db_to_string()\n            else:\n                # Skip serialization when migrations are disabled\n                self.connection._test_serialized_contents = None\n",
      "\n        # We then serialize the current state of the database into a string\n        # and store it on the connection. This slightly horrific process is so people\n        # who are testing on databases without transactions or who are using\n        # a TransactionTestCase still get a clean database on every test run.\n        if serialize:\n            # Check if migrations were run by verifying TEST MIGRATE setting\n            test_settings = self.connection.settings_dict.get('TEST', {})\n            migrate_enabled = test_settings.get('MIGRATE', True)\n            \n            if migrate_enabled:\n                self.connection._test_serialized_contents = self.serialize_db_to_string()\n            else:\n                # Skip serialization when migrations are disabled since tables may not exist\n                self.connection._test_serialized_contents = None\n",
      "\n        if serialize:\n            # Only serialize if migrations were run, otherwise skip to avoid querying non-existent tables\n            migrate_setting = self.connection.settings_dict.get('TEST', {}).get('MIGRATE', True)\n            if migrate_setting:\n                self.connection._test_serialized_contents = self.serialize_db_to_string()\n            else:\n                self.connection._test_serialized_contents = None\n",
      "\n        if serialize:\n            # Check if migrations were run by verifying test settings\n            test_settings = self.connection.settings_dict.get('TEST', {})\n            migrate_setting = test_settings.get('MIGRATE', True)\n            \n            # Only serialize if migrations were actually run\n            if migrate_setting:\n                self.connection._test_serialized_contents = self.serialize_db_to_string()\n            else:\n                # Skip serialization when migrations are disabled\n                self.connection._test_serialized_contents = None\n",
      "\n        if serialize:\n            # Check if migrations were run by verifying if core Django tables exist\n            # If MIGRATE is False, skip serialization to avoid querying non-existent tables\n            migrate_setting = self.connection.settings_dict.get('TEST', {}).get('MIGRATE', True)\n            if migrate_setting is False:\n                # Skip serialization when migrations are disabled\n                self.connection._test_serialized_contents = None\n            else:\n                # Verify that core Django tables exist before attempting serialization\n                try:\n                    with self.connection.cursor() as cursor:\n                        # Check if django_content_type table exists as a proxy for migrations being run\n                        cursor.execute(\"SELECT 1 FROM django_content_type LIMIT 1\")\n                    self.connection._test_serialized_contents = self.serialize_db_to_string()\n                except Exception:\n                    # If core tables don't exist, skip serialization\n                    self.connection._test_serialized_contents = None\n",
      "\n        # We then serialize the current state of the database into a string\n        # and store it on the connection. This slightly horrific process is so people\n        # who are testing on databases without transactions or who are using\n        # a TransactionTestCase still get a clean database on every test run.\n        if serialize:\n            # Check if migrations were run by looking at the test settings\n            migrate_setting = self.connection.settings_dict.get('TEST', {}).get('MIGRATE', True)\n            if migrate_setting:\n                self.connection._test_serialized_contents = self.serialize_db_to_string()\n            else:\n                # Skip serialization when migrations are disabled since tables may not exist\n                self.connection._test_serialized_contents = None\n",
      "\n        # We then serialize the current state of the database into a string\n        # and store it on the connection. This slightly horrific process is so people\n        # who are testing on databases without transactions or who are using\n        # a TransactionTestCase still get a clean database on every test run.\n        if serialize:\n            # Check if migrations were actually run before attempting serialization\n            # If MIGRATE is False, the database may not have the required tables\n            test_settings = self.connection.settings_dict.get('TEST', {})\n            migrate_setting = test_settings.get('MIGRATE', True)\n            \n            if migrate_setting:\n                self.connection._test_serialized_contents = self.serialize_db_to_string()\n            else:\n                # Skip serialization when migrations are disabled to avoid querying non-existent tables\n                self.connection._test_serialized_contents = None\n",
      "\n        # We then serialize the current state of the database into a string\n        # and store it on the connection. This slightly horrific process is so people\n        # who are testing on databases without transactions or who are using\n        # a TransactionTestCase still get a clean database on every test run.\n        if serialize:\n            # Check if migrations were run by looking at the test settings\n            test_migrate = self.connection.settings_dict.get('TEST', {}).get('MIGRATE', True)\n            if test_migrate:\n                self.connection._test_serialized_contents = self.serialize_db_to_string()\n            else:\n                # Skip serialization when migrations are disabled since tables may not exist\n                self.connection._test_serialized_contents = None\n"
    ],
    "Location 2 (/root/hy/projects_3/django/django/db/backends/base/creation.py lines 94-122)": [
      "\n    def serialize_db_to_string(self):\n        \"\"\"\n        Serialize all data in the database into a JSON string.\n        Designed only for test runner usage; will not handle large\n        amounts of data.\n        \"\"\"\n        # Check if migrations were run by verifying core Django tables exist\n        try:\n            with self.connection.cursor() as cursor:\n                cursor.execute(\"SELECT 1 FROM django_migrations LIMIT 1\")\n        except Exception:\n            # If django_migrations table doesn't exist, migrations weren't run\n            # Return empty serialization to avoid querying non-existent tables\n            return \"[]\"\n        \n        # Iteratively return every object for all models to serialize.\n        def get_objects():\n            from django.db.migrations.loader import MigrationLoader\n            loader = MigrationLoader(self.connection)\n            for app_config in apps.get_app_configs():\n                if (\n                    app_config.models_module is not None and\n                    app_config.label in loader.migrated_apps and\n                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n                ):\n                    for model in app_config.get_models():\n                        if (\n                            model._meta.can_migrate(self.connection) and\n                            router.allow_migrate_model(self.connection.alias, model)\n                        ):\n                            try:\n                                queryset = model._default_manager.using(\n                                    self.connection.alias,\n                                ).order_by(model._meta.pk.name)\n                                yield from queryset.iterator()\n                            except Exception:\n                                # Skip models whose tables don't exist\n                                continue\n        # Serialize to a string\n        out = StringIO()\n        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n        return out.getvalue()\n",
      "\ndef serialize_db_to_string(self):\n    \"\"\"\n    Serialize all data in the database into a JSON string.\n    Designed only for test runner usage; will not handle large\n    amounts of data.\n    \"\"\"\n    # Check if migrations have been run by verifying core Django tables exist\n    from django.db import connection\n    from django.core.management.color import no_style\n    \n    try:\n        # Check if django_migrations table exists (created during migrations)\n        with connection.cursor() as cursor:\n            cursor.execute(\n                \"SELECT 1 FROM information_schema.tables WHERE table_name = 'django_migrations'\"\n                if connection.vendor == 'postgresql' else\n                \"SELECT 1 FROM sqlite_master WHERE type='table' AND name='django_migrations'\"\n                if connection.vendor == 'sqlite' else\n                \"SELECT 1 FROM information_schema.tables WHERE table_name = 'django_migrations'\"\n            )\n            if not cursor.fetchone():\n                # No migrations table found, return empty serialization\n                return '[]'\n    except Exception:\n        # If we can't check for migrations table, assume no migrations and return empty\n        return '[]'\n    \n    # Iteratively return every object for all models to serialize.\n    def get_objects():\n        from django.db.migrations.loader import MigrationLoader\n        loader = MigrationLoader(self.connection)\n        for app_config in apps.get_app_configs():\n            if (\n                app_config.models_module is not None and\n                app_config.label in loader.migrated_apps and\n                app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n            ):\n                for model in app_config.get_models():\n                    if (\n                        model._meta.can_migrate(self.connection) and\n                        router.allow_migrate_model(self.connection.alias, model)\n                    ):\n                        try:\n                            queryset = model._default_manager.using(\n                                self.connection.alias,\n                            ).order_by(model._meta.pk.name)\n                            yield from queryset.iterator()\n                        except Exception:\n                            # Skip models whose tables don't exist\n                            continue\n    # Serialize to a string\n    out = StringIO()\n    serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n    return out.getvalue()\n",
      "\ndef serialize_db_to_string(self):\n    \"\"\"\n    Serialize all data in the database into a JSON string.\n    Designed only for test runner usage; will not handle large\n    amounts of data.\n    \"\"\"\n    # Check if migrations have been run by verifying core Django tables exist\n    try:\n        with self.connection.cursor() as cursor:\n            cursor.execute(\"SELECT 1 FROM django_migrations LIMIT 1\")\n    except Exception:\n        # If django_migrations table doesn't exist, migrations haven't been run\n        # Return empty serialization to avoid crashes\n        return \"[]\"\n    \n    # Iteratively return every object for all models to serialize.\n    def get_objects():\n        from django.db.migrations.loader import MigrationLoader\n        loader = MigrationLoader(self.connection)\n        for app_config in apps.get_app_configs():\n            if (\n                app_config.models_module is not None and\n                app_config.label in loader.migrated_apps and\n                app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n            ):\n                for model in app_config.get_models():\n                    if (\n                        model._meta.can_migrate(self.connection) and\n                        router.allow_migrate_model(self.connection.alias, model)\n                    ):\n                        try:\n                            queryset = model._default_manager.using(\n                                self.connection.alias,\n                            ).order_by(model._meta.pk.name)\n                            yield from queryset.iterator()\n                        except Exception:\n                            # Skip models whose tables don't exist (e.g., when MIGRATE=False)\n                            continue\n    \n    # Serialize to a string\n    out = StringIO()\n    try:\n        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n        return out.getvalue()\n    except Exception:\n        # If serialization fails completely, return empty result\n        return \"[]\"\n",
      "\n    def serialize_db_to_string(self):\n        \"\"\"\n        Serialize all data in the database into a JSON string.\n        Designed only for test runner usage; will not handle large\n        amounts of data.\n        \"\"\"\n        # Check if migrations have been run by looking for core Django tables\n        try:\n            with self.connection.cursor() as cursor:\n                cursor.execute(\n                    \"SELECT 1 FROM django_migrations LIMIT 1\"\n                )\n        except Exception:\n            # If django_migrations table doesn't exist, migrations haven't been run\n            # Return empty serialization to avoid querying non-existent tables\n            return \"[]\"\n        \n        # Iteratively return every object for all models to serialize.\n        def get_objects():\n            from django.db.migrations.loader import MigrationLoader\n            loader = MigrationLoader(self.connection)\n            for app_config in apps.get_app_configs():\n                if (\n                    app_config.models_module is not None and\n                    app_config.label in loader.migrated_apps and\n                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n                ):\n                    for model in app_config.get_models():\n                        if (\n                            model._meta.can_migrate(self.connection) and\n                            router.allow_migrate_model(self.connection.alias, model)\n                        ):\n                            try:\n                                queryset = model._default_manager.using(\n                                    self.connection.alias,\n                                ).order_by(model._meta.pk.name)\n                                yield from queryset.iterator()\n                            except Exception:\n                                # Skip models whose tables don't exist\n                                continue\n        # Serialize to a string\n        out = StringIO()\n        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n        return out.getvalue()\n",
      "\n    def serialize_db_to_string(self):\n        \"\"\"\n        Serialize all data in the database into a JSON string.\n        Designed only for test runner usage; will not handle large\n        amounts of data.\n        \"\"\"\n        # Check if migrations were run by verifying core Django tables exist\n        try:\n            with self.connection.cursor() as cursor:\n                cursor.execute(\"SELECT 1 FROM django_migrations LIMIT 1\")\n        except Exception:\n            # If django_migrations table doesn't exist, migrations weren't run\n            # Return empty serialization to avoid crashes\n            return \"[]\"\n        \n        # Iteratively return every object for all models to serialize.\n        def get_objects():\n            from django.db.migrations.loader import MigrationLoader\n            loader = MigrationLoader(self.connection)\n            for app_config in apps.get_app_configs():\n                if (\n                    app_config.models_module is not None and\n                    app_config.label in loader.migrated_apps and\n                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n                ):\n                    for model in app_config.get_models():\n                        if (\n                            model._meta.can_migrate(self.connection) and\n                            router.allow_migrate_model(self.connection.alias, model)\n                        ):\n                            try:\n                                queryset = model._default_manager.using(\n                                    self.connection.alias,\n                                ).order_by(model._meta.pk.name)\n                                yield from queryset.iterator()\n                            except Exception:\n                                # Skip models whose tables don't exist (e.g., when MIGRATE=False)\n                                continue\n        # Serialize to a string\n        out = StringIO()\n        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n        return out.getvalue()\n",
      "\ndef serialize_db_to_string(self):\n    \"\"\"\n    Serialize all data in the database into a JSON string.\n    Designed only for test runner usage; will not handle large\n    amounts of data.\n    \"\"\"\n    # Check if migrations were run by looking for core Django tables\n    with self.connection.cursor() as cursor:\n        try:\n            cursor.execute(\"SELECT 1 FROM django_migrations LIMIT 1\")\n        except Exception:\n            # If django_migrations table doesn't exist, migrations weren't run\n            # Return empty serialization result\n            return \"[]\"\n    \n    # Iteratively return every object for all models to serialize.\n    def get_objects():\n        from django.db.migrations.loader import MigrationLoader\n        loader = MigrationLoader(self.connection)\n        for app_config in apps.get_app_configs():\n            if (\n                app_config.models_module is not None and\n                app_config.label in loader.migrated_apps and\n                app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n            ):\n                for model in app_config.get_models():\n                    if (\n                        model._meta.can_migrate(self.connection) and\n                        router.allow_migrate_model(self.connection.alias, model)\n                    ):\n                        try:\n                            queryset = model._default_manager.using(\n                                self.connection.alias,\n                            ).order_by(model._meta.pk.name)\n                            yield from queryset.iterator()\n                        except Exception:\n                            # Skip models whose tables don't exist\n                            continue\n    # Serialize to a string\n    out = StringIO()\n    serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n    return out.getvalue()\n",
      "\ndef serialize_db_to_string(self):\n    \"\"\"\n    Serialize all data in the database into a JSON string.\n    Designed only for test runner usage; will not handle large\n    amounts of data.\n    \"\"\"\n    # Check if migrations were run by verifying core Django tables exist\n    try:\n        with self.connection.cursor() as cursor:\n            cursor.execute(\"SELECT 1 FROM django_migrations LIMIT 1\")\n    except Exception:\n        # If django_migrations table doesn't exist, migrations weren't run\n        # Return empty serialization to avoid crashes\n        return \"[]\"\n    \n    # Iteratively return every object for all models to serialize.\n    def get_objects():\n        from django.db.migrations.loader import MigrationLoader\n        loader = MigrationLoader(self.connection)\n        for app_config in apps.get_app_configs():\n            if (\n                app_config.models_module is not None and\n                app_config.label in loader.migrated_apps and\n                app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n            ):\n                for model in app_config.get_models():\n                    if (\n                        model._meta.can_migrate(self.connection) and\n                        router.allow_migrate_model(self.connection.alias, model)\n                    ):\n                        try:\n                            queryset = model._default_manager.using(\n                                self.connection.alias,\n                            ).order_by(model._meta.pk.name)\n                            yield from queryset.iterator()\n                        except Exception:\n                            # Skip models whose tables don't exist\n                            continue\n    # Serialize to a string\n    out = StringIO()\n    serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n    return out.getvalue()\n",
      "\n    def serialize_db_to_string(self):\n        \"\"\"\n        Serialize all data in the database into a JSON string.\n        Designed only for test runner usage; will not handle large\n        amounts of data.\n        \"\"\"\n        # Check if migrations were run by verifying core Django tables exist\n        try:\n            with self.connection.cursor() as cursor:\n                cursor.execute(\n                    \"SELECT 1 FROM information_schema.tables WHERE table_name = 'django_migrations' LIMIT 1\"\n                    if self.connection.vendor == 'postgresql'\n                    else \"SELECT 1 FROM sqlite_master WHERE type='table' AND name='django_migrations' LIMIT 1\"\n                    if self.connection.vendor == 'sqlite'\n                    else \"SELECT 1 FROM django_migrations LIMIT 1\"\n                )\n                cursor.fetchone()\n        except Exception:\n            # If django_migrations table doesn't exist, migrations weren't run\n            return \"[]\"\n        \n        # Iteratively return every object for all models to serialize.\n        def get_objects():\n            from django.db.migrations.loader import MigrationLoader\n            loader = MigrationLoader(self.connection)\n            for app_config in apps.get_app_configs():\n                if (\n                    app_config.models_module is not None and\n                    app_config.label in loader.migrated_apps and\n                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n                ):\n                    for model in app_config.get_models():\n                        if (\n                            model._meta.can_migrate(self.connection) and\n                            router.allow_migrate_model(self.connection.alias, model)\n                        ):\n                            try:\n                                queryset = model._default_manager.using(\n                                    self.connection.alias,\n                                ).order_by(model._meta.pk.name)\n                                yield from queryset.iterator()\n                            except Exception:\n                                # Skip models whose tables don't exist\n                                continue\n        # Serialize to a string\n        out = StringIO()\n        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n        return out.getvalue()\n"
    ],
    "Location 3 (/root/hy/projects_3/django/django/db/backends/base/creation.py lines 100-118)": [
      "\n    def serialize_db_to_string(self):\n        \"\"\"\n        Serialize all data in the database into a JSON string.\n        Designed only for test runner usage; will not handle large\n        amounts of data.\n        \"\"\"\n        # Check if migrations have been run by looking for django_migrations table\n        try:\n            with self.connection.cursor() as cursor:\n                cursor.execute(\n                    \"SELECT 1 FROM django_migrations LIMIT 1\"\n                )\n        except Exception:\n            # If django_migrations table doesn't exist, migrations haven't been run\n            # Return empty serialization to avoid querying non-existent tables\n            return \"[]\"\n        \n        # Iteratively return every object for all models to serialize.\n        def get_objects():\n            from django.db.migrations.loader import MigrationLoader\n            loader = MigrationLoader(self.connection)\n            for app_config in apps.get_app_configs():\n                if (\n                    app_config.models_module is not None and\n                    app_config.label in loader.migrated_apps and\n                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n                ):\n                    for model in app_config.get_models():\n                        if (\n                            model._meta.can_migrate(self.connection) and\n                            router.allow_migrate_model(self.connection.alias, model)\n                        ):\n                            try:\n                                queryset = model._default_manager.using(\n                                    self.connection.alias,\n                                ).order_by(model._meta.pk.name)\n                                yield from queryset.iterator()\n                            except Exception:\n                                # Skip models whose tables don't exist\n                                continue\n",
      "\ndef serialize_db_to_string(self):\n    \"\"\"\n    Serialize all data in the database into a JSON string.\n    Designed only for test runner usage; will not handle large\n    amounts of data.\n    \"\"\"\n    # Check if migrations were run by verifying core Django tables exist\n    try:\n        with self.connection.cursor() as cursor:\n            cursor.execute(\n                \"SELECT 1 FROM information_schema.tables WHERE table_name = 'django_migrations' LIMIT 1\"\n            )\n            if not cursor.fetchone():\n                # No migrations table means no migrations were run\n                return '[]'\n    except Exception:\n        # If we can't check, assume no migrations were run\n        return '[]'\n    \n    # Iteratively return every object for all models to serialize.\n    def get_objects():\n        from django.db.migrations.loader import MigrationLoader\n        loader = MigrationLoader(self.connection)\n        for app_config in apps.get_app_configs():\n            if (\n                app_config.models_module is not None and\n                app_config.label in loader.migrated_apps and\n                app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n            ):\n                for model in app_config.get_models():\n                    if (\n                        model._meta.can_migrate(self.connection) and\n                        router.allow_migrate_model(self.connection.alias, model)\n                    ):\n                        try:\n                            queryset = model._default_manager.using(\n                                self.connection.alias,\n                            ).order_by(model._meta.pk.name)\n                            yield from queryset.iterator()\n                        except Exception:\n                            # Skip models whose tables don't exist\n                            continue\n    # Serialize to a string\n    out = StringIO()\n    serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n    return out.getvalue()\n",
      "\n    def serialize_db_to_string(self):\n        \"\"\"\n        Serialize all data in the database into a JSON string.\n        Designed only for test runner usage; will not handle large\n        amounts of data.\n        \"\"\"\n        # Check if migrations have been run by looking for django_migrations table\n        try:\n            with self.connection.cursor() as cursor:\n                cursor.execute(\"SELECT 1 FROM django_migrations LIMIT 1\")\n        except Exception:\n            # If django_migrations table doesn't exist, migrations haven't been run\n            # Return empty serialization to avoid crashes\n            return '[]'\n        \n        # Iteratively return every object for all models to serialize.\n        def get_objects():\n            from django.db.migrations.loader import MigrationLoader\n            loader = MigrationLoader(self.connection)\n            for app_config in apps.get_app_configs():\n                if (\n                    app_config.models_module is not None and\n                    app_config.label in loader.migrated_apps and\n                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n                ):\n                    for model in app_config.get_models():\n                        if (\n                            model._meta.can_migrate(self.connection) and\n                            router.allow_migrate_model(self.connection.alias, model)\n                        ):\n                            try:\n                                queryset = model._default_manager.using(\n                                    self.connection.alias,\n                                ).order_by(model._meta.pk.name)\n                                yield from queryset.iterator()\n                            except Exception:\n                                # Skip models whose tables don't exist\n                                continue\n        # Serialize to a string\n        out = StringIO()\n        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n        return out.getvalue()\n",
      "\n    def serialize_db_to_string(self):\n        \"\"\"\n        Serialize all data in the database into a JSON string.\n        Designed only for test runner usage; will not handle large\n        amounts of data.\n        \"\"\"\n        # Check if migrations were run by verifying core Django tables exist\n        try:\n            with self.connection.cursor() as cursor:\n                cursor.execute(\"SELECT 1 FROM django_migrations LIMIT 1\")\n        except Exception:\n            # If django_migrations table doesn't exist, migrations weren't run\n            # Return empty serialization to avoid crashes\n            return '[]'\n        \n        # Iteratively return every object for all models to serialize.\n        def get_objects():\n            from django.db.migrations.loader import MigrationLoader\n            loader = MigrationLoader(self.connection)\n            for app_config in apps.get_app_configs():\n                if (\n                    app_config.models_module is not None and\n                    app_config.label in loader.migrated_apps and\n                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n                ):\n                    for model in app_config.get_models():\n                        if (\n                            model._meta.can_migrate(self.connection) and\n                            router.allow_migrate_model(self.connection.alias, model)\n                        ):\n                            try:\n                                queryset = model._default_manager.using(\n                                    self.connection.alias,\n                                ).order_by(model._meta.pk.name)\n                                yield from queryset.iterator()\n                            except Exception:\n                                # Skip models whose tables don't exist\n                                continue\n        # Serialize to a string\n        out = StringIO()\n        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n        return out.getvalue()\n",
      "\n    def serialize_db_to_string(self):\n        \"\"\"\n        Serialize all data in the database into a JSON string.\n        Designed only for test runner usage; will not handle large\n        amounts of data.\n        \"\"\"\n        # Check if migrations have been run by verifying core Django tables exist\n        try:\n            with self.connection.cursor() as cursor:\n                cursor.execute(\"SELECT 1 FROM django_migrations LIMIT 1\")\n        except Exception:\n            # If django_migrations table doesn't exist, migrations haven't been run\n            # Return empty serialization instead of crashing\n            return '[]'\n        \n        # Iteratively return every object for all models to serialize.\n        def get_objects():\n            from django.db.migrations.loader import MigrationLoader\n            loader = MigrationLoader(self.connection)\n            for app_config in apps.get_app_configs():\n                if (\n                    app_config.models_module is not None and\n                    app_config.label in loader.migrated_apps and\n                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n                ):\n                    for model in app_config.get_models():\n                        if (\n                            model._meta.can_migrate(self.connection) and\n                            router.allow_migrate_model(self.connection.alias, model)\n                        ):\n                            try:\n                                queryset = model._default_manager.using(\n                                    self.connection.alias,\n                                ).order_by(model._meta.pk.name)\n                                yield from queryset.iterator()\n                            except Exception:\n                                # Skip models whose tables don't exist\n                                continue\n        # Serialize to a string\n        out = StringIO()\n        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n        return out.getvalue()\n",
      "\n    def serialize_db_to_string(self):\n        \"\"\"\n        Serialize all data in the database into a JSON string.\n        Designed only for test runner usage; will not handle large\n        amounts of data.\n        \"\"\"\n        # Check if migrations have been run by verifying core Django tables exist\n        try:\n            with self.connection.cursor() as cursor:\n                cursor.execute(\"SELECT 1 FROM django_migrations LIMIT 1\")\n        except Exception:\n            # If django_migrations table doesn't exist, migrations haven't been run\n            # Return empty serialization to avoid crashes\n            return \"[]\"\n        \n        # Iteratively return every object for all models to serialize.\n        def get_objects():\n            from django.db.migrations.loader import MigrationLoader\n            loader = MigrationLoader(self.connection)\n            for app_config in apps.get_app_configs():\n                if (\n                    app_config.models_module is not None and\n                    app_config.label in loader.migrated_apps and\n                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n                ):\n                    for model in app_config.get_models():\n                        if (\n                            model._meta.can_migrate(self.connection) and\n                            router.allow_migrate_model(self.connection.alias, model)\n                        ):\n                            try:\n                                queryset = model._default_manager.using(\n                                    self.connection.alias,\n                                ).order_by(model._meta.pk.name)\n                                yield from queryset.iterator()\n                            except Exception:\n                                # Skip models whose tables don't exist\n                                continue\n        # Serialize to a string\n        out = StringIO()\n        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n        return out.getvalue()\n",
      "\ndef serialize_db_to_string(self):\n    \"\"\"\n    Serialize all data in the database into a JSON string.\n    Designed only for test runner usage; will not handle large\n    amounts of data.\n    \"\"\"\n    # Check if migrations were run by verifying core Django tables exist\n    try:\n        with self.connection.cursor() as cursor:\n            cursor.execute(\"SELECT 1 FROM django_migrations LIMIT 1\")\n    except Exception:\n        # If django_migrations table doesn't exist, migrations weren't run\n        # Return empty serialization instead of crashing\n        return '[]'\n    \n    # Iteratively return every object for all models to serialize.\n    def get_objects():\n        from django.db.migrations.loader import MigrationLoader\n        loader = MigrationLoader(self.connection)\n        for app_config in apps.get_app_configs():\n            if (\n                app_config.models_module is not None and\n                app_config.label in loader.migrated_apps and\n                app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n            ):\n                for model in app_config.get_models():\n                    if (\n                        model._meta.can_migrate(self.connection) and\n                        router.allow_migrate_model(self.connection.alias, model)\n                    ):\n                        try:\n                            queryset = model._default_manager.using(\n                                self.connection.alias,\n                            ).order_by(model._meta.pk.name)\n                            yield from queryset.iterator()\n                        except Exception:\n                            # Skip models whose tables don't exist\n                            continue\n",
      "\n    def serialize_db_to_string(self):\n        \"\"\"\n        Serialize all data in the database into a JSON string.\n        Designed only for test runner usage; will not handle large\n        amounts of data.\n        \"\"\"\n        # Check if migrations were run by verifying core Django tables exist\n        try:\n            with self.connection.cursor() as cursor:\n                cursor.execute(\"SELECT 1 FROM django_migrations LIMIT 1\")\n        except Exception:\n            # If django_migrations table doesn't exist, migrations weren't run\n            # Return empty serialization to avoid crashes\n            return \"[]\"\n        \n        # Iteratively return every object for all models to serialize.\n        def get_objects():\n            from django.db.migrations.loader import MigrationLoader\n            loader = MigrationLoader(self.connection)\n            for app_config in apps.get_app_configs():\n                if (\n                    app_config.models_module is not None and\n                    app_config.label in loader.migrated_apps and\n                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n                ):\n                    for model in app_config.get_models():\n                        if (\n                            model._meta.can_migrate(self.connection) and\n                            router.allow_migrate_model(self.connection.alias, model)\n                        ):\n                            try:\n                                queryset = model._default_manager.using(\n                                    self.connection.alias,\n                                ).order_by(model._meta.pk.name)\n                                yield from queryset.iterator()\n                            except Exception:\n                                # Skip models whose tables don't exist\n                                continue\n        # Serialize to a string\n        out = StringIO()\n        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n        return out.getvalue()\n"
    ],
    "Location 4 (/root/hy/projects_3/django/django/test/utils.py lines 183-183)": [
      "\n                serialize=connection.settings_dict['TEST'].get('SERIALIZE', True) and connection.settings_dict['TEST'].get('MIGRATE', True),\n",
      "\n                serialize=connection.settings_dict['TEST'].get('SERIALIZE', True) and connection.settings_dict['TEST'].get('MIGRATE', True),\n",
      "\n                serialize=connection.settings_dict['TEST'].get('SERIALIZE', True) and connection.settings_dict['TEST'].get('MIGRATE', True),\n",
      "\n                        serialize=connection.settings_dict['TEST'].get('SERIALIZE', True) and connection.settings_dict['TEST'].get('MIGRATE', True),\n",
      "\n                serialize=connection.settings_dict['TEST'].get('SERIALIZE', True) and connection.settings_dict['TEST'].get('MIGRATE', True),\n",
      "\n                serialize=connection.settings_dict['TEST'].get('SERIALIZE', True) and connection.settings_dict['TEST'].get('MIGRATE', True),\n",
      "\n                serialize=connection.settings_dict['TEST'].get('SERIALIZE', True) and connection.settings_dict['TEST'].get('MIGRATE', True),\n",
      "\n                serialize=connection.settings_dict['TEST'].get('SERIALIZE', True) and connection.settings_dict['TEST'].get('MIGRATE', True),\n"
    ],
    "Location 5 (/root/hy/projects_3/django/django/test/utils.py lines 179-184)": [
      "\n        for db_name, aliases in test_databases.values():\n            first_alias = None\n            for alias in aliases:\n                connection = connections[alias]\n                old_names.append((connection, db_name, first_alias is None))\n\n                # Actually create the database for the first connection\n                if first_alias is None:\n                    first_alias = alias\n                    with time_keeper.timed(\"  Creating '%s'\" % alias):\n                        # Check if migrations are disabled to avoid serialization when tables don't exist\n                        migrate_setting = connection.settings_dict['TEST'].get('MIGRATE', True)\n                        serialize_setting = connection.settings_dict['TEST'].get('SERIALIZE', True)\n                        # Only serialize if migrations are enabled, otherwise serialization will fail\n                        should_serialize = serialize_setting and migrate_setting\n                        \n                        connection.creation.create_test_db(\n                            verbosity=verbosity,\n                            autoclobber=not interactive,\n                            keepdb=keepdb,\n                            serialize=should_serialize,\n                        )\n",
      "\n                connection.creation.create_test_db(\n                    verbosity=verbosity,\n                    autoclobber=not interactive,\n                    keepdb=keepdb,\n                    serialize=connection.settings_dict['TEST'].get('SERIALIZE', True) and connection.settings_dict['TEST'].get('MIGRATE', True),\n                )\n",
      "\n                    connection.creation.create_test_db(\n                        verbosity=verbosity,\n                        autoclobber=not interactive,\n                        keepdb=keepdb,\n                        serialize=connection.settings_dict['TEST'].get('SERIALIZE', True) and connection.settings_dict['TEST'].get('MIGRATE', True),\n                    )\n",
      "\n                    connection.creation.create_test_db(\n                        verbosity=verbosity,\n                        autoclobber=not interactive,\n                        keepdb=keepdb,\n                        serialize=connection.settings_dict['TEST'].get('SERIALIZE', True) and connection.settings_dict['TEST'].get('MIGRATE', True),\n                    )\n",
      "\n            # Actually create the database for the first connection\n            if first_alias is None:\n                first_alias = alias\n                with time_keeper.timed(\"  Creating '%s'\" % alias):\n                    # Check if migrations are disabled to avoid serialization issues\n                    migrate_setting = connection.settings_dict['TEST'].get('MIGRATE', True)\n                    should_serialize = (\n                        connection.settings_dict['TEST'].get('SERIALIZE', True) and \n                        migrate_setting\n                    )\n                    connection.creation.create_test_db(\n                        verbosity=verbosity,\n                        autoclobber=not interactive,\n                        keepdb=keepdb,\n                        serialize=should_serialize,\n                    )\n",
      "\n            # Actually create the database for the first connection\n            if first_alias is None:\n                first_alias = alias\n                with time_keeper.timed(\"  Creating '%s'\" % alias):\n                    # Check if migrations are disabled - if so, don't serialize\n                    migrate_setting = connection.settings_dict['TEST'].get('MIGRATE', True)\n                    should_serialize = (\n                        connection.settings_dict['TEST'].get('SERIALIZE', True) and \n                        migrate_setting is not False\n                    )\n                    connection.creation.create_test_db(\n                        verbosity=verbosity,\n                        autoclobber=not interactive,\n                        keepdb=keepdb,\n                        serialize=should_serialize,\n                    )\n",
      "\n                connection.creation.create_test_db(\n                    verbosity=verbosity,\n                    autoclobber=not interactive,\n                    keepdb=keepdb,\n                    serialize=connection.settings_dict['TEST'].get('SERIALIZE', True) and connection.settings_dict['TEST'].get('MIGRATE', True),\n                )\n",
      "\n                with time_keeper.timed(\"  Creating '%s'\" % alias):\n                    connection.creation.create_test_db(\n                        verbosity=verbosity,\n                        autoclobber=not interactive,\n                        keepdb=keepdb,\n                        serialize=connection.settings_dict['TEST'].get('SERIALIZE', True) and connection.settings_dict['TEST'].get('MIGRATE', True),\n                    )\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/backends/base/creation.py b/django/db/backends/base/creation.py\nindex 503f7f56fd..b68b6a873f 100644\n--- a/django/db/backends/base/creation.py\n+++ b/django/db/backends/base/creation.py\n@@ -74,6 +74,7 @@ class BaseDatabaseCreation:\n         # and store it on the connection. This slightly horrific process is so people\n         # who are testing on databases without transactions or who are using\n         # a TransactionTestCase still get a clean database on every test run.\n+\n         if serialize:\n             self.connection._test_serialized_contents = self.serialize_db_to_string()\n \n@@ -91,6 +92,7 @@ class BaseDatabaseCreation:\n         \"\"\"\n         self.connection.settings_dict['NAME'] = primary_settings_dict['NAME']\n \n+\n     def serialize_db_to_string(self):\n         \"\"\"\n         Serialize all data in the database into a JSON string.\n@@ -99,7 +101,6 @@ class BaseDatabaseCreation:\n         \"\"\"\n         # Iteratively return every object for all models to serialize.\n         def get_objects():\n-            from django.db.migrations.loader import MigrationLoader\n             loader = MigrationLoader(self.connection)\n             for app_config in apps.get_app_configs():\n                 if (\n@@ -112,10 +113,18 @@ class BaseDatabaseCreation:\n                             model._meta.can_migrate(self.connection) and\n                             router.allow_migrate_model(self.connection.alias, model)\n                         ):\n-                            queryset = model._default_manager.using(\n-                                self.connection.alias,\n-                            ).order_by(model._meta.pk.name)\n-                            yield from queryset.iterator()\n+                            try:\n+                                queryset = model._default_manager.using(\n+                                    self.connection.alias,\n+                                ).order_by(model._meta.pk.name)\n+                                yield from queryset.iterator()\n+                            except Exception:\n+                                # Skip models whose tables don't exist (e.g., when MIGRATE=False)\n+                                continue\n+        # Serialize to a string\n+        out = StringIO()\n+        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n+        return out.getvalue()\n         # Serialize to a string\n         out = StringIO()\n         serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\ndiff --git a/django/test/utils.py b/django/test/utils.py\nindex 4f4ce99967..c2eaeea9b0 100644\n--- a/django/test/utils.py\n+++ b/django/test/utils.py\n@@ -176,11 +176,13 @@ def setup_databases(verbosity, interactive, *, time_keeper=None, keepdb=False, d\n             if first_alias is None:\n                 first_alias = alias\n                 with time_keeper.timed(\"  Creating '%s'\" % alias):\n+\n                     connection.creation.create_test_db(\n                         verbosity=verbosity,\n                         autoclobber=not interactive,\n                         keepdb=keepdb,\n-                        serialize=connection.settings_dict['TEST'].get('SERIALIZE', True),\n+                        serialize=connection.settings_dict['TEST'].get('SERIALIZE', True) and connection.settings_dict['TEST'].get('MIGRATE', True),\n+                    )\n                     )\n                 if parallel > 1:\n                     for index in range(parallel):\n",
    "variant_0": "diff --git a/django/db/backends/base/creation.py b/django/db/backends/base/creation.py\nindex 503f7f56fd..b0b83cd6f0 100644\n--- a/django/db/backends/base/creation.py\n+++ b/django/db/backends/base/creation.py\n@@ -74,8 +74,14 @@ class BaseDatabaseCreation:\n         # and store it on the connection. This slightly horrific process is so people\n         # who are testing on databases without transactions or who are using\n         # a TransactionTestCase still get a clean database on every test run.\n+\n         if serialize:\n-            self.connection._test_serialized_contents = self.serialize_db_to_string()\n+            # Only serialize if migrations were run, otherwise skip to avoid querying non-existent tables\n+            migrate_setting = self.connection.settings_dict.get('TEST', {}).get('MIGRATE', True)\n+            if migrate_setting is not False:\n+                self.connection._test_serialized_contents = self.serialize_db_to_string()\n+            else:\n+                self.connection._test_serialized_contents = None\n \n         call_command('createcachetable', database=self.connection.alias)\n \n@@ -91,31 +97,96 @@ class BaseDatabaseCreation:\n         \"\"\"\n         self.connection.settings_dict['NAME'] = primary_settings_dict['NAME']\n \n-    def serialize_db_to_string(self):\n-        \"\"\"\n-        Serialize all data in the database into a JSON string.\n-        Designed only for test runner usage; will not handle large\n-        amounts of data.\n-        \"\"\"\n-        # Iteratively return every object for all models to serialize.\n-        def get_objects():\n-            from django.db.migrations.loader import MigrationLoader\n-            loader = MigrationLoader(self.connection)\n-            for app_config in apps.get_app_configs():\n-                if (\n-                    app_config.models_module is not None and\n-                    app_config.label in loader.migrated_apps and\n-                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n-                ):\n-                    for model in app_config.get_models():\n-                        if (\n-                            model._meta.can_migrate(self.connection) and\n-                            router.allow_migrate_model(self.connection.alias, model)\n-                        ):\n+\n+def serialize_db_to_string(self):\n+    \"\"\"\n+    Serialize all data in the database into a JSON string.\n+    Designed only for test runner usage; will not handle large\n+    amounts of data.\n+    \"\"\"\n+    # Check if migrations were run by verifying core Django tables exist\n+    try:\n+        with self.connection.cursor() as cursor:\n+            cursor.execute(\"SELECT 1 FROM django_migrations LIMIT 1\")\n+    except Exception:\n+        # If django_migrations table doesn't exist, migrations weren't run\n+        # Return empty serialization instead of crashing\n+        return '[]'\n+    \n+    # Iteratively return every object for all models to serialize.\n+    def get_objects():\n+        from django.db.migrations.loader import MigrationLoader\n+        loader = MigrationLoader(self.connection)\n+        for app_config in apps.get_app_configs():\n+            if (\n+                app_config.models_module is not None and\n+                app_config.label in loader.migrated_apps and\n+                app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n+            ):\n+                for model in app_config.get_models():\n+                    if (\n+                        model._meta.can_migrate(self.connection) and\n+                        router.allow_migrate_model(self.connection.alias, model)\n+                    ):\n+                        try:\n                             queryset = model._default_manager.using(\n                                 self.connection.alias,\n                             ).order_by(model._meta.pk.name)\n                             yield from queryset.iterator()\n+                        except Exception:\n+                            # Skip models whose tables don't exist (e.g., when MIGRATE=False)\n+                            continue\n+    # Serialize to a string\n+    out = StringIO()\n+    serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n+    return out.getvalue()\n+    # give it the keepdb param. This is to handle the case\n+    # where the test DB doesn't exist, in which case we need to\n+    # create it, then just not destroy it. If we instead skip\n+    # this, we will get an exception.\n+    self._create_test_db(test_database_name, verbosity, keepdb)\n+\n+    self.connection.close()\n+    settings_dict = self.connection.settings_dict.copy()\n+    settings_dict['NAME'] = test_database_name\n+    # conn.settings_dict references the same dictionary as the\n+    # settings_dict local variable.\n+    self.connection.settings_dict['NAME'] = test_database_name\n+\n+    try:\n+        self.connection.ensure_connection()\n+        if not keepdb:\n+            # Check if migrations should be run before deciding to serialize\n+            test_settings = settings_dict.get('TEST', {})\n+            should_migrate = test_settings.get('MIGRATE', True)\n+            \n+            # Only serialize if migrations are being run\n+            if serialize and should_migrate:\n+                self.connection.ops.disable_constraint_checking()\n+                for app_config in apps.get_app_configs():\n+                    if (\n+                        app_config.models_module is not None and\n+                        app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n+                    ):\n+                        for model in app_config.get_models():\n+                            if model._meta.can_migrate(self.connection):\n+                                management.call_command(\n+                                    'loaddata',\n+                                    verbosity=verbosity,\n+                                    database=self.connection.alias,\n+                                )\n+                                break\n+                self.connection.ops.enable_constraint_checking()\n+            if serialize and should_migrate:\n+                self.connection._test_serialized_contents = self.serialize_db_to_string()\n+    except Exception:\n+        if not keepdb:\n+            try:\n+                self.destroy_test_db(test_database_name, verbosity, keepdb=True)\n+            except Exception as e:\n+                self.log('Got an error destroying the test database: %s' % e)\n+        raise\n+    return test_database_name\n         # Serialize to a string\n         out = StringIO()\n         serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\ndiff --git a/django/test/utils.py b/django/test/utils.py\nindex 4f4ce99967..fb9f78d39d 100644\n--- a/django/test/utils.py\n+++ b/django/test/utils.py\n@@ -176,11 +176,13 @@ def setup_databases(verbosity, interactive, *, time_keeper=None, keepdb=False, d\n             if first_alias is None:\n                 first_alias = alias\n                 with time_keeper.timed(\"  Creating '%s'\" % alias):\n-                    connection.creation.create_test_db(\n-                        verbosity=verbosity,\n-                        autoclobber=not interactive,\n-                        keepdb=keepdb,\n-                        serialize=connection.settings_dict['TEST'].get('SERIALIZE', True),\n+\n+                connection.creation.create_test_db(\n+                    verbosity=verbosity,\n+                    autoclobber=not interactive,\n+                    keepdb=keepdb,\n+                    serialize=connection.settings_dict['TEST'].get('SERIALIZE', True) and connection.settings_dict['TEST'].get('MIGRATE', True),\n+                )\n                     )\n                 if parallel > 1:\n                     for index in range(parallel):\n",
    "variant_1": "diff --git a/django/db/backends/base/creation.py b/django/db/backends/base/creation.py\nindex 503f7f56fd..3012d0401c 100644\n--- a/django/db/backends/base/creation.py\n+++ b/django/db/backends/base/creation.py\n@@ -74,8 +74,17 @@ class BaseDatabaseCreation:\n         # and store it on the connection. This slightly horrific process is so people\n         # who are testing on databases without transactions or who are using\n         # a TransactionTestCase still get a clean database on every test run.\n+\n         if serialize:\n-            self.connection._test_serialized_contents = self.serialize_db_to_string()\n+            # Check if migrations were run by verifying TEST MIGRATE setting\n+            test_settings = self.connection.settings_dict.get('TEST', {})\n+            migrate_enabled = test_settings.get('MIGRATE', True)\n+            \n+            if migrate_enabled:\n+                self.connection._test_serialized_contents = self.serialize_db_to_string()\n+            else:\n+                # Skip serialization when migrations are disabled\n+                self.connection._test_serialized_contents = None\n \n         call_command('createcachetable', database=self.connection.alias)\n \n@@ -91,12 +100,22 @@ class BaseDatabaseCreation:\n         \"\"\"\n         self.connection.settings_dict['NAME'] = primary_settings_dict['NAME']\n \n+\n     def serialize_db_to_string(self):\n         \"\"\"\n         Serialize all data in the database into a JSON string.\n         Designed only for test runner usage; will not handle large\n         amounts of data.\n         \"\"\"\n+        # Check if migrations were run by verifying core Django tables exist\n+        try:\n+            with self.connection.cursor() as cursor:\n+                cursor.execute(\"SELECT 1 FROM django_migrations LIMIT 1\")\n+        except Exception:\n+            # If django_migrations table doesn't exist, migrations weren't run\n+            # Return empty serialization to avoid querying non-existent tables\n+            return \"[]\"\n+        \n         # Iteratively return every object for all models to serialize.\n         def get_objects():\n             from django.db.migrations.loader import MigrationLoader\n@@ -112,10 +131,36 @@ class BaseDatabaseCreation:\n                             model._meta.can_migrate(self.connection) and\n                             router.allow_migrate_model(self.connection.alias, model)\n                         ):\n-                            queryset = model._default_manager.using(\n-                                self.connection.alias,\n-                            ).order_by(model._meta.pk.name)\n-                            yield from queryset.iterator()\n+                            try:\n+                                queryset = model._default_manager.using(\n+                                    self.connection.alias,\n+                                ).order_by(model._meta.pk.name)\n+                                yield from queryset.iterator()\n+                            except Exception:\n+                                # Skip models whose tables don't exist\n+                                continue\n+        # Serialize to a string\n+        out = StringIO()\n+        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n+        return out.getvalue()\n+                if (\n+                    app_config.models_module is not None and\n+                    app_config.label in loader.migrated_apps and\n+                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n+                ):\n+                    for model in app_config.get_models():\n+                        if (\n+                            model._meta.can_migrate(self.connection) and\n+                            router.allow_migrate_model(self.connection.alias, model)\n+                        ):\n+                            try:\n+                                queryset = model._default_manager.using(\n+                                    self.connection.alias,\n+                                ).order_by(model._meta.pk.name)\n+                                yield from queryset.iterator()\n+                            except Exception:\n+                                # Skip models whose tables don't exist\n+                                continue\n         # Serialize to a string\n         out = StringIO()\n         serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\ndiff --git a/django/test/utils.py b/django/test/utils.py\nindex 4f4ce99967..e72185e0c5 100644\n--- a/django/test/utils.py\n+++ b/django/test/utils.py\n@@ -176,11 +176,29 @@ def setup_databases(verbosity, interactive, *, time_keeper=None, keepdb=False, d\n             if first_alias is None:\n                 first_alias = alias\n                 with time_keeper.timed(\"  Creating '%s'\" % alias):\n-                    connection.creation.create_test_db(\n-                        verbosity=verbosity,\n-                        autoclobber=not interactive,\n-                        keepdb=keepdb,\n-                        serialize=connection.settings_dict['TEST'].get('SERIALIZE', True),\n+\n+        for db_name, aliases in test_databases.values():\n+            first_alias = None\n+            for alias in aliases:\n+                connection = connections[alias]\n+                old_names.append((connection, db_name, first_alias is None))\n+\n+                # Actually create the database for the first connection\n+                if first_alias is None:\n+                    first_alias = alias\n+                    with time_keeper.timed(\"  Creating '%s'\" % alias):\n+                        # Check if migrations are disabled to avoid serialization when tables don't exist\n+                        migrate_setting = connection.settings_dict['TEST'].get('MIGRATE', True)\n+                        serialize_setting = connection.settings_dict['TEST'].get('SERIALIZE', True)\n+                        # Only serialize if migrations are enabled, otherwise serialization will fail\n+                        should_serialize = serialize_setting and migrate_setting\n+                        \n+                        connection.creation.create_test_db(\n+                            verbosity=verbosity,\n+                            autoclobber=not interactive,\n+                            keepdb=keepdb,\n+                            serialize=should_serialize,\n+                        )\n                     )\n                 if parallel > 1:\n                     for index in range(parallel):\n",
    "variant_2": "diff --git a/django/db/backends/base/creation.py b/django/db/backends/base/creation.py\nindex 503f7f56fd..46c63bac7f 100644\n--- a/django/db/backends/base/creation.py\n+++ b/django/db/backends/base/creation.py\n@@ -70,12 +70,25 @@ class BaseDatabaseCreation:\n                 run_syncdb=True,\n             )\n \n+        # We then serialize the current state of the database into a string\n+        # and store it on the connection. This slightly horrific process is so people\n+        # who are testing on databases without transactions or who are using\n+        # a TransactionTestCase still get a clean database on every test run.\n+\n         # We then serialize the current state of the database into a string\n         # and store it on the connection. This slightly horrific process is so people\n         # who are testing on databases without transactions or who are using\n         # a TransactionTestCase still get a clean database on every test run.\n         if serialize:\n-            self.connection._test_serialized_contents = self.serialize_db_to_string()\n+            # Check if migrations were run by verifying TEST MIGRATE setting\n+            test_settings = self.connection.settings_dict.get('TEST', {})\n+            migrate_enabled = test_settings.get('MIGRATE', True)\n+            \n+            if migrate_enabled:\n+                self.connection._test_serialized_contents = self.serialize_db_to_string()\n+            else:\n+                # Skip serialization when migrations are disabled since tables may not exist\n+                self.connection._test_serialized_contents = None\n \n         call_command('createcachetable', database=self.connection.alias)\n \n@@ -91,31 +104,85 @@ class BaseDatabaseCreation:\n         \"\"\"\n         self.connection.settings_dict['NAME'] = primary_settings_dict['NAME']\n \n-    def serialize_db_to_string(self):\n-        \"\"\"\n-        Serialize all data in the database into a JSON string.\n-        Designed only for test runner usage; will not handle large\n-        amounts of data.\n-        \"\"\"\n-        # Iteratively return every object for all models to serialize.\n-        def get_objects():\n-            from django.db.migrations.loader import MigrationLoader\n-            loader = MigrationLoader(self.connection)\n-            for app_config in apps.get_app_configs():\n-                if (\n-                    app_config.models_module is not None and\n-                    app_config.label in loader.migrated_apps and\n-                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n-                ):\n-                    for model in app_config.get_models():\n-                        if (\n-                            model._meta.can_migrate(self.connection) and\n-                            router.allow_migrate_model(self.connection.alias, model)\n-                        ):\n+\n+def serialize_db_to_string(self):\n+    \"\"\"\n+    Serialize all data in the database into a JSON string.\n+    Designed only for test runner usage; will not handle large\n+    amounts of data.\n+    \"\"\"\n+    # Check if migrations have been run by verifying core Django tables exist\n+    from django.db import connection\n+    from django.core.management.color import no_style\n+    \n+    try:\n+        # Check if django_migrations table exists (created during migrations)\n+        with connection.cursor() as cursor:\n+            cursor.execute(\n+                \"SELECT 1 FROM information_schema.tables WHERE table_name = 'django_migrations'\"\n+                if connection.vendor == 'postgresql' else\n+                \"SELECT 1 FROM sqlite_master WHERE type='table' AND name='django_migrations'\"\n+                if connection.vendor == 'sqlite' else\n+                \"SELECT 1 FROM information_schema.tables WHERE table_name = 'django_migrations'\"\n+            )\n+            if not cursor.fetchone():\n+                # No migrations table found, return empty serialization\n+                return '[]'\n+    except Exception:\n+        # If we can't check for migrations table, assume no migrations and return empty\n+        return '[]'\n+    \n+    # Iteratively return every object for all models to serialize.\n+    def get_objects():\n+        from django.db.migrations.loader import MigrationLoader\n+        loader = MigrationLoader(self.connection)\n+        for app_config in apps.get_app_configs():\n+            if (\n+                app_config.models_module is not None and\n+                app_config.label in loader.migrated_apps and\n+                app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n+            ):\n+                for model in app_config.get_models():\n+                    if (\n+                        model._meta.can_migrate(self.connection) and\n+                        router.allow_migrate_model(self.connection.alias, model)\n+                    ):\n+                        try:\n+                            queryset = model._default_manager.using(\n+                                self.connection.alias,\n+                            ).order_by(model._meta.pk.name)\n+                            yield from queryset.iterator()\n+                        except Exception:\n+                            # Skip models whose tables don't exist\n+                            continue\n+    # Serialize to a string\n+    out = StringIO()\n+    serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n+    return out.getvalue()\n+        loader = MigrationLoader(self.connection)\n+        for app_config in apps.get_app_configs():\n+            if (\n+                app_config.models_module is not None and\n+                app_config.label in loader.migrated_apps and\n+                app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n+            ):\n+                for model in app_config.get_models():\n+                    if (\n+                        model._meta.can_migrate(self.connection) and\n+                        router.allow_migrate_model(self.connection.alias, model)\n+                    ):\n+                        try:\n                             queryset = model._default_manager.using(\n                                 self.connection.alias,\n                             ).order_by(model._meta.pk.name)\n                             yield from queryset.iterator()\n+                        except Exception:\n+                            # Skip models whose tables don't exist\n+                            continue\n+    # Serialize to a string\n+    out = StringIO()\n+    serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n+    return out.getvalue()\n         # Serialize to a string\n         out = StringIO()\n         serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\ndiff --git a/django/test/utils.py b/django/test/utils.py\nindex 4f4ce99967..fb9f78d39d 100644\n--- a/django/test/utils.py\n+++ b/django/test/utils.py\n@@ -176,11 +176,13 @@ def setup_databases(verbosity, interactive, *, time_keeper=None, keepdb=False, d\n             if first_alias is None:\n                 first_alias = alias\n                 with time_keeper.timed(\"  Creating '%s'\" % alias):\n-                    connection.creation.create_test_db(\n-                        verbosity=verbosity,\n-                        autoclobber=not interactive,\n-                        keepdb=keepdb,\n-                        serialize=connection.settings_dict['TEST'].get('SERIALIZE', True),\n+\n+                connection.creation.create_test_db(\n+                    verbosity=verbosity,\n+                    autoclobber=not interactive,\n+                    keepdb=keepdb,\n+                    serialize=connection.settings_dict['TEST'].get('SERIALIZE', True) and connection.settings_dict['TEST'].get('MIGRATE', True),\n+                )\n                     )\n                 if parallel > 1:\n                     for index in range(parallel):\n",
    "variant_3": "diff --git a/django/db/backends/base/creation.py b/django/db/backends/base/creation.py\nindex 503f7f56fd..4f4bf5d259 100644\n--- a/django/db/backends/base/creation.py\n+++ b/django/db/backends/base/creation.py\n@@ -74,8 +74,14 @@ class BaseDatabaseCreation:\n         # and store it on the connection. This slightly horrific process is so people\n         # who are testing on databases without transactions or who are using\n         # a TransactionTestCase still get a clean database on every test run.\n+\n         if serialize:\n-            self.connection._test_serialized_contents = self.serialize_db_to_string()\n+            # Only serialize if migrations were run, otherwise skip to avoid querying non-existent tables\n+            migrate_setting = self.connection.settings_dict.get('TEST', {}).get('MIGRATE', True)\n+            if migrate_setting:\n+                self.connection._test_serialized_contents = self.serialize_db_to_string()\n+            else:\n+                self.connection._test_serialized_contents = None\n \n         call_command('createcachetable', database=self.connection.alias)\n \n@@ -91,19 +97,54 @@ class BaseDatabaseCreation:\n         \"\"\"\n         self.connection.settings_dict['NAME'] = primary_settings_dict['NAME']\n \n-    def serialize_db_to_string(self):\n-        \"\"\"\n-        Serialize all data in the database into a JSON string.\n-        Designed only for test runner usage; will not handle large\n-        amounts of data.\n-        \"\"\"\n-        # Iteratively return every object for all models to serialize.\n-        def get_objects():\n-            from django.db.migrations.loader import MigrationLoader\n-            loader = MigrationLoader(self.connection)\n-            for app_config in apps.get_app_configs():\n-                if (\n-                    app_config.models_module is not None and\n+\n+def serialize_db_to_string(self):\n+    \"\"\"\n+    Serialize all data in the database into a JSON string.\n+    Designed only for test runner usage; will not handle large\n+    amounts of data.\n+    \"\"\"\n+    # Check if migrations have been run by verifying core Django tables exist\n+    try:\n+        with self.connection.cursor() as cursor:\n+            cursor.execute(\"SELECT 1 FROM django_migrations LIMIT 1\")\n+    except Exception:\n+        # If django_migrations table doesn't exist, migrations haven't been run\n+        # Return empty serialization to avoid crashes\n+        return \"[]\"\n+    \n+    # Iteratively return every object for all models to serialize.\n+    def get_objects():\n+        from django.db.migrations.loader import MigrationLoader\n+        loader = MigrationLoader(self.connection)\n+        for app_config in apps.get_app_configs():\n+            if (\n+                app_config.models_module is not None and\n+                app_config.label in loader.migrated_apps and\n+                app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n+            ):\n+                for model in app_config.get_models():\n+                    if (\n+                        model._meta.can_migrate(self.connection) and\n+                        router.allow_migrate_model(self.connection.alias, model)\n+                    ):\n+                        try:\n+                            queryset = model._default_manager.using(\n+                                self.connection.alias,\n+                            ).order_by(model._meta.pk.name)\n+                            yield from queryset.iterator()\n+                        except Exception:\n+                            # Skip models whose tables don't exist (e.g., when MIGRATE=False)\n+                            continue\n+    \n+    # Serialize to a string\n+    out = StringIO()\n+    try:\n+        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n+        return out.getvalue()\n+    except Exception:\n+        # If serialization fails completely, return empty result\n+        return \"[]\"\n                     app_config.label in loader.migrated_apps and\n                     app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n                 ):\n@@ -112,10 +153,18 @@ class BaseDatabaseCreation:\n                             model._meta.can_migrate(self.connection) and\n                             router.allow_migrate_model(self.connection.alias, model)\n                         ):\n-                            queryset = model._default_manager.using(\n-                                self.connection.alias,\n-                            ).order_by(model._meta.pk.name)\n-                            yield from queryset.iterator()\n+                            try:\n+                                queryset = model._default_manager.using(\n+                                    self.connection.alias,\n+                                ).order_by(model._meta.pk.name)\n+                                yield from queryset.iterator()\n+                            except Exception:\n+                                # Skip models whose tables don't exist\n+                                continue\n+        # Serialize to a string\n+        out = StringIO()\n+        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n+        return out.getvalue()\n         # Serialize to a string\n         out = StringIO()\n         serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\ndiff --git a/django/test/utils.py b/django/test/utils.py\nindex 4f4ce99967..c2eaeea9b0 100644\n--- a/django/test/utils.py\n+++ b/django/test/utils.py\n@@ -176,11 +176,13 @@ def setup_databases(verbosity, interactive, *, time_keeper=None, keepdb=False, d\n             if first_alias is None:\n                 first_alias = alias\n                 with time_keeper.timed(\"  Creating '%s'\" % alias):\n+\n                     connection.creation.create_test_db(\n                         verbosity=verbosity,\n                         autoclobber=not interactive,\n                         keepdb=keepdb,\n-                        serialize=connection.settings_dict['TEST'].get('SERIALIZE', True),\n+                        serialize=connection.settings_dict['TEST'].get('SERIALIZE', True) and connection.settings_dict['TEST'].get('MIGRATE', True),\n+                    )\n                     )\n                 if parallel > 1:\n                     for index in range(parallel):\n",
    "variant_4": "diff --git a/django/db/backends/base/creation.py b/django/db/backends/base/creation.py\nindex 503f7f56fd..9945859b88 100644\n--- a/django/db/backends/base/creation.py\n+++ b/django/db/backends/base/creation.py\n@@ -74,8 +74,18 @@ class BaseDatabaseCreation:\n         # and store it on the connection. This slightly horrific process is so people\n         # who are testing on databases without transactions or who are using\n         # a TransactionTestCase still get a clean database on every test run.\n+\n         if serialize:\n-            self.connection._test_serialized_contents = self.serialize_db_to_string()\n+            # Check if migrations were run by verifying test settings\n+            test_settings = self.connection.settings_dict.get('TEST', {})\n+            migrate_setting = test_settings.get('MIGRATE', True)\n+            \n+            # Only serialize if migrations were actually run\n+            if migrate_setting:\n+                self.connection._test_serialized_contents = self.serialize_db_to_string()\n+            else:\n+                # Skip serialization when migrations are disabled\n+                self.connection._test_serialized_contents = None\n \n         call_command('createcachetable', database=self.connection.alias)\n \n@@ -91,12 +101,24 @@ class BaseDatabaseCreation:\n         \"\"\"\n         self.connection.settings_dict['NAME'] = primary_settings_dict['NAME']\n \n+\n     def serialize_db_to_string(self):\n         \"\"\"\n         Serialize all data in the database into a JSON string.\n         Designed only for test runner usage; will not handle large\n         amounts of data.\n         \"\"\"\n+        # Check if migrations have been run by looking for core Django tables\n+        try:\n+            with self.connection.cursor() as cursor:\n+                cursor.execute(\n+                    \"SELECT 1 FROM django_migrations LIMIT 1\"\n+                )\n+        except Exception:\n+            # If django_migrations table doesn't exist, migrations haven't been run\n+            # Return empty serialization to avoid querying non-existent tables\n+            return \"[]\"\n+        \n         # Iteratively return every object for all models to serialize.\n         def get_objects():\n             from django.db.migrations.loader import MigrationLoader\n@@ -112,10 +134,38 @@ class BaseDatabaseCreation:\n                             model._meta.can_migrate(self.connection) and\n                             router.allow_migrate_model(self.connection.alias, model)\n                         ):\n-                            queryset = model._default_manager.using(\n-                                self.connection.alias,\n-                            ).order_by(model._meta.pk.name)\n-                            yield from queryset.iterator()\n+                            try:\n+                                queryset = model._default_manager.using(\n+                                    self.connection.alias,\n+                                ).order_by(model._meta.pk.name)\n+                                yield from queryset.iterator()\n+                            except Exception:\n+                                # Skip models whose tables don't exist\n+                                continue\n+        # Serialize to a string\n+        out = StringIO()\n+        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n+        return out.getvalue()\n+                    app_config.label in loader.migrated_apps and\n+                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n+                ):\n+                    for model in app_config.get_models():\n+                        if (\n+                            model._meta.can_migrate(self.connection) and\n+                            router.allow_migrate_model(self.connection.alias, model)\n+                        ):\n+                            try:\n+                                queryset = model._default_manager.using(\n+                                    self.connection.alias,\n+                                ).order_by(model._meta.pk.name)\n+                                yield from queryset.iterator()\n+                            except Exception:\n+                                # Skip models whose tables don't exist\n+                                continue\n+        # Serialize to a string\n+        out = StringIO()\n+        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n+        return out.getvalue()\n         # Serialize to a string\n         out = StringIO()\n         serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\ndiff --git a/django/test/utils.py b/django/test/utils.py\nindex 4f4ce99967..c2eaeea9b0 100644\n--- a/django/test/utils.py\n+++ b/django/test/utils.py\n@@ -176,11 +176,13 @@ def setup_databases(verbosity, interactive, *, time_keeper=None, keepdb=False, d\n             if first_alias is None:\n                 first_alias = alias\n                 with time_keeper.timed(\"  Creating '%s'\" % alias):\n+\n                     connection.creation.create_test_db(\n                         verbosity=verbosity,\n                         autoclobber=not interactive,\n                         keepdb=keepdb,\n-                        serialize=connection.settings_dict['TEST'].get('SERIALIZE', True),\n+                        serialize=connection.settings_dict['TEST'].get('SERIALIZE', True) and connection.settings_dict['TEST'].get('MIGRATE', True),\n+                    )\n                     )\n                 if parallel > 1:\n                     for index in range(parallel):\n",
    "variant_5": "diff --git a/django/db/backends/base/creation.py b/django/db/backends/base/creation.py\nindex 503f7f56fd..79530c4a1f 100644\n--- a/django/db/backends/base/creation.py\n+++ b/django/db/backends/base/creation.py\n@@ -74,8 +74,24 @@ class BaseDatabaseCreation:\n         # and store it on the connection. This slightly horrific process is so people\n         # who are testing on databases without transactions or who are using\n         # a TransactionTestCase still get a clean database on every test run.\n+\n         if serialize:\n-            self.connection._test_serialized_contents = self.serialize_db_to_string()\n+            # Check if migrations were run by verifying if core Django tables exist\n+            # If MIGRATE is False, skip serialization to avoid querying non-existent tables\n+            migrate_setting = self.connection.settings_dict.get('TEST', {}).get('MIGRATE', True)\n+            if migrate_setting is False:\n+                # Skip serialization when migrations are disabled\n+                self.connection._test_serialized_contents = None\n+            else:\n+                # Verify that core Django tables exist before attempting serialization\n+                try:\n+                    with self.connection.cursor() as cursor:\n+                        # Check if django_content_type table exists as a proxy for migrations being run\n+                        cursor.execute(\"SELECT 1 FROM django_content_type LIMIT 1\")\n+                    self.connection._test_serialized_contents = self.serialize_db_to_string()\n+                except Exception:\n+                    # If core tables don't exist, skip serialization\n+                    self.connection._test_serialized_contents = None\n \n         call_command('createcachetable', database=self.connection.alias)\n \n@@ -91,12 +107,22 @@ class BaseDatabaseCreation:\n         \"\"\"\n         self.connection.settings_dict['NAME'] = primary_settings_dict['NAME']\n \n+\n     def serialize_db_to_string(self):\n         \"\"\"\n         Serialize all data in the database into a JSON string.\n         Designed only for test runner usage; will not handle large\n         amounts of data.\n         \"\"\"\n+        # Check if migrations were run by verifying core Django tables exist\n+        try:\n+            with self.connection.cursor() as cursor:\n+                cursor.execute(\"SELECT 1 FROM django_migrations LIMIT 1\")\n+        except Exception:\n+            # If django_migrations table doesn't exist, migrations weren't run\n+            # Return empty serialization to avoid crashes\n+            return \"[]\"\n+        \n         # Iteratively return every object for all models to serialize.\n         def get_objects():\n             from django.db.migrations.loader import MigrationLoader\n@@ -112,10 +138,38 @@ class BaseDatabaseCreation:\n                             model._meta.can_migrate(self.connection) and\n                             router.allow_migrate_model(self.connection.alias, model)\n                         ):\n-                            queryset = model._default_manager.using(\n-                                self.connection.alias,\n-                            ).order_by(model._meta.pk.name)\n-                            yield from queryset.iterator()\n+                            try:\n+                                queryset = model._default_manager.using(\n+                                    self.connection.alias,\n+                                ).order_by(model._meta.pk.name)\n+                                yield from queryset.iterator()\n+                            except Exception:\n+                                # Skip models whose tables don't exist (e.g., when MIGRATE=False)\n+                                continue\n+        # Serialize to a string\n+        out = StringIO()\n+        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n+        return out.getvalue()\n+                    app_config.label in loader.migrated_apps and\n+                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n+                ):\n+                    for model in app_config.get_models():\n+                        if (\n+                            model._meta.can_migrate(self.connection) and\n+                            router.allow_migrate_model(self.connection.alias, model)\n+                        ):\n+                            try:\n+                                queryset = model._default_manager.using(\n+                                    self.connection.alias,\n+                                ).order_by(model._meta.pk.name)\n+                                yield from queryset.iterator()\n+                            except Exception:\n+                                # Skip models whose tables don't exist\n+                                continue\n+        # Serialize to a string\n+        out = StringIO()\n+        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n+        return out.getvalue()\n         # Serialize to a string\n         out = StringIO()\n         serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\ndiff --git a/django/test/utils.py b/django/test/utils.py\nindex 4f4ce99967..09bf7b5bf2 100644\n--- a/django/test/utils.py\n+++ b/django/test/utils.py\n@@ -176,11 +176,23 @@ def setup_databases(verbosity, interactive, *, time_keeper=None, keepdb=False, d\n             if first_alias is None:\n                 first_alias = alias\n                 with time_keeper.timed(\"  Creating '%s'\" % alias):\n+\n+            # Actually create the database for the first connection\n+            if first_alias is None:\n+                first_alias = alias\n+                with time_keeper.timed(\"  Creating '%s'\" % alias):\n+                    # Check if migrations are disabled to avoid serialization issues\n+                    migrate_setting = connection.settings_dict['TEST'].get('MIGRATE', True)\n+                    should_serialize = (\n+                        connection.settings_dict['TEST'].get('SERIALIZE', True) and \n+                        migrate_setting\n+                    )\n                     connection.creation.create_test_db(\n                         verbosity=verbosity,\n                         autoclobber=not interactive,\n                         keepdb=keepdb,\n-                        serialize=connection.settings_dict['TEST'].get('SERIALIZE', True),\n+                        serialize=should_serialize,\n+                    )\n                     )\n                 if parallel > 1:\n                     for index in range(parallel):\n",
    "variant_6": "diff --git a/django/db/backends/base/creation.py b/django/db/backends/base/creation.py\nindex 503f7f56fd..0800ad9cad 100644\n--- a/django/db/backends/base/creation.py\n+++ b/django/db/backends/base/creation.py\n@@ -70,12 +70,23 @@ class BaseDatabaseCreation:\n                 run_syncdb=True,\n             )\n \n+        # We then serialize the current state of the database into a string\n+        # and store it on the connection. This slightly horrific process is so people\n+        # who are testing on databases without transactions or who are using\n+        # a TransactionTestCase still get a clean database on every test run.\n+\n         # We then serialize the current state of the database into a string\n         # and store it on the connection. This slightly horrific process is so people\n         # who are testing on databases without transactions or who are using\n         # a TransactionTestCase still get a clean database on every test run.\n         if serialize:\n-            self.connection._test_serialized_contents = self.serialize_db_to_string()\n+            # Check if migrations were run by looking at the test settings\n+            migrate_setting = self.connection.settings_dict.get('TEST', {}).get('MIGRATE', True)\n+            if migrate_setting:\n+                self.connection._test_serialized_contents = self.serialize_db_to_string()\n+            else:\n+                # Skip serialization when migrations are disabled since tables may not exist\n+                self.connection._test_serialized_contents = None\n \n         call_command('createcachetable', database=self.connection.alias)\n \n@@ -91,19 +102,49 @@ class BaseDatabaseCreation:\n         \"\"\"\n         self.connection.settings_dict['NAME'] = primary_settings_dict['NAME']\n \n-    def serialize_db_to_string(self):\n-        \"\"\"\n-        Serialize all data in the database into a JSON string.\n-        Designed only for test runner usage; will not handle large\n-        amounts of data.\n-        \"\"\"\n-        # Iteratively return every object for all models to serialize.\n-        def get_objects():\n-            from django.db.migrations.loader import MigrationLoader\n-            loader = MigrationLoader(self.connection)\n-            for app_config in apps.get_app_configs():\n-                if (\n-                    app_config.models_module is not None and\n+\n+def serialize_db_to_string(self):\n+    \"\"\"\n+    Serialize all data in the database into a JSON string.\n+    Designed only for test runner usage; will not handle large\n+    amounts of data.\n+    \"\"\"\n+    # Check if migrations were run by looking for core Django tables\n+    with self.connection.cursor() as cursor:\n+        try:\n+            cursor.execute(\"SELECT 1 FROM django_migrations LIMIT 1\")\n+        except Exception:\n+            # If django_migrations table doesn't exist, migrations weren't run\n+            # Return empty serialization result\n+            return \"[]\"\n+    \n+    # Iteratively return every object for all models to serialize.\n+    def get_objects():\n+        from django.db.migrations.loader import MigrationLoader\n+        loader = MigrationLoader(self.connection)\n+        for app_config in apps.get_app_configs():\n+            if (\n+                app_config.models_module is not None and\n+                app_config.label in loader.migrated_apps and\n+                app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n+            ):\n+                for model in app_config.get_models():\n+                    if (\n+                        model._meta.can_migrate(self.connection) and\n+                        router.allow_migrate_model(self.connection.alias, model)\n+                    ):\n+                        try:\n+                            queryset = model._default_manager.using(\n+                                self.connection.alias,\n+                            ).order_by(model._meta.pk.name)\n+                            yield from queryset.iterator()\n+                        except Exception:\n+                            # Skip models whose tables don't exist\n+                            continue\n+    # Serialize to a string\n+    out = StringIO()\n+    serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n+    return out.getvalue()\n                     app_config.label in loader.migrated_apps and\n                     app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n                 ):\n@@ -112,10 +153,18 @@ class BaseDatabaseCreation:\n                             model._meta.can_migrate(self.connection) and\n                             router.allow_migrate_model(self.connection.alias, model)\n                         ):\n-                            queryset = model._default_manager.using(\n-                                self.connection.alias,\n-                            ).order_by(model._meta.pk.name)\n-                            yield from queryset.iterator()\n+                            try:\n+                                queryset = model._default_manager.using(\n+                                    self.connection.alias,\n+                                ).order_by(model._meta.pk.name)\n+                                yield from queryset.iterator()\n+                            except Exception:\n+                                # Skip models whose tables don't exist\n+                                continue\n+        # Serialize to a string\n+        out = StringIO()\n+        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n+        return out.getvalue()\n         # Serialize to a string\n         out = StringIO()\n         serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\ndiff --git a/django/test/utils.py b/django/test/utils.py\nindex 4f4ce99967..38dc7c5b20 100644\n--- a/django/test/utils.py\n+++ b/django/test/utils.py\n@@ -176,11 +176,23 @@ def setup_databases(verbosity, interactive, *, time_keeper=None, keepdb=False, d\n             if first_alias is None:\n                 first_alias = alias\n                 with time_keeper.timed(\"  Creating '%s'\" % alias):\n+\n+            # Actually create the database for the first connection\n+            if first_alias is None:\n+                first_alias = alias\n+                with time_keeper.timed(\"  Creating '%s'\" % alias):\n+                    # Check if migrations are disabled - if so, don't serialize\n+                    migrate_setting = connection.settings_dict['TEST'].get('MIGRATE', True)\n+                    should_serialize = (\n+                        connection.settings_dict['TEST'].get('SERIALIZE', True) and \n+                        migrate_setting is not False\n+                    )\n                     connection.creation.create_test_db(\n                         verbosity=verbosity,\n                         autoclobber=not interactive,\n                         keepdb=keepdb,\n-                        serialize=connection.settings_dict['TEST'].get('SERIALIZE', True),\n+                        serialize=should_serialize,\n+                    )\n                     )\n                 if parallel > 1:\n                     for index in range(parallel):\n",
    "variant_7": "diff --git a/django/db/backends/base/creation.py b/django/db/backends/base/creation.py\nindex 503f7f56fd..0118ee81e5 100644\n--- a/django/db/backends/base/creation.py\n+++ b/django/db/backends/base/creation.py\n@@ -70,12 +70,26 @@ class BaseDatabaseCreation:\n                 run_syncdb=True,\n             )\n \n+        # We then serialize the current state of the database into a string\n+        # and store it on the connection. This slightly horrific process is so people\n+        # who are testing on databases without transactions or who are using\n+        # a TransactionTestCase still get a clean database on every test run.\n+\n         # We then serialize the current state of the database into a string\n         # and store it on the connection. This slightly horrific process is so people\n         # who are testing on databases without transactions or who are using\n         # a TransactionTestCase still get a clean database on every test run.\n         if serialize:\n-            self.connection._test_serialized_contents = self.serialize_db_to_string()\n+            # Check if migrations were actually run before attempting serialization\n+            # If MIGRATE is False, the database may not have the required tables\n+            test_settings = self.connection.settings_dict.get('TEST', {})\n+            migrate_setting = test_settings.get('MIGRATE', True)\n+            \n+            if migrate_setting:\n+                self.connection._test_serialized_contents = self.serialize_db_to_string()\n+            else:\n+                # Skip serialization when migrations are disabled to avoid querying non-existent tables\n+                self.connection._test_serialized_contents = None\n \n         call_command('createcachetable', database=self.connection.alias)\n \n@@ -91,31 +105,65 @@ class BaseDatabaseCreation:\n         \"\"\"\n         self.connection.settings_dict['NAME'] = primary_settings_dict['NAME']\n \n-    def serialize_db_to_string(self):\n-        \"\"\"\n-        Serialize all data in the database into a JSON string.\n-        Designed only for test runner usage; will not handle large\n-        amounts of data.\n-        \"\"\"\n-        # Iteratively return every object for all models to serialize.\n-        def get_objects():\n-            from django.db.migrations.loader import MigrationLoader\n-            loader = MigrationLoader(self.connection)\n-            for app_config in apps.get_app_configs():\n-                if (\n-                    app_config.models_module is not None and\n-                    app_config.label in loader.migrated_apps and\n-                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n-                ):\n-                    for model in app_config.get_models():\n-                        if (\n-                            model._meta.can_migrate(self.connection) and\n-                            router.allow_migrate_model(self.connection.alias, model)\n-                        ):\n+\n+def serialize_db_to_string(self):\n+    \"\"\"\n+    Serialize all data in the database into a JSON string.\n+    Designed only for test runner usage; will not handle large\n+    amounts of data.\n+    \"\"\"\n+    # Check if migrations were run by verifying core Django tables exist\n+    try:\n+        with self.connection.cursor() as cursor:\n+            cursor.execute(\"SELECT 1 FROM django_migrations LIMIT 1\")\n+    except Exception:\n+        # If django_migrations table doesn't exist, migrations weren't run\n+        # Return empty serialization to avoid crashes\n+        return \"[]\"\n+    \n+    # Iteratively return every object for all models to serialize.\n+    def get_objects():\n+        from django.db.migrations.loader import MigrationLoader\n+        loader = MigrationLoader(self.connection)\n+        for app_config in apps.get_app_configs():\n+            if (\n+                app_config.models_module is not None and\n+                app_config.label in loader.migrated_apps and\n+                app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n+            ):\n+                for model in app_config.get_models():\n+                    if (\n+                        model._meta.can_migrate(self.connection) and\n+                        router.allow_migrate_model(self.connection.alias, model)\n+                    ):\n+                        try:\n+                            queryset = model._default_manager.using(\n+                                self.connection.alias,\n+                            ).order_by(model._meta.pk.name)\n+                            yield from queryset.iterator()\n+                        except Exception:\n+                            # Skip models whose tables don't exist\n+                            continue\n+    # Serialize to a string\n+    out = StringIO()\n+    serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n+    return out.getvalue()\n+                app_config.label in loader.migrated_apps and\n+                app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n+            ):\n+                for model in app_config.get_models():\n+                    if (\n+                        model._meta.can_migrate(self.connection) and\n+                        router.allow_migrate_model(self.connection.alias, model)\n+                    ):\n+                        try:\n                             queryset = model._default_manager.using(\n                                 self.connection.alias,\n                             ).order_by(model._meta.pk.name)\n                             yield from queryset.iterator()\n+                        except Exception:\n+                            # Skip models whose tables don't exist\n+                            continue\n         # Serialize to a string\n         out = StringIO()\n         serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\ndiff --git a/django/test/utils.py b/django/test/utils.py\nindex 4f4ce99967..fb9f78d39d 100644\n--- a/django/test/utils.py\n+++ b/django/test/utils.py\n@@ -176,11 +176,13 @@ def setup_databases(verbosity, interactive, *, time_keeper=None, keepdb=False, d\n             if first_alias is None:\n                 first_alias = alias\n                 with time_keeper.timed(\"  Creating '%s'\" % alias):\n-                    connection.creation.create_test_db(\n-                        verbosity=verbosity,\n-                        autoclobber=not interactive,\n-                        keepdb=keepdb,\n-                        serialize=connection.settings_dict['TEST'].get('SERIALIZE', True),\n+\n+                connection.creation.create_test_db(\n+                    verbosity=verbosity,\n+                    autoclobber=not interactive,\n+                    keepdb=keepdb,\n+                    serialize=connection.settings_dict['TEST'].get('SERIALIZE', True) and connection.settings_dict['TEST'].get('MIGRATE', True),\n+                )\n                     )\n                 if parallel > 1:\n                     for index in range(parallel):\n",
    "variant_8": "diff --git a/django/db/backends/base/creation.py b/django/db/backends/base/creation.py\nindex 503f7f56fd..fde5910054 100644\n--- a/django/db/backends/base/creation.py\n+++ b/django/db/backends/base/creation.py\n@@ -70,12 +70,23 @@ class BaseDatabaseCreation:\n                 run_syncdb=True,\n             )\n \n+        # We then serialize the current state of the database into a string\n+        # and store it on the connection. This slightly horrific process is so people\n+        # who are testing on databases without transactions or who are using\n+        # a TransactionTestCase still get a clean database on every test run.\n+\n         # We then serialize the current state of the database into a string\n         # and store it on the connection. This slightly horrific process is so people\n         # who are testing on databases without transactions or who are using\n         # a TransactionTestCase still get a clean database on every test run.\n         if serialize:\n-            self.connection._test_serialized_contents = self.serialize_db_to_string()\n+            # Check if migrations were run by looking at the test settings\n+            test_migrate = self.connection.settings_dict.get('TEST', {}).get('MIGRATE', True)\n+            if test_migrate:\n+                self.connection._test_serialized_contents = self.serialize_db_to_string()\n+            else:\n+                # Skip serialization when migrations are disabled since tables may not exist\n+                self.connection._test_serialized_contents = None\n \n         call_command('createcachetable', database=self.connection.alias)\n \n@@ -91,12 +102,28 @@ class BaseDatabaseCreation:\n         \"\"\"\n         self.connection.settings_dict['NAME'] = primary_settings_dict['NAME']\n \n+\n     def serialize_db_to_string(self):\n         \"\"\"\n         Serialize all data in the database into a JSON string.\n         Designed only for test runner usage; will not handle large\n         amounts of data.\n         \"\"\"\n+        # Check if migrations were run by verifying core Django tables exist\n+        try:\n+            with self.connection.cursor() as cursor:\n+                cursor.execute(\n+                    \"SELECT 1 FROM information_schema.tables WHERE table_name = 'django_migrations' LIMIT 1\"\n+                    if self.connection.vendor == 'postgresql'\n+                    else \"SELECT 1 FROM sqlite_master WHERE type='table' AND name='django_migrations' LIMIT 1\"\n+                    if self.connection.vendor == 'sqlite'\n+                    else \"SELECT 1 FROM django_migrations LIMIT 1\"\n+                )\n+                cursor.fetchone()\n+        except Exception:\n+            # If django_migrations table doesn't exist, migrations weren't run\n+            return \"[]\"\n+        \n         # Iteratively return every object for all models to serialize.\n         def get_objects():\n             from django.db.migrations.loader import MigrationLoader\n@@ -112,10 +139,38 @@ class BaseDatabaseCreation:\n                             model._meta.can_migrate(self.connection) and\n                             router.allow_migrate_model(self.connection.alias, model)\n                         ):\n-                            queryset = model._default_manager.using(\n-                                self.connection.alias,\n-                            ).order_by(model._meta.pk.name)\n-                            yield from queryset.iterator()\n+                            try:\n+                                queryset = model._default_manager.using(\n+                                    self.connection.alias,\n+                                ).order_by(model._meta.pk.name)\n+                                yield from queryset.iterator()\n+                            except Exception:\n+                                # Skip models whose tables don't exist\n+                                continue\n+        # Serialize to a string\n+        out = StringIO()\n+        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n+        return out.getvalue()\n+                    app_config.label in loader.migrated_apps and\n+                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n+                ):\n+                    for model in app_config.get_models():\n+                        if (\n+                            model._meta.can_migrate(self.connection) and\n+                            router.allow_migrate_model(self.connection.alias, model)\n+                        ):\n+                            try:\n+                                queryset = model._default_manager.using(\n+                                    self.connection.alias,\n+                                ).order_by(model._meta.pk.name)\n+                                yield from queryset.iterator()\n+                            except Exception:\n+                                # Skip models whose tables don't exist\n+                                continue\n+        # Serialize to a string\n+        out = StringIO()\n+        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n+        return out.getvalue()\n         # Serialize to a string\n         out = StringIO()\n         serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\ndiff --git a/django/test/utils.py b/django/test/utils.py\nindex 4f4ce99967..45d52b1c5c 100644\n--- a/django/test/utils.py\n+++ b/django/test/utils.py\n@@ -175,12 +175,15 @@ def setup_databases(verbosity, interactive, *, time_keeper=None, keepdb=False, d\n             # Actually create the database for the first connection\n             if first_alias is None:\n                 first_alias = alias\n+                with time_keeper.timed(\"  Creating '%s'\" % alias):\n+\n                 with time_keeper.timed(\"  Creating '%s'\" % alias):\n                     connection.creation.create_test_db(\n                         verbosity=verbosity,\n                         autoclobber=not interactive,\n                         keepdb=keepdb,\n-                        serialize=connection.settings_dict['TEST'].get('SERIALIZE', True),\n+                        serialize=connection.settings_dict['TEST'].get('SERIALIZE', True) and connection.settings_dict['TEST'].get('MIGRATE', True),\n+                    )\n                     )\n                 if parallel > 1:\n                     for index in range(parallel):\n"
  }
}