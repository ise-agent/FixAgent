{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/sphinx/sphinx/ext/autodoc/typehints.py lines 169-177)": "\n    # Add 'type' for parameters with a description but no declared type.\n    for name in annotations:\n        if name in ('return', 'returns'):\n            continue\n        \n        # Normalize parameter names for variadic parameters\n        # Check both the original name and variadic forms\n        normalized_name = name\n        variadic_forms = [name]\n        \n        # For regular parameters, also check if they have variadic forms documented\n        if name == 'args':\n            variadic_forms.extend(['*args'])\n        elif name == 'kwargs':\n            variadic_forms.extend(['**kwargs'])\n        \n        # Check if any form of the parameter has a description but no type\n        has_desc = any(form in has_description for form in variadic_forms)\n        has_typ = any(form in has_type for form in variadic_forms)\n        \n        if has_desc and not has_typ:\n            field = nodes.field()\n            # Use the documented form if it exists, otherwise use the annotation name\n            documented_name = next((form for form in variadic_forms if form in has_description), name)\n            field += nodes.field_name('', 'type ' + documented_name)\n            field += nodes.field_body('', nodes.paragraph('', annotations[name]))\n            node += field\n",
    "Location 2 (/root/hy/projects_3/sphinx/sphinx/ext/autodoc/typehints.py lines 152-163)": "\n    fields = cast(Iterable[nodes.field], node)\n    has_description = set()  # type: Set[str]\n    has_type = set()  # type: Set[str]\n    for field in fields:\n        field_name = field[0].astext()\n        parts = re.split(' +', field_name)\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                param_name = parts[1]\n                has_description.add(param_name)\n                # Also add normalized name for variadic parameters\n                if param_name.startswith('**'):\n                    has_description.add(param_name[2:])\n                elif param_name.startswith('*'):\n                    has_description.add(param_name[1:])\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                has_description.add(name)\n                has_type.add(name)\n                # Also add normalized name for variadic parameters\n                if name.startswith('**'):\n                    has_description.add(name[2:])\n                    has_type.add(name[2:])\n                elif name.startswith('*'):\n                    has_description.add(name[1:])\n                    has_type.add(name[1:])\n        elif parts[0] == 'type':\n            name = ' '.join(parts[1:])\n            has_type.add(name)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/sphinx/sphinx/ext/autodoc/typehints.py lines 169-177)": [
      "\n    # Add 'type' for parameters with a description but no declared type.\n    for name in annotations:\n        if name in ('return', 'returns'):\n            continue\n        \n        # Normalize parameter names for variadic arguments\n        normalized_name = name\n        if name.startswith('*'):\n            # For *args and **kwargs, remove asterisks for comparison\n            normalized_name = name.lstrip('*')\n        \n        # Check if this parameter (or its variadic form) has a description but no type\n        has_desc = (name in has_description or \n                   ('*' + name) in has_description or \n                   ('**' + name) in has_description)\n        has_typ = (name in has_type or \n                  ('*' + name) in has_type or \n                  ('**' + name) in has_type)\n        \n        if has_desc and not has_typ:\n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + name)\n            field += nodes.field_body('', nodes.paragraph('', annotations[name]))\n            node += field\n",
      "\n    # Add 'type' for parameters with a description but no declared type.\n    for name in annotations:\n        if name in ('return', 'returns'):\n            continue\n        \n        # Handle variadic parameters by checking both normalized and prefixed names\n        normalized_name = name\n        prefixed_name = name\n        if name == 'args':\n            prefixed_name = '*args'\n        elif name == 'kwargs':\n            prefixed_name = '**kwargs'\n        elif name.startswith('*'):\n            if name.startswith('**'):\n                normalized_name = name[2:]\n            else:\n                normalized_name = name[1:]\n        \n        # Check if parameter has description (using either form) but no type\n        has_desc = (normalized_name in has_description or prefixed_name in has_description)\n        has_typ = (normalized_name in has_type or prefixed_name in has_type)\n        \n        if has_desc and not has_typ:\n            field = nodes.field()\n            # Use the prefixed name for display if it exists in descriptions\n            display_name = prefixed_name if prefixed_name in has_description else normalized_name\n            field += nodes.field_name('', 'type ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', annotations[name]))\n            node += field\n",
      "\n    # Add 'type' for parameters with a description but no declared type.\n    for name in annotations:\n        if name in ('return', 'returns'):\n            continue\n        \n        # Handle variadic parameters by checking both normalized and prefixed forms\n        variadic_name = None\n        if name == 'args':\n            variadic_name = '*args'\n        elif name == 'kwargs':\n            variadic_name = '**kwargs'\n        \n        # Check if parameter has description (either as original name or variadic form)\n        has_desc = name in has_description or (variadic_name and variadic_name in has_description)\n        # Check if parameter has type (either as original name or variadic form)\n        has_typ = name in has_type or (variadic_name and variadic_name in has_type)\n        \n        if has_desc and not has_typ:\n            field = nodes.field()\n            # Use the variadic form in the field name if it exists in descriptions\n            display_name = variadic_name if variadic_name and variadic_name in has_description else name\n            field += nodes.field_name('', 'type ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', annotations[name]))\n            node += field\n",
      "\n    # Add 'type' for parameters with a description but no declared type.\n    for name in annotations:\n        if name in ('return', 'returns'):\n            continue\n        \n        # Handle variadic parameters by checking both normalized and prefixed names\n        normalized_name = name\n        prefixed_name = name\n        if name == 'args':\n            prefixed_name = '*args'\n        elif name == 'kwargs':\n            prefixed_name = '**kwargs'\n        \n        # Check if parameter has description (either as normalized or prefixed name)\n        has_desc = (normalized_name in has_description or prefixed_name in has_description)\n        # Check if parameter already has type (either as normalized or prefixed name)\n        has_typ = (normalized_name in has_type or prefixed_name in has_type)\n        \n        if has_desc and not has_typ:\n            field = nodes.field()\n            # Use the prefixed name for display if it exists in descriptions\n            display_name = prefixed_name if prefixed_name in has_description else normalized_name\n            field += nodes.field_name('', 'type ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', annotations[name]))\n            node += field\n",
      "\n    # Add 'type' for parameters with a description but no declared type.\n    for name in annotations:\n        if name in ('return', 'returns'):\n            continue\n        \n        # Handle variadic parameters by checking both normalized and prefixed forms\n        check_names = [name]\n        if name == 'args':\n            check_names.append('*args')\n        elif name == 'kwargs':\n            check_names.append('**kwargs')\n        elif name.startswith('*'):\n            # Handle case where annotation name has asterisks\n            check_names.append(name.lstrip('*'))\n        \n        # Check if any form of the parameter name has description but no type\n        has_desc = any(n in has_description for n in check_names)\n        has_typ = any(n in has_type for n in check_names)\n        \n        if has_desc and not has_typ:\n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + name)\n            field += nodes.field_body('', nodes.paragraph('', annotations[name]))\n            node += field\n",
      "\n    # Add 'type' for parameters with a description but no declared type.\n    for name in annotations:\n        if name in ('return', 'returns'):\n            continue\n        \n        # Normalize parameter names for variadic parameters\n        # Check both the original name and variadic forms\n        param_variants = [name]\n        if name == 'args':\n            param_variants.append('*args')\n        elif name == 'kwargs':\n            param_variants.append('**kwargs')\n        elif name.startswith('*'):\n            # Handle cases where annotation might come with asterisks\n            if name.startswith('**'):\n                param_variants.append(name[2:])  # Remove **\n            else:\n                param_variants.append(name[1:])   # Remove *\n        \n        # Check if any variant has description but no type\n        has_desc = any(variant in has_description for variant in param_variants)\n        has_typ = any(variant in has_type for variant in param_variants)\n        \n        if has_desc and not has_typ:\n            field = nodes.field()\n            # Use the form that exists in has_description for the field name\n            display_name = next((variant for variant in param_variants if variant in has_description), name)\n            field += nodes.field_name('', 'type ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', annotations[name]))\n            node += field\n",
      "\n    # Add 'type' for parameters with a description but no declared type.\n    for name in annotations:\n        if name in ('return', 'returns'):\n            continue\n        \n        # For variadic parameters, check both normalized and original forms\n        check_names = [name]\n        if name in ('args', 'kwargs'):\n            check_names.extend([f'*{name}', f'**{name}'])\n        elif name.startswith('*'):\n            # Strip asterisks for checking\n            normalized_name = name.lstrip('*')\n            check_names.append(normalized_name)\n        \n        # Check if any form of the parameter name has description but no type\n        has_desc = any(n in has_description for n in check_names)\n        has_typ = any(n in has_type for n in check_names)\n        \n        if has_desc and not has_typ:\n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + name)\n            field += nodes.field_body('', nodes.paragraph('', annotations[name]))\n            node += field\n",
      "\n    # Add 'type' for parameters with a description but no declared type.\n    for name in annotations:\n        if name in ('return', 'returns'):\n            continue\n        \n        # Normalize parameter names for variadic parameters\n        # Check both the original name and the normalized name (with/without asterisks)\n        normalized_name = name\n        asterisk_name = name\n        \n        if name == 'args':\n            asterisk_name = '*args'\n        elif name == 'kwargs':\n            asterisk_name = '**kwargs'\n        elif name.startswith('**'):\n            normalized_name = name[2:]\n        elif name.startswith('*'):\n            normalized_name = name[1:]\n        \n        # Check if parameter has description but no type using both forms\n        has_desc = (name in has_description or asterisk_name in has_description or \n                   normalized_name in has_description)\n        has_typ = (name in has_type or asterisk_name in has_type or \n                  normalized_name in has_type)\n        \n        if has_desc and not has_typ:\n            field = nodes.field()\n            # Use the asterisk form for display if it exists in descriptions\n            display_name = name\n            if asterisk_name in has_description:\n                display_name = asterisk_name\n            elif normalized_name in has_description and name not in has_description:\n                display_name = normalized_name\n                \n            field += nodes.field_name('', 'type ' + display_name)\n            field += nodes.field_body('', nodes.paragraph('', annotations[name]))\n            node += field\n"
    ],
    "Location 2 (/root/hy/projects_3/sphinx/sphinx/ext/autodoc/typehints.py lines 152-163)": [
      "\n    fields = cast(Iterable[nodes.field], node)\n    has_description = set()  # type: Set[str]\n    has_type = set()  # type: Set[str]\n    for field in fields:\n        field_name = field[0].astext()\n        parts = re.split(' +', field_name)\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                param_name = parts[1]\n                has_description.add(param_name)\n                # Also add normalized name for variadic parameters\n                if param_name.startswith('**'):\n                    has_description.add(param_name[2:])\n                elif param_name.startswith('*'):\n                    has_description.add(param_name[1:])\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                has_description.add(name)\n                has_type.add(name)\n                # Also add normalized name for variadic parameters\n                if name.startswith('**'):\n                    has_description.add(name[2:])\n                    has_type.add(name[2:])\n                elif name.startswith('*'):\n                    has_description.add(name[1:])\n                    has_type.add(name[1:])\n        elif parts[0] == 'type':\n            name = ' '.join(parts[1:])\n            has_type.add(name)\n",
      "\n    fields = cast(Iterable[nodes.field], node)\n    has_description = set()  # type: Set[str]\n    has_type = set()  # type: Set[str]\n    for field in fields:\n        field_name = field[0].astext()\n        parts = re.split(' +', field_name)\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                param_name = parts[1]\n                has_description.add(param_name)\n                # Also add normalized name for variadic parameters\n                if param_name.startswith('**'):\n                    has_description.add(param_name[2:])\n                elif param_name.startswith('*'):\n                    has_description.add(param_name[1:])\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                has_description.add(name)\n                has_type.add(name)\n                # Also add normalized name for variadic parameters\n                if name.startswith('**'):\n                    has_description.add(name[2:])\n                    has_type.add(name[2:])\n                elif name.startswith('*'):\n                    has_description.add(name[1:])\n                    has_type.add(name[1:])\n        elif parts[0] == 'type':\n            name = ' '.join(parts[1:])\n            has_type.add(name)\n",
      "\n    fields = cast(Iterable[nodes.field], node)\n    has_description = set()  # type: Set[str]\n    has_type = set()  # type: Set[str]\n    for field in fields:\n        field_name = field[0].astext()\n        parts = re.split(' +', field_name)\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                param_name = parts[1]\n                has_description.add(param_name)\n                # Also add normalized name for variadic parameters\n                if param_name.startswith('**'):\n                    has_description.add(param_name[2:])\n                elif param_name.startswith('*'):\n                    has_description.add(param_name[1:])\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                has_description.add(name)\n                has_type.add(name)\n                # Also add normalized name for variadic parameters\n                if name.startswith('**'):\n                    has_description.add(name[2:])\n                    has_type.add(name[2:])\n                elif name.startswith('*'):\n                    has_description.add(name[1:])\n                    has_type.add(name[1:])\n        elif parts[0] == 'type':\n            name = ' '.join(parts[1:])\n            has_type.add(name)\n",
      "\n    node: nodes.field_list,\n    annotations: Dict[str, str],\n    force_rtype: bool\n) -> None:\n    fields = cast(Iterable[nodes.field], node)\n    has_description = set()  # type: Set[str]\n    has_type = set()  # type: Set[str]\n    for field in fields:\n        field_name = field[0].astext()\n        parts = re.split(' +', field_name)\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                param_name = parts[1]\n                has_description.add(param_name)\n                # Also add normalized name for variadic parameters\n                if param_name.startswith('*'):\n                    normalized_name = param_name.lstrip('*')\n                    has_description.add(normalized_name)\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                param_name = ' '.join(parts[2:])\n                has_description.add(param_name)\n                has_type.add(param_name)\n                # Also add normalized name for variadic parameters\n                if param_name.startswith('*'):\n                    normalized_name = param_name.lstrip('*')\n                    has_description.add(normalized_name)\n                    has_type.add(normalized_name)\n        elif parts[0] == 'type':\n            param_name = ' '.join(parts[1:])\n            has_type.add(param_name)\n            # Also add normalized name for variadic parameters\n            if param_name.startswith('*'):\n                normalized_name = param_name.lstrip('*')\n                has_type.add(normalized_name)\n\n    # Add 'type' for parameters with a description but no declared type.\n    for name in annotations:\n        if name in ('return', 'returns'):\n            continue\n        if name in has_description and name not in has_type:\n",
      "\n    fields = cast(Iterable[nodes.field], node)\n    has_description = set()  # type: Set[str]\n    has_type = set()  # type: Set[str]\n    for field in fields:\n        field_name = field[0].astext()\n        parts = re.split(' +', field_name)\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                param_name = parts[1]\n                has_description.add(param_name)\n                # Also add normalized name for variadic parameters\n                if param_name.startswith('**'):\n                    has_description.add(param_name[2:])\n                elif param_name.startswith('*'):\n                    has_description.add(param_name[1:])\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                has_description.add(name)\n                has_type.add(name)\n                # Also add normalized name for variadic parameters\n                if name.startswith('**'):\n                    has_description.add(name[2:])\n                    has_type.add(name[2:])\n                elif name.startswith('*'):\n                    has_description.add(name[1:])\n                    has_type.add(name[1:])\n        elif parts[0] == 'type':\n            name = ' '.join(parts[1:])\n            has_type.add(name)\n",
      "\n    fields = cast(Iterable[nodes.field], node)\n    has_description = set()  # type: Set[str]\n    has_type = set()  # type: Set[str]\n    for field in fields:\n        field_name = field[0].astext()\n        parts = re.split(' +', field_name)\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                param_name = parts[1]\n                has_description.add(param_name)\n                # Also add normalized name for variadic parameters\n                if param_name.startswith('**'):\n                    has_description.add(param_name[2:])\n                elif param_name.startswith('*'):\n                    has_description.add(param_name[1:])\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                has_description.add(name)\n                has_type.add(name)\n                # Also add normalized name for variadic parameters\n                if name.startswith('**'):\n                    has_description.add(name[2:])\n                    has_type.add(name[2:])\n                elif name.startswith('*'):\n                    has_description.add(name[1:])\n                    has_type.add(name[1:])\n        elif parts[0] == 'type':\n            name = ' '.join(parts[1:])\n            has_type.add(name)\n",
      "\n    fields = cast(Iterable[nodes.field], node)\n    has_description = set()  # type: Set[str]\n    has_type = set()  # type: Set[str]\n    for field in fields:\n        field_name = field[0].astext()\n        parts = re.split(' +', field_name)\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                param_name = parts[1]\n                has_description.add(param_name)\n                # Also add normalized name for variadic parameters\n                if param_name.startswith('**'):\n                    has_description.add(param_name[2:])\n                elif param_name.startswith('*'):\n                    has_description.add(param_name[1:])\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                has_description.add(name)\n                has_type.add(name)\n                # Also add normalized name for variadic parameters\n                if name.startswith('**'):\n                    has_description.add(name[2:])\n                    has_type.add(name[2:])\n                elif name.startswith('*'):\n                    has_description.add(name[1:])\n                    has_type.add(name[1:])\n        elif parts[0] == 'type':\n            name = ' '.join(parts[1:])\n            has_type.add(name)\n",
      "\n    fields = cast(Iterable[nodes.field], node)\n    has_description = set()  # type: Set[str]\n    has_type = set()  # type: Set[str]\n    for field in fields:\n        field_name = field[0].astext()\n        parts = re.split(' +', field_name)\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                param_name = parts[1]\n                has_description.add(param_name)\n                # Also add normalized name for variadic parameters\n                if param_name.startswith('**'):\n                    has_description.add(param_name[2:])\n                elif param_name.startswith('*'):\n                    has_description.add(param_name[1:])\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                param_name = ' '.join(parts[2:])\n                has_description.add(param_name)\n                has_type.add(param_name)\n                # Also add normalized name for variadic parameters\n                if param_name.startswith('**'):\n                    has_description.add(param_name[2:])\n                    has_type.add(param_name[2:])\n                elif param_name.startswith('*'):\n                    has_description.add(param_name[1:])\n                    has_type.add(param_name[1:])\n        elif parts[0] == 'type':\n            param_name = ' '.join(parts[1:])\n            has_type.add(param_name)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex d912cd7d5..2d0a7b686 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -149,32 +149,56 @@ def augment_descriptions_with_types(\n     for field in fields:\n         field_name = field[0].astext()\n         parts = re.split(' +', field_name)\n+\n+    # Add 'type' for parameters with a description but no declared type.\n+    for name in annotations:\n+        if name in ('return', 'returns'):\n+            continue\n+        # Check if parameter has description (including variadic parameter variants)\n+        has_desc = (name in has_description or \n+                   '*' + name in has_description or \n+                   '**' + name in has_description)\n+        # Check if parameter has type (including variadic parameter variants)\n+        has_typ = (name in has_type or \n+                  '*' + name in has_type or \n+                  '**' + name in has_type)\n+        \n+        if has_desc and not has_typ:\n+            field = nodes.field()\n+            field += nodes.field_name('', 'type ' + name)\n+            field += nodes.field_body('', nodes.paragraph('', annotations[name]))\n+            node += field\n+        elif parts[0] in ('return', 'returns'):\n+            has_description.add('return')\n+        elif parts[0] == 'rtype':\n+            has_type.add('return')\n+\n+\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n-                has_description.add(parts[1])\n+                name = parts[1]\n+                has_description.add(name)\n+                # Also add normalized name for variadic parameters\n+                if name.startswith('**'):\n+                    has_description.add(name[2:])\n+                elif name.startswith('*'):\n+                    has_description.add(name[1:])\n             elif len(parts) > 2:\n                 # :param xxx yyy:\n                 name = ' '.join(parts[2:])\n                 has_description.add(name)\n                 has_type.add(name)\n+                # Also add normalized name for variadic parameters\n+                if name.startswith('**'):\n+                    has_description.add(name[2:])\n+                    has_type.add(name[2:])\n+                elif name.startswith('*'):\n+                    has_description.add(name[1:])\n+                    has_type.add(name[1:])\n         elif parts[0] == 'type':\n             name = ' '.join(parts[1:])\n             has_type.add(name)\n-        elif parts[0] in ('return', 'returns'):\n-            has_description.add('return')\n-        elif parts[0] == 'rtype':\n-            has_type.add('return')\n-\n-    # Add 'type' for parameters with a description but no declared type.\n-    for name in annotations:\n-        if name in ('return', 'returns'):\n-            continue\n-        if name in has_description and name not in has_type:\n-            field = nodes.field()\n-            field += nodes.field_name('', 'type ' + name)\n-            field += nodes.field_body('', nodes.paragraph('', annotations[name]))\n-            node += field\n \n     # Add 'rtype' if 'return' is present and 'rtype' isn't.\n     if 'return' in annotations:\n",
    "variant_0": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex d912cd7d5..4f51fb96c 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -143,6 +143,13 @@ def augment_descriptions_with_types(\n     annotations: Dict[str, str],\n     force_rtype: bool\n ) -> None:\n+    fields = cast(Iterable[nodes.field], node)\n+    has_description = set()  # type: Set[str]\n+    has_type = set()  # type: Set[str]\n+    for field in fields:\n+        field_name = field[0].astext()\n+        parts = re.split(' +', field_name)\n+\n     fields = cast(Iterable[nodes.field], node)\n     has_description = set()  # type: Set[str]\n     has_type = set()  # type: Set[str]\n@@ -152,12 +159,25 @@ def augment_descriptions_with_types(\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n-                has_description.add(parts[1])\n+                param_name = parts[1]\n+                has_description.add(param_name)\n+                # Also add normalized name for variadic parameters\n+                if param_name.startswith('**'):\n+                    has_description.add(param_name[2:])\n+                elif param_name.startswith('*'):\n+                    has_description.add(param_name[1:])\n             elif len(parts) > 2:\n                 # :param xxx yyy:\n                 name = ' '.join(parts[2:])\n                 has_description.add(name)\n                 has_type.add(name)\n+                # Also add normalized name for variadic parameters\n+                if name.startswith('**'):\n+                    has_description.add(name[2:])\n+                    has_type.add(name[2:])\n+                elif name.startswith('*'):\n+                    has_description.add(name[1:])\n+                    has_type.add(name[1:])\n         elif parts[0] == 'type':\n             name = ' '.join(parts[1:])\n             has_type.add(name)\n@@ -166,13 +186,32 @@ def augment_descriptions_with_types(\n         elif parts[0] == 'rtype':\n             has_type.add('return')\n \n+\n     # Add 'type' for parameters with a description but no declared type.\n     for name in annotations:\n         if name in ('return', 'returns'):\n             continue\n-        if name in has_description and name not in has_type:\n+        \n+        # Normalize parameter names for variadic parameters\n+        # Check both the original name and variadic forms\n+        normalized_name = name\n+        variadic_forms = [name]\n+        \n+        # For regular parameters, also check if they have variadic forms documented\n+        if name == 'args':\n+            variadic_forms.extend(['*args'])\n+        elif name == 'kwargs':\n+            variadic_forms.extend(['**kwargs'])\n+        \n+        # Check if any form of the parameter has a description but no type\n+        has_desc = any(form in has_description for form in variadic_forms)\n+        has_typ = any(form in has_type for form in variadic_forms)\n+        \n+        if has_desc and not has_typ:\n             field = nodes.field()\n-            field += nodes.field_name('', 'type ' + name)\n+            # Use the documented form if it exists, otherwise use the annotation name\n+            documented_name = next((form for form in variadic_forms if form in has_description), name)\n+            field += nodes.field_name('', 'type ' + documented_name)\n             field += nodes.field_body('', nodes.paragraph('', annotations[name]))\n             node += field\n \n",
    "variant_1": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex d912cd7d5..1ac49d513 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -143,6 +143,13 @@ def augment_descriptions_with_types(\n     annotations: Dict[str, str],\n     force_rtype: bool\n ) -> None:\n+    fields = cast(Iterable[nodes.field], node)\n+    has_description = set()  # type: Set[str]\n+    has_type = set()  # type: Set[str]\n+    for field in fields:\n+        field_name = field[0].astext()\n+        parts = re.split(' +', field_name)\n+\n     fields = cast(Iterable[nodes.field], node)\n     has_description = set()  # type: Set[str]\n     has_type = set()  # type: Set[str]\n@@ -152,12 +159,25 @@ def augment_descriptions_with_types(\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n-                has_description.add(parts[1])\n+                param_name = parts[1]\n+                has_description.add(param_name)\n+                # Also add normalized name for variadic parameters\n+                if param_name.startswith('**'):\n+                    has_description.add(param_name[2:])\n+                elif param_name.startswith('*'):\n+                    has_description.add(param_name[1:])\n             elif len(parts) > 2:\n                 # :param xxx yyy:\n                 name = ' '.join(parts[2:])\n                 has_description.add(name)\n                 has_type.add(name)\n+                # Also add normalized name for variadic parameters\n+                if name.startswith('**'):\n+                    has_description.add(name[2:])\n+                    has_type.add(name[2:])\n+                elif name.startswith('*'):\n+                    has_description.add(name[1:])\n+                    has_type.add(name[1:])\n         elif parts[0] == 'type':\n             name = ' '.join(parts[1:])\n             has_type.add(name)\n@@ -166,11 +186,27 @@ def augment_descriptions_with_types(\n         elif parts[0] == 'rtype':\n             has_type.add('return')\n \n+\n     # Add 'type' for parameters with a description but no declared type.\n     for name in annotations:\n         if name in ('return', 'returns'):\n             continue\n-        if name in has_description and name not in has_type:\n+        \n+        # Normalize parameter names for variadic arguments\n+        normalized_name = name\n+        if name.startswith('*'):\n+            # For *args and **kwargs, remove asterisks for comparison\n+            normalized_name = name.lstrip('*')\n+        \n+        # Check if this parameter (or its variadic form) has a description but no type\n+        has_desc = (name in has_description or \n+                   ('*' + name) in has_description or \n+                   ('**' + name) in has_description)\n+        has_typ = (name in has_type or \n+                  ('*' + name) in has_type or \n+                  ('**' + name) in has_type)\n+        \n+        if has_desc and not has_typ:\n             field = nodes.field()\n             field += nodes.field_name('', 'type ' + name)\n             field += nodes.field_body('', nodes.paragraph('', annotations[name]))\n",
    "variant_2": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex d912cd7d5..2e960ac80 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -143,6 +143,13 @@ def augment_descriptions_with_types(\n     annotations: Dict[str, str],\n     force_rtype: bool\n ) -> None:\n+    fields = cast(Iterable[nodes.field], node)\n+    has_description = set()  # type: Set[str]\n+    has_type = set()  # type: Set[str]\n+    for field in fields:\n+        field_name = field[0].astext()\n+        parts = re.split(' +', field_name)\n+\n     fields = cast(Iterable[nodes.field], node)\n     has_description = set()  # type: Set[str]\n     has_type = set()  # type: Set[str]\n@@ -152,12 +159,25 @@ def augment_descriptions_with_types(\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n-                has_description.add(parts[1])\n+                param_name = parts[1]\n+                has_description.add(param_name)\n+                # Also add normalized name for variadic parameters\n+                if param_name.startswith('**'):\n+                    has_description.add(param_name[2:])\n+                elif param_name.startswith('*'):\n+                    has_description.add(param_name[1:])\n             elif len(parts) > 2:\n                 # :param xxx yyy:\n                 name = ' '.join(parts[2:])\n                 has_description.add(name)\n                 has_type.add(name)\n+                # Also add normalized name for variadic parameters\n+                if name.startswith('**'):\n+                    has_description.add(name[2:])\n+                    has_type.add(name[2:])\n+                elif name.startswith('*'):\n+                    has_description.add(name[1:])\n+                    has_type.add(name[1:])\n         elif parts[0] == 'type':\n             name = ' '.join(parts[1:])\n             has_type.add(name)\n@@ -166,13 +186,34 @@ def augment_descriptions_with_types(\n         elif parts[0] == 'rtype':\n             has_type.add('return')\n \n+\n     # Add 'type' for parameters with a description but no declared type.\n     for name in annotations:\n         if name in ('return', 'returns'):\n             continue\n-        if name in has_description and name not in has_type:\n+        \n+        # Handle variadic parameters by checking both normalized and prefixed names\n+        normalized_name = name\n+        prefixed_name = name\n+        if name == 'args':\n+            prefixed_name = '*args'\n+        elif name == 'kwargs':\n+            prefixed_name = '**kwargs'\n+        elif name.startswith('*'):\n+            if name.startswith('**'):\n+                normalized_name = name[2:]\n+            else:\n+                normalized_name = name[1:]\n+        \n+        # Check if parameter has description (using either form) but no type\n+        has_desc = (normalized_name in has_description or prefixed_name in has_description)\n+        has_typ = (normalized_name in has_type or prefixed_name in has_type)\n+        \n+        if has_desc and not has_typ:\n             field = nodes.field()\n-            field += nodes.field_name('', 'type ' + name)\n+            # Use the prefixed name for display if it exists in descriptions\n+            display_name = prefixed_name if prefixed_name in has_description else normalized_name\n+            field += nodes.field_name('', 'type ' + display_name)\n             field += nodes.field_body('', nodes.paragraph('', annotations[name]))\n             node += field\n \n",
    "variant_3": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex d912cd7d5..b031f8077 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -143,6 +143,13 @@ def augment_descriptions_with_types(\n     annotations: Dict[str, str],\n     force_rtype: bool\n ) -> None:\n+    fields = cast(Iterable[nodes.field], node)\n+    has_description = set()  # type: Set[str]\n+    has_type = set()  # type: Set[str]\n+    for field in fields:\n+        field_name = field[0].astext()\n+        parts = re.split(' +', field_name)\n+\n     fields = cast(Iterable[nodes.field], node)\n     has_description = set()  # type: Set[str]\n     has_type = set()  # type: Set[str]\n@@ -152,12 +159,25 @@ def augment_descriptions_with_types(\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n-                has_description.add(parts[1])\n+                param_name = parts[1]\n+                has_description.add(param_name)\n+                # Also add normalized name for variadic parameters\n+                if param_name.startswith('**'):\n+                    has_description.add(param_name[2:])\n+                elif param_name.startswith('*'):\n+                    has_description.add(param_name[1:])\n             elif len(parts) > 2:\n                 # :param xxx yyy:\n                 name = ' '.join(parts[2:])\n                 has_description.add(name)\n                 has_type.add(name)\n+                # Also add normalized name for variadic parameters\n+                if name.startswith('**'):\n+                    has_description.add(name[2:])\n+                    has_type.add(name[2:])\n+                elif name.startswith('*'):\n+                    has_description.add(name[1:])\n+                    has_type.add(name[1:])\n         elif parts[0] == 'type':\n             name = ' '.join(parts[1:])\n             has_type.add(name)\n@@ -166,13 +186,29 @@ def augment_descriptions_with_types(\n         elif parts[0] == 'rtype':\n             has_type.add('return')\n \n+\n     # Add 'type' for parameters with a description but no declared type.\n     for name in annotations:\n         if name in ('return', 'returns'):\n             continue\n-        if name in has_description and name not in has_type:\n+        \n+        # Handle variadic parameters by checking both normalized and prefixed forms\n+        variadic_name = None\n+        if name == 'args':\n+            variadic_name = '*args'\n+        elif name == 'kwargs':\n+            variadic_name = '**kwargs'\n+        \n+        # Check if parameter has description (either as original name or variadic form)\n+        has_desc = name in has_description or (variadic_name and variadic_name in has_description)\n+        # Check if parameter has type (either as original name or variadic form)\n+        has_typ = name in has_type or (variadic_name and variadic_name in has_type)\n+        \n+        if has_desc and not has_typ:\n             field = nodes.field()\n-            field += nodes.field_name('', 'type ' + name)\n+            # Use the variadic form in the field name if it exists in descriptions\n+            display_name = variadic_name if variadic_name and variadic_name in has_description else name\n+            field += nodes.field_name('', 'type ' + display_name)\n             field += nodes.field_body('', nodes.paragraph('', annotations[name]))\n             node += field\n \n",
    "variant_4": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex d912cd7d5..d2e3f8ccc 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -139,6 +139,17 @@ def modify_field_list(node: nodes.field_list, annotations: Dict[str, str],\n \n \n def augment_descriptions_with_types(\n+    node: nodes.field_list,\n+    annotations: Dict[str, str],\n+    force_rtype: bool\n+) -> None:\n+    fields = cast(Iterable[nodes.field], node)\n+    has_description = set()  # type: Set[str]\n+    has_type = set()  # type: Set[str]\n+    for field in fields:\n+        field_name = field[0].astext()\n+        parts = re.split(' +', field_name)\n+\n     node: nodes.field_list,\n     annotations: Dict[str, str],\n     force_rtype: bool\n@@ -152,27 +163,64 @@ def augment_descriptions_with_types(\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n-                has_description.add(parts[1])\n+                param_name = parts[1]\n+                has_description.add(param_name)\n+                # Also add normalized name for variadic parameters\n+                if param_name.startswith('*'):\n+                    normalized_name = param_name.lstrip('*')\n+                    has_description.add(normalized_name)\n             elif len(parts) > 2:\n                 # :param xxx yyy:\n-                name = ' '.join(parts[2:])\n-                has_description.add(name)\n-                has_type.add(name)\n+                param_name = ' '.join(parts[2:])\n+                has_description.add(param_name)\n+                has_type.add(param_name)\n+                # Also add normalized name for variadic parameters\n+                if param_name.startswith('*'):\n+                    normalized_name = param_name.lstrip('*')\n+                    has_description.add(normalized_name)\n+                    has_type.add(normalized_name)\n         elif parts[0] == 'type':\n-            name = ' '.join(parts[1:])\n-            has_type.add(name)\n+            param_name = ' '.join(parts[1:])\n+            has_type.add(param_name)\n+            # Also add normalized name for variadic parameters\n+            if param_name.startswith('*'):\n+                normalized_name = param_name.lstrip('*')\n+                has_type.add(normalized_name)\n+\n+    # Add 'type' for parameters with a description but no declared type.\n+    for name in annotations:\n+        if name in ('return', 'returns'):\n+            continue\n+        if name in has_description and name not in has_type:\n         elif parts[0] in ('return', 'returns'):\n             has_description.add('return')\n         elif parts[0] == 'rtype':\n             has_type.add('return')\n \n+\n     # Add 'type' for parameters with a description but no declared type.\n     for name in annotations:\n         if name in ('return', 'returns'):\n             continue\n-        if name in has_description and name not in has_type:\n+        \n+        # Handle variadic parameters by checking both normalized and prefixed names\n+        normalized_name = name\n+        prefixed_name = name\n+        if name == 'args':\n+            prefixed_name = '*args'\n+        elif name == 'kwargs':\n+            prefixed_name = '**kwargs'\n+        \n+        # Check if parameter has description (either as normalized or prefixed name)\n+        has_desc = (normalized_name in has_description or prefixed_name in has_description)\n+        # Check if parameter already has type (either as normalized or prefixed name)\n+        has_typ = (normalized_name in has_type or prefixed_name in has_type)\n+        \n+        if has_desc and not has_typ:\n             field = nodes.field()\n-            field += nodes.field_name('', 'type ' + name)\n+            # Use the prefixed name for display if it exists in descriptions\n+            display_name = prefixed_name if prefixed_name in has_description else normalized_name\n+            field += nodes.field_name('', 'type ' + display_name)\n             field += nodes.field_body('', nodes.paragraph('', annotations[name]))\n             node += field\n \n",
    "variant_5": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex d912cd7d5..c7db45ef3 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -143,6 +143,13 @@ def augment_descriptions_with_types(\n     annotations: Dict[str, str],\n     force_rtype: bool\n ) -> None:\n+    fields = cast(Iterable[nodes.field], node)\n+    has_description = set()  # type: Set[str]\n+    has_type = set()  # type: Set[str]\n+    for field in fields:\n+        field_name = field[0].astext()\n+        parts = re.split(' +', field_name)\n+\n     fields = cast(Iterable[nodes.field], node)\n     has_description = set()  # type: Set[str]\n     has_type = set()  # type: Set[str]\n@@ -152,12 +159,25 @@ def augment_descriptions_with_types(\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n-                has_description.add(parts[1])\n+                param_name = parts[1]\n+                has_description.add(param_name)\n+                # Also add normalized name for variadic parameters\n+                if param_name.startswith('**'):\n+                    has_description.add(param_name[2:])\n+                elif param_name.startswith('*'):\n+                    has_description.add(param_name[1:])\n             elif len(parts) > 2:\n                 # :param xxx yyy:\n                 name = ' '.join(parts[2:])\n                 has_description.add(name)\n                 has_type.add(name)\n+                # Also add normalized name for variadic parameters\n+                if name.startswith('**'):\n+                    has_description.add(name[2:])\n+                    has_type.add(name[2:])\n+                elif name.startswith('*'):\n+                    has_description.add(name[1:])\n+                    has_type.add(name[1:])\n         elif parts[0] == 'type':\n             name = ' '.join(parts[1:])\n             has_type.add(name)\n@@ -166,11 +186,27 @@ def augment_descriptions_with_types(\n         elif parts[0] == 'rtype':\n             has_type.add('return')\n \n+\n     # Add 'type' for parameters with a description but no declared type.\n     for name in annotations:\n         if name in ('return', 'returns'):\n             continue\n-        if name in has_description and name not in has_type:\n+        \n+        # Handle variadic parameters by checking both normalized and prefixed forms\n+        check_names = [name]\n+        if name == 'args':\n+            check_names.append('*args')\n+        elif name == 'kwargs':\n+            check_names.append('**kwargs')\n+        elif name.startswith('*'):\n+            # Handle case where annotation name has asterisks\n+            check_names.append(name.lstrip('*'))\n+        \n+        # Check if any form of the parameter name has description but no type\n+        has_desc = any(n in has_description for n in check_names)\n+        has_typ = any(n in has_type for n in check_names)\n+        \n+        if has_desc and not has_typ:\n             field = nodes.field()\n             field += nodes.field_name('', 'type ' + name)\n             field += nodes.field_body('', nodes.paragraph('', annotations[name]))\n",
    "variant_6": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex d912cd7d5..a62a468be 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -143,6 +143,13 @@ def augment_descriptions_with_types(\n     annotations: Dict[str, str],\n     force_rtype: bool\n ) -> None:\n+    fields = cast(Iterable[nodes.field], node)\n+    has_description = set()  # type: Set[str]\n+    has_type = set()  # type: Set[str]\n+    for field in fields:\n+        field_name = field[0].astext()\n+        parts = re.split(' +', field_name)\n+\n     fields = cast(Iterable[nodes.field], node)\n     has_description = set()  # type: Set[str]\n     has_type = set()  # type: Set[str]\n@@ -152,12 +159,25 @@ def augment_descriptions_with_types(\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n-                has_description.add(parts[1])\n+                param_name = parts[1]\n+                has_description.add(param_name)\n+                # Also add normalized name for variadic parameters\n+                if param_name.startswith('**'):\n+                    has_description.add(param_name[2:])\n+                elif param_name.startswith('*'):\n+                    has_description.add(param_name[1:])\n             elif len(parts) > 2:\n                 # :param xxx yyy:\n                 name = ' '.join(parts[2:])\n                 has_description.add(name)\n                 has_type.add(name)\n+                # Also add normalized name for variadic parameters\n+                if name.startswith('**'):\n+                    has_description.add(name[2:])\n+                    has_type.add(name[2:])\n+                elif name.startswith('*'):\n+                    has_description.add(name[1:])\n+                    has_type.add(name[1:])\n         elif parts[0] == 'type':\n             name = ' '.join(parts[1:])\n             has_type.add(name)\n@@ -166,13 +186,35 @@ def augment_descriptions_with_types(\n         elif parts[0] == 'rtype':\n             has_type.add('return')\n \n+\n     # Add 'type' for parameters with a description but no declared type.\n     for name in annotations:\n         if name in ('return', 'returns'):\n             continue\n-        if name in has_description and name not in has_type:\n+        \n+        # Normalize parameter names for variadic parameters\n+        # Check both the original name and variadic forms\n+        param_variants = [name]\n+        if name == 'args':\n+            param_variants.append('*args')\n+        elif name == 'kwargs':\n+            param_variants.append('**kwargs')\n+        elif name.startswith('*'):\n+            # Handle cases where annotation might come with asterisks\n+            if name.startswith('**'):\n+                param_variants.append(name[2:])  # Remove **\n+            else:\n+                param_variants.append(name[1:])   # Remove *\n+        \n+        # Check if any variant has description but no type\n+        has_desc = any(variant in has_description for variant in param_variants)\n+        has_typ = any(variant in has_type for variant in param_variants)\n+        \n+        if has_desc and not has_typ:\n             field = nodes.field()\n-            field += nodes.field_name('', 'type ' + name)\n+            # Use the form that exists in has_description for the field name\n+            display_name = next((variant for variant in param_variants if variant in has_description), name)\n+            field += nodes.field_name('', 'type ' + display_name)\n             field += nodes.field_body('', nodes.paragraph('', annotations[name]))\n             node += field\n \n",
    "variant_7": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex d912cd7d5..491077fa7 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -143,6 +143,13 @@ def augment_descriptions_with_types(\n     annotations: Dict[str, str],\n     force_rtype: bool\n ) -> None:\n+    fields = cast(Iterable[nodes.field], node)\n+    has_description = set()  # type: Set[str]\n+    has_type = set()  # type: Set[str]\n+    for field in fields:\n+        field_name = field[0].astext()\n+        parts = re.split(' +', field_name)\n+\n     fields = cast(Iterable[nodes.field], node)\n     has_description = set()  # type: Set[str]\n     has_type = set()  # type: Set[str]\n@@ -152,12 +159,25 @@ def augment_descriptions_with_types(\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n-                has_description.add(parts[1])\n+                param_name = parts[1]\n+                has_description.add(param_name)\n+                # Also add normalized name for variadic parameters\n+                if param_name.startswith('**'):\n+                    has_description.add(param_name[2:])\n+                elif param_name.startswith('*'):\n+                    has_description.add(param_name[1:])\n             elif len(parts) > 2:\n                 # :param xxx yyy:\n                 name = ' '.join(parts[2:])\n                 has_description.add(name)\n                 has_type.add(name)\n+                # Also add normalized name for variadic parameters\n+                if name.startswith('**'):\n+                    has_description.add(name[2:])\n+                    has_type.add(name[2:])\n+                elif name.startswith('*'):\n+                    has_description.add(name[1:])\n+                    has_type.add(name[1:])\n         elif parts[0] == 'type':\n             name = ' '.join(parts[1:])\n             has_type.add(name)\n@@ -166,11 +186,26 @@ def augment_descriptions_with_types(\n         elif parts[0] == 'rtype':\n             has_type.add('return')\n \n+\n     # Add 'type' for parameters with a description but no declared type.\n     for name in annotations:\n         if name in ('return', 'returns'):\n             continue\n-        if name in has_description and name not in has_type:\n+        \n+        # For variadic parameters, check both normalized and original forms\n+        check_names = [name]\n+        if name in ('args', 'kwargs'):\n+            check_names.extend([f'*{name}', f'**{name}'])\n+        elif name.startswith('*'):\n+            # Strip asterisks for checking\n+            normalized_name = name.lstrip('*')\n+            check_names.append(normalized_name)\n+        \n+        # Check if any form of the parameter name has description but no type\n+        has_desc = any(n in has_description for n in check_names)\n+        has_typ = any(n in has_type for n in check_names)\n+        \n+        if has_desc and not has_typ:\n             field = nodes.field()\n             field += nodes.field_name('', 'type ' + name)\n             field += nodes.field_body('', nodes.paragraph('', annotations[name]))\n",
    "variant_8": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex d912cd7d5..e443996d0 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -143,6 +143,13 @@ def augment_descriptions_with_types(\n     annotations: Dict[str, str],\n     force_rtype: bool\n ) -> None:\n+    fields = cast(Iterable[nodes.field], node)\n+    has_description = set()  # type: Set[str]\n+    has_type = set()  # type: Set[str]\n+    for field in fields:\n+        field_name = field[0].astext()\n+        parts = re.split(' +', field_name)\n+\n     fields = cast(Iterable[nodes.field], node)\n     has_description = set()  # type: Set[str]\n     has_type = set()  # type: Set[str]\n@@ -152,27 +159,69 @@ def augment_descriptions_with_types(\n         if parts[0] == 'param':\n             if len(parts) == 2:\n                 # :param xxx:\n-                has_description.add(parts[1])\n+                param_name = parts[1]\n+                has_description.add(param_name)\n+                # Also add normalized name for variadic parameters\n+                if param_name.startswith('**'):\n+                    has_description.add(param_name[2:])\n+                elif param_name.startswith('*'):\n+                    has_description.add(param_name[1:])\n             elif len(parts) > 2:\n                 # :param xxx yyy:\n-                name = ' '.join(parts[2:])\n-                has_description.add(name)\n-                has_type.add(name)\n+                param_name = ' '.join(parts[2:])\n+                has_description.add(param_name)\n+                has_type.add(param_name)\n+                # Also add normalized name for variadic parameters\n+                if param_name.startswith('**'):\n+                    has_description.add(param_name[2:])\n+                    has_type.add(param_name[2:])\n+                elif param_name.startswith('*'):\n+                    has_description.add(param_name[1:])\n+                    has_type.add(param_name[1:])\n         elif parts[0] == 'type':\n-            name = ' '.join(parts[1:])\n-            has_type.add(name)\n+            param_name = ' '.join(parts[1:])\n+            has_type.add(param_name)\n         elif parts[0] in ('return', 'returns'):\n             has_description.add('return')\n         elif parts[0] == 'rtype':\n             has_type.add('return')\n \n+\n     # Add 'type' for parameters with a description but no declared type.\n     for name in annotations:\n         if name in ('return', 'returns'):\n             continue\n-        if name in has_description and name not in has_type:\n+        \n+        # Normalize parameter names for variadic parameters\n+        # Check both the original name and the normalized name (with/without asterisks)\n+        normalized_name = name\n+        asterisk_name = name\n+        \n+        if name == 'args':\n+            asterisk_name = '*args'\n+        elif name == 'kwargs':\n+            asterisk_name = '**kwargs'\n+        elif name.startswith('**'):\n+            normalized_name = name[2:]\n+        elif name.startswith('*'):\n+            normalized_name = name[1:]\n+        \n+        # Check if parameter has description but no type using both forms\n+        has_desc = (name in has_description or asterisk_name in has_description or \n+                   normalized_name in has_description)\n+        has_typ = (name in has_type or asterisk_name in has_type or \n+                  normalized_name in has_type)\n+        \n+        if has_desc and not has_typ:\n             field = nodes.field()\n-            field += nodes.field_name('', 'type ' + name)\n+            # Use the asterisk form for display if it exists in descriptions\n+            display_name = name\n+            if asterisk_name in has_description:\n+                display_name = asterisk_name\n+            elif normalized_name in has_description and name not in has_description:\n+                display_name = normalized_name\n+                \n+            field += nodes.field_name('', 'type ' + display_name)\n             field += nodes.field_body('', nodes.paragraph('', annotations[name]))\n             node += field\n \n"
  }
}