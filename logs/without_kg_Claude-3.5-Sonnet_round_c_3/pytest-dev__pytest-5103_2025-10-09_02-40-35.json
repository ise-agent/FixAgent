{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/pytest/src/_pytest/assertion/rewrite.py lines 967-992)": "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() calls\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Create a temporary variable to store the iterable\n            iterable_var = self.assign(self.visit(iterable_arg)[0])\n            \n            # Create explanation for the original call\n            iterable_expl = self.visit(iterable_arg)[1]\n            \n            # Generate code that iterates through the iterable and checks each element\n            # For all(): return False on first falsy element, True if all are truthy\n            # For any(): return True on first truthy element, False if all are falsy\n            \n            if func_name == 'all':\n                # all() returns False if any element is falsy\n                template = \"\"\"\nfor {elem_var} in {iterable_var}:\n    if not {elem_var}:\n        {result_var} = False\n        break\nelse:\n    {result_var} = True\n\"\"\"\n            else:  # any()\n                # any() returns True if any element is truthy\n                template = \"\"\"\nfor {elem_var} in {iterable_var}:\n    if {elem_var}:\n        {result_var} = True\n        break\nelse:\n    {result_var} = False\n\"\"\"\n            \n            # Create variable names\n            elem_var_name = self.variable()\n            result_var_name = self.variable()\n            \n            # Parse the template into AST\n            loop_code = template.format(\n                elem_var=elem_var_name,\n                iterable_var=iterable_var.id if isinstance(iterable_var, ast.Name) else 'iter_temp',\n                result_var=result_var_name\n            )\n            \n            # Create the loop manually instead of parsing template\n            elem_var = ast.Name(elem_var_name, ast.Store())\n            result_var = ast.Name(result_var_name, ast.Store())\n            \n            if func_name == 'all':\n                # if not elem_var: result = False; break\n                test_condition = ast.UnaryOp(ast.Not(), ast.Name(elem_var_name, ast.Load()))\n                break_stmt = ast.Break()\n                assign_false = ast.Assign([result_var], ast.NameConstant(False))\n                if_body = [assign_false, break_stmt]\n                \n                # else: result = True\n                else_assign = ast.Assign([ast.Name(result_var_name, ast.Store())], ast.NameConstant(True))\n                orelse = [else_assign]\n            else:  # any()\n                # if elem_var: result = True; break  \n                test_condition = ast.Name(elem_var_name, ast.Load())\n                break_stmt = ast.Break()\n                assign_true = ast.Assign([result_var], ast.NameConstant(True))\n                if_body = [assign_true, break_stmt]\n                \n                # else: result = False\n                else_assign = ast.Assign([ast.Name(result_var_name, ast.Store())], ast.NameConstant(False))\n                orelse = [else_assign]\n            \n            # Create the for loop\n            for_loop = ast.For(\n                target=elem_var,\n                iter=iterable_var,\n                body=[ast.If(test_condition, if_body, [])],\n                orelse=orelse\n            )\n            \n            # Add the loop to statements\n            self.statements.append(for_loop)\n            \n            # Create explanation\n            expl = \"%s(%s)\" % (func_name, iterable_expl)\n            result_node = ast.Name(result_var_name, ast.Load())\n            res_expl = self.explanation_param(self.display(result_node))\n            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n            \n            return result_node, outer_expl\n        \n        # Default handling for other function calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
    "Location 2 (/root/hy/projects_3/pytest/src/_pytest/assertion/rewrite.py lines 1000-1028)": "\n    def visit_Call_legacy(self, call):\n        \"\"\"\n        visit `ast.Call nodes on 3.4 and below`\n        \"\"\"\n        # Special handling for all() and any() built-ins\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1 and \n            not call.keywords and \n            not call.starargs and \n            not call.kwargs):\n            \n            return self._visit_all_any(call.func.id, call.args[0])\n        \n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        new_star = new_kwarg = None\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            new_args.append(res)\n            arg_expls.append(expl)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            arg_expls.append(keyword.arg + \"=\" + expl)\n        if call.starargs:\n            new_star, expl = self.visit(call.starargs)\n            arg_expls.append(\"*\" + expl)\n        if call.kwargs:\n            new_kwarg, expl = self.visit(call.kwargs)\n            arg_expls.append(\"**\" + expl)\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/pytest/src/_pytest/assertion/rewrite.py lines 967-992)": [
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() built-in functions\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Check if it's a generator expression or list comprehension\n            if isinstance(iterable_arg, (ast.GeneratorExp, ast.ListComp)):\n                # Create a temporary variable for the result\n                result_var = self.variable()\n                \n                # Create the unrolled loop\n                loop_var = self.variable()\n                test_var = self.variable()\n                \n                # Extract the element and condition from comprehension\n                comprehension = iterable_arg.elt if hasattr(iterable_arg, 'elt') else iterable_arg\n                generator = iterable_arg.generators[0]\n                \n                # Create loop to test each element\n                loop_target = generator.target\n                loop_iter, iter_expl = self.visit(generator.iter)\n                \n                # Create the test expression for each element\n                element_test, element_expl = self.visit(comprehension)\n                \n                # Build explanation\n                if func_name == 'all':\n                    # For all(), we want to show the first False element\n                    explanation = \"assert all(%s)\" % iter_expl\n                    failure_msg = \"assert False, ('Element failed: %s')\" % element_expl\n                else:\n                    # For any(), we want to show that no element was True\n                    explanation = \"assert any(%s)\" % iter_expl\n                    failure_msg = \"assert False, ('No element was True')\"\n                \n                # Return the original call for now - full implementation would require\n                # more complex AST transformation to create the unrolled loop\n                new_func, func_expl = self.visit(call.func)\n                arg_expls = []\n                new_args = []\n                for arg in call.args:\n                    res, expl = self.visit(arg)\n                    arg_expls.append(expl)\n                    new_args.append(res)\n                \n                expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n                new_call = ast.Call(new_func, new_args, [])\n                res = self.assign(new_call)\n                res_expl = self.explanation_param(self.display(res))\n                outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n                return res, outer_expl\n        \n        # Default handling for other function calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() calls\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Create a unique variable name for the result\n            result_var = self.variable()\n            \n            # Visit the iterable argument\n            iterable_expr, iterable_expl = self.visit(iterable_arg)\n            \n            # Create variables for loop iteration\n            item_var = self.variable()\n            iter_var = self.variable()\n            \n            # Create the unrolled loop logic\n            # For all(): if any item is False, fail with that item's info\n            # For any(): if all items are False, fail with last item's info\n            \n            if func_name == 'all':\n                # all() fails when first False item is found\n                template = \"\"\"\nfor {item} in {iter}:\n    if not {item}:\n        {result} = False\n        break\nelse:\n    {result} = True\n\"\"\".format(item=item_var, iter=iter_var, result=result_var)\n            else:  # any()\n                # any() fails when no True item is found\n                template = \"\"\"\nfor {item} in {iter}:\n    if {item}:\n        {result} = True\n        break\nelse:\n    {result} = False\n\"\"\".format(item=item_var, iter=iter_var, result=result_var)\n            \n            # Parse the template into AST nodes\n            loop_ast = ast.parse(template).body[0]\n            \n            # Create assignment for the iterable\n            iter_assign = ast.Assign([ast.Name(iter_var, ast.Store())], iterable_expr)\n            \n            # Modify the loop to use our visited expressions\n            loop_ast.iter = ast.Name(iter_var, ast.Load())\n            loop_ast.target = ast.Name(item_var, ast.Store())\n            \n            # Insert the assignments and loop\n            self.statements.append(iter_assign)\n            self.statements.append(loop_ast)\n            \n            # Return the result variable\n            result_expr = ast.Name(result_var, ast.Load())\n            expl = \"%s(%s)\" % (func_name, iterable_expl)\n            return result_expr, expl\n        \n        # Default handling for other function calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() built-in functions\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Create a temporary variable to store the iterable\n            iterable_var = self.variable()\n            iterable_expr, iterable_expl = self.visit(iterable_arg)\n            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_expr))\n            \n            # Create a loop variable\n            loop_var = self.variable()\n            \n            # Create the result variable\n            result_var = self.variable()\n            \n            # Initialize result based on function type\n            init_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], init_value))\n            \n            # Create the loop body\n            loop_body = []\n            \n            # Create assertion for each element\n            element_expr = ast.Name(loop_var, ast.Load())\n            element_res, element_expl = self.visit(element_expr)\n            \n            # Create the condition based on function type\n            if func_name == 'all':\n                # For all(), we want to check if element is falsy\n                condition = ast.UnaryOp(ast.Not(), element_res)\n                failure_msg = \"assert %s\" % element_expl\n            else:\n                # For any(), we want to check if element is truthy  \n                condition = element_res\n                failure_msg = \"assert %s\" % element_expl\n            \n            # Create the assertion\n            assertion = ast.Assert(condition, None)\n            \n            # Create assignment to update result\n            if func_name == 'all':\n                # For all(), if any element is falsy, result becomes False\n                assign_target = ast.Name(result_var, ast.Store())\n                assign_value = ast.NameConstant(False)\n                result_assign = ast.Assign([assign_target], assign_value)\n                \n                # Add conditional assignment and break\n                if_stmt = ast.If(\n                    ast.UnaryOp(ast.Not(), element_res),\n                    [result_assign, ast.Break()],\n                    []\n                )\n                loop_body.append(if_stmt)\n            else:\n                # For any(), if any element is truthy, result becomes True\n                assign_target = ast.Name(result_var, ast.Store())\n                assign_value = ast.NameConstant(True)\n                result_assign = ast.Assign([assign_target], assign_value)\n                \n                # Add conditional assignment and break\n                if_stmt = ast.If(\n                    element_res,\n                    [result_assign, ast.Break()],\n                    []\n                )\n                loop_body.append(if_stmt)\n            \n            # Create the for loop\n            for_loop = ast.For(\n                target=ast.Name(loop_var, ast.Store()),\n                iter=ast.Name(iterable_var, ast.Load()),\n                body=loop_body,\n                orelse=[]\n            )\n            \n            self.statements.append(for_loop)\n            \n            # Return the result variable\n            res = ast.Name(result_var, ast.Load())\n            expl = \"%s(%s)\" % (func_name, iterable_expl)\n            return res, expl\n        \n        # Default handling for other function calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() calls\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1):\n            return self._visit_all_any(call, call.func.id)\n        \n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() calls\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Handle generator expressions and list comprehensions\n            if isinstance(iterable_arg, (ast.GeneratorExp, ast.ListComp)):\n                # Create a temporary variable for the result\n                result_var = self.variable()\n                \n                # Create the loop to check each element\n                loop_var = self.variable()\n                element_var = self.variable()\n                \n                # Get the iterator expression\n                if isinstance(iterable_arg, ast.GeneratorExp):\n                    generator = iterable_arg.generators[0]\n                    element_test = iterable_arg.elt\n                else:  # ListComp\n                    generator = iterable_arg.generators[0]\n                    element_test = iterable_arg.elt\n                \n                # Visit the iterator\n                iter_expr, iter_expl = self.visit(generator.iter)\n                \n                # Create loop variable assignment\n                target = generator.target\n                \n                # Initialize result variable\n                if func_name == 'all':\n                    init_value = ast.NameConstant(value=True)\n                else:  # any\n                    init_value = ast.NameConstant(value=False)\n                \n                result_assign = ast.Assign([ast.Name(result_var, ast.Store())], init_value)\n                self.statements.append(result_assign)\n                \n                # Create the for loop\n                loop_target = ast.Name(element_var, ast.Store())\n                \n                # Visit the element test expression, substituting the loop variable\n                old_target = target\n                new_target = ast.Name(element_var, ast.Load())\n                \n                # Substitute target in element_test\n                substituted_test = self._substitute_target(element_test, old_target, new_target)\n                test_expr, test_expl = self.visit(substituted_test)\n                \n                # Create assertion for the element\n                if func_name == 'all':\n                    # For all(), we want to assert each element is True\n                    assertion = ast.Assert(test_expr, None)\n                    # If assertion fails, set result to False and break\n                    fail_assign = ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(value=False))\n                    break_stmt = ast.Break()\n                    loop_body = [assertion, fail_assign, break_stmt]\n                else:  # any\n                    # For any(), we want to find at least one True element\n                    if_test = test_expr\n                    success_assign = ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(value=True))\n                    break_stmt = ast.Break()\n                    if_stmt = ast.If(if_test, [success_assign, break_stmt], [])\n                    loop_body = [if_stmt]\n                \n                for_loop = ast.For(loop_target, iter_expr, loop_body, [])\n                self.statements.append(for_loop)\n                \n                # Return the result variable\n                res = ast.Name(result_var, ast.Load())\n                expl = \"%s(%s)\" % (func_name, iter_expl)\n                return res, expl\n        \n        # Default handling for regular function calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n    \n    def _substitute_target(self, node, old_target, new_target):\n        \"\"\"Helper method to substitute target variables in AST nodes\"\"\"\n        class TargetSubstituter(ast.NodeTransformer):\n            def visit_Name(self, node):\n                if isinstance(old_target, ast.Name) and node.id == old_target.id:\n                    return new_target\n                return node\n        \n        substituter = TargetSubstituter()\n        return substituter.visit(node)\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() built-in functions\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Handle generator expressions and list comprehensions\n            if isinstance(iterable_arg, (ast.GeneratorExp, ast.ListComp)):\n                # Create a temporary variable for the result\n                result_var = self.variable()\n                \n                # Visit the iterable to get its explanation\n                iterable_expr, iterable_expl = self.visit(iterable_arg)\n                \n                # Create code that iterates and tests each element\n                iter_var = self.variable()\n                element_var = self.variable()\n                \n                # For all(): result starts True, becomes False on first False element\n                # For any(): result starts False, becomes True on first True element\n                initial_value = ast.NameConstant(value=(func_name == 'all'))\n                result_assign = ast.Assign([ast.Name(result_var, ast.Store())], initial_value)\n                \n                # Create the loop that tests each element\n                if isinstance(iterable_arg, ast.GeneratorExp):\n                    # For generator expressions, recreate the generator logic\n                    target = iterable_arg.elt\n                    iter_source = iterable_arg.generators[0].iter\n                    conditions = iterable_arg.generators[0].ifs\n                    \n                    # Visit the target expression to get detailed explanation\n                    target_expr, target_expl = self.visit(target)\n                    \n                    # Create individual assertion for each element\n                    if func_name == 'all':\n                        test_condition = target_expr\n                        failure_msg = \"assert %s\" % target_expl\n                    else:  # any\n                        test_condition = ast.UnaryOp(ast.Not(), target_expr)\n                        failure_msg = \"assert not (%s)\" % target_expl\n                    \n                    # Create the assertion with detailed explanation\n                    assertion = ast.Assert(test_condition, ast.Str(failure_msg))\n                    \n                    # Build explanation showing which element failed\n                    explanation = \"%s(%s)\" % (func_name, iterable_expl)\n                    \n                elif isinstance(iterable_arg, ast.ListComp):\n                    # Similar handling for list comprehensions\n                    target = iterable_arg.elt\n                    target_expr, target_expl = self.visit(target)\n                    \n                    if func_name == 'all':\n                        explanation = \"assert all([%s for ...])\" % target_expl\n                    else:\n                        explanation = \"assert any([%s for ...])\" % target_expl\n                \n                # For now, fall back to the original behavior but with better explanation\n                new_func, func_expl = self.visit(call.func)\n                arg_expls = []\n                new_args = []\n                \n                res, expl = self.visit(iterable_arg)\n                arg_expls.append(expl)\n                new_args.append(res)\n                \n                expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n                new_call = ast.Call(new_func, new_args, [])\n                res = self.assign(new_call)\n                res_expl = self.explanation_param(self.display(res))\n                \n                # Enhanced explanation for all/any failures\n                if isinstance(iterable_arg, (ast.GeneratorExp, ast.ListComp)):\n                    outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n                else:\n                    outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n                \n                return res, outer_expl\n        \n        # Default handling for regular function calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() calls\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Create a temporary variable to store the iterable\n            iterable_var = self.variable()\n            iterable_assign = ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_arg)\n            self.statements.append(iterable_assign)\n            \n            # Create loop variable\n            loop_var = self.variable()\n            \n            # Create the result variable\n            result_var = self.variable()\n            \n            # Initialize result based on function type\n            initial_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n            result_init = ast.Assign([ast.Name(result_var, ast.Store())], initial_value)\n            self.statements.append(result_init)\n            \n            # Create the loop body\n            loop_body = []\n            \n            # Visit the loop variable to get explanation\n            loop_element = ast.Name(loop_var, ast.Load())\n            element_expr, element_expl = self.visit(loop_element)\n            \n            # Create condition based on function type\n            if func_name == 'all':\n                # For all(): if not element, set result to False and break\n                condition = ast.UnaryOp(ast.Not(), element_expr)\n                break_value = ast.NameConstant(False)\n            else:\n                # For any(): if element, set result to True and break\n                condition = element_expr\n                break_value = ast.NameConstant(True)\n            \n            # Create the if statement that breaks on failure\n            assign_result = ast.Assign([ast.Name(result_var, ast.Store())], break_value)\n            break_stmt = ast.Break()\n            if_body = [assign_result, break_stmt]\n            \n            if_stmt = ast.If(condition, if_body, [])\n            loop_body.append(if_stmt)\n            \n            # Create the for loop\n            for_loop = ast.For(\n                target=ast.Name(loop_var, ast.Store()),\n                iter=ast.Name(iterable_var, ast.Load()),\n                body=loop_body,\n                orelse=[]\n            )\n            self.statements.append(for_loop)\n            \n            # Return the result variable\n            result_name = ast.Name(result_var, ast.Load())\n            return result_name, result_var\n        \n        # Default handling for other function calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() calls\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Handle generator expressions and list comprehensions\n            if isinstance(iterable_arg, (ast.GeneratorExp, ast.ListComp)):\n                # Create a temporary variable for the result\n                result_var = self.variable()\n                \n                # Get the element and test from the comprehension\n                if isinstance(iterable_arg, ast.GeneratorExp):\n                    comp = iterable_arg\n                else:  # ListComp\n                    comp = iterable_arg\n                \n                element = comp.elt\n                generators = comp.generators\n                \n                # Create the unrolled version\n                if func_name == 'all':\n                    # For all(), we want to find the first False\n                    test_expr = element\n                    default_result = ast.NameConstant(value=True)\n                    failure_result = ast.NameConstant(value=False)\n                else:  # any()\n                    # For any(), we want to find the first True\n                    test_expr = element\n                    default_result = ast.NameConstant(value=False)\n                    failure_result = ast.NameConstant(value=True)\n                \n                # Visit the test expression to get explanation\n                test_res, test_expl = self.visit(test_expr)\n                \n                # Create explanation for the unrolled call\n                if func_name == 'all':\n                    expl = \"all(%s)\" % test_expl\n                else:\n                    expl = \"any(%s)\" % test_expl\n                \n                # For now, fall back to original behavior but with better explanation\n                new_func, func_expl = self.visit(call.func)\n                arg_expls = []\n                new_args = []\n                for arg in call.args:\n                    res, arg_expl = self.visit(arg)\n                    arg_expls.append(arg_expl)\n                    new_args.append(res)\n                \n                expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n                new_call = ast.Call(new_func, new_args, [])\n                res = self.assign(new_call)\n                res_expl = self.explanation_param(self.display(res))\n                outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n                return res, outer_expl\n        \n        # Original implementation for other calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n"
    ],
    "Location 2 (/root/hy/projects_3/pytest/src/_pytest/assertion/rewrite.py lines 1000-1028)": [
      "\n    def visit_Call_legacy(self, call):\n        \"\"\"\n        visit `ast.Call nodes on 3.4 and below`\n        \"\"\"\n        # Special handling for all() and any() calls\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1 and \n            not call.keywords and \n            not call.starargs and \n            not call.kwargs):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Handle generator expressions and list comprehensions\n            if isinstance(iterable_arg, (ast.GeneratorExp, ast.ListComp)):\n                comp = iterable_arg\n                # Create a unique variable name for the loop\n                loop_var = self.variable()\n                \n                # Create the for loop that tests each element\n                # For all(): if not element: return False\n                # For any(): if element: return True\n                if func_name == 'all':\n                    test_condition = ast.UnaryOp(ast.Not(), ast.Name(loop_var, ast.Load()))\n                    return_value = ast.NameConstant(False)\n                else:  # any()\n                    test_condition = ast.Name(loop_var, ast.Load())\n                    return_value = ast.NameConstant(True)\n                \n                # Build the unrolled assertions\n                stmts = []\n                for generator in comp.generators:\n                    target = generator.target\n                    iter_node = generator.iter\n                    \n                    # Visit the iterable\n                    new_iter, iter_expl = self.visit(iter_node)\n                    \n                    # Create for loop variable\n                    for_target = ast.Name(self.variable(), ast.Store())\n                    \n                    # Transform the comprehension element with current loop variable\n                    old_target = target\n                    if isinstance(comp, ast.GeneratorExp):\n                        element = comp.elt\n                    else:  # ListComp\n                        element = comp.elt\n                    \n                    # Replace the comprehension target with our for loop variable in the element\n                    element_transformer = self._create_name_replacer(old_target, for_target)\n                    new_element = element_transformer.visit(element)\n                    \n                    # Visit the transformed element to get assertion rewriting\n                    element_res, element_expl = self.visit(new_element)\n                    \n                    # Create the assertion for this element\n                    if func_name == 'all':\n                        # assert element, explanation\n                        assertion = ast.Assert(element_res, None)\n                    else:  # any()\n                        # For any(), we need to check if any element is True\n                        # We'll use a different approach - collect results and check at end\n                        pass\n                \n                # For now, fall back to original behavior for complex cases\n                # This is a simplified implementation\n                pass\n        \n        # Original implementation for non-all/any calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        new_star = new_kwarg = None\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            new_args.append(res)\n            arg_expls.append(expl)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            arg_expls.append(keyword.arg + \"=\" + expl)\n        if call.starargs:\n            new_star, expl = self.visit(call.starargs)\n            arg_expls.append(\"*\" + expl)\n        if call.kwargs:\n            new_kwarg, expl = self.visit(call.kwargs)\n            arg_expls.append(\"**\" + expl)\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_legacy(self, call):\n        \"\"\"\n        visit `ast.Call nodes on 3.4 and below`\n        \"\"\"\n        # Special handling for all() and any() calls\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1 and \n            not call.keywords and \n            not call.starargs and \n            not call.kwargs):\n            \n            return self._visit_all_any(call.func.id, call.args[0])\n        \n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        new_star = new_kwarg = None\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            new_args.append(res)\n            arg_expls.append(expl)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            arg_expls.append(keyword.arg + \"=\" + expl)\n        if call.starargs:\n            new_star, expl = self.visit(call.starargs)\n            arg_expls.append(\"*\" + expl)\n        if call.kwargs:\n            new_kwarg, expl = self.visit(call.kwargs)\n            arg_expls.append(\"**\" + expl)\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_legacy(self, call):\n        \"\"\"\n        visit `ast.Call nodes on 3.4 and below`\n        \"\"\"\n        # Special handling for all() and any() calls\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1 and \n            not call.keywords and \n            not call.starargs and \n            not call.kwargs):\n            \n            return self._handle_all_any_call(call)\n        \n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        new_star = new_kwarg = None\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            new_args.append(res)\n            arg_expls.append(expl)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            arg_expls.append(keyword.arg + \"=\" + expl)\n        if call.starargs:\n            new_star, expl = self.visit(call.starargs)\n            arg_expls.append(\"*\" + expl)\n        if call.kwargs:\n            new_kwarg, expl = self.visit(call.kwargs)\n            arg_expls.append(\"**\" + expl)\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_legacy(self, call):\n        \"\"\"\n        visit `ast.Call nodes on 3.4 and below`\n        \"\"\"\n        # Special handling for all() and any() built-ins\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1 and \n            not call.keywords and \n            not call.starargs and \n            not call.kwargs):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Handle generator expressions and comprehensions\n            if isinstance(iterable_arg, (ast.GeneratorExp, ast.ListComp, ast.SetComp)):\n                # Create a temporary variable for the result\n                result_var = self.variable()\n                \n                # Create individual assertions for each element\n                if isinstance(iterable_arg, ast.GeneratorExp):\n                    element = iterable_arg.elt\n                    generators = iterable_arg.generators\n                elif isinstance(iterable_arg, (ast.ListComp, ast.SetComp)):\n                    element = iterable_arg.elt\n                    generators = iterable_arg.generators\n                \n                # Build the unrolled loop\n                test_var = self.variable()\n                \n                # Create the loop body that tests each element\n                element_res, element_expl = self.visit(element)\n                \n                # For all(), we want to assert each element is True\n                # For any(), we want to find at least one True element\n                if func_name == 'all':\n                    # Assert each element is truthy\n                    assertion = ast.Assert(\n                        test=element_res,\n                        msg=None\n                    )\n                else:  # any()\n                    # For any(), we need to track if we found a True value\n                    assertion = ast.If(\n                        test=element_res,\n                        body=[ast.Assign(\n                            targets=[ast.Name(result_var, ast.Store())],\n                            value=ast.NameConstant(True)\n                        )],\n                        orelse=[]\n                    )\n                \n                # Build the complete loop structure\n                loop_body = [assertion]\n                \n                # Create the for loop\n                for gen in reversed(generators):\n                    target_res, target_expl = self.visit(gen.target)\n                    iter_res, iter_expl = self.visit(gen.iter)\n                    \n                    for_loop = ast.For(\n                        target=target_res,\n                        iter=iter_res,\n                        body=loop_body,\n                        orelse=[]\n                    )\n                    \n                    # Add conditions if present\n                    if gen.ifs:\n                        for if_clause in gen.ifs:\n                            if_res, if_expl = self.visit(if_clause)\n                            if_stmt = ast.If(\n                                test=if_res,\n                                body=loop_body,\n                                orelse=[]\n                            )\n                            loop_body = [if_stmt]\n                \n                # Return the transformed structure\n                if func_name == 'all':\n                    # For all(), if we get here without assertion failure, return True\n                    final_result = ast.NameConstant(True)\n                else:\n                    # For any(), return the result variable (False if never set to True)\n                    final_result = ast.Name(result_var, ast.Load())\n                \n                res = self.assign(final_result)\n                res_expl = self.explanation_param(self.display(res))\n                return res, res_expl\n        \n        # Original implementation for non-all/any calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        new_star = new_kwarg = None\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            new_args.append(res)\n            arg_expls.append(expl)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            arg_expls.append(keyword.arg + \"=\" + expl)\n        if call.starargs:\n            new_star, expl = self.visit(call.starargs)\n            arg_expls.append(\"*\" + expl)\n        if call.kwargs:\n            new_kwarg, expl = self.visit(call.kwargs)\n            arg_expls.append(\"**\" + expl)\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_legacy(self, call):\n        \"\"\"\n        visit `ast.Call nodes on 3.4 and below`\n        \"\"\"\n        # Special handling for all() and any() calls\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1 and \n            not call.keywords and \n            not call.starargs and \n            not call.kwargs):\n            \n            return self._visit_all_any_call(call, call.func.id)\n        \n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        new_star = new_kwarg = None\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            new_args.append(res)\n            arg_expls.append(expl)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            arg_expls.append(keyword.arg + \"=\" + expl)\n        if call.starargs:\n            new_star, expl = self.visit(call.starargs)\n            arg_expls.append(\"*\" + expl)\n        if call.kwargs:\n            new_kwarg, expl = self.visit(call.kwargs)\n            arg_expls.append(\"**\" + expl)\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_legacy(self, call):\n        \"\"\"\n        visit `ast.Call nodes on 3.4 and below`\n        \"\"\"\n        # Special handling for all() and any() calls\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1 and \n            not call.keywords and \n            not call.starargs and \n            not call.kwargs):\n            \n            return self._visit_all_any_call(call.func.id, call.args[0])\n        \n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        new_star = new_kwarg = None\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            new_args.append(res)\n            arg_expls.append(expl)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            arg_expls.append(keyword.arg + \"=\" + expl)\n        if call.starargs:\n            new_star, expl = self.visit(call.starargs)\n            arg_expls.append(\"*\" + expl)\n        if call.kwargs:\n            new_kwarg, expl = self.visit(call.kwargs)\n            arg_expls.append(\"**\" + expl)\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_legacy(self, call):\n        \"\"\"\n        visit `ast.Call nodes on 3.4 and below`\n        \"\"\"\n        # Special handling for all() and any() built-in functions\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1 and \n            not call.keywords and \n            not call.starargs and \n            not call.kwargs):\n            \n            return self._visit_all_any(call.func.id, call.args[0])\n        \n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        new_star = new_kwarg = None\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            new_args.append(res)\n            arg_expls.append(expl)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            arg_expls.append(keyword.arg + \"=\" + expl)\n        if call.starargs:\n            new_star, expl = self.visit(call.starargs)\n            arg_expls.append(\"*\" + expl)\n        if call.kwargs:\n            new_kwarg, expl = self.visit(call.kwargs)\n            arg_expls.append(\"**\" + expl)\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_legacy(self, call):\n        \"\"\"\n        visit `ast.Call nodes on 3.4 and below`\n        \"\"\"\n        # Check if this is an all() or any() call that we should unroll\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in ('all', 'any') and \n            len(call.args) == 1 and \n            not call.keywords and \n            not call.starargs and \n            not call.kwargs):\n            \n            # Unroll all() or any() into individual assertions\n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Create a temporary variable to store the iterable\n            temp_var = self.variable()\n            \n            # Visit the iterable argument\n            iterable_res, iterable_expl = self.visit(iterable_arg)\n            \n            # Create assignment of iterable to temp variable\n            temp_assign = ast.Assign([ast.Name(temp_var, ast.Store())], iterable_res)\n            self.statements.append(temp_assign)\n            \n            # Create a loop variable\n            loop_var = self.variable()\n            \n            # Create the unrolled assertion logic\n            if func_name == 'all':\n                # For all(), we want to assert each element is truthy\n                # If any element is falsy, the assertion should fail with details about that element\n                inner_test = ast.Name(loop_var, ast.Load())\n                inner_test_res, inner_test_expl = self.visit(inner_test)\n                \n                # Create the assertion\n                assertion = ast.Assert(inner_test_res, None)\n                \n                # Create explanation for the failed element\n                explanation = self.explanation_param(self.display(inner_test_res))\n                \n                # Create the for loop\n                for_loop = ast.For(\n                    target=ast.Name(loop_var, ast.Store()),\n                    iter=ast.Name(temp_var, ast.Load()),\n                    body=[assertion],\n                    orelse=[]\n                )\n                self.statements.append(for_loop)\n                \n                # Return True (all elements passed) with explanation\n                result_var = self.variable()\n                result_assign = ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True))\n                self.statements.append(result_assign)\n                \n                res_expl = self.explanation_param(self.display(ast.Name(result_var, ast.Load())))\n                outer_expl = \"%s\\n{%s = all(%s)\\n}\" % (res_expl, res_expl, iterable_expl)\n                return ast.Name(result_var, ast.Load()), outer_expl\n                \n            else:  # any()\n                # For any(), we want to check if at least one element is truthy\n                # We'll create a flag variable and set it to True if we find a truthy element\n                flag_var = self.variable()\n                flag_assign = ast.Assign([ast.Name(flag_var, ast.Store())], ast.NameConstant(False))\n                self.statements.append(flag_assign)\n                \n                # Create the loop body that sets flag to True if element is truthy\n                inner_test = ast.Name(loop_var, ast.Load())\n                flag_update = ast.If(\n                    test=inner_test,\n                    body=[ast.Assign([ast.Name(flag_var, ast.Store())], ast.NameConstant(True))],\n                    orelse=[]\n                )\n                \n                for_loop = ast.For(\n                    target=ast.Name(loop_var, ast.Store()),\n                    iter=ast.Name(temp_var, ast.Load()),\n                    body=[flag_update],\n                    orelse=[]\n                )\n                self.statements.append(for_loop)\n                \n                res_expl = self.explanation_param(self.display(ast.Name(flag_var, ast.Load())))\n                outer_expl = \"%s\\n{%s = any(%s)\\n}\" % (res_expl, res_expl, iterable_expl)\n                return ast.Name(flag_var, ast.Load()), outer_expl\n        \n        # Original implementation for non-all/any calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        new_star = new_kwarg = None\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            new_args.append(res)\n            arg_expls.append(expl)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            arg_expls.append(keyword.arg + \"=\" + expl)\n        if call.starargs:\n            new_star, expl = self.visit(call.starargs)\n            arg_expls.append(\"*\" + expl)\n        if call.kwargs:\n            new_kwarg, expl = self.visit(call.kwargs)\n            arg_expls.append(\"**\" + expl)\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2903b8995..71e14fd63 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -964,10 +964,95 @@ warn_explicit(\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return res, explanation\n \n+\n     def visit_Call_35(self, call):\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n+        # Special handling for all() and any() calls to provide better error messages\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1 and \n+            not call.keywords):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Create a temporary variable to store the iterable\n+            iterable_var = self.variable()\n+            iterable_res, iterable_expl = self.visit(iterable_arg)\n+            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_res))\n+            \n+            # Create a loop variable\n+            loop_var = self.variable()\n+            \n+            # Create the unrolled assertion logic\n+            # For all(): assert each element is truthy\n+            # For any(): assert at least one element is truthy (stop on first True)\n+            \n+            if func_name == 'all':\n+                # Generate: for item in iterable: assert item\n+                loop_body = [\n+                    ast.Assign([ast.Name(loop_var, ast.Store())], \n+                              ast.Name(loop_var, ast.Load())),\n+                    ast.Assert(ast.Name(loop_var, ast.Load()), None)\n+                ]\n+                \n+                # Create the for loop\n+                for_loop = ast.For(\n+                    target=ast.Name(loop_var, ast.Store()),\n+                    iter=ast.Name(iterable_var, ast.Load()),\n+                    body=loop_body,\n+                    orelse=[]\n+                )\n+                \n+                # Add the loop to statements\n+                self.statements.append(for_loop)\n+                \n+                # Return True as the result (if we get here, all items were truthy)\n+                res = self.assign(ast.NameConstant(True))\n+                res_expl = self.explanation_param(self.display(res))\n+                outer_expl = \"%s\\n{%s = all(%s)\\n}\" % (res_expl, res_expl, iterable_expl)\n+                return res, outer_expl\n+                \n+            else:  # func_name == 'any'\n+                # For any(), we need to check each element and return True on first truthy\n+                # This is more complex as we need to track if any element was True\n+                found_var = self.variable()\n+                self.statements.append(ast.Assign([ast.Name(found_var, ast.Store())], ast.NameConstant(False)))\n+                \n+                # Create loop body that sets found_var to True and breaks on first truthy element\n+                loop_body = [\n+                    ast.Assign([ast.Name(loop_var, ast.Store())], \n+                              ast.Name(loop_var, ast.Load())),\n+                    ast.If(\n+                        test=ast.Name(loop_var, ast.Load()),\n+                        body=[\n+                            ast.Assign([ast.Name(found_var, ast.Store())], ast.NameConstant(True)),\n+                            ast.Break()\n+                        ],\n+                        orelse=[]\n+                    )\n+                ]\n+                \n+                for_loop = ast.For(\n+                    target=ast.Name(loop_var, ast.Store()),\n+                    iter=ast.Name(iterable_var, ast.Load()),\n+                    body=loop_body,\n+                    orelse=[]\n+                )\n+                \n+                self.statements.append(for_loop)\n+                \n+                # Assert that we found at least one truthy element\n+                self.statements.append(ast.Assert(ast.Name(found_var, ast.Load()), None))\n+                \n+                res = self.assign(ast.Name(found_var, ast.Load()))\n+                res_expl = self.explanation_param(self.display(res))\n+                outer_expl = \"%s\\n{%s = any(%s)\\n}\" % (res_expl, res_expl, iterable_expl)\n+                return res, outer_expl\n+        \n+        # Default handling for other function calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -997,10 +1082,97 @@ warn_explicit(\n         new_starred = ast.Starred(res, starred.ctx)\n         return new_starred, \"*\" + expl\n \n+\n     def visit_Call_legacy(self, call):\n         \"\"\"\n         visit `ast.Call nodes on 3.4 and below`\n         \"\"\"\n+        # Special handling for all() and any() calls to provide better error messages\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1 and \n+            not call.keywords and\n+            not call.starargs and\n+            not call.kwargs):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Create a temporary variable to store the iterable\n+            iterable_var = self.variable()\n+            iterable_res, iterable_expl = self.visit(iterable_arg)\n+            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_res))\n+            \n+            # Create a loop variable\n+            loop_var = self.variable()\n+            \n+            # Create the unrolled assertion logic\n+            # For all(): assert each element is truthy\n+            # For any(): assert at least one element is truthy (stop on first True)\n+            \n+            if func_name == 'all':\n+                # Generate: for item in iterable: assert item\n+                loop_body = [\n+                    ast.Assign([ast.Name(loop_var, ast.Store())], \n+                              ast.Name(loop_var, ast.Load())),\n+                    ast.Assert(ast.Name(loop_var, ast.Load()), None)\n+                ]\n+                \n+                # Create the for loop\n+                for_loop = ast.For(\n+                    target=ast.Name(loop_var, ast.Store()),\n+                    iter=ast.Name(iterable_var, ast.Load()),\n+                    body=loop_body,\n+                    orelse=[]\n+                )\n+                \n+                # Add the loop to statements\n+                self.statements.append(for_loop)\n+                \n+                # Return True as the result (if we get here, all items were truthy)\n+                res = self.assign(ast.NameConstant(True))\n+                res_expl = self.explanation_param(self.display(res))\n+                outer_expl = \"%s\\n{%s = all(%s)\\n}\" % (res_expl, res_expl, iterable_expl)\n+                return res, outer_expl\n+                \n+            else:  # func_name == 'any'\n+                # For any(), we need to check each element and return True on first truthy\n+                # This is more complex as we need to track if any element was True\n+                found_var = self.variable()\n+                self.statements.append(ast.Assign([ast.Name(found_var, ast.Store())], ast.NameConstant(False)))\n+                \n+                # Create loop body that sets found_var to True and breaks on first truthy element\n+                loop_body = [\n+                    ast.Assign([ast.Name(loop_var, ast.Store())], \n+                              ast.Name(loop_var, ast.Load())),\n+                    ast.If(\n+                        test=ast.Name(loop_var, ast.Load()),\n+                        body=[\n+                            ast.Assign([ast.Name(found_var, ast.Store())], ast.NameConstant(True)),\n+                            ast.Break()\n+                        ],\n+                        orelse=[]\n+                    )\n+                ]\n+                \n+                for_loop = ast.For(\n+                    target=ast.Name(loop_var, ast.Store()),\n+                    iter=ast.Name(iterable_var, ast.Load()),\n+                    body=loop_body,\n+                    orelse=[]\n+                )\n+                \n+                self.statements.append(for_loop)\n+                \n+                # Assert that we found at least one truthy element\n+                self.statements.append(ast.Assert(ast.Name(found_var, ast.Load()), None))\n+                \n+                res = self.assign(ast.Name(found_var, ast.Load()))\n+                res_expl = self.explanation_param(self.display(res))\n+                outer_expl = \"%s\\n{%s = any(%s)\\n}\" % (res_expl, res_expl, iterable_expl)\n+                return res, outer_expl\n+        \n+        # Default handling for other function calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n",
    "variant_0": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2903b8995..f83310dfc 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -964,10 +964,106 @@ warn_explicit(\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return res, explanation\n \n+\n     def visit_Call_35(self, call):\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n+        # Special handling for all() and any() calls\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Create a temporary variable to store the iterable\n+            iterable_var = self.assign(self.visit(iterable_arg)[0])\n+            \n+            # Create explanation for the original call\n+            iterable_expl = self.visit(iterable_arg)[1]\n+            \n+            # Generate code that iterates through the iterable and checks each element\n+            # For all(): return False on first falsy element, True if all are truthy\n+            # For any(): return True on first truthy element, False if all are falsy\n+            \n+            if func_name == 'all':\n+                # all() returns False if any element is falsy\n+                template = \"\"\"\n+for {elem_var} in {iterable_var}:\n+    if not {elem_var}:\n+        {result_var} = False\n+        break\n+else:\n+    {result_var} = True\n+\"\"\"\n+            else:  # any()\n+                # any() returns True if any element is truthy\n+                template = \"\"\"\n+for {elem_var} in {iterable_var}:\n+    if {elem_var}:\n+        {result_var} = True\n+        break\n+else:\n+    {result_var} = False\n+\"\"\"\n+            \n+            # Create variable names\n+            elem_var_name = self.variable()\n+            result_var_name = self.variable()\n+            \n+            # Parse the template into AST\n+            loop_code = template.format(\n+                elem_var=elem_var_name,\n+                iterable_var=iterable_var.id if isinstance(iterable_var, ast.Name) else 'iter_temp',\n+                result_var=result_var_name\n+            )\n+            \n+            # Create the loop manually instead of parsing template\n+            elem_var = ast.Name(elem_var_name, ast.Store())\n+            result_var = ast.Name(result_var_name, ast.Store())\n+            \n+            if func_name == 'all':\n+                # if not elem_var: result = False; break\n+                test_condition = ast.UnaryOp(ast.Not(), ast.Name(elem_var_name, ast.Load()))\n+                break_stmt = ast.Break()\n+                assign_false = ast.Assign([result_var], ast.NameConstant(False))\n+                if_body = [assign_false, break_stmt]\n+                \n+                # else: result = True\n+                else_assign = ast.Assign([ast.Name(result_var_name, ast.Store())], ast.NameConstant(True))\n+                orelse = [else_assign]\n+            else:  # any()\n+                # if elem_var: result = True; break  \n+                test_condition = ast.Name(elem_var_name, ast.Load())\n+                break_stmt = ast.Break()\n+                assign_true = ast.Assign([result_var], ast.NameConstant(True))\n+                if_body = [assign_true, break_stmt]\n+                \n+                # else: result = False\n+                else_assign = ast.Assign([ast.Name(result_var_name, ast.Store())], ast.NameConstant(False))\n+                orelse = [else_assign]\n+            \n+            # Create the for loop\n+            for_loop = ast.For(\n+                target=elem_var,\n+                iter=iterable_var,\n+                body=[ast.If(test_condition, if_body, [])],\n+                orelse=orelse\n+            )\n+            \n+            # Add the loop to statements\n+            self.statements.append(for_loop)\n+            \n+            # Create explanation\n+            expl = \"%s(%s)\" % (func_name, iterable_expl)\n+            result_node = ast.Name(result_var_name, ast.Load())\n+            res_expl = self.explanation_param(self.display(result_node))\n+            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+            \n+            return result_node, outer_expl\n+        \n+        # Default handling for other function calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -997,10 +1093,21 @@ warn_explicit(\n         new_starred = ast.Starred(res, starred.ctx)\n         return new_starred, \"*\" + expl\n \n+\n     def visit_Call_legacy(self, call):\n         \"\"\"\n         visit `ast.Call nodes on 3.4 and below`\n         \"\"\"\n+        # Special handling for all() and any() built-ins\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1 and \n+            not call.keywords and \n+            not call.starargs and \n+            not call.kwargs):\n+            \n+            return self._visit_all_any(call.func.id, call.args[0])\n+        \n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n",
    "variant_1": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2903b8995..1df18d93b 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -964,10 +964,67 @@ warn_explicit(\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return res, explanation\n \n+\n     def visit_Call_35(self, call):\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n+        # Special handling for all() and any() built-in functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Check if it's a generator expression or list comprehension\n+            if isinstance(iterable_arg, (ast.GeneratorExp, ast.ListComp)):\n+                # Create a temporary variable for the result\n+                result_var = self.variable()\n+                \n+                # Create the unrolled loop\n+                loop_var = self.variable()\n+                test_var = self.variable()\n+                \n+                # Extract the element and condition from comprehension\n+                comprehension = iterable_arg.elt if hasattr(iterable_arg, 'elt') else iterable_arg\n+                generator = iterable_arg.generators[0]\n+                \n+                # Create loop to test each element\n+                loop_target = generator.target\n+                loop_iter, iter_expl = self.visit(generator.iter)\n+                \n+                # Create the test expression for each element\n+                element_test, element_expl = self.visit(comprehension)\n+                \n+                # Build explanation\n+                if func_name == 'all':\n+                    # For all(), we want to show the first False element\n+                    explanation = \"assert all(%s)\" % iter_expl\n+                    failure_msg = \"assert False, ('Element failed: %s')\" % element_expl\n+                else:\n+                    # For any(), we want to show that no element was True\n+                    explanation = \"assert any(%s)\" % iter_expl\n+                    failure_msg = \"assert False, ('No element was True')\"\n+                \n+                # Return the original call for now - full implementation would require\n+                # more complex AST transformation to create the unrolled loop\n+                new_func, func_expl = self.visit(call.func)\n+                arg_expls = []\n+                new_args = []\n+                for arg in call.args:\n+                    res, expl = self.visit(arg)\n+                    arg_expls.append(expl)\n+                    new_args.append(res)\n+                \n+                expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n+                new_call = ast.Call(new_func, new_args, [])\n+                res = self.assign(new_call)\n+                res_expl = self.explanation_param(self.display(res))\n+                outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+                return res, outer_expl\n+        \n+        # Default handling for other function calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -997,10 +1054,78 @@ warn_explicit(\n         new_starred = ast.Starred(res, starred.ctx)\n         return new_starred, \"*\" + expl\n \n+\n     def visit_Call_legacy(self, call):\n         \"\"\"\n         visit `ast.Call nodes on 3.4 and below`\n         \"\"\"\n+        # Special handling for all() and any() calls\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1 and \n+            not call.keywords and \n+            not call.starargs and \n+            not call.kwargs):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Handle generator expressions and list comprehensions\n+            if isinstance(iterable_arg, (ast.GeneratorExp, ast.ListComp)):\n+                comp = iterable_arg\n+                # Create a unique variable name for the loop\n+                loop_var = self.variable()\n+                \n+                # Create the for loop that tests each element\n+                # For all(): if not element: return False\n+                # For any(): if element: return True\n+                if func_name == 'all':\n+                    test_condition = ast.UnaryOp(ast.Not(), ast.Name(loop_var, ast.Load()))\n+                    return_value = ast.NameConstant(False)\n+                else:  # any()\n+                    test_condition = ast.Name(loop_var, ast.Load())\n+                    return_value = ast.NameConstant(True)\n+                \n+                # Build the unrolled assertions\n+                stmts = []\n+                for generator in comp.generators:\n+                    target = generator.target\n+                    iter_node = generator.iter\n+                    \n+                    # Visit the iterable\n+                    new_iter, iter_expl = self.visit(iter_node)\n+                    \n+                    # Create for loop variable\n+                    for_target = ast.Name(self.variable(), ast.Store())\n+                    \n+                    # Transform the comprehension element with current loop variable\n+                    old_target = target\n+                    if isinstance(comp, ast.GeneratorExp):\n+                        element = comp.elt\n+                    else:  # ListComp\n+                        element = comp.elt\n+                    \n+                    # Replace the comprehension target with our for loop variable in the element\n+                    element_transformer = self._create_name_replacer(old_target, for_target)\n+                    new_element = element_transformer.visit(element)\n+                    \n+                    # Visit the transformed element to get assertion rewriting\n+                    element_res, element_expl = self.visit(new_element)\n+                    \n+                    # Create the assertion for this element\n+                    if func_name == 'all':\n+                        # assert element, explanation\n+                        assertion = ast.Assert(element_res, None)\n+                    else:  # any()\n+                        # For any(), we need to check if any element is True\n+                        # We'll use a different approach - collect results and check at end\n+                        pass\n+                \n+                # For now, fall back to original behavior for complex cases\n+                # This is a simplified implementation\n+                pass\n+        \n+        # Original implementation for non-all/any calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n",
    "variant_2": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2903b8995..375a3a377 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -964,10 +964,74 @@ warn_explicit(\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return res, explanation\n \n+\n     def visit_Call_35(self, call):\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n+        # Special handling for all() and any() calls\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Create a unique variable name for the result\n+            result_var = self.variable()\n+            \n+            # Visit the iterable argument\n+            iterable_expr, iterable_expl = self.visit(iterable_arg)\n+            \n+            # Create variables for loop iteration\n+            item_var = self.variable()\n+            iter_var = self.variable()\n+            \n+            # Create the unrolled loop logic\n+            # For all(): if any item is False, fail with that item's info\n+            # For any(): if all items are False, fail with last item's info\n+            \n+            if func_name == 'all':\n+                # all() fails when first False item is found\n+                template = \"\"\"\n+for {item} in {iter}:\n+    if not {item}:\n+        {result} = False\n+        break\n+else:\n+    {result} = True\n+\"\"\".format(item=item_var, iter=iter_var, result=result_var)\n+            else:  # any()\n+                # any() fails when no True item is found\n+                template = \"\"\"\n+for {item} in {iter}:\n+    if {item}:\n+        {result} = True\n+        break\n+else:\n+    {result} = False\n+\"\"\".format(item=item_var, iter=iter_var, result=result_var)\n+            \n+            # Parse the template into AST nodes\n+            loop_ast = ast.parse(template).body[0]\n+            \n+            # Create assignment for the iterable\n+            iter_assign = ast.Assign([ast.Name(iter_var, ast.Store())], iterable_expr)\n+            \n+            # Modify the loop to use our visited expressions\n+            loop_ast.iter = ast.Name(iter_var, ast.Load())\n+            loop_ast.target = ast.Name(item_var, ast.Store())\n+            \n+            # Insert the assignments and loop\n+            self.statements.append(iter_assign)\n+            self.statements.append(loop_ast)\n+            \n+            # Return the result variable\n+            result_expr = ast.Name(result_var, ast.Load())\n+            expl = \"%s(%s)\" % (func_name, iterable_expl)\n+            return result_expr, expl\n+        \n+        # Default handling for other function calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -997,10 +1061,21 @@ warn_explicit(\n         new_starred = ast.Starred(res, starred.ctx)\n         return new_starred, \"*\" + expl\n \n+\n     def visit_Call_legacy(self, call):\n         \"\"\"\n         visit `ast.Call nodes on 3.4 and below`\n         \"\"\"\n+        # Special handling for all() and any() calls\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1 and \n+            not call.keywords and \n+            not call.starargs and \n+            not call.kwargs):\n+            \n+            return self._visit_all_any(call.func.id, call.args[0])\n+        \n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n",
    "variant_3": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2903b8995..5380886c8 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -964,10 +964,98 @@ warn_explicit(\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return res, explanation\n \n+\n     def visit_Call_35(self, call):\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n+        # Special handling for all() and any() built-in functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Create a temporary variable to store the iterable\n+            iterable_var = self.variable()\n+            iterable_expr, iterable_expl = self.visit(iterable_arg)\n+            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_expr))\n+            \n+            # Create a loop variable\n+            loop_var = self.variable()\n+            \n+            # Create the result variable\n+            result_var = self.variable()\n+            \n+            # Initialize result based on function type\n+            init_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n+            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], init_value))\n+            \n+            # Create the loop body\n+            loop_body = []\n+            \n+            # Create assertion for each element\n+            element_expr = ast.Name(loop_var, ast.Load())\n+            element_res, element_expl = self.visit(element_expr)\n+            \n+            # Create the condition based on function type\n+            if func_name == 'all':\n+                # For all(), we want to check if element is falsy\n+                condition = ast.UnaryOp(ast.Not(), element_res)\n+                failure_msg = \"assert %s\" % element_expl\n+            else:\n+                # For any(), we want to check if element is truthy  \n+                condition = element_res\n+                failure_msg = \"assert %s\" % element_expl\n+            \n+            # Create the assertion\n+            assertion = ast.Assert(condition, None)\n+            \n+            # Create assignment to update result\n+            if func_name == 'all':\n+                # For all(), if any element is falsy, result becomes False\n+                assign_target = ast.Name(result_var, ast.Store())\n+                assign_value = ast.NameConstant(False)\n+                result_assign = ast.Assign([assign_target], assign_value)\n+                \n+                # Add conditional assignment and break\n+                if_stmt = ast.If(\n+                    ast.UnaryOp(ast.Not(), element_res),\n+                    [result_assign, ast.Break()],\n+                    []\n+                )\n+                loop_body.append(if_stmt)\n+            else:\n+                # For any(), if any element is truthy, result becomes True\n+                assign_target = ast.Name(result_var, ast.Store())\n+                assign_value = ast.NameConstant(True)\n+                result_assign = ast.Assign([assign_target], assign_value)\n+                \n+                # Add conditional assignment and break\n+                if_stmt = ast.If(\n+                    element_res,\n+                    [result_assign, ast.Break()],\n+                    []\n+                )\n+                loop_body.append(if_stmt)\n+            \n+            # Create the for loop\n+            for_loop = ast.For(\n+                target=ast.Name(loop_var, ast.Store()),\n+                iter=ast.Name(iterable_var, ast.Load()),\n+                body=loop_body,\n+                orelse=[]\n+            )\n+            \n+            self.statements.append(for_loop)\n+            \n+            # Return the result variable\n+            res = ast.Name(result_var, ast.Load())\n+            expl = \"%s(%s)\" % (func_name, iterable_expl)\n+            return res, expl\n+        \n+        # Default handling for other function calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -997,10 +1085,21 @@ warn_explicit(\n         new_starred = ast.Starred(res, starred.ctx)\n         return new_starred, \"*\" + expl\n \n+\n     def visit_Call_legacy(self, call):\n         \"\"\"\n         visit `ast.Call nodes on 3.4 and below`\n         \"\"\"\n+        # Special handling for all() and any() calls\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1 and \n+            not call.keywords and \n+            not call.starargs and \n+            not call.kwargs):\n+            \n+            return self._handle_all_any_call(call)\n+        \n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n",
    "variant_4": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2903b8995..af87b7ced 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -964,10 +964,17 @@ warn_explicit(\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return res, explanation\n \n+\n     def visit_Call_35(self, call):\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n+        # Special handling for all() and any() calls\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            return self._visit_all_any(call, call.func.id)\n+        \n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -997,10 +1004,99 @@ warn_explicit(\n         new_starred = ast.Starred(res, starred.ctx)\n         return new_starred, \"*\" + expl\n \n+\n     def visit_Call_legacy(self, call):\n         \"\"\"\n         visit `ast.Call nodes on 3.4 and below`\n         \"\"\"\n+        # Special handling for all() and any() built-ins\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1 and \n+            not call.keywords and \n+            not call.starargs and \n+            not call.kwargs):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Handle generator expressions and comprehensions\n+            if isinstance(iterable_arg, (ast.GeneratorExp, ast.ListComp, ast.SetComp)):\n+                # Create a temporary variable for the result\n+                result_var = self.variable()\n+                \n+                # Create individual assertions for each element\n+                if isinstance(iterable_arg, ast.GeneratorExp):\n+                    element = iterable_arg.elt\n+                    generators = iterable_arg.generators\n+                elif isinstance(iterable_arg, (ast.ListComp, ast.SetComp)):\n+                    element = iterable_arg.elt\n+                    generators = iterable_arg.generators\n+                \n+                # Build the unrolled loop\n+                test_var = self.variable()\n+                \n+                # Create the loop body that tests each element\n+                element_res, element_expl = self.visit(element)\n+                \n+                # For all(), we want to assert each element is True\n+                # For any(), we want to find at least one True element\n+                if func_name == 'all':\n+                    # Assert each element is truthy\n+                    assertion = ast.Assert(\n+                        test=element_res,\n+                        msg=None\n+                    )\n+                else:  # any()\n+                    # For any(), we need to track if we found a True value\n+                    assertion = ast.If(\n+                        test=element_res,\n+                        body=[ast.Assign(\n+                            targets=[ast.Name(result_var, ast.Store())],\n+                            value=ast.NameConstant(True)\n+                        )],\n+                        orelse=[]\n+                    )\n+                \n+                # Build the complete loop structure\n+                loop_body = [assertion]\n+                \n+                # Create the for loop\n+                for gen in reversed(generators):\n+                    target_res, target_expl = self.visit(gen.target)\n+                    iter_res, iter_expl = self.visit(gen.iter)\n+                    \n+                    for_loop = ast.For(\n+                        target=target_res,\n+                        iter=iter_res,\n+                        body=loop_body,\n+                        orelse=[]\n+                    )\n+                    \n+                    # Add conditions if present\n+                    if gen.ifs:\n+                        for if_clause in gen.ifs:\n+                            if_res, if_expl = self.visit(if_clause)\n+                            if_stmt = ast.If(\n+                                test=if_res,\n+                                body=loop_body,\n+                                orelse=[]\n+                            )\n+                            loop_body = [if_stmt]\n+                \n+                # Return the transformed structure\n+                if func_name == 'all':\n+                    # For all(), if we get here without assertion failure, return True\n+                    final_result = ast.NameConstant(True)\n+                else:\n+                    # For any(), return the result variable (False if never set to True)\n+                    final_result = ast.Name(result_var, ast.Load())\n+                \n+                res = self.assign(final_result)\n+                res_expl = self.explanation_param(self.display(res))\n+                return res, res_expl\n+        \n+        # Original implementation for non-all/any calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n",
    "variant_5": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2903b8995..f9d628692 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -964,10 +964,87 @@ warn_explicit(\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return res, explanation\n \n+\n     def visit_Call_35(self, call):\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n+        # Special handling for all() and any() calls\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Handle generator expressions and list comprehensions\n+            if isinstance(iterable_arg, (ast.GeneratorExp, ast.ListComp)):\n+                # Create a temporary variable for the result\n+                result_var = self.variable()\n+                \n+                # Create the loop to check each element\n+                loop_var = self.variable()\n+                element_var = self.variable()\n+                \n+                # Get the iterator expression\n+                if isinstance(iterable_arg, ast.GeneratorExp):\n+                    generator = iterable_arg.generators[0]\n+                    element_test = iterable_arg.elt\n+                else:  # ListComp\n+                    generator = iterable_arg.generators[0]\n+                    element_test = iterable_arg.elt\n+                \n+                # Visit the iterator\n+                iter_expr, iter_expl = self.visit(generator.iter)\n+                \n+                # Create loop variable assignment\n+                target = generator.target\n+                \n+                # Initialize result variable\n+                if func_name == 'all':\n+                    init_value = ast.NameConstant(value=True)\n+                else:  # any\n+                    init_value = ast.NameConstant(value=False)\n+                \n+                result_assign = ast.Assign([ast.Name(result_var, ast.Store())], init_value)\n+                self.statements.append(result_assign)\n+                \n+                # Create the for loop\n+                loop_target = ast.Name(element_var, ast.Store())\n+                \n+                # Visit the element test expression, substituting the loop variable\n+                old_target = target\n+                new_target = ast.Name(element_var, ast.Load())\n+                \n+                # Substitute target in element_test\n+                substituted_test = self._substitute_target(element_test, old_target, new_target)\n+                test_expr, test_expl = self.visit(substituted_test)\n+                \n+                # Create assertion for the element\n+                if func_name == 'all':\n+                    # For all(), we want to assert each element is True\n+                    assertion = ast.Assert(test_expr, None)\n+                    # If assertion fails, set result to False and break\n+                    fail_assign = ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(value=False))\n+                    break_stmt = ast.Break()\n+                    loop_body = [assertion, fail_assign, break_stmt]\n+                else:  # any\n+                    # For any(), we want to find at least one True element\n+                    if_test = test_expr\n+                    success_assign = ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(value=True))\n+                    break_stmt = ast.Break()\n+                    if_stmt = ast.If(if_test, [success_assign, break_stmt], [])\n+                    loop_body = [if_stmt]\n+                \n+                for_loop = ast.For(loop_target, iter_expr, loop_body, [])\n+                self.statements.append(for_loop)\n+                \n+                # Return the result variable\n+                res = ast.Name(result_var, ast.Load())\n+                expl = \"%s(%s)\" % (func_name, iter_expl)\n+                return res, expl\n+        \n+        # Default handling for regular function calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -990,6 +1067,17 @@ warn_explicit(\n         res_expl = self.explanation_param(self.display(res))\n         outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n         return res, outer_expl\n+    \n+    def _substitute_target(self, node, old_target, new_target):\n+        \"\"\"Helper method to substitute target variables in AST nodes\"\"\"\n+        class TargetSubstituter(ast.NodeTransformer):\n+            def visit_Name(self, node):\n+                if isinstance(old_target, ast.Name) and node.id == old_target.id:\n+                    return new_target\n+                return node\n+        \n+        substituter = TargetSubstituter()\n+        return substituter.visit(node)\n \n     def visit_Starred(self, starred):\n         # From Python 3.5, a Starred node can appear in a function call\n@@ -997,10 +1085,21 @@ warn_explicit(\n         new_starred = ast.Starred(res, starred.ctx)\n         return new_starred, \"*\" + expl\n \n+\n     def visit_Call_legacy(self, call):\n         \"\"\"\n         visit `ast.Call nodes on 3.4 and below`\n         \"\"\"\n+        # Special handling for all() and any() calls\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1 and \n+            not call.keywords and \n+            not call.starargs and \n+            not call.kwargs):\n+            \n+            return self._visit_all_any_call(call, call.func.id)\n+        \n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n",
    "variant_6": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2903b8995..e389710ba 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -964,10 +964,93 @@ warn_explicit(\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return res, explanation\n \n+\n     def visit_Call_35(self, call):\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n+        # Special handling for all() and any() built-in functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Handle generator expressions and list comprehensions\n+            if isinstance(iterable_arg, (ast.GeneratorExp, ast.ListComp)):\n+                # Create a temporary variable for the result\n+                result_var = self.variable()\n+                \n+                # Visit the iterable to get its explanation\n+                iterable_expr, iterable_expl = self.visit(iterable_arg)\n+                \n+                # Create code that iterates and tests each element\n+                iter_var = self.variable()\n+                element_var = self.variable()\n+                \n+                # For all(): result starts True, becomes False on first False element\n+                # For any(): result starts False, becomes True on first True element\n+                initial_value = ast.NameConstant(value=(func_name == 'all'))\n+                result_assign = ast.Assign([ast.Name(result_var, ast.Store())], initial_value)\n+                \n+                # Create the loop that tests each element\n+                if isinstance(iterable_arg, ast.GeneratorExp):\n+                    # For generator expressions, recreate the generator logic\n+                    target = iterable_arg.elt\n+                    iter_source = iterable_arg.generators[0].iter\n+                    conditions = iterable_arg.generators[0].ifs\n+                    \n+                    # Visit the target expression to get detailed explanation\n+                    target_expr, target_expl = self.visit(target)\n+                    \n+                    # Create individual assertion for each element\n+                    if func_name == 'all':\n+                        test_condition = target_expr\n+                        failure_msg = \"assert %s\" % target_expl\n+                    else:  # any\n+                        test_condition = ast.UnaryOp(ast.Not(), target_expr)\n+                        failure_msg = \"assert not (%s)\" % target_expl\n+                    \n+                    # Create the assertion with detailed explanation\n+                    assertion = ast.Assert(test_condition, ast.Str(failure_msg))\n+                    \n+                    # Build explanation showing which element failed\n+                    explanation = \"%s(%s)\" % (func_name, iterable_expl)\n+                    \n+                elif isinstance(iterable_arg, ast.ListComp):\n+                    # Similar handling for list comprehensions\n+                    target = iterable_arg.elt\n+                    target_expr, target_expl = self.visit(target)\n+                    \n+                    if func_name == 'all':\n+                        explanation = \"assert all([%s for ...])\" % target_expl\n+                    else:\n+                        explanation = \"assert any([%s for ...])\" % target_expl\n+                \n+                # For now, fall back to the original behavior but with better explanation\n+                new_func, func_expl = self.visit(call.func)\n+                arg_expls = []\n+                new_args = []\n+                \n+                res, expl = self.visit(iterable_arg)\n+                arg_expls.append(expl)\n+                new_args.append(res)\n+                \n+                expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n+                new_call = ast.Call(new_func, new_args, [])\n+                res = self.assign(new_call)\n+                res_expl = self.explanation_param(self.display(res))\n+                \n+                # Enhanced explanation for all/any failures\n+                if isinstance(iterable_arg, (ast.GeneratorExp, ast.ListComp)):\n+                    outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+                else:\n+                    outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+                \n+                return res, outer_expl\n+        \n+        # Default handling for regular function calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -997,10 +1080,21 @@ warn_explicit(\n         new_starred = ast.Starred(res, starred.ctx)\n         return new_starred, \"*\" + expl\n \n+\n     def visit_Call_legacy(self, call):\n         \"\"\"\n         visit `ast.Call nodes on 3.4 and below`\n         \"\"\"\n+        # Special handling for all() and any() calls\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1 and \n+            not call.keywords and \n+            not call.starargs and \n+            not call.kwargs):\n+            \n+            return self._visit_all_any_call(call.func.id, call.args[0])\n+        \n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n",
    "variant_7": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2903b8995..54ae361f9 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -964,10 +964,74 @@ warn_explicit(\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return res, explanation\n \n+\n     def visit_Call_35(self, call):\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n+        # Special handling for all() and any() calls\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Create a temporary variable to store the iterable\n+            iterable_var = self.variable()\n+            iterable_assign = ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_arg)\n+            self.statements.append(iterable_assign)\n+            \n+            # Create loop variable\n+            loop_var = self.variable()\n+            \n+            # Create the result variable\n+            result_var = self.variable()\n+            \n+            # Initialize result based on function type\n+            initial_value = ast.NameConstant(True) if func_name == 'all' else ast.NameConstant(False)\n+            result_init = ast.Assign([ast.Name(result_var, ast.Store())], initial_value)\n+            self.statements.append(result_init)\n+            \n+            # Create the loop body\n+            loop_body = []\n+            \n+            # Visit the loop variable to get explanation\n+            loop_element = ast.Name(loop_var, ast.Load())\n+            element_expr, element_expl = self.visit(loop_element)\n+            \n+            # Create condition based on function type\n+            if func_name == 'all':\n+                # For all(): if not element, set result to False and break\n+                condition = ast.UnaryOp(ast.Not(), element_expr)\n+                break_value = ast.NameConstant(False)\n+            else:\n+                # For any(): if element, set result to True and break\n+                condition = element_expr\n+                break_value = ast.NameConstant(True)\n+            \n+            # Create the if statement that breaks on failure\n+            assign_result = ast.Assign([ast.Name(result_var, ast.Store())], break_value)\n+            break_stmt = ast.Break()\n+            if_body = [assign_result, break_stmt]\n+            \n+            if_stmt = ast.If(condition, if_body, [])\n+            loop_body.append(if_stmt)\n+            \n+            # Create the for loop\n+            for_loop = ast.For(\n+                target=ast.Name(loop_var, ast.Store()),\n+                iter=ast.Name(iterable_var, ast.Load()),\n+                body=loop_body,\n+                orelse=[]\n+            )\n+            self.statements.append(for_loop)\n+            \n+            # Return the result variable\n+            result_name = ast.Name(result_var, ast.Load())\n+            return result_name, result_var\n+        \n+        # Default handling for other function calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -997,10 +1061,21 @@ warn_explicit(\n         new_starred = ast.Starred(res, starred.ctx)\n         return new_starred, \"*\" + expl\n \n+\n     def visit_Call_legacy(self, call):\n         \"\"\"\n         visit `ast.Call nodes on 3.4 and below`\n         \"\"\"\n+        # Special handling for all() and any() built-in functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1 and \n+            not call.keywords and \n+            not call.starargs and \n+            not call.kwargs):\n+            \n+            return self._visit_all_any(call.func.id, call.args[0])\n+        \n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n",
    "variant_8": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2903b8995..fc3fedd8a 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -964,10 +964,71 @@ warn_explicit(\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return res, explanation\n \n+\n     def visit_Call_35(self, call):\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n+        # Special handling for all() and any() calls\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Handle generator expressions and list comprehensions\n+            if isinstance(iterable_arg, (ast.GeneratorExp, ast.ListComp)):\n+                # Create a temporary variable for the result\n+                result_var = self.variable()\n+                \n+                # Get the element and test from the comprehension\n+                if isinstance(iterable_arg, ast.GeneratorExp):\n+                    comp = iterable_arg\n+                else:  # ListComp\n+                    comp = iterable_arg\n+                \n+                element = comp.elt\n+                generators = comp.generators\n+                \n+                # Create the unrolled version\n+                if func_name == 'all':\n+                    # For all(), we want to find the first False\n+                    test_expr = element\n+                    default_result = ast.NameConstant(value=True)\n+                    failure_result = ast.NameConstant(value=False)\n+                else:  # any()\n+                    # For any(), we want to find the first True\n+                    test_expr = element\n+                    default_result = ast.NameConstant(value=False)\n+                    failure_result = ast.NameConstant(value=True)\n+                \n+                # Visit the test expression to get explanation\n+                test_res, test_expl = self.visit(test_expr)\n+                \n+                # Create explanation for the unrolled call\n+                if func_name == 'all':\n+                    expl = \"all(%s)\" % test_expl\n+                else:\n+                    expl = \"any(%s)\" % test_expl\n+                \n+                # For now, fall back to original behavior but with better explanation\n+                new_func, func_expl = self.visit(call.func)\n+                arg_expls = []\n+                new_args = []\n+                for arg in call.args:\n+                    res, arg_expl = self.visit(arg)\n+                    arg_expls.append(arg_expl)\n+                    new_args.append(res)\n+                \n+                expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n+                new_call = ast.Call(new_func, new_args, [])\n+                res = self.assign(new_call)\n+                res_expl = self.explanation_param(self.display(res))\n+                outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+                return res, outer_expl\n+        \n+        # Original implementation for other calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -997,10 +1058,95 @@ warn_explicit(\n         new_starred = ast.Starred(res, starred.ctx)\n         return new_starred, \"*\" + expl\n \n+\n     def visit_Call_legacy(self, call):\n         \"\"\"\n         visit `ast.Call nodes on 3.4 and below`\n         \"\"\"\n+        # Check if this is an all() or any() call that we should unroll\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in ('all', 'any') and \n+            len(call.args) == 1 and \n+            not call.keywords and \n+            not call.starargs and \n+            not call.kwargs):\n+            \n+            # Unroll all() or any() into individual assertions\n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Create a temporary variable to store the iterable\n+            temp_var = self.variable()\n+            \n+            # Visit the iterable argument\n+            iterable_res, iterable_expl = self.visit(iterable_arg)\n+            \n+            # Create assignment of iterable to temp variable\n+            temp_assign = ast.Assign([ast.Name(temp_var, ast.Store())], iterable_res)\n+            self.statements.append(temp_assign)\n+            \n+            # Create a loop variable\n+            loop_var = self.variable()\n+            \n+            # Create the unrolled assertion logic\n+            if func_name == 'all':\n+                # For all(), we want to assert each element is truthy\n+                # If any element is falsy, the assertion should fail with details about that element\n+                inner_test = ast.Name(loop_var, ast.Load())\n+                inner_test_res, inner_test_expl = self.visit(inner_test)\n+                \n+                # Create the assertion\n+                assertion = ast.Assert(inner_test_res, None)\n+                \n+                # Create explanation for the failed element\n+                explanation = self.explanation_param(self.display(inner_test_res))\n+                \n+                # Create the for loop\n+                for_loop = ast.For(\n+                    target=ast.Name(loop_var, ast.Store()),\n+                    iter=ast.Name(temp_var, ast.Load()),\n+                    body=[assertion],\n+                    orelse=[]\n+                )\n+                self.statements.append(for_loop)\n+                \n+                # Return True (all elements passed) with explanation\n+                result_var = self.variable()\n+                result_assign = ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True))\n+                self.statements.append(result_assign)\n+                \n+                res_expl = self.explanation_param(self.display(ast.Name(result_var, ast.Load())))\n+                outer_expl = \"%s\\n{%s = all(%s)\\n}\" % (res_expl, res_expl, iterable_expl)\n+                return ast.Name(result_var, ast.Load()), outer_expl\n+                \n+            else:  # any()\n+                # For any(), we want to check if at least one element is truthy\n+                # We'll create a flag variable and set it to True if we find a truthy element\n+                flag_var = self.variable()\n+                flag_assign = ast.Assign([ast.Name(flag_var, ast.Store())], ast.NameConstant(False))\n+                self.statements.append(flag_assign)\n+                \n+                # Create the loop body that sets flag to True if element is truthy\n+                inner_test = ast.Name(loop_var, ast.Load())\n+                flag_update = ast.If(\n+                    test=inner_test,\n+                    body=[ast.Assign([ast.Name(flag_var, ast.Store())], ast.NameConstant(True))],\n+                    orelse=[]\n+                )\n+                \n+                for_loop = ast.For(\n+                    target=ast.Name(loop_var, ast.Store()),\n+                    iter=ast.Name(temp_var, ast.Load()),\n+                    body=[flag_update],\n+                    orelse=[]\n+                )\n+                self.statements.append(for_loop)\n+                \n+                res_expl = self.explanation_param(self.display(ast.Name(flag_var, ast.Load())))\n+                outer_expl = \"%s\\n{%s = any(%s)\\n}\" % (res_expl, res_expl, iterable_expl)\n+                return ast.Name(flag_var, ast.Load()), outer_expl\n+        \n+        # Original implementation for non-all/any calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n"
  }
}