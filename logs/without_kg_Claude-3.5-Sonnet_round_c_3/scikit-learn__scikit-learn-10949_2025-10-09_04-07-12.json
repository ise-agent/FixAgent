{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/scikit-learn/sklearn/utils/validation.py lines 464-467)": "\ndtype_orig = getattr(array, \"dtype\", None)\nif dtype_orig is not None and not hasattr(dtype_orig, 'kind'):\n    # Handle pandas DataFrame case - preserve the dtype for warning purposes\n    try:\n        # For pandas DataFrames, get the common dtype or object if mixed\n        if hasattr(array, 'dtypes'):  # pandas DataFrame\n            unique_dtypes = array.dtypes.unique()\n            if len(unique_dtypes) == 1:\n                dtype_orig = unique_dtypes[0]\n            else:\n                dtype_orig = np.dtype('object')  # Mixed dtypes default to object\n        else:\n            # not a data type (e.g. a column named dtype attribute)\n            dtype_orig = None\n    except (AttributeError, TypeError):\n        dtype_orig = None\n",
    "Location 2 (/root/hy/projects_3/scikit-learn/sklearn/utils/validation.py lines 576-579)": "\n    if warn_on_dtype and dtype_orig is not None and array.dtype != dtype_orig:\n        # Handle both numpy dtypes and pandas dtypes for consistent messaging\n        orig_dtype_str = str(dtype_orig)\n        if hasattr(dtype_orig, 'name'):\n            orig_dtype_str = dtype_orig.name\n        msg = (\"Data with input dtype %s was converted to %s%s.\"\n               % (orig_dtype_str, array.dtype, context))\n        warnings.warn(msg, DataConversionWarning)\n",
    "Location 3 (/root/hy/projects_3/scikit-learn/sklearn/utils/validation.py lines 510-515)": "\n        dtype_orig = getattr(array, \"dtype\", None)\n        if dtype_orig is not None and not hasattr(dtype_orig, 'kind'):\n            # Handle pandas DataFrame case - preserve the dtype for warning purposes\n            try:\n                # For pandas DataFrames, get the common dtype or object if mixed\n                if hasattr(array, 'dtypes'):  # pandas DataFrame\n                    unique_dtypes = array.dtypes.unique()\n                    if len(unique_dtypes) == 1:\n                        dtype_orig = unique_dtypes[0]\n                    else:\n                        dtype_orig = np.dtype('object')  # Mixed dtypes default to object\n                else:\n                    # not a data type (e.g. a column named dtype attribute)\n                    dtype_orig = None\n            except (AttributeError, TypeError):\n                dtype_orig = None\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/scikit-learn/sklearn/utils/validation.py lines 464-467)": [
      "\ndtype_orig = getattr(array, \"dtype\", None)\nif dtype_orig is not None and not hasattr(dtype_orig, 'kind'):\n    # Handle pandas DataFrame case - preserve the dtype for warning purposes\n    try:\n        # For pandas DataFrames, get the common dtype or object if mixed\n        if hasattr(array, 'dtypes'):  # pandas DataFrame\n            unique_dtypes = array.dtypes.unique()\n            if len(unique_dtypes) == 1:\n                dtype_orig = unique_dtypes[0]\n            else:\n                dtype_orig = np.dtype('object')  # Mixed dtypes default to object\n        else:\n            # not a data type (e.g. a column named dtype attribute)\n            dtype_orig = None\n    except (AttributeError, TypeError):\n        dtype_orig = None\n",
      "\ndtype_orig = getattr(array, \"dtype\", None)\nif dtype_orig is not None and not hasattr(dtype_orig, 'kind'):\n    # Handle pandas DataFrame case - preserve the dtype for warning purposes\n    try:\n        # For pandas DataFrames, get the common dtype or object if mixed\n        if hasattr(array, 'dtypes'):  # pandas DataFrame\n            unique_dtypes = array.dtypes.unique()\n            if len(unique_dtypes) == 1:\n                dtype_orig = unique_dtypes[0]\n            else:\n                dtype_orig = np.dtype('object')  # Mixed dtypes default to object\n        else:\n            # not a data type (e.g. a column named dtype attribute)\n            dtype_orig = None\n    except (AttributeError, TypeError):\n        dtype_orig = None\n",
      "\n    dtype_orig = getattr(array, \"dtype\", None)\n    if dtype_orig is not None and not hasattr(dtype_orig, 'kind'):\n        # Handle pandas DataFrame case - preserve the dtype for warning purposes\n        try:\n            # For pandas DataFrames, get the common dtype or object if mixed\n            if hasattr(array, 'dtypes'):  # pandas DataFrame\n                unique_dtypes = array.dtypes.unique()\n                if len(unique_dtypes) == 1:\n                    dtype_orig = unique_dtypes[0]\n                else:\n                    dtype_orig = np.dtype('object')  # Mixed dtypes default to object\n            else:\n                # not a data type (e.g. a column named dtype attribute)\n                dtype_orig = None\n        except (AttributeError, TypeError):\n            dtype_orig = None\n",
      "\ndtype_orig = getattr(array, \"dtype\", None)\nif dtype_orig is not None and not hasattr(dtype_orig, 'kind'):\n    # Handle pandas DataFrame case - preserve the dtype for warning purposes\n    try:\n        # For pandas DataFrames, get the common dtype or object if mixed\n        if hasattr(array, 'dtypes'):  # pandas DataFrame\n            unique_dtypes = array.dtypes.unique()\n            if len(unique_dtypes) == 1:\n                dtype_orig = unique_dtypes[0]\n            else:\n                dtype_orig = np.dtype('object')  # Mixed dtypes default to object\n        else:\n            # not a data type (e.g. a column named dtype attribute)\n            dtype_orig = None\n    except (AttributeError, TypeError):\n        dtype_orig = None\n",
      "\ndtype_orig = getattr(array, \"dtype\", None)\nif dtype_orig is not None and not hasattr(dtype_orig, 'kind'):\n    # Handle pandas DataFrame case - preserve the dtype for warning purposes\n    try:\n        # For pandas DataFrames, get the common dtype or object if mixed\n        if hasattr(array, 'dtypes'):  # pandas DataFrame\n            unique_dtypes = array.dtypes.unique()\n            if len(unique_dtypes) == 1:\n                dtype_orig = unique_dtypes[0]\n            else:\n                dtype_orig = np.dtype('object')  # Mixed dtypes default to object\n        else:\n            # not a data type (e.g. a column named dtype attribute)\n            dtype_orig = None\n    except (AttributeError, TypeError):\n        dtype_orig = None\n",
      "\ndtype_orig = getattr(array, \"dtype\", None)\nif dtype_orig is not None and not hasattr(dtype_orig, 'kind'):\n    # Handle pandas DataFrame case - preserve the dtype for warning purposes\n    try:\n        # For pandas DataFrames, get the common dtype or object if mixed\n        if hasattr(array, 'dtypes'):  # pandas DataFrame\n            unique_dtypes = array.dtypes.unique()\n            if len(unique_dtypes) == 1:\n                dtype_orig = unique_dtypes[0]\n            else:\n                dtype_orig = np.dtype('object')  # Mixed dtypes default to object\n        else:\n            # not a data type (e.g. a column named dtype attribute)\n            dtype_orig = None\n    except (AttributeError, TypeError):\n        dtype_orig = None\n",
      "\ndtype_orig = getattr(array, \"dtype\", None)\nif dtype_orig is not None and not hasattr(dtype_orig, 'kind'):\n    # Handle pandas DataFrame case - preserve the dtype for warning purposes\n    try:\n        # For pandas DataFrames, get the common dtype or object if mixed\n        if hasattr(array, 'dtypes'):  # pandas DataFrame\n            unique_dtypes = array.dtypes.unique()\n            if len(unique_dtypes) == 1:\n                dtype_orig = unique_dtypes[0]\n            else:\n                dtype_orig = np.dtype('object')  # Mixed dtypes default to object\n        else:\n            # not a data type (e.g. a column named dtype attribute)\n            dtype_orig = None\n    except (AttributeError, TypeError):\n        dtype_orig = None\n",
      "\ndtype_orig = getattr(array, \"dtype\", None)\nif dtype_orig is not None and not hasattr(dtype_orig, 'kind'):\n    # Handle pandas DataFrame case - preserve the dtype for warning purposes\n    try:\n        # For pandas DataFrames, get the common dtype or object if mixed\n        if hasattr(array, 'dtypes'):  # pandas DataFrame\n            unique_dtypes = array.dtypes.unique()\n            if len(unique_dtypes) == 1:\n                dtype_orig = unique_dtypes[0]\n            else:\n                dtype_orig = np.dtype('object')  # Mixed dtypes default to object\n        else:\n            # not a data type (e.g. a column named dtype attribute)\n            dtype_orig = None\n    except (AttributeError, TypeError):\n        dtype_orig = None\n"
    ],
    "Location 2 (/root/hy/projects_3/scikit-learn/sklearn/utils/validation.py lines 576-579)": [
      "\n    if warn_on_dtype and dtype_orig is not None and array.dtype != dtype_orig:\n        # Handle both numpy dtypes and pandas dtypes for consistent messaging\n        orig_dtype_str = str(dtype_orig)\n        if hasattr(dtype_orig, 'name'):\n            orig_dtype_str = dtype_orig.name\n        msg = (\"Data with input dtype %s was converted to %s%s.\"\n               % (orig_dtype_str, array.dtype, context))\n        warnings.warn(msg, DataConversionWarning)\n",
      "\n    if warn_on_dtype and dtype_orig is not None and array.dtype != dtype_orig:\n        # Handle both numpy dtypes and pandas dtypes for consistent messaging\n        orig_dtype_str = str(dtype_orig)\n        if hasattr(dtype_orig, 'name'):\n            orig_dtype_str = dtype_orig.name\n        msg = (\"Data with input dtype %s was converted to %s%s.\"\n               % (orig_dtype_str, array.dtype, context))\n        warnings.warn(msg, DataConversionWarning)\n",
      "\nif warn_on_dtype and dtype_orig is not None and array.dtype != dtype_orig:\n    # Handle both numpy dtypes and pandas dtypes for consistent messaging\n    orig_dtype_str = str(dtype_orig)\n    if hasattr(dtype_orig, 'name'):\n        orig_dtype_str = dtype_orig.name\n    msg = (\"Data with input dtype %s was converted to %s%s.\"\n           % (orig_dtype_str, array.dtype, context))\n    warnings.warn(msg, DataConversionWarning)\n",
      "\n    if warn_on_dtype and dtype_orig is not None and array.dtype != dtype_orig:\n        # Handle both numpy dtypes and pandas dtypes for consistent messaging\n        orig_dtype_str = str(dtype_orig)\n        if hasattr(dtype_orig, 'name'):\n            orig_dtype_str = dtype_orig.name\n        msg = (\"Data with input dtype %s was converted to %s%s.\"\n               % (orig_dtype_str, array.dtype, context))\n        warnings.warn(msg, DataConversionWarning)\n",
      "\n    if warn_on_dtype and dtype_orig is not None and array.dtype != dtype_orig:\n        # Handle both numpy dtypes and pandas dtypes for consistent messaging\n        orig_dtype_str = str(dtype_orig)\n        if hasattr(dtype_orig, 'name'):\n            orig_dtype_str = dtype_orig.name\n        msg = (\"Data with input dtype %s was converted to %s%s.\"\n               % (orig_dtype_str, array.dtype, context))\n        warnings.warn(msg, DataConversionWarning)\n",
      "\n    if warn_on_dtype and dtype_orig is not None and array.dtype != dtype_orig:\n        # Handle both numpy dtypes and pandas dtypes for consistent messaging\n        orig_dtype_str = str(dtype_orig)\n        if hasattr(dtype_orig, 'name'):\n            orig_dtype_str = dtype_orig.name\n        msg = (\"Data with input dtype %s was converted to %s%s.\"\n               % (orig_dtype_str, array.dtype, context))\n        warnings.warn(msg, DataConversionWarning)\n",
      "\n    if warn_on_dtype and dtype_orig is not None and array.dtype != dtype_orig:\n        # Handle both numpy dtypes and pandas dtypes for consistent messaging\n        orig_dtype_str = str(dtype_orig)\n        if hasattr(dtype_orig, 'name'):\n            orig_dtype_str = dtype_orig.name\n        msg = (\"Data with input dtype %s was converted to %s%s.\"\n               % (orig_dtype_str, array.dtype, context))\n        warnings.warn(msg, DataConversionWarning)\n",
      "\nif warn_on_dtype and dtype_orig is not None and array.dtype != dtype_orig:\n    # Handle both numpy dtypes and pandas dtypes for consistent messaging\n    orig_dtype_str = str(dtype_orig)\n    if hasattr(dtype_orig, 'name'):\n        orig_dtype_str = dtype_orig.name\n    msg = (\"Data with input dtype %s was converted to %s%s.\"\n           % (orig_dtype_str, array.dtype, context))\n    warnings.warn(msg, DataConversionWarning)\n"
    ],
    "Location 3 (/root/hy/projects_3/scikit-learn/sklearn/utils/validation.py lines 510-515)": [
      "\n        dtype_orig = getattr(array, \"dtype\", None)\n        if dtype_orig is not None and not hasattr(dtype_orig, 'kind'):\n            # Handle pandas DataFrame case - preserve the dtype for warning purposes\n            try:\n                # For pandas DataFrames, get the common dtype or object if mixed\n                if hasattr(array, 'dtypes'):  # pandas DataFrame\n                    unique_dtypes = array.dtypes.unique()\n                    if len(unique_dtypes) == 1:\n                        dtype_orig = unique_dtypes[0]\n                    else:\n                        dtype_orig = np.dtype('object')  # Mixed dtypes default to object\n                else:\n                    # not a data type (e.g. a column named dtype attribute)\n                    dtype_orig = None\n            except (AttributeError, TypeError):\n                dtype_orig = None\n",
      "\n        dtype_orig = getattr(array, \"dtype\", None)\n        if dtype_orig is not None and not hasattr(dtype_orig, 'kind'):\n            # Handle pandas DataFrame case - preserve the dtype for warning purposes\n            try:\n                # For pandas DataFrames, get the common dtype or object if mixed\n                if hasattr(array, 'dtypes'):  # pandas DataFrame\n                    unique_dtypes = array.dtypes.unique()\n                    if len(unique_dtypes) == 1:\n                        dtype_orig = unique_dtypes[0]\n                    else:\n                        dtype_orig = np.dtype('object')  # Mixed dtypes default to object\n                else:\n                    # not a data type (e.g. a column named dtype attribute)\n                    dtype_orig = None\n            except (AttributeError, TypeError):\n                dtype_orig = None\n",
      "\n        dtype_orig = getattr(array, \"dtype\", None)\n        if dtype_orig is not None and not hasattr(dtype_orig, 'kind'):\n            # Handle pandas DataFrame case - preserve the dtype for warning purposes\n            try:\n                # For pandas DataFrames, get the common dtype or object if mixed\n                if hasattr(array, 'dtypes'):  # pandas DataFrame\n                    unique_dtypes = array.dtypes.unique()\n                    if len(unique_dtypes) == 1:\n                        dtype_orig = unique_dtypes[0]\n                    else:\n                        dtype_orig = np.dtype('object')  # Mixed dtypes default to object\n                else:\n                    # not a data type (e.g. a column named dtype attribute)\n                    dtype_orig = None\n            except (AttributeError, TypeError):\n                dtype_orig = None\n",
      "\n        dtype_orig = getattr(array, \"dtype\", None)\n        if dtype_orig is not None and not hasattr(dtype_orig, 'kind'):\n            # Handle pandas DataFrame case - preserve the dtype for warning purposes\n            try:\n                # For pandas DataFrames, get the common dtype or object if mixed\n                if hasattr(array, 'dtypes'):  # pandas DataFrame\n                    unique_dtypes = array.dtypes.unique()\n                    if len(unique_dtypes) == 1:\n                        dtype_orig = unique_dtypes[0]\n                    else:\n                        dtype_orig = np.dtype('object')  # Mixed dtypes default to object\n                else:\n                    # not a data type (e.g. a column named dtype attribute)\n                    dtype_orig = None\n            except (AttributeError, TypeError):\n                dtype_orig = None\n",
      "\n        dtype_orig = getattr(array, \"dtype\", None)\n        if dtype_orig is not None and not hasattr(dtype_orig, 'kind'):\n            # Handle pandas DataFrame case - preserve the dtype for warning purposes\n            try:\n                # For pandas DataFrames, get the common dtype or object if mixed\n                if hasattr(array, 'dtypes'):  # pandas DataFrame\n                    unique_dtypes = array.dtypes.unique()\n                    if len(unique_dtypes) == 1:\n                        dtype_orig = unique_dtypes[0]\n                    else:\n                        dtype_orig = np.dtype('object')  # Mixed dtypes default to object\n                else:\n                    # not a data type (e.g. a column named dtype attribute)\n                    dtype_orig = None\n            except (AttributeError, TypeError):\n                dtype_orig = None\n",
      "\n        dtype_orig = getattr(array, \"dtype\", None)\n        if dtype_orig is not None and not hasattr(dtype_orig, 'kind'):\n            # Handle pandas DataFrame case - preserve the dtype for warning purposes\n            try:\n                # For pandas DataFrames, get the common dtype or object if mixed\n                if hasattr(array, 'dtypes'):  # pandas DataFrame\n                    unique_dtypes = array.dtypes.unique()\n                    if len(unique_dtypes) == 1:\n                        dtype_orig = unique_dtypes[0]\n                    else:\n                        dtype_orig = np.dtype('object')  # Mixed dtypes default to object\n                else:\n                    # not a data type (e.g. a column named dtype attribute)\n                    dtype_orig = None\n            except (AttributeError, TypeError):\n                dtype_orig = None\n",
      "\n        dtype_orig = getattr(array, \"dtype\", None)\n        if dtype_orig is not None and not hasattr(dtype_orig, 'kind'):\n            # Handle pandas DataFrame case - preserve the dtype for warning purposes\n            try:\n                # For pandas DataFrames, get the common dtype or object if mixed\n                if hasattr(array, 'dtypes'):  # pandas DataFrame\n                    unique_dtypes = array.dtypes.unique()\n                    if len(unique_dtypes) == 1:\n                        dtype_orig = unique_dtypes[0]\n                    else:\n                        dtype_orig = np.dtype('object')  # Mixed dtypes default to object\n                else:\n                    # not a data type (e.g. a column named dtype attribute)\n                    dtype_orig = None\n            except (AttributeError, TypeError):\n                dtype_orig = None\n",
      "\n        dtype_orig = getattr(array, \"dtype\", None)\n        if dtype_orig is not None and not hasattr(dtype_orig, 'kind'):\n            # Handle pandas DataFrame case - preserve the dtype for warning purposes\n            try:\n                # For pandas DataFrames, get the common dtype or object if mixed\n                if hasattr(array, 'dtypes'):  # pandas DataFrame\n                    unique_dtypes = array.dtypes.unique()\n                    if len(unique_dtypes) == 1:\n                        dtype_orig = unique_dtypes[0]\n                    else:\n                        dtype_orig = np.dtype('object')  # Mixed dtypes default to object\n                else:\n                    # not a data type (e.g. a column named dtype attribute)\n                    dtype_orig = None\n            except (AttributeError, TypeError):\n                dtype_orig = None\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sklearn/utils/validation.py b/sklearn/utils/validation.py\nindex fe1f7236e..7121cb583 100644\n--- a/sklearn/utils/validation.py\n+++ b/sklearn/utils/validation.py\n@@ -461,10 +461,23 @@ def check_array(array, accept_sparse=False, accept_large_sparse=True,\n     # store whether originally we wanted numeric dtype\n     dtype_numeric = isinstance(dtype, six.string_types) and dtype == \"numeric\"\n \n+\n     dtype_orig = getattr(array, \"dtype\", None)\n-    if not hasattr(dtype_orig, 'kind'):\n-        # not a data type (e.g. a column named dtype in a pandas DataFrame)\n-        dtype_orig = None\n+    if dtype_orig is not None and not hasattr(dtype_orig, 'kind'):\n+        # Handle pandas DataFrame case - preserve the dtype for warning purposes\n+        try:\n+            # For pandas DataFrames, get the common dtype or object if mixed\n+            if hasattr(array, 'dtypes'):  # pandas DataFrame\n+                unique_dtypes = array.dtypes.unique()\n+                if len(unique_dtypes) == 1:\n+                    dtype_orig = unique_dtypes[0]\n+                else:\n+                    dtype_orig = np.dtype('object')  # Mixed dtypes default to object\n+            else:\n+                # not a data type (e.g. a column named dtype attribute)\n+                dtype_orig = None\n+        except (AttributeError, TypeError):\n+            dtype_orig = None\n \n     if dtype_numeric:\n         if dtype_orig is not None and dtype_orig.kind == \"O\":\n@@ -507,6 +520,7 @@ def check_array(array, accept_sparse=False, accept_large_sparse=True,\n         # dtype to the function converts complex to real dtype,\n         # thereby passing the test made in the lines following the scope\n         # of warnings context manager.\n+\n         with warnings.catch_warnings():\n             try:\n                 warnings.simplefilter('error', ComplexWarning)\n@@ -573,9 +587,14 @@ def check_array(array, accept_sparse=False, accept_large_sparse=True,\n                              % (n_features, shape_repr, ensure_min_features,\n                                 context))\n \n+\n     if warn_on_dtype and dtype_orig is not None and array.dtype != dtype_orig:\n+        # Handle both numpy dtypes and pandas dtypes for consistent messaging\n+        orig_dtype_str = str(dtype_orig)\n+        if hasattr(dtype_orig, 'name'):\n+            orig_dtype_str = dtype_orig.name\n         msg = (\"Data with input dtype %s was converted to %s%s.\"\n-               % (dtype_orig, array.dtype, context))\n+               % (orig_dtype_str, array.dtype, context))\n         warnings.warn(msg, DataConversionWarning)\n \n     if copy and np.may_share_memory(array, array_orig):\n",
    "variant_0": "diff --git a/sklearn/utils/validation.py b/sklearn/utils/validation.py\nindex fe1f7236e..c39a7fabc 100644\n--- a/sklearn/utils/validation.py\n+++ b/sklearn/utils/validation.py\n@@ -461,9 +461,22 @@ def check_array(array, accept_sparse=False, accept_large_sparse=True,\n     # store whether originally we wanted numeric dtype\n     dtype_numeric = isinstance(dtype, six.string_types) and dtype == \"numeric\"\n \n-    dtype_orig = getattr(array, \"dtype\", None)\n-    if not hasattr(dtype_orig, 'kind'):\n-        # not a data type (e.g. a column named dtype in a pandas DataFrame)\n+\n+dtype_orig = getattr(array, \"dtype\", None)\n+if dtype_orig is not None and not hasattr(dtype_orig, 'kind'):\n+    # Handle pandas DataFrame case - preserve the dtype for warning purposes\n+    try:\n+        # For pandas DataFrames, get the common dtype or object if mixed\n+        if hasattr(array, 'dtypes'):  # pandas DataFrame\n+            unique_dtypes = array.dtypes.unique()\n+            if len(unique_dtypes) == 1:\n+                dtype_orig = unique_dtypes[0]\n+            else:\n+                dtype_orig = np.dtype('object')  # Mixed dtypes default to object\n+        else:\n+            # not a data type (e.g. a column named dtype attribute)\n+            dtype_orig = None\n+    except (AttributeError, TypeError):\n         dtype_orig = None\n \n     if dtype_numeric:\n@@ -507,12 +520,23 @@ def check_array(array, accept_sparse=False, accept_large_sparse=True,\n         # dtype to the function converts complex to real dtype,\n         # thereby passing the test made in the lines following the scope\n         # of warnings context manager.\n-        with warnings.catch_warnings():\n+\n+        dtype_orig = getattr(array, \"dtype\", None)\n+        if dtype_orig is not None and not hasattr(dtype_orig, 'kind'):\n+            # Handle pandas DataFrame case - preserve the dtype for warning purposes\n             try:\n-                warnings.simplefilter('error', ComplexWarning)\n-                array = np.asarray(array, dtype=dtype, order=order)\n-            except ComplexWarning:\n-                raise ValueError(\"Complex data not supported\\n\"\n+                # For pandas DataFrames, get the common dtype or object if mixed\n+                if hasattr(array, 'dtypes'):  # pandas DataFrame\n+                    unique_dtypes = array.dtypes.unique()\n+                    if len(unique_dtypes) == 1:\n+                        dtype_orig = unique_dtypes[0]\n+                    else:\n+                        dtype_orig = np.dtype('object')  # Mixed dtypes default to object\n+                else:\n+                    # not a data type (e.g. a column named dtype attribute)\n+                    dtype_orig = None\n+            except (AttributeError, TypeError):\n+                dtype_orig = None\n                                  \"{}\\n\".format(array))\n \n         # It is possible that the np.array(..) gave no warning. This happens\n@@ -573,9 +597,14 @@ def check_array(array, accept_sparse=False, accept_large_sparse=True,\n                              % (n_features, shape_repr, ensure_min_features,\n                                 context))\n \n+\n     if warn_on_dtype and dtype_orig is not None and array.dtype != dtype_orig:\n+        # Handle both numpy dtypes and pandas dtypes for consistent messaging\n+        orig_dtype_str = str(dtype_orig)\n+        if hasattr(dtype_orig, 'name'):\n+            orig_dtype_str = dtype_orig.name\n         msg = (\"Data with input dtype %s was converted to %s%s.\"\n-               % (dtype_orig, array.dtype, context))\n+               % (orig_dtype_str, array.dtype, context))\n         warnings.warn(msg, DataConversionWarning)\n \n     if copy and np.may_share_memory(array, array_orig):\n",
    "variant_1": "diff --git a/sklearn/utils/validation.py b/sklearn/utils/validation.py\nindex fe1f7236e..c39a7fabc 100644\n--- a/sklearn/utils/validation.py\n+++ b/sklearn/utils/validation.py\n@@ -461,9 +461,22 @@ def check_array(array, accept_sparse=False, accept_large_sparse=True,\n     # store whether originally we wanted numeric dtype\n     dtype_numeric = isinstance(dtype, six.string_types) and dtype == \"numeric\"\n \n-    dtype_orig = getattr(array, \"dtype\", None)\n-    if not hasattr(dtype_orig, 'kind'):\n-        # not a data type (e.g. a column named dtype in a pandas DataFrame)\n+\n+dtype_orig = getattr(array, \"dtype\", None)\n+if dtype_orig is not None and not hasattr(dtype_orig, 'kind'):\n+    # Handle pandas DataFrame case - preserve the dtype for warning purposes\n+    try:\n+        # For pandas DataFrames, get the common dtype or object if mixed\n+        if hasattr(array, 'dtypes'):  # pandas DataFrame\n+            unique_dtypes = array.dtypes.unique()\n+            if len(unique_dtypes) == 1:\n+                dtype_orig = unique_dtypes[0]\n+            else:\n+                dtype_orig = np.dtype('object')  # Mixed dtypes default to object\n+        else:\n+            # not a data type (e.g. a column named dtype attribute)\n+            dtype_orig = None\n+    except (AttributeError, TypeError):\n         dtype_orig = None\n \n     if dtype_numeric:\n@@ -507,12 +520,23 @@ def check_array(array, accept_sparse=False, accept_large_sparse=True,\n         # dtype to the function converts complex to real dtype,\n         # thereby passing the test made in the lines following the scope\n         # of warnings context manager.\n-        with warnings.catch_warnings():\n+\n+        dtype_orig = getattr(array, \"dtype\", None)\n+        if dtype_orig is not None and not hasattr(dtype_orig, 'kind'):\n+            # Handle pandas DataFrame case - preserve the dtype for warning purposes\n             try:\n-                warnings.simplefilter('error', ComplexWarning)\n-                array = np.asarray(array, dtype=dtype, order=order)\n-            except ComplexWarning:\n-                raise ValueError(\"Complex data not supported\\n\"\n+                # For pandas DataFrames, get the common dtype or object if mixed\n+                if hasattr(array, 'dtypes'):  # pandas DataFrame\n+                    unique_dtypes = array.dtypes.unique()\n+                    if len(unique_dtypes) == 1:\n+                        dtype_orig = unique_dtypes[0]\n+                    else:\n+                        dtype_orig = np.dtype('object')  # Mixed dtypes default to object\n+                else:\n+                    # not a data type (e.g. a column named dtype attribute)\n+                    dtype_orig = None\n+            except (AttributeError, TypeError):\n+                dtype_orig = None\n                                  \"{}\\n\".format(array))\n \n         # It is possible that the np.array(..) gave no warning. This happens\n@@ -573,9 +597,14 @@ def check_array(array, accept_sparse=False, accept_large_sparse=True,\n                              % (n_features, shape_repr, ensure_min_features,\n                                 context))\n \n+\n     if warn_on_dtype and dtype_orig is not None and array.dtype != dtype_orig:\n+        # Handle both numpy dtypes and pandas dtypes for consistent messaging\n+        orig_dtype_str = str(dtype_orig)\n+        if hasattr(dtype_orig, 'name'):\n+            orig_dtype_str = dtype_orig.name\n         msg = (\"Data with input dtype %s was converted to %s%s.\"\n-               % (dtype_orig, array.dtype, context))\n+               % (orig_dtype_str, array.dtype, context))\n         warnings.warn(msg, DataConversionWarning)\n \n     if copy and np.may_share_memory(array, array_orig):\n",
    "variant_2": "diff --git a/sklearn/utils/validation.py b/sklearn/utils/validation.py\nindex fe1f7236e..c39a7fabc 100644\n--- a/sklearn/utils/validation.py\n+++ b/sklearn/utils/validation.py\n@@ -461,9 +461,22 @@ def check_array(array, accept_sparse=False, accept_large_sparse=True,\n     # store whether originally we wanted numeric dtype\n     dtype_numeric = isinstance(dtype, six.string_types) and dtype == \"numeric\"\n \n-    dtype_orig = getattr(array, \"dtype\", None)\n-    if not hasattr(dtype_orig, 'kind'):\n-        # not a data type (e.g. a column named dtype in a pandas DataFrame)\n+\n+dtype_orig = getattr(array, \"dtype\", None)\n+if dtype_orig is not None and not hasattr(dtype_orig, 'kind'):\n+    # Handle pandas DataFrame case - preserve the dtype for warning purposes\n+    try:\n+        # For pandas DataFrames, get the common dtype or object if mixed\n+        if hasattr(array, 'dtypes'):  # pandas DataFrame\n+            unique_dtypes = array.dtypes.unique()\n+            if len(unique_dtypes) == 1:\n+                dtype_orig = unique_dtypes[0]\n+            else:\n+                dtype_orig = np.dtype('object')  # Mixed dtypes default to object\n+        else:\n+            # not a data type (e.g. a column named dtype attribute)\n+            dtype_orig = None\n+    except (AttributeError, TypeError):\n         dtype_orig = None\n \n     if dtype_numeric:\n@@ -507,12 +520,23 @@ def check_array(array, accept_sparse=False, accept_large_sparse=True,\n         # dtype to the function converts complex to real dtype,\n         # thereby passing the test made in the lines following the scope\n         # of warnings context manager.\n-        with warnings.catch_warnings():\n+\n+        dtype_orig = getattr(array, \"dtype\", None)\n+        if dtype_orig is not None and not hasattr(dtype_orig, 'kind'):\n+            # Handle pandas DataFrame case - preserve the dtype for warning purposes\n             try:\n-                warnings.simplefilter('error', ComplexWarning)\n-                array = np.asarray(array, dtype=dtype, order=order)\n-            except ComplexWarning:\n-                raise ValueError(\"Complex data not supported\\n\"\n+                # For pandas DataFrames, get the common dtype or object if mixed\n+                if hasattr(array, 'dtypes'):  # pandas DataFrame\n+                    unique_dtypes = array.dtypes.unique()\n+                    if len(unique_dtypes) == 1:\n+                        dtype_orig = unique_dtypes[0]\n+                    else:\n+                        dtype_orig = np.dtype('object')  # Mixed dtypes default to object\n+                else:\n+                    # not a data type (e.g. a column named dtype attribute)\n+                    dtype_orig = None\n+            except (AttributeError, TypeError):\n+                dtype_orig = None\n                                  \"{}\\n\".format(array))\n \n         # It is possible that the np.array(..) gave no warning. This happens\n@@ -573,9 +597,14 @@ def check_array(array, accept_sparse=False, accept_large_sparse=True,\n                              % (n_features, shape_repr, ensure_min_features,\n                                 context))\n \n+\n     if warn_on_dtype and dtype_orig is not None and array.dtype != dtype_orig:\n+        # Handle both numpy dtypes and pandas dtypes for consistent messaging\n+        orig_dtype_str = str(dtype_orig)\n+        if hasattr(dtype_orig, 'name'):\n+            orig_dtype_str = dtype_orig.name\n         msg = (\"Data with input dtype %s was converted to %s%s.\"\n-               % (dtype_orig, array.dtype, context))\n+               % (orig_dtype_str, array.dtype, context))\n         warnings.warn(msg, DataConversionWarning)\n \n     if copy and np.may_share_memory(array, array_orig):\n",
    "variant_3": "diff --git a/sklearn/utils/validation.py b/sklearn/utils/validation.py\nindex fe1f7236e..3238fdb13 100644\n--- a/sklearn/utils/validation.py\n+++ b/sklearn/utils/validation.py\n@@ -461,10 +461,23 @@ def check_array(array, accept_sparse=False, accept_large_sparse=True,\n     # store whether originally we wanted numeric dtype\n     dtype_numeric = isinstance(dtype, six.string_types) and dtype == \"numeric\"\n \n+\n     dtype_orig = getattr(array, \"dtype\", None)\n-    if not hasattr(dtype_orig, 'kind'):\n-        # not a data type (e.g. a column named dtype in a pandas DataFrame)\n-        dtype_orig = None\n+    if dtype_orig is not None and not hasattr(dtype_orig, 'kind'):\n+        # Handle pandas DataFrame case - preserve the dtype for warning purposes\n+        try:\n+            # For pandas DataFrames, get the common dtype or object if mixed\n+            if hasattr(array, 'dtypes'):  # pandas DataFrame\n+                unique_dtypes = array.dtypes.unique()\n+                if len(unique_dtypes) == 1:\n+                    dtype_orig = unique_dtypes[0]\n+                else:\n+                    dtype_orig = np.dtype('object')  # Mixed dtypes default to object\n+            else:\n+                # not a data type (e.g. a column named dtype attribute)\n+                dtype_orig = None\n+        except (AttributeError, TypeError):\n+            dtype_orig = None\n \n     if dtype_numeric:\n         if dtype_orig is not None and dtype_orig.kind == \"O\":\n@@ -507,12 +520,23 @@ def check_array(array, accept_sparse=False, accept_large_sparse=True,\n         # dtype to the function converts complex to real dtype,\n         # thereby passing the test made in the lines following the scope\n         # of warnings context manager.\n-        with warnings.catch_warnings():\n+\n+        dtype_orig = getattr(array, \"dtype\", None)\n+        if dtype_orig is not None and not hasattr(dtype_orig, 'kind'):\n+            # Handle pandas DataFrame case - preserve the dtype for warning purposes\n             try:\n-                warnings.simplefilter('error', ComplexWarning)\n-                array = np.asarray(array, dtype=dtype, order=order)\n-            except ComplexWarning:\n-                raise ValueError(\"Complex data not supported\\n\"\n+                # For pandas DataFrames, get the common dtype or object if mixed\n+                if hasattr(array, 'dtypes'):  # pandas DataFrame\n+                    unique_dtypes = array.dtypes.unique()\n+                    if len(unique_dtypes) == 1:\n+                        dtype_orig = unique_dtypes[0]\n+                    else:\n+                        dtype_orig = np.dtype('object')  # Mixed dtypes default to object\n+                else:\n+                    # not a data type (e.g. a column named dtype attribute)\n+                    dtype_orig = None\n+            except (AttributeError, TypeError):\n+                dtype_orig = None\n                                  \"{}\\n\".format(array))\n \n         # It is possible that the np.array(..) gave no warning. This happens\n@@ -573,10 +597,15 @@ def check_array(array, accept_sparse=False, accept_large_sparse=True,\n                              % (n_features, shape_repr, ensure_min_features,\n                                 context))\n \n-    if warn_on_dtype and dtype_orig is not None and array.dtype != dtype_orig:\n-        msg = (\"Data with input dtype %s was converted to %s%s.\"\n-               % (dtype_orig, array.dtype, context))\n-        warnings.warn(msg, DataConversionWarning)\n+\n+if warn_on_dtype and dtype_orig is not None and array.dtype != dtype_orig:\n+    # Handle both numpy dtypes and pandas dtypes for consistent messaging\n+    orig_dtype_str = str(dtype_orig)\n+    if hasattr(dtype_orig, 'name'):\n+        orig_dtype_str = dtype_orig.name\n+    msg = (\"Data with input dtype %s was converted to %s%s.\"\n+           % (orig_dtype_str, array.dtype, context))\n+    warnings.warn(msg, DataConversionWarning)\n \n     if copy and np.may_share_memory(array, array_orig):\n         array = np.array(array, dtype=dtype, order=order)\n",
    "variant_4": "diff --git a/sklearn/utils/validation.py b/sklearn/utils/validation.py\nindex fe1f7236e..c39a7fabc 100644\n--- a/sklearn/utils/validation.py\n+++ b/sklearn/utils/validation.py\n@@ -461,9 +461,22 @@ def check_array(array, accept_sparse=False, accept_large_sparse=True,\n     # store whether originally we wanted numeric dtype\n     dtype_numeric = isinstance(dtype, six.string_types) and dtype == \"numeric\"\n \n-    dtype_orig = getattr(array, \"dtype\", None)\n-    if not hasattr(dtype_orig, 'kind'):\n-        # not a data type (e.g. a column named dtype in a pandas DataFrame)\n+\n+dtype_orig = getattr(array, \"dtype\", None)\n+if dtype_orig is not None and not hasattr(dtype_orig, 'kind'):\n+    # Handle pandas DataFrame case - preserve the dtype for warning purposes\n+    try:\n+        # For pandas DataFrames, get the common dtype or object if mixed\n+        if hasattr(array, 'dtypes'):  # pandas DataFrame\n+            unique_dtypes = array.dtypes.unique()\n+            if len(unique_dtypes) == 1:\n+                dtype_orig = unique_dtypes[0]\n+            else:\n+                dtype_orig = np.dtype('object')  # Mixed dtypes default to object\n+        else:\n+            # not a data type (e.g. a column named dtype attribute)\n+            dtype_orig = None\n+    except (AttributeError, TypeError):\n         dtype_orig = None\n \n     if dtype_numeric:\n@@ -507,12 +520,23 @@ def check_array(array, accept_sparse=False, accept_large_sparse=True,\n         # dtype to the function converts complex to real dtype,\n         # thereby passing the test made in the lines following the scope\n         # of warnings context manager.\n-        with warnings.catch_warnings():\n+\n+        dtype_orig = getattr(array, \"dtype\", None)\n+        if dtype_orig is not None and not hasattr(dtype_orig, 'kind'):\n+            # Handle pandas DataFrame case - preserve the dtype for warning purposes\n             try:\n-                warnings.simplefilter('error', ComplexWarning)\n-                array = np.asarray(array, dtype=dtype, order=order)\n-            except ComplexWarning:\n-                raise ValueError(\"Complex data not supported\\n\"\n+                # For pandas DataFrames, get the common dtype or object if mixed\n+                if hasattr(array, 'dtypes'):  # pandas DataFrame\n+                    unique_dtypes = array.dtypes.unique()\n+                    if len(unique_dtypes) == 1:\n+                        dtype_orig = unique_dtypes[0]\n+                    else:\n+                        dtype_orig = np.dtype('object')  # Mixed dtypes default to object\n+                else:\n+                    # not a data type (e.g. a column named dtype attribute)\n+                    dtype_orig = None\n+            except (AttributeError, TypeError):\n+                dtype_orig = None\n                                  \"{}\\n\".format(array))\n \n         # It is possible that the np.array(..) gave no warning. This happens\n@@ -573,9 +597,14 @@ def check_array(array, accept_sparse=False, accept_large_sparse=True,\n                              % (n_features, shape_repr, ensure_min_features,\n                                 context))\n \n+\n     if warn_on_dtype and dtype_orig is not None and array.dtype != dtype_orig:\n+        # Handle both numpy dtypes and pandas dtypes for consistent messaging\n+        orig_dtype_str = str(dtype_orig)\n+        if hasattr(dtype_orig, 'name'):\n+            orig_dtype_str = dtype_orig.name\n         msg = (\"Data with input dtype %s was converted to %s%s.\"\n-               % (dtype_orig, array.dtype, context))\n+               % (orig_dtype_str, array.dtype, context))\n         warnings.warn(msg, DataConversionWarning)\n \n     if copy and np.may_share_memory(array, array_orig):\n",
    "variant_5": "diff --git a/sklearn/utils/validation.py b/sklearn/utils/validation.py\nindex fe1f7236e..c39a7fabc 100644\n--- a/sklearn/utils/validation.py\n+++ b/sklearn/utils/validation.py\n@@ -461,9 +461,22 @@ def check_array(array, accept_sparse=False, accept_large_sparse=True,\n     # store whether originally we wanted numeric dtype\n     dtype_numeric = isinstance(dtype, six.string_types) and dtype == \"numeric\"\n \n-    dtype_orig = getattr(array, \"dtype\", None)\n-    if not hasattr(dtype_orig, 'kind'):\n-        # not a data type (e.g. a column named dtype in a pandas DataFrame)\n+\n+dtype_orig = getattr(array, \"dtype\", None)\n+if dtype_orig is not None and not hasattr(dtype_orig, 'kind'):\n+    # Handle pandas DataFrame case - preserve the dtype for warning purposes\n+    try:\n+        # For pandas DataFrames, get the common dtype or object if mixed\n+        if hasattr(array, 'dtypes'):  # pandas DataFrame\n+            unique_dtypes = array.dtypes.unique()\n+            if len(unique_dtypes) == 1:\n+                dtype_orig = unique_dtypes[0]\n+            else:\n+                dtype_orig = np.dtype('object')  # Mixed dtypes default to object\n+        else:\n+            # not a data type (e.g. a column named dtype attribute)\n+            dtype_orig = None\n+    except (AttributeError, TypeError):\n         dtype_orig = None\n \n     if dtype_numeric:\n@@ -507,12 +520,23 @@ def check_array(array, accept_sparse=False, accept_large_sparse=True,\n         # dtype to the function converts complex to real dtype,\n         # thereby passing the test made in the lines following the scope\n         # of warnings context manager.\n-        with warnings.catch_warnings():\n+\n+        dtype_orig = getattr(array, \"dtype\", None)\n+        if dtype_orig is not None and not hasattr(dtype_orig, 'kind'):\n+            # Handle pandas DataFrame case - preserve the dtype for warning purposes\n             try:\n-                warnings.simplefilter('error', ComplexWarning)\n-                array = np.asarray(array, dtype=dtype, order=order)\n-            except ComplexWarning:\n-                raise ValueError(\"Complex data not supported\\n\"\n+                # For pandas DataFrames, get the common dtype or object if mixed\n+                if hasattr(array, 'dtypes'):  # pandas DataFrame\n+                    unique_dtypes = array.dtypes.unique()\n+                    if len(unique_dtypes) == 1:\n+                        dtype_orig = unique_dtypes[0]\n+                    else:\n+                        dtype_orig = np.dtype('object')  # Mixed dtypes default to object\n+                else:\n+                    # not a data type (e.g. a column named dtype attribute)\n+                    dtype_orig = None\n+            except (AttributeError, TypeError):\n+                dtype_orig = None\n                                  \"{}\\n\".format(array))\n \n         # It is possible that the np.array(..) gave no warning. This happens\n@@ -573,9 +597,14 @@ def check_array(array, accept_sparse=False, accept_large_sparse=True,\n                              % (n_features, shape_repr, ensure_min_features,\n                                 context))\n \n+\n     if warn_on_dtype and dtype_orig is not None and array.dtype != dtype_orig:\n+        # Handle both numpy dtypes and pandas dtypes for consistent messaging\n+        orig_dtype_str = str(dtype_orig)\n+        if hasattr(dtype_orig, 'name'):\n+            orig_dtype_str = dtype_orig.name\n         msg = (\"Data with input dtype %s was converted to %s%s.\"\n-               % (dtype_orig, array.dtype, context))\n+               % (orig_dtype_str, array.dtype, context))\n         warnings.warn(msg, DataConversionWarning)\n \n     if copy and np.may_share_memory(array, array_orig):\n",
    "variant_6": "diff --git a/sklearn/utils/validation.py b/sklearn/utils/validation.py\nindex fe1f7236e..c39a7fabc 100644\n--- a/sklearn/utils/validation.py\n+++ b/sklearn/utils/validation.py\n@@ -461,9 +461,22 @@ def check_array(array, accept_sparse=False, accept_large_sparse=True,\n     # store whether originally we wanted numeric dtype\n     dtype_numeric = isinstance(dtype, six.string_types) and dtype == \"numeric\"\n \n-    dtype_orig = getattr(array, \"dtype\", None)\n-    if not hasattr(dtype_orig, 'kind'):\n-        # not a data type (e.g. a column named dtype in a pandas DataFrame)\n+\n+dtype_orig = getattr(array, \"dtype\", None)\n+if dtype_orig is not None and not hasattr(dtype_orig, 'kind'):\n+    # Handle pandas DataFrame case - preserve the dtype for warning purposes\n+    try:\n+        # For pandas DataFrames, get the common dtype or object if mixed\n+        if hasattr(array, 'dtypes'):  # pandas DataFrame\n+            unique_dtypes = array.dtypes.unique()\n+            if len(unique_dtypes) == 1:\n+                dtype_orig = unique_dtypes[0]\n+            else:\n+                dtype_orig = np.dtype('object')  # Mixed dtypes default to object\n+        else:\n+            # not a data type (e.g. a column named dtype attribute)\n+            dtype_orig = None\n+    except (AttributeError, TypeError):\n         dtype_orig = None\n \n     if dtype_numeric:\n@@ -507,12 +520,23 @@ def check_array(array, accept_sparse=False, accept_large_sparse=True,\n         # dtype to the function converts complex to real dtype,\n         # thereby passing the test made in the lines following the scope\n         # of warnings context manager.\n-        with warnings.catch_warnings():\n+\n+        dtype_orig = getattr(array, \"dtype\", None)\n+        if dtype_orig is not None and not hasattr(dtype_orig, 'kind'):\n+            # Handle pandas DataFrame case - preserve the dtype for warning purposes\n             try:\n-                warnings.simplefilter('error', ComplexWarning)\n-                array = np.asarray(array, dtype=dtype, order=order)\n-            except ComplexWarning:\n-                raise ValueError(\"Complex data not supported\\n\"\n+                # For pandas DataFrames, get the common dtype or object if mixed\n+                if hasattr(array, 'dtypes'):  # pandas DataFrame\n+                    unique_dtypes = array.dtypes.unique()\n+                    if len(unique_dtypes) == 1:\n+                        dtype_orig = unique_dtypes[0]\n+                    else:\n+                        dtype_orig = np.dtype('object')  # Mixed dtypes default to object\n+                else:\n+                    # not a data type (e.g. a column named dtype attribute)\n+                    dtype_orig = None\n+            except (AttributeError, TypeError):\n+                dtype_orig = None\n                                  \"{}\\n\".format(array))\n \n         # It is possible that the np.array(..) gave no warning. This happens\n@@ -573,9 +597,14 @@ def check_array(array, accept_sparse=False, accept_large_sparse=True,\n                              % (n_features, shape_repr, ensure_min_features,\n                                 context))\n \n+\n     if warn_on_dtype and dtype_orig is not None and array.dtype != dtype_orig:\n+        # Handle both numpy dtypes and pandas dtypes for consistent messaging\n+        orig_dtype_str = str(dtype_orig)\n+        if hasattr(dtype_orig, 'name'):\n+            orig_dtype_str = dtype_orig.name\n         msg = (\"Data with input dtype %s was converted to %s%s.\"\n-               % (dtype_orig, array.dtype, context))\n+               % (orig_dtype_str, array.dtype, context))\n         warnings.warn(msg, DataConversionWarning)\n \n     if copy and np.may_share_memory(array, array_orig):\n",
    "variant_7": "diff --git a/sklearn/utils/validation.py b/sklearn/utils/validation.py\nindex fe1f7236e..c39a7fabc 100644\n--- a/sklearn/utils/validation.py\n+++ b/sklearn/utils/validation.py\n@@ -461,9 +461,22 @@ def check_array(array, accept_sparse=False, accept_large_sparse=True,\n     # store whether originally we wanted numeric dtype\n     dtype_numeric = isinstance(dtype, six.string_types) and dtype == \"numeric\"\n \n-    dtype_orig = getattr(array, \"dtype\", None)\n-    if not hasattr(dtype_orig, 'kind'):\n-        # not a data type (e.g. a column named dtype in a pandas DataFrame)\n+\n+dtype_orig = getattr(array, \"dtype\", None)\n+if dtype_orig is not None and not hasattr(dtype_orig, 'kind'):\n+    # Handle pandas DataFrame case - preserve the dtype for warning purposes\n+    try:\n+        # For pandas DataFrames, get the common dtype or object if mixed\n+        if hasattr(array, 'dtypes'):  # pandas DataFrame\n+            unique_dtypes = array.dtypes.unique()\n+            if len(unique_dtypes) == 1:\n+                dtype_orig = unique_dtypes[0]\n+            else:\n+                dtype_orig = np.dtype('object')  # Mixed dtypes default to object\n+        else:\n+            # not a data type (e.g. a column named dtype attribute)\n+            dtype_orig = None\n+    except (AttributeError, TypeError):\n         dtype_orig = None\n \n     if dtype_numeric:\n@@ -507,12 +520,23 @@ def check_array(array, accept_sparse=False, accept_large_sparse=True,\n         # dtype to the function converts complex to real dtype,\n         # thereby passing the test made in the lines following the scope\n         # of warnings context manager.\n-        with warnings.catch_warnings():\n+\n+        dtype_orig = getattr(array, \"dtype\", None)\n+        if dtype_orig is not None and not hasattr(dtype_orig, 'kind'):\n+            # Handle pandas DataFrame case - preserve the dtype for warning purposes\n             try:\n-                warnings.simplefilter('error', ComplexWarning)\n-                array = np.asarray(array, dtype=dtype, order=order)\n-            except ComplexWarning:\n-                raise ValueError(\"Complex data not supported\\n\"\n+                # For pandas DataFrames, get the common dtype or object if mixed\n+                if hasattr(array, 'dtypes'):  # pandas DataFrame\n+                    unique_dtypes = array.dtypes.unique()\n+                    if len(unique_dtypes) == 1:\n+                        dtype_orig = unique_dtypes[0]\n+                    else:\n+                        dtype_orig = np.dtype('object')  # Mixed dtypes default to object\n+                else:\n+                    # not a data type (e.g. a column named dtype attribute)\n+                    dtype_orig = None\n+            except (AttributeError, TypeError):\n+                dtype_orig = None\n                                  \"{}\\n\".format(array))\n \n         # It is possible that the np.array(..) gave no warning. This happens\n@@ -573,9 +597,14 @@ def check_array(array, accept_sparse=False, accept_large_sparse=True,\n                              % (n_features, shape_repr, ensure_min_features,\n                                 context))\n \n+\n     if warn_on_dtype and dtype_orig is not None and array.dtype != dtype_orig:\n+        # Handle both numpy dtypes and pandas dtypes for consistent messaging\n+        orig_dtype_str = str(dtype_orig)\n+        if hasattr(dtype_orig, 'name'):\n+            orig_dtype_str = dtype_orig.name\n         msg = (\"Data with input dtype %s was converted to %s%s.\"\n-               % (dtype_orig, array.dtype, context))\n+               % (orig_dtype_str, array.dtype, context))\n         warnings.warn(msg, DataConversionWarning)\n \n     if copy and np.may_share_memory(array, array_orig):\n",
    "variant_8": "diff --git a/sklearn/utils/validation.py b/sklearn/utils/validation.py\nindex fe1f7236e..c196b8300 100644\n--- a/sklearn/utils/validation.py\n+++ b/sklearn/utils/validation.py\n@@ -461,9 +461,22 @@ def check_array(array, accept_sparse=False, accept_large_sparse=True,\n     # store whether originally we wanted numeric dtype\n     dtype_numeric = isinstance(dtype, six.string_types) and dtype == \"numeric\"\n \n-    dtype_orig = getattr(array, \"dtype\", None)\n-    if not hasattr(dtype_orig, 'kind'):\n-        # not a data type (e.g. a column named dtype in a pandas DataFrame)\n+\n+dtype_orig = getattr(array, \"dtype\", None)\n+if dtype_orig is not None and not hasattr(dtype_orig, 'kind'):\n+    # Handle pandas DataFrame case - preserve the dtype for warning purposes\n+    try:\n+        # For pandas DataFrames, get the common dtype or object if mixed\n+        if hasattr(array, 'dtypes'):  # pandas DataFrame\n+            unique_dtypes = array.dtypes.unique()\n+            if len(unique_dtypes) == 1:\n+                dtype_orig = unique_dtypes[0]\n+            else:\n+                dtype_orig = np.dtype('object')  # Mixed dtypes default to object\n+        else:\n+            # not a data type (e.g. a column named dtype attribute)\n+            dtype_orig = None\n+    except (AttributeError, TypeError):\n         dtype_orig = None\n \n     if dtype_numeric:\n@@ -507,12 +520,23 @@ def check_array(array, accept_sparse=False, accept_large_sparse=True,\n         # dtype to the function converts complex to real dtype,\n         # thereby passing the test made in the lines following the scope\n         # of warnings context manager.\n-        with warnings.catch_warnings():\n+\n+        dtype_orig = getattr(array, \"dtype\", None)\n+        if dtype_orig is not None and not hasattr(dtype_orig, 'kind'):\n+            # Handle pandas DataFrame case - preserve the dtype for warning purposes\n             try:\n-                warnings.simplefilter('error', ComplexWarning)\n-                array = np.asarray(array, dtype=dtype, order=order)\n-            except ComplexWarning:\n-                raise ValueError(\"Complex data not supported\\n\"\n+                # For pandas DataFrames, get the common dtype or object if mixed\n+                if hasattr(array, 'dtypes'):  # pandas DataFrame\n+                    unique_dtypes = array.dtypes.unique()\n+                    if len(unique_dtypes) == 1:\n+                        dtype_orig = unique_dtypes[0]\n+                    else:\n+                        dtype_orig = np.dtype('object')  # Mixed dtypes default to object\n+                else:\n+                    # not a data type (e.g. a column named dtype attribute)\n+                    dtype_orig = None\n+            except (AttributeError, TypeError):\n+                dtype_orig = None\n                                  \"{}\\n\".format(array))\n \n         # It is possible that the np.array(..) gave no warning. This happens\n@@ -573,10 +597,15 @@ def check_array(array, accept_sparse=False, accept_large_sparse=True,\n                              % (n_features, shape_repr, ensure_min_features,\n                                 context))\n \n-    if warn_on_dtype and dtype_orig is not None and array.dtype != dtype_orig:\n-        msg = (\"Data with input dtype %s was converted to %s%s.\"\n-               % (dtype_orig, array.dtype, context))\n-        warnings.warn(msg, DataConversionWarning)\n+\n+if warn_on_dtype and dtype_orig is not None and array.dtype != dtype_orig:\n+    # Handle both numpy dtypes and pandas dtypes for consistent messaging\n+    orig_dtype_str = str(dtype_orig)\n+    if hasattr(dtype_orig, 'name'):\n+        orig_dtype_str = dtype_orig.name\n+    msg = (\"Data with input dtype %s was converted to %s%s.\"\n+           % (orig_dtype_str, array.dtype, context))\n+    warnings.warn(msg, DataConversionWarning)\n \n     if copy and np.may_share_memory(array, array_orig):\n         array = np.array(array, dtype=dtype, order=order)\n"
  }
}