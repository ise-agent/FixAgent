{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/requests/requests/sessions.py lines 91-91)": "\nclass SessionRedirectMixin(object):\n    def resolve_redirects(self, resp, req, stream=False, timeout=None,\n                          verify=True, cert=None, proxies=None):\n        \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n\n        i = 0\n        prepared_request = req.copy()\n\n        while resp.is_redirect:\n            if i > 0:\n                # For subsequent redirects, copy the current prepared_request\n                # to preserve method changes from previous redirects\n                prepared_request = prepared_request.copy()\n            \n            resp.content  # Consume socket so it can be released\n\n            if i >= self.max_redirects:\n                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)\n\n            # Release the connection back into the pool.\n            resp.close()\n\n            url = resp.headers['location']\n            method = prepared_request.method\n",
    "Location 2 (/root/hy/projects_3/requests/requests/sessions.py lines 102-102)": "\n            method = prepared_request.method\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/requests/requests/sessions.py lines 91-91)": [
      "\nclass SessionRedirectMixin(object):\n    def resolve_redirects(self, resp, req, stream=False, timeout=None,\n                          verify=True, cert=None, proxies=None):\n        \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n\n        i = 0\n        prepared_request = req.copy()\n\n        while resp.is_redirect:\n            if i > 0:\n                # For subsequent redirects, copy the current prepared_request\n                # to preserve any method changes from previous redirects\n                prepared_request = prepared_request.copy()\n            \n            resp.content  # Consume socket so it can be released\n\n            if i >= self.max_redirects:\n                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)\n\n            # Release the connection back into the pool.\n            resp.close()\n\n            url = resp.headers['location']\n            method = prepared_request.method\n\n            # https://github.com/kennethreitz/requests/issues/1084\n            if resp.status_code not in (codes.temporary_redirect, codes.permanent_redirect):\n                # https://github.com/kennethreitz/requests/issues/3490\n                purged_headers = {}\n                for header in ('Authorization', 'Content-Length', 'Content-Type'):\n                    if header in prepared_request.headers:\n                        purged_headers[header] = prepared_request.headers[header]\n                        del prepared_request.headers[header]\n\n                if resp.status_code == codes.see_other:\n                    method = 'GET'\n\n                # Do what the browsers do, despite standards...\n                # First, turn 302s into GETs.\n                if resp.status_code == codes.found:\n                    method = 'GET'\n\n                # Second, if a POST is responded to with a 301, turn it into a GET.\n                # This bizarre behaviour is explained in Issue 1704.\n                if resp.status_code == codes.moved_permanently:\n                    method = 'GET'\n\n                prepared_request.body = None\n                for header in purged_headers:\n                    prepared_request.headers[header] = purged_headers[header]\n\n            prepared_request.method = method\n            prepared_request.url = url\n            prepared_request.prepare_cookies(self.cookies)\n            resp = self.send(prepared_request, stream=stream, timeout=timeout,\n                           verify=verify, cert=cert, proxies=proxies)\n            extract_cookies_to_jar(self.cookies, prepared_request, resp.raw)\n            i += 1\n\n        return resp\n",
      "\nclass SessionRedirectMixin(object):\n    def resolve_redirects(self, resp, req, stream=False, timeout=None,\n                          verify=True, cert=None, proxies=None):\n        \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n\n        i = 0\n        prepared_request = req.copy()\n\n        while resp.is_redirect:\n            if i > 0:\n                # For subsequent redirects, copy from the current prepared_request\n                # to preserve method changes from previous redirects\n                prepared_request = prepared_request.copy()\n            \n            resp.content  # Consume socket so it can be released\n\n            if i >= self.max_redirects:\n                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)\n\n            # Release the connection back into the pool.\n            resp.close()\n\n            url = resp.headers['location']\n            method = prepared_request.method\n",
      "\nclass SessionRedirectMixin(object):\n    def resolve_redirects(self, resp, req, stream=False, timeout=None,\n                          verify=True, cert=None, proxies=None):\n        \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n\n        i = 0\n        prepared_request = req.copy()\n\n        while resp.is_redirect:\n            if i > 0:\n                # For subsequent redirects, copy the current prepared_request\n                # to preserve method changes from previous redirects\n                prepared_request = prepared_request.copy()\n            \n            resp.content  # Consume socket so it can be released\n\n            if i >= self.max_redirects:\n                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)\n\n            # Release the connection back into the pool.\n            resp.close()\n\n            url = resp.headers['location']\n            method = prepared_request.method\n",
      "\nclass SessionRedirectMixin(object):\n    def resolve_redirects(self, resp, req, stream=False, timeout=None,\n                          verify=True, cert=None, proxies=None):\n        \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n\n        i = 0\n        prepared_request = req.copy()\n\n        while resp.is_redirect:\n            if i > 0:\n                # For subsequent redirects, copy from the current prepared_request\n                # to preserve method changes from previous redirects\n                prepared_request = prepared_request.copy()\n            \n            resp.content  # Consume socket so it can be released\n\n            if i >= self.max_redirects:\n                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)\n\n            # Release the connection back into the pool.\n            resp.close()\n\n            url = resp.headers['location']\n            method = prepared_request.method\n\n            # https://tools.ietf.org/html/rfc7231#section-6.4.4\n            if (resp.status_code == codes.see_other and\n                    method != 'HEAD'):\n                method = 'GET'\n\n            # https://tools.ietf.org/html/rfc7231#section-6.4.4\n            if (resp.status_code == codes.found and\n                    method != 'HEAD'):\n                method = 'GET'\n\n            # https://tools.ietf.org/html/rfc7231#section-6.4.4\n            if (resp.status_code == codes.moved and\n                    method != 'HEAD'):\n                method = 'GET'\n\n            # Remove the body and content-type headers for GET requests\n            if method == 'GET':\n                prepared_request.body = None\n                prepared_request.headers.pop('Content-Type', None)\n                prepared_request.headers.pop('Content-Length', None)\n\n            prepared_request.method = method\n\n            # https://github.com/kennethreitz/requests/issues/1084\n            if resp.status_code not in (codes.temporary_redirect, codes.permanent_redirect):\n                if 'Authorization' in prepared_request.headers:\n                    # If we get redirected to a new host, we should strip out any\n                    # authentication headers.\n                    original_parsed = urlparse(resp.request.url)\n                    redirect_parsed = urlparse(url)\n                    if (original_parsed.hostname != redirect_parsed.hostname):\n                        del prepared_request.headers['Authorization']\n\n            try:\n                del prepared_request.headers['Cookie']\n            except KeyError:\n                pass\n\n            prepared_request.url = url\n            prepared_request.prepare_cookies(self.cookies)\n            resp = self.send(prepared_request, stream=stream, timeout=timeout,\n                           verify=verify, cert=cert, proxies=proxies)\n            extract_cookies_to_jar(self.cookies, prepared_request, resp.raw)\n\n            i += 1\n            yield resp\n",
      "\nclass SessionRedirectMixin(object):\n    def resolve_redirects(self, resp, req, stream=False, timeout=None,\n                          verify=True, cert=None, proxies=None):\n        \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n\n        i = 0\n        prepared_request = req.copy()\n\n        while resp.is_redirect:\n            if i > 0:\n                # For subsequent redirects, copy the current prepared_request\n                # to preserve method changes from previous redirects\n                prepared_request = prepared_request.copy()\n            \n            resp.content  # Consume socket so it can be released\n\n            if i >= self.max_redirects:\n                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)\n\n            # Release the connection back into the pool.\n            resp.close()\n\n            url = resp.headers['location']\n            method = prepared_request.method\n\n            # https://github.com/kennethreitz/requests/issues/1084\n            if resp.status_code not in (codes.temporary_redirect, codes.permanent_redirect):\n                # https://github.com/kennethreitz/requests/issues/3490\n                purged_headers = ('Authorization', 'Content-Length', 'Content-Type', 'Cookie')\n                for header in purged_headers:\n                    prepared_request.headers.pop(header, None)\n\n            # https://github.com/kennethreitz/requests/issues/1063\n            if resp.status_code == codes.see_other and method != 'HEAD':\n                method = 'GET'\n\n            # Do what the browsers do, despite standards...\n            # First, turn 302s into GETs.\n            if resp.status_code == codes.found and method != 'HEAD':\n                method = 'GET'\n\n            # Second, if a POST is responded to with a 301, turn it into a GET.\n            # This bizarre behaviour is explained in Issue 1704.\n            if resp.status_code == codes.moved_permanently and method == 'POST':\n                method = 'GET'\n\n            prepared_request.method = method\n\n            # https://github.com/kennethreitz/requests/issues/1084\n            if resp.status_code not in (codes.temporary_redirect, codes.permanent_redirect):\n                prepared_request.body = None\n\n            headers = prepared_request.headers\n            try:\n                del headers['Cookie']\n            except KeyError:\n                pass\n\n            extract_cookies_to_jar(prepared_request._cookies, prepared_request, resp.raw)\n            prepared_request._cookies.update(self.cookies)\n            prepared_request.prepare_cookies(prepared_request._cookies)\n\n            # Rebuild auth and proxies information from environment, if needed.\n            if 'Authorization' not in headers:\n                prepared_request = rebuild_auth(prepared_request, resp)\n\n            proxies = self.rebuild_proxies(prepared_request, proxies)\n            prepared_request.url = url\n            prepared_request.prepare_url(prepared_request.url, None)\n\n            self.send(prepared_request, **adapter_kwargs)\n            yield resp\n\n            i += 1\n",
      "\nclass SessionRedirectMixin(object):\n    def resolve_redirects(self, resp, req, stream=False, timeout=None,\n                          verify=True, cert=None, proxies=None):\n        \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n\n        i = 0\n        prepared_request = req.copy()\n\n        while resp.is_redirect:\n            if i > 0:\n                prepared_request = prepared_request.copy()\n\n            resp.content  # Consume socket so it can be released\n\n            if i >= self.max_redirects:\n                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)\n\n            # Release the connection back into the pool.\n            resp.close()\n\n            url = resp.headers['location']\n            method = prepared_request.method\n",
      "\nclass SessionRedirectMixin(object):\n    def resolve_redirects(self, resp, req, stream=False, timeout=None,\n                          verify=True, cert=None, proxies=None):\n        \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n\n        i = 0\n        prepared_request = req.copy()\n\n        while resp.is_redirect:\n            if i > 0:\n                # For subsequent redirects, use the current prepared_request\n                # to preserve method changes from previous redirects\n                prepared_request = prepared_request.copy()\n            else:\n                # For first redirect, copy from original request\n                prepared_request = req.copy()\n\n            resp.content  # Consume socket so it can be released\n\n            if i >= self.max_redirects:\n                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)\n\n            # Release the connection back into the pool.\n            resp.close()\n\n            url = resp.headers['location']\n            method = prepared_request.method\n",
      "\nclass SessionRedirectMixin(object):\n    def resolve_redirects(self, resp, req, stream=False, timeout=None,\n                          verify=True, cert=None, proxies=None):\n        \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n\n        i = 0\n        prepared_request = req.copy()\n\n        while resp.is_redirect:\n            if i > 0:\n                prepared_request = prepared_request.copy()\n\n            resp.content  # Consume socket so it can be released\n\n            if i >= self.max_redirects:\n                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)\n\n            # Release the connection back into the pool.\n            resp.close()\n\n            url = resp.headers['location']\n            method = prepared_request.method\n"
    ],
    "Location 2 (/root/hy/projects_3/requests/requests/sessions.py lines 102-102)": [
      "\n            method = prepared_request.method\n",
      "\n            method = prepared_request.method\n",
      "\n            method = prepared_request.method\n",
      "\n            method = prepared_request.method\n",
      "\n            method = prepared_request.method\n",
      "\n            method = prepared_request.method\n",
      "\n            method = prepared_request.method\n",
      "\n            method = prepared_request.method\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 425db22c..ddf2869f 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -88,7 +88,8 @@ class SessionRedirectMixin(object):\n         i = 0\n \n         while resp.is_redirect:\n-            prepared_request = req.copy()\n+\n+            prepared_request = req.copy() if i == 0 else prepared_request.copy()\n \n             resp.content  # Consume socket so it can be released\n \n@@ -99,7 +100,8 @@ class SessionRedirectMixin(object):\n             resp.close()\n \n             url = resp.headers['location']\n-            method = req.method\n+\n+            method = prepared_request.method\n \n             # Handle redirection without scheme (see: RFC 1808 Section 4)\n             if url.startswith('//'):\n",
    "variant_0": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 425db22c..3c0cfbed 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -88,8 +88,21 @@ class SessionRedirectMixin(object):\n         i = 0\n \n         while resp.is_redirect:\n-            prepared_request = req.copy()\n \n+class SessionRedirectMixin(object):\n+    def resolve_redirects(self, resp, req, stream=False, timeout=None,\n+                          verify=True, cert=None, proxies=None):\n+        \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n+\n+        i = 0\n+        prepared_request = req.copy()\n+\n+        while resp.is_redirect:\n+            if i > 0:\n+                # For subsequent redirects, copy the current prepared_request\n+                # to preserve method changes from previous redirects\n+                prepared_request = prepared_request.copy()\n+            \n             resp.content  # Consume socket so it can be released\n \n             if i >= self.max_redirects:\n@@ -99,7 +112,19 @@ class SessionRedirectMixin(object):\n             resp.close()\n \n             url = resp.headers['location']\n-            method = req.method\n+            method = prepared_request.method\n+\n+            resp.content  # Consume socket so it can be released\n+\n+            if i >= self.max_redirects:\n+                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)\n+\n+            # Release the connection back into the pool.\n+            resp.close()\n+\n+            url = resp.headers['location']\n+\n+            method = prepared_request.method\n \n             # Handle redirection without scheme (see: RFC 1808 Section 4)\n             if url.startswith('//'):\n",
    "variant_1": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 425db22c..102952b0 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -88,8 +88,21 @@ class SessionRedirectMixin(object):\n         i = 0\n \n         while resp.is_redirect:\n-            prepared_request = req.copy()\n \n+class SessionRedirectMixin(object):\n+    def resolve_redirects(self, resp, req, stream=False, timeout=None,\n+                          verify=True, cert=None, proxies=None):\n+        \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n+\n+        i = 0\n+        prepared_request = req.copy()\n+\n+        while resp.is_redirect:\n+            if i > 0:\n+                # For subsequent redirects, copy the current prepared_request\n+                # to preserve any method changes from previous redirects\n+                prepared_request = prepared_request.copy()\n+            \n             resp.content  # Consume socket so it can be released\n \n             if i >= self.max_redirects:\n@@ -99,7 +112,55 @@ class SessionRedirectMixin(object):\n             resp.close()\n \n             url = resp.headers['location']\n-            method = req.method\n+            method = prepared_request.method\n+\n+            # https://github.com/kennethreitz/requests/issues/1084\n+            if resp.status_code not in (codes.temporary_redirect, codes.permanent_redirect):\n+                # https://github.com/kennethreitz/requests/issues/3490\n+                purged_headers = {}\n+                for header in ('Authorization', 'Content-Length', 'Content-Type'):\n+                    if header in prepared_request.headers:\n+                        purged_headers[header] = prepared_request.headers[header]\n+                        del prepared_request.headers[header]\n+\n+                if resp.status_code == codes.see_other:\n+                    method = 'GET'\n+\n+                # Do what the browsers do, despite standards...\n+                # First, turn 302s into GETs.\n+                if resp.status_code == codes.found:\n+                    method = 'GET'\n+\n+                # Second, if a POST is responded to with a 301, turn it into a GET.\n+                # This bizarre behaviour is explained in Issue 1704.\n+                if resp.status_code == codes.moved_permanently:\n+                    method = 'GET'\n+\n+                prepared_request.body = None\n+                for header in purged_headers:\n+                    prepared_request.headers[header] = purged_headers[header]\n+\n+            prepared_request.method = method\n+            prepared_request.url = url\n+            prepared_request.prepare_cookies(self.cookies)\n+            resp = self.send(prepared_request, stream=stream, timeout=timeout,\n+                           verify=verify, cert=cert, proxies=proxies)\n+            extract_cookies_to_jar(self.cookies, prepared_request, resp.raw)\n+            i += 1\n+\n+        return resp\n+\n+            resp.content  # Consume socket so it can be released\n+\n+            if i >= self.max_redirects:\n+                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)\n+\n+            # Release the connection back into the pool.\n+            resp.close()\n+\n+            url = resp.headers['location']\n+\n+            method = prepared_request.method\n \n             # Handle redirection without scheme (see: RFC 1808 Section 4)\n             if url.startswith('//'):\n",
    "variant_2": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 425db22c..ac1fb08e 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -88,8 +88,21 @@ class SessionRedirectMixin(object):\n         i = 0\n \n         while resp.is_redirect:\n-            prepared_request = req.copy()\n \n+class SessionRedirectMixin(object):\n+    def resolve_redirects(self, resp, req, stream=False, timeout=None,\n+                          verify=True, cert=None, proxies=None):\n+        \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n+\n+        i = 0\n+        prepared_request = req.copy()\n+\n+        while resp.is_redirect:\n+            if i > 0:\n+                # For subsequent redirects, copy from the current prepared_request\n+                # to preserve method changes from previous redirects\n+                prepared_request = prepared_request.copy()\n+            \n             resp.content  # Consume socket so it can be released\n \n             if i >= self.max_redirects:\n@@ -99,7 +112,19 @@ class SessionRedirectMixin(object):\n             resp.close()\n \n             url = resp.headers['location']\n-            method = req.method\n+            method = prepared_request.method\n+\n+            resp.content  # Consume socket so it can be released\n+\n+            if i >= self.max_redirects:\n+                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)\n+\n+            # Release the connection back into the pool.\n+            resp.close()\n+\n+            url = resp.headers['location']\n+\n+            method = prepared_request.method\n \n             # Handle redirection without scheme (see: RFC 1808 Section 4)\n             if url.startswith('//'):\n",
    "variant_3": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 425db22c..3c0cfbed 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -88,8 +88,21 @@ class SessionRedirectMixin(object):\n         i = 0\n \n         while resp.is_redirect:\n-            prepared_request = req.copy()\n \n+class SessionRedirectMixin(object):\n+    def resolve_redirects(self, resp, req, stream=False, timeout=None,\n+                          verify=True, cert=None, proxies=None):\n+        \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n+\n+        i = 0\n+        prepared_request = req.copy()\n+\n+        while resp.is_redirect:\n+            if i > 0:\n+                # For subsequent redirects, copy the current prepared_request\n+                # to preserve method changes from previous redirects\n+                prepared_request = prepared_request.copy()\n+            \n             resp.content  # Consume socket so it can be released\n \n             if i >= self.max_redirects:\n@@ -99,7 +112,19 @@ class SessionRedirectMixin(object):\n             resp.close()\n \n             url = resp.headers['location']\n-            method = req.method\n+            method = prepared_request.method\n+\n+            resp.content  # Consume socket so it can be released\n+\n+            if i >= self.max_redirects:\n+                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)\n+\n+            # Release the connection back into the pool.\n+            resp.close()\n+\n+            url = resp.headers['location']\n+\n+            method = prepared_request.method\n \n             # Handle redirection without scheme (see: RFC 1808 Section 4)\n             if url.startswith('//'):\n",
    "variant_4": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 425db22c..ca3f0db9 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -88,7 +88,78 @@ class SessionRedirectMixin(object):\n         i = 0\n \n         while resp.is_redirect:\n-            prepared_request = req.copy()\n+\n+class SessionRedirectMixin(object):\n+    def resolve_redirects(self, resp, req, stream=False, timeout=None,\n+                          verify=True, cert=None, proxies=None):\n+        \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n+\n+        i = 0\n+        prepared_request = req.copy()\n+\n+        while resp.is_redirect:\n+            if i > 0:\n+                # For subsequent redirects, copy from the current prepared_request\n+                # to preserve method changes from previous redirects\n+                prepared_request = prepared_request.copy()\n+            \n+            resp.content  # Consume socket so it can be released\n+\n+            if i >= self.max_redirects:\n+                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)\n+\n+            # Release the connection back into the pool.\n+            resp.close()\n+\n+            url = resp.headers['location']\n+            method = prepared_request.method\n+\n+            # https://tools.ietf.org/html/rfc7231#section-6.4.4\n+            if (resp.status_code == codes.see_other and\n+                    method != 'HEAD'):\n+                method = 'GET'\n+\n+            # https://tools.ietf.org/html/rfc7231#section-6.4.4\n+            if (resp.status_code == codes.found and\n+                    method != 'HEAD'):\n+                method = 'GET'\n+\n+            # https://tools.ietf.org/html/rfc7231#section-6.4.4\n+            if (resp.status_code == codes.moved and\n+                    method != 'HEAD'):\n+                method = 'GET'\n+\n+            # Remove the body and content-type headers for GET requests\n+            if method == 'GET':\n+                prepared_request.body = None\n+                prepared_request.headers.pop('Content-Type', None)\n+                prepared_request.headers.pop('Content-Length', None)\n+\n+            prepared_request.method = method\n+\n+            # https://github.com/kennethreitz/requests/issues/1084\n+            if resp.status_code not in (codes.temporary_redirect, codes.permanent_redirect):\n+                if 'Authorization' in prepared_request.headers:\n+                    # If we get redirected to a new host, we should strip out any\n+                    # authentication headers.\n+                    original_parsed = urlparse(resp.request.url)\n+                    redirect_parsed = urlparse(url)\n+                    if (original_parsed.hostname != redirect_parsed.hostname):\n+                        del prepared_request.headers['Authorization']\n+\n+            try:\n+                del prepared_request.headers['Cookie']\n+            except KeyError:\n+                pass\n+\n+            prepared_request.url = url\n+            prepared_request.prepare_cookies(self.cookies)\n+            resp = self.send(prepared_request, stream=stream, timeout=timeout,\n+                           verify=verify, cert=cert, proxies=proxies)\n+            extract_cookies_to_jar(self.cookies, prepared_request, resp.raw)\n+\n+            i += 1\n+            yield resp\n \n             resp.content  # Consume socket so it can be released\n \n@@ -99,7 +170,8 @@ class SessionRedirectMixin(object):\n             resp.close()\n \n             url = resp.headers['location']\n-            method = req.method\n+\n+            method = prepared_request.method\n \n             # Handle redirection without scheme (see: RFC 1808 Section 4)\n             if url.startswith('//'):\n",
    "variant_5": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 425db22c..0be337d2 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -88,7 +88,81 @@ class SessionRedirectMixin(object):\n         i = 0\n \n         while resp.is_redirect:\n-            prepared_request = req.copy()\n+\n+class SessionRedirectMixin(object):\n+    def resolve_redirects(self, resp, req, stream=False, timeout=None,\n+                          verify=True, cert=None, proxies=None):\n+        \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n+\n+        i = 0\n+        prepared_request = req.copy()\n+\n+        while resp.is_redirect:\n+            if i > 0:\n+                # For subsequent redirects, copy the current prepared_request\n+                # to preserve method changes from previous redirects\n+                prepared_request = prepared_request.copy()\n+            \n+            resp.content  # Consume socket so it can be released\n+\n+            if i >= self.max_redirects:\n+                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)\n+\n+            # Release the connection back into the pool.\n+            resp.close()\n+\n+            url = resp.headers['location']\n+            method = prepared_request.method\n+\n+            # https://github.com/kennethreitz/requests/issues/1084\n+            if resp.status_code not in (codes.temporary_redirect, codes.permanent_redirect):\n+                # https://github.com/kennethreitz/requests/issues/3490\n+                purged_headers = ('Authorization', 'Content-Length', 'Content-Type', 'Cookie')\n+                for header in purged_headers:\n+                    prepared_request.headers.pop(header, None)\n+\n+            # https://github.com/kennethreitz/requests/issues/1063\n+            if resp.status_code == codes.see_other and method != 'HEAD':\n+                method = 'GET'\n+\n+            # Do what the browsers do, despite standards...\n+            # First, turn 302s into GETs.\n+            if resp.status_code == codes.found and method != 'HEAD':\n+                method = 'GET'\n+\n+            # Second, if a POST is responded to with a 301, turn it into a GET.\n+            # This bizarre behaviour is explained in Issue 1704.\n+            if resp.status_code == codes.moved_permanently and method == 'POST':\n+                method = 'GET'\n+\n+            prepared_request.method = method\n+\n+            # https://github.com/kennethreitz/requests/issues/1084\n+            if resp.status_code not in (codes.temporary_redirect, codes.permanent_redirect):\n+                prepared_request.body = None\n+\n+            headers = prepared_request.headers\n+            try:\n+                del headers['Cookie']\n+            except KeyError:\n+                pass\n+\n+            extract_cookies_to_jar(prepared_request._cookies, prepared_request, resp.raw)\n+            prepared_request._cookies.update(self.cookies)\n+            prepared_request.prepare_cookies(prepared_request._cookies)\n+\n+            # Rebuild auth and proxies information from environment, if needed.\n+            if 'Authorization' not in headers:\n+                prepared_request = rebuild_auth(prepared_request, resp)\n+\n+            proxies = self.rebuild_proxies(prepared_request, proxies)\n+            prepared_request.url = url\n+            prepared_request.prepare_url(prepared_request.url, None)\n+\n+            self.send(prepared_request, **adapter_kwargs)\n+            yield resp\n+\n+            i += 1\n \n             resp.content  # Consume socket so it can be released\n \n@@ -99,7 +173,8 @@ class SessionRedirectMixin(object):\n             resp.close()\n \n             url = resp.headers['location']\n-            method = req.method\n+\n+            method = prepared_request.method\n \n             # Handle redirection without scheme (see: RFC 1808 Section 4)\n             if url.startswith('//'):\n",
    "variant_6": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 425db22c..9d17a333 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -88,7 +88,29 @@ class SessionRedirectMixin(object):\n         i = 0\n \n         while resp.is_redirect:\n-            prepared_request = req.copy()\n+\n+class SessionRedirectMixin(object):\n+    def resolve_redirects(self, resp, req, stream=False, timeout=None,\n+                          verify=True, cert=None, proxies=None):\n+        \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n+\n+        i = 0\n+        prepared_request = req.copy()\n+\n+        while resp.is_redirect:\n+            if i > 0:\n+                prepared_request = prepared_request.copy()\n+\n+            resp.content  # Consume socket so it can be released\n+\n+            if i >= self.max_redirects:\n+                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)\n+\n+            # Release the connection back into the pool.\n+            resp.close()\n+\n+            url = resp.headers['location']\n+            method = prepared_request.method\n \n             resp.content  # Consume socket so it can be released\n \n@@ -99,7 +121,8 @@ class SessionRedirectMixin(object):\n             resp.close()\n \n             url = resp.headers['location']\n-            method = req.method\n+\n+            method = prepared_request.method\n \n             # Handle redirection without scheme (see: RFC 1808 Section 4)\n             if url.startswith('//'):\n",
    "variant_7": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 425db22c..5947255f 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -88,7 +88,23 @@ class SessionRedirectMixin(object):\n         i = 0\n \n         while resp.is_redirect:\n-            prepared_request = req.copy()\n+\n+class SessionRedirectMixin(object):\n+    def resolve_redirects(self, resp, req, stream=False, timeout=None,\n+                          verify=True, cert=None, proxies=None):\n+        \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n+\n+        i = 0\n+        prepared_request = req.copy()\n+\n+        while resp.is_redirect:\n+            if i > 0:\n+                # For subsequent redirects, use the current prepared_request\n+                # to preserve method changes from previous redirects\n+                prepared_request = prepared_request.copy()\n+            else:\n+                # For first redirect, copy from original request\n+                prepared_request = req.copy()\n \n             resp.content  # Consume socket so it can be released\n \n@@ -99,7 +115,19 @@ class SessionRedirectMixin(object):\n             resp.close()\n \n             url = resp.headers['location']\n-            method = req.method\n+            method = prepared_request.method\n+\n+            resp.content  # Consume socket so it can be released\n+\n+            if i >= self.max_redirects:\n+                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)\n+\n+            # Release the connection back into the pool.\n+            resp.close()\n+\n+            url = resp.headers['location']\n+\n+            method = prepared_request.method\n \n             # Handle redirection without scheme (see: RFC 1808 Section 4)\n             if url.startswith('//'):\n",
    "variant_8": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 425db22c..9d17a333 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -88,7 +88,29 @@ class SessionRedirectMixin(object):\n         i = 0\n \n         while resp.is_redirect:\n-            prepared_request = req.copy()\n+\n+class SessionRedirectMixin(object):\n+    def resolve_redirects(self, resp, req, stream=False, timeout=None,\n+                          verify=True, cert=None, proxies=None):\n+        \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n+\n+        i = 0\n+        prepared_request = req.copy()\n+\n+        while resp.is_redirect:\n+            if i > 0:\n+                prepared_request = prepared_request.copy()\n+\n+            resp.content  # Consume socket so it can be released\n+\n+            if i >= self.max_redirects:\n+                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)\n+\n+            # Release the connection back into the pool.\n+            resp.close()\n+\n+            url = resp.headers['location']\n+            method = prepared_request.method\n \n             resp.content  # Consume socket so it can be released\n \n@@ -99,7 +121,8 @@ class SessionRedirectMixin(object):\n             resp.close()\n \n             url = resp.headers['location']\n-            method = req.method\n+\n+            method = prepared_request.method\n \n             # Handle redirection without scheme (see: RFC 1808 Section 4)\n             if url.startswith('//'):\n"
  }
}