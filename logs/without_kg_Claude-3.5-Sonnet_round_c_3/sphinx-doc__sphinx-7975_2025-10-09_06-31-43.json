{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/sphinx/sphinx/environment/adapters/indexentries.py lines 111-112)": "\n        def keyfunc(entry: Tuple[str, List]) -> Tuple[str, str]:\n            key, (void, void, category_key) = entry\n            if category_key:\n                # using specified category key to sort\n                key = category_key\n            lckey = unicodedata.normalize('NFD', key.lower())\n            if lckey.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                lckey = lckey[1:]\n            if lckey[0:1].isalpha() or lckey.startswith('_'):\n                # Keep alphabetic entries as-is for normal sorting\n                pass\n            else:\n                # Add prefix to symbols to sort them at the front\n                lckey = chr(0) + lckey\n",
    "Location 2 (/root/hy/projects_3/sphinx/sphinx/environment/adapters/indexentries.py lines 153-154)": "\n        # sort the sub-index entries\n        def keyfunc2(entry: Tuple[str, List]) -> str:\n            key = unicodedata.normalize('NFD', entry[0].lower())\n            if key.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                key = key[1:]\n            if key[0:1].isalpha() or key.startswith('_'):\n                # Keep alphabetic entries as-is\n                pass\n            else:\n                # Add prefix to symbols to sort them at the front\n                key = chr(0) + key\n            return key\n",
    "Location 3 (/root/hy/projects_3/sphinx/sphinx/environment/adapters/indexentries.py lines 167-172)": "\n        # group the entries by letter\n        def keyfunc3(item: Tuple[str, List]) -> str:\n            # hack: mutating the subitems dicts to a list in the keyfunc\n            k, v = item\n            v[1] = sorted(((si, se) for (si, (se, void, void)) in v[1].items()),\n                          key=keyfunc2)\n            if v[2] is None:\n                # now calculate the key\n                if k.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                    k = k[1:]\n                letter = unicodedata.normalize('NFD', k[0])[0].upper()\n                if letter.isalpha() or letter == '_':\n                    return letter\n                else:\n                    # get all other symbols under one heading\n                    return _('Symbols')\n            else:\n                return v[2]\n",
    "Location 4 (/root/hy/projects_3/sphinx/sphinx/environment/adapters/indexentries.py lines 175-176)": "\n        return [(key_, list(group))\n                for (key_, group) in groupby(newlist, keyfunc3)]\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/sphinx/sphinx/environment/adapters/indexentries.py lines 111-112)": [
      "\n        def keyfunc(entry: Tuple[str, List]) -> Tuple[str, str]:\n            key, (void, void, category_key) = entry\n            if category_key:\n                # using specified category key to sort\n                key = category_key\n            lckey = unicodedata.normalize('NFD', key.lower())\n            if lckey.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                lckey = lckey[1:]\n            if lckey[0:1].isalpha() or lckey.startswith('_'):\n                # Keep alphabetic entries as-is for normal sorting\n                pass\n            else:\n                # Add prefix to symbols to sort them at the front\n                lckey = chr(0) + lckey\n            # ensure a determinstic order *within* letters by also sorting on\n            # the entry itself\n            return (lckey, entry[0])\n",
      "\n        def keyfunc(entry: Tuple[str, List]) -> Tuple[str, str]:\n            key, (void, void, category_key) = entry\n            if category_key:\n                # using specified category key to sort\n                key = category_key\n            lckey = unicodedata.normalize('NFD', key.lower())\n            if lckey.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                lckey = lckey[1:]\n            if not (lckey[0:1].isalpha() or lckey.startswith('_')):\n                lckey = chr(0) + lckey\n            # ensure a determinstic order *within* letters by also sorting on\n            # the entry itself\n            return (lckey, entry[0])\n",
      "\n            if lckey[0:1].isalpha() or lckey.startswith('_'):\n                # Keep alphabetic entries as-is for normal sorting\n                pass\n            else:\n                # Add prefix to symbols to sort them at the front\n                lckey = chr(0) + lckey\n",
      "\n            if lckey[0:1].isalpha() or lckey.startswith('_'):\n                # Keep alphabetic entries as-is for normal sorting\n                pass\n            else:\n                # Add prefix to symbols to sort them at the front\n                lckey = chr(0) + lckey\n",
      "\n        def keyfunc(entry: Tuple[str, List]) -> Tuple[str, str]:\n            key, (void, void, category_key) = entry\n            if category_key:\n                # using specified category key to sort\n                key = category_key\n            lckey = unicodedata.normalize('NFD', key.lower())\n            if lckey.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                lckey = lckey[1:]\n            if lckey[0:1].isalpha() or lckey.startswith('_'):\n                # Keep alphabetic entries as-is for normal sorting\n                pass\n            else:\n                # Add prefix to symbols to sort them at the front\n                lckey = chr(0) + lckey\n            # ensure a determinstic order *within* letters by also sorting on\n            # the entry itself\n            return (lckey, entry[0])\n",
      "\n        def keyfunc(entry: Tuple[str, List]) -> Tuple[str, str]:\n            key, (void, void, category_key) = entry\n            if category_key:\n                # using specified category key to sort\n                key = category_key\n            lckey = unicodedata.normalize('NFD', key.lower())\n            if lckey.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                lckey = lckey[1:]\n            if lckey[0:1].isalpha() or lckey.startswith('_'):\n                # Keep alphabetic entries as-is for normal sorting\n                pass\n            else:\n                # Add prefix to symbols to sort them at the front\n                lckey = chr(0) + lckey\n            # ensure a determinstic order *within* letters by also sorting on\n            # the entry itself\n            return (lckey, entry[0])\n",
      "\n        def keyfunc(entry: Tuple[str, List]) -> Tuple[str, str]:\n            key, (void, void, category_key) = entry\n            if category_key:\n                # using specified category key to sort\n                key = category_key\n            lckey = unicodedata.normalize('NFD', key.lower())\n            if lckey.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                lckey = lckey[1:]\n            if lckey[0:1].isalpha() or lckey.startswith('_'):\n                # Keep alphabetic entries as-is for normal sorting\n                pass\n            else:\n                # Add prefix to symbols to sort them at the front\n                lckey = chr(0) + lckey\n            # ensure a determinstic order *within* letters by also sorting on\n            # the entry itself\n            return (lckey, entry[0])\n",
      "\n        def keyfunc(entry: Tuple[str, List]) -> Tuple[str, str]:\n            key, (void, void, category_key) = entry\n            if category_key:\n                # using specified category key to sort\n                key = category_key\n            lckey = unicodedata.normalize('NFD', key.lower())\n            if lckey.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                lckey = lckey[1:]\n            if lckey[0:1].isalpha() or lckey.startswith('_'):\n                # Keep alphabetic entries as-is for normal sorting\n                pass\n            else:\n                # Add prefix to symbols to sort them at the front\n                lckey = chr(0) + lckey\n"
    ],
    "Location 2 (/root/hy/projects_3/sphinx/sphinx/environment/adapters/indexentries.py lines 153-154)": [
      "\n        # sort the sub-index entries\n        def keyfunc2(entry: Tuple[str, List]) -> str:\n            key = unicodedata.normalize('NFD', entry[0].lower())\n            if key.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                key = key[1:]\n            if key[0:1].isalpha() or key.startswith('_'):\n                # Keep alphabetic entries as-is for normal sorting\n                pass\n            else:\n                # Add prefix to symbols to sort them at the front\n                key = chr(0) + key\n            return key\n",
      "\n        # sort the sub-index entries\n        def keyfunc2(entry: Tuple[str, List]) -> str:\n            key = unicodedata.normalize('NFD', entry[0].lower())\n            if key.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                key = key[1:]\n            if key[0:1].isalpha() or key.startswith('_'):\n                # Keep alphabetic entries as-is\n                pass\n            else:\n                # Add prefix to symbols to sort them at the front\n                key = chr(0) + key\n            return key\n",
      "\n        # sort the sub-index entries\n        def keyfunc2(entry: Tuple[str, List]) -> str:\n            key = unicodedata.normalize('NFD', entry[0].lower())\n            if key.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                key = key[1:]\n            if key[0:1].isalpha() or key.startswith('_'):\n                # Keep alphabetic entries as-is for normal sorting\n                pass\n            else:\n                # Add prefix to symbols to sort them at the front\n                key = chr(0) + key\n            return key\n",
      "\n        # sort the sub-index entries\n        def keyfunc2(entry: Tuple[str, List]) -> str:\n            key = unicodedata.normalize('NFD', entry[0].lower())\n            if key.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                key = key[1:]\n            if key[0:1].isalpha() or key.startswith('_'):\n                # Keep alphabetic entries as-is\n                pass\n            else:\n                # Add prefix to symbols to sort them at the front\n                key = chr(0) + key\n            return key\n",
      "\n        # sort the sub-index entries\n        def keyfunc2(entry: Tuple[str, List]) -> str:\n            key = unicodedata.normalize('NFD', entry[0].lower())\n            if key.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                key = key[1:]\n            if key[0:1].isalpha() or key.startswith('_'):\n                # Keep alphabetic entries as-is\n                pass\n            else:\n                # Add prefix to symbols to sort them at the front\n                key = chr(0) + key\n            return key\n",
      "\n        # sort the sub-index entries\n        def keyfunc2(entry: Tuple[str, List]) -> str:\n            key = unicodedata.normalize('NFD', entry[0].lower())\n            if key.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                key = key[1:]\n            if key[0:1].isalpha() or key.startswith('_'):\n                # Keep alphabetic entries as-is for normal sorting\n                pass\n            else:\n                # Add prefix to symbols to sort them at the front\n                key = chr(0) + key\n            return key\n",
      "\n        # sort the sub-index entries\n        def keyfunc2(entry: Tuple[str, List]) -> str:\n            key = unicodedata.normalize('NFD', entry[0].lower())\n            if key.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                key = key[1:]\n            if key[0:1].isalpha() or key.startswith('_'):\n                # Keep alphabetic entries as-is\n                pass\n            else:\n                # Add prefix to symbols to sort them at the front\n                key = chr(0) + key\n            return key\n",
      "\n        # sort the sub-index entries\n        def keyfunc2(entry: Tuple[str, List]) -> str:\n            key = unicodedata.normalize('NFD', entry[0].lower())\n            if key.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                key = key[1:]\n            if key[0:1].isalpha() or key.startswith('_'):\n                # Keep alphabetic entries as-is\n                pass\n            else:\n                # Add prefix to symbols to sort them at the front\n                key = chr(0) + key\n            return key\n"
    ],
    "Location 3 (/root/hy/projects_3/sphinx/sphinx/environment/adapters/indexentries.py lines 167-172)": [
      "\n        # group the entries by letter\n        def keyfunc3(item: Tuple[str, List]) -> str:\n            # hack: mutating the subitems dicts to a list in the keyfunc\n            k, v = item\n            v[1] = sorted(((si, se) for (si, (se, void, void)) in v[1].items()),\n                          key=keyfunc2)\n            if v[2] is None:\n                # now calculate the key\n                if k.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                    k = k[1:]\n                letter = unicodedata.normalize('NFD', k[0])[0].upper()\n                if letter.isalpha() or letter == '_':\n                    return letter\n                else:\n                    # get all other symbols under one heading\n                    return _('Symbols')\n            else:\n                return v[2]\n",
      "\n        # group the entries by letter\n        def keyfunc3(item: Tuple[str, List]) -> str:\n            # hack: mutating the subitems dicts to a list in the keyfunc\n            k, v = item\n            v[1] = sorted(((si, se) for (si, (se, void, void)) in v[1].items()),\n                          key=keyfunc2)\n            if v[2] is None:\n                # now calculate the key\n                if k.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                    k = k[1:]\n                letter = unicodedata.normalize('NFD', k[0])[0].upper()\n                if letter.isalpha() or letter == '_':\n                    return letter\n                else:\n                    # get all other symbols under one heading\n                    return _('Symbols')\n            else:\n                return v[2]\n",
      "\n        # group the entries by letter\n        def keyfunc3(item: Tuple[str, List]) -> str:\n            # hack: mutating the subitems dicts to a list in the keyfunc\n            k, v = item\n            v[1] = sorted(((si, se) for (si, (se, void, void)) in v[1].items()),\n                          key=keyfunc2)\n            if v[2] is None:\n                # now calculate the key\n                if k.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                    k = k[1:]\n                letter = unicodedata.normalize('NFD', k[0])[0].upper()\n                if letter.isalpha() or letter == '_':\n                    return letter\n                else:\n                    # get all other symbols under one heading\n                    return _('Symbols')\n            else:\n                return v[2]\n",
      "\n        # group the entries by letter\n        def keyfunc3(item: Tuple[str, List]) -> str:\n            # hack: mutating the subitems dicts to a list in the keyfunc\n            k, v = item\n            v[1] = sorted(((si, se) for (si, (se, void, void)) in v[1].items()),\n                          key=keyfunc2)\n            if v[2] is None:\n                # now calculate the key\n                if k.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                    k = k[1:]\n                letter = unicodedata.normalize('NFD', k[0])[0].upper()\n                if letter.isalpha() or letter == '_':\n                    return letter\n                else:\n                    # get all other symbols under one heading\n                    return _('Symbols')\n            else:\n                return v[2]\n",
      "\n        # group the entries by letter\n        def keyfunc3(item: Tuple[str, List]) -> str:\n            # hack: mutating the subitems dicts to a list in the keyfunc\n            k, v = item\n            v[1] = sorted(((si, se) for (si, (se, void, void)) in v[1].items()),\n                          key=keyfunc2)\n            if v[2] is None:\n                # now calculate the key\n                if k.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                    k = k[1:]\n                letter = unicodedata.normalize('NFD', k[0])[0].upper()\n                if letter.isalpha() or letter == '_':\n                    return letter\n                else:\n                    # get all other symbols under one heading\n                    return _('Symbols')\n            else:\n                return v[2]\n",
      "\n        # group the entries by letter\n        def keyfunc3(item: Tuple[str, List]) -> str:\n            # hack: mutating the subitems dicts to a list in the keyfunc\n            k, v = item\n            v[1] = sorted(((si, se) for (si, (se, void, void)) in v[1].items()),\n                          key=keyfunc2)\n            if v[2] is None:\n                # now calculate the key\n                if k.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                    k = k[1:]\n                letter = unicodedata.normalize('NFD', k[0])[0].upper()\n                if letter.isalpha() or letter == '_':\n                    return letter\n                else:\n                    # get all other symbols under one heading\n                    return _('Symbols')\n            else:\n                return v[2]\n",
      "\n        # group the entries by letter\n        def keyfunc3(item: Tuple[str, List]) -> str:\n            # hack: mutating the subitems dicts to a list in the keyfunc\n            k, v = item\n            v[1] = sorted(((si, se) for (si, (se, void, void)) in v[1].items()),\n                          key=keyfunc2)\n            if v[2] is None:\n                # now calculate the key\n                if k.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                    k = k[1:]\n                letter = unicodedata.normalize('NFD', k[0])[0].upper()\n                if letter.isalpha() or letter == '_':\n                    return letter\n                else:\n                    # get all other symbols under one heading\n                    return _('Symbols')\n            else:\n                return v[2]\n",
      "\n        # group the entries by letter\n        def keyfunc3(item: Tuple[str, List]) -> str:\n            # hack: mutating the subitems dicts to a list in the keyfunc\n            k, v = item\n            v[1] = sorted(((si, se) for (si, (se, void, void)) in v[1].items()),\n                          key=keyfunc2)\n            if v[2] is None:\n                # now calculate the key\n                if k.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                    k = k[1:]\n                letter = unicodedata.normalize('NFD', k[0])[0].upper()\n                if letter.isalpha() or letter == '_':\n                    return letter\n                else:\n                    # get all other symbols under one heading\n                    return _('Symbols')\n            else:\n                return v[2]\n"
    ],
    "Location 4 (/root/hy/projects_3/sphinx/sphinx/environment/adapters/indexentries.py lines 175-176)": [
      "\n        return [(key_, list(group))\n                for (key_, group) in groupby(newlist, keyfunc3)]\n",
      "\n        return [(key_, list(group))\n                for (key_, group) in groupby(newlist, keyfunc3)]\n",
      "\n        return [(key_, list(group))\n                for (key_, group) in groupby(newlist, keyfunc3)]\n",
      "\n        return [(key_, list(group))\n                for (key_, group) in groupby(newlist, keyfunc3)]\n",
      "\n        return [(key_, list(group))\n                for (key_, group) in groupby(newlist, keyfunc3)]\n",
      "\n        return [(key_, list(group))\n                for (key_, group) in groupby(newlist, keyfunc3)]\n",
      "\n        return [(key_, list(group))\n                for (key_, group) in groupby(newlist, keyfunc3)]\n",
      "\n        return [(key_, list(group))\n                for (key_, group) in groupby(newlist, keyfunc3)]\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sphinx/environment/adapters/indexentries.py b/sphinx/environment/adapters/indexentries.py\nindex 5af213932..b7dfff07c 100644\n--- a/sphinx/environment/adapters/indexentries.py\n+++ b/sphinx/environment/adapters/indexentries.py\n@@ -108,8 +108,13 @@ class IndexEntries:\n             lckey = unicodedata.normalize('NFD', key.lower())\n             if lckey.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                 lckey = lckey[1:]\n+\n             if lckey[0:1].isalpha() or lckey.startswith('_'):\n-                lckey = chr(127) + lckey\n+                # Keep alphabetic entries as-is for normal sorting\n+                pass\n+            else:\n+                # Add prefix to symbols to sort them at the front\n+                lckey = chr(0) + lckey\n             # ensure a determinstic order *within* letters by also sorting on\n             # the entry itself\n             return (lckey, entry[0])\n@@ -150,8 +155,13 @@ class IndexEntries:\n             key = unicodedata.normalize('NFD', entry[0].lower())\n             if key.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                 key = key[1:]\n+\n             if key[0:1].isalpha() or key.startswith('_'):\n-                key = chr(127) + key\n+                # Keep alphabetic entries as-is\n+                pass\n+            else:\n+                # Add prefix to symbols to sort them at the front\n+                key = chr(0) + key\n             return key\n \n         # group the entries by letter\n@@ -164,6 +174,7 @@ class IndexEntries:\n                 # now calculate the key\n                 if k.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                     k = k[1:]\n+\n                 letter = unicodedata.normalize('NFD', k[0])[0].upper()\n                 if letter.isalpha() or letter == '_':\n                     return letter\n@@ -172,5 +183,6 @@ class IndexEntries:\n                     return _('Symbols')\n             else:\n                 return v[2]\n+\n         return [(key_, list(group))\n                 for (key_, group) in groupby(newlist, keyfunc3)]\n",
    "variant_0": "diff --git a/sphinx/environment/adapters/indexentries.py b/sphinx/environment/adapters/indexentries.py\nindex 5af213932..2b0704b02 100644\n--- a/sphinx/environment/adapters/indexentries.py\n+++ b/sphinx/environment/adapters/indexentries.py\n@@ -100,6 +100,15 @@ class IndexEntries:\n \n         # sort the index entries; put all symbols at the front, even those\n         # following the letters in ASCII, this is where the chr(127) comes from\n+        def keyfunc(entry: Tuple[str, List]) -> Tuple[str, str]:\n+            key, (void, void, category_key) = entry\n+            if category_key:\n+                # using specified category key to sort\n+                key = category_key\n+            lckey = unicodedata.normalize('NFD', key.lower())\n+            if lckey.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n+                lckey = lckey[1:]\n+\n         def keyfunc(entry: Tuple[str, List]) -> Tuple[str, str]:\n             key, (void, void, category_key) = entry\n             if category_key:\n@@ -109,7 +118,11 @@ class IndexEntries:\n             if lckey.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                 lckey = lckey[1:]\n             if lckey[0:1].isalpha() or lckey.startswith('_'):\n-                lckey = chr(127) + lckey\n+                # Keep alphabetic entries as-is for normal sorting\n+                pass\n+            else:\n+                # Add prefix to symbols to sort them at the front\n+                lckey = chr(0) + lckey\n             # ensure a determinstic order *within* letters by also sorting on\n             # the entry itself\n             return (lckey, entry[0])\n@@ -145,15 +158,37 @@ class IndexEntries:\n                 oldsubitems = subitems\n                 i += 1\n \n+        # sort the sub-index entries\n+        def keyfunc2(entry: Tuple[str, List]) -> str:\n+            key = unicodedata.normalize('NFD', entry[0].lower())\n+            if key.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n+                key = key[1:]\n+\n         # sort the sub-index entries\n         def keyfunc2(entry: Tuple[str, List]) -> str:\n             key = unicodedata.normalize('NFD', entry[0].lower())\n             if key.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                 key = key[1:]\n             if key[0:1].isalpha() or key.startswith('_'):\n-                key = chr(127) + key\n+                # Keep alphabetic entries as-is\n+                pass\n+            else:\n+                # Add prefix to symbols to sort them at the front\n+                key = chr(0) + key\n+            return key\n             return key\n \n+        # group the entries by letter\n+        def keyfunc3(item: Tuple[str, List]) -> str:\n+            # hack: mutating the subitems dicts to a list in the keyfunc\n+            k, v = item\n+            v[1] = sorted(((si, se) for (si, (se, void, void)) in v[1].items()),\n+                          key=keyfunc2)\n+            if v[2] is None:\n+                # now calculate the key\n+                if k.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n+                    k = k[1:]\n+\n         # group the entries by letter\n         def keyfunc3(item: Tuple[str, List]) -> str:\n             # hack: mutating the subitems dicts to a list in the keyfunc\n@@ -172,5 +207,8 @@ class IndexEntries:\n                     return _('Symbols')\n             else:\n                 return v[2]\n+            else:\n+                return v[2]\n+\n         return [(key_, list(group))\n                 for (key_, group) in groupby(newlist, keyfunc3)]\n",
    "variant_1": "diff --git a/sphinx/environment/adapters/indexentries.py b/sphinx/environment/adapters/indexentries.py\nindex 5af213932..19b3cda39 100644\n--- a/sphinx/environment/adapters/indexentries.py\n+++ b/sphinx/environment/adapters/indexentries.py\n@@ -100,6 +100,15 @@ class IndexEntries:\n \n         # sort the index entries; put all symbols at the front, even those\n         # following the letters in ASCII, this is where the chr(127) comes from\n+        def keyfunc(entry: Tuple[str, List]) -> Tuple[str, str]:\n+            key, (void, void, category_key) = entry\n+            if category_key:\n+                # using specified category key to sort\n+                key = category_key\n+            lckey = unicodedata.normalize('NFD', key.lower())\n+            if lckey.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n+                lckey = lckey[1:]\n+\n         def keyfunc(entry: Tuple[str, List]) -> Tuple[str, str]:\n             key, (void, void, category_key) = entry\n             if category_key:\n@@ -109,7 +118,14 @@ class IndexEntries:\n             if lckey.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                 lckey = lckey[1:]\n             if lckey[0:1].isalpha() or lckey.startswith('_'):\n-                lckey = chr(127) + lckey\n+                # Keep alphabetic entries as-is for normal sorting\n+                pass\n+            else:\n+                # Add prefix to symbols to sort them at the front\n+                lckey = chr(0) + lckey\n+            # ensure a determinstic order *within* letters by also sorting on\n+            # the entry itself\n+            return (lckey, entry[0])\n             # ensure a determinstic order *within* letters by also sorting on\n             # the entry itself\n             return (lckey, entry[0])\n@@ -145,15 +161,37 @@ class IndexEntries:\n                 oldsubitems = subitems\n                 i += 1\n \n+        # sort the sub-index entries\n+        def keyfunc2(entry: Tuple[str, List]) -> str:\n+            key = unicodedata.normalize('NFD', entry[0].lower())\n+            if key.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n+                key = key[1:]\n+\n         # sort the sub-index entries\n         def keyfunc2(entry: Tuple[str, List]) -> str:\n             key = unicodedata.normalize('NFD', entry[0].lower())\n             if key.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                 key = key[1:]\n             if key[0:1].isalpha() or key.startswith('_'):\n-                key = chr(127) + key\n+                # Keep alphabetic entries as-is for normal sorting\n+                pass\n+            else:\n+                # Add prefix to symbols to sort them at the front\n+                key = chr(0) + key\n+            return key\n             return key\n \n+        # group the entries by letter\n+        def keyfunc3(item: Tuple[str, List]) -> str:\n+            # hack: mutating the subitems dicts to a list in the keyfunc\n+            k, v = item\n+            v[1] = sorted(((si, se) for (si, (se, void, void)) in v[1].items()),\n+                          key=keyfunc2)\n+            if v[2] is None:\n+                # now calculate the key\n+                if k.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n+                    k = k[1:]\n+\n         # group the entries by letter\n         def keyfunc3(item: Tuple[str, List]) -> str:\n             # hack: mutating the subitems dicts to a list in the keyfunc\n@@ -172,5 +210,8 @@ class IndexEntries:\n                     return _('Symbols')\n             else:\n                 return v[2]\n+            else:\n+                return v[2]\n+\n         return [(key_, list(group))\n                 for (key_, group) in groupby(newlist, keyfunc3)]\n",
    "variant_2": "diff --git a/sphinx/environment/adapters/indexentries.py b/sphinx/environment/adapters/indexentries.py\nindex 5af213932..173238722 100644\n--- a/sphinx/environment/adapters/indexentries.py\n+++ b/sphinx/environment/adapters/indexentries.py\n@@ -108,8 +108,20 @@ class IndexEntries:\n             lckey = unicodedata.normalize('NFD', key.lower())\n             if lckey.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                 lckey = lckey[1:]\n-            if lckey[0:1].isalpha() or lckey.startswith('_'):\n-                lckey = chr(127) + lckey\n+\n+        def keyfunc(entry: Tuple[str, List]) -> Tuple[str, str]:\n+            key, (void, void, category_key) = entry\n+            if category_key:\n+                # using specified category key to sort\n+                key = category_key\n+            lckey = unicodedata.normalize('NFD', key.lower())\n+            if lckey.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n+                lckey = lckey[1:]\n+            if not (lckey[0:1].isalpha() or lckey.startswith('_')):\n+                lckey = chr(0) + lckey\n+            # ensure a determinstic order *within* letters by also sorting on\n+            # the entry itself\n+            return (lckey, entry[0])\n             # ensure a determinstic order *within* letters by also sorting on\n             # the entry itself\n             return (lckey, entry[0])\n@@ -145,15 +157,37 @@ class IndexEntries:\n                 oldsubitems = subitems\n                 i += 1\n \n+        # sort the sub-index entries\n+        def keyfunc2(entry: Tuple[str, List]) -> str:\n+            key = unicodedata.normalize('NFD', entry[0].lower())\n+            if key.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n+                key = key[1:]\n+\n         # sort the sub-index entries\n         def keyfunc2(entry: Tuple[str, List]) -> str:\n             key = unicodedata.normalize('NFD', entry[0].lower())\n             if key.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                 key = key[1:]\n             if key[0:1].isalpha() or key.startswith('_'):\n-                key = chr(127) + key\n+                # Keep alphabetic entries as-is\n+                pass\n+            else:\n+                # Add prefix to symbols to sort them at the front\n+                key = chr(0) + key\n+            return key\n             return key\n \n+        # group the entries by letter\n+        def keyfunc3(item: Tuple[str, List]) -> str:\n+            # hack: mutating the subitems dicts to a list in the keyfunc\n+            k, v = item\n+            v[1] = sorted(((si, se) for (si, (se, void, void)) in v[1].items()),\n+                          key=keyfunc2)\n+            if v[2] is None:\n+                # now calculate the key\n+                if k.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n+                    k = k[1:]\n+\n         # group the entries by letter\n         def keyfunc3(item: Tuple[str, List]) -> str:\n             # hack: mutating the subitems dicts to a list in the keyfunc\n@@ -172,5 +206,8 @@ class IndexEntries:\n                     return _('Symbols')\n             else:\n                 return v[2]\n+            else:\n+                return v[2]\n+\n         return [(key_, list(group))\n                 for (key_, group) in groupby(newlist, keyfunc3)]\n",
    "variant_3": "diff --git a/sphinx/environment/adapters/indexentries.py b/sphinx/environment/adapters/indexentries.py\nindex 5af213932..2907f0efb 100644\n--- a/sphinx/environment/adapters/indexentries.py\n+++ b/sphinx/environment/adapters/indexentries.py\n@@ -108,8 +108,13 @@ class IndexEntries:\n             lckey = unicodedata.normalize('NFD', key.lower())\n             if lckey.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                 lckey = lckey[1:]\n+\n             if lckey[0:1].isalpha() or lckey.startswith('_'):\n-                lckey = chr(127) + lckey\n+                # Keep alphabetic entries as-is for normal sorting\n+                pass\n+            else:\n+                # Add prefix to symbols to sort them at the front\n+                lckey = chr(0) + lckey\n             # ensure a determinstic order *within* letters by also sorting on\n             # the entry itself\n             return (lckey, entry[0])\n@@ -145,14 +150,36 @@ class IndexEntries:\n                 oldsubitems = subitems\n                 i += 1\n \n+        # sort the sub-index entries\n+        def keyfunc2(entry: Tuple[str, List]) -> str:\n+            key = unicodedata.normalize('NFD', entry[0].lower())\n+            if key.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n+                key = key[1:]\n+\n         # sort the sub-index entries\n         def keyfunc2(entry: Tuple[str, List]) -> str:\n             key = unicodedata.normalize('NFD', entry[0].lower())\n             if key.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                 key = key[1:]\n             if key[0:1].isalpha() or key.startswith('_'):\n-                key = chr(127) + key\n+                # Keep alphabetic entries as-is for normal sorting\n+                pass\n+            else:\n+                # Add prefix to symbols to sort them at the front\n+                key = chr(0) + key\n             return key\n+            return key\n+\n+        # group the entries by letter\n+        def keyfunc3(item: Tuple[str, List]) -> str:\n+            # hack: mutating the subitems dicts to a list in the keyfunc\n+            k, v = item\n+            v[1] = sorted(((si, se) for (si, (se, void, void)) in v[1].items()),\n+                          key=keyfunc2)\n+            if v[2] is None:\n+                # now calculate the key\n+                if k.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n+                    k = k[1:]\n \n         # group the entries by letter\n         def keyfunc3(item: Tuple[str, List]) -> str:\n@@ -172,5 +199,8 @@ class IndexEntries:\n                     return _('Symbols')\n             else:\n                 return v[2]\n+            else:\n+                return v[2]\n+\n         return [(key_, list(group))\n                 for (key_, group) in groupby(newlist, keyfunc3)]\n",
    "variant_4": "diff --git a/sphinx/environment/adapters/indexentries.py b/sphinx/environment/adapters/indexentries.py\nindex 5af213932..4195535ff 100644\n--- a/sphinx/environment/adapters/indexentries.py\n+++ b/sphinx/environment/adapters/indexentries.py\n@@ -108,8 +108,13 @@ class IndexEntries:\n             lckey = unicodedata.normalize('NFD', key.lower())\n             if lckey.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                 lckey = lckey[1:]\n+\n             if lckey[0:1].isalpha() or lckey.startswith('_'):\n-                lckey = chr(127) + lckey\n+                # Keep alphabetic entries as-is for normal sorting\n+                pass\n+            else:\n+                # Add prefix to symbols to sort them at the front\n+                lckey = chr(0) + lckey\n             # ensure a determinstic order *within* letters by also sorting on\n             # the entry itself\n             return (lckey, entry[0])\n@@ -145,14 +150,36 @@ class IndexEntries:\n                 oldsubitems = subitems\n                 i += 1\n \n+        # sort the sub-index entries\n+        def keyfunc2(entry: Tuple[str, List]) -> str:\n+            key = unicodedata.normalize('NFD', entry[0].lower())\n+            if key.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n+                key = key[1:]\n+\n         # sort the sub-index entries\n         def keyfunc2(entry: Tuple[str, List]) -> str:\n             key = unicodedata.normalize('NFD', entry[0].lower())\n             if key.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                 key = key[1:]\n             if key[0:1].isalpha() or key.startswith('_'):\n-                key = chr(127) + key\n+                # Keep alphabetic entries as-is\n+                pass\n+            else:\n+                # Add prefix to symbols to sort them at the front\n+                key = chr(0) + key\n             return key\n+            return key\n+\n+        # group the entries by letter\n+        def keyfunc3(item: Tuple[str, List]) -> str:\n+            # hack: mutating the subitems dicts to a list in the keyfunc\n+            k, v = item\n+            v[1] = sorted(((si, se) for (si, (se, void, void)) in v[1].items()),\n+                          key=keyfunc2)\n+            if v[2] is None:\n+                # now calculate the key\n+                if k.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n+                    k = k[1:]\n \n         # group the entries by letter\n         def keyfunc3(item: Tuple[str, List]) -> str:\n@@ -172,5 +199,8 @@ class IndexEntries:\n                     return _('Symbols')\n             else:\n                 return v[2]\n+            else:\n+                return v[2]\n+\n         return [(key_, list(group))\n                 for (key_, group) in groupby(newlist, keyfunc3)]\n",
    "variant_5": "diff --git a/sphinx/environment/adapters/indexentries.py b/sphinx/environment/adapters/indexentries.py\nindex 5af213932..7f37134b8 100644\n--- a/sphinx/environment/adapters/indexentries.py\n+++ b/sphinx/environment/adapters/indexentries.py\n@@ -100,6 +100,15 @@ class IndexEntries:\n \n         # sort the index entries; put all symbols at the front, even those\n         # following the letters in ASCII, this is where the chr(127) comes from\n+        def keyfunc(entry: Tuple[str, List]) -> Tuple[str, str]:\n+            key, (void, void, category_key) = entry\n+            if category_key:\n+                # using specified category key to sort\n+                key = category_key\n+            lckey = unicodedata.normalize('NFD', key.lower())\n+            if lckey.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n+                lckey = lckey[1:]\n+\n         def keyfunc(entry: Tuple[str, List]) -> Tuple[str, str]:\n             key, (void, void, category_key) = entry\n             if category_key:\n@@ -109,7 +118,14 @@ class IndexEntries:\n             if lckey.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                 lckey = lckey[1:]\n             if lckey[0:1].isalpha() or lckey.startswith('_'):\n-                lckey = chr(127) + lckey\n+                # Keep alphabetic entries as-is for normal sorting\n+                pass\n+            else:\n+                # Add prefix to symbols to sort them at the front\n+                lckey = chr(0) + lckey\n+            # ensure a determinstic order *within* letters by also sorting on\n+            # the entry itself\n+            return (lckey, entry[0])\n             # ensure a determinstic order *within* letters by also sorting on\n             # the entry itself\n             return (lckey, entry[0])\n@@ -145,15 +161,37 @@ class IndexEntries:\n                 oldsubitems = subitems\n                 i += 1\n \n+        # sort the sub-index entries\n+        def keyfunc2(entry: Tuple[str, List]) -> str:\n+            key = unicodedata.normalize('NFD', entry[0].lower())\n+            if key.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n+                key = key[1:]\n+\n         # sort the sub-index entries\n         def keyfunc2(entry: Tuple[str, List]) -> str:\n             key = unicodedata.normalize('NFD', entry[0].lower())\n             if key.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                 key = key[1:]\n             if key[0:1].isalpha() or key.startswith('_'):\n-                key = chr(127) + key\n+                # Keep alphabetic entries as-is\n+                pass\n+            else:\n+                # Add prefix to symbols to sort them at the front\n+                key = chr(0) + key\n+            return key\n             return key\n \n+        # group the entries by letter\n+        def keyfunc3(item: Tuple[str, List]) -> str:\n+            # hack: mutating the subitems dicts to a list in the keyfunc\n+            k, v = item\n+            v[1] = sorted(((si, se) for (si, (se, void, void)) in v[1].items()),\n+                          key=keyfunc2)\n+            if v[2] is None:\n+                # now calculate the key\n+                if k.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n+                    k = k[1:]\n+\n         # group the entries by letter\n         def keyfunc3(item: Tuple[str, List]) -> str:\n             # hack: mutating the subitems dicts to a list in the keyfunc\n@@ -172,5 +210,8 @@ class IndexEntries:\n                     return _('Symbols')\n             else:\n                 return v[2]\n+            else:\n+                return v[2]\n+\n         return [(key_, list(group))\n                 for (key_, group) in groupby(newlist, keyfunc3)]\n",
    "variant_6": "diff --git a/sphinx/environment/adapters/indexentries.py b/sphinx/environment/adapters/indexentries.py\nindex 5af213932..19b3cda39 100644\n--- a/sphinx/environment/adapters/indexentries.py\n+++ b/sphinx/environment/adapters/indexentries.py\n@@ -100,6 +100,15 @@ class IndexEntries:\n \n         # sort the index entries; put all symbols at the front, even those\n         # following the letters in ASCII, this is where the chr(127) comes from\n+        def keyfunc(entry: Tuple[str, List]) -> Tuple[str, str]:\n+            key, (void, void, category_key) = entry\n+            if category_key:\n+                # using specified category key to sort\n+                key = category_key\n+            lckey = unicodedata.normalize('NFD', key.lower())\n+            if lckey.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n+                lckey = lckey[1:]\n+\n         def keyfunc(entry: Tuple[str, List]) -> Tuple[str, str]:\n             key, (void, void, category_key) = entry\n             if category_key:\n@@ -109,7 +118,14 @@ class IndexEntries:\n             if lckey.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                 lckey = lckey[1:]\n             if lckey[0:1].isalpha() or lckey.startswith('_'):\n-                lckey = chr(127) + lckey\n+                # Keep alphabetic entries as-is for normal sorting\n+                pass\n+            else:\n+                # Add prefix to symbols to sort them at the front\n+                lckey = chr(0) + lckey\n+            # ensure a determinstic order *within* letters by also sorting on\n+            # the entry itself\n+            return (lckey, entry[0])\n             # ensure a determinstic order *within* letters by also sorting on\n             # the entry itself\n             return (lckey, entry[0])\n@@ -145,15 +161,37 @@ class IndexEntries:\n                 oldsubitems = subitems\n                 i += 1\n \n+        # sort the sub-index entries\n+        def keyfunc2(entry: Tuple[str, List]) -> str:\n+            key = unicodedata.normalize('NFD', entry[0].lower())\n+            if key.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n+                key = key[1:]\n+\n         # sort the sub-index entries\n         def keyfunc2(entry: Tuple[str, List]) -> str:\n             key = unicodedata.normalize('NFD', entry[0].lower())\n             if key.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                 key = key[1:]\n             if key[0:1].isalpha() or key.startswith('_'):\n-                key = chr(127) + key\n+                # Keep alphabetic entries as-is for normal sorting\n+                pass\n+            else:\n+                # Add prefix to symbols to sort them at the front\n+                key = chr(0) + key\n+            return key\n             return key\n \n+        # group the entries by letter\n+        def keyfunc3(item: Tuple[str, List]) -> str:\n+            # hack: mutating the subitems dicts to a list in the keyfunc\n+            k, v = item\n+            v[1] = sorted(((si, se) for (si, (se, void, void)) in v[1].items()),\n+                          key=keyfunc2)\n+            if v[2] is None:\n+                # now calculate the key\n+                if k.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n+                    k = k[1:]\n+\n         # group the entries by letter\n         def keyfunc3(item: Tuple[str, List]) -> str:\n             # hack: mutating the subitems dicts to a list in the keyfunc\n@@ -172,5 +210,8 @@ class IndexEntries:\n                     return _('Symbols')\n             else:\n                 return v[2]\n+            else:\n+                return v[2]\n+\n         return [(key_, list(group))\n                 for (key_, group) in groupby(newlist, keyfunc3)]\n",
    "variant_7": "diff --git a/sphinx/environment/adapters/indexentries.py b/sphinx/environment/adapters/indexentries.py\nindex 5af213932..7f37134b8 100644\n--- a/sphinx/environment/adapters/indexentries.py\n+++ b/sphinx/environment/adapters/indexentries.py\n@@ -100,6 +100,15 @@ class IndexEntries:\n \n         # sort the index entries; put all symbols at the front, even those\n         # following the letters in ASCII, this is where the chr(127) comes from\n+        def keyfunc(entry: Tuple[str, List]) -> Tuple[str, str]:\n+            key, (void, void, category_key) = entry\n+            if category_key:\n+                # using specified category key to sort\n+                key = category_key\n+            lckey = unicodedata.normalize('NFD', key.lower())\n+            if lckey.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n+                lckey = lckey[1:]\n+\n         def keyfunc(entry: Tuple[str, List]) -> Tuple[str, str]:\n             key, (void, void, category_key) = entry\n             if category_key:\n@@ -109,7 +118,14 @@ class IndexEntries:\n             if lckey.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                 lckey = lckey[1:]\n             if lckey[0:1].isalpha() or lckey.startswith('_'):\n-                lckey = chr(127) + lckey\n+                # Keep alphabetic entries as-is for normal sorting\n+                pass\n+            else:\n+                # Add prefix to symbols to sort them at the front\n+                lckey = chr(0) + lckey\n+            # ensure a determinstic order *within* letters by also sorting on\n+            # the entry itself\n+            return (lckey, entry[0])\n             # ensure a determinstic order *within* letters by also sorting on\n             # the entry itself\n             return (lckey, entry[0])\n@@ -145,15 +161,37 @@ class IndexEntries:\n                 oldsubitems = subitems\n                 i += 1\n \n+        # sort the sub-index entries\n+        def keyfunc2(entry: Tuple[str, List]) -> str:\n+            key = unicodedata.normalize('NFD', entry[0].lower())\n+            if key.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n+                key = key[1:]\n+\n         # sort the sub-index entries\n         def keyfunc2(entry: Tuple[str, List]) -> str:\n             key = unicodedata.normalize('NFD', entry[0].lower())\n             if key.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                 key = key[1:]\n             if key[0:1].isalpha() or key.startswith('_'):\n-                key = chr(127) + key\n+                # Keep alphabetic entries as-is\n+                pass\n+            else:\n+                # Add prefix to symbols to sort them at the front\n+                key = chr(0) + key\n+            return key\n             return key\n \n+        # group the entries by letter\n+        def keyfunc3(item: Tuple[str, List]) -> str:\n+            # hack: mutating the subitems dicts to a list in the keyfunc\n+            k, v = item\n+            v[1] = sorted(((si, se) for (si, (se, void, void)) in v[1].items()),\n+                          key=keyfunc2)\n+            if v[2] is None:\n+                # now calculate the key\n+                if k.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n+                    k = k[1:]\n+\n         # group the entries by letter\n         def keyfunc3(item: Tuple[str, List]) -> str:\n             # hack: mutating the subitems dicts to a list in the keyfunc\n@@ -172,5 +210,8 @@ class IndexEntries:\n                     return _('Symbols')\n             else:\n                 return v[2]\n+            else:\n+                return v[2]\n+\n         return [(key_, list(group))\n                 for (key_, group) in groupby(newlist, keyfunc3)]\n",
    "variant_8": "diff --git a/sphinx/environment/adapters/indexentries.py b/sphinx/environment/adapters/indexentries.py\nindex 5af213932..2b0704b02 100644\n--- a/sphinx/environment/adapters/indexentries.py\n+++ b/sphinx/environment/adapters/indexentries.py\n@@ -100,6 +100,15 @@ class IndexEntries:\n \n         # sort the index entries; put all symbols at the front, even those\n         # following the letters in ASCII, this is where the chr(127) comes from\n+        def keyfunc(entry: Tuple[str, List]) -> Tuple[str, str]:\n+            key, (void, void, category_key) = entry\n+            if category_key:\n+                # using specified category key to sort\n+                key = category_key\n+            lckey = unicodedata.normalize('NFD', key.lower())\n+            if lckey.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n+                lckey = lckey[1:]\n+\n         def keyfunc(entry: Tuple[str, List]) -> Tuple[str, str]:\n             key, (void, void, category_key) = entry\n             if category_key:\n@@ -109,7 +118,11 @@ class IndexEntries:\n             if lckey.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                 lckey = lckey[1:]\n             if lckey[0:1].isalpha() or lckey.startswith('_'):\n-                lckey = chr(127) + lckey\n+                # Keep alphabetic entries as-is for normal sorting\n+                pass\n+            else:\n+                # Add prefix to symbols to sort them at the front\n+                lckey = chr(0) + lckey\n             # ensure a determinstic order *within* letters by also sorting on\n             # the entry itself\n             return (lckey, entry[0])\n@@ -145,15 +158,37 @@ class IndexEntries:\n                 oldsubitems = subitems\n                 i += 1\n \n+        # sort the sub-index entries\n+        def keyfunc2(entry: Tuple[str, List]) -> str:\n+            key = unicodedata.normalize('NFD', entry[0].lower())\n+            if key.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n+                key = key[1:]\n+\n         # sort the sub-index entries\n         def keyfunc2(entry: Tuple[str, List]) -> str:\n             key = unicodedata.normalize('NFD', entry[0].lower())\n             if key.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n                 key = key[1:]\n             if key[0:1].isalpha() or key.startswith('_'):\n-                key = chr(127) + key\n+                # Keep alphabetic entries as-is\n+                pass\n+            else:\n+                # Add prefix to symbols to sort them at the front\n+                key = chr(0) + key\n+            return key\n             return key\n \n+        # group the entries by letter\n+        def keyfunc3(item: Tuple[str, List]) -> str:\n+            # hack: mutating the subitems dicts to a list in the keyfunc\n+            k, v = item\n+            v[1] = sorted(((si, se) for (si, (se, void, void)) in v[1].items()),\n+                          key=keyfunc2)\n+            if v[2] is None:\n+                # now calculate the key\n+                if k.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n+                    k = k[1:]\n+\n         # group the entries by letter\n         def keyfunc3(item: Tuple[str, List]) -> str:\n             # hack: mutating the subitems dicts to a list in the keyfunc\n@@ -172,5 +207,8 @@ class IndexEntries:\n                     return _('Symbols')\n             else:\n                 return v[2]\n+            else:\n+                return v[2]\n+\n         return [(key_, list(group))\n                 for (key_, group) in groupby(newlist, keyfunc3)]\n"
  }
}