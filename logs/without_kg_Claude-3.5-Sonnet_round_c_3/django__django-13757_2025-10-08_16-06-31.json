{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/django/django/db/models/fields/json.py lines 368-371)": "\nclass KeyTransformIsNull(lookups.IsNull):\n    # key__isnull=False is the same as has_key='key'\n    def as_oracle(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n        else:\n            # For isnull=True, check that the key doesn't exist (not just that it's null)\n            lhs, lhs_params = self.process_lhs(compiler, connection)\n            key_name = self.lhs.key_name\n            return \"NOT JSON_EXISTS(%s, '$.%s')\" % (lhs, key_name), lhs_params\n\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        else:\n            # For isnull=True, check that the key doesn't exist (not just that it's null)\n            lhs, lhs_params = self.process_lhs(compiler, connection)\n            key_name = self.lhs.key_name\n            return \"JSON_TYPE(%s, '$.%s') IS NULL\" % (lhs, key_name), lhs_params\n",
    "Location 2 (/root/hy/projects_3/django/django/db/models/fields/json.py lines 373-376)": "\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        else:\n            # For isnull=True, check that the key doesn't exist (not just that it's null)\n            lhs, lhs_params = self.process_lhs(compiler, connection)\n            rhs, rhs_params = self.process_rhs(compiler, connection)\n            key_name = self.lhs.key_name\n            return 'JSON_TYPE(%s, %%s) IS NULL' % lhs, lhs_params + [key_name]\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/django/django/db/models/fields/json.py lines 368-371)": [
      "\nclass KeyTransformIsNull(lookups.IsNull):\n    # key__isnull=False is the same as has_key='key'\n    def as_oracle(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n        else:\n            # For isnull=True, check that the key doesn't exist (inverse of HasKey)\n            lhs, lhs_params = self.process_lhs(compiler, connection)\n            key_name = self.lhs.key_name\n            return 'NOT JSON_EXISTS(%s, \\'$.%s\\')' % (lhs, key_name), lhs_params\n\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        else:\n            # For isnull=True, check that the key doesn't exist (inverse of HasKey)\n            lhs, lhs_params = self.process_lhs(compiler, connection)\n            key_name = self.lhs.key_name\n            return 'JSON_TYPE(%s, \\'$.%s\\') IS NULL' % (lhs, key_name), lhs_params\n",
      "\nclass KeyTransformIsNull(lookups.IsNull):\n    # key__isnull=False is the same as has_key='key'\n    def as_oracle(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n        else:\n            # For isnull=True, check that the key doesn't exist (inverse of HasKey)\n            lhs, lhs_params = self.process_lhs(compiler, connection)\n            key_name = self.lhs.key_name\n            return \"NOT JSON_EXISTS(%s, '$.%s')\" % (lhs, key_name), lhs_params\n\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        else:\n            # For isnull=True, check that the key doesn't exist (inverse of HasKey)\n            lhs, lhs_params = self.process_lhs(compiler, connection)\n            key_name = self.lhs.key_name\n            return \"JSON_TYPE(%s, '$.%s') IS NULL\" % (lhs, key_name), lhs_params\n",
      "\nclass KeyTransformIsNull(lookups.IsNull):\n    # key__isnull=False is the same as has_key='key'\n    def as_oracle(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n        else:\n            # For isnull=True, check that the key doesn't exist (inverse of HasKey)\n            lhs, lhs_params, key_transforms = self.lhs.preprocess_lhs(compiler, connection)\n            json_path = compile_json_path(key_transforms)\n            return 'NOT JSON_EXISTS(%s, %%s)' % lhs, lhs_params + [json_path]\n\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        else:\n            # For isnull=True, check that the key doesn't exist (inverse of HasKey)\n            lhs, lhs_params, key_transforms = self.lhs.preprocess_lhs(compiler, connection)\n            json_path = compile_json_path(key_transforms)\n            return 'JSON_TYPE(%s, %%s) IS NULL' % lhs, lhs_params + [json_path]\n",
      "\nclass KeyTransformIsNull(lookups.IsNull):\n    # key__isnull=False is the same as has_key='key'\n    def as_oracle(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n        else:\n            # For isnull=True, check that the key doesn't exist (inverse of HasKey)\n            lhs, lhs_params = self.process_lhs(compiler, connection)\n            key_name = self.lhs.key_name\n            return \"NOT JSON_EXISTS(%s, '$.%s')\" % (lhs, key_name), lhs_params\n\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        else:\n            # For isnull=True, check that the key doesn't exist (inverse of HasKey)\n            lhs, lhs_params = self.process_lhs(compiler, connection)\n            key_name = self.lhs.key_name\n            return \"JSON_TYPE(%s, '$.%s') IS NULL\" % (lhs, key_name), lhs_params\n",
      "\nclass KeyTransformIsNull(lookups.IsNull):\n    # key__isnull=False is the same as has_key='key'\n    def as_oracle(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n        else:\n            # For isnull=True, check that the key doesn't exist (inverse of HasKey)\n            lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n            json_path = compile_json_path([key_name], include_root=False)\n            return 'NOT JSON_EXISTS(%s, %%s)' % lhs, lhs_params + [json_path]\n\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        else:\n            # For isnull=True, check that the key doesn't exist (inverse of HasKey)\n            lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n            json_path = compile_json_path([key_name])\n            return 'JSON_TYPE(%s, %%s) IS NULL' % lhs, lhs_params + [json_path]\n",
      "\nclass KeyTransformIsNull(lookups.IsNull):\n    # key__isnull=False is the same as has_key='key'\n    def as_oracle(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n        else:\n            # For isnull=True, check that the key doesn't exist (inverse of HasKey)\n            lhs, lhs_params = self.process_lhs(compiler, connection)\n            key_name = self.lhs.key_name\n            return \"NOT JSON_EXISTS(%s, '$.%s')\" % (lhs, key_name), lhs_params\n\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        else:\n            # For isnull=True, check that the key doesn't exist (inverse of HasKey)\n            lhs, lhs_params = self.process_lhs(compiler, connection)\n            key_name = self.lhs.key_name\n            return \"JSON_TYPE(%s, '$.%s') IS NULL\" % (lhs, key_name), lhs_params\n",
      "\nclass KeyTransformIsNull(lookups.IsNull):\n    # key__isnull=False is the same as has_key='key'\n    def as_oracle(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n        else:\n            # For isnull=True, check that the key doesn't exist (inverse of HasKey)\n            lhs, lhs_params = self.process_lhs(compiler, connection)\n            key_name = self.lhs.key_name\n            return \"NOT JSON_EXISTS(%s, '$.%s')\" % (lhs, key_name), lhs_params\n\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        else:\n            # For isnull=True, check that the key doesn't exist (inverse of HasKey)\n            lhs, lhs_params = self.process_lhs(compiler, connection)\n            key_name = self.lhs.key_name\n            return \"JSON_TYPE(%s, '$.%s') IS NULL\" % (lhs, key_name), lhs_params\n",
      "\n    def as_oracle(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n        else:\n            # For isnull=True, check that the key doesn't exist (inverse of HasKey)\n            lhs, lhs_params = self.process_lhs(compiler, connection)\n            key_name = self.lhs.key_name\n            return 'NOT JSON_EXISTS(%s, \\'$.%s\\')' % (lhs, key_name), lhs_params\n"
    ],
    "Location 2 (/root/hy/projects_3/django/django/db/models/fields/json.py lines 373-376)": [
      "\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        else:\n            # For isnull=True, check that the key doesn't exist (not just that it's null)\n            # Use JSON_TYPE to distinguish between non-existent keys and null values\n            lhs, lhs_params = self.process_lhs(compiler, connection)\n            key_name = self.lhs.key_name\n            return f\"JSON_TYPE({lhs}, %s) IS NULL\", lhs_params + [f'$.{key_name}']\n",
      "\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        else:\n            # For isnull=True, check that the key doesn't exist (not that it exists with null value)\n            lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n            json_path = compile_json_path([key_name])\n            return 'JSON_TYPE(%s, %%s) IS NULL' % lhs, lhs_params + [json_path]\n",
      "\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        else:\n            # For isnull=True, check that the key doesn't exist (not just that it's null)\n            template = 'JSON_TYPE(%s, %%s) IS NULL'\n            sql, params = self.lhs.lhs.as_sql(compiler, connection)\n            params.append(self.lhs.compile_json_path(compiler, connection))\n            return template % sql, params\n",
      "\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        else:\n            # For isnull=True, check that the key doesn't exist (not just that it's null)\n            # Use JSON_TYPE to distinguish between non-existent keys and null values\n            lhs, lhs_params = self.process_lhs(compiler, connection)\n            key_name = self.lhs.key_name\n            return f\"JSON_TYPE({lhs}, %s) IS NULL\", lhs_params + [f'$.{key_name}']\n",
      "\n    def as_oracle(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n        else:\n            # For isnull=True, check that the key doesn't exist (inverse of HasKey)\n            lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n            json_path = compile_json_path([key_name], include_root=False)\n            return 'NOT JSON_EXISTS(%s, %%s)' % lhs, lhs_params + [json_path]\n\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        else:\n            # For isnull=True, check that the key doesn't exist (inverse of HasKey)\n            lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n            json_path = compile_json_path([key_name])\n            return 'JSON_TYPE(%s, %%s) IS NULL' % lhs, lhs_params + [json_path]\n",
      "\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        else:\n            # For isnull=True, check that the key doesn't exist (not just that it's null)\n            # Use JSON_TYPE which returns NULL for non-existent keys\n            lhs, lhs_params = self.process_lhs(compiler, connection)\n            key_name = self.lhs.key_name\n            return 'JSON_TYPE(%s, %%s) IS NULL' % lhs, lhs_params + [key_name]\n",
      "\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        else:\n            # For isnull=True, check that the key doesn't exist (not just that it's null)\n            # Use JSON_TYPE IS NULL to check for key non-existence\n            template = 'JSON_TYPE(%s, %%s) IS NULL'\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection, template)\n",
      "\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        else:\n            # For isnull=True, check that the key doesn't exist (not just that it's null)\n            lhs, lhs_params = self.process_lhs(compiler, connection)\n            key_name = self.lhs.key_name\n            return f\"JSON_TYPE({lhs}, %s) IS NULL\", lhs_params + [f'$.{key_name}']\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex 29c6ff0926..80e9e4c5b4 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -365,15 +365,38 @@ class CaseInsensitiveMixin:\n \n class KeyTransformIsNull(lookups.IsNull):\n     # key__isnull=False is the same as has_key='key'\n+\n     def as_oracle(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        else:\n+            # For isnull=True, check that the key does not exist\n+            # Use the inverse of HasKey logic: NOT JSON_EXISTS\n+            lhs, lhs_params = self.process_lhs(compiler, connection)\n+            if isinstance(self.lhs, KeyTransform):\n+                *_, key_transforms = self.lhs.preprocess_lhs(compiler, connection)\n+                json_path = compile_json_path(key_transforms)\n+            else:\n+                json_path = '$'\n+            # Oracle requires path expressions to be embedded directly in SQL\n+            sql = 'NOT JSON_EXISTS(%s, \\'%s\\')' % (lhs, json_path)\n+            return sql, lhs_params\n+\n \n     def as_sqlite(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        else:\n+            # For isnull=True, check that the key does not exist\n+            # Use the inverse of HasKey logic: JSON_TYPE IS NULL\n+            lhs, lhs_params = self.process_lhs(compiler, connection)\n+            if isinstance(self.lhs, KeyTransform):\n+                *_, key_transforms = self.lhs.preprocess_lhs(compiler, connection)\n+                json_path = compile_json_path(key_transforms)\n+            else:\n+                json_path = '$'\n+            sql = 'JSON_TYPE(%s, %%s) IS NULL' % lhs\n+            return sql, lhs_params + (json_path,)\n \n \n class KeyTransformIn(lookups.In):\n",
    "variant_0": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex 29c6ff0926..71573a88e7 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -363,17 +363,39 @@ class CaseInsensitiveMixin:\n         return rhs, rhs_params\n \n \n+class KeyTransformIsNull(lookups.IsNull):\n+    # key__isnull=False is the same as has_key='key'\n+\n class KeyTransformIsNull(lookups.IsNull):\n     # key__isnull=False is the same as has_key='key'\n     def as_oracle(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        else:\n+            # For isnull=True, check that the key doesn't exist (not just that it's null)\n+            lhs, lhs_params = self.process_lhs(compiler, connection)\n+            key_name = self.lhs.key_name\n+            return \"NOT JSON_EXISTS(%s, '$.%s')\" % (lhs, key_name), lhs_params\n \n     def as_sqlite(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        else:\n+            # For isnull=True, check that the key doesn't exist (not just that it's null)\n+            lhs, lhs_params = self.process_lhs(compiler, connection)\n+            key_name = self.lhs.key_name\n+            return \"JSON_TYPE(%s, '$.%s') IS NULL\" % (lhs, key_name), lhs_params\n+\n+\n+    def as_sqlite(self, compiler, connection):\n+        if not self.rhs:\n+            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n+        else:\n+            # For isnull=True, check that the key doesn't exist (not just that it's null)\n+            lhs, lhs_params = self.process_lhs(compiler, connection)\n+            rhs, rhs_params = self.process_rhs(compiler, connection)\n+            key_name = self.lhs.key_name\n+            return 'JSON_TYPE(%s, %%s) IS NULL' % lhs, lhs_params + [key_name]\n \n \n class KeyTransformIn(lookups.In):\n",
    "variant_1": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex 29c6ff0926..9f8c4ad2b8 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -363,17 +363,39 @@ class CaseInsensitiveMixin:\n         return rhs, rhs_params\n \n \n+class KeyTransformIsNull(lookups.IsNull):\n+    # key__isnull=False is the same as has_key='key'\n+\n class KeyTransformIsNull(lookups.IsNull):\n     # key__isnull=False is the same as has_key='key'\n     def as_oracle(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        else:\n+            # For isnull=True, check that the key doesn't exist (inverse of HasKey)\n+            lhs, lhs_params = self.process_lhs(compiler, connection)\n+            key_name = self.lhs.key_name\n+            return 'NOT JSON_EXISTS(%s, \\'$.%s\\')' % (lhs, key_name), lhs_params\n \n     def as_sqlite(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        else:\n+            # For isnull=True, check that the key doesn't exist (inverse of HasKey)\n+            lhs, lhs_params = self.process_lhs(compiler, connection)\n+            key_name = self.lhs.key_name\n+            return 'JSON_TYPE(%s, \\'$.%s\\') IS NULL' % (lhs, key_name), lhs_params\n+\n+\n+    def as_sqlite(self, compiler, connection):\n+        if not self.rhs:\n+            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n+        else:\n+            # For isnull=True, check that the key doesn't exist (not just that it's null)\n+            # Use JSON_TYPE to distinguish between non-existent keys and null values\n+            lhs, lhs_params = self.process_lhs(compiler, connection)\n+            key_name = self.lhs.key_name\n+            return f\"JSON_TYPE({lhs}, %s) IS NULL\", lhs_params + [f'$.{key_name}']\n \n \n class KeyTransformIn(lookups.In):\n",
    "variant_2": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex 29c6ff0926..54f33fef4a 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -363,17 +363,38 @@ class CaseInsensitiveMixin:\n         return rhs, rhs_params\n \n \n+class KeyTransformIsNull(lookups.IsNull):\n+    # key__isnull=False is the same as has_key='key'\n+\n class KeyTransformIsNull(lookups.IsNull):\n     # key__isnull=False is the same as has_key='key'\n     def as_oracle(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        else:\n+            # For isnull=True, check that the key doesn't exist (inverse of HasKey)\n+            lhs, lhs_params = self.process_lhs(compiler, connection)\n+            key_name = self.lhs.key_name\n+            return \"NOT JSON_EXISTS(%s, '$.%s')\" % (lhs, key_name), lhs_params\n \n     def as_sqlite(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        else:\n+            # For isnull=True, check that the key doesn't exist (inverse of HasKey)\n+            lhs, lhs_params = self.process_lhs(compiler, connection)\n+            key_name = self.lhs.key_name\n+            return \"JSON_TYPE(%s, '$.%s') IS NULL\" % (lhs, key_name), lhs_params\n+\n+\n+    def as_sqlite(self, compiler, connection):\n+        if not self.rhs:\n+            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n+        else:\n+            # For isnull=True, check that the key doesn't exist (not that it exists with null value)\n+            lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n+            json_path = compile_json_path([key_name])\n+            return 'JSON_TYPE(%s, %%s) IS NULL' % lhs, lhs_params + [json_path]\n \n \n class KeyTransformIn(lookups.In):\n",
    "variant_3": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex 29c6ff0926..fcf4cabbec 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -363,17 +363,39 @@ class CaseInsensitiveMixin:\n         return rhs, rhs_params\n \n \n+class KeyTransformIsNull(lookups.IsNull):\n+    # key__isnull=False is the same as has_key='key'\n+\n class KeyTransformIsNull(lookups.IsNull):\n     # key__isnull=False is the same as has_key='key'\n     def as_oracle(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        else:\n+            # For isnull=True, check that the key doesn't exist (inverse of HasKey)\n+            lhs, lhs_params, key_transforms = self.lhs.preprocess_lhs(compiler, connection)\n+            json_path = compile_json_path(key_transforms)\n+            return 'NOT JSON_EXISTS(%s, %%s)' % lhs, lhs_params + [json_path]\n \n     def as_sqlite(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        else:\n+            # For isnull=True, check that the key doesn't exist (inverse of HasKey)\n+            lhs, lhs_params, key_transforms = self.lhs.preprocess_lhs(compiler, connection)\n+            json_path = compile_json_path(key_transforms)\n+            return 'JSON_TYPE(%s, %%s) IS NULL' % lhs, lhs_params + [json_path]\n+\n+\n+    def as_sqlite(self, compiler, connection):\n+        if not self.rhs:\n+            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n+        else:\n+            # For isnull=True, check that the key doesn't exist (not just that it's null)\n+            template = 'JSON_TYPE(%s, %%s) IS NULL'\n+            sql, params = self.lhs.lhs.as_sql(compiler, connection)\n+            params.append(self.lhs.compile_json_path(compiler, connection))\n+            return template % sql, params\n \n \n class KeyTransformIn(lookups.In):\n",
    "variant_4": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex 29c6ff0926..7b3c1d28ad 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -363,17 +363,39 @@ class CaseInsensitiveMixin:\n         return rhs, rhs_params\n \n \n+class KeyTransformIsNull(lookups.IsNull):\n+    # key__isnull=False is the same as has_key='key'\n+\n class KeyTransformIsNull(lookups.IsNull):\n     # key__isnull=False is the same as has_key='key'\n     def as_oracle(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        else:\n+            # For isnull=True, check that the key doesn't exist (inverse of HasKey)\n+            lhs, lhs_params = self.process_lhs(compiler, connection)\n+            key_name = self.lhs.key_name\n+            return \"NOT JSON_EXISTS(%s, '$.%s')\" % (lhs, key_name), lhs_params\n \n     def as_sqlite(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        else:\n+            # For isnull=True, check that the key doesn't exist (inverse of HasKey)\n+            lhs, lhs_params = self.process_lhs(compiler, connection)\n+            key_name = self.lhs.key_name\n+            return \"JSON_TYPE(%s, '$.%s') IS NULL\" % (lhs, key_name), lhs_params\n+\n+\n+    def as_sqlite(self, compiler, connection):\n+        if not self.rhs:\n+            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n+        else:\n+            # For isnull=True, check that the key doesn't exist (not just that it's null)\n+            # Use JSON_TYPE to distinguish between non-existent keys and null values\n+            lhs, lhs_params = self.process_lhs(compiler, connection)\n+            key_name = self.lhs.key_name\n+            return f\"JSON_TYPE({lhs}, %s) IS NULL\", lhs_params + [f'$.{key_name}']\n \n \n class KeyTransformIn(lookups.In):\n",
    "variant_5": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex 29c6ff0926..c8a61a0c69 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -363,17 +363,47 @@ class CaseInsensitiveMixin:\n         return rhs, rhs_params\n \n \n+class KeyTransformIsNull(lookups.IsNull):\n+    # key__isnull=False is the same as has_key='key'\n+\n class KeyTransformIsNull(lookups.IsNull):\n     # key__isnull=False is the same as has_key='key'\n     def as_oracle(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        else:\n+            # For isnull=True, check that the key doesn't exist (inverse of HasKey)\n+            lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n+            json_path = compile_json_path([key_name], include_root=False)\n+            return 'NOT JSON_EXISTS(%s, %%s)' % lhs, lhs_params + [json_path]\n \n     def as_sqlite(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        else:\n+            # For isnull=True, check that the key doesn't exist (inverse of HasKey)\n+            lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n+            json_path = compile_json_path([key_name])\n+            return 'JSON_TYPE(%s, %%s) IS NULL' % lhs, lhs_params + [json_path]\n+\n+\n+    def as_oracle(self, compiler, connection):\n+        if not self.rhs:\n+            return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n+        else:\n+            # For isnull=True, check that the key doesn't exist (inverse of HasKey)\n+            lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n+            json_path = compile_json_path([key_name], include_root=False)\n+            return 'NOT JSON_EXISTS(%s, %%s)' % lhs, lhs_params + [json_path]\n+\n+    def as_sqlite(self, compiler, connection):\n+        if not self.rhs:\n+            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n+        else:\n+            # For isnull=True, check that the key doesn't exist (inverse of HasKey)\n+            lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n+            json_path = compile_json_path([key_name])\n+            return 'JSON_TYPE(%s, %%s) IS NULL' % lhs, lhs_params + [json_path]\n \n \n class KeyTransformIn(lookups.In):\n",
    "variant_6": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex 29c6ff0926..4fe8b4c9f1 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -363,17 +363,39 @@ class CaseInsensitiveMixin:\n         return rhs, rhs_params\n \n \n+class KeyTransformIsNull(lookups.IsNull):\n+    # key__isnull=False is the same as has_key='key'\n+\n class KeyTransformIsNull(lookups.IsNull):\n     # key__isnull=False is the same as has_key='key'\n     def as_oracle(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        else:\n+            # For isnull=True, check that the key doesn't exist (inverse of HasKey)\n+            lhs, lhs_params = self.process_lhs(compiler, connection)\n+            key_name = self.lhs.key_name\n+            return \"NOT JSON_EXISTS(%s, '$.%s')\" % (lhs, key_name), lhs_params\n \n     def as_sqlite(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        else:\n+            # For isnull=True, check that the key doesn't exist (inverse of HasKey)\n+            lhs, lhs_params = self.process_lhs(compiler, connection)\n+            key_name = self.lhs.key_name\n+            return \"JSON_TYPE(%s, '$.%s') IS NULL\" % (lhs, key_name), lhs_params\n+\n+\n+    def as_sqlite(self, compiler, connection):\n+        if not self.rhs:\n+            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n+        else:\n+            # For isnull=True, check that the key doesn't exist (not just that it's null)\n+            # Use JSON_TYPE which returns NULL for non-existent keys\n+            lhs, lhs_params = self.process_lhs(compiler, connection)\n+            key_name = self.lhs.key_name\n+            return 'JSON_TYPE(%s, %%s) IS NULL' % lhs, lhs_params + [key_name]\n \n \n class KeyTransformIn(lookups.In):\n",
    "variant_7": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex 29c6ff0926..5763b781cb 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -363,17 +363,38 @@ class CaseInsensitiveMixin:\n         return rhs, rhs_params\n \n \n+class KeyTransformIsNull(lookups.IsNull):\n+    # key__isnull=False is the same as has_key='key'\n+\n class KeyTransformIsNull(lookups.IsNull):\n     # key__isnull=False is the same as has_key='key'\n     def as_oracle(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        else:\n+            # For isnull=True, check that the key doesn't exist (inverse of HasKey)\n+            lhs, lhs_params = self.process_lhs(compiler, connection)\n+            key_name = self.lhs.key_name\n+            return \"NOT JSON_EXISTS(%s, '$.%s')\" % (lhs, key_name), lhs_params\n \n     def as_sqlite(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        else:\n+            # For isnull=True, check that the key doesn't exist (inverse of HasKey)\n+            lhs, lhs_params = self.process_lhs(compiler, connection)\n+            key_name = self.lhs.key_name\n+            return \"JSON_TYPE(%s, '$.%s') IS NULL\" % (lhs, key_name), lhs_params\n+\n+\n+    def as_sqlite(self, compiler, connection):\n+        if not self.rhs:\n+            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n+        else:\n+            # For isnull=True, check that the key doesn't exist (not just that it's null)\n+            # Use JSON_TYPE IS NULL to check for key non-existence\n+            template = 'JSON_TYPE(%s, %%s) IS NULL'\n+            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection, template)\n \n \n class KeyTransformIn(lookups.In):\n",
    "variant_8": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex 29c6ff0926..76715e452e 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -365,15 +365,25 @@ class CaseInsensitiveMixin:\n \n class KeyTransformIsNull(lookups.IsNull):\n     # key__isnull=False is the same as has_key='key'\n+\n     def as_oracle(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        else:\n+            # For isnull=True, check that the key doesn't exist (inverse of HasKey)\n+            lhs, lhs_params = self.process_lhs(compiler, connection)\n+            key_name = self.lhs.key_name\n+            return 'NOT JSON_EXISTS(%s, \\'$.%s\\')' % (lhs, key_name), lhs_params\n+\n \n     def as_sqlite(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        else:\n+            # For isnull=True, check that the key doesn't exist (not just that it's null)\n+            lhs, lhs_params = self.process_lhs(compiler, connection)\n+            key_name = self.lhs.key_name\n+            return f\"JSON_TYPE({lhs}, %s) IS NULL\", lhs_params + [f'$.{key_name}']\n \n \n class KeyTransformIn(lookups.In):\n"
  }
}