{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/django/django/urls/resolvers.py lines 48-53)": "\n        # Unwrap functools.partial objects to get the actual function\n        original_func = func\n        while isinstance(original_func, functools.partial):\n            original_func = original_func.func\n\n        if not hasattr(original_func, '__name__'):\n            # A class-based view\n            self._func_path = original_func.__class__.__module__ + '.' + original_func.__class__.__name__\n        else:\n            # A function-based view\n            self._func_path = original_func.__module__ + '.' + original_func.__name__\n",
    "Location 2 (/root/hy/projects_3/django/tests/urlpatterns_reverse/tests.py lines 1140-1146)": "\n    def __init__(self, func, args, kwargs, url_name=None, app_names=None, namespaces=None, route=None, tried=None):\n        self.func = func\n        self.args = args\n        self.kwargs = kwargs\n        self.url_name = url_name\n        self.route = route\n        self.tried = tried\n        self.app_names = app_names or []\n        self.app_name = ':'.join(self.app_names)\n        self.namespaces = namespaces or []\n        self.namespace = ':'.join(self.namespaces)\n\n        # Unwrap functools.partial objects to get the actual function\n        actual_func = func\n        while isinstance(actual_func, functools.partial):\n            actual_func = actual_func.func\n\n        if not hasattr(actual_func, '__name__'):\n            # If it's a class-based view or similar, use the class name\n            self._func_path = actual_func.__class__.__module__ + '.' + actual_func.__class__.__name__\n        else:\n            # It's a function-based view\n            self._func_path = actual_func.__module__ + '.' + actual_func.__name__\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/django/django/urls/resolvers.py lines 48-53)": [
      "\n        # Unwrap functools.partial objects to get the original function\n        original_func = func\n        while isinstance(original_func, functools.partial):\n            original_func = original_func.func\n\n        if not hasattr(original_func, '__name__'):\n            # A class-based view\n            self._func_path = original_func.__class__.__module__ + '.' + original_func.__class__.__name__\n        else:\n            # A function-based view\n            self._func_path = original_func.__module__ + '.' + original_func.__name__\n",
      "\n        # Unwrap functools.partial objects to get the actual function\n        actual_func = func\n        while isinstance(actual_func, functools.partial):\n            actual_func = actual_func.func\n\n        if not hasattr(actual_func, '__name__'):\n            # A class-based view\n            self._func_path = actual_func.__class__.__module__ + '.' + actual_func.__class__.__name__\n        else:\n            # A function-based view\n            self._func_path = actual_func.__module__ + '.' + actual_func.__name__\n",
      "\n        # Unwrap functools.partial objects to get the underlying function\n        unwrapped_func = func\n        while isinstance(unwrapped_func, functools.partial):\n            unwrapped_func = unwrapped_func.func\n\n        if not hasattr(unwrapped_func, '__name__'):\n            # A class-based view\n            self._func_path = unwrapped_func.__class__.__module__ + '.' + unwrapped_func.__class__.__name__\n        else:\n            # A function-based view\n            self._func_path = unwrapped_func.__module__ + '.' + unwrapped_func.__name__\n",
      "\n        if isinstance(func, functools.partial):\n            # Unwrap functools.partial to get the actual function\n            actual_func = func\n            while isinstance(actual_func, functools.partial):\n                actual_func = actual_func.func\n            self._func_path = actual_func.__module__ + '.' + actual_func.__name__\n        elif not hasattr(func, '__name__'):\n            # A class-based view\n            self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__\n        else:\n            # A function-based view\n            self._func_path = func.__module__ + '.' + func.__name__\n",
      "\n        if isinstance(func, functools.partial):\n            # Unwrap functools.partial to get the actual function\n            unwrapped_func = func\n            while isinstance(unwrapped_func, functools.partial):\n                unwrapped_func = unwrapped_func.func\n            \n            if not hasattr(unwrapped_func, '__name__'):\n                # A class-based view\n                self._func_path = unwrapped_func.__class__.__module__ + '.' + unwrapped_func.__class__.__name__\n            else:\n                # A function-based view\n                self._func_path = unwrapped_func.__module__ + '.' + unwrapped_func.__name__\n        elif not hasattr(func, '__name__'):\n            # A class-based view\n            self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__\n        else:\n            # A function-based view\n            self._func_path = func.__module__ + '.' + func.__name__\n",
      "\n        # Unwrap functools.partial objects to get the actual function\n        actual_func = func\n        while isinstance(actual_func, functools.partial):\n            actual_func = actual_func.func\n\n        if not hasattr(actual_func, '__name__'):\n            # A class-based view\n            self._func_path = actual_func.__class__.__module__ + '.' + actual_func.__class__.__name__\n        else:\n            # A function-based view\n            self._func_path = actual_func.__module__ + '.' + actual_func.__name__\n",
      "\n        # Unwrap functools.partial objects to get the actual function\n        actual_func = func\n        while isinstance(actual_func, functools.partial):\n            actual_func = actual_func.func\n\n        if not hasattr(actual_func, '__name__'):\n            # A class-based view\n            self._func_path = actual_func.__class__.__module__ + '.' + actual_func.__class__.__name__\n        else:\n            # A function-based view\n            self._func_path = actual_func.__module__ + '.' + actual_func.__name__\n",
      "\n        # Unwrap functools.partial objects to get the original function\n        original_func = func\n        while isinstance(original_func, functools.partial):\n            original_func = original_func.func\n\n        if not hasattr(original_func, '__name__'):\n            # A class-based view\n            self._func_path = original_func.__class__.__module__ + '.' + original_func.__class__.__name__\n        else:\n            # A function-based view\n            self._func_path = original_func.__module__ + '.' + original_func.__name__\n"
    ],
    "Location 2 (/root/hy/projects_3/django/tests/urlpatterns_reverse/tests.py lines 1140-1146)": [
      "\ndef test_repr(self):\n    self.assertEqual(\n        repr(resolve('/no_kwargs/42/37/')),\n        \"ResolverMatch(func=urlpatterns_reverse.views.empty_view, \"\n        \"args=('42', '37'), kwargs={}, url_name=no-kwargs, app_names=[], \"\n        \"namespaces=[], route=^no_kwargs/([0-9]+)/([0-9]+)/$)\",\n    )\n    \n    # Test that partial functions show the underlying function in repr\n    from functools import partial\n    from .views import empty_view\n    \n    # Test simple partial\n    empty_view_partial = partial(empty_view)\n    self.assertEqual(\n        repr(resolve('/partial_view/42/')),\n        \"ResolverMatch(func=urlpatterns_reverse.views.empty_view, \"\n        \"args=('42',), kwargs={}, url_name=partial-view, app_names=[], \"\n        \"namespaces=[], route=^partial_view/([0-9]+)/$)\",\n    )\n    \n    # Test nested partial\n    empty_view_nested_partial = partial(partial(empty_view))\n    self.assertEqual(\n        repr(resolve('/nested_partial_view/42/')),\n        \"ResolverMatch(func=urlpatterns_reverse.views.empty_view, \"\n        \"args=('42',), kwargs={}, url_name=nested-partial-view, app_names=[], \"\n        \"namespaces=[], route=^nested_partial_view/([0-9]+)/$)\",\n    )\n",
      "\n    def test_repr(self):\n        self.assertEqual(\n            repr(resolve('/no_kwargs/42/37/')),\n            \"ResolverMatch(func=urlpatterns_reverse.views.empty_view, \"\n            \"args=('42', '37'), kwargs={}, url_name=no-kwargs, app_names=[], \"\n            \"namespaces=[], route=^no_kwargs/([0-9]+)/([0-9]+)/$)\",\n        )\n        # Test partial function representation\n        self.assertEqual(\n            repr(resolve('/partial/')),\n            \"ResolverMatch(func=urlpatterns_reverse.views.empty_view, \"\n            \"args=(), kwargs={}, url_name=partial, app_names=[], \"\n            \"namespaces=[], route=^partial/$)\",\n        )\n        # Test nested partial function representation\n        self.assertEqual(\n            repr(resolve('/nested_partial/')),\n            \"ResolverMatch(func=urlpatterns_reverse.views.empty_view, \"\n            \"args=(), kwargs={}, url_name=nested-partial, app_names=[], \"\n            \"namespaces=[], route=^nested_partial/$)\",\n        )\n        # Test wrapped partial function representation\n        self.assertEqual(\n            repr(resolve('/wrapped_partial/')),\n            \"ResolverMatch(func=urlpatterns_reverse.views.empty_view, \"\n            \"args=(), kwargs={}, url_name=wrapped-partial, app_names=[], \"\n            \"namespaces=[], route=^wrapped_partial/$)\",\n        )\n",
      "\n    def __init__(self, func, args, kwargs, url_name=None, app_names=None, namespaces=None, route=None, tried=None):\n        self.func = func\n        self.args = args\n        self.kwargs = kwargs\n        self.url_name = url_name\n        self.route = route\n        self.tried = tried\n        self.app_names = app_names or []\n        self.app_name = ':'.join(self.app_names)\n        self.namespaces = namespaces or []\n        self.namespace = ':'.join(self.namespaces)\n\n        # Unwrap functools.partial objects to get the original function\n        unwrapped_func = func\n        while isinstance(unwrapped_func, functools.partial):\n            unwrapped_func = unwrapped_func.func\n\n        if not hasattr(unwrapped_func, '__name__'):\n            # The view has a __call__ method.\n            self._func_path = unwrapped_func.__class__.__module__ + '.' + unwrapped_func.__class__.__name__\n        else:\n            self._func_path = unwrapped_func.__module__ + '.' + unwrapped_func.__name__\n\n        view_path = url_name or self._func_path\n        self.view_name = ':'.join(self.namespaces + [view_path])\n",
      "\n    def __init__(self, func, args, kwargs, url_name=None, app_names=None, namespaces=None, route=None):\n        self.func = func\n        self.args = args\n        self.kwargs = kwargs\n        self.url_name = url_name\n        self.route = route\n\n        # Unwrap functools.partial to get the original function\n        unwrapped_func = func\n        while isinstance(unwrapped_func, functools.partial):\n            unwrapped_func = unwrapped_func.func\n\n        if not hasattr(unwrapped_func, '__name__'):\n            # CBV\n            self._func_path = unwrapped_func.__class__.__module__ + '.' + unwrapped_func.__class__.__name__\n        else:\n            # FBV\n            self._func_path = unwrapped_func.__module__ + '.' + unwrapped_func.__name__\n\n        view_path = url_name or self._func_path\n        self.view_name = ':'.join(self.namespaces + [view_path])\n        self.app_names = [] if app_names is None else app_names\n        self.app_name = ':'.join(app_names) if app_names else None\n        self.namespaces = [] if namespaces is None else namespaces\n        self.namespace = ':'.join(namespaces) if namespaces else None\n\n    @cached_property\n    def app_names(self):\n        return [x.app_name for x in self.tried if x.app_name is not None]\n\n    @cached_property\n    def namespaces(self):\n        return [x.namespace for x in self.tried if x.namespace is not None]\n",
      "\n    def __init__(self, func, args, kwargs, url_name=None, app_names=None, namespaces=None, route=None, tried=None):\n        self.func = func\n        self.args = args\n        self.kwargs = kwargs\n        self.url_name = url_name\n        self.route = route\n        self.tried = tried\n        self.app_names = app_names or []\n        self.app_name = ':'.join(self.app_names)\n        self.namespaces = namespaces or []\n        self.namespace = ':'.join(self.namespaces)\n\n        # Unwrap functools.partial objects to get the underlying function\n        unwrapped_func = func\n        while isinstance(unwrapped_func, functools.partial):\n            unwrapped_func = unwrapped_func.func\n\n        if not hasattr(unwrapped_func, '__name__'):\n            # If it's a callable object, try to get the class\n            if hasattr(unwrapped_func, '__class__'):\n                self._func_path = unwrapped_func.__class__.__module__ + '.' + unwrapped_func.__class__.__name__\n            else:\n                self._func_path = repr(unwrapped_func)\n        else:\n            self._func_path = unwrapped_func.__module__ + '.' + unwrapped_func.__name__\n",
      "\n    def __init__(self, func, args, kwargs, url_name=None, app_names=None, namespaces=None, route=None, tried=None):\n        self.func = func\n        self.args = args\n        self.kwargs = kwargs\n        self.url_name = url_name\n        self.route = route\n        self.tried = tried\n        self.app_names = app_names or []\n        self.app_name = ':'.join(self.app_names)\n        self.namespaces = namespaces or []\n        self.namespace = ':'.join(self.namespaces)\n\n        # Unwrap functools.partial objects to get the underlying function\n        unwrapped_func = func\n        while isinstance(unwrapped_func, functools.partial):\n            unwrapped_func = unwrapped_func.func\n\n        if not hasattr(unwrapped_func, '__name__'):\n            # We can't reverse this view, so it's a class-based view.\n            self._func_path = unwrapped_func.__class__.__module__ + '.' + unwrapped_func.__class__.__name__\n        else:\n            self._func_path = unwrapped_func.__module__ + '.' + unwrapped_func.__name__\n\n        view_path = url_name or self._func_path\n        self.view_name = ':'.join(self.namespaces + [view_path])\n",
      "\n    def __init__(self, func, args, kwargs, url_name=None, app_names=None, namespaces=None, route=None, tried=None):\n        self.func = func\n        self.args = args\n        self.kwargs = kwargs\n        self.url_name = url_name\n        self.route = route\n        self.tried = tried\n        self.app_names = app_names or []\n        self.app_name = ':'.join(self.app_names)\n        self.namespaces = namespaces or []\n        self.namespace = ':'.join(self.namespaces)\n\n        # Unwrap functools.partial objects to get the actual function\n        actual_func = func\n        while isinstance(actual_func, functools.partial):\n            actual_func = actual_func.func\n\n        if not hasattr(actual_func, '__name__'):\n            # CBV\n            self._func_path = actual_func.__class__.__module__ + '.' + actual_func.__class__.__name__\n        else:\n            # FBV\n            self._func_path = actual_func.__module__ + '.' + actual_func.__name__\n",
      "\n    def __init__(self, func, args, kwargs, url_name=None, app_names=None, namespaces=None, route=None, tried=None):\n        self.func = func\n        self.args = args\n        self.kwargs = kwargs\n        self.url_name = url_name\n        self.route = route\n        self.tried = tried\n        self.app_names = app_names or []\n        self.app_name = ':'.join(self.app_names)\n        self.namespaces = namespaces or []\n        self.namespace = ':'.join(self.namespaces)\n\n        # Unwrap functools.partial objects to get the actual function\n        unwrapped_func = func\n        while isinstance(unwrapped_func, functools.partial):\n            unwrapped_func = unwrapped_func.func\n\n        if not hasattr(unwrapped_func, '__name__'):\n            # If it's a callable object, try to get the class\n            klass = unwrapped_func.__class__\n            self._func_path = klass.__module__ + '.' + klass.__name__\n        else:\n            self._func_path = unwrapped_func.__module__ + '.' + unwrapped_func.__name__\n\n        view_name = url_name or self._func_path\n        self.view_name = ':'.join(self.namespaces + [view_name])\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/urls/resolvers.py b/django/urls/resolvers.py\nindex 9b00e24509..57abb4b97d 100644\n--- a/django/urls/resolvers.py\n+++ b/django/urls/resolvers.py\n@@ -45,12 +45,18 @@ class ResolverMatch:\n         self.namespaces = [x for x in namespaces if x] if namespaces else []\n         self.namespace = ':'.join(self.namespaces)\n \n-        if not hasattr(func, '__name__'):\n+\n+        # Handle functools.partial objects by unwrapping them to get the original function\n+        original_func = func\n+        while isinstance(original_func, functools.partial):\n+            original_func = original_func.func\n+        \n+        if not hasattr(original_func, '__name__'):\n             # A class-based view\n-            self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__\n+            self._func_path = original_func.__class__.__module__ + '.' + original_func.__class__.__name__\n         else:\n             # A function-based view\n-            self._func_path = func.__module__ + '.' + func.__name__\n+            self._func_path = original_func.__module__ + '.' + original_func.__name__\n \n         view_path = url_name or self._func_path\n         self.view_name = ':'.join(self.namespaces + [view_path])\ndiff --git a/tests/urlpatterns_reverse/tests.py b/tests/urlpatterns_reverse/tests.py\nindex 09028be795..ca76cbf9be 100644\n--- a/tests/urlpatterns_reverse/tests.py\n+++ b/tests/urlpatterns_reverse/tests.py\n@@ -1137,6 +1137,7 @@ class ResolverMatchTests(SimpleTestCase):\n         request = HttpRequest()\n         self.assertIsNone(request.resolver_match)\n \n+\n     def test_repr(self):\n         self.assertEqual(\n             repr(resolve('/no_kwargs/42/37/')),\n@@ -1144,6 +1145,30 @@ class ResolverMatchTests(SimpleTestCase):\n             \"args=('42', '37'), kwargs={}, url_name=no-kwargs, app_names=[], \"\n             \"namespaces=[], route=^no_kwargs/([0-9]+)/([0-9]+)/$)\",\n         )\n+        \n+        # Test partial function representation\n+        self.assertEqual(\n+            repr(resolve('/partial/')),\n+            \"ResolverMatch(func=urlpatterns_reverse.views.empty_view, \"\n+            \"args=(), kwargs={}, url_name=partial, app_names=[], \"\n+            \"namespaces=[], route=partial/)\",\n+        )\n+        \n+        # Test nested partial function representation\n+        self.assertEqual(\n+            repr(resolve('/partial_nested/')),\n+            \"ResolverMatch(func=urlpatterns_reverse.views.empty_view, \"\n+            \"args=(), kwargs={}, url_name=partial_nested, app_names=[], \"\n+            \"namespaces=[], route=partial_nested/)\",\n+        )\n+        \n+        # Test wrapped partial function representation\n+        self.assertEqual(\n+            repr(resolve('/partial_wrapped/')),\n+            \"ResolverMatch(func=urlpatterns_reverse.views.empty_view, \"\n+            \"args=(), kwargs={}, url_name=partial_wrapped, app_names=[], \"\n+            \"namespaces=[], route=partial_wrapped/)\",\n+        )\n \n \n @override_settings(ROOT_URLCONF='urlpatterns_reverse.erroneous_urls')\n",
    "variant_0": "diff --git a/django/urls/resolvers.py b/django/urls/resolvers.py\nindex 9b00e24509..74cb8ff27c 100644\n--- a/django/urls/resolvers.py\n+++ b/django/urls/resolvers.py\n@@ -45,12 +45,18 @@ class ResolverMatch:\n         self.namespaces = [x for x in namespaces if x] if namespaces else []\n         self.namespace = ':'.join(self.namespaces)\n \n-        if not hasattr(func, '__name__'):\n+\n+        # Unwrap functools.partial objects to get the actual function\n+        original_func = func\n+        while isinstance(original_func, functools.partial):\n+            original_func = original_func.func\n+\n+        if not hasattr(original_func, '__name__'):\n             # A class-based view\n-            self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__\n+            self._func_path = original_func.__class__.__module__ + '.' + original_func.__class__.__name__\n         else:\n             # A function-based view\n-            self._func_path = func.__module__ + '.' + func.__name__\n+            self._func_path = original_func.__module__ + '.' + original_func.__name__\n \n         view_path = url_name or self._func_path\n         self.view_name = ':'.join(self.namespaces + [view_path])\ndiff --git a/tests/urlpatterns_reverse/tests.py b/tests/urlpatterns_reverse/tests.py\nindex 09028be795..70cdd03869 100644\n--- a/tests/urlpatterns_reverse/tests.py\n+++ b/tests/urlpatterns_reverse/tests.py\n@@ -1137,13 +1137,30 @@ class ResolverMatchTests(SimpleTestCase):\n         request = HttpRequest()\n         self.assertIsNone(request.resolver_match)\n \n-    def test_repr(self):\n-        self.assertEqual(\n-            repr(resolve('/no_kwargs/42/37/')),\n-            \"ResolverMatch(func=urlpatterns_reverse.views.empty_view, \"\n-            \"args=('42', '37'), kwargs={}, url_name=no-kwargs, app_names=[], \"\n-            \"namespaces=[], route=^no_kwargs/([0-9]+)/([0-9]+)/$)\",\n-        )\n+\n+    def __init__(self, func, args, kwargs, url_name=None, app_names=None, namespaces=None, route=None, tried=None):\n+        self.func = func\n+        self.args = args\n+        self.kwargs = kwargs\n+        self.url_name = url_name\n+        self.route = route\n+        self.tried = tried\n+        self.app_names = app_names or []\n+        self.app_name = ':'.join(self.app_names)\n+        self.namespaces = namespaces or []\n+        self.namespace = ':'.join(self.namespaces)\n+\n+        # Unwrap functools.partial objects to get the actual function\n+        actual_func = func\n+        while isinstance(actual_func, functools.partial):\n+            actual_func = actual_func.func\n+\n+        if not hasattr(actual_func, '__name__'):\n+            # If it's a class-based view or similar, use the class name\n+            self._func_path = actual_func.__class__.__module__ + '.' + actual_func.__class__.__name__\n+        else:\n+            # It's a function-based view\n+            self._func_path = actual_func.__module__ + '.' + actual_func.__name__\n \n \n @override_settings(ROOT_URLCONF='urlpatterns_reverse.erroneous_urls')\n",
    "variant_1": "diff --git a/django/urls/resolvers.py b/django/urls/resolvers.py\nindex 9b00e24509..4fa9edaf82 100644\n--- a/django/urls/resolvers.py\n+++ b/django/urls/resolvers.py\n@@ -45,12 +45,18 @@ class ResolverMatch:\n         self.namespaces = [x for x in namespaces if x] if namespaces else []\n         self.namespace = ':'.join(self.namespaces)\n \n-        if not hasattr(func, '__name__'):\n+\n+        # Unwrap functools.partial objects to get the original function\n+        original_func = func\n+        while isinstance(original_func, functools.partial):\n+            original_func = original_func.func\n+\n+        if not hasattr(original_func, '__name__'):\n             # A class-based view\n-            self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__\n+            self._func_path = original_func.__class__.__module__ + '.' + original_func.__class__.__name__\n         else:\n             # A function-based view\n-            self._func_path = func.__module__ + '.' + func.__name__\n+            self._func_path = original_func.__module__ + '.' + original_func.__name__\n \n         view_path = url_name or self._func_path\n         self.view_name = ':'.join(self.namespaces + [view_path])\ndiff --git a/tests/urlpatterns_reverse/tests.py b/tests/urlpatterns_reverse/tests.py\nindex 09028be795..d61a12ee6c 100644\n--- a/tests/urlpatterns_reverse/tests.py\n+++ b/tests/urlpatterns_reverse/tests.py\n@@ -1137,13 +1137,36 @@ class ResolverMatchTests(SimpleTestCase):\n         request = HttpRequest()\n         self.assertIsNone(request.resolver_match)\n \n-    def test_repr(self):\n-        self.assertEqual(\n-            repr(resolve('/no_kwargs/42/37/')),\n-            \"ResolverMatch(func=urlpatterns_reverse.views.empty_view, \"\n-            \"args=('42', '37'), kwargs={}, url_name=no-kwargs, app_names=[], \"\n-            \"namespaces=[], route=^no_kwargs/([0-9]+)/([0-9]+)/$)\",\n-        )\n+\n+def test_repr(self):\n+    self.assertEqual(\n+        repr(resolve('/no_kwargs/42/37/')),\n+        \"ResolverMatch(func=urlpatterns_reverse.views.empty_view, \"\n+        \"args=('42', '37'), kwargs={}, url_name=no-kwargs, app_names=[], \"\n+        \"namespaces=[], route=^no_kwargs/([0-9]+)/([0-9]+)/$)\",\n+    )\n+    \n+    # Test that partial functions show the underlying function in repr\n+    from functools import partial\n+    from .views import empty_view\n+    \n+    # Test simple partial\n+    empty_view_partial = partial(empty_view)\n+    self.assertEqual(\n+        repr(resolve('/partial_view/42/')),\n+        \"ResolverMatch(func=urlpatterns_reverse.views.empty_view, \"\n+        \"args=('42',), kwargs={}, url_name=partial-view, app_names=[], \"\n+        \"namespaces=[], route=^partial_view/([0-9]+)/$)\",\n+    )\n+    \n+    # Test nested partial\n+    empty_view_nested_partial = partial(partial(empty_view))\n+    self.assertEqual(\n+        repr(resolve('/nested_partial_view/42/')),\n+        \"ResolverMatch(func=urlpatterns_reverse.views.empty_view, \"\n+        \"args=('42',), kwargs={}, url_name=nested-partial-view, app_names=[], \"\n+        \"namespaces=[], route=^nested_partial_view/([0-9]+)/$)\",\n+    )\n \n \n @override_settings(ROOT_URLCONF='urlpatterns_reverse.erroneous_urls')\n",
    "variant_2": "diff --git a/django/urls/resolvers.py b/django/urls/resolvers.py\nindex 9b00e24509..85b8015589 100644\n--- a/django/urls/resolvers.py\n+++ b/django/urls/resolvers.py\n@@ -45,12 +45,18 @@ class ResolverMatch:\n         self.namespaces = [x for x in namespaces if x] if namespaces else []\n         self.namespace = ':'.join(self.namespaces)\n \n-        if not hasattr(func, '__name__'):\n+\n+        # Unwrap functools.partial objects to get the actual function\n+        actual_func = func\n+        while isinstance(actual_func, functools.partial):\n+            actual_func = actual_func.func\n+\n+        if not hasattr(actual_func, '__name__'):\n             # A class-based view\n-            self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__\n+            self._func_path = actual_func.__class__.__module__ + '.' + actual_func.__class__.__name__\n         else:\n             # A function-based view\n-            self._func_path = func.__module__ + '.' + func.__name__\n+            self._func_path = actual_func.__module__ + '.' + actual_func.__name__\n \n         view_path = url_name or self._func_path\n         self.view_name = ':'.join(self.namespaces + [view_path])\ndiff --git a/tests/urlpatterns_reverse/tests.py b/tests/urlpatterns_reverse/tests.py\nindex 09028be795..f9aa339704 100644\n--- a/tests/urlpatterns_reverse/tests.py\n+++ b/tests/urlpatterns_reverse/tests.py\n@@ -1137,6 +1137,7 @@ class ResolverMatchTests(SimpleTestCase):\n         request = HttpRequest()\n         self.assertIsNone(request.resolver_match)\n \n+\n     def test_repr(self):\n         self.assertEqual(\n             repr(resolve('/no_kwargs/42/37/')),\n@@ -1144,6 +1145,27 @@ class ResolverMatchTests(SimpleTestCase):\n             \"args=('42', '37'), kwargs={}, url_name=no-kwargs, app_names=[], \"\n             \"namespaces=[], route=^no_kwargs/([0-9]+)/([0-9]+)/$)\",\n         )\n+        # Test partial function representation\n+        self.assertEqual(\n+            repr(resolve('/partial/')),\n+            \"ResolverMatch(func=urlpatterns_reverse.views.empty_view, \"\n+            \"args=(), kwargs={}, url_name=partial, app_names=[], \"\n+            \"namespaces=[], route=^partial/$)\",\n+        )\n+        # Test nested partial function representation\n+        self.assertEqual(\n+            repr(resolve('/nested_partial/')),\n+            \"ResolverMatch(func=urlpatterns_reverse.views.empty_view, \"\n+            \"args=(), kwargs={}, url_name=nested-partial, app_names=[], \"\n+            \"namespaces=[], route=^nested_partial/$)\",\n+        )\n+        # Test wrapped partial function representation\n+        self.assertEqual(\n+            repr(resolve('/wrapped_partial/')),\n+            \"ResolverMatch(func=urlpatterns_reverse.views.empty_view, \"\n+            \"args=(), kwargs={}, url_name=wrapped-partial, app_names=[], \"\n+            \"namespaces=[], route=^wrapped_partial/$)\",\n+        )\n \n \n @override_settings(ROOT_URLCONF='urlpatterns_reverse.erroneous_urls')\n",
    "variant_3": "diff --git a/django/urls/resolvers.py b/django/urls/resolvers.py\nindex 9b00e24509..f40e262df6 100644\n--- a/django/urls/resolvers.py\n+++ b/django/urls/resolvers.py\n@@ -45,12 +45,18 @@ class ResolverMatch:\n         self.namespaces = [x for x in namespaces if x] if namespaces else []\n         self.namespace = ':'.join(self.namespaces)\n \n-        if not hasattr(func, '__name__'):\n+\n+        # Unwrap functools.partial objects to get the underlying function\n+        unwrapped_func = func\n+        while isinstance(unwrapped_func, functools.partial):\n+            unwrapped_func = unwrapped_func.func\n+\n+        if not hasattr(unwrapped_func, '__name__'):\n             # A class-based view\n-            self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__\n+            self._func_path = unwrapped_func.__class__.__module__ + '.' + unwrapped_func.__class__.__name__\n         else:\n             # A function-based view\n-            self._func_path = func.__module__ + '.' + func.__name__\n+            self._func_path = unwrapped_func.__module__ + '.' + unwrapped_func.__name__\n \n         view_path = url_name or self._func_path\n         self.view_name = ':'.join(self.namespaces + [view_path])\ndiff --git a/tests/urlpatterns_reverse/tests.py b/tests/urlpatterns_reverse/tests.py\nindex 09028be795..41e58a201f 100644\n--- a/tests/urlpatterns_reverse/tests.py\n+++ b/tests/urlpatterns_reverse/tests.py\n@@ -1137,13 +1137,32 @@ class ResolverMatchTests(SimpleTestCase):\n         request = HttpRequest()\n         self.assertIsNone(request.resolver_match)\n \n-    def test_repr(self):\n-        self.assertEqual(\n-            repr(resolve('/no_kwargs/42/37/')),\n-            \"ResolverMatch(func=urlpatterns_reverse.views.empty_view, \"\n-            \"args=('42', '37'), kwargs={}, url_name=no-kwargs, app_names=[], \"\n-            \"namespaces=[], route=^no_kwargs/([0-9]+)/([0-9]+)/$)\",\n-        )\n+\n+    def __init__(self, func, args, kwargs, url_name=None, app_names=None, namespaces=None, route=None, tried=None):\n+        self.func = func\n+        self.args = args\n+        self.kwargs = kwargs\n+        self.url_name = url_name\n+        self.route = route\n+        self.tried = tried\n+        self.app_names = app_names or []\n+        self.app_name = ':'.join(self.app_names)\n+        self.namespaces = namespaces or []\n+        self.namespace = ':'.join(self.namespaces)\n+\n+        # Unwrap functools.partial objects to get the original function\n+        unwrapped_func = func\n+        while isinstance(unwrapped_func, functools.partial):\n+            unwrapped_func = unwrapped_func.func\n+\n+        if not hasattr(unwrapped_func, '__name__'):\n+            # The view has a __call__ method.\n+            self._func_path = unwrapped_func.__class__.__module__ + '.' + unwrapped_func.__class__.__name__\n+        else:\n+            self._func_path = unwrapped_func.__module__ + '.' + unwrapped_func.__name__\n+\n+        view_path = url_name or self._func_path\n+        self.view_name = ':'.join(self.namespaces + [view_path])\n \n \n @override_settings(ROOT_URLCONF='urlpatterns_reverse.erroneous_urls')\n",
    "variant_4": "diff --git a/django/urls/resolvers.py b/django/urls/resolvers.py\nindex 9b00e24509..d5b58f2cbc 100644\n--- a/django/urls/resolvers.py\n+++ b/django/urls/resolvers.py\n@@ -45,7 +45,14 @@ class ResolverMatch:\n         self.namespaces = [x for x in namespaces if x] if namespaces else []\n         self.namespace = ':'.join(self.namespaces)\n \n-        if not hasattr(func, '__name__'):\n+\n+        if isinstance(func, functools.partial):\n+            # Unwrap functools.partial to get the actual function\n+            actual_func = func\n+            while isinstance(actual_func, functools.partial):\n+                actual_func = actual_func.func\n+            self._func_path = actual_func.__module__ + '.' + actual_func.__name__\n+        elif not hasattr(func, '__name__'):\n             # A class-based view\n             self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__\n         else:\ndiff --git a/tests/urlpatterns_reverse/tests.py b/tests/urlpatterns_reverse/tests.py\nindex 09028be795..b9c3850d1c 100644\n--- a/tests/urlpatterns_reverse/tests.py\n+++ b/tests/urlpatterns_reverse/tests.py\n@@ -1137,13 +1137,40 @@ class ResolverMatchTests(SimpleTestCase):\n         request = HttpRequest()\n         self.assertIsNone(request.resolver_match)\n \n-    def test_repr(self):\n-        self.assertEqual(\n-            repr(resolve('/no_kwargs/42/37/')),\n-            \"ResolverMatch(func=urlpatterns_reverse.views.empty_view, \"\n-            \"args=('42', '37'), kwargs={}, url_name=no-kwargs, app_names=[], \"\n-            \"namespaces=[], route=^no_kwargs/([0-9]+)/([0-9]+)/$)\",\n-        )\n+\n+    def __init__(self, func, args, kwargs, url_name=None, app_names=None, namespaces=None, route=None):\n+        self.func = func\n+        self.args = args\n+        self.kwargs = kwargs\n+        self.url_name = url_name\n+        self.route = route\n+\n+        # Unwrap functools.partial to get the original function\n+        unwrapped_func = func\n+        while isinstance(unwrapped_func, functools.partial):\n+            unwrapped_func = unwrapped_func.func\n+\n+        if not hasattr(unwrapped_func, '__name__'):\n+            # CBV\n+            self._func_path = unwrapped_func.__class__.__module__ + '.' + unwrapped_func.__class__.__name__\n+        else:\n+            # FBV\n+            self._func_path = unwrapped_func.__module__ + '.' + unwrapped_func.__name__\n+\n+        view_path = url_name or self._func_path\n+        self.view_name = ':'.join(self.namespaces + [view_path])\n+        self.app_names = [] if app_names is None else app_names\n+        self.app_name = ':'.join(app_names) if app_names else None\n+        self.namespaces = [] if namespaces is None else namespaces\n+        self.namespace = ':'.join(namespaces) if namespaces else None\n+\n+    @cached_property\n+    def app_names(self):\n+        return [x.app_name for x in self.tried if x.app_name is not None]\n+\n+    @cached_property\n+    def namespaces(self):\n+        return [x.namespace for x in self.tried if x.namespace is not None]\n \n \n @override_settings(ROOT_URLCONF='urlpatterns_reverse.erroneous_urls')\n",
    "variant_5": "diff --git a/django/urls/resolvers.py b/django/urls/resolvers.py\nindex 9b00e24509..9997fa82c4 100644\n--- a/django/urls/resolvers.py\n+++ b/django/urls/resolvers.py\n@@ -45,7 +45,20 @@ class ResolverMatch:\n         self.namespaces = [x for x in namespaces if x] if namespaces else []\n         self.namespace = ':'.join(self.namespaces)\n \n-        if not hasattr(func, '__name__'):\n+\n+        if isinstance(func, functools.partial):\n+            # Unwrap functools.partial to get the actual function\n+            unwrapped_func = func\n+            while isinstance(unwrapped_func, functools.partial):\n+                unwrapped_func = unwrapped_func.func\n+            \n+            if not hasattr(unwrapped_func, '__name__'):\n+                # A class-based view\n+                self._func_path = unwrapped_func.__class__.__module__ + '.' + unwrapped_func.__class__.__name__\n+            else:\n+                # A function-based view\n+                self._func_path = unwrapped_func.__module__ + '.' + unwrapped_func.__name__\n+        elif not hasattr(func, '__name__'):\n             # A class-based view\n             self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__\n         else:\ndiff --git a/tests/urlpatterns_reverse/tests.py b/tests/urlpatterns_reverse/tests.py\nindex 09028be795..ce3c0a68cb 100644\n--- a/tests/urlpatterns_reverse/tests.py\n+++ b/tests/urlpatterns_reverse/tests.py\n@@ -1137,13 +1137,32 @@ class ResolverMatchTests(SimpleTestCase):\n         request = HttpRequest()\n         self.assertIsNone(request.resolver_match)\n \n-    def test_repr(self):\n-        self.assertEqual(\n-            repr(resolve('/no_kwargs/42/37/')),\n-            \"ResolverMatch(func=urlpatterns_reverse.views.empty_view, \"\n-            \"args=('42', '37'), kwargs={}, url_name=no-kwargs, app_names=[], \"\n-            \"namespaces=[], route=^no_kwargs/([0-9]+)/([0-9]+)/$)\",\n-        )\n+\n+    def __init__(self, func, args, kwargs, url_name=None, app_names=None, namespaces=None, route=None, tried=None):\n+        self.func = func\n+        self.args = args\n+        self.kwargs = kwargs\n+        self.url_name = url_name\n+        self.route = route\n+        self.tried = tried\n+        self.app_names = app_names or []\n+        self.app_name = ':'.join(self.app_names)\n+        self.namespaces = namespaces or []\n+        self.namespace = ':'.join(self.namespaces)\n+\n+        # Unwrap functools.partial objects to get the underlying function\n+        unwrapped_func = func\n+        while isinstance(unwrapped_func, functools.partial):\n+            unwrapped_func = unwrapped_func.func\n+\n+        if not hasattr(unwrapped_func, '__name__'):\n+            # If it's a callable object, try to get the class\n+            if hasattr(unwrapped_func, '__class__'):\n+                self._func_path = unwrapped_func.__class__.__module__ + '.' + unwrapped_func.__class__.__name__\n+            else:\n+                self._func_path = repr(unwrapped_func)\n+        else:\n+            self._func_path = unwrapped_func.__module__ + '.' + unwrapped_func.__name__\n \n \n @override_settings(ROOT_URLCONF='urlpatterns_reverse.erroneous_urls')\n",
    "variant_6": "diff --git a/django/urls/resolvers.py b/django/urls/resolvers.py\nindex 9b00e24509..85b8015589 100644\n--- a/django/urls/resolvers.py\n+++ b/django/urls/resolvers.py\n@@ -45,12 +45,18 @@ class ResolverMatch:\n         self.namespaces = [x for x in namespaces if x] if namespaces else []\n         self.namespace = ':'.join(self.namespaces)\n \n-        if not hasattr(func, '__name__'):\n+\n+        # Unwrap functools.partial objects to get the actual function\n+        actual_func = func\n+        while isinstance(actual_func, functools.partial):\n+            actual_func = actual_func.func\n+\n+        if not hasattr(actual_func, '__name__'):\n             # A class-based view\n-            self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__\n+            self._func_path = actual_func.__class__.__module__ + '.' + actual_func.__class__.__name__\n         else:\n             # A function-based view\n-            self._func_path = func.__module__ + '.' + func.__name__\n+            self._func_path = actual_func.__module__ + '.' + actual_func.__name__\n \n         view_path = url_name or self._func_path\n         self.view_name = ':'.join(self.namespaces + [view_path])\ndiff --git a/tests/urlpatterns_reverse/tests.py b/tests/urlpatterns_reverse/tests.py\nindex 09028be795..55086ffc89 100644\n--- a/tests/urlpatterns_reverse/tests.py\n+++ b/tests/urlpatterns_reverse/tests.py\n@@ -1137,13 +1137,32 @@ class ResolverMatchTests(SimpleTestCase):\n         request = HttpRequest()\n         self.assertIsNone(request.resolver_match)\n \n-    def test_repr(self):\n-        self.assertEqual(\n-            repr(resolve('/no_kwargs/42/37/')),\n-            \"ResolverMatch(func=urlpatterns_reverse.views.empty_view, \"\n-            \"args=('42', '37'), kwargs={}, url_name=no-kwargs, app_names=[], \"\n-            \"namespaces=[], route=^no_kwargs/([0-9]+)/([0-9]+)/$)\",\n-        )\n+\n+    def __init__(self, func, args, kwargs, url_name=None, app_names=None, namespaces=None, route=None, tried=None):\n+        self.func = func\n+        self.args = args\n+        self.kwargs = kwargs\n+        self.url_name = url_name\n+        self.route = route\n+        self.tried = tried\n+        self.app_names = app_names or []\n+        self.app_name = ':'.join(self.app_names)\n+        self.namespaces = namespaces or []\n+        self.namespace = ':'.join(self.namespaces)\n+\n+        # Unwrap functools.partial objects to get the underlying function\n+        unwrapped_func = func\n+        while isinstance(unwrapped_func, functools.partial):\n+            unwrapped_func = unwrapped_func.func\n+\n+        if not hasattr(unwrapped_func, '__name__'):\n+            # We can't reverse this view, so it's a class-based view.\n+            self._func_path = unwrapped_func.__class__.__module__ + '.' + unwrapped_func.__class__.__name__\n+        else:\n+            self._func_path = unwrapped_func.__module__ + '.' + unwrapped_func.__name__\n+\n+        view_path = url_name or self._func_path\n+        self.view_name = ':'.join(self.namespaces + [view_path])\n \n \n @override_settings(ROOT_URLCONF='urlpatterns_reverse.erroneous_urls')\n",
    "variant_7": "diff --git a/django/urls/resolvers.py b/django/urls/resolvers.py\nindex 9b00e24509..85b8015589 100644\n--- a/django/urls/resolvers.py\n+++ b/django/urls/resolvers.py\n@@ -45,12 +45,18 @@ class ResolverMatch:\n         self.namespaces = [x for x in namespaces if x] if namespaces else []\n         self.namespace = ':'.join(self.namespaces)\n \n-        if not hasattr(func, '__name__'):\n+\n+        # Unwrap functools.partial objects to get the actual function\n+        actual_func = func\n+        while isinstance(actual_func, functools.partial):\n+            actual_func = actual_func.func\n+\n+        if not hasattr(actual_func, '__name__'):\n             # A class-based view\n-            self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__\n+            self._func_path = actual_func.__class__.__module__ + '.' + actual_func.__class__.__name__\n         else:\n             # A function-based view\n-            self._func_path = func.__module__ + '.' + func.__name__\n+            self._func_path = actual_func.__module__ + '.' + actual_func.__name__\n \n         view_path = url_name or self._func_path\n         self.view_name = ':'.join(self.namespaces + [view_path])\ndiff --git a/tests/urlpatterns_reverse/tests.py b/tests/urlpatterns_reverse/tests.py\nindex 09028be795..e745f3e7f7 100644\n--- a/tests/urlpatterns_reverse/tests.py\n+++ b/tests/urlpatterns_reverse/tests.py\n@@ -1137,13 +1137,30 @@ class ResolverMatchTests(SimpleTestCase):\n         request = HttpRequest()\n         self.assertIsNone(request.resolver_match)\n \n-    def test_repr(self):\n-        self.assertEqual(\n-            repr(resolve('/no_kwargs/42/37/')),\n-            \"ResolverMatch(func=urlpatterns_reverse.views.empty_view, \"\n-            \"args=('42', '37'), kwargs={}, url_name=no-kwargs, app_names=[], \"\n-            \"namespaces=[], route=^no_kwargs/([0-9]+)/([0-9]+)/$)\",\n-        )\n+\n+    def __init__(self, func, args, kwargs, url_name=None, app_names=None, namespaces=None, route=None, tried=None):\n+        self.func = func\n+        self.args = args\n+        self.kwargs = kwargs\n+        self.url_name = url_name\n+        self.route = route\n+        self.tried = tried\n+        self.app_names = app_names or []\n+        self.app_name = ':'.join(self.app_names)\n+        self.namespaces = namespaces or []\n+        self.namespace = ':'.join(self.namespaces)\n+\n+        # Unwrap functools.partial objects to get the actual function\n+        actual_func = func\n+        while isinstance(actual_func, functools.partial):\n+            actual_func = actual_func.func\n+\n+        if not hasattr(actual_func, '__name__'):\n+            # CBV\n+            self._func_path = actual_func.__class__.__module__ + '.' + actual_func.__class__.__name__\n+        else:\n+            # FBV\n+            self._func_path = actual_func.__module__ + '.' + actual_func.__name__\n \n \n @override_settings(ROOT_URLCONF='urlpatterns_reverse.erroneous_urls')\n",
    "variant_8": "diff --git a/django/urls/resolvers.py b/django/urls/resolvers.py\nindex 9b00e24509..4fa9edaf82 100644\n--- a/django/urls/resolvers.py\n+++ b/django/urls/resolvers.py\n@@ -45,12 +45,18 @@ class ResolverMatch:\n         self.namespaces = [x for x in namespaces if x] if namespaces else []\n         self.namespace = ':'.join(self.namespaces)\n \n-        if not hasattr(func, '__name__'):\n+\n+        # Unwrap functools.partial objects to get the original function\n+        original_func = func\n+        while isinstance(original_func, functools.partial):\n+            original_func = original_func.func\n+\n+        if not hasattr(original_func, '__name__'):\n             # A class-based view\n-            self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__\n+            self._func_path = original_func.__class__.__module__ + '.' + original_func.__class__.__name__\n         else:\n             # A function-based view\n-            self._func_path = func.__module__ + '.' + func.__name__\n+            self._func_path = original_func.__module__ + '.' + original_func.__name__\n \n         view_path = url_name or self._func_path\n         self.view_name = ':'.join(self.namespaces + [view_path])\ndiff --git a/tests/urlpatterns_reverse/tests.py b/tests/urlpatterns_reverse/tests.py\nindex 09028be795..b33bf27a44 100644\n--- a/tests/urlpatterns_reverse/tests.py\n+++ b/tests/urlpatterns_reverse/tests.py\n@@ -1137,13 +1137,33 @@ class ResolverMatchTests(SimpleTestCase):\n         request = HttpRequest()\n         self.assertIsNone(request.resolver_match)\n \n-    def test_repr(self):\n-        self.assertEqual(\n-            repr(resolve('/no_kwargs/42/37/')),\n-            \"ResolverMatch(func=urlpatterns_reverse.views.empty_view, \"\n-            \"args=('42', '37'), kwargs={}, url_name=no-kwargs, app_names=[], \"\n-            \"namespaces=[], route=^no_kwargs/([0-9]+)/([0-9]+)/$)\",\n-        )\n+\n+    def __init__(self, func, args, kwargs, url_name=None, app_names=None, namespaces=None, route=None, tried=None):\n+        self.func = func\n+        self.args = args\n+        self.kwargs = kwargs\n+        self.url_name = url_name\n+        self.route = route\n+        self.tried = tried\n+        self.app_names = app_names or []\n+        self.app_name = ':'.join(self.app_names)\n+        self.namespaces = namespaces or []\n+        self.namespace = ':'.join(self.namespaces)\n+\n+        # Unwrap functools.partial objects to get the actual function\n+        unwrapped_func = func\n+        while isinstance(unwrapped_func, functools.partial):\n+            unwrapped_func = unwrapped_func.func\n+\n+        if not hasattr(unwrapped_func, '__name__'):\n+            # If it's a callable object, try to get the class\n+            klass = unwrapped_func.__class__\n+            self._func_path = klass.__module__ + '.' + klass.__name__\n+        else:\n+            self._func_path = unwrapped_func.__module__ + '.' + unwrapped_func.__name__\n+\n+        view_name = url_name or self._func_path\n+        self.view_name = ':'.join(self.namespaces + [view_name])\n \n \n @override_settings(ROOT_URLCONF='urlpatterns_reverse.erroneous_urls')\n"
  }
}