{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/django/django/db/models/fields/__init__.py lines 283-292)": "\n        else:\n            # Check if max_length is sufficient for all choice values\n            if hasattr(self, 'max_length') and self.max_length is not None and self.choices:\n                max_choice_length = 0\n                longest_choice = None\n                \n                for choice in self.choices:\n                    if isinstance(choice, (list, tuple)) and len(choice) == 2:\n                        # Handle both simple choices and grouped choices\n                        if isinstance(choice[1], (list, tuple)):\n                            # Grouped choice: ('Group Name', [('value1', 'display1'), ...])\n                            for sub_choice in choice[1]:\n                                if isinstance(sub_choice, (list, tuple)) and len(sub_choice) >= 1:\n                                    choice_value = str(sub_choice[0])\n                                    if len(choice_value) > max_choice_length:\n                                        max_choice_length = len(choice_value)\n                                        longest_choice = choice_value\n                        else:\n                            # Simple choice: ('value', 'display')\n                            choice_value = str(choice[0])\n                            if len(choice_value) > max_choice_length:\n                                max_choice_length = len(choice_value)\n                                longest_choice = choice_value\n                \n                if max_choice_length > self.max_length:\n                    return [\n                        checks.Error(\n                            \"Choice value '{}' is longer than max_length={}. \"\n                            \"Ensure all choice values fit within the field's max_length.\".format(\n                                longest_choice, self.max_length\n                            ),\n                            obj=self,\n                            id='fields.E009',\n                        )\n                    ]\n            \n            return []\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/django/django/db/models/fields/__init__.py lines 283-292)": [
      "\n        else:\n            # Check max_length constraint against choice values\n            if hasattr(self, 'max_length') and self.max_length is not None and self.choices:\n                max_choice_length = 0\n                longest_choice = None\n                \n                for choice in self.choices:\n                    if isinstance(choice, (list, tuple)) and len(choice) == 2:\n                        # Check if this is a grouped choice\n                        group_name, group_choices = choice\n                        if isinstance(group_choices, (list, tuple)):\n                            # Grouped choices format\n                            for group_choice in group_choices:\n                                if isinstance(group_choice, (list, tuple)) and len(group_choice) >= 2:\n                                    choice_value = str(group_choice[0])\n                                    if len(choice_value) > max_choice_length:\n                                        max_choice_length = len(choice_value)\n                                        longest_choice = choice_value\n                        else:\n                            # Simple choice format\n                            choice_value = str(choice[0])\n                            if len(choice_value) > max_choice_length:\n                                max_choice_length = len(choice_value)\n                                longest_choice = choice_value\n                \n                if max_choice_length > self.max_length:\n                    return [\n                        checks.Error(\n                            f\"'max_length' is too small to fit the longest choice value. \"\n                            f\"Choice '{longest_choice}' has length {max_choice_length} \"\n                            f\"but max_length is {self.max_length}.\",\n                            obj=self,\n                            id='fields.E009',\n                        )\n                    ]\n            \n            return []\n\n        return [\n            checks.Error(\n                \"'choices' must be an iterable containing \"\n                \"(actual value, human readable name) tuples.\",\n                obj=self,\n                id='fields.E005',\n            )\n        ]\n",
      "\n        else:\n            # Check if max_length is sufficient for all choices\n            if hasattr(self, 'max_length') and self.max_length is not None and self.choices:\n                max_choice_length = 0\n                longest_choice = None\n                \n                for choice in self.choices:\n                    if isinstance(choice, (list, tuple)) and len(choice) == 2:\n                        # Check if this is a group (second element is iterable of choices)\n                        try:\n                            # Try to iterate over the second element to see if it's a group\n                            iter(choice[1])\n                            # If we can iterate and it's not a string, it's likely a group\n                            if not isinstance(choice[1], str):\n                                # It's a grouped choice\n                                for group_choice in choice[1]:\n                                    if isinstance(group_choice, (list, tuple)) and len(group_choice) >= 2:\n                                        choice_value = str(group_choice[0])\n                                        if len(choice_value) > max_choice_length:\n                                            max_choice_length = len(choice_value)\n                                            longest_choice = choice_value\n                            else:\n                                # It's a simple choice\n                                choice_value = str(choice[0])\n                                if len(choice_value) > max_choice_length:\n                                    max_choice_length = len(choice_value)\n                                    longest_choice = choice_value\n                        except TypeError:\n                            # Second element is not iterable, so it's a simple choice\n                            choice_value = str(choice[0])\n                            if len(choice_value) > max_choice_length:\n                                max_choice_length = len(choice_value)\n                                longest_choice = choice_value\n                \n                if max_choice_length > self.max_length:\n                    return [\n                        checks.Error(\n                            f\"'max_length' is too small to fit the longest choice: '{longest_choice}' \"\n                            f\"({max_choice_length} characters). Increase 'max_length' to at least {max_choice_length}.\",\n                            obj=self,\n                            id='fields.E009',\n                        )\n                    ]\n            \n            return []\n\n        return [\n            checks.Error(\n                \"'choices' must be an iterable containing \"\n                \"(actual value, human readable name) tuples.\",\n                obj=self,\n                id='fields.E005',\n            )\n        ]\n",
      "\n        else:\n            # Check max_length against choices if both are specified\n            if hasattr(self, 'max_length') and self.max_length is not None and self.choices:\n                max_choice_length = 0\n                longest_choice = None\n                \n                for choice_item in self.choices:\n                    try:\n                        # Handle grouped choices: ('Group Name', [('value', 'label'), ...])\n                        group_name, group_choices = choice_item\n                        if isinstance(group_choices, (list, tuple)):\n                            for sub_choice in group_choices:\n                                try:\n                                    value, _ = sub_choice\n                                    choice_str = str(value)\n                                    if len(choice_str) > max_choice_length:\n                                        max_choice_length = len(choice_str)\n                                        longest_choice = choice_str\n                                except (TypeError, ValueError):\n                                    pass\n                        else:\n                            # Handle ungrouped choice as value\n                            choice_str = str(group_name)\n                            if len(choice_str) > max_choice_length:\n                                max_choice_length = len(choice_str)\n                                longest_choice = choice_str\n                    except (TypeError, ValueError):\n                        # Handle simple choices: ('value', 'label')\n                        try:\n                            value, _ = choice_item\n                            choice_str = str(value)\n                            if len(choice_str) > max_choice_length:\n                                max_choice_length = len(choice_str)\n                                longest_choice = choice_str\n                        except (TypeError, ValueError):\n                            pass\n                \n                if max_choice_length > self.max_length:\n                    return [\n                        checks.Error(\n                            f\"'max_length' is too small to fit the longest choice: \"\n                            f\"'{longest_choice}' ({max_choice_length} characters). \"\n                            f\"Increase 'max_length' to at least {max_choice_length}.\",\n                            obj=self,\n                            id='fields.E009',\n                        )\n                    ]\n            \n            return []\n\n        return [\n            checks.Error(\n                \"'choices' must be an iterable containing \"\n                \"(actual value, human readable name) tuples.\",\n                obj=self,\n                id='fields.E005',\n            )\n        ]\n",
      "\n        else:\n            # Check if max_length is sufficient for all choice values\n            if hasattr(self, 'max_length') and self.max_length is not None and self.choices:\n                max_choice_length = 0\n                longest_choice = None\n                \n                for choice_group in self.choices:\n                    try:\n                        group_name, group_choices = choice_group\n                    except (TypeError, ValueError):\n                        # Simple format: (value, display)\n                        value = choice_group[0]\n                        choice_str = str(value)\n                        if len(choice_str) > max_choice_length:\n                            max_choice_length = len(choice_str)\n                            longest_choice = choice_str\n                    else:\n                        # Grouped format: (group_name, [(value, display), ...])\n                        if isinstance(group_choices, (list, tuple)):\n                            for choice in group_choices:\n                                try:\n                                    value = choice[0]\n                                    choice_str = str(value)\n                                    if len(choice_str) > max_choice_length:\n                                        max_choice_length = len(choice_str)\n                                        longest_choice = choice_str\n                                except (TypeError, IndexError):\n                                    continue\n                \n                if max_choice_length > self.max_length:\n                    return [\n                        checks.Error(\n                            f\"'max_length' is too small to fit the longest value \"\n                            f\"in 'choices' ('{longest_choice}' with length {max_choice_length}).\",\n                            hint=f\"Set 'max_length' to at least {max_choice_length}.\",\n                            obj=self,\n                            id='fields.E009',\n                        )\n                    ]\n            \n            return []\n\n        return [\n            checks.Error(\n                \"'choices' must be an iterable containing \"\n                \"(actual value, human readable name) tuples.\",\n                obj=self,\n                id='fields.E005',\n            )\n        ]\n",
      "\n        else:\n            return []\n\n        # Check if max_length is sufficient for all choice values\n        if hasattr(self, 'max_length') and self.max_length is not None and self.choices:\n            max_choice_length = 0\n            longest_choice = None\n            \n            for choice in self.choices:\n                if isinstance(choice, (list, tuple)) and len(choice) == 2:\n                    group_name, group_choices = choice\n                    if isinstance(group_choices, (list, tuple)):\n                        # Grouped choices format\n                        for group_choice in group_choices:\n                            if isinstance(group_choice, (list, tuple)) and len(group_choice) >= 1:\n                                choice_value = str(group_choice[0])\n                                if len(choice_value) > max_choice_length:\n                                    max_choice_length = len(choice_value)\n                                    longest_choice = choice_value\n                    else:\n                        # Simple choices format\n                        choice_value = str(choice[0])\n                        if len(choice_value) > max_choice_length:\n                            max_choice_length = len(choice_value)\n                            longest_choice = choice_value\n            \n            if max_choice_length > self.max_length:\n                return [\n                    checks.Error(\n                        f\"'max_length' is too small to fit the longest choice: \"\n                        f\"'{longest_choice}' ({max_choice_length} characters). \"\n                        f\"'max_length' should be at least {max_choice_length}.\",\n                        obj=self,\n                        id='fields.E009',\n                    )\n                ]\n\n        return [\n            checks.Error(\n                \"'choices' must be an iterable containing \"\n                \"(actual value, human readable name) tuples.\",\n                obj=self,\n                id='fields.E005',\n            )\n        ]\n",
      "\n        else:\n            # Check if max_length is sufficient for all choice values\n            if hasattr(self, 'max_length') and self.max_length is not None and self.choices:\n                max_choice_length = 0\n                longest_choice = None\n                \n                for choice in self.choices:\n                    try:\n                        # Handle grouped choices: ('Group Name', [('value', 'display'), ...])\n                        group_name, group_choices = choice\n                        if isinstance(group_choices, (list, tuple)):\n                            for group_choice in group_choices:\n                                try:\n                                    value, _ = group_choice\n                                    choice_length = len(str(value))\n                                    if choice_length > max_choice_length:\n                                        max_choice_length = choice_length\n                                        longest_choice = value\n                                except (TypeError, ValueError):\n                                    pass\n                        else:\n                            # Handle simple choice format where choice is actually a tuple\n                            value = group_name\n                            choice_length = len(str(value))\n                            if choice_length > max_choice_length:\n                                max_choice_length = choice_length\n                                longest_choice = value\n                    except (TypeError, ValueError):\n                        # Handle simple choices: ('value', 'display')\n                        try:\n                            value, _ = choice\n                            choice_length = len(str(value))\n                            if choice_length > max_choice_length:\n                                max_choice_length = choice_length\n                                longest_choice = value\n                        except (TypeError, ValueError):\n                            pass\n                \n                if max_choice_length > self.max_length:\n                    return [\n                        checks.Error(\n                            f\"'max_length' is too small to fit the longest choice: \"\n                            f\"'{longest_choice}' ({max_choice_length} characters). \"\n                            f\"'max_length' should be at least {max_choice_length}.\",\n                            obj=self,\n                            id='fields.E009',\n                        )\n                    ]\n            \n            return []\n\n        return [\n            checks.Error(\n                \"'choices' must be an iterable containing \"\n                \"(actual value, human readable name) tuples.\",\n                obj=self,\n                id='fields.E005',\n            )\n        ]\n",
      "\n        else:\n            # Check if max_length is sufficient for all choice values\n            if hasattr(self, 'max_length') and self.max_length is not None and self.choices:\n                max_choice_length = 0\n                longest_choice = None\n                \n                for choice_item in self.choices:\n                    try:\n                        # Handle grouped choices: ('Group Name', [('value', 'display'), ...])\n                        group_name, group_choices = choice_item\n                        if isinstance(group_choices, (list, tuple)):\n                            for choice_value, _ in group_choices:\n                                choice_str = str(choice_value)\n                                if len(choice_str) > max_choice_length:\n                                    max_choice_length = len(choice_str)\n                                    longest_choice = choice_str\n                        else:\n                            # Simple choice format: ('value', 'display')\n                            choice_str = str(group_name)\n                            if len(choice_str) > max_choice_length:\n                                max_choice_length = len(choice_str)\n                                longest_choice = choice_str\n                    except (TypeError, ValueError):\n                        # Simple choice format: ('value', 'display')\n                        choice_str = str(choice_item[0]) if hasattr(choice_item, '__getitem__') and len(choice_item) > 0 else str(choice_item)\n                        if len(choice_str) > max_choice_length:\n                            max_choice_length = len(choice_str)\n                            longest_choice = choice_str\n                \n                if max_choice_length > self.max_length:\n                    return [\n                        checks.Error(\n                            f\"'max_length' is too small to fit the longest choice value. \"\n                            f\"Choice '{longest_choice}' has length {max_choice_length} but 'max_length' is {self.max_length}.\",\n                            obj=self,\n                            id='fields.E009',\n                        )\n                    ]\n            \n            return []\n",
      "\n        else:\n            # Check if max_length is sufficient for all choice values\n            if hasattr(self, 'max_length') and self.max_length is not None and self.choices:\n                max_choice_length = 0\n                longest_choice = None\n                \n                for choice in self.choices:\n                    if isinstance(choice, (list, tuple)) and len(choice) == 2:\n                        # Handle both simple choices and grouped choices\n                        group_name, group_choices = choice\n                        if isinstance(group_choices, (list, tuple)):\n                            # This is a grouped choice\n                            for group_choice in group_choices:\n                                if isinstance(group_choice, (list, tuple)) and len(group_choice) >= 1:\n                                    choice_value = str(group_choice[0])\n                                    if len(choice_value) > max_choice_length:\n                                        max_choice_length = len(choice_value)\n                                        longest_choice = choice_value\n                        else:\n                            # This is a simple choice\n                            choice_value = str(group_name)\n                            if len(choice_value) > max_choice_length:\n                                max_choice_length = len(choice_value)\n                                longest_choice = choice_value\n                \n                if max_choice_length > self.max_length:\n                    return [\n                        checks.Error(\n                            f\"'max_length' is too small to fit the longest choice: \"\n                            f\"'{longest_choice}' ({max_choice_length} characters). \"\n                            f\"Set 'max_length' to at least {max_choice_length}.\",\n                            obj=self,\n                            id='fields.E009',\n                        )\n                    ]\n            \n            return []\n\n        return [\n            checks.Error(\n                \"'choices' must be an iterable containing \"\n                \"(actual value, human readable name) tuples.\",\n                obj=self,\n                id='fields.E005',\n            )\n        ]\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 9ce46e3f73..71c3501e04 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -280,6 +280,38 @@ class Field(RegisterLookupMixin):\n             if isinstance(choices_group, str):\n                 break\n         else:\n+\n+            # Check if max_length is sufficient for all choice values\n+            if self.max_length is not None and self.choices:\n+                choice_values = []\n+                \n+                # Extract all choice values from both simple and grouped formats\n+                for choices_group in self.choices:\n+                    try:\n+                        group_name, group_choices = choices_group\n+                        # This is a grouped choice format\n+                        for value, human_name in group_choices:\n+                            choice_values.append(str(value))\n+                    except (TypeError, ValueError):\n+                        # This is a simple choice format [value, display]\n+                        value, human_name = choices_group\n+                        choice_values.append(str(value))\n+                \n+                # Find the longest choice value\n+                if choice_values:\n+                    max_choice_length = max(len(value) for value in choice_values)\n+                    if max_choice_length > self.max_length:\n+                        longest_choice = max(choice_values, key=len)\n+                        return [\n+                            checks.Error(\n+                                f\"'max_length' is too small to fit the longest value \"\n+                                f\"in 'choices' ('{longest_choice}' has length {max_choice_length}, \"\n+                                f\"but max_length is {self.max_length}).\",\n+                                obj=self,\n+                                id='fields.E009',\n+                            )\n+                        ]\n+            \n             return []\n \n         return [\n",
    "variant_0": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 9ce46e3f73..df2e85dd62 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -280,16 +280,44 @@ class Field(RegisterLookupMixin):\n             if isinstance(choices_group, str):\n                 break\n         else:\n-            return []\n \n-        return [\n-            checks.Error(\n-                \"'choices' must be an iterable containing \"\n-                \"(actual value, human readable name) tuples.\",\n-                obj=self,\n-                id='fields.E005',\n-            )\n-        ]\n+        else:\n+            # Check if max_length is sufficient for all choice values\n+            if hasattr(self, 'max_length') and self.max_length is not None and self.choices:\n+                max_choice_length = 0\n+                longest_choice = None\n+                \n+                for choice in self.choices:\n+                    if isinstance(choice, (list, tuple)) and len(choice) == 2:\n+                        # Handle both simple choices and grouped choices\n+                        if isinstance(choice[1], (list, tuple)):\n+                            # Grouped choice: ('Group Name', [('value1', 'display1'), ...])\n+                            for sub_choice in choice[1]:\n+                                if isinstance(sub_choice, (list, tuple)) and len(sub_choice) >= 1:\n+                                    choice_value = str(sub_choice[0])\n+                                    if len(choice_value) > max_choice_length:\n+                                        max_choice_length = len(choice_value)\n+                                        longest_choice = choice_value\n+                        else:\n+                            # Simple choice: ('value', 'display')\n+                            choice_value = str(choice[0])\n+                            if len(choice_value) > max_choice_length:\n+                                max_choice_length = len(choice_value)\n+                                longest_choice = choice_value\n+                \n+                if max_choice_length > self.max_length:\n+                    return [\n+                        checks.Error(\n+                            \"Choice value '{}' is longer than max_length={}. \"\n+                            \"Ensure all choice values fit within the field's max_length.\".format(\n+                                longest_choice, self.max_length\n+                            ),\n+                            obj=self,\n+                            id='fields.E009',\n+                        )\n+                    ]\n+            \n+            return []\n \n     def _check_db_index(self):\n         if self.db_index not in (None, True, False):\n",
    "variant_1": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 9ce46e3f73..e8e57fcd4e 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -280,6 +280,43 @@ class Field(RegisterLookupMixin):\n             if isinstance(choices_group, str):\n                 break\n         else:\n+\n+        else:\n+            # Check max_length constraint against choice values\n+            if hasattr(self, 'max_length') and self.max_length is not None and self.choices:\n+                max_choice_length = 0\n+                longest_choice = None\n+                \n+                for choice in self.choices:\n+                    if isinstance(choice, (list, tuple)) and len(choice) == 2:\n+                        # Check if this is a grouped choice\n+                        group_name, group_choices = choice\n+                        if isinstance(group_choices, (list, tuple)):\n+                            # Grouped choices format\n+                            for group_choice in group_choices:\n+                                if isinstance(group_choice, (list, tuple)) and len(group_choice) >= 2:\n+                                    choice_value = str(group_choice[0])\n+                                    if len(choice_value) > max_choice_length:\n+                                        max_choice_length = len(choice_value)\n+                                        longest_choice = choice_value\n+                        else:\n+                            # Simple choice format\n+                            choice_value = str(choice[0])\n+                            if len(choice_value) > max_choice_length:\n+                                max_choice_length = len(choice_value)\n+                                longest_choice = choice_value\n+                \n+                if max_choice_length > self.max_length:\n+                    return [\n+                        checks.Error(\n+                            f\"'max_length' is too small to fit the longest choice value. \"\n+                            f\"Choice '{longest_choice}' has length {max_choice_length} \"\n+                            f\"but max_length is {self.max_length}.\",\n+                            obj=self,\n+                            id='fields.E009',\n+                        )\n+                    ]\n+            \n             return []\n \n         return [\n",
    "variant_2": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 9ce46e3f73..c08a88660e 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -280,6 +280,51 @@ class Field(RegisterLookupMixin):\n             if isinstance(choices_group, str):\n                 break\n         else:\n+\n+        else:\n+            # Check if max_length is sufficient for all choices\n+            if hasattr(self, 'max_length') and self.max_length is not None and self.choices:\n+                max_choice_length = 0\n+                longest_choice = None\n+                \n+                for choice in self.choices:\n+                    if isinstance(choice, (list, tuple)) and len(choice) == 2:\n+                        # Check if this is a group (second element is iterable of choices)\n+                        try:\n+                            # Try to iterate over the second element to see if it's a group\n+                            iter(choice[1])\n+                            # If we can iterate and it's not a string, it's likely a group\n+                            if not isinstance(choice[1], str):\n+                                # It's a grouped choice\n+                                for group_choice in choice[1]:\n+                                    if isinstance(group_choice, (list, tuple)) and len(group_choice) >= 2:\n+                                        choice_value = str(group_choice[0])\n+                                        if len(choice_value) > max_choice_length:\n+                                            max_choice_length = len(choice_value)\n+                                            longest_choice = choice_value\n+                            else:\n+                                # It's a simple choice\n+                                choice_value = str(choice[0])\n+                                if len(choice_value) > max_choice_length:\n+                                    max_choice_length = len(choice_value)\n+                                    longest_choice = choice_value\n+                        except TypeError:\n+                            # Second element is not iterable, so it's a simple choice\n+                            choice_value = str(choice[0])\n+                            if len(choice_value) > max_choice_length:\n+                                max_choice_length = len(choice_value)\n+                                longest_choice = choice_value\n+                \n+                if max_choice_length > self.max_length:\n+                    return [\n+                        checks.Error(\n+                            f\"'max_length' is too small to fit the longest choice: '{longest_choice}' \"\n+                            f\"({max_choice_length} characters). Increase 'max_length' to at least {max_choice_length}.\",\n+                            obj=self,\n+                            id='fields.E009',\n+                        )\n+                    ]\n+            \n             return []\n \n         return [\n",
    "variant_3": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 9ce46e3f73..cafa6ec265 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -280,6 +280,55 @@ class Field(RegisterLookupMixin):\n             if isinstance(choices_group, str):\n                 break\n         else:\n+\n+        else:\n+            # Check max_length against choices if both are specified\n+            if hasattr(self, 'max_length') and self.max_length is not None and self.choices:\n+                max_choice_length = 0\n+                longest_choice = None\n+                \n+                for choice_item in self.choices:\n+                    try:\n+                        # Handle grouped choices: ('Group Name', [('value', 'label'), ...])\n+                        group_name, group_choices = choice_item\n+                        if isinstance(group_choices, (list, tuple)):\n+                            for sub_choice in group_choices:\n+                                try:\n+                                    value, _ = sub_choice\n+                                    choice_str = str(value)\n+                                    if len(choice_str) > max_choice_length:\n+                                        max_choice_length = len(choice_str)\n+                                        longest_choice = choice_str\n+                                except (TypeError, ValueError):\n+                                    pass\n+                        else:\n+                            # Handle ungrouped choice as value\n+                            choice_str = str(group_name)\n+                            if len(choice_str) > max_choice_length:\n+                                max_choice_length = len(choice_str)\n+                                longest_choice = choice_str\n+                    except (TypeError, ValueError):\n+                        # Handle simple choices: ('value', 'label')\n+                        try:\n+                            value, _ = choice_item\n+                            choice_str = str(value)\n+                            if len(choice_str) > max_choice_length:\n+                                max_choice_length = len(choice_str)\n+                                longest_choice = choice_str\n+                        except (TypeError, ValueError):\n+                            pass\n+                \n+                if max_choice_length > self.max_length:\n+                    return [\n+                        checks.Error(\n+                            f\"'max_length' is too small to fit the longest choice: \"\n+                            f\"'{longest_choice}' ({max_choice_length} characters). \"\n+                            f\"Increase 'max_length' to at least {max_choice_length}.\",\n+                            obj=self,\n+                            id='fields.E009',\n+                        )\n+                    ]\n+            \n             return []\n \n         return [\n",
    "variant_4": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 9ce46e3f73..e0a07d0a2c 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -280,6 +280,47 @@ class Field(RegisterLookupMixin):\n             if isinstance(choices_group, str):\n                 break\n         else:\n+\n+        else:\n+            # Check if max_length is sufficient for all choice values\n+            if hasattr(self, 'max_length') and self.max_length is not None and self.choices:\n+                max_choice_length = 0\n+                longest_choice = None\n+                \n+                for choice_group in self.choices:\n+                    try:\n+                        group_name, group_choices = choice_group\n+                    except (TypeError, ValueError):\n+                        # Simple format: (value, display)\n+                        value = choice_group[0]\n+                        choice_str = str(value)\n+                        if len(choice_str) > max_choice_length:\n+                            max_choice_length = len(choice_str)\n+                            longest_choice = choice_str\n+                    else:\n+                        # Grouped format: (group_name, [(value, display), ...])\n+                        if isinstance(group_choices, (list, tuple)):\n+                            for choice in group_choices:\n+                                try:\n+                                    value = choice[0]\n+                                    choice_str = str(value)\n+                                    if len(choice_str) > max_choice_length:\n+                                        max_choice_length = len(choice_str)\n+                                        longest_choice = choice_str\n+                                except (TypeError, IndexError):\n+                                    continue\n+                \n+                if max_choice_length > self.max_length:\n+                    return [\n+                        checks.Error(\n+                            f\"'max_length' is too small to fit the longest value \"\n+                            f\"in 'choices' ('{longest_choice}' with length {max_choice_length}).\",\n+                            hint=f\"Set 'max_length' to at least {max_choice_length}.\",\n+                            obj=self,\n+                            id='fields.E009',\n+                        )\n+                    ]\n+            \n             return []\n \n         return [\n",
    "variant_5": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 9ce46e3f73..02b767abfc 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -279,9 +279,45 @@ class Field(RegisterLookupMixin):\n             # Special case: choices=['ab']\n             if isinstance(choices_group, str):\n                 break\n+        else:\n+\n         else:\n             return []\n \n+        # Check if max_length is sufficient for all choice values\n+        if hasattr(self, 'max_length') and self.max_length is not None and self.choices:\n+            max_choice_length = 0\n+            longest_choice = None\n+            \n+            for choice in self.choices:\n+                if isinstance(choice, (list, tuple)) and len(choice) == 2:\n+                    group_name, group_choices = choice\n+                    if isinstance(group_choices, (list, tuple)):\n+                        # Grouped choices format\n+                        for group_choice in group_choices:\n+                            if isinstance(group_choice, (list, tuple)) and len(group_choice) >= 1:\n+                                choice_value = str(group_choice[0])\n+                                if len(choice_value) > max_choice_length:\n+                                    max_choice_length = len(choice_value)\n+                                    longest_choice = choice_value\n+                    else:\n+                        # Simple choices format\n+                        choice_value = str(choice[0])\n+                        if len(choice_value) > max_choice_length:\n+                            max_choice_length = len(choice_value)\n+                            longest_choice = choice_value\n+            \n+            if max_choice_length > self.max_length:\n+                return [\n+                    checks.Error(\n+                        f\"'max_length' is too small to fit the longest choice: \"\n+                        f\"'{longest_choice}' ({max_choice_length} characters). \"\n+                        f\"'max_length' should be at least {max_choice_length}.\",\n+                        obj=self,\n+                        id='fields.E009',\n+                    )\n+                ]\n+\n         return [\n             checks.Error(\n                 \"'choices' must be an iterable containing \"\n",
    "variant_6": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 9ce46e3f73..38c4305887 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -280,6 +280,56 @@ class Field(RegisterLookupMixin):\n             if isinstance(choices_group, str):\n                 break\n         else:\n+\n+        else:\n+            # Check if max_length is sufficient for all choice values\n+            if hasattr(self, 'max_length') and self.max_length is not None and self.choices:\n+                max_choice_length = 0\n+                longest_choice = None\n+                \n+                for choice in self.choices:\n+                    try:\n+                        # Handle grouped choices: ('Group Name', [('value', 'display'), ...])\n+                        group_name, group_choices = choice\n+                        if isinstance(group_choices, (list, tuple)):\n+                            for group_choice in group_choices:\n+                                try:\n+                                    value, _ = group_choice\n+                                    choice_length = len(str(value))\n+                                    if choice_length > max_choice_length:\n+                                        max_choice_length = choice_length\n+                                        longest_choice = value\n+                                except (TypeError, ValueError):\n+                                    pass\n+                        else:\n+                            # Handle simple choice format where choice is actually a tuple\n+                            value = group_name\n+                            choice_length = len(str(value))\n+                            if choice_length > max_choice_length:\n+                                max_choice_length = choice_length\n+                                longest_choice = value\n+                    except (TypeError, ValueError):\n+                        # Handle simple choices: ('value', 'display')\n+                        try:\n+                            value, _ = choice\n+                            choice_length = len(str(value))\n+                            if choice_length > max_choice_length:\n+                                max_choice_length = choice_length\n+                                longest_choice = value\n+                        except (TypeError, ValueError):\n+                            pass\n+                \n+                if max_choice_length > self.max_length:\n+                    return [\n+                        checks.Error(\n+                            f\"'max_length' is too small to fit the longest choice: \"\n+                            f\"'{longest_choice}' ({max_choice_length} characters). \"\n+                            f\"'max_length' should be at least {max_choice_length}.\",\n+                            obj=self,\n+                            id='fields.E009',\n+                        )\n+                    ]\n+            \n             return []\n \n         return [\n",
    "variant_7": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 9ce46e3f73..c8787c3076 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -280,16 +280,47 @@ class Field(RegisterLookupMixin):\n             if isinstance(choices_group, str):\n                 break\n         else:\n-            return []\n \n-        return [\n-            checks.Error(\n-                \"'choices' must be an iterable containing \"\n-                \"(actual value, human readable name) tuples.\",\n-                obj=self,\n-                id='fields.E005',\n-            )\n-        ]\n+        else:\n+            # Check if max_length is sufficient for all choice values\n+            if hasattr(self, 'max_length') and self.max_length is not None and self.choices:\n+                max_choice_length = 0\n+                longest_choice = None\n+                \n+                for choice_item in self.choices:\n+                    try:\n+                        # Handle grouped choices: ('Group Name', [('value', 'display'), ...])\n+                        group_name, group_choices = choice_item\n+                        if isinstance(group_choices, (list, tuple)):\n+                            for choice_value, _ in group_choices:\n+                                choice_str = str(choice_value)\n+                                if len(choice_str) > max_choice_length:\n+                                    max_choice_length = len(choice_str)\n+                                    longest_choice = choice_str\n+                        else:\n+                            # Simple choice format: ('value', 'display')\n+                            choice_str = str(group_name)\n+                            if len(choice_str) > max_choice_length:\n+                                max_choice_length = len(choice_str)\n+                                longest_choice = choice_str\n+                    except (TypeError, ValueError):\n+                        # Simple choice format: ('value', 'display')\n+                        choice_str = str(choice_item[0]) if hasattr(choice_item, '__getitem__') and len(choice_item) > 0 else str(choice_item)\n+                        if len(choice_str) > max_choice_length:\n+                            max_choice_length = len(choice_str)\n+                            longest_choice = choice_str\n+                \n+                if max_choice_length > self.max_length:\n+                    return [\n+                        checks.Error(\n+                            f\"'max_length' is too small to fit the longest choice value. \"\n+                            f\"Choice '{longest_choice}' has length {max_choice_length} but 'max_length' is {self.max_length}.\",\n+                            obj=self,\n+                            id='fields.E009',\n+                        )\n+                    ]\n+            \n+            return []\n \n     def _check_db_index(self):\n         if self.db_index not in (None, True, False):\n",
    "variant_8": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 9ce46e3f73..40baa4d481 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -280,6 +280,43 @@ class Field(RegisterLookupMixin):\n             if isinstance(choices_group, str):\n                 break\n         else:\n+\n+        else:\n+            # Check if max_length is sufficient for all choice values\n+            if hasattr(self, 'max_length') and self.max_length is not None and self.choices:\n+                max_choice_length = 0\n+                longest_choice = None\n+                \n+                for choice in self.choices:\n+                    if isinstance(choice, (list, tuple)) and len(choice) == 2:\n+                        # Handle both simple choices and grouped choices\n+                        group_name, group_choices = choice\n+                        if isinstance(group_choices, (list, tuple)):\n+                            # This is a grouped choice\n+                            for group_choice in group_choices:\n+                                if isinstance(group_choice, (list, tuple)) and len(group_choice) >= 1:\n+                                    choice_value = str(group_choice[0])\n+                                    if len(choice_value) > max_choice_length:\n+                                        max_choice_length = len(choice_value)\n+                                        longest_choice = choice_value\n+                        else:\n+                            # This is a simple choice\n+                            choice_value = str(group_name)\n+                            if len(choice_value) > max_choice_length:\n+                                max_choice_length = len(choice_value)\n+                                longest_choice = choice_value\n+                \n+                if max_choice_length > self.max_length:\n+                    return [\n+                        checks.Error(\n+                            f\"'max_length' is too small to fit the longest choice: \"\n+                            f\"'{longest_choice}' ({max_choice_length} characters). \"\n+                            f\"Set 'max_length' to at least {max_choice_length}.\",\n+                            obj=self,\n+                            id='fields.E009',\n+                        )\n+                    ]\n+            \n             return []\n \n         return [\n"
  }
}