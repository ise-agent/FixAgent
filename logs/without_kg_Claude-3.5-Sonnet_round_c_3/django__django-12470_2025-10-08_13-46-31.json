{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/django/django/db/models/sql/compiler.py lines 729-730)": "\n                results.extend(self.find_ordering_name(item, opts, alias,\n                                                       default_order, already_seen))\n",
    "Location 2 (/root/hy/projects_3/django/django/db/models/sql/compiler.py lines 714-731)": "\n        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n\n            results = []\n            for item in opts.ordering:\n                if hasattr(item, 'resolve_expression') and not isinstance(item, OrderBy):\n                    item = item.desc() if descending else item.asc()\n                if isinstance(item, OrderBy):\n                    results.append((item, False))\n                    continue\n                results.extend(self.find_ordering_name(item, opts, alias,\n                                                       default_order, already_seen))\n            return results\n",
    "Location 3 (/root/hy/projects_3/django/django/db/models/sql/compiler.py lines 706-707)": "\n                results.extend(self.find_ordering_name(item, opts, alias, default_order, already_seen))\n",
    "Location 4 (/root/hy/projects_3/django/django/db/models/sql/compiler.py lines 340-341)": "\n                order_by.extend(self.find_ordering_name(\n                    field, self.query.get_meta(), default_order=default_order))\n",
    "Location 5 (/root/hy/projects_3/django/django/db/models/sql/compiler.py lines 699-708)": "\n    def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n                           already_seen=None):\n        \"\"\"\n        Return the table alias (the name might be ambiguous, the alias will\n        not be) and column name for ordering by the given 'name' parameter.\n        The 'name' is of the form 'field1__field2__...__fieldN'.\n        \"\"\"\n        name, order = get_order_dir(name, default_order)\n        descending = order == 'DESC'\n        pieces = name.split(LOOKUP_SEP)\n        field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless the attribute name\n        # of the field is specified.\n        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n            results = []\n            for item in opts.ordering:\n                results.extend(self.find_ordering_name(item, opts, alias,\n                                                       default_order, already_seen))\n            return results\n        targets, alias, _ = self.query.trim_joins(targets, joins, path)\n        return [(OrderBy(transform_function(targets[0], alias), descending=descending), False)]\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/django/django/db/models/sql/compiler.py lines 729-730)": [
      "\n                results.extend(self.find_ordering_name(item, opts, alias,\n                                                       default_order, already_seen))\n",
      "\n                results.extend(self.find_ordering_name(item, opts, alias,\n                                                       default_order, already_seen))\n",
      "\n                results.extend(self.find_ordering_name(item, opts, alias,\n                                                       default_order, already_seen))\n",
      "\n                results.extend(self.find_ordering_name(item, opts, alias,\n                                                       default_order, already_seen))\n",
      "\n                results.extend(self.find_ordering_name(item, opts, alias,\n                                                       default_order, already_seen))\n",
      "\n                results.extend(self.find_ordering_name(item, opts, alias,\n                                                       default_order, already_seen))\n",
      "\n                results.extend(self.find_ordering_name(item, opts, alias,\n                                                       default_order, already_seen))\n",
      "\n                results.extend(self.find_ordering_name(item, opts, alias,\n                                                       default_order, already_seen))\n"
    ],
    "Location 2 (/root/hy/projects_3/django/django/db/models/sql/compiler.py lines 714-731)": [
      "\n        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n\n            results = []\n            for item in opts.ordering:\n                if hasattr(item, 'resolve_expression') and not isinstance(item, OrderBy):\n                    item = item.desc() if descending else item.asc()\n                if isinstance(item, OrderBy):\n                    results.append((item, False))\n                    continue\n                results.extend(self.find_ordering_name(item, opts, alias,\n                                                       default_order, already_seen))\n            return results\n",
      "\n        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n\n            results = []\n            for item in opts.ordering:\n                if hasattr(item, 'resolve_expression') and not isinstance(item, OrderBy):\n                    item = item.desc() if descending else item.asc()\n                if isinstance(item, OrderBy):\n                    results.append((item, False))\n                    continue\n                results.extend(self.find_ordering_name(item, opts, alias,\n                                                       default_order, already_seen))\n            return results\n",
      "\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless the attribute name\n        # of the field is specified.\n        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n\n            results = []\n            for item in opts.ordering:\n                if hasattr(item, 'resolve_expression') and not isinstance(item, OrderBy):\n                    item = item.desc() if descending else item.asc()\n                if isinstance(item, OrderBy):\n                    results.append((item, False))\n                    continue\n                results.extend(self.find_ordering_name(item, opts, alias,\n                                                       default_order, already_seen))\n            return results\n",
      "\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless the attribute name\n        # of the field is specified.\n        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n\n            results = []\n            for item in opts.ordering:\n                if hasattr(item, 'resolve_expression') and not isinstance(item, OrderBy):\n                    item = item.desc() if descending else item.asc()\n                if isinstance(item, OrderBy):\n                    results.append((item, False))\n                    continue\n                results.extend(self.find_ordering_name(item, opts, alias,\n                                                       default_order, already_seen))\n            return results\n",
      "\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless the attribute name\n        # of the field is specified.\n        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n\n            results = []\n            for item in opts.ordering:\n                if hasattr(item, 'resolve_expression') and not isinstance(item, OrderBy):\n                    item = item.desc() if descending else item.asc()\n                if isinstance(item, OrderBy):\n                    results.append((item, False))\n                    continue\n                results.extend(self.find_ordering_name(item, opts, alias,\n                                                       default_order, already_seen))\n            return results\n",
      "\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless the attribute name\n        # of the field is specified.\n        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n\n            results = []\n            for item in opts.ordering:\n                if hasattr(item, 'resolve_expression') and not isinstance(item, OrderBy):\n                    item = item.desc() if descending else item.asc()\n                if isinstance(item, OrderBy):\n                    results.append((item, False))\n                    continue\n                results.extend(self.find_ordering_name(item, opts, alias,\n                                                       default_order, already_seen))\n            return results\n",
      "\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless the attribute name\n        # of the field is specified.\n        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n\n            results = []\n            for item in opts.ordering:\n                if hasattr(item, 'resolve_expression') and not isinstance(item, OrderBy):\n                    item = item.desc() if descending else item.asc()\n                if isinstance(item, OrderBy):\n                    results.append((item, False))\n                    continue\n                results.extend(self.find_ordering_name(item, opts, alias,\n                                                       default_order, already_seen))\n            return results\n",
      "\n        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n\n            results = []\n            for item in opts.ordering:\n                if hasattr(item, 'resolve_expression') and not isinstance(item, OrderBy):\n                    item = item.desc() if descending else item.asc()\n                if isinstance(item, OrderBy):\n                    results.append((item, False))\n                    continue\n                results.extend(self.find_ordering_name(item, opts, alias,\n                                                       default_order, already_seen))\n            return results\n"
    ],
    "Location 3 (/root/hy/projects_3/django/django/db/models/sql/compiler.py lines 706-707)": [
      "\n    def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n                           already_seen=None):\n        \"\"\"\n        Return the table alias (the name might be ambiguous, the alias will\n        not be) and column name for ordering by the given 'name' parameter.\n        The 'name' is of the form 'field1__field2__...__fieldN'.\n        \"\"\"\n        name, order = get_order_dir(name, default_order)\n        descending = order == 'DESC'\n        pieces = name.split(LOOKUP_SEP)\n        field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless the attribute name\n        # of the field is specified.\n        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n\n            results = []\n            for item in opts.ordering:\n                if hasattr(item, 'resolve_expression') and not isinstance(item, OrderBy):\n                    item = item.desc() if descending else item.asc()\n                    results.append((item, False))\n                    continue\n                if isinstance(item, OrderBy):\n                    results.append((item, False))\n                    continue\n                results.extend(self.find_ordering_name(item, opts, alias, default_order, already_seen))\n            return results\n        targets, alias, _ = self.query.trim_joins(targets, joins, path)\n        return [(OrderBy(transform_function(targets[0], alias), descending=descending), False)]\n",
      "\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless the attribute name\n        # of the field is specified.\n        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n            results = []\n            for item in opts.ordering:\n                results.extend(self.find_ordering_name(item, opts, alias, default_order, already_seen))\n            return results\n",
      "\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless the attribute name\n        # of the field is specified.\n        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n\n            results = []\n            for item in opts.ordering:\n                results.extend(self.find_ordering_name(item, opts, alias, default_order, already_seen))\n            return results\n",
      "\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless the attribute name\n        # of the field is specified.\n        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n            results = []\n            for item in opts.ordering:\n                results.extend(self.find_ordering_name(item, opts, alias, default_order, already_seen))\n            return results\n        targets, alias, _ = self.query.trim_joins(targets, joins, path)\n        return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]\n",
      "\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless the attribute name\n        # of the field is specified.\n        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n\n            results = []\n            for item in opts.ordering:\n                results.extend(self.find_ordering_name(item, opts, alias,\n                                                      default_order, already_seen))\n            return results\n        targets, alias, _ = self.query.trim_joins(targets, joins, path)\n        return [(OrderBy(transform_function(targets[0], alias), descending=descending), False)]\n",
      "\n                results.extend(self.find_ordering_name(item, opts, alias, default_order, already_seen))\n",
      "\n                # Avoid infinite loops.\n                already_seen = already_seen or set()\n                join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n                if join_tuple in already_seen:\n                    raise FieldError('Infinite loop caused by ordering.')\n                already_seen.add(join_tuple)\n\n                results = []\n                for item in opts.ordering:\n                    if isinstance(item, OrderBy) and isinstance(item.expression, F):\n                        item = item.expression.name\n                    if hasattr(item, 'resolve_expression'):\n                        # We only support expressions that have a target field.\n                        if not hasattr(item, 'target'):\n                            continue\n                        results.extend(self.find_ordering_name(item, opts, alias, default_order, already_seen))\n                    else:\n                        results.extend(self.find_ordering_name(item, opts, alias, default_order, already_seen))\n                return results\n",
      "\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless the attribute name\n        # of the field is specified.\n        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n\n            results = []\n            for item in opts.ordering:\n                results.extend(self.find_ordering_name(item, opts, alias, default_order, already_seen))\n            return results\n"
    ],
    "Location 4 (/root/hy/projects_3/django/django/db/models/sql/compiler.py lines 340-341)": [
      "\n                order_by.extend(self.find_ordering_name(\n                    field, self.query.get_meta(), default_order=default_order))\n",
      "\n                order_by.extend(self.find_ordering_name(\n                    field, self.query.get_meta(), default_order=asc))\n",
      "\n                results.extend(self.find_ordering_name(item, opts, alias, default_order, already_seen))\n",
      "\n                order_by.extend(self.find_ordering_name(\n                    field, self.query.get_meta(), default_order=default_order))\n",
      "\n                order_by.extend(self.find_ordering_name(\n                    field, self.query.get_meta(), default_order=asc))\n",
      "\n                order_by.extend(self.find_ordering_name(\n                    field, self.query.get_meta(), default_order=asc))\n",
      "\n                order_by.extend(self.find_ordering_name(\n                    field, self.query.get_meta(), default_order=default_order))\n",
      "\n                order_by.extend(self.find_ordering_name(\n                    field, self.query.get_meta(), default_order=asc))\n"
    ],
    "Location 5 (/root/hy/projects_3/django/django/db/models/sql/compiler.py lines 699-708)": [
      "\n    def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n                           already_seen=None):\n        \"\"\"\n        Return the table alias (the name might be ambiguous, the alias will\n        not be) and column name for ordering by the given 'name' parameter.\n        The 'name' is of the form 'field1__field2__...__fieldN'.\n        \"\"\"\n        name, order = get_order_dir(name, default_order)\n        descending = order == 'DESC'\n        pieces = name.split(LOOKUP_SEP)\n        field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless the attribute name\n        # of the field is specified.\n        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n            results = []\n            for item in opts.ordering:\n                results.extend(self.find_ordering_name(item, opts, alias, default_order, already_seen))\n            return results\n        targets, alias, _ = self.query.trim_joins(targets, joins, path)\n        return [(OrderBy(transform_function(targets[0], alias), descending=descending), False)]\n",
      "\n    def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n                           already_seen=None):\n        \"\"\"\n        Return the table alias (the name might be ambiguous, the alias will\n        not be) and column name for ordering by the given 'name' parameter.\n        The 'name' is of the form 'field1__field2__...__fieldN'.\n        \"\"\"\n        name, order = get_order_dir(name, default_order)\n        descending = order == 'DESC'\n        pieces = name.split(LOOKUP_SEP)\n        field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless the attribute name\n        # of the field is specified.\n        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n            results = []\n            for item in opts.ordering:\n                results.extend(self.find_ordering_name(item, opts, alias,\n                                                       default_order, already_seen))\n            return results\n        targets, alias, _ = self.query.trim_joins(targets, joins, path)\n        return [(OrderBy(transform_function(targets[0], alias), descending=descending), False)]\n",
      "\n    def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n                           already_seen=None):\n        \"\"\"\n        Return the table alias (the name might be ambiguous, the alias will\n        not be) and column name for ordering by the given 'name' parameter.\n        The 'name' is of the form 'field1__field2__...__fieldN'.\n        \"\"\"\n        name, order = get_order_dir(name, default_order)\n        descending = order == 'DESC'\n        pieces = name.split(LOOKUP_SEP)\n        field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless the attribute name\n        # of the field is specified.\n        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n            results = []\n            for item in opts.ordering:\n                results.extend(self.find_ordering_name(item, opts, alias, default_order, already_seen))\n            return results\n        targets, alias, _ = self.query.trim_joins(targets, joins, path)\n        return [(OrderBy(transform_function(targets[0], alias), descending=descending), False)]\n",
      "\n    def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n                           already_seen=None):\n        \"\"\"\n        Return the table alias (the name might be ambiguous, the alias will\n        not be) and column name for ordering by the given 'name' parameter.\n        The 'name' is of the form 'field1__field2__...__fieldN'.\n        \"\"\"\n        name, order = get_order_dir(name, default_order)\n        descending = order == 'DESC'\n        pieces = name.split(LOOKUP_SEP)\n        field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless the attribute name\n        # of the field is specified.\n        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n\n            results = []\n            for item in opts.ordering:\n                results.extend(self.find_ordering_name(item, opts, alias, default_order, already_seen))\n            return results\n        targets, alias, _ = self.query.trim_joins(targets, joins, path)\n        return [(OrderBy(transform_function(targets[0], alias), descending=descending), False)]\n",
      "\n    def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n                           already_seen=None):\n        \"\"\"\n        Return the table alias (the name might be ambiguous, the alias will\n        not be) and column name for ordering by the given 'name' parameter.\n        The 'name' is of the form 'field1__field2__...__fieldN'.\n        \"\"\"\n        name, order = get_order_dir(name, default_order)\n        descending = order == 'DESC'\n        pieces = name.split(LOOKUP_SEP)\n        field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless the attribute name\n        # of the field is specified.\n        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n            results = []\n            for item in opts.ordering:\n                results.extend(self.find_ordering_name(item, opts, alias, default_order, already_seen))\n            return results\n        targets, alias, _ = self.query.trim_joins(targets, joins, path)\n        return [(OrderBy(transform_function(targets[0], alias), descending=descending), False)]\n",
      "\n    def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n                           already_seen=None):\n        \"\"\"\n        Return the table alias (the name might be ambiguous, the alias will\n        not be) and column name for ordering by the given 'name' parameter.\n        The 'name' is of the form 'field1__field2__...__fieldN'.\n        \"\"\"\n        name, order = get_order_dir(name, default_order)\n        descending = order == 'DESC'\n        pieces = name.split(LOOKUP_SEP)\n        field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless the attribute name\n        # of the field is specified.\n        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n            results = []\n            for item in opts.ordering:\n                results.extend(self.find_ordering_name(item, opts, alias, default_order, already_seen))\n            return results\n        targets, alias, _ = self.query.trim_joins(targets, joins, path)\n        return [(OrderBy(transform_function(targets[0], alias), descending=descending), False)]\n",
      "\n    def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n                           already_seen=None):\n        \"\"\"\n        Return the table alias (the name might be ambiguous, the alias will\n        not be) and column name for ordering by the given 'name' parameter.\n        The 'name' is of the form 'field1__field2__...__fieldN'.\n        \"\"\"\n        name, order = get_order_dir(name, default_order)\n        descending = order == 'DESC'\n        pieces = name.split(LOOKUP_SEP)\n        field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless the attribute name\n        # of the field is specified.\n        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n            results = []\n            for item in opts.ordering:\n                results.extend(self.find_ordering_name(item, opts, alias, default_order, already_seen))\n            return results\n        targets, alias, _ = self.query.trim_joins(targets, joins, path)\n        return [(OrderBy(transform_function(targets[0], alias), descending=descending), False)]\n",
      "\n    def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n                           already_seen=None):\n        \"\"\"\n        Return the table alias (the name might be ambiguous, the alias will\n        not be) and column name for ordering by the given 'name' parameter.\n        The 'name' is of the form 'field1__field2__...__fieldN'.\n        \"\"\"\n        name, order = get_order_dir(name, default_order)\n        descending = order == 'DESC'\n        pieces = name.split(LOOKUP_SEP)\n        field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n\n        # If we get to this point and the field is a relation to another model,\n        # append the default ordering for that model unless the attribute name\n        # of the field is specified.\n        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n            # Firstly, avoid infinite loops.\n            already_seen = already_seen or set()\n            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n            if join_tuple in already_seen:\n                raise FieldError('Infinite loop caused by ordering.')\n            already_seen.add(join_tuple)\n            results = []\n            for item in opts.ordering:\n                results.extend(self.find_ordering_name(item, opts, alias, default_order, already_seen))\n            return results\n        targets, alias, _ = self.query.trim_joins(targets, joins, path)\n        return [(OrderBy(transform_function(targets[0], alias), descending=descending), False)]\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 92213a4e67..33190ba29b 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -337,6 +337,7 @@ class SQLCompiler:\n             if not self.query.extra or col not in self.query.extra:\n                 # 'col' is of the form 'field' or 'field1__field2' or\n                 # '-field1__field2__field', etc.\n+\n                 order_by.extend(self.find_ordering_name(\n                     field, self.query.get_meta(), default_order=asc))\n             else:\n@@ -696,6 +697,7 @@ class SQLCompiler:\n                     params.append(p)\n         return result, params\n \n+\n     def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n                            already_seen=None):\n         \"\"\"\n@@ -706,11 +708,13 @@ class SQLCompiler:\n         name, order = get_order_dir(name, default_order)\n         descending = order == 'DESC'\n         pieces = name.split(LOOKUP_SEP)\n+        pieces = name.split(LOOKUP_SEP)\n         field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n \n         # If we get to this point and the field is a relation to another model,\n         # append the default ordering for that model unless the attribute name\n         # of the field is specified.\n+\n         if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n             # Firstly, avoid infinite loops.\n             already_seen = already_seen or set()\n@@ -727,7 +731,8 @@ class SQLCompiler:\n                     results.append((item, False))\n                     continue\n                 results.extend(self.find_ordering_name(item, opts, alias,\n-                                                       order, already_seen))\n+                                                       default_order, already_seen))\n+            return results\n             return results\n         targets, alias, _ = self.query.trim_joins(targets, joins, path)\n         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]\n",
    "variant_0": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 92213a4e67..6fbfb9adcc 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -337,8 +337,9 @@ class SQLCompiler:\n             if not self.query.extra or col not in self.query.extra:\n                 # 'col' is of the form 'field' or 'field1__field2' or\n                 # '-field1__field2__field', etc.\n+\n                 order_by.extend(self.find_ordering_name(\n-                    field, self.query.get_meta(), default_order=asc))\n+                    field, self.query.get_meta(), default_order=default_order))\n             else:\n                 if col not in self.query.extra_select:\n                     order_by.append((\n@@ -696,6 +697,7 @@ class SQLCompiler:\n                     params.append(p)\n         return result, params\n \n+\n     def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n                            already_seen=None):\n         \"\"\"\n@@ -711,6 +713,26 @@ class SQLCompiler:\n         # If we get to this point and the field is a relation to another model,\n         # append the default ordering for that model unless the attribute name\n         # of the field is specified.\n+        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n+            # Firstly, avoid infinite loops.\n+            already_seen = already_seen or set()\n+            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n+            if join_tuple in already_seen:\n+                raise FieldError('Infinite loop caused by ordering.')\n+            already_seen.add(join_tuple)\n+            results = []\n+            for item in opts.ordering:\n+                results.extend(self.find_ordering_name(item, opts, alias,\n+                                                       default_order, already_seen))\n+            return results\n+        targets, alias, _ = self.query.trim_joins(targets, joins, path)\n+        return [(OrderBy(transform_function(targets[0], alias), descending=descending), False)]\n+        field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n+\n+        # If we get to this point and the field is a relation to another model,\n+        # append the default ordering for that model unless the attribute name\n+        # of the field is specified.\n+\n         if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n             # Firstly, avoid infinite loops.\n             already_seen = already_seen or set()\n@@ -727,7 +749,8 @@ class SQLCompiler:\n                     results.append((item, False))\n                     continue\n                 results.extend(self.find_ordering_name(item, opts, alias,\n-                                                       order, already_seen))\n+                                                       default_order, already_seen))\n+            return results\n             return results\n         targets, alias, _ = self.query.trim_joins(targets, joins, path)\n         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]\n",
    "variant_1": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 92213a4e67..c9384009b6 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -337,8 +337,9 @@ class SQLCompiler:\n             if not self.query.extra or col not in self.query.extra:\n                 # 'col' is of the form 'field' or 'field1__field2' or\n                 # '-field1__field2__field', etc.\n+\n                 order_by.extend(self.find_ordering_name(\n-                    field, self.query.get_meta(), default_order=asc))\n+                    field, self.query.get_meta(), default_order=default_order))\n             else:\n                 if col not in self.query.extra_select:\n                     order_by.append((\n@@ -696,6 +697,7 @@ class SQLCompiler:\n                     params.append(p)\n         return result, params\n \n+\n     def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n                            already_seen=None):\n         \"\"\"\n@@ -708,9 +710,63 @@ class SQLCompiler:\n         pieces = name.split(LOOKUP_SEP)\n         field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n \n+        # If we get to this point and the field is a relation to another model,\n+        # append the default ordering for that model unless the attribute name\n+        # of the field is specified.\n+        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n+            # Firstly, avoid infinite loops.\n+            already_seen = already_seen or set()\n+            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n+            if join_tuple in already_seen:\n+                raise FieldError('Infinite loop caused by ordering.')\n+            already_seen.add(join_tuple)\n+            results = []\n+            for item in opts.ordering:\n+                results.extend(self.find_ordering_name(item, opts, alias, default_order, already_seen))\n+            return results\n+        targets, alias, _ = self.query.trim_joins(targets, joins, path)\n+        return [(OrderBy(transform_function(targets[0], alias), descending=descending), False)]\n+        \"\"\"\n+        Return the table alias (the name might be ambiguous, the alias will\n+        not be) and column name for ordering by the given 'name' parameter.\n+        The 'name' is of the form 'field1__field2__...__fieldN'.\n+        \"\"\"\n+        name, order = get_order_dir(name, default_order)\n+        descending = order == 'DESC'\n+        pieces = name.split(LOOKUP_SEP)\n+        field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n+\n         # If we get to this point and the field is a relation to another model,\n         # append the default ordering for that model unless the attribute name\n         # of the field is specified.\n+        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n+            # Firstly, avoid infinite loops.\n+            already_seen = already_seen or set()\n+            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n+            if join_tuple in already_seen:\n+                raise FieldError('Infinite loop caused by ordering.')\n+            already_seen.add(join_tuple)\n+\n+            results = []\n+            for item in opts.ordering:\n+                if hasattr(item, 'resolve_expression') and not isinstance(item, OrderBy):\n+                    item = item.desc() if descending else item.asc()\n+                    results.append((item, False))\n+                    continue\n+                if isinstance(item, OrderBy):\n+                    results.append((item, False))\n+                    continue\n+                results.extend(self.find_ordering_name(item, opts, alias, default_order, already_seen))\n+            return results\n+        targets, alias, _ = self.query.trim_joins(targets, joins, path)\n+        return [(OrderBy(transform_function(targets[0], alias), descending=descending), False)]\n+        pieces = name.split(LOOKUP_SEP)\n+        field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n+\n+        # If we get to this point and the field is a relation to another model,\n+        # append the default ordering for that model unless the attribute name\n+        # of the field is specified.\n+\n         if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n             # Firstly, avoid infinite loops.\n             already_seen = already_seen or set()\n@@ -727,7 +783,8 @@ class SQLCompiler:\n                     results.append((item, False))\n                     continue\n                 results.extend(self.find_ordering_name(item, opts, alias,\n-                                                       order, already_seen))\n+                                                       default_order, already_seen))\n+            return results\n             return results\n         targets, alias, _ = self.query.trim_joins(targets, joins, path)\n         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]\n",
    "variant_2": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 92213a4e67..c626b2603b 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -337,6 +337,7 @@ class SQLCompiler:\n             if not self.query.extra or col not in self.query.extra:\n                 # 'col' is of the form 'field' or 'field1__field2' or\n                 # '-field1__field2__field', etc.\n+\n                 order_by.extend(self.find_ordering_name(\n                     field, self.query.get_meta(), default_order=asc))\n             else:\n@@ -696,6 +697,7 @@ class SQLCompiler:\n                     params.append(p)\n         return result, params\n \n+\n     def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n                            already_seen=None):\n         \"\"\"\n@@ -711,6 +713,39 @@ class SQLCompiler:\n         # If we get to this point and the field is a relation to another model,\n         # append the default ordering for that model unless the attribute name\n         # of the field is specified.\n+        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n+            # Firstly, avoid infinite loops.\n+            already_seen = already_seen or set()\n+            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n+            if join_tuple in already_seen:\n+                raise FieldError('Infinite loop caused by ordering.')\n+            already_seen.add(join_tuple)\n+            results = []\n+            for item in opts.ordering:\n+                results.extend(self.find_ordering_name(item, opts, alias,\n+                                                       default_order, already_seen))\n+            return results\n+        targets, alias, _ = self.query.trim_joins(targets, joins, path)\n+        return [(OrderBy(transform_function(targets[0], alias), descending=descending), False)]\n+        # of the field is specified.\n+        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n+            # Firstly, avoid infinite loops.\n+            already_seen = already_seen or set()\n+            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n+            if join_tuple in already_seen:\n+                raise FieldError('Infinite loop caused by ordering.')\n+            already_seen.add(join_tuple)\n+            results = []\n+            for item in opts.ordering:\n+                results.extend(self.find_ordering_name(item, opts, alias, default_order, already_seen))\n+            return results\n+        pieces = name.split(LOOKUP_SEP)\n+        field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n+\n+        # If we get to this point and the field is a relation to another model,\n+        # append the default ordering for that model unless the attribute name\n+        # of the field is specified.\n+\n         if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n             # Firstly, avoid infinite loops.\n             already_seen = already_seen or set()\n@@ -727,7 +762,8 @@ class SQLCompiler:\n                     results.append((item, False))\n                     continue\n                 results.extend(self.find_ordering_name(item, opts, alias,\n-                                                       order, already_seen))\n+                                                       default_order, already_seen))\n+            return results\n             return results\n         targets, alias, _ = self.query.trim_joins(targets, joins, path)\n         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]\n",
    "variant_3": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 92213a4e67..0638623857 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -337,8 +337,8 @@ class SQLCompiler:\n             if not self.query.extra or col not in self.query.extra:\n                 # 'col' is of the form 'field' or 'field1__field2' or\n                 # '-field1__field2__field', etc.\n-                order_by.extend(self.find_ordering_name(\n-                    field, self.query.get_meta(), default_order=asc))\n+\n+                results.extend(self.find_ordering_name(item, opts, alias, default_order, already_seen))\n             else:\n                 if col not in self.query.extra_select:\n                     order_by.append((\n@@ -696,6 +696,7 @@ class SQLCompiler:\n                     params.append(p)\n         return result, params\n \n+\n     def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n                            already_seen=None):\n         \"\"\"\n@@ -708,6 +709,42 @@ class SQLCompiler:\n         pieces = name.split(LOOKUP_SEP)\n         field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n \n+        # If we get to this point and the field is a relation to another model,\n+        # append the default ordering for that model unless the attribute name\n+        # of the field is specified.\n+        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n+            # Firstly, avoid infinite loops.\n+            already_seen = already_seen or set()\n+            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n+            if join_tuple in already_seen:\n+                raise FieldError('Infinite loop caused by ordering.')\n+            already_seen.add(join_tuple)\n+            results = []\n+            for item in opts.ordering:\n+                results.extend(self.find_ordering_name(item, opts, alias, default_order, already_seen))\n+            return results\n+        targets, alias, _ = self.query.trim_joins(targets, joins, path)\n+        return [(OrderBy(transform_function(targets[0], alias), descending=descending), False)]\n+        # of the field is specified.\n+        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n+            # Firstly, avoid infinite loops.\n+            already_seen = already_seen or set()\n+            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n+            if join_tuple in already_seen:\n+                raise FieldError('Infinite loop caused by ordering.')\n+            already_seen.add(join_tuple)\n+\n+            results = []\n+            for item in opts.ordering:\n+                results.extend(self.find_ordering_name(item, opts, alias, default_order, already_seen))\n+            return results\n+        pieces = name.split(LOOKUP_SEP)\n+        field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n+\n+        # If we get to this point and the field is a relation to another model,\n+        # append the default ordering for that model unless the attribute name\n+        # of the field is specified.\n+\n         # If we get to this point and the field is a relation to another model,\n         # append the default ordering for that model unless the attribute name\n         # of the field is specified.\n@@ -727,7 +764,8 @@ class SQLCompiler:\n                     results.append((item, False))\n                     continue\n                 results.extend(self.find_ordering_name(item, opts, alias,\n-                                                       order, already_seen))\n+                                                       default_order, already_seen))\n+            return results\n             return results\n         targets, alias, _ = self.query.trim_joins(targets, joins, path)\n         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]\n",
    "variant_4": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 92213a4e67..e2039103a3 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -337,8 +337,9 @@ class SQLCompiler:\n             if not self.query.extra or col not in self.query.extra:\n                 # 'col' is of the form 'field' or 'field1__field2' or\n                 # '-field1__field2__field', etc.\n+\n                 order_by.extend(self.find_ordering_name(\n-                    field, self.query.get_meta(), default_order=asc))\n+                    field, self.query.get_meta(), default_order=default_order))\n             else:\n                 if col not in self.query.extra_select:\n                     order_by.append((\n@@ -696,6 +697,7 @@ class SQLCompiler:\n                     params.append(p)\n         return result, params\n \n+\n     def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n                            already_seen=None):\n         \"\"\"\n@@ -708,6 +710,44 @@ class SQLCompiler:\n         pieces = name.split(LOOKUP_SEP)\n         field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n \n+        # If we get to this point and the field is a relation to another model,\n+        # append the default ordering for that model unless the attribute name\n+        # of the field is specified.\n+        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n+            # Firstly, avoid infinite loops.\n+            already_seen = already_seen or set()\n+            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n+            if join_tuple in already_seen:\n+                raise FieldError('Infinite loop caused by ordering.')\n+            already_seen.add(join_tuple)\n+\n+            results = []\n+            for item in opts.ordering:\n+                results.extend(self.find_ordering_name(item, opts, alias, default_order, already_seen))\n+            return results\n+        targets, alias, _ = self.query.trim_joins(targets, joins, path)\n+        return [(OrderBy(transform_function(targets[0], alias), descending=descending), False)]\n+        # of the field is specified.\n+        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n+            # Firstly, avoid infinite loops.\n+            already_seen = already_seen or set()\n+            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n+            if join_tuple in already_seen:\n+                raise FieldError('Infinite loop caused by ordering.')\n+            already_seen.add(join_tuple)\n+            results = []\n+            for item in opts.ordering:\n+                results.extend(self.find_ordering_name(item, opts, alias, default_order, already_seen))\n+            return results\n+        targets, alias, _ = self.query.trim_joins(targets, joins, path)\n+        return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]\n+        pieces = name.split(LOOKUP_SEP)\n+        field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n+\n+        # If we get to this point and the field is a relation to another model,\n+        # append the default ordering for that model unless the attribute name\n+        # of the field is specified.\n+\n         # If we get to this point and the field is a relation to another model,\n         # append the default ordering for that model unless the attribute name\n         # of the field is specified.\n@@ -727,7 +767,8 @@ class SQLCompiler:\n                     results.append((item, False))\n                     continue\n                 results.extend(self.find_ordering_name(item, opts, alias,\n-                                                       order, already_seen))\n+                                                       default_order, already_seen))\n+            return results\n             return results\n         targets, alias, _ = self.query.trim_joins(targets, joins, path)\n         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]\n",
    "variant_5": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 92213a4e67..4d47caaff8 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -337,6 +337,7 @@ class SQLCompiler:\n             if not self.query.extra or col not in self.query.extra:\n                 # 'col' is of the form 'field' or 'field1__field2' or\n                 # '-field1__field2__field', etc.\n+\n                 order_by.extend(self.find_ordering_name(\n                     field, self.query.get_meta(), default_order=asc))\n             else:\n@@ -696,6 +697,7 @@ class SQLCompiler:\n                     params.append(p)\n         return result, params\n \n+\n     def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n                            already_seen=None):\n         \"\"\"\n@@ -708,6 +710,45 @@ class SQLCompiler:\n         pieces = name.split(LOOKUP_SEP)\n         field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n \n+        # If we get to this point and the field is a relation to another model,\n+        # append the default ordering for that model unless the attribute name\n+        # of the field is specified.\n+        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n+            # Firstly, avoid infinite loops.\n+            already_seen = already_seen or set()\n+            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n+            if join_tuple in already_seen:\n+                raise FieldError('Infinite loop caused by ordering.')\n+            already_seen.add(join_tuple)\n+            results = []\n+            for item in opts.ordering:\n+                results.extend(self.find_ordering_name(item, opts, alias, default_order, already_seen))\n+            return results\n+        targets, alias, _ = self.query.trim_joins(targets, joins, path)\n+        return [(OrderBy(transform_function(targets[0], alias), descending=descending), False)]\n+        # of the field is specified.\n+        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n+            # Firstly, avoid infinite loops.\n+            already_seen = already_seen or set()\n+            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n+            if join_tuple in already_seen:\n+                raise FieldError('Infinite loop caused by ordering.')\n+            already_seen.add(join_tuple)\n+\n+            results = []\n+            for item in opts.ordering:\n+                results.extend(self.find_ordering_name(item, opts, alias,\n+                                                      default_order, already_seen))\n+            return results\n+        targets, alias, _ = self.query.trim_joins(targets, joins, path)\n+        return [(OrderBy(transform_function(targets[0], alias), descending=descending), False)]\n+        pieces = name.split(LOOKUP_SEP)\n+        field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n+\n+        # If we get to this point and the field is a relation to another model,\n+        # append the default ordering for that model unless the attribute name\n+        # of the field is specified.\n+\n         # If we get to this point and the field is a relation to another model,\n         # append the default ordering for that model unless the attribute name\n         # of the field is specified.\n@@ -727,7 +768,8 @@ class SQLCompiler:\n                     results.append((item, False))\n                     continue\n                 results.extend(self.find_ordering_name(item, opts, alias,\n-                                                       order, already_seen))\n+                                                       default_order, already_seen))\n+            return results\n             return results\n         targets, alias, _ = self.query.trim_joins(targets, joins, path)\n         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]\n",
    "variant_6": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 92213a4e67..1c3d9ef15d 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -337,6 +337,7 @@ class SQLCompiler:\n             if not self.query.extra or col not in self.query.extra:\n                 # 'col' is of the form 'field' or 'field1__field2' or\n                 # '-field1__field2__field', etc.\n+\n                 order_by.extend(self.find_ordering_name(\n                     field, self.query.get_meta(), default_order=asc))\n             else:\n@@ -696,6 +697,7 @@ class SQLCompiler:\n                     params.append(p)\n         return result, params\n \n+\n     def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n                            already_seen=None):\n         \"\"\"\n@@ -708,6 +710,28 @@ class SQLCompiler:\n         pieces = name.split(LOOKUP_SEP)\n         field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n \n+        # If we get to this point and the field is a relation to another model,\n+        # append the default ordering for that model unless the attribute name\n+        # of the field is specified.\n+        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n+            # Firstly, avoid infinite loops.\n+            already_seen = already_seen or set()\n+            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n+            if join_tuple in already_seen:\n+                raise FieldError('Infinite loop caused by ordering.')\n+            already_seen.add(join_tuple)\n+            results = []\n+            for item in opts.ordering:\n+                results.extend(self.find_ordering_name(item, opts, alias, default_order, already_seen))\n+            return results\n+        targets, alias, _ = self.query.trim_joins(targets, joins, path)\n+        return [(OrderBy(transform_function(targets[0], alias), descending=descending), False)]\n+        field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n+\n+        # If we get to this point and the field is a relation to another model,\n+        # append the default ordering for that model unless the attribute name\n+        # of the field is specified.\n+\n         # If we get to this point and the field is a relation to another model,\n         # append the default ordering for that model unless the attribute name\n         # of the field is specified.\n@@ -727,7 +751,8 @@ class SQLCompiler:\n                     results.append((item, False))\n                     continue\n                 results.extend(self.find_ordering_name(item, opts, alias,\n-                                                       order, already_seen))\n+                                                       default_order, already_seen))\n+            return results\n             return results\n         targets, alias, _ = self.query.trim_joins(targets, joins, path)\n         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]\n",
    "variant_7": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 92213a4e67..16a99b196a 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -337,8 +337,9 @@ class SQLCompiler:\n             if not self.query.extra or col not in self.query.extra:\n                 # 'col' is of the form 'field' or 'field1__field2' or\n                 # '-field1__field2__field', etc.\n+\n                 order_by.extend(self.find_ordering_name(\n-                    field, self.query.get_meta(), default_order=asc))\n+                    field, self.query.get_meta(), default_order=default_order))\n             else:\n                 if col not in self.query.extra_select:\n                     order_by.append((\n@@ -696,6 +697,7 @@ class SQLCompiler:\n                     params.append(p)\n         return result, params\n \n+\n     def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n                            already_seen=None):\n         \"\"\"\n@@ -708,6 +710,46 @@ class SQLCompiler:\n         pieces = name.split(LOOKUP_SEP)\n         field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n \n+        # If we get to this point and the field is a relation to another model,\n+        # append the default ordering for that model unless the attribute name\n+        # of the field is specified.\n+        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n+            # Firstly, avoid infinite loops.\n+            already_seen = already_seen or set()\n+            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n+            if join_tuple in already_seen:\n+                raise FieldError('Infinite loop caused by ordering.')\n+            already_seen.add(join_tuple)\n+            results = []\n+            for item in opts.ordering:\n+                results.extend(self.find_ordering_name(item, opts, alias, default_order, already_seen))\n+            return results\n+        targets, alias, _ = self.query.trim_joins(targets, joins, path)\n+        return [(OrderBy(transform_function(targets[0], alias), descending=descending), False)]\n+                join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n+                if join_tuple in already_seen:\n+                    raise FieldError('Infinite loop caused by ordering.')\n+                already_seen.add(join_tuple)\n+\n+                results = []\n+                for item in opts.ordering:\n+                    if isinstance(item, OrderBy) and isinstance(item.expression, F):\n+                        item = item.expression.name\n+                    if hasattr(item, 'resolve_expression'):\n+                        # We only support expressions that have a target field.\n+                        if not hasattr(item, 'target'):\n+                            continue\n+                        results.extend(self.find_ordering_name(item, opts, alias, default_order, already_seen))\n+                    else:\n+                        results.extend(self.find_ordering_name(item, opts, alias, default_order, already_seen))\n+                return results\n+        pieces = name.split(LOOKUP_SEP)\n+        field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n+\n+        # If we get to this point and the field is a relation to another model,\n+        # append the default ordering for that model unless the attribute name\n+        # of the field is specified.\n+\n         # If we get to this point and the field is a relation to another model,\n         # append the default ordering for that model unless the attribute name\n         # of the field is specified.\n@@ -727,7 +769,8 @@ class SQLCompiler:\n                     results.append((item, False))\n                     continue\n                 results.extend(self.find_ordering_name(item, opts, alias,\n-                                                       order, already_seen))\n+                                                       default_order, already_seen))\n+            return results\n             return results\n         targets, alias, _ = self.query.trim_joins(targets, joins, path)\n         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]\n",
    "variant_8": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 92213a4e67..cf70511d11 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -337,6 +337,7 @@ class SQLCompiler:\n             if not self.query.extra or col not in self.query.extra:\n                 # 'col' is of the form 'field' or 'field1__field2' or\n                 # '-field1__field2__field', etc.\n+\n                 order_by.extend(self.find_ordering_name(\n                     field, self.query.get_meta(), default_order=asc))\n             else:\n@@ -696,6 +697,7 @@ class SQLCompiler:\n                     params.append(p)\n         return result, params\n \n+\n     def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n                            already_seen=None):\n         \"\"\"\n@@ -711,6 +713,39 @@ class SQLCompiler:\n         # If we get to this point and the field is a relation to another model,\n         # append the default ordering for that model unless the attribute name\n         # of the field is specified.\n+        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n+            # Firstly, avoid infinite loops.\n+            already_seen = already_seen or set()\n+            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n+            if join_tuple in already_seen:\n+                raise FieldError('Infinite loop caused by ordering.')\n+            already_seen.add(join_tuple)\n+            results = []\n+            for item in opts.ordering:\n+                results.extend(self.find_ordering_name(item, opts, alias, default_order, already_seen))\n+            return results\n+        targets, alias, _ = self.query.trim_joins(targets, joins, path)\n+        return [(OrderBy(transform_function(targets[0], alias), descending=descending), False)]\n+        # of the field is specified.\n+        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n+            # Firstly, avoid infinite loops.\n+            already_seen = already_seen or set()\n+            join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n+            if join_tuple in already_seen:\n+                raise FieldError('Infinite loop caused by ordering.')\n+            already_seen.add(join_tuple)\n+\n+            results = []\n+            for item in opts.ordering:\n+                results.extend(self.find_ordering_name(item, opts, alias, default_order, already_seen))\n+            return results\n+        pieces = name.split(LOOKUP_SEP)\n+        field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n+\n+        # If we get to this point and the field is a relation to another model,\n+        # append the default ordering for that model unless the attribute name\n+        # of the field is specified.\n+\n         if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:\n             # Firstly, avoid infinite loops.\n             already_seen = already_seen or set()\n@@ -727,7 +762,8 @@ class SQLCompiler:\n                     results.append((item, False))\n                     continue\n                 results.extend(self.find_ordering_name(item, opts, alias,\n-                                                       order, already_seen))\n+                                                       default_order, already_seen))\n+            return results\n             return results\n         targets, alias, _ = self.query.trim_joins(targets, joins, path)\n         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]\n"
  }
}