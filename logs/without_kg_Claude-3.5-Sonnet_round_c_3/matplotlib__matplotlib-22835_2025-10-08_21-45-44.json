{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/matplotlib/lib/matplotlib/artist.py lines 1307-1308)": "\n            if np.isfinite(normed):\n                # Midpoints of neighboring color intervals.\n                try:\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Fallback for non-invertible normalizers like BoundaryNorm\n                    g_sig_digits = 3  # Consistent with default below.\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n",
    "Location 2 (/root/hy/projects_3/matplotlib/lib/matplotlib/artist.py lines 1305-1313)": "\n        if np.isfinite(normed):\n            # Midpoints of neighboring color intervals.\n            try:\n                neighbors = self.norm.inverse(\n                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                delta = abs(neighbors - data).max()\n                g_sig_digits = cbook._g_sig_digits(data, delta)\n            except ValueError:\n                # Fallback for non-invertible normalizers like BoundaryNorm\n                g_sig_digits = 3  # Consistent with default below.\n        else:\n            g_sig_digits = 3  # Consistent with default below.\n        return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n",
    "Location 3 (/root/hy/projects_3/matplotlib/lib/matplotlib/colors.py lines 1904-1912)": "\n    def format_cursor_data(self, data):\n        \"\"\"\n        Return a string representation of *data*.\n\n        .. note::\n            This method is intended to be overridden by artist subclasses.\n            As an end-user of Matplotlib you will most likely not call this\n            method yourself.\n\n        The default implementation converts ints and floats and arrays of ints\n        and floats into a comma-separated string enclosed in square brackets,\n        unless the artist has an associated colorbar, in which case scalar\n        values are formatted using the colorbar's formatter.\n\n        See Also\n        --------\n        .format_cursor_data\n        \"\"\"\n        try:\n            # Comment to avoid issues with tight bbox when\n            # rc_context is used such as in rc_context test\n            if hasattr(self, 'norm') and self.norm is not None:\n                normed = self.norm(data)\n                if np.isfinite(normed):\n                    try:\n                        neighbors = self.norm.inverse(\n                            (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                        delta = abs(neighbors - data).max()\n                        g_sig_digits = cbook._g_sig_digits(data, delta)\n                    except ValueError:\n                        # Fallback for non-invertible normalizers like BoundaryNorm\n                        g_sig_digits = 3\n                else:\n                    g_sig_digits = 3\n            else:\n                g_sig_digits = 3\n        except (TypeError, IndexError):\n            g_sig_digits = 3\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/matplotlib/lib/matplotlib/artist.py lines 1307-1308)": [
      "\n            if np.isfinite(normed):\n                # Midpoints of neighboring color intervals.\n                try:\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Fallback for non-invertible normalizers like BoundaryNorm\n                    g_sig_digits = 3  # Consistent with default below.\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n",
      "\n            if np.isfinite(normed):\n                # Midpoints of neighboring color intervals.\n                try:\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Fallback for non-invertible normalizers like BoundaryNorm\n                    g_sig_digits = 3  # Consistent with default below.\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n",
      "\n            if np.isfinite(normed):\n                # Midpoints of neighboring color intervals.\n                try:\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Fallback for non-invertible normalizers like BoundaryNorm\n                    g_sig_digits = 3  # Consistent with default below.\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n",
      "\n            if np.isfinite(normed):\n                # Midpoints of neighboring color intervals.\n                try:\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Fallback for non-invertible normalizers like BoundaryNorm\n                    g_sig_digits = 3  # Consistent with default below.\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n",
      "\n            if np.isfinite(normed):\n                # Midpoints of neighboring color intervals.\n                try:\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Fallback for non-invertible normalizers like BoundaryNorm\n                    g_sig_digits = 3  # Consistent with default below.\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n",
      "\n            if np.isfinite(normed):\n                # Midpoints of neighboring color intervals.\n                try:\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Fallback for non-invertible normalizers like BoundaryNorm\n                    g_sig_digits = 3  # Consistent with default below.\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n",
      "\n            if np.isfinite(normed):\n                # Midpoints of neighboring color intervals.\n                try:\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Fallback for non-invertible normalizers like BoundaryNorm\n                    g_sig_digits = 3  # Consistent with default below.\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n",
      "\n            if np.isfinite(normed):\n                # Midpoints of neighboring color intervals.\n                try:\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Fallback for non-invertible normalizers like BoundaryNorm\n                    g_sig_digits = 3  # Consistent with default below.\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n"
    ],
    "Location 2 (/root/hy/projects_3/matplotlib/lib/matplotlib/artist.py lines 1305-1313)": [
      "\n        if np.isfinite(normed):\n            # Midpoints of neighboring color intervals.\n            try:\n                neighbors = self.norm.inverse(\n                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                delta = abs(neighbors - data).max()\n                g_sig_digits = cbook._g_sig_digits(data, delta)\n            except ValueError:\n                # Fallback for non-invertible normalizers like BoundaryNorm\n                g_sig_digits = 3  # Consistent with default below.\n        else:\n            g_sig_digits = 3  # Consistent with default below.\n        return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n",
      "\n        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n            # This block logically belongs to ScalarMappable, but can't be\n            # implemented in it because most ScalarMappable subclasses inherit\n            # from Artist first and from ScalarMappable second, so\n            # Artist.format_cursor_data would always have precedence over\n            # ScalarMappable.format_cursor_data.\n            n = self.cmap.N\n            if np.ma.getmask(data):\n                return \"[]\"\n            normed = self.norm(data)\n            if np.isfinite(normed):\n                try:\n                    # Midpoints of neighboring color intervals.\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Fallback for non-invertible normalizers like BoundaryNorm\n                    g_sig_digits = 3  # Consistent with default below.\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n",
      "\n        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n            # This block logically belongs to ScalarMappable, but can't be\n            # implemented in it because most ScalarMappable subclasses inherit\n            # from Artist first and from ScalarMappable second, so\n            # Artist.format_cursor_data would always have precedence over\n            # ScalarMappable.format_cursor_data.\n            n = self.cmap.N\n            if np.ma.getmask(data):\n                return \"[]\"\n            normed = self.norm(data)\n            if np.isfinite(normed):\n                # Midpoints of neighboring color intervals.\n                try:\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Fallback for non-invertible normalizers like BoundaryNorm\n                    g_sig_digits = 3  # Consistent with default below.\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n",
      "\n        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n            # This block logically belongs to ScalarMappable, but can't be\n            # implemented in it because most ScalarMappable subclasses inherit\n            # from Artist first and from ScalarMappable second, so\n            # Artist.format_cursor_data would always have precedence over\n            # ScalarMappable.format_cursor_data.\n            n = self.cmap.N\n            if np.ma.getmask(data):\n                return \"[]\"\n            normed = self.norm(data)\n            if np.isfinite(normed):\n                try:\n                    # Midpoints of neighboring color intervals.\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Fallback for non-invertible normalizers like BoundaryNorm\n                    g_sig_digits = 3  # Consistent with default below.\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n",
      "\n        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n            # This block logically belongs to ScalarMappable, but can't be\n            # implemented in it because most ScalarMappable subclasses inherit\n            # from Artist first and from ScalarMappable second, so\n            # Artist.format_cursor_data would always have precedence over\n            # ScalarMappable.format_cursor_data.\n            n = self.cmap.N\n            if np.ma.getmask(data):\n                return \"[]\"\n            normed = self.norm(data)\n            if np.isfinite(normed):\n                try:\n                    # Midpoints of neighboring color intervals.\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Fallback for non-invertible normalizers like BoundaryNorm\n                    g_sig_digits = 3  # Consistent with default below.\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n",
      "\n        if np.isfinite(normed):\n            # Midpoints of neighboring color intervals.\n            try:\n                neighbors = self.norm.inverse(\n                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                delta = abs(neighbors - data).max()\n                g_sig_digits = cbook._g_sig_digits(data, delta)\n            except ValueError:\n                # Fallback for non-invertible normalizers like BoundaryNorm\n                g_sig_digits = 3  # Consistent with default below.\n        else:\n            g_sig_digits = 3  # Consistent with default below.\n        return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n",
      "\n        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n            # This block logically belongs to ScalarMappable, but can't be\n            # implemented in it because most ScalarMappable subclasses inherit\n            # from Artist first and from ScalarMappable second, so\n            # Artist.format_cursor_data would always have precedence over\n            # ScalarMappable.format_cursor_data.\n            n = self.cmap.N\n            if np.ma.getmask(data):\n                return \"[]\"\n            normed = self.norm(data)\n            if np.isfinite(normed):\n                # Midpoints of neighboring color intervals.\n                try:\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Fallback for non-invertible normalizers like BoundaryNorm\n                    g_sig_digits = 3  # Consistent with default below.\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n",
      "\n        if np.isfinite(normed):\n            # Midpoints of neighboring color intervals.\n            try:\n                neighbors = self.norm.inverse(\n                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                delta = abs(neighbors - data).max()\n                g_sig_digits = cbook._g_sig_digits(data, delta)\n            except ValueError:\n                # Fallback for non-invertible normalizers like BoundaryNorm\n                g_sig_digits = 3  # Consistent with default below.\n        else:\n            g_sig_digits = 3  # Consistent with default below.\n        return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n"
    ],
    "Location 3 (/root/hy/projects_3/matplotlib/lib/matplotlib/colors.py lines 1904-1912)": [
      "\n    def format_cursor_data(self, data):\n        \"\"\"\n        Return a string representation of *data*.\n\n        .. note::\n           This method is intended to be overridden by artist subclasses.\n           As an end-user of Matplotlib you will most likely not call this\n           method yourself.\n\n        The default implementation converts ints and floats and arrays of ints\n        and floats into a comma-separated string enclosed in square brackets,\n        unless the artist has an associated colorbar, in which case scalar\n        values are formatted using the colorbar's formatter.\n\n        See Also\n        --------\n        get_cursor_data\n        \"\"\"\n        try:\n            # if we have a formatter (from a colorbar) we use it\n            if hasattr(self, 'colorbar') and self.colorbar is not None:\n                return self.colorbar.format_cursor_data(data)\n            # if we have a norm, we use that to get better precision for\n            # the cursor readout\n            if self.norm is not None:\n                # make sure this is a ndarray\n                data = np.asarray(data)\n                normed = self.norm(data)\n                if np.isfinite(normed):\n                    n = 256\n                    try:\n                        neighbors = self.norm.inverse(\n                            (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                        delta = abs(neighbors - data).max()\n                        g_sig_digits = cbook._g_sig_digits(data, delta)\n                    except ValueError:\n                        # Fallback for non-invertible normalizers like BoundaryNorm\n                        g_sig_digits = 3\n                else:\n                    g_sig_digits = 3\n                return \"[{:g}]\".format(data) if data.shape == () else \\\n                    \"[\" + \", \".join(\"{:{}g}\".format(v, g_sig_digits)\n                                    for v in data.flat) + \"]\"\n        except (TypeError, IndexError):\n            pass\n\n        try:\n            return '[' + ', '.join('{:0.3g}'.format(v) for v in data) + ']'\n        except (TypeError, ValueError):\n            return '{!r}'.format(data)\n",
      "\n        if np.isfinite(normed):\n            try:\n                neighbors = self.norm.inverse(\n                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                delta = abs(neighbors - data).max()\n                g_sig_digits = cbook._g_sig_digits(data, delta)\n            except ValueError:\n                # Fallback for non-invertible normalizers like BoundaryNorm\n                g_sig_digits = 3\n        else:\n            g_sig_digits = 3\n",
      "\n    def format_cursor_data(self, data):\n        \"\"\"\n        Return a string representation of *data*.\n\n        .. note::\n           This method is intended to be overridden by artist subclasses.\n           As an end-user of Matplotlib you will most likely not call this\n           method yourself.\n\n        The default implementation converts ints and floats and arrays of ints\n        and floats into a comma-separated string enclosed in square brackets,\n        unless the artist has an associated colorbar, in which case scalar\n        values are formatted using the colorbar's formatter.\n\n        See Also\n        --------\n        get_cursor_data\n        \"\"\"\n        if self.colorbar is not None and isinstance(data, (int, float)):\n            # Respect the colorbar's formatter, if present\n            if hasattr(self.colorbar, 'formatter'):\n                return self.colorbar.formatter.format_data_short(data)\n\n        try:\n            data = cbook._sanitize_sequence(data)\n        except ValueError:\n            pass\n        else:\n            if self.axes and hasattr(self.norm, 'inverse') and len(data) == 1:\n                # We have a single value in a mappable; check if it's in a\n                # plausible range for the normalization.\n                normed = self.norm(data)\n                if np.isfinite(normed):\n                    try:\n                        neighbors = self.norm.inverse(\n                            (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                        delta = abs(neighbors - data).max()\n                        g_sig_digits = cbook._g_sig_digits(data, delta)\n                    except ValueError:\n                        # Fallback for non-invertible normalizers like BoundaryNorm\n                        g_sig_digits = 3  # Consistent with default below\n                else:\n                    g_sig_digits = 3\n                data = cbook._g_sig_digits(data, g_sig_digits)\n        return \"[\" + \", \".join(map(str, data)) + \"]\"\n",
      "\n    def format_cursor_data(self, data):\n        \"\"\"\n        Return a string representation of *data*.\n\n        .. note::\n            This method is intended to be overridden by artist subclasses.\n            As an end-user of Matplotlib you will most likely not call this\n            method yourself.\n\n        The default implementation converts ints and floats and arrays of ints\n        and floats into a comma-separated string enclosed in square brackets,\n        unless the artist has an associated colorbar, in which case scalar\n        values are formatted using the colorbar's formatter.\n\n        See Also\n        --------\n        format_coord\n        \"\"\"\n        try:\n            # if we have a formatter from a colorbar, use it\n            if hasattr(self, 'colorbar') and self.colorbar is not None:\n                return self.colorbar.formatter.format_data_short(data)\n            # if we have a norm, try to use it\n            if self.norm is not None:\n                # Attempt to format the data using the norm\n                # In particular, LogNorm is able to format values\n                normed = self.norm(data)\n                if np.isfinite(normed):\n                    # Deltaless formatting for other norms.\n                    n = self.norm.N if hasattr(self.norm, 'N') else 256\n                    try:\n                        neighbors = self.norm.inverse(\n                            (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                        delta = abs(neighbors - data).max()\n                        g_sig_digits = cbook._g_sig_digits(data, delta)\n                    except ValueError:\n                        # Fallback for non-invertible normalizers like BoundaryNorm\n                        g_sig_digits = 3\n                else:\n                    g_sig_digits = 3\n                return cbook._auto_format_str(data, g_sig_digits)\n        except (TypeError, IndexError):\n            pass\n        return '{:1.4g}'.format(data)\n",
      "\n    def format_cursor_data(self, data):\n        \"\"\"\n        Return a string representation of *data*.\n\n        .. note::\n            This method is intended to be overridden by artist subclasses.\n            As an end-user of Matplotlib you will most likely not call this\n            method yourself.\n\n        The default implementation converts ints and floats and arrays of ints\n        and floats into a comma-separated string enclosed in square brackets,\n        unless the artist has an associated colorbar, in which case scalar\n        values are formatted using the colorbar's formatter.\n\n        See Also\n        --------\n        format_coord\n        \"\"\"\n        if self.get_array() is not None:\n            # Scalar mappable with array data\n            if hasattr(self, 'norm') and hasattr(self.norm, 'inverse'):\n                normed = self.norm(data)\n                if np.isfinite(normed):\n                    n = self.cmap.N\n                    try:\n                        neighbors = self.norm.inverse(\n                            (int(normed * n) + np.array([0, 1])) / n)\n                        delta = abs(neighbors - data).max()\n                        g_sig_digits = cbook._g_sig_digits(data, delta)\n                    except ValueError:\n                        # Fallback for non-invertible normalizers like BoundaryNorm\n                        g_sig_digits = 3  # Consistent with default below\n                else:\n                    g_sig_digits = 3\n                return \"{:-#.{}g}\".format(data, g_sig_digits)\n        return \"{:g}\".format(data)\n",
      "\n    def format_cursor_data(self, data):\n        \"\"\"\n        Return a string representation of *data*.\n\n        .. note::\n            This method is intended to be overridden by artist subclasses.\n            As an end-user of Matplotlib you will most likely not call this\n            method yourself.\n\n        The default implementation converts ints and floats and arrays of ints\n        and floats into a comma-separated string enclosed in square brackets,\n        unless the artist has an associated colorbar, in which case scalar\n        values are formatted using the colorbar's formatter.\n\n        See Also\n        --------\n        format_coord\n        \"\"\"\n        if self.colorbar is not None:\n            # we have a colorbar so format the data with the colorbar's\n            # formatter.  This must come first since we don't want to\n            # override the colorbar's format_cursor_data\n            return self.colorbar.format_cursor_data(data)\n\n        data = np.asarray(data)\n        data_str = cbook.format_approx(data, 3)\n        if data.ndim > 0:\n            return \"[\" + data_str + \"]\"\n        else:\n            return data_str\n\n    def format_coord(self, x, y):\n        \"\"\"\n        Return a string representation of the coordinates.\n\n        This method is intended to be overridden by artist subclasses.\n        As an end-user of Matplotlib you will most likely not call this\n        method yourself.\n\n        Parameters\n        ----------\n        x, y : float\n            The coordinates to format.\n\n        Returns\n        -------\n        str\n            The string representation of the coordinates.\n        \"\"\"\n        return f\"x={x:g}, y={y:g}\"\n\n    def get_cursor_data(self, event):\n        \"\"\"\n        Return the cursor data for a given event.\n\n        .. note::\n            This method is intended to be overridden by artist subclasses.\n            As an end-user of Matplotlib you will most likely not call this\n            method yourself.\n\n        Cursor data can be used by Artists to provide additional context\n        information for a given event. The default implementation just returns\n        *None*.\n\n        Subclasses can override the method and return arbitrary data. However,\n        when doing so, they must ensure that :meth:`format_cursor_data` can\n        convert the data to a string representation.\n\n        The only current use of this method is in conjunction with the\n        ``cursor`` tool.\n\n        Parameters\n        ----------\n        event : `matplotlib.backend_bases.MouseEvent`\n\n        Returns\n        -------\n        object\n            The cursor data for a given event, or *None* if no data is set.\n        \"\"\"\n        return None\n\n    def get_mouseover(self):\n        \"\"\"\n        Return whether this artist is queried for custom context information\n        when the mouse cursor moves over it.\n        \"\"\"\n        return self.mouseover\n\n    def set_mouseover(self, mouseover):\n        \"\"\"\n        Set whether this artist is queried for custom context information when\n        the mouse cursor moves over it.\n\n        Parameters\n        ----------\n        mouseover : bool\n        \"\"\"\n        self.mouseover = mouseover\n\n    def format_coord(self, x, y):\n        \"\"\"\n        Return a string representation of the coordinates.\n\n        This method is intended to be overridden by artist subclasses.\n        As an end-user of Matplotlib you will most likely not call this\n        method yourself.\n\n        Parameters\n        ----------\n        x, y : float\n            The coordinates to format.\n\n        Returns\n        -------\n        str\n            The string representation of the coordinates.\n        \"\"\"\n        return f\"x={x:g}, y={y:g}\"\n\n    def _format_coord(self, x, y):\n        \"\"\"\n        Return a string representation of the coordinates.\n\n        This method is intended to be overridden by artist subclasses.\n        As an end-user of Matplotlib you will most likely not call this\n        method yourself.\n\n        Parameters\n        ----------\n        x, y : float\n            The coordinates to format.\n\n        Returns\n        -------\n        str\n            The string representation of the coordinates.\n        \"\"\"\n        # note: this is a private method, and may be called with out-of-bounds\n        # coordinates.  It should not error out.\n        if np.isfinite(normed):\n            try:\n                neighbors = self.norm.inverse(\n                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                delta = abs(neighbors - data).max()\n                g_sig_digits = cbook._g_sig_digits(data, delta)\n            except ValueError:\n                # Fallback for non-invertible normalizers like BoundaryNorm\n                g_sig_digits = 3\n        else:\n            g_sig_digits = 3\n        s = cbook.format_approx(data, g_sig_digits)\n        return s\n",
      "\n    def _format_coord(self, x, y):\n        # convert from data coords -> pixel coords\n        xp, yp = self.axes.transData.transform((x, y))\n        # convert back from pixel coords -> new data coords (with pixel offset)\n        xd, yd = self.axes.transData.inverted().transform((xp, yp))\n        data = self.get_array()[int(yd), int(xd)]\n        # Compute precision to use for formatting: for this we need to\n        # process the data around the cursor position and not only the\n        # data at that position.\n        # First, we search in a cross around the position for the data\n        # points that will have a different color representation\n        if (hasattr(self, 'norm') and self.norm is not None\n                and np.isfinite(data)):\n            # To be consistent with colorbar, we pick 10 steps\n            n = 10\n            normed = self.norm(data)\n            if np.isfinite(normed):\n                try:\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Fallback for non-invertible normalizers like BoundaryNorm\n                    g_sig_digits = 3\n            else:\n                g_sig_digits = 3\n        else:\n            g_sig_digits = 3\n        return \"[{:.{}g}]\".format(data, g_sig_digits)\n",
      "\n    def format_cursor_data(self, data):\n        \"\"\"\n        Return a string representation of *data*.\n\n        .. note::\n            This method is intended to be overridden by artist subclasses.\n            As an end-user of Matplotlib you will most likely not call this\n            method yourself.\n\n        The default implementation converts ints and floats and arrays of ints\n        and floats into a comma-separated string enclosed in square brackets,\n        unless the artist has an associated colorbar, in which case scalar\n        values are formatted using the colorbar's formatter.\n\n        See Also\n        --------\n        format_xdata, format_ydata\n        \"\"\"\n        try:\n            # if we have a fmt_str, then assume x,y are coordinates\n            return self._format_coord % (data[0], data[1])\n        except (TypeError, ValueError):\n            pass\n        try:\n            return self.cbar.formatter.format_data_short(data)\n        except AttributeError:\n            pass\n        try:\n            # Check if we have a norm that we can use for context\n            normed = self.norm(data)\n        except (TypeError, ValueError):\n            pass\n        else:\n            # Offset by 0.5 so that we return the middle of the\n            # cell instead of the bottom-left corner of the cell\n            normed += 0.5 / self.norm.N  # type: ignore[union-attr]\n            # Now, for floats, we want to return the value at the\n            # center of the pixel, rather than the pixel value. For\n            # example, if the pixel is [0, 1), we want to return 0.5.\n            # The same is true for non-floats, but the midpoint is\n            # usually not representable, so we return the pixel value.\n            if np.isfinite(normed):\n                # compute the value to use for determining the number\n                # of digits to display\n                n = self.norm.N  # type: ignore[union-attr]\n                try:\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Fallback for non-invertible normalizers like BoundaryNorm\n                    g_sig_digits = 3\n            else:\n                g_sig_digits = 3\n            # %g is supposed to do what we want, but it's inconsistent\n            # about how it treats digits after the decimal point.\n            # So we need to do our own formatting.\n            return cbook._g_sig_digits(data, delta, g_sig_digits)\n        return '[{!r}]'.format(data)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..c5ee3c1c8e 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1302,10 +1302,22 @@ class Artist:\n             if np.ma.getmask(data):\n                 return \"[]\"\n             normed = self.norm(data)\n+\n             if np.isfinite(normed):\n                 # Midpoints of neighboring color intervals.\n-                neighbors = self.norm.inverse(\n-                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                try:\n+                    neighbors = self.norm.inverse(\n+                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                    delta = abs(neighbors - data).max()\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Fallback for non-invertible normalizers like BoundaryNorm\n+                    g_sig_digits = 3  # Consistent with default below\n+            else:\n+                g_sig_digits = 3  # Consistent with default below.\n+            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n+                    # Fallback for non-invertible normalizers like BoundaryNorm\n+                    g_sig_digits = 3  # Consistent with default below\n                 delta = abs(neighbors - data).max()\n                 g_sig_digits = cbook._g_sig_digits(data, delta)\n             else:\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..f165c23b2c 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1901,6 +1901,7 @@ class BoundaryNorm(Normalize):\n             ret = int(ret[0])  # assume python scalar\n         return ret\n \n+\n     def inverse(self, value):\n         \"\"\"\n         Raises\n",
    "variant_0": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..306996c782 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1302,12 +1302,28 @@ class Artist:\n             if np.ma.getmask(data):\n                 return \"[]\"\n             normed = self.norm(data)\n-            if np.isfinite(normed):\n-                # Midpoints of neighboring color intervals.\n+\n+        if np.isfinite(normed):\n+            # Midpoints of neighboring color intervals.\n+            try:\n                 neighbors = self.norm.inverse(\n                     (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                 delta = abs(neighbors - data).max()\n                 g_sig_digits = cbook._g_sig_digits(data, delta)\n+            except ValueError:\n+                # Fallback for non-invertible normalizers like BoundaryNorm\n+                g_sig_digits = 3  # Consistent with default below.\n+        else:\n+            g_sig_digits = 3  # Consistent with default below.\n+        return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Fallback for non-invertible normalizers like BoundaryNorm\n+                    g_sig_digits = 3  # Consistent with default below.\n+            else:\n+                g_sig_digits = 3  # Consistent with default below.\n+                delta = abs(neighbors - data).max()\n+                g_sig_digits = cbook._g_sig_digits(data, delta)\n             else:\n                 g_sig_digits = 3  # Consistent with default below.\n             return \"[{:-#.{}g}]\".format(data, g_sig_digits)\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..2beca80bf3 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1901,15 +1901,45 @@ class BoundaryNorm(Normalize):\n             ret = int(ret[0])  # assume python scalar\n         return ret\n \n-    def inverse(self, value):\n+\n+    def format_cursor_data(self, data):\n         \"\"\"\n-        Raises\n-        ------\n-        ValueError\n-            BoundaryNorm is not invertible, so calling this method will always\n-            raise an error\n+        Return a string representation of *data*.\n+\n+        .. note::\n+            This method is intended to be overridden by artist subclasses.\n+            As an end-user of Matplotlib you will most likely not call this\n+            method yourself.\n+\n+        The default implementation converts ints and floats and arrays of ints\n+        and floats into a comma-separated string enclosed in square brackets,\n+        unless the artist has an associated colorbar, in which case scalar\n+        values are formatted using the colorbar's formatter.\n+\n+        See Also\n+        --------\n+        .format_cursor_data\n         \"\"\"\n-        raise ValueError(\"BoundaryNorm is not invertible\")\n+        try:\n+            # Comment to avoid issues with tight bbox when\n+            # rc_context is used such as in rc_context test\n+            if hasattr(self, 'norm') and self.norm is not None:\n+                normed = self.norm(data)\n+                if np.isfinite(normed):\n+                    try:\n+                        neighbors = self.norm.inverse(\n+                            (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                        delta = abs(neighbors - data).max()\n+                        g_sig_digits = cbook._g_sig_digits(data, delta)\n+                    except ValueError:\n+                        # Fallback for non-invertible normalizers like BoundaryNorm\n+                        g_sig_digits = 3\n+                else:\n+                    g_sig_digits = 3\n+            else:\n+                g_sig_digits = 3\n+        except (TypeError, IndexError):\n+            g_sig_digits = 3\n \n \n class NoNorm(Normalize):\n",
    "variant_1": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..306996c782 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1302,12 +1302,28 @@ class Artist:\n             if np.ma.getmask(data):\n                 return \"[]\"\n             normed = self.norm(data)\n-            if np.isfinite(normed):\n-                # Midpoints of neighboring color intervals.\n+\n+        if np.isfinite(normed):\n+            # Midpoints of neighboring color intervals.\n+            try:\n                 neighbors = self.norm.inverse(\n                     (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                 delta = abs(neighbors - data).max()\n                 g_sig_digits = cbook._g_sig_digits(data, delta)\n+            except ValueError:\n+                # Fallback for non-invertible normalizers like BoundaryNorm\n+                g_sig_digits = 3  # Consistent with default below.\n+        else:\n+            g_sig_digits = 3  # Consistent with default below.\n+        return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Fallback for non-invertible normalizers like BoundaryNorm\n+                    g_sig_digits = 3  # Consistent with default below.\n+            else:\n+                g_sig_digits = 3  # Consistent with default below.\n+                delta = abs(neighbors - data).max()\n+                g_sig_digits = cbook._g_sig_digits(data, delta)\n             else:\n                 g_sig_digits = 3  # Consistent with default below.\n             return \"[{:-#.{}g}]\".format(data, g_sig_digits)\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..c585061cf0 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1901,15 +1901,57 @@ class BoundaryNorm(Normalize):\n             ret = int(ret[0])  # assume python scalar\n         return ret\n \n-    def inverse(self, value):\n+\n+    def format_cursor_data(self, data):\n         \"\"\"\n-        Raises\n-        ------\n-        ValueError\n-            BoundaryNorm is not invertible, so calling this method will always\n-            raise an error\n+        Return a string representation of *data*.\n+\n+        .. note::\n+           This method is intended to be overridden by artist subclasses.\n+           As an end-user of Matplotlib you will most likely not call this\n+           method yourself.\n+\n+        The default implementation converts ints and floats and arrays of ints\n+        and floats into a comma-separated string enclosed in square brackets,\n+        unless the artist has an associated colorbar, in which case scalar\n+        values are formatted using the colorbar's formatter.\n+\n+        See Also\n+        --------\n+        get_cursor_data\n         \"\"\"\n-        raise ValueError(\"BoundaryNorm is not invertible\")\n+        try:\n+            # if we have a formatter (from a colorbar) we use it\n+            if hasattr(self, 'colorbar') and self.colorbar is not None:\n+                return self.colorbar.format_cursor_data(data)\n+            # if we have a norm, we use that to get better precision for\n+            # the cursor readout\n+            if self.norm is not None:\n+                # make sure this is a ndarray\n+                data = np.asarray(data)\n+                normed = self.norm(data)\n+                if np.isfinite(normed):\n+                    n = 256\n+                    try:\n+                        neighbors = self.norm.inverse(\n+                            (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                        delta = abs(neighbors - data).max()\n+                        g_sig_digits = cbook._g_sig_digits(data, delta)\n+                    except ValueError:\n+                        # Fallback for non-invertible normalizers like BoundaryNorm\n+                        g_sig_digits = 3\n+                else:\n+                    g_sig_digits = 3\n+                return \"[{:g}]\".format(data) if data.shape == () else \\\n+                    \"[\" + \", \".join(\"{:{}g}\".format(v, g_sig_digits)\n+                                    for v in data.flat) + \"]\"\n+        except (TypeError, IndexError):\n+            pass\n+\n+        try:\n+            return '[' + ', '.join('{:0.3g}'.format(v) for v in data) + ']'\n+        except (TypeError, ValueError):\n+            return '{!r}'.format(data)\n \n \n class NoNorm(Normalize):\n",
    "variant_2": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..2a2cb0319d 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1292,6 +1292,17 @@ class Artist:\n         --------\n         get_cursor_data\n         \"\"\"\n+        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n+            # This block logically belongs to ScalarMappable, but can't be\n+            # implemented in it because most ScalarMappable subclasses inherit\n+            # from Artist first and from ScalarMappable second, so\n+            # Artist.format_cursor_data would always have precedence over\n+            # ScalarMappable.format_cursor_data.\n+            n = self.cmap.N\n+            if np.ma.getmask(data):\n+                return \"[]\"\n+            normed = self.norm(data)\n+\n         if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n             # This block logically belongs to ScalarMappable, but can't be\n             # implemented in it because most ScalarMappable subclasses inherit\n@@ -1303,9 +1314,24 @@ class Artist:\n                 return \"[]\"\n             normed = self.norm(data)\n             if np.isfinite(normed):\n-                # Midpoints of neighboring color intervals.\n-                neighbors = self.norm.inverse(\n-                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                try:\n+                    # Midpoints of neighboring color intervals.\n+                    neighbors = self.norm.inverse(\n+                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                    delta = abs(neighbors - data).max()\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Fallback for non-invertible normalizers like BoundaryNorm\n+                    g_sig_digits = 3  # Consistent with default below.\n+            else:\n+                g_sig_digits = 3  # Consistent with default below.\n+            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Fallback for non-invertible normalizers like BoundaryNorm\n+                    g_sig_digits = 3  # Consistent with default below.\n+            else:\n+                g_sig_digits = 3  # Consistent with default below.\n                 delta = abs(neighbors - data).max()\n                 g_sig_digits = cbook._g_sig_digits(data, delta)\n             else:\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..7f48f65e5a 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1901,15 +1901,18 @@ class BoundaryNorm(Normalize):\n             ret = int(ret[0])  # assume python scalar\n         return ret\n \n-    def inverse(self, value):\n-        \"\"\"\n-        Raises\n-        ------\n-        ValueError\n-            BoundaryNorm is not invertible, so calling this method will always\n-            raise an error\n-        \"\"\"\n-        raise ValueError(\"BoundaryNorm is not invertible\")\n+\n+        if np.isfinite(normed):\n+            try:\n+                neighbors = self.norm.inverse(\n+                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                delta = abs(neighbors - data).max()\n+                g_sig_digits = cbook._g_sig_digits(data, delta)\n+            except ValueError:\n+                # Fallback for non-invertible normalizers like BoundaryNorm\n+                g_sig_digits = 3\n+        else:\n+            g_sig_digits = 3\n \n \n class NoNorm(Normalize):\n",
    "variant_3": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..9aaa81c908 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1292,6 +1292,17 @@ class Artist:\n         --------\n         get_cursor_data\n         \"\"\"\n+        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n+            # This block logically belongs to ScalarMappable, but can't be\n+            # implemented in it because most ScalarMappable subclasses inherit\n+            # from Artist first and from ScalarMappable second, so\n+            # Artist.format_cursor_data would always have precedence over\n+            # ScalarMappable.format_cursor_data.\n+            n = self.cmap.N\n+            if np.ma.getmask(data):\n+                return \"[]\"\n+            normed = self.norm(data)\n+\n         if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n             # This block logically belongs to ScalarMappable, but can't be\n             # implemented in it because most ScalarMappable subclasses inherit\n@@ -1304,8 +1315,23 @@ class Artist:\n             normed = self.norm(data)\n             if np.isfinite(normed):\n                 # Midpoints of neighboring color intervals.\n-                neighbors = self.norm.inverse(\n-                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                try:\n+                    neighbors = self.norm.inverse(\n+                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                    delta = abs(neighbors - data).max()\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Fallback for non-invertible normalizers like BoundaryNorm\n+                    g_sig_digits = 3  # Consistent with default below.\n+            else:\n+                g_sig_digits = 3  # Consistent with default below.\n+            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Fallback for non-invertible normalizers like BoundaryNorm\n+                    g_sig_digits = 3  # Consistent with default below.\n+            else:\n+                g_sig_digits = 3  # Consistent with default below.\n                 delta = abs(neighbors - data).max()\n                 g_sig_digits = cbook._g_sig_digits(data, delta)\n             else:\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..1233708afa 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1901,15 +1901,52 @@ class BoundaryNorm(Normalize):\n             ret = int(ret[0])  # assume python scalar\n         return ret\n \n-    def inverse(self, value):\n+\n+    def format_cursor_data(self, data):\n         \"\"\"\n-        Raises\n-        ------\n-        ValueError\n-            BoundaryNorm is not invertible, so calling this method will always\n-            raise an error\n+        Return a string representation of *data*.\n+\n+        .. note::\n+           This method is intended to be overridden by artist subclasses.\n+           As an end-user of Matplotlib you will most likely not call this\n+           method yourself.\n+\n+        The default implementation converts ints and floats and arrays of ints\n+        and floats into a comma-separated string enclosed in square brackets,\n+        unless the artist has an associated colorbar, in which case scalar\n+        values are formatted using the colorbar's formatter.\n+\n+        See Also\n+        --------\n+        get_cursor_data\n         \"\"\"\n-        raise ValueError(\"BoundaryNorm is not invertible\")\n+        if self.colorbar is not None and isinstance(data, (int, float)):\n+            # Respect the colorbar's formatter, if present\n+            if hasattr(self.colorbar, 'formatter'):\n+                return self.colorbar.formatter.format_data_short(data)\n+\n+        try:\n+            data = cbook._sanitize_sequence(data)\n+        except ValueError:\n+            pass\n+        else:\n+            if self.axes and hasattr(self.norm, 'inverse') and len(data) == 1:\n+                # We have a single value in a mappable; check if it's in a\n+                # plausible range for the normalization.\n+                normed = self.norm(data)\n+                if np.isfinite(normed):\n+                    try:\n+                        neighbors = self.norm.inverse(\n+                            (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                        delta = abs(neighbors - data).max()\n+                        g_sig_digits = cbook._g_sig_digits(data, delta)\n+                    except ValueError:\n+                        # Fallback for non-invertible normalizers like BoundaryNorm\n+                        g_sig_digits = 3  # Consistent with default below\n+                else:\n+                    g_sig_digits = 3\n+                data = cbook._g_sig_digits(data, g_sig_digits)\n+        return \"[\" + \", \".join(map(str, data)) + \"]\"\n \n \n class NoNorm(Normalize):\n",
    "variant_4": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..2a2cb0319d 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1292,6 +1292,17 @@ class Artist:\n         --------\n         get_cursor_data\n         \"\"\"\n+        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n+            # This block logically belongs to ScalarMappable, but can't be\n+            # implemented in it because most ScalarMappable subclasses inherit\n+            # from Artist first and from ScalarMappable second, so\n+            # Artist.format_cursor_data would always have precedence over\n+            # ScalarMappable.format_cursor_data.\n+            n = self.cmap.N\n+            if np.ma.getmask(data):\n+                return \"[]\"\n+            normed = self.norm(data)\n+\n         if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n             # This block logically belongs to ScalarMappable, but can't be\n             # implemented in it because most ScalarMappable subclasses inherit\n@@ -1303,9 +1314,24 @@ class Artist:\n                 return \"[]\"\n             normed = self.norm(data)\n             if np.isfinite(normed):\n-                # Midpoints of neighboring color intervals.\n-                neighbors = self.norm.inverse(\n-                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                try:\n+                    # Midpoints of neighboring color intervals.\n+                    neighbors = self.norm.inverse(\n+                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                    delta = abs(neighbors - data).max()\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Fallback for non-invertible normalizers like BoundaryNorm\n+                    g_sig_digits = 3  # Consistent with default below.\n+            else:\n+                g_sig_digits = 3  # Consistent with default below.\n+            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Fallback for non-invertible normalizers like BoundaryNorm\n+                    g_sig_digits = 3  # Consistent with default below.\n+            else:\n+                g_sig_digits = 3  # Consistent with default below.\n                 delta = abs(neighbors - data).max()\n                 g_sig_digits = cbook._g_sig_digits(data, delta)\n             else:\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..45f0dd93b4 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1901,15 +1901,51 @@ class BoundaryNorm(Normalize):\n             ret = int(ret[0])  # assume python scalar\n         return ret\n \n-    def inverse(self, value):\n+\n+    def format_cursor_data(self, data):\n         \"\"\"\n-        Raises\n-        ------\n-        ValueError\n-            BoundaryNorm is not invertible, so calling this method will always\n-            raise an error\n+        Return a string representation of *data*.\n+\n+        .. note::\n+            This method is intended to be overridden by artist subclasses.\n+            As an end-user of Matplotlib you will most likely not call this\n+            method yourself.\n+\n+        The default implementation converts ints and floats and arrays of ints\n+        and floats into a comma-separated string enclosed in square brackets,\n+        unless the artist has an associated colorbar, in which case scalar\n+        values are formatted using the colorbar's formatter.\n+\n+        See Also\n+        --------\n+        format_coord\n         \"\"\"\n-        raise ValueError(\"BoundaryNorm is not invertible\")\n+        try:\n+            # if we have a formatter from a colorbar, use it\n+            if hasattr(self, 'colorbar') and self.colorbar is not None:\n+                return self.colorbar.formatter.format_data_short(data)\n+            # if we have a norm, try to use it\n+            if self.norm is not None:\n+                # Attempt to format the data using the norm\n+                # In particular, LogNorm is able to format values\n+                normed = self.norm(data)\n+                if np.isfinite(normed):\n+                    # Deltaless formatting for other norms.\n+                    n = self.norm.N if hasattr(self.norm, 'N') else 256\n+                    try:\n+                        neighbors = self.norm.inverse(\n+                            (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                        delta = abs(neighbors - data).max()\n+                        g_sig_digits = cbook._g_sig_digits(data, delta)\n+                    except ValueError:\n+                        # Fallback for non-invertible normalizers like BoundaryNorm\n+                        g_sig_digits = 3\n+                else:\n+                    g_sig_digits = 3\n+                return cbook._auto_format_str(data, g_sig_digits)\n+        except (TypeError, IndexError):\n+            pass\n+        return '{:1.4g}'.format(data)\n \n \n class NoNorm(Normalize):\n",
    "variant_5": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..2a2cb0319d 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1292,6 +1292,17 @@ class Artist:\n         --------\n         get_cursor_data\n         \"\"\"\n+        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n+            # This block logically belongs to ScalarMappable, but can't be\n+            # implemented in it because most ScalarMappable subclasses inherit\n+            # from Artist first and from ScalarMappable second, so\n+            # Artist.format_cursor_data would always have precedence over\n+            # ScalarMappable.format_cursor_data.\n+            n = self.cmap.N\n+            if np.ma.getmask(data):\n+                return \"[]\"\n+            normed = self.norm(data)\n+\n         if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n             # This block logically belongs to ScalarMappable, but can't be\n             # implemented in it because most ScalarMappable subclasses inherit\n@@ -1303,9 +1314,24 @@ class Artist:\n                 return \"[]\"\n             normed = self.norm(data)\n             if np.isfinite(normed):\n-                # Midpoints of neighboring color intervals.\n-                neighbors = self.norm.inverse(\n-                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                try:\n+                    # Midpoints of neighboring color intervals.\n+                    neighbors = self.norm.inverse(\n+                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                    delta = abs(neighbors - data).max()\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Fallback for non-invertible normalizers like BoundaryNorm\n+                    g_sig_digits = 3  # Consistent with default below.\n+            else:\n+                g_sig_digits = 3  # Consistent with default below.\n+            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Fallback for non-invertible normalizers like BoundaryNorm\n+                    g_sig_digits = 3  # Consistent with default below.\n+            else:\n+                g_sig_digits = 3  # Consistent with default below.\n                 delta = abs(neighbors - data).max()\n                 g_sig_digits = cbook._g_sig_digits(data, delta)\n             else:\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..b55167f424 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1901,15 +1901,43 @@ class BoundaryNorm(Normalize):\n             ret = int(ret[0])  # assume python scalar\n         return ret\n \n-    def inverse(self, value):\n+\n+    def format_cursor_data(self, data):\n         \"\"\"\n-        Raises\n-        ------\n-        ValueError\n-            BoundaryNorm is not invertible, so calling this method will always\n-            raise an error\n+        Return a string representation of *data*.\n+\n+        .. note::\n+            This method is intended to be overridden by artist subclasses.\n+            As an end-user of Matplotlib you will most likely not call this\n+            method yourself.\n+\n+        The default implementation converts ints and floats and arrays of ints\n+        and floats into a comma-separated string enclosed in square brackets,\n+        unless the artist has an associated colorbar, in which case scalar\n+        values are formatted using the colorbar's formatter.\n+\n+        See Also\n+        --------\n+        format_coord\n         \"\"\"\n-        raise ValueError(\"BoundaryNorm is not invertible\")\n+        if self.get_array() is not None:\n+            # Scalar mappable with array data\n+            if hasattr(self, 'norm') and hasattr(self.norm, 'inverse'):\n+                normed = self.norm(data)\n+                if np.isfinite(normed):\n+                    n = self.cmap.N\n+                    try:\n+                        neighbors = self.norm.inverse(\n+                            (int(normed * n) + np.array([0, 1])) / n)\n+                        delta = abs(neighbors - data).max()\n+                        g_sig_digits = cbook._g_sig_digits(data, delta)\n+                    except ValueError:\n+                        # Fallback for non-invertible normalizers like BoundaryNorm\n+                        g_sig_digits = 3  # Consistent with default below\n+                else:\n+                    g_sig_digits = 3\n+                return \"{:-#.{}g}\".format(data, g_sig_digits)\n+        return \"{:g}\".format(data)\n \n \n class NoNorm(Normalize):\n",
    "variant_6": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..306996c782 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1302,12 +1302,28 @@ class Artist:\n             if np.ma.getmask(data):\n                 return \"[]\"\n             normed = self.norm(data)\n-            if np.isfinite(normed):\n-                # Midpoints of neighboring color intervals.\n+\n+        if np.isfinite(normed):\n+            # Midpoints of neighboring color intervals.\n+            try:\n                 neighbors = self.norm.inverse(\n                     (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                 delta = abs(neighbors - data).max()\n                 g_sig_digits = cbook._g_sig_digits(data, delta)\n+            except ValueError:\n+                # Fallback for non-invertible normalizers like BoundaryNorm\n+                g_sig_digits = 3  # Consistent with default below.\n+        else:\n+            g_sig_digits = 3  # Consistent with default below.\n+        return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Fallback for non-invertible normalizers like BoundaryNorm\n+                    g_sig_digits = 3  # Consistent with default below.\n+            else:\n+                g_sig_digits = 3  # Consistent with default below.\n+                delta = abs(neighbors - data).max()\n+                g_sig_digits = cbook._g_sig_digits(data, delta)\n             else:\n                 g_sig_digits = 3  # Consistent with default below.\n             return \"[{:-#.{}g}]\".format(data, g_sig_digits)\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..d79fdbedc9 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1901,15 +1901,160 @@ class BoundaryNorm(Normalize):\n             ret = int(ret[0])  # assume python scalar\n         return ret\n \n-    def inverse(self, value):\n+\n+    def format_cursor_data(self, data):\n+        \"\"\"\n+        Return a string representation of *data*.\n+\n+        .. note::\n+            This method is intended to be overridden by artist subclasses.\n+            As an end-user of Matplotlib you will most likely not call this\n+            method yourself.\n+\n+        The default implementation converts ints and floats and arrays of ints\n+        and floats into a comma-separated string enclosed in square brackets,\n+        unless the artist has an associated colorbar, in which case scalar\n+        values are formatted using the colorbar's formatter.\n+\n+        See Also\n+        --------\n+        format_coord\n+        \"\"\"\n+        if self.colorbar is not None:\n+            # we have a colorbar so format the data with the colorbar's\n+            # formatter.  This must come first since we don't want to\n+            # override the colorbar's format_cursor_data\n+            return self.colorbar.format_cursor_data(data)\n+\n+        data = np.asarray(data)\n+        data_str = cbook.format_approx(data, 3)\n+        if data.ndim > 0:\n+            return \"[\" + data_str + \"]\"\n+        else:\n+            return data_str\n+\n+    def format_coord(self, x, y):\n+        \"\"\"\n+        Return a string representation of the coordinates.\n+\n+        This method is intended to be overridden by artist subclasses.\n+        As an end-user of Matplotlib you will most likely not call this\n+        method yourself.\n+\n+        Parameters\n+        ----------\n+        x, y : float\n+            The coordinates to format.\n+\n+        Returns\n+        -------\n+        str\n+            The string representation of the coordinates.\n+        \"\"\"\n+        return f\"x={x:g}, y={y:g}\"\n+\n+    def get_cursor_data(self, event):\n+        \"\"\"\n+        Return the cursor data for a given event.\n+\n+        .. note::\n+            This method is intended to be overridden by artist subclasses.\n+            As an end-user of Matplotlib you will most likely not call this\n+            method yourself.\n+\n+        Cursor data can be used by Artists to provide additional context\n+        information for a given event. The default implementation just returns\n+        *None*.\n+\n+        Subclasses can override the method and return arbitrary data. However,\n+        when doing so, they must ensure that :meth:`format_cursor_data` can\n+        convert the data to a string representation.\n+\n+        The only current use of this method is in conjunction with the\n+        ``cursor`` tool.\n+\n+        Parameters\n+        ----------\n+        event : `matplotlib.backend_bases.MouseEvent`\n+\n+        Returns\n+        -------\n+        object\n+            The cursor data for a given event, or *None* if no data is set.\n+        \"\"\"\n+        return None\n+\n+    def get_mouseover(self):\n+        \"\"\"\n+        Return whether this artist is queried for custom context information\n+        when the mouse cursor moves over it.\n+        \"\"\"\n+        return self.mouseover\n+\n+    def set_mouseover(self, mouseover):\n+        \"\"\"\n+        Set whether this artist is queried for custom context information when\n+        the mouse cursor moves over it.\n+\n+        Parameters\n+        ----------\n+        mouseover : bool\n         \"\"\"\n-        Raises\n-        ------\n-        ValueError\n-            BoundaryNorm is not invertible, so calling this method will always\n-            raise an error\n+        self.mouseover = mouseover\n+\n+    def format_coord(self, x, y):\n         \"\"\"\n-        raise ValueError(\"BoundaryNorm is not invertible\")\n+        Return a string representation of the coordinates.\n+\n+        This method is intended to be overridden by artist subclasses.\n+        As an end-user of Matplotlib you will most likely not call this\n+        method yourself.\n+\n+        Parameters\n+        ----------\n+        x, y : float\n+            The coordinates to format.\n+\n+        Returns\n+        -------\n+        str\n+            The string representation of the coordinates.\n+        \"\"\"\n+        return f\"x={x:g}, y={y:g}\"\n+\n+    def _format_coord(self, x, y):\n+        \"\"\"\n+        Return a string representation of the coordinates.\n+\n+        This method is intended to be overridden by artist subclasses.\n+        As an end-user of Matplotlib you will most likely not call this\n+        method yourself.\n+\n+        Parameters\n+        ----------\n+        x, y : float\n+            The coordinates to format.\n+\n+        Returns\n+        -------\n+        str\n+            The string representation of the coordinates.\n+        \"\"\"\n+        # note: this is a private method, and may be called with out-of-bounds\n+        # coordinates.  It should not error out.\n+        if np.isfinite(normed):\n+            try:\n+                neighbors = self.norm.inverse(\n+                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                delta = abs(neighbors - data).max()\n+                g_sig_digits = cbook._g_sig_digits(data, delta)\n+            except ValueError:\n+                # Fallback for non-invertible normalizers like BoundaryNorm\n+                g_sig_digits = 3\n+        else:\n+            g_sig_digits = 3\n+        s = cbook.format_approx(data, g_sig_digits)\n+        return s\n \n \n class NoNorm(Normalize):\n",
    "variant_7": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..9aaa81c908 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1292,6 +1292,17 @@ class Artist:\n         --------\n         get_cursor_data\n         \"\"\"\n+        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n+            # This block logically belongs to ScalarMappable, but can't be\n+            # implemented in it because most ScalarMappable subclasses inherit\n+            # from Artist first and from ScalarMappable second, so\n+            # Artist.format_cursor_data would always have precedence over\n+            # ScalarMappable.format_cursor_data.\n+            n = self.cmap.N\n+            if np.ma.getmask(data):\n+                return \"[]\"\n+            normed = self.norm(data)\n+\n         if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n             # This block logically belongs to ScalarMappable, but can't be\n             # implemented in it because most ScalarMappable subclasses inherit\n@@ -1304,8 +1315,23 @@ class Artist:\n             normed = self.norm(data)\n             if np.isfinite(normed):\n                 # Midpoints of neighboring color intervals.\n-                neighbors = self.norm.inverse(\n-                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                try:\n+                    neighbors = self.norm.inverse(\n+                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                    delta = abs(neighbors - data).max()\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Fallback for non-invertible normalizers like BoundaryNorm\n+                    g_sig_digits = 3  # Consistent with default below.\n+            else:\n+                g_sig_digits = 3  # Consistent with default below.\n+            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Fallback for non-invertible normalizers like BoundaryNorm\n+                    g_sig_digits = 3  # Consistent with default below.\n+            else:\n+                g_sig_digits = 3  # Consistent with default below.\n                 delta = abs(neighbors - data).max()\n                 g_sig_digits = cbook._g_sig_digits(data, delta)\n             else:\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..cf8a39f402 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1901,15 +1901,37 @@ class BoundaryNorm(Normalize):\n             ret = int(ret[0])  # assume python scalar\n         return ret\n \n-    def inverse(self, value):\n-        \"\"\"\n-        Raises\n-        ------\n-        ValueError\n-            BoundaryNorm is not invertible, so calling this method will always\n-            raise an error\n-        \"\"\"\n-        raise ValueError(\"BoundaryNorm is not invertible\")\n+\n+    def _format_coord(self, x, y):\n+        # convert from data coords -> pixel coords\n+        xp, yp = self.axes.transData.transform((x, y))\n+        # convert back from pixel coords -> new data coords (with pixel offset)\n+        xd, yd = self.axes.transData.inverted().transform((xp, yp))\n+        data = self.get_array()[int(yd), int(xd)]\n+        # Compute precision to use for formatting: for this we need to\n+        # process the data around the cursor position and not only the\n+        # data at that position.\n+        # First, we search in a cross around the position for the data\n+        # points that will have a different color representation\n+        if (hasattr(self, 'norm') and self.norm is not None\n+                and np.isfinite(data)):\n+            # To be consistent with colorbar, we pick 10 steps\n+            n = 10\n+            normed = self.norm(data)\n+            if np.isfinite(normed):\n+                try:\n+                    neighbors = self.norm.inverse(\n+                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                    delta = abs(neighbors - data).max()\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Fallback for non-invertible normalizers like BoundaryNorm\n+                    g_sig_digits = 3\n+            else:\n+                g_sig_digits = 3\n+        else:\n+            g_sig_digits = 3\n+        return \"[{:.{}g}]\".format(data, g_sig_digits)\n \n \n class NoNorm(Normalize):\n",
    "variant_8": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..306996c782 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1302,12 +1302,28 @@ class Artist:\n             if np.ma.getmask(data):\n                 return \"[]\"\n             normed = self.norm(data)\n-            if np.isfinite(normed):\n-                # Midpoints of neighboring color intervals.\n+\n+        if np.isfinite(normed):\n+            # Midpoints of neighboring color intervals.\n+            try:\n                 neighbors = self.norm.inverse(\n                     (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                 delta = abs(neighbors - data).max()\n                 g_sig_digits = cbook._g_sig_digits(data, delta)\n+            except ValueError:\n+                # Fallback for non-invertible normalizers like BoundaryNorm\n+                g_sig_digits = 3  # Consistent with default below.\n+        else:\n+            g_sig_digits = 3  # Consistent with default below.\n+        return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Fallback for non-invertible normalizers like BoundaryNorm\n+                    g_sig_digits = 3  # Consistent with default below.\n+            else:\n+                g_sig_digits = 3  # Consistent with default below.\n+                delta = abs(neighbors - data).max()\n+                g_sig_digits = cbook._g_sig_digits(data, delta)\n             else:\n                 g_sig_digits = 3  # Consistent with default below.\n             return \"[{:-#.{}g}]\".format(data, g_sig_digits)\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..230946f12c 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1901,15 +1901,67 @@ class BoundaryNorm(Normalize):\n             ret = int(ret[0])  # assume python scalar\n         return ret\n \n-    def inverse(self, value):\n+\n+    def format_cursor_data(self, data):\n         \"\"\"\n-        Raises\n-        ------\n-        ValueError\n-            BoundaryNorm is not invertible, so calling this method will always\n-            raise an error\n+        Return a string representation of *data*.\n+\n+        .. note::\n+            This method is intended to be overridden by artist subclasses.\n+            As an end-user of Matplotlib you will most likely not call this\n+            method yourself.\n+\n+        The default implementation converts ints and floats and arrays of ints\n+        and floats into a comma-separated string enclosed in square brackets,\n+        unless the artist has an associated colorbar, in which case scalar\n+        values are formatted using the colorbar's formatter.\n+\n+        See Also\n+        --------\n+        format_xdata, format_ydata\n         \"\"\"\n-        raise ValueError(\"BoundaryNorm is not invertible\")\n+        try:\n+            # if we have a fmt_str, then assume x,y are coordinates\n+            return self._format_coord % (data[0], data[1])\n+        except (TypeError, ValueError):\n+            pass\n+        try:\n+            return self.cbar.formatter.format_data_short(data)\n+        except AttributeError:\n+            pass\n+        try:\n+            # Check if we have a norm that we can use for context\n+            normed = self.norm(data)\n+        except (TypeError, ValueError):\n+            pass\n+        else:\n+            # Offset by 0.5 so that we return the middle of the\n+            # cell instead of the bottom-left corner of the cell\n+            normed += 0.5 / self.norm.N  # type: ignore[union-attr]\n+            # Now, for floats, we want to return the value at the\n+            # center of the pixel, rather than the pixel value. For\n+            # example, if the pixel is [0, 1), we want to return 0.5.\n+            # The same is true for non-floats, but the midpoint is\n+            # usually not representable, so we return the pixel value.\n+            if np.isfinite(normed):\n+                # compute the value to use for determining the number\n+                # of digits to display\n+                n = self.norm.N  # type: ignore[union-attr]\n+                try:\n+                    neighbors = self.norm.inverse(\n+                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                    delta = abs(neighbors - data).max()\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Fallback for non-invertible normalizers like BoundaryNorm\n+                    g_sig_digits = 3\n+            else:\n+                g_sig_digits = 3\n+            # %g is supposed to do what we want, but it's inconsistent\n+            # about how it treats digits after the decimal point.\n+            # So we need to do our own formatting.\n+            return cbook._g_sig_digits(data, delta, g_sig_digits)\n+        return '[{!r}]'.format(data)\n \n \n class NoNorm(Normalize):\n"
  }
}