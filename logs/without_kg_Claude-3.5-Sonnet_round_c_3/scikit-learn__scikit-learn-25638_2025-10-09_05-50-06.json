{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/scikit-learn/sklearn/utils/multiclass.py lines 1-10)": "\n# Author: Arnaud Joly, Joel Nothman, Hamzeh Alsalhi\n#\n# License: BSD 3 clause\n\"\"\"\nMulti-class / multi-label utility function\n==========================================\n\n\"\"\"\nfrom collections.abc import Sequence\nfrom itertools import chain\nimport warnings\n\nfrom scipy.sparse import issparse\nfrom scipy.sparse import dok_matrix\nfrom scipy.sparse import lil_matrix\n\nimport numpy as np\n\nfrom .validation import check_array, _assert_all_finite\nfrom ..utils._array_api import get_namespace\n\ntry:\n    import pandas as pd\n    from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n    _pandas_available = True\nexcept ImportError:\n    _pandas_available = False\n",
    "Location 2 (/root/hy/projects_3/scikit-learn/sklearn/utils/multiclass.py lines 290-306)": "\n    if not valid:\n        raise ValueError(\n            \"Expected array-like (array or non-string sequence), got %r\" % y\n        )\n\n    sparse_pandas = y.__class__.__name__ in [\"SparseSeries\", \"SparseArray\"]\n    if sparse_pandas:\n        raise ValueError(\"y cannot be class 'SparseSeries' or 'SparseArray'\")\n\n    if is_multilabel(y):\n        return \"multilabel-indicator\"\n\n    # Handle pandas nullable dtypes before numpy conversion\n    try:\n        import pandas as pd\n        from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n        if hasattr(y, 'dtype') and is_extension_array_dtype(y.dtype):\n            # Convert pandas nullable dtypes to their non-nullable equivalents\n            if is_integer_dtype(y.dtype):\n                y = y.astype('int64')\n            elif is_float_dtype(y.dtype):\n                y = y.astype('float64')\n            elif is_bool_dtype(y.dtype):\n                y = y.astype('bool')\n    except ImportError:\n        pass\n\n    # DeprecationWarning will be replaced by ValueError, see NEP 34\n    # https://numpy.org/neps/nep-0034-infer-dtype-is-object.html\n    # We therefore catch both deprecation (NumPy < 1.24) warning and\n    # value error (NumPy >= 1.24).\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n",
    "Location 3 (/root/hy/projects_3/scikit-learn/sklearn/utils/multiclass.py lines 307-313)": "\n    # Handle pandas extension dtypes before numpy conversion\n    if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n        try:\n            import pandas as pd\n            from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n            \n            if is_extension_array_dtype(y.dtype):\n                # Convert pandas nullable dtypes to their non-nullable equivalents\n                if is_integer_dtype(y.dtype):\n                    y = y.astype('int64')\n                elif is_float_dtype(y.dtype):\n                    y = y.astype('float64')\n                elif is_bool_dtype(y.dtype):\n                    y = y.astype('bool')\n        except ImportError:\n            pass\n\n    if not issparse(y):\n        try:\n            y = xp.asarray(y)\n        except (np.VisibleDeprecationWarning, ValueError):\n            # dtype=object should be provided explicitly for ragged arrays,\n            # see NEP 34\n            y = xp.asarray(y, dtype=object)\n",
    "Location 4 (/root/hy/projects_3/scikit-learn/sklearn/utils/multiclass.py lines 340-346)": "\n    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n        # [obj_1] and not [\"label_1\"]\n        return \"unknown\"\n",
    "Location 5 (/root/hy/projects_3/scikit-learn/sklearn/utils/multiclass.py lines 81-81)": "\nys_types = set(type_of_target(x) for x in ys)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/scikit-learn/sklearn/utils/multiclass.py lines 1-10)": [
      "\n# Author: Arnaud Joly, Joel Nothman, Hamzeh Alsalhi\n#\n# License: BSD 3 clause\n\"\"\"\nMulti-class / multi-label utility function\n==========================================\n\n\"\"\"\nfrom collections.abc import Sequence\nfrom itertools import chain\nimport warnings\n\nfrom scipy.sparse import issparse\nfrom scipy.sparse import dok_matrix\nfrom scipy.sparse import lil_matrix\n\nimport numpy as np\n\nfrom .validation import check_array, _assert_all_finite\nfrom ..utils._array_api import get_namespace\n\ntry:\n    import pandas as pd\n    from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n    _pandas_available = True\nexcept ImportError:\n    _pandas_available = False\n",
      "\n# Author: Arnaud Joly, Joel Nothman, Hamzeh Alsalhi\n#\n# License: BSD 3 clause\n\"\"\"\nMulti-class / multi-label utility function\n==========================================\n\n\"\"\"\nfrom collections.abc import Sequence\nfrom itertools import chain\nimport warnings\n\nfrom scipy.sparse import issparse\nfrom scipy.sparse import dok_matrix\nfrom scipy.sparse import lil_matrix\n\nimport numpy as np\n\nfrom .validation import check_array, _assert_all_finite\nfrom ..utils._array_api import get_namespace\n\ntry:\n    import pandas as pd\n    from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n    _pandas_available = True\nexcept ImportError:\n    _pandas_available = False\n",
      "\n# Author: Arnaud Joly, Joel Nothman, Hamzeh Alsalhi\n#\n# License: BSD 3 clause\n\"\"\"\nMulti-class / multi-label utility function\n==========================================\n\n\"\"\"\nfrom collections.abc import Sequence\nfrom itertools import chain\nimport warnings\n\nfrom scipy.sparse import issparse\nfrom scipy.sparse import dok_matrix\nfrom scipy.sparse import lil_matrix\n\nimport numpy as np\n\nfrom .validation import check_array, _assert_all_finite\nfrom ..utils._array_api import get_namespace\n\ntry:\n    import pandas as pd\n    from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n    _pandas_available = True\nexcept ImportError:\n    _pandas_available = False\n",
      "\n# Author: Arnaud Joly, Joel Nothman, Hamzeh Alsalhi\n#\n# License: BSD 3 clause\n\"\"\"\nMulti-class / multi-label utility function\n==========================================\n\n\"\"\"\nfrom collections.abc import Sequence\nfrom itertools import chain\nimport warnings\n\nfrom scipy.sparse import issparse\nfrom scipy.sparse import dok_matrix\nfrom scipy.sparse import lil_matrix\n\nimport numpy as np\n\nfrom .validation import check_array, _assert_all_finite\nfrom ..utils._array_api import get_namespace\n\ntry:\n    import pandas as pd\n    from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n    _pandas_available = True\nexcept ImportError:\n    _pandas_available = False\n",
      "\n# Author: Arnaud Joly, Joel Nothman, Hamzeh Alsalhi\n#\n# License: BSD 3 clause\n\"\"\"\nMulti-class / multi-label utility function\n==========================================\n\n\"\"\"\nfrom collections.abc import Sequence\nfrom itertools import chain\nimport warnings\n\nfrom scipy.sparse import issparse\nfrom scipy.sparse import dok_matrix\nfrom scipy.sparse import lil_matrix\n\nimport numpy as np\n\nfrom .validation import check_array, _assert_all_finite\nfrom ..utils._array_api import get_namespace\n\ntry:\n    import pandas as pd\n    from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n    _pandas_available = True\nexcept ImportError:\n    _pandas_available = False\n",
      "\n# Author: Arnaud Joly, Joel Nothman, Hamzeh Alsalhi\n#\n# License: BSD 3 clause\n\"\"\"\nMulti-class / multi-label utility function\n==========================================\n\n\"\"\"\nfrom collections.abc import Sequence\nfrom itertools import chain\nimport warnings\n\nfrom scipy.sparse import issparse\nfrom scipy.sparse import dok_matrix\nfrom scipy.sparse import lil_matrix\n\nimport numpy as np\n\nfrom .validation import check_array, _assert_all_finite\nfrom ..utils._array_api import get_namespace\n\ntry:\n    import pandas as pd\n    from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n    _pandas_available = True\nexcept ImportError:\n    _pandas_available = False\n",
      "\n# Author: Arnaud Joly, Joel Nothman, Hamzeh Alsalhi\n#\n# License: BSD 3 clause\n\"\"\"\nMulti-class / multi-label utility function\n==========================================\n\n\"\"\"\nfrom collections.abc import Sequence\nfrom itertools import chain\nimport warnings\n\nfrom scipy.sparse import issparse\nfrom scipy.sparse import dok_matrix\nfrom scipy.sparse import lil_matrix\n\nimport numpy as np\n\nfrom .validation import check_array, _assert_all_finite\nfrom ..utils._array_api import get_namespace\n\ntry:\n    import pandas as pd\n    from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n    _pandas_available = True\nexcept ImportError:\n    _pandas_available = False\n",
      "\n# Author: Arnaud Joly, Joel Nothman, Hamzeh Alsalhi\n#\n# License: BSD 3 clause\n\"\"\"\nMulti-class / multi-label utility function\n==========================================\n\n\"\"\"\nfrom collections.abc import Sequence\nfrom itertools import chain\nimport warnings\n\nfrom scipy.sparse import issparse\nfrom scipy.sparse import dok_matrix\nfrom scipy.sparse import lil_matrix\n\nimport numpy as np\n\nfrom .validation import check_array, _assert_all_finite\nfrom ..utils._array_api import get_namespace\n\ntry:\n    import pandas as pd\n    from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n    _pandas_available = True\nexcept ImportError:\n    _pandas_available = False\n"
    ],
    "Location 2 (/root/hy/projects_3/scikit-learn/sklearn/utils/multiclass.py lines 290-306)": [
      "\n    if not valid:\n        raise ValueError(\n            \"Expected array-like (array or non-string sequence), got %r\" % y\n        )\n\n    sparse_pandas = y.__class__.__name__ in [\"SparseSeries\", \"SparseArray\"]\n    if sparse_pandas:\n        raise ValueError(\"y cannot be class 'SparseSeries' or 'SparseArray'\")\n\n    if is_multilabel(y):\n        return \"multilabel-indicator\"\n\n    # Handle pandas extension dtypes before numpy conversion\n    try:\n        import pandas as pd\n        from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n        if hasattr(y, 'dtype') and is_extension_array_dtype(y.dtype):\n            # Handle pandas nullable dtypes by preserving their semantic meaning\n            if is_integer_dtype(y.dtype):\n                # Convert nullable Int64 to regular int64 for consistent classification\n                y = y.astype('int64')\n            elif is_float_dtype(y.dtype):\n                # Convert nullable Float64 to regular float64 for consistent classification  \n                y = y.astype('float64')\n            elif is_bool_dtype(y.dtype):\n                # Convert nullable boolean to regular bool for consistent classification\n                y = y.astype('bool')\n    except ImportError:\n        pass\n\n    # DeprecationWarning will be replaced by ValueError, see NEP 34\n    # https://numpy.org/neps/nep-0034-infer-dtype-is-object.html\n    # We therefore catch both deprecation (NumPy < 1.24) warning and\n    # value error (NumPy >= 1.24).\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n",
      "\n    if not valid:\n        raise ValueError(\n            \"Expected array-like (array or non-string sequence), got %r\" % y\n        )\n\n    sparse_pandas = y.__class__.__name__ in [\"SparseSeries\", \"SparseArray\"]\n    if sparse_pandas:\n        raise ValueError(\"y cannot be class 'SparseSeries' or 'SparseArray'\")\n\n    if is_multilabel(y):\n        return \"multilabel-indicator\"\n\n    # Handle pandas extension dtypes before numpy conversion\n    try:\n        import pandas as pd\n        from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n        \n        if hasattr(y, 'dtype') and is_extension_array_dtype(y.dtype):\n            # Convert nullable pandas dtypes to their non-nullable equivalents\n            if is_integer_dtype(y.dtype):\n                y = y.astype('int64')\n            elif is_float_dtype(y.dtype):\n                y = y.astype('float64')\n            elif is_bool_dtype(y.dtype):\n                y = y.astype('bool')\n    except ImportError:\n        pass\n\n    # DeprecationWarning will be replaced by ValueError, see NEP 34\n    # https://numpy.org/neps/nep-0034-infer-dtype-is-object.html\n    # We therefore catch both deprecation (NumPy < 1.24) warning and\n    # value error (NumPy >= 1.24).\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n",
      "\n    if not valid:\n        raise ValueError(\n            \"Expected array-like (array or non-string sequence), got %r\" % y\n        )\n\n    sparse_pandas = y.__class__.__name__ in [\"SparseSeries\", \"SparseArray\"]\n    if sparse_pandas:\n        raise ValueError(\"y cannot be class 'SparseSeries' or 'SparseArray'\")\n\n    if is_multilabel(y):\n        return \"multilabel-indicator\"\n\n    # Handle pandas extension dtypes before numpy conversion\n    try:\n        import pandas as pd\n        from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n        \n        if hasattr(y, 'dtype') and is_extension_array_dtype(y.dtype):\n            # Handle pandas nullable dtypes by preserving their semantic meaning\n            if is_integer_dtype(y.dtype):\n                # Convert nullable Int64 to regular int64 for consistent classification\n                y = y.astype('int64')\n            elif is_float_dtype(y.dtype):\n                # Convert nullable Float64 to regular float64 for consistent classification  \n                y = y.astype('float64')\n            elif is_bool_dtype(y.dtype):\n                # Convert nullable boolean to regular bool for consistent classification\n                y = y.astype('bool')\n    except ImportError:\n        pass\n\n    # DeprecationWarning will be replaced by ValueError, see NEP 34\n    # https://numpy.org/neps/nep-0034-infer-dtype-is-object.html\n    # We therefore catch both deprecation (NumPy < 1.24) warning and\n    # value error (NumPy >= 1.24).\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n",
      "\n    sparse_pandas = y.__class__.__name__ in [\"SparseSeries\", \"SparseArray\"]\n    if sparse_pandas:\n        raise ValueError(\"y cannot be class 'SparseSeries' or 'SparseArray'\")\n\n    # Handle pandas extension dtypes before numpy conversion\n    try:\n        import pandas as pd\n        from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n        \n        if hasattr(y, 'dtype') and is_extension_array_dtype(y.dtype):\n            # Handle pandas nullable dtypes by preserving their semantic meaning\n            if is_integer_dtype(y.dtype):\n                # Convert nullable Int64 to regular int64 for consistent classification\n                y = y.astype('int64')\n            elif is_float_dtype(y.dtype):\n                # Convert nullable Float64 to regular float64 for consistent classification  \n                y = y.astype('float64')\n            elif is_bool_dtype(y.dtype):\n                # Convert nullable boolean to regular bool for consistent classification\n                y = y.astype('bool')\n    except ImportError:\n        # pandas not available, proceed with existing logic\n        pass\n\n    if is_multilabel(y):\n        return \"multilabel-indicator\"\n\n    # DeprecationWarning will be replaced by ValueError, see NEP 34\n    # https://numpy.org/neps/nep-0034-infer-dtype-is-object.html\n    # We therefore catch both deprecation (NumPy < 1.24) warning and\n    # value error (NumPy >= 1.24).\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n",
      "\n    if not valid:\n        raise ValueError(\n            \"Expected array-like (array or non-string sequence), got %r\" % y\n        )\n\n    sparse_pandas = y.__class__.__name__ in [\"SparseSeries\", \"SparseArray\"]\n    if sparse_pandas:\n        raise ValueError(\"y cannot be class 'SparseSeries' or 'SparseArray'\")\n\n    if is_multilabel(y):\n        return \"multilabel-indicator\"\n\n    # Handle pandas extension dtypes before numpy conversion\n    try:\n        import pandas as pd\n        from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n        if hasattr(y, 'dtype') and is_extension_array_dtype(y.dtype):\n            # Convert pandas nullable dtypes to their non-nullable equivalents\n            if is_integer_dtype(y.dtype):\n                y = y.astype('int64')\n            elif is_float_dtype(y.dtype):\n                y = y.astype('float64')\n            elif is_bool_dtype(y.dtype):\n                y = y.astype('bool')\n    except ImportError:\n        pass\n\n    # DeprecationWarning will be replaced by ValueError, see NEP 34\n    # https://numpy.org/neps/nep-0034-infer-dtype-is-object.html\n    # We therefore catch both deprecation (NumPy < 1.24) warning and\n    # value error (NumPy >= 1.24).\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n",
      "\n    if not valid:\n        raise ValueError(\n            \"Expected array-like (array or non-string sequence), got %r\" % y\n        )\n\n    sparse_pandas = y.__class__.__name__ in [\"SparseSeries\", \"SparseArray\"]\n    if sparse_pandas:\n        raise ValueError(\"y cannot be class 'SparseSeries' or 'SparseArray'\")\n\n    if is_multilabel(y):\n        return \"multilabel-indicator\"\n\n    # Handle pandas extension dtypes before numpy conversion\n    try:\n        import pandas as pd\n        from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n        if hasattr(y, 'dtype') and is_extension_array_dtype(y.dtype):\n            # Convert pandas nullable dtypes to their non-nullable equivalents\n            if is_integer_dtype(y.dtype):\n                y = y.astype('int64')\n            elif is_float_dtype(y.dtype):\n                y = y.astype('float64')\n            elif is_bool_dtype(y.dtype):\n                y = y.astype('bool')\n    except ImportError:\n        pass\n\n    # DeprecationWarning will be replaced by ValueError, see NEP 34\n    # https://numpy.org/neps/nep-0034-infer-dtype-is-object.html\n    # We therefore catch both deprecation (NumPy < 1.24) warning and\n    # value error (NumPy >= 1.24).\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n",
      "\n    if not valid:\n        raise ValueError(\n            \"Expected array-like (array or non-string sequence), got %r\" % y\n        )\n\n    sparse_pandas = y.__class__.__name__ in [\"SparseSeries\", \"SparseArray\"]\n    if sparse_pandas:\n        raise ValueError(\"y cannot be class 'SparseSeries' or 'SparseArray'\")\n\n    if is_multilabel(y):\n        return \"multilabel-indicator\"\n\n    # Handle pandas extension dtypes before numpy conversion\n    try:\n        import pandas as pd\n        from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n        \n        if hasattr(y, 'dtype') and is_extension_array_dtype(y.dtype):\n            # Convert pandas nullable dtypes to their non-nullable equivalents\n            if is_integer_dtype(y.dtype):\n                y = y.astype('int64')\n            elif is_float_dtype(y.dtype):\n                y = y.astype('float64')\n            elif is_bool_dtype(y.dtype):\n                y = y.astype('bool')\n    except ImportError:\n        pass\n\n    # DeprecationWarning will be replaced by ValueError, see NEP 34\n    # https://numpy.org/neps/nep-0034-infer-dtype-is-object.html\n    # We therefore catch both deprecation (NumPy < 1.24) warning and\n    # value error (NumPy >= 1.24).\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n",
      "\n    # Handle pandas extension dtypes before numpy conversion\n    if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n        try:\n            import pandas as pd\n            from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n            \n            if is_extension_array_dtype(y.dtype):\n                # Convert pandas nullable dtypes to their non-nullable equivalents\n                if is_integer_dtype(y.dtype):\n                    y = y.astype('int64')\n                elif is_float_dtype(y.dtype):\n                    y = y.astype('float64')\n                elif is_bool_dtype(y.dtype):\n                    y = y.astype('bool')\n        except ImportError:\n            pass\n\n    sparse_pandas = y.__class__.__name__ in [\"SparseSeries\", \"SparseArray\"]\n    if sparse_pandas:\n        raise ValueError(\"y cannot be class 'SparseSeries' or 'SparseArray'\")\n\n    if is_multilabel(y):\n        return \"multilabel-indicator\"\n\n    # DeprecationWarning will be replaced by ValueError, see NEP 34\n    # https://numpy.org/neps/nep-0034-infer-dtype-is-object.html\n    # We therefore catch both deprecation (NumPy < 1.24) warning and\n    # value error (NumPy >= 1.24).\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n"
    ],
    "Location 3 (/root/hy/projects_3/scikit-learn/sklearn/utils/multiclass.py lines 307-313)": [
      "\n    # Handle pandas extension dtypes before numpy conversion\n    if _pandas_available and hasattr(y, 'dtype') and is_extension_array_dtype(y.dtype):\n        # Handle pandas nullable dtypes by preserving their semantic meaning\n        if is_integer_dtype(y.dtype):\n            # Convert nullable Int64 to regular int64 for consistent classification\n            y = y.astype('int64')\n        elif is_float_dtype(y.dtype):\n            # Convert nullable Float64 to regular float64 for consistent classification  \n            y = y.astype('float64')\n        elif is_bool_dtype(y.dtype):\n            # Convert nullable boolean to regular bool for consistent classification\n            y = y.astype('bool')\n\n    if not issparse(y):\n        try:\n            y = xp.asarray(y)\n        except (np.VisibleDeprecationWarning, ValueError):\n            # dtype=object should be provided explicitly for ragged arrays,\n            # see NEP 34\n            y = xp.asarray(y, dtype=object)\n",
      "\n    # Handle pandas extension dtypes before numpy conversion\n    if _pandas_available and hasattr(y, 'dtype') and is_extension_array_dtype(y.dtype):\n        # Handle pandas nullable dtypes by preserving their semantic meaning\n        if is_integer_dtype(y.dtype):\n            # Convert nullable Int64 to regular int64 for consistent classification\n            y = y.astype('int64')\n        elif is_float_dtype(y.dtype):\n            # Convert nullable Float64 to regular float64 for consistent classification  \n            y = y.astype('float64')\n        elif is_bool_dtype(y.dtype):\n            # Convert nullable boolean to regular bool for consistent classification\n            y = y.astype('bool')\n\n    if not issparse(y):\n        try:\n            y = xp.asarray(y)\n        except (np.VisibleDeprecationWarning, ValueError):\n            # dtype=object should be provided explicitly for ragged arrays,\n            # see NEP 34\n            y = xp.asarray(y, dtype=object)\n",
      "\n    # Handle pandas extension arrays before numpy conversion\n    if _pandas_available and hasattr(y, 'dtype') and is_extension_array_dtype(y.dtype):\n        # Handle pandas nullable dtypes by preserving their semantic meaning\n        if is_integer_dtype(y.dtype):\n            # Convert nullable Int64 to regular int64 for consistent classification\n            y = y.astype('int64')\n        elif is_float_dtype(y.dtype):\n            # Convert nullable Float64 to regular float64 for consistent classification  \n            y = y.astype('float64')\n        elif is_bool_dtype(y.dtype):\n            # Convert nullable boolean to regular bool for consistent classification\n            y = y.astype('bool')\n\n    if not issparse(y):\n        try:\n            y = xp.asarray(y)\n        except (np.VisibleDeprecationWarning, ValueError):\n            # dtype=object should be provided explicitly for ragged arrays,\n            # see NEP 34\n            y = xp.asarray(y, dtype=object)\n",
      "\n    # Handle pandas extension dtypes before numpy conversion\n    if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n        try:\n            import pandas as pd\n            from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n            \n            if is_extension_array_dtype(y.dtype):\n                # Convert pandas nullable dtypes to their non-nullable equivalents\n                if is_integer_dtype(y.dtype):\n                    y = y.astype('int64')\n                elif is_float_dtype(y.dtype):\n                    y = y.astype('float64')\n                elif is_bool_dtype(y.dtype):\n                    y = y.astype('bool')\n        except ImportError:\n            # pandas not available, continue with existing logic\n            pass\n\n    if not issparse(y):\n        try:\n            y = xp.asarray(y)\n        except (np.VisibleDeprecationWarning, ValueError):\n            # dtype=object should be provided explicitly for ragged arrays,\n            # see NEP 34\n            y = xp.asarray(y, dtype=object)\n",
      "\n    # Handle pandas extension dtypes before numpy conversion\n    if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n        try:\n            import pandas as pd\n            from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n            \n            if is_extension_array_dtype(y.dtype):\n                # Convert pandas nullable dtypes to their non-nullable equivalents\n                if is_integer_dtype(y.dtype):\n                    y = y.astype('int64')\n                elif is_float_dtype(y.dtype):\n                    y = y.astype('float64')\n                elif is_bool_dtype(y.dtype):\n                    y = y.astype('bool')\n        except ImportError:\n            pass\n\n    if not issparse(y):\n        try:\n            y = xp.asarray(y)\n        except (np.VisibleDeprecationWarning, ValueError):\n            # dtype=object should be provided explicitly for ragged arrays,\n            # see NEP 34\n            y = xp.asarray(y, dtype=object)\n",
      "\n    # Handle pandas extension dtypes before numpy conversion\n    if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n        try:\n            import pandas as pd\n            from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n            \n            if is_extension_array_dtype(y.dtype):\n                # Convert pandas nullable dtypes to their non-nullable equivalents\n                if is_integer_dtype(y.dtype):\n                    y = y.astype('int64')\n                elif is_float_dtype(y.dtype):\n                    y = y.astype('float64')\n                elif is_bool_dtype(y.dtype):\n                    y = y.astype('bool')\n        except ImportError:\n            # pandas not available, continue with existing logic\n            pass\n\n    if not issparse(y):\n        try:\n            y = xp.asarray(y)\n        except (np.VisibleDeprecationWarning, ValueError):\n            # dtype=object should be provided explicitly for ragged arrays,\n            # see NEP 34\n            y = xp.asarray(y, dtype=object)\n",
      "\n    # Handle pandas extension dtypes before numpy conversion\n    if _pandas_available and hasattr(y, 'dtype') and is_extension_array_dtype(y.dtype):\n        # Handle pandas nullable dtypes by preserving their semantic meaning\n        if is_integer_dtype(y.dtype):\n            # Convert nullable Int64 to regular int64 for consistent classification\n            y = y.astype('int64')\n        elif is_float_dtype(y.dtype):\n            # Convert nullable Float64 to regular float64 for consistent classification  \n            y = y.astype('float64')\n        elif is_bool_dtype(y.dtype):\n            # Convert nullable boolean to regular bool for consistent classification\n            y = y.astype('bool')\n\n    if not issparse(y):\n        try:\n            y = xp.asarray(y)\n        except (np.VisibleDeprecationWarning, ValueError):\n            # dtype=object should be provided explicitly for ragged arrays,\n            # see NEP 34\n            y = xp.asarray(y, dtype=object)\n",
      "\n    # Handle pandas extension dtypes before numpy conversion\n    if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n        try:\n            import pandas as pd\n            from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n            \n            if is_extension_array_dtype(y.dtype):\n                # Convert pandas nullable dtypes to their non-nullable equivalents\n                if is_integer_dtype(y.dtype):\n                    y = y.astype('int64')\n                elif is_float_dtype(y.dtype):\n                    y = y.astype('float64')\n                elif is_bool_dtype(y.dtype):\n                    y = y.astype('bool')\n        except ImportError:\n            pass\n\n    if not issparse(y):\n        try:\n            y = xp.asarray(y)\n        except (np.VisibleDeprecationWarning, ValueError):\n            # dtype=object should be provided explicitly for ragged arrays,\n            # see NEP 34\n            y = xp.asarray(y, dtype=object)\n"
    ],
    "Location 4 (/root/hy/projects_3/scikit-learn/sklearn/utils/multiclass.py lines 340-346)": [
      "\n    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n        # Check if this is a pandas extension array that should be handled differently\n        if _pandas_available and hasattr(y, 'dtype') and is_extension_array_dtype(y.dtype):\n            # Skip the unknown classification for pandas extension arrays\n            pass\n        else:\n            # [obj_1] and not [\"label_1\"]\n            return \"unknown\"\n",
      "\n    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n        # Check if this might be a pandas extension array that wasn't properly converted\n        if hasattr(y, 'dtype') and str(y.dtype).startswith(('Int', 'Float', 'boolean')):\n            # This is likely a pandas extension dtype that should have been converted earlier\n            pass\n        else:\n            # [obj_1] and not [\"label_1\"]\n            return \"unknown\"\n",
      "\n    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n        # Check if this might be a pandas extension array that wasn't properly converted\n        if _pandas_available and hasattr(y, 'dtype'):\n            try:\n                if is_extension_array_dtype(y.dtype):\n                    # This should have been handled earlier, but as fallback return based on content\n                    return \"unknown\"\n            except (AttributeError, TypeError):\n                pass\n        # [obj_1] and not [\"label_1\"]\n        return \"unknown\"\n",
      "\n    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n        # [obj_1] and not [\"label_1\"]\n        return \"unknown\"\n",
      "\n    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n        # Check if this is a pandas extension array that should be handled differently\n        if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n            # Skip object dtype classification for pandas extension arrays\n            # as they should have been converted earlier\n            pass\n        else:\n            # [obj_1] and not [\"label_1\"]\n            return \"unknown\"\n",
      "\n    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n        # Check if this might be a pandas extension array that wasn't properly converted\n        if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n            # Skip classification as unknown for pandas extension arrays\n            pass\n        else:\n            # [obj_1] and not [\"label_1\"]\n            return \"unknown\"\n",
      "\n    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n        # [obj_1] and not [\"label_1\"]\n        return \"unknown\"\n",
      "\n    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n        # Check if this is a pandas extension array that should be handled differently\n        if _pandas_available and hasattr(y, 'dtype') and is_extension_array_dtype(y.dtype):\n            # This is a pandas extension array, don't classify as unknown\n            pass\n        else:\n            # [obj_1] and not [\"label_1\"]\n            return \"unknown\"\n"
    ],
    "Location 5 (/root/hy/projects_3/scikit-learn/sklearn/utils/multiclass.py lines 81-81)": [
      "\nys_types = set(type_of_target(x) for x in ys)\n",
      "\nys_types = set(type_of_target(x) for x in ys)\n",
      "\nys_types = set(type_of_target(x) for x in ys)\n",
      "\n    ys_types = set(type_of_target(x) for x in ys)\n",
      "\nys_types = set(type_of_target(x) for x in ys)\n",
      "\n    ys_types = set(type_of_target(x) for x in ys)\n",
      "\nys_types = set(type_of_target(x) for x in ys)\n",
      "\nys_types = set(type_of_target(x) for x in ys)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sklearn/utils/multiclass.py b/sklearn/utils/multiclass.py\nindex 5eaef2fde..a965db9c3 100644\n--- a/sklearn/utils/multiclass.py\n+++ b/sklearn/utils/multiclass.py\n@@ -1,3 +1,4 @@\n+\n # Author: Arnaud Joly, Joel Nothman, Hamzeh Alsalhi\n #\n # License: BSD 3 clause\n@@ -19,6 +20,23 @@ import numpy as np\n from .validation import check_array, _assert_all_finite\n from ..utils._array_api import get_namespace\n \n+# Add pandas dtype checking imports for nullable dtype support\n+try:\n+    from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n+    _pandas_available = True\n+except ImportError:\n+    _pandas_available = False\n+import warnings\n+\n+from scipy.sparse import issparse\n+from scipy.sparse import dok_matrix\n+from scipy.sparse import lil_matrix\n+\n+import numpy as np\n+\n+from .validation import check_array, _assert_all_finite\n+from ..utils._array_api import get_namespace\n+\n \n def _unique_multiclass(y):\n     xp, is_array_api = get_namespace(y)\n@@ -78,6 +96,7 @@ def unique_labels(*ys):\n         raise ValueError(\"No argument has been passed.\")\n     # Check that we don't mix label format\n \n+\n     ys_types = set(type_of_target(x) for x in ys)\n     if ys_types == {\"binary\", \"multiclass\"}:\n         ys_types = {\"multiclass\"}\n@@ -287,6 +306,7 @@ def type_of_target(y, input_name=\"\"):\n     )\n \n     if not valid:\n+\n         raise ValueError(\n             \"Expected array-like (array or non-string sequence), got %r\" % y\n         )\n@@ -298,12 +318,25 @@ def type_of_target(y, input_name=\"\"):\n     if is_multilabel(y):\n         return \"multilabel-indicator\"\n \n+    # Handle pandas nullable dtypes by preserving their semantic meaning\n+    if _pandas_available and hasattr(y, 'dtype') and is_extension_array_dtype(y.dtype):\n+        if is_integer_dtype(y.dtype):\n+            # Convert nullable Int64 to regular int64 for consistent classification\n+            y = y.astype('int64')\n+        elif is_float_dtype(y.dtype):\n+            # Convert nullable Float64 to regular float64 for consistent classification  \n+            y = y.astype('float64')\n+        elif is_bool_dtype(y.dtype):\n+            # Convert nullable boolean to regular bool for consistent classification\n+            y = y.astype('bool')\n+\n     # DeprecationWarning will be replaced by ValueError, see NEP 34\n     # https://numpy.org/neps/nep-0034-infer-dtype-is-object.html\n     # We therefore catch both deprecation (NumPy < 1.24) warning and\n     # value error (NumPy >= 1.24).\n     with warnings.catch_warnings():\n         warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n+\n         if not issparse(y):\n             try:\n                 y = xp.asarray(y)\n@@ -337,13 +370,13 @@ def type_of_target(y, input_name=\"\"):\n         # Empty ndarray: []/[[]]\n         if y.ndim == 1:\n             # 1-D empty array: []\n+\n             return \"binary\"  # []\n         # 2-D empty array: [[]]\n         return \"unknown\"\n     if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n         # [obj_1] and not [\"label_1\"]\n         return \"unknown\"\n-\n     # Check if multioutput\n     if y.ndim == 2 and y.shape[1] > 1:\n         suffix = \"-multioutput\"  # [[1, 2], [1, 2]]\n",
    "variant_0": "diff --git a/sklearn/utils/multiclass.py b/sklearn/utils/multiclass.py\nindex 5eaef2fde..e76fd1b2b 100644\n--- a/sklearn/utils/multiclass.py\n+++ b/sklearn/utils/multiclass.py\n@@ -1,3 +1,4 @@\n+\n # Author: Arnaud Joly, Joel Nothman, Hamzeh Alsalhi\n #\n # License: BSD 3 clause\n@@ -19,6 +20,23 @@ import numpy as np\n from .validation import check_array, _assert_all_finite\n from ..utils._array_api import get_namespace\n \n+try:\n+    import pandas as pd\n+    from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n+    _pandas_available = True\n+except ImportError:\n+    _pandas_available = False\n+import warnings\n+\n+from scipy.sparse import issparse\n+from scipy.sparse import dok_matrix\n+from scipy.sparse import lil_matrix\n+\n+import numpy as np\n+\n+from .validation import check_array, _assert_all_finite\n+from ..utils._array_api import get_namespace\n+\n \n def _unique_multiclass(y):\n     xp, is_array_api = get_namespace(y)\n@@ -78,7 +96,8 @@ def unique_labels(*ys):\n         raise ValueError(\"No argument has been passed.\")\n     # Check that we don't mix label format\n \n-    ys_types = set(type_of_target(x) for x in ys)\n+\n+ys_types = set(type_of_target(x) for x in ys)\n     if ys_types == {\"binary\", \"multiclass\"}:\n         ys_types = {\"multiclass\"}\n \n@@ -286,6 +305,8 @@ def type_of_target(y, input_name=\"\"):\n         or is_array_api\n     )\n \n+    if not valid:\n+\n     if not valid:\n         raise ValueError(\n             \"Expected array-like (array or non-string sequence), got %r\" % y\n@@ -298,19 +319,52 @@ def type_of_target(y, input_name=\"\"):\n     if is_multilabel(y):\n         return \"multilabel-indicator\"\n \n+    # Handle pandas nullable dtypes before numpy conversion\n+    try:\n+        import pandas as pd\n+        from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n+        if hasattr(y, 'dtype') and is_extension_array_dtype(y.dtype):\n+            # Convert pandas nullable dtypes to their non-nullable equivalents\n+            if is_integer_dtype(y.dtype):\n+                y = y.astype('int64')\n+            elif is_float_dtype(y.dtype):\n+                y = y.astype('float64')\n+            elif is_bool_dtype(y.dtype):\n+                y = y.astype('bool')\n+    except ImportError:\n+        pass\n+\n     # DeprecationWarning will be replaced by ValueError, see NEP 34\n     # https://numpy.org/neps/nep-0034-infer-dtype-is-object.html\n     # We therefore catch both deprecation (NumPy < 1.24) warning and\n     # value error (NumPy >= 1.24).\n     with warnings.catch_warnings():\n         warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n-        if not issparse(y):\n-            try:\n-                y = xp.asarray(y)\n-            except (np.VisibleDeprecationWarning, ValueError):\n-                # dtype=object should be provided explicitly for ragged arrays,\n-                # see NEP 34\n-                y = xp.asarray(y, dtype=object)\n+\n+    # Handle pandas extension dtypes before numpy conversion\n+    if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n+        try:\n+            import pandas as pd\n+            from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n+            \n+            if is_extension_array_dtype(y.dtype):\n+                # Convert pandas nullable dtypes to their non-nullable equivalents\n+                if is_integer_dtype(y.dtype):\n+                    y = y.astype('int64')\n+                elif is_float_dtype(y.dtype):\n+                    y = y.astype('float64')\n+                elif is_bool_dtype(y.dtype):\n+                    y = y.astype('bool')\n+        except ImportError:\n+            pass\n+\n+    if not issparse(y):\n+        try:\n+            y = xp.asarray(y)\n+        except (np.VisibleDeprecationWarning, ValueError):\n+            # dtype=object should be provided explicitly for ragged arrays,\n+            # see NEP 34\n+            y = xp.asarray(y, dtype=object)\n \n     # The old sequence of sequences format\n     try:\n@@ -337,13 +391,10 @@ def type_of_target(y, input_name=\"\"):\n         # Empty ndarray: []/[[]]\n         if y.ndim == 1:\n             # 1-D empty array: []\n-            return \"binary\"  # []\n-        # 2-D empty array: [[]]\n-        return \"unknown\"\n+\n     if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n         # [obj_1] and not [\"label_1\"]\n         return \"unknown\"\n-\n     # Check if multioutput\n     if y.ndim == 2 and y.shape[1] > 1:\n         suffix = \"-multioutput\"  # [[1, 2], [1, 2]]\n",
    "variant_1": "diff --git a/sklearn/utils/multiclass.py b/sklearn/utils/multiclass.py\nindex 5eaef2fde..8953a1fe4 100644\n--- a/sklearn/utils/multiclass.py\n+++ b/sklearn/utils/multiclass.py\n@@ -1,3 +1,4 @@\n+\n # Author: Arnaud Joly, Joel Nothman, Hamzeh Alsalhi\n #\n # License: BSD 3 clause\n@@ -19,6 +20,23 @@ import numpy as np\n from .validation import check_array, _assert_all_finite\n from ..utils._array_api import get_namespace\n \n+try:\n+    import pandas as pd\n+    from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n+    _pandas_available = True\n+except ImportError:\n+    _pandas_available = False\n+import warnings\n+\n+from scipy.sparse import issparse\n+from scipy.sparse import dok_matrix\n+from scipy.sparse import lil_matrix\n+\n+import numpy as np\n+\n+from .validation import check_array, _assert_all_finite\n+from ..utils._array_api import get_namespace\n+\n \n def _unique_multiclass(y):\n     xp, is_array_api = get_namespace(y)\n@@ -78,7 +96,8 @@ def unique_labels(*ys):\n         raise ValueError(\"No argument has been passed.\")\n     # Check that we don't mix label format\n \n-    ys_types = set(type_of_target(x) for x in ys)\n+\n+ys_types = set(type_of_target(x) for x in ys)\n     if ys_types == {\"binary\", \"multiclass\"}:\n         ys_types = {\"multiclass\"}\n \n@@ -286,6 +305,8 @@ def type_of_target(y, input_name=\"\"):\n         or is_array_api\n     )\n \n+    if not valid:\n+\n     if not valid:\n         raise ValueError(\n             \"Expected array-like (array or non-string sequence), got %r\" % y\n@@ -298,19 +319,51 @@ def type_of_target(y, input_name=\"\"):\n     if is_multilabel(y):\n         return \"multilabel-indicator\"\n \n+    # Handle pandas extension dtypes before numpy conversion\n+    try:\n+        import pandas as pd\n+        from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n+        if hasattr(y, 'dtype') and is_extension_array_dtype(y.dtype):\n+            # Handle pandas nullable dtypes by preserving their semantic meaning\n+            if is_integer_dtype(y.dtype):\n+                # Convert nullable Int64 to regular int64 for consistent classification\n+                y = y.astype('int64')\n+            elif is_float_dtype(y.dtype):\n+                # Convert nullable Float64 to regular float64 for consistent classification  \n+                y = y.astype('float64')\n+            elif is_bool_dtype(y.dtype):\n+                # Convert nullable boolean to regular bool for consistent classification\n+                y = y.astype('bool')\n+    except ImportError:\n+        pass\n+\n     # DeprecationWarning will be replaced by ValueError, see NEP 34\n     # https://numpy.org/neps/nep-0034-infer-dtype-is-object.html\n     # We therefore catch both deprecation (NumPy < 1.24) warning and\n     # value error (NumPy >= 1.24).\n     with warnings.catch_warnings():\n         warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n-        if not issparse(y):\n-            try:\n-                y = xp.asarray(y)\n-            except (np.VisibleDeprecationWarning, ValueError):\n-                # dtype=object should be provided explicitly for ragged arrays,\n-                # see NEP 34\n-                y = xp.asarray(y, dtype=object)\n+\n+    # Handle pandas extension dtypes before numpy conversion\n+    if _pandas_available and hasattr(y, 'dtype') and is_extension_array_dtype(y.dtype):\n+        # Handle pandas nullable dtypes by preserving their semantic meaning\n+        if is_integer_dtype(y.dtype):\n+            # Convert nullable Int64 to regular int64 for consistent classification\n+            y = y.astype('int64')\n+        elif is_float_dtype(y.dtype):\n+            # Convert nullable Float64 to regular float64 for consistent classification  \n+            y = y.astype('float64')\n+        elif is_bool_dtype(y.dtype):\n+            # Convert nullable boolean to regular bool for consistent classification\n+            y = y.astype('bool')\n+\n+    if not issparse(y):\n+        try:\n+            y = xp.asarray(y)\n+        except (np.VisibleDeprecationWarning, ValueError):\n+            # dtype=object should be provided explicitly for ragged arrays,\n+            # see NEP 34\n+            y = xp.asarray(y, dtype=object)\n \n     # The old sequence of sequences format\n     try:\n@@ -337,13 +390,15 @@ def type_of_target(y, input_name=\"\"):\n         # Empty ndarray: []/[[]]\n         if y.ndim == 1:\n             # 1-D empty array: []\n-            return \"binary\"  # []\n-        # 2-D empty array: [[]]\n-        return \"unknown\"\n-    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n-        # [obj_1] and not [\"label_1\"]\n-        return \"unknown\"\n \n+    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n+        # Check if this is a pandas extension array that should be handled differently\n+        if _pandas_available and hasattr(y, 'dtype') and is_extension_array_dtype(y.dtype):\n+            # Skip the unknown classification for pandas extension arrays\n+            pass\n+        else:\n+            # [obj_1] and not [\"label_1\"]\n+            return \"unknown\"\n     # Check if multioutput\n     if y.ndim == 2 and y.shape[1] > 1:\n         suffix = \"-multioutput\"  # [[1, 2], [1, 2]]\n",
    "variant_2": "diff --git a/sklearn/utils/multiclass.py b/sklearn/utils/multiclass.py\nindex 5eaef2fde..f9e51f090 100644\n--- a/sklearn/utils/multiclass.py\n+++ b/sklearn/utils/multiclass.py\n@@ -1,3 +1,4 @@\n+\n # Author: Arnaud Joly, Joel Nothman, Hamzeh Alsalhi\n #\n # License: BSD 3 clause\n@@ -19,6 +20,23 @@ import numpy as np\n from .validation import check_array, _assert_all_finite\n from ..utils._array_api import get_namespace\n \n+try:\n+    import pandas as pd\n+    from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n+    _pandas_available = True\n+except ImportError:\n+    _pandas_available = False\n+import warnings\n+\n+from scipy.sparse import issparse\n+from scipy.sparse import dok_matrix\n+from scipy.sparse import lil_matrix\n+\n+import numpy as np\n+\n+from .validation import check_array, _assert_all_finite\n+from ..utils._array_api import get_namespace\n+\n \n def _unique_multiclass(y):\n     xp, is_array_api = get_namespace(y)\n@@ -78,7 +96,8 @@ def unique_labels(*ys):\n         raise ValueError(\"No argument has been passed.\")\n     # Check that we don't mix label format\n \n-    ys_types = set(type_of_target(x) for x in ys)\n+\n+ys_types = set(type_of_target(x) for x in ys)\n     if ys_types == {\"binary\", \"multiclass\"}:\n         ys_types = {\"multiclass\"}\n \n@@ -286,6 +305,8 @@ def type_of_target(y, input_name=\"\"):\n         or is_array_api\n     )\n \n+    if not valid:\n+\n     if not valid:\n         raise ValueError(\n             \"Expected array-like (array or non-string sequence), got %r\" % y\n@@ -298,19 +319,49 @@ def type_of_target(y, input_name=\"\"):\n     if is_multilabel(y):\n         return \"multilabel-indicator\"\n \n+    # Handle pandas extension dtypes before numpy conversion\n+    try:\n+        import pandas as pd\n+        from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n+        \n+        if hasattr(y, 'dtype') and is_extension_array_dtype(y.dtype):\n+            # Convert nullable pandas dtypes to their non-nullable equivalents\n+            if is_integer_dtype(y.dtype):\n+                y = y.astype('int64')\n+            elif is_float_dtype(y.dtype):\n+                y = y.astype('float64')\n+            elif is_bool_dtype(y.dtype):\n+                y = y.astype('bool')\n+    except ImportError:\n+        pass\n+\n     # DeprecationWarning will be replaced by ValueError, see NEP 34\n     # https://numpy.org/neps/nep-0034-infer-dtype-is-object.html\n     # We therefore catch both deprecation (NumPy < 1.24) warning and\n     # value error (NumPy >= 1.24).\n     with warnings.catch_warnings():\n         warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n-        if not issparse(y):\n-            try:\n-                y = xp.asarray(y)\n-            except (np.VisibleDeprecationWarning, ValueError):\n-                # dtype=object should be provided explicitly for ragged arrays,\n-                # see NEP 34\n-                y = xp.asarray(y, dtype=object)\n+\n+    # Handle pandas extension dtypes before numpy conversion\n+    if _pandas_available and hasattr(y, 'dtype') and is_extension_array_dtype(y.dtype):\n+        # Handle pandas nullable dtypes by preserving their semantic meaning\n+        if is_integer_dtype(y.dtype):\n+            # Convert nullable Int64 to regular int64 for consistent classification\n+            y = y.astype('int64')\n+        elif is_float_dtype(y.dtype):\n+            # Convert nullable Float64 to regular float64 for consistent classification  \n+            y = y.astype('float64')\n+        elif is_bool_dtype(y.dtype):\n+            # Convert nullable boolean to regular bool for consistent classification\n+            y = y.astype('bool')\n+\n+    if not issparse(y):\n+        try:\n+            y = xp.asarray(y)\n+        except (np.VisibleDeprecationWarning, ValueError):\n+            # dtype=object should be provided explicitly for ragged arrays,\n+            # see NEP 34\n+            y = xp.asarray(y, dtype=object)\n \n     # The old sequence of sequences format\n     try:\n@@ -337,13 +388,15 @@ def type_of_target(y, input_name=\"\"):\n         # Empty ndarray: []/[[]]\n         if y.ndim == 1:\n             # 1-D empty array: []\n-            return \"binary\"  # []\n-        # 2-D empty array: [[]]\n-        return \"unknown\"\n-    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n-        # [obj_1] and not [\"label_1\"]\n-        return \"unknown\"\n \n+    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n+        # Check if this might be a pandas extension array that wasn't properly converted\n+        if hasattr(y, 'dtype') and str(y.dtype).startswith(('Int', 'Float', 'boolean')):\n+            # This is likely a pandas extension dtype that should have been converted earlier\n+            pass\n+        else:\n+            # [obj_1] and not [\"label_1\"]\n+            return \"unknown\"\n     # Check if multioutput\n     if y.ndim == 2 and y.shape[1] > 1:\n         suffix = \"-multioutput\"  # [[1, 2], [1, 2]]\n",
    "variant_3": "diff --git a/sklearn/utils/multiclass.py b/sklearn/utils/multiclass.py\nindex 5eaef2fde..5da80ad9d 100644\n--- a/sklearn/utils/multiclass.py\n+++ b/sklearn/utils/multiclass.py\n@@ -1,3 +1,4 @@\n+\n # Author: Arnaud Joly, Joel Nothman, Hamzeh Alsalhi\n #\n # License: BSD 3 clause\n@@ -19,6 +20,23 @@ import numpy as np\n from .validation import check_array, _assert_all_finite\n from ..utils._array_api import get_namespace\n \n+try:\n+    import pandas as pd\n+    from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n+    _pandas_available = True\n+except ImportError:\n+    _pandas_available = False\n+import warnings\n+\n+from scipy.sparse import issparse\n+from scipy.sparse import dok_matrix\n+from scipy.sparse import lil_matrix\n+\n+import numpy as np\n+\n+from .validation import check_array, _assert_all_finite\n+from ..utils._array_api import get_namespace\n+\n \n def _unique_multiclass(y):\n     xp, is_array_api = get_namespace(y)\n@@ -78,7 +96,8 @@ def unique_labels(*ys):\n         raise ValueError(\"No argument has been passed.\")\n     # Check that we don't mix label format\n \n-    ys_types = set(type_of_target(x) for x in ys)\n+\n+ys_types = set(type_of_target(x) for x in ys)\n     if ys_types == {\"binary\", \"multiclass\"}:\n         ys_types = {\"multiclass\"}\n \n@@ -286,6 +305,8 @@ def type_of_target(y, input_name=\"\"):\n         or is_array_api\n     )\n \n+    if not valid:\n+\n     if not valid:\n         raise ValueError(\n             \"Expected array-like (array or non-string sequence), got %r\" % y\n@@ -298,19 +319,52 @@ def type_of_target(y, input_name=\"\"):\n     if is_multilabel(y):\n         return \"multilabel-indicator\"\n \n+    # Handle pandas extension dtypes before numpy conversion\n+    try:\n+        import pandas as pd\n+        from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n+        \n+        if hasattr(y, 'dtype') and is_extension_array_dtype(y.dtype):\n+            # Handle pandas nullable dtypes by preserving their semantic meaning\n+            if is_integer_dtype(y.dtype):\n+                # Convert nullable Int64 to regular int64 for consistent classification\n+                y = y.astype('int64')\n+            elif is_float_dtype(y.dtype):\n+                # Convert nullable Float64 to regular float64 for consistent classification  \n+                y = y.astype('float64')\n+            elif is_bool_dtype(y.dtype):\n+                # Convert nullable boolean to regular bool for consistent classification\n+                y = y.astype('bool')\n+    except ImportError:\n+        pass\n+\n     # DeprecationWarning will be replaced by ValueError, see NEP 34\n     # https://numpy.org/neps/nep-0034-infer-dtype-is-object.html\n     # We therefore catch both deprecation (NumPy < 1.24) warning and\n     # value error (NumPy >= 1.24).\n     with warnings.catch_warnings():\n         warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n-        if not issparse(y):\n-            try:\n-                y = xp.asarray(y)\n-            except (np.VisibleDeprecationWarning, ValueError):\n-                # dtype=object should be provided explicitly for ragged arrays,\n-                # see NEP 34\n-                y = xp.asarray(y, dtype=object)\n+\n+    # Handle pandas extension arrays before numpy conversion\n+    if _pandas_available and hasattr(y, 'dtype') and is_extension_array_dtype(y.dtype):\n+        # Handle pandas nullable dtypes by preserving their semantic meaning\n+        if is_integer_dtype(y.dtype):\n+            # Convert nullable Int64 to regular int64 for consistent classification\n+            y = y.astype('int64')\n+        elif is_float_dtype(y.dtype):\n+            # Convert nullable Float64 to regular float64 for consistent classification  \n+            y = y.astype('float64')\n+        elif is_bool_dtype(y.dtype):\n+            # Convert nullable boolean to regular bool for consistent classification\n+            y = y.astype('bool')\n+\n+    if not issparse(y):\n+        try:\n+            y = xp.asarray(y)\n+        except (np.VisibleDeprecationWarning, ValueError):\n+            # dtype=object should be provided explicitly for ragged arrays,\n+            # see NEP 34\n+            y = xp.asarray(y, dtype=object)\n \n     # The old sequence of sequences format\n     try:\n@@ -337,13 +391,18 @@ def type_of_target(y, input_name=\"\"):\n         # Empty ndarray: []/[[]]\n         if y.ndim == 1:\n             # 1-D empty array: []\n-            return \"binary\"  # []\n-        # 2-D empty array: [[]]\n-        return \"unknown\"\n+\n     if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n+        # Check if this might be a pandas extension array that wasn't properly converted\n+        if _pandas_available and hasattr(y, 'dtype'):\n+            try:\n+                if is_extension_array_dtype(y.dtype):\n+                    # This should have been handled earlier, but as fallback return based on content\n+                    return \"unknown\"\n+            except (AttributeError, TypeError):\n+                pass\n         # [obj_1] and not [\"label_1\"]\n         return \"unknown\"\n-\n     # Check if multioutput\n     if y.ndim == 2 and y.shape[1] > 1:\n         suffix = \"-multioutput\"  # [[1, 2], [1, 2]]\n",
    "variant_4": "diff --git a/sklearn/utils/multiclass.py b/sklearn/utils/multiclass.py\nindex 5eaef2fde..f7f100aed 100644\n--- a/sklearn/utils/multiclass.py\n+++ b/sklearn/utils/multiclass.py\n@@ -1,3 +1,4 @@\n+\n # Author: Arnaud Joly, Joel Nothman, Hamzeh Alsalhi\n #\n # License: BSD 3 clause\n@@ -19,6 +20,23 @@ import numpy as np\n from .validation import check_array, _assert_all_finite\n from ..utils._array_api import get_namespace\n \n+try:\n+    import pandas as pd\n+    from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n+    _pandas_available = True\n+except ImportError:\n+    _pandas_available = False\n+import warnings\n+\n+from scipy.sparse import issparse\n+from scipy.sparse import dok_matrix\n+from scipy.sparse import lil_matrix\n+\n+import numpy as np\n+\n+from .validation import check_array, _assert_all_finite\n+from ..utils._array_api import get_namespace\n+\n \n def _unique_multiclass(y):\n     xp, is_array_api = get_namespace(y)\n@@ -78,6 +96,7 @@ def unique_labels(*ys):\n         raise ValueError(\"No argument has been passed.\")\n     # Check that we don't mix label format\n \n+\n     ys_types = set(type_of_target(x) for x in ys)\n     if ys_types == {\"binary\", \"multiclass\"}:\n         ys_types = {\"multiclass\"}\n@@ -287,14 +306,31 @@ def type_of_target(y, input_name=\"\"):\n     )\n \n     if not valid:\n-        raise ValueError(\n-            \"Expected array-like (array or non-string sequence), got %r\" % y\n-        )\n \n     sparse_pandas = y.__class__.__name__ in [\"SparseSeries\", \"SparseArray\"]\n     if sparse_pandas:\n         raise ValueError(\"y cannot be class 'SparseSeries' or 'SparseArray'\")\n \n+    # Handle pandas extension dtypes before numpy conversion\n+    try:\n+        import pandas as pd\n+        from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n+        \n+        if hasattr(y, 'dtype') and is_extension_array_dtype(y.dtype):\n+            # Handle pandas nullable dtypes by preserving their semantic meaning\n+            if is_integer_dtype(y.dtype):\n+                # Convert nullable Int64 to regular int64 for consistent classification\n+                y = y.astype('int64')\n+            elif is_float_dtype(y.dtype):\n+                # Convert nullable Float64 to regular float64 for consistent classification  \n+                y = y.astype('float64')\n+            elif is_bool_dtype(y.dtype):\n+                # Convert nullable boolean to regular bool for consistent classification\n+                y = y.astype('bool')\n+    except ImportError:\n+        # pandas not available, proceed with existing logic\n+        pass\n+\n     if is_multilabel(y):\n         return \"multilabel-indicator\"\n \n@@ -304,13 +340,32 @@ def type_of_target(y, input_name=\"\"):\n     # value error (NumPy >= 1.24).\n     with warnings.catch_warnings():\n         warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n-        if not issparse(y):\n-            try:\n-                y = xp.asarray(y)\n-            except (np.VisibleDeprecationWarning, ValueError):\n-                # dtype=object should be provided explicitly for ragged arrays,\n-                # see NEP 34\n-                y = xp.asarray(y, dtype=object)\n+\n+    # Handle pandas extension dtypes before numpy conversion\n+    if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n+        try:\n+            import pandas as pd\n+            from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n+            \n+            if is_extension_array_dtype(y.dtype):\n+                # Convert pandas nullable dtypes to their non-nullable equivalents\n+                if is_integer_dtype(y.dtype):\n+                    y = y.astype('int64')\n+                elif is_float_dtype(y.dtype):\n+                    y = y.astype('float64')\n+                elif is_bool_dtype(y.dtype):\n+                    y = y.astype('bool')\n+        except ImportError:\n+            # pandas not available, continue with existing logic\n+            pass\n+\n+    if not issparse(y):\n+        try:\n+            y = xp.asarray(y)\n+        except (np.VisibleDeprecationWarning, ValueError):\n+            # dtype=object should be provided explicitly for ragged arrays,\n+            # see NEP 34\n+            y = xp.asarray(y, dtype=object)\n \n     # The old sequence of sequences format\n     try:\n@@ -337,13 +392,10 @@ def type_of_target(y, input_name=\"\"):\n         # Empty ndarray: []/[[]]\n         if y.ndim == 1:\n             # 1-D empty array: []\n-            return \"binary\"  # []\n-        # 2-D empty array: [[]]\n-        return \"unknown\"\n+\n     if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n         # [obj_1] and not [\"label_1\"]\n         return \"unknown\"\n-\n     # Check if multioutput\n     if y.ndim == 2 and y.shape[1] > 1:\n         suffix = \"-multioutput\"  # [[1, 2], [1, 2]]\n",
    "variant_5": "diff --git a/sklearn/utils/multiclass.py b/sklearn/utils/multiclass.py\nindex 5eaef2fde..2a1e99bce 100644\n--- a/sklearn/utils/multiclass.py\n+++ b/sklearn/utils/multiclass.py\n@@ -1,3 +1,4 @@\n+\n # Author: Arnaud Joly, Joel Nothman, Hamzeh Alsalhi\n #\n # License: BSD 3 clause\n@@ -19,6 +20,23 @@ import numpy as np\n from .validation import check_array, _assert_all_finite\n from ..utils._array_api import get_namespace\n \n+try:\n+    import pandas as pd\n+    from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n+    _pandas_available = True\n+except ImportError:\n+    _pandas_available = False\n+import warnings\n+\n+from scipy.sparse import issparse\n+from scipy.sparse import dok_matrix\n+from scipy.sparse import lil_matrix\n+\n+import numpy as np\n+\n+from .validation import check_array, _assert_all_finite\n+from ..utils._array_api import get_namespace\n+\n \n def _unique_multiclass(y):\n     xp, is_array_api = get_namespace(y)\n@@ -78,7 +96,8 @@ def unique_labels(*ys):\n         raise ValueError(\"No argument has been passed.\")\n     # Check that we don't mix label format\n \n-    ys_types = set(type_of_target(x) for x in ys)\n+\n+ys_types = set(type_of_target(x) for x in ys)\n     if ys_types == {\"binary\", \"multiclass\"}:\n         ys_types = {\"multiclass\"}\n \n@@ -286,6 +305,8 @@ def type_of_target(y, input_name=\"\"):\n         or is_array_api\n     )\n \n+    if not valid:\n+\n     if not valid:\n         raise ValueError(\n             \"Expected array-like (array or non-string sequence), got %r\" % y\n@@ -298,19 +319,52 @@ def type_of_target(y, input_name=\"\"):\n     if is_multilabel(y):\n         return \"multilabel-indicator\"\n \n+    # Handle pandas extension dtypes before numpy conversion\n+    try:\n+        import pandas as pd\n+        from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n+        if hasattr(y, 'dtype') and is_extension_array_dtype(y.dtype):\n+            # Convert pandas nullable dtypes to their non-nullable equivalents\n+            if is_integer_dtype(y.dtype):\n+                y = y.astype('int64')\n+            elif is_float_dtype(y.dtype):\n+                y = y.astype('float64')\n+            elif is_bool_dtype(y.dtype):\n+                y = y.astype('bool')\n+    except ImportError:\n+        pass\n+\n     # DeprecationWarning will be replaced by ValueError, see NEP 34\n     # https://numpy.org/neps/nep-0034-infer-dtype-is-object.html\n     # We therefore catch both deprecation (NumPy < 1.24) warning and\n     # value error (NumPy >= 1.24).\n     with warnings.catch_warnings():\n         warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n-        if not issparse(y):\n-            try:\n-                y = xp.asarray(y)\n-            except (np.VisibleDeprecationWarning, ValueError):\n-                # dtype=object should be provided explicitly for ragged arrays,\n-                # see NEP 34\n-                y = xp.asarray(y, dtype=object)\n+\n+    # Handle pandas extension dtypes before numpy conversion\n+    if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n+        try:\n+            import pandas as pd\n+            from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n+            \n+            if is_extension_array_dtype(y.dtype):\n+                # Convert pandas nullable dtypes to their non-nullable equivalents\n+                if is_integer_dtype(y.dtype):\n+                    y = y.astype('int64')\n+                elif is_float_dtype(y.dtype):\n+                    y = y.astype('float64')\n+                elif is_bool_dtype(y.dtype):\n+                    y = y.astype('bool')\n+        except ImportError:\n+            pass\n+\n+    if not issparse(y):\n+        try:\n+            y = xp.asarray(y)\n+        except (np.VisibleDeprecationWarning, ValueError):\n+            # dtype=object should be provided explicitly for ragged arrays,\n+            # see NEP 34\n+            y = xp.asarray(y, dtype=object)\n \n     # The old sequence of sequences format\n     try:\n@@ -337,13 +391,16 @@ def type_of_target(y, input_name=\"\"):\n         # Empty ndarray: []/[[]]\n         if y.ndim == 1:\n             # 1-D empty array: []\n-            return \"binary\"  # []\n-        # 2-D empty array: [[]]\n-        return \"unknown\"\n-    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n-        # [obj_1] and not [\"label_1\"]\n-        return \"unknown\"\n \n+    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n+        # Check if this is a pandas extension array that should be handled differently\n+        if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n+            # Skip object dtype classification for pandas extension arrays\n+            # as they should have been converted earlier\n+            pass\n+        else:\n+            # [obj_1] and not [\"label_1\"]\n+            return \"unknown\"\n     # Check if multioutput\n     if y.ndim == 2 and y.shape[1] > 1:\n         suffix = \"-multioutput\"  # [[1, 2], [1, 2]]\n",
    "variant_6": "diff --git a/sklearn/utils/multiclass.py b/sklearn/utils/multiclass.py\nindex 5eaef2fde..7346d26bb 100644\n--- a/sklearn/utils/multiclass.py\n+++ b/sklearn/utils/multiclass.py\n@@ -1,3 +1,4 @@\n+\n # Author: Arnaud Joly, Joel Nothman, Hamzeh Alsalhi\n #\n # License: BSD 3 clause\n@@ -19,6 +20,23 @@ import numpy as np\n from .validation import check_array, _assert_all_finite\n from ..utils._array_api import get_namespace\n \n+try:\n+    import pandas as pd\n+    from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n+    _pandas_available = True\n+except ImportError:\n+    _pandas_available = False\n+import warnings\n+\n+from scipy.sparse import issparse\n+from scipy.sparse import dok_matrix\n+from scipy.sparse import lil_matrix\n+\n+import numpy as np\n+\n+from .validation import check_array, _assert_all_finite\n+from ..utils._array_api import get_namespace\n+\n \n def _unique_multiclass(y):\n     xp, is_array_api = get_namespace(y)\n@@ -78,6 +96,7 @@ def unique_labels(*ys):\n         raise ValueError(\"No argument has been passed.\")\n     # Check that we don't mix label format\n \n+\n     ys_types = set(type_of_target(x) for x in ys)\n     if ys_types == {\"binary\", \"multiclass\"}:\n         ys_types = {\"multiclass\"}\n@@ -286,6 +305,8 @@ def type_of_target(y, input_name=\"\"):\n         or is_array_api\n     )\n \n+    if not valid:\n+\n     if not valid:\n         raise ValueError(\n             \"Expected array-like (array or non-string sequence), got %r\" % y\n@@ -298,19 +319,53 @@ def type_of_target(y, input_name=\"\"):\n     if is_multilabel(y):\n         return \"multilabel-indicator\"\n \n+    # Handle pandas extension dtypes before numpy conversion\n+    try:\n+        import pandas as pd\n+        from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n+        if hasattr(y, 'dtype') and is_extension_array_dtype(y.dtype):\n+            # Convert pandas nullable dtypes to their non-nullable equivalents\n+            if is_integer_dtype(y.dtype):\n+                y = y.astype('int64')\n+            elif is_float_dtype(y.dtype):\n+                y = y.astype('float64')\n+            elif is_bool_dtype(y.dtype):\n+                y = y.astype('bool')\n+    except ImportError:\n+        pass\n+\n     # DeprecationWarning will be replaced by ValueError, see NEP 34\n     # https://numpy.org/neps/nep-0034-infer-dtype-is-object.html\n     # We therefore catch both deprecation (NumPy < 1.24) warning and\n     # value error (NumPy >= 1.24).\n     with warnings.catch_warnings():\n         warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n-        if not issparse(y):\n-            try:\n-                y = xp.asarray(y)\n-            except (np.VisibleDeprecationWarning, ValueError):\n-                # dtype=object should be provided explicitly for ragged arrays,\n-                # see NEP 34\n-                y = xp.asarray(y, dtype=object)\n+\n+    # Handle pandas extension dtypes before numpy conversion\n+    if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n+        try:\n+            import pandas as pd\n+            from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n+            \n+            if is_extension_array_dtype(y.dtype):\n+                # Convert pandas nullable dtypes to their non-nullable equivalents\n+                if is_integer_dtype(y.dtype):\n+                    y = y.astype('int64')\n+                elif is_float_dtype(y.dtype):\n+                    y = y.astype('float64')\n+                elif is_bool_dtype(y.dtype):\n+                    y = y.astype('bool')\n+        except ImportError:\n+            # pandas not available, continue with existing logic\n+            pass\n+\n+    if not issparse(y):\n+        try:\n+            y = xp.asarray(y)\n+        except (np.VisibleDeprecationWarning, ValueError):\n+            # dtype=object should be provided explicitly for ragged arrays,\n+            # see NEP 34\n+            y = xp.asarray(y, dtype=object)\n \n     # The old sequence of sequences format\n     try:\n@@ -337,13 +392,15 @@ def type_of_target(y, input_name=\"\"):\n         # Empty ndarray: []/[[]]\n         if y.ndim == 1:\n             # 1-D empty array: []\n-            return \"binary\"  # []\n-        # 2-D empty array: [[]]\n-        return \"unknown\"\n-    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n-        # [obj_1] and not [\"label_1\"]\n-        return \"unknown\"\n \n+    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n+        # Check if this might be a pandas extension array that wasn't properly converted\n+        if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n+            # Skip classification as unknown for pandas extension arrays\n+            pass\n+        else:\n+            # [obj_1] and not [\"label_1\"]\n+            return \"unknown\"\n     # Check if multioutput\n     if y.ndim == 2 and y.shape[1] > 1:\n         suffix = \"-multioutput\"  # [[1, 2], [1, 2]]\n",
    "variant_7": "diff --git a/sklearn/utils/multiclass.py b/sklearn/utils/multiclass.py\nindex 5eaef2fde..fc6ebd965 100644\n--- a/sklearn/utils/multiclass.py\n+++ b/sklearn/utils/multiclass.py\n@@ -1,3 +1,4 @@\n+\n # Author: Arnaud Joly, Joel Nothman, Hamzeh Alsalhi\n #\n # License: BSD 3 clause\n@@ -19,6 +20,23 @@ import numpy as np\n from .validation import check_array, _assert_all_finite\n from ..utils._array_api import get_namespace\n \n+try:\n+    import pandas as pd\n+    from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n+    _pandas_available = True\n+except ImportError:\n+    _pandas_available = False\n+import warnings\n+\n+from scipy.sparse import issparse\n+from scipy.sparse import dok_matrix\n+from scipy.sparse import lil_matrix\n+\n+import numpy as np\n+\n+from .validation import check_array, _assert_all_finite\n+from ..utils._array_api import get_namespace\n+\n \n def _unique_multiclass(y):\n     xp, is_array_api = get_namespace(y)\n@@ -78,7 +96,8 @@ def unique_labels(*ys):\n         raise ValueError(\"No argument has been passed.\")\n     # Check that we don't mix label format\n \n-    ys_types = set(type_of_target(x) for x in ys)\n+\n+ys_types = set(type_of_target(x) for x in ys)\n     if ys_types == {\"binary\", \"multiclass\"}:\n         ys_types = {\"multiclass\"}\n \n@@ -286,6 +305,8 @@ def type_of_target(y, input_name=\"\"):\n         or is_array_api\n     )\n \n+    if not valid:\n+\n     if not valid:\n         raise ValueError(\n             \"Expected array-like (array or non-string sequence), got %r\" % y\n@@ -298,19 +319,49 @@ def type_of_target(y, input_name=\"\"):\n     if is_multilabel(y):\n         return \"multilabel-indicator\"\n \n+    # Handle pandas extension dtypes before numpy conversion\n+    try:\n+        import pandas as pd\n+        from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n+        \n+        if hasattr(y, 'dtype') and is_extension_array_dtype(y.dtype):\n+            # Convert pandas nullable dtypes to their non-nullable equivalents\n+            if is_integer_dtype(y.dtype):\n+                y = y.astype('int64')\n+            elif is_float_dtype(y.dtype):\n+                y = y.astype('float64')\n+            elif is_bool_dtype(y.dtype):\n+                y = y.astype('bool')\n+    except ImportError:\n+        pass\n+\n     # DeprecationWarning will be replaced by ValueError, see NEP 34\n     # https://numpy.org/neps/nep-0034-infer-dtype-is-object.html\n     # We therefore catch both deprecation (NumPy < 1.24) warning and\n     # value error (NumPy >= 1.24).\n     with warnings.catch_warnings():\n         warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n-        if not issparse(y):\n-            try:\n-                y = xp.asarray(y)\n-            except (np.VisibleDeprecationWarning, ValueError):\n-                # dtype=object should be provided explicitly for ragged arrays,\n-                # see NEP 34\n-                y = xp.asarray(y, dtype=object)\n+\n+    # Handle pandas extension dtypes before numpy conversion\n+    if _pandas_available and hasattr(y, 'dtype') and is_extension_array_dtype(y.dtype):\n+        # Handle pandas nullable dtypes by preserving their semantic meaning\n+        if is_integer_dtype(y.dtype):\n+            # Convert nullable Int64 to regular int64 for consistent classification\n+            y = y.astype('int64')\n+        elif is_float_dtype(y.dtype):\n+            # Convert nullable Float64 to regular float64 for consistent classification  \n+            y = y.astype('float64')\n+        elif is_bool_dtype(y.dtype):\n+            # Convert nullable boolean to regular bool for consistent classification\n+            y = y.astype('bool')\n+\n+    if not issparse(y):\n+        try:\n+            y = xp.asarray(y)\n+        except (np.VisibleDeprecationWarning, ValueError):\n+            # dtype=object should be provided explicitly for ragged arrays,\n+            # see NEP 34\n+            y = xp.asarray(y, dtype=object)\n \n     # The old sequence of sequences format\n     try:\n@@ -337,13 +388,10 @@ def type_of_target(y, input_name=\"\"):\n         # Empty ndarray: []/[[]]\n         if y.ndim == 1:\n             # 1-D empty array: []\n-            return \"binary\"  # []\n-        # 2-D empty array: [[]]\n-        return \"unknown\"\n+\n     if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n         # [obj_1] and not [\"label_1\"]\n         return \"unknown\"\n-\n     # Check if multioutput\n     if y.ndim == 2 and y.shape[1] > 1:\n         suffix = \"-multioutput\"  # [[1, 2], [1, 2]]\n",
    "variant_8": "diff --git a/sklearn/utils/multiclass.py b/sklearn/utils/multiclass.py\nindex 5eaef2fde..8ddb757e8 100644\n--- a/sklearn/utils/multiclass.py\n+++ b/sklearn/utils/multiclass.py\n@@ -1,3 +1,4 @@\n+\n # Author: Arnaud Joly, Joel Nothman, Hamzeh Alsalhi\n #\n # License: BSD 3 clause\n@@ -19,6 +20,23 @@ import numpy as np\n from .validation import check_array, _assert_all_finite\n from ..utils._array_api import get_namespace\n \n+try:\n+    import pandas as pd\n+    from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n+    _pandas_available = True\n+except ImportError:\n+    _pandas_available = False\n+import warnings\n+\n+from scipy.sparse import issparse\n+from scipy.sparse import dok_matrix\n+from scipy.sparse import lil_matrix\n+\n+import numpy as np\n+\n+from .validation import check_array, _assert_all_finite\n+from ..utils._array_api import get_namespace\n+\n \n def _unique_multiclass(y):\n     xp, is_array_api = get_namespace(y)\n@@ -78,7 +96,8 @@ def unique_labels(*ys):\n         raise ValueError(\"No argument has been passed.\")\n     # Check that we don't mix label format\n \n-    ys_types = set(type_of_target(x) for x in ys)\n+\n+ys_types = set(type_of_target(x) for x in ys)\n     if ys_types == {\"binary\", \"multiclass\"}:\n         ys_types = {\"multiclass\"}\n \n@@ -287,9 +306,23 @@ def type_of_target(y, input_name=\"\"):\n     )\n \n     if not valid:\n-        raise ValueError(\n-            \"Expected array-like (array or non-string sequence), got %r\" % y\n-        )\n+\n+    # Handle pandas extension dtypes before numpy conversion\n+    if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n+        try:\n+            import pandas as pd\n+            from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n+            \n+            if is_extension_array_dtype(y.dtype):\n+                # Convert pandas nullable dtypes to their non-nullable equivalents\n+                if is_integer_dtype(y.dtype):\n+                    y = y.astype('int64')\n+                elif is_float_dtype(y.dtype):\n+                    y = y.astype('float64')\n+                elif is_bool_dtype(y.dtype):\n+                    y = y.astype('bool')\n+        except ImportError:\n+            pass\n \n     sparse_pandas = y.__class__.__name__ in [\"SparseSeries\", \"SparseArray\"]\n     if sparse_pandas:\n@@ -304,13 +337,31 @@ def type_of_target(y, input_name=\"\"):\n     # value error (NumPy >= 1.24).\n     with warnings.catch_warnings():\n         warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n-        if not issparse(y):\n-            try:\n-                y = xp.asarray(y)\n-            except (np.VisibleDeprecationWarning, ValueError):\n-                # dtype=object should be provided explicitly for ragged arrays,\n-                # see NEP 34\n-                y = xp.asarray(y, dtype=object)\n+\n+    # Handle pandas extension dtypes before numpy conversion\n+    if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n+        try:\n+            import pandas as pd\n+            from pandas.api.types import is_extension_array_dtype, is_integer_dtype, is_float_dtype, is_bool_dtype\n+            \n+            if is_extension_array_dtype(y.dtype):\n+                # Convert pandas nullable dtypes to their non-nullable equivalents\n+                if is_integer_dtype(y.dtype):\n+                    y = y.astype('int64')\n+                elif is_float_dtype(y.dtype):\n+                    y = y.astype('float64')\n+                elif is_bool_dtype(y.dtype):\n+                    y = y.astype('bool')\n+        except ImportError:\n+            pass\n+\n+    if not issparse(y):\n+        try:\n+            y = xp.asarray(y)\n+        except (np.VisibleDeprecationWarning, ValueError):\n+            # dtype=object should be provided explicitly for ragged arrays,\n+            # see NEP 34\n+            y = xp.asarray(y, dtype=object)\n \n     # The old sequence of sequences format\n     try:\n@@ -337,13 +388,15 @@ def type_of_target(y, input_name=\"\"):\n         # Empty ndarray: []/[[]]\n         if y.ndim == 1:\n             # 1-D empty array: []\n-            return \"binary\"  # []\n-        # 2-D empty array: [[]]\n-        return \"unknown\"\n-    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n-        # [obj_1] and not [\"label_1\"]\n-        return \"unknown\"\n \n+    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n+        # Check if this is a pandas extension array that should be handled differently\n+        if _pandas_available and hasattr(y, 'dtype') and is_extension_array_dtype(y.dtype):\n+            # This is a pandas extension array, don't classify as unknown\n+            pass\n+        else:\n+            # [obj_1] and not [\"label_1\"]\n+            return \"unknown\"\n     # Check if multioutput\n     if y.ndim == 2 and y.shape[1] > 1:\n         suffix = \"-multioutput\"  # [[1, 2], [1, 2]]\n"
  }
}