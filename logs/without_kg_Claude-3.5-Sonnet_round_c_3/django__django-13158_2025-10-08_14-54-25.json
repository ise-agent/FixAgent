{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/django/django/db/models/query.py lines 919-923)": "\n    def none(self):\n        \"\"\"Return an empty QuerySet.\"\"\"\n        # If this is a combined query (union/intersection/difference), \n        # we need to return a fresh empty queryset instead of trying\n        # to add NothingNode to the combined query structure\n        if self.query.combined_queries:\n            clone = self._clone()\n            clone.query = clone.query.clone()\n            clone.query.combined_queries = ()\n            clone.query.combinator = None\n            clone.query.combinator_all = False\n            clone.query.set_empty()\n            return clone\n        \n        clone = self._chain()\n        clone.query.set_empty()\n        return clone\n",
    "Location 2 (/root/hy/projects_3/django/django/db/models/query.py lines 999-1004)": "\n    def none(self):\n        \"\"\"Return an empty QuerySet.\"\"\"\n        # If this is a combined query (union, intersection, difference),\n        # we need to return a truly empty queryset instead of trying to\n        # add NothingNode to the combined query structure\n        if self.query.combined_queries:\n            return self._chain().filter(pk__in=[])\n        \n        clone = self._chain()\n        clone.query.set_empty()\n        return clone\n",
    "Location 3 (/root/hy/projects_3/django/django/db/models/query.py lines 988-997)": "\n    def none(self):\n        \"\"\"Return an empty QuerySet.\"\"\"\n        # For combined queries (union, intersection, difference), we need to\n        # return a truly empty queryset rather than trying to add NothingNode\n        # to the combined query structure, which doesn't work correctly.\n        if self.query.combined_queries:\n            # Create a fresh empty queryset of the same model\n            return self.model._default_manager.none()\n        \n        clone = self._chain()\n        clone.query.set_empty()\n        return clone\n",
    "Location 4 (/root/hy/projects_3/django/django/db/models/sql/query.py lines 1778-1782)": "\ndef none(self):\n    \"\"\"Return an empty QuerySet.\"\"\"\n    if self.query.combined_queries:\n        # For combined queries (union/intersection/difference), we need to\n        # return a fresh empty queryset rather than trying to add NothingNode\n        # to the combined query structure, which doesn't work correctly.\n        clone = self._chain()\n        clone.query = self.query.clone()\n        clone.query.combined_queries = ()\n        clone.query.combinator = None\n        clone.query.combinator_all = False\n        clone.query.set_empty()\n        return clone\n    else:\n        clone = self._chain()\n        clone.query.set_empty()\n        return clone\n",
    "Location 5 (/root/hy/projects_3/django/django/forms/models.py lines 1326-1326)": "\ndef none(self):\n    \"\"\"Return an empty QuerySet.\"\"\"\n    if self.query.combined_queries:\n        # For union/intersection/difference queries, return a fresh empty queryset\n        # instead of trying to modify the combined query structure\n        return self._chain().filter(pk__in=[])\n    clone = self._chain()\n    clone.query.set_empty()\n    return clone\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/django/django/db/models/query.py lines 919-923)": [
      "\ndef none(self):\n    \"\"\"Return an empty QuerySet.\"\"\"\n    # For combined queries (union, intersection, difference), we need to return\n    # a fresh empty queryset instead of trying to add NothingNode to the\n    # combined query structure, which doesn't work correctly.\n    if self.query.combined_queries:\n        # Create a fresh empty queryset with the same model\n        empty_qs = self.__class__(self.model, using=self._db, hints=self._hints)\n        empty_qs.query.set_empty()\n        return empty_qs\n    \n    clone = self._chain()\n    clone.query.set_empty()\n    return clone\n",
      "\ndef none(self):\n    \"\"\"Return an empty QuerySet.\"\"\"\n    # If this is a combined query (union, intersection, difference),\n    # we need to return a fresh empty queryset instead of trying to\n    # add NothingNode to the combined query structure\n    if self.query.combined_queries:\n        clone = self._clone()\n        clone.query = self.query.clone()\n        clone.query.combined_queries = ()\n        clone.query.combinator = None\n        clone.query.combinator_all = False\n        clone.query.set_empty()\n        return clone\n    \n    clone = self._chain()\n    clone.query.set_empty()\n    return clone\n",
      "\n    def none(self):\n        \"\"\"Return an empty QuerySet.\"\"\"\n        # For combined queries (union, intersection, difference), we need to\n        # return a fresh empty queryset instead of trying to set_empty()\n        # on the combined query structure, which doesn't work correctly\n        if self.query.combined_queries:\n            clone = self._clone()\n            clone.query = self.query.clone()\n            clone.query.clear_ordering(True)\n            clone.query.clear_limits()\n            clone.query.combined_queries = ()\n            clone.query.combinator = None\n            clone.query.combinator_all = False\n            clone.query.set_empty()\n            return clone\n        \n        clone = self._chain()\n        clone.query.set_empty()\n        return clone\n",
      "\ndef none(self):\n    \"\"\"Return an empty QuerySet.\"\"\"\n    # For combined queries (union, intersection, difference), we need to\n    # return a fresh empty queryset instead of trying to set the existing\n    # combined query structure to empty, as that doesn't work correctly.\n    if self.query.combined_queries:\n        clone = self._chain()\n        clone.query = self.query.clone()\n        clone.query.clear_select_clause()\n        clone.query.clear_select_fields()\n        clone.query.combined_queries = ()\n        clone.query.combinator = None\n        clone.query.combinator_all = False\n        clone.query.set_empty()\n        return clone\n    \n    clone = self._chain()\n    clone.query.set_empty()\n    return clone\n",
      "\n    def none(self):\n        \"\"\"Return an empty QuerySet.\"\"\"\n        # For combined queries (union, intersection, difference), we need to\n        # return a fresh empty queryset instead of trying to set the combined\n        # query structure to empty, which doesn't work correctly.\n        if self.query.combined_queries:\n            return self.model._default_manager.none()\n        \n        clone = self._chain()\n        clone.query.set_empty()\n        return clone\n",
      "\n    def none(self):\n        \"\"\"Return an empty QuerySet.\"\"\"\n        # If this is a combined query (union/intersection/difference),\n        # we need to return a fresh empty queryset instead of trying\n        # to add NothingNode to the combined query structure\n        if self.query.combined_queries:\n            return self._clone().filter(pk__in=[])\n        \n        clone = self._chain()\n        clone.query.set_empty()\n        return clone\n",
      "\ndef none(self):\n    \"\"\"Return an empty QuerySet.\"\"\"\n    # For combined queries (union, intersection, difference), we need to\n    # return a fresh empty queryset rather than trying to set_empty()\n    # on the combined query structure, which doesn't work correctly.\n    if self.query.combined_queries:\n        clone = self._clone()\n        clone.query = self.query.clone()\n        clone.query.clear_select_clause()\n        clone.query.clear_ordering(force=True)\n        clone.query.clear_limits()\n        clone.query.combined_queries = ()\n        clone.query.combinator = None\n        clone.query.combinator_all = False\n        clone.query.set_empty()\n        return clone\n    \n    clone = self._chain()\n    clone.query.set_empty()\n    return clone\n",
      "\ndef none(self):\n    \"\"\"Return an empty QuerySet.\"\"\"\n    # If this is a combined query (union/intersection/difference),\n    # we need to return a fresh empty queryset instead of trying\n    # to add NothingNode to the combined query structure\n    if self.query.combined_queries:\n        # Create a new empty queryset of the same model\n        empty_qs = self.__class__(model=self.model, query=self.query.__class__(self.model), using=self._db)\n        empty_qs.query.set_empty()\n        return empty_qs\n    \n    clone = self._chain()\n    clone.query.set_empty()\n    return clone\n"
    ],
    "Location 2 (/root/hy/projects_3/django/django/db/models/query.py lines 999-1004)": [
      "\ndef none(self):\n    \"\"\"Return an empty QuerySet.\"\"\"\n    # If this is a combined query (union/intersection/difference),\n    # we need to return a fresh empty queryset instead of trying\n    # to add NothingNode to the combined query structure\n    if self.query.combined_queries:\n        # Create a new empty queryset with the same model\n        empty_qs = self.model._base_manager.none()\n        # Preserve any prefetch_related calls\n        if hasattr(self, '_prefetch_related_lookups'):\n            empty_qs._prefetch_related_lookups = self._prefetch_related_lookups[:]\n        return empty_qs\n    \n    clone = self._chain()\n    clone.query.set_empty()\n    return clone\n",
      "\ndef none(self):\n    \"\"\"Return an empty QuerySet.\"\"\"\n    # If this is a combined query (union, intersection, difference),\n    # we need to return a fresh empty queryset instead of trying to\n    # add NothingNode to the combined query structure\n    if self.query.combined_queries:\n        return self.model._default_manager.none()\n    \n    clone = self._chain()\n    clone.query.set_empty()\n    return clone\n",
      "\ndef none(self):\n    \"\"\"Return an empty QuerySet.\"\"\"\n    # If this is a combined query (union/intersection/difference), \n    # we need to return a fresh empty queryset rather than trying\n    # to add NothingNode to the combined query structure\n    if self.query.combined_queries:\n        # Create a new empty queryset of the same model\n        return self.model._default_manager.none()\n    \n    clone = self._chain()\n    clone.query.set_empty()\n    return clone\n",
      "\ndef none(self):\n    \"\"\"Return an empty QuerySet.\"\"\"\n    # If this is a combined query (union/intersection/difference), \n    # we need to return a fresh empty queryset instead of trying\n    # to add NothingNode to the combined query structure\n    if self.query.combined_queries:\n        return self._chain().filter(pk__in=[])\n    \n    clone = self._chain()\n    clone.query.set_empty()\n    return clone\n",
      "\ndef none(self):\n    \"\"\"Return an empty QuerySet.\"\"\"\n    # If this is a combined query (union, intersection, difference),\n    # we need to return a fresh empty queryset instead of trying to\n    # add NothingNode to the combined query structure\n    if self.query.combined_queries:\n        return self._chain().filter(pk__in=[])\n    \n    clone = self._chain()\n    clone.query.set_empty()\n    return clone\n",
      "\ndef none(self):\n    \"\"\"Return an empty QuerySet.\"\"\"\n    # If this is a combined query (union/intersection/difference),\n    # we need to return a fresh empty queryset instead of trying\n    # to add NothingNode to the combined query structure\n    if self.query.combined_queries:\n        # Create a fresh empty queryset from the model\n        empty_qs = self.model._default_manager.none()\n        # Preserve any select_related/prefetch_related from the original\n        if self.query.select_related:\n            empty_qs = empty_qs.select_related(*self.query.select_related.keys())\n        if self._prefetch_related_lookups:\n            empty_qs = empty_qs.prefetch_related(*self._prefetch_related_lookups)\n        return empty_qs\n    \n    clone = self._chain()\n    clone.query.set_empty()\n    return clone\n",
      "\ndef none(self):\n    \"\"\"Return an empty QuerySet.\"\"\"\n    # If this is a combined query (union/intersection/difference), \n    # we need to return a fresh empty queryset rather than trying\n    # to add NothingNode to the combined query structure\n    if self.query.combined_queries:\n        # Create a new empty queryset from the same model\n        return self.model._default_manager.none()\n    \n    clone = self._chain()\n    clone.query.set_empty()\n    return clone\n",
      "\n    def none(self):\n        \"\"\"Return an empty QuerySet.\"\"\"\n        if self.query.combined_queries:\n            # For combined queries (union, intersection, difference),\n            # we need to return a fresh empty queryset rather than\n            # trying to add NothingNode to the combined query structure\n            return self._clone().filter(pk__in=[])\n        clone = self._clone()\n        clone.query.set_empty()\n        return clone\n"
    ],
    "Location 3 (/root/hy/projects_3/django/django/db/models/query.py lines 988-997)": [
      "\n    def none(self):\n        \"\"\"Return an empty QuerySet.\"\"\"\n        # If this is a combined query (union, intersection, difference),\n        # we need to return a fresh empty queryset rather than trying to\n        # add NothingNode to the combined query structure\n        if self.query.combined_queries:\n            return self._chain().filter(pk__in=[])\n        \n        clone = self._chain()\n        clone.query.set_empty()\n        return clone\n",
      "\ndef none(self):\n    \"\"\"Return an empty QuerySet.\"\"\"\n    # If this is a combined query (union, intersection, difference),\n    # we need to return a fresh empty queryset rather than trying\n    # to add NothingNode to the combined query structure\n    if self.query.combined_queries:\n        # Create a fresh empty queryset from the model\n        empty_qs = self.model._default_manager.get_queryset()\n        clone = empty_qs._chain()\n        clone.query.set_empty()\n        return clone\n    else:\n        clone = self._chain()\n        clone.query.set_empty()\n        return clone\n",
      "\n    def none(self):\n        \"\"\"Return an empty QuerySet.\"\"\"\n        if self.query.combined_queries:\n            # For combined queries (union/intersection/difference), we need to return\n            # a fresh empty queryset rather than trying to add NothingNode to the\n            # combined query structure, which doesn't work correctly\n            return self._chain().filter(pk__in=[])\n        clone = self._chain()\n        clone.query.set_empty()\n        return clone\n",
      "\n    def none(self):\n        \"\"\"Return an empty QuerySet.\"\"\"\n        if self.query.combined_queries:\n            # For combined queries (union/intersection/difference), we need to\n            # return a fresh empty queryset rather than trying to add NothingNode\n            # to the combined query structure, which doesn't work properly\n            return self.model._default_manager.none()\n        clone = self._chain()\n        clone.query.set_empty()\n        return clone\n",
      "\n    def none(self):\n        \"\"\"Return an empty QuerySet.\"\"\"\n        if self.query.combined_queries:\n            # For union/intersection/difference queries, return a fresh empty queryset\n            # instead of trying to add NothingNode to the combined query structure\n            return self._chain().filter(pk__in=[])\n        clone = self._chain()\n        clone.query.set_empty()\n        return clone\n",
      "\n    def none(self):\n        \"\"\"Return an empty QuerySet.\"\"\"\n        if self.query.combined_queries:\n            # For union/intersection/difference queries, return a fresh empty queryset\n            # instead of trying to add NothingNode to the combined query structure\n            return self._chain().filter(pk__in=[])\n        clone = self._chain()\n        clone.query.set_empty()\n        return clone\n",
      "\n    def none(self):\n        \"\"\"Return an empty QuerySet.\"\"\"\n        if self.query.combined_queries:\n            # For combined queries (union/intersection/difference), we need to\n            # return a fresh empty queryset rather than trying to add NothingNode\n            # to the combined query structure, which doesn't work correctly\n            return self._chain().filter(pk__in=[])\n        clone = self._chain()\n        clone.query.set_empty()\n        return clone\n",
      "\n    def none(self):\n        \"\"\"Return an empty QuerySet.\"\"\"\n        if self.query.combined_queries:\n            # For union/intersection/difference queries, return a fresh empty queryset\n            # instead of trying to add NothingNode to the combined query structure\n            clone = self._chain()\n            clone.query = self.model._meta.default_manager.none().query\n            return clone\n        else:\n            clone = self._chain()\n            clone.query.set_empty()\n            return clone\n"
    ],
    "Location 4 (/root/hy/projects_3/django/django/db/models/sql/query.py lines 1778-1782)": [
      "\ndef none(self):\n    \"\"\"Return an empty QuerySet.\"\"\"\n    # For combined queries (union, intersection, difference), we need to\n    # return a fresh empty queryset rather than adding NothingNode to\n    # the combined query structure, which doesn't work properly.\n    if self.query.combined_queries:\n        clone = self._chain()\n        clone.query = self.query.clone()\n        clone.query.combined_queries = ()\n        clone.query.combinator = None\n        clone.query.combinator_all = False\n        clone.query.set_empty()\n        return clone\n    \n    clone = self._chain()\n    clone.query.set_empty()\n    return clone\n",
      "\ndef none(self):\n    \"\"\"Return an empty QuerySet.\"\"\"\n    # If this is a combined query (union/intersection/difference),\n    # we need to return a fresh empty queryset instead of adding\n    # NothingNode to the combined structure, which doesn't work correctly.\n    if self.query.combined_queries:\n        clone = self._chain()\n        clone.query = self.query.__class__(self.model)\n        clone.query.set_empty()\n        return clone\n    else:\n        clone = self._clone()\n        clone.query.set_empty()\n        return clone\n",
      "\ndef none(self):\n    \"\"\"Return an empty QuerySet.\"\"\"\n    if self.query.combined_queries:\n        # For union/intersection/difference queries, create a fresh empty queryset\n        # instead of trying to add NothingNode to the combined query structure\n        clone = self._chain()\n        clone.query = self.query.__class__(self.model)\n        clone.query.set_empty()\n        return clone\n    else:\n        clone = self._chain()\n        clone.query.set_empty()\n        return clone\n",
      "\ndef none(self):\n    \"\"\"Return an empty QuerySet.\"\"\"\n    if self.query.combined_queries:\n        # For union/intersection/difference queries, return a fresh empty queryset\n        # instead of trying to add NothingNode to the combined query structure\n        clone = self._chain()\n        clone.query = self.query.__class__(self.model)\n        clone.query.set_empty()\n        return clone\n    else:\n        clone = self._chain()\n        clone.query.set_empty()\n        return clone\n",
      "\ndef none(self):\n    \"\"\"Return an empty QuerySet.\"\"\"\n    # If this is a combined query (union/intersection/difference),\n    # we need to return a fresh empty queryset instead of trying\n    # to add NothingNode to the combined query structure\n    if self.query.combined_queries:\n        clone = self._chain()\n        clone.query = self.query.clone()\n        clone.query.combined_queries = ()\n        clone.query.combinator = None\n        clone.query.combinator_all = False\n        clone.query.set_empty()\n        return clone\n    \n    clone = self._clone()\n    clone.query.set_empty()\n    return clone\n",
      "\ndef none(self):\n    \"\"\"Return an empty QuerySet.\"\"\"\n    # If this is a combined query (union, intersection, difference),\n    # we need to return a fresh empty queryset instead of trying to\n    # add NothingNode to the combined query structure\n    if self.query.combined_queries:\n        clone = self._chain()\n        clone.query = self.query.__class__(self.model)\n        clone.query.set_empty()\n        return clone\n    \n    clone = self._chain()\n    clone.query.set_empty()\n    return clone\n",
      "\ndef none(self):\n    \"\"\"Return an empty QuerySet.\"\"\"\n    if self.query.combined_queries:\n        # For combined queries (union/intersection/difference), we need to\n        # return a fresh empty queryset rather than trying to add NothingNode\n        # to the combined query structure, which doesn't work correctly.\n        return self._chain().filter(pk__in=[])\n    else:\n        clone = self._chain()\n        clone.query.set_empty()\n        return clone\n",
      "\ndef none(self):\n    \"\"\"Return an empty QuerySet.\"\"\"\n    if self.query.combined_queries:\n        # For union/intersection/difference queries, return a fresh empty queryset\n        # instead of trying to add NothingNode to the combined query structure\n        clone = self._chain()\n        clone.query = self.query.__class__(self.model)\n        clone.query.set_empty()\n        return clone\n    else:\n        clone = self._chain()\n        clone.query.set_empty()\n        return clone\n"
    ],
    "Location 5 (/root/hy/projects_3/django/django/forms/models.py lines 1326-1326)": [
      "\ndef none(self):\n    \"\"\"Return an empty QuerySet.\"\"\"\n    if self.query.combined_queries:\n        # For combined queries (union/intersection/difference), we need to\n        # return a fresh empty queryset rather than trying to add NothingNode\n        # to the combined query structure, which doesn't work properly.\n        return self._chain().filter(pk__in=[])\n    else:\n        clone = self._chain()\n        clone.query.set_empty()\n        return clone\n",
      "\ndef none(self):\n    \"\"\"Return an empty QuerySet.\"\"\"\n    if self.query.combined_queries:\n        # For combined queries (union, intersection, difference), \n        # return a fresh empty queryset instead of trying to add\n        # NothingNode to the combined query structure\n        clone = self._chain()\n        clone.query = self.query.__class__(self.model)\n        clone.query.set_empty()\n        return clone\n    else:\n        clone = self._chain()\n        clone.query.set_empty()\n        return clone\n",
      "\ndef none(self):\n    \"\"\"Return an empty QuerySet.\"\"\"\n    # If this is a combined query (union/intersection/difference),\n    # we need to return a truly empty queryset instead of trying\n    # to add NothingNode to the combined query structure\n    if self.query.combined_queries:\n        # Create a fresh empty queryset of the same model\n        empty_qs = self._chain()\n        empty_qs.query = self.query.clone()\n        empty_qs.query.combined_queries = ()\n        empty_qs.query.combinator = None\n        empty_qs.query.combinator_all = False\n        empty_qs.query.set_empty()\n        return empty_qs\n    \n    clone = self._chain()\n    clone.query.set_empty()\n    return clone\n",
      "\ndef none(self):\n    \"\"\"Return an empty QuerySet.\"\"\"\n    if self.query.combined_queries:\n        # For combined queries (union, intersection, difference),\n        # create a fresh empty queryset instead of trying to add\n        # NothingNode to the combined query structure\n        return self._chain(_result_cache=[])\n    clone = self._chain()\n    clone.query.set_empty()\n    return clone\n",
      "\ndef none(self):\n    \"\"\"Return an empty QuerySet.\"\"\"\n    if self.query.combined_queries:\n        # For union/intersection/difference queries, return a fresh empty queryset\n        # instead of trying to add NothingNode to the combined query structure\n        return self._chain().filter(pk__in=[])\n    clone = self._chain()\n    clone.query.set_empty()\n    return clone\n",
      "\ndef none(self):\n    \"\"\"Return an empty QuerySet.\"\"\"\n    if self.query.combined_queries:\n        # For combined queries (union/intersection/difference), we need to\n        # return a fresh empty queryset instead of trying to add NothingNode\n        # to the combined query structure, which doesn't work correctly.\n        return self._chain().filter(pk__in=[])\n    else:\n        clone = self._chain()\n        clone.query.set_empty()\n        return clone\n",
      "\ndef none(self):\n    \"\"\"Return an empty QuerySet.\"\"\"\n    # If this is a combined query (union/intersection/difference),\n    # we need to return a fresh empty queryset instead of trying\n    # to add NothingNode to the combined query structure\n    if self.query.combined_queries:\n        return self._chain().filter(pk__in=[])\n    \n    clone = self._chain()\n    clone.query.set_empty()\n    return clone\n",
      "\ndef none(self):\n    \"\"\"Return an empty QuerySet.\"\"\"\n    if self.query.combined_queries:\n        # For union/intersection/difference queries, create a fresh empty queryset\n        # instead of trying to add NothingNode to the combined query structure\n        clone = self._chain()\n        clone.query = self.query.__class__(self.model)\n        clone.query.set_empty()\n        return clone\n    else:\n        clone = self._chain()\n        clone.query.set_empty()\n        return clone\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 07d6ffd4ca..971ad50672 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -916,8 +916,15 @@ class QuerySet:\n             'datetimefield', flat=True\n         ).distinct().filter(plain_field__isnull=False).order_by(('-' if order == 'DESC' else '') + 'datetimefield')\n \n+\n     def none(self):\n         \"\"\"Return an empty QuerySet.\"\"\"\n+        # For combined queries (union, intersection, difference), we need to\n+        # return a fresh empty queryset instead of adding NothingNode to the\n+        # existing combined query structure, as that doesn't work properly.\n+        if getattr(self.query, 'combined_queries', None):\n+            # Create a fresh empty queryset from the model\n+            return self.model._default_manager.none()\n         clone = self._chain()\n         clone.query.set_empty()\n         return clone\n@@ -985,6 +992,7 @@ class QuerySet:\n         else:\n             return self._filter_or_exclude(False, **filter_obj)\n \n+\n     def _combinator_query(self, combinator, *other_qs, all=False):\n         # Clone the query to inherit the select list and everything\n         clone = self._chain()\n@@ -996,6 +1004,7 @@ class QuerySet:\n         clone.query.combinator_all = all\n         return clone\n \n+\n     def union(self, *other_qs, all=False):\n         # If the query is an EmptyQuerySet, combine all nonempty querysets.\n         if isinstance(self, EmptyQuerySet):\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex c913267476..798be59626 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1775,6 +1775,7 @@ class Query(BaseExpression):\n             # outercol IS NULL we will not match the row.\n         return condition, needed_inner\n \n+\n     def set_empty(self):\n         self.where.add(NothingNode(), AND)\n \ndiff --git a/django/forms/models.py b/django/forms/models.py\nindex ab611afca7..f1d1bc8ae8 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1323,6 +1323,7 @@ class ModelMultipleChoiceField(ModelChoiceField):\n         if self.required and not value:\n             raise ValidationError(self.error_messages['required'], code='required')\n         elif not self.required and not value:\n+\n             return self.queryset.none()\n         if not isinstance(value, (list, tuple)):\n             raise ValidationError(\n",
    "variant_0": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 07d6ffd4ca..21ccdceadf 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -916,8 +916,21 @@ class QuerySet:\n             'datetimefield', flat=True\n         ).distinct().filter(plain_field__isnull=False).order_by(('-' if order == 'DESC' else '') + 'datetimefield')\n \n+\n     def none(self):\n         \"\"\"Return an empty QuerySet.\"\"\"\n+        # If this is a combined query (union/intersection/difference), \n+        # we need to return a fresh empty queryset instead of trying\n+        # to add NothingNode to the combined query structure\n+        if self.query.combined_queries:\n+            clone = self._clone()\n+            clone.query = clone.query.clone()\n+            clone.query.combined_queries = ()\n+            clone.query.combinator = None\n+            clone.query.combinator_all = False\n+            clone.query.set_empty()\n+            return clone\n+        \n         clone = self._chain()\n         clone.query.set_empty()\n         return clone\n@@ -985,23 +998,32 @@ class QuerySet:\n         else:\n             return self._filter_or_exclude(False, **filter_obj)\n \n-    def _combinator_query(self, combinator, *other_qs, all=False):\n-        # Clone the query to inherit the select list and everything\n+\n+    def none(self):\n+        \"\"\"Return an empty QuerySet.\"\"\"\n+        # For combined queries (union, intersection, difference), we need to\n+        # return a truly empty queryset rather than trying to add NothingNode\n+        # to the combined query structure, which doesn't work correctly.\n+        if self.query.combined_queries:\n+            # Create a fresh empty queryset of the same model\n+            return self.model._default_manager.none()\n+        \n         clone = self._chain()\n-        # Clear limits and ordering so they can be reapplied\n-        clone.query.clear_ordering(True)\n-        clone.query.clear_limits()\n-        clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n-        clone.query.combinator = combinator\n-        clone.query.combinator_all = all\n+        clone.query.set_empty()\n         return clone\n \n-    def union(self, *other_qs, all=False):\n-        # If the query is an EmptyQuerySet, combine all nonempty querysets.\n-        if isinstance(self, EmptyQuerySet):\n-            qs = [q for q in other_qs if not isinstance(q, EmptyQuerySet)]\n-            return qs[0]._combinator_query('union', *qs[1:], all=all) if qs else self\n-        return self._combinator_query('union', *other_qs, all=all)\n+\n+    def none(self):\n+        \"\"\"Return an empty QuerySet.\"\"\"\n+        # If this is a combined query (union, intersection, difference),\n+        # we need to return a truly empty queryset instead of trying to\n+        # add NothingNode to the combined query structure\n+        if self.query.combined_queries:\n+            return self._chain().filter(pk__in=[])\n+        \n+        clone = self._chain()\n+        clone.query.set_empty()\n+        return clone\n \n     def intersection(self, *other_qs):\n         # If any query is an EmptyQuerySet, return it.\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex c913267476..0b734420bf 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1775,11 +1775,24 @@ class Query(BaseExpression):\n             # outercol IS NULL we will not match the row.\n         return condition, needed_inner\n \n-    def set_empty(self):\n-        self.where.add(NothingNode(), AND)\n \n-    def is_empty(self):\n-        return any(isinstance(c, NothingNode) for c in self.where.children)\n+def none(self):\n+    \"\"\"Return an empty QuerySet.\"\"\"\n+    if self.query.combined_queries:\n+        # For combined queries (union/intersection/difference), we need to\n+        # return a fresh empty queryset rather than trying to add NothingNode\n+        # to the combined query structure, which doesn't work correctly.\n+        clone = self._chain()\n+        clone.query = self.query.clone()\n+        clone.query.combined_queries = ()\n+        clone.query.combinator = None\n+        clone.query.combinator_all = False\n+        clone.query.set_empty()\n+        return clone\n+    else:\n+        clone = self._chain()\n+        clone.query.set_empty()\n+        return clone\n \n     def set_limits(self, low=None, high=None):\n         \"\"\"\ndiff --git a/django/forms/models.py b/django/forms/models.py\nindex ab611afca7..82e3c926cb 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1323,7 +1323,16 @@ class ModelMultipleChoiceField(ModelChoiceField):\n         if self.required and not value:\n             raise ValidationError(self.error_messages['required'], code='required')\n         elif not self.required and not value:\n-            return self.queryset.none()\n+\n+def none(self):\n+    \"\"\"Return an empty QuerySet.\"\"\"\n+    if self.query.combined_queries:\n+        # For union/intersection/difference queries, return a fresh empty queryset\n+        # instead of trying to modify the combined query structure\n+        return self._chain().filter(pk__in=[])\n+    clone = self._chain()\n+    clone.query.set_empty()\n+    return clone\n         if not isinstance(value, (list, tuple)):\n             raise ValidationError(\n                 self.error_messages['invalid_list'],\n",
    "variant_1": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 07d6ffd4ca..f2c1f8ff59 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -916,11 +916,21 @@ class QuerySet:\n             'datetimefield', flat=True\n         ).distinct().filter(plain_field__isnull=False).order_by(('-' if order == 'DESC' else '') + 'datetimefield')\n \n-    def none(self):\n-        \"\"\"Return an empty QuerySet.\"\"\"\n-        clone = self._chain()\n-        clone.query.set_empty()\n-        return clone\n+\n+def none(self):\n+    \"\"\"Return an empty QuerySet.\"\"\"\n+    # For combined queries (union, intersection, difference), we need to return\n+    # a fresh empty queryset instead of trying to add NothingNode to the\n+    # combined query structure, which doesn't work correctly.\n+    if self.query.combined_queries:\n+        # Create a fresh empty queryset with the same model\n+        empty_qs = self.__class__(self.model, using=self._db, hints=self._hints)\n+        empty_qs.query.set_empty()\n+        return empty_qs\n+    \n+    clone = self._chain()\n+    clone.query.set_empty()\n+    return clone\n \n     ##################################################################\n     # PUBLIC METHODS THAT ALTER ATTRIBUTES AND RETURN A NEW QUERYSET #\n@@ -985,23 +995,36 @@ class QuerySet:\n         else:\n             return self._filter_or_exclude(False, **filter_obj)\n \n-    def _combinator_query(self, combinator, *other_qs, all=False):\n-        # Clone the query to inherit the select list and everything\n+\n+    def none(self):\n+        \"\"\"Return an empty QuerySet.\"\"\"\n+        # If this is a combined query (union, intersection, difference),\n+        # we need to return a fresh empty queryset rather than trying to\n+        # add NothingNode to the combined query structure\n+        if self.query.combined_queries:\n+            return self._chain().filter(pk__in=[])\n+        \n         clone = self._chain()\n-        # Clear limits and ordering so they can be reapplied\n-        clone.query.clear_ordering(True)\n-        clone.query.clear_limits()\n-        clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n-        clone.query.combinator = combinator\n-        clone.query.combinator_all = all\n+        clone.query.set_empty()\n         return clone\n \n-    def union(self, *other_qs, all=False):\n-        # If the query is an EmptyQuerySet, combine all nonempty querysets.\n-        if isinstance(self, EmptyQuerySet):\n-            qs = [q for q in other_qs if not isinstance(q, EmptyQuerySet)]\n-            return qs[0]._combinator_query('union', *qs[1:], all=all) if qs else self\n-        return self._combinator_query('union', *other_qs, all=all)\n+\n+def none(self):\n+    \"\"\"Return an empty QuerySet.\"\"\"\n+    # If this is a combined query (union/intersection/difference),\n+    # we need to return a fresh empty queryset instead of trying\n+    # to add NothingNode to the combined query structure\n+    if self.query.combined_queries:\n+        # Create a new empty queryset with the same model\n+        empty_qs = self.model._base_manager.none()\n+        # Preserve any prefetch_related calls\n+        if hasattr(self, '_prefetch_related_lookups'):\n+            empty_qs._prefetch_related_lookups = self._prefetch_related_lookups[:]\n+        return empty_qs\n+    \n+    clone = self._chain()\n+    clone.query.set_empty()\n+    return clone\n \n     def intersection(self, *other_qs):\n         # If any query is an EmptyQuerySet, return it.\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex c913267476..be99ffe09c 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1775,11 +1775,24 @@ class Query(BaseExpression):\n             # outercol IS NULL we will not match the row.\n         return condition, needed_inner\n \n-    def set_empty(self):\n-        self.where.add(NothingNode(), AND)\n \n-    def is_empty(self):\n-        return any(isinstance(c, NothingNode) for c in self.where.children)\n+def none(self):\n+    \"\"\"Return an empty QuerySet.\"\"\"\n+    # For combined queries (union, intersection, difference), we need to\n+    # return a fresh empty queryset rather than adding NothingNode to\n+    # the combined query structure, which doesn't work properly.\n+    if self.query.combined_queries:\n+        clone = self._chain()\n+        clone.query = self.query.clone()\n+        clone.query.combined_queries = ()\n+        clone.query.combinator = None\n+        clone.query.combinator_all = False\n+        clone.query.set_empty()\n+        return clone\n+    \n+    clone = self._chain()\n+    clone.query.set_empty()\n+    return clone\n \n     def set_limits(self, low=None, high=None):\n         \"\"\"\ndiff --git a/django/forms/models.py b/django/forms/models.py\nindex ab611afca7..983293a7b1 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1323,7 +1323,18 @@ class ModelMultipleChoiceField(ModelChoiceField):\n         if self.required and not value:\n             raise ValidationError(self.error_messages['required'], code='required')\n         elif not self.required and not value:\n-            return self.queryset.none()\n+\n+def none(self):\n+    \"\"\"Return an empty QuerySet.\"\"\"\n+    if self.query.combined_queries:\n+        # For combined queries (union/intersection/difference), we need to\n+        # return a fresh empty queryset rather than trying to add NothingNode\n+        # to the combined query structure, which doesn't work properly.\n+        return self._chain().filter(pk__in=[])\n+    else:\n+        clone = self._chain()\n+        clone.query.set_empty()\n+        return clone\n         if not isinstance(value, (list, tuple)):\n             raise ValidationError(\n                 self.error_messages['invalid_list'],\n",
    "variant_2": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 07d6ffd4ca..5183253807 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -916,11 +916,24 @@ class QuerySet:\n             'datetimefield', flat=True\n         ).distinct().filter(plain_field__isnull=False).order_by(('-' if order == 'DESC' else '') + 'datetimefield')\n \n-    def none(self):\n-        \"\"\"Return an empty QuerySet.\"\"\"\n-        clone = self._chain()\n+\n+def none(self):\n+    \"\"\"Return an empty QuerySet.\"\"\"\n+    # If this is a combined query (union, intersection, difference),\n+    # we need to return a fresh empty queryset instead of trying to\n+    # add NothingNode to the combined query structure\n+    if self.query.combined_queries:\n+        clone = self._clone()\n+        clone.query = self.query.clone()\n+        clone.query.combined_queries = ()\n+        clone.query.combinator = None\n+        clone.query.combinator_all = False\n         clone.query.set_empty()\n         return clone\n+    \n+    clone = self._chain()\n+    clone.query.set_empty()\n+    return clone\n \n     ##################################################################\n     # PUBLIC METHODS THAT ALTER ATTRIBUTES AND RETURN A NEW QUERYSET #\n@@ -985,23 +998,35 @@ class QuerySet:\n         else:\n             return self._filter_or_exclude(False, **filter_obj)\n \n-    def _combinator_query(self, combinator, *other_qs, all=False):\n-        # Clone the query to inherit the select list and everything\n+\n+def none(self):\n+    \"\"\"Return an empty QuerySet.\"\"\"\n+    # If this is a combined query (union, intersection, difference),\n+    # we need to return a fresh empty queryset rather than trying\n+    # to add NothingNode to the combined query structure\n+    if self.query.combined_queries:\n+        # Create a fresh empty queryset from the model\n+        empty_qs = self.model._default_manager.get_queryset()\n+        clone = empty_qs._chain()\n+        clone.query.set_empty()\n+        return clone\n+    else:\n         clone = self._chain()\n-        # Clear limits and ordering so they can be reapplied\n-        clone.query.clear_ordering(True)\n-        clone.query.clear_limits()\n-        clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n-        clone.query.combinator = combinator\n-        clone.query.combinator_all = all\n+        clone.query.set_empty()\n         return clone\n \n-    def union(self, *other_qs, all=False):\n-        # If the query is an EmptyQuerySet, combine all nonempty querysets.\n-        if isinstance(self, EmptyQuerySet):\n-            qs = [q for q in other_qs if not isinstance(q, EmptyQuerySet)]\n-            return qs[0]._combinator_query('union', *qs[1:], all=all) if qs else self\n-        return self._combinator_query('union', *other_qs, all=all)\n+\n+def none(self):\n+    \"\"\"Return an empty QuerySet.\"\"\"\n+    # If this is a combined query (union, intersection, difference),\n+    # we need to return a fresh empty queryset instead of trying to\n+    # add NothingNode to the combined query structure\n+    if self.query.combined_queries:\n+        return self.model._default_manager.none()\n+    \n+    clone = self._chain()\n+    clone.query.set_empty()\n+    return clone\n \n     def intersection(self, *other_qs):\n         # If any query is an EmptyQuerySet, return it.\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex c913267476..69d6a05b40 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1775,11 +1775,21 @@ class Query(BaseExpression):\n             # outercol IS NULL we will not match the row.\n         return condition, needed_inner\n \n-    def set_empty(self):\n-        self.where.add(NothingNode(), AND)\n \n-    def is_empty(self):\n-        return any(isinstance(c, NothingNode) for c in self.where.children)\n+def none(self):\n+    \"\"\"Return an empty QuerySet.\"\"\"\n+    # If this is a combined query (union/intersection/difference),\n+    # we need to return a fresh empty queryset instead of adding\n+    # NothingNode to the combined structure, which doesn't work correctly.\n+    if self.query.combined_queries:\n+        clone = self._chain()\n+        clone.query = self.query.__class__(self.model)\n+        clone.query.set_empty()\n+        return clone\n+    else:\n+        clone = self._clone()\n+        clone.query.set_empty()\n+        return clone\n \n     def set_limits(self, low=None, high=None):\n         \"\"\"\ndiff --git a/django/forms/models.py b/django/forms/models.py\nindex ab611afca7..fd630d10c4 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1323,7 +1323,21 @@ class ModelMultipleChoiceField(ModelChoiceField):\n         if self.required and not value:\n             raise ValidationError(self.error_messages['required'], code='required')\n         elif not self.required and not value:\n-            return self.queryset.none()\n+\n+def none(self):\n+    \"\"\"Return an empty QuerySet.\"\"\"\n+    if self.query.combined_queries:\n+        # For combined queries (union, intersection, difference), \n+        # return a fresh empty queryset instead of trying to add\n+        # NothingNode to the combined query structure\n+        clone = self._chain()\n+        clone.query = self.query.__class__(self.model)\n+        clone.query.set_empty()\n+        return clone\n+    else:\n+        clone = self._chain()\n+        clone.query.set_empty()\n+        return clone\n         if not isinstance(value, (list, tuple)):\n             raise ValidationError(\n                 self.error_messages['invalid_list'],\n",
    "variant_3": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 07d6ffd4ca..c725920921 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -916,8 +916,23 @@ class QuerySet:\n             'datetimefield', flat=True\n         ).distinct().filter(plain_field__isnull=False).order_by(('-' if order == 'DESC' else '') + 'datetimefield')\n \n+\n     def none(self):\n         \"\"\"Return an empty QuerySet.\"\"\"\n+        # For combined queries (union, intersection, difference), we need to\n+        # return a fresh empty queryset instead of trying to set_empty()\n+        # on the combined query structure, which doesn't work correctly\n+        if self.query.combined_queries:\n+            clone = self._clone()\n+            clone.query = self.query.clone()\n+            clone.query.clear_ordering(True)\n+            clone.query.clear_limits()\n+            clone.query.combined_queries = ()\n+            clone.query.combinator = None\n+            clone.query.combinator_all = False\n+            clone.query.set_empty()\n+            return clone\n+        \n         clone = self._chain()\n         clone.query.set_empty()\n         return clone\n@@ -985,23 +1000,31 @@ class QuerySet:\n         else:\n             return self._filter_or_exclude(False, **filter_obj)\n \n-    def _combinator_query(self, combinator, *other_qs, all=False):\n-        # Clone the query to inherit the select list and everything\n+\n+    def none(self):\n+        \"\"\"Return an empty QuerySet.\"\"\"\n+        if self.query.combined_queries:\n+            # For combined queries (union/intersection/difference), we need to return\n+            # a fresh empty queryset rather than trying to add NothingNode to the\n+            # combined query structure, which doesn't work correctly\n+            return self._chain().filter(pk__in=[])\n         clone = self._chain()\n-        # Clear limits and ordering so they can be reapplied\n-        clone.query.clear_ordering(True)\n-        clone.query.clear_limits()\n-        clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n-        clone.query.combinator = combinator\n-        clone.query.combinator_all = all\n+        clone.query.set_empty()\n         return clone\n \n-    def union(self, *other_qs, all=False):\n-        # If the query is an EmptyQuerySet, combine all nonempty querysets.\n-        if isinstance(self, EmptyQuerySet):\n-            qs = [q for q in other_qs if not isinstance(q, EmptyQuerySet)]\n-            return qs[0]._combinator_query('union', *qs[1:], all=all) if qs else self\n-        return self._combinator_query('union', *other_qs, all=all)\n+\n+def none(self):\n+    \"\"\"Return an empty QuerySet.\"\"\"\n+    # If this is a combined query (union/intersection/difference), \n+    # we need to return a fresh empty queryset rather than trying\n+    # to add NothingNode to the combined query structure\n+    if self.query.combined_queries:\n+        # Create a new empty queryset of the same model\n+        return self.model._default_manager.none()\n+    \n+    clone = self._chain()\n+    clone.query.set_empty()\n+    return clone\n \n     def intersection(self, *other_qs):\n         # If any query is an EmptyQuerySet, return it.\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex c913267476..ee0d0ec7ad 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1775,11 +1775,20 @@ class Query(BaseExpression):\n             # outercol IS NULL we will not match the row.\n         return condition, needed_inner\n \n-    def set_empty(self):\n-        self.where.add(NothingNode(), AND)\n \n-    def is_empty(self):\n-        return any(isinstance(c, NothingNode) for c in self.where.children)\n+def none(self):\n+    \"\"\"Return an empty QuerySet.\"\"\"\n+    if self.query.combined_queries:\n+        # For union/intersection/difference queries, create a fresh empty queryset\n+        # instead of trying to add NothingNode to the combined query structure\n+        clone = self._chain()\n+        clone.query = self.query.__class__(self.model)\n+        clone.query.set_empty()\n+        return clone\n+    else:\n+        clone = self._chain()\n+        clone.query.set_empty()\n+        return clone\n \n     def set_limits(self, low=None, high=None):\n         \"\"\"\ndiff --git a/django/forms/models.py b/django/forms/models.py\nindex ab611afca7..dbb51606de 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1323,7 +1323,25 @@ class ModelMultipleChoiceField(ModelChoiceField):\n         if self.required and not value:\n             raise ValidationError(self.error_messages['required'], code='required')\n         elif not self.required and not value:\n-            return self.queryset.none()\n+\n+def none(self):\n+    \"\"\"Return an empty QuerySet.\"\"\"\n+    # If this is a combined query (union/intersection/difference),\n+    # we need to return a truly empty queryset instead of trying\n+    # to add NothingNode to the combined query structure\n+    if self.query.combined_queries:\n+        # Create a fresh empty queryset of the same model\n+        empty_qs = self._chain()\n+        empty_qs.query = self.query.clone()\n+        empty_qs.query.combined_queries = ()\n+        empty_qs.query.combinator = None\n+        empty_qs.query.combinator_all = False\n+        empty_qs.query.set_empty()\n+        return empty_qs\n+    \n+    clone = self._chain()\n+    clone.query.set_empty()\n+    return clone\n         if not isinstance(value, (list, tuple)):\n             raise ValidationError(\n                 self.error_messages['invalid_list'],\n",
    "variant_4": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 07d6ffd4ca..4c419d8ebb 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -916,11 +916,26 @@ class QuerySet:\n             'datetimefield', flat=True\n         ).distinct().filter(plain_field__isnull=False).order_by(('-' if order == 'DESC' else '') + 'datetimefield')\n \n-    def none(self):\n-        \"\"\"Return an empty QuerySet.\"\"\"\n+\n+def none(self):\n+    \"\"\"Return an empty QuerySet.\"\"\"\n+    # For combined queries (union, intersection, difference), we need to\n+    # return a fresh empty queryset instead of trying to set the existing\n+    # combined query structure to empty, as that doesn't work correctly.\n+    if self.query.combined_queries:\n         clone = self._chain()\n+        clone.query = self.query.clone()\n+        clone.query.clear_select_clause()\n+        clone.query.clear_select_fields()\n+        clone.query.combined_queries = ()\n+        clone.query.combinator = None\n+        clone.query.combinator_all = False\n         clone.query.set_empty()\n         return clone\n+    \n+    clone = self._chain()\n+    clone.query.set_empty()\n+    return clone\n \n     ##################################################################\n     # PUBLIC METHODS THAT ALTER ATTRIBUTES AND RETURN A NEW QUERYSET #\n@@ -985,23 +1000,30 @@ class QuerySet:\n         else:\n             return self._filter_or_exclude(False, **filter_obj)\n \n-    def _combinator_query(self, combinator, *other_qs, all=False):\n-        # Clone the query to inherit the select list and everything\n+\n+    def none(self):\n+        \"\"\"Return an empty QuerySet.\"\"\"\n+        if self.query.combined_queries:\n+            # For combined queries (union/intersection/difference), we need to\n+            # return a fresh empty queryset rather than trying to add NothingNode\n+            # to the combined query structure, which doesn't work properly\n+            return self.model._default_manager.none()\n         clone = self._chain()\n-        # Clear limits and ordering so they can be reapplied\n-        clone.query.clear_ordering(True)\n-        clone.query.clear_limits()\n-        clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n-        clone.query.combinator = combinator\n-        clone.query.combinator_all = all\n+        clone.query.set_empty()\n         return clone\n \n-    def union(self, *other_qs, all=False):\n-        # If the query is an EmptyQuerySet, combine all nonempty querysets.\n-        if isinstance(self, EmptyQuerySet):\n-            qs = [q for q in other_qs if not isinstance(q, EmptyQuerySet)]\n-            return qs[0]._combinator_query('union', *qs[1:], all=all) if qs else self\n-        return self._combinator_query('union', *other_qs, all=all)\n+\n+def none(self):\n+    \"\"\"Return an empty QuerySet.\"\"\"\n+    # If this is a combined query (union/intersection/difference), \n+    # we need to return a fresh empty queryset instead of trying\n+    # to add NothingNode to the combined query structure\n+    if self.query.combined_queries:\n+        return self._chain().filter(pk__in=[])\n+    \n+    clone = self._chain()\n+    clone.query.set_empty()\n+    return clone\n \n     def intersection(self, *other_qs):\n         # If any query is an EmptyQuerySet, return it.\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex c913267476..e0f0dcb9a7 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1775,11 +1775,20 @@ class Query(BaseExpression):\n             # outercol IS NULL we will not match the row.\n         return condition, needed_inner\n \n-    def set_empty(self):\n-        self.where.add(NothingNode(), AND)\n \n-    def is_empty(self):\n-        return any(isinstance(c, NothingNode) for c in self.where.children)\n+def none(self):\n+    \"\"\"Return an empty QuerySet.\"\"\"\n+    if self.query.combined_queries:\n+        # For union/intersection/difference queries, return a fresh empty queryset\n+        # instead of trying to add NothingNode to the combined query structure\n+        clone = self._chain()\n+        clone.query = self.query.__class__(self.model)\n+        clone.query.set_empty()\n+        return clone\n+    else:\n+        clone = self._chain()\n+        clone.query.set_empty()\n+        return clone\n \n     def set_limits(self, low=None, high=None):\n         \"\"\"\ndiff --git a/django/forms/models.py b/django/forms/models.py\nindex ab611afca7..9f2205bc50 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1323,7 +1323,17 @@ class ModelMultipleChoiceField(ModelChoiceField):\n         if self.required and not value:\n             raise ValidationError(self.error_messages['required'], code='required')\n         elif not self.required and not value:\n-            return self.queryset.none()\n+\n+def none(self):\n+    \"\"\"Return an empty QuerySet.\"\"\"\n+    if self.query.combined_queries:\n+        # For combined queries (union, intersection, difference),\n+        # create a fresh empty queryset instead of trying to add\n+        # NothingNode to the combined query structure\n+        return self._chain(_result_cache=[])\n+    clone = self._chain()\n+    clone.query.set_empty()\n+    return clone\n         if not isinstance(value, (list, tuple)):\n             raise ValidationError(\n                 self.error_messages['invalid_list'],\n",
    "variant_5": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 07d6ffd4ca..23eaa7be3b 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -916,8 +916,15 @@ class QuerySet:\n             'datetimefield', flat=True\n         ).distinct().filter(plain_field__isnull=False).order_by(('-' if order == 'DESC' else '') + 'datetimefield')\n \n+\n     def none(self):\n         \"\"\"Return an empty QuerySet.\"\"\"\n+        # For combined queries (union, intersection, difference), we need to\n+        # return a fresh empty queryset instead of trying to set the combined\n+        # query structure to empty, which doesn't work correctly.\n+        if self.query.combined_queries:\n+            return self.model._default_manager.none()\n+        \n         clone = self._chain()\n         clone.query.set_empty()\n         return clone\n@@ -985,23 +992,29 @@ class QuerySet:\n         else:\n             return self._filter_or_exclude(False, **filter_obj)\n \n-    def _combinator_query(self, combinator, *other_qs, all=False):\n-        # Clone the query to inherit the select list and everything\n+\n+    def none(self):\n+        \"\"\"Return an empty QuerySet.\"\"\"\n+        if self.query.combined_queries:\n+            # For union/intersection/difference queries, return a fresh empty queryset\n+            # instead of trying to add NothingNode to the combined query structure\n+            return self._chain().filter(pk__in=[])\n         clone = self._chain()\n-        # Clear limits and ordering so they can be reapplied\n-        clone.query.clear_ordering(True)\n-        clone.query.clear_limits()\n-        clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n-        clone.query.combinator = combinator\n-        clone.query.combinator_all = all\n+        clone.query.set_empty()\n         return clone\n \n-    def union(self, *other_qs, all=False):\n-        # If the query is an EmptyQuerySet, combine all nonempty querysets.\n-        if isinstance(self, EmptyQuerySet):\n-            qs = [q for q in other_qs if not isinstance(q, EmptyQuerySet)]\n-            return qs[0]._combinator_query('union', *qs[1:], all=all) if qs else self\n-        return self._combinator_query('union', *other_qs, all=all)\n+\n+def none(self):\n+    \"\"\"Return an empty QuerySet.\"\"\"\n+    # If this is a combined query (union, intersection, difference),\n+    # we need to return a fresh empty queryset instead of trying to\n+    # add NothingNode to the combined query structure\n+    if self.query.combined_queries:\n+        return self._chain().filter(pk__in=[])\n+    \n+    clone = self._chain()\n+    clone.query.set_empty()\n+    return clone\n \n     def intersection(self, *other_qs):\n         # If any query is an EmptyQuerySet, return it.\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex c913267476..b11743cb30 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1775,11 +1775,24 @@ class Query(BaseExpression):\n             # outercol IS NULL we will not match the row.\n         return condition, needed_inner\n \n-    def set_empty(self):\n-        self.where.add(NothingNode(), AND)\n \n-    def is_empty(self):\n-        return any(isinstance(c, NothingNode) for c in self.where.children)\n+def none(self):\n+    \"\"\"Return an empty QuerySet.\"\"\"\n+    # If this is a combined query (union/intersection/difference),\n+    # we need to return a fresh empty queryset instead of trying\n+    # to add NothingNode to the combined query structure\n+    if self.query.combined_queries:\n+        clone = self._chain()\n+        clone.query = self.query.clone()\n+        clone.query.combined_queries = ()\n+        clone.query.combinator = None\n+        clone.query.combinator_all = False\n+        clone.query.set_empty()\n+        return clone\n+    \n+    clone = self._clone()\n+    clone.query.set_empty()\n+    return clone\n \n     def set_limits(self, low=None, high=None):\n         \"\"\"\ndiff --git a/django/forms/models.py b/django/forms/models.py\nindex ab611afca7..7cb17ceab3 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1323,7 +1323,16 @@ class ModelMultipleChoiceField(ModelChoiceField):\n         if self.required and not value:\n             raise ValidationError(self.error_messages['required'], code='required')\n         elif not self.required and not value:\n-            return self.queryset.none()\n+\n+def none(self):\n+    \"\"\"Return an empty QuerySet.\"\"\"\n+    if self.query.combined_queries:\n+        # For union/intersection/difference queries, return a fresh empty queryset\n+        # instead of trying to add NothingNode to the combined query structure\n+        return self._chain().filter(pk__in=[])\n+    clone = self._chain()\n+    clone.query.set_empty()\n+    return clone\n         if not isinstance(value, (list, tuple)):\n             raise ValidationError(\n                 self.error_messages['invalid_list'],\n",
    "variant_6": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 07d6ffd4ca..0403187e3a 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -916,8 +916,15 @@ class QuerySet:\n             'datetimefield', flat=True\n         ).distinct().filter(plain_field__isnull=False).order_by(('-' if order == 'DESC' else '') + 'datetimefield')\n \n+\n     def none(self):\n         \"\"\"Return an empty QuerySet.\"\"\"\n+        # If this is a combined query (union/intersection/difference),\n+        # we need to return a fresh empty queryset instead of trying\n+        # to add NothingNode to the combined query structure\n+        if self.query.combined_queries:\n+            return self._clone().filter(pk__in=[])\n+        \n         clone = self._chain()\n         clone.query.set_empty()\n         return clone\n@@ -985,23 +992,36 @@ class QuerySet:\n         else:\n             return self._filter_or_exclude(False, **filter_obj)\n \n-    def _combinator_query(self, combinator, *other_qs, all=False):\n-        # Clone the query to inherit the select list and everything\n+\n+    def none(self):\n+        \"\"\"Return an empty QuerySet.\"\"\"\n+        if self.query.combined_queries:\n+            # For union/intersection/difference queries, return a fresh empty queryset\n+            # instead of trying to add NothingNode to the combined query structure\n+            return self._chain().filter(pk__in=[])\n         clone = self._chain()\n-        # Clear limits and ordering so they can be reapplied\n-        clone.query.clear_ordering(True)\n-        clone.query.clear_limits()\n-        clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n-        clone.query.combinator = combinator\n-        clone.query.combinator_all = all\n+        clone.query.set_empty()\n         return clone\n \n-    def union(self, *other_qs, all=False):\n-        # If the query is an EmptyQuerySet, combine all nonempty querysets.\n-        if isinstance(self, EmptyQuerySet):\n-            qs = [q for q in other_qs if not isinstance(q, EmptyQuerySet)]\n-            return qs[0]._combinator_query('union', *qs[1:], all=all) if qs else self\n-        return self._combinator_query('union', *other_qs, all=all)\n+\n+def none(self):\n+    \"\"\"Return an empty QuerySet.\"\"\"\n+    # If this is a combined query (union/intersection/difference),\n+    # we need to return a fresh empty queryset instead of trying\n+    # to add NothingNode to the combined query structure\n+    if self.query.combined_queries:\n+        # Create a fresh empty queryset from the model\n+        empty_qs = self.model._default_manager.none()\n+        # Preserve any select_related/prefetch_related from the original\n+        if self.query.select_related:\n+            empty_qs = empty_qs.select_related(*self.query.select_related.keys())\n+        if self._prefetch_related_lookups:\n+            empty_qs = empty_qs.prefetch_related(*self._prefetch_related_lookups)\n+        return empty_qs\n+    \n+    clone = self._chain()\n+    clone.query.set_empty()\n+    return clone\n \n     def intersection(self, *other_qs):\n         # If any query is an EmptyQuerySet, return it.\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex c913267476..c89cf53890 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1775,11 +1775,21 @@ class Query(BaseExpression):\n             # outercol IS NULL we will not match the row.\n         return condition, needed_inner\n \n-    def set_empty(self):\n-        self.where.add(NothingNode(), AND)\n \n-    def is_empty(self):\n-        return any(isinstance(c, NothingNode) for c in self.where.children)\n+def none(self):\n+    \"\"\"Return an empty QuerySet.\"\"\"\n+    # If this is a combined query (union, intersection, difference),\n+    # we need to return a fresh empty queryset instead of trying to\n+    # add NothingNode to the combined query structure\n+    if self.query.combined_queries:\n+        clone = self._chain()\n+        clone.query = self.query.__class__(self.model)\n+        clone.query.set_empty()\n+        return clone\n+    \n+    clone = self._chain()\n+    clone.query.set_empty()\n+    return clone\n \n     def set_limits(self, low=None, high=None):\n         \"\"\"\ndiff --git a/django/forms/models.py b/django/forms/models.py\nindex ab611afca7..1ab12026f2 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1323,7 +1323,18 @@ class ModelMultipleChoiceField(ModelChoiceField):\n         if self.required and not value:\n             raise ValidationError(self.error_messages['required'], code='required')\n         elif not self.required and not value:\n-            return self.queryset.none()\n+\n+def none(self):\n+    \"\"\"Return an empty QuerySet.\"\"\"\n+    if self.query.combined_queries:\n+        # For combined queries (union/intersection/difference), we need to\n+        # return a fresh empty queryset instead of trying to add NothingNode\n+        # to the combined query structure, which doesn't work correctly.\n+        return self._chain().filter(pk__in=[])\n+    else:\n+        clone = self._chain()\n+        clone.query.set_empty()\n+        return clone\n         if not isinstance(value, (list, tuple)):\n             raise ValidationError(\n                 self.error_messages['invalid_list'],\n",
    "variant_7": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 07d6ffd4ca..031418295d 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -916,11 +916,27 @@ class QuerySet:\n             'datetimefield', flat=True\n         ).distinct().filter(plain_field__isnull=False).order_by(('-' if order == 'DESC' else '') + 'datetimefield')\n \n-    def none(self):\n-        \"\"\"Return an empty QuerySet.\"\"\"\n-        clone = self._chain()\n+\n+def none(self):\n+    \"\"\"Return an empty QuerySet.\"\"\"\n+    # For combined queries (union, intersection, difference), we need to\n+    # return a fresh empty queryset rather than trying to set_empty()\n+    # on the combined query structure, which doesn't work correctly.\n+    if self.query.combined_queries:\n+        clone = self._clone()\n+        clone.query = self.query.clone()\n+        clone.query.clear_select_clause()\n+        clone.query.clear_ordering(force=True)\n+        clone.query.clear_limits()\n+        clone.query.combined_queries = ()\n+        clone.query.combinator = None\n+        clone.query.combinator_all = False\n         clone.query.set_empty()\n         return clone\n+    \n+    clone = self._chain()\n+    clone.query.set_empty()\n+    return clone\n \n     ##################################################################\n     # PUBLIC METHODS THAT ALTER ATTRIBUTES AND RETURN A NEW QUERYSET #\n@@ -985,23 +1001,31 @@ class QuerySet:\n         else:\n             return self._filter_or_exclude(False, **filter_obj)\n \n-    def _combinator_query(self, combinator, *other_qs, all=False):\n-        # Clone the query to inherit the select list and everything\n+\n+    def none(self):\n+        \"\"\"Return an empty QuerySet.\"\"\"\n+        if self.query.combined_queries:\n+            # For combined queries (union/intersection/difference), we need to\n+            # return a fresh empty queryset rather than trying to add NothingNode\n+            # to the combined query structure, which doesn't work correctly\n+            return self._chain().filter(pk__in=[])\n         clone = self._chain()\n-        # Clear limits and ordering so they can be reapplied\n-        clone.query.clear_ordering(True)\n-        clone.query.clear_limits()\n-        clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n-        clone.query.combinator = combinator\n-        clone.query.combinator_all = all\n+        clone.query.set_empty()\n         return clone\n \n-    def union(self, *other_qs, all=False):\n-        # If the query is an EmptyQuerySet, combine all nonempty querysets.\n-        if isinstance(self, EmptyQuerySet):\n-            qs = [q for q in other_qs if not isinstance(q, EmptyQuerySet)]\n-            return qs[0]._combinator_query('union', *qs[1:], all=all) if qs else self\n-        return self._combinator_query('union', *other_qs, all=all)\n+\n+def none(self):\n+    \"\"\"Return an empty QuerySet.\"\"\"\n+    # If this is a combined query (union/intersection/difference), \n+    # we need to return a fresh empty queryset rather than trying\n+    # to add NothingNode to the combined query structure\n+    if self.query.combined_queries:\n+        # Create a new empty queryset from the same model\n+        return self.model._default_manager.none()\n+    \n+    clone = self._chain()\n+    clone.query.set_empty()\n+    return clone\n \n     def intersection(self, *other_qs):\n         # If any query is an EmptyQuerySet, return it.\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex c913267476..50eb88d7cf 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1775,11 +1775,18 @@ class Query(BaseExpression):\n             # outercol IS NULL we will not match the row.\n         return condition, needed_inner\n \n-    def set_empty(self):\n-        self.where.add(NothingNode(), AND)\n \n-    def is_empty(self):\n-        return any(isinstance(c, NothingNode) for c in self.where.children)\n+def none(self):\n+    \"\"\"Return an empty QuerySet.\"\"\"\n+    if self.query.combined_queries:\n+        # For combined queries (union/intersection/difference), we need to\n+        # return a fresh empty queryset rather than trying to add NothingNode\n+        # to the combined query structure, which doesn't work correctly.\n+        return self._chain().filter(pk__in=[])\n+    else:\n+        clone = self._chain()\n+        clone.query.set_empty()\n+        return clone\n \n     def set_limits(self, low=None, high=None):\n         \"\"\"\ndiff --git a/django/forms/models.py b/django/forms/models.py\nindex ab611afca7..9056a067f8 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1323,7 +1323,18 @@ class ModelMultipleChoiceField(ModelChoiceField):\n         if self.required and not value:\n             raise ValidationError(self.error_messages['required'], code='required')\n         elif not self.required and not value:\n-            return self.queryset.none()\n+\n+def none(self):\n+    \"\"\"Return an empty QuerySet.\"\"\"\n+    # If this is a combined query (union/intersection/difference),\n+    # we need to return a fresh empty queryset instead of trying\n+    # to add NothingNode to the combined query structure\n+    if self.query.combined_queries:\n+        return self._chain().filter(pk__in=[])\n+    \n+    clone = self._chain()\n+    clone.query.set_empty()\n+    return clone\n         if not isinstance(value, (list, tuple)):\n             raise ValidationError(\n                 self.error_messages['invalid_list'],\n",
    "variant_8": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 07d6ffd4ca..a78adce3f8 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -916,11 +916,21 @@ class QuerySet:\n             'datetimefield', flat=True\n         ).distinct().filter(plain_field__isnull=False).order_by(('-' if order == 'DESC' else '') + 'datetimefield')\n \n-    def none(self):\n-        \"\"\"Return an empty QuerySet.\"\"\"\n-        clone = self._chain()\n-        clone.query.set_empty()\n-        return clone\n+\n+def none(self):\n+    \"\"\"Return an empty QuerySet.\"\"\"\n+    # If this is a combined query (union/intersection/difference),\n+    # we need to return a fresh empty queryset instead of trying\n+    # to add NothingNode to the combined query structure\n+    if self.query.combined_queries:\n+        # Create a new empty queryset of the same model\n+        empty_qs = self.__class__(model=self.model, query=self.query.__class__(self.model), using=self._db)\n+        empty_qs.query.set_empty()\n+        return empty_qs\n+    \n+    clone = self._chain()\n+    clone.query.set_empty()\n+    return clone\n \n     ##################################################################\n     # PUBLIC METHODS THAT ALTER ATTRIBUTES AND RETURN A NEW QUERYSET #\n@@ -985,23 +995,31 @@ class QuerySet:\n         else:\n             return self._filter_or_exclude(False, **filter_obj)\n \n-    def _combinator_query(self, combinator, *other_qs, all=False):\n-        # Clone the query to inherit the select list and everything\n-        clone = self._chain()\n-        # Clear limits and ordering so they can be reapplied\n-        clone.query.clear_ordering(True)\n-        clone.query.clear_limits()\n-        clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n-        clone.query.combinator = combinator\n-        clone.query.combinator_all = all\n-        return clone\n \n-    def union(self, *other_qs, all=False):\n-        # If the query is an EmptyQuerySet, combine all nonempty querysets.\n-        if isinstance(self, EmptyQuerySet):\n-            qs = [q for q in other_qs if not isinstance(q, EmptyQuerySet)]\n-            return qs[0]._combinator_query('union', *qs[1:], all=all) if qs else self\n-        return self._combinator_query('union', *other_qs, all=all)\n+    def none(self):\n+        \"\"\"Return an empty QuerySet.\"\"\"\n+        if self.query.combined_queries:\n+            # For union/intersection/difference queries, return a fresh empty queryset\n+            # instead of trying to add NothingNode to the combined query structure\n+            clone = self._chain()\n+            clone.query = self.model._meta.default_manager.none().query\n+            return clone\n+        else:\n+            clone = self._chain()\n+            clone.query.set_empty()\n+            return clone\n+\n+\n+    def none(self):\n+        \"\"\"Return an empty QuerySet.\"\"\"\n+        if self.query.combined_queries:\n+            # For combined queries (union, intersection, difference),\n+            # we need to return a fresh empty queryset rather than\n+            # trying to add NothingNode to the combined query structure\n+            return self._clone().filter(pk__in=[])\n+        clone = self._clone()\n+        clone.query.set_empty()\n+        return clone\n \n     def intersection(self, *other_qs):\n         # If any query is an EmptyQuerySet, return it.\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex c913267476..e0f0dcb9a7 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1775,11 +1775,20 @@ class Query(BaseExpression):\n             # outercol IS NULL we will not match the row.\n         return condition, needed_inner\n \n-    def set_empty(self):\n-        self.where.add(NothingNode(), AND)\n \n-    def is_empty(self):\n-        return any(isinstance(c, NothingNode) for c in self.where.children)\n+def none(self):\n+    \"\"\"Return an empty QuerySet.\"\"\"\n+    if self.query.combined_queries:\n+        # For union/intersection/difference queries, return a fresh empty queryset\n+        # instead of trying to add NothingNode to the combined query structure\n+        clone = self._chain()\n+        clone.query = self.query.__class__(self.model)\n+        clone.query.set_empty()\n+        return clone\n+    else:\n+        clone = self._chain()\n+        clone.query.set_empty()\n+        return clone\n \n     def set_limits(self, low=None, high=None):\n         \"\"\"\ndiff --git a/django/forms/models.py b/django/forms/models.py\nindex ab611afca7..190e183734 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1323,7 +1323,20 @@ class ModelMultipleChoiceField(ModelChoiceField):\n         if self.required and not value:\n             raise ValidationError(self.error_messages['required'], code='required')\n         elif not self.required and not value:\n-            return self.queryset.none()\n+\n+def none(self):\n+    \"\"\"Return an empty QuerySet.\"\"\"\n+    if self.query.combined_queries:\n+        # For union/intersection/difference queries, create a fresh empty queryset\n+        # instead of trying to add NothingNode to the combined query structure\n+        clone = self._chain()\n+        clone.query = self.query.__class__(self.model)\n+        clone.query.set_empty()\n+        return clone\n+    else:\n+        clone = self._chain()\n+        clone.query.set_empty()\n+        return clone\n         if not isinstance(value, (list, tuple)):\n             raise ValidationError(\n                 self.error_messages['invalid_list'],\n"
  }
}