{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/django/django/templatetags/static.py lines 39-47)": "\n@classmethod\ndef handle_simple(cls, name):\n    try:\n        from django.conf import settings\n    except ImportError:\n        prefix = ''\n    else:\n        prefix = iri_to_uri(getattr(settings, name, ''))\n        \n        # Add SCRIPT_NAME awareness for sub-path deployments\n        try:\n            from django.core.context_processors import request\n            from threading import local\n            _thread_locals = getattr(request, '_thread_locals', None)\n            if _thread_locals and hasattr(_thread_locals, 'request'):\n                script_name = _thread_locals.request.META.get('SCRIPT_NAME', '')\n                if script_name and not prefix.startswith(script_name):\n                    prefix = script_name.rstrip('/') + '/' + prefix.lstrip('/')\n        except (ImportError, AttributeError):\n            # Fallback: try to get SCRIPT_NAME from current context\n            try:\n                from django.template.context import RequestContext\n                import threading\n                frame = threading.current_thread()\n                if hasattr(frame, 'request'):\n                    script_name = frame.request.META.get('SCRIPT_NAME', '')\n                    if script_name and not prefix.startswith(script_name):\n                        prefix = script_name.rstrip('/') + '/' + prefix.lstrip('/')\n            except (AttributeError, ImportError):\n                pass\n                \n    return prefix\n",
    "Location 2 (/root/hy/projects_3/django/django/templatetags/static.py lines 115-120)": "\n    @classmethod\n    def handle_simple(cls, path):\n        if apps.is_installed('django.contrib.staticfiles'):\n            from django.contrib.staticfiles.storage import staticfiles_storage\n            return staticfiles_storage.url(path)\n        else:\n            # Get SCRIPT_NAME-aware static URL using PrefixNode\n            static_url = PrefixNode.handle_simple(\"STATIC_URL\")\n            return urljoin(static_url, quote(path))\n",
    "Location 3 (/root/hy/projects_3/django/django/contrib/staticfiles/storage.py lines 23-34)": "\ndef __init__(self, location=None, base_url=None, *args, **kwargs):\n    if location is None:\n        location = settings.STATIC_ROOT\n    if base_url is None:\n        base_url = settings.STATIC_URL\n    check_settings(base_url)\n    # Store the original base_url for SCRIPT_NAME handling\n    self._original_base_url = base_url\n    super().__init__(location, base_url, *args, **kwargs)\n    # FileSystemStorage fallbacks to MEDIA_ROOT when location\n    # is empty, so we restore the empty value.\n    if not location:\n        self.base_location = None\n        self.location = None\n\n@property\ndef base_url(self):\n    \"\"\"Return base_url with SCRIPT_NAME prefix if available.\"\"\"\n    base = self._original_base_url or ''\n    if not base:\n        return base\n    \n    # Try to get SCRIPT_NAME from current request context\n    try:\n        from django.core.context_processors import request\n        from threading import local\n        _thread_locals = getattr(request, '_thread_locals', None)\n        if _thread_locals and hasattr(_thread_locals, 'request'):\n            script_name = _thread_locals.request.META.get('SCRIPT_NAME', '')\n            if script_name and not base.startswith(script_name):\n                # Ensure script_name ends with / if base starts with /\n                if base.startswith('/') and not script_name.endswith('/'):\n                    script_name += '/'\n                return script_name + base.lstrip('/')\n    except (ImportError, AttributeError):\n        pass\n    \n    return base\n\n@base_url.setter\ndef base_url(self, value):\n    \"\"\"Set the original base_url value.\"\"\"\n    self._original_base_url = value\n",
    "Location 4 (/root/hy/projects_3/django/django/core/files/storage.py lines 217-220)": "\n    @cached_property\n    def base_url(self):\n        if self._base_url is not None and not self._base_url.endswith('/'):\n            self._base_url += '/'\n        base_url = self._value_or_setting(self._base_url, settings.MEDIA_URL)\n        \n        # Add SCRIPT_NAME support for proper URL generation in sub-path deployments\n        try:\n            from django.core.context_processors import request\n            from django.template.context import RequestContext\n            from threading import current_thread\n            \n            # Try to get SCRIPT_NAME from current request context\n            if hasattr(current_thread(), 'request') and hasattr(current_thread().request, 'META'):\n                script_name = current_thread().request.META.get('SCRIPT_NAME', '')\n                if script_name and not script_name.endswith('/'):\n                    script_name += '/'\n                if script_name and base_url and not base_url.startswith(script_name):\n                    base_url = script_name.lstrip('/') + base_url.lstrip('/')\n                    if not base_url.startswith('/'):\n                        base_url = '/' + base_url\n        except (ImportError, AttributeError):\n            # Fallback to original behavior if request context unavailable\n            pass\n            \n        return base_url\n",
    "Location 5 (/root/hy/projects_3/django/django/core/files/storage.py lines 329-335)": "\n    def url(self, name):\n        if self.base_url is None:\n            raise ValueError(\"This file is not accessible via a URL.\")\n        url = filepath_to_uri(name)\n        if url is not None:\n            url = url.lstrip('/')\n        \n        # Get SCRIPT_NAME from current request context if available\n        from django.urls import get_script_prefix\n        script_prefix = get_script_prefix()\n        if script_prefix and script_prefix != '/':\n            # Ensure base_url includes script prefix\n            base_url = self.base_url\n            if not base_url.startswith(script_prefix):\n                base_url = urljoin(script_prefix.rstrip('/') + '/', base_url.lstrip('/'))\n            return urljoin(base_url, url)\n        \n        return urljoin(self.base_url, url)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/django/django/templatetags/static.py lines 39-47)": [
      "\n    @classmethod\n    def handle_simple(cls, name):\n        try:\n            from django.conf import settings\n        except ImportError:\n            prefix = ''\n        else:\n            prefix = iri_to_uri(getattr(settings, name, ''))\n            \n            # Check for SCRIPT_NAME in current request context\n            try:\n                from django.core.context_processors import request as get_current_request\n                from threading import current_thread\n                from django.utils.deprecation import MiddlewareMixin\n                \n                # Try to get current request from thread local storage\n                request = getattr(current_thread(), 'request', None)\n                if request and hasattr(request, 'META'):\n                    script_name = request.META.get('SCRIPT_NAME', '')\n                    if script_name and not prefix.startswith(script_name):\n                        prefix = script_name.rstrip('/') + '/' + prefix.lstrip('/')\n            except (ImportError, AttributeError):\n                # Fallback if request context is not available\n                pass\n                \n        return prefix\n",
      "\n@classmethod\ndef handle_simple(cls, name):\n    try:\n        from django.conf import settings\n    except ImportError:\n        prefix = ''\n    else:\n        prefix = iri_to_uri(getattr(settings, name, ''))\n        \n    # Add SCRIPT_NAME support for reverse proxy deployments\n    try:\n        from django.core.context_processors import request\n        from threading import current_thread\n        # Try to get SCRIPT_NAME from current request context\n        if hasattr(current_thread(), 'request'):\n            script_name = getattr(current_thread().request, 'META', {}).get('SCRIPT_NAME', '')\n            if script_name and not prefix.startswith(script_name):\n                prefix = script_name.rstrip('/') + prefix\n    except (ImportError, AttributeError):\n        pass\n        \n    return prefix\n",
      "\n    @classmethod\n    def handle_simple(cls, name):\n        try:\n            from django.conf import settings\n        except ImportError:\n            prefix = ''\n        else:\n            prefix = iri_to_uri(getattr(settings, name, ''))\n            \n            # Add SCRIPT_NAME awareness for reverse proxy deployments\n            try:\n                from django.core.context_processors import request\n                from threading import current_thread\n                \n                # Try to get SCRIPT_NAME from current request context\n                if hasattr(current_thread(), 'request'):\n                    script_name = getattr(current_thread().request, 'META', {}).get('SCRIPT_NAME', '')\n                    if script_name and not prefix.startswith(script_name):\n                        prefix = script_name.rstrip('/') + '/' + prefix.lstrip('/')\n            except (ImportError, AttributeError):\n                # Fallback: try to get from template context if available\n                pass\n                \n        return prefix\n",
      "\n@classmethod\ndef handle_simple(cls, name):\n    try:\n        from django.conf import settings\n    except ImportError:\n        prefix = ''\n    else:\n        prefix = iri_to_uri(getattr(settings, name, ''))\n        \n    # Add SCRIPT_NAME awareness for proper URL generation in sub-path deployments\n    try:\n        from django.urls import get_script_prefix\n        script_prefix = get_script_prefix()\n        if script_prefix and script_prefix != '/':\n            # Remove trailing slash from script_prefix to avoid double slashes\n            script_prefix = script_prefix.rstrip('/')\n            # Only prepend if prefix doesn't already start with script_prefix\n            if prefix and not prefix.startswith(script_prefix):\n                prefix = script_prefix + prefix\n    except ImportError:\n        pass\n        \n    return prefix\n",
      "\n    @classmethod\n    def handle_simple(cls, name):\n        try:\n            from django.conf import settings\n        except ImportError:\n            prefix = ''\n        else:\n            prefix = iri_to_uri(getattr(settings, name, ''))\n            \n            # Add SCRIPT_NAME support for proper URL generation in subdirectory deployments\n            try:\n                from django.http import HttpRequest\n                from threading import current_thread\n                \n                # Try to get SCRIPT_NAME from current request context\n                request = getattr(current_thread(), 'request', None)\n                if hasattr(request, 'META') and 'SCRIPT_NAME' in request.META:\n                    script_name = request.META['SCRIPT_NAME'].rstrip('/')\n                    if script_name and not prefix.startswith(script_name):\n                        prefix = script_name + prefix\n            except (ImportError, AttributeError):\n                # Fallback: try to get from template context if available\n                pass\n                \n        return prefix\n",
      "\n@classmethod\ndef handle_simple(cls, name):\n    try:\n        from django.conf import settings\n    except ImportError:\n        prefix = ''\n    else:\n        prefix = iri_to_uri(getattr(settings, name, ''))\n        # Add SCRIPT_NAME support for URL prefixing\n        try:\n            from django.urls import get_script_prefix\n            script_prefix = get_script_prefix()\n            if script_prefix and script_prefix != '/':\n                prefix = urljoin(script_prefix.rstrip('/') + '/', prefix.lstrip('/'))\n        except (ImportError, AttributeError):\n            pass\n    return prefix\n",
      "\n    @classmethod\n    def handle_simple(cls, name):\n        try:\n            from django.conf import settings\n        except ImportError:\n            prefix = ''\n        else:\n            prefix = iri_to_uri(getattr(settings, name, ''))\n            \n        # Add SCRIPT_NAME support for URL prefixing\n        try:\n            from django.urls import get_script_prefix\n            script_prefix = get_script_prefix()\n            if script_prefix and script_prefix != '/':\n                # Remove trailing slash from script_prefix if prefix starts with /\n                if prefix.startswith('/') and script_prefix.endswith('/'):\n                    script_prefix = script_prefix[:-1]\n                prefix = script_prefix + prefix\n        except ImportError:\n            pass\n            \n        return prefix\n",
      "\n@classmethod\ndef handle_simple(cls, name):\n    try:\n        from django.conf import settings\n    except ImportError:\n        prefix = ''\n    else:\n        prefix = iri_to_uri(getattr(settings, name, ''))\n        \n        # Add SCRIPT_NAME awareness for proper URL generation in sub-path deployments\n        try:\n            from django.urls import get_script_prefix\n            script_prefix = get_script_prefix()\n            if script_prefix and script_prefix != '/':\n                # Remove trailing slash from script_prefix to avoid double slashes\n                script_prefix = script_prefix.rstrip('/')\n                prefix = script_prefix + prefix\n        except ImportError:\n            pass\n    return prefix\n"
    ],
    "Location 2 (/root/hy/projects_3/django/django/templatetags/static.py lines 115-120)": [
      "\n    @classmethod\n    def handle_simple(cls, path):\n        if apps.is_installed('django.contrib.staticfiles'):\n            from django.contrib.staticfiles.storage import staticfiles_storage\n            return staticfiles_storage.url(path)\n        else:\n            # Get SCRIPT_NAME-aware static URL from PrefixNode\n            static_url = PrefixNode.handle_simple(\"STATIC_URL\")\n            return urljoin(static_url, quote(path))\n",
      "\n    @classmethod\n    def handle_simple(cls, path):\n        if apps.is_installed('django.contrib.staticfiles'):\n            from django.contrib.staticfiles.storage import staticfiles_storage\n            return staticfiles_storage.url(path)\n        else:\n            # Get SCRIPT_NAME-aware STATIC_URL from PrefixNode\n            static_url = PrefixNode.handle_simple(\"STATIC_URL\")\n            return urljoin(static_url, quote(path))\n",
      "\n    @classmethod\n    def handle_simple(cls, path):\n        if apps.is_installed('django.contrib.staticfiles'):\n            from django.contrib.staticfiles.storage import staticfiles_storage\n            return staticfiles_storage.url(path)\n        else:\n            # Get the base static URL with SCRIPT_NAME awareness\n            base_url = PrefixNode.handle_simple(\"STATIC_URL\")\n            return urljoin(base_url, quote(path))\n",
      "\n    @classmethod\n    def handle_simple(cls, path):\n        if apps.is_installed('django.contrib.staticfiles'):\n            from django.contrib.staticfiles.storage import staticfiles_storage\n            return staticfiles_storage.url(path)\n        else:\n            # Get SCRIPT_NAME-aware STATIC_URL from PrefixNode\n            static_url = PrefixNode.handle_simple(\"STATIC_URL\")\n            return urljoin(static_url, quote(path))\n",
      "\n    @classmethod\n    def handle_simple(cls, path):\n        if apps.is_installed('django.contrib.staticfiles'):\n            from django.contrib.staticfiles.storage import staticfiles_storage\n            return staticfiles_storage.url(path)\n        else:\n            # Get SCRIPT_NAME-aware static URL prefix\n            static_prefix = PrefixNode.handle_simple(\"STATIC_URL\")\n            return urljoin(static_prefix, quote(path))\n",
      "\n    @classmethod\n    def handle_simple(cls, path):\n        if apps.is_installed('django.contrib.staticfiles'):\n            from django.contrib.staticfiles.storage import staticfiles_storage\n            return staticfiles_storage.url(path)\n        else:\n            # Get the base static URL with SCRIPT_NAME awareness\n            base_url = PrefixNode.handle_simple(\"STATIC_URL\")\n            return urljoin(base_url, quote(path))\n",
      "\n    @classmethod\n    def handle_simple(cls, path):\n        if apps.is_installed('django.contrib.staticfiles'):\n            from django.contrib.staticfiles.storage import staticfiles_storage\n            url = staticfiles_storage.url(path)\n            # Get SCRIPT_NAME from current request context if available\n            try:\n                from django.core.context_processors import request\n                from threading import local\n                _thread_locals = getattr(local(), 'request', None)\n                if hasattr(_thread_locals, 'META') and 'SCRIPT_NAME' in _thread_locals.META:\n                    script_name = _thread_locals.META['SCRIPT_NAME'].rstrip('/')\n                    if script_name and not url.startswith(script_name):\n                        url = script_name + url\n            except (ImportError, AttributeError):\n                pass\n            return url\n        else:\n            return urljoin(PrefixNode.handle_simple(\"STATIC_URL\"), quote(path))\n",
      "\n    @classmethod\n    def handle_simple(cls, path):\n        if apps.is_installed('django.contrib.staticfiles'):\n            from django.contrib.staticfiles.storage import staticfiles_storage\n            url = staticfiles_storage.url(path)\n            # Get SCRIPT_NAME from current request context if available\n            try:\n                from django.core.context_processors import request\n                from threading import local\n                _thread_locals = getattr(request, '_thread_locals', None)\n                if _thread_locals and hasattr(_thread_locals, 'request'):\n                    script_name = _thread_locals.request.META.get('SCRIPT_NAME', '')\n                    if script_name and not url.startswith(script_name):\n                        url = script_name.rstrip('/') + url\n            except (ImportError, AttributeError):\n                pass\n            return url\n        else:\n            return urljoin(PrefixNode.handle_simple(\"STATIC_URL\"), quote(path))\n"
    ],
    "Location 3 (/root/hy/projects_3/django/django/contrib/staticfiles/storage.py lines 23-34)": [
      "\ndef __init__(self, location=None, base_url=None, *args, **kwargs):\n    if location is None:\n        location = settings.STATIC_ROOT\n    if base_url is None:\n        base_url = settings.STATIC_URL\n    check_settings(base_url)\n    \n    # Store original base_url for SCRIPT_NAME handling\n    self._original_base_url = base_url\n    \n    super().__init__(location, base_url, *args, **kwargs)\n    # FileSystemStorage fallbacks to MEDIA_ROOT when location\n    # is empty, so we restore the empty value.\n    if not location:\n        self.base_location = None\n        self.location = None\n\n@property\ndef base_url(self):\n    \"\"\"Return base_url with SCRIPT_NAME prefix if available.\"\"\"\n    from django.urls import get_script_prefix\n    try:\n        script_prefix = get_script_prefix()\n        if script_prefix and script_prefix != '/':\n            return script_prefix.rstrip('/') + self._original_base_url\n    except:\n        pass\n    return self._original_base_url\n\n@base_url.setter  \ndef base_url(self, value):\n    self._original_base_url = value\n",
      "\ndef __init__(self, location=None, base_url=None, *args, **kwargs):\n    if location is None:\n        location = settings.STATIC_ROOT\n    if base_url is None:\n        base_url = settings.STATIC_URL\n    check_settings(base_url)\n    \n    # Store original base_url for SCRIPT_NAME handling\n    self._original_base_url = base_url\n    \n    super().__init__(location, base_url, *args, **kwargs)\n    # FileSystemStorage fallbacks to MEDIA_ROOT when location\n    # is empty, so we restore the empty value.\n    if not location:\n        self.base_location = None\n        self.location = None\n\n@property\ndef base_url(self):\n    \"\"\"Return base_url with SCRIPT_NAME prefix if available.\"\"\"\n    base = self._original_base_url\n    if not base:\n        return base\n    \n    # Try to get SCRIPT_NAME from current request context\n    try:\n        from django.urls import get_script_prefix\n        script_prefix = get_script_prefix()\n        if script_prefix and script_prefix != '/':\n            # Ensure proper URL joining\n            if base.startswith('/'):\n                base = base[1:]\n            return script_prefix.rstrip('/') + '/' + base.lstrip('/')\n    except Exception:\n        pass\n    \n    return base\n\n@base_url.setter\ndef base_url(self, value):\n    \"\"\"Set the original base_url value.\"\"\"\n    self._original_base_url = value\n",
      "\ndef __init__(self, location=None, base_url=None, *args, **kwargs):\n    if location is None:\n        location = settings.STATIC_ROOT\n    if base_url is None:\n        base_url = settings.STATIC_URL\n    check_settings(base_url)\n    \n    # Store original base_url for SCRIPT_NAME handling\n    self._original_base_url = base_url\n    \n    super().__init__(location, base_url, *args, **kwargs)\n    # FileSystemStorage fallbacks to MEDIA_ROOT when location\n    # is empty, so we restore the empty value.\n    if not location:\n        self.base_location = None\n        self.location = None\n\n@property\ndef base_url(self):\n    \"\"\"Return base_url with SCRIPT_NAME prefix if available.\"\"\"\n    from django.urls import get_script_prefix\n    \n    base_url = self._original_base_url or ''\n    if base_url and not base_url.startswith(('http://', 'https://', '//')):\n        script_prefix = get_script_prefix()\n        if script_prefix and script_prefix != '/':\n            # Remove trailing slash from script_prefix and ensure base_url starts with /\n            script_prefix = script_prefix.rstrip('/')\n            if not base_url.startswith('/'):\n                base_url = '/' + base_url\n            base_url = script_prefix + base_url\n    return base_url\n\n@base_url.setter\ndef base_url(self, value):\n    \"\"\"Set the original base_url value.\"\"\"\n    self._original_base_url = value\n",
      "\ndef __init__(self, location=None, base_url=None, *args, **kwargs):\n    if location is None:\n        location = settings.STATIC_ROOT\n    if base_url is None:\n        base_url = settings.STATIC_URL\n    check_settings(base_url)\n    \n    # Store original base_url for SCRIPT_NAME handling\n    self._original_base_url = base_url\n    \n    super().__init__(location, base_url, *args, **kwargs)\n    # FileSystemStorage fallbacks to MEDIA_ROOT when location\n    # is empty, so we restore the empty value.\n    if not location:\n        self.base_location = None\n        self.location = None\n\n@property\ndef base_url(self):\n    \"\"\"Return base_url with SCRIPT_NAME prefix if available.\"\"\"\n    base = self._original_base_url or ''\n    \n    # Try to get SCRIPT_NAME from current request context\n    try:\n        from django.utils.deprecation import MiddlewareMixin\n        import threading\n        \n        # Access current request from thread local if available\n        request = getattr(threading.current_thread(), 'request', None)\n        if request and hasattr(request, 'META'):\n            script_name = request.META.get('SCRIPT_NAME', '')\n            if script_name and not base.startswith(script_name):\n                # Ensure SCRIPT_NAME ends with / and base starts with /\n                if not script_name.endswith('/'):\n                    script_name += '/'\n                if base.startswith('/'):\n                    base = base[1:]\n                return script_name + base\n    except (ImportError, AttributeError):\n        pass\n    \n    return base\n\n@base_url.setter\ndef base_url(self, value):\n    \"\"\"Store the original base_url value.\"\"\"\n    self._original_base_url = value\n",
      "\ndef __init__(self, location=None, base_url=None, *args, **kwargs):\n    if location is None:\n        location = settings.STATIC_ROOT\n    if base_url is None:\n        base_url = settings.STATIC_URL\n    check_settings(base_url)\n    \n    # Store original base_url for SCRIPT_NAME handling\n    self._original_base_url = base_url\n    \n    super().__init__(location, base_url, *args, **kwargs)\n    # FileSystemStorage fallbacks to MEDIA_ROOT when location\n    # is empty, so we restore the empty value.\n    if not location:\n        self.base_location = None\n        self.location = None\n\n@property\ndef base_url(self):\n    \"\"\"Return base_url with SCRIPT_NAME prefix if available.\"\"\"\n    base = self._original_base_url\n    if not base:\n        return base\n    \n    # Try to get SCRIPT_NAME from current request context\n    try:\n        from django.urls import get_script_prefix\n        script_prefix = get_script_prefix()\n        if script_prefix and script_prefix != '/':\n            # Ensure proper URL joining\n            if base.startswith('/'):\n                base = base[1:]\n            return script_prefix.rstrip('/') + '/' + base.lstrip('/')\n    except Exception:\n        pass\n    \n    return base\n\n@base_url.setter\ndef base_url(self, value):\n    \"\"\"Set the original base_url value.\"\"\"\n    self._original_base_url = value\n",
      "\ndef __init__(self, location=None, base_url=None, *args, **kwargs):\n    if location is None:\n        location = settings.STATIC_ROOT\n    if base_url is None:\n        base_url = settings.STATIC_URL\n    check_settings(base_url)\n    \n    # Store original base_url for SCRIPT_NAME handling\n    self._original_base_url = base_url\n    \n    super().__init__(location, base_url, *args, **kwargs)\n    # FileSystemStorage fallbacks to MEDIA_ROOT when location\n    # is empty, so we restore the empty value.\n    if not location:\n        self.base_location = None\n        self.location = None\n\n@property\ndef base_url(self):\n    \"\"\"Return base_url with SCRIPT_NAME prefix if available.\"\"\"\n    base = self._original_base_url\n    if not base:\n        return base\n    \n    # Try to get SCRIPT_NAME from current request context\n    try:\n        from django.urls import get_script_prefix\n        script_prefix = get_script_prefix()\n        if script_prefix and script_prefix != '/':\n            # Ensure proper URL joining\n            if not base.startswith('/'):\n                base = '/' + base\n            base = script_prefix.rstrip('/') + base\n    except Exception:\n        # Fallback to original base_url if context unavailable\n        pass\n    \n    return base\n\n@base_url.setter\ndef base_url(self, value):\n    \"\"\"Set the original base_url value.\"\"\"\n    self._original_base_url = value\n",
      "\ndef __init__(self, location=None, base_url=None, *args, **kwargs):\n    if location is None:\n        location = settings.STATIC_ROOT\n    if base_url is None:\n        base_url = settings.STATIC_URL\n    check_settings(base_url)\n    \n    # Store original base_url for SCRIPT_NAME handling\n    self._original_base_url = base_url\n    \n    super().__init__(location, base_url, *args, **kwargs)\n    # FileSystemStorage fallbacks to MEDIA_ROOT when location\n    # is empty, so we restore the empty value.\n    if not location:\n        self.base_location = None\n        self.location = None\n\n@property\ndef base_url(self):\n    \"\"\"Return base URL with SCRIPT_NAME prefix when available.\"\"\"\n    from django.core.context_processors import request\n    try:\n        # Try to get current request from thread locals\n        from threading import current_thread\n        for frame_record in __import__('inspect').stack():\n            frame_locals = frame_record.frame.f_locals\n            if 'request' in frame_locals:\n                request_obj = frame_locals['request']\n                if hasattr(request_obj, 'META'):\n                    script_name = request_obj.META.get('SCRIPT_NAME', '')\n                    if script_name and self._original_base_url:\n                        # Ensure script_name ends with / and base_url is properly joined\n                        if not script_name.endswith('/'):\n                            script_name += '/'\n                        return script_name.rstrip('/') + self._original_base_url\n                    break\n    except:\n        pass\n    return self._original_base_url\n\n@base_url.setter\ndef base_url(self, value):\n    self._original_base_url = value\n",
      "\ndef __init__(self, location=None, base_url=None, *args, **kwargs):\n    if location is None:\n        location = settings.STATIC_ROOT\n    if base_url is None:\n        base_url = settings.STATIC_URL\n    check_settings(base_url)\n    \n    # Store original base_url for SCRIPT_NAME handling\n    self._original_base_url = base_url\n    \n    super().__init__(location, base_url, *args, **kwargs)\n    # FileSystemStorage fallbacks to MEDIA_ROOT when location\n    # is empty, so we restore the empty value.\n    if not location:\n        self.base_location = None\n        self.location = None\n\n@property\ndef base_url(self):\n    \"\"\"Return base_url with SCRIPT_NAME prefix if available.\"\"\"\n    base = self._original_base_url or ''\n    if not base:\n        return base\n    \n    # Try to get SCRIPT_NAME from current request context\n    try:\n        from django.urls import get_script_prefix\n        script_prefix = get_script_prefix()\n        if script_prefix and script_prefix != '/':\n            # Ensure proper URL joining\n            if base.startswith('/'):\n                base = base[1:]\n            return script_prefix.rstrip('/') + '/' + base.lstrip('/')\n    except Exception:\n        pass\n    \n    return base\n\n@base_url.setter\ndef base_url(self, value):\n    \"\"\"Set the original base_url value.\"\"\"\n    self._original_base_url = value\n"
    ],
    "Location 4 (/root/hy/projects_3/django/django/core/files/storage.py lines 217-220)": [
      "\n    @cached_property\n    def base_url(self):\n        if self._base_url is not None and not self._base_url.endswith('/'):\n            self._base_url += '/'\n        \n        base_url = self._value_or_setting(self._base_url, settings.MEDIA_URL)\n        \n        # Add SCRIPT_NAME prefix if available in current request context\n        try:\n            from django.urls import get_script_prefix\n            script_prefix = get_script_prefix()\n            if script_prefix and script_prefix != '/' and base_url:\n                # Ensure script_prefix ends with '/' and base_url starts with '/'\n                if not script_prefix.endswith('/'):\n                    script_prefix += '/'\n                if base_url.startswith('/'):\n                    base_url = base_url[1:]\n                base_url = script_prefix + base_url\n        except ImportError:\n            pass\n        \n        return base_url\n",
      "\n    @cached_property\n    def base_url(self):\n        if self._base_url is not None and not self._base_url.endswith('/'):\n            self._base_url += '/'\n        base_url = self._value_or_setting(self._base_url, settings.MEDIA_URL)\n        \n        # Add SCRIPT_NAME awareness for proper URL generation in sub-path deployments\n        try:\n            from django.urls import get_script_prefix\n            script_prefix = get_script_prefix()\n            if script_prefix and script_prefix != '/' and base_url:\n                # Ensure script_prefix ends with '/' and base_url starts with '/'\n                if not script_prefix.endswith('/'):\n                    script_prefix += '/'\n                if not base_url.startswith('/'):\n                    base_url = '/' + base_url\n                base_url = script_prefix.rstrip('/') + base_url\n        except ImportError:\n            pass\n            \n        return base_url\n",
      "\n    @cached_property\n    def base_url(self):\n        if self._base_url is not None and not self._base_url.endswith('/'):\n            self._base_url += '/'\n        base_url = self._value_or_setting(self._base_url, settings.MEDIA_URL)\n        \n        # Add SCRIPT_NAME support for proper URL generation in sub-path deployments\n        try:\n            from django.urls import get_script_prefix\n            script_prefix = get_script_prefix()\n            if script_prefix and script_prefix != '/' and base_url:\n                # Ensure script_prefix ends with '/' and base_url starts with '/'\n                if not script_prefix.endswith('/'):\n                    script_prefix += '/'\n                if base_url.startswith('/'):\n                    base_url = script_prefix + base_url[1:]\n                else:\n                    base_url = script_prefix + base_url\n        except ImportError:\n            pass\n        \n        return base_url\n",
      "\n    @cached_property\n    def base_url(self):\n        if self._base_url is not None and not self._base_url.endswith('/'):\n            self._base_url += '/'\n        base_url = self._value_or_setting(self._base_url, settings.MEDIA_URL)\n        \n        # Add SCRIPT_NAME support for URL generation\n        try:\n            from django.urls import get_script_prefix\n            script_prefix = get_script_prefix()\n            if script_prefix and script_prefix != '/' and base_url:\n                # Ensure script_prefix ends with '/' and base_url starts with '/'\n                if not script_prefix.endswith('/'):\n                    script_prefix += '/'\n                if base_url.startswith('/'):\n                    base_url = base_url[1:]\n                base_url = script_prefix + base_url\n        except ImportError:\n            pass\n        \n        return base_url\n",
      "\n    @cached_property\n    def base_url(self):\n        if self._base_url is not None and not self._base_url.endswith('/'):\n            self._base_url += '/'\n        base_url = self._value_or_setting(self._base_url, settings.MEDIA_URL)\n        \n        # Add SCRIPT_NAME support for proper URL generation in sub-path deployments\n        try:\n            from django.urls import get_script_prefix\n            script_prefix = get_script_prefix()\n            if script_prefix and script_prefix != '/' and base_url:\n                # Ensure script_prefix ends with '/' and base_url doesn't start with '/'\n                if not script_prefix.endswith('/'):\n                    script_prefix += '/'\n                if base_url.startswith('/'):\n                    base_url = base_url[1:]\n                base_url = script_prefix + base_url\n        except ImportError:\n            # Fallback if get_script_prefix is not available\n            pass\n            \n        return base_url\n",
      "\n    @cached_property\n    def base_url(self):\n        if self._base_url is not None and not self._base_url.endswith('/'):\n            self._base_url += '/'\n        base_url = self._value_or_setting(self._base_url, settings.MEDIA_URL)\n        \n        # Add SCRIPT_NAME support for proper URL generation in subpath deployments\n        try:\n            from django.urls import get_script_prefix\n            script_prefix = get_script_prefix()\n            if script_prefix and script_prefix != '/' and base_url:\n                # Remove leading slash from base_url if present to avoid double slashes\n                if base_url.startswith('/'):\n                    base_url = base_url[1:]\n                base_url = urljoin(script_prefix, base_url)\n        except ImportError:\n            pass\n        \n        return base_url\n",
      "\n    @cached_property\n    def base_url(self):\n        if self._base_url is not None and not self._base_url.endswith('/'):\n            self._base_url += '/'\n        \n        base_url = self._value_or_setting(self._base_url, settings.MEDIA_URL)\n        \n        # Check for SCRIPT_NAME in the current request context\n        try:\n            from django.core.context_processors import request\n            from threading import current_thread\n            \n            # Try to get SCRIPT_NAME from thread-local storage\n            if hasattr(current_thread(), 'request'):\n                script_name = getattr(current_thread().request, 'META', {}).get('SCRIPT_NAME', '')\n                if script_name and not script_name.endswith('/'):\n                    script_name += '/'\n                if script_name and base_url:\n                    base_url = script_name.rstrip('/') + base_url\n        except (ImportError, AttributeError):\n            # Fallback: try to get from Django's current request if available\n            try:\n                from django.utils.deprecation import MiddlewareMixin\n                from django.core.context import request_context\n                if hasattr(request_context, 'request') and request_context.request:\n                    script_name = request_context.request.META.get('SCRIPT_NAME', '')\n                    if script_name and not script_name.endswith('/'):\n                        script_name += '/'\n                    if script_name and base_url:\n                        base_url = script_name.rstrip('/') + base_url\n            except (ImportError, AttributeError):\n                pass\n        \n        return base_url\n",
      "\n    @cached_property\n    def base_url(self):\n        if self._base_url is not None and not self._base_url.endswith('/'):\n            self._base_url += '/'\n        base_url = self._value_or_setting(self._base_url, settings.MEDIA_URL)\n        \n        # Add SCRIPT_NAME support for WSGI deployments\n        try:\n            from django.core.context_processors import request\n            from threading import current_thread\n            \n            # Try to get SCRIPT_NAME from thread-local request context\n            thread_locals = getattr(current_thread(), 'request', None)\n            if hasattr(thread_locals, 'META'):\n                script_name = thread_locals.META.get('SCRIPT_NAME', '')\n                if script_name and not script_name.endswith('/'):\n                    script_name += '/'\n                if script_name and base_url and not base_url.startswith(script_name):\n                    base_url = script_name.rstrip('/') + base_url\n        except (ImportError, AttributeError):\n            # Fallback to original behavior if request context unavailable\n            pass\n            \n        return base_url\n"
    ],
    "Location 5 (/root/hy/projects_3/django/django/core/files/storage.py lines 329-335)": [
      "\n    def url(self, name):\n        if self.base_url is None:\n            raise ValueError(\"This file is not accessible via a URL.\")\n        \n        # Get SCRIPT_NAME from current request context if available\n        script_name = ''\n        try:\n            from django.urls import get_script_prefix\n            script_name = get_script_prefix()\n        except (ImportError, RuntimeError):\n            # Fallback: try to get from thread-local request\n            try:\n                from django.utils.deprecation import MiddlewareMixin\n                from threading import local\n                import threading\n                if hasattr(threading.current_thread(), 'request'):\n                    request = getattr(threading.current_thread(), 'request', None)\n                    if request and hasattr(request, 'META'):\n                        script_name = request.META.get('SCRIPT_NAME', '')\n            except:\n                pass\n        \n        # Ensure script_name ends with / if it exists and doesn't already\n        if script_name and not script_name.endswith('/'):\n            script_name += '/'\n        \n        url = filepath_to_uri(name)\n        if url is not None:\n            url = url.lstrip('/')\n        \n        # Combine script_name with base_url for final URL\n        base_url_with_script = urljoin(script_name, self.base_url.lstrip('/')) if script_name else self.base_url\n        return urljoin(base_url_with_script, url)\n",
      "\n    def url(self, name):\n        if self.base_url is None:\n            raise ValueError(\"This file is not accessible via a URL.\")\n        url = filepath_to_uri(name)\n        if url is not None:\n            url = url.lstrip('/')\n        \n        # Get SCRIPT_NAME from current request context if available\n        from django.urls import get_script_prefix\n        script_prefix = get_script_prefix()\n        \n        # Ensure base_url includes script prefix\n        base_url = self.base_url\n        if script_prefix and script_prefix != '/' and not base_url.startswith(script_prefix):\n            # Remove leading slash from base_url if present to avoid double slashes\n            if base_url.startswith('/'):\n                base_url = base_url[1:]\n            base_url = urljoin(script_prefix, base_url)\n        \n        return urljoin(base_url, url)\n",
      "\n    def url(self, name):\n        if self.base_url is None:\n            raise ValueError(\"This file is not accessible via a URL.\")\n        \n        # Get SCRIPT_NAME from current request context if available\n        from django.urls import get_script_prefix\n        script_prefix = get_script_prefix()\n        \n        url = filepath_to_uri(name)\n        if url is not None:\n            url = url.lstrip('/')\n        \n        # Ensure base_url includes script prefix for proper URL construction\n        base_url = self.base_url\n        if script_prefix and script_prefix != '/' and not base_url.startswith(script_prefix):\n            # Only prepend if base_url doesn't already include the script prefix\n            base_url = script_prefix.rstrip('/') + '/' + base_url.lstrip('/')\n        \n        return urljoin(base_url, url)\n",
      "\n    def url(self, name):\n        if self.base_url is None:\n            raise ValueError(\"This file is not accessible via a URL.\")\n        url = filepath_to_uri(name)\n        if url is not None:\n            url = url.lstrip('/')\n        \n        # Get SCRIPT_NAME from current request context if available\n        from django.core.context_processors import request\n        try:\n            from django.http import HttpRequest\n            import threading\n            local = getattr(threading.current_thread(), 'request', None)\n            if hasattr(local, 'META') and 'SCRIPT_NAME' in local.META:\n                script_name = local.META['SCRIPT_NAME'].rstrip('/')\n                if script_name and not self.base_url.startswith(script_name):\n                    base_url = script_name + self.base_url\n                else:\n                    base_url = self.base_url\n            else:\n                base_url = self.base_url\n        except (ImportError, AttributeError):\n            base_url = self.base_url\n            \n        return urljoin(base_url, url)\n",
      "\n    def url(self, name):\n        if self.base_url is None:\n            raise ValueError(\"This file is not accessible via a URL.\")\n        url = filepath_to_uri(name)\n        if url is not None:\n            url = url.lstrip('/')\n        \n        # Get SCRIPT_NAME from current request if available\n        from django.core.context_processors import request\n        try:\n            from django.http import HttpRequest\n            # Try to get current request from thread locals\n            import threading\n            local = getattr(threading.current_thread(), 'request', None)\n            if hasattr(local, 'META') and 'SCRIPT_NAME' in local.META:\n                script_name = local.META['SCRIPT_NAME'].rstrip('/')\n                if script_name:\n                    base_url = script_name + self.base_url\n                    return urljoin(base_url, url)\n        except (ImportError, AttributeError):\n            pass\n            \n        return urljoin(self.base_url, url)\n",
      "\n    def url(self, name):\n        if self.base_url is None:\n            raise ValueError(\"This file is not accessible via a URL.\")\n        \n        # Get SCRIPT_NAME from current request context if available\n        script_name = ''\n        try:\n            from django.urls import get_script_prefix\n            script_name = get_script_prefix()\n        except ImportError:\n            pass\n        \n        url = filepath_to_uri(name)\n        if url is not None:\n            url = url.lstrip('/')\n        \n        # Combine script_name with base_url for proper URL construction\n        if script_name and not self.base_url.startswith(script_name):\n            full_base_url = script_name.rstrip('/') + '/' + self.base_url.lstrip('/')\n        else:\n            full_base_url = self.base_url\n            \n        return urljoin(full_base_url, url)\n",
      "\n    def url(self, name):\n        if self.base_url is None:\n            raise ValueError(\"This file is not accessible via a URL.\")\n        url = filepath_to_uri(name)\n        if url is not None:\n            url = url.lstrip('/')\n        \n        # Get SCRIPT_NAME from current request context if available\n        from django.urls import get_script_prefix\n        try:\n            script_prefix = get_script_prefix()\n            if script_prefix and script_prefix != '/':\n                # Ensure base_url includes script prefix\n                base_url = self.base_url\n                if not base_url.startswith(script_prefix):\n                    base_url = script_prefix.rstrip('/') + base_url\n                return urljoin(base_url, url)\n        except:\n            # Fall back to original behavior if no request context\n            pass\n            \n        return urljoin(self.base_url, url)\n",
      "\ndef url(self, name):\n    if self.base_url is None:\n        raise ValueError(\"This file is not accessible via a URL.\")\n    url = filepath_to_uri(name)\n    if url is not None:\n        url = url.lstrip('/')\n    \n    # Get SCRIPT_NAME from current request context if available\n    from django.core.context_processors import request\n    try:\n        from django.http import HttpRequest\n        import threading\n        \n        # Try to get current request from thread locals\n        current_request = getattr(threading.current_thread(), 'request', None)\n        if current_request and hasattr(current_request, 'META'):\n            script_name = current_request.META.get('SCRIPT_NAME', '')\n            if script_name and not script_name.endswith('/'):\n                script_name += '/'\n            base_url = script_name + self.base_url.lstrip('/') if script_name else self.base_url\n        else:\n            base_url = self.base_url\n    except (ImportError, AttributeError):\n        base_url = self.base_url\n    \n    return urljoin(base_url, url)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/contrib/staticfiles/storage.py b/django/contrib/staticfiles/storage.py\nindex ba3b62620d..c6d41cd6c6 100644\n--- a/django/contrib/staticfiles/storage.py\n+++ b/django/contrib/staticfiles/storage.py\n@@ -20,6 +20,7 @@ class StaticFilesStorage(FileSystemStorage):\n     The defaults for ``location`` and ``base_url`` are\n     ``STATIC_ROOT`` and ``STATIC_URL``.\n     \"\"\"\n+\n     def __init__(self, location=None, base_url=None, *args, **kwargs):\n         if location is None:\n             location = settings.STATIC_ROOT\ndiff --git a/django/core/files/storage.py b/django/core/files/storage.py\nindex 4c27fce605..3aaf03dbff 100644\n--- a/django/core/files/storage.py\n+++ b/django/core/files/storage.py\n@@ -213,11 +213,19 @@ class FileSystemStorage(Storage):\n     def location(self):\n         return os.path.abspath(self.base_location)\n \n+    @cached_property\n+\n     @cached_property\n     def base_url(self):\n         if self._base_url is not None and not self._base_url.endswith('/'):\n             self._base_url += '/'\n-        return self._value_or_setting(self._base_url, settings.MEDIA_URL)\n+        base_url = self._value_or_setting(self._base_url, settings.MEDIA_URL)\n+        if base_url:\n+            from django.urls import get_script_prefix\n+            script_prefix = get_script_prefix()\n+            if script_prefix:\n+                base_url = script_prefix.rstrip('/') + base_url\n+        return base_url\n \n     @cached_property\n     def file_permissions_mode(self):\n@@ -326,6 +334,7 @@ class FileSystemStorage(Storage):\n     def size(self, name):\n         return os.path.getsize(self.path(name))\n \n+\n     def url(self, name):\n         if self.base_url is None:\n             raise ValueError(\"This file is not accessible via a URL.\")\ndiff --git a/django/templatetags/static.py b/django/templatetags/static.py\nindex 39712aaba0..41c6e54e82 100644\n--- a/django/templatetags/static.py\n+++ b/django/templatetags/static.py\n@@ -36,14 +36,19 @@ class PrefixNode(template.Node):\n             varname = None\n         return cls(varname, name)\n \n+\n     @classmethod\n     def handle_simple(cls, name):\n         try:\n             from django.conf import settings\n+            from django.urls import get_script_prefix\n         except ImportError:\n             prefix = ''\n         else:\n             prefix = iri_to_uri(getattr(settings, name, ''))\n+            script_prefix = get_script_prefix()\n+            if script_prefix and prefix:\n+                prefix = script_prefix.rstrip('/') + prefix\n         return prefix\n \n     def render(self, context):\n@@ -111,6 +116,8 @@ class StaticNode(template.Node):\n         context[self.varname] = url\n         return ''\n \n+    @classmethod\n+\n     @classmethod\n     def handle_simple(cls, path):\n         if apps.is_installed('django.contrib.staticfiles'):\n",
    "variant_0": "diff --git a/django/contrib/staticfiles/storage.py b/django/contrib/staticfiles/storage.py\nindex ba3b62620d..4a30c7fc88 100644\n--- a/django/contrib/staticfiles/storage.py\n+++ b/django/contrib/staticfiles/storage.py\n@@ -20,18 +20,50 @@ class StaticFilesStorage(FileSystemStorage):\n     The defaults for ``location`` and ``base_url`` are\n     ``STATIC_ROOT`` and ``STATIC_URL``.\n     \"\"\"\n-    def __init__(self, location=None, base_url=None, *args, **kwargs):\n-        if location is None:\n-            location = settings.STATIC_ROOT\n-        if base_url is None:\n-            base_url = settings.STATIC_URL\n-        check_settings(base_url)\n-        super().__init__(location, base_url, *args, **kwargs)\n-        # FileSystemStorage fallbacks to MEDIA_ROOT when location\n-        # is empty, so we restore the empty value.\n-        if not location:\n-            self.base_location = None\n-            self.location = None\n+\n+def __init__(self, location=None, base_url=None, *args, **kwargs):\n+    if location is None:\n+        location = settings.STATIC_ROOT\n+    if base_url is None:\n+        base_url = settings.STATIC_URL\n+    check_settings(base_url)\n+    # Store the original base_url for SCRIPT_NAME handling\n+    self._original_base_url = base_url\n+    super().__init__(location, base_url, *args, **kwargs)\n+    # FileSystemStorage fallbacks to MEDIA_ROOT when location\n+    # is empty, so we restore the empty value.\n+    if not location:\n+        self.base_location = None\n+        self.location = None\n+\n+@property\n+def base_url(self):\n+    \"\"\"Return base_url with SCRIPT_NAME prefix if available.\"\"\"\n+    base = self._original_base_url or ''\n+    if not base:\n+        return base\n+    \n+    # Try to get SCRIPT_NAME from current request context\n+    try:\n+        from django.core.context_processors import request\n+        from threading import local\n+        _thread_locals = getattr(request, '_thread_locals', None)\n+        if _thread_locals and hasattr(_thread_locals, 'request'):\n+            script_name = _thread_locals.request.META.get('SCRIPT_NAME', '')\n+            if script_name and not base.startswith(script_name):\n+                # Ensure script_name ends with / if base starts with /\n+                if base.startswith('/') and not script_name.endswith('/'):\n+                    script_name += '/'\n+                return script_name + base.lstrip('/')\n+    except (ImportError, AttributeError):\n+        pass\n+    \n+    return base\n+\n+@base_url.setter\n+def base_url(self, value):\n+    \"\"\"Set the original base_url value.\"\"\"\n+    self._original_base_url = value\n \n     def path(self, name):\n         if not self.location:\ndiff --git a/django/core/files/storage.py b/django/core/files/storage.py\nindex 4c27fce605..6693b7a9b4 100644\n--- a/django/core/files/storage.py\n+++ b/django/core/files/storage.py\n@@ -213,11 +213,34 @@ class FileSystemStorage(Storage):\n     def location(self):\n         return os.path.abspath(self.base_location)\n \n+    @cached_property\n+\n     @cached_property\n     def base_url(self):\n         if self._base_url is not None and not self._base_url.endswith('/'):\n             self._base_url += '/'\n-        return self._value_or_setting(self._base_url, settings.MEDIA_URL)\n+        base_url = self._value_or_setting(self._base_url, settings.MEDIA_URL)\n+        \n+        # Add SCRIPT_NAME support for proper URL generation in sub-path deployments\n+        try:\n+            from django.core.context_processors import request\n+            from django.template.context import RequestContext\n+            from threading import current_thread\n+            \n+            # Try to get SCRIPT_NAME from current request context\n+            if hasattr(current_thread(), 'request') and hasattr(current_thread().request, 'META'):\n+                script_name = current_thread().request.META.get('SCRIPT_NAME', '')\n+                if script_name and not script_name.endswith('/'):\n+                    script_name += '/'\n+                if script_name and base_url and not base_url.startswith(script_name):\n+                    base_url = script_name.lstrip('/') + base_url.lstrip('/')\n+                    if not base_url.startswith('/'):\n+                        base_url = '/' + base_url\n+        except (ImportError, AttributeError):\n+            # Fallback to original behavior if request context unavailable\n+            pass\n+            \n+        return base_url\n \n     @cached_property\n     def file_permissions_mode(self):\n@@ -326,12 +349,24 @@ class FileSystemStorage(Storage):\n     def size(self, name):\n         return os.path.getsize(self.path(name))\n \n+\n     def url(self, name):\n         if self.base_url is None:\n             raise ValueError(\"This file is not accessible via a URL.\")\n         url = filepath_to_uri(name)\n         if url is not None:\n             url = url.lstrip('/')\n+        \n+        # Get SCRIPT_NAME from current request context if available\n+        from django.urls import get_script_prefix\n+        script_prefix = get_script_prefix()\n+        if script_prefix and script_prefix != '/':\n+            # Ensure base_url includes script prefix\n+            base_url = self.base_url\n+            if not base_url.startswith(script_prefix):\n+                base_url = urljoin(script_prefix.rstrip('/') + '/', base_url.lstrip('/'))\n+            return urljoin(base_url, url)\n+        \n         return urljoin(self.base_url, url)\n \n     def _datetime_from_timestamp(self, ts):\ndiff --git a/django/templatetags/static.py b/django/templatetags/static.py\nindex 39712aaba0..c5137b8804 100644\n--- a/django/templatetags/static.py\n+++ b/django/templatetags/static.py\n@@ -36,15 +36,39 @@ class PrefixNode(template.Node):\n             varname = None\n         return cls(varname, name)\n \n-    @classmethod\n-    def handle_simple(cls, name):\n+\n+@classmethod\n+def handle_simple(cls, name):\n+    try:\n+        from django.conf import settings\n+    except ImportError:\n+        prefix = ''\n+    else:\n+        prefix = iri_to_uri(getattr(settings, name, ''))\n+        \n+        # Add SCRIPT_NAME awareness for sub-path deployments\n         try:\n-            from django.conf import settings\n-        except ImportError:\n-            prefix = ''\n-        else:\n-            prefix = iri_to_uri(getattr(settings, name, ''))\n-        return prefix\n+            from django.core.context_processors import request\n+            from threading import local\n+            _thread_locals = getattr(request, '_thread_locals', None)\n+            if _thread_locals and hasattr(_thread_locals, 'request'):\n+                script_name = _thread_locals.request.META.get('SCRIPT_NAME', '')\n+                if script_name and not prefix.startswith(script_name):\n+                    prefix = script_name.rstrip('/') + '/' + prefix.lstrip('/')\n+        except (ImportError, AttributeError):\n+            # Fallback: try to get SCRIPT_NAME from current context\n+            try:\n+                from django.template.context import RequestContext\n+                import threading\n+                frame = threading.current_thread()\n+                if hasattr(frame, 'request'):\n+                    script_name = frame.request.META.get('SCRIPT_NAME', '')\n+                    if script_name and not prefix.startswith(script_name):\n+                        prefix = script_name.rstrip('/') + '/' + prefix.lstrip('/')\n+            except (AttributeError, ImportError):\n+                pass\n+                \n+    return prefix\n \n     def render(self, context):\n         prefix = self.handle_simple(self.name)\n@@ -111,13 +135,17 @@ class StaticNode(template.Node):\n         context[self.varname] = url\n         return ''\n \n+    @classmethod\n+\n     @classmethod\n     def handle_simple(cls, path):\n         if apps.is_installed('django.contrib.staticfiles'):\n             from django.contrib.staticfiles.storage import staticfiles_storage\n             return staticfiles_storage.url(path)\n         else:\n-            return urljoin(PrefixNode.handle_simple(\"STATIC_URL\"), quote(path))\n+            # Get SCRIPT_NAME-aware static URL using PrefixNode\n+            static_url = PrefixNode.handle_simple(\"STATIC_URL\")\n+            return urljoin(static_url, quote(path))\n \n     @classmethod\n     def handle_token(cls, parser, token):\n",
    "variant_1": "diff --git a/django/contrib/staticfiles/storage.py b/django/contrib/staticfiles/storage.py\nindex ba3b62620d..381cd0cf9e 100644\n--- a/django/contrib/staticfiles/storage.py\n+++ b/django/contrib/staticfiles/storage.py\n@@ -20,18 +20,39 @@ class StaticFilesStorage(FileSystemStorage):\n     The defaults for ``location`` and ``base_url`` are\n     ``STATIC_ROOT`` and ``STATIC_URL``.\n     \"\"\"\n-    def __init__(self, location=None, base_url=None, *args, **kwargs):\n-        if location is None:\n-            location = settings.STATIC_ROOT\n-        if base_url is None:\n-            base_url = settings.STATIC_URL\n-        check_settings(base_url)\n-        super().__init__(location, base_url, *args, **kwargs)\n-        # FileSystemStorage fallbacks to MEDIA_ROOT when location\n-        # is empty, so we restore the empty value.\n-        if not location:\n-            self.base_location = None\n-            self.location = None\n+\n+def __init__(self, location=None, base_url=None, *args, **kwargs):\n+    if location is None:\n+        location = settings.STATIC_ROOT\n+    if base_url is None:\n+        base_url = settings.STATIC_URL\n+    check_settings(base_url)\n+    \n+    # Store original base_url for SCRIPT_NAME handling\n+    self._original_base_url = base_url\n+    \n+    super().__init__(location, base_url, *args, **kwargs)\n+    # FileSystemStorage fallbacks to MEDIA_ROOT when location\n+    # is empty, so we restore the empty value.\n+    if not location:\n+        self.base_location = None\n+        self.location = None\n+\n+@property\n+def base_url(self):\n+    \"\"\"Return base_url with SCRIPT_NAME prefix if available.\"\"\"\n+    from django.urls import get_script_prefix\n+    try:\n+        script_prefix = get_script_prefix()\n+        if script_prefix and script_prefix != '/':\n+            return script_prefix.rstrip('/') + self._original_base_url\n+    except:\n+        pass\n+    return self._original_base_url\n+\n+@base_url.setter  \n+def base_url(self, value):\n+    self._original_base_url = value\n \n     def path(self, name):\n         if not self.location:\ndiff --git a/django/core/files/storage.py b/django/core/files/storage.py\nindex 4c27fce605..35b0487dbe 100644\n--- a/django/core/files/storage.py\n+++ b/django/core/files/storage.py\n@@ -213,11 +213,30 @@ class FileSystemStorage(Storage):\n     def location(self):\n         return os.path.abspath(self.base_location)\n \n+    @cached_property\n+\n     @cached_property\n     def base_url(self):\n         if self._base_url is not None and not self._base_url.endswith('/'):\n             self._base_url += '/'\n-        return self._value_or_setting(self._base_url, settings.MEDIA_URL)\n+        \n+        base_url = self._value_or_setting(self._base_url, settings.MEDIA_URL)\n+        \n+        # Add SCRIPT_NAME prefix if available in current request context\n+        try:\n+            from django.urls import get_script_prefix\n+            script_prefix = get_script_prefix()\n+            if script_prefix and script_prefix != '/' and base_url:\n+                # Ensure script_prefix ends with '/' and base_url starts with '/'\n+                if not script_prefix.endswith('/'):\n+                    script_prefix += '/'\n+                if base_url.startswith('/'):\n+                    base_url = base_url[1:]\n+                base_url = script_prefix + base_url\n+        except ImportError:\n+            pass\n+        \n+        return base_url\n \n     @cached_property\n     def file_permissions_mode(self):\n@@ -326,13 +345,40 @@ class FileSystemStorage(Storage):\n     def size(self, name):\n         return os.path.getsize(self.path(name))\n \n+\n     def url(self, name):\n         if self.base_url is None:\n             raise ValueError(\"This file is not accessible via a URL.\")\n+        \n+        # Get SCRIPT_NAME from current request context if available\n+        script_name = ''\n+        try:\n+            from django.urls import get_script_prefix\n+            script_name = get_script_prefix()\n+        except (ImportError, RuntimeError):\n+            # Fallback: try to get from thread-local request\n+            try:\n+                from django.utils.deprecation import MiddlewareMixin\n+                from threading import local\n+                import threading\n+                if hasattr(threading.current_thread(), 'request'):\n+                    request = getattr(threading.current_thread(), 'request', None)\n+                    if request and hasattr(request, 'META'):\n+                        script_name = request.META.get('SCRIPT_NAME', '')\n+            except:\n+                pass\n+        \n+        # Ensure script_name ends with / if it exists and doesn't already\n+        if script_name and not script_name.endswith('/'):\n+            script_name += '/'\n+        \n         url = filepath_to_uri(name)\n         if url is not None:\n             url = url.lstrip('/')\n-        return urljoin(self.base_url, url)\n+        \n+        # Combine script_name with base_url for final URL\n+        base_url_with_script = urljoin(script_name, self.base_url.lstrip('/')) if script_name else self.base_url\n+        return urljoin(base_url_with_script, url)\n \n     def _datetime_from_timestamp(self, ts):\n         \"\"\"\ndiff --git a/django/templatetags/static.py b/django/templatetags/static.py\nindex 39712aaba0..1c8704a477 100644\n--- a/django/templatetags/static.py\n+++ b/django/templatetags/static.py\n@@ -36,6 +36,7 @@ class PrefixNode(template.Node):\n             varname = None\n         return cls(varname, name)\n \n+\n     @classmethod\n     def handle_simple(cls, name):\n         try:\n@@ -44,6 +45,23 @@ class PrefixNode(template.Node):\n             prefix = ''\n         else:\n             prefix = iri_to_uri(getattr(settings, name, ''))\n+            \n+            # Check for SCRIPT_NAME in current request context\n+            try:\n+                from django.core.context_processors import request as get_current_request\n+                from threading import current_thread\n+                from django.utils.deprecation import MiddlewareMixin\n+                \n+                # Try to get current request from thread local storage\n+                request = getattr(current_thread(), 'request', None)\n+                if request and hasattr(request, 'META'):\n+                    script_name = request.META.get('SCRIPT_NAME', '')\n+                    if script_name and not prefix.startswith(script_name):\n+                        prefix = script_name.rstrip('/') + '/' + prefix.lstrip('/')\n+            except (ImportError, AttributeError):\n+                # Fallback if request context is not available\n+                pass\n+                \n         return prefix\n \n     def render(self, context):\n@@ -111,13 +129,17 @@ class StaticNode(template.Node):\n         context[self.varname] = url\n         return ''\n \n+    @classmethod\n+\n     @classmethod\n     def handle_simple(cls, path):\n         if apps.is_installed('django.contrib.staticfiles'):\n             from django.contrib.staticfiles.storage import staticfiles_storage\n             return staticfiles_storage.url(path)\n         else:\n-            return urljoin(PrefixNode.handle_simple(\"STATIC_URL\"), quote(path))\n+            # Get SCRIPT_NAME-aware static URL from PrefixNode\n+            static_url = PrefixNode.handle_simple(\"STATIC_URL\")\n+            return urljoin(static_url, quote(path))\n \n     @classmethod\n     def handle_token(cls, parser, token):\n",
    "variant_2": "diff --git a/django/contrib/staticfiles/storage.py b/django/contrib/staticfiles/storage.py\nindex ba3b62620d..855b877674 100644\n--- a/django/contrib/staticfiles/storage.py\n+++ b/django/contrib/staticfiles/storage.py\n@@ -20,18 +20,49 @@ class StaticFilesStorage(FileSystemStorage):\n     The defaults for ``location`` and ``base_url`` are\n     ``STATIC_ROOT`` and ``STATIC_URL``.\n     \"\"\"\n-    def __init__(self, location=None, base_url=None, *args, **kwargs):\n-        if location is None:\n-            location = settings.STATIC_ROOT\n-        if base_url is None:\n-            base_url = settings.STATIC_URL\n-        check_settings(base_url)\n-        super().__init__(location, base_url, *args, **kwargs)\n-        # FileSystemStorage fallbacks to MEDIA_ROOT when location\n-        # is empty, so we restore the empty value.\n-        if not location:\n-            self.base_location = None\n-            self.location = None\n+\n+def __init__(self, location=None, base_url=None, *args, **kwargs):\n+    if location is None:\n+        location = settings.STATIC_ROOT\n+    if base_url is None:\n+        base_url = settings.STATIC_URL\n+    check_settings(base_url)\n+    \n+    # Store original base_url for SCRIPT_NAME handling\n+    self._original_base_url = base_url\n+    \n+    super().__init__(location, base_url, *args, **kwargs)\n+    # FileSystemStorage fallbacks to MEDIA_ROOT when location\n+    # is empty, so we restore the empty value.\n+    if not location:\n+        self.base_location = None\n+        self.location = None\n+\n+@property\n+def base_url(self):\n+    \"\"\"Return base_url with SCRIPT_NAME prefix if available.\"\"\"\n+    base = self._original_base_url\n+    if not base:\n+        return base\n+    \n+    # Try to get SCRIPT_NAME from current request context\n+    try:\n+        from django.urls import get_script_prefix\n+        script_prefix = get_script_prefix()\n+        if script_prefix and script_prefix != '/':\n+            # Ensure proper URL joining\n+            if base.startswith('/'):\n+                base = base[1:]\n+            return script_prefix.rstrip('/') + '/' + base.lstrip('/')\n+    except Exception:\n+        pass\n+    \n+    return base\n+\n+@base_url.setter\n+def base_url(self, value):\n+    \"\"\"Set the original base_url value.\"\"\"\n+    self._original_base_url = value\n \n     def path(self, name):\n         if not self.location:\ndiff --git a/django/core/files/storage.py b/django/core/files/storage.py\nindex 4c27fce605..8f022c4456 100644\n--- a/django/core/files/storage.py\n+++ b/django/core/files/storage.py\n@@ -213,11 +213,29 @@ class FileSystemStorage(Storage):\n     def location(self):\n         return os.path.abspath(self.base_location)\n \n+    @cached_property\n+\n     @cached_property\n     def base_url(self):\n         if self._base_url is not None and not self._base_url.endswith('/'):\n             self._base_url += '/'\n-        return self._value_or_setting(self._base_url, settings.MEDIA_URL)\n+        base_url = self._value_or_setting(self._base_url, settings.MEDIA_URL)\n+        \n+        # Add SCRIPT_NAME awareness for proper URL generation in sub-path deployments\n+        try:\n+            from django.urls import get_script_prefix\n+            script_prefix = get_script_prefix()\n+            if script_prefix and script_prefix != '/' and base_url:\n+                # Ensure script_prefix ends with '/' and base_url starts with '/'\n+                if not script_prefix.endswith('/'):\n+                    script_prefix += '/'\n+                if not base_url.startswith('/'):\n+                    base_url = '/' + base_url\n+                base_url = script_prefix.rstrip('/') + base_url\n+        except ImportError:\n+            pass\n+            \n+        return base_url\n \n     @cached_property\n     def file_permissions_mode(self):\n@@ -326,13 +344,27 @@ class FileSystemStorage(Storage):\n     def size(self, name):\n         return os.path.getsize(self.path(name))\n \n+\n     def url(self, name):\n         if self.base_url is None:\n             raise ValueError(\"This file is not accessible via a URL.\")\n         url = filepath_to_uri(name)\n         if url is not None:\n             url = url.lstrip('/')\n-        return urljoin(self.base_url, url)\n+        \n+        # Get SCRIPT_NAME from current request context if available\n+        from django.urls import get_script_prefix\n+        script_prefix = get_script_prefix()\n+        \n+        # Ensure base_url includes script prefix\n+        base_url = self.base_url\n+        if script_prefix and script_prefix != '/' and not base_url.startswith(script_prefix):\n+            # Remove leading slash from base_url if present to avoid double slashes\n+            if base_url.startswith('/'):\n+                base_url = base_url[1:]\n+            base_url = urljoin(script_prefix, base_url)\n+        \n+        return urljoin(base_url, url)\n \n     def _datetime_from_timestamp(self, ts):\n         \"\"\"\ndiff --git a/django/templatetags/static.py b/django/templatetags/static.py\nindex 39712aaba0..18a0e03aa1 100644\n--- a/django/templatetags/static.py\n+++ b/django/templatetags/static.py\n@@ -36,15 +36,29 @@ class PrefixNode(template.Node):\n             varname = None\n         return cls(varname, name)\n \n-    @classmethod\n-    def handle_simple(cls, name):\n-        try:\n-            from django.conf import settings\n-        except ImportError:\n-            prefix = ''\n-        else:\n-            prefix = iri_to_uri(getattr(settings, name, ''))\n-        return prefix\n+\n+@classmethod\n+def handle_simple(cls, name):\n+    try:\n+        from django.conf import settings\n+    except ImportError:\n+        prefix = ''\n+    else:\n+        prefix = iri_to_uri(getattr(settings, name, ''))\n+        \n+    # Add SCRIPT_NAME support for reverse proxy deployments\n+    try:\n+        from django.core.context_processors import request\n+        from threading import current_thread\n+        # Try to get SCRIPT_NAME from current request context\n+        if hasattr(current_thread(), 'request'):\n+            script_name = getattr(current_thread().request, 'META', {}).get('SCRIPT_NAME', '')\n+            if script_name and not prefix.startswith(script_name):\n+                prefix = script_name.rstrip('/') + prefix\n+    except (ImportError, AttributeError):\n+        pass\n+        \n+    return prefix\n \n     def render(self, context):\n         prefix = self.handle_simple(self.name)\n@@ -111,13 +125,17 @@ class StaticNode(template.Node):\n         context[self.varname] = url\n         return ''\n \n+    @classmethod\n+\n     @classmethod\n     def handle_simple(cls, path):\n         if apps.is_installed('django.contrib.staticfiles'):\n             from django.contrib.staticfiles.storage import staticfiles_storage\n             return staticfiles_storage.url(path)\n         else:\n-            return urljoin(PrefixNode.handle_simple(\"STATIC_URL\"), quote(path))\n+            # Get SCRIPT_NAME-aware STATIC_URL from PrefixNode\n+            static_url = PrefixNode.handle_simple(\"STATIC_URL\")\n+            return urljoin(static_url, quote(path))\n \n     @classmethod\n     def handle_token(cls, parser, token):\n",
    "variant_3": "diff --git a/django/contrib/staticfiles/storage.py b/django/contrib/staticfiles/storage.py\nindex ba3b62620d..2ae9397178 100644\n--- a/django/contrib/staticfiles/storage.py\n+++ b/django/contrib/staticfiles/storage.py\n@@ -20,18 +20,44 @@ class StaticFilesStorage(FileSystemStorage):\n     The defaults for ``location`` and ``base_url`` are\n     ``STATIC_ROOT`` and ``STATIC_URL``.\n     \"\"\"\n-    def __init__(self, location=None, base_url=None, *args, **kwargs):\n-        if location is None:\n-            location = settings.STATIC_ROOT\n-        if base_url is None:\n-            base_url = settings.STATIC_URL\n-        check_settings(base_url)\n-        super().__init__(location, base_url, *args, **kwargs)\n-        # FileSystemStorage fallbacks to MEDIA_ROOT when location\n-        # is empty, so we restore the empty value.\n-        if not location:\n-            self.base_location = None\n-            self.location = None\n+\n+def __init__(self, location=None, base_url=None, *args, **kwargs):\n+    if location is None:\n+        location = settings.STATIC_ROOT\n+    if base_url is None:\n+        base_url = settings.STATIC_URL\n+    check_settings(base_url)\n+    \n+    # Store original base_url for SCRIPT_NAME handling\n+    self._original_base_url = base_url\n+    \n+    super().__init__(location, base_url, *args, **kwargs)\n+    # FileSystemStorage fallbacks to MEDIA_ROOT when location\n+    # is empty, so we restore the empty value.\n+    if not location:\n+        self.base_location = None\n+        self.location = None\n+\n+@property\n+def base_url(self):\n+    \"\"\"Return base_url with SCRIPT_NAME prefix if available.\"\"\"\n+    from django.urls import get_script_prefix\n+    \n+    base_url = self._original_base_url or ''\n+    if base_url and not base_url.startswith(('http://', 'https://', '//')):\n+        script_prefix = get_script_prefix()\n+        if script_prefix and script_prefix != '/':\n+            # Remove trailing slash from script_prefix and ensure base_url starts with /\n+            script_prefix = script_prefix.rstrip('/')\n+            if not base_url.startswith('/'):\n+                base_url = '/' + base_url\n+            base_url = script_prefix + base_url\n+    return base_url\n+\n+@base_url.setter\n+def base_url(self, value):\n+    \"\"\"Set the original base_url value.\"\"\"\n+    self._original_base_url = value\n \n     def path(self, name):\n         if not self.location:\ndiff --git a/django/core/files/storage.py b/django/core/files/storage.py\nindex 4c27fce605..7f119e3f57 100644\n--- a/django/core/files/storage.py\n+++ b/django/core/files/storage.py\n@@ -213,11 +213,30 @@ class FileSystemStorage(Storage):\n     def location(self):\n         return os.path.abspath(self.base_location)\n \n+    @cached_property\n+\n     @cached_property\n     def base_url(self):\n         if self._base_url is not None and not self._base_url.endswith('/'):\n             self._base_url += '/'\n-        return self._value_or_setting(self._base_url, settings.MEDIA_URL)\n+        base_url = self._value_or_setting(self._base_url, settings.MEDIA_URL)\n+        \n+        # Add SCRIPT_NAME support for proper URL generation in sub-path deployments\n+        try:\n+            from django.urls import get_script_prefix\n+            script_prefix = get_script_prefix()\n+            if script_prefix and script_prefix != '/' and base_url:\n+                # Ensure script_prefix ends with '/' and base_url starts with '/'\n+                if not script_prefix.endswith('/'):\n+                    script_prefix += '/'\n+                if base_url.startswith('/'):\n+                    base_url = script_prefix + base_url[1:]\n+                else:\n+                    base_url = script_prefix + base_url\n+        except ImportError:\n+            pass\n+        \n+        return base_url\n \n     @cached_property\n     def file_permissions_mode(self):\n@@ -326,13 +345,26 @@ class FileSystemStorage(Storage):\n     def size(self, name):\n         return os.path.getsize(self.path(name))\n \n+\n     def url(self, name):\n         if self.base_url is None:\n             raise ValueError(\"This file is not accessible via a URL.\")\n+        \n+        # Get SCRIPT_NAME from current request context if available\n+        from django.urls import get_script_prefix\n+        script_prefix = get_script_prefix()\n+        \n         url = filepath_to_uri(name)\n         if url is not None:\n             url = url.lstrip('/')\n-        return urljoin(self.base_url, url)\n+        \n+        # Ensure base_url includes script prefix for proper URL construction\n+        base_url = self.base_url\n+        if script_prefix and script_prefix != '/' and not base_url.startswith(script_prefix):\n+            # Only prepend if base_url doesn't already include the script prefix\n+            base_url = script_prefix.rstrip('/') + '/' + base_url.lstrip('/')\n+        \n+        return urljoin(base_url, url)\n \n     def _datetime_from_timestamp(self, ts):\n         \"\"\"\ndiff --git a/django/templatetags/static.py b/django/templatetags/static.py\nindex 39712aaba0..00473c2ff3 100644\n--- a/django/templatetags/static.py\n+++ b/django/templatetags/static.py\n@@ -36,6 +36,7 @@ class PrefixNode(template.Node):\n             varname = None\n         return cls(varname, name)\n \n+\n     @classmethod\n     def handle_simple(cls, name):\n         try:\n@@ -44,6 +45,21 @@ class PrefixNode(template.Node):\n             prefix = ''\n         else:\n             prefix = iri_to_uri(getattr(settings, name, ''))\n+            \n+            # Add SCRIPT_NAME awareness for reverse proxy deployments\n+            try:\n+                from django.core.context_processors import request\n+                from threading import current_thread\n+                \n+                # Try to get SCRIPT_NAME from current request context\n+                if hasattr(current_thread(), 'request'):\n+                    script_name = getattr(current_thread().request, 'META', {}).get('SCRIPT_NAME', '')\n+                    if script_name and not prefix.startswith(script_name):\n+                        prefix = script_name.rstrip('/') + '/' + prefix.lstrip('/')\n+            except (ImportError, AttributeError):\n+                # Fallback: try to get from template context if available\n+                pass\n+                \n         return prefix\n \n     def render(self, context):\n@@ -111,13 +127,17 @@ class StaticNode(template.Node):\n         context[self.varname] = url\n         return ''\n \n+    @classmethod\n+\n     @classmethod\n     def handle_simple(cls, path):\n         if apps.is_installed('django.contrib.staticfiles'):\n             from django.contrib.staticfiles.storage import staticfiles_storage\n             return staticfiles_storage.url(path)\n         else:\n-            return urljoin(PrefixNode.handle_simple(\"STATIC_URL\"), quote(path))\n+            # Get the base static URL with SCRIPT_NAME awareness\n+            base_url = PrefixNode.handle_simple(\"STATIC_URL\")\n+            return urljoin(base_url, quote(path))\n \n     @classmethod\n     def handle_token(cls, parser, token):\n",
    "variant_4": "diff --git a/django/contrib/staticfiles/storage.py b/django/contrib/staticfiles/storage.py\nindex ba3b62620d..d4b5d128cf 100644\n--- a/django/contrib/staticfiles/storage.py\n+++ b/django/contrib/staticfiles/storage.py\n@@ -20,18 +20,54 @@ class StaticFilesStorage(FileSystemStorage):\n     The defaults for ``location`` and ``base_url`` are\n     ``STATIC_ROOT`` and ``STATIC_URL``.\n     \"\"\"\n-    def __init__(self, location=None, base_url=None, *args, **kwargs):\n-        if location is None:\n-            location = settings.STATIC_ROOT\n-        if base_url is None:\n-            base_url = settings.STATIC_URL\n-        check_settings(base_url)\n-        super().__init__(location, base_url, *args, **kwargs)\n-        # FileSystemStorage fallbacks to MEDIA_ROOT when location\n-        # is empty, so we restore the empty value.\n-        if not location:\n-            self.base_location = None\n-            self.location = None\n+\n+def __init__(self, location=None, base_url=None, *args, **kwargs):\n+    if location is None:\n+        location = settings.STATIC_ROOT\n+    if base_url is None:\n+        base_url = settings.STATIC_URL\n+    check_settings(base_url)\n+    \n+    # Store original base_url for SCRIPT_NAME handling\n+    self._original_base_url = base_url\n+    \n+    super().__init__(location, base_url, *args, **kwargs)\n+    # FileSystemStorage fallbacks to MEDIA_ROOT when location\n+    # is empty, so we restore the empty value.\n+    if not location:\n+        self.base_location = None\n+        self.location = None\n+\n+@property\n+def base_url(self):\n+    \"\"\"Return base_url with SCRIPT_NAME prefix if available.\"\"\"\n+    base = self._original_base_url or ''\n+    \n+    # Try to get SCRIPT_NAME from current request context\n+    try:\n+        from django.utils.deprecation import MiddlewareMixin\n+        import threading\n+        \n+        # Access current request from thread local if available\n+        request = getattr(threading.current_thread(), 'request', None)\n+        if request and hasattr(request, 'META'):\n+            script_name = request.META.get('SCRIPT_NAME', '')\n+            if script_name and not base.startswith(script_name):\n+                # Ensure SCRIPT_NAME ends with / and base starts with /\n+                if not script_name.endswith('/'):\n+                    script_name += '/'\n+                if base.startswith('/'):\n+                    base = base[1:]\n+                return script_name + base\n+    except (ImportError, AttributeError):\n+        pass\n+    \n+    return base\n+\n+@base_url.setter\n+def base_url(self, value):\n+    \"\"\"Store the original base_url value.\"\"\"\n+    self._original_base_url = value\n \n     def path(self, name):\n         if not self.location:\ndiff --git a/django/core/files/storage.py b/django/core/files/storage.py\nindex 4c27fce605..bba0fe56b2 100644\n--- a/django/core/files/storage.py\n+++ b/django/core/files/storage.py\n@@ -213,11 +213,29 @@ class FileSystemStorage(Storage):\n     def location(self):\n         return os.path.abspath(self.base_location)\n \n+    @cached_property\n+\n     @cached_property\n     def base_url(self):\n         if self._base_url is not None and not self._base_url.endswith('/'):\n             self._base_url += '/'\n-        return self._value_or_setting(self._base_url, settings.MEDIA_URL)\n+        base_url = self._value_or_setting(self._base_url, settings.MEDIA_URL)\n+        \n+        # Add SCRIPT_NAME support for URL generation\n+        try:\n+            from django.urls import get_script_prefix\n+            script_prefix = get_script_prefix()\n+            if script_prefix and script_prefix != '/' and base_url:\n+                # Ensure script_prefix ends with '/' and base_url starts with '/'\n+                if not script_prefix.endswith('/'):\n+                    script_prefix += '/'\n+                if base_url.startswith('/'):\n+                    base_url = base_url[1:]\n+                base_url = script_prefix + base_url\n+        except ImportError:\n+            pass\n+        \n+        return base_url\n \n     @cached_property\n     def file_permissions_mode(self):\n@@ -326,13 +344,32 @@ class FileSystemStorage(Storage):\n     def size(self, name):\n         return os.path.getsize(self.path(name))\n \n+\n     def url(self, name):\n         if self.base_url is None:\n             raise ValueError(\"This file is not accessible via a URL.\")\n         url = filepath_to_uri(name)\n         if url is not None:\n             url = url.lstrip('/')\n-        return urljoin(self.base_url, url)\n+        \n+        # Get SCRIPT_NAME from current request context if available\n+        from django.core.context_processors import request\n+        try:\n+            from django.http import HttpRequest\n+            import threading\n+            local = getattr(threading.current_thread(), 'request', None)\n+            if hasattr(local, 'META') and 'SCRIPT_NAME' in local.META:\n+                script_name = local.META['SCRIPT_NAME'].rstrip('/')\n+                if script_name and not self.base_url.startswith(script_name):\n+                    base_url = script_name + self.base_url\n+                else:\n+                    base_url = self.base_url\n+            else:\n+                base_url = self.base_url\n+        except (ImportError, AttributeError):\n+            base_url = self.base_url\n+            \n+        return urljoin(base_url, url)\n \n     def _datetime_from_timestamp(self, ts):\n         \"\"\"\ndiff --git a/django/templatetags/static.py b/django/templatetags/static.py\nindex 39712aaba0..8a29bc3ee4 100644\n--- a/django/templatetags/static.py\n+++ b/django/templatetags/static.py\n@@ -36,15 +36,30 @@ class PrefixNode(template.Node):\n             varname = None\n         return cls(varname, name)\n \n-    @classmethod\n-    def handle_simple(cls, name):\n-        try:\n-            from django.conf import settings\n-        except ImportError:\n-            prefix = ''\n-        else:\n-            prefix = iri_to_uri(getattr(settings, name, ''))\n-        return prefix\n+\n+@classmethod\n+def handle_simple(cls, name):\n+    try:\n+        from django.conf import settings\n+    except ImportError:\n+        prefix = ''\n+    else:\n+        prefix = iri_to_uri(getattr(settings, name, ''))\n+        \n+    # Add SCRIPT_NAME awareness for proper URL generation in sub-path deployments\n+    try:\n+        from django.urls import get_script_prefix\n+        script_prefix = get_script_prefix()\n+        if script_prefix and script_prefix != '/':\n+            # Remove trailing slash from script_prefix to avoid double slashes\n+            script_prefix = script_prefix.rstrip('/')\n+            # Only prepend if prefix doesn't already start with script_prefix\n+            if prefix and not prefix.startswith(script_prefix):\n+                prefix = script_prefix + prefix\n+    except ImportError:\n+        pass\n+        \n+    return prefix\n \n     def render(self, context):\n         prefix = self.handle_simple(self.name)\n@@ -111,13 +126,17 @@ class StaticNode(template.Node):\n         context[self.varname] = url\n         return ''\n \n+    @classmethod\n+\n     @classmethod\n     def handle_simple(cls, path):\n         if apps.is_installed('django.contrib.staticfiles'):\n             from django.contrib.staticfiles.storage import staticfiles_storage\n             return staticfiles_storage.url(path)\n         else:\n-            return urljoin(PrefixNode.handle_simple(\"STATIC_URL\"), quote(path))\n+            # Get SCRIPT_NAME-aware STATIC_URL from PrefixNode\n+            static_url = PrefixNode.handle_simple(\"STATIC_URL\")\n+            return urljoin(static_url, quote(path))\n \n     @classmethod\n     def handle_token(cls, parser, token):\n",
    "variant_5": "diff --git a/django/contrib/staticfiles/storage.py b/django/contrib/staticfiles/storage.py\nindex ba3b62620d..855b877674 100644\n--- a/django/contrib/staticfiles/storage.py\n+++ b/django/contrib/staticfiles/storage.py\n@@ -20,18 +20,49 @@ class StaticFilesStorage(FileSystemStorage):\n     The defaults for ``location`` and ``base_url`` are\n     ``STATIC_ROOT`` and ``STATIC_URL``.\n     \"\"\"\n-    def __init__(self, location=None, base_url=None, *args, **kwargs):\n-        if location is None:\n-            location = settings.STATIC_ROOT\n-        if base_url is None:\n-            base_url = settings.STATIC_URL\n-        check_settings(base_url)\n-        super().__init__(location, base_url, *args, **kwargs)\n-        # FileSystemStorage fallbacks to MEDIA_ROOT when location\n-        # is empty, so we restore the empty value.\n-        if not location:\n-            self.base_location = None\n-            self.location = None\n+\n+def __init__(self, location=None, base_url=None, *args, **kwargs):\n+    if location is None:\n+        location = settings.STATIC_ROOT\n+    if base_url is None:\n+        base_url = settings.STATIC_URL\n+    check_settings(base_url)\n+    \n+    # Store original base_url for SCRIPT_NAME handling\n+    self._original_base_url = base_url\n+    \n+    super().__init__(location, base_url, *args, **kwargs)\n+    # FileSystemStorage fallbacks to MEDIA_ROOT when location\n+    # is empty, so we restore the empty value.\n+    if not location:\n+        self.base_location = None\n+        self.location = None\n+\n+@property\n+def base_url(self):\n+    \"\"\"Return base_url with SCRIPT_NAME prefix if available.\"\"\"\n+    base = self._original_base_url\n+    if not base:\n+        return base\n+    \n+    # Try to get SCRIPT_NAME from current request context\n+    try:\n+        from django.urls import get_script_prefix\n+        script_prefix = get_script_prefix()\n+        if script_prefix and script_prefix != '/':\n+            # Ensure proper URL joining\n+            if base.startswith('/'):\n+                base = base[1:]\n+            return script_prefix.rstrip('/') + '/' + base.lstrip('/')\n+    except Exception:\n+        pass\n+    \n+    return base\n+\n+@base_url.setter\n+def base_url(self, value):\n+    \"\"\"Set the original base_url value.\"\"\"\n+    self._original_base_url = value\n \n     def path(self, name):\n         if not self.location:\ndiff --git a/django/core/files/storage.py b/django/core/files/storage.py\nindex 4c27fce605..c05977bf58 100644\n--- a/django/core/files/storage.py\n+++ b/django/core/files/storage.py\n@@ -213,11 +213,30 @@ class FileSystemStorage(Storage):\n     def location(self):\n         return os.path.abspath(self.base_location)\n \n+    @cached_property\n+\n     @cached_property\n     def base_url(self):\n         if self._base_url is not None and not self._base_url.endswith('/'):\n             self._base_url += '/'\n-        return self._value_or_setting(self._base_url, settings.MEDIA_URL)\n+        base_url = self._value_or_setting(self._base_url, settings.MEDIA_URL)\n+        \n+        # Add SCRIPT_NAME support for proper URL generation in sub-path deployments\n+        try:\n+            from django.urls import get_script_prefix\n+            script_prefix = get_script_prefix()\n+            if script_prefix and script_prefix != '/' and base_url:\n+                # Ensure script_prefix ends with '/' and base_url doesn't start with '/'\n+                if not script_prefix.endswith('/'):\n+                    script_prefix += '/'\n+                if base_url.startswith('/'):\n+                    base_url = base_url[1:]\n+                base_url = script_prefix + base_url\n+        except ImportError:\n+            # Fallback if get_script_prefix is not available\n+            pass\n+            \n+        return base_url\n \n     @cached_property\n     def file_permissions_mode(self):\n@@ -326,12 +345,29 @@ class FileSystemStorage(Storage):\n     def size(self, name):\n         return os.path.getsize(self.path(name))\n \n+\n     def url(self, name):\n         if self.base_url is None:\n             raise ValueError(\"This file is not accessible via a URL.\")\n         url = filepath_to_uri(name)\n         if url is not None:\n             url = url.lstrip('/')\n+        \n+        # Get SCRIPT_NAME from current request if available\n+        from django.core.context_processors import request\n+        try:\n+            from django.http import HttpRequest\n+            # Try to get current request from thread locals\n+            import threading\n+            local = getattr(threading.current_thread(), 'request', None)\n+            if hasattr(local, 'META') and 'SCRIPT_NAME' in local.META:\n+                script_name = local.META['SCRIPT_NAME'].rstrip('/')\n+                if script_name:\n+                    base_url = script_name + self.base_url\n+                    return urljoin(base_url, url)\n+        except (ImportError, AttributeError):\n+            pass\n+            \n         return urljoin(self.base_url, url)\n \n     def _datetime_from_timestamp(self, ts):\ndiff --git a/django/templatetags/static.py b/django/templatetags/static.py\nindex 39712aaba0..041b15b5eb 100644\n--- a/django/templatetags/static.py\n+++ b/django/templatetags/static.py\n@@ -36,6 +36,7 @@ class PrefixNode(template.Node):\n             varname = None\n         return cls(varname, name)\n \n+\n     @classmethod\n     def handle_simple(cls, name):\n         try:\n@@ -44,6 +45,22 @@ class PrefixNode(template.Node):\n             prefix = ''\n         else:\n             prefix = iri_to_uri(getattr(settings, name, ''))\n+            \n+            # Add SCRIPT_NAME support for proper URL generation in subdirectory deployments\n+            try:\n+                from django.http import HttpRequest\n+                from threading import current_thread\n+                \n+                # Try to get SCRIPT_NAME from current request context\n+                request = getattr(current_thread(), 'request', None)\n+                if hasattr(request, 'META') and 'SCRIPT_NAME' in request.META:\n+                    script_name = request.META['SCRIPT_NAME'].rstrip('/')\n+                    if script_name and not prefix.startswith(script_name):\n+                        prefix = script_name + prefix\n+            except (ImportError, AttributeError):\n+                # Fallback: try to get from template context if available\n+                pass\n+                \n         return prefix\n \n     def render(self, context):\n@@ -111,13 +128,17 @@ class StaticNode(template.Node):\n         context[self.varname] = url\n         return ''\n \n+    @classmethod\n+\n     @classmethod\n     def handle_simple(cls, path):\n         if apps.is_installed('django.contrib.staticfiles'):\n             from django.contrib.staticfiles.storage import staticfiles_storage\n             return staticfiles_storage.url(path)\n         else:\n-            return urljoin(PrefixNode.handle_simple(\"STATIC_URL\"), quote(path))\n+            # Get SCRIPT_NAME-aware static URL prefix\n+            static_prefix = PrefixNode.handle_simple(\"STATIC_URL\")\n+            return urljoin(static_prefix, quote(path))\n \n     @classmethod\n     def handle_token(cls, parser, token):\n",
    "variant_6": "diff --git a/django/contrib/staticfiles/storage.py b/django/contrib/staticfiles/storage.py\nindex ba3b62620d..a4779314f7 100644\n--- a/django/contrib/staticfiles/storage.py\n+++ b/django/contrib/staticfiles/storage.py\n@@ -20,18 +20,50 @@ class StaticFilesStorage(FileSystemStorage):\n     The defaults for ``location`` and ``base_url`` are\n     ``STATIC_ROOT`` and ``STATIC_URL``.\n     \"\"\"\n-    def __init__(self, location=None, base_url=None, *args, **kwargs):\n-        if location is None:\n-            location = settings.STATIC_ROOT\n-        if base_url is None:\n-            base_url = settings.STATIC_URL\n-        check_settings(base_url)\n-        super().__init__(location, base_url, *args, **kwargs)\n-        # FileSystemStorage fallbacks to MEDIA_ROOT when location\n-        # is empty, so we restore the empty value.\n-        if not location:\n-            self.base_location = None\n-            self.location = None\n+\n+def __init__(self, location=None, base_url=None, *args, **kwargs):\n+    if location is None:\n+        location = settings.STATIC_ROOT\n+    if base_url is None:\n+        base_url = settings.STATIC_URL\n+    check_settings(base_url)\n+    \n+    # Store original base_url for SCRIPT_NAME handling\n+    self._original_base_url = base_url\n+    \n+    super().__init__(location, base_url, *args, **kwargs)\n+    # FileSystemStorage fallbacks to MEDIA_ROOT when location\n+    # is empty, so we restore the empty value.\n+    if not location:\n+        self.base_location = None\n+        self.location = None\n+\n+@property\n+def base_url(self):\n+    \"\"\"Return base_url with SCRIPT_NAME prefix if available.\"\"\"\n+    base = self._original_base_url\n+    if not base:\n+        return base\n+    \n+    # Try to get SCRIPT_NAME from current request context\n+    try:\n+        from django.urls import get_script_prefix\n+        script_prefix = get_script_prefix()\n+        if script_prefix and script_prefix != '/':\n+            # Ensure proper URL joining\n+            if not base.startswith('/'):\n+                base = '/' + base\n+            base = script_prefix.rstrip('/') + base\n+    except Exception:\n+        # Fallback to original base_url if context unavailable\n+        pass\n+    \n+    return base\n+\n+@base_url.setter\n+def base_url(self, value):\n+    \"\"\"Set the original base_url value.\"\"\"\n+    self._original_base_url = value\n \n     def path(self, name):\n         if not self.location:\ndiff --git a/django/core/files/storage.py b/django/core/files/storage.py\nindex 4c27fce605..c5fc1dca2e 100644\n--- a/django/core/files/storage.py\n+++ b/django/core/files/storage.py\n@@ -213,11 +213,27 @@ class FileSystemStorage(Storage):\n     def location(self):\n         return os.path.abspath(self.base_location)\n \n+    @cached_property\n+\n     @cached_property\n     def base_url(self):\n         if self._base_url is not None and not self._base_url.endswith('/'):\n             self._base_url += '/'\n-        return self._value_or_setting(self._base_url, settings.MEDIA_URL)\n+        base_url = self._value_or_setting(self._base_url, settings.MEDIA_URL)\n+        \n+        # Add SCRIPT_NAME support for proper URL generation in subpath deployments\n+        try:\n+            from django.urls import get_script_prefix\n+            script_prefix = get_script_prefix()\n+            if script_prefix and script_prefix != '/' and base_url:\n+                # Remove leading slash from base_url if present to avoid double slashes\n+                if base_url.startswith('/'):\n+                    base_url = base_url[1:]\n+                base_url = urljoin(script_prefix, base_url)\n+        except ImportError:\n+            pass\n+        \n+        return base_url\n \n     @cached_property\n     def file_permissions_mode(self):\n@@ -326,13 +342,30 @@ class FileSystemStorage(Storage):\n     def size(self, name):\n         return os.path.getsize(self.path(name))\n \n+\n     def url(self, name):\n         if self.base_url is None:\n             raise ValueError(\"This file is not accessible via a URL.\")\n+        \n+        # Get SCRIPT_NAME from current request context if available\n+        script_name = ''\n+        try:\n+            from django.urls import get_script_prefix\n+            script_name = get_script_prefix()\n+        except ImportError:\n+            pass\n+        \n         url = filepath_to_uri(name)\n         if url is not None:\n             url = url.lstrip('/')\n-        return urljoin(self.base_url, url)\n+        \n+        # Combine script_name with base_url for proper URL construction\n+        if script_name and not self.base_url.startswith(script_name):\n+            full_base_url = script_name.rstrip('/') + '/' + self.base_url.lstrip('/')\n+        else:\n+            full_base_url = self.base_url\n+            \n+        return urljoin(full_base_url, url)\n \n     def _datetime_from_timestamp(self, ts):\n         \"\"\"\ndiff --git a/django/templatetags/static.py b/django/templatetags/static.py\nindex 39712aaba0..be211fd2b9 100644\n--- a/django/templatetags/static.py\n+++ b/django/templatetags/static.py\n@@ -36,15 +36,24 @@ class PrefixNode(template.Node):\n             varname = None\n         return cls(varname, name)\n \n-    @classmethod\n-    def handle_simple(cls, name):\n+\n+@classmethod\n+def handle_simple(cls, name):\n+    try:\n+        from django.conf import settings\n+    except ImportError:\n+        prefix = ''\n+    else:\n+        prefix = iri_to_uri(getattr(settings, name, ''))\n+        # Add SCRIPT_NAME support for URL prefixing\n         try:\n-            from django.conf import settings\n-        except ImportError:\n-            prefix = ''\n-        else:\n-            prefix = iri_to_uri(getattr(settings, name, ''))\n-        return prefix\n+            from django.urls import get_script_prefix\n+            script_prefix = get_script_prefix()\n+            if script_prefix and script_prefix != '/':\n+                prefix = urljoin(script_prefix.rstrip('/') + '/', prefix.lstrip('/'))\n+        except (ImportError, AttributeError):\n+            pass\n+    return prefix\n \n     def render(self, context):\n         prefix = self.handle_simple(self.name)\n@@ -111,13 +120,17 @@ class StaticNode(template.Node):\n         context[self.varname] = url\n         return ''\n \n+    @classmethod\n+\n     @classmethod\n     def handle_simple(cls, path):\n         if apps.is_installed('django.contrib.staticfiles'):\n             from django.contrib.staticfiles.storage import staticfiles_storage\n             return staticfiles_storage.url(path)\n         else:\n-            return urljoin(PrefixNode.handle_simple(\"STATIC_URL\"), quote(path))\n+            # Get the base static URL with SCRIPT_NAME awareness\n+            base_url = PrefixNode.handle_simple(\"STATIC_URL\")\n+            return urljoin(base_url, quote(path))\n \n     @classmethod\n     def handle_token(cls, parser, token):\n",
    "variant_7": "diff --git a/django/contrib/staticfiles/storage.py b/django/contrib/staticfiles/storage.py\nindex ba3b62620d..1619fa37be 100644\n--- a/django/contrib/staticfiles/storage.py\n+++ b/django/contrib/staticfiles/storage.py\n@@ -20,18 +20,50 @@ class StaticFilesStorage(FileSystemStorage):\n     The defaults for ``location`` and ``base_url`` are\n     ``STATIC_ROOT`` and ``STATIC_URL``.\n     \"\"\"\n-    def __init__(self, location=None, base_url=None, *args, **kwargs):\n-        if location is None:\n-            location = settings.STATIC_ROOT\n-        if base_url is None:\n-            base_url = settings.STATIC_URL\n-        check_settings(base_url)\n-        super().__init__(location, base_url, *args, **kwargs)\n-        # FileSystemStorage fallbacks to MEDIA_ROOT when location\n-        # is empty, so we restore the empty value.\n-        if not location:\n-            self.base_location = None\n-            self.location = None\n+\n+def __init__(self, location=None, base_url=None, *args, **kwargs):\n+    if location is None:\n+        location = settings.STATIC_ROOT\n+    if base_url is None:\n+        base_url = settings.STATIC_URL\n+    check_settings(base_url)\n+    \n+    # Store original base_url for SCRIPT_NAME handling\n+    self._original_base_url = base_url\n+    \n+    super().__init__(location, base_url, *args, **kwargs)\n+    # FileSystemStorage fallbacks to MEDIA_ROOT when location\n+    # is empty, so we restore the empty value.\n+    if not location:\n+        self.base_location = None\n+        self.location = None\n+\n+@property\n+def base_url(self):\n+    \"\"\"Return base URL with SCRIPT_NAME prefix when available.\"\"\"\n+    from django.core.context_processors import request\n+    try:\n+        # Try to get current request from thread locals\n+        from threading import current_thread\n+        for frame_record in __import__('inspect').stack():\n+            frame_locals = frame_record.frame.f_locals\n+            if 'request' in frame_locals:\n+                request_obj = frame_locals['request']\n+                if hasattr(request_obj, 'META'):\n+                    script_name = request_obj.META.get('SCRIPT_NAME', '')\n+                    if script_name and self._original_base_url:\n+                        # Ensure script_name ends with / and base_url is properly joined\n+                        if not script_name.endswith('/'):\n+                            script_name += '/'\n+                        return script_name.rstrip('/') + self._original_base_url\n+                    break\n+    except:\n+        pass\n+    return self._original_base_url\n+\n+@base_url.setter\n+def base_url(self, value):\n+    self._original_base_url = value\n \n     def path(self, name):\n         if not self.location:\ndiff --git a/django/core/files/storage.py b/django/core/files/storage.py\nindex 4c27fce605..f9742028c6 100644\n--- a/django/core/files/storage.py\n+++ b/django/core/files/storage.py\n@@ -213,11 +213,42 @@ class FileSystemStorage(Storage):\n     def location(self):\n         return os.path.abspath(self.base_location)\n \n+    @cached_property\n+\n     @cached_property\n     def base_url(self):\n         if self._base_url is not None and not self._base_url.endswith('/'):\n             self._base_url += '/'\n-        return self._value_or_setting(self._base_url, settings.MEDIA_URL)\n+        \n+        base_url = self._value_or_setting(self._base_url, settings.MEDIA_URL)\n+        \n+        # Check for SCRIPT_NAME in the current request context\n+        try:\n+            from django.core.context_processors import request\n+            from threading import current_thread\n+            \n+            # Try to get SCRIPT_NAME from thread-local storage\n+            if hasattr(current_thread(), 'request'):\n+                script_name = getattr(current_thread().request, 'META', {}).get('SCRIPT_NAME', '')\n+                if script_name and not script_name.endswith('/'):\n+                    script_name += '/'\n+                if script_name and base_url:\n+                    base_url = script_name.rstrip('/') + base_url\n+        except (ImportError, AttributeError):\n+            # Fallback: try to get from Django's current request if available\n+            try:\n+                from django.utils.deprecation import MiddlewareMixin\n+                from django.core.context import request_context\n+                if hasattr(request_context, 'request') and request_context.request:\n+                    script_name = request_context.request.META.get('SCRIPT_NAME', '')\n+                    if script_name and not script_name.endswith('/'):\n+                        script_name += '/'\n+                    if script_name and base_url:\n+                        base_url = script_name.rstrip('/') + base_url\n+            except (ImportError, AttributeError):\n+                pass\n+        \n+        return base_url\n \n     @cached_property\n     def file_permissions_mode(self):\n@@ -326,12 +357,28 @@ class FileSystemStorage(Storage):\n     def size(self, name):\n         return os.path.getsize(self.path(name))\n \n+\n     def url(self, name):\n         if self.base_url is None:\n             raise ValueError(\"This file is not accessible via a URL.\")\n         url = filepath_to_uri(name)\n         if url is not None:\n             url = url.lstrip('/')\n+        \n+        # Get SCRIPT_NAME from current request context if available\n+        from django.urls import get_script_prefix\n+        try:\n+            script_prefix = get_script_prefix()\n+            if script_prefix and script_prefix != '/':\n+                # Ensure base_url includes script prefix\n+                base_url = self.base_url\n+                if not base_url.startswith(script_prefix):\n+                    base_url = script_prefix.rstrip('/') + base_url\n+                return urljoin(base_url, url)\n+        except:\n+            # Fall back to original behavior if no request context\n+            pass\n+            \n         return urljoin(self.base_url, url)\n \n     def _datetime_from_timestamp(self, ts):\ndiff --git a/django/templatetags/static.py b/django/templatetags/static.py\nindex 39712aaba0..ca4e914e96 100644\n--- a/django/templatetags/static.py\n+++ b/django/templatetags/static.py\n@@ -36,6 +36,7 @@ class PrefixNode(template.Node):\n             varname = None\n         return cls(varname, name)\n \n+\n     @classmethod\n     def handle_simple(cls, name):\n         try:\n@@ -44,6 +45,19 @@ class PrefixNode(template.Node):\n             prefix = ''\n         else:\n             prefix = iri_to_uri(getattr(settings, name, ''))\n+            \n+        # Add SCRIPT_NAME support for URL prefixing\n+        try:\n+            from django.urls import get_script_prefix\n+            script_prefix = get_script_prefix()\n+            if script_prefix and script_prefix != '/':\n+                # Remove trailing slash from script_prefix if prefix starts with /\n+                if prefix.startswith('/') and script_prefix.endswith('/'):\n+                    script_prefix = script_prefix[:-1]\n+                prefix = script_prefix + prefix\n+        except ImportError:\n+            pass\n+            \n         return prefix\n \n     def render(self, context):\n@@ -111,11 +125,25 @@ class StaticNode(template.Node):\n         context[self.varname] = url\n         return ''\n \n+    @classmethod\n+\n     @classmethod\n     def handle_simple(cls, path):\n         if apps.is_installed('django.contrib.staticfiles'):\n             from django.contrib.staticfiles.storage import staticfiles_storage\n-            return staticfiles_storage.url(path)\n+            url = staticfiles_storage.url(path)\n+            # Get SCRIPT_NAME from current request context if available\n+            try:\n+                from django.core.context_processors import request\n+                from threading import local\n+                _thread_locals = getattr(local(), 'request', None)\n+                if hasattr(_thread_locals, 'META') and 'SCRIPT_NAME' in _thread_locals.META:\n+                    script_name = _thread_locals.META['SCRIPT_NAME'].rstrip('/')\n+                    if script_name and not url.startswith(script_name):\n+                        url = script_name + url\n+            except (ImportError, AttributeError):\n+                pass\n+            return url\n         else:\n             return urljoin(PrefixNode.handle_simple(\"STATIC_URL\"), quote(path))\n \n",
    "variant_8": "diff --git a/django/contrib/staticfiles/storage.py b/django/contrib/staticfiles/storage.py\nindex ba3b62620d..808d395e3d 100644\n--- a/django/contrib/staticfiles/storage.py\n+++ b/django/contrib/staticfiles/storage.py\n@@ -20,18 +20,49 @@ class StaticFilesStorage(FileSystemStorage):\n     The defaults for ``location`` and ``base_url`` are\n     ``STATIC_ROOT`` and ``STATIC_URL``.\n     \"\"\"\n-    def __init__(self, location=None, base_url=None, *args, **kwargs):\n-        if location is None:\n-            location = settings.STATIC_ROOT\n-        if base_url is None:\n-            base_url = settings.STATIC_URL\n-        check_settings(base_url)\n-        super().__init__(location, base_url, *args, **kwargs)\n-        # FileSystemStorage fallbacks to MEDIA_ROOT when location\n-        # is empty, so we restore the empty value.\n-        if not location:\n-            self.base_location = None\n-            self.location = None\n+\n+def __init__(self, location=None, base_url=None, *args, **kwargs):\n+    if location is None:\n+        location = settings.STATIC_ROOT\n+    if base_url is None:\n+        base_url = settings.STATIC_URL\n+    check_settings(base_url)\n+    \n+    # Store original base_url for SCRIPT_NAME handling\n+    self._original_base_url = base_url\n+    \n+    super().__init__(location, base_url, *args, **kwargs)\n+    # FileSystemStorage fallbacks to MEDIA_ROOT when location\n+    # is empty, so we restore the empty value.\n+    if not location:\n+        self.base_location = None\n+        self.location = None\n+\n+@property\n+def base_url(self):\n+    \"\"\"Return base_url with SCRIPT_NAME prefix if available.\"\"\"\n+    base = self._original_base_url or ''\n+    if not base:\n+        return base\n+    \n+    # Try to get SCRIPT_NAME from current request context\n+    try:\n+        from django.urls import get_script_prefix\n+        script_prefix = get_script_prefix()\n+        if script_prefix and script_prefix != '/':\n+            # Ensure proper URL joining\n+            if base.startswith('/'):\n+                base = base[1:]\n+            return script_prefix.rstrip('/') + '/' + base.lstrip('/')\n+    except Exception:\n+        pass\n+    \n+    return base\n+\n+@base_url.setter\n+def base_url(self, value):\n+    \"\"\"Set the original base_url value.\"\"\"\n+    self._original_base_url = value\n \n     def path(self, name):\n         if not self.location:\ndiff --git a/django/core/files/storage.py b/django/core/files/storage.py\nindex 4c27fce605..0c1f616c15 100644\n--- a/django/core/files/storage.py\n+++ b/django/core/files/storage.py\n@@ -213,11 +213,32 @@ class FileSystemStorage(Storage):\n     def location(self):\n         return os.path.abspath(self.base_location)\n \n+    @cached_property\n+\n     @cached_property\n     def base_url(self):\n         if self._base_url is not None and not self._base_url.endswith('/'):\n             self._base_url += '/'\n-        return self._value_or_setting(self._base_url, settings.MEDIA_URL)\n+        base_url = self._value_or_setting(self._base_url, settings.MEDIA_URL)\n+        \n+        # Add SCRIPT_NAME support for WSGI deployments\n+        try:\n+            from django.core.context_processors import request\n+            from threading import current_thread\n+            \n+            # Try to get SCRIPT_NAME from thread-local request context\n+            thread_locals = getattr(current_thread(), 'request', None)\n+            if hasattr(thread_locals, 'META'):\n+                script_name = thread_locals.META.get('SCRIPT_NAME', '')\n+                if script_name and not script_name.endswith('/'):\n+                    script_name += '/'\n+                if script_name and base_url and not base_url.startswith(script_name):\n+                    base_url = script_name.rstrip('/') + base_url\n+        except (ImportError, AttributeError):\n+            # Fallback to original behavior if request context unavailable\n+            pass\n+            \n+        return base_url\n \n     @cached_property\n     def file_permissions_mode(self):\n@@ -326,13 +347,33 @@ class FileSystemStorage(Storage):\n     def size(self, name):\n         return os.path.getsize(self.path(name))\n \n-    def url(self, name):\n-        if self.base_url is None:\n-            raise ValueError(\"This file is not accessible via a URL.\")\n-        url = filepath_to_uri(name)\n-        if url is not None:\n-            url = url.lstrip('/')\n-        return urljoin(self.base_url, url)\n+\n+def url(self, name):\n+    if self.base_url is None:\n+        raise ValueError(\"This file is not accessible via a URL.\")\n+    url = filepath_to_uri(name)\n+    if url is not None:\n+        url = url.lstrip('/')\n+    \n+    # Get SCRIPT_NAME from current request context if available\n+    from django.core.context_processors import request\n+    try:\n+        from django.http import HttpRequest\n+        import threading\n+        \n+        # Try to get current request from thread locals\n+        current_request = getattr(threading.current_thread(), 'request', None)\n+        if current_request and hasattr(current_request, 'META'):\n+            script_name = current_request.META.get('SCRIPT_NAME', '')\n+            if script_name and not script_name.endswith('/'):\n+                script_name += '/'\n+            base_url = script_name + self.base_url.lstrip('/') if script_name else self.base_url\n+        else:\n+            base_url = self.base_url\n+    except (ImportError, AttributeError):\n+        base_url = self.base_url\n+    \n+    return urljoin(base_url, url)\n \n     def _datetime_from_timestamp(self, ts):\n         \"\"\"\ndiff --git a/django/templatetags/static.py b/django/templatetags/static.py\nindex 39712aaba0..861e32bb47 100644\n--- a/django/templatetags/static.py\n+++ b/django/templatetags/static.py\n@@ -36,15 +36,27 @@ class PrefixNode(template.Node):\n             varname = None\n         return cls(varname, name)\n \n-    @classmethod\n-    def handle_simple(cls, name):\n+\n+@classmethod\n+def handle_simple(cls, name):\n+    try:\n+        from django.conf import settings\n+    except ImportError:\n+        prefix = ''\n+    else:\n+        prefix = iri_to_uri(getattr(settings, name, ''))\n+        \n+        # Add SCRIPT_NAME awareness for proper URL generation in sub-path deployments\n         try:\n-            from django.conf import settings\n+            from django.urls import get_script_prefix\n+            script_prefix = get_script_prefix()\n+            if script_prefix and script_prefix != '/':\n+                # Remove trailing slash from script_prefix to avoid double slashes\n+                script_prefix = script_prefix.rstrip('/')\n+                prefix = script_prefix + prefix\n         except ImportError:\n-            prefix = ''\n-        else:\n-            prefix = iri_to_uri(getattr(settings, name, ''))\n-        return prefix\n+            pass\n+    return prefix\n \n     def render(self, context):\n         prefix = self.handle_simple(self.name)\n@@ -111,11 +123,25 @@ class StaticNode(template.Node):\n         context[self.varname] = url\n         return ''\n \n+    @classmethod\n+\n     @classmethod\n     def handle_simple(cls, path):\n         if apps.is_installed('django.contrib.staticfiles'):\n             from django.contrib.staticfiles.storage import staticfiles_storage\n-            return staticfiles_storage.url(path)\n+            url = staticfiles_storage.url(path)\n+            # Get SCRIPT_NAME from current request context if available\n+            try:\n+                from django.core.context_processors import request\n+                from threading import local\n+                _thread_locals = getattr(request, '_thread_locals', None)\n+                if _thread_locals and hasattr(_thread_locals, 'request'):\n+                    script_name = _thread_locals.request.META.get('SCRIPT_NAME', '')\n+                    if script_name and not url.startswith(script_name):\n+                        url = script_name.rstrip('/') + url\n+            except (ImportError, AttributeError):\n+                pass\n+            return url\n         else:\n             return urljoin(PrefixNode.handle_simple(\"STATIC_URL\"), quote(path))\n \n"
  }
}