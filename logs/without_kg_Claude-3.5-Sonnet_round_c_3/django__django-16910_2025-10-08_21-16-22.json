{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/django/django/db/models/sql/compiler.py lines 1250-1255)": "\n        if restricted:\n            related_fields = [\n                (o.field, o.related_model)\n                for o in opts.related_objects\n                if o.field.unique and not o.many_to_many\n            ]\n            for related_field, model in related_fields:\n                # Handle reverse OneToOneField relations by checking if the field has a remote_field\n                # and using that for the select_mask lookup\n                mask_lookup_field = related_field\n                if hasattr(related_field, 'remote_field') and related_field.remote_field:\n                    # For reverse relations, try to find the forward field in select_mask\n                    forward_field = related_field.remote_field\n                    if forward_field in select_mask:\n                        mask_lookup_field = forward_field\n                \n                related_select_mask = select_mask.get(mask_lookup_field) or {}\n                if not select_related_descend(\n                    related_field,\n",
    "Location 2 (/root/hy/projects_3/django/django/db/models/sql/query.py lines 775-790)": "\ndef _get_only_select_mask(self, opts, mask, select_mask=None):\n    if select_mask is None:\n        select_mask = {}\n    select_mask[opts.pk] = {}\n    # Only include fields mentioned in the mask.\n    for field_name, field_mask in mask.items():\n        field = opts.get_field(field_name)\n        field_select_mask = select_mask.setdefault(field, {})\n        \n        # For OneToOneField relations, also add the reverse field mapping\n        if field.one_to_one and hasattr(field, 'remote_field'):\n            reverse_field = field.remote_field\n            if reverse_field and hasattr(reverse_field, 'get_accessor_name'):\n                # Map the reverse field object to the same select mask\n                select_mask[reverse_field] = field_select_mask\n        \n        if field_mask:\n            if not field.is_relation:\n                raise FieldError(next(iter(field_mask)))\n            related_model = field.remote_field.model._meta.concrete_model\n            self._get_only_select_mask(\n                related_model._meta, field_mask, field_select_mask\n            )\n    return select_mask\n",
    "Location 3 (/root/hy/projects_3/django/django/db/models/sql/query.py lines 805-812)": "\n    def get_select_mask(self):\n        \"\"\"\n        Determine which fields should be used to select data from the database.\n\n        This is used for both the select and masked (unselected) sets of\n        columns. The result is a dictionary mapping each model to a\n        structure, describing the field that *will* be loaded. This is used to\n        compute the columns to select from the database and also by the\n        QuerySet class to work out which fields are being initialized on each\n        model. Models that have all their fields included aren't mentioned in\n        the result, only those that have field restrictions in place.\n        \"\"\"\n        field_names, defer = self.deferred_loading\n        if not field_names:\n            return {}\n        mask = {}\n        for field_name in field_names:\n            part_mask = mask\n            for part in field_name.split(LOOKUP_SEP):\n                part_mask = part_mask.setdefault(part, {})\n        opts = self.get_meta()\n        if defer:\n            return self._get_defer_select_mask(opts, mask)\n        return self._get_only_select_mask(opts, mask)\n",
    "Location 4 (/root/hy/projects_3/django/django/db/models/sql/compiler.py lines 1281-1286)": "\n                klass_info = {\n                    \"model\": model,\n                    \"field\": related_field,\n                    \"reverse\": True,\n                    \"local_setter\": related_field.remote_field.set_cached_value,\n                    \"remote_setter\": related_field.set_cached_value,\n                    \"from_parent\": from_parent,\n                }\n                related_klass_infos.append(klass_info)\n                select_fields = []\n                \n                # Fix for reverse OneToOneField relations with only() fields\n                related_select_mask = select_mask.get(related_field)\n                if related_select_mask is None and hasattr(related_field, 'remote_field'):\n                    # Try to get mask using the remote field for reverse relations\n                    related_select_mask = select_mask.get(related_field.remote_field)\n                related_select_mask = related_select_mask or {}\n                \n                columns = self.get_default_columns(\n                    related_select_mask,\n                    start_alias=alias,\n                    opts=model._meta,\n                    from_parent=opts.model,\n                )\n",
    "Location 5 (/root/hy/projects_3/django/django/db/models/sql/compiler.py lines 993-994)": "\n            if related_field:\n                # Handle reverse OneToOneField relations by checking if the field\n                # has a reverse relation and using appropriate field mapping\n                related_select_mask = select_mask.get(related_field)\n                if not related_select_mask and hasattr(related_field, 'remote_field'):\n                    # Try to find the mask using the reverse field object\n                    reverse_field = related_field.remote_field\n                    if reverse_field:\n                        related_select_mask = select_mask.get(reverse_field)\n                related_select_mask = related_select_mask or {}\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/django/django/db/models/sql/compiler.py lines 1250-1255)": [
      "\n        if restricted:\n            related_fields = [\n                (o.field, o.related_model)\n                for o in opts.related_objects\n                if o.field.unique and not o.many_to_many\n            ]\n            for related_field, model in related_fields:\n                # Handle reverse OneToOneField relations by checking for the forward field\n                # in the select_mask if the reverse field lookup fails\n                related_select_mask = select_mask.get(related_field)\n                if not related_select_mask and hasattr(related_field, 'remote_field'):\n                    # Try to get the mask using the forward field object\n                    forward_field = related_field.remote_field\n                    related_select_mask = select_mask.get(forward_field)\n                related_select_mask = related_select_mask or {}\n                \n                if not select_related_descend(\n                    related_field,\n",
      "\n        if restricted:\n            related_fields = [\n                (o.field, o.related_model)\n                for o in opts.related_objects\n                if o.field.unique and not o.many_to_many\n            ]\n            for related_field, model in related_fields:\n                # Handle reverse OneToOneField relations by checking if the field\n                # has a forward counterpart in the select_mask\n                related_select_mask = select_mask.get(related_field)\n                if related_select_mask is None and hasattr(related_field, 'remote_field'):\n                    # For reverse relations, try to find the mask using the forward field\n                    forward_field = related_field.remote_field\n                    related_select_mask = select_mask.get(forward_field)\n                related_select_mask = related_select_mask or {}\n                \n                if not select_related_descend(\n                    related_field,\n",
      "\n        if restricted:\n            related_fields = [\n                (o.field, o.related_model)\n                for o in opts.related_objects\n                if o.field.unique and not o.many_to_many\n            ]\n            for related_field, model in related_fields:\n                # Handle reverse OneToOneField relations by checking for forward field mapping\n                related_select_mask = select_mask.get(related_field)\n                if not related_select_mask and hasattr(related_field, 'remote_field'):\n                    # Try to get mask using the forward field from the related model\n                    forward_field = related_field.remote_field\n                    related_select_mask = select_mask.get(forward_field)\n                related_select_mask = related_select_mask or {}\n                \n                if not select_related_descend(\n                    related_field,\n",
      "\n        if restricted:\n            related_fields = [\n                (o.field, o.related_model)\n                for o in opts.related_objects\n                if o.field.unique and not o.many_to_many\n            ]\n            for related_field, model in related_fields:\n                # Handle reverse OneToOneField relations by checking if the field\n                # has a reverse accessor and using the forward field for mask lookup\n                mask_lookup_field = related_field\n                if hasattr(related_field, 'remote_field') and related_field.remote_field:\n                    # For reverse relations, try to get the forward field\n                    forward_field = related_field.remote_field\n                    if forward_field in select_mask:\n                        mask_lookup_field = forward_field\n                \n                related_select_mask = select_mask.get(mask_lookup_field) or {}\n                if not select_related_descend(\n                    related_field,\n",
      "\n        if restricted:\n            related_fields = [\n                (o.field, o.related_model)\n                for o in opts.related_objects\n                if o.field.unique and not o.many_to_many\n            ]\n            for related_field, model in related_fields:\n                # Handle reverse OneToOneField relations by checking if the field\n                # has a reverse relation and using the forward field for mask lookup\n                mask_field = related_field\n                if hasattr(related_field, 'remote_field') and related_field.remote_field:\n                    # For reverse relations, try to get the forward field from select_mask\n                    forward_field = related_field.remote_field\n                    if forward_field in select_mask:\n                        mask_field = forward_field\n                \n                related_select_mask = select_mask.get(mask_field) or {}\n                if not select_related_descend(\n                    related_field,\n",
      "\n        if restricted:\n            related_fields = [\n                (o.field, o.related_model)\n                for o in opts.related_objects\n                if o.field.unique and not o.many_to_many\n            ]\n            for related_field, model in related_fields:\n                # Handle reverse OneToOneField relations by checking for forward field mapping\n                related_select_mask = select_mask.get(related_field)\n                if related_select_mask is None and hasattr(related_field, 'remote_field'):\n                    # Try to find the mask using the forward field object\n                    forward_field = related_field.remote_field\n                    related_select_mask = select_mask.get(forward_field)\n                related_select_mask = related_select_mask or {}\n                \n                if not select_related_descend(\n                    related_field,\n",
      "\n        if restricted:\n            related_fields = [\n                (o.field, o.related_model)\n                for o in opts.related_objects\n                if o.field.unique and not o.many_to_many\n            ]\n            for related_field, model in related_fields:\n                # Handle reverse OneToOneField relations by checking for the forward field\n                if hasattr(related_field, 'remote_field') and related_field.remote_field:\n                    # For reverse relations, try to get the mask using the forward field\n                    forward_field = related_field.remote_field\n                    related_select_mask = select_mask.get(forward_field) or select_mask.get(related_field) or {}\n                else:\n                    related_select_mask = select_mask.get(related_field) or {}\n                \n                if not select_related_descend(\n                    related_field,\n",
      "\n        if restricted:\n            related_fields = [\n                (o.field, o.related_model)\n                for o in opts.related_objects\n                if o.field.unique and not o.many_to_many\n            ]\n            for related_field, model in related_fields:\n                # Handle reverse OneToOneField relations by checking for forward field mapping\n                related_select_mask = select_mask.get(related_field)\n                if related_select_mask is None and hasattr(related_field, 'remote_field'):\n                    # For reverse relations, try to find the mask using the forward field\n                    forward_field = related_field.remote_field\n                    related_select_mask = select_mask.get(forward_field)\n                related_select_mask = related_select_mask or {}\n                if not select_related_descend(\n                    related_field,\n"
    ],
    "Location 2 (/root/hy/projects_3/django/django/db/models/sql/query.py lines 775-790)": [
      "\n    def _get_only_select_mask(self, opts, mask, select_mask=None):\n        if select_mask is None:\n            select_mask = {}\n        select_mask[opts.pk] = {}\n        # Only include fields mentioned in the mask.\n        for field_name, field_mask in mask.items():\n            field = opts.get_field(field_name)\n            field_select_mask = select_mask.setdefault(field, {})\n            if field_mask:\n                if not field.is_relation:\n                    raise FieldError(next(iter(field_mask)))\n                related_model = field.remote_field.model._meta.concrete_model\n                self._get_only_select_mask(\n                    related_model._meta, field_mask, field_select_mask\n                )\n                # For OneToOneField, also map the reverse field to the same mask\n                if hasattr(field, 'one_to_one') and field.one_to_one:\n                    try:\n                        reverse_field = field.remote_field.get_related_field()\n                        if reverse_field and reverse_field not in select_mask:\n                            select_mask[reverse_field] = field_select_mask\n                    except AttributeError:\n                        pass\n        return select_mask\n",
      "\n    def _get_only_select_mask(self, opts, mask, select_mask=None):\n        if select_mask is None:\n            select_mask = {}\n        select_mask[opts.pk] = {}\n        # Only include fields mentioned in the mask.\n        for field_name, field_mask in mask.items():\n            field = opts.get_field(field_name)\n            field_select_mask = select_mask.setdefault(field, {})\n            if field_mask:\n                if not field.is_relation:\n                    raise FieldError(next(iter(field_mask)))\n                related_model = field.remote_field.model._meta.concrete_model\n                # For OneToOneField, also add the reverse relation mapping\n                if hasattr(field, 'one_to_one') and field.one_to_one:\n                    reverse_field = field.remote_field\n                    if reverse_field and hasattr(reverse_field, 'get_accessor_name'):\n                        try:\n                            reverse_rel = related_model._meta.get_field(reverse_field.get_accessor_name())\n                            select_mask[reverse_rel] = field_select_mask\n                        except FieldDoesNotExist:\n                            pass\n                self._get_only_select_mask(\n                    related_model._meta, field_mask, field_select_mask\n                )\n        return select_mask\n",
      "\n    def _get_only_select_mask(self, opts, mask, select_mask=None):\n        if select_mask is None:\n            select_mask = {}\n        select_mask[opts.pk] = {}\n        # Only include fields mentioned in the mask.\n        for field_name, field_mask in mask.items():\n            field = opts.get_field(field_name)\n            field_select_mask = select_mask.setdefault(field, {})\n            if field_mask:\n                if not field.is_relation:\n                    raise FieldError(next(iter(field_mask)))\n                related_model = field.remote_field.model._meta.concrete_model\n                self._get_only_select_mask(\n                    related_model._meta, field_mask, field_select_mask\n                )\n                # For OneToOneField relations, also map the reverse field object\n                # to ensure both forward and reverse lookups work in select_mask\n                if hasattr(field, 'remote_field') and hasattr(field.remote_field, 'get_accessor_name'):\n                    try:\n                        reverse_field = related_model._meta.get_field(field.remote_field.get_accessor_name())\n                        if reverse_field and reverse_field not in select_mask:\n                            select_mask[reverse_field] = field_select_mask\n                    except FieldDoesNotExist:\n                        pass\n        return select_mask\n",
      "\n    def _get_only_select_mask(self, opts, mask, select_mask=None):\n        if select_mask is None:\n            select_mask = {}\n        select_mask[opts.pk] = {}\n        # Only include fields mentioned in the mask.\n        for field_name, field_mask in mask.items():\n            field = opts.get_field(field_name)\n            field_select_mask = select_mask.setdefault(field, {})\n            if field_mask:\n                if not field.is_relation:\n                    raise FieldError(next(iter(field_mask)))\n                related_model = field.remote_field.model._meta.concrete_model\n                self._get_only_select_mask(\n                    related_model._meta, field_mask, field_select_mask\n                )\n                # For OneToOneField, also map the reverse field to the same mask\n                # to ensure reverse relation lookups work correctly\n                if hasattr(field, 'one_to_one') and field.one_to_one:\n                    reverse_field = field.remote_field\n                    if reverse_field and hasattr(reverse_field, 'get_accessor_name'):\n                        select_mask[reverse_field] = field_select_mask\n        return select_mask\n",
      "\n    def _get_only_select_mask(self, opts, mask, select_mask=None):\n        if select_mask is None:\n            select_mask = {}\n        select_mask[opts.pk] = {}\n        # Only include fields mentioned in the mask.\n        for field_name, field_mask in mask.items():\n            field = opts.get_field(field_name)\n            field_select_mask = select_mask.setdefault(field, {})\n            if field_mask:\n                if not field.is_relation:\n                    raise FieldError(next(iter(field_mask)))\n                related_model = field.remote_field.model._meta.concrete_model\n                self._get_only_select_mask(\n                    related_model._meta, field_mask, field_select_mask\n                )\n                # For OneToOneField relations, also create mapping for reverse field\n                if hasattr(field, 'remote_field') and field.remote_field and hasattr(field.remote_field, 'related_name'):\n                    reverse_field = getattr(related_model._meta, 'get_field', lambda x: None)(field.remote_field.related_name or field.name + '_set')\n                    if reverse_field and hasattr(reverse_field, 'field') and reverse_field.field == field:\n                        select_mask[reverse_field] = field_select_mask\n        return select_mask\n",
      "\n    def _get_only_select_mask(self, opts, mask, select_mask=None):\n        if select_mask is None:\n            select_mask = {}\n        select_mask[opts.pk] = {}\n        # Only include fields mentioned in the mask.\n        for field_name, field_mask in mask.items():\n            field = opts.get_field(field_name)\n            field_select_mask = select_mask.setdefault(field, {})\n            if field_mask:\n                if not field.is_relation:\n                    raise FieldError(next(iter(field_mask)))\n                related_model = field.remote_field.model._meta.concrete_model\n                self._get_only_select_mask(\n                    related_model._meta, field_mask, field_select_mask\n                )\n                # For OneToOneField relations, also map the reverse field object\n                # to the same select mask to handle reverse relation lookups\n                if hasattr(field, 'remote_field') and hasattr(field.remote_field, 'get_related_field'):\n                    reverse_field = field.remote_field.get_related_field()\n                    if reverse_field and hasattr(reverse_field, 'remote_field'):\n                        select_mask[reverse_field] = field_select_mask\n        return select_mask\n",
      "\n    def _get_only_select_mask(self, opts, mask, select_mask=None):\n        if select_mask is None:\n            select_mask = {}\n        select_mask[opts.pk] = {}\n        # Only include fields mentioned in the mask.\n        for field_name, field_mask in mask.items():\n            field = opts.get_field(field_name)\n            field_select_mask = select_mask.setdefault(field, {})\n            if field_mask:\n                if not field.is_relation:\n                    raise FieldError(next(iter(field_mask)))\n                related_model = field.remote_field.model._meta.concrete_model\n                self._get_only_select_mask(\n                    related_model._meta, field_mask, field_select_mask\n                )\n            # For OneToOneField relations, also map the reverse field to ensure\n            # both forward and reverse lookups work in the select mask\n            if field.one_to_one and hasattr(field.remote_field, 'related_model'):\n                reverse_field = field.remote_field\n                if reverse_field and hasattr(reverse_field, 'get_accessor_name'):\n                    # Map the reverse field object to the same selection mask\n                    select_mask[reverse_field] = field_select_mask\n        return select_mask\n",
      "\n    def _get_only_select_mask(self, opts, mask, select_mask=None):\n        if select_mask is None:\n            select_mask = {}\n        select_mask[opts.pk] = {}\n        # Only include fields mentioned in the mask.\n        for field_name, field_mask in mask.items():\n            field = opts.get_field(field_name)\n            field_select_mask = select_mask.setdefault(field, {})\n            if field_mask:\n                if not field.is_relation:\n                    raise FieldError(next(iter(field_mask)))\n                related_model = field.remote_field.model._meta.concrete_model\n                self._get_only_select_mask(\n                    related_model._meta, field_mask, field_select_mask\n                )\n                # For OneToOneField relations, also map the reverse field\n                if hasattr(field, 'remote_field') and hasattr(field.remote_field, 'related_model'):\n                    reverse_field = field.remote_field\n                    if hasattr(reverse_field, 'field') and reverse_field.field not in select_mask:\n                        select_mask[reverse_field.field] = field_select_mask\n        return select_mask\n"
    ],
    "Location 3 (/root/hy/projects_3/django/django/db/models/sql/query.py lines 805-812)": [
      "\n    def get_select_mask(self):\n        \"\"\"\n        Convert the self.deferred_loading data into a dictionary suitable for\n        passing as the select argument to some methods. The \"mask\" is a\n        structure, describing the field that *will* be loaded. This is used to\n        compute the columns to select from the database and also by the\n        QuerySet class to work out which fields are being initialized on each\n        model. Models that have all their fields included aren't mentioned in\n        the result, only those that have field restrictions in place.\n        \"\"\"\n        field_names, defer = self.deferred_loading\n        if not field_names:\n            return {}\n        mask = {}\n        for field_name in field_names:\n            part_mask = mask\n            for part in field_name.split(LOOKUP_SEP):\n                part_mask = part_mask.setdefault(part, {})\n        \n        # Handle reverse OneToOneField relations by ensuring proper field mappings\n        opts = self.get_meta()\n        for field in opts.get_fields():\n            if field.one_to_one and hasattr(field, 'remote_field') and field.remote_field:\n                # For forward OneToOneField, check if reverse relation is in mask\n                reverse_name = field.remote_field.get_accessor_name()\n                if reverse_name in mask and field.name not in mask:\n                    mask[field.name] = mask[reverse_name]\n                # For reverse OneToOneField, check if forward relation is in mask  \n                elif field.name in mask and reverse_name not in mask:\n                    mask[reverse_name] = mask[field.name]\n        \n        if defer:\n            return self._get_defer_select_mask(opts, mask)\n        return self._get_only_select_mask(opts, mask)\n",
      "\n    def get_select_mask(self):\n        \"\"\"\n        Determine which fields should be used when the user has called\n        QuerySet.defer() or only(). If neither defer() nor only() have been\n        called, return an empty dict.\n\n        The returned dict will map each field object to a dictionary of the\n        field names (or attribute names) on the model object that should be\n        loaded. The returned structure is:\n        {model_field_obj: {model_field_name: {...}}}\n\n        This is the format returned by\n        self.deferred_loading[1](self.get_loaded_field_names()).\n\n        This method is separate from the similar get_loaded_field_names()\n        because ultimately a field may not be loaded, even if it appears in\n        \"loaded field names\" (such as adding a field to the query and then\n        removing it). This method is also separate from\n        get_loaded_field_names() because the \"loaded field names\" can be\n        changed between SQL construction and SQL execution.\n\n        The mask should be a nested dictionary of the same form as the \"mask\"\n        parameter to deferred_loading[1]().\n\n        This method can alter the tables that are joined, as it can result in\n        an additional join if adding a field results in a join to a model that\n        is not the base table. However, this method should not alter the\n        results, as it is only adding a field that should have been added\n        anyway.\n\n        This method can only be called once the query has been constructed.\n        This is because it can result in changes to self.tables.\n\n        The return value is a nested dict in the following format:\n        {model_field_obj: {field_name: {...}}}\n\n        The field_name is the name of the field on the model, while the\n        model_field_obj is the field object. For example, if you have a query\n        like Model.objects.only('field1__field2'), then the return value\n        would be:\n        {model_field_obj: {'field1': {'field2': {}}}}\n\n        In this example, model_field_obj would be the field object for the\n        'field1' field on the model.\n\n        The mask should be used to determine which columns to include in the\n        SELECT clause. The mask is passed to the get_default_columns() method\n        of the compiler, which uses it to determine which columns to include.\n\n        The mask can also be used by other parts of Django to determine which\n        fields should be loaded. For example, the QuerySet class uses the mask\n        to determine which fields should be initialized on each model instance.\n\n        The mask should be computed once and cached, as it can be expensive to\n        compute. However, the mask should be recomputed if the query changes.\n\n        The mask should be computed based on the deferred_loading attribute,\n        which is a tuple of (field_names, defer). The field_names is a set of\n        field names that should be deferred or only loaded. The defer is a\n        boolean that indicates whether the field_names should be deferred\n        (True) or only loaded (False).\n\n        The mask should be computed by iterating over the field_names and\n        building a nested dictionary. The keys of the dictionary should be the\n        field objects, and the values should be nested dictionaries of the\n        same form.\n\n        The mask should be computed by calling the _get_defer_select_mask() or\n        _get_only_select_mask() method, depending on the value of defer.\n\n        The _get_defer_select_mask() and _get_only_select_mask() methods should\n        be called with the model's _meta object and the mask built from the\n        field_names.\n\n        The mask built from the field_names should be a nested dictionary\n        where the keys are the field names and the values are nested\n        dictionaries of the same form. For example, if the field_names is\n        {'field1__field2'}, then the mask should be:\n        {'field1': {'field2': {}}}\n\n        The _get_defer_select_mask() and _get_only_select_mask() methods should\n        convert the mask built from field names to a mask with field objects\n        as keys.\n\n        The mask with field objects as keys should be a nested dictionary\n        where the keys are field objects and the values are nested dictionaries\n        of the same form. For example, if the mask built from field names is\n        {'field1': {'field2': {}}}, then the mask with field objects as keys\n        should be:\n        {field1_obj: {'field2': {}}}\n\n        In this example, field1_obj would be the field object for the 'field1'\n        field on the model.\n\n        The conversion from field names to field objects should be done by\n        looking up the field object for each field name. This can be done using\n        the _meta.get_field() method.\n\n        The conversion should also handle related fields. For example, if the\n        field name is 'field1__field2', then the field object for 'field1'\n        should be looked up, and then the field object for 'field2' should be\n        looked up on the related model.\n\n        The conversion should also handle reverse related fields. For example,\n        if the field name is 'reverse_field__field2', then the field object\n        for 'reverse_field' should be looked up, and then the field object for\n        'field2' should be looked up on the related model.\n\n        The conversion should also handle many-to-many fields and other complex\n        field types.\n\n        The conversion should be robust and handle edge cases. For example, if\n        a field name does not exist, then an appropriate exception should be\n        raised.\n\n        The conversion should also handle the case where the same field is\n        referenced multiple times. In this case, the field should only appear\n        once in the mask.\n\n        The conversion should also handle the case where a field is both\n        deferred and only loaded. In this case, an appropriate exception should\n        be raised.\n\n        The conversion should be efficient and not do unnecessary work. For\n        example, if the field_names is empty, then the mask should be empty\n        and no field lookups should be done.\n\n        The conversion should be correct and produce the expected mask. The\n        mask should be tested to ensure that it produces the expected results.\n\n        The mask should be used consistently throughout Django. The same mask\n        should be used for all operations that need to determine which fields\n        should be loaded.\n\n        The mask should be documented and well-understood. The format of the\n        mask should be clearly documented, and the behavior of the methods that\n        use the mask should be clearly specified.\n\n        The mask should be maintained and updated as Django evolves. If the\n        format of the mask changes, then all code that uses the mask should be\n        updated accordingly.\n\n        This method is a key part of Django's deferred loading functionality.\n        It is important that it works correctly and efficiently, as it can have\n        a significant impact on the performance of Django applications.\n\n        The method should be thoroughly tested to ensure that it works correctly\n        in all cases. The tests should cover edge cases and ensure that the\n        method produces the expected results.\n\n        The method should also be benchmarked to ensure that it performs well.\n        If the method is slow, then it can have a negative impact on the\n        performance of Django applications.\n\n        The method should be reviewed and approved by the Django core team\n        before being merged into the main codebase. The method should follow\n        Django's coding standards and best practices.\n\n        The method should be documented in Django's documentation. The\n        documentation should explain how the method works and how it should be\n        used.\n\n        The method should be announced to the Django community when it is\n        released. The announcement should explain the benefits of the method\n        and any breaking changes that it introduces.\n\n        The method should be supported and maintained by the Django core team.\n        Bug reports and feature requests related to the method should be\n        handled promptly and professionally.\n\n        This method is an important part of Django's ORM, and it should be\n        treated with the care and attention that it deserves.\n        \"\"\"\n        field_names, defer = self.deferred_loading\n        if not field_names:\n            return {}\n        mask = {}\n        for field_name in field_names:\n            part_mask = mask\n            for part in field_name.split(LOOKUP_SEP):\n                part_mask = part_mask.setdefault(part, {})\n        opts = self.get_meta()\n        if defer:\n            return self._get_defer_select_mask(opts, mask)\n        return self._get_only_select_mask(opts, mask)\n",
      "\n    def get_select_mask(self):\n        \"\"\"\n        Convert the self.deferred_loading data into a data structure, describing\n        the field that *will* be loaded. This is used to\n        compute the columns to select from the database and also by the\n        QuerySet class to work out which fields are being initialized on each\n        model. Models that have all their fields included aren't mentioned in\n        the result, only those that have field restrictions in place.\n        \"\"\"\n        field_names, defer = self.deferred_loading\n        if not field_names:\n            return {}\n        mask = {}\n        for field_name in field_names:\n            part_mask = mask\n            parts = field_name.split(LOOKUP_SEP)\n            for part in parts:\n                part_mask = part_mask.setdefault(part, {})\n        opts = self.get_meta()\n        if defer:\n            return self._get_defer_select_mask(opts, mask)\n        return self._get_only_select_mask(opts, mask)\n",
      "\n    def get_select_mask(self):\n        \"\"\"\n        Determine which fields should be returned by the query. This is used\n        to compute the columns to select from the database and also by the\n        QuerySet class to work out which fields are being initialized on each\n        model. Models that have all their fields included aren't mentioned in\n        the result, only those that have field restrictions in place.\n        \"\"\"\n        field_names, defer = self.deferred_loading\n        if not field_names:\n            return {}\n        mask = {}\n        for field_name in field_names:\n            part_mask = mask\n            for part in field_name.split(LOOKUP_SEP):\n                part_mask = part_mask.setdefault(part, {})\n        opts = self.get_meta()\n        if defer:\n            return self._get_defer_select_mask(opts, mask)\n        return self._get_only_select_mask(opts, mask)\n",
      "\n    def get_select_mask(self):\n        \"\"\"\n        Determine which fields should be used to create the select clause\n        (model loading).\n\n        The select mask is a dictionary mapping model options to a dictionary\n        of field names to booleans. The dictionary describes the\n        structure, describing the field that *will* be loaded. This is used to\n        compute the columns to select from the database and also by the\n        QuerySet class to work out which fields are being initialized on each\n        model. Models that have all their fields included aren't mentioned in\n        the result, only those that have field restrictions in place.\n        \"\"\"\n        field_names, defer = self.deferred_loading\n        if not field_names:\n            return {}\n        mask = {}\n        for field_name in field_names:\n            part_mask = mask\n            parts = field_name.split(LOOKUP_SEP)\n            for part in parts:\n                part_mask = part_mask.setdefault(part, {})\n        opts = self.get_meta()\n        if defer:\n            return self._get_defer_select_mask(opts, mask)\n        return self._get_only_select_mask(opts, mask)\n",
      "\n    def get_select_mask(self):\n        \"\"\"\n        Convert the self.deferred_loading data into a data structure, describing\n        the field that *will* be loaded. This is used to compute the columns to\n        select from the database and also by the QuerySet class to work out\n        which fields are being initialized on each model. Models that have all\n        their fields included aren't mentioned in the result, only those that\n        have field restrictions in place.\n        \"\"\"\n        field_names, defer = self.deferred_loading\n        if not field_names:\n            return {}\n        mask = {}\n        for field_name in field_names:\n            part_mask = mask\n            parts = field_name.split(LOOKUP_SEP)\n            for i, part in enumerate(parts):\n                # Check if this is the last part and represents a reverse OneToOneField\n                if i == len(parts) - 1:\n                    # Get the current model's options\n                    current_opts = self.get_meta()\n                    # Check if this field name corresponds to a reverse OneToOneField\n                    try:\n                        field = current_opts.get_field(part)\n                        if hasattr(field, 'remote_field') and field.remote_field and field.remote_field.one_to_one:\n                            # For reverse OneToOneField, also create mapping using the field object\n                            part_mask = part_mask.setdefault(part, {})\n                            # Store the field object as well for reverse lookup compatibility\n                            if hasattr(field, 'remote_field') and field.remote_field:\n                                reverse_field = field.remote_field\n                                part_mask.setdefault('__field_obj__', reverse_field)\n                        else:\n                            part_mask = part_mask.setdefault(part, {})\n                    except FieldDoesNotExist:\n                        part_mask = part_mask.setdefault(part, {})\n                else:\n                    part_mask = part_mask.setdefault(part, {})\n        opts = self.get_meta()\n        if defer:\n            return self._get_defer_select_mask(opts, mask)\n        return self._get_only_select_mask(opts, mask)\n",
      "\n    def get_select_mask(self):\n        \"\"\"\n        Convert the self.deferred_loading data into a dictionary suitable for\n        use in rendering the select clause. The keys are the field names and the\n        values are the field objects.\n\n        This is used to implement select_related() (only loading the needed\n        values) and also for implementing the load_on_demand from deferred\n        loading.\n\n        The method returns a dictionary of field_name -> field_object for all\n        the fields that need to be loaded. This is then used by the QuerySet\n        class to work out which fields are being initialized on each model.\n\n        The return value is a dictionary, where the keys are field names and\n        the values are dictionaries. This is a nested data structure, like\n        this:\n            {\n                'field1': {},\n                'field2': {\n                    'subfield1': {},\n                    'subfield2': {},\n                },\n            }\n\n        The empty dictionaries are used to represent the fact that the field\n        should be loaded, but no subfields of that field should be loaded. This\n        is used by the select_related() code.\n\n        Note that this data structure is converted into a different format by\n        the _get_defer_select_mask() and _get_only_select_mask() methods. That\n        structure, describing the field that *will* be loaded. This is used to\n        compute the columns to select from the database and also by the\n        QuerySet class to work out which fields are being initialized on each\n        model. Models that have all their fields included aren't mentioned in\n        the result, only those that have field restrictions in place.\n        \"\"\"\n        field_names, defer = self.deferred_loading\n        if not field_names:\n            return {}\n        mask = {}\n        for field_name in field_names:\n            part_mask = mask\n            parts = field_name.split(LOOKUP_SEP)\n            for part in parts:\n                part_mask = part_mask.setdefault(part, {})\n        opts = self.get_meta()\n        if defer:\n            return self._get_defer_select_mask(opts, mask)\n        return self._get_only_select_mask(opts, mask)\n",
      "\n    def get_select_mask(self):\n        \"\"\"\n        Convert the self.deferred_loading data into a dictionary suitable for use\n        in get_default_columns().\n        \"\"\"\n        if self.deferred_loading == (frozenset(), True):\n            return {}\n        # Reverse of an empty deferred_loading means defer everything.\n        field_names, defer = self.deferred_loading\n        if not field_names:\n            return {}\n        mask = {}\n        for field_name in field_names:\n            part_mask = mask\n            for part in field_name.split(LOOKUP_SEP):\n                part_mask = part_mask.setdefault(part, {})\n        opts = self.get_meta()\n        if defer:\n            return self._get_defer_select_mask(opts, mask)\n        return self._get_only_select_mask(opts, mask)\n"
    ],
    "Location 4 (/root/hy/projects_3/django/django/db/models/sql/compiler.py lines 1281-1286)": [
      "\n                # Get the field's select mask.\n                related_select_mask = select_mask.get(related_field) or {}\n                \n                # Handle reverse OneToOneField relations by checking if the related_field\n                # has a reverse relation and trying to get the mask using the reverse field\n                if not related_select_mask and hasattr(related_field, 'remote_field') and related_field.remote_field:\n                    # For reverse OneToOneField relations, try to get the mask using the remote field\n                    reverse_field = related_field.remote_field\n                    related_select_mask = select_mask.get(reverse_field) or {}\n",
      "\n                related_select_mask = select_mask.get(related_field)\n                if related_select_mask is None and hasattr(related_field, 'remote_field') and related_field.remote_field:\n                    # Handle reverse OneToOneField relations by checking the remote field\n                    related_select_mask = select_mask.get(related_field.remote_field)\n                related_select_mask = related_select_mask or {}\n",
      "\n                related_select_mask = select_mask.get(related_field)\n                if related_select_mask is None and hasattr(related_field, 'remote_field') and related_field.remote_field:\n                    # Handle reverse OneToOneField relations by looking up the forward field\n                    forward_field = related_field.remote_field\n                    related_select_mask = select_mask.get(forward_field)\n                related_select_mask = related_select_mask or {}\n",
      "\n                related_select_mask = select_mask.get(related_field)\n                \n                # Handle reverse OneToOneField relations by checking the remote field\n                if related_select_mask is None and hasattr(related_field, 'remote_field') and related_field.remote_field:\n                    # For reverse relations, try to get the mask using the remote field\n                    related_select_mask = select_mask.get(related_field.remote_field)\n                \n                related_select_mask = related_select_mask or {}\n",
      "\n                related_select_mask = select_mask.get(related_field)\n                if related_select_mask is None:\n                    # Handle reverse OneToOneField relations by checking the remote field\n                    if hasattr(related_field, 'remote_field') and related_field.remote_field:\n                        related_select_mask = select_mask.get(related_field.remote_field)\n                    if related_select_mask is None:\n                        related_select_mask = {}\n                else:\n                    related_select_mask = related_select_mask or {}\n",
      "\n            if related_field.many_to_many:\n                continue\n            related_select_mask = select_mask.get(related_field)\n            if related_select_mask is None and hasattr(related_field, 'remote_field'):\n                # Handle reverse OneToOneField relations by checking if the reverse field\n                # has a mask in select_mask\n                reverse_field = related_field.remote_field\n                if reverse_field and hasattr(reverse_field, 'one_to_one') and reverse_field.one_to_one:\n                    related_select_mask = select_mask.get(reverse_field)\n            related_select_mask = related_select_mask or {}\n",
      "\n            if related_field.many_to_many:\n                continue\n            related_select_mask = select_mask.get(related_field)\n            # Handle reverse OneToOneField relations by checking for the reverse field\n            if related_select_mask is None and hasattr(related_field, 'remote_field'):\n                # For reverse OneToOneField, try to find the mask using the remote field\n                related_select_mask = select_mask.get(related_field.remote_field)\n            related_select_mask = related_select_mask or {}\n",
      "\n            related_field = related_klass_info[\"field\"]\n            related_select_mask = select_mask.get(related_field)\n            \n            # Handle reverse OneToOneField relations by checking if we need to look up\n            # the mask using the remote field instead\n            if related_select_mask is None and hasattr(related_field, 'remote_field'):\n                # For reverse relations, try to find the mask using the forward field\n                remote_field = related_field.remote_field\n                if remote_field and hasattr(remote_field, 'name'):\n                    # Look for the mask using the forward field name path\n                    for mask_key, mask_value in select_mask.items():\n                        if (hasattr(mask_key, 'name') and mask_key.name == remote_field.name and\n                            hasattr(mask_key, 'model') and mask_key.model == remote_field.model):\n                            related_select_mask = mask_value\n                            break\n            \n            related_select_mask = related_select_mask or {}\n"
    ],
    "Location 5 (/root/hy/projects_3/django/django/db/models/sql/compiler.py lines 993-994)": [
      "\n            related_select_mask = select_mask.get(related_field)\n            if related_select_mask is None and hasattr(related_field, 'remote_field'):\n                # Handle reverse OneToOneField relations by checking the forward field\n                forward_field = related_field.remote_field\n                related_select_mask = select_mask.get(forward_field)\n            related_select_mask = related_select_mask or {}\n",
      "\n            if related_field in select_mask:\n                related_select_mask = select_mask[related_field]\n            elif hasattr(related_field, 'remote_field') and related_field.remote_field and related_field.remote_field.one_to_one:\n                # Handle reverse OneToOneField relations by looking up the forward field\n                forward_field = related_field.remote_field\n                related_select_mask = select_mask.get(forward_field, {})\n            else:\n                related_select_mask = {}\n",
      "\n            related_select_mask = select_mask.get(related_field)\n            \n            # Handle reverse OneToOneField relations by checking for the reverse field\n            if related_select_mask is None and hasattr(related_field, 'remote_field'):\n                # For reverse OneToOneField relations, try to find the mask using the reverse field\n                reverse_field = related_field.remote_field\n                if reverse_field and hasattr(reverse_field, 'one_to_one') and reverse_field.one_to_one:\n                    related_select_mask = select_mask.get(reverse_field)\n            \n            related_select_mask = related_select_mask or {}\n",
      "\n        if related_select_mask is None:\n            if related_field.many_to_many:\n                related_select_mask = {}\n            else:\n                # Handle reverse OneToOneField relations by checking for reverse relation\n                if hasattr(related_field, 'remote_field') and related_field.remote_field:\n                    # Try to find the mask using the remote field\n                    remote_field = related_field.remote_field\n                    related_select_mask = select_mask.get(remote_field) or {}\n                else:\n                    related_select_mask = select_mask.get(related_field) or {}\n",
      "\n            # Handle reverse OneToOneField relations by mapping to forward field\n            related_select_mask = select_mask.get(related_field)\n            if related_select_mask is None and hasattr(related_field, 'remote_field'):\n                # Try to find the mask using the reverse field mapping\n                reverse_field = related_field.remote_field\n                if reverse_field and hasattr(reverse_field, 'related_model'):\n                    related_select_mask = select_mask.get(reverse_field)\n            related_select_mask = related_select_mask or {}\n",
      "\n            related_select_mask = select_mask.get(related_field)\n            if related_select_mask is None:\n                # Handle reverse OneToOneField relations by checking if the related_field\n                # has a reverse relation and use the forward field for lookup\n                if hasattr(related_field, 'remote_field') and related_field.remote_field:\n                    # For reverse OneToOneField, try to find the forward field in select_mask\n                    forward_field = related_field.remote_field\n                    related_select_mask = select_mask.get(forward_field)\n                if related_select_mask is None:\n                    related_select_mask = {}\n            elif related_select_mask is False:\n                related_select_mask = {}\n",
      "\n        related_select_mask = select_mask.get(related_field)\n        if related_select_mask is None and hasattr(related_field, 'remote_field') and related_field.remote_field:\n            # Handle reverse OneToOneField relations by looking up the forward field\n            forward_field = related_field.remote_field\n            related_select_mask = select_mask.get(forward_field)\n        related_select_mask = related_select_mask or {}\n",
      "\n            related_select_mask = select_mask.get(related_field) or {}\n            \n            # Handle reverse OneToOneField relations by checking the remote field\n            if not related_select_mask and hasattr(related_field, 'remote_field') and related_field.remote_field:\n                # For reverse OneToOneField relations, try the remote field as the key\n                related_select_mask = select_mask.get(related_field.remote_field) or {}\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex b28dc925ba..a12d776b5f 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -990,6 +990,7 @@ class SQLCompiler:\n                 # parent model data is already present in the SELECT clause,\n                 # and we want to avoid reloading the same data again.\n                 continue\n+\n             if select_mask and field not in select_mask:\n                 continue\n             alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n@@ -1244,13 +1245,27 @@ class SQLCompiler:\n             get_related_klass_infos(klass_info, next_klass_infos)\n \n         if restricted:\n+            related_fields = [\n+                (o.field, o.related_model)\n+                for o in opts.related_objects\n+\n             related_fields = [\n                 (o.field, o.related_model)\n                 for o in opts.related_objects\n                 if o.field.unique and not o.many_to_many\n             ]\n             for related_field, model in related_fields:\n-                related_select_mask = select_mask.get(related_field) or {}\n+                related_select_mask = select_mask.get(related_field)\n+                \n+                # Handle reverse OneToOneField relations: if the reverse field isn't found,\n+                # try to find the corresponding forward field in the select_mask\n+                if related_select_mask is None and hasattr(related_field, 'remote_field'):\n+                    # For reverse relations, try to find the forward field\n+                    forward_field = related_field.remote_field\n+                    related_select_mask = select_mask.get(forward_field)\n+                \n+                related_select_mask = related_select_mask or {}\n+                \n                 if not select_related_descend(\n                     related_field,\n                     restricted,\n@@ -1278,6 +1293,7 @@ class SQLCompiler:\n                 }\n                 related_klass_infos.append(klass_info)\n                 select_fields = []\n+\n                 columns = self.get_default_columns(\n                     related_select_mask,\n                     start_alias=alias,\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 781dfd5499..8c8955d4ab 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -772,6 +772,7 @@ class Query(BaseExpression):\n             )\n         return select_mask\n \n+\n     def _get_only_select_mask(self, opts, mask, select_mask=None):\n         if select_mask is None:\n             select_mask = {}\n@@ -780,6 +781,14 @@ class Query(BaseExpression):\n         for field_name, field_mask in mask.items():\n             field = opts.get_field(field_name)\n             field_select_mask = select_mask.setdefault(field, {})\n+            \n+            # For OneToOneField relations, also create reverse mapping\n+            if hasattr(field, 'remote_field') and field.remote_field and hasattr(field, 'one_to_one') and field.one_to_one:\n+                # Add the reverse field as a key pointing to the same mask\n+                reverse_field = field.remote_field\n+                if reverse_field:\n+                    select_mask[reverse_field] = field_select_mask\n+            \n             if field_mask:\n                 if not field.is_relation:\n                     raise FieldError(next(iter(field_mask)))\n@@ -802,6 +811,7 @@ class Query(BaseExpression):\n         if not field_names:\n             return {}\n         mask = {}\n+\n         for field_name in field_names:\n             part_mask = mask\n             for part in field_name.split(LOOKUP_SEP):\n",
    "variant_0": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex b28dc925ba..3b516db718 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -990,8 +990,17 @@ class SQLCompiler:\n                 # parent model data is already present in the SELECT clause,\n                 # and we want to avoid reloading the same data again.\n                 continue\n-            if select_mask and field not in select_mask:\n-                continue\n+\n+            if related_field:\n+                # Handle reverse OneToOneField relations by checking if the field\n+                # has a reverse relation and using appropriate field mapping\n+                related_select_mask = select_mask.get(related_field)\n+                if not related_select_mask and hasattr(related_field, 'remote_field'):\n+                    # Try to find the mask using the reverse field object\n+                    reverse_field = related_field.remote_field\n+                    if reverse_field:\n+                        related_select_mask = select_mask.get(reverse_field)\n+                related_select_mask = related_select_mask or {}\n             alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n             column = field.get_col(alias)\n             result.append(column)\n@@ -1243,6 +1252,11 @@ class SQLCompiler:\n             )\n             get_related_klass_infos(klass_info, next_klass_infos)\n \n+        if restricted:\n+            related_fields = [\n+                (o.field, o.related_model)\n+                for o in opts.related_objects\n+\n         if restricted:\n             related_fields = [\n                 (o.field, o.related_model)\n@@ -1250,7 +1264,16 @@ class SQLCompiler:\n                 if o.field.unique and not o.many_to_many\n             ]\n             for related_field, model in related_fields:\n-                related_select_mask = select_mask.get(related_field) or {}\n+                # Handle reverse OneToOneField relations by checking if the field has a remote_field\n+                # and using that for the select_mask lookup\n+                mask_lookup_field = related_field\n+                if hasattr(related_field, 'remote_field') and related_field.remote_field:\n+                    # For reverse relations, try to find the forward field in select_mask\n+                    forward_field = related_field.remote_field\n+                    if forward_field in select_mask:\n+                        mask_lookup_field = forward_field\n+                \n+                related_select_mask = select_mask.get(mask_lookup_field) or {}\n                 if not select_related_descend(\n                     related_field,\n                     restricted,\n@@ -1278,6 +1301,25 @@ class SQLCompiler:\n                 }\n                 related_klass_infos.append(klass_info)\n                 select_fields = []\n+\n+                klass_info = {\n+                    \"model\": model,\n+                    \"field\": related_field,\n+                    \"reverse\": True,\n+                    \"local_setter\": related_field.remote_field.set_cached_value,\n+                    \"remote_setter\": related_field.set_cached_value,\n+                    \"from_parent\": from_parent,\n+                }\n+                related_klass_infos.append(klass_info)\n+                select_fields = []\n+                \n+                # Fix for reverse OneToOneField relations with only() fields\n+                related_select_mask = select_mask.get(related_field)\n+                if related_select_mask is None and hasattr(related_field, 'remote_field'):\n+                    # Try to get mask using the remote field for reverse relations\n+                    related_select_mask = select_mask.get(related_field.remote_field)\n+                related_select_mask = related_select_mask or {}\n+                \n                 columns = self.get_default_columns(\n                     related_select_mask,\n                     start_alias=alias,\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 781dfd5499..815a6bd8fc 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -772,22 +772,31 @@ class Query(BaseExpression):\n             )\n         return select_mask\n \n-    def _get_only_select_mask(self, opts, mask, select_mask=None):\n-        if select_mask is None:\n-            select_mask = {}\n-        select_mask[opts.pk] = {}\n-        # Only include fields mentioned in the mask.\n-        for field_name, field_mask in mask.items():\n-            field = opts.get_field(field_name)\n-            field_select_mask = select_mask.setdefault(field, {})\n-            if field_mask:\n-                if not field.is_relation:\n-                    raise FieldError(next(iter(field_mask)))\n-                related_model = field.remote_field.model._meta.concrete_model\n-                self._get_only_select_mask(\n-                    related_model._meta, field_mask, field_select_mask\n-                )\n-        return select_mask\n+\n+def _get_only_select_mask(self, opts, mask, select_mask=None):\n+    if select_mask is None:\n+        select_mask = {}\n+    select_mask[opts.pk] = {}\n+    # Only include fields mentioned in the mask.\n+    for field_name, field_mask in mask.items():\n+        field = opts.get_field(field_name)\n+        field_select_mask = select_mask.setdefault(field, {})\n+        \n+        # For OneToOneField relations, also add the reverse field mapping\n+        if field.one_to_one and hasattr(field, 'remote_field'):\n+            reverse_field = field.remote_field\n+            if reverse_field and hasattr(reverse_field, 'get_accessor_name'):\n+                # Map the reverse field object to the same select mask\n+                select_mask[reverse_field] = field_select_mask\n+        \n+        if field_mask:\n+            if not field.is_relation:\n+                raise FieldError(next(iter(field_mask)))\n+            related_model = field.remote_field.model._meta.concrete_model\n+            self._get_only_select_mask(\n+                related_model._meta, field_mask, field_select_mask\n+            )\n+    return select_mask\n \n     def get_select_mask(self):\n         \"\"\"\n@@ -802,6 +811,23 @@ class Query(BaseExpression):\n         if not field_names:\n             return {}\n         mask = {}\n+\n+    def get_select_mask(self):\n+        \"\"\"\n+        Determine which fields should be used to select data from the database.\n+\n+        This is used for both the select and masked (unselected) sets of\n+        columns. The result is a dictionary mapping each model to a\n+        structure, describing the field that *will* be loaded. This is used to\n+        compute the columns to select from the database and also by the\n+        QuerySet class to work out which fields are being initialized on each\n+        model. Models that have all their fields included aren't mentioned in\n+        the result, only those that have field restrictions in place.\n+        \"\"\"\n+        field_names, defer = self.deferred_loading\n+        if not field_names:\n+            return {}\n+        mask = {}\n         for field_name in field_names:\n             part_mask = mask\n             for part in field_name.split(LOOKUP_SEP):\n",
    "variant_1": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex b28dc925ba..19ed502260 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -990,8 +990,13 @@ class SQLCompiler:\n                 # parent model data is already present in the SELECT clause,\n                 # and we want to avoid reloading the same data again.\n                 continue\n-            if select_mask and field not in select_mask:\n-                continue\n+\n+            related_select_mask = select_mask.get(related_field)\n+            if related_select_mask is None and hasattr(related_field, 'remote_field'):\n+                # Handle reverse OneToOneField relations by checking the forward field\n+                forward_field = related_field.remote_field\n+                related_select_mask = select_mask.get(forward_field)\n+            related_select_mask = related_select_mask or {}\n             alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n             column = field.get_col(alias)\n             result.append(column)\n@@ -1243,6 +1248,11 @@ class SQLCompiler:\n             )\n             get_related_klass_infos(klass_info, next_klass_infos)\n \n+        if restricted:\n+            related_fields = [\n+                (o.field, o.related_model)\n+                for o in opts.related_objects\n+\n         if restricted:\n             related_fields = [\n                 (o.field, o.related_model)\n@@ -1250,7 +1260,15 @@ class SQLCompiler:\n                 if o.field.unique and not o.many_to_many\n             ]\n             for related_field, model in related_fields:\n-                related_select_mask = select_mask.get(related_field) or {}\n+                # Handle reverse OneToOneField relations by checking for the forward field\n+                # in the select_mask if the reverse field lookup fails\n+                related_select_mask = select_mask.get(related_field)\n+                if not related_select_mask and hasattr(related_field, 'remote_field'):\n+                    # Try to get the mask using the forward field object\n+                    forward_field = related_field.remote_field\n+                    related_select_mask = select_mask.get(forward_field)\n+                related_select_mask = related_select_mask or {}\n+                \n                 if not select_related_descend(\n                     related_field,\n                     restricted,\n@@ -1278,12 +1296,16 @@ class SQLCompiler:\n                 }\n                 related_klass_infos.append(klass_info)\n                 select_fields = []\n-                columns = self.get_default_columns(\n-                    related_select_mask,\n-                    start_alias=alias,\n-                    opts=model._meta,\n-                    from_parent=opts.model,\n-                )\n+\n+                # Get the field's select mask.\n+                related_select_mask = select_mask.get(related_field) or {}\n+                \n+                # Handle reverse OneToOneField relations by checking if the related_field\n+                # has a reverse relation and trying to get the mask using the reverse field\n+                if not related_select_mask and hasattr(related_field, 'remote_field') and related_field.remote_field:\n+                    # For reverse OneToOneField relations, try to get the mask using the remote field\n+                    reverse_field = related_field.remote_field\n+                    related_select_mask = select_mask.get(reverse_field) or {}\n                 for col in columns:\n                     select_fields.append(len(select))\n                     select.append((col, None))\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 781dfd5499..91d3e14263 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -772,6 +772,7 @@ class Query(BaseExpression):\n             )\n         return select_mask\n \n+\n     def _get_only_select_mask(self, opts, mask, select_mask=None):\n         if select_mask is None:\n             select_mask = {}\n@@ -787,6 +788,14 @@ class Query(BaseExpression):\n                 self._get_only_select_mask(\n                     related_model._meta, field_mask, field_select_mask\n                 )\n+                # For OneToOneField, also map the reverse field to the same mask\n+                if hasattr(field, 'one_to_one') and field.one_to_one:\n+                    try:\n+                        reverse_field = field.remote_field.get_related_field()\n+                        if reverse_field and reverse_field not in select_mask:\n+                            select_mask[reverse_field] = field_select_mask\n+                    except AttributeError:\n+                        pass\n         return select_mask\n \n     def get_select_mask(self):\n@@ -802,11 +811,38 @@ class Query(BaseExpression):\n         if not field_names:\n             return {}\n         mask = {}\n+\n+    def get_select_mask(self):\n+        \"\"\"\n+        Convert the self.deferred_loading data into a dictionary suitable for\n+        passing as the select argument to some methods. The \"mask\" is a\n+        structure, describing the field that *will* be loaded. This is used to\n+        compute the columns to select from the database and also by the\n+        QuerySet class to work out which fields are being initialized on each\n+        model. Models that have all their fields included aren't mentioned in\n+        the result, only those that have field restrictions in place.\n+        \"\"\"\n+        field_names, defer = self.deferred_loading\n+        if not field_names:\n+            return {}\n+        mask = {}\n         for field_name in field_names:\n             part_mask = mask\n             for part in field_name.split(LOOKUP_SEP):\n                 part_mask = part_mask.setdefault(part, {})\n+        \n+        # Handle reverse OneToOneField relations by ensuring proper field mappings\n         opts = self.get_meta()\n+        for field in opts.get_fields():\n+            if field.one_to_one and hasattr(field, 'remote_field') and field.remote_field:\n+                # For forward OneToOneField, check if reverse relation is in mask\n+                reverse_name = field.remote_field.get_accessor_name()\n+                if reverse_name in mask and field.name not in mask:\n+                    mask[field.name] = mask[reverse_name]\n+                # For reverse OneToOneField, check if forward relation is in mask  \n+                elif field.name in mask and reverse_name not in mask:\n+                    mask[reverse_name] = mask[field.name]\n+        \n         if defer:\n             return self._get_defer_select_mask(opts, mask)\n         return self._get_only_select_mask(opts, mask)\n",
    "variant_2": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex b28dc925ba..71c557fd68 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -990,8 +990,15 @@ class SQLCompiler:\n                 # parent model data is already present in the SELECT clause,\n                 # and we want to avoid reloading the same data again.\n                 continue\n-            if select_mask and field not in select_mask:\n-                continue\n+\n+            if related_field in select_mask:\n+                related_select_mask = select_mask[related_field]\n+            elif hasattr(related_field, 'remote_field') and related_field.remote_field and related_field.remote_field.one_to_one:\n+                # Handle reverse OneToOneField relations by looking up the forward field\n+                forward_field = related_field.remote_field\n+                related_select_mask = select_mask.get(forward_field, {})\n+            else:\n+                related_select_mask = {}\n             alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n             column = field.get_col(alias)\n             result.append(column)\n@@ -1243,6 +1250,11 @@ class SQLCompiler:\n             )\n             get_related_klass_infos(klass_info, next_klass_infos)\n \n+        if restricted:\n+            related_fields = [\n+                (o.field, o.related_model)\n+                for o in opts.related_objects\n+\n         if restricted:\n             related_fields = [\n                 (o.field, o.related_model)\n@@ -1250,7 +1262,15 @@ class SQLCompiler:\n                 if o.field.unique and not o.many_to_many\n             ]\n             for related_field, model in related_fields:\n-                related_select_mask = select_mask.get(related_field) or {}\n+                # Handle reverse OneToOneField relations by checking if the field\n+                # has a forward counterpart in the select_mask\n+                related_select_mask = select_mask.get(related_field)\n+                if related_select_mask is None and hasattr(related_field, 'remote_field'):\n+                    # For reverse relations, try to find the mask using the forward field\n+                    forward_field = related_field.remote_field\n+                    related_select_mask = select_mask.get(forward_field)\n+                related_select_mask = related_select_mask or {}\n+                \n                 if not select_related_descend(\n                     related_field,\n                     restricted,\n@@ -1278,12 +1298,12 @@ class SQLCompiler:\n                 }\n                 related_klass_infos.append(klass_info)\n                 select_fields = []\n-                columns = self.get_default_columns(\n-                    related_select_mask,\n-                    start_alias=alias,\n-                    opts=model._meta,\n-                    from_parent=opts.model,\n-                )\n+\n+                related_select_mask = select_mask.get(related_field)\n+                if related_select_mask is None and hasattr(related_field, 'remote_field') and related_field.remote_field:\n+                    # Handle reverse OneToOneField relations by checking the remote field\n+                    related_select_mask = select_mask.get(related_field.remote_field)\n+                related_select_mask = related_select_mask or {}\n                 for col in columns:\n                     select_fields.append(len(select))\n                     select.append((col, None))\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 781dfd5499..54177bd6b9 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -772,6 +772,7 @@ class Query(BaseExpression):\n             )\n         return select_mask\n \n+\n     def _get_only_select_mask(self, opts, mask, select_mask=None):\n         if select_mask is None:\n             select_mask = {}\n@@ -784,6 +785,15 @@ class Query(BaseExpression):\n                 if not field.is_relation:\n                     raise FieldError(next(iter(field_mask)))\n                 related_model = field.remote_field.model._meta.concrete_model\n+                # For OneToOneField, also add the reverse relation mapping\n+                if hasattr(field, 'one_to_one') and field.one_to_one:\n+                    reverse_field = field.remote_field\n+                    if reverse_field and hasattr(reverse_field, 'get_accessor_name'):\n+                        try:\n+                            reverse_rel = related_model._meta.get_field(reverse_field.get_accessor_name())\n+                            select_mask[reverse_rel] = field_select_mask\n+                        except FieldDoesNotExist:\n+                            pass\n                 self._get_only_select_mask(\n                     related_model._meta, field_mask, field_select_mask\n                 )\n@@ -802,6 +812,184 @@ class Query(BaseExpression):\n         if not field_names:\n             return {}\n         mask = {}\n+\n+    def get_select_mask(self):\n+        \"\"\"\n+        Determine which fields should be used when the user has called\n+        QuerySet.defer() or only(). If neither defer() nor only() have been\n+        called, return an empty dict.\n+\n+        The returned dict will map each field object to a dictionary of the\n+        field names (or attribute names) on the model object that should be\n+        loaded. The returned structure is:\n+        {model_field_obj: {model_field_name: {...}}}\n+\n+        This is the format returned by\n+        self.deferred_loading[1](self.get_loaded_field_names()).\n+\n+        This method is separate from the similar get_loaded_field_names()\n+        because ultimately a field may not be loaded, even if it appears in\n+        \"loaded field names\" (such as adding a field to the query and then\n+        removing it). This method is also separate from\n+        get_loaded_field_names() because the \"loaded field names\" can be\n+        changed between SQL construction and SQL execution.\n+\n+        The mask should be a nested dictionary of the same form as the \"mask\"\n+        parameter to deferred_loading[1]().\n+\n+        This method can alter the tables that are joined, as it can result in\n+        an additional join if adding a field results in a join to a model that\n+        is not the base table. However, this method should not alter the\n+        results, as it is only adding a field that should have been added\n+        anyway.\n+\n+        This method can only be called once the query has been constructed.\n+        This is because it can result in changes to self.tables.\n+\n+        The return value is a nested dict in the following format:\n+        {model_field_obj: {field_name: {...}}}\n+\n+        The field_name is the name of the field on the model, while the\n+        model_field_obj is the field object. For example, if you have a query\n+        like Model.objects.only('field1__field2'), then the return value\n+        would be:\n+        {model_field_obj: {'field1': {'field2': {}}}}\n+\n+        In this example, model_field_obj would be the field object for the\n+        'field1' field on the model.\n+\n+        The mask should be used to determine which columns to include in the\n+        SELECT clause. The mask is passed to the get_default_columns() method\n+        of the compiler, which uses it to determine which columns to include.\n+\n+        The mask can also be used by other parts of Django to determine which\n+        fields should be loaded. For example, the QuerySet class uses the mask\n+        to determine which fields should be initialized on each model instance.\n+\n+        The mask should be computed once and cached, as it can be expensive to\n+        compute. However, the mask should be recomputed if the query changes.\n+\n+        The mask should be computed based on the deferred_loading attribute,\n+        which is a tuple of (field_names, defer). The field_names is a set of\n+        field names that should be deferred or only loaded. The defer is a\n+        boolean that indicates whether the field_names should be deferred\n+        (True) or only loaded (False).\n+\n+        The mask should be computed by iterating over the field_names and\n+        building a nested dictionary. The keys of the dictionary should be the\n+        field objects, and the values should be nested dictionaries of the\n+        same form.\n+\n+        The mask should be computed by calling the _get_defer_select_mask() or\n+        _get_only_select_mask() method, depending on the value of defer.\n+\n+        The _get_defer_select_mask() and _get_only_select_mask() methods should\n+        be called with the model's _meta object and the mask built from the\n+        field_names.\n+\n+        The mask built from the field_names should be a nested dictionary\n+        where the keys are the field names and the values are nested\n+        dictionaries of the same form. For example, if the field_names is\n+        {'field1__field2'}, then the mask should be:\n+        {'field1': {'field2': {}}}\n+\n+        The _get_defer_select_mask() and _get_only_select_mask() methods should\n+        convert the mask built from field names to a mask with field objects\n+        as keys.\n+\n+        The mask with field objects as keys should be a nested dictionary\n+        where the keys are field objects and the values are nested dictionaries\n+        of the same form. For example, if the mask built from field names is\n+        {'field1': {'field2': {}}}, then the mask with field objects as keys\n+        should be:\n+        {field1_obj: {'field2': {}}}\n+\n+        In this example, field1_obj would be the field object for the 'field1'\n+        field on the model.\n+\n+        The conversion from field names to field objects should be done by\n+        looking up the field object for each field name. This can be done using\n+        the _meta.get_field() method.\n+\n+        The conversion should also handle related fields. For example, if the\n+        field name is 'field1__field2', then the field object for 'field1'\n+        should be looked up, and then the field object for 'field2' should be\n+        looked up on the related model.\n+\n+        The conversion should also handle reverse related fields. For example,\n+        if the field name is 'reverse_field__field2', then the field object\n+        for 'reverse_field' should be looked up, and then the field object for\n+        'field2' should be looked up on the related model.\n+\n+        The conversion should also handle many-to-many fields and other complex\n+        field types.\n+\n+        The conversion should be robust and handle edge cases. For example, if\n+        a field name does not exist, then an appropriate exception should be\n+        raised.\n+\n+        The conversion should also handle the case where the same field is\n+        referenced multiple times. In this case, the field should only appear\n+        once in the mask.\n+\n+        The conversion should also handle the case where a field is both\n+        deferred and only loaded. In this case, an appropriate exception should\n+        be raised.\n+\n+        The conversion should be efficient and not do unnecessary work. For\n+        example, if the field_names is empty, then the mask should be empty\n+        and no field lookups should be done.\n+\n+        The conversion should be correct and produce the expected mask. The\n+        mask should be tested to ensure that it produces the expected results.\n+\n+        The mask should be used consistently throughout Django. The same mask\n+        should be used for all operations that need to determine which fields\n+        should be loaded.\n+\n+        The mask should be documented and well-understood. The format of the\n+        mask should be clearly documented, and the behavior of the methods that\n+        use the mask should be clearly specified.\n+\n+        The mask should be maintained and updated as Django evolves. If the\n+        format of the mask changes, then all code that uses the mask should be\n+        updated accordingly.\n+\n+        This method is a key part of Django's deferred loading functionality.\n+        It is important that it works correctly and efficiently, as it can have\n+        a significant impact on the performance of Django applications.\n+\n+        The method should be thoroughly tested to ensure that it works correctly\n+        in all cases. The tests should cover edge cases and ensure that the\n+        method produces the expected results.\n+\n+        The method should also be benchmarked to ensure that it performs well.\n+        If the method is slow, then it can have a negative impact on the\n+        performance of Django applications.\n+\n+        The method should be reviewed and approved by the Django core team\n+        before being merged into the main codebase. The method should follow\n+        Django's coding standards and best practices.\n+\n+        The method should be documented in Django's documentation. The\n+        documentation should explain how the method works and how it should be\n+        used.\n+\n+        The method should be announced to the Django community when it is\n+        released. The announcement should explain the benefits of the method\n+        and any breaking changes that it introduces.\n+\n+        The method should be supported and maintained by the Django core team.\n+        Bug reports and feature requests related to the method should be\n+        handled promptly and professionally.\n+\n+        This method is an important part of Django's ORM, and it should be\n+        treated with the care and attention that it deserves.\n+        \"\"\"\n+        field_names, defer = self.deferred_loading\n+        if not field_names:\n+            return {}\n+        mask = {}\n         for field_name in field_names:\n             part_mask = mask\n             for part in field_name.split(LOOKUP_SEP):\n",
    "variant_3": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex b28dc925ba..e4c6c589a7 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -990,8 +990,17 @@ class SQLCompiler:\n                 # parent model data is already present in the SELECT clause,\n                 # and we want to avoid reloading the same data again.\n                 continue\n-            if select_mask and field not in select_mask:\n-                continue\n+\n+            related_select_mask = select_mask.get(related_field)\n+            \n+            # Handle reverse OneToOneField relations by checking for the reverse field\n+            if related_select_mask is None and hasattr(related_field, 'remote_field'):\n+                # For reverse OneToOneField relations, try to find the mask using the reverse field\n+                reverse_field = related_field.remote_field\n+                if reverse_field and hasattr(reverse_field, 'one_to_one') and reverse_field.one_to_one:\n+                    related_select_mask = select_mask.get(reverse_field)\n+            \n+            related_select_mask = related_select_mask or {}\n             alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n             column = field.get_col(alias)\n             result.append(column)\n@@ -1243,6 +1252,11 @@ class SQLCompiler:\n             )\n             get_related_klass_infos(klass_info, next_klass_infos)\n \n+        if restricted:\n+            related_fields = [\n+                (o.field, o.related_model)\n+                for o in opts.related_objects\n+\n         if restricted:\n             related_fields = [\n                 (o.field, o.related_model)\n@@ -1250,7 +1264,14 @@ class SQLCompiler:\n                 if o.field.unique and not o.many_to_many\n             ]\n             for related_field, model in related_fields:\n-                related_select_mask = select_mask.get(related_field) or {}\n+                # Handle reverse OneToOneField relations by checking for forward field mapping\n+                related_select_mask = select_mask.get(related_field)\n+                if not related_select_mask and hasattr(related_field, 'remote_field'):\n+                    # Try to get mask using the forward field from the related model\n+                    forward_field = related_field.remote_field\n+                    related_select_mask = select_mask.get(forward_field)\n+                related_select_mask = related_select_mask or {}\n+                \n                 if not select_related_descend(\n                     related_field,\n                     restricted,\n@@ -1278,12 +1299,13 @@ class SQLCompiler:\n                 }\n                 related_klass_infos.append(klass_info)\n                 select_fields = []\n-                columns = self.get_default_columns(\n-                    related_select_mask,\n-                    start_alias=alias,\n-                    opts=model._meta,\n-                    from_parent=opts.model,\n-                )\n+\n+                related_select_mask = select_mask.get(related_field)\n+                if related_select_mask is None and hasattr(related_field, 'remote_field') and related_field.remote_field:\n+                    # Handle reverse OneToOneField relations by looking up the forward field\n+                    forward_field = related_field.remote_field\n+                    related_select_mask = select_mask.get(forward_field)\n+                related_select_mask = related_select_mask or {}\n                 for col in columns:\n                     select_fields.append(len(select))\n                     select.append((col, None))\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 781dfd5499..351b9420b4 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -772,6 +772,7 @@ class Query(BaseExpression):\n             )\n         return select_mask\n \n+\n     def _get_only_select_mask(self, opts, mask, select_mask=None):\n         if select_mask is None:\n             select_mask = {}\n@@ -787,6 +788,15 @@ class Query(BaseExpression):\n                 self._get_only_select_mask(\n                     related_model._meta, field_mask, field_select_mask\n                 )\n+                # For OneToOneField relations, also map the reverse field object\n+                # to ensure both forward and reverse lookups work in select_mask\n+                if hasattr(field, 'remote_field') and hasattr(field.remote_field, 'get_accessor_name'):\n+                    try:\n+                        reverse_field = related_model._meta.get_field(field.remote_field.get_accessor_name())\n+                        if reverse_field and reverse_field not in select_mask:\n+                            select_mask[reverse_field] = field_select_mask\n+                    except FieldDoesNotExist:\n+                        pass\n         return select_mask\n \n     def get_select_mask(self):\n@@ -802,9 +812,24 @@ class Query(BaseExpression):\n         if not field_names:\n             return {}\n         mask = {}\n+\n+    def get_select_mask(self):\n+        \"\"\"\n+        Convert the self.deferred_loading data into a data structure, describing\n+        the field that *will* be loaded. This is used to\n+        compute the columns to select from the database and also by the\n+        QuerySet class to work out which fields are being initialized on each\n+        model. Models that have all their fields included aren't mentioned in\n+        the result, only those that have field restrictions in place.\n+        \"\"\"\n+        field_names, defer = self.deferred_loading\n+        if not field_names:\n+            return {}\n+        mask = {}\n         for field_name in field_names:\n             part_mask = mask\n-            for part in field_name.split(LOOKUP_SEP):\n+            parts = field_name.split(LOOKUP_SEP)\n+            for part in parts:\n                 part_mask = part_mask.setdefault(part, {})\n         opts = self.get_meta()\n         if defer:\n",
    "variant_4": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex b28dc925ba..03d174bf9a 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -990,8 +990,18 @@ class SQLCompiler:\n                 # parent model data is already present in the SELECT clause,\n                 # and we want to avoid reloading the same data again.\n                 continue\n-            if select_mask and field not in select_mask:\n-                continue\n+\n+        if related_select_mask is None:\n+            if related_field.many_to_many:\n+                related_select_mask = {}\n+            else:\n+                # Handle reverse OneToOneField relations by checking for reverse relation\n+                if hasattr(related_field, 'remote_field') and related_field.remote_field:\n+                    # Try to find the mask using the remote field\n+                    remote_field = related_field.remote_field\n+                    related_select_mask = select_mask.get(remote_field) or {}\n+                else:\n+                    related_select_mask = select_mask.get(related_field) or {}\n             alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n             column = field.get_col(alias)\n             result.append(column)\n@@ -1243,6 +1253,11 @@ class SQLCompiler:\n             )\n             get_related_klass_infos(klass_info, next_klass_infos)\n \n+        if restricted:\n+            related_fields = [\n+                (o.field, o.related_model)\n+                for o in opts.related_objects\n+\n         if restricted:\n             related_fields = [\n                 (o.field, o.related_model)\n@@ -1250,7 +1265,16 @@ class SQLCompiler:\n                 if o.field.unique and not o.many_to_many\n             ]\n             for related_field, model in related_fields:\n-                related_select_mask = select_mask.get(related_field) or {}\n+                # Handle reverse OneToOneField relations by checking if the field\n+                # has a reverse accessor and using the forward field for mask lookup\n+                mask_lookup_field = related_field\n+                if hasattr(related_field, 'remote_field') and related_field.remote_field:\n+                    # For reverse relations, try to get the forward field\n+                    forward_field = related_field.remote_field\n+                    if forward_field in select_mask:\n+                        mask_lookup_field = forward_field\n+                \n+                related_select_mask = select_mask.get(mask_lookup_field) or {}\n                 if not select_related_descend(\n                     related_field,\n                     restricted,\n@@ -1278,12 +1302,15 @@ class SQLCompiler:\n                 }\n                 related_klass_infos.append(klass_info)\n                 select_fields = []\n-                columns = self.get_default_columns(\n-                    related_select_mask,\n-                    start_alias=alias,\n-                    opts=model._meta,\n-                    from_parent=opts.model,\n-                )\n+\n+                related_select_mask = select_mask.get(related_field)\n+                \n+                # Handle reverse OneToOneField relations by checking the remote field\n+                if related_select_mask is None and hasattr(related_field, 'remote_field') and related_field.remote_field:\n+                    # For reverse relations, try to get the mask using the remote field\n+                    related_select_mask = select_mask.get(related_field.remote_field)\n+                \n+                related_select_mask = related_select_mask or {}\n                 for col in columns:\n                     select_fields.append(len(select))\n                     select.append((col, None))\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 781dfd5499..b51c3cf801 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -772,6 +772,7 @@ class Query(BaseExpression):\n             )\n         return select_mask\n \n+\n     def _get_only_select_mask(self, opts, mask, select_mask=None):\n         if select_mask is None:\n             select_mask = {}\n@@ -787,6 +788,12 @@ class Query(BaseExpression):\n                 self._get_only_select_mask(\n                     related_model._meta, field_mask, field_select_mask\n                 )\n+                # For OneToOneField, also map the reverse field to the same mask\n+                # to ensure reverse relation lookups work correctly\n+                if hasattr(field, 'one_to_one') and field.one_to_one:\n+                    reverse_field = field.remote_field\n+                    if reverse_field and hasattr(reverse_field, 'get_accessor_name'):\n+                        select_mask[reverse_field] = field_select_mask\n         return select_mask\n \n     def get_select_mask(self):\n@@ -802,6 +809,19 @@ class Query(BaseExpression):\n         if not field_names:\n             return {}\n         mask = {}\n+\n+    def get_select_mask(self):\n+        \"\"\"\n+        Determine which fields should be returned by the query. This is used\n+        to compute the columns to select from the database and also by the\n+        QuerySet class to work out which fields are being initialized on each\n+        model. Models that have all their fields included aren't mentioned in\n+        the result, only those that have field restrictions in place.\n+        \"\"\"\n+        field_names, defer = self.deferred_loading\n+        if not field_names:\n+            return {}\n+        mask = {}\n         for field_name in field_names:\n             part_mask = mask\n             for part in field_name.split(LOOKUP_SEP):\n",
    "variant_5": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex b28dc925ba..041784913a 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -990,8 +990,15 @@ class SQLCompiler:\n                 # parent model data is already present in the SELECT clause,\n                 # and we want to avoid reloading the same data again.\n                 continue\n-            if select_mask and field not in select_mask:\n-                continue\n+\n+            # Handle reverse OneToOneField relations by mapping to forward field\n+            related_select_mask = select_mask.get(related_field)\n+            if related_select_mask is None and hasattr(related_field, 'remote_field'):\n+                # Try to find the mask using the reverse field mapping\n+                reverse_field = related_field.remote_field\n+                if reverse_field and hasattr(reverse_field, 'related_model'):\n+                    related_select_mask = select_mask.get(reverse_field)\n+            related_select_mask = related_select_mask or {}\n             alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n             column = field.get_col(alias)\n             result.append(column)\n@@ -1243,6 +1250,11 @@ class SQLCompiler:\n             )\n             get_related_klass_infos(klass_info, next_klass_infos)\n \n+        if restricted:\n+            related_fields = [\n+                (o.field, o.related_model)\n+                for o in opts.related_objects\n+\n         if restricted:\n             related_fields = [\n                 (o.field, o.related_model)\n@@ -1250,7 +1262,16 @@ class SQLCompiler:\n                 if o.field.unique and not o.many_to_many\n             ]\n             for related_field, model in related_fields:\n-                related_select_mask = select_mask.get(related_field) or {}\n+                # Handle reverse OneToOneField relations by checking if the field\n+                # has a reverse relation and using the forward field for mask lookup\n+                mask_field = related_field\n+                if hasattr(related_field, 'remote_field') and related_field.remote_field:\n+                    # For reverse relations, try to get the forward field from select_mask\n+                    forward_field = related_field.remote_field\n+                    if forward_field in select_mask:\n+                        mask_field = forward_field\n+                \n+                related_select_mask = select_mask.get(mask_field) or {}\n                 if not select_related_descend(\n                     related_field,\n                     restricted,\n@@ -1278,12 +1299,16 @@ class SQLCompiler:\n                 }\n                 related_klass_infos.append(klass_info)\n                 select_fields = []\n-                columns = self.get_default_columns(\n-                    related_select_mask,\n-                    start_alias=alias,\n-                    opts=model._meta,\n-                    from_parent=opts.model,\n-                )\n+\n+                related_select_mask = select_mask.get(related_field)\n+                if related_select_mask is None:\n+                    # Handle reverse OneToOneField relations by checking the remote field\n+                    if hasattr(related_field, 'remote_field') and related_field.remote_field:\n+                        related_select_mask = select_mask.get(related_field.remote_field)\n+                    if related_select_mask is None:\n+                        related_select_mask = {}\n+                else:\n+                    related_select_mask = related_select_mask or {}\n                 for col in columns:\n                     select_fields.append(len(select))\n                     select.append((col, None))\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 781dfd5499..e6b1ca2216 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -772,6 +772,7 @@ class Query(BaseExpression):\n             )\n         return select_mask\n \n+\n     def _get_only_select_mask(self, opts, mask, select_mask=None):\n         if select_mask is None:\n             select_mask = {}\n@@ -787,6 +788,11 @@ class Query(BaseExpression):\n                 self._get_only_select_mask(\n                     related_model._meta, field_mask, field_select_mask\n                 )\n+                # For OneToOneField relations, also create mapping for reverse field\n+                if hasattr(field, 'remote_field') and field.remote_field and hasattr(field.remote_field, 'related_name'):\n+                    reverse_field = getattr(related_model._meta, 'get_field', lambda x: None)(field.remote_field.related_name or field.name + '_set')\n+                    if reverse_field and hasattr(reverse_field, 'field') and reverse_field.field == field:\n+                        select_mask[reverse_field] = field_select_mask\n         return select_mask\n \n     def get_select_mask(self):\n@@ -802,9 +808,28 @@ class Query(BaseExpression):\n         if not field_names:\n             return {}\n         mask = {}\n+\n+    def get_select_mask(self):\n+        \"\"\"\n+        Determine which fields should be used to create the select clause\n+        (model loading).\n+\n+        The select mask is a dictionary mapping model options to a dictionary\n+        of field names to booleans. The dictionary describes the\n+        structure, describing the field that *will* be loaded. This is used to\n+        compute the columns to select from the database and also by the\n+        QuerySet class to work out which fields are being initialized on each\n+        model. Models that have all their fields included aren't mentioned in\n+        the result, only those that have field restrictions in place.\n+        \"\"\"\n+        field_names, defer = self.deferred_loading\n+        if not field_names:\n+            return {}\n+        mask = {}\n         for field_name in field_names:\n             part_mask = mask\n-            for part in field_name.split(LOOKUP_SEP):\n+            parts = field_name.split(LOOKUP_SEP)\n+            for part in parts:\n                 part_mask = part_mask.setdefault(part, {})\n         opts = self.get_meta()\n         if defer:\n",
    "variant_6": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex b28dc925ba..03fcd19745 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -990,8 +990,19 @@ class SQLCompiler:\n                 # parent model data is already present in the SELECT clause,\n                 # and we want to avoid reloading the same data again.\n                 continue\n-            if select_mask and field not in select_mask:\n-                continue\n+\n+            related_select_mask = select_mask.get(related_field)\n+            if related_select_mask is None:\n+                # Handle reverse OneToOneField relations by checking if the related_field\n+                # has a reverse relation and use the forward field for lookup\n+                if hasattr(related_field, 'remote_field') and related_field.remote_field:\n+                    # For reverse OneToOneField, try to find the forward field in select_mask\n+                    forward_field = related_field.remote_field\n+                    related_select_mask = select_mask.get(forward_field)\n+                if related_select_mask is None:\n+                    related_select_mask = {}\n+            elif related_select_mask is False:\n+                related_select_mask = {}\n             alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n             column = field.get_col(alias)\n             result.append(column)\n@@ -1243,6 +1254,11 @@ class SQLCompiler:\n             )\n             get_related_klass_infos(klass_info, next_klass_infos)\n \n+        if restricted:\n+            related_fields = [\n+                (o.field, o.related_model)\n+                for o in opts.related_objects\n+\n         if restricted:\n             related_fields = [\n                 (o.field, o.related_model)\n@@ -1250,7 +1266,14 @@ class SQLCompiler:\n                 if o.field.unique and not o.many_to_many\n             ]\n             for related_field, model in related_fields:\n-                related_select_mask = select_mask.get(related_field) or {}\n+                # Handle reverse OneToOneField relations by checking for forward field mapping\n+                related_select_mask = select_mask.get(related_field)\n+                if related_select_mask is None and hasattr(related_field, 'remote_field'):\n+                    # Try to find the mask using the forward field object\n+                    forward_field = related_field.remote_field\n+                    related_select_mask = select_mask.get(forward_field)\n+                related_select_mask = related_select_mask or {}\n+                \n                 if not select_related_descend(\n                     related_field,\n                     restricted,\n@@ -1278,12 +1301,17 @@ class SQLCompiler:\n                 }\n                 related_klass_infos.append(klass_info)\n                 select_fields = []\n-                columns = self.get_default_columns(\n-                    related_select_mask,\n-                    start_alias=alias,\n-                    opts=model._meta,\n-                    from_parent=opts.model,\n-                )\n+\n+            if related_field.many_to_many:\n+                continue\n+            related_select_mask = select_mask.get(related_field)\n+            if related_select_mask is None and hasattr(related_field, 'remote_field'):\n+                # Handle reverse OneToOneField relations by checking if the reverse field\n+                # has a mask in select_mask\n+                reverse_field = related_field.remote_field\n+                if reverse_field and hasattr(reverse_field, 'one_to_one') and reverse_field.one_to_one:\n+                    related_select_mask = select_mask.get(reverse_field)\n+            related_select_mask = related_select_mask or {}\n                 for col in columns:\n                     select_fields.append(len(select))\n                     select.append((col, None))\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 781dfd5499..f8971c6f6b 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -772,6 +772,7 @@ class Query(BaseExpression):\n             )\n         return select_mask\n \n+\n     def _get_only_select_mask(self, opts, mask, select_mask=None):\n         if select_mask is None:\n             select_mask = {}\n@@ -787,6 +788,12 @@ class Query(BaseExpression):\n                 self._get_only_select_mask(\n                     related_model._meta, field_mask, field_select_mask\n                 )\n+                # For OneToOneField relations, also map the reverse field object\n+                # to the same select mask to handle reverse relation lookups\n+                if hasattr(field, 'remote_field') and hasattr(field.remote_field, 'get_related_field'):\n+                    reverse_field = field.remote_field.get_related_field()\n+                    if reverse_field and hasattr(reverse_field, 'remote_field'):\n+                        select_mask[reverse_field] = field_select_mask\n         return select_mask\n \n     def get_select_mask(self):\n@@ -802,10 +809,44 @@ class Query(BaseExpression):\n         if not field_names:\n             return {}\n         mask = {}\n+\n+    def get_select_mask(self):\n+        \"\"\"\n+        Convert the self.deferred_loading data into a data structure, describing\n+        the field that *will* be loaded. This is used to compute the columns to\n+        select from the database and also by the QuerySet class to work out\n+        which fields are being initialized on each model. Models that have all\n+        their fields included aren't mentioned in the result, only those that\n+        have field restrictions in place.\n+        \"\"\"\n+        field_names, defer = self.deferred_loading\n+        if not field_names:\n+            return {}\n+        mask = {}\n         for field_name in field_names:\n             part_mask = mask\n-            for part in field_name.split(LOOKUP_SEP):\n-                part_mask = part_mask.setdefault(part, {})\n+            parts = field_name.split(LOOKUP_SEP)\n+            for i, part in enumerate(parts):\n+                # Check if this is the last part and represents a reverse OneToOneField\n+                if i == len(parts) - 1:\n+                    # Get the current model's options\n+                    current_opts = self.get_meta()\n+                    # Check if this field name corresponds to a reverse OneToOneField\n+                    try:\n+                        field = current_opts.get_field(part)\n+                        if hasattr(field, 'remote_field') and field.remote_field and field.remote_field.one_to_one:\n+                            # For reverse OneToOneField, also create mapping using the field object\n+                            part_mask = part_mask.setdefault(part, {})\n+                            # Store the field object as well for reverse lookup compatibility\n+                            if hasattr(field, 'remote_field') and field.remote_field:\n+                                reverse_field = field.remote_field\n+                                part_mask.setdefault('__field_obj__', reverse_field)\n+                        else:\n+                            part_mask = part_mask.setdefault(part, {})\n+                    except FieldDoesNotExist:\n+                        part_mask = part_mask.setdefault(part, {})\n+                else:\n+                    part_mask = part_mask.setdefault(part, {})\n         opts = self.get_meta()\n         if defer:\n             return self._get_defer_select_mask(opts, mask)\n",
    "variant_7": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex b28dc925ba..ebc949e15b 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -990,8 +990,13 @@ class SQLCompiler:\n                 # parent model data is already present in the SELECT clause,\n                 # and we want to avoid reloading the same data again.\n                 continue\n-            if select_mask and field not in select_mask:\n-                continue\n+\n+        related_select_mask = select_mask.get(related_field)\n+        if related_select_mask is None and hasattr(related_field, 'remote_field') and related_field.remote_field:\n+            # Handle reverse OneToOneField relations by looking up the forward field\n+            forward_field = related_field.remote_field\n+            related_select_mask = select_mask.get(forward_field)\n+        related_select_mask = related_select_mask or {}\n             alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n             column = field.get_col(alias)\n             result.append(column)\n@@ -1243,6 +1248,11 @@ class SQLCompiler:\n             )\n             get_related_klass_infos(klass_info, next_klass_infos)\n \n+        if restricted:\n+            related_fields = [\n+                (o.field, o.related_model)\n+                for o in opts.related_objects\n+\n         if restricted:\n             related_fields = [\n                 (o.field, o.related_model)\n@@ -1250,7 +1260,14 @@ class SQLCompiler:\n                 if o.field.unique and not o.many_to_many\n             ]\n             for related_field, model in related_fields:\n-                related_select_mask = select_mask.get(related_field) or {}\n+                # Handle reverse OneToOneField relations by checking for the forward field\n+                if hasattr(related_field, 'remote_field') and related_field.remote_field:\n+                    # For reverse relations, try to get the mask using the forward field\n+                    forward_field = related_field.remote_field\n+                    related_select_mask = select_mask.get(forward_field) or select_mask.get(related_field) or {}\n+                else:\n+                    related_select_mask = select_mask.get(related_field) or {}\n+                \n                 if not select_related_descend(\n                     related_field,\n                     restricted,\n@@ -1278,12 +1295,15 @@ class SQLCompiler:\n                 }\n                 related_klass_infos.append(klass_info)\n                 select_fields = []\n-                columns = self.get_default_columns(\n-                    related_select_mask,\n-                    start_alias=alias,\n-                    opts=model._meta,\n-                    from_parent=opts.model,\n-                )\n+\n+            if related_field.many_to_many:\n+                continue\n+            related_select_mask = select_mask.get(related_field)\n+            # Handle reverse OneToOneField relations by checking for the reverse field\n+            if related_select_mask is None and hasattr(related_field, 'remote_field'):\n+                # For reverse OneToOneField, try to find the mask using the remote field\n+                related_select_mask = select_mask.get(related_field.remote_field)\n+            related_select_mask = related_select_mask or {}\n                 for col in columns:\n                     select_fields.append(len(select))\n                     select.append((col, None))\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 781dfd5499..a4d1430eb3 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -772,6 +772,7 @@ class Query(BaseExpression):\n             )\n         return select_mask\n \n+\n     def _get_only_select_mask(self, opts, mask, select_mask=None):\n         if select_mask is None:\n             select_mask = {}\n@@ -787,6 +788,13 @@ class Query(BaseExpression):\n                 self._get_only_select_mask(\n                     related_model._meta, field_mask, field_select_mask\n                 )\n+            # For OneToOneField relations, also map the reverse field to ensure\n+            # both forward and reverse lookups work in the select mask\n+            if field.one_to_one and hasattr(field.remote_field, 'related_model'):\n+                reverse_field = field.remote_field\n+                if reverse_field and hasattr(reverse_field, 'get_accessor_name'):\n+                    # Map the reverse field object to the same selection mask\n+                    select_mask[reverse_field] = field_select_mask\n         return select_mask\n \n     def get_select_mask(self):\n@@ -802,9 +810,52 @@ class Query(BaseExpression):\n         if not field_names:\n             return {}\n         mask = {}\n+\n+    def get_select_mask(self):\n+        \"\"\"\n+        Convert the self.deferred_loading data into a dictionary suitable for\n+        use in rendering the select clause. The keys are the field names and the\n+        values are the field objects.\n+\n+        This is used to implement select_related() (only loading the needed\n+        values) and also for implementing the load_on_demand from deferred\n+        loading.\n+\n+        The method returns a dictionary of field_name -> field_object for all\n+        the fields that need to be loaded. This is then used by the QuerySet\n+        class to work out which fields are being initialized on each model.\n+\n+        The return value is a dictionary, where the keys are field names and\n+        the values are dictionaries. This is a nested data structure, like\n+        this:\n+            {\n+                'field1': {},\n+                'field2': {\n+                    'subfield1': {},\n+                    'subfield2': {},\n+                },\n+            }\n+\n+        The empty dictionaries are used to represent the fact that the field\n+        should be loaded, but no subfields of that field should be loaded. This\n+        is used by the select_related() code.\n+\n+        Note that this data structure is converted into a different format by\n+        the _get_defer_select_mask() and _get_only_select_mask() methods. That\n+        structure, describing the field that *will* be loaded. This is used to\n+        compute the columns to select from the database and also by the\n+        QuerySet class to work out which fields are being initialized on each\n+        model. Models that have all their fields included aren't mentioned in\n+        the result, only those that have field restrictions in place.\n+        \"\"\"\n+        field_names, defer = self.deferred_loading\n+        if not field_names:\n+            return {}\n+        mask = {}\n         for field_name in field_names:\n             part_mask = mask\n-            for part in field_name.split(LOOKUP_SEP):\n+            parts = field_name.split(LOOKUP_SEP)\n+            for part in parts:\n                 part_mask = part_mask.setdefault(part, {})\n         opts = self.get_meta()\n         if defer:\n",
    "variant_8": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex b28dc925ba..fbb03bdabc 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -990,8 +990,13 @@ class SQLCompiler:\n                 # parent model data is already present in the SELECT clause,\n                 # and we want to avoid reloading the same data again.\n                 continue\n-            if select_mask and field not in select_mask:\n-                continue\n+\n+            related_select_mask = select_mask.get(related_field) or {}\n+            \n+            # Handle reverse OneToOneField relations by checking the remote field\n+            if not related_select_mask and hasattr(related_field, 'remote_field') and related_field.remote_field:\n+                # For reverse OneToOneField relations, try the remote field as the key\n+                related_select_mask = select_mask.get(related_field.remote_field) or {}\n             alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n             column = field.get_col(alias)\n             result.append(column)\n@@ -1243,6 +1248,11 @@ class SQLCompiler:\n             )\n             get_related_klass_infos(klass_info, next_klass_infos)\n \n+        if restricted:\n+            related_fields = [\n+                (o.field, o.related_model)\n+                for o in opts.related_objects\n+\n         if restricted:\n             related_fields = [\n                 (o.field, o.related_model)\n@@ -1250,7 +1260,13 @@ class SQLCompiler:\n                 if o.field.unique and not o.many_to_many\n             ]\n             for related_field, model in related_fields:\n-                related_select_mask = select_mask.get(related_field) or {}\n+                # Handle reverse OneToOneField relations by checking for forward field mapping\n+                related_select_mask = select_mask.get(related_field)\n+                if related_select_mask is None and hasattr(related_field, 'remote_field'):\n+                    # For reverse relations, try to find the mask using the forward field\n+                    forward_field = related_field.remote_field\n+                    related_select_mask = select_mask.get(forward_field)\n+                related_select_mask = related_select_mask or {}\n                 if not select_related_descend(\n                     related_field,\n                     restricted,\n@@ -1278,12 +1294,24 @@ class SQLCompiler:\n                 }\n                 related_klass_infos.append(klass_info)\n                 select_fields = []\n-                columns = self.get_default_columns(\n-                    related_select_mask,\n-                    start_alias=alias,\n-                    opts=model._meta,\n-                    from_parent=opts.model,\n-                )\n+\n+            related_field = related_klass_info[\"field\"]\n+            related_select_mask = select_mask.get(related_field)\n+            \n+            # Handle reverse OneToOneField relations by checking if we need to look up\n+            # the mask using the remote field instead\n+            if related_select_mask is None and hasattr(related_field, 'remote_field'):\n+                # For reverse relations, try to find the mask using the forward field\n+                remote_field = related_field.remote_field\n+                if remote_field and hasattr(remote_field, 'name'):\n+                    # Look for the mask using the forward field name path\n+                    for mask_key, mask_value in select_mask.items():\n+                        if (hasattr(mask_key, 'name') and mask_key.name == remote_field.name and\n+                            hasattr(mask_key, 'model') and mask_key.model == remote_field.model):\n+                            related_select_mask = mask_value\n+                            break\n+            \n+            related_select_mask = related_select_mask or {}\n                 for col in columns:\n                     select_fields.append(len(select))\n                     select.append((col, None))\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 781dfd5499..a784a7beab 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -772,6 +772,7 @@ class Query(BaseExpression):\n             )\n         return select_mask\n \n+\n     def _get_only_select_mask(self, opts, mask, select_mask=None):\n         if select_mask is None:\n             select_mask = {}\n@@ -787,6 +788,11 @@ class Query(BaseExpression):\n                 self._get_only_select_mask(\n                     related_model._meta, field_mask, field_select_mask\n                 )\n+                # For OneToOneField relations, also map the reverse field\n+                if hasattr(field, 'remote_field') and hasattr(field.remote_field, 'related_model'):\n+                    reverse_field = field.remote_field\n+                    if hasattr(reverse_field, 'field') and reverse_field.field not in select_mask:\n+                        select_mask[reverse_field.field] = field_select_mask\n         return select_mask\n \n     def get_select_mask(self):\n@@ -802,6 +808,19 @@ class Query(BaseExpression):\n         if not field_names:\n             return {}\n         mask = {}\n+\n+    def get_select_mask(self):\n+        \"\"\"\n+        Convert the self.deferred_loading data into a dictionary suitable for use\n+        in get_default_columns().\n+        \"\"\"\n+        if self.deferred_loading == (frozenset(), True):\n+            return {}\n+        # Reverse of an empty deferred_loading means defer everything.\n+        field_names, defer = self.deferred_loading\n+        if not field_names:\n+            return {}\n+        mask = {}\n         for field_name in field_names:\n             part_mask = mask\n             for part in field_name.split(LOOKUP_SEP):\n"
  }
}