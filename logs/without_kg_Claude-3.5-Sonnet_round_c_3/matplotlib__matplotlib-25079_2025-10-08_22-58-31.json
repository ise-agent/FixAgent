{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/matplotlib/lib/matplotlib/colors.py lines 1363-1366)": "\n    def autoscale(self, A):\n        \"\"\"Set *vmin*, *vmax* to min, max of *A*.\"\"\"\n        # Only reset vmin/vmax if they are not already properly set\n        # This prevents race conditions during drawing operations\n        if self.vmin is None or self.vmax is None:\n            self.vmin = self.vmax = None\n            self.autoscale_None(A)\n",
    "Location 2 (/root/hy/projects_3/matplotlib/lib/matplotlib/colors.py lines 1682-1697)": "\n        def __call__(self, value, clip=None):\n            value, is_scalar = self.process_value(value)\n            if self.vmin is None or self.vmax is None:\n                self.autoscale_None(value)\n            if self.vmin > self.vmax:\n                raise ValueError(\"vmin must be less or equal to vmax\")\n            if self.vmin == self.vmax:\n                return np.full_like(value, 0)\n            if clip is None:\n                clip = self.clip\n            if clip:\n                value = np.clip(value, self.vmin, self.vmax)\n            t_value = self._trf.transform(value).reshape(np.shape(value))\n            # Only validate transform results if vmin/vmax are not None\n            if self.vmin is not None and self.vmax is not None:\n                t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n                if not np.isfinite([t_vmin, t_vmax]).all():\n                    raise ValueError(\"Invalid vmin or vmax\")\n            else:\n                # Fallback case - should not happen with proper autoscale_None\n                t_vmin, t_vmax = 0.0, 1.0\n",
    "Location 3 (/root/hy/projects_3/matplotlib/lib/matplotlib/colors.py lines 1368-1374)": "\ndef autoscale_None(self, A):\n    \"\"\"If vmin or vmax are not set, use the min/max of *A* to set them.\"\"\"\n    A = np.asanyarray(A)\n    if self.vmin is None and A.size:\n        min_val = A.min()\n        # For LogNorm, ensure vmin is positive\n        if hasattr(self, '_transform') and hasattr(self._transform, 'transform_non_affine'):\n            if min_val <= 0:\n                min_val = np.min(A[A > 0]) if np.any(A > 0) else 1e-10\n        self.vmin = min_val\n    if self.vmax is None and A.size:\n        max_val = A.max()\n        # For LogNorm, ensure vmax is positive\n        if hasattr(self, '_transform') and hasattr(self._transform, 'transform_non_affine'):\n            if max_val <= 0:\n                max_val = 1.0\n        self.vmax = max_val\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/matplotlib/lib/matplotlib/colors.py lines 1363-1366)": [
      "\n    def autoscale(self, A):\n        \"\"\"Set *vmin*, *vmax* to min, max of *A*.\"\"\"\n        # Only reset vmin/vmax if they are not already set with valid values\n        if self.vmin is None or self.vmax is None:\n            self.vmin = self.vmax = None\n            self.autoscale_None(A)\n",
      "\n    def autoscale(self, A):\n        \"\"\"Set *vmin*, *vmax* to min, max of *A*.\"\"\"\n        # Only reset vmin/vmax if they are not already set with valid values\n        if self.vmin is None or self.vmax is None:\n            self.vmin = self.vmax = None\n            self.autoscale_None(A)\n",
      "\ndef autoscale(self, A):\n    \"\"\"Set *vmin*, *vmax* to min, max of *A*.\"\"\"\n    # Only reset vmin/vmax if they are not already set with valid values\n    if self.vmin is None or self.vmax is None:\n        self.vmin = self.vmax = None\n        self.autoscale_None(A)\n",
      "\n    def autoscale(self, A):\n        \"\"\"Set *vmin*, *vmax* to min, max of *A*.\"\"\"\n        # Only reset vmin/vmax if they are not already properly set\n        # This prevents race conditions during drawing operations\n        if self.vmin is None or self.vmax is None:\n            self.vmin = self.vmax = None\n            self.autoscale_None(A)\n        else:\n            # If both vmin and vmax are already set, still call autoscale_None\n            # to handle any edge cases, but don't reset the values first\n            self.autoscale_None(A)\n",
      "\n    def autoscale(self, A):\n        \"\"\"Set *vmin*, *vmax* to min, max of *A*.\"\"\"\n        # Only reset vmin/vmax if they are not already properly set\n        A = np.asanyarray(A)\n        if A.size == 0:\n            # No data to autoscale from, keep existing values if valid\n            return\n        \n        # Reset and recalculate vmin/vmax from the data\n        self.vmin = self.vmax = None\n        self.autoscale_None(A)\n",
      "\n    def autoscale(self, A):\n        \"\"\"Set *vmin*, *vmax* to min, max of *A*.\"\"\"\n        # Only reset vmin/vmax if they are not already set with valid values\n        if self.vmin is None or self.vmax is None:\n            self.vmin = self.vmax = None\n            self.autoscale_None(A)\n",
      "\n    def autoscale(self, A):\n        \"\"\"Set *vmin*, *vmax* to min, max of *A*.\"\"\"\n        # Only reset vmin/vmax if they are not already properly set\n        A = np.asanyarray(A)\n        if A.size == 0:\n            return\n        \n        # For LogNorm, we need to ensure positive values\n        if hasattr(self, '_transform') and hasattr(self._transform, '_transform_non_affine'):\n            # This is likely a LogNorm or similar transform\n            A_positive = A[A > 0] if A.size > 0 else A\n            if A_positive.size > 0:\n                self.vmin = A_positive.min()\n                self.vmax = A_positive.max()\n        else:\n            self.vmin = A.min()\n            self.vmax = A.max()\n",
      "\n    def autoscale(self, A):\n        \"\"\"Set *vmin*, *vmax* to min, max of *A*.\"\"\"\n        # Only reset vmin/vmax if they are not already set with valid values\n        if self.vmin is None or self.vmax is None:\n            self.vmin = self.vmax = None\n            self.autoscale_None(A)\n"
    ],
    "Location 2 (/root/hy/projects_3/matplotlib/lib/matplotlib/colors.py lines 1682-1697)": [
      "\n        def __call__(self, value, clip=None):\n            value, is_scalar = self.process_value(value)\n            if self.vmin is None or self.vmax is None:\n                self.autoscale_None(value)\n            if self.vmin > self.vmax:\n                raise ValueError(\"vmin must be less or equal to vmax\")\n            if self.vmin == self.vmax:\n                return np.full_like(value, 0)\n            if clip is None:\n                clip = self.clip\n            if clip:\n                value = np.clip(value, self.vmin, self.vmax)\n            t_value = self._trf.transform(value).reshape(np.shape(value))\n            # Only validate transform if vmin/vmax are not None\n            if self.vmin is not None and self.vmax is not None:\n                t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n                if not np.isfinite([t_vmin, t_vmax]).all():\n                    raise ValueError(\"Invalid vmin or vmax\")\n            else:\n                # Fallback to identity transform bounds if vmin/vmax are None\n                t_vmin, t_vmax = 0, 1\n",
      "\n        def __call__(self, value, clip=None):\n            value, is_scalar = self.process_value(value)\n            if self.vmin is None or self.vmax is None:\n                self.autoscale_None(value)\n            if self.vmin > self.vmax:\n                raise ValueError(\"vmin must be less or equal to vmax\")\n            if self.vmin == self.vmax:\n                return np.full_like(value, 0)\n            if clip is None:\n                clip = self.clip\n            if clip:\n                value = np.clip(value, self.vmin, self.vmax)\n            t_value = self._trf.transform(value).reshape(np.shape(value))\n            # Only validate transform if vmin/vmax are not None\n            if self.vmin is not None and self.vmax is not None:\n                t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n                if not np.isfinite([t_vmin, t_vmax]).all():\n                    raise ValueError(\"Invalid vmin or vmax\")\n                t_value -= t_vmin\n                t_value /= (t_vmax - t_vmin)\n            t_value = np.ma.masked_invalid(t_value, copy=False)\n            return t_value[0] if is_scalar else t_value\n",
      "\n        def __call__(self, value, clip=None):\n            value, is_scalar = self.process_value(value)\n            if self.vmin is None or self.vmax is None:\n                self.autoscale_None(value)\n            if self.vmin > self.vmax:\n                raise ValueError(\"vmin must be less or equal to vmax\")\n            if self.vmin == self.vmax:\n                return np.full_like(value, 0)\n            if clip is None:\n                clip = self.clip\n            if clip:\n                value = np.clip(value, self.vmin, self.vmax)\n            t_value = self._trf.transform(value).reshape(np.shape(value))\n            # Check if vmin/vmax are None before transforming to avoid invalid transforms\n            if self.vmin is not None and self.vmax is not None:\n                t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n                if not np.isfinite([t_vmin, t_vmax]).all():\n                    raise ValueError(\"Invalid vmin or vmax\")\n            else:\n                # If vmin/vmax are None, we can't validate the transform\n                # This should not happen after autoscale_None, but handle gracefully\n                raise ValueError(\"vmin and vmax must be set before normalization\")\n",
      "\n        def __call__(self, value, clip=None):\n            value, is_scalar = self.process_value(value)\n            if self.vmin is None or self.vmax is None:\n                self.autoscale_None(value)\n            if self.vmin > self.vmax:\n                raise ValueError(\"vmin must be less or equal to vmax\")\n            if self.vmin == self.vmax:\n                return np.full_like(value, 0)\n            if clip is None:\n                clip = self.clip\n            if clip:\n                value = np.clip(value, self.vmin, self.vmax)\n            t_value = self._trf.transform(value).reshape(np.shape(value))\n            # Only validate transformed bounds if vmin/vmax are not None\n            if self.vmin is not None and self.vmax is not None:\n                t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n                if not np.isfinite([t_vmin, t_vmax]).all():\n                    raise ValueError(\"Invalid vmin or vmax\")\n                t_value -= t_vmin\n                t_value /= (t_vmax - t_vmin)\n            t_value = np.ma.masked_invalid(t_value, copy=False)\n            return t_value[0] if is_scalar else t_value\n",
      "\n        def __call__(self, value, clip=None):\n            value, is_scalar = self.process_value(value)\n            if self.vmin is None or self.vmax is None:\n                self.autoscale_None(value)\n            if self.vmin > self.vmax:\n                raise ValueError(\"vmin must be less or equal to vmax\")\n            if self.vmin == self.vmax:\n                return np.full_like(value, 0)\n            if clip is None:\n                clip = self.clip\n            if clip:\n                value = np.clip(value, self.vmin, self.vmax)\n            t_value = self._trf.transform(value).reshape(np.shape(value))\n            # Defensive check: ensure vmin/vmax are not None before transform validation\n            if self.vmin is not None and self.vmax is not None:\n                t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n                if not np.isfinite([t_vmin, t_vmax]).all():\n                    raise ValueError(\"Invalid vmin or vmax\")\n                t_value -= t_vmin\n                t_value /= (t_vmax - t_vmin)\n            t_value = np.ma.masked_invalid(t_value, copy=False)\n            return t_value[0] if is_scalar else t_value\n",
      "\n        def __call__(self, value, clip=None):\n            value, is_scalar = self.process_value(value)\n            if self.vmin is None or self.vmax is None:\n                self.autoscale_None(value)\n            if self.vmin > self.vmax:\n                raise ValueError(\"vmin must be less or equal to vmax\")\n            if self.vmin == self.vmax:\n                return np.full_like(value, 0)\n            if clip is None:\n                clip = self.clip\n            if clip:\n                value = np.clip(value, self.vmin, self.vmax)\n            t_value = self._trf.transform(value).reshape(np.shape(value))\n            # Check that vmin and vmax are not None before transforming\n            if self.vmin is not None and self.vmax is not None:\n                t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n                if not np.isfinite([t_vmin, t_vmax]).all():\n                    raise ValueError(\"Invalid vmin or vmax\")\n            else:\n                # If vmin or vmax are still None, we can't proceed with normalization\n                raise ValueError(\"vmin and vmax must be set before normalization\")\n            t_value -= t_vmin\n            t_value /= (t_vmax - t_vmin)\n            t_value = np.ma.masked_invalid(t_value, copy=False)\n            return t_value[0] if is_scalar else t_value\n",
      "\n        def __call__(self, value, clip=None):\n            value, is_scalar = self.process_value(value)\n            if self.vmin is None or self.vmax is None:\n                self.autoscale_None(value)\n            if self.vmin > self.vmax:\n                raise ValueError(\"vmin must be less or equal to vmax\")\n            if self.vmin == self.vmax:\n                return np.full_like(value, 0)\n            if clip is None:\n                clip = self.clip\n            if clip:\n                value = np.clip(value, self.vmin, self.vmax)\n            t_value = self._trf.transform(value).reshape(np.shape(value))\n            # Check that vmin and vmax are not None before transforming\n            if self.vmin is not None and self.vmax is not None:\n                t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n                if not np.isfinite([t_vmin, t_vmax]).all():\n                    raise ValueError(\"Invalid vmin or vmax\")\n            else:\n                raise ValueError(\"vmin and vmax must be set\")\n            t_value -= t_vmin\n            t_value /= (t_vmax - t_vmin)\n            t_value = np.ma.masked_invalid(t_value, copy=False)\n            return t_value[0] if is_scalar else t_value\n",
      "\n        def __call__(self, value, clip=None):\n            value, is_scalar = self.process_value(value)\n            if self.vmin is None or self.vmax is None:\n                self.autoscale_None(value)\n            if self.vmin > self.vmax:\n                raise ValueError(\"vmin must be less or equal to vmax\")\n            if self.vmin == self.vmax:\n                return np.full_like(value, 0)\n            if clip is None:\n                clip = self.clip\n            if clip:\n                value = np.clip(value, self.vmin, self.vmax)\n            t_value = self._trf.transform(value).reshape(np.shape(value))\n            # Check if vmin/vmax are None before transforming to avoid race condition\n            if self.vmin is not None and self.vmax is not None:\n                t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n                if not np.isfinite([t_vmin, t_vmax]).all():\n                    raise ValueError(\"Invalid vmin or vmax\")\n            else:\n                raise ValueError(\"vmin and vmax must be set\")\n            t_value -= t_vmin\n            t_value /= (t_vmax - t_vmin)\n            t_value = np.ma.masked_invalid(t_value, copy=False)\n            return t_value[0] if is_scalar else t_value\n"
    ],
    "Location 3 (/root/hy/projects_3/matplotlib/lib/matplotlib/colors.py lines 1368-1374)": [
      "\ndef autoscale_None(self, A):\n    \"\"\"If vmin or vmax are not set, use the min/max of *A* to set them.\"\"\"\n    A = np.asanyarray(A)\n    if self.vmin is None and A.size:\n        min_val = A.min()\n        # For LogNorm, ensure vmin is positive\n        if hasattr(self, '_transform') and hasattr(self._transform, 'transform_non_affine'):\n            if min_val <= 0:\n                min_val = np.min(A[A > 0]) if np.any(A > 0) else 1e-10\n        self.vmin = min_val\n    if self.vmax is None and A.size:\n        max_val = A.max()\n        # For LogNorm, ensure vmax is positive\n        if hasattr(self, '_transform') and hasattr(self._transform, 'transform_non_affine'):\n            if max_val <= 0:\n                max_val = 1.0\n        self.vmax = max_val\n",
      "\ndef autoscale_None(self, A):\n    \"\"\"If vmin or vmax are not set, use the min/max of *A* to set them.\"\"\"\n    A = np.asanyarray(A)\n    if self.vmin is None and A.size:\n        min_val = A.min()\n        # For LogNorm, ensure vmin is positive\n        if hasattr(self, '_transform') and min_val <= 0:\n            # Find the smallest positive value or use a small default\n            positive_vals = A[A > 0]\n            if positive_vals.size > 0:\n                self.vmin = positive_vals.min()\n            else:\n                self.vmin = 1e-10\n        else:\n            self.vmin = min_val\n    if self.vmax is None and A.size:\n        max_val = A.max()\n        # For LogNorm, ensure vmax is positive\n        if hasattr(self, '_transform') and max_val <= 0:\n            # If all values are non-positive, set a reasonable default\n            self.vmax = 1.0\n        else:\n            self.vmax = max_val\n",
      "\n    def autoscale_None(self, A):\n        \"\"\"If vmin or vmax are not set, use the min/max of *A* to set them.\"\"\"\n        A = np.asanyarray(A)\n        if self.vmin is None and A.size:\n            min_val = A.min()\n            # For LogNorm, ensure vmin is positive\n            if hasattr(self, '_transform') and min_val <= 0:\n                # Find the smallest positive value or use a small default\n                positive_vals = A[A > 0]\n                if positive_vals.size > 0:\n                    self.vmin = positive_vals.min()\n                else:\n                    self.vmin = 1e-10\n            else:\n                self.vmin = min_val\n        if self.vmax is None and A.size:\n            max_val = A.max()\n            # For LogNorm, ensure vmax is positive\n            if hasattr(self, '_transform') and max_val <= 0:\n                # Use a reasonable default if all values are non-positive\n                self.vmax = 1.0\n            else:\n                self.vmax = max_val\n",
      "\n    def autoscale_None(self, A):\n        \"\"\"If vmin or vmax are not set, use the min/max of *A* to set them.\"\"\"\n        A = np.asanyarray(A)\n        if self.vmin is None and A.size:\n            min_val = A.min()\n            # For LogNorm, ensure vmin is positive\n            if hasattr(self, '_transform') and hasattr(self, '_inverse'):\n                # This is likely a LogNorm or similar that requires positive values\n                min_val = max(min_val, np.finfo(float).eps)\n            self.vmin = min_val\n        if self.vmax is None and A.size:\n            max_val = A.max()\n            # For LogNorm, ensure vmax is positive\n            if hasattr(self, '_transform') and hasattr(self, '_inverse'):\n                # This is likely a LogNorm or similar that requires positive values\n                max_val = max(max_val, np.finfo(float).eps)\n            self.vmax = max_val\n",
      "\ndef autoscale_None(self, A):\n    \"\"\"If vmin or vmax are not set, use the min/max of *A* to set them.\"\"\"\n    A = np.asanyarray(A)\n    if self.vmin is None and A.size:\n        min_val = A.min()\n        # For LogNorm, ensure vmin is positive\n        if hasattr(self, '_transform') and min_val <= 0:\n            # Find the smallest positive value or use a small default\n            positive_vals = A[A > 0]\n            if positive_vals.size > 0:\n                min_val = positive_vals.min()\n            else:\n                min_val = 1e-10\n        self.vmin = min_val\n    if self.vmax is None and A.size:\n        max_val = A.max()\n        # For LogNorm, ensure vmax is positive\n        if hasattr(self, '_transform') and max_val <= 0:\n            max_val = 1.0  # Default positive value\n        self.vmax = max_val\n",
      "\ndef autoscale_None(self, A):\n    \"\"\"If vmin or vmax are not set, use the min/max of *A* to set them.\"\"\"\n    A = np.asanyarray(A)\n    if self.vmin is None and A.size:\n        self.vmin = A.min()\n    if self.vmax is None and A.size:\n        self.vmax = A.max()\n",
      "\ndef autoscale_None(self, A):\n    \"\"\"If vmin or vmax are not set, use the min/max of *A* to set them.\"\"\"\n    A = np.asanyarray(A)\n    if self.vmin is None and A.size:\n        min_val = A.min()\n        # For LogNorm, ensure vmin is positive\n        if hasattr(self, '_transform') and min_val <= 0:\n            positive_vals = A[A > 0]\n            if positive_vals.size > 0:\n                self.vmin = positive_vals.min()\n            else:\n                self.vmin = 1e-10  # fallback for all non-positive data\n        else:\n            self.vmin = min_val\n    if self.vmax is None and A.size:\n        max_val = A.max()\n        # For LogNorm, ensure vmax is positive\n        if hasattr(self, '_transform') and max_val <= 0:\n            positive_vals = A[A > 0]\n            if positive_vals.size > 0:\n                self.vmax = positive_vals.max()\n            else:\n                self.vmax = 1.0  # fallback for all non-positive data\n        else:\n            self.vmax = max_val\n",
      "\ndef autoscale_None(self, A):\n    \"\"\"If vmin or vmax are not set, use the min/max of *A* to set them.\"\"\"\n    A = np.asanyarray(A)\n    if self.vmin is None and A.size:\n        self.vmin = A.min()\n        # For LogNorm, ensure vmin is positive\n        if hasattr(self, '_transform') and hasattr(self._transform, 'base'):\n            self.vmin = max(self.vmin, np.finfo(float).eps)\n    if self.vmax is None and A.size:\n        self.vmax = A.max()\n        # For LogNorm, ensure vmax is positive\n        if hasattr(self, '_transform') and hasattr(self._transform, 'base'):\n            self.vmax = max(self.vmax, np.finfo(float).eps)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex f9e4dcbd62..52d5f69e0e 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1360,11 +1360,17 @@ class Normalize:\n         else:\n             return vmin + value * (vmax - vmin)\n \n+\n     def autoscale(self, A):\n         \"\"\"Set *vmin*, *vmax* to min, max of *A*.\"\"\"\n-        self.vmin = self.vmax = None\n+        # Only reset vmin/vmax to None if they need to be recalculated from data\n+        # This prevents the race condition where valid values are temporarily set to None\n+        if not self.scaled():\n+            # If vmin/vmax are not set, we need to calculate them from data\n+            self.vmin = self.vmax = None\n         self.autoscale_None(A)\n \n+\n     def autoscale_None(self, A):\n         \"\"\"If vmin or vmax are not set, use the min/max of *A* to set them.\"\"\"\n         A = np.asanyarray(A)\n@@ -1679,6 +1685,7 @@ def _make_norm_from_scale(\n             inspect.Parameter(\"self\", inspect.Parameter.POSITIONAL_OR_KEYWORD),\n             *bound_init_signature.parameters.values()])\n \n+\n         def __call__(self, value, clip=None):\n             value, is_scalar = self.process_value(value)\n             if self.vmin is None or self.vmax is None:\n@@ -1692,8 +1699,14 @@ def _make_norm_from_scale(\n             if clip:\n                 value = np.clip(value, self.vmin, self.vmax)\n             t_value = self._trf.transform(value).reshape(np.shape(value))\n-            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n-            if not np.isfinite([t_vmin, t_vmax]).all():\n+            # Add defensive validation to ensure vmin/vmax are not None before transform\n+            if self.vmin is not None and self.vmax is not None:\n+                t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n+                if not np.isfinite([t_vmin, t_vmax]).all():\n+                    raise ValueError(\"Invalid vmin or vmax\")\n+            else:\n+                # If vmin/vmax are None, we can't validate the transform\n+                # This should not happen if autoscale_None worked correctly\n                 raise ValueError(\"Invalid vmin or vmax\")\n             t_value -= t_vmin\n             t_value /= (t_vmax - t_vmin)\n",
    "variant_0": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex f9e4dcbd62..7206bdc573 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1360,18 +1360,33 @@ class Normalize:\n         else:\n             return vmin + value * (vmax - vmin)\n \n+\n     def autoscale(self, A):\n         \"\"\"Set *vmin*, *vmax* to min, max of *A*.\"\"\"\n-        self.vmin = self.vmax = None\n-        self.autoscale_None(A)\n-\n-    def autoscale_None(self, A):\n-        \"\"\"If vmin or vmax are not set, use the min/max of *A* to set them.\"\"\"\n-        A = np.asanyarray(A)\n-        if self.vmin is None and A.size:\n-            self.vmin = A.min()\n-        if self.vmax is None and A.size:\n-            self.vmax = A.max()\n+        # Only reset vmin/vmax if they are not already properly set\n+        # This prevents race conditions during drawing operations\n+        if self.vmin is None or self.vmax is None:\n+            self.vmin = self.vmax = None\n+            self.autoscale_None(A)\n+\n+\n+def autoscale_None(self, A):\n+    \"\"\"If vmin or vmax are not set, use the min/max of *A* to set them.\"\"\"\n+    A = np.asanyarray(A)\n+    if self.vmin is None and A.size:\n+        min_val = A.min()\n+        # For LogNorm, ensure vmin is positive\n+        if hasattr(self, '_transform') and hasattr(self._transform, 'transform_non_affine'):\n+            if min_val <= 0:\n+                min_val = np.min(A[A > 0]) if np.any(A > 0) else 1e-10\n+        self.vmin = min_val\n+    if self.vmax is None and A.size:\n+        max_val = A.max()\n+        # For LogNorm, ensure vmax is positive\n+        if hasattr(self, '_transform') and hasattr(self._transform, 'transform_non_affine'):\n+            if max_val <= 0:\n+                max_val = 1.0\n+        self.vmax = max_val\n \n     def scaled(self):\n         \"\"\"Return whether vmin and vmax are set.\"\"\"\n@@ -1679,6 +1694,7 @@ def _make_norm_from_scale(\n             inspect.Parameter(\"self\", inspect.Parameter.POSITIONAL_OR_KEYWORD),\n             *bound_init_signature.parameters.values()])\n \n+\n         def __call__(self, value, clip=None):\n             value, is_scalar = self.process_value(value)\n             if self.vmin is None or self.vmax is None:\n@@ -1692,9 +1708,14 @@ def _make_norm_from_scale(\n             if clip:\n                 value = np.clip(value, self.vmin, self.vmax)\n             t_value = self._trf.transform(value).reshape(np.shape(value))\n-            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n-            if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n+            # Only validate transform results if vmin/vmax are not None\n+            if self.vmin is not None and self.vmax is not None:\n+                t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n+                if not np.isfinite([t_vmin, t_vmax]).all():\n+                    raise ValueError(\"Invalid vmin or vmax\")\n+            else:\n+                # Fallback case - should not happen with proper autoscale_None\n+                t_vmin, t_vmax = 0.0, 1.0\n             t_value -= t_vmin\n             t_value /= (t_vmax - t_vmin)\n             t_value = np.ma.masked_invalid(t_value, copy=False)\n",
    "variant_1": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex f9e4dcbd62..01d699caa8 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1360,18 +1360,32 @@ class Normalize:\n         else:\n             return vmin + value * (vmax - vmin)\n \n+\n     def autoscale(self, A):\n         \"\"\"Set *vmin*, *vmax* to min, max of *A*.\"\"\"\n-        self.vmin = self.vmax = None\n-        self.autoscale_None(A)\n-\n-    def autoscale_None(self, A):\n-        \"\"\"If vmin or vmax are not set, use the min/max of *A* to set them.\"\"\"\n-        A = np.asanyarray(A)\n-        if self.vmin is None and A.size:\n-            self.vmin = A.min()\n-        if self.vmax is None and A.size:\n-            self.vmax = A.max()\n+        # Only reset vmin/vmax if they are not already set with valid values\n+        if self.vmin is None or self.vmax is None:\n+            self.vmin = self.vmax = None\n+            self.autoscale_None(A)\n+\n+\n+def autoscale_None(self, A):\n+    \"\"\"If vmin or vmax are not set, use the min/max of *A* to set them.\"\"\"\n+    A = np.asanyarray(A)\n+    if self.vmin is None and A.size:\n+        min_val = A.min()\n+        # For LogNorm, ensure vmin is positive\n+        if hasattr(self, '_transform') and hasattr(self._transform, 'transform_non_affine'):\n+            if min_val <= 0:\n+                min_val = np.min(A[A > 0]) if np.any(A > 0) else 1e-10\n+        self.vmin = min_val\n+    if self.vmax is None and A.size:\n+        max_val = A.max()\n+        # For LogNorm, ensure vmax is positive\n+        if hasattr(self, '_transform') and hasattr(self._transform, 'transform_non_affine'):\n+            if max_val <= 0:\n+                max_val = 1.0\n+        self.vmax = max_val\n \n     def scaled(self):\n         \"\"\"Return whether vmin and vmax are set.\"\"\"\n@@ -1679,6 +1693,7 @@ def _make_norm_from_scale(\n             inspect.Parameter(\"self\", inspect.Parameter.POSITIONAL_OR_KEYWORD),\n             *bound_init_signature.parameters.values()])\n \n+\n         def __call__(self, value, clip=None):\n             value, is_scalar = self.process_value(value)\n             if self.vmin is None or self.vmax is None:\n@@ -1692,9 +1707,14 @@ def _make_norm_from_scale(\n             if clip:\n                 value = np.clip(value, self.vmin, self.vmax)\n             t_value = self._trf.transform(value).reshape(np.shape(value))\n-            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n-            if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n+            # Only validate transform if vmin/vmax are not None\n+            if self.vmin is not None and self.vmax is not None:\n+                t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n+                if not np.isfinite([t_vmin, t_vmax]).all():\n+                    raise ValueError(\"Invalid vmin or vmax\")\n+            else:\n+                # Fallback to identity transform bounds if vmin/vmax are None\n+                t_vmin, t_vmax = 0, 1\n             t_value -= t_vmin\n             t_value /= (t_vmax - t_vmin)\n             t_value = np.ma.masked_invalid(t_value, copy=False)\n",
    "variant_2": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex f9e4dcbd62..780e90254d 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1360,18 +1360,38 @@ class Normalize:\n         else:\n             return vmin + value * (vmax - vmin)\n \n+\n     def autoscale(self, A):\n         \"\"\"Set *vmin*, *vmax* to min, max of *A*.\"\"\"\n-        self.vmin = self.vmax = None\n-        self.autoscale_None(A)\n-\n-    def autoscale_None(self, A):\n-        \"\"\"If vmin or vmax are not set, use the min/max of *A* to set them.\"\"\"\n-        A = np.asanyarray(A)\n-        if self.vmin is None and A.size:\n-            self.vmin = A.min()\n-        if self.vmax is None and A.size:\n-            self.vmax = A.max()\n+        # Only reset vmin/vmax if they are not already set with valid values\n+        if self.vmin is None or self.vmax is None:\n+            self.vmin = self.vmax = None\n+            self.autoscale_None(A)\n+\n+\n+def autoscale_None(self, A):\n+    \"\"\"If vmin or vmax are not set, use the min/max of *A* to set them.\"\"\"\n+    A = np.asanyarray(A)\n+    if self.vmin is None and A.size:\n+        min_val = A.min()\n+        # For LogNorm, ensure vmin is positive\n+        if hasattr(self, '_transform') and min_val <= 0:\n+            # Find the smallest positive value or use a small default\n+            positive_vals = A[A > 0]\n+            if positive_vals.size > 0:\n+                self.vmin = positive_vals.min()\n+            else:\n+                self.vmin = 1e-10\n+        else:\n+            self.vmin = min_val\n+    if self.vmax is None and A.size:\n+        max_val = A.max()\n+        # For LogNorm, ensure vmax is positive\n+        if hasattr(self, '_transform') and max_val <= 0:\n+            # If all values are non-positive, set a reasonable default\n+            self.vmax = 1.0\n+        else:\n+            self.vmax = max_val\n \n     def scaled(self):\n         \"\"\"Return whether vmin and vmax are set.\"\"\"\n@@ -1679,6 +1699,7 @@ def _make_norm_from_scale(\n             inspect.Parameter(\"self\", inspect.Parameter.POSITIONAL_OR_KEYWORD),\n             *bound_init_signature.parameters.values()])\n \n+\n         def __call__(self, value, clip=None):\n             value, is_scalar = self.process_value(value)\n             if self.vmin is None or self.vmax is None:\n@@ -1692,9 +1713,15 @@ def _make_norm_from_scale(\n             if clip:\n                 value = np.clip(value, self.vmin, self.vmax)\n             t_value = self._trf.transform(value).reshape(np.shape(value))\n-            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n-            if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n+            # Only validate transform if vmin/vmax are not None\n+            if self.vmin is not None and self.vmax is not None:\n+                t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n+                if not np.isfinite([t_vmin, t_vmax]).all():\n+                    raise ValueError(\"Invalid vmin or vmax\")\n+                t_value -= t_vmin\n+                t_value /= (t_vmax - t_vmin)\n+            t_value = np.ma.masked_invalid(t_value, copy=False)\n+            return t_value[0] if is_scalar else t_value\n             t_value -= t_vmin\n             t_value /= (t_vmax - t_vmin)\n             t_value = np.ma.masked_invalid(t_value, copy=False)\n",
    "variant_3": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex f9e4dcbd62..278b34b12a 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1360,18 +1360,38 @@ class Normalize:\n         else:\n             return vmin + value * (vmax - vmin)\n \n-    def autoscale(self, A):\n-        \"\"\"Set *vmin*, *vmax* to min, max of *A*.\"\"\"\n+\n+def autoscale(self, A):\n+    \"\"\"Set *vmin*, *vmax* to min, max of *A*.\"\"\"\n+    # Only reset vmin/vmax if they are not already set with valid values\n+    if self.vmin is None or self.vmax is None:\n         self.vmin = self.vmax = None\n         self.autoscale_None(A)\n \n+\n     def autoscale_None(self, A):\n         \"\"\"If vmin or vmax are not set, use the min/max of *A* to set them.\"\"\"\n         A = np.asanyarray(A)\n         if self.vmin is None and A.size:\n-            self.vmin = A.min()\n+            min_val = A.min()\n+            # For LogNorm, ensure vmin is positive\n+            if hasattr(self, '_transform') and min_val <= 0:\n+                # Find the smallest positive value or use a small default\n+                positive_vals = A[A > 0]\n+                if positive_vals.size > 0:\n+                    self.vmin = positive_vals.min()\n+                else:\n+                    self.vmin = 1e-10\n+            else:\n+                self.vmin = min_val\n         if self.vmax is None and A.size:\n-            self.vmax = A.max()\n+            max_val = A.max()\n+            # For LogNorm, ensure vmax is positive\n+            if hasattr(self, '_transform') and max_val <= 0:\n+                # Use a reasonable default if all values are non-positive\n+                self.vmax = 1.0\n+            else:\n+                self.vmax = max_val\n \n     def scaled(self):\n         \"\"\"Return whether vmin and vmax are set.\"\"\"\n@@ -1679,6 +1699,7 @@ def _make_norm_from_scale(\n             inspect.Parameter(\"self\", inspect.Parameter.POSITIONAL_OR_KEYWORD),\n             *bound_init_signature.parameters.values()])\n \n+\n         def __call__(self, value, clip=None):\n             value, is_scalar = self.process_value(value)\n             if self.vmin is None or self.vmax is None:\n@@ -1692,9 +1713,15 @@ def _make_norm_from_scale(\n             if clip:\n                 value = np.clip(value, self.vmin, self.vmax)\n             t_value = self._trf.transform(value).reshape(np.shape(value))\n-            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n-            if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n+            # Check if vmin/vmax are None before transforming to avoid invalid transforms\n+            if self.vmin is not None and self.vmax is not None:\n+                t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n+                if not np.isfinite([t_vmin, t_vmax]).all():\n+                    raise ValueError(\"Invalid vmin or vmax\")\n+            else:\n+                # If vmin/vmax are None, we can't validate the transform\n+                # This should not happen after autoscale_None, but handle gracefully\n+                raise ValueError(\"vmin and vmax must be set before normalization\")\n             t_value -= t_vmin\n             t_value /= (t_vmax - t_vmin)\n             t_value = np.ma.masked_invalid(t_value, copy=False)\n",
    "variant_4": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex f9e4dcbd62..fc3bab5738 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1360,18 +1360,37 @@ class Normalize:\n         else:\n             return vmin + value * (vmax - vmin)\n \n+\n     def autoscale(self, A):\n         \"\"\"Set *vmin*, *vmax* to min, max of *A*.\"\"\"\n-        self.vmin = self.vmax = None\n-        self.autoscale_None(A)\n+        # Only reset vmin/vmax if they are not already properly set\n+        # This prevents race conditions during drawing operations\n+        if self.vmin is None or self.vmax is None:\n+            self.vmin = self.vmax = None\n+            self.autoscale_None(A)\n+        else:\n+            # If both vmin and vmax are already set, still call autoscale_None\n+            # to handle any edge cases, but don't reset the values first\n+            self.autoscale_None(A)\n+\n \n     def autoscale_None(self, A):\n         \"\"\"If vmin or vmax are not set, use the min/max of *A* to set them.\"\"\"\n         A = np.asanyarray(A)\n         if self.vmin is None and A.size:\n-            self.vmin = A.min()\n+            min_val = A.min()\n+            # For LogNorm, ensure vmin is positive\n+            if hasattr(self, '_transform') and hasattr(self, '_inverse'):\n+                # This is likely a LogNorm or similar that requires positive values\n+                min_val = max(min_val, np.finfo(float).eps)\n+            self.vmin = min_val\n         if self.vmax is None and A.size:\n-            self.vmax = A.max()\n+            max_val = A.max()\n+            # For LogNorm, ensure vmax is positive\n+            if hasattr(self, '_transform') and hasattr(self, '_inverse'):\n+                # This is likely a LogNorm or similar that requires positive values\n+                max_val = max(max_val, np.finfo(float).eps)\n+            self.vmax = max_val\n \n     def scaled(self):\n         \"\"\"Return whether vmin and vmax are set.\"\"\"\n@@ -1679,6 +1698,7 @@ def _make_norm_from_scale(\n             inspect.Parameter(\"self\", inspect.Parameter.POSITIONAL_OR_KEYWORD),\n             *bound_init_signature.parameters.values()])\n \n+\n         def __call__(self, value, clip=None):\n             value, is_scalar = self.process_value(value)\n             if self.vmin is None or self.vmax is None:\n@@ -1692,9 +1712,15 @@ def _make_norm_from_scale(\n             if clip:\n                 value = np.clip(value, self.vmin, self.vmax)\n             t_value = self._trf.transform(value).reshape(np.shape(value))\n-            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n-            if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n+            # Only validate transformed bounds if vmin/vmax are not None\n+            if self.vmin is not None and self.vmax is not None:\n+                t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n+                if not np.isfinite([t_vmin, t_vmax]).all():\n+                    raise ValueError(\"Invalid vmin or vmax\")\n+                t_value -= t_vmin\n+                t_value /= (t_vmax - t_vmin)\n+            t_value = np.ma.masked_invalid(t_value, copy=False)\n+            return t_value[0] if is_scalar else t_value\n             t_value -= t_vmin\n             t_value /= (t_vmax - t_vmin)\n             t_value = np.ma.masked_invalid(t_value, copy=False)\n",
    "variant_5": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex f9e4dcbd62..1df489f943 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1360,18 +1360,40 @@ class Normalize:\n         else:\n             return vmin + value * (vmax - vmin)\n \n+\n     def autoscale(self, A):\n         \"\"\"Set *vmin*, *vmax* to min, max of *A*.\"\"\"\n+        # Only reset vmin/vmax if they are not already properly set\n+        A = np.asanyarray(A)\n+        if A.size == 0:\n+            # No data to autoscale from, keep existing values if valid\n+            return\n+        \n+        # Reset and recalculate vmin/vmax from the data\n         self.vmin = self.vmax = None\n         self.autoscale_None(A)\n \n-    def autoscale_None(self, A):\n-        \"\"\"If vmin or vmax are not set, use the min/max of *A* to set them.\"\"\"\n-        A = np.asanyarray(A)\n-        if self.vmin is None and A.size:\n-            self.vmin = A.min()\n-        if self.vmax is None and A.size:\n-            self.vmax = A.max()\n+\n+def autoscale_None(self, A):\n+    \"\"\"If vmin or vmax are not set, use the min/max of *A* to set them.\"\"\"\n+    A = np.asanyarray(A)\n+    if self.vmin is None and A.size:\n+        min_val = A.min()\n+        # For LogNorm, ensure vmin is positive\n+        if hasattr(self, '_transform') and min_val <= 0:\n+            # Find the smallest positive value or use a small default\n+            positive_vals = A[A > 0]\n+            if positive_vals.size > 0:\n+                min_val = positive_vals.min()\n+            else:\n+                min_val = 1e-10\n+        self.vmin = min_val\n+    if self.vmax is None and A.size:\n+        max_val = A.max()\n+        # For LogNorm, ensure vmax is positive\n+        if hasattr(self, '_transform') and max_val <= 0:\n+            max_val = 1.0  # Default positive value\n+        self.vmax = max_val\n \n     def scaled(self):\n         \"\"\"Return whether vmin and vmax are set.\"\"\"\n@@ -1679,6 +1701,7 @@ def _make_norm_from_scale(\n             inspect.Parameter(\"self\", inspect.Parameter.POSITIONAL_OR_KEYWORD),\n             *bound_init_signature.parameters.values()])\n \n+\n         def __call__(self, value, clip=None):\n             value, is_scalar = self.process_value(value)\n             if self.vmin is None or self.vmax is None:\n@@ -1692,9 +1715,15 @@ def _make_norm_from_scale(\n             if clip:\n                 value = np.clip(value, self.vmin, self.vmax)\n             t_value = self._trf.transform(value).reshape(np.shape(value))\n-            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n-            if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n+            # Defensive check: ensure vmin/vmax are not None before transform validation\n+            if self.vmin is not None and self.vmax is not None:\n+                t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n+                if not np.isfinite([t_vmin, t_vmax]).all():\n+                    raise ValueError(\"Invalid vmin or vmax\")\n+                t_value -= t_vmin\n+                t_value /= (t_vmax - t_vmin)\n+            t_value = np.ma.masked_invalid(t_value, copy=False)\n+            return t_value[0] if is_scalar else t_value\n             t_value -= t_vmin\n             t_value /= (t_vmax - t_vmin)\n             t_value = np.ma.masked_invalid(t_value, copy=False)\n",
    "variant_6": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex f9e4dcbd62..0cd28d5ef9 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1360,18 +1360,22 @@ class Normalize:\n         else:\n             return vmin + value * (vmax - vmin)\n \n+\n     def autoscale(self, A):\n         \"\"\"Set *vmin*, *vmax* to min, max of *A*.\"\"\"\n-        self.vmin = self.vmax = None\n-        self.autoscale_None(A)\n+        # Only reset vmin/vmax if they are not already set with valid values\n+        if self.vmin is None or self.vmax is None:\n+            self.vmin = self.vmax = None\n+            self.autoscale_None(A)\n \n-    def autoscale_None(self, A):\n-        \"\"\"If vmin or vmax are not set, use the min/max of *A* to set them.\"\"\"\n-        A = np.asanyarray(A)\n-        if self.vmin is None and A.size:\n-            self.vmin = A.min()\n-        if self.vmax is None and A.size:\n-            self.vmax = A.max()\n+\n+def autoscale_None(self, A):\n+    \"\"\"If vmin or vmax are not set, use the min/max of *A* to set them.\"\"\"\n+    A = np.asanyarray(A)\n+    if self.vmin is None and A.size:\n+        self.vmin = A.min()\n+    if self.vmax is None and A.size:\n+        self.vmax = A.max()\n \n     def scaled(self):\n         \"\"\"Return whether vmin and vmax are set.\"\"\"\n@@ -1679,6 +1683,7 @@ def _make_norm_from_scale(\n             inspect.Parameter(\"self\", inspect.Parameter.POSITIONAL_OR_KEYWORD),\n             *bound_init_signature.parameters.values()])\n \n+\n         def __call__(self, value, clip=None):\n             value, is_scalar = self.process_value(value)\n             if self.vmin is None or self.vmax is None:\n@@ -1692,9 +1697,18 @@ def _make_norm_from_scale(\n             if clip:\n                 value = np.clip(value, self.vmin, self.vmax)\n             t_value = self._trf.transform(value).reshape(np.shape(value))\n-            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n-            if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n+            # Check that vmin and vmax are not None before transforming\n+            if self.vmin is not None and self.vmax is not None:\n+                t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n+                if not np.isfinite([t_vmin, t_vmax]).all():\n+                    raise ValueError(\"Invalid vmin or vmax\")\n+            else:\n+                # If vmin or vmax are still None, we can't proceed with normalization\n+                raise ValueError(\"vmin and vmax must be set before normalization\")\n+            t_value -= t_vmin\n+            t_value /= (t_vmax - t_vmin)\n+            t_value = np.ma.masked_invalid(t_value, copy=False)\n+            return t_value[0] if is_scalar else t_value\n             t_value -= t_vmin\n             t_value /= (t_vmax - t_vmin)\n             t_value = np.ma.masked_invalid(t_value, copy=False)\n",
    "variant_7": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex f9e4dcbd62..850754609e 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1360,19 +1360,52 @@ class Normalize:\n         else:\n             return vmin + value * (vmax - vmin)\n \n+\n     def autoscale(self, A):\n         \"\"\"Set *vmin*, *vmax* to min, max of *A*.\"\"\"\n-        self.vmin = self.vmax = None\n-        self.autoscale_None(A)\n-\n-    def autoscale_None(self, A):\n-        \"\"\"If vmin or vmax are not set, use the min/max of *A* to set them.\"\"\"\n+        # Only reset vmin/vmax if they are not already properly set\n         A = np.asanyarray(A)\n-        if self.vmin is None and A.size:\n+        if A.size == 0:\n+            return\n+        \n+        # For LogNorm, we need to ensure positive values\n+        if hasattr(self, '_transform') and hasattr(self._transform, '_transform_non_affine'):\n+            # This is likely a LogNorm or similar transform\n+            A_positive = A[A > 0] if A.size > 0 else A\n+            if A_positive.size > 0:\n+                self.vmin = A_positive.min()\n+                self.vmax = A_positive.max()\n+        else:\n             self.vmin = A.min()\n-        if self.vmax is None and A.size:\n             self.vmax = A.max()\n \n+\n+def autoscale_None(self, A):\n+    \"\"\"If vmin or vmax are not set, use the min/max of *A* to set them.\"\"\"\n+    A = np.asanyarray(A)\n+    if self.vmin is None and A.size:\n+        min_val = A.min()\n+        # For LogNorm, ensure vmin is positive\n+        if hasattr(self, '_transform') and min_val <= 0:\n+            positive_vals = A[A > 0]\n+            if positive_vals.size > 0:\n+                self.vmin = positive_vals.min()\n+            else:\n+                self.vmin = 1e-10  # fallback for all non-positive data\n+        else:\n+            self.vmin = min_val\n+    if self.vmax is None and A.size:\n+        max_val = A.max()\n+        # For LogNorm, ensure vmax is positive\n+        if hasattr(self, '_transform') and max_val <= 0:\n+            positive_vals = A[A > 0]\n+            if positive_vals.size > 0:\n+                self.vmax = positive_vals.max()\n+            else:\n+                self.vmax = 1.0  # fallback for all non-positive data\n+        else:\n+            self.vmax = max_val\n+\n     def scaled(self):\n         \"\"\"Return whether vmin and vmax are set.\"\"\"\n         return self.vmin is not None and self.vmax is not None\n@@ -1679,6 +1712,7 @@ def _make_norm_from_scale(\n             inspect.Parameter(\"self\", inspect.Parameter.POSITIONAL_OR_KEYWORD),\n             *bound_init_signature.parameters.values()])\n \n+\n         def __call__(self, value, clip=None):\n             value, is_scalar = self.process_value(value)\n             if self.vmin is None or self.vmax is None:\n@@ -1692,9 +1726,17 @@ def _make_norm_from_scale(\n             if clip:\n                 value = np.clip(value, self.vmin, self.vmax)\n             t_value = self._trf.transform(value).reshape(np.shape(value))\n-            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n-            if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n+            # Check that vmin and vmax are not None before transforming\n+            if self.vmin is not None and self.vmax is not None:\n+                t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n+                if not np.isfinite([t_vmin, t_vmax]).all():\n+                    raise ValueError(\"Invalid vmin or vmax\")\n+            else:\n+                raise ValueError(\"vmin and vmax must be set\")\n+            t_value -= t_vmin\n+            t_value /= (t_vmax - t_vmin)\n+            t_value = np.ma.masked_invalid(t_value, copy=False)\n+            return t_value[0] if is_scalar else t_value\n             t_value -= t_vmin\n             t_value /= (t_vmax - t_vmin)\n             t_value = np.ma.masked_invalid(t_value, copy=False)\n",
    "variant_8": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex f9e4dcbd62..949c9e67fe 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1360,18 +1360,28 @@ class Normalize:\n         else:\n             return vmin + value * (vmax - vmin)\n \n+\n     def autoscale(self, A):\n         \"\"\"Set *vmin*, *vmax* to min, max of *A*.\"\"\"\n-        self.vmin = self.vmax = None\n-        self.autoscale_None(A)\n-\n-    def autoscale_None(self, A):\n-        \"\"\"If vmin or vmax are not set, use the min/max of *A* to set them.\"\"\"\n-        A = np.asanyarray(A)\n-        if self.vmin is None and A.size:\n-            self.vmin = A.min()\n-        if self.vmax is None and A.size:\n-            self.vmax = A.max()\n+        # Only reset vmin/vmax if they are not already set with valid values\n+        if self.vmin is None or self.vmax is None:\n+            self.vmin = self.vmax = None\n+            self.autoscale_None(A)\n+\n+\n+def autoscale_None(self, A):\n+    \"\"\"If vmin or vmax are not set, use the min/max of *A* to set them.\"\"\"\n+    A = np.asanyarray(A)\n+    if self.vmin is None and A.size:\n+        self.vmin = A.min()\n+        # For LogNorm, ensure vmin is positive\n+        if hasattr(self, '_transform') and hasattr(self._transform, 'base'):\n+            self.vmin = max(self.vmin, np.finfo(float).eps)\n+    if self.vmax is None and A.size:\n+        self.vmax = A.max()\n+        # For LogNorm, ensure vmax is positive\n+        if hasattr(self, '_transform') and hasattr(self._transform, 'base'):\n+            self.vmax = max(self.vmax, np.finfo(float).eps)\n \n     def scaled(self):\n         \"\"\"Return whether vmin and vmax are set.\"\"\"\n@@ -1679,6 +1689,7 @@ def _make_norm_from_scale(\n             inspect.Parameter(\"self\", inspect.Parameter.POSITIONAL_OR_KEYWORD),\n             *bound_init_signature.parameters.values()])\n \n+\n         def __call__(self, value, clip=None):\n             value, is_scalar = self.process_value(value)\n             if self.vmin is None or self.vmax is None:\n@@ -1692,9 +1703,17 @@ def _make_norm_from_scale(\n             if clip:\n                 value = np.clip(value, self.vmin, self.vmax)\n             t_value = self._trf.transform(value).reshape(np.shape(value))\n-            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n-            if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n+            # Check if vmin/vmax are None before transforming to avoid race condition\n+            if self.vmin is not None and self.vmax is not None:\n+                t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n+                if not np.isfinite([t_vmin, t_vmax]).all():\n+                    raise ValueError(\"Invalid vmin or vmax\")\n+            else:\n+                raise ValueError(\"vmin and vmax must be set\")\n+            t_value -= t_vmin\n+            t_value /= (t_vmax - t_vmin)\n+            t_value = np.ma.masked_invalid(t_value, copy=False)\n+            return t_value[0] if is_scalar else t_value\n             t_value -= t_vmin\n             t_value /= (t_vmax - t_vmin)\n             t_value = np.ma.masked_invalid(t_value, copy=False)\n"
  }
}