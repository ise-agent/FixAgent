{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/matplotlib/lib/matplotlib/widgets.py lines 542-552)": "\n        elif ((event.name == 'button_release_event') or\n              (event.name == 'button_press_event' and\n               event.inaxes != self.ax)):\n            self.drag_active = False\n            event.canvas.release_mouse(self.ax)\n            # Process any pending callback after drag completion\n            if hasattr(self, '_pending_callback_val') and self._pending_callback_val is not None:\n                pending_val = self._pending_callback_val\n                self._pending_callback_val = None\n                self.set_val(pending_val)\n            return\n        if self.orientation == 'vertical':\n            val = self._value_in_bounds(event.ydata)\n        else:\n            val = self._value_in_bounds(event.xdata)\n        if val not in [None, self.val]:\n            if self.drag_active:\n                # Defer callback during active dragging\n                self._pending_callback_val = val\n                # Update visual position without triggering callback\n                self.set_val(val, trigger_callback=False)\n            else:\n                self.set_val(val)\n",
    "Location 2 (/root/hy/projects_3/matplotlib/lib/matplotlib/widgets.py lines 582-586)": "\n    def set_val(self, val, trigger_callback=True):\n        \"\"\"\n        Set slider value to *val*.\n\n        Parameters\n        ----------\n        val : float\n        \"\"\"\n        if self.closedmin and val <= self.valmin:\n            if not self.closedmax:\n                val = np.nextafter(self.valmin, self.valmax)\n            else:\n                val = self.valmin\n        elif self.closedmax and val >= self.valmax:\n            if not self.closedmin:\n                val = np.nextafter(self.valmax, self.valmin)\n            else:\n                val = self.valmax\n\n        if self.valfmt is not None:\n            val = float(self.valfmt % val)\n        else:\n            val = (self.valmax - self.valmin) * np.round(\n                (val - self.valmin) / (self.valmax - self.valmin) *\n                (1/self.valfmt)) / (1/self.valfmt) + self.valmin\n\n        xy = self.poly.xy\n        if self.orientation == 'vertical':\n            xy[1] = .25, val\n            xy[2] = .75, val\n            self._handle.set_ydata([val])\n        else:\n            xy[2] = val, .75\n            xy[3] = val, .25\n            self._handle.set_xdata([val])\n        self.poly.xy = xy\n        self.valtext.set_text(self._format(val))\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n        self.val = val\n        if self.eventson and trigger_callback and not getattr(self, 'drag_active', False):\n            self._observers.process('changed', val)\n",
    "Location 3 (/root/hy/projects_3/matplotlib/lib/matplotlib/widgets.py lines 896-906)": "\n        # determine which handle was grabbed\n        if self.orientation == \"vertical\":\n            handle_index = np.argmin(\n                np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n            )\n        else:\n            handle_index = np.argmin(\n                np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n            )\n        handle = self._handles[handle_index]\n\n        # these checks ensure smooth behavior if the handles swap which one\n        # has a higher value. i.e. if one is dragged over and past the other.\n        if handle is not self._active_handle:\n            self._active_handle = handle\n\n        if self.orientation == \"vertical\":\n            if self.drag_active:\n                # Store pending position for callback after drag completion\n                self._pending_callback_pos = event.ydata\n            else:\n                self._update_val_from_pos(event.ydata)\n        else:\n            if self.drag_active:\n                # Store pending position for callback after drag completion\n                self._pending_callback_pos = event.xdata\n            else:\n                self._update_val_from_pos(event.xdata)\n",
    "Location 4 (/root/hy/projects_3/matplotlib/lib/matplotlib/widgets.py lines 965-969)": "\n    def set_val(self, val, trigger_callback=True):\n        \"\"\"\n        Set the value of the RangeSlider.\n\n        Parameters\n        ----------\n        val : tuple or array-like of float\n        trigger_callback : bool, default: True\n            Whether to trigger the callback immediately. When False,\n            the callback will be deferred until drag completion.\n        \"\"\"\n        val = np.sort(val)\n        _api.check_shape((2,), val=val)\n        vmin, vmax = val\n        vmin = self._value_in_bounds(vmin)\n        vmax = self._value_in_bounds(vmax)\n        if vmax < vmin:\n            raise ValueError(f\"Value vmax={vmax} is less than vmin={vmin}\")\n        self._active_handle = None\n        self._update_selection_poly(vmin, vmax)\n        if self.orientation == \"vertical\":\n            self._handles[0].set_ydata([vmin])\n            self._handles[1].set_ydata([vmax])\n        else:\n            self._handles[0].set_xdata([vmin])\n            self._handles[1].set_xdata([vmax])\n\n        self.valtext.set_text(self._format((vmin, vmax)))\n\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n        self.val = (vmin, vmax)\n        if self.eventson and trigger_callback and not getattr(self, 'drag_active', False):\n            self._observers.process(\"changed\", (vmin, vmax))\n        elif self.eventson and getattr(self, 'drag_active', False):\n            # Store the value for deferred callback during drag\n            self._pending_callback_val = (vmin, vmax)\n",
    "Location 5 (/root/hy/projects_3/matplotlib/lib/matplotlib/widgets.py lines 297-301)": "\n        self.connect_event(\"button_press_event\", self._update)\n        self.connect_event(\"button_release_event\", self._update)\n        if dragging:\n            self.connect_event(\"motion_notify_event\", self._update)\n        self._observers = cbook.CallbackRegistry(signals=[\"changed\"])\n        self._pending_callback_val = None\n        self.drag_active = False\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/matplotlib/lib/matplotlib/widgets.py lines 542-552)": [
      "\n        elif ((event.name == 'button_release_event') or\n              (event.name == 'button_press_event' and\n               event.inaxes != self.ax)):\n            self.drag_active = False\n            event.canvas.release_mouse(self.ax)\n            # Process any pending callback after drag completion\n            if hasattr(self, '_pending_callback_val') and self._pending_callback_val is not None:\n                pending_val = self._pending_callback_val\n                self._pending_callback_val = None\n                self.set_val(pending_val)\n            return\n        if self.orientation == 'vertical':\n            val = self._value_in_bounds(event.ydata)\n        else:\n            val = self._value_in_bounds(event.xdata)\n        if val not in [None, self.val]:\n            if self.drag_active:\n                # Defer callback during active dragging\n                self._pending_callback_val = val\n                # Update visual appearance without triggering callback\n                self.set_val(val, trigger_callback=False)\n            else:\n                self.set_val(val)\n",
      "\n        elif ((event.name == 'button_release_event') or\n              (event.name == 'button_press_event' and\n               event.inaxes != self.ax)):\n            self.drag_active = False\n            event.canvas.release_mouse(self.ax)\n            # Process any pending callback after drag completion\n            if hasattr(self, '_pending_callback_val') and self._pending_callback_val is not None:\n                pending_val = self._pending_callback_val\n                self._pending_callback_val = None\n                if pending_val != self.val:\n                    self.set_val(pending_val)\n            return\n        if self.orientation == 'vertical':\n            val = self._value_in_bounds(event.ydata)\n        else:\n            val = self._value_in_bounds(event.xdata)\n        if val not in [None, self.val]:\n            if self.drag_active:\n                # Store pending value during drag, don't trigger callback yet\n                self._pending_callback_val = val\n            else:\n                self.set_val(val)\n",
      "\n        elif ((event.name == 'button_release_event') or\n              (event.name == 'button_press_event' and\n               event.inaxes != self.ax)):\n            self.drag_active = False\n            event.canvas.release_mouse(self.ax)\n            # Process any pending callback after drag completion\n            if hasattr(self, '_pending_callback_val') and self._pending_callback_val is not None:\n                pending_val = self._pending_callback_val\n                self._pending_callback_val = None\n                if pending_val != self.val:\n                    self.set_val(pending_val)\n            return\n        if self.orientation == 'vertical':\n            val = self._value_in_bounds(event.ydata)\n        else:\n            val = self._value_in_bounds(event.xdata)\n        if val not in [None, self.val]:\n            if self.drag_active:\n                # Store pending value to trigger callback after drag completion\n                self._pending_callback_val = val\n                # Update visual position without triggering callback\n                self.set_val(val, trigger_callback=False)\n            else:\n                self.set_val(val)\n",
      "\n        elif ((event.name == 'button_release_event') or\n              (event.name == 'button_press_event' and\n               event.inaxes != self.ax)):\n            self.drag_active = False\n            event.canvas.release_mouse(self.ax)\n            # Process any pending callback after drag completion\n            if hasattr(self, '_pending_callback_val') and self._pending_callback_val is not None:\n                pending_val = self._pending_callback_val\n                self._pending_callback_val = None\n                if pending_val != self.val:\n                    self.set_val(pending_val)\n            return\n        if self.orientation == 'vertical':\n            val = self._value_in_bounds(event.ydata)\n        else:\n            val = self._value_in_bounds(event.xdata)\n        if val not in [None, self.val]:\n            # Defer callback execution during active dragging\n            if self.drag_active:\n                self._pending_callback_val = val\n                # Update visual position without triggering callbacks\n                self.set_val(val, trigger_callback=False)\n            else:\n                self.set_val(val)\n",
      "\n        elif ((event.name == 'button_release_event') or\n              (event.name == 'button_press_event' and\n               event.inaxes != self.ax)):\n            self.drag_active = False\n            event.canvas.release_mouse(self.ax)\n            # Process any pending callback after drag completion\n            if hasattr(self, '_pending_callback_val') and self._pending_callback_val is not None:\n                pending_val = self._pending_callback_val\n                self._pending_callback_val = None\n                if pending_val != self.val:\n                    self.set_val(pending_val)\n            return\n        if self.orientation == 'vertical':\n            val = self._value_in_bounds(event.ydata)\n        else:\n            val = self._value_in_bounds(event.xdata)\n        if val not in [None, self.val]:\n            # Defer callback during active dragging\n            if self.drag_active:\n                self._pending_callback_val = val\n                # Update visual position without triggering callback\n                self.set_val(val, trigger_callback=False)\n            else:\n                self.set_val(val)\n",
      "\n        elif ((event.name == 'button_release_event') or\n              (event.name == 'button_press_event' and\n               event.inaxes != self.ax)):\n            self.drag_active = False\n            event.canvas.release_mouse(self.ax)\n            # Process any pending callback after drag completion\n            if hasattr(self, '_pending_callback_val') and self._pending_callback_val is not None:\n                pending_val = self._pending_callback_val\n                self._pending_callback_val = None\n                if pending_val != self.val:\n                    self.set_val(pending_val)\n            return\n        if self.orientation == 'vertical':\n            val = self._value_in_bounds(event.ydata)\n        else:\n            val = self._value_in_bounds(event.xdata)\n        if val not in [None, self.val]:\n            # Defer callback execution during active dragging\n            if self.drag_active:\n                self._pending_callback_val = val\n                # Update visual position without triggering callback\n                self.set_val(val, trigger_callback=False)\n            else:\n                self.set_val(val)\n",
      "\n        elif ((event.name == 'button_release_event') or\n              (event.name == 'button_press_event' and\n               event.inaxes != self.ax)):\n            self.drag_active = False\n            event.canvas.release_mouse(self.ax)\n            # Process any pending callback after drag completion\n            if hasattr(self, '_pending_callback_val') and self._pending_callback_val is not None:\n                pending_val = self._pending_callback_val\n                self._pending_callback_val = None\n                if pending_val != self.val:\n                    self.set_val(pending_val)\n            return\n        if self.orientation == 'vertical':\n            val = self._value_in_bounds(event.ydata)\n        else:\n            val = self._value_in_bounds(event.xdata)\n        if val not in [None, self.val]:\n            if self.drag_active:\n                # Defer callback during active dragging\n                self._pending_callback_val = val\n                # Update visual position without triggering callback\n                self.set_val(val, trigger_callback=False)\n            else:\n                self.set_val(val)\n",
      "\n        elif ((event.name == 'button_release_event') or\n              (event.name == 'button_press_event' and\n               event.inaxes != self.ax)):\n            self.drag_active = False\n            event.canvas.release_mouse(self.ax)\n            # Process any pending callback after drag completion\n            if hasattr(self, '_pending_callback_val') and self._pending_callback_val is not None:\n                pending_val = self._pending_callback_val\n                self._pending_callback_val = None\n                if pending_val != self.val:\n                    self.set_val(pending_val)\n            return\n        if self.orientation == 'vertical':\n            val = self._value_in_bounds(event.ydata)\n        else:\n            val = self._value_in_bounds(event.xdata)\n        if val not in [None, self.val]:\n            # Defer callback during active dragging\n            if self.drag_active:\n                self._pending_callback_val = val\n                # Update visual position without triggering callback\n                self.set_val(val, trigger_callback=False)\n            else:\n                self.set_val(val)\n"
    ],
    "Location 2 (/root/hy/projects_3/matplotlib/lib/matplotlib/widgets.py lines 582-586)": [
      "\n    def set_val(self, val, trigger_callback=True):\n        \"\"\"\n        Set the value of the slider.\n\n        Parameters\n        ----------\n        val : float\n        \"\"\"\n        if self.closedmin and val <= self.valmin:\n            if not self.closedmax:\n                val = np.nextafter(self.valmin, 1)\n            else:\n                val = self.valmin\n        elif self.closedmax and val >= self.valmax:\n            if not self.closedmin:\n                val = np.nextafter(self.valmax, -1)\n            else:\n                val = self.valmax\n\n        if self.orientation == 'vertical':\n            xy = self.poly.xy\n            xy[2] = .25, val\n            xy[3] = .75, val\n        else:\n            xy = self.poly.xy\n            xy[1] = .25, val\n            xy[2] = .75, val\n\n        self.poly.xy = xy\n        self.valtext.set_text(self._format(val))\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n        self.val = val\n        if self.eventson and trigger_callback and not getattr(self, 'drag_active', False):\n            self._observers.process('changed', val)\n",
      "\n    def set_val(self, val, trigger_callback=True):\n        \"\"\"\n        Set slider value to *val*\n\n        Parameters\n        ----------\n        val : float\n        \"\"\"\n        xy = self.poly.xy\n        if self.orientation == 'vertical':\n            xy[1] = .25, val\n            xy[2] = .75, val\n            self._handle.set_ydata([val])\n        else:\n            xy[2] = val, .75\n            xy[3] = val, .25\n            self._handle.set_xdata([val])\n        self.poly.xy = xy\n        self.valtext.set_text(self._format(val))\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n        self.val = val\n        if self.eventson and trigger_callback and not getattr(self, 'drag_active', False):\n            self._observers.process('changed', val)\n",
      "\n    def set_val(self, val, trigger_callback=True):\n        \"\"\"\n        Set slider value to *val*.\n\n        Parameters\n        ----------\n        val : float\n        \"\"\"\n        xy = self.poly.xy\n        if self.orientation == 'vertical':\n            xy[1] = .25, val\n            xy[2] = .75, val\n            self._handle.set_ydata([val])\n        else:\n            xy[2] = val, .75\n            xy[3] = val, .25\n            self._handle.set_xdata([val])\n        self.poly.xy = xy\n        self.valtext.set_text(self._format(val))\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n        self.val = val\n        if self.eventson and trigger_callback and not getattr(self, 'drag_active', False):\n            self._observers.process('changed', val)\n",
      "\n    def set_val(self, val, trigger_callback=True):\n        \"\"\"\n        Set slider value to *val*.\n\n        Parameters\n        ----------\n        val : float\n        \"\"\"\n        xy = self.poly.xy\n        if self.orientation == 'vertical':\n            xy[1] = .25, val\n            xy[2] = .75, val\n            self._handle.set_ydata([val])\n        else:\n            xy[2] = val, .75\n            xy[3] = val, .25\n            self._handle.set_xdata([val])\n        self.poly.xy = xy\n        self.valtext.set_text(self._format(val))\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n        self.val = val\n        if self.eventson and trigger_callback and not getattr(self, 'drag_active', False):\n            self._observers.process('changed', val)\n",
      "\n    def set_val(self, val, trigger_callback=True):\n        \"\"\"\n        Set slider value to *val*.\n\n        Parameters\n        ----------\n        val : float\n        \"\"\"\n        xy = self.poly.xy\n        if self.orientation == 'vertical':\n            xy[1] = .25, val\n            xy[2] = .75, val\n            self._handle.set_ydata([val])\n        else:\n            xy[2] = val, .75\n            xy[3] = val, .25\n            self._handle.set_xdata([val])\n        self.poly.xy = xy\n        self.valtext.set_text(self._format(val))\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n        self.val = val\n        if self.eventson and trigger_callback and not getattr(self, 'drag_active', False):\n            self._observers.process('changed', val)\n",
      "\n    def set_val(self, val, trigger_callback=True):\n        \"\"\"\n        Set slider value to *val*.\n\n        Parameters\n        ----------\n        val : float\n        \"\"\"\n        xy = self.poly.xy\n        if self.orientation == 'vertical':\n            xy[1] = .25, val\n            xy[2] = .75, val\n            self._handle.set_ydata([val])\n        else:\n            xy[2] = val, .75\n            xy[3] = val, .25\n            self._handle.set_xdata([val])\n        self.poly.xy = xy\n        self.valtext.set_text(self._format(val))\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n        self.val = val\n        if self.eventson and trigger_callback and not getattr(self, 'drag_active', False):\n            self._observers.process('changed', val)\n",
      "\n    def set_val(self, val, trigger_callback=True):\n        \"\"\"\n        Set the value of the slider.\n\n        Parameters\n        ----------\n        val : float\n        \"\"\"\n        if self.closedmin and val <= self.valmin:\n            if not self.closedmax:\n                val = np.nextafter(self.valmin, self.valmax)\n            else:\n                val = self.valmin\n        elif self.closedmax and val >= self.valmax:\n            if not self.closedmin:\n                val = np.nextafter(self.valmax, self.valmin)\n            else:\n                val = self.valmax\n\n        xy = self.poly.xy\n        if self.orientation == 'vertical':\n            xy[1] = .25, val\n            xy[2] = .75, val\n            self._handle.set_ydata([val])\n        else:\n            xy[2] = val, .75\n            xy[3] = val, .25\n            self._handle.set_xdata([val])\n        self.poly.xy = xy\n        self.valtext.set_text(self._format(val))\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n        self.val = val\n        if self.eventson and trigger_callback and not getattr(self, 'drag_active', False):\n            self._observers.process('changed', val)\n",
      "\n    def set_val(self, val, trigger_callback=True):\n        \"\"\"\n        Set slider value to *val*.\n\n        Parameters\n        ----------\n        val : float\n        \"\"\"\n        xy = self.poly.xy\n        if self.orientation == 'vertical':\n            xy[1] = .25, val\n            xy[2] = .75, val\n            self._handle.set_ydata([val])\n        else:\n            xy[2] = val, .75\n            xy[3] = val, .25\n            self._handle.set_xdata([val])\n        self.poly.xy = xy\n        self.valtext.set_text(self._format(val))\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n        self.val = val\n        if self.eventson and trigger_callback and not getattr(self, 'drag_active', False):\n            self._observers.process('changed', val)\n"
    ],
    "Location 3 (/root/hy/projects_3/matplotlib/lib/matplotlib/widgets.py lines 896-906)": [
      "\n        # determine which handle was grabbed\n        if self.orientation == \"vertical\":\n            handle_index = np.argmin(\n                np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n            )\n        else:\n            handle_index = np.argmin(\n                np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n            )\n        handle = self._handles[handle_index]\n\n        # these checks ensure smooth behavior if the handles swap which one\n        # has a higher value. i.e. if one is dragged over and past the other.\n        if handle is not self._active_handle:\n            self._active_handle = handle\n\n        if self.orientation == \"vertical\":\n            if self.drag_active:\n                self._pending_callback_pos = event.ydata\n            else:\n                self._update_val_from_pos(event.ydata)\n        else:\n            if self.drag_active:\n                self._pending_callback_pos = event.xdata\n            else:\n                self._update_val_from_pos(event.xdata)\n",
      "\n        # determine which handle was grabbed\n        if self.orientation == \"vertical\":\n            handle_index = np.argmin(\n                np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n            )\n        else:\n            handle_index = np.argmin(\n                np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n            )\n        handle = self._handles[handle_index]\n\n        # these checks ensure smooth behavior if the handles swap which one\n        # has a higher value. i.e. if one is dragged over and past the other.\n        if handle is not self._active_handle:\n            self._active_handle = handle\n\n        if self.orientation == \"vertical\":\n            if self.drag_active:\n                # Store position for deferred processing\n                self._pending_callback_pos = event.ydata\n            else:\n                self._update_val_from_pos(event.ydata)\n        else:\n            if self.drag_active:\n                # Store position for deferred processing\n                self._pending_callback_pos = event.xdata\n            else:\n                self._update_val_from_pos(event.xdata)\n",
      "\n        # determine which handle was grabbed\n        if self.orientation == \"vertical\":\n            handle_index = np.argmin(\n                np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n            )\n        else:\n            handle_index = np.argmin(\n                np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n            )\n        handle = self._handles[handle_index]\n\n        # these checks ensure smooth behavior if the handles swap which one\n        # has a higher value. i.e. if one is dragged over and past the other.\n        if handle is not self._active_handle:\n            self._active_handle = handle\n\n        if self.orientation == \"vertical\":\n            if self.drag_active:\n                # Store pending position for callback after drag completion\n                self._pending_callback_pos = event.ydata\n            else:\n                self._update_val_from_pos(event.ydata)\n        else:\n            if self.drag_active:\n                # Store pending position for callback after drag completion\n                self._pending_callback_pos = event.xdata\n            else:\n                self._update_val_from_pos(event.xdata)\n",
      "\n        # determine which handle was grabbed\n        if self.orientation == \"vertical\":\n            handle_index = np.argmin(\n                np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n            )\n        else:\n            handle_index = np.argmin(\n                np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n            )\n        handle = self._handles[handle_index]\n\n        # these checks ensure smooth behavior if the handles swap which one\n        # has a higher value. i.e. if one is dragged over and past the other.\n        if handle is not self._active_handle:\n            self._active_handle = handle\n\n        if self.orientation == \"vertical\":\n            if self.drag_active:\n                self._pending_callback_pos = event.ydata\n            else:\n                self._update_val_from_pos(event.ydata)\n        else:\n            if self.drag_active:\n                self._pending_callback_pos = event.xdata\n            else:\n                self._update_val_from_pos(event.xdata)\n",
      "\n        # determine which handle was grabbed\n        if self.orientation == \"vertical\":\n            handle_index = np.argmin(\n                np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n            )\n        else:\n            handle_index = np.argmin(\n                np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n            )\n        handle = self._handles[handle_index]\n\n        # these checks ensure smooth behavior if the handles swap which one\n        # has a higher value. i.e. if one is dragged over and past the other.\n        if handle is not self._active_handle:\n            self._active_handle = handle\n\n        if self.orientation == \"vertical\":\n            if self.drag_active:\n                # Store pending position during active dragging\n                self._pending_pos = event.ydata\n            else:\n                self._update_val_from_pos(event.ydata)\n        else:\n            if self.drag_active:\n                # Store pending position during active dragging\n                self._pending_pos = event.xdata\n            else:\n                self._update_val_from_pos(event.xdata)\n",
      "\n        handle = self._handles[handle_index]\n\n        # these checks ensure smooth behavior if the handles swap which one\n        # has a higher value. i.e. if one is dragged over and past the other.\n        if handle is not self._active_handle:\n            self._active_handle = handle\n\n        if self.orientation == \"vertical\":\n            self._pending_callback_pos = event.ydata\n        else:\n            self._pending_callback_pos = event.xdata\n        \n        # Only update immediately if not dragging, otherwise defer until drag ends\n        if not self.drag_active:\n            if self.orientation == \"vertical\":\n                self._update_val_from_pos(event.ydata)\n            else:\n                self._update_val_from_pos(event.xdata)\n",
      "\n        # determine which handle was grabbed\n        if self.orientation == \"vertical\":\n            handle_index = np.argmin(\n                np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n            )\n        else:\n            handle_index = np.argmin(\n                np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n            )\n        handle = self._handles[handle_index]\n\n        # these checks ensure smooth behavior if the handles swap which one\n        # has a higher value. i.e. if one is dragged over and past the other.\n        if handle is not self._active_handle:\n            self._active_handle = handle\n\n        if self.orientation == \"vertical\":\n            if self.drag_active:\n                self._pending_callback_pos = event.ydata\n            else:\n                self._update_val_from_pos(event.ydata)\n        else:\n            if self.drag_active:\n                self._pending_callback_pos = event.xdata\n            else:\n                self._update_val_from_pos(event.xdata)\n",
      "\n        # determine which handle was grabbed\n        if self.orientation == \"vertical\":\n            handle_index = np.argmin(\n                np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n            )\n        else:\n            handle_index = np.argmin(\n                np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n            )\n        handle = self._handles[handle_index]\n\n        # these checks ensure smooth behavior if the handles swap which one\n        # has a higher value. i.e. if one is dragged over and past the other.\n        if handle is not self._active_handle:\n            self._active_handle = handle\n\n        if self.orientation == \"vertical\":\n            pos = event.ydata\n        else:\n            pos = event.xdata\n\n        # Defer callback execution during active dragging\n        if self.drag_active:\n            self._pending_callback_pos = pos\n        else:\n            self._update_val_from_pos(pos)\n"
    ],
    "Location 4 (/root/hy/projects_3/matplotlib/lib/matplotlib/widgets.py lines 965-969)": [
      "\n    def set_val(self, val, trigger_callback=True):\n        \"\"\"\n        Set the value of the slider.\n\n        Parameters\n        ----------\n        val : tuple of float\n        trigger_callback : bool, default: True\n            Whether to trigger the callback. Set to False to defer callback\n            execution until after active dragging is complete.\n        \"\"\"\n        if self.closedmin and val[0] <= self.valmin:\n            if not self.closedmax and val[1] >= self.valmax:\n                raise ValueError(f\"val[0] ({val[0]}) <= valmin ({self.valmin}) \"\n                                 f\"AND val[1] ({val[1]}) >= valmax ({self.valmax})\")\n            val = (self.valmin, val[1])\n        elif self.closedmax and val[1] >= self.valmax:\n            val = (val[0], self.valmax)\n\n        vmin, vmax = val\n        if vmin > vmax:\n            vmin, vmax = vmax, vmin\n        self._update_selection_poly(vmin, vmax)\n        if self.orientation == \"vertical\":\n            self._handles[0].set_ydata([vmin])\n            self._handles[1].set_ydata([vmax])\n        else:\n            self._handles[0].set_xdata([vmin])\n            self._handles[1].set_xdata([vmax])\n\n        self.valtext.set_text(self._format((vmin, vmax)))\n\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n        self.val = (vmin, vmax)\n        if self.eventson and trigger_callback and not getattr(self, 'drag_active', False):\n            self._observers.process(\"changed\", (vmin, vmax))\n        elif self.eventson and getattr(self, 'drag_active', False):\n            # Store pending callback for execution after drag completion\n            self._pending_callback_val = (vmin, vmax)\n",
      "\n    def set_val(self, val, trigger_callback=True):\n        \"\"\"\n        Set the value of the slider.\n\n        Parameters\n        ----------\n        val : tuple or array-like of length 2\n            Lower and upper bounds for the slider.\n        trigger_callback : bool, default: True\n            Whether to trigger the callback. Set to False during dragging\n            to defer callback execution until drag completion.\n        \"\"\"\n        if np.ndim(val) != 1 or len(val) != 2:\n            raise ValueError(f\"val must have shape (2,), got {np.shape(val)}\")\n        val = self._value_in_bounds(val)\n        vmin, vmax = val\n        if self._active_handle is None:\n            if vmin > vmax:\n                vmin, vmax = vmax, vmin\n        else:\n            if vmin == vmax:\n                # Ensure that handles can't swap which one is min and which\n                # is max: if at the same value, differentiate them by their\n                # handle index.\n                vmin, vmax = (vmax, vmin) if self._active_handle else (vmin, vmax)\n        self._update_selection_poly(vmin, vmax)\n        if self.orientation == \"vertical\":\n            self._handles[0].set_ydata([vmin])\n            self._handles[1].set_ydata([vmax])\n        else:\n            self._handles[0].set_xdata([vmin])\n            self._handles[1].set_xdata([vmax])\n\n        self.valtext.set_text(self._format((vmin, vmax)))\n\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n        self.val = (vmin, vmax)\n        if self.eventson and trigger_callback and not getattr(self, 'drag_active', False):\n            self._observers.process(\"changed\", (vmin, vmax))\n",
      "\n    def set_val(self, val, trigger_callback=True):\n        \"\"\"\n        Set the value of the slider.\n\n        Parameters\n        ----------\n        val : tuple of float\n        trigger_callback : bool, optional\n            If True, trigger the callback functions. Default is True.\n        \"\"\"\n        if self.closedmin and val[0] <= self.valmin:\n            if not self.closedmax and val[1] >= self.valmax:\n                raise ValueError(f\"Both min and max are outside the range\")\n            val = (self.valmin, val[1])\n        if self.closedmax and val[1] >= self.valmax:\n            val = (val[0], self.valmax)\n        if self.closedmin and val[0] <= self.valmin:\n            val = (self.valmin, val[1])\n        if self.closedmax and val[1] >= self.valmax:\n            val = (val[0], self.valmax)\n        if val[0] > val[1]:\n            val = (val[1], val[0])\n        vmin, vmax = val\n        if vmin <= self.valmin:\n            if not self.closedmin:\n                return\n            vmin = self.valmin\n        if vmax >= self.valmax:\n            if not self.closedmax:\n                return\n            vmax = self.valmax\n        if vmin > vmax:\n            vmin = vmax\n        self._update_selection_poly(vmin, vmax)\n        if self.orientation == \"vertical\":\n            self._handles[0].set_ydata([vmin])\n            self._handles[1].set_ydata([vmax])\n        else:\n            self._handles[0].set_xdata([vmin])\n            self._handles[1].set_xdata([vmax])\n\n        self.valtext.set_text(self._format((vmin, vmax)))\n\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n        self.val = (vmin, vmax)\n        if self.eventson and trigger_callback and not getattr(self, 'drag_active', False):\n            self._observers.process(\"changed\", (vmin, vmax))\n",
      "\n    def set_val(self, val, trigger_callback=True):\n        \"\"\"\n        Set the value of the slider.\n\n        Parameters\n        ----------\n        val : tuple or array-like of length 2\n        \"\"\"\n        if np.iterable(val):\n            vmin, vmax = val\n        else:\n            # Assume val is a scalar and set both ends of the range to val\n            vmin = vmax = val\n        vmin, vmax = self._min_in_bounds(vmin), self._max_in_bounds(vmax)\n        self._update_selection_poly(vmin, vmax)\n        if self.orientation == \"vertical\":\n            self._handles[0].set_ydata([vmin])\n            self._handles[1].set_ydata([vmax])\n        else:\n            self._handles[0].set_xdata([vmin])\n            self._handles[1].set_xdata([vmax])\n\n        self.valtext.set_text(self._format((vmin, vmax)))\n\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n        self.val = (vmin, vmax)\n        if self.eventson and trigger_callback and not getattr(self, 'drag_active', False):\n            self._observers.process(\"changed\", (vmin, vmax))\n",
      "\n    def set_val(self, val, trigger_callback=True):\n        \"\"\"\n        Set the value of the slider.\n\n        Parameters\n        ----------\n        val : tuple or array-like of length 2\n            Lower and upper bounds for the slider.\n        trigger_callback : bool, default: True\n            Whether to trigger the on_changed callback.\n        \"\"\"\n        val = np.sort(val)\n        _api.check_shape((2,), val=val)\n        vmin, vmax = val\n        vmin = self._min_in_bounds(vmin)\n        vmax = self._max_in_bounds(vmax)\n        self._update_selection_poly(vmin, vmax)\n        if self.orientation == \"vertical\":\n            self._handles[0].set_ydata([vmin])\n            self._handles[1].set_ydata([vmax])\n        else:\n            self._handles[0].set_xdata([vmin])\n            self._handles[1].set_xdata([vmax])\n\n        self.valtext.set_text(self._format((vmin, vmax)))\n\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n        self.val = (vmin, vmax)\n        if self.eventson and trigger_callback and not getattr(self, 'drag_active', False):\n            self._observers.process(\"changed\", (vmin, vmax))\n",
      "\n    def set_val(self, val, trigger_callback=True):\n        \"\"\"\n        Set the value of the slider.\n\n        Parameters\n        ----------\n        val : tuple or array-like of float\n        \"\"\"\n        if self.orientation == 'vertical':\n            vmin, vmax = self._value_in_bounds(val)\n        else:\n            vmin, vmax = self._value_in_bounds(val)\n        self._update_selection_poly(vmin, vmax)\n        if self.orientation == \"vertical\":\n            self._handles[0].set_ydata([vmin])\n            self._handles[1].set_ydata([vmax])\n        else:\n            self._handles[0].set_xdata([vmin])\n            self._handles[1].set_xdata([vmax])\n\n        self.valtext.set_text(self._format((vmin, vmax)))\n\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n        self.val = (vmin, vmax)\n        if self.eventson and trigger_callback and not getattr(self, 'drag_active', False):\n            self._observers.process(\"changed\", (vmin, vmax))\n",
      "\n    def set_val(self, val, trigger_callback=True):\n        \"\"\"\n        Set the value of the slider.\n\n        Parameters\n        ----------\n        val : tuple or array-like of float\n        \"\"\"\n        if self.closedmin and val[0] <= self.valmin:\n            if not self.closedmax and val[1] >= self.valmax:\n                raise ValueError(f\"Both val {val} <= valmin {self.valmin} and \"\n                                 f\"val {val} >= valmax {self.valmax}\")\n            val = (self.valmin, val[1])\n        elif self.closedmax and val[1] >= self.valmax:\n            val = (val[0], self.valmax)\n\n        if self.minspan is not None:\n            if val[1] - val[0] < self.minspan:\n                return\n        vmin, vmax = val\n        vmin = self._value_in_bounds(vmin)\n        vmax = self._value_in_bounds(vmax)\n        if vmin > vmax:\n            vmin, vmax = vmax, vmin\n        self._update_selection_poly(vmin, vmax)\n        if self.orientation == \"vertical\":\n            self._handles[0].set_ydata([vmin])\n            self._handles[1].set_ydata([vmax])\n        else:\n            self._handles[0].set_xdata([vmin])\n            self._handles[1].set_xdata([vmax])\n\n        self.valtext.set_text(self._format((vmin, vmax)))\n\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n        self.val = (vmin, vmax)\n        if self.eventson and trigger_callback and not getattr(self, 'drag_active', False):\n            self._observers.process(\"changed\", (vmin, vmax))\n",
      "\n    def set_val(self, val, trigger_callback=True):\n        \"\"\"\n        Set slider value to *val*.\n\n        Parameters\n        ----------\n        val : tuple or array-like of length 2\n        trigger_callback : bool, default: True\n            Whether to trigger the callback. Set to False during dragging\n            to avoid callback execution during active mouse interaction.\n        \"\"\"\n        val = np.sort(val)\n        _api.check_shape((2,), val=val)\n        vmin, vmax = val\n        vmin = self._min_in_bounds(vmin)\n        vmax = self._max_in_bounds(vmax)\n        self._update_selection_poly(vmin, vmax)\n        if self.orientation == \"vertical\":\n            self._handles[0].set_ydata([vmin])\n            self._handles[1].set_ydata([vmax])\n        else:\n            self._handles[0].set_xdata([vmin])\n            self._handles[1].set_xdata([vmax])\n\n        self.valtext.set_text(self._format((vmin, vmax)))\n\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n        self.val = (vmin, vmax)\n        if self.eventson and trigger_callback and not getattr(self, 'drag_active', False):\n            self._observers.process(\"changed\", (vmin, vmax))\n"
    ],
    "Location 5 (/root/hy/projects_3/matplotlib/lib/matplotlib/widgets.py lines 297-301)": [
      "\n        self.connect_event(\"button_press_event\", self._update)\n        self.connect_event(\"button_release_event\", self._update)\n        if dragging:\n            self.connect_event(\"motion_notify_event\", self._update)\n        self._observers = cbook.CallbackRegistry(signals=[\"changed\"])\n        self._pending_callback_val = None\n        self.drag_active = False\n",
      "\n        self.connect_event(\"button_press_event\", self._update)\n        self.connect_event(\"button_release_event\", self._update)\n        if dragging:\n            self.connect_event(\"motion_notify_event\", self._update)\n        self._observers = cbook.CallbackRegistry(signals=[\"changed\"])\n        self._pending_callback_val = None\n        self.drag_active = False\n",
      "\n        self.connect_event(\"button_press_event\", self._update)\n        self.connect_event(\"button_release_event\", self._update)\n        if dragging:\n            self.connect_event(\"motion_notify_event\", self._update)\n        self._observers = cbook.CallbackRegistry(signals=[\"changed\"])\n        self._pending_callback_val = None\n        self.drag_active = False\n",
      "\n        self.connect_event(\"button_press_event\", self._update)\n        self.connect_event(\"button_release_event\", self._update)\n        if dragging:\n            self.connect_event(\"motion_notify_event\", self._update)\n        self._observers = cbook.CallbackRegistry(signals=[\"changed\"])\n        self._pending_callback_val = None\n        self.drag_active = False\n",
      "\n        self.connect_event(\"button_press_event\", self._update)\n        self.connect_event(\"button_release_event\", self._update)\n        if dragging:\n            self.connect_event(\"motion_notify_event\", self._update)\n        self._observers = cbook.CallbackRegistry(signals=[\"changed\"])\n        self._pending_callback_val = None\n        self.drag_active = False\n",
      "\n        self.connect_event(\"button_press_event\", self._update)\n        self.connect_event(\"button_release_event\", self._update)\n        if dragging:\n            self.connect_event(\"motion_notify_event\", self._update)\n        self._observers = cbook.CallbackRegistry(signals=[\"changed\"])\n        self._pending_callback_val = None\n",
      "\n        self.connect_event(\"button_press_event\", self._update)\n        self.connect_event(\"button_release_event\", self._update)\n        if dragging:\n            self.connect_event(\"motion_notify_event\", self._update)\n        self._observers = cbook.CallbackRegistry(signals=[\"changed\"])\n        self._pending_callback_val = None\n",
      "\n        self.connect_event(\"button_press_event\", self._update)\n        self.connect_event(\"button_release_event\", self._update)\n        if dragging:\n            self.connect_event(\"motion_notify_event\", self._update)\n        self._observers = cbook.CallbackRegistry(signals=[\"changed\"])\n        self._pending_callback_val = None\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex ebe5da43e2..0f8a709f94 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -294,11 +294,15 @@ class SliderBase(AxesWidget):\n         ax.set_axis_off()\n         ax.set_navigate(False)\n \n+\n         self.connect_event(\"button_press_event\", self._update)\n         self.connect_event(\"button_release_event\", self._update)\n         if dragging:\n             self.connect_event(\"motion_notify_event\", self._update)\n         self._observers = cbook.CallbackRegistry(signals=[\"changed\"])\n+        # Initialize pending callback storage\n+        self._pending_callback_val = None\n+        self._pending_pos = None\n \n     def _stepped_value(self, val):\n         \"\"\"Return *val* coerced to closest number in the ``valstep`` grid.\"\"\"\n@@ -538,18 +542,25 @@ class Slider(SliderBase):\n         if not self.drag_active:\n             return\n \n+        elif ((event.name == 'button_release_event') or\n+\n         elif ((event.name == 'button_release_event') or\n               (event.name == 'button_press_event' and\n                event.inaxes != self.ax)):\n             self.drag_active = False\n             event.canvas.release_mouse(self.ax)\n+            # Process any pending callback after drag completion\n+            if hasattr(self, '_pending_callback_val') and self._pending_callback_val is not None:\n+                if self.eventson:\n+                    self._observers.process('changed', self._pending_callback_val)\n+                self._pending_callback_val = None\n             return\n         if self.orientation == 'vertical':\n             val = self._value_in_bounds(event.ydata)\n         else:\n             val = self._value_in_bounds(event.xdata)\n         if val not in [None, self.val]:\n-            self.set_val(val)\n+            self.set_val(val, trigger_callback=not self.drag_active)\n \n     def _format(self, val):\n         \"\"\"Pretty-print *val*.\"\"\"\n@@ -579,11 +590,16 @@ class Slider(SliderBase):\n             self._handle.set_xdata([val])\n         self.poly.xy = xy\n         self.valtext.set_text(self._format(val))\n+\n         if self.drawon:\n             self.ax.figure.canvas.draw_idle()\n         self.val = val\n-        if self.eventson:\n-            self._observers.process('changed', val)\n+        if self.eventson and trigger_callback:\n+            if self.drag_active:\n+                # Store pending callback for later execution\n+                self._pending_callback_val = val\n+            else:\n+                self._observers.process('changed', val)\n \n     def on_changed(self, func):\n         \"\"\"\n@@ -893,6 +909,7 @@ class RangeSlider(SliderBase):\n             handle_index = np.argmin(\n                 np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n             )\n+\n         handle = self._handles[handle_index]\n \n         # these checks ensure smooth behavior if the handles swap which one\n@@ -901,9 +918,17 @@ class RangeSlider(SliderBase):\n             self._active_handle = handle\n \n         if self.orientation == \"vertical\":\n-            self._update_val_from_pos(event.ydata)\n+            if self.drag_active:\n+                # Store pending position for later processing\n+                self._pending_pos = event.ydata\n+            else:\n+                self._update_val_from_pos(event.ydata)\n         else:\n-            self._update_val_from_pos(event.xdata)\n+            if self.drag_active:\n+                # Store pending position for later processing\n+                self._pending_pos = event.xdata\n+            else:\n+                self._update_val_from_pos(event.xdata)\n \n     def _format(self, val):\n         \"\"\"Pretty-print *val*.\"\"\"\n@@ -962,11 +987,16 @@ class RangeSlider(SliderBase):\n \n         self.valtext.set_text(self._format((vmin, vmax)))\n \n+\n         if self.drawon:\n             self.ax.figure.canvas.draw_idle()\n         self.val = (vmin, vmax)\n-        if self.eventson:\n-            self._observers.process(\"changed\", (vmin, vmax))\n+        if self.eventson and trigger_callback:\n+            if self.drag_active:\n+                # Store pending callback for later execution\n+                self._pending_callback_val = (vmin, vmax)\n+            else:\n+                self._observers.process(\"changed\", (vmin, vmax))\n \n     def on_changed(self, func):\n         \"\"\"\n",
    "variant_0": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex ebe5da43e2..cacf281b62 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -294,11 +294,14 @@ class SliderBase(AxesWidget):\n         ax.set_axis_off()\n         ax.set_navigate(False)\n \n+\n         self.connect_event(\"button_press_event\", self._update)\n         self.connect_event(\"button_release_event\", self._update)\n         if dragging:\n             self.connect_event(\"motion_notify_event\", self._update)\n         self._observers = cbook.CallbackRegistry(signals=[\"changed\"])\n+        self._pending_callback_val = None\n+        self.drag_active = False\n \n     def _stepped_value(self, val):\n         \"\"\"Return *val* coerced to closest number in the ``valstep`` grid.\"\"\"\n@@ -538,18 +541,31 @@ class Slider(SliderBase):\n         if not self.drag_active:\n             return\n \n+        elif ((event.name == 'button_release_event') or\n+\n         elif ((event.name == 'button_release_event') or\n               (event.name == 'button_press_event' and\n                event.inaxes != self.ax)):\n             self.drag_active = False\n             event.canvas.release_mouse(self.ax)\n+            # Process any pending callback after drag completion\n+            if hasattr(self, '_pending_callback_val') and self._pending_callback_val is not None:\n+                pending_val = self._pending_callback_val\n+                self._pending_callback_val = None\n+                self.set_val(pending_val)\n             return\n         if self.orientation == 'vertical':\n             val = self._value_in_bounds(event.ydata)\n         else:\n             val = self._value_in_bounds(event.xdata)\n         if val not in [None, self.val]:\n-            self.set_val(val)\n+            if self.drag_active:\n+                # Defer callback during active dragging\n+                self._pending_callback_val = val\n+                # Update visual position without triggering callback\n+                self.set_val(val, trigger_callback=False)\n+            else:\n+                self.set_val(val)\n \n     def _format(self, val):\n         \"\"\"Pretty-print *val*.\"\"\"\n@@ -579,10 +595,48 @@ class Slider(SliderBase):\n             self._handle.set_xdata([val])\n         self.poly.xy = xy\n         self.valtext.set_text(self._format(val))\n+\n+    def set_val(self, val, trigger_callback=True):\n+        \"\"\"\n+        Set slider value to *val*.\n+\n+        Parameters\n+        ----------\n+        val : float\n+        \"\"\"\n+        if self.closedmin and val <= self.valmin:\n+            if not self.closedmax:\n+                val = np.nextafter(self.valmin, self.valmax)\n+            else:\n+                val = self.valmin\n+        elif self.closedmax and val >= self.valmax:\n+            if not self.closedmin:\n+                val = np.nextafter(self.valmax, self.valmin)\n+            else:\n+                val = self.valmax\n+\n+        if self.valfmt is not None:\n+            val = float(self.valfmt % val)\n+        else:\n+            val = (self.valmax - self.valmin) * np.round(\n+                (val - self.valmin) / (self.valmax - self.valmin) *\n+                (1/self.valfmt)) / (1/self.valfmt) + self.valmin\n+\n+        xy = self.poly.xy\n+        if self.orientation == 'vertical':\n+            xy[1] = .25, val\n+            xy[2] = .75, val\n+            self._handle.set_ydata([val])\n+        else:\n+            xy[2] = val, .75\n+            xy[3] = val, .25\n+            self._handle.set_xdata([val])\n+        self.poly.xy = xy\n+        self.valtext.set_text(self._format(val))\n         if self.drawon:\n             self.ax.figure.canvas.draw_idle()\n         self.val = val\n-        if self.eventson:\n+        if self.eventson and trigger_callback and not getattr(self, 'drag_active', False):\n             self._observers.process('changed', val)\n \n     def on_changed(self, func):\n@@ -884,6 +938,16 @@ class RangeSlider(SliderBase):\n             self._active_handle = None\n             return\n \n+        # determine which handle was grabbed\n+        if self.orientation == \"vertical\":\n+            handle_index = np.argmin(\n+                np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n+            )\n+        else:\n+            handle_index = np.argmin(\n+                np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n+            )\n+\n         # determine which handle was grabbed\n         if self.orientation == \"vertical\":\n             handle_index = np.argmin(\n@@ -901,9 +965,17 @@ class RangeSlider(SliderBase):\n             self._active_handle = handle\n \n         if self.orientation == \"vertical\":\n-            self._update_val_from_pos(event.ydata)\n+            if self.drag_active:\n+                # Store pending position for callback after drag completion\n+                self._pending_callback_pos = event.ydata\n+            else:\n+                self._update_val_from_pos(event.ydata)\n         else:\n-            self._update_val_from_pos(event.xdata)\n+            if self.drag_active:\n+                # Store pending position for callback after drag completion\n+                self._pending_callback_pos = event.xdata\n+            else:\n+                self._update_val_from_pos(event.xdata)\n \n     def _format(self, val):\n         \"\"\"Pretty-print *val*.\"\"\"\n@@ -962,11 +1034,44 @@ class RangeSlider(SliderBase):\n \n         self.valtext.set_text(self._format((vmin, vmax)))\n \n+\n+    def set_val(self, val, trigger_callback=True):\n+        \"\"\"\n+        Set the value of the RangeSlider.\n+\n+        Parameters\n+        ----------\n+        val : tuple or array-like of float\n+        trigger_callback : bool, default: True\n+            Whether to trigger the callback immediately. When False,\n+            the callback will be deferred until drag completion.\n+        \"\"\"\n+        val = np.sort(val)\n+        _api.check_shape((2,), val=val)\n+        vmin, vmax = val\n+        vmin = self._value_in_bounds(vmin)\n+        vmax = self._value_in_bounds(vmax)\n+        if vmax < vmin:\n+            raise ValueError(f\"Value vmax={vmax} is less than vmin={vmin}\")\n+        self._active_handle = None\n+        self._update_selection_poly(vmin, vmax)\n+        if self.orientation == \"vertical\":\n+            self._handles[0].set_ydata([vmin])\n+            self._handles[1].set_ydata([vmax])\n+        else:\n+            self._handles[0].set_xdata([vmin])\n+            self._handles[1].set_xdata([vmax])\n+\n+        self.valtext.set_text(self._format((vmin, vmax)))\n+\n         if self.drawon:\n             self.ax.figure.canvas.draw_idle()\n         self.val = (vmin, vmax)\n-        if self.eventson:\n+        if self.eventson and trigger_callback and not getattr(self, 'drag_active', False):\n             self._observers.process(\"changed\", (vmin, vmax))\n+        elif self.eventson and getattr(self, 'drag_active', False):\n+            # Store the value for deferred callback during drag\n+            self._pending_callback_val = (vmin, vmax)\n \n     def on_changed(self, func):\n         \"\"\"\n",
    "variant_1": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex ebe5da43e2..64465163eb 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -294,11 +294,14 @@ class SliderBase(AxesWidget):\n         ax.set_axis_off()\n         ax.set_navigate(False)\n \n+\n         self.connect_event(\"button_press_event\", self._update)\n         self.connect_event(\"button_release_event\", self._update)\n         if dragging:\n             self.connect_event(\"motion_notify_event\", self._update)\n         self._observers = cbook.CallbackRegistry(signals=[\"changed\"])\n+        self._pending_callback_val = None\n+        self.drag_active = False\n \n     def _stepped_value(self, val):\n         \"\"\"Return *val* coerced to closest number in the ``valstep`` grid.\"\"\"\n@@ -538,18 +541,31 @@ class Slider(SliderBase):\n         if not self.drag_active:\n             return\n \n+        elif ((event.name == 'button_release_event') or\n+\n         elif ((event.name == 'button_release_event') or\n               (event.name == 'button_press_event' and\n                event.inaxes != self.ax)):\n             self.drag_active = False\n             event.canvas.release_mouse(self.ax)\n+            # Process any pending callback after drag completion\n+            if hasattr(self, '_pending_callback_val') and self._pending_callback_val is not None:\n+                pending_val = self._pending_callback_val\n+                self._pending_callback_val = None\n+                self.set_val(pending_val)\n             return\n         if self.orientation == 'vertical':\n             val = self._value_in_bounds(event.ydata)\n         else:\n             val = self._value_in_bounds(event.xdata)\n         if val not in [None, self.val]:\n-            self.set_val(val)\n+            if self.drag_active:\n+                # Defer callback during active dragging\n+                self._pending_callback_val = val\n+                # Update visual appearance without triggering callback\n+                self.set_val(val, trigger_callback=False)\n+            else:\n+                self.set_val(val)\n \n     def _format(self, val):\n         \"\"\"Pretty-print *val*.\"\"\"\n@@ -579,10 +595,41 @@ class Slider(SliderBase):\n             self._handle.set_xdata([val])\n         self.poly.xy = xy\n         self.valtext.set_text(self._format(val))\n+\n+    def set_val(self, val, trigger_callback=True):\n+        \"\"\"\n+        Set the value of the slider.\n+\n+        Parameters\n+        ----------\n+        val : float\n+        \"\"\"\n+        if self.closedmin and val <= self.valmin:\n+            if not self.closedmax:\n+                val = np.nextafter(self.valmin, 1)\n+            else:\n+                val = self.valmin\n+        elif self.closedmax and val >= self.valmax:\n+            if not self.closedmin:\n+                val = np.nextafter(self.valmax, -1)\n+            else:\n+                val = self.valmax\n+\n+        if self.orientation == 'vertical':\n+            xy = self.poly.xy\n+            xy[2] = .25, val\n+            xy[3] = .75, val\n+        else:\n+            xy = self.poly.xy\n+            xy[1] = .25, val\n+            xy[2] = .75, val\n+\n+        self.poly.xy = xy\n+        self.valtext.set_text(self._format(val))\n         if self.drawon:\n             self.ax.figure.canvas.draw_idle()\n         self.val = val\n-        if self.eventson:\n+        if self.eventson and trigger_callback and not getattr(self, 'drag_active', False):\n             self._observers.process('changed', val)\n \n     def on_changed(self, func):\n@@ -884,6 +931,16 @@ class RangeSlider(SliderBase):\n             self._active_handle = None\n             return\n \n+        # determine which handle was grabbed\n+        if self.orientation == \"vertical\":\n+            handle_index = np.argmin(\n+                np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n+            )\n+        else:\n+            handle_index = np.argmin(\n+                np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n+            )\n+\n         # determine which handle was grabbed\n         if self.orientation == \"vertical\":\n             handle_index = np.argmin(\n@@ -901,9 +958,15 @@ class RangeSlider(SliderBase):\n             self._active_handle = handle\n \n         if self.orientation == \"vertical\":\n-            self._update_val_from_pos(event.ydata)\n+            if self.drag_active:\n+                self._pending_callback_pos = event.ydata\n+            else:\n+                self._update_val_from_pos(event.ydata)\n         else:\n-            self._update_val_from_pos(event.xdata)\n+            if self.drag_active:\n+                self._pending_callback_pos = event.xdata\n+            else:\n+                self._update_val_from_pos(event.xdata)\n \n     def _format(self, val):\n         \"\"\"Pretty-print *val*.\"\"\"\n@@ -962,11 +1025,47 @@ class RangeSlider(SliderBase):\n \n         self.valtext.set_text(self._format((vmin, vmax)))\n \n+\n+    def set_val(self, val, trigger_callback=True):\n+        \"\"\"\n+        Set the value of the slider.\n+\n+        Parameters\n+        ----------\n+        val : tuple of float\n+        trigger_callback : bool, default: True\n+            Whether to trigger the callback. Set to False to defer callback\n+            execution until after active dragging is complete.\n+        \"\"\"\n+        if self.closedmin and val[0] <= self.valmin:\n+            if not self.closedmax and val[1] >= self.valmax:\n+                raise ValueError(f\"val[0] ({val[0]}) <= valmin ({self.valmin}) \"\n+                                 f\"AND val[1] ({val[1]}) >= valmax ({self.valmax})\")\n+            val = (self.valmin, val[1])\n+        elif self.closedmax and val[1] >= self.valmax:\n+            val = (val[0], self.valmax)\n+\n+        vmin, vmax = val\n+        if vmin > vmax:\n+            vmin, vmax = vmax, vmin\n+        self._update_selection_poly(vmin, vmax)\n+        if self.orientation == \"vertical\":\n+            self._handles[0].set_ydata([vmin])\n+            self._handles[1].set_ydata([vmax])\n+        else:\n+            self._handles[0].set_xdata([vmin])\n+            self._handles[1].set_xdata([vmax])\n+\n+        self.valtext.set_text(self._format((vmin, vmax)))\n+\n         if self.drawon:\n             self.ax.figure.canvas.draw_idle()\n         self.val = (vmin, vmax)\n-        if self.eventson:\n+        if self.eventson and trigger_callback and not getattr(self, 'drag_active', False):\n             self._observers.process(\"changed\", (vmin, vmax))\n+        elif self.eventson and getattr(self, 'drag_active', False):\n+            # Store pending callback for execution after drag completion\n+            self._pending_callback_val = (vmin, vmax)\n \n     def on_changed(self, func):\n         \"\"\"\n",
    "variant_2": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex ebe5da43e2..95769a273f 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -294,11 +294,14 @@ class SliderBase(AxesWidget):\n         ax.set_axis_off()\n         ax.set_navigate(False)\n \n+\n         self.connect_event(\"button_press_event\", self._update)\n         self.connect_event(\"button_release_event\", self._update)\n         if dragging:\n             self.connect_event(\"motion_notify_event\", self._update)\n         self._observers = cbook.CallbackRegistry(signals=[\"changed\"])\n+        self._pending_callback_val = None\n+        self.drag_active = False\n \n     def _stepped_value(self, val):\n         \"\"\"Return *val* coerced to closest number in the ``valstep`` grid.\"\"\"\n@@ -538,18 +541,30 @@ class Slider(SliderBase):\n         if not self.drag_active:\n             return\n \n+        elif ((event.name == 'button_release_event') or\n+\n         elif ((event.name == 'button_release_event') or\n               (event.name == 'button_press_event' and\n                event.inaxes != self.ax)):\n             self.drag_active = False\n             event.canvas.release_mouse(self.ax)\n+            # Process any pending callback after drag completion\n+            if hasattr(self, '_pending_callback_val') and self._pending_callback_val is not None:\n+                pending_val = self._pending_callback_val\n+                self._pending_callback_val = None\n+                if pending_val != self.val:\n+                    self.set_val(pending_val)\n             return\n         if self.orientation == 'vertical':\n             val = self._value_in_bounds(event.ydata)\n         else:\n             val = self._value_in_bounds(event.xdata)\n         if val not in [None, self.val]:\n-            self.set_val(val)\n+            if self.drag_active:\n+                # Store pending value during drag, don't trigger callback yet\n+                self._pending_callback_val = val\n+            else:\n+                self.set_val(val)\n \n     def _format(self, val):\n         \"\"\"Pretty-print *val*.\"\"\"\n@@ -579,10 +594,30 @@ class Slider(SliderBase):\n             self._handle.set_xdata([val])\n         self.poly.xy = xy\n         self.valtext.set_text(self._format(val))\n+\n+    def set_val(self, val, trigger_callback=True):\n+        \"\"\"\n+        Set slider value to *val*\n+\n+        Parameters\n+        ----------\n+        val : float\n+        \"\"\"\n+        xy = self.poly.xy\n+        if self.orientation == 'vertical':\n+            xy[1] = .25, val\n+            xy[2] = .75, val\n+            self._handle.set_ydata([val])\n+        else:\n+            xy[2] = val, .75\n+            xy[3] = val, .25\n+            self._handle.set_xdata([val])\n+        self.poly.xy = xy\n+        self.valtext.set_text(self._format(val))\n         if self.drawon:\n             self.ax.figure.canvas.draw_idle()\n         self.val = val\n-        if self.eventson:\n+        if self.eventson and trigger_callback and not getattr(self, 'drag_active', False):\n             self._observers.process('changed', val)\n \n     def on_changed(self, func):\n@@ -884,6 +919,16 @@ class RangeSlider(SliderBase):\n             self._active_handle = None\n             return\n \n+        # determine which handle was grabbed\n+        if self.orientation == \"vertical\":\n+            handle_index = np.argmin(\n+                np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n+            )\n+        else:\n+            handle_index = np.argmin(\n+                np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n+            )\n+\n         # determine which handle was grabbed\n         if self.orientation == \"vertical\":\n             handle_index = np.argmin(\n@@ -901,9 +946,17 @@ class RangeSlider(SliderBase):\n             self._active_handle = handle\n \n         if self.orientation == \"vertical\":\n-            self._update_val_from_pos(event.ydata)\n+            if self.drag_active:\n+                # Store position for deferred processing\n+                self._pending_callback_pos = event.ydata\n+            else:\n+                self._update_val_from_pos(event.ydata)\n         else:\n-            self._update_val_from_pos(event.xdata)\n+            if self.drag_active:\n+                # Store position for deferred processing\n+                self._pending_callback_pos = event.xdata\n+            else:\n+                self._update_val_from_pos(event.xdata)\n \n     def _format(self, val):\n         \"\"\"Pretty-print *val*.\"\"\"\n@@ -962,10 +1015,46 @@ class RangeSlider(SliderBase):\n \n         self.valtext.set_text(self._format((vmin, vmax)))\n \n+\n+    def set_val(self, val, trigger_callback=True):\n+        \"\"\"\n+        Set the value of the slider.\n+\n+        Parameters\n+        ----------\n+        val : tuple or array-like of length 2\n+            Lower and upper bounds for the slider.\n+        trigger_callback : bool, default: True\n+            Whether to trigger the callback. Set to False during dragging\n+            to defer callback execution until drag completion.\n+        \"\"\"\n+        if np.ndim(val) != 1 or len(val) != 2:\n+            raise ValueError(f\"val must have shape (2,), got {np.shape(val)}\")\n+        val = self._value_in_bounds(val)\n+        vmin, vmax = val\n+        if self._active_handle is None:\n+            if vmin > vmax:\n+                vmin, vmax = vmax, vmin\n+        else:\n+            if vmin == vmax:\n+                # Ensure that handles can't swap which one is min and which\n+                # is max: if at the same value, differentiate them by their\n+                # handle index.\n+                vmin, vmax = (vmax, vmin) if self._active_handle else (vmin, vmax)\n+        self._update_selection_poly(vmin, vmax)\n+        if self.orientation == \"vertical\":\n+            self._handles[0].set_ydata([vmin])\n+            self._handles[1].set_ydata([vmax])\n+        else:\n+            self._handles[0].set_xdata([vmin])\n+            self._handles[1].set_xdata([vmax])\n+\n+        self.valtext.set_text(self._format((vmin, vmax)))\n+\n         if self.drawon:\n             self.ax.figure.canvas.draw_idle()\n         self.val = (vmin, vmax)\n-        if self.eventson:\n+        if self.eventson and trigger_callback and not getattr(self, 'drag_active', False):\n             self._observers.process(\"changed\", (vmin, vmax))\n \n     def on_changed(self, func):\n",
    "variant_3": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex ebe5da43e2..43ce816464 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -294,11 +294,14 @@ class SliderBase(AxesWidget):\n         ax.set_axis_off()\n         ax.set_navigate(False)\n \n+\n         self.connect_event(\"button_press_event\", self._update)\n         self.connect_event(\"button_release_event\", self._update)\n         if dragging:\n             self.connect_event(\"motion_notify_event\", self._update)\n         self._observers = cbook.CallbackRegistry(signals=[\"changed\"])\n+        self._pending_callback_val = None\n+        self.drag_active = False\n \n     def _stepped_value(self, val):\n         \"\"\"Return *val* coerced to closest number in the ``valstep`` grid.\"\"\"\n@@ -538,18 +541,32 @@ class Slider(SliderBase):\n         if not self.drag_active:\n             return\n \n+        elif ((event.name == 'button_release_event') or\n+\n         elif ((event.name == 'button_release_event') or\n               (event.name == 'button_press_event' and\n                event.inaxes != self.ax)):\n             self.drag_active = False\n             event.canvas.release_mouse(self.ax)\n+            # Process any pending callback after drag completion\n+            if hasattr(self, '_pending_callback_val') and self._pending_callback_val is not None:\n+                pending_val = self._pending_callback_val\n+                self._pending_callback_val = None\n+                if pending_val != self.val:\n+                    self.set_val(pending_val)\n             return\n         if self.orientation == 'vertical':\n             val = self._value_in_bounds(event.ydata)\n         else:\n             val = self._value_in_bounds(event.xdata)\n         if val not in [None, self.val]:\n-            self.set_val(val)\n+            if self.drag_active:\n+                # Store pending value to trigger callback after drag completion\n+                self._pending_callback_val = val\n+                # Update visual position without triggering callback\n+                self.set_val(val, trigger_callback=False)\n+            else:\n+                self.set_val(val)\n \n     def _format(self, val):\n         \"\"\"Pretty-print *val*.\"\"\"\n@@ -579,10 +596,30 @@ class Slider(SliderBase):\n             self._handle.set_xdata([val])\n         self.poly.xy = xy\n         self.valtext.set_text(self._format(val))\n+\n+    def set_val(self, val, trigger_callback=True):\n+        \"\"\"\n+        Set slider value to *val*.\n+\n+        Parameters\n+        ----------\n+        val : float\n+        \"\"\"\n+        xy = self.poly.xy\n+        if self.orientation == 'vertical':\n+            xy[1] = .25, val\n+            xy[2] = .75, val\n+            self._handle.set_ydata([val])\n+        else:\n+            xy[2] = val, .75\n+            xy[3] = val, .25\n+            self._handle.set_xdata([val])\n+        self.poly.xy = xy\n+        self.valtext.set_text(self._format(val))\n         if self.drawon:\n             self.ax.figure.canvas.draw_idle()\n         self.val = val\n-        if self.eventson:\n+        if self.eventson and trigger_callback and not getattr(self, 'drag_active', False):\n             self._observers.process('changed', val)\n \n     def on_changed(self, func):\n@@ -884,6 +921,16 @@ class RangeSlider(SliderBase):\n             self._active_handle = None\n             return\n \n+        # determine which handle was grabbed\n+        if self.orientation == \"vertical\":\n+            handle_index = np.argmin(\n+                np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n+            )\n+        else:\n+            handle_index = np.argmin(\n+                np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n+            )\n+\n         # determine which handle was grabbed\n         if self.orientation == \"vertical\":\n             handle_index = np.argmin(\n@@ -901,9 +948,17 @@ class RangeSlider(SliderBase):\n             self._active_handle = handle\n \n         if self.orientation == \"vertical\":\n-            self._update_val_from_pos(event.ydata)\n+            if self.drag_active:\n+                # Store pending position for callback after drag completion\n+                self._pending_callback_pos = event.ydata\n+            else:\n+                self._update_val_from_pos(event.ydata)\n         else:\n-            self._update_val_from_pos(event.xdata)\n+            if self.drag_active:\n+                # Store pending position for callback after drag completion\n+                self._pending_callback_pos = event.xdata\n+            else:\n+                self._update_val_from_pos(event.xdata)\n \n     def _format(self, val):\n         \"\"\"Pretty-print *val*.\"\"\"\n@@ -962,10 +1017,54 @@ class RangeSlider(SliderBase):\n \n         self.valtext.set_text(self._format((vmin, vmax)))\n \n+\n+    def set_val(self, val, trigger_callback=True):\n+        \"\"\"\n+        Set the value of the slider.\n+\n+        Parameters\n+        ----------\n+        val : tuple of float\n+        trigger_callback : bool, optional\n+            If True, trigger the callback functions. Default is True.\n+        \"\"\"\n+        if self.closedmin and val[0] <= self.valmin:\n+            if not self.closedmax and val[1] >= self.valmax:\n+                raise ValueError(f\"Both min and max are outside the range\")\n+            val = (self.valmin, val[1])\n+        if self.closedmax and val[1] >= self.valmax:\n+            val = (val[0], self.valmax)\n+        if self.closedmin and val[0] <= self.valmin:\n+            val = (self.valmin, val[1])\n+        if self.closedmax and val[1] >= self.valmax:\n+            val = (val[0], self.valmax)\n+        if val[0] > val[1]:\n+            val = (val[1], val[0])\n+        vmin, vmax = val\n+        if vmin <= self.valmin:\n+            if not self.closedmin:\n+                return\n+            vmin = self.valmin\n+        if vmax >= self.valmax:\n+            if not self.closedmax:\n+                return\n+            vmax = self.valmax\n+        if vmin > vmax:\n+            vmin = vmax\n+        self._update_selection_poly(vmin, vmax)\n+        if self.orientation == \"vertical\":\n+            self._handles[0].set_ydata([vmin])\n+            self._handles[1].set_ydata([vmax])\n+        else:\n+            self._handles[0].set_xdata([vmin])\n+            self._handles[1].set_xdata([vmax])\n+\n+        self.valtext.set_text(self._format((vmin, vmax)))\n+\n         if self.drawon:\n             self.ax.figure.canvas.draw_idle()\n         self.val = (vmin, vmax)\n-        if self.eventson:\n+        if self.eventson and trigger_callback and not getattr(self, 'drag_active', False):\n             self._observers.process(\"changed\", (vmin, vmax))\n \n     def on_changed(self, func):\n",
    "variant_4": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex ebe5da43e2..cdb002aefa 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -294,11 +294,14 @@ class SliderBase(AxesWidget):\n         ax.set_axis_off()\n         ax.set_navigate(False)\n \n+\n         self.connect_event(\"button_press_event\", self._update)\n         self.connect_event(\"button_release_event\", self._update)\n         if dragging:\n             self.connect_event(\"motion_notify_event\", self._update)\n         self._observers = cbook.CallbackRegistry(signals=[\"changed\"])\n+        self._pending_callback_val = None\n+        self.drag_active = False\n \n     def _stepped_value(self, val):\n         \"\"\"Return *val* coerced to closest number in the ``valstep`` grid.\"\"\"\n@@ -538,18 +541,32 @@ class Slider(SliderBase):\n         if not self.drag_active:\n             return\n \n+        elif ((event.name == 'button_release_event') or\n+\n         elif ((event.name == 'button_release_event') or\n               (event.name == 'button_press_event' and\n                event.inaxes != self.ax)):\n             self.drag_active = False\n             event.canvas.release_mouse(self.ax)\n+            # Process any pending callback after drag completion\n+            if hasattr(self, '_pending_callback_val') and self._pending_callback_val is not None:\n+                pending_val = self._pending_callback_val\n+                self._pending_callback_val = None\n+                if pending_val != self.val:\n+                    self.set_val(pending_val)\n             return\n         if self.orientation == 'vertical':\n             val = self._value_in_bounds(event.ydata)\n         else:\n             val = self._value_in_bounds(event.xdata)\n         if val not in [None, self.val]:\n-            self.set_val(val)\n+            # Defer callback execution during active dragging\n+            if self.drag_active:\n+                self._pending_callback_val = val\n+                # Update visual position without triggering callbacks\n+                self.set_val(val, trigger_callback=False)\n+            else:\n+                self.set_val(val)\n \n     def _format(self, val):\n         \"\"\"Pretty-print *val*.\"\"\"\n@@ -579,10 +596,30 @@ class Slider(SliderBase):\n             self._handle.set_xdata([val])\n         self.poly.xy = xy\n         self.valtext.set_text(self._format(val))\n+\n+    def set_val(self, val, trigger_callback=True):\n+        \"\"\"\n+        Set slider value to *val*.\n+\n+        Parameters\n+        ----------\n+        val : float\n+        \"\"\"\n+        xy = self.poly.xy\n+        if self.orientation == 'vertical':\n+            xy[1] = .25, val\n+            xy[2] = .75, val\n+            self._handle.set_ydata([val])\n+        else:\n+            xy[2] = val, .75\n+            xy[3] = val, .25\n+            self._handle.set_xdata([val])\n+        self.poly.xy = xy\n+        self.valtext.set_text(self._format(val))\n         if self.drawon:\n             self.ax.figure.canvas.draw_idle()\n         self.val = val\n-        if self.eventson:\n+        if self.eventson and trigger_callback and not getattr(self, 'drag_active', False):\n             self._observers.process('changed', val)\n \n     def on_changed(self, func):\n@@ -884,6 +921,16 @@ class RangeSlider(SliderBase):\n             self._active_handle = None\n             return\n \n+        # determine which handle was grabbed\n+        if self.orientation == \"vertical\":\n+            handle_index = np.argmin(\n+                np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n+            )\n+        else:\n+            handle_index = np.argmin(\n+                np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n+            )\n+\n         # determine which handle was grabbed\n         if self.orientation == \"vertical\":\n             handle_index = np.argmin(\n@@ -901,9 +948,15 @@ class RangeSlider(SliderBase):\n             self._active_handle = handle\n \n         if self.orientation == \"vertical\":\n-            self._update_val_from_pos(event.ydata)\n+            if self.drag_active:\n+                self._pending_callback_pos = event.ydata\n+            else:\n+                self._update_val_from_pos(event.ydata)\n         else:\n-            self._update_val_from_pos(event.xdata)\n+            if self.drag_active:\n+                self._pending_callback_pos = event.xdata\n+            else:\n+                self._update_val_from_pos(event.xdata)\n \n     def _format(self, val):\n         \"\"\"Pretty-print *val*.\"\"\"\n@@ -962,10 +1015,35 @@ class RangeSlider(SliderBase):\n \n         self.valtext.set_text(self._format((vmin, vmax)))\n \n+\n+    def set_val(self, val, trigger_callback=True):\n+        \"\"\"\n+        Set the value of the slider.\n+\n+        Parameters\n+        ----------\n+        val : tuple or array-like of length 2\n+        \"\"\"\n+        if np.iterable(val):\n+            vmin, vmax = val\n+        else:\n+            # Assume val is a scalar and set both ends of the range to val\n+            vmin = vmax = val\n+        vmin, vmax = self._min_in_bounds(vmin), self._max_in_bounds(vmax)\n+        self._update_selection_poly(vmin, vmax)\n+        if self.orientation == \"vertical\":\n+            self._handles[0].set_ydata([vmin])\n+            self._handles[1].set_ydata([vmax])\n+        else:\n+            self._handles[0].set_xdata([vmin])\n+            self._handles[1].set_xdata([vmax])\n+\n+        self.valtext.set_text(self._format((vmin, vmax)))\n+\n         if self.drawon:\n             self.ax.figure.canvas.draw_idle()\n         self.val = (vmin, vmax)\n-        if self.eventson:\n+        if self.eventson and trigger_callback and not getattr(self, 'drag_active', False):\n             self._observers.process(\"changed\", (vmin, vmax))\n \n     def on_changed(self, func):\n",
    "variant_5": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex ebe5da43e2..9def3c28a3 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -294,11 +294,14 @@ class SliderBase(AxesWidget):\n         ax.set_axis_off()\n         ax.set_navigate(False)\n \n+\n         self.connect_event(\"button_press_event\", self._update)\n         self.connect_event(\"button_release_event\", self._update)\n         if dragging:\n             self.connect_event(\"motion_notify_event\", self._update)\n         self._observers = cbook.CallbackRegistry(signals=[\"changed\"])\n+        self._pending_callback_val = None\n+        self.drag_active = False\n \n     def _stepped_value(self, val):\n         \"\"\"Return *val* coerced to closest number in the ``valstep`` grid.\"\"\"\n@@ -538,18 +541,32 @@ class Slider(SliderBase):\n         if not self.drag_active:\n             return\n \n+        elif ((event.name == 'button_release_event') or\n+\n         elif ((event.name == 'button_release_event') or\n               (event.name == 'button_press_event' and\n                event.inaxes != self.ax)):\n             self.drag_active = False\n             event.canvas.release_mouse(self.ax)\n+            # Process any pending callback after drag completion\n+            if hasattr(self, '_pending_callback_val') and self._pending_callback_val is not None:\n+                pending_val = self._pending_callback_val\n+                self._pending_callback_val = None\n+                if pending_val != self.val:\n+                    self.set_val(pending_val)\n             return\n         if self.orientation == 'vertical':\n             val = self._value_in_bounds(event.ydata)\n         else:\n             val = self._value_in_bounds(event.xdata)\n         if val not in [None, self.val]:\n-            self.set_val(val)\n+            # Defer callback during active dragging\n+            if self.drag_active:\n+                self._pending_callback_val = val\n+                # Update visual position without triggering callback\n+                self.set_val(val, trigger_callback=False)\n+            else:\n+                self.set_val(val)\n \n     def _format(self, val):\n         \"\"\"Pretty-print *val*.\"\"\"\n@@ -579,10 +596,30 @@ class Slider(SliderBase):\n             self._handle.set_xdata([val])\n         self.poly.xy = xy\n         self.valtext.set_text(self._format(val))\n+\n+    def set_val(self, val, trigger_callback=True):\n+        \"\"\"\n+        Set slider value to *val*.\n+\n+        Parameters\n+        ----------\n+        val : float\n+        \"\"\"\n+        xy = self.poly.xy\n+        if self.orientation == 'vertical':\n+            xy[1] = .25, val\n+            xy[2] = .75, val\n+            self._handle.set_ydata([val])\n+        else:\n+            xy[2] = val, .75\n+            xy[3] = val, .25\n+            self._handle.set_xdata([val])\n+        self.poly.xy = xy\n+        self.valtext.set_text(self._format(val))\n         if self.drawon:\n             self.ax.figure.canvas.draw_idle()\n         self.val = val\n-        if self.eventson:\n+        if self.eventson and trigger_callback and not getattr(self, 'drag_active', False):\n             self._observers.process('changed', val)\n \n     def on_changed(self, func):\n@@ -884,6 +921,16 @@ class RangeSlider(SliderBase):\n             self._active_handle = None\n             return\n \n+        # determine which handle was grabbed\n+        if self.orientation == \"vertical\":\n+            handle_index = np.argmin(\n+                np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n+            )\n+        else:\n+            handle_index = np.argmin(\n+                np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n+            )\n+\n         # determine which handle was grabbed\n         if self.orientation == \"vertical\":\n             handle_index = np.argmin(\n@@ -901,9 +948,17 @@ class RangeSlider(SliderBase):\n             self._active_handle = handle\n \n         if self.orientation == \"vertical\":\n-            self._update_val_from_pos(event.ydata)\n+            if self.drag_active:\n+                # Store pending position during active dragging\n+                self._pending_pos = event.ydata\n+            else:\n+                self._update_val_from_pos(event.ydata)\n         else:\n-            self._update_val_from_pos(event.xdata)\n+            if self.drag_active:\n+                # Store pending position during active dragging\n+                self._pending_pos = event.xdata\n+            else:\n+                self._update_val_from_pos(event.xdata)\n \n     def _format(self, val):\n         \"\"\"Pretty-print *val*.\"\"\"\n@@ -962,10 +1017,37 @@ class RangeSlider(SliderBase):\n \n         self.valtext.set_text(self._format((vmin, vmax)))\n \n+\n+    def set_val(self, val, trigger_callback=True):\n+        \"\"\"\n+        Set the value of the slider.\n+\n+        Parameters\n+        ----------\n+        val : tuple or array-like of length 2\n+            Lower and upper bounds for the slider.\n+        trigger_callback : bool, default: True\n+            Whether to trigger the on_changed callback.\n+        \"\"\"\n+        val = np.sort(val)\n+        _api.check_shape((2,), val=val)\n+        vmin, vmax = val\n+        vmin = self._min_in_bounds(vmin)\n+        vmax = self._max_in_bounds(vmax)\n+        self._update_selection_poly(vmin, vmax)\n+        if self.orientation == \"vertical\":\n+            self._handles[0].set_ydata([vmin])\n+            self._handles[1].set_ydata([vmax])\n+        else:\n+            self._handles[0].set_xdata([vmin])\n+            self._handles[1].set_xdata([vmax])\n+\n+        self.valtext.set_text(self._format((vmin, vmax)))\n+\n         if self.drawon:\n             self.ax.figure.canvas.draw_idle()\n         self.val = (vmin, vmax)\n-        if self.eventson:\n+        if self.eventson and trigger_callback and not getattr(self, 'drag_active', False):\n             self._observers.process(\"changed\", (vmin, vmax))\n \n     def on_changed(self, func):\n",
    "variant_6": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex ebe5da43e2..3847acbb8e 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -294,11 +294,13 @@ class SliderBase(AxesWidget):\n         ax.set_axis_off()\n         ax.set_navigate(False)\n \n+\n         self.connect_event(\"button_press_event\", self._update)\n         self.connect_event(\"button_release_event\", self._update)\n         if dragging:\n             self.connect_event(\"motion_notify_event\", self._update)\n         self._observers = cbook.CallbackRegistry(signals=[\"changed\"])\n+        self._pending_callback_val = None\n \n     def _stepped_value(self, val):\n         \"\"\"Return *val* coerced to closest number in the ``valstep`` grid.\"\"\"\n@@ -538,18 +540,32 @@ class Slider(SliderBase):\n         if not self.drag_active:\n             return\n \n+        elif ((event.name == 'button_release_event') or\n+\n         elif ((event.name == 'button_release_event') or\n               (event.name == 'button_press_event' and\n                event.inaxes != self.ax)):\n             self.drag_active = False\n             event.canvas.release_mouse(self.ax)\n+            # Process any pending callback after drag completion\n+            if hasattr(self, '_pending_callback_val') and self._pending_callback_val is not None:\n+                pending_val = self._pending_callback_val\n+                self._pending_callback_val = None\n+                if pending_val != self.val:\n+                    self.set_val(pending_val)\n             return\n         if self.orientation == 'vertical':\n             val = self._value_in_bounds(event.ydata)\n         else:\n             val = self._value_in_bounds(event.xdata)\n         if val not in [None, self.val]:\n-            self.set_val(val)\n+            # Defer callback execution during active dragging\n+            if self.drag_active:\n+                self._pending_callback_val = val\n+                # Update visual position without triggering callback\n+                self.set_val(val, trigger_callback=False)\n+            else:\n+                self.set_val(val)\n \n     def _format(self, val):\n         \"\"\"Pretty-print *val*.\"\"\"\n@@ -579,10 +595,30 @@ class Slider(SliderBase):\n             self._handle.set_xdata([val])\n         self.poly.xy = xy\n         self.valtext.set_text(self._format(val))\n+\n+    def set_val(self, val, trigger_callback=True):\n+        \"\"\"\n+        Set slider value to *val*.\n+\n+        Parameters\n+        ----------\n+        val : float\n+        \"\"\"\n+        xy = self.poly.xy\n+        if self.orientation == 'vertical':\n+            xy[1] = .25, val\n+            xy[2] = .75, val\n+            self._handle.set_ydata([val])\n+        else:\n+            xy[2] = val, .75\n+            xy[3] = val, .25\n+            self._handle.set_xdata([val])\n+        self.poly.xy = xy\n+        self.valtext.set_text(self._format(val))\n         if self.drawon:\n             self.ax.figure.canvas.draw_idle()\n         self.val = val\n-        if self.eventson:\n+        if self.eventson and trigger_callback and not getattr(self, 'drag_active', False):\n             self._observers.process('changed', val)\n \n     def on_changed(self, func):\n@@ -893,6 +929,7 @@ class RangeSlider(SliderBase):\n             handle_index = np.argmin(\n                 np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n             )\n+\n         handle = self._handles[handle_index]\n \n         # these checks ensure smooth behavior if the handles swap which one\n@@ -901,9 +938,16 @@ class RangeSlider(SliderBase):\n             self._active_handle = handle\n \n         if self.orientation == \"vertical\":\n-            self._update_val_from_pos(event.ydata)\n+            self._pending_callback_pos = event.ydata\n         else:\n-            self._update_val_from_pos(event.xdata)\n+            self._pending_callback_pos = event.xdata\n+        \n+        # Only update immediately if not dragging, otherwise defer until drag ends\n+        if not self.drag_active:\n+            if self.orientation == \"vertical\":\n+                self._update_val_from_pos(event.ydata)\n+            else:\n+                self._update_val_from_pos(event.xdata)\n \n     def _format(self, val):\n         \"\"\"Pretty-print *val*.\"\"\"\n@@ -962,10 +1006,33 @@ class RangeSlider(SliderBase):\n \n         self.valtext.set_text(self._format((vmin, vmax)))\n \n+\n+    def set_val(self, val, trigger_callback=True):\n+        \"\"\"\n+        Set the value of the slider.\n+\n+        Parameters\n+        ----------\n+        val : tuple or array-like of float\n+        \"\"\"\n+        if self.orientation == 'vertical':\n+            vmin, vmax = self._value_in_bounds(val)\n+        else:\n+            vmin, vmax = self._value_in_bounds(val)\n+        self._update_selection_poly(vmin, vmax)\n+        if self.orientation == \"vertical\":\n+            self._handles[0].set_ydata([vmin])\n+            self._handles[1].set_ydata([vmax])\n+        else:\n+            self._handles[0].set_xdata([vmin])\n+            self._handles[1].set_xdata([vmax])\n+\n+        self.valtext.set_text(self._format((vmin, vmax)))\n+\n         if self.drawon:\n             self.ax.figure.canvas.draw_idle()\n         self.val = (vmin, vmax)\n-        if self.eventson:\n+        if self.eventson and trigger_callback and not getattr(self, 'drag_active', False):\n             self._observers.process(\"changed\", (vmin, vmax))\n \n     def on_changed(self, func):\n",
    "variant_7": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex ebe5da43e2..25208c60d2 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -294,11 +294,13 @@ class SliderBase(AxesWidget):\n         ax.set_axis_off()\n         ax.set_navigate(False)\n \n+\n         self.connect_event(\"button_press_event\", self._update)\n         self.connect_event(\"button_release_event\", self._update)\n         if dragging:\n             self.connect_event(\"motion_notify_event\", self._update)\n         self._observers = cbook.CallbackRegistry(signals=[\"changed\"])\n+        self._pending_callback_val = None\n \n     def _stepped_value(self, val):\n         \"\"\"Return *val* coerced to closest number in the ``valstep`` grid.\"\"\"\n@@ -538,18 +540,32 @@ class Slider(SliderBase):\n         if not self.drag_active:\n             return\n \n+        elif ((event.name == 'button_release_event') or\n+\n         elif ((event.name == 'button_release_event') or\n               (event.name == 'button_press_event' and\n                event.inaxes != self.ax)):\n             self.drag_active = False\n             event.canvas.release_mouse(self.ax)\n+            # Process any pending callback after drag completion\n+            if hasattr(self, '_pending_callback_val') and self._pending_callback_val is not None:\n+                pending_val = self._pending_callback_val\n+                self._pending_callback_val = None\n+                if pending_val != self.val:\n+                    self.set_val(pending_val)\n             return\n         if self.orientation == 'vertical':\n             val = self._value_in_bounds(event.ydata)\n         else:\n             val = self._value_in_bounds(event.xdata)\n         if val not in [None, self.val]:\n-            self.set_val(val)\n+            if self.drag_active:\n+                # Defer callback during active dragging\n+                self._pending_callback_val = val\n+                # Update visual position without triggering callback\n+                self.set_val(val, trigger_callback=False)\n+            else:\n+                self.set_val(val)\n \n     def _format(self, val):\n         \"\"\"Pretty-print *val*.\"\"\"\n@@ -579,10 +595,41 @@ class Slider(SliderBase):\n             self._handle.set_xdata([val])\n         self.poly.xy = xy\n         self.valtext.set_text(self._format(val))\n+\n+    def set_val(self, val, trigger_callback=True):\n+        \"\"\"\n+        Set the value of the slider.\n+\n+        Parameters\n+        ----------\n+        val : float\n+        \"\"\"\n+        if self.closedmin and val <= self.valmin:\n+            if not self.closedmax:\n+                val = np.nextafter(self.valmin, self.valmax)\n+            else:\n+                val = self.valmin\n+        elif self.closedmax and val >= self.valmax:\n+            if not self.closedmin:\n+                val = np.nextafter(self.valmax, self.valmin)\n+            else:\n+                val = self.valmax\n+\n+        xy = self.poly.xy\n+        if self.orientation == 'vertical':\n+            xy[1] = .25, val\n+            xy[2] = .75, val\n+            self._handle.set_ydata([val])\n+        else:\n+            xy[2] = val, .75\n+            xy[3] = val, .25\n+            self._handle.set_xdata([val])\n+        self.poly.xy = xy\n+        self.valtext.set_text(self._format(val))\n         if self.drawon:\n             self.ax.figure.canvas.draw_idle()\n         self.val = val\n-        if self.eventson:\n+        if self.eventson and trigger_callback and not getattr(self, 'drag_active', False):\n             self._observers.process('changed', val)\n \n     def on_changed(self, func):\n@@ -884,6 +931,16 @@ class RangeSlider(SliderBase):\n             self._active_handle = None\n             return\n \n+        # determine which handle was grabbed\n+        if self.orientation == \"vertical\":\n+            handle_index = np.argmin(\n+                np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n+            )\n+        else:\n+            handle_index = np.argmin(\n+                np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n+            )\n+\n         # determine which handle was grabbed\n         if self.orientation == \"vertical\":\n             handle_index = np.argmin(\n@@ -901,9 +958,15 @@ class RangeSlider(SliderBase):\n             self._active_handle = handle\n \n         if self.orientation == \"vertical\":\n-            self._update_val_from_pos(event.ydata)\n+            if self.drag_active:\n+                self._pending_callback_pos = event.ydata\n+            else:\n+                self._update_val_from_pos(event.ydata)\n         else:\n-            self._update_val_from_pos(event.xdata)\n+            if self.drag_active:\n+                self._pending_callback_pos = event.xdata\n+            else:\n+                self._update_val_from_pos(event.xdata)\n \n     def _format(self, val):\n         \"\"\"Pretty-print *val*.\"\"\"\n@@ -962,10 +1025,45 @@ class RangeSlider(SliderBase):\n \n         self.valtext.set_text(self._format((vmin, vmax)))\n \n+\n+    def set_val(self, val, trigger_callback=True):\n+        \"\"\"\n+        Set the value of the slider.\n+\n+        Parameters\n+        ----------\n+        val : tuple or array-like of float\n+        \"\"\"\n+        if self.closedmin and val[0] <= self.valmin:\n+            if not self.closedmax and val[1] >= self.valmax:\n+                raise ValueError(f\"Both val {val} <= valmin {self.valmin} and \"\n+                                 f\"val {val} >= valmax {self.valmax}\")\n+            val = (self.valmin, val[1])\n+        elif self.closedmax and val[1] >= self.valmax:\n+            val = (val[0], self.valmax)\n+\n+        if self.minspan is not None:\n+            if val[1] - val[0] < self.minspan:\n+                return\n+        vmin, vmax = val\n+        vmin = self._value_in_bounds(vmin)\n+        vmax = self._value_in_bounds(vmax)\n+        if vmin > vmax:\n+            vmin, vmax = vmax, vmin\n+        self._update_selection_poly(vmin, vmax)\n+        if self.orientation == \"vertical\":\n+            self._handles[0].set_ydata([vmin])\n+            self._handles[1].set_ydata([vmax])\n+        else:\n+            self._handles[0].set_xdata([vmin])\n+            self._handles[1].set_xdata([vmax])\n+\n+        self.valtext.set_text(self._format((vmin, vmax)))\n+\n         if self.drawon:\n             self.ax.figure.canvas.draw_idle()\n         self.val = (vmin, vmax)\n-        if self.eventson:\n+        if self.eventson and trigger_callback and not getattr(self, 'drag_active', False):\n             self._observers.process(\"changed\", (vmin, vmax))\n \n     def on_changed(self, func):\n",
    "variant_8": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex ebe5da43e2..f78371df9e 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -294,11 +294,13 @@ class SliderBase(AxesWidget):\n         ax.set_axis_off()\n         ax.set_navigate(False)\n \n+\n         self.connect_event(\"button_press_event\", self._update)\n         self.connect_event(\"button_release_event\", self._update)\n         if dragging:\n             self.connect_event(\"motion_notify_event\", self._update)\n         self._observers = cbook.CallbackRegistry(signals=[\"changed\"])\n+        self._pending_callback_val = None\n \n     def _stepped_value(self, val):\n         \"\"\"Return *val* coerced to closest number in the ``valstep`` grid.\"\"\"\n@@ -538,18 +540,32 @@ class Slider(SliderBase):\n         if not self.drag_active:\n             return\n \n+        elif ((event.name == 'button_release_event') or\n+\n         elif ((event.name == 'button_release_event') or\n               (event.name == 'button_press_event' and\n                event.inaxes != self.ax)):\n             self.drag_active = False\n             event.canvas.release_mouse(self.ax)\n+            # Process any pending callback after drag completion\n+            if hasattr(self, '_pending_callback_val') and self._pending_callback_val is not None:\n+                pending_val = self._pending_callback_val\n+                self._pending_callback_val = None\n+                if pending_val != self.val:\n+                    self.set_val(pending_val)\n             return\n         if self.orientation == 'vertical':\n             val = self._value_in_bounds(event.ydata)\n         else:\n             val = self._value_in_bounds(event.xdata)\n         if val not in [None, self.val]:\n-            self.set_val(val)\n+            # Defer callback during active dragging\n+            if self.drag_active:\n+                self._pending_callback_val = val\n+                # Update visual position without triggering callback\n+                self.set_val(val, trigger_callback=False)\n+            else:\n+                self.set_val(val)\n \n     def _format(self, val):\n         \"\"\"Pretty-print *val*.\"\"\"\n@@ -579,10 +595,30 @@ class Slider(SliderBase):\n             self._handle.set_xdata([val])\n         self.poly.xy = xy\n         self.valtext.set_text(self._format(val))\n+\n+    def set_val(self, val, trigger_callback=True):\n+        \"\"\"\n+        Set slider value to *val*.\n+\n+        Parameters\n+        ----------\n+        val : float\n+        \"\"\"\n+        xy = self.poly.xy\n+        if self.orientation == 'vertical':\n+            xy[1] = .25, val\n+            xy[2] = .75, val\n+            self._handle.set_ydata([val])\n+        else:\n+            xy[2] = val, .75\n+            xy[3] = val, .25\n+            self._handle.set_xdata([val])\n+        self.poly.xy = xy\n+        self.valtext.set_text(self._format(val))\n         if self.drawon:\n             self.ax.figure.canvas.draw_idle()\n         self.val = val\n-        if self.eventson:\n+        if self.eventson and trigger_callback and not getattr(self, 'drag_active', False):\n             self._observers.process('changed', val)\n \n     def on_changed(self, func):\n@@ -884,6 +920,16 @@ class RangeSlider(SliderBase):\n             self._active_handle = None\n             return\n \n+        # determine which handle was grabbed\n+        if self.orientation == \"vertical\":\n+            handle_index = np.argmin(\n+                np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n+            )\n+        else:\n+            handle_index = np.argmin(\n+                np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n+            )\n+\n         # determine which handle was grabbed\n         if self.orientation == \"vertical\":\n             handle_index = np.argmin(\n@@ -901,9 +947,15 @@ class RangeSlider(SliderBase):\n             self._active_handle = handle\n \n         if self.orientation == \"vertical\":\n-            self._update_val_from_pos(event.ydata)\n+            pos = event.ydata\n+        else:\n+            pos = event.xdata\n+\n+        # Defer callback execution during active dragging\n+        if self.drag_active:\n+            self._pending_callback_pos = pos\n         else:\n-            self._update_val_from_pos(event.xdata)\n+            self._update_val_from_pos(pos)\n \n     def _format(self, val):\n         \"\"\"Pretty-print *val*.\"\"\"\n@@ -962,10 +1014,37 @@ class RangeSlider(SliderBase):\n \n         self.valtext.set_text(self._format((vmin, vmax)))\n \n+\n+    def set_val(self, val, trigger_callback=True):\n+        \"\"\"\n+        Set slider value to *val*.\n+\n+        Parameters\n+        ----------\n+        val : tuple or array-like of length 2\n+        trigger_callback : bool, default: True\n+            Whether to trigger the callback. Set to False during dragging\n+            to avoid callback execution during active mouse interaction.\n+        \"\"\"\n+        val = np.sort(val)\n+        _api.check_shape((2,), val=val)\n+        vmin, vmax = val\n+        vmin = self._min_in_bounds(vmin)\n+        vmax = self._max_in_bounds(vmax)\n+        self._update_selection_poly(vmin, vmax)\n+        if self.orientation == \"vertical\":\n+            self._handles[0].set_ydata([vmin])\n+            self._handles[1].set_ydata([vmax])\n+        else:\n+            self._handles[0].set_xdata([vmin])\n+            self._handles[1].set_xdata([vmax])\n+\n+        self.valtext.set_text(self._format((vmin, vmax)))\n+\n         if self.drawon:\n             self.ax.figure.canvas.draw_idle()\n         self.val = (vmin, vmax)\n-        if self.eventson:\n+        if self.eventson and trigger_callback and not getattr(self, 'drag_active', False):\n             self._observers.process(\"changed\", (vmin, vmax))\n \n     def on_changed(self, func):\n"
  }
}