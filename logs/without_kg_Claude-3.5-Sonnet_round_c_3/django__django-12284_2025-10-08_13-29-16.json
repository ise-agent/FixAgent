{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/django/django/db/models/fields/__init__.py lines 766-772)": "\n        if self.choices is not None:\n            if not hasattr(cls, 'get_%s_display' % self.name):\n                setattr(\n                    cls,\n                    'get_%s_display' % self.name,\n                    partialmethod(cls._get_FIELD_display, field_name=self.name),\n                )\n",
    "Location 2 (/root/hy/projects_3/django/django/db/models/base.py lines 946-950)": "\n    def _get_FIELD_display(self, field):\n        value = getattr(self, field.attname)\n        # Dynamically resolve the field from the current model to get updated choices\n        current_field = self._meta.get_field(field.name)\n        choices_dict = dict(make_hashable(current_field.flatchoices))\n        # force_str() to coerce lazy strings.\n        return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n",
    "Location 3 (/root/hy/projects_3/django/django/db/models/fields/__init__.py lines 868-878)": "\n    def _get_flatchoices(self):\n        \"\"\"Flattened version of choices tuple.\"\"\"\n        if self.choices is None:\n            return []\n        flat = []\n        for choice, value in self.choices:\n            if isinstance(value, (list, tuple)):\n                flat.extend(value)\n            else:\n                flat.append((choice, value))\n        return flat\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/django/django/db/models/fields/__init__.py lines 766-772)": [
      "\n    def contribute_to_class(self, cls, name, private_only=False):\n        \"\"\"\n        Register the field with the model class it belongs to.\n\n        If private_only is True, create a separate instance of this field\n        for every subclass of cls, even if cls is not an abstract model.\n        \"\"\"\n        self.set_attributes_from_name(name)\n        self.model = cls\n        cls._meta.add_field(self, private=private_only)\n        if self.column:\n            # Don't override classmethods with the descriptor. This means that\n            # if you have a classmethod and a field with the same name, then\n            # such fields can't be deferred (we don't have a check for this).\n            if not getattr(cls, self.attname, None):\n                setattr(cls, self.attname, self.descriptor_class(self))\n        if self.choices is not None:\n            if not hasattr(cls, 'get_%s_display' % self.name):\n                setattr(\n                    cls,\n                    'get_%s_display' % self.name,\n                    partialmethod(cls._get_FIELD_display, field_name=self.name),\n                )\n",
      "\n    def contribute_to_class(self, cls, name, private_only=False):\n        \"\"\"\n        Register the field with the model class it belongs to.\n\n        If private_only is True, create a separate instance of this field\n        for every subclass of cls, even if cls is not an abstract model.\n        \"\"\"\n        self.set_attributes_from_name(name)\n        self.model = cls\n        cls._meta.add_field(self, private=private_only)\n        if self.column:\n            # Don't override classmethods with the descriptor. This means that\n            # if you have a classmethod and a field with the same name, then\n            # such fields can't be deferred (we don't have a check for this).\n            if not getattr(cls, self.attname, None):\n                setattr(cls, self.attname, self.descriptor_class(self))\n        if self.choices is not None:\n            if not hasattr(cls, 'get_%s_display' % self.name):\n                setattr(\n                    cls,\n                    'get_%s_display' % self.name,\n                    partialmethod(cls._get_FIELD_display, field_name=self.name),\n                )\n",
      "\n    def contribute_to_class(self, cls, name, private_only=False):\n        \"\"\"\n        Register the field with the model class it belongs to.\n\n        If private_only is True, create a separate instance of this field\n        for every subclass of cls, even if cls is not an abstract model.\n        \"\"\"\n        self.set_attributes_from_name(name)\n        self.model = cls\n        cls._meta.add_field(self, private=private_only)\n        if self.column:\n            # Don't override classmethods with the descriptor. This means that\n            # if you have a classmethod and a field with the same name, then\n            # such fields can't be deferred (we don't have a check for this).\n            if not getattr(cls, self.attname, None):\n                setattr(cls, self.attname, self.descriptor_class(self))\n        if self.choices is not None:\n            if not hasattr(cls, 'get_%s_display' % self.name):\n                setattr(\n                    cls,\n                    'get_%s_display' % self.name,\n                    partialmethod(cls._get_FIELD_display, field_name=self.name),\n                )\n",
      "\n    def contribute_to_class(self, cls, name, private_only=False):\n        \"\"\"\n        Register the field with the model class it belongs to.\n\n        If private_only is True, create a separate instance of this field\n        for every subclass of cls, even if cls is not an abstract model.\n        \"\"\"\n        self.set_attributes_from_name(name)\n        self.model = cls\n        cls._meta.add_field(self, private=private_only)\n        if self.column:\n            # Don't override classmethods with the descriptor. This means that\n            # if you have a classmethod and a field with the same name, then\n            # such fields can't be deferred (we don't have a check for this).\n            if not getattr(cls, self.attname, None):\n                setattr(cls, self.attname, self.descriptor_class(self))\n        if self.choices is not None:\n            if not hasattr(cls, 'get_%s_display' % self.name):\n                setattr(\n                    cls,\n                    'get_%s_display' % self.name,\n                    partialmethod(cls._get_FIELD_display, field_name=self.name),\n                )\n",
      "\n    def _get_FIELD_display(self, field):\n        value = getattr(self, field.attname)\n        # Get the field from the current model to ensure we have the latest choices\n        current_field = self._meta.get_field(field.name)\n        choices_dict = dict(current_field.flatchoices)\n        # force_str() to coerce lazy strings.\n        return choices_dict.get(make_hashable(value), value)\n",
      "\n    def contribute_to_class(self, cls, name, private_only=False):\n        \"\"\"\n        Register the field with the model class it belongs to.\n\n        If private_only is True, create a separate instance of this field\n        for every subclass of cls, even if cls is not an abstract model.\n        \"\"\"\n        self.set_attributes_from_name(name)\n        self.model = cls\n        cls._meta.add_field(self, private=private_only)\n        if self.column:\n            # Don't override classmethods with the descriptor. This means that\n            # if you have a classmethod and a field with the same name, then\n            # such fields can't be deferred (we don't have a check for this).\n            if not getattr(cls, self.attname, None):\n                setattr(cls, self.attname, self.descriptor_class(self))\n        if self.choices is not None:\n            if not hasattr(cls, 'get_%s_display' % self.name):\n                setattr(\n                    cls,\n                    'get_%s_display' % self.name,\n                    partialmethod(cls._get_FIELD_display, field_name=self.name),\n                )\n",
      "\n    def contribute_to_class(self, cls, name, private_only=False):\n        \"\"\"\n        Register the field with the model class it belongs to.\n\n        If private_only is True, create a separate instance of this field\n        for every subclass of cls, even if cls is not an abstract model.\n        \"\"\"\n        self.set_attributes_from_name(name)\n        self.model = cls\n        cls._meta.add_field(self, private=private_only)\n        if self.column:\n            # Don't override classmethods with the descriptor. This means that\n            # if you have a classmethod and a field with the same name, then\n            # such fields can't be deferred (we don't have a check for this).\n            if not getattr(cls, self.attname, None):\n                setattr(cls, self.attname, self.descriptor_class(self))\n        if self.choices is not None:\n            if not hasattr(cls, 'get_%s_display' % self.name):\n                setattr(\n                    cls,\n                    'get_%s_display' % self.name,\n                    partialmethod(cls._get_FIELD_display, field_name=self.name),\n                )\n",
      "\n    def contribute_to_class(self, cls, name, private_only=False):\n        \"\"\"\n        Register the field with the model class it belongs to.\n\n        If private_only is True, create a separate instance of this field\n        for every subclass of cls, even if cls is not an abstract model.\n        \"\"\"\n        self.set_attributes_from_name(name)\n        self.model = cls\n        cls._meta.add_field(self, private=private_only)\n        if self.column:\n            # Don't override classmethods with the descriptor. This means that\n            # if you have a classmethod and a field with the same name, then\n            # such fields can't be deferred (we don't have a check for this).\n            if not getattr(cls, self.attname, None):\n                setattr(cls, self.attname, self.descriptor_class(self))\n        if self.choices is not None:\n            if not hasattr(cls, 'get_%s_display' % self.name):\n                setattr(\n                    cls,\n                    'get_%s_display' % self.name,\n                    partialmethod(cls._get_FIELD_display, field_name=self.name),\n                )\n"
    ],
    "Location 2 (/root/hy/projects_3/django/django/db/models/base.py lines 946-950)": [
      "\n    def _get_FIELD_display(self, field):\n        value = getattr(self, field.attname)\n        # Dynamically resolve the field from the current model to handle inheritance\n        current_field = self._meta.get_field(field.name)\n        choices_dict = dict(make_hashable(current_field.flatchoices))\n        # force_str() to coerce lazy strings.\n        return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n",
      "\n    def _get_FIELD_display(self, field):\n        value = getattr(self, field.attname)\n        # Dynamically resolve the field from current model to get updated choices\n        current_field = self._meta.get_field(field.name)\n        choices_dict = dict(make_hashable(current_field.flatchoices))\n        # force_str() to coerce lazy strings.\n        return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n",
      "\n    def _get_FIELD_display(self, field):\n        value = getattr(self, field.attname)\n        # Dynamically resolve the field from the current model to get updated choices\n        current_field = self._meta.get_field(field.name)\n        choices_dict = dict(make_hashable(current_field.flatchoices))\n        # force_str() to coerce lazy strings.\n        return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n",
      "\n    def _get_FIELD_display(self, field):\n        value = getattr(self, field.attname)\n        # Dynamically get the field from the current model to handle inheritance correctly\n        current_field = self._meta.get_field(field.name)\n        choices_dict = dict(make_hashable(current_field.flatchoices))\n        # force_str() to coerce lazy strings.\n        return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n",
      "\ndef _get_FIELD_display(self, field):\n    value = getattr(self, field.attname)\n    # Dynamically resolve the field from the current model to handle inheritance\n    current_field = self._meta.get_field(field.name)\n    choices_dict = dict(make_hashable(current_field.flatchoices))\n    # force_str() to coerce lazy strings.\n    return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n",
      "\n    def _get_FIELD_display(self, field):\n        value = getattr(self, field.attname)\n        # Dynamically resolve the field to get current model's choices\n        current_field = self._meta.get_field(field.name)\n        choices_dict = dict(make_hashable(current_field.flatchoices))\n        # force_str() to coerce lazy strings.\n        return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n",
      "\n    def _get_FIELD_display(self, field):\n        value = getattr(self, field.attname)\n        # Dynamically resolve the field to get current model's field definition\n        current_field = self._meta.get_field(field.name)\n        choices_dict = dict(make_hashable(current_field.flatchoices))\n        # force_str() to coerce lazy strings.\n        return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n",
      "\n    def _get_FIELD_display(self, field):\n        value = getattr(self, field.attname)\n        # Dynamically resolve the field from current model to handle inheritance\n        current_field = self._meta.get_field(field.name)\n        choices_dict = dict(make_hashable(current_field.flatchoices))\n        # force_str() to coerce lazy strings.\n        return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n"
    ],
    "Location 3 (/root/hy/projects_3/django/django/db/models/fields/__init__.py lines 868-878)": [
      "\n    def _get_FIELD_display(self, field):\n        value = getattr(self, field.attname)\n        # Force evaluation of lazy object in case it's a LazyObject.\n        value = value._resolve() if hasattr(value, '_resolve') else value\n        # Dynamically get the field from the current model to handle inheritance correctly\n        current_field = self._meta.get_field(field.name)\n        choices_dict = dict(current_field.flatchoices)\n        # If it's a lazy object, evaluate it.\n        return choices_dict.get(make_hashable(value), value)\n",
      "\n    def _get_flatchoices(self):\n        \"\"\"Flattened version of choices tuple.\"\"\"\n        if self.choices is None:\n            return []\n        flat = []\n        for choice, value in self.choices:\n            if isinstance(value, (list, tuple)):\n                flat.extend(value)\n            else:\n                flat.append((choice, value))\n        return flat\n",
      "\n    def _get_flatchoices(self):\n        \"\"\"Flattened version of choices tuple.\"\"\"\n        if self.choices is None:\n            return []\n        flat = []\n        for choice, value in self.choices:\n            if isinstance(value, (list, tuple)):\n                flat.extend(value)\n            else:\n                flat.append((choice, value))\n        return flat\n",
      "\n    def _get_flatchoices(self):\n        \"\"\"Flattened version of choices tuple.\"\"\"\n        if self.choices is None:\n            return []\n        flat = []\n        for choice, value in self.choices:\n            if isinstance(value, (list, tuple)):\n                flat.extend(value)\n            else:\n                flat.append((choice, value))\n        return flat\n",
      "\n    def _get_flatchoices(self):\n        \"\"\"Flattened version of choices tuple.\"\"\"\n        if self.choices is None:\n            return []\n        flat = []\n        for choice, value in self.choices:\n            if isinstance(value, (list, tuple)):\n                flat.extend(value)\n            else:\n                flat.append((choice, value))\n        return flat\n",
      "\ndef _get_flatchoices(self):\n    \"\"\"Flattened version of choices tuple.\"\"\"\n    if self.choices is None:\n        return []\n    flat = []\n    for choice, value in self.choices:\n        if isinstance(value, (list, tuple)):\n            flat.extend(value)\n        else:\n            flat.append((choice, value))\n    return flat\n",
      "\n    def _get_flatchoices(self):\n        \"\"\"Flattened version of choices tuple.\"\"\"\n        if self.choices is None:\n            return []\n        flat = []\n        for choice, value in self.choices:\n            if isinstance(value, (list, tuple)):\n                flat.extend(value)\n            else:\n                flat.append((choice, value))\n        return flat\n",
      "\n    def _get_flatchoices(self):\n        \"\"\"Flattened version of choices tuple.\"\"\"\n        if self.choices is None:\n            return []\n        flat = []\n        for choice, value in self.choices:\n            if isinstance(value, (list, tuple)):\n                flat.extend(value)\n            else:\n                flat.append((choice, value))\n        return flat\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..e0c75e2780 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -943,7 +943,9 @@ class Model(metaclass=ModelBase):\n \n     delete.alters_data = True\n \n-    def _get_FIELD_display(self, field):\n+\n+    def _get_FIELD_display(self, field_name):\n+        field = self._meta.get_field(field_name)\n         value = getattr(self, field.attname)\n         choices_dict = dict(make_hashable(field.flatchoices))\n         # force_str() to coerce lazy strings.\ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 1a55d3d417..b311eaf7e3 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -763,12 +763,13 @@ class Field(RegisterLookupMixin):\n             # such fields can't be deferred (we don't have a check for this).\n             if not getattr(cls, self.attname, None):\n                 setattr(cls, self.attname, self.descriptor_class(self))\n+\n         if self.choices is not None:\n             if not hasattr(cls, 'get_%s_display' % self.name):\n                 setattr(\n                     cls,\n                     'get_%s_display' % self.name,\n-                    partialmethod(cls._get_FIELD_display, field=self),\n+                    partialmethod(cls._get_FIELD_display, field_name=self.name),\n                 )\n \n     def get_filter_kwargs_for_object(self, obj):\n@@ -865,6 +866,7 @@ class Field(RegisterLookupMixin):\n         \"\"\"\n         return str(self.value_from_object(obj))\n \n+\n     def _get_flatchoices(self):\n         \"\"\"Flattened version of choices tuple.\"\"\"\n         if self.choices is None:\n",
    "variant_0": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..7bfaa493c1 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -943,9 +943,12 @@ class Model(metaclass=ModelBase):\n \n     delete.alters_data = True\n \n+\n     def _get_FIELD_display(self, field):\n         value = getattr(self, field.attname)\n-        choices_dict = dict(make_hashable(field.flatchoices))\n+        # Dynamically resolve the field from the current model to get updated choices\n+        current_field = self._meta.get_field(field.name)\n+        choices_dict = dict(make_hashable(current_field.flatchoices))\n         # force_str() to coerce lazy strings.\n         return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n \ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 1a55d3d417..b311eaf7e3 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -763,12 +763,13 @@ class Field(RegisterLookupMixin):\n             # such fields can't be deferred (we don't have a check for this).\n             if not getattr(cls, self.attname, None):\n                 setattr(cls, self.attname, self.descriptor_class(self))\n+\n         if self.choices is not None:\n             if not hasattr(cls, 'get_%s_display' % self.name):\n                 setattr(\n                     cls,\n                     'get_%s_display' % self.name,\n-                    partialmethod(cls._get_FIELD_display, field=self),\n+                    partialmethod(cls._get_FIELD_display, field_name=self.name),\n                 )\n \n     def get_filter_kwargs_for_object(self, obj):\n@@ -865,6 +866,7 @@ class Field(RegisterLookupMixin):\n         \"\"\"\n         return str(self.value_from_object(obj))\n \n+\n     def _get_flatchoices(self):\n         \"\"\"Flattened version of choices tuple.\"\"\"\n         if self.choices is None:\n",
    "variant_1": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..5ec5f016fe 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -943,9 +943,12 @@ class Model(metaclass=ModelBase):\n \n     delete.alters_data = True\n \n+\n     def _get_FIELD_display(self, field):\n         value = getattr(self, field.attname)\n-        choices_dict = dict(make_hashable(field.flatchoices))\n+        # Dynamically resolve the field from the current model to handle inheritance\n+        current_field = self._meta.get_field(field.name)\n+        choices_dict = dict(make_hashable(current_field.flatchoices))\n         # force_str() to coerce lazy strings.\n         return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n \ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 1a55d3d417..2a3a614988 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -747,6 +747,23 @@ class Field(RegisterLookupMixin):\n         if self.verbose_name is None and self.name:\n             self.verbose_name = self.name.replace('_', ' ')\n \n+    def contribute_to_class(self, cls, name, private_only=False):\n+        \"\"\"\n+        Register the field with the model class it belongs to.\n+\n+        If private_only is True, create a separate instance of this field\n+        for every subclass of cls, even if cls is not an abstract model.\n+        \"\"\"\n+        self.set_attributes_from_name(name)\n+        self.model = cls\n+        cls._meta.add_field(self, private=private_only)\n+        if self.column:\n+            # Don't override classmethods with the descriptor. This means that\n+            # if you have a classmethod and a field with the same name, then\n+            # such fields can't be deferred (we don't have a check for this).\n+            if not getattr(cls, self.attname, None):\n+                setattr(cls, self.attname, self.descriptor_class(self))\n+\n     def contribute_to_class(self, cls, name, private_only=False):\n         \"\"\"\n         Register the field with the model class it belongs to.\n@@ -768,7 +785,7 @@ class Field(RegisterLookupMixin):\n                 setattr(\n                     cls,\n                     'get_%s_display' % self.name,\n-                    partialmethod(cls._get_FIELD_display, field=self),\n+                    partialmethod(cls._get_FIELD_display, field_name=self.name),\n                 )\n \n     def get_filter_kwargs_for_object(self, obj):\n@@ -865,17 +882,16 @@ class Field(RegisterLookupMixin):\n         \"\"\"\n         return str(self.value_from_object(obj))\n \n-    def _get_flatchoices(self):\n-        \"\"\"Flattened version of choices tuple.\"\"\"\n-        if self.choices is None:\n-            return []\n-        flat = []\n-        for choice, value in self.choices:\n-            if isinstance(value, (list, tuple)):\n-                flat.extend(value)\n-            else:\n-                flat.append((choice, value))\n-        return flat\n+\n+    def _get_FIELD_display(self, field):\n+        value = getattr(self, field.attname)\n+        # Force evaluation of lazy object in case it's a LazyObject.\n+        value = value._resolve() if hasattr(value, '_resolve') else value\n+        # Dynamically get the field from the current model to handle inheritance correctly\n+        current_field = self._meta.get_field(field.name)\n+        choices_dict = dict(current_field.flatchoices)\n+        # If it's a lazy object, evaluate it.\n+        return choices_dict.get(make_hashable(value), value)\n     flatchoices = property(_get_flatchoices)\n \n     def save_form_data(self, instance, data):\n",
    "variant_2": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..d5eb38524b 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -943,9 +943,12 @@ class Model(metaclass=ModelBase):\n \n     delete.alters_data = True\n \n+\n     def _get_FIELD_display(self, field):\n         value = getattr(self, field.attname)\n-        choices_dict = dict(make_hashable(field.flatchoices))\n+        # Dynamically resolve the field from current model to get updated choices\n+        current_field = self._meta.get_field(field.name)\n+        choices_dict = dict(make_hashable(current_field.flatchoices))\n         # force_str() to coerce lazy strings.\n         return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n \ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 1a55d3d417..682fc9a890 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -747,6 +747,23 @@ class Field(RegisterLookupMixin):\n         if self.verbose_name is None and self.name:\n             self.verbose_name = self.name.replace('_', ' ')\n \n+    def contribute_to_class(self, cls, name, private_only=False):\n+        \"\"\"\n+        Register the field with the model class it belongs to.\n+\n+        If private_only is True, create a separate instance of this field\n+        for every subclass of cls, even if cls is not an abstract model.\n+        \"\"\"\n+        self.set_attributes_from_name(name)\n+        self.model = cls\n+        cls._meta.add_field(self, private=private_only)\n+        if self.column:\n+            # Don't override classmethods with the descriptor. This means that\n+            # if you have a classmethod and a field with the same name, then\n+            # such fields can't be deferred (we don't have a check for this).\n+            if not getattr(cls, self.attname, None):\n+                setattr(cls, self.attname, self.descriptor_class(self))\n+\n     def contribute_to_class(self, cls, name, private_only=False):\n         \"\"\"\n         Register the field with the model class it belongs to.\n@@ -768,7 +785,7 @@ class Field(RegisterLookupMixin):\n                 setattr(\n                     cls,\n                     'get_%s_display' % self.name,\n-                    partialmethod(cls._get_FIELD_display, field=self),\n+                    partialmethod(cls._get_FIELD_display, field_name=self.name),\n                 )\n \n     def get_filter_kwargs_for_object(self, obj):\n@@ -865,6 +882,7 @@ class Field(RegisterLookupMixin):\n         \"\"\"\n         return str(self.value_from_object(obj))\n \n+\n     def _get_flatchoices(self):\n         \"\"\"Flattened version of choices tuple.\"\"\"\n         if self.choices is None:\n",
    "variant_3": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..7bfaa493c1 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -943,9 +943,12 @@ class Model(metaclass=ModelBase):\n \n     delete.alters_data = True\n \n+\n     def _get_FIELD_display(self, field):\n         value = getattr(self, field.attname)\n-        choices_dict = dict(make_hashable(field.flatchoices))\n+        # Dynamically resolve the field from the current model to get updated choices\n+        current_field = self._meta.get_field(field.name)\n+        choices_dict = dict(make_hashable(current_field.flatchoices))\n         # force_str() to coerce lazy strings.\n         return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n \ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 1a55d3d417..682fc9a890 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -747,6 +747,23 @@ class Field(RegisterLookupMixin):\n         if self.verbose_name is None and self.name:\n             self.verbose_name = self.name.replace('_', ' ')\n \n+    def contribute_to_class(self, cls, name, private_only=False):\n+        \"\"\"\n+        Register the field with the model class it belongs to.\n+\n+        If private_only is True, create a separate instance of this field\n+        for every subclass of cls, even if cls is not an abstract model.\n+        \"\"\"\n+        self.set_attributes_from_name(name)\n+        self.model = cls\n+        cls._meta.add_field(self, private=private_only)\n+        if self.column:\n+            # Don't override classmethods with the descriptor. This means that\n+            # if you have a classmethod and a field with the same name, then\n+            # such fields can't be deferred (we don't have a check for this).\n+            if not getattr(cls, self.attname, None):\n+                setattr(cls, self.attname, self.descriptor_class(self))\n+\n     def contribute_to_class(self, cls, name, private_only=False):\n         \"\"\"\n         Register the field with the model class it belongs to.\n@@ -768,7 +785,7 @@ class Field(RegisterLookupMixin):\n                 setattr(\n                     cls,\n                     'get_%s_display' % self.name,\n-                    partialmethod(cls._get_FIELD_display, field=self),\n+                    partialmethod(cls._get_FIELD_display, field_name=self.name),\n                 )\n \n     def get_filter_kwargs_for_object(self, obj):\n@@ -865,6 +882,7 @@ class Field(RegisterLookupMixin):\n         \"\"\"\n         return str(self.value_from_object(obj))\n \n+\n     def _get_flatchoices(self):\n         \"\"\"Flattened version of choices tuple.\"\"\"\n         if self.choices is None:\n",
    "variant_4": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..64cb7ed550 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -943,9 +943,12 @@ class Model(metaclass=ModelBase):\n \n     delete.alters_data = True\n \n+\n     def _get_FIELD_display(self, field):\n         value = getattr(self, field.attname)\n-        choices_dict = dict(make_hashable(field.flatchoices))\n+        # Dynamically get the field from the current model to handle inheritance correctly\n+        current_field = self._meta.get_field(field.name)\n+        choices_dict = dict(make_hashable(current_field.flatchoices))\n         # force_str() to coerce lazy strings.\n         return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n \ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 1a55d3d417..682fc9a890 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -747,6 +747,23 @@ class Field(RegisterLookupMixin):\n         if self.verbose_name is None and self.name:\n             self.verbose_name = self.name.replace('_', ' ')\n \n+    def contribute_to_class(self, cls, name, private_only=False):\n+        \"\"\"\n+        Register the field with the model class it belongs to.\n+\n+        If private_only is True, create a separate instance of this field\n+        for every subclass of cls, even if cls is not an abstract model.\n+        \"\"\"\n+        self.set_attributes_from_name(name)\n+        self.model = cls\n+        cls._meta.add_field(self, private=private_only)\n+        if self.column:\n+            # Don't override classmethods with the descriptor. This means that\n+            # if you have a classmethod and a field with the same name, then\n+            # such fields can't be deferred (we don't have a check for this).\n+            if not getattr(cls, self.attname, None):\n+                setattr(cls, self.attname, self.descriptor_class(self))\n+\n     def contribute_to_class(self, cls, name, private_only=False):\n         \"\"\"\n         Register the field with the model class it belongs to.\n@@ -768,7 +785,7 @@ class Field(RegisterLookupMixin):\n                 setattr(\n                     cls,\n                     'get_%s_display' % self.name,\n-                    partialmethod(cls._get_FIELD_display, field=self),\n+                    partialmethod(cls._get_FIELD_display, field_name=self.name),\n                 )\n \n     def get_filter_kwargs_for_object(self, obj):\n@@ -865,6 +882,7 @@ class Field(RegisterLookupMixin):\n         \"\"\"\n         return str(self.value_from_object(obj))\n \n+\n     def _get_flatchoices(self):\n         \"\"\"Flattened version of choices tuple.\"\"\"\n         if self.choices is None:\n",
    "variant_5": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..5d9bef051e 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -943,11 +943,14 @@ class Model(metaclass=ModelBase):\n \n     delete.alters_data = True\n \n-    def _get_FIELD_display(self, field):\n-        value = getattr(self, field.attname)\n-        choices_dict = dict(make_hashable(field.flatchoices))\n-        # force_str() to coerce lazy strings.\n-        return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n+\n+def _get_FIELD_display(self, field):\n+    value = getattr(self, field.attname)\n+    # Dynamically resolve the field from the current model to handle inheritance\n+    current_field = self._meta.get_field(field.name)\n+    choices_dict = dict(make_hashable(current_field.flatchoices))\n+    # force_str() to coerce lazy strings.\n+    return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n \n     def _get_next_or_previous_by_FIELD(self, field, is_next, **kwargs):\n         if not self.pk:\ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 1a55d3d417..47da366155 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -763,13 +763,14 @@ class Field(RegisterLookupMixin):\n             # such fields can't be deferred (we don't have a check for this).\n             if not getattr(cls, self.attname, None):\n                 setattr(cls, self.attname, self.descriptor_class(self))\n-        if self.choices is not None:\n-            if not hasattr(cls, 'get_%s_display' % self.name):\n-                setattr(\n-                    cls,\n-                    'get_%s_display' % self.name,\n-                    partialmethod(cls._get_FIELD_display, field=self),\n-                )\n+\n+    def _get_FIELD_display(self, field):\n+        value = getattr(self, field.attname)\n+        # Get the field from the current model to ensure we have the latest choices\n+        current_field = self._meta.get_field(field.name)\n+        choices_dict = dict(current_field.flatchoices)\n+        # force_str() to coerce lazy strings.\n+        return choices_dict.get(make_hashable(value), value)\n \n     def get_filter_kwargs_for_object(self, obj):\n         \"\"\"\n@@ -865,6 +866,7 @@ class Field(RegisterLookupMixin):\n         \"\"\"\n         return str(self.value_from_object(obj))\n \n+\n     def _get_flatchoices(self):\n         \"\"\"Flattened version of choices tuple.\"\"\"\n         if self.choices is None:\n",
    "variant_6": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..aac7b9ce31 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -943,9 +943,12 @@ class Model(metaclass=ModelBase):\n \n     delete.alters_data = True\n \n+\n     def _get_FIELD_display(self, field):\n         value = getattr(self, field.attname)\n-        choices_dict = dict(make_hashable(field.flatchoices))\n+        # Dynamically resolve the field to get current model's choices\n+        current_field = self._meta.get_field(field.name)\n+        choices_dict = dict(make_hashable(current_field.flatchoices))\n         # force_str() to coerce lazy strings.\n         return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n \ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 1a55d3d417..aa7cf1af2f 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -747,6 +747,23 @@ class Field(RegisterLookupMixin):\n         if self.verbose_name is None and self.name:\n             self.verbose_name = self.name.replace('_', ' ')\n \n+    def contribute_to_class(self, cls, name, private_only=False):\n+        \"\"\"\n+        Register the field with the model class it belongs to.\n+\n+        If private_only is True, create a separate instance of this field\n+        for every subclass of cls, even if cls is not an abstract model.\n+        \"\"\"\n+        self.set_attributes_from_name(name)\n+        self.model = cls\n+        cls._meta.add_field(self, private=private_only)\n+        if self.column:\n+            # Don't override classmethods with the descriptor. This means that\n+            # if you have a classmethod and a field with the same name, then\n+            # such fields can't be deferred (we don't have a check for this).\n+            if not getattr(cls, self.attname, None):\n+                setattr(cls, self.attname, self.descriptor_class(self))\n+\n     def contribute_to_class(self, cls, name, private_only=False):\n         \"\"\"\n         Register the field with the model class it belongs to.\n@@ -768,7 +785,7 @@ class Field(RegisterLookupMixin):\n                 setattr(\n                     cls,\n                     'get_%s_display' % self.name,\n-                    partialmethod(cls._get_FIELD_display, field=self),\n+                    partialmethod(cls._get_FIELD_display, field_name=self.name),\n                 )\n \n     def get_filter_kwargs_for_object(self, obj):\n@@ -865,17 +882,18 @@ class Field(RegisterLookupMixin):\n         \"\"\"\n         return str(self.value_from_object(obj))\n \n-    def _get_flatchoices(self):\n-        \"\"\"Flattened version of choices tuple.\"\"\"\n-        if self.choices is None:\n-            return []\n-        flat = []\n-        for choice, value in self.choices:\n-            if isinstance(value, (list, tuple)):\n-                flat.extend(value)\n-            else:\n-                flat.append((choice, value))\n-        return flat\n+\n+def _get_flatchoices(self):\n+    \"\"\"Flattened version of choices tuple.\"\"\"\n+    if self.choices is None:\n+        return []\n+    flat = []\n+    for choice, value in self.choices:\n+        if isinstance(value, (list, tuple)):\n+            flat.extend(value)\n+        else:\n+            flat.append((choice, value))\n+    return flat\n     flatchoices = property(_get_flatchoices)\n \n     def save_form_data(self, instance, data):\n",
    "variant_7": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..022ad64119 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -943,9 +943,12 @@ class Model(metaclass=ModelBase):\n \n     delete.alters_data = True\n \n+\n     def _get_FIELD_display(self, field):\n         value = getattr(self, field.attname)\n-        choices_dict = dict(make_hashable(field.flatchoices))\n+        # Dynamically resolve the field to get current model's field definition\n+        current_field = self._meta.get_field(field.name)\n+        choices_dict = dict(make_hashable(current_field.flatchoices))\n         # force_str() to coerce lazy strings.\n         return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n \ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 1a55d3d417..682fc9a890 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -747,6 +747,23 @@ class Field(RegisterLookupMixin):\n         if self.verbose_name is None and self.name:\n             self.verbose_name = self.name.replace('_', ' ')\n \n+    def contribute_to_class(self, cls, name, private_only=False):\n+        \"\"\"\n+        Register the field with the model class it belongs to.\n+\n+        If private_only is True, create a separate instance of this field\n+        for every subclass of cls, even if cls is not an abstract model.\n+        \"\"\"\n+        self.set_attributes_from_name(name)\n+        self.model = cls\n+        cls._meta.add_field(self, private=private_only)\n+        if self.column:\n+            # Don't override classmethods with the descriptor. This means that\n+            # if you have a classmethod and a field with the same name, then\n+            # such fields can't be deferred (we don't have a check for this).\n+            if not getattr(cls, self.attname, None):\n+                setattr(cls, self.attname, self.descriptor_class(self))\n+\n     def contribute_to_class(self, cls, name, private_only=False):\n         \"\"\"\n         Register the field with the model class it belongs to.\n@@ -768,7 +785,7 @@ class Field(RegisterLookupMixin):\n                 setattr(\n                     cls,\n                     'get_%s_display' % self.name,\n-                    partialmethod(cls._get_FIELD_display, field=self),\n+                    partialmethod(cls._get_FIELD_display, field_name=self.name),\n                 )\n \n     def get_filter_kwargs_for_object(self, obj):\n@@ -865,6 +882,7 @@ class Field(RegisterLookupMixin):\n         \"\"\"\n         return str(self.value_from_object(obj))\n \n+\n     def _get_flatchoices(self):\n         \"\"\"Flattened version of choices tuple.\"\"\"\n         if self.choices is None:\n",
    "variant_8": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..580dbb0a1d 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -943,9 +943,12 @@ class Model(metaclass=ModelBase):\n \n     delete.alters_data = True\n \n+\n     def _get_FIELD_display(self, field):\n         value = getattr(self, field.attname)\n-        choices_dict = dict(make_hashable(field.flatchoices))\n+        # Dynamically resolve the field from current model to handle inheritance\n+        current_field = self._meta.get_field(field.name)\n+        choices_dict = dict(make_hashable(current_field.flatchoices))\n         # force_str() to coerce lazy strings.\n         return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n \ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 1a55d3d417..682fc9a890 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -747,6 +747,23 @@ class Field(RegisterLookupMixin):\n         if self.verbose_name is None and self.name:\n             self.verbose_name = self.name.replace('_', ' ')\n \n+    def contribute_to_class(self, cls, name, private_only=False):\n+        \"\"\"\n+        Register the field with the model class it belongs to.\n+\n+        If private_only is True, create a separate instance of this field\n+        for every subclass of cls, even if cls is not an abstract model.\n+        \"\"\"\n+        self.set_attributes_from_name(name)\n+        self.model = cls\n+        cls._meta.add_field(self, private=private_only)\n+        if self.column:\n+            # Don't override classmethods with the descriptor. This means that\n+            # if you have a classmethod and a field with the same name, then\n+            # such fields can't be deferred (we don't have a check for this).\n+            if not getattr(cls, self.attname, None):\n+                setattr(cls, self.attname, self.descriptor_class(self))\n+\n     def contribute_to_class(self, cls, name, private_only=False):\n         \"\"\"\n         Register the field with the model class it belongs to.\n@@ -768,7 +785,7 @@ class Field(RegisterLookupMixin):\n                 setattr(\n                     cls,\n                     'get_%s_display' % self.name,\n-                    partialmethod(cls._get_FIELD_display, field=self),\n+                    partialmethod(cls._get_FIELD_display, field_name=self.name),\n                 )\n \n     def get_filter_kwargs_for_object(self, obj):\n@@ -865,6 +882,7 @@ class Field(RegisterLookupMixin):\n         \"\"\"\n         return str(self.value_from_object(obj))\n \n+\n     def _get_flatchoices(self):\n         \"\"\"Flattened version of choices tuple.\"\"\"\n         if self.choices is None:\n"
  }
}