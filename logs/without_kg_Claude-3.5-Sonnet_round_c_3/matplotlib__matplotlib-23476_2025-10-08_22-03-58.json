{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/matplotlib/lib/matplotlib/figure.py lines 3052-3058)": "\n        if restore_to_pylab:\n            # lazy import to avoid circularity\n            import matplotlib.pyplot as plt\n            import matplotlib._pylab_helpers as pylab_helpers\n            \n            # Preserve original DPI before creating new figure manager\n            # to prevent DPI doubling during unpickling\n            original_dpi = getattr(self, '_original_dpi', self.dpi)\n            self._original_dpi = original_dpi\n            \n            allnums = plt.get_fignums()\n            num = max(allnums) + 1 if allnums else 1\n            mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n            \n            # Restore original DPI after canvas creation if it was doubled\n            if hasattr(self, '_original_dpi') and self.dpi != self._original_dpi:\n                self.dpi = self._original_dpi\n            \n            pylab_helpers.Gcf._set_new_active_manager(mgr)\n            plt.draw_if_interactive()\n",
    "Location 2 (/root/hy/projects_3/matplotlib/lib/matplotlib/backend_bases.py lines 1655-1656)": "\n        # We don't want to scale up the figure DPI more than once.\n        figure._original_dpi = getattr(figure, '_original_dpi', figure.dpi)\n",
    "Location 3 (/root/hy/projects_3/matplotlib/lib/matplotlib/backend_bases.py lines 1638-1680)": "\ndef __init__(self, figure=None):\n    from matplotlib.figure import Figure\n    self._fix_ipython_backend2gui()\n    self._is_idle_drawing = True\n    self._is_saving = False\n    if figure is None:\n        figure = Figure()\n    \n    # Check if this is an unpickled figure that may have doubled DPI\n    if hasattr(figure, '_original_dpi') and figure.dpi != figure._original_dpi:\n        # Restore original DPI to prevent accumulating DPI scaling\n        figure.dpi = figure._original_dpi\n    \n    figure.set_canvas(self)\n    self.figure = figure\n    self.manager = None\n    self.widgetlock = widgets.LockDraw()\n    self._button = None  # the button pressed\n    self._key = None  # the key pressed\n    self._lastx, self._lasty = None, None\n    self.mouse_grabber = None  # the Axes currently grabbing mouse\n    self.toolbar = None  # NavigationToolbar2 will set me\n    self._is_idle_drawing = False\n    # We don't want to scale up the figure DPI more than once.\n    # Only set _original_dpi if it doesn't already exist (preserve unpickled state)\n    if not hasattr(figure, '_original_dpi'):\n        figure._original_dpi = figure.dpi\n    self._device_pixel_ratio = 1\n    super().__init__()  # Typically the GUI widget init (if any).\n\ncallbacks = property(lambda self: self.figure._canvas_callbacks)\nbutton_pick_id = property(lambda self: self.figure._button_pick_id)\nscroll_pick_id = property(lambda self: self.figure._scroll_pick_id)\n\n@classmethod\n@functools.lru_cache()\ndef _fix_ipython_backend2gui(cls):\n    # Fix hard-coded module -> toolkit mapping in IPython (used for\n    # `ipython --auto`).  This cannot be done at import time due to\n    # ordering issues, so we do it when creating a canvas, and should only\n    # be done once per class (hence the `lru_cache(1)`).\n    if sys.modules.get(\"IPython\") is None:\n        return\n    import IPython\n    ip = IPython.get_ipython()\n    if not ip:\n        return\n    from IPython.core import pylabtools as pt\n    if (not hasattr(pt, \"backend2gui\")\n            or not hasattr(ip, \"enable_matplotlib\")):\n        # In case we ever move the patch to IPython and remove these APIs,\n",
    "Location 4 (/root/hy/projects_3/matplotlib/lib/matplotlib/backends/backend_macosx.py lines 38-40)": "\n    def __init__(self, figure):\n        # Safety check for M1 Mac DPI doubling issue during unpickling\n        if hasattr(figure, '_original_dpi') and figure.dpi != figure._original_dpi:\n            # Reset to original DPI to prevent overflow\n            figure.dpi = figure._original_dpi\n        \n        super().__init__(figure=figure)\n        self._draw_pending = False\n",
    "Location 5 (/root/hy/projects_3/matplotlib/lib/matplotlib/backend_bases.py lines 3510-3512)": "\n    @classmethod\n    def new_figure_manager_given_figure(cls, num, figure):\n        \"\"\"Create a new figure manager instance for the given figure.\"\"\"\n        # Preserve DPI state during canvas creation to prevent doubling during unpickling\n        original_dpi = getattr(figure, '_original_dpi', None)\n        current_dpi = figure.dpi\n        \n        manager = cls.FigureCanvas.new_manager(figure, num)\n        \n        # Restore DPI state if it was modified during canvas creation\n        if original_dpi is not None and figure.dpi != current_dpi:\n            figure.dpi = current_dpi\n            figure._original_dpi = original_dpi\n            \n        return manager\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/matplotlib/lib/matplotlib/figure.py lines 3052-3058)": [
      "\n        if restore_to_pylab:\n            # lazy import to avoid circularity\n            import matplotlib.pyplot as plt\n            import matplotlib._pylab_helpers as pylab_helpers\n            \n            # Store original DPI before creating new figure manager to prevent DPI doubling\n            original_dpi = getattr(self, '_original_dpi', self.dpi)\n            \n            allnums = plt.get_fignums()\n            num = max(allnums) + 1 if allnums else 1\n            mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n            \n            # Restore original DPI after canvas creation\n            if hasattr(self, '_original_dpi'):\n                self.dpi = original_dpi\n            \n            pylab_helpers.Gcf._set_new_active_manager(mgr)\n            plt.draw_if_interactive()\n",
      "\n        if restore_to_pylab:\n            # lazy import to avoid circularity\n            import matplotlib.pyplot as plt\n            import matplotlib._pylab_helpers as pylab_helpers\n            \n            # Preserve original DPI before creating new figure manager\n            original_dpi = getattr(self, '_original_dpi', self.dpi)\n            \n            allnums = plt.get_fignums()\n            num = max(allnums) + 1 if allnums else 1\n            mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n            \n            # Restore original DPI after canvas creation to prevent doubling\n            if hasattr(self, '_original_dpi'):\n                self.dpi = original_dpi\n            \n            pylab_helpers.Gcf._set_new_active_manager(mgr)\n            plt.draw_if_interactive()\n",
      "\n        if restore_to_pylab:\n            # lazy import to avoid circularity\n            import matplotlib.pyplot as plt\n            import matplotlib._pylab_helpers as pylab_helpers\n            # Preserve original DPI before creating new manager to prevent DPI doubling\n            original_dpi = getattr(self, '_original_dpi', self.dpi)\n            allnums = plt.get_fignums()\n            num = max(allnums) + 1 if allnums else 1\n            mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n            # Restore original DPI after canvas creation\n            if hasattr(self, '_original_dpi'):\n                self.dpi = original_dpi\n            pylab_helpers.Gcf._set_new_active_manager(mgr)\n            plt.draw_if_interactive()\n",
      "\n        if restore_to_pylab:\n            # lazy import to avoid circularity\n            import matplotlib.pyplot as plt\n            import matplotlib._pylab_helpers as pylab_helpers\n            \n            # Store original DPI before creating new figure manager to prevent DPI doubling\n            original_dpi = getattr(self, '_original_dpi', self.dpi)\n            \n            allnums = plt.get_fignums()\n            num = max(allnums) + 1 if allnums else 1\n            mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n            \n            # Restore original DPI after canvas creation\n            if hasattr(self, '_original_dpi'):\n                self.dpi = original_dpi\n            \n            pylab_helpers.Gcf._set_new_active_manager(mgr)\n            plt.draw_if_interactive()\n",
      "\n        if restore_to_pylab:\n            # lazy import to avoid circularity\n            import matplotlib.pyplot as plt\n            import matplotlib._pylab_helpers as pylab_helpers\n            \n            # Store original DPI before creating new figure manager to prevent\n            # DPI doubling during unpickling on M1 Mac\n            original_dpi = getattr(self, '_original_dpi', self.dpi)\n            self._original_dpi = original_dpi\n            \n            allnums = plt.get_fignums()\n            num = max(allnums) + 1 if allnums else 1\n            mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n            \n            # Restore original DPI if it was doubled during canvas creation\n            if hasattr(self, '_original_dpi') and self.dpi != self._original_dpi:\n                self.dpi = self._original_dpi\n            \n            pylab_helpers.Gcf._set_new_active_manager(mgr)\n            plt.draw_if_interactive()\n",
      "\n        if restore_to_pylab:\n            # lazy import to avoid circularity\n            import matplotlib.pyplot as plt\n            import matplotlib._pylab_helpers as pylab_helpers\n            \n            # Preserve original DPI before creating new figure manager\n            original_dpi = getattr(self, '_original_dpi', self.dpi)\n            \n            allnums = plt.get_fignums()\n            num = max(allnums) + 1 if allnums else 1\n            mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n            \n            # Restore original DPI if it was doubled during canvas creation\n            if hasattr(self, '_original_dpi') and self.dpi != original_dpi:\n                self.dpi = original_dpi\n            \n            pylab_helpers.Gcf._set_new_active_manager(mgr)\n            plt.draw_if_interactive()\n",
      "\n        if restore_to_pylab:\n            # lazy import to avoid circularity\n            import matplotlib.pyplot as plt\n            import matplotlib._pylab_helpers as pylab_helpers\n            \n            # Preserve original DPI before creating figure manager to prevent doubling\n            original_dpi = getattr(self, '_original_dpi', self.dpi)\n            self._original_dpi = original_dpi\n            \n            allnums = plt.get_fignums()\n            num = max(allnums) + 1 if allnums else 1\n            mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n            \n            # Restore original DPI after canvas creation\n            if hasattr(self, '_original_dpi') and self.dpi != self._original_dpi:\n                self.dpi = self._original_dpi\n                \n            pylab_helpers.Gcf._set_new_active_manager(mgr)\n            plt.draw_if_interactive()\n",
      "\n        if restore_to_pylab:\n            # lazy import to avoid circularity\n            import matplotlib.pyplot as plt\n            import matplotlib._pylab_helpers as pylab_helpers\n            \n            # Store original DPI before creating new manager to prevent doubling\n            original_dpi = getattr(self, '_original_dpi', self.dpi)\n            self._original_dpi = original_dpi\n            \n            allnums = plt.get_fignums()\n            num = max(allnums) + 1 if allnums else 1\n            mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n            \n            # Restore original DPI after manager creation\n            if hasattr(self, '_original_dpi') and self.dpi != self._original_dpi:\n                self.dpi = self._original_dpi\n            \n            pylab_helpers.Gcf._set_new_active_manager(mgr)\n            plt.draw_if_interactive()\n"
    ],
    "Location 2 (/root/hy/projects_3/matplotlib/lib/matplotlib/backend_bases.py lines 1655-1656)": [
      "\n        # We don't want to scale up the figure DPI more than once.\n        figure._original_dpi = getattr(figure, '_original_dpi', figure.dpi)\n",
      "\n        # We don't want to scale up the figure DPI more than once.\n        figure._original_dpi = getattr(figure, '_original_dpi', figure.dpi)\n",
      "\n        # We don't want to scale up the figure DPI more than once.\n        figure._original_dpi = getattr(figure, '_original_dpi', figure.dpi)\n",
      "\n        # We don't want to scale up the figure DPI more than once.\n        figure._original_dpi = getattr(figure, '_original_dpi', figure.dpi)\n",
      "\n        # We don't want to scale up the figure DPI more than once.\n        figure._original_dpi = getattr(figure, '_original_dpi', figure.dpi)\n",
      "\n        # We don't want to scale up the figure DPI more than once.\n        figure._original_dpi = getattr(figure, '_original_dpi', figure.dpi)\n",
      "\n        # We don't want to scale up the figure DPI more than once.\n        figure._original_dpi = getattr(figure, '_original_dpi', figure.dpi)\n",
      "\n        # We don't want to scale up the figure DPI more than once.\n        figure._original_dpi = getattr(figure, '_original_dpi', figure.dpi)\n"
    ],
    "Location 3 (/root/hy/projects_3/matplotlib/lib/matplotlib/backend_bases.py lines 1638-1680)": [
      "\n    def __init__(self, figure=None):\n        from matplotlib.figure import Figure\n        self._fix_ipython_backend2gui()\n        self._is_idle_drawing = True\n        self._is_saving = False\n        if figure is None:\n            figure = Figure()\n        \n        # Check if this is an unpickled figure with doubled DPI\n        if hasattr(figure, '_original_dpi') and figure.dpi != figure._original_dpi:\n            # Restore original DPI to prevent accumulation\n            figure.dpi = figure._original_dpi\n        \n        figure.set_canvas(self)\n        self.figure = figure\n        self.manager = None\n        self.widgetlock = widgets.LockDraw()\n        self._button = None  # the button pressed\n        self._key = None  # the key pressed\n        self._lastx, self._lasty = None, None\n        self.mouse_grabber = None  # the Axes currently grabbing mouse\n        self.toolbar = None  # NavigationToolbar2 will set me\n        self._is_idle_drawing = False\n        # We don't want to scale up the figure DPI more than once.\n        # Only set _original_dpi if it doesn't already exist (preserve unpickled state)\n        if not hasattr(figure, '_original_dpi'):\n            figure._original_dpi = figure.dpi\n        self._device_pixel_ratio = 1\n        super().__init__()  # Typically the GUI widget init (if any).\n\n    callbacks = property(lambda self: self.figure._canvas_callbacks)\n    button_pick_id = property(lambda self: self.figure._button_pick_id)\n    scroll_pick_id = property(lambda self: self.figure._scroll_pick_id)\n\n    @classmethod\n    @functools.lru_cache()\n    def _fix_ipython_backend2gui(cls):\n        # Fix hard-coded module -> toolkit mapping in IPython (used for\n        # `ipython --auto`).  This cannot be done at import time due to\n        # ordering issues, so we do it when creating a canvas, and should only\n        # be done once per class (hence the `lru_cache(1)`).\n        if sys.modules.get(\"IPython\") is None:\n            return\n        import IPython\n        ip = IPython.get_ipython()\n        if not ip:\n            return\n        from IPython.core import pylabtools as pt\n        if (not hasattr(pt, \"backend2gui\")\n                or not hasattr(ip, \"enable_matplotlib\")):\n",
      "\n    def __init__(self, figure=None):\n        from matplotlib.figure import Figure\n        self._fix_ipython_backend2gui()\n        self._is_idle_drawing = True\n        self._is_saving = False\n        if figure is None:\n            figure = Figure()\n        \n        # Check if this is an unpickled figure with DPI doubling issue\n        if hasattr(figure, '_original_dpi') and figure.dpi != figure._original_dpi:\n            # Restore original DPI to prevent doubling\n            figure.dpi = figure._original_dpi\n        \n        figure.set_canvas(self)\n        self.figure = figure\n        self.manager = None\n        self.widgetlock = widgets.LockDraw()\n        self._button = None  # the button pressed\n        self._key = None  # the key pressed\n        self._lastx, self._lasty = None, None\n        self.mouse_grabber = None  # the Axes currently grabbing mouse\n        self.toolbar = None  # NavigationToolbar2 will set me\n        self._is_idle_drawing = False\n        # We don't want to scale up the figure DPI more than once.\n        # Only set _original_dpi if it doesn't already exist (preserve unpickled state)\n        if not hasattr(figure, '_original_dpi'):\n            figure._original_dpi = figure.dpi\n        self._device_pixel_ratio = 1\n        super().__init__()  # Typically the GUI widget init (if any).\n\n    callbacks = property(lambda self: self.figure._canvas_callbacks)\n    button_pick_id = property(lambda self: self.figure._button_pick_id)\n    scroll_pick_id = property(lambda self: self.figure._scroll_pick_id)\n\n    @classmethod\n    @functools.lru_cache()\n    def _fix_ipython_backend2gui(cls):\n        # Fix hard-coded module -> toolkit mapping in IPython (used for\n        # `ipython --auto`).  This cannot be done at import time due to\n        # ordering issues, so we do it when creating a canvas, and should only\n        # be done once per class (hence the `lru_cache(1)`).\n        if sys.modules.get(\"IPython\") is None:\n            return\n        import IPython\n        ip = IPython.get_ipython()\n        if not ip:\n            return\n        from IPython.core import pylabtools as pt\n        if (not hasattr(pt, \"backend2gui\")\n                or not hasattr(ip, \"enable_matplotlib\")):\n",
      "\n    def __init__(self, figure=None):\n        from matplotlib.figure import Figure\n        self._fix_ipython_backend2gui()\n        self._is_idle_drawing = True\n        self._is_saving = False\n        if figure is None:\n            figure = Figure()\n        \n        # Check if this is an unpickled figure with DPI doubling issue\n        if hasattr(figure, '_original_dpi') and figure.dpi != figure._original_dpi:\n            # Reset to original DPI to prevent doubling during canvas creation\n            figure.dpi = figure._original_dpi\n        \n        figure.set_canvas(self)\n        self.figure = figure\n        self.manager = None\n        self.widgetlock = widgets.LockDraw()\n        self._button = None  # the button pressed\n        self._key = None  # the key pressed\n        self._lastx, self._lasty = None, None\n        self.mouse_grabber = None  # the Axes currently grabbing mouse\n        self.toolbar = None  # NavigationToolbar2 will set me\n        self._is_idle_drawing = False\n        # We don't want to scale up the figure DPI more than once.\n        figure._original_dpi = getattr(figure, '_original_dpi', figure.dpi)\n        self._device_pixel_ratio = 1\n        super().__init__()  # Typically the GUI widget init (if any).\n\n    callbacks = property(lambda self: self.figure._canvas_callbacks)\n    button_pick_id = property(lambda self: self.figure._button_pick_id)\n    scroll_pick_id = property(lambda self: self.figure._scroll_pick_id)\n\n    @classmethod\n    @functools.lru_cache()\n    def _fix_ipython_backend2gui(cls):\n        # Fix hard-coded module -> toolkit mapping in IPython (used for\n        # `ipython --auto`).  This cannot be done at import time due to\n        # ordering issues, so we do it when creating a canvas, and should only\n        # be done once per class (hence the `lru_cache(1)`).\n        if sys.modules.get(\"IPython\") is None:\n            return\n        import IPython\n        ip = IPython.get_ipython()\n        if not ip:\n            return\n        from IPython.core import pylabtools as pt\n        if (not hasattr(pt, \"backend2gui\")\n                or not hasattr(ip, \"enable_matplotlib\")):\n",
      "\n    def __init__(self, figure=None):\n        from matplotlib.figure import Figure\n        self._fix_ipython_backend2gui()\n        self._is_idle_drawing = True\n        self._is_saving = False\n        if figure is None:\n            figure = Figure()\n        \n        # Check if this is an unpickled figure that may have doubled DPI\n        if hasattr(figure, '_original_dpi') and figure.dpi != figure._original_dpi:\n            # Reset DPI to original value to prevent accumulation\n            figure.dpi = figure._original_dpi\n        \n        figure.set_canvas(self)\n        self.figure = figure\n        self.manager = None\n        self.widgetlock = widgets.LockDraw()\n        self._button = None  # the button pressed\n        self._key = None  # the key pressed\n        self._lastx, self._lasty = None, None\n        self.mouse_grabber = None  # the Axes currently grabbing mouse\n        self.toolbar = None  # NavigationToolbar2 will set me\n        self._is_idle_drawing = False\n        # We don't want to scale up the figure DPI more than once.\n        # Only set _original_dpi if it doesn't already exist (preserve unpickled state)\n        if not hasattr(figure, '_original_dpi'):\n            figure._original_dpi = figure.dpi\n        self._device_pixel_ratio = 1\n        super().__init__()  # Typically the GUI widget init (if any).\n\n    callbacks = property(lambda self: self.figure._canvas_callbacks)\n    button_pick_id = property(lambda self: self.figure._button_pick_id)\n    scroll_pick_id = property(lambda self: self.figure._scroll_pick_id)\n\n    @classmethod\n    @functools.lru_cache()\n    def _fix_ipython_backend2gui(cls):\n        # Fix hard-coded module -> toolkit mapping in IPython (used for\n        # `ipython --auto`).  This cannot be done at import time due to\n        # ordering issues, so we do it when creating a canvas, and should only\n        # be done once per class (hence the `lru_cache(1)`).\n        if sys.modules.get(\"IPython\") is None:\n            return\n        import IPython\n        ip = IPython.get_ipython()\n        if not ip:\n            return\n        from IPython.core import pylabtools as pt\n        if (not hasattr(pt, \"backend2gui\")\n                or not hasattr(ip, \"enable_matplotlib\")):\n",
      "\n    def __init__(self, figure=None):\n        from matplotlib.figure import Figure\n        self._fix_ipython_backend2gui()\n        self._is_idle_drawing = True\n        self._is_saving = False\n        if figure is None:\n            figure = Figure()\n        \n        # Check if this is an unpickled figure that may have doubled DPI\n        if hasattr(figure, '_original_dpi') and figure.dpi != figure._original_dpi:\n            # Restore original DPI to prevent doubling during canvas creation\n            figure.dpi = figure._original_dpi\n        \n        figure.set_canvas(self)\n        self.figure = figure\n        self.manager = None\n        self.widgetlock = widgets.LockDraw()\n        self._button = None  # the button pressed\n        self._key = None  # the key pressed\n        self._lastx, self._lasty = None, None\n        self.mouse_grabber = None  # the Axes currently grabbing mouse\n        self.toolbar = None  # NavigationToolbar2 will set me\n        self._is_idle_drawing = False\n        # We don't want to scale up the figure DPI more than once.\n        # Only set _original_dpi if it doesn't already exist (e.g., from unpickling)\n        if not hasattr(figure, '_original_dpi'):\n            figure._original_dpi = figure.dpi\n        self._device_pixel_ratio = 1\n        super().__init__()  # Typically the GUI widget init (if any).\n\n    callbacks = property(lambda self: self.figure._canvas_callbacks)\n    button_pick_id = property(lambda self: self.figure._button_pick_id)\n    scroll_pick_id = property(lambda self: self.figure._scroll_pick_id)\n\n    @classmethod\n    @functools.lru_cache()\n    def _fix_ipython_backend2gui(cls):\n        # Fix hard-coded module -> toolkit mapping in IPython (used for\n        # `ipython --auto`).  This cannot be done at import time due to\n        # ordering issues, so we do it when creating a canvas, and should only\n        # be done once per class (hence the `lru_cache(1)`).\n        if sys.modules.get(\"IPython\") is None:\n            return\n        import IPython\n        ip = IPython.get_ipython()\n        if not ip:\n            return\n        from IPython.core import pylabtools as pt\n        if (not hasattr(pt, \"backend2gui\")\n                or not hasattr(ip, \"enable_matplotlib\")):\n",
      "\n    def __init__(self, figure=None):\n        from matplotlib.figure import Figure\n        self._fix_ipython_backend2gui()\n        self._is_idle_drawing = True\n        self._is_saving = False\n        if figure is None:\n            figure = Figure()\n        \n        # Check if this is an unpickled figure with DPI doubling issue\n        if hasattr(figure, '_original_dpi') and figure.dpi != figure._original_dpi:\n            # Reset DPI to original value to prevent doubling\n            figure.dpi = figure._original_dpi\n        \n        figure.set_canvas(self)\n        self.figure = figure\n        self.manager = None\n        self.widgetlock = widgets.LockDraw()\n        self._button = None  # the button pressed\n        self._key = None  # the key pressed\n        self._lastx, self._lasty = None, None\n        self.mouse_grabber = None  # the Axes currently grabbing mouse\n        self.toolbar = None  # NavigationToolbar2 will set me\n        self._is_idle_drawing = False\n        # We don't want to scale up the figure DPI more than once.\n        # Only set _original_dpi if it doesn't already exist (e.g., from unpickling)\n        if not hasattr(figure, '_original_dpi'):\n            figure._original_dpi = figure.dpi\n        self._device_pixel_ratio = 1\n        super().__init__()  # Typically the GUI widget init (if any).\n\n    callbacks = property(lambda self: self.figure._canvas_callbacks)\n    button_pick_id = property(lambda self: self.figure._button_pick_id)\n    scroll_pick_id = property(lambda self: self.figure._scroll_pick_id)\n\n    @classmethod\n    @functools.lru_cache()\n    def _fix_ipython_backend2gui(cls):\n        # Fix hard-coded module -> toolkit mapping in IPython (used for\n        # `ipython --auto`).  This cannot be done at import time due to\n        # ordering issues, so we do it when creating a canvas, and should only\n        # be done once per class (hence the `lru_cache(1)`).\n        if sys.modules.get(\"IPython\") is None:\n            return\n        import IPython\n        ip = IPython.get_ipython()\n        if not ip:\n            return\n        from IPython.core import pylabtools as pt\n        if (not hasattr(pt, \"backend2gui\")\n                or not hasattr(ip, \"enable_matplotlib\")):\n",
      "\ndef __init__(self, figure=None):\n    from matplotlib.figure import Figure\n    self._fix_ipython_backend2gui()\n    self._is_idle_drawing = True\n    self._is_saving = False\n    if figure is None:\n        figure = Figure()\n    \n    # Check if this is an unpickled figure with DPI issues\n    if hasattr(figure, '_original_dpi'):\n        # This is an unpickled figure, restore original DPI if it was doubled\n        if figure.dpi != figure._original_dpi:\n            figure.dpi = figure._original_dpi\n    \n    figure.set_canvas(self)\n    self.figure = figure\n    self.manager = None\n    self.widgetlock = widgets.LockDraw()\n    self._button = None  # the button pressed\n    self._key = None  # the key pressed\n    self._lastx, self._lasty = None, None\n    self.mouse_grabber = None  # the Axes currently grabbing mouse\n    self.toolbar = None  # NavigationToolbar2 will set me\n    self._is_idle_drawing = False\n    # We don't want to scale up the figure DPI more than once.\n    # Only set _original_dpi if it doesn't already exist (from unpickling)\n    if not hasattr(figure, '_original_dpi'):\n        figure._original_dpi = figure.dpi\n    self._device_pixel_ratio = 1\n    super().__init__()  # Typically the GUI widget init (if any).\n\ncallbacks = property(lambda self: self.figure._canvas_callbacks)\nbutton_pick_id = property(lambda self: self.figure._button_pick_id)\nscroll_pick_id = property(lambda self: self.figure._scroll_pick_id)\n\n@classmethod\n@functools.lru_cache()\ndef _fix_ipython_backend2gui(cls):\n    # Fix hard-coded module -> toolkit mapping in IPython (used for\n    # `ipython --auto`).  This cannot be done at import time due to\n    # ordering issues, so we do it when creating a canvas, and should only\n    # be done once per class (hence the `lru_cache(1)`).\n    if sys.modules.get(\"IPython\") is None:\n        return\n    import IPython\n    ip = IPython.get_ipython()\n    if not ip:\n        return\n    from IPython.core import pylabtools as pt\n    if (not hasattr(pt, \"backend2gui\")\n            or not hasattr(ip, \"enable_matplotlib\")):\n",
      "\n    def __init__(self, figure=None):\n        from matplotlib.figure import Figure\n        self._fix_ipython_backend2gui()\n        self._is_idle_drawing = True\n        self._is_saving = False\n        if figure is None:\n            figure = Figure()\n        \n        # Check if this is an unpickled figure with doubled DPI\n        if hasattr(figure, '_original_dpi') and figure.dpi != figure._original_dpi:\n            # Reset to original DPI to prevent accumulating DPI scaling\n            figure.dpi = figure._original_dpi\n        \n        figure.set_canvas(self)\n        self.figure = figure\n        self.manager = None\n        self.widgetlock = widgets.LockDraw()\n        self._button = None  # the button pressed\n        self._key = None  # the key pressed\n        self._lastx, self._lasty = None, None\n        self.mouse_grabber = None  # the Axes currently grabbing mouse\n        self.toolbar = None  # NavigationToolbar2 will set me\n        self._is_idle_drawing = False\n        # We don't want to scale up the figure DPI more than once.\n        # Only set _original_dpi if it doesn't already exist (not an unpickled figure)\n        if not hasattr(figure, '_original_dpi'):\n            figure._original_dpi = figure.dpi\n        self._device_pixel_ratio = 1\n        super().__init__()  # Typically the GUI widget init (if any).\n\n    callbacks = property(lambda self: self.figure._canvas_callbacks)\n    button_pick_id = property(lambda self: self.figure._button_pick_id)\n    scroll_pick_id = property(lambda self: self.figure._scroll_pick_id)\n\n    @classmethod\n    @functools.lru_cache()\n    def _fix_ipython_backend2gui(cls):\n        # Fix hard-coded module -> toolkit mapping in IPython (used for\n        # `ipython --auto`).  This cannot be done at import time due to\n        # ordering issues, so we do it when creating a canvas, and should only\n        # be done once per class (hence the `lru_cache(1)`).\n        if sys.modules.get(\"IPython\") is None:\n            return\n        import IPython\n        ip = IPython.get_ipython()\n        if not ip:\n            return\n        from IPython.core import pylabtools as pt\n        if (not hasattr(pt, \"backend2gui\")\n                or not hasattr(ip, \"enable_matplotlib\")):\n"
    ],
    "Location 4 (/root/hy/projects_3/matplotlib/lib/matplotlib/backends/backend_macosx.py lines 38-40)": [
      "\n    def __init__(self, figure):\n        # Safety check for DPI overflow on M1 Mac during unpickling\n        if hasattr(figure, '_original_dpi') and figure.dpi != figure._original_dpi:\n            # Reset to original DPI if doubling has occurred\n            figure.dpi = figure._original_dpi\n        \n        # Validate figure dimensions won't cause overflow\n        try:\n            # Test if canvas creation would succeed with current dimensions\n            width_px = int(figure.bbox.width)\n            height_px = int(figure.bbox.height)\n            if width_px > 32767 or height_px > 32767:\n                # Dimensions too large, likely due to DPI doubling\n                if hasattr(figure, '_original_dpi'):\n                    figure.dpi = figure._original_dpi\n                else:\n                    # Fallback: halve the DPI\n                    figure.dpi = figure.dpi / 2.0\n        except (ValueError, OverflowError):\n            # Handle any overflow during dimension calculation\n            if hasattr(figure, '_original_dpi'):\n                figure.dpi = figure._original_dpi\n            else:\n                figure.dpi = 72.0  # Safe default DPI\n        \n        super().__init__(figure=figure)\n        self._draw_pending = False\n",
      "\ndef __init__(self, figure):\n    # Check if this is an unpickled figure with DPI issues on M1 Mac\n    if hasattr(figure, '_original_dpi') and figure.dpi != figure._original_dpi:\n        # Reset DPI to prevent overflow during canvas creation\n        figure.dpi = figure._original_dpi\n    \n    # Validate figure dimensions to prevent overflow\n    try:\n        width_inches, height_inches = figure.get_size_inches()\n        if width_inches * figure.dpi > 32767 or height_inches * figure.dpi > 32767:\n            # Dimensions too large, reset to safe DPI\n            safe_dpi = min(32767 / width_inches, 32767 / height_inches, 100)\n            figure.dpi = safe_dpi\n    except (OverflowError, ValueError):\n        # If we can't calculate safely, use a conservative DPI\n        figure.dpi = 72\n    \n    super().__init__(figure=figure)\n    self._draw_pending = False\n",
      "\ndef __init__(self, figure):\n    # Preserve original DPI if this is an unpickled figure\n    if hasattr(figure, '_original_dpi') and figure.dpi != figure._original_dpi:\n        figure.dpi = figure._original_dpi\n    super().__init__(figure=figure)\n    self._draw_pending = False\n",
      "\ndef __init__(self, figure):\n    # Preserve original DPI to prevent doubling on M1 Macs\n    if hasattr(figure, '_original_dpi') and figure.dpi > figure._original_dpi * 1.5:\n        # Reset DPI to original value if it appears to have been doubled\n        figure.dpi = figure._original_dpi\n    \n    super().__init__(figure=figure)\n    self._draw_pending = False\n",
      "\n    def __init__(self, figure):\n        # Validate figure dimensions before initialization to prevent overflow\n        # This is especially important for unpickled figures that may have doubled DPI\n        if hasattr(figure, '_original_dpi') and figure.dpi > figure._original_dpi:\n            # Reset to original DPI if doubling is detected\n            figure.dpi = figure._original_dpi\n        \n        # Additional safety check for unreasonably large dimensions\n        width_inches, height_inches = figure.get_size_inches()\n        if width_inches * figure.dpi > 32767 or height_inches * figure.dpi > 32767:\n            # Reset to a safe DPI value to prevent overflow\n            safe_dpi = min(32767 / width_inches, 32767 / height_inches, 100)\n            figure.dpi = safe_dpi\n        \n        super().__init__(figure=figure)\n        self._draw_pending = False\n",
      "\n    def __init__(self, figure):\n        # Safety check for DPI overflow before canvas initialization\n        if hasattr(figure, '_original_dpi') and figure.dpi > figure._original_dpi * 2:\n            # Reset to original DPI to prevent overflow\n            figure.dpi = figure._original_dpi\n        super().__init__(figure=figure)\n        self._draw_pending = False\n",
      "\ndef __init__(self, figure):\n    # Preserve original DPI if this is an unpickled figure\n    if hasattr(figure, '_original_dpi') and figure.dpi != figure._original_dpi:\n        # Reset to original DPI to prevent overflow from DPI doubling\n        figure.dpi = figure._original_dpi\n    \n    super().__init__(figure=figure)\n    self._draw_pending = False\n",
      "\n    def __init__(self, figure):\n        # Check if figure dimensions would cause overflow due to DPI doubling\n        # This can happen during unpickling on M1 Macs\n        try:\n            # Test if figure dimensions are reasonable\n            width_pixels = figure.bbox.width\n            height_pixels = figure.bbox.height\n            if width_pixels > 32767 or height_pixels > 32767:\n                # Dimensions too large, likely due to DPI doubling\n                if hasattr(figure, '_original_dpi'):\n                    figure.dpi = figure._original_dpi\n                else:\n                    # Fallback: halve the DPI to undo doubling\n                    figure.dpi = figure.dpi / 2\n        except (AttributeError, OverflowError):\n            # If we can't check dimensions, ensure DPI is reasonable\n            if hasattr(figure, '_original_dpi') and figure.dpi != figure._original_dpi:\n                figure.dpi = figure._original_dpi\n        \n        super().__init__(figure=figure)\n        self._draw_pending = False\n"
    ],
    "Location 5 (/root/hy/projects_3/matplotlib/lib/matplotlib/backend_bases.py lines 3510-3512)": [
      "\n    @classmethod\n    def new_figure_manager_given_figure(cls, num, figure):\n        \"\"\"Create a new figure manager instance for the given figure.\"\"\"\n        # Preserve DPI state during canvas creation to prevent doubling during unpickling\n        original_dpi = getattr(figure, '_original_dpi', None)\n        current_dpi = figure.dpi\n        \n        manager = cls.FigureCanvas.new_manager(figure, num)\n        \n        # Restore DPI state if it was modified during canvas creation\n        if original_dpi is not None and figure.dpi != current_dpi:\n            figure.dpi = current_dpi\n            \n        return manager\n",
      "\n    @classmethod\n    def new_figure_manager_given_figure(cls, num, figure):\n        \"\"\"Create a new figure manager instance for the given figure.\"\"\"\n        # Preserve original DPI during canvas creation to prevent doubling during unpickling\n        original_dpi = getattr(figure, '_original_dpi', figure.dpi)\n        canvas = cls.FigureCanvas(figure)\n        # Ensure original DPI is preserved after canvas creation\n        if hasattr(figure, '_original_dpi') and figure.dpi != original_dpi:\n            figure.dpi = original_dpi\n        return canvas.new_manager(figure, num)\n",
      "\n    @classmethod\n    def new_figure_manager_given_figure(cls, num, figure):\n        \"\"\"Create a new figure manager instance for the given figure.\"\"\"\n        # Preserve DPI state during canvas creation to prevent doubling during unpickling\n        original_dpi = getattr(figure, '_original_dpi', None)\n        current_dpi = figure.dpi\n        \n        manager = cls.FigureCanvas.new_manager(figure, num)\n        \n        # Restore DPI state if it was modified during canvas creation\n        if original_dpi is not None and figure.dpi != current_dpi:\n            figure.dpi = original_dpi\n            \n        return manager\n",
      "\n    @classmethod\n    def new_figure_manager_given_figure(cls, num, figure):\n        \"\"\"Create a new figure manager instance for the given figure.\"\"\"\n        # Preserve DPI state during canvas creation to prevent doubling during unpickling\n        original_dpi = getattr(figure, '_original_dpi', None)\n        current_dpi = figure.dpi\n        \n        manager = cls.FigureCanvas.new_manager(figure, num)\n        \n        # Restore original DPI if it was preserved and differs from current\n        if original_dpi is not None and current_dpi != original_dpi:\n            figure.dpi = original_dpi\n            \n        return manager\n",
      "\n    @classmethod\n    def new_figure_manager_given_figure(cls, num, figure):\n        \"\"\"Create a new figure manager instance for the given figure.\"\"\"\n        # Preserve DPI state during canvas creation to prevent doubling during unpickling\n        original_dpi = getattr(figure, '_original_dpi', None)\n        current_dpi = figure.dpi\n        \n        manager = cls.FigureCanvas.new_manager(figure, num)\n        \n        # Restore DPI state if it was modified during canvas creation\n        if original_dpi is not None and figure.dpi != current_dpi:\n            figure.dpi = original_dpi\n            \n        return manager\n",
      "\n    @classmethod\n    def new_figure_manager_given_figure(cls, num, figure):\n        \"\"\"Create a new figure manager instance for the given figure.\"\"\"\n        # Preserve DPI state during canvas creation to prevent doubling during unpickling\n        original_dpi = getattr(figure, '_original_dpi', None)\n        current_dpi = figure.dpi\n        \n        manager = cls.FigureCanvas.new_manager(figure, num)\n        \n        # Restore DPI state if it was modified during canvas creation\n        if original_dpi is not None and hasattr(figure, '_original_dpi'):\n            figure._original_dpi = original_dpi\n        \n        return manager\n",
      "\n    @classmethod\n    def new_figure_manager_given_figure(cls, num, figure):\n        \"\"\"Create a new figure manager instance for the given figure.\"\"\"\n        # Preserve DPI state during canvas creation to prevent doubling during unpickling\n        original_dpi = getattr(figure, '_original_dpi', None)\n        current_dpi = figure.dpi\n        \n        manager = cls.FigureCanvas.new_manager(figure, num)\n        \n        # Restore original DPI if it was preserved and differs from current\n        if original_dpi is not None and current_dpi != original_dpi:\n            figure.dpi = original_dpi\n            \n        return manager\n",
      "\n    @classmethod\n    def new_figure_manager_given_figure(cls, num, figure):\n        \"\"\"Create a new figure manager instance for the given figure.\"\"\"\n        # Preserve DPI state during canvas creation to prevent doubling during unpickling\n        original_dpi = getattr(figure, '_original_dpi', figure.dpi)\n        current_dpi = figure.dpi\n        \n        manager = cls.FigureCanvas.new_manager(figure, num)\n        \n        # Restore original DPI if it was modified during canvas creation\n        if hasattr(figure, '_original_dpi') and figure.dpi != current_dpi:\n            figure.dpi = original_dpi\n            \n        return manager\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/lib/matplotlib/backend_bases.py b/lib/matplotlib/backend_bases.py\nindex 9ae2982c62..937a7370de 100644\n--- a/lib/matplotlib/backend_bases.py\n+++ b/lib/matplotlib/backend_bases.py\n@@ -1635,6 +1635,7 @@ class FigureCanvasBase:\n         return (hasattr(cls, \"copy_from_bbox\")\n                 and hasattr(cls, \"restore_region\"))\n \n+\n     def __init__(self, figure=None):\n         from matplotlib.figure import Figure\n         self._fix_ipython_backend2gui()\n@@ -1642,6 +1643,9 @@ class FigureCanvasBase:\n         self._is_saving = False\n         if figure is None:\n             figure = Figure()\n+        # Detect unpickled figures and restore original DPI before canvas initialization\n+        if hasattr(figure, '_original_dpi') and figure.dpi != figure._original_dpi:\n+            figure.dpi = figure._original_dpi\n         figure.set_canvas(self)\n         self.figure = figure\n         self.manager = None\n@@ -1653,7 +1657,7 @@ class FigureCanvasBase:\n         self.toolbar = None  # NavigationToolbar2 will set me\n         self._is_idle_drawing = False\n         # We don't want to scale up the figure DPI more than once.\n-        figure._original_dpi = figure.dpi\n+        figure._original_dpi = getattr(figure, '_original_dpi', figure.dpi)\n         self._device_pixel_ratio = 1\n         super().__init__()  # Typically the GUI widget init (if any).\n \n@@ -1678,6 +1682,7 @@ class FigureCanvasBase:\n         if (not hasattr(pt, \"backend2gui\")\n                 or not hasattr(ip, \"enable_matplotlib\")):\n             # In case we ever move the patch to IPython and remove these APIs,\n+            # In case we ever move the patch to IPython and remove these APIs,\n             # don't break on our side.\n             return\n         backend2gui_rif = {\n@@ -3507,6 +3512,7 @@ class _Backend:\n         return cls.new_figure_manager_given_figure(num, fig)\n \n     @classmethod\n+\n     def new_figure_manager_given_figure(cls, num, figure):\n         \"\"\"Create a new figure manager instance for the given figure.\"\"\"\n         return cls.FigureCanvas.new_manager(figure, num)\ndiff --git a/lib/matplotlib/backends/backend_macosx.py b/lib/matplotlib/backends/backend_macosx.py\nindex 700d1d4c58..e94a1bdb00 100644\n--- a/lib/matplotlib/backends/backend_macosx.py\n+++ b/lib/matplotlib/backends/backend_macosx.py\n@@ -35,7 +35,11 @@ class FigureCanvasMac(FigureCanvasAgg, _macosx.FigureCanvas, FigureCanvasBase):\n     _timer_cls = TimerMac\n     manager_class = _api.classproperty(lambda cls: FigureManagerMac)\n \n+\n     def __init__(self, figure):\n+        # Safety check to prevent overflow from doubled DPI on unpickled figures\n+        if hasattr(figure, '_original_dpi') and figure.dpi > figure._original_dpi * 2:\n+            figure.dpi = figure._original_dpi\n         super().__init__(figure=figure)\n         self._draw_pending = False\n         self._is_drawing = False\ndiff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex c55864243a..32c83fb110 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -3049,13 +3049,16 @@ class Figure(FigureBase):\n         if restore_to_pylab:\n             # lazy import to avoid circularity\n             import matplotlib.pyplot as plt\n+\n             import matplotlib._pylab_helpers as pylab_helpers\n             allnums = plt.get_fignums()\n             num = max(allnums) + 1 if allnums else 1\n+            # Preserve original DPI before creating new figure manager during unpickling\n+            if not hasattr(self, '_original_dpi'):\n+                self._original_dpi = self.dpi\n             mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n             pylab_helpers.Gcf._set_new_active_manager(mgr)\n             plt.draw_if_interactive()\n-\n         self.stale = True\n \n     def add_axobserver(self, func):\n",
    "variant_0": "diff --git a/lib/matplotlib/backend_bases.py b/lib/matplotlib/backend_bases.py\nindex 9ae2982c62..e3ce2224cc 100644\n--- a/lib/matplotlib/backend_bases.py\n+++ b/lib/matplotlib/backend_bases.py\n@@ -1635,48 +1635,58 @@ class FigureCanvasBase:\n         return (hasattr(cls, \"copy_from_bbox\")\n                 and hasattr(cls, \"restore_region\"))\n \n-    def __init__(self, figure=None):\n-        from matplotlib.figure import Figure\n-        self._fix_ipython_backend2gui()\n-        self._is_idle_drawing = True\n-        self._is_saving = False\n-        if figure is None:\n-            figure = Figure()\n-        figure.set_canvas(self)\n-        self.figure = figure\n-        self.manager = None\n-        self.widgetlock = widgets.LockDraw()\n-        self._button = None  # the button pressed\n-        self._key = None  # the key pressed\n-        self._lastx, self._lasty = None, None\n-        self.mouse_grabber = None  # the Axes currently grabbing mouse\n-        self.toolbar = None  # NavigationToolbar2 will set me\n-        self._is_idle_drawing = False\n-        # We don't want to scale up the figure DPI more than once.\n-        figure._original_dpi = figure.dpi\n-        self._device_pixel_ratio = 1\n-        super().__init__()  # Typically the GUI widget init (if any).\n \n-    callbacks = property(lambda self: self.figure._canvas_callbacks)\n-    button_pick_id = property(lambda self: self.figure._button_pick_id)\n-    scroll_pick_id = property(lambda self: self.figure._scroll_pick_id)\n-\n-    @classmethod\n-    @functools.lru_cache()\n-    def _fix_ipython_backend2gui(cls):\n-        # Fix hard-coded module -> toolkit mapping in IPython (used for\n-        # `ipython --auto`).  This cannot be done at import time due to\n-        # ordering issues, so we do it when creating a canvas, and should only\n-        # be done once per class (hence the `lru_cache(1)`).\n-        if sys.modules.get(\"IPython\") is None:\n-            return\n-        import IPython\n-        ip = IPython.get_ipython()\n-        if not ip:\n-            return\n-        from IPython.core import pylabtools as pt\n-        if (not hasattr(pt, \"backend2gui\")\n-                or not hasattr(ip, \"enable_matplotlib\")):\n+def __init__(self, figure=None):\n+    from matplotlib.figure import Figure\n+    self._fix_ipython_backend2gui()\n+    self._is_idle_drawing = True\n+    self._is_saving = False\n+    if figure is None:\n+        figure = Figure()\n+    \n+    # Check if this is an unpickled figure that may have doubled DPI\n+    if hasattr(figure, '_original_dpi') and figure.dpi != figure._original_dpi:\n+        # Restore original DPI to prevent accumulating DPI scaling\n+        figure.dpi = figure._original_dpi\n+    \n+    figure.set_canvas(self)\n+    self.figure = figure\n+    self.manager = None\n+    self.widgetlock = widgets.LockDraw()\n+    self._button = None  # the button pressed\n+    self._key = None  # the key pressed\n+    self._lastx, self._lasty = None, None\n+    self.mouse_grabber = None  # the Axes currently grabbing mouse\n+    self.toolbar = None  # NavigationToolbar2 will set me\n+    self._is_idle_drawing = False\n+    # We don't want to scale up the figure DPI more than once.\n+    # Only set _original_dpi if it doesn't already exist (preserve unpickled state)\n+    if not hasattr(figure, '_original_dpi'):\n+        figure._original_dpi = figure.dpi\n+    self._device_pixel_ratio = 1\n+    super().__init__()  # Typically the GUI widget init (if any).\n+\n+callbacks = property(lambda self: self.figure._canvas_callbacks)\n+button_pick_id = property(lambda self: self.figure._button_pick_id)\n+scroll_pick_id = property(lambda self: self.figure._scroll_pick_id)\n+\n+@classmethod\n+@functools.lru_cache()\n+def _fix_ipython_backend2gui(cls):\n+    # Fix hard-coded module -> toolkit mapping in IPython (used for\n+    # `ipython --auto`).  This cannot be done at import time due to\n+    # ordering issues, so we do it when creating a canvas, and should only\n+    # be done once per class (hence the `lru_cache(1)`).\n+    if sys.modules.get(\"IPython\") is None:\n+        return\n+    import IPython\n+    ip = IPython.get_ipython()\n+    if not ip:\n+        return\n+    from IPython.core import pylabtools as pt\n+    if (not hasattr(pt, \"backend2gui\")\n+            or not hasattr(ip, \"enable_matplotlib\")):\n+        # In case we ever move the patch to IPython and remove these APIs,\n             # In case we ever move the patch to IPython and remove these APIs,\n             # don't break on our side.\n             return\n@@ -3506,10 +3516,23 @@ class _Backend:\n         fig = fig_cls(*args, **kwargs)\n         return cls.new_figure_manager_given_figure(num, fig)\n \n+    @classmethod\n+\n     @classmethod\n     def new_figure_manager_given_figure(cls, num, figure):\n         \"\"\"Create a new figure manager instance for the given figure.\"\"\"\n-        return cls.FigureCanvas.new_manager(figure, num)\n+        # Preserve DPI state during canvas creation to prevent doubling during unpickling\n+        original_dpi = getattr(figure, '_original_dpi', None)\n+        current_dpi = figure.dpi\n+        \n+        manager = cls.FigureCanvas.new_manager(figure, num)\n+        \n+        # Restore DPI state if it was modified during canvas creation\n+        if original_dpi is not None and figure.dpi != current_dpi:\n+            figure.dpi = current_dpi\n+            figure._original_dpi = original_dpi\n+            \n+        return manager\n \n     @classmethod\n     def draw_if_interactive(cls):\ndiff --git a/lib/matplotlib/backends/backend_macosx.py b/lib/matplotlib/backends/backend_macosx.py\nindex 700d1d4c58..ff87537bd9 100644\n--- a/lib/matplotlib/backends/backend_macosx.py\n+++ b/lib/matplotlib/backends/backend_macosx.py\n@@ -35,7 +35,13 @@ class FigureCanvasMac(FigureCanvasAgg, _macosx.FigureCanvas, FigureCanvasBase):\n     _timer_cls = TimerMac\n     manager_class = _api.classproperty(lambda cls: FigureManagerMac)\n \n+\n     def __init__(self, figure):\n+        # Safety check for M1 Mac DPI doubling issue during unpickling\n+        if hasattr(figure, '_original_dpi') and figure.dpi != figure._original_dpi:\n+            # Reset to original DPI to prevent overflow\n+            figure.dpi = figure._original_dpi\n+        \n         super().__init__(figure=figure)\n         self._draw_pending = False\n         self._is_drawing = False\ndiff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex c55864243a..9bfdd46da8 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -3046,16 +3046,30 @@ class Figure(FigureBase):\n         # re-initialise some of the unstored state information\n         FigureCanvasBase(self)  # Set self.canvas.\n \n+        if restore_to_pylab:\n+            # lazy import to avoid circularity\n+            import matplotlib.pyplot as plt\n+\n         if restore_to_pylab:\n             # lazy import to avoid circularity\n             import matplotlib.pyplot as plt\n             import matplotlib._pylab_helpers as pylab_helpers\n+            \n+            # Preserve original DPI before creating new figure manager\n+            # to prevent DPI doubling during unpickling\n+            original_dpi = getattr(self, '_original_dpi', self.dpi)\n+            self._original_dpi = original_dpi\n+            \n             allnums = plt.get_fignums()\n             num = max(allnums) + 1 if allnums else 1\n             mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n+            \n+            # Restore original DPI after canvas creation if it was doubled\n+            if hasattr(self, '_original_dpi') and self.dpi != self._original_dpi:\n+                self.dpi = self._original_dpi\n+            \n             pylab_helpers.Gcf._set_new_active_manager(mgr)\n             plt.draw_if_interactive()\n-\n         self.stale = True\n \n     def add_axobserver(self, func):\n",
    "variant_1": "diff --git a/lib/matplotlib/backend_bases.py b/lib/matplotlib/backend_bases.py\nindex 9ae2982c62..5d37e8f9c2 100644\n--- a/lib/matplotlib/backend_bases.py\n+++ b/lib/matplotlib/backend_bases.py\n@@ -1635,6 +1635,7 @@ class FigureCanvasBase:\n         return (hasattr(cls, \"copy_from_bbox\")\n                 and hasattr(cls, \"restore_region\"))\n \n+\n     def __init__(self, figure=None):\n         from matplotlib.figure import Figure\n         self._fix_ipython_backend2gui()\n@@ -1642,6 +1643,12 @@ class FigureCanvasBase:\n         self._is_saving = False\n         if figure is None:\n             figure = Figure()\n+        \n+        # Check if this is an unpickled figure with doubled DPI\n+        if hasattr(figure, '_original_dpi') and figure.dpi != figure._original_dpi:\n+            # Restore original DPI to prevent accumulation\n+            figure.dpi = figure._original_dpi\n+        \n         figure.set_canvas(self)\n         self.figure = figure\n         self.manager = None\n@@ -1653,7 +1660,9 @@ class FigureCanvasBase:\n         self.toolbar = None  # NavigationToolbar2 will set me\n         self._is_idle_drawing = False\n         # We don't want to scale up the figure DPI more than once.\n-        figure._original_dpi = figure.dpi\n+        # Only set _original_dpi if it doesn't already exist (preserve unpickled state)\n+        if not hasattr(figure, '_original_dpi'):\n+            figure._original_dpi = figure.dpi\n         self._device_pixel_ratio = 1\n         super().__init__()  # Typically the GUI widget init (if any).\n \n@@ -3506,10 +3515,22 @@ class _Backend:\n         fig = fig_cls(*args, **kwargs)\n         return cls.new_figure_manager_given_figure(num, fig)\n \n+    @classmethod\n+\n     @classmethod\n     def new_figure_manager_given_figure(cls, num, figure):\n         \"\"\"Create a new figure manager instance for the given figure.\"\"\"\n-        return cls.FigureCanvas.new_manager(figure, num)\n+        # Preserve DPI state during canvas creation to prevent doubling during unpickling\n+        original_dpi = getattr(figure, '_original_dpi', None)\n+        current_dpi = figure.dpi\n+        \n+        manager = cls.FigureCanvas.new_manager(figure, num)\n+        \n+        # Restore DPI state if it was modified during canvas creation\n+        if original_dpi is not None and figure.dpi != current_dpi:\n+            figure.dpi = current_dpi\n+            \n+        return manager\n \n     @classmethod\n     def draw_if_interactive(cls):\ndiff --git a/lib/matplotlib/backends/backend_macosx.py b/lib/matplotlib/backends/backend_macosx.py\nindex 700d1d4c58..f45a1236af 100644\n--- a/lib/matplotlib/backends/backend_macosx.py\n+++ b/lib/matplotlib/backends/backend_macosx.py\n@@ -35,7 +35,32 @@ class FigureCanvasMac(FigureCanvasAgg, _macosx.FigureCanvas, FigureCanvasBase):\n     _timer_cls = TimerMac\n     manager_class = _api.classproperty(lambda cls: FigureManagerMac)\n \n+\n     def __init__(self, figure):\n+        # Safety check for DPI overflow on M1 Mac during unpickling\n+        if hasattr(figure, '_original_dpi') and figure.dpi != figure._original_dpi:\n+            # Reset to original DPI if doubling has occurred\n+            figure.dpi = figure._original_dpi\n+        \n+        # Validate figure dimensions won't cause overflow\n+        try:\n+            # Test if canvas creation would succeed with current dimensions\n+            width_px = int(figure.bbox.width)\n+            height_px = int(figure.bbox.height)\n+            if width_px > 32767 or height_px > 32767:\n+                # Dimensions too large, likely due to DPI doubling\n+                if hasattr(figure, '_original_dpi'):\n+                    figure.dpi = figure._original_dpi\n+                else:\n+                    # Fallback: halve the DPI\n+                    figure.dpi = figure.dpi / 2.0\n+        except (ValueError, OverflowError):\n+            # Handle any overflow during dimension calculation\n+            if hasattr(figure, '_original_dpi'):\n+                figure.dpi = figure._original_dpi\n+            else:\n+                figure.dpi = 72.0  # Safe default DPI\n+        \n         super().__init__(figure=figure)\n         self._draw_pending = False\n         self._is_drawing = False\ndiff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex c55864243a..d4de5a8463 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -3046,16 +3046,28 @@ class Figure(FigureBase):\n         # re-initialise some of the unstored state information\n         FigureCanvasBase(self)  # Set self.canvas.\n \n+        if restore_to_pylab:\n+            # lazy import to avoid circularity\n+            import matplotlib.pyplot as plt\n+\n         if restore_to_pylab:\n             # lazy import to avoid circularity\n             import matplotlib.pyplot as plt\n             import matplotlib._pylab_helpers as pylab_helpers\n+            \n+            # Store original DPI before creating new figure manager to prevent DPI doubling\n+            original_dpi = getattr(self, '_original_dpi', self.dpi)\n+            \n             allnums = plt.get_fignums()\n             num = max(allnums) + 1 if allnums else 1\n             mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n+            \n+            # Restore original DPI after canvas creation\n+            if hasattr(self, '_original_dpi'):\n+                self.dpi = original_dpi\n+            \n             pylab_helpers.Gcf._set_new_active_manager(mgr)\n             plt.draw_if_interactive()\n-\n         self.stale = True\n \n     def add_axobserver(self, func):\n",
    "variant_2": "diff --git a/lib/matplotlib/backend_bases.py b/lib/matplotlib/backend_bases.py\nindex 9ae2982c62..8d8338b311 100644\n--- a/lib/matplotlib/backend_bases.py\n+++ b/lib/matplotlib/backend_bases.py\n@@ -1635,6 +1635,7 @@ class FigureCanvasBase:\n         return (hasattr(cls, \"copy_from_bbox\")\n                 and hasattr(cls, \"restore_region\"))\n \n+\n     def __init__(self, figure=None):\n         from matplotlib.figure import Figure\n         self._fix_ipython_backend2gui()\n@@ -1642,6 +1643,12 @@ class FigureCanvasBase:\n         self._is_saving = False\n         if figure is None:\n             figure = Figure()\n+        \n+        # Check if this is an unpickled figure with DPI doubling issue\n+        if hasattr(figure, '_original_dpi') and figure.dpi != figure._original_dpi:\n+            # Restore original DPI to prevent doubling\n+            figure.dpi = figure._original_dpi\n+        \n         figure.set_canvas(self)\n         self.figure = figure\n         self.manager = None\n@@ -1653,7 +1660,9 @@ class FigureCanvasBase:\n         self.toolbar = None  # NavigationToolbar2 will set me\n         self._is_idle_drawing = False\n         # We don't want to scale up the figure DPI more than once.\n-        figure._original_dpi = figure.dpi\n+        # Only set _original_dpi if it doesn't already exist (preserve unpickled state)\n+        if not hasattr(figure, '_original_dpi'):\n+            figure._original_dpi = figure.dpi\n         self._device_pixel_ratio = 1\n         super().__init__()  # Typically the GUI widget init (if any).\n \n@@ -3506,10 +3515,18 @@ class _Backend:\n         fig = fig_cls(*args, **kwargs)\n         return cls.new_figure_manager_given_figure(num, fig)\n \n+    @classmethod\n+\n     @classmethod\n     def new_figure_manager_given_figure(cls, num, figure):\n         \"\"\"Create a new figure manager instance for the given figure.\"\"\"\n-        return cls.FigureCanvas.new_manager(figure, num)\n+        # Preserve original DPI during canvas creation to prevent doubling during unpickling\n+        original_dpi = getattr(figure, '_original_dpi', figure.dpi)\n+        canvas = cls.FigureCanvas(figure)\n+        # Ensure original DPI is preserved after canvas creation\n+        if hasattr(figure, '_original_dpi') and figure.dpi != original_dpi:\n+            figure.dpi = original_dpi\n+        return canvas.new_manager(figure, num)\n \n     @classmethod\n     def draw_if_interactive(cls):\ndiff --git a/lib/matplotlib/backends/backend_macosx.py b/lib/matplotlib/backends/backend_macosx.py\nindex 700d1d4c58..c5f933aeec 100644\n--- a/lib/matplotlib/backends/backend_macosx.py\n+++ b/lib/matplotlib/backends/backend_macosx.py\n@@ -35,9 +35,26 @@ class FigureCanvasMac(FigureCanvasAgg, _macosx.FigureCanvas, FigureCanvasBase):\n     _timer_cls = TimerMac\n     manager_class = _api.classproperty(lambda cls: FigureManagerMac)\n \n-    def __init__(self, figure):\n-        super().__init__(figure=figure)\n-        self._draw_pending = False\n+\n+def __init__(self, figure):\n+    # Check if this is an unpickled figure with DPI issues on M1 Mac\n+    if hasattr(figure, '_original_dpi') and figure.dpi != figure._original_dpi:\n+        # Reset DPI to prevent overflow during canvas creation\n+        figure.dpi = figure._original_dpi\n+    \n+    # Validate figure dimensions to prevent overflow\n+    try:\n+        width_inches, height_inches = figure.get_size_inches()\n+        if width_inches * figure.dpi > 32767 or height_inches * figure.dpi > 32767:\n+            # Dimensions too large, reset to safe DPI\n+            safe_dpi = min(32767 / width_inches, 32767 / height_inches, 100)\n+            figure.dpi = safe_dpi\n+    except (OverflowError, ValueError):\n+        # If we can't calculate safely, use a conservative DPI\n+        figure.dpi = 72\n+    \n+    super().__init__(figure=figure)\n+    self._draw_pending = False\n         self._is_drawing = False\n \n     def draw(self):\ndiff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex c55864243a..af37b0e095 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -3046,16 +3046,28 @@ class Figure(FigureBase):\n         # re-initialise some of the unstored state information\n         FigureCanvasBase(self)  # Set self.canvas.\n \n+        if restore_to_pylab:\n+            # lazy import to avoid circularity\n+            import matplotlib.pyplot as plt\n+\n         if restore_to_pylab:\n             # lazy import to avoid circularity\n             import matplotlib.pyplot as plt\n             import matplotlib._pylab_helpers as pylab_helpers\n+            \n+            # Preserve original DPI before creating new figure manager\n+            original_dpi = getattr(self, '_original_dpi', self.dpi)\n+            \n             allnums = plt.get_fignums()\n             num = max(allnums) + 1 if allnums else 1\n             mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n+            \n+            # Restore original DPI after canvas creation to prevent doubling\n+            if hasattr(self, '_original_dpi'):\n+                self.dpi = original_dpi\n+            \n             pylab_helpers.Gcf._set_new_active_manager(mgr)\n             plt.draw_if_interactive()\n-\n         self.stale = True\n \n     def add_axobserver(self, func):\n",
    "variant_3": "diff --git a/lib/matplotlib/backend_bases.py b/lib/matplotlib/backend_bases.py\nindex 9ae2982c62..76095f889c 100644\n--- a/lib/matplotlib/backend_bases.py\n+++ b/lib/matplotlib/backend_bases.py\n@@ -1635,6 +1635,7 @@ class FigureCanvasBase:\n         return (hasattr(cls, \"copy_from_bbox\")\n                 and hasattr(cls, \"restore_region\"))\n \n+\n     def __init__(self, figure=None):\n         from matplotlib.figure import Figure\n         self._fix_ipython_backend2gui()\n@@ -1642,6 +1643,12 @@ class FigureCanvasBase:\n         self._is_saving = False\n         if figure is None:\n             figure = Figure()\n+        \n+        # Check if this is an unpickled figure with DPI doubling issue\n+        if hasattr(figure, '_original_dpi') and figure.dpi != figure._original_dpi:\n+            # Reset to original DPI to prevent doubling during canvas creation\n+            figure.dpi = figure._original_dpi\n+        \n         figure.set_canvas(self)\n         self.figure = figure\n         self.manager = None\n@@ -1653,7 +1660,7 @@ class FigureCanvasBase:\n         self.toolbar = None  # NavigationToolbar2 will set me\n         self._is_idle_drawing = False\n         # We don't want to scale up the figure DPI more than once.\n-        figure._original_dpi = figure.dpi\n+        figure._original_dpi = getattr(figure, '_original_dpi', figure.dpi)\n         self._device_pixel_ratio = 1\n         super().__init__()  # Typically the GUI widget init (if any).\n \n@@ -3506,10 +3513,22 @@ class _Backend:\n         fig = fig_cls(*args, **kwargs)\n         return cls.new_figure_manager_given_figure(num, fig)\n \n+    @classmethod\n+\n     @classmethod\n     def new_figure_manager_given_figure(cls, num, figure):\n         \"\"\"Create a new figure manager instance for the given figure.\"\"\"\n-        return cls.FigureCanvas.new_manager(figure, num)\n+        # Preserve DPI state during canvas creation to prevent doubling during unpickling\n+        original_dpi = getattr(figure, '_original_dpi', None)\n+        current_dpi = figure.dpi\n+        \n+        manager = cls.FigureCanvas.new_manager(figure, num)\n+        \n+        # Restore DPI state if it was modified during canvas creation\n+        if original_dpi is not None and figure.dpi != current_dpi:\n+            figure.dpi = original_dpi\n+            \n+        return manager\n \n     @classmethod\n     def draw_if_interactive(cls):\ndiff --git a/lib/matplotlib/backends/backend_macosx.py b/lib/matplotlib/backends/backend_macosx.py\nindex 700d1d4c58..a353f042d1 100644\n--- a/lib/matplotlib/backends/backend_macosx.py\n+++ b/lib/matplotlib/backends/backend_macosx.py\n@@ -35,9 +35,13 @@ class FigureCanvasMac(FigureCanvasAgg, _macosx.FigureCanvas, FigureCanvasBase):\n     _timer_cls = TimerMac\n     manager_class = _api.classproperty(lambda cls: FigureManagerMac)\n \n-    def __init__(self, figure):\n-        super().__init__(figure=figure)\n-        self._draw_pending = False\n+\n+def __init__(self, figure):\n+    # Preserve original DPI if this is an unpickled figure\n+    if hasattr(figure, '_original_dpi') and figure.dpi != figure._original_dpi:\n+        figure.dpi = figure._original_dpi\n+    super().__init__(figure=figure)\n+    self._draw_pending = False\n         self._is_drawing = False\n \n     def draw(self):\ndiff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex c55864243a..e48271255a 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -3046,16 +3046,24 @@ class Figure(FigureBase):\n         # re-initialise some of the unstored state information\n         FigureCanvasBase(self)  # Set self.canvas.\n \n+        if restore_to_pylab:\n+            # lazy import to avoid circularity\n+            import matplotlib.pyplot as plt\n+\n         if restore_to_pylab:\n             # lazy import to avoid circularity\n             import matplotlib.pyplot as plt\n             import matplotlib._pylab_helpers as pylab_helpers\n+            # Preserve original DPI before creating new manager to prevent DPI doubling\n+            original_dpi = getattr(self, '_original_dpi', self.dpi)\n             allnums = plt.get_fignums()\n             num = max(allnums) + 1 if allnums else 1\n             mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n+            # Restore original DPI after canvas creation\n+            if hasattr(self, '_original_dpi'):\n+                self.dpi = original_dpi\n             pylab_helpers.Gcf._set_new_active_manager(mgr)\n             plt.draw_if_interactive()\n-\n         self.stale = True\n \n     def add_axobserver(self, func):\n",
    "variant_4": "diff --git a/lib/matplotlib/backend_bases.py b/lib/matplotlib/backend_bases.py\nindex 9ae2982c62..489e5a4f0b 100644\n--- a/lib/matplotlib/backend_bases.py\n+++ b/lib/matplotlib/backend_bases.py\n@@ -1635,6 +1635,7 @@ class FigureCanvasBase:\n         return (hasattr(cls, \"copy_from_bbox\")\n                 and hasattr(cls, \"restore_region\"))\n \n+\n     def __init__(self, figure=None):\n         from matplotlib.figure import Figure\n         self._fix_ipython_backend2gui()\n@@ -1642,6 +1643,12 @@ class FigureCanvasBase:\n         self._is_saving = False\n         if figure is None:\n             figure = Figure()\n+        \n+        # Check if this is an unpickled figure that may have doubled DPI\n+        if hasattr(figure, '_original_dpi') and figure.dpi != figure._original_dpi:\n+            # Reset DPI to original value to prevent accumulation\n+            figure.dpi = figure._original_dpi\n+        \n         figure.set_canvas(self)\n         self.figure = figure\n         self.manager = None\n@@ -1653,7 +1660,9 @@ class FigureCanvasBase:\n         self.toolbar = None  # NavigationToolbar2 will set me\n         self._is_idle_drawing = False\n         # We don't want to scale up the figure DPI more than once.\n-        figure._original_dpi = figure.dpi\n+        # Only set _original_dpi if it doesn't already exist (preserve unpickled state)\n+        if not hasattr(figure, '_original_dpi'):\n+            figure._original_dpi = figure.dpi\n         self._device_pixel_ratio = 1\n         super().__init__()  # Typically the GUI widget init (if any).\n \n@@ -3506,10 +3515,22 @@ class _Backend:\n         fig = fig_cls(*args, **kwargs)\n         return cls.new_figure_manager_given_figure(num, fig)\n \n+    @classmethod\n+\n     @classmethod\n     def new_figure_manager_given_figure(cls, num, figure):\n         \"\"\"Create a new figure manager instance for the given figure.\"\"\"\n-        return cls.FigureCanvas.new_manager(figure, num)\n+        # Preserve DPI state during canvas creation to prevent doubling during unpickling\n+        original_dpi = getattr(figure, '_original_dpi', None)\n+        current_dpi = figure.dpi\n+        \n+        manager = cls.FigureCanvas.new_manager(figure, num)\n+        \n+        # Restore original DPI if it was preserved and differs from current\n+        if original_dpi is not None and current_dpi != original_dpi:\n+            figure.dpi = original_dpi\n+            \n+        return manager\n \n     @classmethod\n     def draw_if_interactive(cls):\ndiff --git a/lib/matplotlib/backends/backend_macosx.py b/lib/matplotlib/backends/backend_macosx.py\nindex 700d1d4c58..3411964700 100644\n--- a/lib/matplotlib/backends/backend_macosx.py\n+++ b/lib/matplotlib/backends/backend_macosx.py\n@@ -35,9 +35,15 @@ class FigureCanvasMac(FigureCanvasAgg, _macosx.FigureCanvas, FigureCanvasBase):\n     _timer_cls = TimerMac\n     manager_class = _api.classproperty(lambda cls: FigureManagerMac)\n \n-    def __init__(self, figure):\n-        super().__init__(figure=figure)\n-        self._draw_pending = False\n+\n+def __init__(self, figure):\n+    # Preserve original DPI to prevent doubling on M1 Macs\n+    if hasattr(figure, '_original_dpi') and figure.dpi > figure._original_dpi * 1.5:\n+        # Reset DPI to original value if it appears to have been doubled\n+        figure.dpi = figure._original_dpi\n+    \n+    super().__init__(figure=figure)\n+    self._draw_pending = False\n         self._is_drawing = False\n \n     def draw(self):\ndiff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex c55864243a..d4de5a8463 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -3046,16 +3046,28 @@ class Figure(FigureBase):\n         # re-initialise some of the unstored state information\n         FigureCanvasBase(self)  # Set self.canvas.\n \n+        if restore_to_pylab:\n+            # lazy import to avoid circularity\n+            import matplotlib.pyplot as plt\n+\n         if restore_to_pylab:\n             # lazy import to avoid circularity\n             import matplotlib.pyplot as plt\n             import matplotlib._pylab_helpers as pylab_helpers\n+            \n+            # Store original DPI before creating new figure manager to prevent DPI doubling\n+            original_dpi = getattr(self, '_original_dpi', self.dpi)\n+            \n             allnums = plt.get_fignums()\n             num = max(allnums) + 1 if allnums else 1\n             mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n+            \n+            # Restore original DPI after canvas creation\n+            if hasattr(self, '_original_dpi'):\n+                self.dpi = original_dpi\n+            \n             pylab_helpers.Gcf._set_new_active_manager(mgr)\n             plt.draw_if_interactive()\n-\n         self.stale = True\n \n     def add_axobserver(self, func):\n",
    "variant_5": "diff --git a/lib/matplotlib/backend_bases.py b/lib/matplotlib/backend_bases.py\nindex 9ae2982c62..605def6293 100644\n--- a/lib/matplotlib/backend_bases.py\n+++ b/lib/matplotlib/backend_bases.py\n@@ -1635,6 +1635,7 @@ class FigureCanvasBase:\n         return (hasattr(cls, \"copy_from_bbox\")\n                 and hasattr(cls, \"restore_region\"))\n \n+\n     def __init__(self, figure=None):\n         from matplotlib.figure import Figure\n         self._fix_ipython_backend2gui()\n@@ -1642,6 +1643,12 @@ class FigureCanvasBase:\n         self._is_saving = False\n         if figure is None:\n             figure = Figure()\n+        \n+        # Check if this is an unpickled figure that may have doubled DPI\n+        if hasattr(figure, '_original_dpi') and figure.dpi != figure._original_dpi:\n+            # Restore original DPI to prevent doubling during canvas creation\n+            figure.dpi = figure._original_dpi\n+        \n         figure.set_canvas(self)\n         self.figure = figure\n         self.manager = None\n@@ -1653,7 +1660,9 @@ class FigureCanvasBase:\n         self.toolbar = None  # NavigationToolbar2 will set me\n         self._is_idle_drawing = False\n         # We don't want to scale up the figure DPI more than once.\n-        figure._original_dpi = figure.dpi\n+        # Only set _original_dpi if it doesn't already exist (e.g., from unpickling)\n+        if not hasattr(figure, '_original_dpi'):\n+            figure._original_dpi = figure.dpi\n         self._device_pixel_ratio = 1\n         super().__init__()  # Typically the GUI widget init (if any).\n \n@@ -3506,10 +3515,22 @@ class _Backend:\n         fig = fig_cls(*args, **kwargs)\n         return cls.new_figure_manager_given_figure(num, fig)\n \n+    @classmethod\n+\n     @classmethod\n     def new_figure_manager_given_figure(cls, num, figure):\n         \"\"\"Create a new figure manager instance for the given figure.\"\"\"\n-        return cls.FigureCanvas.new_manager(figure, num)\n+        # Preserve DPI state during canvas creation to prevent doubling during unpickling\n+        original_dpi = getattr(figure, '_original_dpi', None)\n+        current_dpi = figure.dpi\n+        \n+        manager = cls.FigureCanvas.new_manager(figure, num)\n+        \n+        # Restore DPI state if it was modified during canvas creation\n+        if original_dpi is not None and figure.dpi != current_dpi:\n+            figure.dpi = original_dpi\n+            \n+        return manager\n \n     @classmethod\n     def draw_if_interactive(cls):\ndiff --git a/lib/matplotlib/backends/backend_macosx.py b/lib/matplotlib/backends/backend_macosx.py\nindex 700d1d4c58..e8fa20c423 100644\n--- a/lib/matplotlib/backends/backend_macosx.py\n+++ b/lib/matplotlib/backends/backend_macosx.py\n@@ -35,7 +35,21 @@ class FigureCanvasMac(FigureCanvasAgg, _macosx.FigureCanvas, FigureCanvasBase):\n     _timer_cls = TimerMac\n     manager_class = _api.classproperty(lambda cls: FigureManagerMac)\n \n+\n     def __init__(self, figure):\n+        # Validate figure dimensions before initialization to prevent overflow\n+        # This is especially important for unpickled figures that may have doubled DPI\n+        if hasattr(figure, '_original_dpi') and figure.dpi > figure._original_dpi:\n+            # Reset to original DPI if doubling is detected\n+            figure.dpi = figure._original_dpi\n+        \n+        # Additional safety check for unreasonably large dimensions\n+        width_inches, height_inches = figure.get_size_inches()\n+        if width_inches * figure.dpi > 32767 or height_inches * figure.dpi > 32767:\n+            # Reset to a safe DPI value to prevent overflow\n+            safe_dpi = min(32767 / width_inches, 32767 / height_inches, 100)\n+            figure.dpi = safe_dpi\n+        \n         super().__init__(figure=figure)\n         self._draw_pending = False\n         self._is_drawing = False\ndiff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex c55864243a..4a4a334480 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -3046,16 +3046,30 @@ class Figure(FigureBase):\n         # re-initialise some of the unstored state information\n         FigureCanvasBase(self)  # Set self.canvas.\n \n+        if restore_to_pylab:\n+            # lazy import to avoid circularity\n+            import matplotlib.pyplot as plt\n+\n         if restore_to_pylab:\n             # lazy import to avoid circularity\n             import matplotlib.pyplot as plt\n             import matplotlib._pylab_helpers as pylab_helpers\n+            \n+            # Store original DPI before creating new figure manager to prevent\n+            # DPI doubling during unpickling on M1 Mac\n+            original_dpi = getattr(self, '_original_dpi', self.dpi)\n+            self._original_dpi = original_dpi\n+            \n             allnums = plt.get_fignums()\n             num = max(allnums) + 1 if allnums else 1\n             mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n+            \n+            # Restore original DPI if it was doubled during canvas creation\n+            if hasattr(self, '_original_dpi') and self.dpi != self._original_dpi:\n+                self.dpi = self._original_dpi\n+            \n             pylab_helpers.Gcf._set_new_active_manager(mgr)\n             plt.draw_if_interactive()\n-\n         self.stale = True\n \n     def add_axobserver(self, func):\n",
    "variant_6": "diff --git a/lib/matplotlib/backend_bases.py b/lib/matplotlib/backend_bases.py\nindex 9ae2982c62..f1592ffe61 100644\n--- a/lib/matplotlib/backend_bases.py\n+++ b/lib/matplotlib/backend_bases.py\n@@ -1635,6 +1635,7 @@ class FigureCanvasBase:\n         return (hasattr(cls, \"copy_from_bbox\")\n                 and hasattr(cls, \"restore_region\"))\n \n+\n     def __init__(self, figure=None):\n         from matplotlib.figure import Figure\n         self._fix_ipython_backend2gui()\n@@ -1642,6 +1643,12 @@ class FigureCanvasBase:\n         self._is_saving = False\n         if figure is None:\n             figure = Figure()\n+        \n+        # Check if this is an unpickled figure with DPI doubling issue\n+        if hasattr(figure, '_original_dpi') and figure.dpi != figure._original_dpi:\n+            # Reset DPI to original value to prevent doubling\n+            figure.dpi = figure._original_dpi\n+        \n         figure.set_canvas(self)\n         self.figure = figure\n         self.manager = None\n@@ -1653,7 +1660,9 @@ class FigureCanvasBase:\n         self.toolbar = None  # NavigationToolbar2 will set me\n         self._is_idle_drawing = False\n         # We don't want to scale up the figure DPI more than once.\n-        figure._original_dpi = figure.dpi\n+        # Only set _original_dpi if it doesn't already exist (e.g., from unpickling)\n+        if not hasattr(figure, '_original_dpi'):\n+            figure._original_dpi = figure.dpi\n         self._device_pixel_ratio = 1\n         super().__init__()  # Typically the GUI widget init (if any).\n \n@@ -3506,10 +3515,22 @@ class _Backend:\n         fig = fig_cls(*args, **kwargs)\n         return cls.new_figure_manager_given_figure(num, fig)\n \n+    @classmethod\n+\n     @classmethod\n     def new_figure_manager_given_figure(cls, num, figure):\n         \"\"\"Create a new figure manager instance for the given figure.\"\"\"\n-        return cls.FigureCanvas.new_manager(figure, num)\n+        # Preserve DPI state during canvas creation to prevent doubling during unpickling\n+        original_dpi = getattr(figure, '_original_dpi', None)\n+        current_dpi = figure.dpi\n+        \n+        manager = cls.FigureCanvas.new_manager(figure, num)\n+        \n+        # Restore DPI state if it was modified during canvas creation\n+        if original_dpi is not None and hasattr(figure, '_original_dpi'):\n+            figure._original_dpi = original_dpi\n+        \n+        return manager\n \n     @classmethod\n     def draw_if_interactive(cls):\ndiff --git a/lib/matplotlib/backends/backend_macosx.py b/lib/matplotlib/backends/backend_macosx.py\nindex 700d1d4c58..df0754f0fc 100644\n--- a/lib/matplotlib/backends/backend_macosx.py\n+++ b/lib/matplotlib/backends/backend_macosx.py\n@@ -35,7 +35,12 @@ class FigureCanvasMac(FigureCanvasAgg, _macosx.FigureCanvas, FigureCanvasBase):\n     _timer_cls = TimerMac\n     manager_class = _api.classproperty(lambda cls: FigureManagerMac)\n \n+\n     def __init__(self, figure):\n+        # Safety check for DPI overflow before canvas initialization\n+        if hasattr(figure, '_original_dpi') and figure.dpi > figure._original_dpi * 2:\n+            # Reset to original DPI to prevent overflow\n+            figure.dpi = figure._original_dpi\n         super().__init__(figure=figure)\n         self._draw_pending = False\n         self._is_drawing = False\ndiff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex c55864243a..29186de909 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -3046,16 +3046,28 @@ class Figure(FigureBase):\n         # re-initialise some of the unstored state information\n         FigureCanvasBase(self)  # Set self.canvas.\n \n+        if restore_to_pylab:\n+            # lazy import to avoid circularity\n+            import matplotlib.pyplot as plt\n+\n         if restore_to_pylab:\n             # lazy import to avoid circularity\n             import matplotlib.pyplot as plt\n             import matplotlib._pylab_helpers as pylab_helpers\n+            \n+            # Preserve original DPI before creating new figure manager\n+            original_dpi = getattr(self, '_original_dpi', self.dpi)\n+            \n             allnums = plt.get_fignums()\n             num = max(allnums) + 1 if allnums else 1\n             mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n+            \n+            # Restore original DPI if it was doubled during canvas creation\n+            if hasattr(self, '_original_dpi') and self.dpi != original_dpi:\n+                self.dpi = original_dpi\n+            \n             pylab_helpers.Gcf._set_new_active_manager(mgr)\n             plt.draw_if_interactive()\n-\n         self.stale = True\n \n     def add_axobserver(self, func):\n",
    "variant_7": "diff --git a/lib/matplotlib/backend_bases.py b/lib/matplotlib/backend_bases.py\nindex 9ae2982c62..704832aac3 100644\n--- a/lib/matplotlib/backend_bases.py\n+++ b/lib/matplotlib/backend_bases.py\n@@ -1635,48 +1635,58 @@ class FigureCanvasBase:\n         return (hasattr(cls, \"copy_from_bbox\")\n                 and hasattr(cls, \"restore_region\"))\n \n-    def __init__(self, figure=None):\n-        from matplotlib.figure import Figure\n-        self._fix_ipython_backend2gui()\n-        self._is_idle_drawing = True\n-        self._is_saving = False\n-        if figure is None:\n-            figure = Figure()\n-        figure.set_canvas(self)\n-        self.figure = figure\n-        self.manager = None\n-        self.widgetlock = widgets.LockDraw()\n-        self._button = None  # the button pressed\n-        self._key = None  # the key pressed\n-        self._lastx, self._lasty = None, None\n-        self.mouse_grabber = None  # the Axes currently grabbing mouse\n-        self.toolbar = None  # NavigationToolbar2 will set me\n-        self._is_idle_drawing = False\n-        # We don't want to scale up the figure DPI more than once.\n-        figure._original_dpi = figure.dpi\n-        self._device_pixel_ratio = 1\n-        super().__init__()  # Typically the GUI widget init (if any).\n \n-    callbacks = property(lambda self: self.figure._canvas_callbacks)\n-    button_pick_id = property(lambda self: self.figure._button_pick_id)\n-    scroll_pick_id = property(lambda self: self.figure._scroll_pick_id)\n-\n-    @classmethod\n-    @functools.lru_cache()\n-    def _fix_ipython_backend2gui(cls):\n-        # Fix hard-coded module -> toolkit mapping in IPython (used for\n-        # `ipython --auto`).  This cannot be done at import time due to\n-        # ordering issues, so we do it when creating a canvas, and should only\n-        # be done once per class (hence the `lru_cache(1)`).\n-        if sys.modules.get(\"IPython\") is None:\n-            return\n-        import IPython\n-        ip = IPython.get_ipython()\n-        if not ip:\n-            return\n-        from IPython.core import pylabtools as pt\n-        if (not hasattr(pt, \"backend2gui\")\n-                or not hasattr(ip, \"enable_matplotlib\")):\n+def __init__(self, figure=None):\n+    from matplotlib.figure import Figure\n+    self._fix_ipython_backend2gui()\n+    self._is_idle_drawing = True\n+    self._is_saving = False\n+    if figure is None:\n+        figure = Figure()\n+    \n+    # Check if this is an unpickled figure with DPI issues\n+    if hasattr(figure, '_original_dpi'):\n+        # This is an unpickled figure, restore original DPI if it was doubled\n+        if figure.dpi != figure._original_dpi:\n+            figure.dpi = figure._original_dpi\n+    \n+    figure.set_canvas(self)\n+    self.figure = figure\n+    self.manager = None\n+    self.widgetlock = widgets.LockDraw()\n+    self._button = None  # the button pressed\n+    self._key = None  # the key pressed\n+    self._lastx, self._lasty = None, None\n+    self.mouse_grabber = None  # the Axes currently grabbing mouse\n+    self.toolbar = None  # NavigationToolbar2 will set me\n+    self._is_idle_drawing = False\n+    # We don't want to scale up the figure DPI more than once.\n+    # Only set _original_dpi if it doesn't already exist (from unpickling)\n+    if not hasattr(figure, '_original_dpi'):\n+        figure._original_dpi = figure.dpi\n+    self._device_pixel_ratio = 1\n+    super().__init__()  # Typically the GUI widget init (if any).\n+\n+callbacks = property(lambda self: self.figure._canvas_callbacks)\n+button_pick_id = property(lambda self: self.figure._button_pick_id)\n+scroll_pick_id = property(lambda self: self.figure._scroll_pick_id)\n+\n+@classmethod\n+@functools.lru_cache()\n+def _fix_ipython_backend2gui(cls):\n+    # Fix hard-coded module -> toolkit mapping in IPython (used for\n+    # `ipython --auto`).  This cannot be done at import time due to\n+    # ordering issues, so we do it when creating a canvas, and should only\n+    # be done once per class (hence the `lru_cache(1)`).\n+    if sys.modules.get(\"IPython\") is None:\n+        return\n+    import IPython\n+    ip = IPython.get_ipython()\n+    if not ip:\n+        return\n+    from IPython.core import pylabtools as pt\n+    if (not hasattr(pt, \"backend2gui\")\n+            or not hasattr(ip, \"enable_matplotlib\")):\n             # In case we ever move the patch to IPython and remove these APIs,\n             # don't break on our side.\n             return\n@@ -3506,10 +3516,22 @@ class _Backend:\n         fig = fig_cls(*args, **kwargs)\n         return cls.new_figure_manager_given_figure(num, fig)\n \n+    @classmethod\n+\n     @classmethod\n     def new_figure_manager_given_figure(cls, num, figure):\n         \"\"\"Create a new figure manager instance for the given figure.\"\"\"\n-        return cls.FigureCanvas.new_manager(figure, num)\n+        # Preserve DPI state during canvas creation to prevent doubling during unpickling\n+        original_dpi = getattr(figure, '_original_dpi', None)\n+        current_dpi = figure.dpi\n+        \n+        manager = cls.FigureCanvas.new_manager(figure, num)\n+        \n+        # Restore original DPI if it was preserved and differs from current\n+        if original_dpi is not None and current_dpi != original_dpi:\n+            figure.dpi = original_dpi\n+            \n+        return manager\n \n     @classmethod\n     def draw_if_interactive(cls):\ndiff --git a/lib/matplotlib/backends/backend_macosx.py b/lib/matplotlib/backends/backend_macosx.py\nindex 700d1d4c58..8bbd0d078a 100644\n--- a/lib/matplotlib/backends/backend_macosx.py\n+++ b/lib/matplotlib/backends/backend_macosx.py\n@@ -35,9 +35,15 @@ class FigureCanvasMac(FigureCanvasAgg, _macosx.FigureCanvas, FigureCanvasBase):\n     _timer_cls = TimerMac\n     manager_class = _api.classproperty(lambda cls: FigureManagerMac)\n \n-    def __init__(self, figure):\n-        super().__init__(figure=figure)\n-        self._draw_pending = False\n+\n+def __init__(self, figure):\n+    # Preserve original DPI if this is an unpickled figure\n+    if hasattr(figure, '_original_dpi') and figure.dpi != figure._original_dpi:\n+        # Reset to original DPI to prevent overflow from DPI doubling\n+        figure.dpi = figure._original_dpi\n+    \n+    super().__init__(figure=figure)\n+    self._draw_pending = False\n         self._is_drawing = False\n \n     def draw(self):\ndiff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex c55864243a..3596af1f96 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -3046,16 +3046,29 @@ class Figure(FigureBase):\n         # re-initialise some of the unstored state information\n         FigureCanvasBase(self)  # Set self.canvas.\n \n+        if restore_to_pylab:\n+            # lazy import to avoid circularity\n+            import matplotlib.pyplot as plt\n+\n         if restore_to_pylab:\n             # lazy import to avoid circularity\n             import matplotlib.pyplot as plt\n             import matplotlib._pylab_helpers as pylab_helpers\n+            \n+            # Preserve original DPI before creating figure manager to prevent doubling\n+            original_dpi = getattr(self, '_original_dpi', self.dpi)\n+            self._original_dpi = original_dpi\n+            \n             allnums = plt.get_fignums()\n             num = max(allnums) + 1 if allnums else 1\n             mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n+            \n+            # Restore original DPI after canvas creation\n+            if hasattr(self, '_original_dpi') and self.dpi != self._original_dpi:\n+                self.dpi = self._original_dpi\n+                \n             pylab_helpers.Gcf._set_new_active_manager(mgr)\n             plt.draw_if_interactive()\n-\n         self.stale = True\n \n     def add_axobserver(self, func):\n",
    "variant_8": "diff --git a/lib/matplotlib/backend_bases.py b/lib/matplotlib/backend_bases.py\nindex 9ae2982c62..2b41e8788a 100644\n--- a/lib/matplotlib/backend_bases.py\n+++ b/lib/matplotlib/backend_bases.py\n@@ -1635,6 +1635,7 @@ class FigureCanvasBase:\n         return (hasattr(cls, \"copy_from_bbox\")\n                 and hasattr(cls, \"restore_region\"))\n \n+\n     def __init__(self, figure=None):\n         from matplotlib.figure import Figure\n         self._fix_ipython_backend2gui()\n@@ -1642,6 +1643,12 @@ class FigureCanvasBase:\n         self._is_saving = False\n         if figure is None:\n             figure = Figure()\n+        \n+        # Check if this is an unpickled figure with doubled DPI\n+        if hasattr(figure, '_original_dpi') and figure.dpi != figure._original_dpi:\n+            # Reset to original DPI to prevent accumulating DPI scaling\n+            figure.dpi = figure._original_dpi\n+        \n         figure.set_canvas(self)\n         self.figure = figure\n         self.manager = None\n@@ -1653,7 +1660,9 @@ class FigureCanvasBase:\n         self.toolbar = None  # NavigationToolbar2 will set me\n         self._is_idle_drawing = False\n         # We don't want to scale up the figure DPI more than once.\n-        figure._original_dpi = figure.dpi\n+        # Only set _original_dpi if it doesn't already exist (not an unpickled figure)\n+        if not hasattr(figure, '_original_dpi'):\n+            figure._original_dpi = figure.dpi\n         self._device_pixel_ratio = 1\n         super().__init__()  # Typically the GUI widget init (if any).\n \n@@ -3506,10 +3515,22 @@ class _Backend:\n         fig = fig_cls(*args, **kwargs)\n         return cls.new_figure_manager_given_figure(num, fig)\n \n+    @classmethod\n+\n     @classmethod\n     def new_figure_manager_given_figure(cls, num, figure):\n         \"\"\"Create a new figure manager instance for the given figure.\"\"\"\n-        return cls.FigureCanvas.new_manager(figure, num)\n+        # Preserve DPI state during canvas creation to prevent doubling during unpickling\n+        original_dpi = getattr(figure, '_original_dpi', figure.dpi)\n+        current_dpi = figure.dpi\n+        \n+        manager = cls.FigureCanvas.new_manager(figure, num)\n+        \n+        # Restore original DPI if it was modified during canvas creation\n+        if hasattr(figure, '_original_dpi') and figure.dpi != current_dpi:\n+            figure.dpi = original_dpi\n+            \n+        return manager\n \n     @classmethod\n     def draw_if_interactive(cls):\ndiff --git a/lib/matplotlib/backends/backend_macosx.py b/lib/matplotlib/backends/backend_macosx.py\nindex 700d1d4c58..7c6df1b273 100644\n--- a/lib/matplotlib/backends/backend_macosx.py\n+++ b/lib/matplotlib/backends/backend_macosx.py\n@@ -35,7 +35,26 @@ class FigureCanvasMac(FigureCanvasAgg, _macosx.FigureCanvas, FigureCanvasBase):\n     _timer_cls = TimerMac\n     manager_class = _api.classproperty(lambda cls: FigureManagerMac)\n \n+\n     def __init__(self, figure):\n+        # Check if figure dimensions would cause overflow due to DPI doubling\n+        # This can happen during unpickling on M1 Macs\n+        try:\n+            # Test if figure dimensions are reasonable\n+            width_pixels = figure.bbox.width\n+            height_pixels = figure.bbox.height\n+            if width_pixels > 32767 or height_pixels > 32767:\n+                # Dimensions too large, likely due to DPI doubling\n+                if hasattr(figure, '_original_dpi'):\n+                    figure.dpi = figure._original_dpi\n+                else:\n+                    # Fallback: halve the DPI to undo doubling\n+                    figure.dpi = figure.dpi / 2\n+        except (AttributeError, OverflowError):\n+            # If we can't check dimensions, ensure DPI is reasonable\n+            if hasattr(figure, '_original_dpi') and figure.dpi != figure._original_dpi:\n+                figure.dpi = figure._original_dpi\n+        \n         super().__init__(figure=figure)\n         self._draw_pending = False\n         self._is_drawing = False\ndiff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex c55864243a..24cce9565d 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -3046,16 +3046,29 @@ class Figure(FigureBase):\n         # re-initialise some of the unstored state information\n         FigureCanvasBase(self)  # Set self.canvas.\n \n+        if restore_to_pylab:\n+            # lazy import to avoid circularity\n+            import matplotlib.pyplot as plt\n+\n         if restore_to_pylab:\n             # lazy import to avoid circularity\n             import matplotlib.pyplot as plt\n             import matplotlib._pylab_helpers as pylab_helpers\n+            \n+            # Store original DPI before creating new manager to prevent doubling\n+            original_dpi = getattr(self, '_original_dpi', self.dpi)\n+            self._original_dpi = original_dpi\n+            \n             allnums = plt.get_fignums()\n             num = max(allnums) + 1 if allnums else 1\n             mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n+            \n+            # Restore original DPI after manager creation\n+            if hasattr(self, '_original_dpi') and self.dpi != self._original_dpi:\n+                self.dpi = self._original_dpi\n+            \n             pylab_helpers.Gcf._set_new_active_manager(mgr)\n             plt.draw_if_interactive()\n-\n         self.stale = True\n \n     def add_axobserver(self, func):\n"
  }
}