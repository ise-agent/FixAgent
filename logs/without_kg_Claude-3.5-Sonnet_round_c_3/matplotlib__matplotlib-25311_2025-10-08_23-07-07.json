{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/matplotlib/lib/matplotlib/offsetbox.py lines 1503-1515)": "\n    def __init__(self, ref_artist, use_blit=False):\n        self.ref_artist = ref_artist\n        if not ref_artist.pickable():\n            ref_artist.set_picker(True)\n        self.got_artist = False\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = use_blit and self.canvas.supports_blit\n        self.cids = [\n            self.canvas.callbacks._connect_picklable(\n                'pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable(\n                'button_release_event', self.on_release),\n        ]\n\n    def __getstate__(self):\n        state = self.__dict__.copy()\n        # Remove unpicklable entries\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        self.__dict__.update(state)\n        # Canvas will be reconnected when needed\n        self._reconnect_canvas()\n\n    def _reconnect_canvas(self):\n        \"\"\"Reconnect canvas callbacks after unpickling.\"\"\"\n        if (hasattr(self, 'ref_artist') and \n            self.ref_artist.figure is not None and \n            self.ref_artist.figure.canvas is not None):\n            self.canvas = self.ref_artist.figure.canvas\n            self._use_blit = getattr(self, '_use_blit', False) and self.canvas.supports_blit\n            self.cids = [\n                self.canvas.callbacks._connect_picklable(\n                    'pick_event', self.on_pick),\n                self.canvas.callbacks._connect_picklable(\n                    'button_release_event', self.on_release),\n            ]\n",
    "Location 2 (/root/hy/projects_3/matplotlib/lib/matplotlib/offsetbox.py lines 1538-1544)": "\n    def on_pick(self, evt):\n        if self._check_still_parented() and evt.artist == self.ref_artist:\n            self.mouse_x = evt.mouseevent.x\n            self.mouse_y = evt.mouseevent.y\n            self.got_artist = True\n            if self._use_blit and hasattr(self, 'canvas') and self.canvas is not None:\n                self.ref_artist.set_animated(True)\n                self.canvas.draw()\n                self.background = \\\n                    self.canvas.copy_from_bbox(self.ref_artist.figure.bbox)\n                self.ref_artist.draw(\n                    self.ref_artist.figure._get_renderer())\n                self.canvas.blit()\n            if hasattr(self, 'canvas') and self.canvas is not None:\n                self._c1 = self.canvas.callbacks._connect_picklable(\n                    \"motion_notify_event\", self.on_motion)\n            self.save_offset()\n",
    "Location 3 (/root/hy/projects_3/matplotlib/lib/matplotlib/offsetbox.py lines 1573-1582)": "\n    def save_offset(self):\n        pass\n\n    def update_offset(self, dx, dy):\n        pass\n\n    def finalize_offset(self):\n        pass\n\n    def __getstate__(self):\n        \"\"\"Prepare state for pickling by removing unpicklable canvas references.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable entries\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore state after unpickling.\"\"\"\n        self.__dict__.update(state)\n        # Canvas will be reconnected when needed\n\n    def _reconnect_canvas(self):\n        \"\"\"Reconnect canvas if available.\"\"\"\n        if hasattr(self, 'ref_artist') and self.ref_artist.figure is not None:\n            canvas = self.ref_artist.figure.canvas\n            if canvas is not None:\n                self.canvas = canvas\n                self.cids = []\n                # Reconnect event handlers\n                self.cids.append(self.canvas.mpl_connect('pick_event', self.on_pick))\n                self.cids.append(self.canvas.mpl_connect('button_release_event', self.on_release))\n                if self.use_blit:\n                    self.cids.append(self.canvas.mpl_connect('motion_notify_event', self.on_motion_blit))\n                else:\n                    self.cids.append(self.canvas.mpl_connect('motion_notify_event', self.on_motion))\n",
    "Location 4 (/root/hy/projects_3/matplotlib/lib/matplotlib/offsetbox.py lines 1563-1572)": "\n    def disconnect(self):\n        \"\"\"Disconnect the callbacks.\"\"\"\n        if hasattr(self, 'cids'):\n            for cid in self.cids:\n                if hasattr(self, 'canvas') and self.canvas is not None:\n                    self.canvas.mpl_disconnect(cid)\n        try:\n            c1 = self._c1\n        except AttributeError:\n            pass\n        else:\n            if hasattr(self, 'canvas') and self.canvas is not None:\n                self.canvas.mpl_disconnect(c1)\n\n    def _reconnect_canvas(self):\n        \"\"\"Reconnect canvas after unpickling if figure is available.\"\"\"\n        if (hasattr(self, 'ref_artist') and self.ref_artist.figure is not None \n            and self.ref_artist.figure.canvas is not None):\n            self.canvas = self.ref_artist.figure.canvas\n            self.cids = []\n            # Re-enable picking if it was enabled before\n            if hasattr(self, 'ref_artist') and self.ref_artist.get_picker() is not None:\n                cid = self.canvas.mpl_connect('pick_event', self.on_pick)\n                self.cids.append(cid)\n",
    "Location 5 (/root/hy/projects_3/matplotlib/lib/matplotlib/legend.py lines 53-95)": "\nclass DraggableLegend(DraggableOffsetBox):\n    def __init__(self, legend, use_blit=False, update=\"loc\"):\n        \"\"\"\n        Wrapper around a `.Legend` to support mouse dragging.\n\n        Parameters\n        ----------\n        legend : `.Legend`\n            The `.Legend` instance to wrap.\n        use_blit : bool, optional\n            Use blitting for faster image composition. For details see\n            :ref:`func-animation`.\n        update : {'loc', 'bbox'}, optional\n            If \"loc\", update the *loc* parameter of the legend upon finalizing.\n            If \"bbox\", update the *bbox_to_anchor* parameter.\n        \"\"\"\n        self.legend = legend\n\n        _api.check_in_list([\"loc\", \"bbox\"], update=update)\n        self._update = update\n\n        super().__init__(legend, legend._legend_box, use_blit=use_blit)\n\n    def finalize_offset(self):\n        if self._update == \"loc\":\n            self._update_loc(self.get_loc_in_canvas())\n        elif self._update == \"bbox\":\n            self._bbox_to_anchor(self.get_loc_in_canvas())\n\n    def _update_loc(self, loc_in_canvas):\n        bbox = self.legend.get_bbox_to_anchor()\n        # if bbox has zero width or height, the transformation is\n        # ill-defined. Fall back to the default bbox_to_anchor.\n        if bbox.width == 0 or bbox.height == 0:\n            self.legend.set_bbox_to_anchor(None)\n            bbox = self.legend.get_bbox_to_anchor()\n        _bbox_transform = BboxTransformFrom(bbox)\n        self.legend._loc = tuple(_bbox_transform.transform(loc_in_canvas))\n\n    def _update_bbox_to_anchor(self, loc_in_canvas):\n        loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n        self.legend.set_bbox_to_anchor(loc_in_bbox)\n\n    def __setstate__(self, state):\n        super().__setstate__(state)\n        # Attempt to reconnect canvas if legend's figure is available\n        if (hasattr(self, 'legend') and self.legend.figure is not None \n            and self.legend.figure.canvas is not None):\n            self._reconnect_canvas()\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/matplotlib/lib/matplotlib/offsetbox.py lines 1503-1515)": [
      "\n    def __init__(self, ref_artist, use_blit=False):\n        self.ref_artist = ref_artist\n        if not ref_artist.pickable():\n            ref_artist.set_picker(True)\n        self.got_artist = False\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = use_blit and self.canvas.supports_blit\n        self.cids = [\n            self.canvas.callbacks._connect_picklable(\n                'pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable(\n                'button_release_event', self.on_release),\n        ]\n\n    def __getstate__(self):\n        state = self.__dict__.copy()\n        # Remove unpicklable entries\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        self.__dict__.update(state)\n        # Canvas will be reconnected when needed\n        if (hasattr(self, 'ref_artist') and self.ref_artist.figure is not None \n            and self.ref_artist.figure.canvas is not None):\n            self._reconnect_canvas()\n\n    def _reconnect_canvas(self):\n        \"\"\"Reconnect canvas callbacks after unpickling.\"\"\"\n        self.canvas = self.ref_artist.figure.canvas\n        self.cids = [\n            self.canvas.callbacks._connect_picklable(\n                'pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable(\n                'button_release_event', self.on_release),\n        ]\n",
      "\n    def __init__(self, ref_artist, use_blit=False):\n        self.ref_artist = ref_artist\n        if not ref_artist.pickable():\n            ref_artist.set_picker(True)\n        self.got_artist = False\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = use_blit and self.canvas.supports_blit\n        self.cids = [\n            self.canvas.callbacks._connect_picklable(\n                'pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable(\n                'button_release_event', self.on_release),\n        ]\n\n    def __getstate__(self):\n        state = self.__dict__.copy()\n        # Remove unpicklable entries\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        self.__dict__.update(state)\n        # Canvas will be reconnected when needed\n        self._reconnect_canvas()\n\n    def _reconnect_canvas(self):\n        \"\"\"Reconnect canvas callbacks after unpickling.\"\"\"\n        if (hasattr(self, 'ref_artist') and \n            self.ref_artist.figure is not None and \n            self.ref_artist.figure.canvas is not None):\n            self.canvas = self.ref_artist.figure.canvas\n            self._use_blit = getattr(self, '_use_blit', False) and self.canvas.supports_blit\n            self.cids = [\n                self.canvas.callbacks._connect_picklable(\n                    'pick_event', self.on_pick),\n                self.canvas.callbacks._connect_picklable(\n                    'button_release_event', self.on_release),\n            ]\n",
      "\n    def __init__(self, ref_artist, use_blit=False):\n        self.ref_artist = ref_artist\n        if not ref_artist.pickable():\n            ref_artist.set_picker(True)\n        self.got_artist = False\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = use_blit and self.canvas.supports_blit\n        self.cids = [\n            self.canvas.callbacks._connect_picklable(\n                'pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable(\n                'button_release_event', self.on_release),\n        ]\n\n    def __getstate__(self):\n        state = self.__dict__.copy()\n        # Remove unpicklable entries\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        self.__dict__.update(state)\n        # Canvas will be reconnected when needed\n        self._reconnect_canvas()\n\n    def _reconnect_canvas(self):\n        \"\"\"Reconnect canvas and event handlers if figure is available.\"\"\"\n        if (hasattr(self, 'ref_artist') and self.ref_artist.figure is not None \n            and self.ref_artist.figure.canvas is not None):\n            self.canvas = self.ref_artist.figure.canvas\n            self._use_blit = getattr(self, '_use_blit', False) and self.canvas.supports_blit\n            self.cids = [\n                self.canvas.callbacks._connect_picklable(\n                    'pick_event', self.on_pick),\n                self.canvas.callbacks._connect_picklable(\n                    'button_release_event', self.on_release),\n            ]\n",
      "\n    def __init__(self, ref_artist, use_blit=False):\n        self.ref_artist = ref_artist\n        if not ref_artist.pickable():\n            ref_artist.set_picker(True)\n        self.got_artist = False\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = use_blit and self.canvas.supports_blit\n        self.cids = [\n            self.canvas.callbacks._connect_picklable(\n                'pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable(\n                'button_release_event', self.on_release),\n        ]\n\n    def __getstate__(self):\n        state = self.__dict__.copy()\n        # Remove unpicklable entries\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        self.__dict__.update(state)\n        # Canvas will be reconnected when needed\n        self._reconnect_canvas()\n\n    def _reconnect_canvas(self):\n        \"\"\"Reconnect canvas callbacks if figure and canvas are available.\"\"\"\n        if (hasattr(self, 'ref_artist') and self.ref_artist is not None\n            and hasattr(self.ref_artist, 'figure') and self.ref_artist.figure is not None\n            and hasattr(self.ref_artist.figure, 'canvas') and self.ref_artist.figure.canvas is not None):\n            self.canvas = self.ref_artist.figure.canvas\n            self._use_blit = getattr(self, '_use_blit', False) and self.canvas.supports_blit\n            self.cids = [\n                self.canvas.callbacks._connect_picklable(\n                    'pick_event', self.on_pick),\n                self.canvas.callbacks._connect_picklable(\n                    'button_release_event', self.on_release),\n            ]\n",
      "\n    def __init__(self, ref_artist, use_blit=False):\n        self.ref_artist = ref_artist\n        if not ref_artist.pickable():\n            ref_artist.set_picker(True)\n        self.got_artist = False\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = use_blit and self.canvas.supports_blit\n        self.cids = [\n            self.canvas.callbacks._connect_picklable(\n                'pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable(\n                'button_release_event', self.on_release),\n        ]\n\n    def __getstate__(self):\n        state = self.__dict__.copy()\n        # Remove unpicklable entries\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        self.__dict__.update(state)\n        # Canvas will be reconnected when needed\n        self._reconnect_canvas()\n\n    def _reconnect_canvas(self):\n        \"\"\"Reconnect canvas callbacks after unpickling.\"\"\"\n        if (hasattr(self, 'ref_artist') and self.ref_artist is not None \n            and self.ref_artist.figure is not None \n            and self.ref_artist.figure.canvas is not None):\n            self.canvas = self.ref_artist.figure.canvas\n            self._use_blit = getattr(self, '_use_blit', False) and self.canvas.supports_blit\n            self.cids = [\n                self.canvas.callbacks._connect_picklable(\n                    'pick_event', self.on_pick),\n                self.canvas.callbacks._connect_picklable(\n                    'button_release_event', self.on_release),\n            ]\n",
      "\n    def __init__(self, ref_artist, use_blit=False):\n        self.ref_artist = ref_artist\n        if not ref_artist.pickable():\n            ref_artist.set_picker(True)\n        self.got_artist = False\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = use_blit and self.canvas.supports_blit\n        self.cids = [\n            self.canvas.callbacks._connect_picklable(\n                'pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable(\n                'button_release_event', self.on_release),\n        ]\n\n    def __getstate__(self):\n        state = self.__dict__.copy()\n        # Remove unpicklable entries\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        self.__dict__.update(state)\n        # Canvas will be reconnected when needed\n        self.canvas = None\n        self.cids = []\n        self._reconnect_canvas()\n\n    def _reconnect_canvas(self):\n        \"\"\"Reconnect to canvas if figure and canvas are available.\"\"\"\n        if (hasattr(self, 'ref_artist') and self.ref_artist is not None and\n            hasattr(self.ref_artist, 'figure') and self.ref_artist.figure is not None and\n            hasattr(self.ref_artist.figure, 'canvas') and self.ref_artist.figure.canvas is not None):\n            self.canvas = self.ref_artist.figure.canvas\n            self._use_blit = getattr(self, '_use_blit', False) and self.canvas.supports_blit\n            self.cids = [\n                self.canvas.callbacks._connect_picklable(\n                    'pick_event', self.on_pick),\n                self.canvas.callbacks._connect_picklable(\n                    'button_release_event', self.on_release),\n            ]\n",
      "\n    def __init__(self, ref_artist, use_blit=False):\n        self.ref_artist = ref_artist\n        if not ref_artist.pickable():\n            ref_artist.set_picker(True)\n        self.got_artist = False\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = use_blit and self.canvas.supports_blit\n        self.cids = [\n            self.canvas.callbacks._connect_picklable(\n                'pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable(\n                'button_release_event', self.on_release),\n        ]\n\n    def __getstate__(self):\n        state = self.__dict__.copy()\n        # Remove unpicklable entries\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        self.__dict__.update(state)\n        # Canvas will be reconnected when needed\n        self._reconnect_canvas()\n\n    def _reconnect_canvas(self):\n        \"\"\"Reconnect canvas callbacks after unpickling.\"\"\"\n        if (hasattr(self, 'ref_artist') and \n            hasattr(self.ref_artist, 'figure') and \n            self.ref_artist.figure is not None and\n            hasattr(self.ref_artist.figure, 'canvas') and\n            self.ref_artist.figure.canvas is not None):\n            self.canvas = self.ref_artist.figure.canvas\n            self._use_blit = getattr(self, '_use_blit', False) and self.canvas.supports_blit\n            self.cids = [\n                self.canvas.callbacks._connect_picklable(\n                    'pick_event', self.on_pick),\n                self.canvas.callbacks._connect_picklable(\n                    'button_release_event', self.on_release),\n            ]\n",
      "\n    def __init__(self, ref_artist, use_blit=False):\n        self.ref_artist = ref_artist\n        if not ref_artist.pickable():\n            ref_artist.set_picker(True)\n        self.got_artist = False\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = use_blit and self.canvas.supports_blit\n        self.cids = [\n            self.canvas.callbacks._connect_picklable(\n                'pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable(\n                'button_release_event', self.on_release),\n        ]\n\n    def __getstate__(self):\n        state = self.__dict__.copy()\n        # Remove unpicklable entries\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        self.__dict__.update(state)\n        # Canvas will be reconnected when needed\n        self._reconnect_canvas()\n\n    def _reconnect_canvas(self):\n        \"\"\"Reconnect canvas callbacks if figure and canvas are available.\"\"\"\n        if (hasattr(self, 'ref_artist') and self.ref_artist is not None\n            and hasattr(self.ref_artist, 'figure') and self.ref_artist.figure is not None\n            and hasattr(self.ref_artist.figure, 'canvas') and self.ref_artist.figure.canvas is not None):\n            self.canvas = self.ref_artist.figure.canvas\n            self._use_blit = getattr(self, '_use_blit', False) and self.canvas.supports_blit\n            self.cids = [\n                self.canvas.callbacks._connect_picklable(\n                    'pick_event', self.on_pick),\n                self.canvas.callbacks._connect_picklable(\n                    'button_release_event', self.on_release),\n            ]\n"
    ],
    "Location 2 (/root/hy/projects_3/matplotlib/lib/matplotlib/offsetbox.py lines 1538-1544)": [
      "\n    def on_pick(self, evt):\n        if self._check_still_parented() and evt.artist == self.ref_artist:\n            self.mouse_x = evt.mouseevent.x\n            self.mouse_y = evt.mouseevent.y\n            self.got_artist = True\n            if self._use_blit and hasattr(self, 'canvas') and self.canvas is not None:\n                self.ref_artist.set_animated(True)\n                self.canvas.draw()\n                self.background = \\\n                    self.canvas.copy_from_bbox(self.ref_artist.figure.bbox)\n                self.ref_artist.draw(\n                    self.ref_artist.figure._get_renderer())\n                self.canvas.blit()\n            if hasattr(self, 'canvas') and self.canvas is not None:\n                self._c1 = self.canvas.callbacks._connect_picklable(\n                    \"motion_notify_event\", self.on_motion)\n            self.save_offset()\n",
      "\n    def on_pick(self, evt):\n        if self._check_still_parented() and evt.artist == self.ref_artist:\n            self.mouse_x = evt.mouseevent.x\n            self.mouse_y = evt.mouseevent.y\n            self.got_artist = True\n            if self._use_blit:\n                self.ref_artist.set_animated(True)\n                if hasattr(self, 'canvas') and self.canvas is not None:\n                    self.canvas.draw()\n                    self.background = \\\n                        self.canvas.copy_from_bbox(self.ref_artist.figure.bbox)\n                    self.ref_artist.draw(\n                        self.ref_artist.figure._get_renderer())\n                    self.canvas.blit()\n            if hasattr(self, 'canvas') and self.canvas is not None:\n                self._c1 = self.canvas.callbacks._connect_picklable(\n                    \"motion_notify_event\", self.on_motion)\n            self.save_offset()\n",
      "\n    def on_pick(self, evt):\n        if self._check_still_parented() and evt.artist == self.ref_artist:\n            self.mouse_x = evt.mouseevent.x\n            self.mouse_y = evt.mouseevent.y\n            self.got_artist = True\n            if self._use_blit and hasattr(self, 'canvas') and self.canvas is not None:\n                self.ref_artist.set_animated(True)\n                self.canvas.draw()\n                self.background = \\\n                    self.canvas.copy_from_bbox(self.ref_artist.figure.bbox)\n                self.ref_artist.draw(\n                    self.ref_artist.figure._get_renderer())\n                self.canvas.blit()\n            if hasattr(self, 'canvas') and self.canvas is not None:\n                self._c1 = self.canvas.callbacks._connect_picklable(\n                    \"motion_notify_event\", self.on_motion)\n            self.save_offset()\n",
      "\n    def on_pick(self, evt):\n        if self._check_still_parented() and evt.artist == self.ref_artist:\n            self.mouse_x = evt.mouseevent.x\n            self.mouse_y = evt.mouseevent.y\n            self.got_artist = True\n            if self._use_blit and hasattr(self, 'canvas') and self.canvas is not None:\n                self.ref_artist.set_animated(True)\n                self.canvas.draw()\n                self.background = \\\n                    self.canvas.copy_from_bbox(self.ref_artist.figure.bbox)\n                self.ref_artist.draw(\n                    self.ref_artist.figure._get_renderer())\n                self.canvas.blit()\n            if hasattr(self, 'canvas') and self.canvas is not None:\n                self._c1 = self.canvas.callbacks._connect_picklable(\n                    \"motion_notify_event\", self.on_motion)\n            self.save_offset()\n",
      "\n    def on_pick(self, evt):\n        if self._check_still_parented() and evt.artist == self.ref_artist:\n            self.mouse_x = evt.mouseevent.x\n            self.mouse_y = evt.mouseevent.y\n            self.got_artist = True\n            if self._use_blit and hasattr(self, 'canvas') and self.canvas is not None:\n                self.ref_artist.set_animated(True)\n                self.canvas.draw()\n                self.background = \\\n                    self.canvas.copy_from_bbox(self.ref_artist.figure.bbox)\n                self.ref_artist.draw(\n                    self.ref_artist.figure._get_renderer())\n                self.canvas.blit()\n            if hasattr(self, 'canvas') and self.canvas is not None:\n                self._c1 = self.canvas.callbacks._connect_picklable(\n                    \"motion_notify_event\", self.on_motion)\n            self.save_offset()\n",
      "\n    def on_pick(self, evt):\n        if self._check_still_parented() and evt.artist == self.ref_artist:\n            self.mouse_x = evt.mouseevent.x\n            self.mouse_y = evt.mouseevent.y\n            self.got_artist = True\n            if self._use_blit and hasattr(self, 'canvas') and self.canvas is not None:\n                self.ref_artist.set_animated(True)\n                self.canvas.draw()\n                self.background = \\\n                    self.canvas.copy_from_bbox(self.ref_artist.figure.bbox)\n                self.ref_artist.draw(\n                    self.ref_artist.figure._get_renderer())\n                self.canvas.blit()\n            if hasattr(self, 'canvas') and self.canvas is not None:\n                self._c1 = self.canvas.callbacks._connect_picklable(\n                    \"motion_notify_event\", self.on_motion)\n            self.save_offset()\n",
      "\n    def on_pick(self, evt):\n        if self._check_still_parented() and evt.artist == self.ref_artist:\n            self.mouse_x = evt.mouseevent.x\n            self.mouse_y = evt.mouseevent.y\n            self.got_artist = True\n            if self._use_blit and hasattr(self, 'canvas') and self.canvas is not None:\n                self.ref_artist.set_animated(True)\n                self.canvas.draw()\n                self.background = \\\n                    self.canvas.copy_from_bbox(self.ref_artist.figure.bbox)\n                self.ref_artist.draw(\n                    self.ref_artist.figure._get_renderer())\n                self.canvas.blit()\n            if hasattr(self, 'canvas') and self.canvas is not None:\n                self._c1 = self.canvas.callbacks._connect_picklable(\n                    \"motion_notify_event\", self.on_motion)\n            self.save_offset()\n",
      "\n    def on_pick(self, evt):\n        if self._check_still_parented() and evt.artist == self.ref_artist:\n            self.mouse_x = evt.mouseevent.x\n            self.mouse_y = evt.mouseevent.y\n            self.got_artist = True\n            if self._use_blit and hasattr(self, 'canvas') and self.canvas is not None:\n                self.ref_artist.set_animated(True)\n                self.canvas.draw()\n                self.background = \\\n                    self.canvas.copy_from_bbox(self.ref_artist.figure.bbox)\n                self.ref_artist.draw(\n                    self.ref_artist.figure._get_renderer())\n                self.canvas.blit()\n            if hasattr(self, 'canvas') and self.canvas is not None:\n                self._c1 = self.canvas.callbacks._connect_picklable(\n                    \"motion_notify_event\", self.on_motion)\n            self.save_offset()\n"
    ],
    "Location 3 (/root/hy/projects_3/matplotlib/lib/matplotlib/offsetbox.py lines 1573-1582)": [
      "\n    def save_offset(self):\n        pass\n\n    def update_offset(self, dx, dy):\n        pass\n\n    def finalize_offset(self):\n        pass\n\n    def __getstate__(self):\n        \"\"\"Remove unpicklable canvas references when pickling.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable entries\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore state after unpickling.\"\"\"\n        self.__dict__.update(state)\n        # Canvas will be reconnected when needed\n\n    def _reconnect_canvas(self):\n        \"\"\"Reconnect canvas if available.\"\"\"\n        if (hasattr(self, 'ref_artist') and self.ref_artist is not None \n            and hasattr(self.ref_artist, 'figure') and self.ref_artist.figure is not None\n            and hasattr(self.ref_artist.figure, 'canvas') and self.ref_artist.figure.canvas is not None):\n            self.canvas = self.ref_artist.figure.canvas\n            self.cids = []\n            # Reconnect the callbacks\n            self.cids.append(self.canvas.mpl_connect(\"pick_event\", self.on_pick))\n            self.cids.append(self.canvas.mpl_connect(\"button_release_event\", self.on_release))\n",
      "\n    def save_offset(self):\n        pass\n\n    def update_offset(self, dx, dy):\n        pass\n\n    def finalize_offset(self):\n        pass\n\n    def __getstate__(self):\n        \"\"\"Return state for pickling, excluding unpicklable canvas references.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable entries\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore state from pickling.\"\"\"\n        self.__dict__.update(state)\n        # Canvas will be reconnected when needed\n\n    def _reconnect_canvas(self):\n        \"\"\"Reconnect canvas if available.\"\"\"\n        if (hasattr(self, 'ref_artist') and self.ref_artist is not None and\n            hasattr(self.ref_artist, 'figure') and self.ref_artist.figure is not None and\n            hasattr(self.ref_artist.figure, 'canvas') and self.ref_artist.figure.canvas is not None):\n            self.canvas = self.ref_artist.figure.canvas\n            self.cids = []\n            # Reconnect event handlers\n            self.cids.append(self.canvas.mpl_connect(\"pick_event\", self.on_pick))\n            self.cids.append(self.canvas.mpl_connect(\"button_release_event\", self.on_release))\n",
      "\n    def disconnect(self):\n        \"\"\"Disconnect the callbacks.\"\"\"\n        for cid in self.cids:\n            self.canvas.mpl_disconnect(cid)\n        try:\n            c1 = self._c1\n        except AttributeError:\n            pass\n        else:\n            self.canvas.mpl_disconnect(c1)\n\n    def save_offset(self):\n        pass\n\n    def update_offset(self, dx, dy):\n        pass\n\n    def finalize_offset(self):\n        pass\n\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by removing unpicklable canvas references.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable entries\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling.\"\"\"\n        self.__dict__.update(state)\n        # Canvas will be reconnected when needed\n\n    def _reconnect_canvas(self):\n        \"\"\"Reconnect canvas if available.\"\"\"\n        if (hasattr(self, 'ref_artist') and self.ref_artist.figure is not None \n            and self.ref_artist.figure.canvas is not None):\n            self.canvas = self.ref_artist.figure.canvas\n            self.cids = []\n",
      "\n    def save_offset(self):\n        pass\n\n    def update_offset(self, dx, dy):\n        pass\n\n    def finalize_offset(self):\n        pass\n\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by removing unpicklable references.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable canvas-related attributes\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling.\"\"\"\n        self.__dict__.update(state)\n        # Canvas and event connections will be restored when needed\n\n    def _reconnect_canvas(self):\n        \"\"\"Reconnect to canvas if available.\"\"\"\n        if (hasattr(self, 'ref_artist') and self.ref_artist is not None \n            and hasattr(self.ref_artist, 'figure') and self.ref_artist.figure is not None\n            and hasattr(self.ref_artist.figure, 'canvas') and self.ref_artist.figure.canvas is not None):\n            self.canvas = self.ref_artist.figure.canvas\n            self.cids = []\n            if hasattr(self, 'use_blit') and self.use_blit:\n                self.cids.append(self.canvas.mpl_connect(\"draw_event\", self.on_draw))\n",
      "\n    def save_offset(self):\n        pass\n\n    def update_offset(self, dx, dy):\n        pass\n\n    def finalize_offset(self):\n        pass\n\n    def __getstate__(self):\n        \"\"\"Remove unpicklable attributes when pickling.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable entries\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore state when unpickling.\"\"\"\n        self.__dict__.update(state)\n        # Canvas will be reconnected when needed\n\n    def _reconnect_canvas(self):\n        \"\"\"Reconnect canvas connections if figure is available.\"\"\"\n        if (hasattr(self, 'ref_artist') and self.ref_artist.figure is not None \n            and self.ref_artist.figure.canvas is not None):\n            self.canvas = self.ref_artist.figure.canvas\n            self.cids = [\n                self.canvas.mpl_connect('pick_event', self.on_pick),\n                self.canvas.mpl_connect('button_release_event', self.on_release),\n            ]\n",
      "\n    def save_offset(self):\n        pass\n\n    def update_offset(self, dx, dy):\n        pass\n\n    def finalize_offset(self):\n        pass\n\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by removing unpicklable canvas references.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable entries\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object from pickle and attempt to reconnect canvas if available.\"\"\"\n        self.__dict__.update(state)\n        # Canvas will be reconnected when needed\n        self._reconnect_canvas()\n\n    def _reconnect_canvas(self):\n        \"\"\"Reconnect to canvas if ref_artist has a figure with canvas.\"\"\"\n        if (hasattr(self, 'ref_artist') and self.ref_artist is not None and\n            hasattr(self.ref_artist, 'figure') and self.ref_artist.figure is not None and\n            hasattr(self.ref_artist.figure, 'canvas') and self.ref_artist.figure.canvas is not None):\n            self.canvas = self.ref_artist.figure.canvas\n            self.cids = []\n            # Reconnect event handlers\n            self.cids.append(self.canvas.mpl_connect(\"pick_event\", self.on_pick))\n            self.cids.append(self.canvas.mpl_connect(\"button_release_event\", self.on_release))\n",
      "\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by removing unpicklable canvas references.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable entries\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling.\"\"\"\n        self.__dict__.update(state)\n        # Canvas will be reconnected when needed\n\n    def _reconnect_canvas(self):\n        \"\"\"Reconnect canvas and event handlers if figure is available.\"\"\"\n        if (hasattr(self, 'ref_artist') and self.ref_artist is not None \n            and hasattr(self.ref_artist, 'figure') and self.ref_artist.figure is not None\n            and self.ref_artist.figure.canvas is not None):\n            self.canvas = self.ref_artist.figure.canvas\n            self.cids = [\n                self.canvas.mpl_connect('pick_event', self.on_pick),\n                self.canvas.mpl_connect('button_release_event', self.on_release),\n            ]\n            if self.use_blit:\n                self.cids.append(\n                    self.canvas.mpl_connect('draw_event', self.on_draw)\n                )\n",
      "\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by removing unpicklable canvas references.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable entries\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object from pickle and prepare for canvas reconnection.\"\"\"\n        self.__dict__.update(state)\n        # Canvas will be reconnected when needed\n\n    def _reconnect_canvas(self):\n        \"\"\"Reconnect canvas and event handlers when figure becomes available.\"\"\"\n        if (hasattr(self, 'ref_artist') and \n            self.ref_artist.figure is not None and \n            self.ref_artist.figure.canvas is not None):\n            self.canvas = self.ref_artist.figure.canvas\n            self.cids = [\n                self.canvas.mpl_connect('pick_event', self.on_pick),\n                self.canvas.mpl_connect('button_release_event', self.on_release),\n            ]\n"
    ],
    "Location 4 (/root/hy/projects_3/matplotlib/lib/matplotlib/offsetbox.py lines 1563-1572)": [
      "\n    def disconnect(self):\n        \"\"\"Disconnect the callbacks.\"\"\"\n        for cid in self.cids:\n            self.canvas.mpl_disconnect(cid)\n        try:\n            c1 = self._c1\n        except AttributeError:\n            pass\n        else:\n            self.canvas.mpl_disconnect(c1)\n\n    def _reconnect_canvas(self):\n        \"\"\"Reconnect canvas connections after unpickling.\"\"\"\n        if (hasattr(self, 'ref_artist') and self.ref_artist is not None \n            and self.ref_artist.figure is not None \n            and self.ref_artist.figure.canvas is not None):\n            self.canvas = self.ref_artist.figure.canvas\n            self.cids = []\n            # Reconnect the basic callbacks\n            self.cids.append(self.canvas.mpl_connect(\"pick_event\", self.on_pick))\n            self.cids.append(self.canvas.mpl_connect(\"button_release_event\", self.on_release))\n\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpicklable canvas references.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable entries\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling and attempt to reconnect canvas.\"\"\"\n        self.__dict__.update(state)\n        # Initialize empty lists for callback IDs if they don't exist\n        if not hasattr(self, 'cids'):\n            self.cids = []\n        # Attempt to reconnect canvas if ref_artist has a figure\n        self._reconnect_canvas()\n",
      "\n    def disconnect(self):\n        \"\"\"Disconnect the callbacks.\"\"\"\n        for cid in self.cids:\n            self.canvas.mpl_disconnect(cid)\n        try:\n            c1 = self._c1\n        except AttributeError:\n            pass\n        else:\n            self.canvas.mpl_disconnect(c1)\n\n    def _reconnect_canvas(self):\n        \"\"\"Reconnect canvas after unpickling if figure is available.\"\"\"\n        if (hasattr(self, 'ref_artist') and self.ref_artist.figure is not None \n            and self.ref_artist.figure.canvas is not None):\n            self.canvas = self.ref_artist.figure.canvas\n            self.cids = [\n                self.canvas.mpl_connect(\"pick_event\", self.on_pick),\n                self.canvas.mpl_connect(\"button_release_event\", self.on_release),\n            ]\n\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by removing unpicklable canvas references.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable entries\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling and reconnect canvas if available.\"\"\"\n        self.__dict__.update(state)\n        # Canvas will be reconnected when needed\n        self._reconnect_canvas()\n",
      "\n    def disconnect(self):\n        \"\"\"Disconnect the callbacks.\"\"\"\n        for cid in self.cids:\n            self.canvas.mpl_disconnect(cid)\n        try:\n            c1 = self._c1\n        except AttributeError:\n            pass\n        else:\n            self.canvas.mpl_disconnect(c1)\n\n    def _reconnect_canvas(self):\n        \"\"\"Reconnect canvas after unpickling if figure is available.\"\"\"\n        if (hasattr(self, 'ref_artist') and self.ref_artist.figure is not None \n            and self.ref_artist.figure.canvas is not None):\n            self.canvas = self.ref_artist.figure.canvas\n            self.cids = [\n                self.canvas.mpl_connect(\"pick_event\", self.on_pick),\n                self.canvas.mpl_connect(\"button_release_event\", self.on_release)\n            ]\n\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding unpicklable canvas references.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable entries\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling.\"\"\"\n        self.__dict__.update(state)\n        # Canvas will be reconnected when needed via _reconnect_canvas\n",
      "\n    def disconnect(self):\n        \"\"\"Disconnect the callbacks.\"\"\"\n        for cid in self.cids:\n            self.canvas.mpl_disconnect(cid)\n        try:\n            c1 = self._c1\n        except AttributeError:\n            pass\n        else:\n            self.canvas.mpl_disconnect(c1)\n\n    def _reconnect_canvas(self):\n        \"\"\"Reconnect canvas after unpickling if possible.\"\"\"\n        if (hasattr(self, 'ref_artist') and self.ref_artist.figure is not None \n            and self.ref_artist.figure.canvas is not None):\n            self.canvas = self.ref_artist.figure.canvas\n            self.cids = [\n                self.canvas.mpl_connect(\"pick_event\", self.on_pick),\n                self.canvas.mpl_connect(\"button_release_event\", self.on_release),\n            ]\n\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by removing unpicklable attributes.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable entries\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling.\"\"\"\n        self.__dict__.update(state)\n        # Canvas will be reconnected when needed\n        self.cids = []\n",
      "\n    def disconnect(self):\n        \"\"\"Disconnect the callbacks.\"\"\"\n        for cid in self.cids:\n            self.canvas.mpl_disconnect(cid)\n        try:\n            c1 = self._c1\n        except AttributeError:\n            pass\n        else:\n            self.canvas.mpl_disconnect(c1)\n\n    def _reconnect_canvas(self):\n        \"\"\"Reconnect canvas after unpickling if available.\"\"\"\n        if (hasattr(self, 'ref_artist') and self.ref_artist.figure is not None \n            and self.ref_artist.figure.canvas is not None):\n            self.canvas = self.ref_artist.figure.canvas\n            self.cids = []\n            # Re-register the pick event if needed\n            if hasattr(self.ref_artist, 'set_picker'):\n                self.ref_artist.set_picker(self.artist_picker)\n\n    def __getstate__(self):\n        state = self.__dict__.copy()\n        # Remove unpicklable entries\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        self.__dict__.update(state)\n        # Canvas will be reconnected when needed\n        self._reconnect_canvas()\n",
      "\n    def disconnect(self):\n        \"\"\"Disconnect the callbacks.\"\"\"\n        for cid in self.cids:\n            self.canvas.mpl_disconnect(cid)\n        try:\n            c1 = self._c1\n        except AttributeError:\n            pass\n        else:\n            self.canvas.mpl_disconnect(c1)\n\n    def _reconnect_canvas(self):\n        \"\"\"Reconnect canvas after unpickling if possible.\"\"\"\n        if (hasattr(self, 'ref_artist') and self.ref_artist.figure is not None \n            and self.ref_artist.figure.canvas is not None):\n            self.canvas = self.ref_artist.figure.canvas\n            # Reconnect pick event\n            self.cids = [self.canvas.mpl_connect('pick_event', self.on_pick)]\n\n    def __getstate__(self):\n        state = self.__dict__.copy()\n        # Remove unpicklable entries\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        self.__dict__.update(state)\n        # Canvas will be reconnected when needed\n        self._reconnect_canvas()\n",
      "\n    def disconnect(self):\n        \"\"\"Disconnect the callbacks.\"\"\"\n        if hasattr(self, 'cids'):\n            for cid in self.cids:\n                if hasattr(self, 'canvas') and self.canvas is not None:\n                    self.canvas.mpl_disconnect(cid)\n        try:\n            c1 = self._c1\n        except AttributeError:\n            pass\n        else:\n            if hasattr(self, 'canvas') and self.canvas is not None:\n                self.canvas.mpl_disconnect(c1)\n\n    def _reconnect_canvas(self):\n        \"\"\"Reconnect canvas after unpickling if figure is available.\"\"\"\n        if (hasattr(self, 'ref_artist') and self.ref_artist.figure is not None \n            and self.ref_artist.figure.canvas is not None):\n            self.canvas = self.ref_artist.figure.canvas\n            self.cids = []\n            # Reconnect pick event\n            self.cids.append(self.canvas.mpl_connect(\"pick_event\", self.on_pick))\n",
      "\n    def disconnect(self):\n        \"\"\"Disconnect the callbacks.\"\"\"\n        for cid in self.cids:\n            self.canvas.mpl_disconnect(cid)\n        try:\n            c1 = self._c1\n        except AttributeError:\n            pass\n        else:\n            self.canvas.mpl_disconnect(c1)\n\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by removing unpicklable canvas references.\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable entries\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object after unpickling.\"\"\"\n        self.__dict__.update(state)\n        # Canvas connections will be restored when needed\n\n    def _reconnect_canvas(self):\n        \"\"\"Reconnect canvas if figure is available.\"\"\"\n        if (hasattr(self, 'ref_artist') and self.ref_artist.figure is not None \n            and self.ref_artist.figure.canvas is not None):\n            self.canvas = self.ref_artist.figure.canvas\n            self.cids = [\n                self.canvas.mpl_connect('pick_event', self.on_pick),\n                self.canvas.mpl_connect('button_release_event', self.on_release),\n            ]\n"
    ],
    "Location 5 (/root/hy/projects_3/matplotlib/lib/matplotlib/legend.py lines 53-95)": [
      "\nclass DraggableLegend(DraggableOffsetBox):\n    def __init__(self, legend, use_blit=False, update=\"loc\"):\n        \"\"\"\n        Wrapper around a `.Legend` to support mouse dragging.\n\n        Parameters\n        ----------\n        legend : `.Legend`\n            The `.Legend` instance to wrap.\n        use_blit : bool, optional\n            Use blitting for faster image composition. For details see\n            :ref:`func-animation`.\n        update : {'loc', 'bbox'}, optional\n            If \"loc\", update the *loc* parameter of the legend upon finalizing.\n            If \"bbox\", update the *bbox_to_anchor* parameter.\n        \"\"\"\n        self.legend = legend\n\n        _api.check_in_list([\"loc\", \"bbox\"], update=update)\n        self._update = update\n\n        super().__init__(legend, legend._legend_box, use_blit=use_blit)\n\n    def finalize_offset(self):\n        if self._update == \"loc\":\n            self._update_loc(self.get_loc_in_canvas())\n        elif self._update == \"bbox\":\n            self._bbox_to_anchor(self.get_loc_in_canvas())\n\n    def _update_loc(self, loc_in_canvas):\n        bbox = self.legend.get_bbox_to_anchor()\n        # if bbox has zero width or height, the transformation is\n        # ill-defined. Fall back to the default bbox_to_anchor.\n        if bbox.width == 0 or bbox.height == 0:\n            self.legend.set_bbox_to_anchor(None)\n            bbox = self.legend.get_bbox_to_anchor()\n        _bbox_transform = BboxTransformFrom(bbox)\n        self.legend._loc = tuple(_bbox_transform.transform(loc_in_canvas))\n\n    def _update_bbox_to_anchor(self, loc_in_canvas):\n        loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n        self.legend.set_bbox_to_anchor(loc_in_bbox)\n\n    def __setstate__(self, state):\n        super().__setstate__(state)\n        if (hasattr(self, 'legend') and self.legend.figure is not None \n            and self.legend.figure.canvas is not None):\n            self._reconnect_canvas()\n",
      "\nclass DraggableLegend(DraggableOffsetBox):\n    def __init__(self, legend, use_blit=False, update=\"loc\"):\n        \"\"\"\n        Wrapper around a `.Legend` to support mouse dragging.\n\n        Parameters\n        ----------\n        legend : `.Legend`\n            The `.Legend` instance to wrap.\n        use_blit : bool, optional\n            Use blitting for faster image composition. For details see\n            :ref:`func-animation`.\n        update : {'loc', 'bbox'}, optional\n            If \"loc\", update the *loc* parameter of the legend upon finalizing.\n            If \"bbox\", update the *bbox_to_anchor* parameter.\n        \"\"\"\n        self.legend = legend\n\n        _api.check_in_list([\"loc\", \"bbox\"], update=update)\n        self._update = update\n\n        super().__init__(legend, legend._legend_box, use_blit=use_blit)\n\n    def finalize_offset(self):\n        if self._update == \"loc\":\n            self._update_loc(self.get_loc_in_canvas())\n        elif self._update == \"bbox\":\n            self._bbox_to_anchor(self.get_loc_in_canvas())\n\n    def _update_loc(self, loc_in_canvas):\n        bbox = self.legend.get_bbox_to_anchor()\n        # if bbox has zero width or height, the transformation is\n        # ill-defined. Fall back to the default bbox_to_anchor.\n        if bbox.width == 0 or bbox.height == 0:\n            self.legend.set_bbox_to_anchor(None)\n            bbox = self.legend.get_bbox_to_anchor()\n        _bbox_transform = BboxTransformFrom(bbox)\n        self.legend._loc = tuple(_bbox_transform.transform(loc_in_canvas))\n\n    def _update_bbox_to_anchor(self, loc_in_canvas):\n        loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n        self.legend.set_bbox_to_anchor(loc_in_bbox)\n\n    def __setstate__(self, state):\n        super().__setstate__(state)\n        # Attempt to reconnect canvas if legend's figure is available\n        if (hasattr(self, 'legend') and self.legend.figure is not None \n            and self.legend.figure.canvas is not None):\n            self._reconnect_canvas()\n",
      "\nclass DraggableLegend(DraggableOffsetBox):\n    def __init__(self, legend, use_blit=False, update=\"loc\"):\n        \"\"\"\n        Wrapper around a `.Legend` to support mouse dragging.\n\n        Parameters\n        ----------\n        legend : `.Legend`\n            The `.Legend` instance to wrap.\n        use_blit : bool, optional\n            Use blitting for faster image composition. For details see\n            :ref:`func-animation`.\n        update : {'loc', 'bbox'}, optional\n            If \"loc\", update the *loc* parameter of the legend upon finalizing.\n            If \"bbox\", update the *bbox_to_anchor* parameter.\n        \"\"\"\n        self.legend = legend\n\n        _api.check_in_list([\"loc\", \"bbox\"], update=update)\n        self._update = update\n\n        super().__init__(legend, legend._legend_box, use_blit=use_blit)\n\n    def finalize_offset(self):\n        if self._update == \"loc\":\n            self._update_loc(self.get_loc_in_canvas())\n        elif self._update == \"bbox\":\n            self._bbox_to_anchor(self.get_loc_in_canvas())\n\n    def _update_loc(self, loc_in_canvas):\n        bbox = self.legend.get_bbox_to_anchor()\n        # if bbox has zero width or height, the transformation is\n        # ill-defined. Fall back to the default bbox_to_anchor.\n        if bbox.width == 0 or bbox.height == 0:\n            self.legend.set_bbox_to_anchor(None)\n            bbox = self.legend.get_bbox_to_anchor()\n        _bbox_transform = BboxTransformFrom(bbox)\n        self.legend._loc = tuple(_bbox_transform.transform(loc_in_canvas))\n\n    def _update_bbox_to_anchor(self, loc_in_canvas):\n        loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n        self.legend.set_bbox_to_anchor(loc_in_bbox)\n\n    def __setstate__(self, state):\n        super().__setstate__(state)\n        # Attempt to reconnect canvas if legend's figure is available\n        if (hasattr(self, 'legend') and self.legend.figure is not None \n            and self.legend.figure.canvas is not None):\n            self._reconnect_canvas()\n",
      "\nclass DraggableLegend(DraggableOffsetBox):\n    def __init__(self, legend, use_blit=False, update=\"loc\"):\n        \"\"\"\n        Wrapper around a `.Legend` to support mouse dragging.\n\n        Parameters\n        ----------\n        legend : `.Legend`\n            The `.Legend` instance to wrap.\n        use_blit : bool, optional\n            Use blitting for faster image composition. For details see\n            :ref:`func-animation`.\n        update : {'loc', 'bbox'}, optional\n            If \"loc\", update the *loc* parameter of the legend upon finalizing.\n            If \"bbox\", update the *bbox_to_anchor* parameter.\n        \"\"\"\n        self.legend = legend\n\n        _api.check_in_list([\"loc\", \"bbox\"], update=update)\n        self._update = update\n\n        super().__init__(legend, legend._legend_box, use_blit=use_blit)\n\n    def finalize_offset(self):\n        if self._update == \"loc\":\n            self._update_loc(self.get_loc_in_canvas())\n        elif self._update == \"bbox\":\n            self._bbox_to_anchor(self.get_loc_in_canvas())\n\n    def _update_loc(self, loc_in_canvas):\n        bbox = self.legend.get_bbox_to_anchor()\n        # if bbox has zero width or height, the transformation is\n        # ill-defined. Fall back to the default bbox_to_anchor.\n        if bbox.width == 0 or bbox.height == 0:\n            self.legend.set_bbox_to_anchor(None)\n            bbox = self.legend.get_bbox_to_anchor()\n        _bbox_transform = BboxTransformFrom(bbox)\n        self.legend._loc = tuple(_bbox_transform.transform(loc_in_canvas))\n\n    def _update_bbox_to_anchor(self, loc_in_canvas):\n        loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n        self.legend.set_bbox_to_anchor(loc_in_bbox)\n\n    def __setstate__(self, state):\n        super().__setstate__(state)\n        # Attempt to reconnect canvas if legend's figure is available\n        if (hasattr(self, 'legend') and self.legend.figure is not None \n            and self.legend.figure.canvas is not None):\n            self._reconnect_canvas()\n",
      "\nclass DraggableLegend(DraggableOffsetBox):\n    def __init__(self, legend, use_blit=False, update=\"loc\"):\n        \"\"\"\n        Wrapper around a `.Legend` to support mouse dragging.\n\n        Parameters\n        ----------\n        legend : `.Legend`\n            The `.Legend` instance to wrap.\n        use_blit : bool, optional\n            Use blitting for faster image composition. For details see\n            :ref:`func-animation`.\n        update : {'loc', 'bbox'}, optional\n            If \"loc\", update the *loc* parameter of the legend upon finalizing.\n            If \"bbox\", update the *bbox_to_anchor* parameter.\n        \"\"\"\n        self.legend = legend\n\n        _api.check_in_list([\"loc\", \"bbox\"], update=update)\n        self._update = update\n\n        super().__init__(legend, legend._legend_box, use_blit=use_blit)\n\n    def finalize_offset(self):\n        if self._update == \"loc\":\n            self._update_loc(self.get_loc_in_canvas())\n        elif self._update == \"bbox\":\n            self._bbox_to_anchor(self.get_loc_in_canvas())\n\n    def _update_loc(self, loc_in_canvas):\n        bbox = self.legend.get_bbox_to_anchor()\n        # if bbox has zero width or height, the transformation is\n        # ill-defined. Fall back to the default bbox_to_anchor.\n        if bbox.width == 0 or bbox.height == 0:\n            self.legend.set_bbox_to_anchor(None)\n            bbox = self.legend.get_bbox_to_anchor()\n        _bbox_transform = BboxTransformFrom(bbox)\n        self.legend._loc = tuple(_bbox_transform.transform(loc_in_canvas))\n\n    def _update_bbox_to_anchor(self, loc_in_canvas):\n        loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n        self.legend.set_bbox_to_anchor(loc_in_bbox)\n\n    def __setstate__(self, state):\n        super().__setstate__(state)\n        # Attempt to reconnect canvas if legend's figure is available\n        if (hasattr(self, 'legend') and self.legend.figure is not None \n            and self.legend.figure.canvas is not None):\n            self._reconnect_canvas()\n",
      "\nclass DraggableLegend(DraggableOffsetBox):\n    def __init__(self, legend, use_blit=False, update=\"loc\"):\n        \"\"\"\n        Wrapper around a `.Legend` to support mouse dragging.\n\n        Parameters\n        ----------\n        legend : `.Legend`\n            The `.Legend` instance to wrap.\n        use_blit : bool, optional\n            Use blitting for faster image composition. For details see\n            :ref:`func-animation`.\n        update : {'loc', 'bbox'}, optional\n            If \"loc\", update the *loc* parameter of the legend upon finalizing.\n            If \"bbox\", update the *bbox_to_anchor* parameter.\n        \"\"\"\n        self.legend = legend\n\n        _api.check_in_list([\"loc\", \"bbox\"], update=update)\n        self._update = update\n\n        super().__init__(legend, legend._legend_box, use_blit=use_blit)\n\n    def finalize_offset(self):\n        if self._update == \"loc\":\n            self._update_loc(self.get_loc_in_canvas())\n        elif self._update == \"bbox\":\n            self._bbox_to_anchor(self.get_loc_in_canvas())\n\n    def _update_loc(self, loc_in_canvas):\n        bbox = self.legend.get_bbox_to_anchor()\n        # if bbox has zero width or height, the transformation is\n        # ill-defined. Fall back to the default bbox_to_anchor.\n        if bbox.width == 0 or bbox.height == 0:\n            self.legend.set_bbox_to_anchor(None)\n            bbox = self.legend.get_bbox_to_anchor()\n        _bbox_transform = BboxTransformFrom(bbox)\n        self.legend._loc = tuple(_bbox_transform.transform(loc_in_canvas))\n\n    def _update_bbox_to_anchor(self, loc_in_canvas):\n        loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n        self.legend.set_bbox_to_anchor(loc_in_bbox)\n\n    def __setstate__(self, state):\n        super().__setstate__(state)\n        # Try to reconnect canvas if the legend's figure is available\n        if (hasattr(self, 'legend') and self.legend.figure is not None \n            and self.legend.figure.canvas is not None):\n            self._reconnect_canvas()\n",
      "\nclass DraggableLegend(DraggableOffsetBox):\n    def __init__(self, legend, use_blit=False, update=\"loc\"):\n        \"\"\"\n        Wrapper around a `.Legend` to support mouse dragging.\n\n        Parameters\n        ----------\n        legend : `.Legend`\n            The `.Legend` instance to wrap.\n        use_blit : bool, optional\n            Use blitting for faster image composition. For details see\n            :ref:`func-animation`.\n        update : {'loc', 'bbox'}, optional\n            If \"loc\", update the *loc* parameter of the legend upon finalizing.\n            If \"bbox\", update the *bbox_to_anchor* parameter.\n        \"\"\"\n        self.legend = legend\n\n        _api.check_in_list([\"loc\", \"bbox\"], update=update)\n        self._update = update\n\n        super().__init__(legend, legend._legend_box, use_blit=use_blit)\n\n    def finalize_offset(self):\n        if self._update == \"loc\":\n            self._update_loc(self.get_loc_in_canvas())\n        elif self._update == \"bbox\":\n            self._bbox_to_anchor(self.get_loc_in_canvas())\n\n    def _update_loc(self, loc_in_canvas):\n        bbox = self.legend.get_bbox_to_anchor()\n        # if bbox has zero width or height, the transformation is\n        # ill-defined. Fall back to the default bbox_to_anchor.\n        if bbox.width == 0 or bbox.height == 0:\n            self.legend.set_bbox_to_anchor(None)\n            bbox = self.legend.get_bbox_to_anchor()\n        _bbox_transform = BboxTransformFrom(bbox)\n        self.legend._loc = tuple(_bbox_transform.transform(loc_in_canvas))\n\n    def _update_bbox_to_anchor(self, loc_in_canvas):\n        loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n        self.legend.set_bbox_to_anchor(loc_in_bbox)\n\n    def __setstate__(self, state):\n        super().__setstate__(state)\n        if (hasattr(self, 'legend') and self.legend.figure is not None \n            and self.legend.figure.canvas is not None):\n            self._reconnect_canvas()\n",
      "\nclass DraggableLegend(DraggableOffsetBox):\n    def __init__(self, legend, use_blit=False, update=\"loc\"):\n        \"\"\"\n        Wrapper around a `.Legend` to support mouse dragging.\n\n        Parameters\n        ----------\n        legend : `.Legend`\n            The `.Legend` instance to wrap.\n        use_blit : bool, optional\n            Use blitting for faster image composition. For details see\n            :ref:`func-animation`.\n        update : {'loc', 'bbox'}, optional\n            If \"loc\", update the *loc* parameter of the legend upon finalizing.\n            If \"bbox\", update the *bbox_to_anchor* parameter.\n        \"\"\"\n        self.legend = legend\n\n        _api.check_in_list([\"loc\", \"bbox\"], update=update)\n        self._update = update\n\n        super().__init__(legend, legend._legend_box, use_blit=use_blit)\n\n    def finalize_offset(self):\n        if self._update == \"loc\":\n            self._update_loc(self.get_loc_in_canvas())\n        elif self._update == \"bbox\":\n            self._bbox_to_anchor(self.get_loc_in_canvas())\n\n    def _update_loc(self, loc_in_canvas):\n        bbox = self.legend.get_bbox_to_anchor()\n        # if bbox has zero width or height, the transformation is\n        # ill-defined. Fall back to the default bbox_to_anchor.\n        if bbox.width == 0 or bbox.height == 0:\n            self.legend.set_bbox_to_anchor(None)\n            bbox = self.legend.get_bbox_to_anchor()\n        _bbox_transform = BboxTransformFrom(bbox)\n        self.legend._loc = tuple(_bbox_transform.transform(loc_in_canvas))\n\n    def _update_bbox_to_anchor(self, loc_in_canvas):\n        loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n        self.legend.set_bbox_to_anchor(loc_in_bbox)\n\n    def __setstate__(self, state):\n        super().__setstate__(state)\n        # Attempt to reconnect canvas if legend's figure is available\n        if (hasattr(self, 'legend') and self.legend.figure is not None \n            and self.legend.figure.canvas is not None):\n            self._reconnect_canvas()\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/lib/matplotlib/legend.py b/lib/matplotlib/legend.py\nindex ff6abdb958..713484f401 100644\n--- a/lib/matplotlib/legend.py\n+++ b/lib/matplotlib/legend.py\n@@ -50,6 +50,7 @@ from matplotlib.container import ErrorbarContainer, BarContainer, StemContainer\n from . import legend_handler\n \n \n+\n class DraggableLegend(DraggableOffsetBox):\n     def __init__(self, legend, use_blit=False, update=\"loc\"):\n         \"\"\"\n@@ -77,7 +78,7 @@ class DraggableLegend(DraggableOffsetBox):\n         if self._update == \"loc\":\n             self._update_loc(self.get_loc_in_canvas())\n         elif self._update == \"bbox\":\n-            self._bbox_to_anchor(self.get_loc_in_canvas())\n+            self._update_bbox_to_anchor(self.get_loc_in_canvas())\n \n     def _update_loc(self, loc_in_canvas):\n         bbox = self.legend.get_bbox_to_anchor()\n@@ -93,6 +94,13 @@ class DraggableLegend(DraggableOffsetBox):\n         loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n         self.legend.set_bbox_to_anchor(loc_in_bbox)\n \n+    def __setstate__(self, state):\n+        \"\"\"Restore state from pickle and reconnect canvas if available.\"\"\"\n+        super().__setstate__(state)\n+        # Attempt to reconnect canvas if legend's figure is available\n+        if (hasattr(self, 'legend') and self.legend.figure is not None \n+            and self.legend.figure.canvas is not None):\n+            self._reconnect_canvas()\n \n _legend_kw_doc_base = \"\"\"\n bbox_to_anchor : `.BboxBase`, 2-tuple, or 4-tuple of floats\ndiff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 1dee8a23d9..a2aca3b26b 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1500,6 +1500,7 @@ class DraggableBase:\n     coordinate and set a relevant attribute.\n     \"\"\"\n \n+\n     def __init__(self, ref_artist, use_blit=False):\n         self.ref_artist = ref_artist\n         if not ref_artist.pickable():\n@@ -1532,6 +1533,10 @@ class DraggableBase:\n             self.mouse_x = evt.mouseevent.x\n             self.mouse_y = evt.mouseevent.y\n             self.got_artist = True\n+            if self._use_blit:\n+                self.ref_artist.set_animated(True)\n+                self.canvas.draw()\n+\n             if self._use_blit:\n                 self.ref_artist.set_animated(True)\n                 self.canvas.draw()\n@@ -1560,16 +1565,20 @@ class DraggableBase:\n         else:\n             return True\n \n+\n     def disconnect(self):\n         \"\"\"Disconnect the callbacks.\"\"\"\n-        for cid in self.cids:\n-            self.canvas.mpl_disconnect(cid)\n+        if hasattr(self, 'canvas') and hasattr(self, 'cids'):\n+            for cid in self.cids:\n+                self.canvas.mpl_disconnect(cid)\n         try:\n             c1 = self._c1\n         except AttributeError:\n             pass\n         else:\n-            self.canvas.mpl_disconnect(c1)\n+            if hasattr(self, 'canvas'):\n+                self.canvas.mpl_disconnect(c1)\n+\n \n     def save_offset(self):\n         pass\n@@ -1580,6 +1589,33 @@ class DraggableBase:\n     def finalize_offset(self):\n         pass\n \n+    def __getstate__(self):\n+        \"\"\"Support for pickle by excluding unpicklable canvas references.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable entries\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore state from pickle, canvas will be reconnected when needed.\"\"\"\n+        self.__dict__.update(state)\n+        # Canvas and callbacks will be reconnected when the figure becomes available\n+\n+    def _reconnect_canvas(self):\n+        \"\"\"Reconnect canvas callbacks after unpickling.\"\"\"\n+        if (hasattr(self, 'ref_artist') and self.ref_artist.figure is not None \n+            and self.ref_artist.figure.canvas is not None):\n+            self.canvas = self.ref_artist.figure.canvas\n+            self._use_blit = self._use_blit and self.canvas.supports_blit\n+            self.cids = [\n+                self.canvas.callbacks._connect_picklable(\n+                    'pick_event', self.on_pick),\n+                self.canvas.callbacks._connect_picklable(\n+                    'button_release_event', self.on_release),\n+            ]\n \n class DraggableOffsetBox(DraggableBase):\n     def __init__(self, ref_artist, offsetbox, use_blit=False):\n",
    "variant_0": "diff --git a/lib/matplotlib/legend.py b/lib/matplotlib/legend.py\nindex ff6abdb958..89f40ef6d7 100644\n--- a/lib/matplotlib/legend.py\n+++ b/lib/matplotlib/legend.py\n@@ -50,6 +50,7 @@ from matplotlib.container import ErrorbarContainer, BarContainer, StemContainer\n from . import legend_handler\n \n \n+\n class DraggableLegend(DraggableOffsetBox):\n     def __init__(self, legend, use_blit=False, update=\"loc\"):\n         \"\"\"\n@@ -93,6 +94,12 @@ class DraggableLegend(DraggableOffsetBox):\n         loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n         self.legend.set_bbox_to_anchor(loc_in_bbox)\n \n+    def __setstate__(self, state):\n+        super().__setstate__(state)\n+        # Attempt to reconnect canvas if legend's figure is available\n+        if (hasattr(self, 'legend') and self.legend.figure is not None \n+            and self.legend.figure.canvas is not None):\n+            self._reconnect_canvas()\n \n _legend_kw_doc_base = \"\"\"\n bbox_to_anchor : `.BboxBase`, 2-tuple, or 4-tuple of floats\ndiff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 1dee8a23d9..b9fef9939d 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1500,6 +1500,7 @@ class DraggableBase:\n     coordinate and set a relevant attribute.\n     \"\"\"\n \n+\n     def __init__(self, ref_artist, use_blit=False):\n         self.ref_artist = ref_artist\n         if not ref_artist.pickable():\n@@ -1514,6 +1515,34 @@ class DraggableBase:\n                 'button_release_event', self.on_release),\n         ]\n \n+    def __getstate__(self):\n+        state = self.__dict__.copy()\n+        # Remove unpicklable entries\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        self.__dict__.update(state)\n+        # Canvas will be reconnected when needed\n+        self._reconnect_canvas()\n+\n+    def _reconnect_canvas(self):\n+        \"\"\"Reconnect canvas callbacks after unpickling.\"\"\"\n+        if (hasattr(self, 'ref_artist') and \n+            self.ref_artist.figure is not None and \n+            self.ref_artist.figure.canvas is not None):\n+            self.canvas = self.ref_artist.figure.canvas\n+            self._use_blit = getattr(self, '_use_blit', False) and self.canvas.supports_blit\n+            self.cids = [\n+                self.canvas.callbacks._connect_picklable(\n+                    'pick_event', self.on_pick),\n+                self.canvas.callbacks._connect_picklable(\n+                    'button_release_event', self.on_release),\n+            ]\n+\n     def on_motion(self, evt):\n         if self._check_still_parented() and self.got_artist:\n             dx = evt.x - self.mouse_x\n@@ -1535,13 +1564,24 @@ class DraggableBase:\n             if self._use_blit:\n                 self.ref_artist.set_animated(True)\n                 self.canvas.draw()\n+\n+    def on_pick(self, evt):\n+        if self._check_still_parented() and evt.artist == self.ref_artist:\n+            self.mouse_x = evt.mouseevent.x\n+            self.mouse_y = evt.mouseevent.y\n+            self.got_artist = True\n+            if self._use_blit and hasattr(self, 'canvas') and self.canvas is not None:\n+                self.ref_artist.set_animated(True)\n+                self.canvas.draw()\n                 self.background = \\\n                     self.canvas.copy_from_bbox(self.ref_artist.figure.bbox)\n                 self.ref_artist.draw(\n                     self.ref_artist.figure._get_renderer())\n                 self.canvas.blit()\n-            self._c1 = self.canvas.callbacks._connect_picklable(\n-                \"motion_notify_event\", self.on_motion)\n+            if hasattr(self, 'canvas') and self.canvas is not None:\n+                self._c1 = self.canvas.callbacks._connect_picklable(\n+                    \"motion_notify_event\", self.on_motion)\n+            self.save_offset()\n             self.save_offset()\n \n     def on_release(self, event):\n@@ -1560,16 +1600,31 @@ class DraggableBase:\n         else:\n             return True\n \n+\n     def disconnect(self):\n         \"\"\"Disconnect the callbacks.\"\"\"\n-        for cid in self.cids:\n-            self.canvas.mpl_disconnect(cid)\n+        if hasattr(self, 'cids'):\n+            for cid in self.cids:\n+                if hasattr(self, 'canvas') and self.canvas is not None:\n+                    self.canvas.mpl_disconnect(cid)\n         try:\n             c1 = self._c1\n         except AttributeError:\n             pass\n         else:\n-            self.canvas.mpl_disconnect(c1)\n+            if hasattr(self, 'canvas') and self.canvas is not None:\n+                self.canvas.mpl_disconnect(c1)\n+\n+    def _reconnect_canvas(self):\n+        \"\"\"Reconnect canvas after unpickling if figure is available.\"\"\"\n+        if (hasattr(self, 'ref_artist') and self.ref_artist.figure is not None \n+            and self.ref_artist.figure.canvas is not None):\n+            self.canvas = self.ref_artist.figure.canvas\n+            self.cids = []\n+            # Re-enable picking if it was enabled before\n+            if hasattr(self, 'ref_artist') and self.ref_artist.get_picker() is not None:\n+                cid = self.canvas.mpl_connect('pick_event', self.on_pick)\n+                self.cids.append(cid)\n \n     def save_offset(self):\n         pass\n@@ -1580,6 +1635,35 @@ class DraggableBase:\n     def finalize_offset(self):\n         pass\n \n+    def __getstate__(self):\n+        \"\"\"Prepare state for pickling by removing unpicklable canvas references.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable entries\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore state after unpickling.\"\"\"\n+        self.__dict__.update(state)\n+        # Canvas will be reconnected when needed\n+\n+    def _reconnect_canvas(self):\n+        \"\"\"Reconnect canvas if available.\"\"\"\n+        if hasattr(self, 'ref_artist') and self.ref_artist.figure is not None:\n+            canvas = self.ref_artist.figure.canvas\n+            if canvas is not None:\n+                self.canvas = canvas\n+                self.cids = []\n+                # Reconnect event handlers\n+                self.cids.append(self.canvas.mpl_connect('pick_event', self.on_pick))\n+                self.cids.append(self.canvas.mpl_connect('button_release_event', self.on_release))\n+                if self.use_blit:\n+                    self.cids.append(self.canvas.mpl_connect('motion_notify_event', self.on_motion_blit))\n+                else:\n+                    self.cids.append(self.canvas.mpl_connect('motion_notify_event', self.on_motion))\n \n class DraggableOffsetBox(DraggableBase):\n     def __init__(self, ref_artist, offsetbox, use_blit=False):\n",
    "variant_1": "diff --git a/lib/matplotlib/legend.py b/lib/matplotlib/legend.py\nindex ff6abdb958..a91568246e 100644\n--- a/lib/matplotlib/legend.py\n+++ b/lib/matplotlib/legend.py\n@@ -50,6 +50,7 @@ from matplotlib.container import ErrorbarContainer, BarContainer, StemContainer\n from . import legend_handler\n \n \n+\n class DraggableLegend(DraggableOffsetBox):\n     def __init__(self, legend, use_blit=False, update=\"loc\"):\n         \"\"\"\n@@ -93,6 +94,11 @@ class DraggableLegend(DraggableOffsetBox):\n         loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n         self.legend.set_bbox_to_anchor(loc_in_bbox)\n \n+    def __setstate__(self, state):\n+        super().__setstate__(state)\n+        if (hasattr(self, 'legend') and self.legend.figure is not None \n+            and self.legend.figure.canvas is not None):\n+            self._reconnect_canvas()\n \n _legend_kw_doc_base = \"\"\"\n bbox_to_anchor : `.BboxBase`, 2-tuple, or 4-tuple of floats\ndiff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 1dee8a23d9..f94d5b01a5 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1500,6 +1500,7 @@ class DraggableBase:\n     coordinate and set a relevant attribute.\n     \"\"\"\n \n+\n     def __init__(self, ref_artist, use_blit=False):\n         self.ref_artist = ref_artist\n         if not ref_artist.pickable():\n@@ -1514,6 +1515,32 @@ class DraggableBase:\n                 'button_release_event', self.on_release),\n         ]\n \n+    def __getstate__(self):\n+        state = self.__dict__.copy()\n+        # Remove unpicklable entries\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        self.__dict__.update(state)\n+        # Canvas will be reconnected when needed\n+        if (hasattr(self, 'ref_artist') and self.ref_artist.figure is not None \n+            and self.ref_artist.figure.canvas is not None):\n+            self._reconnect_canvas()\n+\n+    def _reconnect_canvas(self):\n+        \"\"\"Reconnect canvas callbacks after unpickling.\"\"\"\n+        self.canvas = self.ref_artist.figure.canvas\n+        self.cids = [\n+            self.canvas.callbacks._connect_picklable(\n+                'pick_event', self.on_pick),\n+            self.canvas.callbacks._connect_picklable(\n+                'button_release_event', self.on_release),\n+        ]\n+\n     def on_motion(self, evt):\n         if self._check_still_parented() and self.got_artist:\n             dx = evt.x - self.mouse_x\n@@ -1535,13 +1562,24 @@ class DraggableBase:\n             if self._use_blit:\n                 self.ref_artist.set_animated(True)\n                 self.canvas.draw()\n+\n+    def on_pick(self, evt):\n+        if self._check_still_parented() and evt.artist == self.ref_artist:\n+            self.mouse_x = evt.mouseevent.x\n+            self.mouse_y = evt.mouseevent.y\n+            self.got_artist = True\n+            if self._use_blit and hasattr(self, 'canvas') and self.canvas is not None:\n+                self.ref_artist.set_animated(True)\n+                self.canvas.draw()\n                 self.background = \\\n                     self.canvas.copy_from_bbox(self.ref_artist.figure.bbox)\n                 self.ref_artist.draw(\n                     self.ref_artist.figure._get_renderer())\n                 self.canvas.blit()\n-            self._c1 = self.canvas.callbacks._connect_picklable(\n-                \"motion_notify_event\", self.on_motion)\n+            if hasattr(self, 'canvas') and self.canvas is not None:\n+                self._c1 = self.canvas.callbacks._connect_picklable(\n+                    \"motion_notify_event\", self.on_motion)\n+            self.save_offset()\n             self.save_offset()\n \n     def on_release(self, event):\n@@ -1560,6 +1598,7 @@ class DraggableBase:\n         else:\n             return True\n \n+\n     def disconnect(self):\n         \"\"\"Disconnect the callbacks.\"\"\"\n         for cid in self.cids:\n@@ -1571,6 +1610,36 @@ class DraggableBase:\n         else:\n             self.canvas.mpl_disconnect(c1)\n \n+    def _reconnect_canvas(self):\n+        \"\"\"Reconnect canvas connections after unpickling.\"\"\"\n+        if (hasattr(self, 'ref_artist') and self.ref_artist is not None \n+            and self.ref_artist.figure is not None \n+            and self.ref_artist.figure.canvas is not None):\n+            self.canvas = self.ref_artist.figure.canvas\n+            self.cids = []\n+            # Reconnect the basic callbacks\n+            self.cids.append(self.canvas.mpl_connect(\"pick_event\", self.on_pick))\n+            self.cids.append(self.canvas.mpl_connect(\"button_release_event\", self.on_release))\n+\n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpicklable canvas references.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable entries\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling and attempt to reconnect canvas.\"\"\"\n+        self.__dict__.update(state)\n+        # Initialize empty lists for callback IDs if they don't exist\n+        if not hasattr(self, 'cids'):\n+            self.cids = []\n+        # Attempt to reconnect canvas if ref_artist has a figure\n+        self._reconnect_canvas()\n+\n     def save_offset(self):\n         pass\n \n@@ -1580,6 +1649,31 @@ class DraggableBase:\n     def finalize_offset(self):\n         pass\n \n+    def __getstate__(self):\n+        \"\"\"Remove unpicklable canvas references when pickling.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable entries\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore state after unpickling.\"\"\"\n+        self.__dict__.update(state)\n+        # Canvas will be reconnected when needed\n+\n+    def _reconnect_canvas(self):\n+        \"\"\"Reconnect canvas if available.\"\"\"\n+        if (hasattr(self, 'ref_artist') and self.ref_artist is not None \n+            and hasattr(self.ref_artist, 'figure') and self.ref_artist.figure is not None\n+            and hasattr(self.ref_artist.figure, 'canvas') and self.ref_artist.figure.canvas is not None):\n+            self.canvas = self.ref_artist.figure.canvas\n+            self.cids = []\n+            # Reconnect the callbacks\n+            self.cids.append(self.canvas.mpl_connect(\"pick_event\", self.on_pick))\n+            self.cids.append(self.canvas.mpl_connect(\"button_release_event\", self.on_release))\n \n class DraggableOffsetBox(DraggableBase):\n     def __init__(self, ref_artist, offsetbox, use_blit=False):\n",
    "variant_2": "diff --git a/lib/matplotlib/legend.py b/lib/matplotlib/legend.py\nindex ff6abdb958..89f40ef6d7 100644\n--- a/lib/matplotlib/legend.py\n+++ b/lib/matplotlib/legend.py\n@@ -50,6 +50,7 @@ from matplotlib.container import ErrorbarContainer, BarContainer, StemContainer\n from . import legend_handler\n \n \n+\n class DraggableLegend(DraggableOffsetBox):\n     def __init__(self, legend, use_blit=False, update=\"loc\"):\n         \"\"\"\n@@ -93,6 +94,12 @@ class DraggableLegend(DraggableOffsetBox):\n         loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n         self.legend.set_bbox_to_anchor(loc_in_bbox)\n \n+    def __setstate__(self, state):\n+        super().__setstate__(state)\n+        # Attempt to reconnect canvas if legend's figure is available\n+        if (hasattr(self, 'legend') and self.legend.figure is not None \n+            and self.legend.figure.canvas is not None):\n+            self._reconnect_canvas()\n \n _legend_kw_doc_base = \"\"\"\n bbox_to_anchor : `.BboxBase`, 2-tuple, or 4-tuple of floats\ndiff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 1dee8a23d9..028f9aa5e6 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1500,6 +1500,7 @@ class DraggableBase:\n     coordinate and set a relevant attribute.\n     \"\"\"\n \n+\n     def __init__(self, ref_artist, use_blit=False):\n         self.ref_artist = ref_artist\n         if not ref_artist.pickable():\n@@ -1514,6 +1515,34 @@ class DraggableBase:\n                 'button_release_event', self.on_release),\n         ]\n \n+    def __getstate__(self):\n+        state = self.__dict__.copy()\n+        # Remove unpicklable entries\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        self.__dict__.update(state)\n+        # Canvas will be reconnected when needed\n+        self._reconnect_canvas()\n+\n+    def _reconnect_canvas(self):\n+        \"\"\"Reconnect canvas callbacks after unpickling.\"\"\"\n+        if (hasattr(self, 'ref_artist') and \n+            self.ref_artist.figure is not None and \n+            self.ref_artist.figure.canvas is not None):\n+            self.canvas = self.ref_artist.figure.canvas\n+            self._use_blit = getattr(self, '_use_blit', False) and self.canvas.supports_blit\n+            self.cids = [\n+                self.canvas.callbacks._connect_picklable(\n+                    'pick_event', self.on_pick),\n+                self.canvas.callbacks._connect_picklable(\n+                    'button_release_event', self.on_release),\n+            ]\n+\n     def on_motion(self, evt):\n         if self._check_still_parented() and self.got_artist:\n             dx = evt.x - self.mouse_x\n@@ -1535,13 +1564,25 @@ class DraggableBase:\n             if self._use_blit:\n                 self.ref_artist.set_animated(True)\n                 self.canvas.draw()\n-                self.background = \\\n-                    self.canvas.copy_from_bbox(self.ref_artist.figure.bbox)\n-                self.ref_artist.draw(\n-                    self.ref_artist.figure._get_renderer())\n-                self.canvas.blit()\n-            self._c1 = self.canvas.callbacks._connect_picklable(\n-                \"motion_notify_event\", self.on_motion)\n+\n+    def on_pick(self, evt):\n+        if self._check_still_parented() and evt.artist == self.ref_artist:\n+            self.mouse_x = evt.mouseevent.x\n+            self.mouse_y = evt.mouseevent.y\n+            self.got_artist = True\n+            if self._use_blit:\n+                self.ref_artist.set_animated(True)\n+                if hasattr(self, 'canvas') and self.canvas is not None:\n+                    self.canvas.draw()\n+                    self.background = \\\n+                        self.canvas.copy_from_bbox(self.ref_artist.figure.bbox)\n+                    self.ref_artist.draw(\n+                        self.ref_artist.figure._get_renderer())\n+                    self.canvas.blit()\n+            if hasattr(self, 'canvas') and self.canvas is not None:\n+                self._c1 = self.canvas.callbacks._connect_picklable(\n+                    \"motion_notify_event\", self.on_motion)\n+            self.save_offset()\n             self.save_offset()\n \n     def on_release(self, event):\n@@ -1560,6 +1601,7 @@ class DraggableBase:\n         else:\n             return True\n \n+\n     def disconnect(self):\n         \"\"\"Disconnect the callbacks.\"\"\"\n         for cid in self.cids:\n@@ -1571,6 +1613,32 @@ class DraggableBase:\n         else:\n             self.canvas.mpl_disconnect(c1)\n \n+    def _reconnect_canvas(self):\n+        \"\"\"Reconnect canvas after unpickling if figure is available.\"\"\"\n+        if (hasattr(self, 'ref_artist') and self.ref_artist.figure is not None \n+            and self.ref_artist.figure.canvas is not None):\n+            self.canvas = self.ref_artist.figure.canvas\n+            self.cids = [\n+                self.canvas.mpl_connect(\"pick_event\", self.on_pick),\n+                self.canvas.mpl_connect(\"button_release_event\", self.on_release),\n+            ]\n+\n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by removing unpicklable canvas references.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable entries\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling and reconnect canvas if available.\"\"\"\n+        self.__dict__.update(state)\n+        # Canvas will be reconnected when needed\n+        self._reconnect_canvas()\n+\n     def save_offset(self):\n         pass\n \n@@ -1580,6 +1648,31 @@ class DraggableBase:\n     def finalize_offset(self):\n         pass\n \n+    def __getstate__(self):\n+        \"\"\"Return state for pickling, excluding unpicklable canvas references.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable entries\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore state from pickling.\"\"\"\n+        self.__dict__.update(state)\n+        # Canvas will be reconnected when needed\n+\n+    def _reconnect_canvas(self):\n+        \"\"\"Reconnect canvas if available.\"\"\"\n+        if (hasattr(self, 'ref_artist') and self.ref_artist is not None and\n+            hasattr(self.ref_artist, 'figure') and self.ref_artist.figure is not None and\n+            hasattr(self.ref_artist.figure, 'canvas') and self.ref_artist.figure.canvas is not None):\n+            self.canvas = self.ref_artist.figure.canvas\n+            self.cids = []\n+            # Reconnect event handlers\n+            self.cids.append(self.canvas.mpl_connect(\"pick_event\", self.on_pick))\n+            self.cids.append(self.canvas.mpl_connect(\"button_release_event\", self.on_release))\n \n class DraggableOffsetBox(DraggableBase):\n     def __init__(self, ref_artist, offsetbox, use_blit=False):\n",
    "variant_3": "diff --git a/lib/matplotlib/legend.py b/lib/matplotlib/legend.py\nindex ff6abdb958..89f40ef6d7 100644\n--- a/lib/matplotlib/legend.py\n+++ b/lib/matplotlib/legend.py\n@@ -50,6 +50,7 @@ from matplotlib.container import ErrorbarContainer, BarContainer, StemContainer\n from . import legend_handler\n \n \n+\n class DraggableLegend(DraggableOffsetBox):\n     def __init__(self, legend, use_blit=False, update=\"loc\"):\n         \"\"\"\n@@ -93,6 +94,12 @@ class DraggableLegend(DraggableOffsetBox):\n         loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n         self.legend.set_bbox_to_anchor(loc_in_bbox)\n \n+    def __setstate__(self, state):\n+        super().__setstate__(state)\n+        # Attempt to reconnect canvas if legend's figure is available\n+        if (hasattr(self, 'legend') and self.legend.figure is not None \n+            and self.legend.figure.canvas is not None):\n+            self._reconnect_canvas()\n \n _legend_kw_doc_base = \"\"\"\n bbox_to_anchor : `.BboxBase`, 2-tuple, or 4-tuple of floats\ndiff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 1dee8a23d9..7f5fe1807e 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1500,6 +1500,7 @@ class DraggableBase:\n     coordinate and set a relevant attribute.\n     \"\"\"\n \n+\n     def __init__(self, ref_artist, use_blit=False):\n         self.ref_artist = ref_artist\n         if not ref_artist.pickable():\n@@ -1514,6 +1515,33 @@ class DraggableBase:\n                 'button_release_event', self.on_release),\n         ]\n \n+    def __getstate__(self):\n+        state = self.__dict__.copy()\n+        # Remove unpicklable entries\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        self.__dict__.update(state)\n+        # Canvas will be reconnected when needed\n+        self._reconnect_canvas()\n+\n+    def _reconnect_canvas(self):\n+        \"\"\"Reconnect canvas and event handlers if figure is available.\"\"\"\n+        if (hasattr(self, 'ref_artist') and self.ref_artist.figure is not None \n+            and self.ref_artist.figure.canvas is not None):\n+            self.canvas = self.ref_artist.figure.canvas\n+            self._use_blit = getattr(self, '_use_blit', False) and self.canvas.supports_blit\n+            self.cids = [\n+                self.canvas.callbacks._connect_picklable(\n+                    'pick_event', self.on_pick),\n+                self.canvas.callbacks._connect_picklable(\n+                    'button_release_event', self.on_release),\n+            ]\n+\n     def on_motion(self, evt):\n         if self._check_still_parented() and self.got_artist:\n             dx = evt.x - self.mouse_x\n@@ -1535,13 +1563,24 @@ class DraggableBase:\n             if self._use_blit:\n                 self.ref_artist.set_animated(True)\n                 self.canvas.draw()\n+\n+    def on_pick(self, evt):\n+        if self._check_still_parented() and evt.artist == self.ref_artist:\n+            self.mouse_x = evt.mouseevent.x\n+            self.mouse_y = evt.mouseevent.y\n+            self.got_artist = True\n+            if self._use_blit and hasattr(self, 'canvas') and self.canvas is not None:\n+                self.ref_artist.set_animated(True)\n+                self.canvas.draw()\n                 self.background = \\\n                     self.canvas.copy_from_bbox(self.ref_artist.figure.bbox)\n                 self.ref_artist.draw(\n                     self.ref_artist.figure._get_renderer())\n                 self.canvas.blit()\n-            self._c1 = self.canvas.callbacks._connect_picklable(\n-                \"motion_notify_event\", self.on_motion)\n+            if hasattr(self, 'canvas') and self.canvas is not None:\n+                self._c1 = self.canvas.callbacks._connect_picklable(\n+                    \"motion_notify_event\", self.on_motion)\n+            self.save_offset()\n             self.save_offset()\n \n     def on_release(self, event):\n@@ -1560,6 +1599,43 @@ class DraggableBase:\n         else:\n             return True\n \n+\n+    def disconnect(self):\n+        \"\"\"Disconnect the callbacks.\"\"\"\n+        for cid in self.cids:\n+            self.canvas.mpl_disconnect(cid)\n+        try:\n+            c1 = self._c1\n+        except AttributeError:\n+            pass\n+        else:\n+            self.canvas.mpl_disconnect(c1)\n+\n+    def _reconnect_canvas(self):\n+        \"\"\"Reconnect canvas after unpickling if figure is available.\"\"\"\n+        if (hasattr(self, 'ref_artist') and self.ref_artist.figure is not None \n+            and self.ref_artist.figure.canvas is not None):\n+            self.canvas = self.ref_artist.figure.canvas\n+            self.cids = [\n+                self.canvas.mpl_connect(\"pick_event\", self.on_pick),\n+                self.canvas.mpl_connect(\"button_release_event\", self.on_release)\n+            ]\n+\n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding unpicklable canvas references.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable entries\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling.\"\"\"\n+        self.__dict__.update(state)\n+        # Canvas will be reconnected when needed via _reconnect_canvas\n+\n     def disconnect(self):\n         \"\"\"Disconnect the callbacks.\"\"\"\n         for cid in self.cids:\n@@ -1580,6 +1656,27 @@ class DraggableBase:\n     def finalize_offset(self):\n         pass\n \n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by removing unpicklable canvas references.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable entries\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling.\"\"\"\n+        self.__dict__.update(state)\n+        # Canvas will be reconnected when needed\n+\n+    def _reconnect_canvas(self):\n+        \"\"\"Reconnect canvas if available.\"\"\"\n+        if (hasattr(self, 'ref_artist') and self.ref_artist.figure is not None \n+            and self.ref_artist.figure.canvas is not None):\n+            self.canvas = self.ref_artist.figure.canvas\n+            self.cids = []\n \n class DraggableOffsetBox(DraggableBase):\n     def __init__(self, ref_artist, offsetbox, use_blit=False):\n",
    "variant_4": "diff --git a/lib/matplotlib/legend.py b/lib/matplotlib/legend.py\nindex ff6abdb958..89f40ef6d7 100644\n--- a/lib/matplotlib/legend.py\n+++ b/lib/matplotlib/legend.py\n@@ -50,6 +50,7 @@ from matplotlib.container import ErrorbarContainer, BarContainer, StemContainer\n from . import legend_handler\n \n \n+\n class DraggableLegend(DraggableOffsetBox):\n     def __init__(self, legend, use_blit=False, update=\"loc\"):\n         \"\"\"\n@@ -93,6 +94,12 @@ class DraggableLegend(DraggableOffsetBox):\n         loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n         self.legend.set_bbox_to_anchor(loc_in_bbox)\n \n+    def __setstate__(self, state):\n+        super().__setstate__(state)\n+        # Attempt to reconnect canvas if legend's figure is available\n+        if (hasattr(self, 'legend') and self.legend.figure is not None \n+            and self.legend.figure.canvas is not None):\n+            self._reconnect_canvas()\n \n _legend_kw_doc_base = \"\"\"\n bbox_to_anchor : `.BboxBase`, 2-tuple, or 4-tuple of floats\ndiff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 1dee8a23d9..ea9a10a355 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1500,6 +1500,7 @@ class DraggableBase:\n     coordinate and set a relevant attribute.\n     \"\"\"\n \n+\n     def __init__(self, ref_artist, use_blit=False):\n         self.ref_artist = ref_artist\n         if not ref_artist.pickable():\n@@ -1514,6 +1515,34 @@ class DraggableBase:\n                 'button_release_event', self.on_release),\n         ]\n \n+    def __getstate__(self):\n+        state = self.__dict__.copy()\n+        # Remove unpicklable entries\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        self.__dict__.update(state)\n+        # Canvas will be reconnected when needed\n+        self._reconnect_canvas()\n+\n+    def _reconnect_canvas(self):\n+        \"\"\"Reconnect canvas callbacks if figure and canvas are available.\"\"\"\n+        if (hasattr(self, 'ref_artist') and self.ref_artist is not None\n+            and hasattr(self.ref_artist, 'figure') and self.ref_artist.figure is not None\n+            and hasattr(self.ref_artist.figure, 'canvas') and self.ref_artist.figure.canvas is not None):\n+            self.canvas = self.ref_artist.figure.canvas\n+            self._use_blit = getattr(self, '_use_blit', False) and self.canvas.supports_blit\n+            self.cids = [\n+                self.canvas.callbacks._connect_picklable(\n+                    'pick_event', self.on_pick),\n+                self.canvas.callbacks._connect_picklable(\n+                    'button_release_event', self.on_release),\n+            ]\n+\n     def on_motion(self, evt):\n         if self._check_still_parented() and self.got_artist:\n             dx = evt.x - self.mouse_x\n@@ -1535,13 +1564,24 @@ class DraggableBase:\n             if self._use_blit:\n                 self.ref_artist.set_animated(True)\n                 self.canvas.draw()\n+\n+    def on_pick(self, evt):\n+        if self._check_still_parented() and evt.artist == self.ref_artist:\n+            self.mouse_x = evt.mouseevent.x\n+            self.mouse_y = evt.mouseevent.y\n+            self.got_artist = True\n+            if self._use_blit and hasattr(self, 'canvas') and self.canvas is not None:\n+                self.ref_artist.set_animated(True)\n+                self.canvas.draw()\n                 self.background = \\\n                     self.canvas.copy_from_bbox(self.ref_artist.figure.bbox)\n                 self.ref_artist.draw(\n                     self.ref_artist.figure._get_renderer())\n                 self.canvas.blit()\n-            self._c1 = self.canvas.callbacks._connect_picklable(\n-                \"motion_notify_event\", self.on_motion)\n+            if hasattr(self, 'canvas') and self.canvas is not None:\n+                self._c1 = self.canvas.callbacks._connect_picklable(\n+                    \"motion_notify_event\", self.on_motion)\n+            self.save_offset()\n             self.save_offset()\n \n     def on_release(self, event):\n@@ -1560,6 +1600,7 @@ class DraggableBase:\n         else:\n             return True\n \n+\n     def disconnect(self):\n         \"\"\"Disconnect the callbacks.\"\"\"\n         for cid in self.cids:\n@@ -1571,6 +1612,32 @@ class DraggableBase:\n         else:\n             self.canvas.mpl_disconnect(c1)\n \n+    def _reconnect_canvas(self):\n+        \"\"\"Reconnect canvas after unpickling if possible.\"\"\"\n+        if (hasattr(self, 'ref_artist') and self.ref_artist.figure is not None \n+            and self.ref_artist.figure.canvas is not None):\n+            self.canvas = self.ref_artist.figure.canvas\n+            self.cids = [\n+                self.canvas.mpl_connect(\"pick_event\", self.on_pick),\n+                self.canvas.mpl_connect(\"button_release_event\", self.on_release),\n+            ]\n+\n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by removing unpicklable attributes.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable entries\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling.\"\"\"\n+        self.__dict__.update(state)\n+        # Canvas will be reconnected when needed\n+        self.cids = []\n+\n     def save_offset(self):\n         pass\n \n@@ -1580,6 +1647,30 @@ class DraggableBase:\n     def finalize_offset(self):\n         pass\n \n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by removing unpicklable references.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable canvas-related attributes\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling.\"\"\"\n+        self.__dict__.update(state)\n+        # Canvas and event connections will be restored when needed\n+\n+    def _reconnect_canvas(self):\n+        \"\"\"Reconnect to canvas if available.\"\"\"\n+        if (hasattr(self, 'ref_artist') and self.ref_artist is not None \n+            and hasattr(self.ref_artist, 'figure') and self.ref_artist.figure is not None\n+            and hasattr(self.ref_artist.figure, 'canvas') and self.ref_artist.figure.canvas is not None):\n+            self.canvas = self.ref_artist.figure.canvas\n+            self.cids = []\n+            if hasattr(self, 'use_blit') and self.use_blit:\n+                self.cids.append(self.canvas.mpl_connect(\"draw_event\", self.on_draw))\n \n class DraggableOffsetBox(DraggableBase):\n     def __init__(self, ref_artist, offsetbox, use_blit=False):\n",
    "variant_5": "diff --git a/lib/matplotlib/legend.py b/lib/matplotlib/legend.py\nindex ff6abdb958..89f40ef6d7 100644\n--- a/lib/matplotlib/legend.py\n+++ b/lib/matplotlib/legend.py\n@@ -50,6 +50,7 @@ from matplotlib.container import ErrorbarContainer, BarContainer, StemContainer\n from . import legend_handler\n \n \n+\n class DraggableLegend(DraggableOffsetBox):\n     def __init__(self, legend, use_blit=False, update=\"loc\"):\n         \"\"\"\n@@ -93,6 +94,12 @@ class DraggableLegend(DraggableOffsetBox):\n         loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n         self.legend.set_bbox_to_anchor(loc_in_bbox)\n \n+    def __setstate__(self, state):\n+        super().__setstate__(state)\n+        # Attempt to reconnect canvas if legend's figure is available\n+        if (hasattr(self, 'legend') and self.legend.figure is not None \n+            and self.legend.figure.canvas is not None):\n+            self._reconnect_canvas()\n \n _legend_kw_doc_base = \"\"\"\n bbox_to_anchor : `.BboxBase`, 2-tuple, or 4-tuple of floats\ndiff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 1dee8a23d9..ef256f30a8 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1500,6 +1500,7 @@ class DraggableBase:\n     coordinate and set a relevant attribute.\n     \"\"\"\n \n+\n     def __init__(self, ref_artist, use_blit=False):\n         self.ref_artist = ref_artist\n         if not ref_artist.pickable():\n@@ -1514,6 +1515,34 @@ class DraggableBase:\n                 'button_release_event', self.on_release),\n         ]\n \n+    def __getstate__(self):\n+        state = self.__dict__.copy()\n+        # Remove unpicklable entries\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        self.__dict__.update(state)\n+        # Canvas will be reconnected when needed\n+        self._reconnect_canvas()\n+\n+    def _reconnect_canvas(self):\n+        \"\"\"Reconnect canvas callbacks after unpickling.\"\"\"\n+        if (hasattr(self, 'ref_artist') and self.ref_artist is not None \n+            and self.ref_artist.figure is not None \n+            and self.ref_artist.figure.canvas is not None):\n+            self.canvas = self.ref_artist.figure.canvas\n+            self._use_blit = getattr(self, '_use_blit', False) and self.canvas.supports_blit\n+            self.cids = [\n+                self.canvas.callbacks._connect_picklable(\n+                    'pick_event', self.on_pick),\n+                self.canvas.callbacks._connect_picklable(\n+                    'button_release_event', self.on_release),\n+            ]\n+\n     def on_motion(self, evt):\n         if self._check_still_parented() and self.got_artist:\n             dx = evt.x - self.mouse_x\n@@ -1535,13 +1564,24 @@ class DraggableBase:\n             if self._use_blit:\n                 self.ref_artist.set_animated(True)\n                 self.canvas.draw()\n+\n+    def on_pick(self, evt):\n+        if self._check_still_parented() and evt.artist == self.ref_artist:\n+            self.mouse_x = evt.mouseevent.x\n+            self.mouse_y = evt.mouseevent.y\n+            self.got_artist = True\n+            if self._use_blit and hasattr(self, 'canvas') and self.canvas is not None:\n+                self.ref_artist.set_animated(True)\n+                self.canvas.draw()\n                 self.background = \\\n                     self.canvas.copy_from_bbox(self.ref_artist.figure.bbox)\n                 self.ref_artist.draw(\n                     self.ref_artist.figure._get_renderer())\n                 self.canvas.blit()\n-            self._c1 = self.canvas.callbacks._connect_picklable(\n-                \"motion_notify_event\", self.on_motion)\n+            if hasattr(self, 'canvas') and self.canvas is not None:\n+                self._c1 = self.canvas.callbacks._connect_picklable(\n+                    \"motion_notify_event\", self.on_motion)\n+            self.save_offset()\n             self.save_offset()\n \n     def on_release(self, event):\n@@ -1560,6 +1600,7 @@ class DraggableBase:\n         else:\n             return True\n \n+\n     def disconnect(self):\n         \"\"\"Disconnect the callbacks.\"\"\"\n         for cid in self.cids:\n@@ -1571,6 +1612,30 @@ class DraggableBase:\n         else:\n             self.canvas.mpl_disconnect(c1)\n \n+    def _reconnect_canvas(self):\n+        \"\"\"Reconnect canvas after unpickling if available.\"\"\"\n+        if (hasattr(self, 'ref_artist') and self.ref_artist.figure is not None \n+            and self.ref_artist.figure.canvas is not None):\n+            self.canvas = self.ref_artist.figure.canvas\n+            self.cids = []\n+            # Re-register the pick event if needed\n+            if hasattr(self.ref_artist, 'set_picker'):\n+                self.ref_artist.set_picker(self.artist_picker)\n+\n+    def __getstate__(self):\n+        state = self.__dict__.copy()\n+        # Remove unpicklable entries\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        self.__dict__.update(state)\n+        # Canvas will be reconnected when needed\n+        self._reconnect_canvas()\n+\n     def save_offset(self):\n         pass\n \n@@ -1580,6 +1645,30 @@ class DraggableBase:\n     def finalize_offset(self):\n         pass\n \n+    def __getstate__(self):\n+        \"\"\"Remove unpicklable attributes when pickling.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable entries\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore state when unpickling.\"\"\"\n+        self.__dict__.update(state)\n+        # Canvas will be reconnected when needed\n+\n+    def _reconnect_canvas(self):\n+        \"\"\"Reconnect canvas connections if figure is available.\"\"\"\n+        if (hasattr(self, 'ref_artist') and self.ref_artist.figure is not None \n+            and self.ref_artist.figure.canvas is not None):\n+            self.canvas = self.ref_artist.figure.canvas\n+            self.cids = [\n+                self.canvas.mpl_connect('pick_event', self.on_pick),\n+                self.canvas.mpl_connect('button_release_event', self.on_release),\n+            ]\n \n class DraggableOffsetBox(DraggableBase):\n     def __init__(self, ref_artist, offsetbox, use_blit=False):\n",
    "variant_6": "diff --git a/lib/matplotlib/legend.py b/lib/matplotlib/legend.py\nindex ff6abdb958..fc5930fbe7 100644\n--- a/lib/matplotlib/legend.py\n+++ b/lib/matplotlib/legend.py\n@@ -50,6 +50,7 @@ from matplotlib.container import ErrorbarContainer, BarContainer, StemContainer\n from . import legend_handler\n \n \n+\n class DraggableLegend(DraggableOffsetBox):\n     def __init__(self, legend, use_blit=False, update=\"loc\"):\n         \"\"\"\n@@ -93,6 +94,12 @@ class DraggableLegend(DraggableOffsetBox):\n         loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n         self.legend.set_bbox_to_anchor(loc_in_bbox)\n \n+    def __setstate__(self, state):\n+        super().__setstate__(state)\n+        # Try to reconnect canvas if the legend's figure is available\n+        if (hasattr(self, 'legend') and self.legend.figure is not None \n+            and self.legend.figure.canvas is not None):\n+            self._reconnect_canvas()\n \n _legend_kw_doc_base = \"\"\"\n bbox_to_anchor : `.BboxBase`, 2-tuple, or 4-tuple of floats\ndiff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 1dee8a23d9..49bc0795ee 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1500,6 +1500,7 @@ class DraggableBase:\n     coordinate and set a relevant attribute.\n     \"\"\"\n \n+\n     def __init__(self, ref_artist, use_blit=False):\n         self.ref_artist = ref_artist\n         if not ref_artist.pickable():\n@@ -1514,6 +1515,36 @@ class DraggableBase:\n                 'button_release_event', self.on_release),\n         ]\n \n+    def __getstate__(self):\n+        state = self.__dict__.copy()\n+        # Remove unpicklable entries\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        self.__dict__.update(state)\n+        # Canvas will be reconnected when needed\n+        self.canvas = None\n+        self.cids = []\n+        self._reconnect_canvas()\n+\n+    def _reconnect_canvas(self):\n+        \"\"\"Reconnect to canvas if figure and canvas are available.\"\"\"\n+        if (hasattr(self, 'ref_artist') and self.ref_artist is not None and\n+            hasattr(self.ref_artist, 'figure') and self.ref_artist.figure is not None and\n+            hasattr(self.ref_artist.figure, 'canvas') and self.ref_artist.figure.canvas is not None):\n+            self.canvas = self.ref_artist.figure.canvas\n+            self._use_blit = getattr(self, '_use_blit', False) and self.canvas.supports_blit\n+            self.cids = [\n+                self.canvas.callbacks._connect_picklable(\n+                    'pick_event', self.on_pick),\n+                self.canvas.callbacks._connect_picklable(\n+                    'button_release_event', self.on_release),\n+            ]\n+\n     def on_motion(self, evt):\n         if self._check_still_parented() and self.got_artist:\n             dx = evt.x - self.mouse_x\n@@ -1535,13 +1566,24 @@ class DraggableBase:\n             if self._use_blit:\n                 self.ref_artist.set_animated(True)\n                 self.canvas.draw()\n+\n+    def on_pick(self, evt):\n+        if self._check_still_parented() and evt.artist == self.ref_artist:\n+            self.mouse_x = evt.mouseevent.x\n+            self.mouse_y = evt.mouseevent.y\n+            self.got_artist = True\n+            if self._use_blit and hasattr(self, 'canvas') and self.canvas is not None:\n+                self.ref_artist.set_animated(True)\n+                self.canvas.draw()\n                 self.background = \\\n                     self.canvas.copy_from_bbox(self.ref_artist.figure.bbox)\n                 self.ref_artist.draw(\n                     self.ref_artist.figure._get_renderer())\n                 self.canvas.blit()\n-            self._c1 = self.canvas.callbacks._connect_picklable(\n-                \"motion_notify_event\", self.on_motion)\n+            if hasattr(self, 'canvas') and self.canvas is not None:\n+                self._c1 = self.canvas.callbacks._connect_picklable(\n+                    \"motion_notify_event\", self.on_motion)\n+            self.save_offset()\n             self.save_offset()\n \n     def on_release(self, event):\n@@ -1560,6 +1602,7 @@ class DraggableBase:\n         else:\n             return True\n \n+\n     def disconnect(self):\n         \"\"\"Disconnect the callbacks.\"\"\"\n         for cid in self.cids:\n@@ -1571,6 +1614,28 @@ class DraggableBase:\n         else:\n             self.canvas.mpl_disconnect(c1)\n \n+    def _reconnect_canvas(self):\n+        \"\"\"Reconnect canvas after unpickling if possible.\"\"\"\n+        if (hasattr(self, 'ref_artist') and self.ref_artist.figure is not None \n+            and self.ref_artist.figure.canvas is not None):\n+            self.canvas = self.ref_artist.figure.canvas\n+            # Reconnect pick event\n+            self.cids = [self.canvas.mpl_connect('pick_event', self.on_pick)]\n+\n+    def __getstate__(self):\n+        state = self.__dict__.copy()\n+        # Remove unpicklable entries\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        self.__dict__.update(state)\n+        # Canvas will be reconnected when needed\n+        self._reconnect_canvas()\n+\n     def save_offset(self):\n         pass\n \n@@ -1580,6 +1645,32 @@ class DraggableBase:\n     def finalize_offset(self):\n         pass\n \n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by removing unpicklable canvas references.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable entries\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object from pickle and attempt to reconnect canvas if available.\"\"\"\n+        self.__dict__.update(state)\n+        # Canvas will be reconnected when needed\n+        self._reconnect_canvas()\n+\n+    def _reconnect_canvas(self):\n+        \"\"\"Reconnect to canvas if ref_artist has a figure with canvas.\"\"\"\n+        if (hasattr(self, 'ref_artist') and self.ref_artist is not None and\n+            hasattr(self.ref_artist, 'figure') and self.ref_artist.figure is not None and\n+            hasattr(self.ref_artist.figure, 'canvas') and self.ref_artist.figure.canvas is not None):\n+            self.canvas = self.ref_artist.figure.canvas\n+            self.cids = []\n+            # Reconnect event handlers\n+            self.cids.append(self.canvas.mpl_connect(\"pick_event\", self.on_pick))\n+            self.cids.append(self.canvas.mpl_connect(\"button_release_event\", self.on_release))\n \n class DraggableOffsetBox(DraggableBase):\n     def __init__(self, ref_artist, offsetbox, use_blit=False):\n",
    "variant_7": "diff --git a/lib/matplotlib/legend.py b/lib/matplotlib/legend.py\nindex ff6abdb958..a91568246e 100644\n--- a/lib/matplotlib/legend.py\n+++ b/lib/matplotlib/legend.py\n@@ -50,6 +50,7 @@ from matplotlib.container import ErrorbarContainer, BarContainer, StemContainer\n from . import legend_handler\n \n \n+\n class DraggableLegend(DraggableOffsetBox):\n     def __init__(self, legend, use_blit=False, update=\"loc\"):\n         \"\"\"\n@@ -93,6 +94,11 @@ class DraggableLegend(DraggableOffsetBox):\n         loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n         self.legend.set_bbox_to_anchor(loc_in_bbox)\n \n+    def __setstate__(self, state):\n+        super().__setstate__(state)\n+        if (hasattr(self, 'legend') and self.legend.figure is not None \n+            and self.legend.figure.canvas is not None):\n+            self._reconnect_canvas()\n \n _legend_kw_doc_base = \"\"\"\n bbox_to_anchor : `.BboxBase`, 2-tuple, or 4-tuple of floats\ndiff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 1dee8a23d9..fffa0fe617 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1500,6 +1500,7 @@ class DraggableBase:\n     coordinate and set a relevant attribute.\n     \"\"\"\n \n+\n     def __init__(self, ref_artist, use_blit=False):\n         self.ref_artist = ref_artist\n         if not ref_artist.pickable():\n@@ -1514,6 +1515,36 @@ class DraggableBase:\n                 'button_release_event', self.on_release),\n         ]\n \n+    def __getstate__(self):\n+        state = self.__dict__.copy()\n+        # Remove unpicklable entries\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        self.__dict__.update(state)\n+        # Canvas will be reconnected when needed\n+        self._reconnect_canvas()\n+\n+    def _reconnect_canvas(self):\n+        \"\"\"Reconnect canvas callbacks after unpickling.\"\"\"\n+        if (hasattr(self, 'ref_artist') and \n+            hasattr(self.ref_artist, 'figure') and \n+            self.ref_artist.figure is not None and\n+            hasattr(self.ref_artist.figure, 'canvas') and\n+            self.ref_artist.figure.canvas is not None):\n+            self.canvas = self.ref_artist.figure.canvas\n+            self._use_blit = getattr(self, '_use_blit', False) and self.canvas.supports_blit\n+            self.cids = [\n+                self.canvas.callbacks._connect_picklable(\n+                    'pick_event', self.on_pick),\n+                self.canvas.callbacks._connect_picklable(\n+                    'button_release_event', self.on_release),\n+            ]\n+\n     def on_motion(self, evt):\n         if self._check_still_parented() and self.got_artist:\n             dx = evt.x - self.mouse_x\n@@ -1535,13 +1566,24 @@ class DraggableBase:\n             if self._use_blit:\n                 self.ref_artist.set_animated(True)\n                 self.canvas.draw()\n+\n+    def on_pick(self, evt):\n+        if self._check_still_parented() and evt.artist == self.ref_artist:\n+            self.mouse_x = evt.mouseevent.x\n+            self.mouse_y = evt.mouseevent.y\n+            self.got_artist = True\n+            if self._use_blit and hasattr(self, 'canvas') and self.canvas is not None:\n+                self.ref_artist.set_animated(True)\n+                self.canvas.draw()\n                 self.background = \\\n                     self.canvas.copy_from_bbox(self.ref_artist.figure.bbox)\n                 self.ref_artist.draw(\n                     self.ref_artist.figure._get_renderer())\n                 self.canvas.blit()\n-            self._c1 = self.canvas.callbacks._connect_picklable(\n-                \"motion_notify_event\", self.on_motion)\n+            if hasattr(self, 'canvas') and self.canvas is not None:\n+                self._c1 = self.canvas.callbacks._connect_picklable(\n+                    \"motion_notify_event\", self.on_motion)\n+            self.save_offset()\n             self.save_offset()\n \n     def on_release(self, event):\n@@ -1560,26 +1602,59 @@ class DraggableBase:\n         else:\n             return True\n \n+\n     def disconnect(self):\n         \"\"\"Disconnect the callbacks.\"\"\"\n-        for cid in self.cids:\n-            self.canvas.mpl_disconnect(cid)\n+        if hasattr(self, 'cids'):\n+            for cid in self.cids:\n+                if hasattr(self, 'canvas') and self.canvas is not None:\n+                    self.canvas.mpl_disconnect(cid)\n         try:\n             c1 = self._c1\n         except AttributeError:\n             pass\n         else:\n-            self.canvas.mpl_disconnect(c1)\n-\n-    def save_offset(self):\n-        pass\n-\n-    def update_offset(self, dx, dy):\n-        pass\n-\n-    def finalize_offset(self):\n-        pass\n-\n+            if hasattr(self, 'canvas') and self.canvas is not None:\n+                self.canvas.mpl_disconnect(c1)\n+\n+    def _reconnect_canvas(self):\n+        \"\"\"Reconnect canvas after unpickling if figure is available.\"\"\"\n+        if (hasattr(self, 'ref_artist') and self.ref_artist.figure is not None \n+            and self.ref_artist.figure.canvas is not None):\n+            self.canvas = self.ref_artist.figure.canvas\n+            self.cids = []\n+            # Reconnect pick event\n+            self.cids.append(self.canvas.mpl_connect(\"pick_event\", self.on_pick))\n+\n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by removing unpicklable canvas references.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable entries\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling.\"\"\"\n+        self.__dict__.update(state)\n+        # Canvas will be reconnected when needed\n+\n+    def _reconnect_canvas(self):\n+        \"\"\"Reconnect canvas and event handlers if figure is available.\"\"\"\n+        if (hasattr(self, 'ref_artist') and self.ref_artist is not None \n+            and hasattr(self.ref_artist, 'figure') and self.ref_artist.figure is not None\n+            and self.ref_artist.figure.canvas is not None):\n+            self.canvas = self.ref_artist.figure.canvas\n+            self.cids = [\n+                self.canvas.mpl_connect('pick_event', self.on_pick),\n+                self.canvas.mpl_connect('button_release_event', self.on_release),\n+            ]\n+            if self.use_blit:\n+                self.cids.append(\n+                    self.canvas.mpl_connect('draw_event', self.on_draw)\n+                )\n \n class DraggableOffsetBox(DraggableBase):\n     def __init__(self, ref_artist, offsetbox, use_blit=False):\n",
    "variant_8": "diff --git a/lib/matplotlib/legend.py b/lib/matplotlib/legend.py\nindex ff6abdb958..89f40ef6d7 100644\n--- a/lib/matplotlib/legend.py\n+++ b/lib/matplotlib/legend.py\n@@ -50,6 +50,7 @@ from matplotlib.container import ErrorbarContainer, BarContainer, StemContainer\n from . import legend_handler\n \n \n+\n class DraggableLegend(DraggableOffsetBox):\n     def __init__(self, legend, use_blit=False, update=\"loc\"):\n         \"\"\"\n@@ -93,6 +94,12 @@ class DraggableLegend(DraggableOffsetBox):\n         loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n         self.legend.set_bbox_to_anchor(loc_in_bbox)\n \n+    def __setstate__(self, state):\n+        super().__setstate__(state)\n+        # Attempt to reconnect canvas if legend's figure is available\n+        if (hasattr(self, 'legend') and self.legend.figure is not None \n+            and self.legend.figure.canvas is not None):\n+            self._reconnect_canvas()\n \n _legend_kw_doc_base = \"\"\"\n bbox_to_anchor : `.BboxBase`, 2-tuple, or 4-tuple of floats\ndiff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 1dee8a23d9..edb45c6187 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1500,6 +1500,7 @@ class DraggableBase:\n     coordinate and set a relevant attribute.\n     \"\"\"\n \n+\n     def __init__(self, ref_artist, use_blit=False):\n         self.ref_artist = ref_artist\n         if not ref_artist.pickable():\n@@ -1514,6 +1515,34 @@ class DraggableBase:\n                 'button_release_event', self.on_release),\n         ]\n \n+    def __getstate__(self):\n+        state = self.__dict__.copy()\n+        # Remove unpicklable entries\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        self.__dict__.update(state)\n+        # Canvas will be reconnected when needed\n+        self._reconnect_canvas()\n+\n+    def _reconnect_canvas(self):\n+        \"\"\"Reconnect canvas callbacks if figure and canvas are available.\"\"\"\n+        if (hasattr(self, 'ref_artist') and self.ref_artist is not None\n+            and hasattr(self.ref_artist, 'figure') and self.ref_artist.figure is not None\n+            and hasattr(self.ref_artist.figure, 'canvas') and self.ref_artist.figure.canvas is not None):\n+            self.canvas = self.ref_artist.figure.canvas\n+            self._use_blit = getattr(self, '_use_blit', False) and self.canvas.supports_blit\n+            self.cids = [\n+                self.canvas.callbacks._connect_picklable(\n+                    'pick_event', self.on_pick),\n+                self.canvas.callbacks._connect_picklable(\n+                    'button_release_event', self.on_release),\n+            ]\n+\n     def on_motion(self, evt):\n         if self._check_still_parented() and self.got_artist:\n             dx = evt.x - self.mouse_x\n@@ -1535,13 +1564,24 @@ class DraggableBase:\n             if self._use_blit:\n                 self.ref_artist.set_animated(True)\n                 self.canvas.draw()\n+\n+    def on_pick(self, evt):\n+        if self._check_still_parented() and evt.artist == self.ref_artist:\n+            self.mouse_x = evt.mouseevent.x\n+            self.mouse_y = evt.mouseevent.y\n+            self.got_artist = True\n+            if self._use_blit and hasattr(self, 'canvas') and self.canvas is not None:\n+                self.ref_artist.set_animated(True)\n+                self.canvas.draw()\n                 self.background = \\\n                     self.canvas.copy_from_bbox(self.ref_artist.figure.bbox)\n                 self.ref_artist.draw(\n                     self.ref_artist.figure._get_renderer())\n                 self.canvas.blit()\n-            self._c1 = self.canvas.callbacks._connect_picklable(\n-                \"motion_notify_event\", self.on_motion)\n+            if hasattr(self, 'canvas') and self.canvas is not None:\n+                self._c1 = self.canvas.callbacks._connect_picklable(\n+                    \"motion_notify_event\", self.on_motion)\n+            self.save_offset()\n             self.save_offset()\n \n     def on_release(self, event):\n@@ -1560,6 +1600,7 @@ class DraggableBase:\n         else:\n             return True\n \n+\n     def disconnect(self):\n         \"\"\"Disconnect the callbacks.\"\"\"\n         for cid in self.cids:\n@@ -1571,15 +1612,56 @@ class DraggableBase:\n         else:\n             self.canvas.mpl_disconnect(c1)\n \n-    def save_offset(self):\n-        pass\n-\n-    def update_offset(self, dx, dy):\n-        pass\n-\n-    def finalize_offset(self):\n-        pass\n-\n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by removing unpicklable canvas references.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable entries\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object after unpickling.\"\"\"\n+        self.__dict__.update(state)\n+        # Canvas connections will be restored when needed\n+\n+    def _reconnect_canvas(self):\n+        \"\"\"Reconnect canvas if figure is available.\"\"\"\n+        if (hasattr(self, 'ref_artist') and self.ref_artist.figure is not None \n+            and self.ref_artist.figure.canvas is not None):\n+            self.canvas = self.ref_artist.figure.canvas\n+            self.cids = [\n+                self.canvas.mpl_connect('pick_event', self.on_pick),\n+                self.canvas.mpl_connect('button_release_event', self.on_release),\n+            ]\n+\n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by removing unpicklable canvas references.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove unpicklable entries\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object from pickle and prepare for canvas reconnection.\"\"\"\n+        self.__dict__.update(state)\n+        # Canvas will be reconnected when needed\n+\n+    def _reconnect_canvas(self):\n+        \"\"\"Reconnect canvas and event handlers when figure becomes available.\"\"\"\n+        if (hasattr(self, 'ref_artist') and \n+            self.ref_artist.figure is not None and \n+            self.ref_artist.figure.canvas is not None):\n+            self.canvas = self.ref_artist.figure.canvas\n+            self.cids = [\n+                self.canvas.mpl_connect('pick_event', self.on_pick),\n+                self.canvas.mpl_connect('button_release_event', self.on_release),\n+            ]\n \n class DraggableOffsetBox(DraggableBase):\n     def __init__(self, ref_artist, offsetbox, use_blit=False):\n"
  }
}