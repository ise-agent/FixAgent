{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/django/django/db/migrations/serializer.py lines 124-131)": "\nclass EnumSerializer(BaseSerializer):\n    def serialize(self):\n        enum_class = self.value.__class__\n        module = enum_class.__module__\n        \n        # Handle combined flags by decomposing them\n        if hasattr(enum_class, '_decompose'):\n            # For Flag enums, decompose combined values\n            decomposed, not_covered = enum_class._decompose(self.value)\n            if not_covered:\n                # If there are bits not covered by named flags, fall back to value\n                return (\n                    \"%s.%s(%r)\" % (module, enum_class.__qualname__, self.value.value),\n                    {\"import %s\" % module},\n                )\n            elif len(decomposed) == 1:\n                # Single flag, use name directly\n                return (\n                    \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n                    {\"import %s\" % module},\n                )\n            else:\n                # Combined flags, reconstruct using OR operations\n                flag_names = [flag.name for flag in decomposed]\n                flag_expr = \" | \".join(\"%s.%s.%s\" % (module, enum_class.__qualname__, name) for name in flag_names)\n                return (\n                    flag_expr,\n                    {\"import %s\" % module},\n                )\n        else:\n            # Regular enum, use name\n            return (\n                \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n                {\"import %s\" % module},\n            )\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/django/django/db/migrations/serializer.py lines 124-131)": [
      "\nclass EnumSerializer(BaseSerializer):\n    def serialize(self):\n        enum_class = self.value.__class__\n        module = enum_class.__module__\n        \n        # Handle combined enum flags by decomposing them\n        if hasattr(enum, '_decompose') and hasattr(self.value, '_value_'):\n            # For combined flags, decompose and reconstruct\n            try:\n                # Try to get the name directly first (for single flags)\n                name_repr = repr(self.value.name)\n            except AttributeError:\n                # For combined flags, use enum._decompose to get constituent flags\n                decomposed = enum._decompose(enum_class, self.value._value_)\n                if len(decomposed[1]) > 1:\n                    # Multiple flags combined - reconstruct using bitwise OR\n                    flag_names = [flag.name for flag in decomposed[1]]\n                    name_repr = \" | \".join(f\"{module}.{enum_class.__qualname__}.{name}\" for name in flag_names)\n                    return (name_repr, {\"import %s\" % module})\n                else:\n                    # Single flag from decomposition\n                    name_repr = repr(decomposed[1][0].name)\n        else:\n            # Fallback for regular enums\n            name_repr = repr(self.value.name)\n        \n        return (\n            \"%s.%s[%s]\" % (module, enum_class.__qualname__, name_repr),\n            {\"import %s\" % module},\n        )\n",
      "\nclass EnumSerializer(BaseSerializer):\n    def serialize(self):\n        enum_class = self.value.__class__\n        module = enum_class.__module__\n        \n        # Handle combined flags using _decompose() for Flag/IntFlag enums\n        if hasattr(enum, 'Flag') and isinstance(self.value, enum.Flag):\n            # For combined flags, use _decompose() to get constituent flags\n            try:\n                decomposed = enum._decompose(enum_class, self.value.value)\n                if len(decomposed[1]) > 1:  # Multiple flags combined\n                    flag_names = [flag.name for flag in decomposed[1]]\n                    return (\n                        \"%s.%s[%s]\" % (module, enum_class.__qualname__, \" | \".join(repr(name) for name in flag_names)),\n                        {\"import %s\" % module},\n                    )\n            except (AttributeError, ValueError):\n                pass\n        \n        # Default behavior for single flags and other enums\n        return (\n            \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n            {\"import %s\" % module},\n        )\n",
      "\nclass EnumSerializer(BaseSerializer):\n    def serialize(self):\n        enum_class = self.value.__class__\n        module = enum_class.__module__\n        \n        # Handle combined flags using _decompose for IntFlag/Flag enums\n        if hasattr(enum_class, '_decompose') and hasattr(self.value, '_decompose'):\n            # For combined flags, reconstruct using bitwise OR of component flags\n            flags, _ = self.value._decompose(enum_class, self.value)\n            if len(flags) > 1:\n                flag_parts = []\n                for flag in flags:\n                    flag_parts.append(\"%s.%s.%s\" % (module, enum_class.__qualname__, flag.name))\n                return \" | \".join(flag_parts), {\"import %s\" % module}\n        \n        # Handle single enum values using the original approach\n        return (\n            \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n            {\"import %s\" % module},\n        )\n",
      "\nclass EnumSerializer(BaseSerializer):\n    def serialize(self):\n        enum_class = self.value.__class__\n        module = enum_class.__module__\n        \n        # Handle combined flags by checking if the enum has _decompose method\n        # and if the value's name is None (indicating a combined flag)\n        if hasattr(enum_class, '_decompose') and self.value.name is None:\n            # For combined flags, decompose into constituent flags\n            flags, _ = enum_class._decompose(self.value)\n            if flags:\n                flag_parts = []\n                for flag in flags:\n                    flag_parts.append(\"%s.%s.%s\" % (module, enum_class.__qualname__, flag.name))\n                return \" | \".join(flag_parts), {\"import %s\" % module}\n        \n        # For single flags or non-flag enums, use the original logic\n        return (\n            \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n            {\"import %s\" % module},\n        )\n",
      "\nclass EnumSerializer(BaseSerializer):\n    def serialize(self):\n        enum_class = self.value.__class__\n        module = enum_class.__module__\n        \n        # Handle combined flags by checking if the enum has _decompose method\n        # and if the value is not a single named member\n        if (hasattr(enum_class, '_decompose') and \n            hasattr(self.value, 'name') and self.value.name is None):\n            # This is a combined flag, decompose it\n            members, not_covered = enum_class._decompose(self.value)\n            if not not_covered and members:\n                # Successfully decomposed into known members\n                member_strings = []\n                for member in members:\n                    member_strings.append(\"%s.%s.%s\" % (module, enum_class.__qualname__, member.name))\n                return \" | \".join(member_strings), {\"import %s\" % module}\n        \n        # Single enum member or fallback for non-decomposable values\n        return (\n            \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n            {\"import %s\" % module},\n        )\n",
      "\nclass EnumSerializer(BaseSerializer):\n    def serialize(self):\n        enum_class = self.value.__class__\n        module = enum_class.__module__\n        \n        # Handle combined flags by using _decompose() if available\n        if hasattr(enum, '_decompose') and hasattr(self.value, '_name_') and self.value._name_ is None:\n            # This is a combined flag, use _decompose to get constituent flags\n            flags, _ = enum._decompose(enum_class, self.value)\n            flag_names = [flag.name for flag in flags]\n            if len(flag_names) > 1:\n                flag_expr = \" | \".join(f\"{module}.{enum_class.__qualname__}.{name}\" for name in flag_names)\n                return flag_expr, {\"import %s\" % module}\n        \n        # Handle single flags or fallback for older Python versions\n        if hasattr(self.value, 'name') and self.value.name is not None:\n            return (\n                \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n                {\"import %s\" % module},\n            )\n        else:\n            # Fallback for combined flags when _decompose is not available\n            return (\n                \"%s.%s(%r)\" % (module, enum_class.__qualname__, self.value.value),\n                {\"import %s\" % module},\n            )\n",
      "\nclass EnumSerializer(BaseSerializer):\n    def serialize(self):\n        enum_class = self.value.__class__\n        module = enum_class.__module__\n        \n        # Handle combined flags (like re.UNICODE | re.IGNORECASE)\n        if hasattr(enum_class, '_decompose') and hasattr(self.value, 'name') and self.value.name is None:\n            # This is a combined flag, decompose it\n            flags, _ = enum_class._decompose(self.value)\n            if len(flags) > 1:\n                # Multiple flags combined\n                flag_parts = []\n                for flag in flags:\n                    flag_parts.append(\"%s.%s.%s\" % (module, enum_class.__qualname__, flag.name))\n                return \" | \".join(flag_parts), {\"import %s\" % module}\n        \n        # Handle single flags (existing behavior)\n        return (\n            \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n            {\"import %s\" % module},\n        )\n",
      "\nclass EnumSerializer(BaseSerializer):\n    def serialize(self):\n        enum_class = self.value.__class__\n        module = enum_class.__module__\n        \n        # Handle combined flags by decomposing them\n        if hasattr(enum_class, '_decompose') and hasattr(self.value, '_decompose'):\n            # This is a Flag enum that might be combined\n            try:\n                # Try to get the name first (for single flags)\n                name = self.value.name\n                return (\n                    \"%s.%s[%r]\" % (module, enum_class.__qualname__, name),\n                    {\"import %s\" % module},\n                )\n            except AttributeError:\n                # For combined flags, decompose and reconstruct\n                members, _ = self.value._decompose(enum_class, self.value.value)\n                if members:\n                    member_names = [member.name for member in members]\n                    flag_expr = \" | \".join(\"%s.%s.%s\" % (module, enum_class.__qualname__, name) for name in member_names)\n                    return (\n                        flag_expr,\n                        {\"import %s\" % module},\n                    )\n        \n        # Fallback for regular enums and single flags\n        return (\n            \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n            {\"import %s\" % module},\n        )\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 38da1e6ecc..0d564e63a8 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -121,10 +121,36 @@ class DictionarySerializer(BaseSerializer):\n         return \"{%s}\" % (\", \".join(\"%s: %s\" % (k, v) for k, v in strings)), imports\n \n \n+\n class EnumSerializer(BaseSerializer):\n     def serialize(self):\n         enum_class = self.value.__class__\n         module = enum_class.__module__\n+        \n+        # Handle single enum values (backward compatibility)\n+        if self.value.name is not None:\n+            return (\n+                \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n+                {\"import %s\" % module},\n+            )\n+        \n+        # Handle combined enum flags using _decompose\n+        try:\n+            # Use enum._decompose to get individual flag components\n+            decomposed = enum._decompose(enum_class, self.value.value)\n+            if decomposed:\n+                # Create OR expression from individual flag names\n+                flag_names = [flag.name for flag in decomposed[1]]\n+                if flag_names:\n+                    flag_expr = \" | \".join(\"%s.%s.%s\" % (module, enum_class.__qualname__, name) for name in flag_names)\n+                    return (\n+                        \"(%s)\" % flag_expr,\n+                        {\"import %s\" % module},\n+                    )\n+        except (AttributeError, ValueError):\n+            pass\n+        \n+        # Fallback to original behavior if decomposition fails\n         return (\n             \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n             {\"import %s\" % module},\n",
    "variant_0": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 38da1e6ecc..9296429de2 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -121,14 +121,42 @@ class DictionarySerializer(BaseSerializer):\n         return \"{%s}\" % (\", \".join(\"%s: %s\" % (k, v) for k, v in strings)), imports\n \n \n+\n class EnumSerializer(BaseSerializer):\n     def serialize(self):\n         enum_class = self.value.__class__\n         module = enum_class.__module__\n-        return (\n-            \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n-            {\"import %s\" % module},\n-        )\n+        \n+        # Handle combined flags by decomposing them\n+        if hasattr(enum_class, '_decompose'):\n+            # For Flag enums, decompose combined values\n+            decomposed, not_covered = enum_class._decompose(self.value)\n+            if not_covered:\n+                # If there are bits not covered by named flags, fall back to value\n+                return (\n+                    \"%s.%s(%r)\" % (module, enum_class.__qualname__, self.value.value),\n+                    {\"import %s\" % module},\n+                )\n+            elif len(decomposed) == 1:\n+                # Single flag, use name directly\n+                return (\n+                    \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n+                    {\"import %s\" % module},\n+                )\n+            else:\n+                # Combined flags, reconstruct using OR operations\n+                flag_names = [flag.name for flag in decomposed]\n+                flag_expr = \" | \".join(\"%s.%s.%s\" % (module, enum_class.__qualname__, name) for name in flag_names)\n+                return (\n+                    flag_expr,\n+                    {\"import %s\" % module},\n+                )\n+        else:\n+            # Regular enum, use name\n+            return (\n+                \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n+                {\"import %s\" % module},\n+            )\n \n \n class FloatSerializer(BaseSimpleSerializer):\n",
    "variant_1": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 38da1e6ecc..54f6196b7c 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -121,12 +121,35 @@ class DictionarySerializer(BaseSerializer):\n         return \"{%s}\" % (\", \".join(\"%s: %s\" % (k, v) for k, v in strings)), imports\n \n \n+\n class EnumSerializer(BaseSerializer):\n     def serialize(self):\n         enum_class = self.value.__class__\n         module = enum_class.__module__\n+        \n+        # Handle combined enum flags by decomposing them\n+        if hasattr(enum, '_decompose') and hasattr(self.value, '_value_'):\n+            # For combined flags, decompose and reconstruct\n+            try:\n+                # Try to get the name directly first (for single flags)\n+                name_repr = repr(self.value.name)\n+            except AttributeError:\n+                # For combined flags, use enum._decompose to get constituent flags\n+                decomposed = enum._decompose(enum_class, self.value._value_)\n+                if len(decomposed[1]) > 1:\n+                    # Multiple flags combined - reconstruct using bitwise OR\n+                    flag_names = [flag.name for flag in decomposed[1]]\n+                    name_repr = \" | \".join(f\"{module}.{enum_class.__qualname__}.{name}\" for name in flag_names)\n+                    return (name_repr, {\"import %s\" % module})\n+                else:\n+                    # Single flag from decomposition\n+                    name_repr = repr(decomposed[1][0].name)\n+        else:\n+            # Fallback for regular enums\n+            name_repr = repr(self.value.name)\n+        \n         return (\n-            \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n+            \"%s.%s[%s]\" % (module, enum_class.__qualname__, name_repr),\n             {\"import %s\" % module},\n         )\n \n",
    "variant_2": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 38da1e6ecc..a7aee268e3 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -121,10 +121,27 @@ class DictionarySerializer(BaseSerializer):\n         return \"{%s}\" % (\", \".join(\"%s: %s\" % (k, v) for k, v in strings)), imports\n \n \n+\n class EnumSerializer(BaseSerializer):\n     def serialize(self):\n         enum_class = self.value.__class__\n         module = enum_class.__module__\n+        \n+        # Handle combined flags using _decompose() for Flag/IntFlag enums\n+        if hasattr(enum, 'Flag') and isinstance(self.value, enum.Flag):\n+            # For combined flags, use _decompose() to get constituent flags\n+            try:\n+                decomposed = enum._decompose(enum_class, self.value.value)\n+                if len(decomposed[1]) > 1:  # Multiple flags combined\n+                    flag_names = [flag.name for flag in decomposed[1]]\n+                    return (\n+                        \"%s.%s[%s]\" % (module, enum_class.__qualname__, \" | \".join(repr(name) for name in flag_names)),\n+                        {\"import %s\" % module},\n+                    )\n+            except (AttributeError, ValueError):\n+                pass\n+        \n+        # Default behavior for single flags and other enums\n         return (\n             \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n             {\"import %s\" % module},\n",
    "variant_3": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 38da1e6ecc..0f2212c138 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -121,10 +121,23 @@ class DictionarySerializer(BaseSerializer):\n         return \"{%s}\" % (\", \".join(\"%s: %s\" % (k, v) for k, v in strings)), imports\n \n \n+\n class EnumSerializer(BaseSerializer):\n     def serialize(self):\n         enum_class = self.value.__class__\n         module = enum_class.__module__\n+        \n+        # Handle combined flags using _decompose for IntFlag/Flag enums\n+        if hasattr(enum_class, '_decompose') and hasattr(self.value, '_decompose'):\n+            # For combined flags, reconstruct using bitwise OR of component flags\n+            flags, _ = self.value._decompose(enum_class, self.value)\n+            if len(flags) > 1:\n+                flag_parts = []\n+                for flag in flags:\n+                    flag_parts.append(\"%s.%s.%s\" % (module, enum_class.__qualname__, flag.name))\n+                return \" | \".join(flag_parts), {\"import %s\" % module}\n+        \n+        # Handle single enum values using the original approach\n         return (\n             \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n             {\"import %s\" % module},\n",
    "variant_4": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 38da1e6ecc..b7657e8e07 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -121,10 +121,24 @@ class DictionarySerializer(BaseSerializer):\n         return \"{%s}\" % (\", \".join(\"%s: %s\" % (k, v) for k, v in strings)), imports\n \n \n+\n class EnumSerializer(BaseSerializer):\n     def serialize(self):\n         enum_class = self.value.__class__\n         module = enum_class.__module__\n+        \n+        # Handle combined flags by checking if the enum has _decompose method\n+        # and if the value's name is None (indicating a combined flag)\n+        if hasattr(enum_class, '_decompose') and self.value.name is None:\n+            # For combined flags, decompose into constituent flags\n+            flags, _ = enum_class._decompose(self.value)\n+            if flags:\n+                flag_parts = []\n+                for flag in flags:\n+                    flag_parts.append(\"%s.%s.%s\" % (module, enum_class.__qualname__, flag.name))\n+                return \" | \".join(flag_parts), {\"import %s\" % module}\n+        \n+        # For single flags or non-flag enums, use the original logic\n         return (\n             \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n             {\"import %s\" % module},\n",
    "variant_5": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 38da1e6ecc..115310438e 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -121,10 +121,26 @@ class DictionarySerializer(BaseSerializer):\n         return \"{%s}\" % (\", \".join(\"%s: %s\" % (k, v) for k, v in strings)), imports\n \n \n+\n class EnumSerializer(BaseSerializer):\n     def serialize(self):\n         enum_class = self.value.__class__\n         module = enum_class.__module__\n+        \n+        # Handle combined flags by checking if the enum has _decompose method\n+        # and if the value is not a single named member\n+        if (hasattr(enum_class, '_decompose') and \n+            hasattr(self.value, 'name') and self.value.name is None):\n+            # This is a combined flag, decompose it\n+            members, not_covered = enum_class._decompose(self.value)\n+            if not not_covered and members:\n+                # Successfully decomposed into known members\n+                member_strings = []\n+                for member in members:\n+                    member_strings.append(\"%s.%s.%s\" % (module, enum_class.__qualname__, member.name))\n+                return \" | \".join(member_strings), {\"import %s\" % module}\n+        \n+        # Single enum member or fallback for non-decomposable values\n         return (\n             \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n             {\"import %s\" % module},\n",
    "variant_6": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 38da1e6ecc..e134ecafe9 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -121,14 +121,33 @@ class DictionarySerializer(BaseSerializer):\n         return \"{%s}\" % (\", \".join(\"%s: %s\" % (k, v) for k, v in strings)), imports\n \n \n+\n class EnumSerializer(BaseSerializer):\n     def serialize(self):\n         enum_class = self.value.__class__\n         module = enum_class.__module__\n-        return (\n-            \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n-            {\"import %s\" % module},\n-        )\n+        \n+        # Handle combined flags by using _decompose() if available\n+        if hasattr(enum, '_decompose') and hasattr(self.value, '_name_') and self.value._name_ is None:\n+            # This is a combined flag, use _decompose to get constituent flags\n+            flags, _ = enum._decompose(enum_class, self.value)\n+            flag_names = [flag.name for flag in flags]\n+            if len(flag_names) > 1:\n+                flag_expr = \" | \".join(f\"{module}.{enum_class.__qualname__}.{name}\" for name in flag_names)\n+                return flag_expr, {\"import %s\" % module}\n+        \n+        # Handle single flags or fallback for older Python versions\n+        if hasattr(self.value, 'name') and self.value.name is not None:\n+            return (\n+                \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n+                {\"import %s\" % module},\n+            )\n+        else:\n+            # Fallback for combined flags when _decompose is not available\n+            return (\n+                \"%s.%s(%r)\" % (module, enum_class.__qualname__, self.value.value),\n+                {\"import %s\" % module},\n+            )\n \n \n class FloatSerializer(BaseSimpleSerializer):\n",
    "variant_7": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 38da1e6ecc..6ef922f2cb 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -121,10 +121,24 @@ class DictionarySerializer(BaseSerializer):\n         return \"{%s}\" % (\", \".join(\"%s: %s\" % (k, v) for k, v in strings)), imports\n \n \n+\n class EnumSerializer(BaseSerializer):\n     def serialize(self):\n         enum_class = self.value.__class__\n         module = enum_class.__module__\n+        \n+        # Handle combined flags (like re.UNICODE | re.IGNORECASE)\n+        if hasattr(enum_class, '_decompose') and hasattr(self.value, 'name') and self.value.name is None:\n+            # This is a combined flag, decompose it\n+            flags, _ = enum_class._decompose(self.value)\n+            if len(flags) > 1:\n+                # Multiple flags combined\n+                flag_parts = []\n+                for flag in flags:\n+                    flag_parts.append(\"%s.%s.%s\" % (module, enum_class.__qualname__, flag.name))\n+                return \" | \".join(flag_parts), {\"import %s\" % module}\n+        \n+        # Handle single flags (existing behavior)\n         return (\n             \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n             {\"import %s\" % module},\n",
    "variant_8": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 38da1e6ecc..9035be9bc0 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -121,10 +121,34 @@ class DictionarySerializer(BaseSerializer):\n         return \"{%s}\" % (\", \".join(\"%s: %s\" % (k, v) for k, v in strings)), imports\n \n \n+\n class EnumSerializer(BaseSerializer):\n     def serialize(self):\n         enum_class = self.value.__class__\n         module = enum_class.__module__\n+        \n+        # Handle combined flags by decomposing them\n+        if hasattr(enum_class, '_decompose') and hasattr(self.value, '_decompose'):\n+            # This is a Flag enum that might be combined\n+            try:\n+                # Try to get the name first (for single flags)\n+                name = self.value.name\n+                return (\n+                    \"%s.%s[%r]\" % (module, enum_class.__qualname__, name),\n+                    {\"import %s\" % module},\n+                )\n+            except AttributeError:\n+                # For combined flags, decompose and reconstruct\n+                members, _ = self.value._decompose(enum_class, self.value.value)\n+                if members:\n+                    member_names = [member.name for member in members]\n+                    flag_expr = \" | \".join(\"%s.%s.%s\" % (module, enum_class.__qualname__, name) for name in member_names)\n+                    return (\n+                        flag_expr,\n+                        {\"import %s\" % module},\n+                    )\n+        \n+        # Fallback for regular enums and single flags\n         return (\n             \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n             {\"import %s\" % module},\n"
  }
}