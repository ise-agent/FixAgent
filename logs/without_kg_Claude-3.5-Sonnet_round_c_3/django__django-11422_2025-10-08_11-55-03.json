{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/django/django/utils/autoreload.py lines 239-249)": "\n    def watched_files(self, include_globs=True):\n        \"\"\"\n        Yield all files that need to be watched, including module files and\n        files within globs.\n        \"\"\"\n        yield from iter_all_python_module_files()\n        yield from self.extra_files\n        \n        # Include the main script file if it exists and is a Python file\n        if sys.argv and sys.argv[0]:\n            main_script = Path(sys.argv[0]).resolve()\n            if main_script.exists() and main_script.suffix == '.py':\n                yield main_script\n        \n        if include_globs:\n            for directory, patterns in self.directory_globs.items():\n                for pattern in patterns:\n                    yield from directory.glob(pattern)\n",
    "Location 2 (/root/hy/projects_3/django/django/utils/autoreload.py lines 99-108)": "\ndef iter_all_python_module_files():\n    # This is a hot path during reloading. Create a stable sorted list of\n    # modules based on the module name and pass it to iter_modules_and_files().\n    # This ensures cached results are returned in the usual case that modules\n    # aren't loaded on the fly.\n    keys = sorted(sys.modules)\n    modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n    \n    # Include the main script file (e.g., manage.py) if it's a Python file\n    main_script_files = set()\n    if sys.argv and sys.argv[0]:\n        main_script = Path(sys.argv[0])\n        if main_script.exists() and main_script.suffix == '.py':\n            main_script_files.add(main_script.resolve())\n    \n    # Combine error files with main script files\n    extra_files = frozenset(_error_files) | frozenset(main_script_files)\n    \n    return iter_modules_and_files(modules, extra_files)\n",
    "Location 3 (/root/hy/projects_3/django/django/utils/autoreload.py lines 187-202)": "\ndef get_child_arguments():\n    \"\"\"\n    Return the executable. This contains a workaround for Windows if the\n    executable is reported to not have the .exe extension which can cause bugs\n    on reloading.\n    \"\"\"\n    import django.__main__\n\n    args = [sys.executable] + ['-W%s' % o for o in sys.warnoptions]\n    if sys.argv[0] == django.__main__.__file__:\n        # The server was started with `python -m django runserver`.\n        args += ['-m', 'django']\n        args += sys.argv[1:]\n    else:\n        args += sys.argv\n    return args\n\n\ndef get_main_script_file():\n    \"\"\"\n    Return the main script file path if it exists and is a Python file.\n    This utility function helps identify the main script across different\n    execution contexts.\n    \"\"\"\n    if not sys.argv:\n        return None\n    \n    main_script = sys.argv[0]\n    if not main_script:\n        return None\n    \n    # Convert to Path object for easier handling\n    script_path = Path(main_script)\n    \n    # Check if it's a Python file and exists\n    if script_path.exists() and script_path.suffix == '.py':\n        return script_path.resolve().absolute()\n    \n    return None\n",
    "Location 4 (/root/hy/projects_3/django/django/utils/autoreload.py lines 577-583)": "\ndef run_with_reloader(main_func, *args, **kwargs):\n    signal.signal(signal.SIGTERM, lambda *args: sys.exit(0))\n    try:\n        if os.environ.get(DJANGO_AUTORELOAD_ENV) == 'true':\n            reloader = get_reloader()\n            # Ensure the main script file is watched\n            main_script = Path(sys.argv[0]).resolve()\n            if main_script.suffix == '.py' and main_script.is_file():\n                reloader.watch_file(main_script)\n            logger.info('Watching for file changes with %s', reloader.__class__.__name__)\n            start_django(reloader, main_func, *args, **kwargs)\n        else:\n            exit_code = restart_with_reloader()\n            sys.exit(exit_code)\n    except KeyboardInterrupt:\n        pass\n",
    "Location 5 (/root/hy/projects_3/django/django/utils/autoreload.py lines 219-224)": "\nclass BaseReloader:\n    def __init__(self):\n        self.extra_files = set()\n        self.directory_globs = defaultdict(set)\n        self._stop_condition = threading.Event()\n        \n        # Add the main script file to watched files if it exists and is a Python file\n        main_script = Path(sys.argv[0]).resolve()\n        if main_script.exists() and main_script.suffix == '.py':\n            self.extra_files.add(main_script)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/django/django/utils/autoreload.py lines 239-249)": [
      "\n    def watched_files(self, include_globs=True):\n        \"\"\"\n        Yield all files that need to be watched, including module files and\n        files within globs.\n        \"\"\"\n        yield from iter_all_python_module_files()\n        yield from self.extra_files\n        \n        # Include the main script file if it exists and is a Python file\n        if sys.argv and sys.argv[0]:\n            main_script = Path(sys.argv[0]).resolve()\n            if main_script.exists() and main_script.suffix == '.py':\n                yield main_script\n                \n        if include_globs:\n            for directory, patterns in self.directory_globs.items():\n                for pattern in patterns:\n                    yield from directory.glob(pattern)\n",
      "\n    def watched_files(self, include_globs=True):\n        \"\"\"\n        Yield all files that need to be watched, including module files and\n        files within globs.\n        \"\"\"\n        yield from iter_all_python_module_files()\n        yield from self.extra_files\n        \n        # Include the main script file (manage.py or __main__.py)\n        main_script = Path(sys.argv[0]).resolve()\n        if main_script.exists() and main_script.suffix == '.py':\n            yield main_script\n            \n        if include_globs:\n            for directory, patterns in self.directory_globs.items():\n                for pattern in patterns:\n                    yield from directory.glob(pattern)\n",
      "\n    def watched_files(self, include_globs=True):\n        \"\"\"\n        Yield all files that need to be watched, including module files and\n        files within globs.\n        \"\"\"\n        yield from iter_all_python_module_files()\n        yield from self.extra_files\n        \n        # Watch the main script file (manage.py or equivalent)\n        main_script = sys.argv[0] if sys.argv else None\n        if main_script:\n            main_script_path = Path(main_script).resolve()\n            if main_script_path.exists() and main_script_path.suffix == '.py':\n                yield main_script_path\n        \n        if include_globs:\n            for directory, patterns in self.directory_globs.items():\n                for pattern in patterns:\n                    yield from directory.glob(pattern)\n",
      "\n    def watched_files(self, include_globs=True):\n        \"\"\"\n        Yield all files that need to be watched, including module files and\n        files within globs.\n        \"\"\"\n        yield from iter_all_python_module_files()\n        yield from self.extra_files\n        \n        # Include the main script file if it's a Python file\n        if sys.argv and sys.argv[0]:\n            main_script = Path(sys.argv[0]).resolve()\n            if main_script.suffix == '.py' and main_script.exists():\n                yield main_script\n        \n        if include_globs:\n            for directory, patterns in self.directory_globs.items():\n                for pattern in patterns:\n                    yield from directory.glob(pattern)\n",
      "\n    def watched_files(self, include_globs=True):\n        \"\"\"\n        Yield all files that need to be watched, including module files and\n        files within globs.\n        \"\"\"\n        yield from iter_all_python_module_files()\n        yield from self.extra_files\n        \n        # Include the main script file if it's a Python file and not already included\n        if sys.argv and sys.argv[0]:\n            main_script = Path(sys.argv[0])\n            if main_script.exists() and main_script.suffix == '.py':\n                main_script = main_script.resolve()\n                # Only yield if not already in extra_files to avoid duplicates\n                if main_script not in self.extra_files:\n                    yield main_script\n        \n        if include_globs:\n            for directory, patterns in self.directory_globs.items():\n                for pattern in patterns:\n                    yield from directory.glob(pattern)\n",
      "\n    def watched_files(self, include_globs=True):\n        \"\"\"\n        Yield all files that need to be watched, including module files and\n        files within globs.\n        \"\"\"\n        yield from iter_all_python_module_files()\n        yield from self.extra_files\n        \n        # Include the main script file (e.g., manage.py) if it exists\n        if sys.argv and sys.argv[0]:\n            main_script = Path(sys.argv[0]).resolve()\n            if main_script.exists() and main_script.suffix == '.py':\n                yield main_script\n        \n        if include_globs:\n            for directory, patterns in self.directory_globs.items():\n                for pattern in patterns:\n                    yield from directory.glob(pattern)\n",
      "\n    def watched_files(self, include_globs=True):\n        \"\"\"\n        Yield all files that need to be watched, including module files and\n        files within globs.\n        \"\"\"\n        yield from iter_all_python_module_files()\n        yield from self.extra_files\n        \n        # Include the main script file if it exists and is a Python file\n        if sys.argv and sys.argv[0]:\n            main_script = Path(sys.argv[0]).resolve()\n            if main_script.suffix == '.py' and main_script.is_file():\n                yield main_script\n        \n        if include_globs:\n            for directory, patterns in self.directory_globs.items():\n                for pattern in patterns:\n                    yield from directory.glob(pattern)\n",
      "\n    def watched_files(self, include_globs=True):\n        \"\"\"\n        Yield all files that need to be watched, including module files and\n        files within globs.\n        \"\"\"\n        yield from iter_all_python_module_files()\n        yield from self.extra_files\n        \n        # Include the main script file (e.g., manage.py) if it exists and is a Python file\n        if sys.argv and sys.argv[0]:\n            main_script = Path(sys.argv[0]).resolve()\n            if main_script.exists() and main_script.suffix == '.py':\n                yield main_script\n        \n        if include_globs:\n            for directory, patterns in self.directory_globs.items():\n                for pattern in patterns:\n                    yield from directory.glob(pattern)\n"
    ],
    "Location 2 (/root/hy/projects_3/django/django/utils/autoreload.py lines 99-108)": [
      "\ndef iter_all_python_module_files():\n    # This is a hot path during reloading. Create a stable sorted list of\n    # modules based on the module name and pass it to iter_modules_and_files().\n    # This ensures cached results are returned in the usual case that modules\n    # aren't loaded on the fly.\n    keys = sorted(sys.modules)\n    modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n    \n    # Yield files from modules\n    yield from iter_modules_and_files(modules, frozenset(_error_files))\n    \n    # Also yield the main script file if it exists and is a Python file\n    if sys.argv and sys.argv[0]:\n        main_script = Path(sys.argv[0]).resolve()\n        if main_script.suffix == '.py' and main_script.is_file():\n            yield main_script\n",
      "\ndef iter_all_python_module_files():\n    # This is a hot path during reloading. Create a stable sorted list of\n    # modules based on the module name and pass it to iter_modules_and_files().\n    # This ensures cached results are returned in the usual case that modules\n    # aren't loaded on the fly.\n    keys = sorted(sys.modules)\n    modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n    \n    # Yield files from modules\n    yield from iter_modules_and_files(modules, frozenset(_error_files))\n    \n    # Also yield the main script file if it exists and is a Python file\n    if sys.argv and sys.argv[0]:\n        main_script = Path(sys.argv[0]).resolve()\n        if main_script.suffix == '.py' and main_script.is_file():\n            yield main_script\n",
      "\ndef iter_all_python_module_files():\n    # This is a hot path during reloading. Create a stable sorted list of\n    # modules based on the module name and pass it to iter_modules_and_files().\n    # This ensures cached results are returned in the usual case that modules\n    # aren't loaded on the fly.\n    keys = sorted(sys.modules)\n    modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n    \n    # Include the main script file (manage.py) which isn't in sys.modules\n    main_script = None\n    if sys.argv and sys.argv[0]:\n        main_script_path = pathlib.Path(sys.argv[0])\n        if main_script_path.suffix == '.py' and main_script_path.exists():\n            main_script = main_script_path.resolve()\n    \n    for path in iter_modules_and_files(modules, frozenset(_error_files)):\n        yield path\n    \n    if main_script:\n        yield main_script\n",
      "\ndef iter_all_python_module_files():\n    # This is a hot path during reloading. Create a stable sorted list of\n    # modules based on the module name and pass it to iter_modules_and_files().\n    # This ensures cached results are returned in the usual case that modules\n    # aren't loaded on the fly.\n    keys = sorted(sys.modules)\n    modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n    \n    # Also yield the main script file if it exists and is a Python file\n    main_script = sys.argv[0] if sys.argv else None\n    if main_script and main_script.endswith('.py') and os.path.isfile(main_script):\n        yield Path(main_script).resolve()\n    \n    yield from iter_modules_and_files(modules, frozenset(_error_files))\n",
      "\ndef iter_all_python_module_files():\n    # This is a hot path during reloading. Create a stable sorted list of\n    # modules based on the module name and pass it to iter_modules_and_files().\n    # This ensures cached results are returned in the usual case that modules\n    # aren't loaded on the fly.\n    keys = sorted(sys.modules)\n    modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n    \n    # Also include the main script file if it exists and is a Python file\n    main_script_path = None\n    if sys.argv and sys.argv[0]:\n        script_path = Path(sys.argv[0]).resolve()\n        if script_path.exists() and script_path.suffix == '.py':\n            main_script_path = script_path\n    \n    result = iter_modules_and_files(modules, frozenset(_error_files))\n    \n    # Yield the main script file if it's not already included\n    if main_script_path:\n        yield main_script_path\n    \n    # Yield all other files from iter_modules_and_files\n    yield from result\n",
      "\ndef iter_all_python_module_files():\n    # This is a hot path during reloading. Create a stable sorted list of\n    # modules based on the module name and pass it to iter_modules_and_files().\n    # This ensures cached results are returned in the usual case that modules\n    # aren't loaded on the fly.\n    keys = sorted(sys.modules)\n    modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n    \n    # Include the main script file if it exists and is a Python file\n    extra_files = set(_error_files)\n    if sys.argv and sys.argv[0]:\n        main_script = pathlib.Path(sys.argv[0]).resolve()\n        if main_script.suffix == '.py' and main_script.is_file():\n            extra_files.add(main_script)\n    \n    return iter_modules_and_files(modules, frozenset(extra_files))\n",
      "\ndef iter_all_python_module_files():\n    # This is a hot path during reloading. Create a stable sorted list of\n    # modules based on the module name and pass it to iter_modules_and_files().\n    # This ensures cached results are returned in the usual case that modules\n    # aren't loaded on the fly.\n    keys = sorted(sys.modules)\n    modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n    \n    # Include the main script file if it exists and is a Python file\n    main_script = None\n    if sys.argv and sys.argv[0]:\n        main_script_path = Path(sys.argv[0]).resolve()\n        if main_script_path.exists() and main_script_path.suffix == '.py':\n            main_script = main_script_path\n    \n    for file_path in iter_modules_and_files(modules, frozenset(_error_files)):\n        yield file_path\n    \n    # Yield the main script file if it's not already included\n    if main_script is not None:\n        yield main_script\n",
      "\ndef iter_all_python_module_files():\n    # This is a hot path during reloading. Create a stable sorted list of\n    # modules based on the module name and pass it to iter_modules_and_files().\n    # This ensures cached results are returned in the usual case that modules\n    # aren't loaded on the fly.\n    keys = sorted(sys.modules)\n    modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n    \n    # Include the main script file (e.g., manage.py) if it exists and is a Python file\n    main_script_path = None\n    if sys.argv and sys.argv[0]:\n        script_path = Path(sys.argv[0])\n        if script_path.exists() and script_path.suffix == '.py':\n            main_script_path = script_path.resolve()\n    \n    # Yield files from modules\n    for file_path in iter_modules_and_files(modules, frozenset(_error_files)):\n        yield file_path\n    \n    # Yield the main script file if it's not already included\n    if main_script_path and main_script_path not in frozenset(_error_files):\n        yield main_script_path\n"
    ],
    "Location 3 (/root/hy/projects_3/django/django/utils/autoreload.py lines 187-202)": [
      "\ndef get_child_arguments():\n    \"\"\"\n    Return the executable. This contains a workaround for Windows if the\n    executable is reported to not have the .exe extension which can cause bugs\n    on reloading.\n    \"\"\"\n    import django.__main__\n\n    args = [sys.executable] + ['-W%s' % o for o in sys.warnoptions]\n    if sys.argv[0] == django.__main__.__file__:\n        # The server was started with `python -m django runserver`.\n        args += ['-m', 'django']\n        args += sys.argv[1:]\n    else:\n        args += sys.argv\n    return args\n\n\ndef get_main_script_file():\n    \"\"\"\n    Return the main script file path if it exists and is a Python file.\n    This handles both `python manage.py runserver` and `python -m django runserver` cases.\n    \"\"\"\n    import django.__main__\n    \n    if sys.argv[0] == django.__main__.__file__:\n        # Started with `python -m django runserver`, main script is django.__main__\n        return Path(django.__main__.__file__).resolve()\n    else:\n        # Started with `python manage.py runserver` or similar\n        main_script = Path(sys.argv[0])\n        if main_script.exists() and main_script.suffix == '.py':\n            return main_script.resolve()\n    return None\n",
      "\ndef get_child_arguments():\n    \"\"\"\n    Return the executable. This contains a workaround for Windows if the\n    executable is reported to not have the .exe extension which can cause bugs\n    on reloading.\n    \"\"\"\n    import django.__main__\n\n    args = [sys.executable] + ['-W%s' % o for o in sys.warnoptions]\n    if sys.argv[0] == django.__main__.__file__:\n        # The server was started with `python -m django runserver`.\n        args += ['-m', 'django']\n        args += sys.argv[1:]\n    else:\n        args += sys.argv\n    return args\n\n\ndef get_main_script_file():\n    \"\"\"\n    Return the main script file path if it exists and is a Python file.\n    This handles both `python manage.py runserver` and `python -m django runserver` cases.\n    \"\"\"\n    import django.__main__\n    \n    if sys.argv[0] == django.__main__.__file__:\n        # Started with `python -m django runserver`\n        return None\n    \n    script_path = Path(sys.argv[0])\n    if script_path.exists() and script_path.suffix == '.py':\n        return script_path.resolve()\n    return None\n",
      "\ndef get_child_arguments():\n    \"\"\"\n    Return the executable. This contains a workaround for Windows if the\n    executable is reported to not have the .exe extension which can cause bugs\n    on reloading.\n    \"\"\"\n    import django.__main__\n\n    args = [sys.executable] + ['-W%s' % o for o in sys.warnoptions]\n    if sys.argv[0] == django.__main__.__file__:\n        # The server was started with `python -m django runserver`.\n        args += ['-m', 'django']\n        args += sys.argv[1:]\n    else:\n        args += sys.argv\n    return args\n\n\ndef get_main_script_file():\n    \"\"\"\n    Return the main script file path if it exists and is a Python file.\n    This handles both `python manage.py runserver` and `python -m django runserver` cases.\n    \"\"\"\n    import django.__main__\n    \n    if sys.argv[0] == django.__main__.__file__:\n        # Started with `python -m django runserver`\n        return None\n    \n    main_script = pathlib.Path(sys.argv[0])\n    if main_script.exists() and main_script.suffix == '.py':\n        return main_script.resolve().absolute()\n    return None\n",
      "\ndef get_child_arguments():\n    \"\"\"\n    Return the executable. This contains a workaround for Windows if the\n    executable is reported to not have the .exe extension which can cause bugs\n    on reloading.\n    \"\"\"\n    import django.__main__\n\n    args = [sys.executable] + ['-W%s' % o for o in sys.warnoptions]\n    if sys.argv[0] == django.__main__.__file__:\n        # The server was started with `python -m django runserver`.\n        args += ['-m', 'django']\n        args += sys.argv[1:]\n    else:\n        args += sys.argv\n    return args\n\n\ndef get_main_script_file():\n    \"\"\"\n    Return the main script file path if it exists and is a Python file.\n    This handles both direct script execution and module execution scenarios.\n    \"\"\"\n    import django.__main__\n    \n    # Handle python -m django runserver case\n    if sys.argv[0] == django.__main__.__file__:\n        # Look for manage.py in the current directory as a fallback\n        manage_py = Path.cwd() / 'manage.py'\n        if manage_py.exists():\n            return manage_py.resolve().absolute()\n        return None\n    \n    # Handle direct script execution case (python manage.py runserver)\n    script_path = Path(sys.argv[0])\n    if script_path.exists() and script_path.suffix == '.py':\n        return script_path.resolve().absolute()\n    \n    return None\n",
      "\ndef get_child_arguments():\n    \"\"\"\n    Return the executable. This contains a workaround for Windows if the\n    executable is reported to not have the .exe extension which can cause bugs\n    on reloading.\n    \"\"\"\n    import django.__main__\n\n    args = [sys.executable] + ['-W%s' % o for o in sys.warnoptions]\n    if sys.argv[0] == django.__main__.__file__:\n        # The server was started with `python -m django runserver`.\n        args += ['-m', 'django']\n        args += sys.argv[1:]\n    else:\n        args += sys.argv\n    return args\n\n\ndef get_main_script_file():\n    \"\"\"\n    Return the main script file path if it exists and is a Python file.\n    This is used to ensure the main script (like manage.py) is watched for changes.\n    \"\"\"\n    if not sys.argv or not sys.argv[0]:\n        return None\n    \n    main_script = Path(sys.argv[0])\n    if main_script.exists() and main_script.suffix == '.py':\n        return main_script.resolve().absolute()\n    return None\n",
      "\ndef get_child_arguments():\n    \"\"\"\n    Return the executable. This contains a workaround for Windows if the\n    executable is reported to not have the .exe extension which can cause bugs\n    on reloading.\n    \"\"\"\n    import django.__main__\n\n    args = [sys.executable] + ['-W%s' % o for o in sys.warnoptions]\n    if sys.argv[0] == django.__main__.__file__:\n        # The server was started with `python -m django runserver`.\n        args += ['-m', 'django']\n        args += sys.argv[1:]\n    else:\n        args += sys.argv\n    return args\n\n\ndef get_main_script_file():\n    \"\"\"\n    Return the main script file path if it exists and is a Python file.\n    This is used to ensure the main script (like manage.py) is watched for changes.\n    \"\"\"\n    if not sys.argv:\n        return None\n    \n    main_script = sys.argv[0]\n    if not main_script:\n        return None\n    \n    try:\n        script_path = Path(main_script).resolve()\n        if script_path.exists() and script_path.suffix == '.py':\n            return script_path\n    except (OSError, ValueError):\n        pass\n    \n    return None\n",
      "\ndef get_child_arguments():\n    \"\"\"\n    Return the executable. This contains a workaround for Windows if the\n    executable is reported to not have the .exe extension which can cause bugs\n    on reloading.\n    \"\"\"\n    import django.__main__\n\n    args = [sys.executable] + ['-W%s' % o for o in sys.warnoptions]\n    if sys.argv[0] == django.__main__.__file__:\n        # The server was started with `python -m django runserver`.\n        args += ['-m', 'django']\n        args += sys.argv[1:]\n    else:\n        args += sys.argv\n    return args\n\n\ndef get_main_script_file():\n    \"\"\"\n    Return the main script file path if it exists and is a Python file.\n    This handles both `python manage.py runserver` and `python -m django runserver` cases.\n    \"\"\"\n    import django.__main__\n    \n    if sys.argv[0] == django.__main__.__file__:\n        # Started with `python -m django runserver` - no main script file to watch\n        return None\n    \n    main_script = Path(sys.argv[0])\n    if main_script.exists() and main_script.suffix == '.py':\n        return main_script.resolve().absolute()\n    \n    return None\n",
      "\ndef get_child_arguments():\n    \"\"\"\n    Return the executable. This contains a workaround for Windows if the\n    executable is reported to not have the .exe extension which can cause bugs\n    on reloading.\n    \"\"\"\n    import django.__main__\n\n    args = [sys.executable] + ['-W%s' % o for o in sys.warnoptions]\n    if sys.argv[0] == django.__main__.__file__:\n        # The server was started with `python -m django runserver`.\n        args += ['-m', 'django']\n        args += sys.argv[1:]\n    else:\n        args += sys.argv\n    return args\n\n\ndef get_main_script_file():\n    \"\"\"\n    Return the main script file being executed, or None if it's not a Python file.\n    This handles both `python manage.py runserver` and `python -m django runserver` cases.\n    \"\"\"\n    import django.__main__\n    \n    if sys.argv[0] == django.__main__.__file__:\n        # Started with `python -m django runserver`\n        return None\n    \n    main_script = Path(sys.argv[0])\n    if main_script.exists() and main_script.suffix == '.py':\n        return main_script.resolve().absolute()\n    \n    return None\n"
    ],
    "Location 4 (/root/hy/projects_3/django/django/utils/autoreload.py lines 577-583)": [
      "\ndef run_with_reloader(main_func, *args, **kwargs):\n    signal.signal(signal.SIGTERM, lambda *args: sys.exit(0))\n    try:\n        if os.environ.get(DJANGO_AUTORELOAD_ENV) == 'true':\n            reloader = get_reloader()\n            # Ensure the main script file is watched\n            main_script = Path(sys.argv[0]).resolve()\n            if main_script.exists() and main_script.suffix == '.py':\n                reloader.watch_file(main_script)\n            logger.info('Watching for file changes with %s', reloader.__class__.__name__)\n            start_django(reloader, main_func, *args, **kwargs)\n        else:\n            exit_code = restart_with_reloader()\n            sys.exit(exit_code)\n    except KeyboardInterrupt:\n        pass\n",
      "\ndef run_with_reloader(main_func, *args, **kwargs):\n    signal.signal(signal.SIGTERM, lambda *args: sys.exit(0))\n    try:\n        if os.environ.get(DJANGO_AUTORELOAD_ENV) == 'true':\n            reloader = get_reloader()\n            # Ensure the main script file is being watched\n            main_script = Path(sys.argv[0]).resolve()\n            if main_script.exists() and main_script.suffix == '.py':\n                reloader.watch_file(main_script)\n            logger.info('Watching for file changes with %s', reloader.__class__.__name__)\n            start_django(reloader, main_func, *args, **kwargs)\n        else:\n            exit_code = restart_with_reloader()\n            sys.exit(exit_code)\n    except KeyboardInterrupt:\n        pass\n",
      "\ndef run_with_reloader(main_func, *args, **kwargs):\n    signal.signal(signal.SIGTERM, lambda *args: sys.exit(0))\n    try:\n        if os.environ.get(DJANGO_AUTORELOAD_ENV) == 'true':\n            reloader = get_reloader()\n            \n            # Ensure the main script file is watched\n            main_script = sys.argv[0] if sys.argv else None\n            if main_script and os.path.isfile(main_script) and main_script.endswith('.py'):\n                reloader.watch_file(Path(main_script))\n            \n            logger.info('Watching for file changes with %s', reloader.__class__.__name__)\n            start_django(reloader, main_func, *args, **kwargs)\n        else:\n            exit_code = restart_with_reloader()\n            sys.exit(exit_code)\n    except KeyboardInterrupt:\n        pass\n",
      "\ndef run_with_reloader(main_func, *args, **kwargs):\n    signal.signal(signal.SIGTERM, lambda *args: sys.exit(0))\n    try:\n        if os.environ.get(DJANGO_AUTORELOAD_ENV) == 'true':\n            reloader = get_reloader()\n            # Ensure the main script is watched for changes\n            main_script = Path(sys.argv[0]).resolve()\n            if main_script.suffix == '.py' and main_script.exists():\n                reloader.watch_file(main_script)\n            logger.info('Watching for file changes with %s', reloader.__class__.__name__)\n            start_django(reloader, main_func, *args, **kwargs)\n        else:\n            exit_code = restart_with_reloader()\n            sys.exit(exit_code)\n    except KeyboardInterrupt:\n        pass\n",
      "\ndef run_with_reloader(main_func, *args, **kwargs):\n    signal.signal(signal.SIGTERM, lambda *args: sys.exit(0))\n    try:\n        if os.environ.get(DJANGO_AUTORELOAD_ENV) == 'true':\n            reloader = get_reloader()\n            # Ensure the main script file is watched\n            main_script = Path(sys.argv[0])\n            if main_script.exists() and main_script.suffix == '.py':\n                reloader.watch_file(main_script)\n            logger.info('Watching for file changes with %s', reloader.__class__.__name__)\n            start_django(reloader, main_func, *args, **kwargs)\n        else:\n            exit_code = restart_with_reloader()\n            sys.exit(exit_code)\n    except KeyboardInterrupt:\n        pass\n",
      "\ndef run_with_reloader(main_func, *args, **kwargs):\n    signal.signal(signal.SIGTERM, lambda *args: sys.exit(0))\n    try:\n        if os.environ.get(DJANGO_AUTORELOAD_ENV) == 'true':\n            reloader = get_reloader()\n            # Add the main script file to watched files to ensure changes are detected\n            main_script = Path(sys.argv[0]).resolve()\n            if main_script.exists() and main_script.suffix == '.py':\n                reloader.watch_file(main_script)\n            logger.info('Watching for file changes with %s', reloader.__class__.__name__)\n            start_django(reloader, main_func, *args, **kwargs)\n        else:\n            exit_code = restart_with_reloader()\n            sys.exit(exit_code)\n    except KeyboardInterrupt:\n        pass\n",
      "\ndef run_with_reloader(main_func, *args, **kwargs):\n    signal.signal(signal.SIGTERM, lambda *args: sys.exit(0))\n    try:\n        if os.environ.get(DJANGO_AUTORELOAD_ENV) == 'true':\n            reloader = get_reloader()\n            # Ensure the main script file is watched for changes\n            main_script = Path(sys.argv[0]).resolve()\n            if main_script.exists() and main_script.suffix == '.py':\n                reloader.watch_file(main_script)\n            logger.info('Watching for file changes with %s', reloader.__class__.__name__)\n            start_django(reloader, main_func, *args, **kwargs)\n        else:\n            exit_code = restart_with_reloader()\n            sys.exit(exit_code)\n    except KeyboardInterrupt:\n        pass\n",
      "\ndef run_with_reloader(main_func, *args, **kwargs):\n    signal.signal(signal.SIGTERM, lambda *args: sys.exit(0))\n    try:\n        if os.environ.get(DJANGO_AUTORELOAD_ENV) == 'true':\n            reloader = get_reloader()\n            # Ensure the main script file is watched\n            main_script = Path(sys.argv[0]).resolve()\n            if main_script.suffix == '.py' and main_script.exists():\n                reloader.watch_file(main_script)\n            logger.info('Watching for file changes with %s', reloader.__class__.__name__)\n            start_django(reloader, main_func, *args, **kwargs)\n        else:\n            exit_code = restart_with_reloader()\n            sys.exit(exit_code)\n    except KeyboardInterrupt:\n        pass\n"
    ],
    "Location 5 (/root/hy/projects_3/django/django/utils/autoreload.py lines 219-224)": [
      "\nclass BaseReloader:\n    def __init__(self):\n        self.extra_files = set()\n        self.directory_globs = defaultdict(set)\n        self._stop_condition = threading.Event()\n        \n        # Automatically watch the main script file (manage.py or equivalent)\n        main_script = Path(sys.argv[0]).resolve()\n        if main_script.exists() and main_script.suffix == '.py':\n            self.extra_files.add(main_script)\n",
      "\nclass BaseReloader:\n    def __init__(self):\n        self.extra_files = set()\n        self.directory_globs = defaultdict(set)\n        self._stop_condition = threading.Event()\n        \n        # Add the main script file to watched files\n        main_script = sys.argv[0] if sys.argv else None\n        if main_script and os.path.isfile(main_script) and main_script.endswith('.py'):\n            self.extra_files.add(Path(main_script).resolve())\n",
      "\nclass BaseReloader:\n    def __init__(self):\n        self.extra_files = set()\n        self.directory_globs = defaultdict(set)\n        self._stop_condition = threading.Event()\n        \n        # Add the main script file to watched files if it's a Python file\n        main_script = Path(sys.argv[0]).resolve()\n        if main_script.suffix == '.py' and main_script.is_file():\n            self.extra_files.add(main_script)\n",
      "\nclass BaseReloader:\n    def __init__(self):\n        self.extra_files = set()\n        self.directory_globs = defaultdict(set)\n        self._stop_condition = threading.Event()\n        # Add the main script file to watched files\n        main_script = Path(sys.argv[0]).resolve()\n        if main_script.exists() and main_script.suffix == '.py':\n            self.extra_files.add(main_script)\n",
      "\nclass BaseReloader:\n    def __init__(self):\n        self.extra_files = set()\n        self.directory_globs = defaultdict(set)\n        self._stop_condition = threading.Event()\n        \n        # Add the main script file to watched files if it exists and is a Python file\n        main_script = Path(sys.argv[0]).resolve()\n        if main_script.exists() and main_script.suffix == '.py':\n            self.extra_files.add(main_script)\n",
      "\nclass BaseReloader:\n    def __init__(self):\n        self.extra_files = set()\n        self.directory_globs = defaultdict(set)\n        self._stop_condition = threading.Event()\n        # Automatically watch the main script file (manage.py or __main__.py)\n        main_script = Path(sys.argv[0]).resolve()\n        if main_script.exists() and main_script.suffix == '.py':\n            self.extra_files.add(main_script)\n",
      "\nclass BaseReloader:\n    def __init__(self):\n        self.extra_files = set()\n        self.directory_globs = defaultdict(set)\n        self._stop_condition = threading.Event()\n        # Automatically watch the main script file\n        main_script = sys.argv[0] if sys.argv else None\n        if main_script and Path(main_script).suffix == '.py':\n            try:\n                main_script_path = Path(main_script).resolve()\n                self.extra_files.add(main_script_path)\n            except (OSError, ValueError):\n                # If we can't resolve the path, skip it\n                pass\n",
      "\nclass BaseReloader:\n    def __init__(self):\n        self.extra_files = set()\n        self.directory_globs = defaultdict(set)\n        self._stop_condition = threading.Event()\n        \n        # Add the main script file to watched files if it's a Python file\n        main_script = Path(sys.argv[0]).resolve()\n        if main_script.suffix == '.py' and main_script.is_file():\n            self.extra_files.add(main_script)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 7ca0d68fae..fe7368eebc 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -96,6 +96,7 @@ def ensure_echo_on():\n             signal.signal(signal.SIGTTOU, old_handler)\n \n \n+\n def iter_all_python_module_files():\n     # This is a hot path during reloading. Create a stable sorted list of\n     # modules based on the module name and pass it to iter_modules_and_files().\n@@ -103,9 +104,13 @@ def iter_all_python_module_files():\n     # aren't loaded on the fly.\n     keys = sorted(sys.modules)\n     modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n-    return iter_modules_and_files(modules, frozenset(_error_files))\n-\n-\n+    \n+    # Also include the main script file (e.g., manage.py) which isn't in sys.modules\n+    main_script = Path(sys.argv[0]).resolve()\n+    if main_script.exists() and main_script.suffix == '.py':\n+        yield main_script\n+    \n+    yield from iter_modules_and_files(modules, frozenset(_error_files))\n @functools.lru_cache(maxsize=1)\n def iter_modules_and_files(modules, extra_files):\n     \"\"\"Iterate through all modules needed to be watched.\"\"\"\n@@ -184,6 +189,7 @@ def sys_path_directories():\n             yield path\n \n \n+\n def get_child_arguments():\n     \"\"\"\n     Return the executable. This contains a workaround for Windows if the\n@@ -202,6 +208,17 @@ def get_child_arguments():\n     return args\n \n \n+def get_main_script_path():\n+    \"\"\"\n+    Return the path to the main script file being executed.\n+    This handles both 'python manage.py' and 'python -m django' scenarios.\n+    \"\"\"\n+    main_script = Path(sys.argv[0]).resolve()\n+    if main_script.exists() and main_script.suffix == '.py':\n+        return main_script\n+    return None\n+\n+\n def trigger_reload(filename):\n     logger.info('%s changed, reloading.', filename)\n     sys.exit(3)\n@@ -216,12 +233,17 @@ def restart_with_reloader():\n             return exit_code\n \n \n+\n class BaseReloader:\n     def __init__(self):\n         self.extra_files = set()\n         self.directory_globs = defaultdict(set)\n         self._stop_condition = threading.Event()\n-\n+        \n+        # Automatically watch the main script file (e.g., manage.py)\n+        main_script = Path(sys.argv[0]).resolve()\n+        if main_script.exists() and main_script.suffix == '.py':\n+            self.extra_files.add(main_script)\n     def watch_dir(self, path, glob):\n         path = Path(path)\n         if not path.is_absolute():\n@@ -236,6 +258,7 @@ class BaseReloader:\n         logger.debug('Watching file %s.', path)\n         self.extra_files.add(path)\n \n+\n     def watched_files(self, include_globs=True):\n         \"\"\"\n         Yield all files that need to be watched, including module files and\n@@ -247,6 +270,11 @@ class BaseReloader:\n             for directory, patterns in self.directory_globs.items():\n                 for pattern in patterns:\n                     yield from directory.glob(pattern)\n+        \n+        # Also watch the main script file (e.g., manage.py)\n+        main_script = Path(sys.argv[0]).resolve()\n+        if main_script.exists() and main_script.suffix == '.py':\n+            yield main_script\n \n     def wait_for_apps_ready(self, app_reg, django_main_thread):\n         \"\"\"\n@@ -574,12 +602,19 @@ def start_django(reloader, main_func, *args, **kwargs):\n             logger.info('Watching for file changes with %s', reloader.__class__.__name__)\n \n \n+\n def run_with_reloader(main_func, *args, **kwargs):\n     signal.signal(signal.SIGTERM, lambda *args: sys.exit(0))\n     try:\n         if os.environ.get(DJANGO_AUTORELOAD_ENV) == 'true':\n             reloader = get_reloader()\n             logger.info('Watching for file changes with %s', reloader.__class__.__name__)\n+            \n+            # Ensure the main script file is watched\n+            main_script = Path(sys.argv[0]).resolve()\n+            if main_script.exists() and main_script.suffix == '.py':\n+                reloader.watch_file(main_script)\n+            \n             start_django(reloader, main_func, *args, **kwargs)\n         else:\n             exit_code = restart_with_reloader()\n",
    "variant_0": "diff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 7ca0d68fae..fa97b1a0cb 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -96,6 +96,7 @@ def ensure_echo_on():\n             signal.signal(signal.SIGTTOU, old_handler)\n \n \n+\n def iter_all_python_module_files():\n     # This is a hot path during reloading. Create a stable sorted list of\n     # modules based on the module name and pass it to iter_modules_and_files().\n@@ -103,9 +104,18 @@ def iter_all_python_module_files():\n     # aren't loaded on the fly.\n     keys = sorted(sys.modules)\n     modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n-    return iter_modules_and_files(modules, frozenset(_error_files))\n-\n-\n+    \n+    # Include the main script file (e.g., manage.py) if it's a Python file\n+    main_script_files = set()\n+    if sys.argv and sys.argv[0]:\n+        main_script = Path(sys.argv[0])\n+        if main_script.exists() and main_script.suffix == '.py':\n+            main_script_files.add(main_script.resolve())\n+    \n+    # Combine error files with main script files\n+    extra_files = frozenset(_error_files) | frozenset(main_script_files)\n+    \n+    return iter_modules_and_files(modules, extra_files)\n @functools.lru_cache(maxsize=1)\n def iter_modules_and_files(modules, extra_files):\n     \"\"\"Iterate through all modules needed to be watched.\"\"\"\n@@ -184,6 +194,7 @@ def sys_path_directories():\n             yield path\n \n \n+\n def get_child_arguments():\n     \"\"\"\n     Return the executable. This contains a workaround for Windows if the\n@@ -202,6 +213,29 @@ def get_child_arguments():\n     return args\n \n \n+def get_main_script_file():\n+    \"\"\"\n+    Return the main script file path if it exists and is a Python file.\n+    This utility function helps identify the main script across different\n+    execution contexts.\n+    \"\"\"\n+    if not sys.argv:\n+        return None\n+    \n+    main_script = sys.argv[0]\n+    if not main_script:\n+        return None\n+    \n+    # Convert to Path object for easier handling\n+    script_path = Path(main_script)\n+    \n+    # Check if it's a Python file and exists\n+    if script_path.exists() and script_path.suffix == '.py':\n+        return script_path.resolve().absolute()\n+    \n+    return None\n+\n+\n def trigger_reload(filename):\n     logger.info('%s changed, reloading.', filename)\n     sys.exit(3)\n@@ -216,12 +250,17 @@ def restart_with_reloader():\n             return exit_code\n \n \n+\n class BaseReloader:\n     def __init__(self):\n         self.extra_files = set()\n         self.directory_globs = defaultdict(set)\n         self._stop_condition = threading.Event()\n-\n+        \n+        # Add the main script file to watched files if it exists and is a Python file\n+        main_script = Path(sys.argv[0]).resolve()\n+        if main_script.exists() and main_script.suffix == '.py':\n+            self.extra_files.add(main_script)\n     def watch_dir(self, path, glob):\n         path = Path(path)\n         if not path.is_absolute():\n@@ -236,6 +275,7 @@ class BaseReloader:\n         logger.debug('Watching file %s.', path)\n         self.extra_files.add(path)\n \n+\n     def watched_files(self, include_globs=True):\n         \"\"\"\n         Yield all files that need to be watched, including module files and\n@@ -243,6 +283,13 @@ class BaseReloader:\n         \"\"\"\n         yield from iter_all_python_module_files()\n         yield from self.extra_files\n+        \n+        # Include the main script file if it exists and is a Python file\n+        if sys.argv and sys.argv[0]:\n+            main_script = Path(sys.argv[0]).resolve()\n+            if main_script.exists() and main_script.suffix == '.py':\n+                yield main_script\n+        \n         if include_globs:\n             for directory, patterns in self.directory_globs.items():\n                 for pattern in patterns:\n@@ -574,11 +621,16 @@ def start_django(reloader, main_func, *args, **kwargs):\n             logger.info('Watching for file changes with %s', reloader.__class__.__name__)\n \n \n+\n def run_with_reloader(main_func, *args, **kwargs):\n     signal.signal(signal.SIGTERM, lambda *args: sys.exit(0))\n     try:\n         if os.environ.get(DJANGO_AUTORELOAD_ENV) == 'true':\n             reloader = get_reloader()\n+            # Ensure the main script file is watched\n+            main_script = Path(sys.argv[0]).resolve()\n+            if main_script.suffix == '.py' and main_script.is_file():\n+                reloader.watch_file(main_script)\n             logger.info('Watching for file changes with %s', reloader.__class__.__name__)\n             start_django(reloader, main_func, *args, **kwargs)\n         else:\n@@ -586,3 +638,8 @@ def run_with_reloader(main_func, *args, **kwargs):\n             sys.exit(exit_code)\n     except KeyboardInterrupt:\n         pass\n+        else:\n+            exit_code = restart_with_reloader()\n+            sys.exit(exit_code)\n+    except KeyboardInterrupt:\n+        pass\n",
    "variant_1": "diff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 7ca0d68fae..e0577acf80 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -96,6 +96,7 @@ def ensure_echo_on():\n             signal.signal(signal.SIGTTOU, old_handler)\n \n \n+\n def iter_all_python_module_files():\n     # This is a hot path during reloading. Create a stable sorted list of\n     # modules based on the module name and pass it to iter_modules_and_files().\n@@ -103,9 +104,15 @@ def iter_all_python_module_files():\n     # aren't loaded on the fly.\n     keys = sorted(sys.modules)\n     modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n-    return iter_modules_and_files(modules, frozenset(_error_files))\n-\n-\n+    \n+    # Yield files from modules\n+    yield from iter_modules_and_files(modules, frozenset(_error_files))\n+    \n+    # Also yield the main script file if it exists and is a Python file\n+    if sys.argv and sys.argv[0]:\n+        main_script = Path(sys.argv[0]).resolve()\n+        if main_script.suffix == '.py' and main_script.is_file():\n+            yield main_script\n @functools.lru_cache(maxsize=1)\n def iter_modules_and_files(modules, extra_files):\n     \"\"\"Iterate through all modules needed to be watched.\"\"\"\n@@ -184,6 +191,7 @@ def sys_path_directories():\n             yield path\n \n \n+\n def get_child_arguments():\n     \"\"\"\n     Return the executable. This contains a workaround for Windows if the\n@@ -202,6 +210,24 @@ def get_child_arguments():\n     return args\n \n \n+def get_main_script_file():\n+    \"\"\"\n+    Return the main script file path if it exists and is a Python file.\n+    This handles both `python manage.py runserver` and `python -m django runserver` cases.\n+    \"\"\"\n+    import django.__main__\n+    \n+    if sys.argv[0] == django.__main__.__file__:\n+        # Started with `python -m django runserver`, main script is django.__main__\n+        return Path(django.__main__.__file__).resolve()\n+    else:\n+        # Started with `python manage.py runserver` or similar\n+        main_script = Path(sys.argv[0])\n+        if main_script.exists() and main_script.suffix == '.py':\n+            return main_script.resolve()\n+    return None\n+\n+\n def trigger_reload(filename):\n     logger.info('%s changed, reloading.', filename)\n     sys.exit(3)\n@@ -216,12 +242,17 @@ def restart_with_reloader():\n             return exit_code\n \n \n+\n class BaseReloader:\n     def __init__(self):\n         self.extra_files = set()\n         self.directory_globs = defaultdict(set)\n         self._stop_condition = threading.Event()\n-\n+        \n+        # Automatically watch the main script file (manage.py or equivalent)\n+        main_script = Path(sys.argv[0]).resolve()\n+        if main_script.exists() and main_script.suffix == '.py':\n+            self.extra_files.add(main_script)\n     def watch_dir(self, path, glob):\n         path = Path(path)\n         if not path.is_absolute():\n@@ -236,6 +267,7 @@ class BaseReloader:\n         logger.debug('Watching file %s.', path)\n         self.extra_files.add(path)\n \n+\n     def watched_files(self, include_globs=True):\n         \"\"\"\n         Yield all files that need to be watched, including module files and\n@@ -243,6 +275,13 @@ class BaseReloader:\n         \"\"\"\n         yield from iter_all_python_module_files()\n         yield from self.extra_files\n+        \n+        # Include the main script file if it exists and is a Python file\n+        if sys.argv and sys.argv[0]:\n+            main_script = Path(sys.argv[0]).resolve()\n+            if main_script.exists() and main_script.suffix == '.py':\n+                yield main_script\n+                \n         if include_globs:\n             for directory, patterns in self.directory_globs.items():\n                 for pattern in patterns:\n@@ -574,11 +613,16 @@ def start_django(reloader, main_func, *args, **kwargs):\n             logger.info('Watching for file changes with %s', reloader.__class__.__name__)\n \n \n+\n def run_with_reloader(main_func, *args, **kwargs):\n     signal.signal(signal.SIGTERM, lambda *args: sys.exit(0))\n     try:\n         if os.environ.get(DJANGO_AUTORELOAD_ENV) == 'true':\n             reloader = get_reloader()\n+            # Ensure the main script file is watched\n+            main_script = Path(sys.argv[0]).resolve()\n+            if main_script.exists() and main_script.suffix == '.py':\n+                reloader.watch_file(main_script)\n             logger.info('Watching for file changes with %s', reloader.__class__.__name__)\n             start_django(reloader, main_func, *args, **kwargs)\n         else:\n@@ -586,3 +630,8 @@ def run_with_reloader(main_func, *args, **kwargs):\n             sys.exit(exit_code)\n     except KeyboardInterrupt:\n         pass\n+        else:\n+            exit_code = restart_with_reloader()\n+            sys.exit(exit_code)\n+    except KeyboardInterrupt:\n+        pass\n",
    "variant_2": "diff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 7ca0d68fae..a45165e4ad 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -96,6 +96,7 @@ def ensure_echo_on():\n             signal.signal(signal.SIGTTOU, old_handler)\n \n \n+\n def iter_all_python_module_files():\n     # This is a hot path during reloading. Create a stable sorted list of\n     # modules based on the module name and pass it to iter_modules_and_files().\n@@ -103,9 +104,15 @@ def iter_all_python_module_files():\n     # aren't loaded on the fly.\n     keys = sorted(sys.modules)\n     modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n-    return iter_modules_and_files(modules, frozenset(_error_files))\n-\n-\n+    \n+    # Yield files from modules\n+    yield from iter_modules_and_files(modules, frozenset(_error_files))\n+    \n+    # Also yield the main script file if it exists and is a Python file\n+    if sys.argv and sys.argv[0]:\n+        main_script = Path(sys.argv[0]).resolve()\n+        if main_script.suffix == '.py' and main_script.is_file():\n+            yield main_script\n @functools.lru_cache(maxsize=1)\n def iter_modules_and_files(modules, extra_files):\n     \"\"\"Iterate through all modules needed to be watched.\"\"\"\n@@ -184,6 +191,7 @@ def sys_path_directories():\n             yield path\n \n \n+\n def get_child_arguments():\n     \"\"\"\n     Return the executable. This contains a workaround for Windows if the\n@@ -202,6 +210,23 @@ def get_child_arguments():\n     return args\n \n \n+def get_main_script_file():\n+    \"\"\"\n+    Return the main script file path if it exists and is a Python file.\n+    This handles both `python manage.py runserver` and `python -m django runserver` cases.\n+    \"\"\"\n+    import django.__main__\n+    \n+    if sys.argv[0] == django.__main__.__file__:\n+        # Started with `python -m django runserver`\n+        return None\n+    \n+    script_path = Path(sys.argv[0])\n+    if script_path.exists() and script_path.suffix == '.py':\n+        return script_path.resolve()\n+    return None\n+\n+\n def trigger_reload(filename):\n     logger.info('%s changed, reloading.', filename)\n     sys.exit(3)\n@@ -216,12 +241,17 @@ def restart_with_reloader():\n             return exit_code\n \n \n+\n class BaseReloader:\n     def __init__(self):\n         self.extra_files = set()\n         self.directory_globs = defaultdict(set)\n         self._stop_condition = threading.Event()\n-\n+        \n+        # Add the main script file to watched files\n+        main_script = sys.argv[0] if sys.argv else None\n+        if main_script and os.path.isfile(main_script) and main_script.endswith('.py'):\n+            self.extra_files.add(Path(main_script).resolve())\n     def watch_dir(self, path, glob):\n         path = Path(path)\n         if not path.is_absolute():\n@@ -236,6 +266,7 @@ class BaseReloader:\n         logger.debug('Watching file %s.', path)\n         self.extra_files.add(path)\n \n+\n     def watched_files(self, include_globs=True):\n         \"\"\"\n         Yield all files that need to be watched, including module files and\n@@ -243,6 +274,12 @@ class BaseReloader:\n         \"\"\"\n         yield from iter_all_python_module_files()\n         yield from self.extra_files\n+        \n+        # Include the main script file (manage.py or __main__.py)\n+        main_script = Path(sys.argv[0]).resolve()\n+        if main_script.exists() and main_script.suffix == '.py':\n+            yield main_script\n+            \n         if include_globs:\n             for directory, patterns in self.directory_globs.items():\n                 for pattern in patterns:\n@@ -574,11 +611,16 @@ def start_django(reloader, main_func, *args, **kwargs):\n             logger.info('Watching for file changes with %s', reloader.__class__.__name__)\n \n \n+\n def run_with_reloader(main_func, *args, **kwargs):\n     signal.signal(signal.SIGTERM, lambda *args: sys.exit(0))\n     try:\n         if os.environ.get(DJANGO_AUTORELOAD_ENV) == 'true':\n             reloader = get_reloader()\n+            # Ensure the main script file is being watched\n+            main_script = Path(sys.argv[0]).resolve()\n+            if main_script.exists() and main_script.suffix == '.py':\n+                reloader.watch_file(main_script)\n             logger.info('Watching for file changes with %s', reloader.__class__.__name__)\n             start_django(reloader, main_func, *args, **kwargs)\n         else:\n@@ -586,3 +628,8 @@ def run_with_reloader(main_func, *args, **kwargs):\n             sys.exit(exit_code)\n     except KeyboardInterrupt:\n         pass\n+        else:\n+            exit_code = restart_with_reloader()\n+            sys.exit(exit_code)\n+    except KeyboardInterrupt:\n+        pass\n",
    "variant_3": "diff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 7ca0d68fae..ed7d814209 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -96,6 +96,7 @@ def ensure_echo_on():\n             signal.signal(signal.SIGTTOU, old_handler)\n \n \n+\n def iter_all_python_module_files():\n     # This is a hot path during reloading. Create a stable sorted list of\n     # modules based on the module name and pass it to iter_modules_and_files().\n@@ -103,9 +104,19 @@ def iter_all_python_module_files():\n     # aren't loaded on the fly.\n     keys = sorted(sys.modules)\n     modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n-    return iter_modules_and_files(modules, frozenset(_error_files))\n-\n-\n+    \n+    # Include the main script file (manage.py) which isn't in sys.modules\n+    main_script = None\n+    if sys.argv and sys.argv[0]:\n+        main_script_path = pathlib.Path(sys.argv[0])\n+        if main_script_path.suffix == '.py' and main_script_path.exists():\n+            main_script = main_script_path.resolve()\n+    \n+    for path in iter_modules_and_files(modules, frozenset(_error_files)):\n+        yield path\n+    \n+    if main_script:\n+        yield main_script\n @functools.lru_cache(maxsize=1)\n def iter_modules_and_files(modules, extra_files):\n     \"\"\"Iterate through all modules needed to be watched.\"\"\"\n@@ -184,6 +195,7 @@ def sys_path_directories():\n             yield path\n \n \n+\n def get_child_arguments():\n     \"\"\"\n     Return the executable. This contains a workaround for Windows if the\n@@ -202,6 +214,23 @@ def get_child_arguments():\n     return args\n \n \n+def get_main_script_file():\n+    \"\"\"\n+    Return the main script file path if it exists and is a Python file.\n+    This handles both `python manage.py runserver` and `python -m django runserver` cases.\n+    \"\"\"\n+    import django.__main__\n+    \n+    if sys.argv[0] == django.__main__.__file__:\n+        # Started with `python -m django runserver`\n+        return None\n+    \n+    main_script = pathlib.Path(sys.argv[0])\n+    if main_script.exists() and main_script.suffix == '.py':\n+        return main_script.resolve().absolute()\n+    return None\n+\n+\n def trigger_reload(filename):\n     logger.info('%s changed, reloading.', filename)\n     sys.exit(3)\n@@ -216,12 +245,17 @@ def restart_with_reloader():\n             return exit_code\n \n \n+\n class BaseReloader:\n     def __init__(self):\n         self.extra_files = set()\n         self.directory_globs = defaultdict(set)\n         self._stop_condition = threading.Event()\n-\n+        \n+        # Add the main script file to watched files if it's a Python file\n+        main_script = Path(sys.argv[0]).resolve()\n+        if main_script.suffix == '.py' and main_script.is_file():\n+            self.extra_files.add(main_script)\n     def watch_dir(self, path, glob):\n         path = Path(path)\n         if not path.is_absolute():\n@@ -236,6 +270,7 @@ class BaseReloader:\n         logger.debug('Watching file %s.', path)\n         self.extra_files.add(path)\n \n+\n     def watched_files(self, include_globs=True):\n         \"\"\"\n         Yield all files that need to be watched, including module files and\n@@ -243,6 +278,14 @@ class BaseReloader:\n         \"\"\"\n         yield from iter_all_python_module_files()\n         yield from self.extra_files\n+        \n+        # Watch the main script file (manage.py or equivalent)\n+        main_script = sys.argv[0] if sys.argv else None\n+        if main_script:\n+            main_script_path = Path(main_script).resolve()\n+            if main_script_path.exists() and main_script_path.suffix == '.py':\n+                yield main_script_path\n+        \n         if include_globs:\n             for directory, patterns in self.directory_globs.items():\n                 for pattern in patterns:\n@@ -574,11 +617,18 @@ def start_django(reloader, main_func, *args, **kwargs):\n             logger.info('Watching for file changes with %s', reloader.__class__.__name__)\n \n \n+\n def run_with_reloader(main_func, *args, **kwargs):\n     signal.signal(signal.SIGTERM, lambda *args: sys.exit(0))\n     try:\n         if os.environ.get(DJANGO_AUTORELOAD_ENV) == 'true':\n             reloader = get_reloader()\n+            \n+            # Ensure the main script file is watched\n+            main_script = sys.argv[0] if sys.argv else None\n+            if main_script and os.path.isfile(main_script) and main_script.endswith('.py'):\n+                reloader.watch_file(Path(main_script))\n+            \n             logger.info('Watching for file changes with %s', reloader.__class__.__name__)\n             start_django(reloader, main_func, *args, **kwargs)\n         else:\n@@ -586,3 +636,8 @@ def run_with_reloader(main_func, *args, **kwargs):\n             sys.exit(exit_code)\n     except KeyboardInterrupt:\n         pass\n+        else:\n+            exit_code = restart_with_reloader()\n+            sys.exit(exit_code)\n+    except KeyboardInterrupt:\n+        pass\n",
    "variant_4": "diff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 7ca0d68fae..2b6c86151e 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -96,6 +96,7 @@ def ensure_echo_on():\n             signal.signal(signal.SIGTTOU, old_handler)\n \n \n+\n def iter_all_python_module_files():\n     # This is a hot path during reloading. Create a stable sorted list of\n     # modules based on the module name and pass it to iter_modules_and_files().\n@@ -103,9 +104,13 @@ def iter_all_python_module_files():\n     # aren't loaded on the fly.\n     keys = sorted(sys.modules)\n     modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n-    return iter_modules_and_files(modules, frozenset(_error_files))\n-\n-\n+    \n+    # Also yield the main script file if it exists and is a Python file\n+    main_script = sys.argv[0] if sys.argv else None\n+    if main_script and main_script.endswith('.py') and os.path.isfile(main_script):\n+        yield Path(main_script).resolve()\n+    \n+    yield from iter_modules_and_files(modules, frozenset(_error_files))\n @functools.lru_cache(maxsize=1)\n def iter_modules_and_files(modules, extra_files):\n     \"\"\"Iterate through all modules needed to be watched.\"\"\"\n@@ -184,6 +189,7 @@ def sys_path_directories():\n             yield path\n \n \n+\n def get_child_arguments():\n     \"\"\"\n     Return the executable. This contains a workaround for Windows if the\n@@ -202,6 +208,29 @@ def get_child_arguments():\n     return args\n \n \n+def get_main_script_file():\n+    \"\"\"\n+    Return the main script file path if it exists and is a Python file.\n+    This handles both direct script execution and module execution scenarios.\n+    \"\"\"\n+    import django.__main__\n+    \n+    # Handle python -m django runserver case\n+    if sys.argv[0] == django.__main__.__file__:\n+        # Look for manage.py in the current directory as a fallback\n+        manage_py = Path.cwd() / 'manage.py'\n+        if manage_py.exists():\n+            return manage_py.resolve().absolute()\n+        return None\n+    \n+    # Handle direct script execution case (python manage.py runserver)\n+    script_path = Path(sys.argv[0])\n+    if script_path.exists() and script_path.suffix == '.py':\n+        return script_path.resolve().absolute()\n+    \n+    return None\n+\n+\n def trigger_reload(filename):\n     logger.info('%s changed, reloading.', filename)\n     sys.exit(3)\n@@ -216,12 +245,16 @@ def restart_with_reloader():\n             return exit_code\n \n \n+\n class BaseReloader:\n     def __init__(self):\n         self.extra_files = set()\n         self.directory_globs = defaultdict(set)\n         self._stop_condition = threading.Event()\n-\n+        # Add the main script file to watched files\n+        main_script = Path(sys.argv[0]).resolve()\n+        if main_script.exists() and main_script.suffix == '.py':\n+            self.extra_files.add(main_script)\n     def watch_dir(self, path, glob):\n         path = Path(path)\n         if not path.is_absolute():\n@@ -236,6 +269,7 @@ class BaseReloader:\n         logger.debug('Watching file %s.', path)\n         self.extra_files.add(path)\n \n+\n     def watched_files(self, include_globs=True):\n         \"\"\"\n         Yield all files that need to be watched, including module files and\n@@ -243,6 +277,13 @@ class BaseReloader:\n         \"\"\"\n         yield from iter_all_python_module_files()\n         yield from self.extra_files\n+        \n+        # Include the main script file if it's a Python file\n+        if sys.argv and sys.argv[0]:\n+            main_script = Path(sys.argv[0]).resolve()\n+            if main_script.suffix == '.py' and main_script.exists():\n+                yield main_script\n+        \n         if include_globs:\n             for directory, patterns in self.directory_globs.items():\n                 for pattern in patterns:\n@@ -574,11 +615,16 @@ def start_django(reloader, main_func, *args, **kwargs):\n             logger.info('Watching for file changes with %s', reloader.__class__.__name__)\n \n \n+\n def run_with_reloader(main_func, *args, **kwargs):\n     signal.signal(signal.SIGTERM, lambda *args: sys.exit(0))\n     try:\n         if os.environ.get(DJANGO_AUTORELOAD_ENV) == 'true':\n             reloader = get_reloader()\n+            # Ensure the main script is watched for changes\n+            main_script = Path(sys.argv[0]).resolve()\n+            if main_script.suffix == '.py' and main_script.exists():\n+                reloader.watch_file(main_script)\n             logger.info('Watching for file changes with %s', reloader.__class__.__name__)\n             start_django(reloader, main_func, *args, **kwargs)\n         else:\n@@ -586,3 +632,8 @@ def run_with_reloader(main_func, *args, **kwargs):\n             sys.exit(exit_code)\n     except KeyboardInterrupt:\n         pass\n+        else:\n+            exit_code = restart_with_reloader()\n+            sys.exit(exit_code)\n+    except KeyboardInterrupt:\n+        pass\n",
    "variant_5": "diff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 7ca0d68fae..033e86d541 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -96,6 +96,7 @@ def ensure_echo_on():\n             signal.signal(signal.SIGTTOU, old_handler)\n \n \n+\n def iter_all_python_module_files():\n     # This is a hot path during reloading. Create a stable sorted list of\n     # modules based on the module name and pass it to iter_modules_and_files().\n@@ -103,9 +104,22 @@ def iter_all_python_module_files():\n     # aren't loaded on the fly.\n     keys = sorted(sys.modules)\n     modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n-    return iter_modules_and_files(modules, frozenset(_error_files))\n-\n-\n+    \n+    # Also include the main script file if it exists and is a Python file\n+    main_script_path = None\n+    if sys.argv and sys.argv[0]:\n+        script_path = Path(sys.argv[0]).resolve()\n+        if script_path.exists() and script_path.suffix == '.py':\n+            main_script_path = script_path\n+    \n+    result = iter_modules_and_files(modules, frozenset(_error_files))\n+    \n+    # Yield the main script file if it's not already included\n+    if main_script_path:\n+        yield main_script_path\n+    \n+    # Yield all other files from iter_modules_and_files\n+    yield from result\n @functools.lru_cache(maxsize=1)\n def iter_modules_and_files(modules, extra_files):\n     \"\"\"Iterate through all modules needed to be watched.\"\"\"\n@@ -184,6 +198,7 @@ def sys_path_directories():\n             yield path\n \n \n+\n def get_child_arguments():\n     \"\"\"\n     Return the executable. This contains a workaround for Windows if the\n@@ -202,6 +217,20 @@ def get_child_arguments():\n     return args\n \n \n+def get_main_script_file():\n+    \"\"\"\n+    Return the main script file path if it exists and is a Python file.\n+    This is used to ensure the main script (like manage.py) is watched for changes.\n+    \"\"\"\n+    if not sys.argv or not sys.argv[0]:\n+        return None\n+    \n+    main_script = Path(sys.argv[0])\n+    if main_script.exists() and main_script.suffix == '.py':\n+        return main_script.resolve().absolute()\n+    return None\n+\n+\n def trigger_reload(filename):\n     logger.info('%s changed, reloading.', filename)\n     sys.exit(3)\n@@ -216,12 +245,17 @@ def restart_with_reloader():\n             return exit_code\n \n \n+\n class BaseReloader:\n     def __init__(self):\n         self.extra_files = set()\n         self.directory_globs = defaultdict(set)\n         self._stop_condition = threading.Event()\n-\n+        \n+        # Add the main script file to watched files if it exists and is a Python file\n+        main_script = Path(sys.argv[0]).resolve()\n+        if main_script.exists() and main_script.suffix == '.py':\n+            self.extra_files.add(main_script)\n     def watch_dir(self, path, glob):\n         path = Path(path)\n         if not path.is_absolute():\n@@ -236,6 +270,7 @@ class BaseReloader:\n         logger.debug('Watching file %s.', path)\n         self.extra_files.add(path)\n \n+\n     def watched_files(self, include_globs=True):\n         \"\"\"\n         Yield all files that need to be watched, including module files and\n@@ -243,6 +278,16 @@ class BaseReloader:\n         \"\"\"\n         yield from iter_all_python_module_files()\n         yield from self.extra_files\n+        \n+        # Include the main script file if it's a Python file and not already included\n+        if sys.argv and sys.argv[0]:\n+            main_script = Path(sys.argv[0])\n+            if main_script.exists() and main_script.suffix == '.py':\n+                main_script = main_script.resolve()\n+                # Only yield if not already in extra_files to avoid duplicates\n+                if main_script not in self.extra_files:\n+                    yield main_script\n+        \n         if include_globs:\n             for directory, patterns in self.directory_globs.items():\n                 for pattern in patterns:\n@@ -574,11 +619,16 @@ def start_django(reloader, main_func, *args, **kwargs):\n             logger.info('Watching for file changes with %s', reloader.__class__.__name__)\n \n \n+\n def run_with_reloader(main_func, *args, **kwargs):\n     signal.signal(signal.SIGTERM, lambda *args: sys.exit(0))\n     try:\n         if os.environ.get(DJANGO_AUTORELOAD_ENV) == 'true':\n             reloader = get_reloader()\n+            # Ensure the main script file is watched\n+            main_script = Path(sys.argv[0])\n+            if main_script.exists() and main_script.suffix == '.py':\n+                reloader.watch_file(main_script)\n             logger.info('Watching for file changes with %s', reloader.__class__.__name__)\n             start_django(reloader, main_func, *args, **kwargs)\n         else:\n@@ -586,3 +636,8 @@ def run_with_reloader(main_func, *args, **kwargs):\n             sys.exit(exit_code)\n     except KeyboardInterrupt:\n         pass\n+        else:\n+            exit_code = restart_with_reloader()\n+            sys.exit(exit_code)\n+    except KeyboardInterrupt:\n+        pass\n",
    "variant_6": "diff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 7ca0d68fae..2e72b2a587 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -96,6 +96,7 @@ def ensure_echo_on():\n             signal.signal(signal.SIGTTOU, old_handler)\n \n \n+\n def iter_all_python_module_files():\n     # This is a hot path during reloading. Create a stable sorted list of\n     # modules based on the module name and pass it to iter_modules_and_files().\n@@ -103,9 +104,15 @@ def iter_all_python_module_files():\n     # aren't loaded on the fly.\n     keys = sorted(sys.modules)\n     modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n-    return iter_modules_and_files(modules, frozenset(_error_files))\n-\n-\n+    \n+    # Include the main script file if it exists and is a Python file\n+    extra_files = set(_error_files)\n+    if sys.argv and sys.argv[0]:\n+        main_script = pathlib.Path(sys.argv[0]).resolve()\n+        if main_script.suffix == '.py' and main_script.is_file():\n+            extra_files.add(main_script)\n+    \n+    return iter_modules_and_files(modules, frozenset(extra_files))\n @functools.lru_cache(maxsize=1)\n def iter_modules_and_files(modules, extra_files):\n     \"\"\"Iterate through all modules needed to be watched.\"\"\"\n@@ -184,6 +191,7 @@ def sys_path_directories():\n             yield path\n \n \n+\n def get_child_arguments():\n     \"\"\"\n     Return the executable. This contains a workaround for Windows if the\n@@ -202,6 +210,28 @@ def get_child_arguments():\n     return args\n \n \n+def get_main_script_file():\n+    \"\"\"\n+    Return the main script file path if it exists and is a Python file.\n+    This is used to ensure the main script (like manage.py) is watched for changes.\n+    \"\"\"\n+    if not sys.argv:\n+        return None\n+    \n+    main_script = sys.argv[0]\n+    if not main_script:\n+        return None\n+    \n+    try:\n+        script_path = Path(main_script).resolve()\n+        if script_path.exists() and script_path.suffix == '.py':\n+            return script_path\n+    except (OSError, ValueError):\n+        pass\n+    \n+    return None\n+\n+\n def trigger_reload(filename):\n     logger.info('%s changed, reloading.', filename)\n     sys.exit(3)\n@@ -216,12 +246,16 @@ def restart_with_reloader():\n             return exit_code\n \n \n+\n class BaseReloader:\n     def __init__(self):\n         self.extra_files = set()\n         self.directory_globs = defaultdict(set)\n         self._stop_condition = threading.Event()\n-\n+        # Automatically watch the main script file (manage.py or __main__.py)\n+        main_script = Path(sys.argv[0]).resolve()\n+        if main_script.exists() and main_script.suffix == '.py':\n+            self.extra_files.add(main_script)\n     def watch_dir(self, path, glob):\n         path = Path(path)\n         if not path.is_absolute():\n@@ -236,6 +270,7 @@ class BaseReloader:\n         logger.debug('Watching file %s.', path)\n         self.extra_files.add(path)\n \n+\n     def watched_files(self, include_globs=True):\n         \"\"\"\n         Yield all files that need to be watched, including module files and\n@@ -243,6 +278,13 @@ class BaseReloader:\n         \"\"\"\n         yield from iter_all_python_module_files()\n         yield from self.extra_files\n+        \n+        # Include the main script file (e.g., manage.py) if it exists\n+        if sys.argv and sys.argv[0]:\n+            main_script = Path(sys.argv[0]).resolve()\n+            if main_script.exists() and main_script.suffix == '.py':\n+                yield main_script\n+        \n         if include_globs:\n             for directory, patterns in self.directory_globs.items():\n                 for pattern in patterns:\n@@ -574,11 +616,16 @@ def start_django(reloader, main_func, *args, **kwargs):\n             logger.info('Watching for file changes with %s', reloader.__class__.__name__)\n \n \n+\n def run_with_reloader(main_func, *args, **kwargs):\n     signal.signal(signal.SIGTERM, lambda *args: sys.exit(0))\n     try:\n         if os.environ.get(DJANGO_AUTORELOAD_ENV) == 'true':\n             reloader = get_reloader()\n+            # Add the main script file to watched files to ensure changes are detected\n+            main_script = Path(sys.argv[0]).resolve()\n+            if main_script.exists() and main_script.suffix == '.py':\n+                reloader.watch_file(main_script)\n             logger.info('Watching for file changes with %s', reloader.__class__.__name__)\n             start_django(reloader, main_func, *args, **kwargs)\n         else:\n@@ -586,3 +633,8 @@ def run_with_reloader(main_func, *args, **kwargs):\n             sys.exit(exit_code)\n     except KeyboardInterrupt:\n         pass\n+        else:\n+            exit_code = restart_with_reloader()\n+            sys.exit(exit_code)\n+    except KeyboardInterrupt:\n+        pass\n",
    "variant_7": "diff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 7ca0d68fae..adb3a3552f 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -96,6 +96,7 @@ def ensure_echo_on():\n             signal.signal(signal.SIGTTOU, old_handler)\n \n \n+\n def iter_all_python_module_files():\n     # This is a hot path during reloading. Create a stable sorted list of\n     # modules based on the module name and pass it to iter_modules_and_files().\n@@ -103,9 +104,20 @@ def iter_all_python_module_files():\n     # aren't loaded on the fly.\n     keys = sorted(sys.modules)\n     modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n-    return iter_modules_and_files(modules, frozenset(_error_files))\n-\n-\n+    \n+    # Include the main script file if it exists and is a Python file\n+    main_script = None\n+    if sys.argv and sys.argv[0]:\n+        main_script_path = Path(sys.argv[0]).resolve()\n+        if main_script_path.exists() and main_script_path.suffix == '.py':\n+            main_script = main_script_path\n+    \n+    for file_path in iter_modules_and_files(modules, frozenset(_error_files)):\n+        yield file_path\n+    \n+    # Yield the main script file if it's not already included\n+    if main_script is not None:\n+        yield main_script\n @functools.lru_cache(maxsize=1)\n def iter_modules_and_files(modules, extra_files):\n     \"\"\"Iterate through all modules needed to be watched.\"\"\"\n@@ -184,6 +196,7 @@ def sys_path_directories():\n             yield path\n \n \n+\n def get_child_arguments():\n     \"\"\"\n     Return the executable. This contains a workaround for Windows if the\n@@ -202,6 +215,24 @@ def get_child_arguments():\n     return args\n \n \n+def get_main_script_file():\n+    \"\"\"\n+    Return the main script file path if it exists and is a Python file.\n+    This handles both `python manage.py runserver` and `python -m django runserver` cases.\n+    \"\"\"\n+    import django.__main__\n+    \n+    if sys.argv[0] == django.__main__.__file__:\n+        # Started with `python -m django runserver` - no main script file to watch\n+        return None\n+    \n+    main_script = Path(sys.argv[0])\n+    if main_script.exists() and main_script.suffix == '.py':\n+        return main_script.resolve().absolute()\n+    \n+    return None\n+\n+\n def trigger_reload(filename):\n     logger.info('%s changed, reloading.', filename)\n     sys.exit(3)\n@@ -216,12 +247,21 @@ def restart_with_reloader():\n             return exit_code\n \n \n+\n class BaseReloader:\n     def __init__(self):\n         self.extra_files = set()\n         self.directory_globs = defaultdict(set)\n         self._stop_condition = threading.Event()\n-\n+        # Automatically watch the main script file\n+        main_script = sys.argv[0] if sys.argv else None\n+        if main_script and Path(main_script).suffix == '.py':\n+            try:\n+                main_script_path = Path(main_script).resolve()\n+                self.extra_files.add(main_script_path)\n+            except (OSError, ValueError):\n+                # If we can't resolve the path, skip it\n+                pass\n     def watch_dir(self, path, glob):\n         path = Path(path)\n         if not path.is_absolute():\n@@ -236,6 +276,7 @@ class BaseReloader:\n         logger.debug('Watching file %s.', path)\n         self.extra_files.add(path)\n \n+\n     def watched_files(self, include_globs=True):\n         \"\"\"\n         Yield all files that need to be watched, including module files and\n@@ -243,6 +284,13 @@ class BaseReloader:\n         \"\"\"\n         yield from iter_all_python_module_files()\n         yield from self.extra_files\n+        \n+        # Include the main script file if it exists and is a Python file\n+        if sys.argv and sys.argv[0]:\n+            main_script = Path(sys.argv[0]).resolve()\n+            if main_script.suffix == '.py' and main_script.is_file():\n+                yield main_script\n+        \n         if include_globs:\n             for directory, patterns in self.directory_globs.items():\n                 for pattern in patterns:\n@@ -574,11 +622,16 @@ def start_django(reloader, main_func, *args, **kwargs):\n             logger.info('Watching for file changes with %s', reloader.__class__.__name__)\n \n \n+\n def run_with_reloader(main_func, *args, **kwargs):\n     signal.signal(signal.SIGTERM, lambda *args: sys.exit(0))\n     try:\n         if os.environ.get(DJANGO_AUTORELOAD_ENV) == 'true':\n             reloader = get_reloader()\n+            # Ensure the main script file is watched for changes\n+            main_script = Path(sys.argv[0]).resolve()\n+            if main_script.exists() and main_script.suffix == '.py':\n+                reloader.watch_file(main_script)\n             logger.info('Watching for file changes with %s', reloader.__class__.__name__)\n             start_django(reloader, main_func, *args, **kwargs)\n         else:\n@@ -586,3 +639,8 @@ def run_with_reloader(main_func, *args, **kwargs):\n             sys.exit(exit_code)\n     except KeyboardInterrupt:\n         pass\n+        else:\n+            exit_code = restart_with_reloader()\n+            sys.exit(exit_code)\n+    except KeyboardInterrupt:\n+        pass\n",
    "variant_8": "diff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 7ca0d68fae..a6e2737dc7 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -96,6 +96,7 @@ def ensure_echo_on():\n             signal.signal(signal.SIGTTOU, old_handler)\n \n \n+\n def iter_all_python_module_files():\n     # This is a hot path during reloading. Create a stable sorted list of\n     # modules based on the module name and pass it to iter_modules_and_files().\n@@ -103,9 +104,21 @@ def iter_all_python_module_files():\n     # aren't loaded on the fly.\n     keys = sorted(sys.modules)\n     modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n-    return iter_modules_and_files(modules, frozenset(_error_files))\n-\n-\n+    \n+    # Include the main script file (e.g., manage.py) if it exists and is a Python file\n+    main_script_path = None\n+    if sys.argv and sys.argv[0]:\n+        script_path = Path(sys.argv[0])\n+        if script_path.exists() and script_path.suffix == '.py':\n+            main_script_path = script_path.resolve()\n+    \n+    # Yield files from modules\n+    for file_path in iter_modules_and_files(modules, frozenset(_error_files)):\n+        yield file_path\n+    \n+    # Yield the main script file if it's not already included\n+    if main_script_path and main_script_path not in frozenset(_error_files):\n+        yield main_script_path\n @functools.lru_cache(maxsize=1)\n def iter_modules_and_files(modules, extra_files):\n     \"\"\"Iterate through all modules needed to be watched.\"\"\"\n@@ -184,6 +197,7 @@ def sys_path_directories():\n             yield path\n \n \n+\n def get_child_arguments():\n     \"\"\"\n     Return the executable. This contains a workaround for Windows if the\n@@ -202,6 +216,24 @@ def get_child_arguments():\n     return args\n \n \n+def get_main_script_file():\n+    \"\"\"\n+    Return the main script file being executed, or None if it's not a Python file.\n+    This handles both `python manage.py runserver` and `python -m django runserver` cases.\n+    \"\"\"\n+    import django.__main__\n+    \n+    if sys.argv[0] == django.__main__.__file__:\n+        # Started with `python -m django runserver`\n+        return None\n+    \n+    main_script = Path(sys.argv[0])\n+    if main_script.exists() and main_script.suffix == '.py':\n+        return main_script.resolve().absolute()\n+    \n+    return None\n+\n+\n def trigger_reload(filename):\n     logger.info('%s changed, reloading.', filename)\n     sys.exit(3)\n@@ -216,12 +248,17 @@ def restart_with_reloader():\n             return exit_code\n \n \n+\n class BaseReloader:\n     def __init__(self):\n         self.extra_files = set()\n         self.directory_globs = defaultdict(set)\n         self._stop_condition = threading.Event()\n-\n+        \n+        # Add the main script file to watched files if it's a Python file\n+        main_script = Path(sys.argv[0]).resolve()\n+        if main_script.suffix == '.py' and main_script.is_file():\n+            self.extra_files.add(main_script)\n     def watch_dir(self, path, glob):\n         path = Path(path)\n         if not path.is_absolute():\n@@ -236,6 +273,7 @@ class BaseReloader:\n         logger.debug('Watching file %s.', path)\n         self.extra_files.add(path)\n \n+\n     def watched_files(self, include_globs=True):\n         \"\"\"\n         Yield all files that need to be watched, including module files and\n@@ -243,6 +281,13 @@ class BaseReloader:\n         \"\"\"\n         yield from iter_all_python_module_files()\n         yield from self.extra_files\n+        \n+        # Include the main script file (e.g., manage.py) if it exists and is a Python file\n+        if sys.argv and sys.argv[0]:\n+            main_script = Path(sys.argv[0]).resolve()\n+            if main_script.exists() and main_script.suffix == '.py':\n+                yield main_script\n+        \n         if include_globs:\n             for directory, patterns in self.directory_globs.items():\n                 for pattern in patterns:\n@@ -574,11 +619,16 @@ def start_django(reloader, main_func, *args, **kwargs):\n             logger.info('Watching for file changes with %s', reloader.__class__.__name__)\n \n \n+\n def run_with_reloader(main_func, *args, **kwargs):\n     signal.signal(signal.SIGTERM, lambda *args: sys.exit(0))\n     try:\n         if os.environ.get(DJANGO_AUTORELOAD_ENV) == 'true':\n             reloader = get_reloader()\n+            # Ensure the main script file is watched\n+            main_script = Path(sys.argv[0]).resolve()\n+            if main_script.suffix == '.py' and main_script.exists():\n+                reloader.watch_file(main_script)\n             logger.info('Watching for file changes with %s', reloader.__class__.__name__)\n             start_django(reloader, main_func, *args, **kwargs)\n         else:\n@@ -586,3 +636,8 @@ def run_with_reloader(main_func, *args, **kwargs):\n             sys.exit(exit_code)\n     except KeyboardInterrupt:\n         pass\n+        else:\n+            exit_code = restart_with_reloader()\n+            sys.exit(exit_code)\n+    except KeyboardInterrupt:\n+        pass\n"
  }
}