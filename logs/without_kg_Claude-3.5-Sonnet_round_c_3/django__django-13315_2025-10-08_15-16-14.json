{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/django/django/forms/models.py lines 98-103)": "\ndef apply_limit_choices_to_to_formfield(formfield):\n    \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n    if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n        limit_choices_to = formfield.get_limit_choices_to()\n        if limit_choices_to is not None:\n            formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n            # Apply distinct() when using Q objects to prevent duplicates from joins\n            if hasattr(limit_choices_to, 'children'):  # Q object detection\n                formfield.queryset = formfield.queryset.distinct()\n",
    "Location 2 (/root/hy/projects_3/django/django/forms/models.py lines 8-10)": "\nfrom django.core.exceptions import (\n    NON_FIELD_ERRORS, FieldError, ImproperlyConfigured, ValidationError,\n)\nfrom django.db.models import Q\n",
    "Location 3 (/root/hy/projects_3/django/django/db/models/query.py lines 968-983)": "\n    def complex_filter(self, filter_obj):\n        \"\"\"\n        Return a new QuerySet instance with filter_obj added to the filters.\n\n        filter_obj can be a Q object or a dictionary of keyword lookup\n        arguments.\n\n        This exists to support framework features such as 'limit_choices_to',\n        and usually it will be more natural to use other methods.\n        \"\"\"\n        if isinstance(filter_obj, Q):\n            clone = self._chain()\n            clone.query.add_q(filter_obj)\n            return clone\n        else:\n            return self._filter_or_exclude(False, args=(), kwargs=filter_obj)\n",
    "Location 4 (/root/hy/projects_3/django/django/db/models/fields/related.py lines 401-419)": "\n    def formfield(self, **kwargs):\n        \"\"\"\n        Pass ``limit_choices_to`` to the field being constructed.\n\n        Only passes it if there is a type that supports related fields.\n        This is a similar strategy used to pass the ``queryset`` to the field\n        being constructed.\n        \"\"\"\n        defaults = {}\n        if hasattr(self.remote_field, 'get_related_field'):\n            # If this is a callable, do not invoke it here. Just pass\n            # it in the defaults for when the form class will later be\n            # instantiated.\n            limit_choices_to = self.remote_field.limit_choices_to\n            defaults.update({\n                'limit_choices_to': limit_choices_to,\n            })\n        defaults.update(kwargs)\n        return super().formfield(**defaults)\n",
    "Location 5 (/root/hy/projects_3/django/django/db/models/fields/related.py lines 390-399)": "\n    def get_limit_choices_to(self):\n        \"\"\"\n        Return ``limit_choices_to`` for this model field.\n\n        If it is a callable, it will be invoked and the result will be\n        returned.\n        \"\"\"\n        if callable(self.remote_field.limit_choices_to):\n            return self.remote_field.limit_choices_to()\n        return self.remote_field.limit_choices_to\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/django/django/forms/models.py lines 98-103)": [
      "\ndef apply_limit_choices_to_to_formfield(formfield):\n    \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n    if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n        limit_choices_to = formfield.get_limit_choices_to()\n        if limit_choices_to is not None:\n            formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n            # Apply distinct() when limit_choices_to is a Q object to prevent duplicates\n            # that can occur when Q objects involve joins\n            from django.db.models import Q\n            if isinstance(limit_choices_to, Q):\n                formfield.queryset = formfield.queryset.distinct()\n",
      "\ndef apply_limit_choices_to_to_formfield(formfield):\n    \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n    if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n        limit_choices_to = formfield.get_limit_choices_to()\n        if limit_choices_to is not None:\n            formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n            # Apply distinct() when limit_choices_to is a Q object to prevent duplicates\n            # that can occur when Q objects involve database joins\n            from django.db.models import Q\n            if isinstance(limit_choices_to, Q):\n                formfield.queryset = formfield.queryset.distinct()\n",
      "\ndef apply_limit_choices_to_to_formfield(formfield):\n    \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n    if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n        limit_choices_to = formfield.get_limit_choices_to()\n        if limit_choices_to is not None:\n            formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n            # Apply distinct() when limit_choices_to is a Q object to prevent duplicates\n            # that can occur when Q objects involve joins\n            from django.db.models import Q\n            if isinstance(limit_choices_to, Q):\n                formfield.queryset = formfield.queryset.distinct()\n",
      "\ndef apply_limit_choices_to_to_formfield(formfield):\n    \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n    if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n        limit_choices_to = formfield.get_limit_choices_to()\n        if limit_choices_to is not None:\n            formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n            # Apply distinct() when limit_choices_to is a Q object to prevent duplicates\n            # that can occur when Q objects involve joins\n            from django.db.models import Q\n            if isinstance(limit_choices_to, Q):\n                formfield.queryset = formfield.queryset.distinct()\n",
      "\ndef apply_limit_choices_to_to_formfield(formfield):\n    \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n    if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n        limit_choices_to = formfield.get_limit_choices_to()\n        if limit_choices_to is not None:\n            formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n            # Apply distinct() when limit_choices_to is a Q object to prevent duplicates\n            # that can occur when Q objects involve database joins\n            from django.db.models import Q\n            if isinstance(limit_choices_to, Q):\n                formfield.queryset = formfield.queryset.distinct()\n",
      "\ndef apply_limit_choices_to_to_formfield(formfield):\n    \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n    if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n        limit_choices_to = formfield.get_limit_choices_to()\n        if limit_choices_to is not None:\n            formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n            # Apply distinct() when limit_choices_to is a Q object to prevent duplicates\n            # that can occur when Q objects involve joins\n            from django.db.models import Q\n            if isinstance(limit_choices_to, Q):\n                formfield.queryset = formfield.queryset.distinct()\n",
      "\ndef apply_limit_choices_to_to_formfield(formfield):\n    \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n    if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n        limit_choices_to = formfield.get_limit_choices_to()\n        if limit_choices_to is not None:\n            formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n            # Apply distinct() when limit_choices_to is a Q object to prevent duplicates\n            # that can occur when Q objects involve joins\n            from django.db.models import Q\n            if isinstance(limit_choices_to, Q):\n                formfield.queryset = formfield.queryset.distinct()\n",
      "\ndef apply_limit_choices_to_to_formfield(formfield):\n    \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n    if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n        limit_choices_to = formfield.get_limit_choices_to()\n        if limit_choices_to is not None:\n            formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n            # Apply distinct() when limit_choices_to is a Q object to prevent duplicates\n            # that can occur when the Q object involves joins\n            from django.db.models import Q\n            if isinstance(limit_choices_to, Q):\n                formfield.queryset = formfield.queryset.distinct()\n"
    ],
    "Location 2 (/root/hy/projects_3/django/django/forms/models.py lines 8-10)": [
      "\nfrom django.core.exceptions import (\n    NON_FIELD_ERRORS, FieldError, ImproperlyConfigured, ValidationError,\n)\nfrom django.db.models import Q\n",
      "\nfrom django.core.exceptions import (\n    NON_FIELD_ERRORS, FieldError, ImproperlyConfigured, ValidationError,\n)\nfrom django.db.models import Q\n",
      "\nfrom django.core.exceptions import (\n    NON_FIELD_ERRORS, FieldError, ImproperlyConfigured, ValidationError,\n)\nfrom django.db.models import Q\n",
      "\nfrom django.core.exceptions import (\n    NON_FIELD_ERRORS, FieldError, ImproperlyConfigured, ValidationError,\n)\nfrom django.db.models import Q\n",
      "\nfrom django.core.exceptions import (\n    NON_FIELD_ERRORS, FieldError, ImproperlyConfigured, ValidationError,\n)\nfrom django.db.models import Q\n",
      "\nfrom django.core.exceptions import (\n    NON_FIELD_ERRORS, FieldError, ImproperlyConfigured, ValidationError,\n)\nfrom django.db.models import Q\n",
      "\nfrom django.core.exceptions import (\n    NON_FIELD_ERRORS, FieldError, ImproperlyConfigured, ValidationError,\n)\nfrom django.db.models import Q\n",
      "\nfrom django.core.exceptions import (\n    NON_FIELD_ERRORS, FieldError, ImproperlyConfigured, ValidationError,\n)\nfrom django.db.models import Q\n"
    ],
    "Location 3 (/root/hy/projects_3/django/django/db/models/query.py lines 968-983)": [
      "\n    def complex_filter(self, filter_obj):\n        \"\"\"\n        Return a new QuerySet instance with filter_obj added to the filters.\n\n        filter_obj can be a Q object or a dictionary of keyword lookup\n        arguments.\n\n        This exists to support framework features such as 'limit_choices_to',\n        and usually it will be more natural to use other methods.\n        \"\"\"\n        if isinstance(filter_obj, Q):\n            clone = self._chain()\n            clone.query.add_q(filter_obj)\n            return clone\n        else:\n            return self._filter_or_exclude(False, args=(), kwargs=filter_obj)\n",
      "\n    def complex_filter(self, filter_obj):\n        \"\"\"\n        Return a new QuerySet instance with filter_obj added to the filters.\n\n        filter_obj can be a Q object or a dictionary of keyword lookup\n        arguments.\n\n        This exists to support framework features such as 'limit_choices_to',\n        and usually it will be more natural to use other methods.\n        \"\"\"\n        if isinstance(filter_obj, Q):\n            clone = self._chain()\n            clone.query.add_q(filter_obj)\n            return clone\n        else:\n            return self._filter_or_exclude(False, args=(), kwargs=filter_obj)\n",
      "\n    def complex_filter(self, filter_obj):\n        \"\"\"\n        Return a new QuerySet instance with filter_obj added to the filters.\n\n        filter_obj can be a Q object or a dictionary of keyword lookup\n        arguments.\n\n        This exists to support framework features such as 'limit_choices_to',\n        and usually it will be more natural to use other methods.\n        \"\"\"\n        if isinstance(filter_obj, Q):\n            clone = self._chain()\n            clone.query.add_q(filter_obj)\n            return clone\n        else:\n            return self._filter_or_exclude(False, args=(), kwargs=filter_obj)\n",
      "\ndef complex_filter(self, filter_obj):\n    \"\"\"\n    Return a new QuerySet instance with filter_obj added to the filters.\n\n    filter_obj can be a Q object or a dictionary of keyword lookup\n    arguments.\n\n    This exists to support framework features such as 'limit_choices_to',\n    and usually it will be more natural to use other methods.\n    \"\"\"\n    if isinstance(filter_obj, Q):\n        clone = self._chain()\n        clone.query.add_q(filter_obj)\n        return clone\n    else:\n        return self._filter_or_exclude(False, args=(), kwargs=filter_obj)\n",
      "\n    def complex_filter(self, filter_obj):\n        \"\"\"\n        Return a new QuerySet instance with filter_obj added to the filters.\n\n        filter_obj can be a Q object or a dictionary of keyword lookup\n        arguments.\n\n        This exists to support framework features such as 'limit_choices_to',\n        and usually it will be more natural to use other methods.\n        \"\"\"\n        if isinstance(filter_obj, Q):\n            clone = self._chain()\n            clone.query.add_q(filter_obj)\n            return clone\n        else:\n            return self._filter_or_exclude(False, args=(), kwargs=filter_obj)\n",
      "\ndef apply_limit_choices_to_to_formfield(formfield, limit_choices_to):\n    \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n    if limit_choices_to is not None and hasattr(formfield, 'queryset'):\n        formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n        # If limit_choices_to is a Q object, apply distinct() to prevent duplicates\n        # that can occur when the Q object involves joins\n        if isinstance(limit_choices_to, Q):\n            formfield.queryset = formfield.queryset.distinct()\n",
      "\ndef apply_limit_choices_to_to_formfield(formfield, limit_choices_to):\n    \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n    if limit_choices_to is not None:\n        formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n        # When limit_choices_to is a Q object that involves joins, complex_filter\n        # can produce duplicate results. Apply distinct() to ensure unique options.\n        if isinstance(limit_choices_to, Q):\n            formfield.queryset = formfield.queryset.distinct()\n",
      "\n    def complex_filter(self, filter_obj):\n        \"\"\"\n        Return a new QuerySet instance with filter_obj added to the filters.\n\n        filter_obj can be a Q object or a dictionary of keyword lookup\n        arguments.\n\n        This exists to support framework features such as 'limit_choices_to',\n        and usually it will be more natural to use other methods.\n        \"\"\"\n        if isinstance(filter_obj, Q):\n            clone = self._chain()\n            clone.query.add_q(filter_obj)\n            return clone\n        else:\n            return self._filter_or_exclude(False, args=(), kwargs=filter_obj)\n"
    ],
    "Location 4 (/root/hy/projects_3/django/django/db/models/fields/related.py lines 401-419)": [
      "\ndef apply_limit_choices_to_to_formfield(formfield, limit_choices_to):\n    \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n    if hasattr(formfield, 'queryset') and hasattr(formfield.queryset, 'complex_filter'):\n        from django.db.models import Q\n        formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n        if isinstance(limit_choices_to, Q):\n            formfield.queryset = formfield.queryset.distinct()\n",
      "\n    def formfield(self, **kwargs):\n        \"\"\"\n        Pass ``limit_choices_to`` to the field being constructed.\n\n        Only passes it if there is a type that supports related fields.\n        This is a similar strategy used to pass the ``queryset`` to the field\n        being constructed.\n        \"\"\"\n        defaults = {}\n        if hasattr(self.remote_field, 'get_related_field'):\n            # If this is a callable, do not invoke it here. Just pass\n            # it in the defaults for when the form class will later be\n            # instantiated.\n            limit_choices_to = self.remote_field.limit_choices_to\n            defaults.update({\n                'limit_choices_to': limit_choices_to,\n            })\n        defaults.update(kwargs)\n        return super().formfield(**defaults)\n",
      "\ndef apply_limit_choices_to_to_formfield(formfield):\n    \"\"\"Apply limit_choices_to (if any) to the formfield.\"\"\"\n    if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n        limit_choices_to = formfield.get_limit_choices_to()\n        if limit_choices_to is not None:\n            formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n            # Prevent duplicates when Q objects involve joins\n            from django.db.models import Q\n            if isinstance(limit_choices_to, Q):\n                formfield.queryset = formfield.queryset.distinct()\n",
      "\ndef formfield(self, **kwargs):\n    \"\"\"\n    Pass ``limit_choices_to`` to the field being constructed.\n\n    Only passes it if there is a type that supports related fields.\n    This is a similar strategy used to pass the ``queryset`` to the field\n    being constructed.\n    \"\"\"\n    defaults = {}\n    if hasattr(self.remote_field, 'get_related_field'):\n        # If this is a callable, do not invoke it here. Just pass\n        # it in the defaults for when the form class will later be\n        # instantiated.\n        limit_choices_to = self.remote_field.limit_choices_to\n        defaults.update({\n            'limit_choices_to': limit_choices_to,\n        })\n    defaults.update(kwargs)\n    return super().formfield(**defaults)\n",
      "\ndef apply_limit_choices_to_to_formfield(formfield, limit_choices_to):\n    \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n    if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n        limit_choices_to = formfield.get_limit_choices_to()\n        if limit_choices_to is not None:\n            formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n            # Add distinct() when limit_choices_to is a Q object to prevent duplicates\n            # that can occur when the Q object involves joins\n            if isinstance(limit_choices_to, Q):\n                formfield.queryset = formfield.queryset.distinct()\n",
      "\ndef apply_limit_choices_to_to_formfield(formfield, limit_choices_to):\n    \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n    if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n        limit_choices_to = formfield.get_limit_choices_to()\n        if limit_choices_to:\n            formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n            if isinstance(limit_choices_to, Q):\n                formfield.queryset = formfield.queryset.distinct()\n",
      "\ndef apply_limit_choices_to_to_formfield(formfield, limit_choices_to):\n    \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n    if hasattr(formfield, 'queryset') and hasattr(formfield.queryset, 'complex_filter'):\n        formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n        # Apply distinct() when using Q objects to prevent duplicates from joins\n        if isinstance(limit_choices_to, Q):\n            formfield.queryset = formfield.queryset.distinct()\n",
      "\ndef apply_limit_choices_to_to_formfield(formfield, limit_choices_to):\n    \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n    if hasattr(formfield, 'queryset') and hasattr(formfield.queryset, 'complex_filter'):\n        formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n        # Apply distinct() when limit_choices_to is a Q object to prevent duplicates\n        # that can occur when Q objects involve joins\n        if isinstance(limit_choices_to, Q):\n            formfield.queryset = formfield.queryset.distinct()\n"
    ],
    "Location 5 (/root/hy/projects_3/django/django/db/models/fields/related.py lines 390-399)": [
      "\ndef get_limit_choices_to(self):\n    \"\"\"\n    Return ``limit_choices_to`` for this model field.\n\n    If it is a callable, it will be invoked and the result will be\n    returned.\n    \"\"\"\n    if callable(self.remote_field.limit_choices_to):\n        return self.remote_field.limit_choices_to()\n    return self.remote_field.limit_choices_to\n",
      "\n    def get_limit_choices_to(self):\n        \"\"\"\n        Return ``limit_choices_to`` for this model field.\n\n        If it is a callable, it will be invoked and the result will be\n        returned.\n        \"\"\"\n        if callable(self.remote_field.limit_choices_to):\n            return self.remote_field.limit_choices_to()\n        return self.remote_field.limit_choices_to\n",
      "\n    def get_limit_choices_to(self):\n        \"\"\"\n        Return ``limit_choices_to`` for this model field.\n\n        If it is a callable, it will be invoked and the result will be\n        returned.\n        \"\"\"\n        if callable(self.remote_field.limit_choices_to):\n            return self.remote_field.limit_choices_to()\n        return self.remote_field.limit_choices_to\n",
      "\n    def get_limit_choices_to(self):\n        \"\"\"\n        Return ``limit_choices_to`` for this model field.\n\n        If it is a callable, it will be invoked and the result will be\n        returned.\n        \"\"\"\n        if callable(self.remote_field.limit_choices_to):\n            return self.remote_field.limit_choices_to()\n        return self.remote_field.limit_choices_to\n",
      "\n    def get_limit_choices_to(self):\n        \"\"\"\n        Return ``limit_choices_to`` for this model field.\n\n        If it is a callable, it will be invoked and the result will be\n        returned.\n        \"\"\"\n        if callable(self.remote_field.limit_choices_to):\n            return self.remote_field.limit_choices_to()\n        return self.remote_field.limit_choices_to\n",
      "\ndef get_limit_choices_to(self):\n    \"\"\"\n    Return ``limit_choices_to`` for this model field.\n\n    If it is a callable, it will be invoked and the result will be\n    returned.\n    \"\"\"\n    if callable(self.remote_field.limit_choices_to):\n        return self.remote_field.limit_choices_to()\n    return self.remote_field.limit_choices_to\n",
      "\ndef get_limit_choices_to(self):\n    \"\"\"\n    Return ``limit_choices_to`` for this model field.\n\n    If it is a callable, it will be invoked and the result will be\n    returned.\n    \"\"\"\n    if callable(self.remote_field.limit_choices_to):\n        return self.remote_field.limit_choices_to()\n    return self.remote_field.limit_choices_to\n",
      "\ndef get_limit_choices_to(self):\n    \"\"\"\n    Return ``limit_choices_to`` for this model field.\n\n    If it is a callable, it will be invoked and the result will be\n    returned.\n    \"\"\"\n    if callable(self.remote_field.limit_choices_to):\n        return self.remote_field.limit_choices_to()\n    return self.remote_field.limit_choices_to\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 397146a354..428e54293f 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -387,6 +387,7 @@ class RelatedField(FieldCacheMixin, Field):\n         self.set_attributes_from_rel()\n         self.contribute_to_related_class(other, self.remote_field)\n \n+\n     def get_limit_choices_to(self):\n         \"\"\"\n         Return ``limit_choices_to`` for this model field.\n@@ -398,6 +399,7 @@ class RelatedField(FieldCacheMixin, Field):\n             return self.remote_field.limit_choices_to()\n         return self.remote_field.limit_choices_to\n \n+\n     def formfield(self, **kwargs):\n         \"\"\"\n         Pass ``limit_choices_to`` to the field being constructed.\ndiff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 2c2b5d0883..cdcaccd800 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -965,6 +965,7 @@ class QuerySet:\n         else:\n             self._query.add_q(Q(*args, **kwargs))\n \n+\n     def complex_filter(self, filter_obj):\n         \"\"\"\n         Return a new QuerySet instance with filter_obj added to the filters.\ndiff --git a/django/forms/models.py b/django/forms/models.py\nindex 5d115458a1..def39f1b46 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -5,9 +5,11 @@ and database field objects.\n import warnings\n from itertools import chain\n \n+\n from django.core.exceptions import (\n     NON_FIELD_ERRORS, FieldError, ImproperlyConfigured, ValidationError,\n )\n+from django.db.models import Q\n from django.forms.fields import ChoiceField, Field\n from django.forms.forms import BaseForm, DeclarativeFieldsMetaclass\n from django.forms.formsets import BaseFormSet, formset_factory\n@@ -95,12 +97,16 @@ def model_to_dict(instance, fields=None, exclude=None):\n     return data\n \n \n+\n def apply_limit_choices_to_to_formfield(formfield):\n     \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n     if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n         limit_choices_to = formfield.get_limit_choices_to()\n         if limit_choices_to is not None:\n             formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n+            # Apply distinct() when limit_choices_to is a Q object to avoid duplicates from joins\n+            if isinstance(limit_choices_to, Q):\n+                formfield.queryset = formfield.queryset.distinct()\n \n \n def fields_for_model(model, fields=None, exclude=None, widgets=None,\n",
    "variant_0": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 397146a354..428e54293f 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -387,6 +387,7 @@ class RelatedField(FieldCacheMixin, Field):\n         self.set_attributes_from_rel()\n         self.contribute_to_related_class(other, self.remote_field)\n \n+\n     def get_limit_choices_to(self):\n         \"\"\"\n         Return ``limit_choices_to`` for this model field.\n@@ -398,6 +399,7 @@ class RelatedField(FieldCacheMixin, Field):\n             return self.remote_field.limit_choices_to()\n         return self.remote_field.limit_choices_to\n \n+\n     def formfield(self, **kwargs):\n         \"\"\"\n         Pass ``limit_choices_to`` to the field being constructed.\ndiff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 2c2b5d0883..cdcaccd800 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -965,6 +965,7 @@ class QuerySet:\n         else:\n             self._query.add_q(Q(*args, **kwargs))\n \n+\n     def complex_filter(self, filter_obj):\n         \"\"\"\n         Return a new QuerySet instance with filter_obj added to the filters.\ndiff --git a/django/forms/models.py b/django/forms/models.py\nindex 5d115458a1..51f2002fa4 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -5,9 +5,11 @@ and database field objects.\n import warnings\n from itertools import chain\n \n+\n from django.core.exceptions import (\n     NON_FIELD_ERRORS, FieldError, ImproperlyConfigured, ValidationError,\n )\n+from django.db.models import Q\n from django.forms.fields import ChoiceField, Field\n from django.forms.forms import BaseForm, DeclarativeFieldsMetaclass\n from django.forms.formsets import BaseFormSet, formset_factory\n@@ -95,12 +97,16 @@ def model_to_dict(instance, fields=None, exclude=None):\n     return data\n \n \n+\n def apply_limit_choices_to_to_formfield(formfield):\n     \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n     if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n         limit_choices_to = formfield.get_limit_choices_to()\n         if limit_choices_to is not None:\n             formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n+            # Apply distinct() when using Q objects to prevent duplicates from joins\n+            if hasattr(limit_choices_to, 'children'):  # Q object detection\n+                formfield.queryset = formfield.queryset.distinct()\n \n \n def fields_for_model(model, fields=None, exclude=None, widgets=None,\n",
    "variant_1": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 397146a354..64da40c710 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -387,36 +387,26 @@ class RelatedField(FieldCacheMixin, Field):\n         self.set_attributes_from_rel()\n         self.contribute_to_related_class(other, self.remote_field)\n \n-    def get_limit_choices_to(self):\n-        \"\"\"\n-        Return ``limit_choices_to`` for this model field.\n-\n-        If it is a callable, it will be invoked and the result will be\n-        returned.\n-        \"\"\"\n-        if callable(self.remote_field.limit_choices_to):\n-            return self.remote_field.limit_choices_to()\n-        return self.remote_field.limit_choices_to\n \n-    def formfield(self, **kwargs):\n-        \"\"\"\n-        Pass ``limit_choices_to`` to the field being constructed.\n+def get_limit_choices_to(self):\n+    \"\"\"\n+    Return ``limit_choices_to`` for this model field.\n \n-        Only passes it if there is a type that supports related fields.\n-        This is a similar strategy used to pass the ``queryset`` to the field\n-        being constructed.\n-        \"\"\"\n-        defaults = {}\n-        if hasattr(self.remote_field, 'get_related_field'):\n-            # If this is a callable, do not invoke it here. Just pass\n-            # it in the defaults for when the form class will later be\n-            # instantiated.\n-            limit_choices_to = self.remote_field.limit_choices_to\n-            defaults.update({\n-                'limit_choices_to': limit_choices_to,\n-            })\n-        defaults.update(kwargs)\n-        return super().formfield(**defaults)\n+    If it is a callable, it will be invoked and the result will be\n+    returned.\n+    \"\"\"\n+    if callable(self.remote_field.limit_choices_to):\n+        return self.remote_field.limit_choices_to()\n+    return self.remote_field.limit_choices_to\n+\n+\n+def apply_limit_choices_to_to_formfield(formfield, limit_choices_to):\n+    \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n+    if hasattr(formfield, 'queryset') and hasattr(formfield.queryset, 'complex_filter'):\n+        from django.db.models import Q\n+        formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n+        if isinstance(limit_choices_to, Q):\n+            formfield.queryset = formfield.queryset.distinct()\n \n     def related_query_name(self):\n         \"\"\"\ndiff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 2c2b5d0883..cdcaccd800 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -965,6 +965,7 @@ class QuerySet:\n         else:\n             self._query.add_q(Q(*args, **kwargs))\n \n+\n     def complex_filter(self, filter_obj):\n         \"\"\"\n         Return a new QuerySet instance with filter_obj added to the filters.\ndiff --git a/django/forms/models.py b/django/forms/models.py\nindex 5d115458a1..ea322ec474 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -5,9 +5,11 @@ and database field objects.\n import warnings\n from itertools import chain\n \n+\n from django.core.exceptions import (\n     NON_FIELD_ERRORS, FieldError, ImproperlyConfigured, ValidationError,\n )\n+from django.db.models import Q\n from django.forms.fields import ChoiceField, Field\n from django.forms.forms import BaseForm, DeclarativeFieldsMetaclass\n from django.forms.formsets import BaseFormSet, formset_factory\n@@ -95,12 +97,18 @@ def model_to_dict(instance, fields=None, exclude=None):\n     return data\n \n \n+\n def apply_limit_choices_to_to_formfield(formfield):\n     \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n     if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n         limit_choices_to = formfield.get_limit_choices_to()\n         if limit_choices_to is not None:\n             formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n+            # Apply distinct() when limit_choices_to is a Q object to prevent duplicates\n+            # that can occur when Q objects involve joins\n+            from django.db.models import Q\n+            if isinstance(limit_choices_to, Q):\n+                formfield.queryset = formfield.queryset.distinct()\n \n \n def fields_for_model(model, fields=None, exclude=None, widgets=None,\n",
    "variant_2": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 397146a354..428e54293f 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -387,6 +387,7 @@ class RelatedField(FieldCacheMixin, Field):\n         self.set_attributes_from_rel()\n         self.contribute_to_related_class(other, self.remote_field)\n \n+\n     def get_limit_choices_to(self):\n         \"\"\"\n         Return ``limit_choices_to`` for this model field.\n@@ -398,6 +399,7 @@ class RelatedField(FieldCacheMixin, Field):\n             return self.remote_field.limit_choices_to()\n         return self.remote_field.limit_choices_to\n \n+\n     def formfield(self, **kwargs):\n         \"\"\"\n         Pass ``limit_choices_to`` to the field being constructed.\ndiff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 2c2b5d0883..cdcaccd800 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -965,6 +965,7 @@ class QuerySet:\n         else:\n             self._query.add_q(Q(*args, **kwargs))\n \n+\n     def complex_filter(self, filter_obj):\n         \"\"\"\n         Return a new QuerySet instance with filter_obj added to the filters.\ndiff --git a/django/forms/models.py b/django/forms/models.py\nindex 5d115458a1..c00c2b5fe3 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -5,9 +5,11 @@ and database field objects.\n import warnings\n from itertools import chain\n \n+\n from django.core.exceptions import (\n     NON_FIELD_ERRORS, FieldError, ImproperlyConfigured, ValidationError,\n )\n+from django.db.models import Q\n from django.forms.fields import ChoiceField, Field\n from django.forms.forms import BaseForm, DeclarativeFieldsMetaclass\n from django.forms.formsets import BaseFormSet, formset_factory\n@@ -95,12 +97,18 @@ def model_to_dict(instance, fields=None, exclude=None):\n     return data\n \n \n+\n def apply_limit_choices_to_to_formfield(formfield):\n     \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n     if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n         limit_choices_to = formfield.get_limit_choices_to()\n         if limit_choices_to is not None:\n             formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n+            # Apply distinct() when limit_choices_to is a Q object to prevent duplicates\n+            # that can occur when Q objects involve database joins\n+            from django.db.models import Q\n+            if isinstance(limit_choices_to, Q):\n+                formfield.queryset = formfield.queryset.distinct()\n \n \n def fields_for_model(model, fields=None, exclude=None, widgets=None,\n",
    "variant_3": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 397146a354..6be5015886 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -387,6 +387,7 @@ class RelatedField(FieldCacheMixin, Field):\n         self.set_attributes_from_rel()\n         self.contribute_to_related_class(other, self.remote_field)\n \n+\n     def get_limit_choices_to(self):\n         \"\"\"\n         Return ``limit_choices_to`` for this model field.\n@@ -398,25 +399,17 @@ class RelatedField(FieldCacheMixin, Field):\n             return self.remote_field.limit_choices_to()\n         return self.remote_field.limit_choices_to\n \n-    def formfield(self, **kwargs):\n-        \"\"\"\n-        Pass ``limit_choices_to`` to the field being constructed.\n \n-        Only passes it if there is a type that supports related fields.\n-        This is a similar strategy used to pass the ``queryset`` to the field\n-        being constructed.\n-        \"\"\"\n-        defaults = {}\n-        if hasattr(self.remote_field, 'get_related_field'):\n-            # If this is a callable, do not invoke it here. Just pass\n-            # it in the defaults for when the form class will later be\n-            # instantiated.\n-            limit_choices_to = self.remote_field.limit_choices_to\n-            defaults.update({\n-                'limit_choices_to': limit_choices_to,\n-            })\n-        defaults.update(kwargs)\n-        return super().formfield(**defaults)\n+def apply_limit_choices_to_to_formfield(formfield):\n+    \"\"\"Apply limit_choices_to (if any) to the formfield.\"\"\"\n+    if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n+        limit_choices_to = formfield.get_limit_choices_to()\n+        if limit_choices_to is not None:\n+            formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n+            # Prevent duplicates when Q objects involve joins\n+            from django.db.models import Q\n+            if isinstance(limit_choices_to, Q):\n+                formfield.queryset = formfield.queryset.distinct()\n \n     def related_query_name(self):\n         \"\"\"\ndiff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 2c2b5d0883..cdcaccd800 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -965,6 +965,7 @@ class QuerySet:\n         else:\n             self._query.add_q(Q(*args, **kwargs))\n \n+\n     def complex_filter(self, filter_obj):\n         \"\"\"\n         Return a new QuerySet instance with filter_obj added to the filters.\ndiff --git a/django/forms/models.py b/django/forms/models.py\nindex 5d115458a1..ea322ec474 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -5,9 +5,11 @@ and database field objects.\n import warnings\n from itertools import chain\n \n+\n from django.core.exceptions import (\n     NON_FIELD_ERRORS, FieldError, ImproperlyConfigured, ValidationError,\n )\n+from django.db.models import Q\n from django.forms.fields import ChoiceField, Field\n from django.forms.forms import BaseForm, DeclarativeFieldsMetaclass\n from django.forms.formsets import BaseFormSet, formset_factory\n@@ -95,12 +97,18 @@ def model_to_dict(instance, fields=None, exclude=None):\n     return data\n \n \n+\n def apply_limit_choices_to_to_formfield(formfield):\n     \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n     if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n         limit_choices_to = formfield.get_limit_choices_to()\n         if limit_choices_to is not None:\n             formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n+            # Apply distinct() when limit_choices_to is a Q object to prevent duplicates\n+            # that can occur when Q objects involve joins\n+            from django.db.models import Q\n+            if isinstance(limit_choices_to, Q):\n+                formfield.queryset = formfield.queryset.distinct()\n \n \n def fields_for_model(model, fields=None, exclude=None, widgets=None,\n",
    "variant_4": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 397146a354..48894b0a66 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -387,6 +387,7 @@ class RelatedField(FieldCacheMixin, Field):\n         self.set_attributes_from_rel()\n         self.contribute_to_related_class(other, self.remote_field)\n \n+\n     def get_limit_choices_to(self):\n         \"\"\"\n         Return ``limit_choices_to`` for this model field.\n@@ -398,25 +399,26 @@ class RelatedField(FieldCacheMixin, Field):\n             return self.remote_field.limit_choices_to()\n         return self.remote_field.limit_choices_to\n \n-    def formfield(self, **kwargs):\n-        \"\"\"\n-        Pass ``limit_choices_to`` to the field being constructed.\n \n-        Only passes it if there is a type that supports related fields.\n-        This is a similar strategy used to pass the ``queryset`` to the field\n-        being constructed.\n-        \"\"\"\n-        defaults = {}\n-        if hasattr(self.remote_field, 'get_related_field'):\n-            # If this is a callable, do not invoke it here. Just pass\n-            # it in the defaults for when the form class will later be\n-            # instantiated.\n-            limit_choices_to = self.remote_field.limit_choices_to\n-            defaults.update({\n-                'limit_choices_to': limit_choices_to,\n-            })\n-        defaults.update(kwargs)\n-        return super().formfield(**defaults)\n+def formfield(self, **kwargs):\n+    \"\"\"\n+    Pass ``limit_choices_to`` to the field being constructed.\n+\n+    Only passes it if there is a type that supports related fields.\n+    This is a similar strategy used to pass the ``queryset`` to the field\n+    being constructed.\n+    \"\"\"\n+    defaults = {}\n+    if hasattr(self.remote_field, 'get_related_field'):\n+        # If this is a callable, do not invoke it here. Just pass\n+        # it in the defaults for when the form class will later be\n+        # instantiated.\n+        limit_choices_to = self.remote_field.limit_choices_to\n+        defaults.update({\n+            'limit_choices_to': limit_choices_to,\n+        })\n+    defaults.update(kwargs)\n+    return super().formfield(**defaults)\n \n     def related_query_name(self):\n         \"\"\"\ndiff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 2c2b5d0883..1080903c22 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -965,22 +965,23 @@ class QuerySet:\n         else:\n             self._query.add_q(Q(*args, **kwargs))\n \n-    def complex_filter(self, filter_obj):\n-        \"\"\"\n-        Return a new QuerySet instance with filter_obj added to the filters.\n \n-        filter_obj can be a Q object or a dictionary of keyword lookup\n-        arguments.\n+def complex_filter(self, filter_obj):\n+    \"\"\"\n+    Return a new QuerySet instance with filter_obj added to the filters.\n \n-        This exists to support framework features such as 'limit_choices_to',\n-        and usually it will be more natural to use other methods.\n-        \"\"\"\n-        if isinstance(filter_obj, Q):\n-            clone = self._chain()\n-            clone.query.add_q(filter_obj)\n-            return clone\n-        else:\n-            return self._filter_or_exclude(False, args=(), kwargs=filter_obj)\n+    filter_obj can be a Q object or a dictionary of keyword lookup\n+    arguments.\n+\n+    This exists to support framework features such as 'limit_choices_to',\n+    and usually it will be more natural to use other methods.\n+    \"\"\"\n+    if isinstance(filter_obj, Q):\n+        clone = self._chain()\n+        clone.query.add_q(filter_obj)\n+        return clone\n+    else:\n+        return self._filter_or_exclude(False, args=(), kwargs=filter_obj)\n \n     def _combinator_query(self, combinator, *other_qs, all=False):\n         # Clone the query to inherit the select list and everything\ndiff --git a/django/forms/models.py b/django/forms/models.py\nindex 5d115458a1..ea322ec474 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -5,9 +5,11 @@ and database field objects.\n import warnings\n from itertools import chain\n \n+\n from django.core.exceptions import (\n     NON_FIELD_ERRORS, FieldError, ImproperlyConfigured, ValidationError,\n )\n+from django.db.models import Q\n from django.forms.fields import ChoiceField, Field\n from django.forms.forms import BaseForm, DeclarativeFieldsMetaclass\n from django.forms.formsets import BaseFormSet, formset_factory\n@@ -95,12 +97,18 @@ def model_to_dict(instance, fields=None, exclude=None):\n     return data\n \n \n+\n def apply_limit_choices_to_to_formfield(formfield):\n     \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n     if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n         limit_choices_to = formfield.get_limit_choices_to()\n         if limit_choices_to is not None:\n             formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n+            # Apply distinct() when limit_choices_to is a Q object to prevent duplicates\n+            # that can occur when Q objects involve joins\n+            from django.db.models import Q\n+            if isinstance(limit_choices_to, Q):\n+                formfield.queryset = formfield.queryset.distinct()\n \n \n def fields_for_model(model, fields=None, exclude=None, widgets=None,\n",
    "variant_5": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 397146a354..1c749ab385 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -387,6 +387,7 @@ class RelatedField(FieldCacheMixin, Field):\n         self.set_attributes_from_rel()\n         self.contribute_to_related_class(other, self.remote_field)\n \n+\n     def get_limit_choices_to(self):\n         \"\"\"\n         Return ``limit_choices_to`` for this model field.\n@@ -398,25 +399,17 @@ class RelatedField(FieldCacheMixin, Field):\n             return self.remote_field.limit_choices_to()\n         return self.remote_field.limit_choices_to\n \n-    def formfield(self, **kwargs):\n-        \"\"\"\n-        Pass ``limit_choices_to`` to the field being constructed.\n \n-        Only passes it if there is a type that supports related fields.\n-        This is a similar strategy used to pass the ``queryset`` to the field\n-        being constructed.\n-        \"\"\"\n-        defaults = {}\n-        if hasattr(self.remote_field, 'get_related_field'):\n-            # If this is a callable, do not invoke it here. Just pass\n-            # it in the defaults for when the form class will later be\n-            # instantiated.\n-            limit_choices_to = self.remote_field.limit_choices_to\n-            defaults.update({\n-                'limit_choices_to': limit_choices_to,\n-            })\n-        defaults.update(kwargs)\n-        return super().formfield(**defaults)\n+def apply_limit_choices_to_to_formfield(formfield, limit_choices_to):\n+    \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n+    if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n+        limit_choices_to = formfield.get_limit_choices_to()\n+        if limit_choices_to is not None:\n+            formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n+            # Add distinct() when limit_choices_to is a Q object to prevent duplicates\n+            # that can occur when the Q object involves joins\n+            if isinstance(limit_choices_to, Q):\n+                formfield.queryset = formfield.queryset.distinct()\n \n     def related_query_name(self):\n         \"\"\"\ndiff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 2c2b5d0883..cdcaccd800 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -965,6 +965,7 @@ class QuerySet:\n         else:\n             self._query.add_q(Q(*args, **kwargs))\n \n+\n     def complex_filter(self, filter_obj):\n         \"\"\"\n         Return a new QuerySet instance with filter_obj added to the filters.\ndiff --git a/django/forms/models.py b/django/forms/models.py\nindex 5d115458a1..c00c2b5fe3 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -5,9 +5,11 @@ and database field objects.\n import warnings\n from itertools import chain\n \n+\n from django.core.exceptions import (\n     NON_FIELD_ERRORS, FieldError, ImproperlyConfigured, ValidationError,\n )\n+from django.db.models import Q\n from django.forms.fields import ChoiceField, Field\n from django.forms.forms import BaseForm, DeclarativeFieldsMetaclass\n from django.forms.formsets import BaseFormSet, formset_factory\n@@ -95,12 +97,18 @@ def model_to_dict(instance, fields=None, exclude=None):\n     return data\n \n \n+\n def apply_limit_choices_to_to_formfield(formfield):\n     \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n     if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n         limit_choices_to = formfield.get_limit_choices_to()\n         if limit_choices_to is not None:\n             formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n+            # Apply distinct() when limit_choices_to is a Q object to prevent duplicates\n+            # that can occur when Q objects involve database joins\n+            from django.db.models import Q\n+            if isinstance(limit_choices_to, Q):\n+                formfield.queryset = formfield.queryset.distinct()\n \n \n def fields_for_model(model, fields=None, exclude=None, widgets=None,\n",
    "variant_6": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 397146a354..b52bee9f25 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -387,36 +387,27 @@ class RelatedField(FieldCacheMixin, Field):\n         self.set_attributes_from_rel()\n         self.contribute_to_related_class(other, self.remote_field)\n \n-    def get_limit_choices_to(self):\n-        \"\"\"\n-        Return ``limit_choices_to`` for this model field.\n-\n-        If it is a callable, it will be invoked and the result will be\n-        returned.\n-        \"\"\"\n-        if callable(self.remote_field.limit_choices_to):\n-            return self.remote_field.limit_choices_to()\n-        return self.remote_field.limit_choices_to\n \n-    def formfield(self, **kwargs):\n-        \"\"\"\n-        Pass ``limit_choices_to`` to the field being constructed.\n+def get_limit_choices_to(self):\n+    \"\"\"\n+    Return ``limit_choices_to`` for this model field.\n \n-        Only passes it if there is a type that supports related fields.\n-        This is a similar strategy used to pass the ``queryset`` to the field\n-        being constructed.\n-        \"\"\"\n-        defaults = {}\n-        if hasattr(self.remote_field, 'get_related_field'):\n-            # If this is a callable, do not invoke it here. Just pass\n-            # it in the defaults for when the form class will later be\n-            # instantiated.\n-            limit_choices_to = self.remote_field.limit_choices_to\n-            defaults.update({\n-                'limit_choices_to': limit_choices_to,\n-            })\n-        defaults.update(kwargs)\n-        return super().formfield(**defaults)\n+    If it is a callable, it will be invoked and the result will be\n+    returned.\n+    \"\"\"\n+    if callable(self.remote_field.limit_choices_to):\n+        return self.remote_field.limit_choices_to()\n+    return self.remote_field.limit_choices_to\n+\n+\n+def apply_limit_choices_to_to_formfield(formfield, limit_choices_to):\n+    \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n+    if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n+        limit_choices_to = formfield.get_limit_choices_to()\n+        if limit_choices_to:\n+            formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n+            if isinstance(limit_choices_to, Q):\n+                formfield.queryset = formfield.queryset.distinct()\n \n     def related_query_name(self):\n         \"\"\"\ndiff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 2c2b5d0883..cb2205b032 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -965,22 +965,15 @@ class QuerySet:\n         else:\n             self._query.add_q(Q(*args, **kwargs))\n \n-    def complex_filter(self, filter_obj):\n-        \"\"\"\n-        Return a new QuerySet instance with filter_obj added to the filters.\n-\n-        filter_obj can be a Q object or a dictionary of keyword lookup\n-        arguments.\n \n-        This exists to support framework features such as 'limit_choices_to',\n-        and usually it will be more natural to use other methods.\n-        \"\"\"\n-        if isinstance(filter_obj, Q):\n-            clone = self._chain()\n-            clone.query.add_q(filter_obj)\n-            return clone\n-        else:\n-            return self._filter_or_exclude(False, args=(), kwargs=filter_obj)\n+def apply_limit_choices_to_to_formfield(formfield, limit_choices_to):\n+    \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n+    if limit_choices_to is not None and hasattr(formfield, 'queryset'):\n+        formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n+        # If limit_choices_to is a Q object, apply distinct() to prevent duplicates\n+        # that can occur when the Q object involves joins\n+        if isinstance(limit_choices_to, Q):\n+            formfield.queryset = formfield.queryset.distinct()\n \n     def _combinator_query(self, combinator, *other_qs, all=False):\n         # Clone the query to inherit the select list and everything\ndiff --git a/django/forms/models.py b/django/forms/models.py\nindex 5d115458a1..ea322ec474 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -5,9 +5,11 @@ and database field objects.\n import warnings\n from itertools import chain\n \n+\n from django.core.exceptions import (\n     NON_FIELD_ERRORS, FieldError, ImproperlyConfigured, ValidationError,\n )\n+from django.db.models import Q\n from django.forms.fields import ChoiceField, Field\n from django.forms.forms import BaseForm, DeclarativeFieldsMetaclass\n from django.forms.formsets import BaseFormSet, formset_factory\n@@ -95,12 +97,18 @@ def model_to_dict(instance, fields=None, exclude=None):\n     return data\n \n \n+\n def apply_limit_choices_to_to_formfield(formfield):\n     \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n     if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n         limit_choices_to = formfield.get_limit_choices_to()\n         if limit_choices_to is not None:\n             formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n+            # Apply distinct() when limit_choices_to is a Q object to prevent duplicates\n+            # that can occur when Q objects involve joins\n+            from django.db.models import Q\n+            if isinstance(limit_choices_to, Q):\n+                formfield.queryset = formfield.queryset.distinct()\n \n \n def fields_for_model(model, fields=None, exclude=None, widgets=None,\n",
    "variant_7": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 397146a354..685769915e 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -387,36 +387,26 @@ class RelatedField(FieldCacheMixin, Field):\n         self.set_attributes_from_rel()\n         self.contribute_to_related_class(other, self.remote_field)\n \n-    def get_limit_choices_to(self):\n-        \"\"\"\n-        Return ``limit_choices_to`` for this model field.\n-\n-        If it is a callable, it will be invoked and the result will be\n-        returned.\n-        \"\"\"\n-        if callable(self.remote_field.limit_choices_to):\n-            return self.remote_field.limit_choices_to()\n-        return self.remote_field.limit_choices_to\n \n-    def formfield(self, **kwargs):\n-        \"\"\"\n-        Pass ``limit_choices_to`` to the field being constructed.\n+def get_limit_choices_to(self):\n+    \"\"\"\n+    Return ``limit_choices_to`` for this model field.\n \n-        Only passes it if there is a type that supports related fields.\n-        This is a similar strategy used to pass the ``queryset`` to the field\n-        being constructed.\n-        \"\"\"\n-        defaults = {}\n-        if hasattr(self.remote_field, 'get_related_field'):\n-            # If this is a callable, do not invoke it here. Just pass\n-            # it in the defaults for when the form class will later be\n-            # instantiated.\n-            limit_choices_to = self.remote_field.limit_choices_to\n-            defaults.update({\n-                'limit_choices_to': limit_choices_to,\n-            })\n-        defaults.update(kwargs)\n-        return super().formfield(**defaults)\n+    If it is a callable, it will be invoked and the result will be\n+    returned.\n+    \"\"\"\n+    if callable(self.remote_field.limit_choices_to):\n+        return self.remote_field.limit_choices_to()\n+    return self.remote_field.limit_choices_to\n+\n+\n+def apply_limit_choices_to_to_formfield(formfield, limit_choices_to):\n+    \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n+    if hasattr(formfield, 'queryset') and hasattr(formfield.queryset, 'complex_filter'):\n+        formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n+        # Apply distinct() when using Q objects to prevent duplicates from joins\n+        if isinstance(limit_choices_to, Q):\n+            formfield.queryset = formfield.queryset.distinct()\n \n     def related_query_name(self):\n         \"\"\"\ndiff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 2c2b5d0883..580dd46243 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -965,22 +965,15 @@ class QuerySet:\n         else:\n             self._query.add_q(Q(*args, **kwargs))\n \n-    def complex_filter(self, filter_obj):\n-        \"\"\"\n-        Return a new QuerySet instance with filter_obj added to the filters.\n-\n-        filter_obj can be a Q object or a dictionary of keyword lookup\n-        arguments.\n \n-        This exists to support framework features such as 'limit_choices_to',\n-        and usually it will be more natural to use other methods.\n-        \"\"\"\n-        if isinstance(filter_obj, Q):\n-            clone = self._chain()\n-            clone.query.add_q(filter_obj)\n-            return clone\n-        else:\n-            return self._filter_or_exclude(False, args=(), kwargs=filter_obj)\n+def apply_limit_choices_to_to_formfield(formfield, limit_choices_to):\n+    \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n+    if limit_choices_to is not None:\n+        formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n+        # When limit_choices_to is a Q object that involves joins, complex_filter\n+        # can produce duplicate results. Apply distinct() to ensure unique options.\n+        if isinstance(limit_choices_to, Q):\n+            formfield.queryset = formfield.queryset.distinct()\n \n     def _combinator_query(self, combinator, *other_qs, all=False):\n         # Clone the query to inherit the select list and everything\ndiff --git a/django/forms/models.py b/django/forms/models.py\nindex 5d115458a1..ea322ec474 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -5,9 +5,11 @@ and database field objects.\n import warnings\n from itertools import chain\n \n+\n from django.core.exceptions import (\n     NON_FIELD_ERRORS, FieldError, ImproperlyConfigured, ValidationError,\n )\n+from django.db.models import Q\n from django.forms.fields import ChoiceField, Field\n from django.forms.forms import BaseForm, DeclarativeFieldsMetaclass\n from django.forms.formsets import BaseFormSet, formset_factory\n@@ -95,12 +97,18 @@ def model_to_dict(instance, fields=None, exclude=None):\n     return data\n \n \n+\n def apply_limit_choices_to_to_formfield(formfield):\n     \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n     if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n         limit_choices_to = formfield.get_limit_choices_to()\n         if limit_choices_to is not None:\n             formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n+            # Apply distinct() when limit_choices_to is a Q object to prevent duplicates\n+            # that can occur when Q objects involve joins\n+            from django.db.models import Q\n+            if isinstance(limit_choices_to, Q):\n+                formfield.queryset = formfield.queryset.distinct()\n \n \n def fields_for_model(model, fields=None, exclude=None, widgets=None,\n",
    "variant_8": "diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex 397146a354..28b47757aa 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -387,36 +387,27 @@ class RelatedField(FieldCacheMixin, Field):\n         self.set_attributes_from_rel()\n         self.contribute_to_related_class(other, self.remote_field)\n \n-    def get_limit_choices_to(self):\n-        \"\"\"\n-        Return ``limit_choices_to`` for this model field.\n-\n-        If it is a callable, it will be invoked and the result will be\n-        returned.\n-        \"\"\"\n-        if callable(self.remote_field.limit_choices_to):\n-            return self.remote_field.limit_choices_to()\n-        return self.remote_field.limit_choices_to\n \n-    def formfield(self, **kwargs):\n-        \"\"\"\n-        Pass ``limit_choices_to`` to the field being constructed.\n+def get_limit_choices_to(self):\n+    \"\"\"\n+    Return ``limit_choices_to`` for this model field.\n \n-        Only passes it if there is a type that supports related fields.\n-        This is a similar strategy used to pass the ``queryset`` to the field\n-        being constructed.\n-        \"\"\"\n-        defaults = {}\n-        if hasattr(self.remote_field, 'get_related_field'):\n-            # If this is a callable, do not invoke it here. Just pass\n-            # it in the defaults for when the form class will later be\n-            # instantiated.\n-            limit_choices_to = self.remote_field.limit_choices_to\n-            defaults.update({\n-                'limit_choices_to': limit_choices_to,\n-            })\n-        defaults.update(kwargs)\n-        return super().formfield(**defaults)\n+    If it is a callable, it will be invoked and the result will be\n+    returned.\n+    \"\"\"\n+    if callable(self.remote_field.limit_choices_to):\n+        return self.remote_field.limit_choices_to()\n+    return self.remote_field.limit_choices_to\n+\n+\n+def apply_limit_choices_to_to_formfield(formfield, limit_choices_to):\n+    \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n+    if hasattr(formfield, 'queryset') and hasattr(formfield.queryset, 'complex_filter'):\n+        formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n+        # Apply distinct() when limit_choices_to is a Q object to prevent duplicates\n+        # that can occur when Q objects involve joins\n+        if isinstance(limit_choices_to, Q):\n+            formfield.queryset = formfield.queryset.distinct()\n \n     def related_query_name(self):\n         \"\"\"\ndiff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 2c2b5d0883..cdcaccd800 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -965,6 +965,7 @@ class QuerySet:\n         else:\n             self._query.add_q(Q(*args, **kwargs))\n \n+\n     def complex_filter(self, filter_obj):\n         \"\"\"\n         Return a new QuerySet instance with filter_obj added to the filters.\ndiff --git a/django/forms/models.py b/django/forms/models.py\nindex 5d115458a1..f7987d0b7e 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -5,9 +5,11 @@ and database field objects.\n import warnings\n from itertools import chain\n \n+\n from django.core.exceptions import (\n     NON_FIELD_ERRORS, FieldError, ImproperlyConfigured, ValidationError,\n )\n+from django.db.models import Q\n from django.forms.fields import ChoiceField, Field\n from django.forms.forms import BaseForm, DeclarativeFieldsMetaclass\n from django.forms.formsets import BaseFormSet, formset_factory\n@@ -95,12 +97,18 @@ def model_to_dict(instance, fields=None, exclude=None):\n     return data\n \n \n+\n def apply_limit_choices_to_to_formfield(formfield):\n     \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n     if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n         limit_choices_to = formfield.get_limit_choices_to()\n         if limit_choices_to is not None:\n             formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n+            # Apply distinct() when limit_choices_to is a Q object to prevent duplicates\n+            # that can occur when the Q object involves joins\n+            from django.db.models import Q\n+            if isinstance(limit_choices_to, Q):\n+                formfield.queryset = formfield.queryset.distinct()\n \n \n def fields_for_model(model, fields=None, exclude=None, widgets=None,\n"
  }
}