{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/astropy/astropy/wcs/wcs.py lines 1214-1231)": "\n    def _array_converter(self, func, sky, *args, ra_dec_order=False):\n        \"\"\"\n        A helper function to support reading either a pair of arrays\n        or a single Nx2 array.\n        \"\"\"\n\n        def _return_list_of_arrays(axes, origin):\n            try:\n                axes = np.broadcast_arrays(*axes)\n            except ValueError:\n                raise ValueError(\n                    \"Coordinate arrays are not broadcastable to each other\")\n\n            # Handle empty arrays early to avoid issues with C library\n            if any(x.size == 0 for x in axes):\n                if ra_dec_order and sky == 'output':\n                    return (np.empty(axes[0].shape, dtype=float),\n                            np.empty(axes[0].shape, dtype=float))\n                return [np.empty(axes[0].shape, dtype=float)\n                        for i in range(self.naxis)]\n\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            if ra_dec_order and sky == 'input':\n                xy = self._denormalize_sky(xy)\n            output = func(xy, origin)\n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/astropy/astropy/wcs/wcs.py lines 1214-1231)": [
      "\n    def _array_converter(self, func, sky, *args, ra_dec_order=False):\n        \"\"\"\n        A helper function to support reading either a pair of arrays\n        or a single Nx2 array.\n        \"\"\"\n\n        def _return_list_of_arrays(axes, origin):\n            try:\n                axes = np.broadcast_arrays(*axes)\n            except ValueError:\n                raise ValueError(\n                    \"Coordinate arrays are not broadcastable to each other\")\n\n            # Handle empty arrays early to avoid issues with C library\n            if axes[0].size == 0:\n                # Return empty arrays with correct shape and structure\n                if ra_dec_order and sky == 'output':\n                    return (np.array([]).reshape(axes[0].shape),\n                            np.array([]).reshape(axes[0].shape))\n                return [np.array([]).reshape(axes[0].shape)\n                        for i in range(self.naxis)]\n\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            if ra_dec_order and sky == 'input':\n                xy = self._denormalize_sky(xy)\n            output = func(xy, origin)\n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n    def _array_converter(self, func, sky, *args, ra_dec_order=False):\n        \"\"\"\n        A helper function to support reading either a pair of arrays\n        or a single Nx2 array.\n        \"\"\"\n\n        def _return_list_of_arrays(axes, origin):\n            try:\n                axes = np.broadcast_arrays(*axes)\n            except ValueError:\n                raise ValueError(\n                    \"Coordinate arrays are not broadcastable to each other\")\n\n            # Handle empty arrays\n            if any(x.size == 0 for x in axes):\n                # Return empty arrays with correct shape and structure\n                if ra_dec_order and sky == 'output':\n                    return (np.empty(axes[0].shape, dtype=float),\n                            np.empty(axes[0].shape, dtype=float))\n                else:\n                    return [np.empty(axes[0].shape, dtype=float)\n                            for i in range(self.naxis)]\n\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            if ra_dec_order and sky == 'input':\n                xy = self._denormalize_sky(xy)\n            output = func(xy, origin)\n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n    def _array_converter(self, func, sky, *args, ra_dec_order=False):\n        \"\"\"\n        A helper function to support reading either a pair of arrays\n        or a single Nx2 array.\n        \"\"\"\n\n        def _return_list_of_arrays(axes, origin):\n            try:\n                axes = np.broadcast_arrays(*axes)\n            except ValueError:\n                raise ValueError(\n                    \"Coordinate arrays are not broadcastable to each other\")\n\n            # Handle empty arrays\n            if any(x.size == 0 for x in axes):\n                if ra_dec_order and sky == 'output':\n                    return (np.array([]).reshape(axes[0].shape),\n                            np.array([]).reshape(axes[0].shape))\n                return [np.array([]).reshape(axes[0].shape)\n                        for i in range(self.naxis)]\n\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            if ra_dec_order and sky == 'input':\n                xy = self._denormalize_sky(xy)\n            output = func(xy, origin)\n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n    def _array_converter(self, func, sky, *args, ra_dec_order=False):\n        \"\"\"\n        A helper function to support reading either a pair of arrays\n        or a single Nx2 array.\n        \"\"\"\n\n        def _return_list_of_arrays(axes, origin):\n            try:\n                axes = np.broadcast_arrays(*axes)\n            except ValueError:\n                raise ValueError(\n                    \"Coordinate arrays are not broadcastable to each other\")\n\n            # Handle empty arrays early to avoid issues with C library\n            if axes[0].size == 0:\n                if ra_dec_order and sky == 'output':\n                    return (np.array([]).reshape(axes[0].shape),\n                            np.array([]).reshape(axes[0].shape))\n                return [np.array([]).reshape(axes[0].shape) \n                        for i in range(self.naxis)]\n\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            if ra_dec_order and sky == 'input':\n                xy = self._denormalize_sky(xy)\n            output = func(xy, origin)\n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n    def _array_converter(self, func, sky, *args, ra_dec_order=False):\n        \"\"\"\n        A helper function to support reading either a pair of arrays\n        or a single Nx2 array.\n        \"\"\"\n\n        def _return_list_of_arrays(axes, origin):\n            try:\n                axes = np.broadcast_arrays(*axes)\n            except ValueError:\n                raise ValueError(\n                    \"Coordinate arrays are not broadcastable to each other\")\n\n            # Handle empty arrays early to avoid issues with C library\n            if any(x.size == 0 for x in axes):\n                empty_shape = axes[0].shape\n                if ra_dec_order and sky == 'output':\n                    return (np.empty(empty_shape, dtype=float),\n                            np.empty(empty_shape, dtype=float))\n                return [np.empty(empty_shape, dtype=float)\n                        for i in range(self.naxis)]\n\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            if ra_dec_order and sky == 'input':\n                xy = self._denormalize_sky(xy)\n            output = func(xy, origin)\n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n    def _array_converter(self, func, sky, *args, ra_dec_order=False):\n        \"\"\"\n        A helper function to support reading either a pair of arrays\n        or a single Nx2 array.\n        \"\"\"\n\n        def _return_list_of_arrays(axes, origin):\n            try:\n                axes = np.broadcast_arrays(*axes)\n            except ValueError:\n                raise ValueError(\n                    \"Coordinate arrays are not broadcastable to each other\")\n\n            # Handle empty arrays\n            if axes[0].size == 0:\n                # Return empty arrays with correct shape and structure\n                empty_shape = axes[0].shape\n                if ra_dec_order and sky == 'output':\n                    return (np.array([]).reshape(empty_shape),\n                            np.array([]).reshape(empty_shape))\n                else:\n                    return [np.array([]).reshape(empty_shape)\n                            for i in range(self.naxis)]\n\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            if ra_dec_order and sky == 'input':\n                xy = self._denormalize_sky(xy)\n            output = func(xy, origin)\n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n    def _array_converter(self, func, sky, *args, ra_dec_order=False):\n        \"\"\"\n        A helper function to support reading either a pair of arrays\n        or a single Nx2 array.\n        \"\"\"\n\n        def _return_list_of_arrays(axes, origin):\n            try:\n                axes = np.broadcast_arrays(*axes)\n            except ValueError:\n                raise ValueError(\n                    \"Coordinate arrays are not broadcastable to each other\")\n\n            # Handle empty arrays early to avoid issues with C library\n            if any(x.size == 0 for x in axes):\n                # Create empty output arrays with correct shape\n                if ra_dec_order and sky == 'output':\n                    return (np.empty(axes[0].shape, dtype=float),\n                            np.empty(axes[0].shape, dtype=float))\n                else:\n                    return [np.empty(axes[0].shape, dtype=float)\n                            for i in range(self.naxis)]\n\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            if ra_dec_order and sky == 'input':\n                xy = self._denormalize_sky(xy)\n            output = func(xy, origin)\n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n    def _array_converter(self, func, sky, *args, ra_dec_order=False):\n        \"\"\"\n        A helper function to support reading either a pair of arrays\n        or a single Nx2 array.\n        \"\"\"\n\n        def _return_list_of_arrays(axes, origin):\n            try:\n                axes = np.broadcast_arrays(*axes)\n            except ValueError:\n                raise ValueError(\n                    \"Coordinate arrays are not broadcastable to each other\")\n\n            # Check if any of the input arrays are empty\n            if any(x.size == 0 for x in axes):\n                # Return appropriately shaped empty arrays\n                if ra_dec_order and sky == 'output':\n                    return (np.array([]).reshape(axes[0].shape),\n                            np.array([]).reshape(axes[0].shape))\n                return [np.array([]).reshape(axes[0].shape)\n                        for i in range(self.naxis)]\n\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            if ra_dec_order and sky == 'input':\n                xy = self._denormalize_sky(xy)\n            output = func(xy, origin)\n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..22122da4a0 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1211,6 +1211,7 @@ reduce these to 2 dimensions using the naxis kwarg.\n         or a single Nx2 array.\n         \"\"\"\n \n+\n         def _return_list_of_arrays(axes, origin):\n             try:\n                 axes = np.broadcast_arrays(*axes)\n@@ -1218,6 +1219,15 @@ reduce these to 2 dimensions using the naxis kwarg.\n                 raise ValueError(\n                     \"Coordinate arrays are not broadcastable to each other\")\n \n+            # Handle empty arrays - return empty arrays with correct shape\n+            # without calling the underlying C library\n+            if axes[0].size == 0:\n+                if ra_dec_order and sky == 'output':\n+                    return (np.array([]).reshape(axes[0].shape),\n+                            np.array([]).reshape(axes[0].shape))\n+                return [np.array([]).reshape(axes[0].shape)\n+                        for i in range(len(axes))]\n+\n             xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n             if ra_dec_order and sky == 'input':\n",
    "variant_0": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..b545908127 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1205,6 +1205,13 @@ reduce these to 2 dimensions using the naxis kwarg.\n             out[:, 1] = sky[:, self.wcs.lat]\n             return out\n \n+    def _array_converter(self, func, sky, *args, ra_dec_order=False):\n+        \"\"\"\n+        A helper function to support reading either a pair of arrays\n+        or a single Nx2 array.\n+        \"\"\"\n+\n+\n     def _array_converter(self, func, sky, *args, ra_dec_order=False):\n         \"\"\"\n         A helper function to support reading either a pair of arrays\n@@ -1218,6 +1225,14 @@ reduce these to 2 dimensions using the naxis kwarg.\n                 raise ValueError(\n                     \"Coordinate arrays are not broadcastable to each other\")\n \n+            # Handle empty arrays early to avoid issues with C library\n+            if any(x.size == 0 for x in axes):\n+                if ra_dec_order and sky == 'output':\n+                    return (np.empty(axes[0].shape, dtype=float),\n+                            np.empty(axes[0].shape, dtype=float))\n+                return [np.empty(axes[0].shape, dtype=float)\n+                        for i in range(self.naxis)]\n+\n             xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n             if ra_dec_order and sky == 'input':\n",
    "variant_1": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..d32088b45f 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1205,6 +1205,13 @@ reduce these to 2 dimensions using the naxis kwarg.\n             out[:, 1] = sky[:, self.wcs.lat]\n             return out\n \n+    def _array_converter(self, func, sky, *args, ra_dec_order=False):\n+        \"\"\"\n+        A helper function to support reading either a pair of arrays\n+        or a single Nx2 array.\n+        \"\"\"\n+\n+\n     def _array_converter(self, func, sky, *args, ra_dec_order=False):\n         \"\"\"\n         A helper function to support reading either a pair of arrays\n@@ -1218,6 +1225,15 @@ reduce these to 2 dimensions using the naxis kwarg.\n                 raise ValueError(\n                     \"Coordinate arrays are not broadcastable to each other\")\n \n+            # Handle empty arrays early to avoid issues with C library\n+            if axes[0].size == 0:\n+                # Return empty arrays with correct shape and structure\n+                if ra_dec_order and sky == 'output':\n+                    return (np.array([]).reshape(axes[0].shape),\n+                            np.array([]).reshape(axes[0].shape))\n+                return [np.array([]).reshape(axes[0].shape)\n+                        for i in range(self.naxis)]\n+\n             xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n             if ra_dec_order and sky == 'input':\n",
    "variant_2": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..84b5ba95ca 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1205,6 +1205,13 @@ reduce these to 2 dimensions using the naxis kwarg.\n             out[:, 1] = sky[:, self.wcs.lat]\n             return out\n \n+    def _array_converter(self, func, sky, *args, ra_dec_order=False):\n+        \"\"\"\n+        A helper function to support reading either a pair of arrays\n+        or a single Nx2 array.\n+        \"\"\"\n+\n+\n     def _array_converter(self, func, sky, *args, ra_dec_order=False):\n         \"\"\"\n         A helper function to support reading either a pair of arrays\n@@ -1218,6 +1225,16 @@ reduce these to 2 dimensions using the naxis kwarg.\n                 raise ValueError(\n                     \"Coordinate arrays are not broadcastable to each other\")\n \n+            # Handle empty arrays\n+            if any(x.size == 0 for x in axes):\n+                # Return empty arrays with correct shape and structure\n+                if ra_dec_order and sky == 'output':\n+                    return (np.empty(axes[0].shape, dtype=float),\n+                            np.empty(axes[0].shape, dtype=float))\n+                else:\n+                    return [np.empty(axes[0].shape, dtype=float)\n+                            for i in range(self.naxis)]\n+\n             xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n             if ra_dec_order and sky == 'input':\n",
    "variant_3": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..61c4d53bd2 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1205,6 +1205,13 @@ reduce these to 2 dimensions using the naxis kwarg.\n             out[:, 1] = sky[:, self.wcs.lat]\n             return out\n \n+    def _array_converter(self, func, sky, *args, ra_dec_order=False):\n+        \"\"\"\n+        A helper function to support reading either a pair of arrays\n+        or a single Nx2 array.\n+        \"\"\"\n+\n+\n     def _array_converter(self, func, sky, *args, ra_dec_order=False):\n         \"\"\"\n         A helper function to support reading either a pair of arrays\n@@ -1218,6 +1225,14 @@ reduce these to 2 dimensions using the naxis kwarg.\n                 raise ValueError(\n                     \"Coordinate arrays are not broadcastable to each other\")\n \n+            # Handle empty arrays\n+            if any(x.size == 0 for x in axes):\n+                if ra_dec_order and sky == 'output':\n+                    return (np.array([]).reshape(axes[0].shape),\n+                            np.array([]).reshape(axes[0].shape))\n+                return [np.array([]).reshape(axes[0].shape)\n+                        for i in range(self.naxis)]\n+\n             xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n             if ra_dec_order and sky == 'input':\n",
    "variant_4": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..f9d4b9bc20 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1205,6 +1205,13 @@ reduce these to 2 dimensions using the naxis kwarg.\n             out[:, 1] = sky[:, self.wcs.lat]\n             return out\n \n+    def _array_converter(self, func, sky, *args, ra_dec_order=False):\n+        \"\"\"\n+        A helper function to support reading either a pair of arrays\n+        or a single Nx2 array.\n+        \"\"\"\n+\n+\n     def _array_converter(self, func, sky, *args, ra_dec_order=False):\n         \"\"\"\n         A helper function to support reading either a pair of arrays\n@@ -1218,6 +1225,14 @@ reduce these to 2 dimensions using the naxis kwarg.\n                 raise ValueError(\n                     \"Coordinate arrays are not broadcastable to each other\")\n \n+            # Handle empty arrays early to avoid issues with C library\n+            if axes[0].size == 0:\n+                if ra_dec_order and sky == 'output':\n+                    return (np.array([]).reshape(axes[0].shape),\n+                            np.array([]).reshape(axes[0].shape))\n+                return [np.array([]).reshape(axes[0].shape) \n+                        for i in range(self.naxis)]\n+\n             xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n             if ra_dec_order and sky == 'input':\n",
    "variant_5": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..4b9c6bf02e 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1205,6 +1205,13 @@ reduce these to 2 dimensions using the naxis kwarg.\n             out[:, 1] = sky[:, self.wcs.lat]\n             return out\n \n+    def _array_converter(self, func, sky, *args, ra_dec_order=False):\n+        \"\"\"\n+        A helper function to support reading either a pair of arrays\n+        or a single Nx2 array.\n+        \"\"\"\n+\n+\n     def _array_converter(self, func, sky, *args, ra_dec_order=False):\n         \"\"\"\n         A helper function to support reading either a pair of arrays\n@@ -1218,6 +1225,15 @@ reduce these to 2 dimensions using the naxis kwarg.\n                 raise ValueError(\n                     \"Coordinate arrays are not broadcastable to each other\")\n \n+            # Handle empty arrays early to avoid issues with C library\n+            if any(x.size == 0 for x in axes):\n+                empty_shape = axes[0].shape\n+                if ra_dec_order and sky == 'output':\n+                    return (np.empty(empty_shape, dtype=float),\n+                            np.empty(empty_shape, dtype=float))\n+                return [np.empty(empty_shape, dtype=float)\n+                        for i in range(self.naxis)]\n+\n             xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n             if ra_dec_order and sky == 'input':\n",
    "variant_6": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..da2eccee33 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1205,6 +1205,13 @@ reduce these to 2 dimensions using the naxis kwarg.\n             out[:, 1] = sky[:, self.wcs.lat]\n             return out\n \n+    def _array_converter(self, func, sky, *args, ra_dec_order=False):\n+        \"\"\"\n+        A helper function to support reading either a pair of arrays\n+        or a single Nx2 array.\n+        \"\"\"\n+\n+\n     def _array_converter(self, func, sky, *args, ra_dec_order=False):\n         \"\"\"\n         A helper function to support reading either a pair of arrays\n@@ -1218,6 +1225,17 @@ reduce these to 2 dimensions using the naxis kwarg.\n                 raise ValueError(\n                     \"Coordinate arrays are not broadcastable to each other\")\n \n+            # Handle empty arrays\n+            if axes[0].size == 0:\n+                # Return empty arrays with correct shape and structure\n+                empty_shape = axes[0].shape\n+                if ra_dec_order and sky == 'output':\n+                    return (np.array([]).reshape(empty_shape),\n+                            np.array([]).reshape(empty_shape))\n+                else:\n+                    return [np.array([]).reshape(empty_shape)\n+                            for i in range(self.naxis)]\n+\n             xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n             if ra_dec_order and sky == 'input':\n",
    "variant_7": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..658dfe36c9 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1205,6 +1205,13 @@ reduce these to 2 dimensions using the naxis kwarg.\n             out[:, 1] = sky[:, self.wcs.lat]\n             return out\n \n+    def _array_converter(self, func, sky, *args, ra_dec_order=False):\n+        \"\"\"\n+        A helper function to support reading either a pair of arrays\n+        or a single Nx2 array.\n+        \"\"\"\n+\n+\n     def _array_converter(self, func, sky, *args, ra_dec_order=False):\n         \"\"\"\n         A helper function to support reading either a pair of arrays\n@@ -1218,6 +1225,16 @@ reduce these to 2 dimensions using the naxis kwarg.\n                 raise ValueError(\n                     \"Coordinate arrays are not broadcastable to each other\")\n \n+            # Handle empty arrays early to avoid issues with C library\n+            if any(x.size == 0 for x in axes):\n+                # Create empty output arrays with correct shape\n+                if ra_dec_order and sky == 'output':\n+                    return (np.empty(axes[0].shape, dtype=float),\n+                            np.empty(axes[0].shape, dtype=float))\n+                else:\n+                    return [np.empty(axes[0].shape, dtype=float)\n+                            for i in range(self.naxis)]\n+\n             xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n             if ra_dec_order and sky == 'input':\n",
    "variant_8": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..7866ae09fc 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1205,6 +1205,13 @@ reduce these to 2 dimensions using the naxis kwarg.\n             out[:, 1] = sky[:, self.wcs.lat]\n             return out\n \n+    def _array_converter(self, func, sky, *args, ra_dec_order=False):\n+        \"\"\"\n+        A helper function to support reading either a pair of arrays\n+        or a single Nx2 array.\n+        \"\"\"\n+\n+\n     def _array_converter(self, func, sky, *args, ra_dec_order=False):\n         \"\"\"\n         A helper function to support reading either a pair of arrays\n@@ -1218,6 +1225,15 @@ reduce these to 2 dimensions using the naxis kwarg.\n                 raise ValueError(\n                     \"Coordinate arrays are not broadcastable to each other\")\n \n+            # Check if any of the input arrays are empty\n+            if any(x.size == 0 for x in axes):\n+                # Return appropriately shaped empty arrays\n+                if ra_dec_order and sky == 'output':\n+                    return (np.array([]).reshape(axes[0].shape),\n+                            np.array([]).reshape(axes[0].shape))\n+                return [np.array([]).reshape(axes[0].shape)\n+                        for i in range(self.naxis)]\n+\n             xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n             if ra_dec_order and sky == 'input':\n"
  }
}