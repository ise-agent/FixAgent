{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/pytest/src/_pytest/python.py lines 610-614)": "\n            raise self.CollectError(\n                \"Using pytest.skip outside of a test is not allowed. \"\n                \"To decorate a test function, use the @pytest.mark.skip \"\n                \"or @pytest.mark.skipif decorators instead. To skip a \"\n                \"module, use `pytestmark = pytest.mark.{skip,skipif}` or \"\n                \"call `skip(msg='reason', allow_module_level=True)` for \"\n                \"modules with syntax incompatible with older Python versions.\"\n            ) from e\n",
    "Location 2 (/root/hy/projects_3/pytest/src/_pytest/outcomes.py lines 124-144)": "\n@_with_exception(Skipped)\ndef skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n    \"\"\"Skip an executing test with the given message.\n\n    This function should be called only during testing (setup, call or teardown) or\n    during collection by using the ``allow_module_level`` flag.  This function can\n    be called in doctests as well.\n\n    :param bool allow_module_level:\n        Allows this function to be called at module level, skipping the rest\n        of the module. Defaults to False.\n\n    .. note::\n        It is better to use the :ref:`pytest.mark.skipif ref` marker when\n        possible to declare a test to be skipped under certain conditions\n        like mismatching platforms or dependencies.\n        Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n        <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n        to skip a doctest statically.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Skipped(msg=msg, allow_module_level=allow_module_level)\n\n\ndef skip_module(msg: str = \"\") -> \"NoReturn\":\n    \"\"\"Skip the entire module with the given message.\n    \n    This is a convenience function equivalent to skip(msg, allow_module_level=True).\n    Use this when you need to skip a module due to syntax compatibility or\n    missing dependencies that would prevent the module from being processed.\n    \"\"\"\n    __tracebackhide__ = True\n    skip(msg=msg, allow_module_level=True)\n",
    "Location 3 (/root/hy/projects_3/pytest/src/_pytest/outcomes.py lines 1-30)": "\n\"\"\"Exception classes and constants handling test outcomes as well as\nfunctions creating them.\"\"\"\nimport sys\nfrom typing import Any\nfrom typing import Callable\nfrom typing import cast\nfrom typing import Optional\nfrom typing import Type\nfrom typing import TypeVar\nfrom typing import NoReturn\nfrom typing_extensions import Protocol\nfrom typing import Generic\nimport warnings\nfrom packaging.version import Version\n\nTYPE_CHECKING = False  # Avoid circular import through compat.\n\nif TYPE_CHECKING:\n    pass\nelse:\n    # typing.Protocol is only available starting from Python 3.8. It is also\n    # available from typing_extensions, but we don't want a runtime dependency\n    # on that. So use a dummy runtime implementation.\n    Protocol = Generic\n\n\nclass OutcomeException(BaseException):\n    \"\"\"OutcomeException and its subclass instances indicate and contain info\n    about test and collection outcomes.\"\"\"\n\n    def __init__(self, msg: Optional[str] = None, pytrace: bool = True) -> None:\n        if msg is not None and not isinstance(msg, str):\n",
    "Location 4 (/root/hy/projects_3/pytest/src/_pytest/skipping.py lines 1-50)": "\n\"\"\"Support for skip/xfail functions and markers.\"\"\"\nimport os\nimport platform\nimport sys\nimport traceback\nfrom collections.abc import Mapping\nfrom typing import Generator\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Type\n\nimport attr\n\nfrom _pytest.config import Config\nfrom _pytest.config import hookimpl\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.mark.structures import Mark\nfrom _pytest.nodes import Item\nfrom _pytest.outcomes import fail\nfrom _pytest.outcomes import skip\nfrom _pytest.outcomes import xfail\nfrom _pytest.reports import BaseReport\nfrom _pytest.runner import CallInfo\nfrom _pytest.store import StoreKey\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"general\")\n    group.addoption(\n        \"--runxfail\",\n        action=\"store_true\",\n        dest=\"runxfail\",\n        default=False,\n        help=\"report the results of xfail tests as if they were not marked\",\n    )\n\n    parser.addini(\n        \"xfail_strict\",\n        \"default for the strict parameter of xfail \"\n        \"markers when not given explicitly (default: False)\",\n        default=False,\n        type=\"bool\",\n    )\n\n\ndef pytest_configure(config: Config) -> None:\n    if config.option.runxfail:\n        # yay a hack\n        import pytest\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/pytest/src/_pytest/python.py lines 610-614)": [
      "\n            raise self.CollectError(\n                \"Using pytest.skip outside of a test is not allowed. \"\n                \"To decorate a test function, use the @pytest.mark.skip \"\n                \"or @pytest.mark.skipif decorators instead. To skip a \"\n                \"module, use `pytestmark = pytest.mark.{skip,skipif}` or \"\n                \"call `skip(msg='reason', allow_module_level=True)` for \"\n                \"modules with syntax incompatible with older Python versions.\"\n            ) from e\n",
      "\n            raise self.CollectError(\n                \"Using pytest.skip outside of a test is not allowed. \"\n                \"To decorate a test function, use the @pytest.mark.skip \"\n                \"or @pytest.mark.skipif decorators instead. To skip a \"\n                \"module, use `pytestmark = pytest.mark.{skip,skipif}` or \"\n                \"call `skip(msg='reason', allow_module_level=True)` for \"\n                \"modules with syntax incompatible with older Python versions.\"\n            ) from e\n",
      "\n            raise self.CollectError(\n                \"Using pytest.skip outside of a test is not allowed. \"\n                \"To decorate a test function, use the @pytest.mark.skip \"\n                \"or @pytest.mark.skipif decorators instead. To skip a \"\n                \"module, use `pytestmark = pytest.mark.{skip,skipif}` or \"\n                \"call `skip(msg='reason', allow_module_level=True)` for \"\n                \"modules with syntax incompatible with older Python versions.\"\n            ) from e\n",
      "\n            raise self.CollectError(\n                \"Using pytest.skip outside of a test is not allowed. \"\n                \"To decorate a test function, use the @pytest.mark.skip \"\n                \"or @pytest.mark.skipif decorators instead. To skip a \"\n                \"module, use `pytestmark = pytest.mark.{skip,skipif}` or \"\n                \"call `skip(msg='reason', allow_module_level=True)` for \"\n                \"modules with syntax incompatible with older Python versions.\"\n            ) from e\n",
      "\n            raise self.CollectError(\n                \"Using pytest.skip outside of a test is not allowed. \"\n                \"To decorate a test function, use the @pytest.mark.skip \"\n                \"or @pytest.mark.skipif decorators instead. To skip a \"\n                \"module, use `pytestmark = pytest.mark.{skip,skipif}` or \"\n                \"call `skip(msg='reason', allow_module_level=True)` for \"\n                \"modules with syntax incompatible with older Python versions.\"\n            ) from e\n",
      "\n            raise self.CollectError(\n                \"Using pytest.skip outside of a test is not allowed. \"\n                \"To decorate a test function, use the @pytest.mark.skip \"\n                \"or @pytest.mark.skipif decorators instead. To skip a \"\n                \"module, use `pytestmark = pytest.mark.{skip,skipif}` or \"\n                \"call `skip(msg='reason', allow_module_level=True)` for \"\n                \"modules with syntax incompatible with older Python versions.\"\n            ) from e\n",
      "\n            raise self.CollectError(\n                \"Using pytest.skip outside of a test is not allowed. \"\n                \"To decorate a test function, use the @pytest.mark.skip \"\n                \"or @pytest.mark.skipif decorators instead. To skip a \"\n                \"module, use `pytestmark = pytest.mark.{skip,skipif}` or \"\n                \"call `skip(msg='reason', allow_module_level=True)` for \"\n                \"modules with syntax incompatible with older Python versions.\"\n            ) from e\n",
      "\n            raise self.CollectError(\n                \"Using pytest.skip outside of a test is not allowed. \"\n                \"To decorate a test function, use the @pytest.mark.skip \"\n                \"or @pytest.mark.skipif decorators instead. To skip a \"\n                \"module, use `pytestmark = pytest.mark.{skip,skipif}` or \"\n                \"call `skip(msg='reason', allow_module_level=True)` for \"\n                \"modules with syntax incompatible with older Python versions.\"\n            ) from e\n"
    ],
    "Location 2 (/root/hy/projects_3/pytest/src/_pytest/outcomes.py lines 124-144)": [
      "\n@_with_exception(Skipped)\ndef skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n    \"\"\"Skip an executing test with the given message.\n\n    This function should be called only during testing (setup, call or teardown) or\n    during collection by using the ``allow_module_level`` flag.  This function can\n    be called in doctests as well.\n\n    :param bool allow_module_level:\n        Allows this function to be called at module level, skipping the rest\n        of the module. Defaults to False.\n\n    .. note::\n        It is better to use the :ref:`pytest.mark.skipif ref` marker when\n        possible to declare a test to be skipped under certain conditions\n        like mismatching platforms or dependencies.\n        Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n        <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n        to skip a doctest statically.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Skipped(msg=msg, allow_module_level=allow_module_level)\n\n\ndef skip_module(msg: str = \"\") -> \"NoReturn\":\n    \"\"\"Skip the entire module with the given message.\n    \n    This is a convenience function equivalent to skip(msg, allow_module_level=True).\n    Use this when you need to skip a module due to syntax compatibility or\n    missing dependencies that would prevent the module from being processed.\n    \"\"\"\n    __tracebackhide__ = True\n    skip(msg=msg, allow_module_level=True)\n",
      "\n@_with_exception(Skipped)\ndef skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n    \"\"\"Skip an executing test with the given message.\n\n    This function should be called only during testing (setup, call or teardown) or\n    during collection by using the ``allow_module_level`` flag.  This function can\n    be called in doctests as well.\n\n    :param bool allow_module_level:\n        Allows this function to be called at module level, skipping the rest\n        of the module. Defaults to False.\n\n    .. note::\n        It is better to use the :ref:`pytest.mark.skipif ref` marker when\n        possible to declare a test to be skipped under certain conditions\n        like mismatching platforms or dependencies.\n        Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n        <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n        to skip a doctest statically.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Skipped(msg=msg, allow_module_level=allow_module_level)\n\n\ndef skip_module(msg: str = \"\") -> \"NoReturn\":\n    \"\"\"Skip the entire module with the given message.\n    \n    This is a convenience function equivalent to skip(msg, allow_module_level=True).\n    Use this when you need to skip a module due to syntax compatibility or\n    missing dependencies that would prevent the module from being processed.\n    \"\"\"\n    __tracebackhide__ = True\n    skip(msg=msg, allow_module_level=True)\n",
      "\n@_with_exception(Skipped)\ndef skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n    \"\"\"Skip an executing test with the given message.\n\n    This function should be called only during testing (setup, call or teardown) or\n    during collection by using the ``allow_module_level`` flag.  This function can\n    be called in doctests as well.\n\n    :param bool allow_module_level:\n        Allows this function to be called at module level, skipping the rest\n        of the module. Defaults to False.\n\n    .. note::\n        It is better to use the :ref:`pytest.mark.skipif ref` marker when\n        possible to declare a test to be skipped under certain conditions\n        like mismatching platforms or dependencies.\n        Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n        <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n        to skip a doctest statically.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Skipped(msg=msg, allow_module_level=allow_module_level)\n\n\n@_with_exception(Skipped)\ndef skip_module(msg: str = \"\") -> \"NoReturn\":\n    \"\"\"Skip the entire module with the given message.\n    \n    This is a convenience function equivalent to skip(msg, allow_module_level=True).\n    Use this when you need to skip a module due to syntax compatibility or\n    missing dependencies that would prevent the module from being processed.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Skipped(msg=msg, allow_module_level=True)\n",
      "\n@_with_exception(Skipped)\ndef skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n    \"\"\"Skip an executing test with the given message.\n\n    This function should be called only during testing (setup, call or teardown) or\n    during collection by using the ``allow_module_level`` flag.  This function can\n    be called in doctests as well.\n\n    :param bool allow_module_level:\n        Allows this function to be called at module level, skipping the rest\n        of the module. Defaults to False.\n\n    .. note::\n        It is better to use the :ref:`pytest.mark.skipif ref` marker when\n        possible to declare a test to be skipped under certain conditions\n        like mismatching platforms or dependencies.\n        Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n        <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n        to skip a doctest statically.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Skipped(msg=msg, allow_module_level=allow_module_level)\n\n\n@_with_exception(Skipped)\ndef skip_module(msg: str = \"\") -> \"NoReturn\":\n    \"\"\"Skip the entire module with the given message.\n    \n    This is a convenience function equivalent to skip(msg, allow_module_level=True).\n    Use this when you need to skip a module due to syntax compatibility or\n    missing dependencies that would prevent the module from being processed.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Skipped(msg=msg, allow_module_level=True)\n",
      "\n@_with_exception(Skipped)\ndef skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n    \"\"\"Skip an executing test with the given message.\n\n    This function should be called only during testing (setup, call or teardown) or\n    during collection by using the ``allow_module_level`` flag.  This function can\n    be called in doctests as well.\n\n    :param bool allow_module_level:\n        Allows this function to be called at module level, skipping the rest\n        of the module. Defaults to False.\n\n    .. note::\n        It is better to use the :ref:`pytest.mark.skipif ref` marker when\n        possible to declare a test to be skipped under certain conditions\n        like mismatching platforms or dependencies.\n        Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n        <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n        to skip a doctest statically.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Skipped(msg=msg, allow_module_level=allow_module_level)\n\n\ndef skip_module(msg: str = \"\") -> \"NoReturn\":\n    \"\"\"Skip the entire module with the given message.\n    \n    This is a convenience function equivalent to skip(msg, allow_module_level=True).\n    Use this when you need to skip a module due to syntax compatibility or\n    missing dependencies that would prevent the module from being processed.\n    \"\"\"\n    __tracebackhide__ = True\n    skip(msg=msg, allow_module_level=True)\n",
      "\n@_with_exception(Skipped)\ndef skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n    \"\"\"Skip an executing test with the given message.\n\n    This function should be called only during testing (setup, call or teardown) or\n    during collection by using the ``allow_module_level`` flag.  This function can\n    be called in doctests as well.\n\n    :param bool allow_module_level:\n        Allows this function to be called at module level, skipping the rest\n        of the module. Defaults to False.\n\n    .. note::\n        It is better to use the :ref:`pytest.mark.skipif ref` marker when\n        possible to declare a test to be skipped under certain conditions\n        like mismatching platforms or dependencies.\n        Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n        <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n        to skip a doctest statically.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Skipped(msg=msg, allow_module_level=allow_module_level)\n\n\n@_with_exception(Skipped)\ndef skip_module(msg: str = \"\") -> \"NoReturn\":\n    \"\"\"Skip the entire module with the given message.\n    \n    This is a convenience function equivalent to skip(msg, allow_module_level=True).\n    Use this when you need to skip a module due to syntax compatibility or\n    missing dependencies that would prevent the module from being processed.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Skipped(msg=msg, allow_module_level=True)\n",
      "\n@_with_exception(Skipped)\ndef skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n    \"\"\"Skip an executing test with the given message.\n\n    This function should be called only during testing (setup, call or teardown) or\n    during collection by using the ``allow_module_level`` flag.  This function can\n    be called in doctests as well.\n\n    :param bool allow_module_level:\n        Allows this function to be called at module level, skipping the rest\n        of the module. Defaults to False.\n\n    .. note::\n        It is better to use the :ref:`pytest.mark.skipif ref` marker when\n        possible to declare a test to be skipped under certain conditions\n        like mismatching platforms or dependencies.\n        Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n        <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n        to skip a doctest statically.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Skipped(msg=msg, allow_module_level=allow_module_level)\n\n\ndef skip_module(msg: str = \"\") -> \"NoReturn\":\n    \"\"\"Skip the entire module with the given message.\n    \n    This is a convenience function equivalent to skip(msg, allow_module_level=True).\n    Use this when you need to skip a module due to syntax compatibility or\n    missing dependencies that would prevent the module from being processed.\n    \"\"\"\n    __tracebackhide__ = True\n    skip(msg=msg, allow_module_level=True)\n",
      "\n@_with_exception(Skipped)\ndef skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n    \"\"\"Skip an executing test with the given message.\n\n    This function should be called only during testing (setup, call or teardown) or\n    during collection by using the ``allow_module_level`` flag.  This function can\n    be called in doctests as well.\n\n    :param bool allow_module_level:\n        Allows this function to be called at module level, skipping the rest\n        of the module. Defaults to False.\n\n    .. note::\n        It is better to use the :ref:`pytest.mark.skipif ref` marker when\n        possible to declare a test to be skipped under certain conditions\n        like mismatching platforms or dependencies.\n        Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n        <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n        to skip a doctest statically.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Skipped(msg=msg, allow_module_level=allow_module_level)\n\n\ndef skip_module(msg: str = \"\") -> \"NoReturn\":\n    \"\"\"Skip the entire module with the given message.\n    \n    This is a convenience function equivalent to skip(msg, allow_module_level=True).\n    Use this when you need to skip a module due to syntax compatibility or\n    missing dependencies that would prevent the module from being processed.\n    \"\"\"\n    __tracebackhide__ = True\n    skip(msg=msg, allow_module_level=True)\n"
    ],
    "Location 3 (/root/hy/projects_3/pytest/src/_pytest/outcomes.py lines 1-30)": [
      "\n\"\"\"Exception classes and constants handling test outcomes as well as\nfunctions creating them.\"\"\"\nimport sys\nfrom typing import Any\nfrom typing import Callable\nfrom typing import cast\nfrom typing import Optional\nfrom typing import Type\nfrom typing import TypeVar\nfrom typing import NoReturn\nfrom typing_extensions import Protocol\nfrom typing import Generic\nimport warnings\nfrom packaging.version import Version\n\nTYPE_CHECKING = False  # Avoid circular import through compat.\n\nif TYPE_CHECKING:\n    pass\nelse:\n    # typing.Protocol is only available starting from Python 3.8. It is also\n    # available from typing_extensions, but we don't want a runtime dependency\n    # on that. So use a dummy runtime implementation.\n    Protocol = Generic\n\n\nclass OutcomeException(BaseException):\n    \"\"\"OutcomeException and its subclass instances indicate and contain info\n    about test and collection outcomes.\"\"\"\n\n    def __init__(self, msg: Optional[str] = None, pytrace: bool = True) -> None:\n        if msg is not None and not isinstance(msg, str):\n",
      "\n\"\"\"Exception classes and constants handling test outcomes as well as\nfunctions creating them.\"\"\"\nimport sys\nfrom typing import Any\nfrom typing import Callable\nfrom typing import cast\nfrom typing import Optional\nfrom typing import Type\nfrom typing import TypeVar\nfrom typing import NoReturn\nfrom typing_extensions import Protocol\nfrom typing import Generic\nimport warnings\nfrom packaging.version import Version\n\nTYPE_CHECKING = False  # Avoid circular import through compat.\n\nif TYPE_CHECKING:\n    pass\nelse:\n    # typing.Protocol is only available starting from Python 3.8. It is also\n    # available from typing_extensions, but we don't want a runtime dependency\n    # on that. So use a dummy runtime implementation.\n    Protocol = Generic\n\n\nclass OutcomeException(BaseException):\n    \"\"\"OutcomeException and its subclass instances indicate and contain info\n    about test and collection outcomes.\"\"\"\n\n    def __init__(self, msg: Optional[str] = None, pytrace: bool = True) -> None:\n        if msg is not None and not isinstance(msg, str):\n",
      "\n\"\"\"Exception classes and constants handling test outcomes as well as\nfunctions creating them.\"\"\"\nimport sys\nfrom typing import Any\nfrom typing import Callable\nfrom typing import cast\nfrom typing import Optional\nfrom typing import Type\nfrom typing import TypeVar\nfrom typing import NoReturn\nfrom typing_extensions import Protocol\nfrom typing import Generic\nimport warnings\nfrom packaging.version import Version\n\nTYPE_CHECKING = False  # Avoid circular import through compat.\n\nif TYPE_CHECKING:\n    pass\nelse:\n    # typing.Protocol is only available starting from Python 3.8. It is also\n    # available from typing_extensions, but we don't want a runtime dependency\n    # on that. So use a dummy runtime implementation.\n    Protocol = Generic\n\n\nclass OutcomeException(BaseException):\n    \"\"\"OutcomeException and its subclass instances indicate and contain info\n    about test and collection outcomes.\"\"\"\n\n    def __init__(self, msg: Optional[str] = None, pytrace: bool = True) -> None:\n        if msg is not None and not isinstance(msg, str):\n",
      "\n\"\"\"Exception classes and constants handling test outcomes as well as\nfunctions creating them.\"\"\"\nimport sys\nfrom typing import Any\nfrom typing import Callable\nfrom typing import cast\nfrom typing import Optional\nfrom typing import Type\nfrom typing import TypeVar\nfrom typing import NoReturn\nfrom typing_extensions import Protocol\nfrom typing import Generic\nimport warnings\nfrom packaging.version import Version\n\n\nclass OutcomeException(BaseException):\n    \"\"\"OutcomeException and its subclass instances indicate and contain info\n    about test and collection outcomes.\"\"\"\n\n    def __init__(self, msg: Optional[str] = None, pytrace: bool = True) -> None:\n        if msg is not None and not isinstance(msg, str):\n            error_msg = (  # type: ignore[unreachable]\n                \"{} expected string as 'msg' parameter, got '{}' instead.\\n\"\n                \"Perhaps you meant to use a mark?\"\n            )\n            raise TypeError(error_msg.format(type(self).__name__, type(msg).__name__))\n        BaseException.__init__(self, msg)\n        self.msg = msg\n        self.pytrace = pytrace\n",
      "\n\"\"\"Exception classes and constants handling test outcomes as well as\nfunctions creating them.\"\"\"\nimport sys\nfrom typing import Any\nfrom typing import Callable\nfrom typing import cast\nfrom typing import Optional\nfrom typing import Type\nfrom typing import TypeVar\nfrom typing import NoReturn\nfrom typing_extensions import Protocol\nfrom typing import Generic\nimport warnings\nfrom packaging.version import Version\n\nTYPE_CHECKING = False  # Avoid circular import through compat.\n\nif TYPE_CHECKING:\n    pass\nelse:\n    # typing.Protocol is only available starting from Python 3.8. It is also\n    # available from typing_extensions, but we don't want a runtime dependency\n    # on that. So use a dummy runtime implementation.\n    Protocol = Generic\n\n\nclass OutcomeException(BaseException):\n    \"\"\"OutcomeException and its subclass instances indicate and contain info\n    about test and collection outcomes.\"\"\"\n\n    def __init__(self, msg: Optional[str] = None, pytrace: bool = True) -> None:\n        if msg is not None and not isinstance(msg, str):\n",
      "\n\"\"\"Exception classes and constants handling test outcomes as well as\nfunctions creating them.\"\"\"\nimport sys\nfrom typing import Any\nfrom typing import Callable\nfrom typing import cast\nfrom typing import Optional\nfrom typing import Type\nfrom typing import TypeVar\nfrom typing import NoReturn\nfrom typing_extensions import Protocol\nfrom typing import Generic\nimport warnings\nfrom packaging.version import Version\n\nTYPE_CHECKING = False  # Avoid circular import through compat.\n\nif TYPE_CHECKING:\n    pass\nelse:\n    # typing.Protocol is only available starting from Python 3.8. It is also\n    # available from typing_extensions, but we don't want a runtime dependency\n    # on that. So use a dummy runtime implementation.\n    Protocol = Generic\n\n\nclass OutcomeException(BaseException):\n    \"\"\"OutcomeException and its subclass instances indicate and contain info\n    about test and collection outcomes.\"\"\"\n\n    def __init__(self, msg: Optional[str] = None, pytrace: bool = True) -> None:\n        if msg is not None and not isinstance(msg, str):\n",
      "\n\"\"\"Exception classes and constants handling test outcomes as well as\nfunctions creating them.\"\"\"\nimport sys\nfrom typing import Any\nfrom typing import Callable\nfrom typing import cast\nfrom typing import Optional\nfrom typing import Type\nfrom typing import TypeVar\nfrom typing import NoReturn\nfrom typing_extensions import Protocol\nfrom typing import Generic\nimport warnings\nfrom packaging.version import Version\n\nTYPE_CHECKING = False  # Avoid circular import through compat.\n\nif TYPE_CHECKING:\n    pass\nelse:\n    # typing.Protocol is only available starting from Python 3.8. It is also\n    # available from typing_extensions, but we don't want a runtime dependency\n    # on that. So use a dummy runtime implementation.\n    Protocol = Generic\n\n\nclass OutcomeException(BaseException):\n    \"\"\"OutcomeException and its subclass instances indicate and contain info\n    about test and collection outcomes.\"\"\"\n\n    def __init__(self, msg: Optional[str] = None, pytrace: bool = True) -> None:\n        if msg is not None and not isinstance(msg, str):\n",
      "\n\"\"\"Exception classes and constants handling test outcomes as well as\nfunctions creating them.\"\"\"\nimport sys\nfrom typing import Any\nfrom typing import Callable\nfrom typing import cast\nfrom typing import Optional\nfrom typing import Type\nfrom typing import TypeVar\nfrom typing import NoReturn\nfrom typing_extensions import Protocol\nfrom typing import Generic\nimport warnings\nfrom packaging.version import Version\n\nTYPE_CHECKING = False  # Avoid circular import through compat.\n\n\nclass OutcomeException(BaseException):\n    \"\"\"OutcomeException and its subclass instances indicate and contain info\n    about test and collection outcomes.\"\"\"\n\n    def __init__(self, msg: Optional[str] = None, pytrace: bool = True) -> None:\n        if msg is not None and not isinstance(msg, str):\n            error_msg = (  # type: ignore[unreachable]\n                \"{} expected string as 'msg' parameter, got '{}' instead.\\n\"\n                \"Perhaps you meant to use a mark?\"\n            )\n"
    ],
    "Location 4 (/root/hy/projects_3/pytest/src/_pytest/skipping.py lines 1-50)": [
      "\n\"\"\"Support for skip/xfail functions and markers.\"\"\"\nimport os\nimport platform\nimport sys\nimport traceback\nfrom collections.abc import Mapping\nfrom typing import Generator\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Type\n\nimport attr\n\nfrom _pytest.config import Config\nfrom _pytest.config import hookimpl\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.mark.structures import Mark\nfrom _pytest.nodes import Item\nfrom _pytest.outcomes import fail\nfrom _pytest.outcomes import skip\nfrom _pytest.outcomes import xfail\nfrom _pytest.reports import BaseReport\nfrom _pytest.runner import CallInfo\nfrom _pytest.store import StoreKey\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"general\")\n    group.addoption(\n        \"--runxfail\",\n        action=\"store_true\",\n        dest=\"runxfail\",\n        default=False,\n        help=\"report the results of xfail tests as if they were not marked\",\n    )\n\n    parser.addini(\n        \"xfail_strict\",\n        \"default for the strict parameter of xfail \"\n        \"markers when not given explicitly (default: False)\",\n        default=False,\n        type=\"bool\",\n    )\n\n\ndef pytest_configure(config: Config) -> None:\n    if config.option.runxfail:\n        # yay a hack\n        import pytest\n",
      "\n\"\"\"Support for skip/xfail functions and markers.\"\"\"\nimport os\nimport platform\nimport sys\nimport traceback\nfrom collections.abc import Mapping\nfrom typing import Generator\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Type\n\nimport attr\n\nfrom _pytest.config import Config\nfrom _pytest.config import hookimpl\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.mark.structures import Mark\nfrom _pytest.nodes import Item\nfrom _pytest.outcomes import fail\nfrom _pytest.outcomes import skip\nfrom _pytest.outcomes import skip_module\nfrom _pytest.outcomes import xfail\nfrom _pytest.reports import BaseReport\nfrom _pytest.runner import CallInfo\nfrom _pytest.store import StoreKey\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"general\")\n    group.addoption(\n        \"--runxfail\",\n        action=\"store_true\",\n        dest=\"runxfail\",\n        default=False,\n        help=\"report the results of xfail tests as if they were not marked\",\n    )\n\n    parser.addini(\n        \"xfail_strict\",\n        \"default for the strict parameter of xfail \"\n        \"markers when not given explicitly (default: False)\",\n        default=False,\n        type=\"bool\",\n    )\n\n\ndef pytest_configure(config: Config) -> None:\n    if config.option.runxfail:\n        # yay a hack\n        import pytest\n",
      "\n\"\"\"Support for skip/xfail functions and markers.\"\"\"\nimport os\nimport platform\nimport sys\nimport traceback\nfrom collections.abc import Mapping\nfrom typing import Generator\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Type\n\nimport attr\n\nfrom _pytest.config import Config\nfrom _pytest.config import hookimpl\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.mark.structures import Mark\nfrom _pytest.nodes import Item\nfrom _pytest.outcomes import fail\nfrom _pytest.outcomes import skip\nfrom _pytest.outcomes import xfail\nfrom _pytest.reports import BaseReport\nfrom _pytest.runner import CallInfo\nfrom _pytest.store import StoreKey\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"general\")\n    group.addoption(\n        \"--runxfail\",\n        action=\"store_true\",\n        dest=\"runxfail\",\n        default=False,\n        help=\"report the results of xfail tests as if they were not marked\",\n    )\n\n    parser.addini(\n        \"xfail_strict\",\n        \"default for the strict parameter of xfail \"\n        \"markers when not given explicitly (default: False)\",\n        default=False,\n        type=\"bool\",\n    )\n\n\ndef pytest_configure(config: Config) -> None:\n    if config.option.runxfail:\n        # yay a hack\n        import pytest\n",
      "\n\"\"\"Support for skip/xfail functions and markers.\"\"\"\nimport os\nimport platform\nimport sys\nimport traceback\nfrom collections.abc import Mapping\nfrom typing import Generator\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Type\n\nimport attr\n\nfrom _pytest.config import Config\nfrom _pytest.config import hookimpl\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.mark.structures import Mark\nfrom _pytest.nodes import Item\nfrom _pytest.outcomes import fail\nfrom _pytest.outcomes import skip\nfrom _pytest.outcomes import xfail\nfrom _pytest.reports import BaseReport\nfrom _pytest.runner import CallInfo\nfrom _pytest.store import StoreKey\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"general\")\n    group.addoption(\n        \"--runxfail\",\n        action=\"store_true\",\n        dest=\"runxfail\",\n        default=False,\n        help=\"report the results of xfail tests as if they were not marked\",\n    )\n\n    parser.addini(\n        \"xfail_strict\",\n        \"default for the strict parameter of xfail \"\n        \"markers when not given explicitly (default: False)\",\n        default=False,\n        type=\"bool\",\n    )\n\n\ndef pytest_configure(config: Config) -> None:\n    if config.option.runxfail:\n        # yay a hack\n        import pytest\n",
      "\n\"\"\"Support for skip/xfail functions and markers.\"\"\"\nimport os\nimport platform\nimport sys\nimport traceback\nfrom collections.abc import Mapping\nfrom typing import Generator\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Type\n\nimport attr\n\nfrom _pytest.config import Config\nfrom _pytest.config import hookimpl\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.mark.structures import Mark\nfrom _pytest.nodes import Item\nfrom _pytest.outcomes import fail\nfrom _pytest.outcomes import skip\nfrom _pytest.outcomes import skip_module\nfrom _pytest.outcomes import xfail\nfrom _pytest.reports import BaseReport\nfrom _pytest.runner import CallInfo\nfrom _pytest.store import StoreKey\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"general\")\n    group.addoption(\n        \"--runxfail\",\n        action=\"store_true\",\n        dest=\"runxfail\",\n        default=False,\n        help=\"report the results of xfail tests as if they were not marked\",\n    )\n\n    parser.addini(\n        \"xfail_strict\",\n        \"default for the strict parameter of xfail \"\n        \"markers when not given explicitly (default: False)\",\n        default=False,\n        type=\"bool\",\n    )\n\n\ndef pytest_configure(config: Config) -> None:\n    if config.option.runxfail:\n        # yay a hack\n        import pytest\n",
      "\n\"\"\"Support for skip/xfail functions and markers.\"\"\"\nimport os\nimport platform\nimport sys\nimport traceback\nfrom collections.abc import Mapping\nfrom typing import Generator\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Type\n\nimport attr\n\nfrom _pytest.config import Config\nfrom _pytest.config import hookimpl\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.mark.structures import Mark\nfrom _pytest.nodes import Item\nfrom _pytest.outcomes import fail\nfrom _pytest.outcomes import skip\nfrom _pytest.outcomes import xfail\nfrom _pytest.reports import BaseReport\nfrom _pytest.runner import CallInfo\nfrom _pytest.store import StoreKey\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"general\")\n    group.addoption(\n        \"--runxfail\",\n        action=\"store_true\",\n        dest=\"runxfail\",\n        default=False,\n        help=\"report the results of xfail tests as if they were not marked\",\n    )\n\n    parser.addini(\n        \"xfail_strict\",\n        \"default for the strict parameter of xfail \"\n        \"markers when not given explicitly (default: False)\",\n        default=False,\n        type=\"bool\",\n    )\n\n\ndef pytest_configure(config: Config) -> None:\n    if config.option.runxfail:\n        # yay a hack\n        import pytest\n",
      "\n\"\"\"Support for skip/xfail functions and markers.\"\"\"\nimport os\nimport platform\nimport sys\nimport traceback\nfrom collections.abc import Mapping\nfrom typing import Generator\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Type\n\nimport attr\n\nfrom _pytest.config import Config\nfrom _pytest.config import hookimpl\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.mark.structures import Mark\nfrom _pytest.nodes import Item\nfrom _pytest.outcomes import fail\nfrom _pytest.outcomes import skip\nfrom _pytest.outcomes import skip_module\nfrom _pytest.outcomes import xfail\nfrom _pytest.reports import BaseReport\nfrom _pytest.runner import CallInfo\nfrom _pytest.store import StoreKey\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"general\")\n    group.addoption(\n        \"--runxfail\",\n        action=\"store_true\",\n        dest=\"runxfail\",\n        default=False,\n        help=\"report the results of xfail tests as if they were not marked\",\n    )\n\n    parser.addini(\n        \"xfail_strict\",\n        \"default for the strict parameter of xfail \"\n        \"markers when not given explicitly (default: False)\",\n        default=False,\n        type=\"bool\",\n    )\n\n\ndef pytest_configure(config: Config) -> None:\n    if config.option.runxfail:\n        # yay a hack\n        import pytest\n",
      "\n\"\"\"Support for skip/xfail functions and markers.\"\"\"\nimport os\nimport platform\nimport sys\nimport traceback\nfrom collections.abc import Mapping\nfrom typing import Generator\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Type\n\nimport attr\n\nfrom _pytest.config import Config\nfrom _pytest.config import hookimpl\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.mark.structures import Mark\nfrom _pytest.nodes import Item\nfrom _pytest.outcomes import fail\nfrom _pytest.outcomes import skip\nfrom _pytest.outcomes import xfail\nfrom _pytest.reports import BaseReport\nfrom _pytest.runner import CallInfo\nfrom _pytest.store import StoreKey\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"general\")\n    group.addoption(\n        \"--runxfail\",\n        action=\"store_true\",\n        dest=\"runxfail\",\n        default=False,\n        help=\"report the results of xfail tests as if they were not marked\",\n    )\n\n    parser.addini(\n        \"xfail_strict\",\n        \"default for the strict parameter of xfail \"\n        \"markers when not given explicitly (default: False)\",\n        default=False,\n        type=\"bool\",\n    )\n\n\ndef pytest_configure(config: Config) -> None:\n    if config.option.runxfail:\n        # yay a hack\n        import pytest\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/src/_pytest/outcomes.py b/src/_pytest/outcomes.py\nindex 2addf5572..5c35e33f7 100644\n--- a/src/_pytest/outcomes.py\n+++ b/src/_pytest/outcomes.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Exception classes and constants handling test outcomes as well as\n functions creating them.\"\"\"\n import sys\n@@ -120,6 +121,8 @@ def exit(msg: str, returncode: Optional[int] = None) -> \"NoReturn\":\n     raise Exit(msg, returncode)\n \n \n+@_with_exception(Skipped)\n+\n @_with_exception(Skipped)\n def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n     \"\"\"Skip an executing test with the given message.\n@@ -144,6 +147,20 @@ def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n     raise Skipped(msg=msg, allow_module_level=allow_module_level)\n \n \n+@_with_exception(Skipped)\n+def skip_module(msg: str = \"\") -> \"NoReturn\":\n+    \"\"\"Skip the entire module with the given message.\n+    \n+    This is a convenience function equivalent to skip(msg, allow_module_level=True).\n+    Use this when you need to skip a module due to syntax compatibility or\n+    missing dependencies that would prevent the module from being processed.\n+    \n+    :param str msg: The message to show as reason for skipping the module.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    skip(msg=msg, allow_module_level=True)\n+\n+\n @_with_exception(Failed)\n def fail(msg: str = \"\", pytrace: bool = True) -> \"NoReturn\":\n     \"\"\"Explicitly fail an executing test with the given message.\ndiff --git a/src/_pytest/python.py b/src/_pytest/python.py\nindex 79dfb7320..5cd4b559e 100644\n--- a/src/_pytest/python.py\n+++ b/src/_pytest/python.py\n@@ -607,11 +607,14 @@ class Module(nodes.File, PyCollector):\n         except skip.Exception as e:\n             if e.allow_module_level:\n                 raise\n+\n             raise self.CollectError(\n                 \"Using pytest.skip outside of a test is not allowed. \"\n                 \"To decorate a test function, use the @pytest.mark.skip \"\n-                \"or @pytest.mark.skipif decorators instead, and to skip a \"\n-                \"module use `pytestmark = pytest.mark.{skip,skipif}.\"\n+                \"or @pytest.mark.skipif decorators instead. To skip a \"\n+                \"module, use `pytestmark = pytest.mark.{skip,skipif}` or \"\n+                \"call `skip(msg='reason', allow_module_level=True)` for \"\n+                \"modules with syntax incompatible with older Python versions.\"\n             ) from e\n         self.config.pluginmanager.consider_module(mod)\n         return mod\ndiff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex f7a026ae7..26f30621b 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Support for skip/xfail functions and markers.\"\"\"\n import os\n import platform\n@@ -18,6 +19,7 @@ from _pytest.mark.structures import Mark\n from _pytest.nodes import Item\n from _pytest.outcomes import fail\n from _pytest.outcomes import skip\n+from _pytest.outcomes import skip_module\n from _pytest.outcomes import xfail\n from _pytest.reports import BaseReport\n from _pytest.runner import CallInfo\n@@ -47,7 +49,6 @@ def pytest_configure(config: Config) -> None:\n     if config.option.runxfail:\n         # yay a hack\n         import pytest\n-\n         old = pytest.xfail\n         config._cleanup.append(lambda: setattr(pytest, \"xfail\", old))\n \n",
    "variant_0": "diff --git a/src/_pytest/outcomes.py b/src/_pytest/outcomes.py\nindex 2addf5572..531c465a5 100644\n--- a/src/_pytest/outcomes.py\n+++ b/src/_pytest/outcomes.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Exception classes and constants handling test outcomes as well as\n functions creating them.\"\"\"\n import sys\n@@ -7,18 +8,20 @@ from typing import cast\n from typing import Optional\n from typing import Type\n from typing import TypeVar\n+from typing import NoReturn\n+from typing_extensions import Protocol\n+from typing import Generic\n+import warnings\n+from packaging.version import Version\n \n TYPE_CHECKING = False  # Avoid circular import through compat.\n \n if TYPE_CHECKING:\n-    from typing import NoReturn\n-    from typing_extensions import Protocol\n+    pass\n else:\n     # typing.Protocol is only available starting from Python 3.8. It is also\n     # available from typing_extensions, but we don't want a runtime dependency\n     # on that. So use a dummy runtime implementation.\n-    from typing import Generic\n-\n     Protocol = Generic\n \n \n@@ -120,6 +123,8 @@ def exit(msg: str, returncode: Optional[int] = None) -> \"NoReturn\":\n     raise Exit(msg, returncode)\n \n \n+@_with_exception(Skipped)\n+\n @_with_exception(Skipped)\n def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n     \"\"\"Skip an executing test with the given message.\n@@ -144,6 +149,17 @@ def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n     raise Skipped(msg=msg, allow_module_level=allow_module_level)\n \n \n+def skip_module(msg: str = \"\") -> \"NoReturn\":\n+    \"\"\"Skip the entire module with the given message.\n+    \n+    This is a convenience function equivalent to skip(msg, allow_module_level=True).\n+    Use this when you need to skip a module due to syntax compatibility or\n+    missing dependencies that would prevent the module from being processed.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    skip(msg=msg, allow_module_level=True)\n+\n+\n @_with_exception(Failed)\n def fail(msg: str = \"\", pytrace: bool = True) -> \"NoReturn\":\n     \"\"\"Explicitly fail an executing test with the given message.\ndiff --git a/src/_pytest/python.py b/src/_pytest/python.py\nindex 79dfb7320..a7a4c5eb8 100644\n--- a/src/_pytest/python.py\n+++ b/src/_pytest/python.py\n@@ -607,11 +607,15 @@ class Module(nodes.File, PyCollector):\n         except skip.Exception as e:\n             if e.allow_module_level:\n                 raise\n+\n             raise self.CollectError(\n                 \"Using pytest.skip outside of a test is not allowed. \"\n                 \"To decorate a test function, use the @pytest.mark.skip \"\n-                \"or @pytest.mark.skipif decorators instead, and to skip a \"\n-                \"module use `pytestmark = pytest.mark.{skip,skipif}.\"\n+                \"or @pytest.mark.skipif decorators instead. To skip a \"\n+                \"module, use `pytestmark = pytest.mark.{skip,skipif}` or \"\n+                \"call `skip(msg='reason', allow_module_level=True)` for \"\n+                \"modules with syntax incompatible with older Python versions.\"\n+            ) from e\n             ) from e\n         self.config.pluginmanager.consider_module(mod)\n         return mod\ndiff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex f7a026ae7..125324f7f 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Support for skip/xfail functions and markers.\"\"\"\n import os\n import platform\n@@ -47,7 +48,6 @@ def pytest_configure(config: Config) -> None:\n     if config.option.runxfail:\n         # yay a hack\n         import pytest\n-\n         old = pytest.xfail\n         config._cleanup.append(lambda: setattr(pytest, \"xfail\", old))\n \n",
    "variant_1": "diff --git a/src/_pytest/outcomes.py b/src/_pytest/outcomes.py\nindex 2addf5572..531c465a5 100644\n--- a/src/_pytest/outcomes.py\n+++ b/src/_pytest/outcomes.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Exception classes and constants handling test outcomes as well as\n functions creating them.\"\"\"\n import sys\n@@ -7,18 +8,20 @@ from typing import cast\n from typing import Optional\n from typing import Type\n from typing import TypeVar\n+from typing import NoReturn\n+from typing_extensions import Protocol\n+from typing import Generic\n+import warnings\n+from packaging.version import Version\n \n TYPE_CHECKING = False  # Avoid circular import through compat.\n \n if TYPE_CHECKING:\n-    from typing import NoReturn\n-    from typing_extensions import Protocol\n+    pass\n else:\n     # typing.Protocol is only available starting from Python 3.8. It is also\n     # available from typing_extensions, but we don't want a runtime dependency\n     # on that. So use a dummy runtime implementation.\n-    from typing import Generic\n-\n     Protocol = Generic\n \n \n@@ -120,6 +123,8 @@ def exit(msg: str, returncode: Optional[int] = None) -> \"NoReturn\":\n     raise Exit(msg, returncode)\n \n \n+@_with_exception(Skipped)\n+\n @_with_exception(Skipped)\n def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n     \"\"\"Skip an executing test with the given message.\n@@ -144,6 +149,17 @@ def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n     raise Skipped(msg=msg, allow_module_level=allow_module_level)\n \n \n+def skip_module(msg: str = \"\") -> \"NoReturn\":\n+    \"\"\"Skip the entire module with the given message.\n+    \n+    This is a convenience function equivalent to skip(msg, allow_module_level=True).\n+    Use this when you need to skip a module due to syntax compatibility or\n+    missing dependencies that would prevent the module from being processed.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    skip(msg=msg, allow_module_level=True)\n+\n+\n @_with_exception(Failed)\n def fail(msg: str = \"\", pytrace: bool = True) -> \"NoReturn\":\n     \"\"\"Explicitly fail an executing test with the given message.\ndiff --git a/src/_pytest/python.py b/src/_pytest/python.py\nindex 79dfb7320..a7a4c5eb8 100644\n--- a/src/_pytest/python.py\n+++ b/src/_pytest/python.py\n@@ -607,11 +607,15 @@ class Module(nodes.File, PyCollector):\n         except skip.Exception as e:\n             if e.allow_module_level:\n                 raise\n+\n             raise self.CollectError(\n                 \"Using pytest.skip outside of a test is not allowed. \"\n                 \"To decorate a test function, use the @pytest.mark.skip \"\n-                \"or @pytest.mark.skipif decorators instead, and to skip a \"\n-                \"module use `pytestmark = pytest.mark.{skip,skipif}.\"\n+                \"or @pytest.mark.skipif decorators instead. To skip a \"\n+                \"module, use `pytestmark = pytest.mark.{skip,skipif}` or \"\n+                \"call `skip(msg='reason', allow_module_level=True)` for \"\n+                \"modules with syntax incompatible with older Python versions.\"\n+            ) from e\n             ) from e\n         self.config.pluginmanager.consider_module(mod)\n         return mod\ndiff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex f7a026ae7..125324f7f 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Support for skip/xfail functions and markers.\"\"\"\n import os\n import platform\n@@ -47,7 +48,6 @@ def pytest_configure(config: Config) -> None:\n     if config.option.runxfail:\n         # yay a hack\n         import pytest\n-\n         old = pytest.xfail\n         config._cleanup.append(lambda: setattr(pytest, \"xfail\", old))\n \n",
    "variant_2": "diff --git a/src/_pytest/outcomes.py b/src/_pytest/outcomes.py\nindex 2addf5572..531c465a5 100644\n--- a/src/_pytest/outcomes.py\n+++ b/src/_pytest/outcomes.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Exception classes and constants handling test outcomes as well as\n functions creating them.\"\"\"\n import sys\n@@ -7,18 +8,20 @@ from typing import cast\n from typing import Optional\n from typing import Type\n from typing import TypeVar\n+from typing import NoReturn\n+from typing_extensions import Protocol\n+from typing import Generic\n+import warnings\n+from packaging.version import Version\n \n TYPE_CHECKING = False  # Avoid circular import through compat.\n \n if TYPE_CHECKING:\n-    from typing import NoReturn\n-    from typing_extensions import Protocol\n+    pass\n else:\n     # typing.Protocol is only available starting from Python 3.8. It is also\n     # available from typing_extensions, but we don't want a runtime dependency\n     # on that. So use a dummy runtime implementation.\n-    from typing import Generic\n-\n     Protocol = Generic\n \n \n@@ -120,6 +123,8 @@ def exit(msg: str, returncode: Optional[int] = None) -> \"NoReturn\":\n     raise Exit(msg, returncode)\n \n \n+@_with_exception(Skipped)\n+\n @_with_exception(Skipped)\n def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n     \"\"\"Skip an executing test with the given message.\n@@ -144,6 +149,17 @@ def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n     raise Skipped(msg=msg, allow_module_level=allow_module_level)\n \n \n+def skip_module(msg: str = \"\") -> \"NoReturn\":\n+    \"\"\"Skip the entire module with the given message.\n+    \n+    This is a convenience function equivalent to skip(msg, allow_module_level=True).\n+    Use this when you need to skip a module due to syntax compatibility or\n+    missing dependencies that would prevent the module from being processed.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    skip(msg=msg, allow_module_level=True)\n+\n+\n @_with_exception(Failed)\n def fail(msg: str = \"\", pytrace: bool = True) -> \"NoReturn\":\n     \"\"\"Explicitly fail an executing test with the given message.\ndiff --git a/src/_pytest/python.py b/src/_pytest/python.py\nindex 79dfb7320..a7a4c5eb8 100644\n--- a/src/_pytest/python.py\n+++ b/src/_pytest/python.py\n@@ -607,11 +607,15 @@ class Module(nodes.File, PyCollector):\n         except skip.Exception as e:\n             if e.allow_module_level:\n                 raise\n+\n             raise self.CollectError(\n                 \"Using pytest.skip outside of a test is not allowed. \"\n                 \"To decorate a test function, use the @pytest.mark.skip \"\n-                \"or @pytest.mark.skipif decorators instead, and to skip a \"\n-                \"module use `pytestmark = pytest.mark.{skip,skipif}.\"\n+                \"or @pytest.mark.skipif decorators instead. To skip a \"\n+                \"module, use `pytestmark = pytest.mark.{skip,skipif}` or \"\n+                \"call `skip(msg='reason', allow_module_level=True)` for \"\n+                \"modules with syntax incompatible with older Python versions.\"\n+            ) from e\n             ) from e\n         self.config.pluginmanager.consider_module(mod)\n         return mod\ndiff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex f7a026ae7..26f30621b 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Support for skip/xfail functions and markers.\"\"\"\n import os\n import platform\n@@ -18,6 +19,7 @@ from _pytest.mark.structures import Mark\n from _pytest.nodes import Item\n from _pytest.outcomes import fail\n from _pytest.outcomes import skip\n+from _pytest.outcomes import skip_module\n from _pytest.outcomes import xfail\n from _pytest.reports import BaseReport\n from _pytest.runner import CallInfo\n@@ -47,7 +49,6 @@ def pytest_configure(config: Config) -> None:\n     if config.option.runxfail:\n         # yay a hack\n         import pytest\n-\n         old = pytest.xfail\n         config._cleanup.append(lambda: setattr(pytest, \"xfail\", old))\n \n",
    "variant_3": "diff --git a/src/_pytest/outcomes.py b/src/_pytest/outcomes.py\nindex 2addf5572..a742a68c6 100644\n--- a/src/_pytest/outcomes.py\n+++ b/src/_pytest/outcomes.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Exception classes and constants handling test outcomes as well as\n functions creating them.\"\"\"\n import sys\n@@ -7,18 +8,20 @@ from typing import cast\n from typing import Optional\n from typing import Type\n from typing import TypeVar\n+from typing import NoReturn\n+from typing_extensions import Protocol\n+from typing import Generic\n+import warnings\n+from packaging.version import Version\n \n TYPE_CHECKING = False  # Avoid circular import through compat.\n \n if TYPE_CHECKING:\n-    from typing import NoReturn\n-    from typing_extensions import Protocol\n+    pass\n else:\n     # typing.Protocol is only available starting from Python 3.8. It is also\n     # available from typing_extensions, but we don't want a runtime dependency\n     # on that. So use a dummy runtime implementation.\n-    from typing import Generic\n-\n     Protocol = Generic\n \n \n@@ -120,6 +123,8 @@ def exit(msg: str, returncode: Optional[int] = None) -> \"NoReturn\":\n     raise Exit(msg, returncode)\n \n \n+@_with_exception(Skipped)\n+\n @_with_exception(Skipped)\n def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n     \"\"\"Skip an executing test with the given message.\n@@ -144,6 +149,18 @@ def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n     raise Skipped(msg=msg, allow_module_level=allow_module_level)\n \n \n+@_with_exception(Skipped)\n+def skip_module(msg: str = \"\") -> \"NoReturn\":\n+    \"\"\"Skip the entire module with the given message.\n+    \n+    This is a convenience function equivalent to skip(msg, allow_module_level=True).\n+    Use this when you need to skip a module due to syntax compatibility or\n+    missing dependencies that would prevent the module from being processed.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    raise Skipped(msg=msg, allow_module_level=True)\n+\n+\n @_with_exception(Failed)\n def fail(msg: str = \"\", pytrace: bool = True) -> \"NoReturn\":\n     \"\"\"Explicitly fail an executing test with the given message.\ndiff --git a/src/_pytest/python.py b/src/_pytest/python.py\nindex 79dfb7320..a7a4c5eb8 100644\n--- a/src/_pytest/python.py\n+++ b/src/_pytest/python.py\n@@ -607,11 +607,15 @@ class Module(nodes.File, PyCollector):\n         except skip.Exception as e:\n             if e.allow_module_level:\n                 raise\n+\n             raise self.CollectError(\n                 \"Using pytest.skip outside of a test is not allowed. \"\n                 \"To decorate a test function, use the @pytest.mark.skip \"\n-                \"or @pytest.mark.skipif decorators instead, and to skip a \"\n-                \"module use `pytestmark = pytest.mark.{skip,skipif}.\"\n+                \"or @pytest.mark.skipif decorators instead. To skip a \"\n+                \"module, use `pytestmark = pytest.mark.{skip,skipif}` or \"\n+                \"call `skip(msg='reason', allow_module_level=True)` for \"\n+                \"modules with syntax incompatible with older Python versions.\"\n+            ) from e\n             ) from e\n         self.config.pluginmanager.consider_module(mod)\n         return mod\ndiff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex f7a026ae7..125324f7f 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Support for skip/xfail functions and markers.\"\"\"\n import os\n import platform\n@@ -47,7 +48,6 @@ def pytest_configure(config: Config) -> None:\n     if config.option.runxfail:\n         # yay a hack\n         import pytest\n-\n         old = pytest.xfail\n         config._cleanup.append(lambda: setattr(pytest, \"xfail\", old))\n \n",
    "variant_4": "diff --git a/src/_pytest/outcomes.py b/src/_pytest/outcomes.py\nindex 2addf5572..3635baed3 100644\n--- a/src/_pytest/outcomes.py\n+++ b/src/_pytest/outcomes.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Exception classes and constants handling test outcomes as well as\n functions creating them.\"\"\"\n import sys\n@@ -7,19 +8,11 @@ from typing import cast\n from typing import Optional\n from typing import Type\n from typing import TypeVar\n-\n-TYPE_CHECKING = False  # Avoid circular import through compat.\n-\n-if TYPE_CHECKING:\n-    from typing import NoReturn\n-    from typing_extensions import Protocol\n-else:\n-    # typing.Protocol is only available starting from Python 3.8. It is also\n-    # available from typing_extensions, but we don't want a runtime dependency\n-    # on that. So use a dummy runtime implementation.\n-    from typing import Generic\n-\n-    Protocol = Generic\n+from typing import NoReturn\n+from typing_extensions import Protocol\n+from typing import Generic\n+import warnings\n+from packaging.version import Version\n \n \n class OutcomeException(BaseException):\n@@ -36,6 +29,14 @@ class OutcomeException(BaseException):\n         BaseException.__init__(self, msg)\n         self.msg = msg\n         self.pytrace = pytrace\n+            error_msg = (  # type: ignore[unreachable]\n+                \"{} expected string as 'msg' parameter, got '{}' instead.\\n\"\n+                \"Perhaps you meant to use a mark?\"\n+            )\n+            raise TypeError(error_msg.format(type(self).__name__, type(msg).__name__))\n+        BaseException.__init__(self, msg)\n+        self.msg = msg\n+        self.pytrace = pytrace\n \n     def __repr__(self) -> str:\n         if self.msg is not None:\n@@ -120,6 +121,8 @@ def exit(msg: str, returncode: Optional[int] = None) -> \"NoReturn\":\n     raise Exit(msg, returncode)\n \n \n+@_with_exception(Skipped)\n+\n @_with_exception(Skipped)\n def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n     \"\"\"Skip an executing test with the given message.\n@@ -144,6 +147,18 @@ def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n     raise Skipped(msg=msg, allow_module_level=allow_module_level)\n \n \n+@_with_exception(Skipped)\n+def skip_module(msg: str = \"\") -> \"NoReturn\":\n+    \"\"\"Skip the entire module with the given message.\n+    \n+    This is a convenience function equivalent to skip(msg, allow_module_level=True).\n+    Use this when you need to skip a module due to syntax compatibility or\n+    missing dependencies that would prevent the module from being processed.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    raise Skipped(msg=msg, allow_module_level=True)\n+\n+\n @_with_exception(Failed)\n def fail(msg: str = \"\", pytrace: bool = True) -> \"NoReturn\":\n     \"\"\"Explicitly fail an executing test with the given message.\ndiff --git a/src/_pytest/python.py b/src/_pytest/python.py\nindex 79dfb7320..a7a4c5eb8 100644\n--- a/src/_pytest/python.py\n+++ b/src/_pytest/python.py\n@@ -607,11 +607,15 @@ class Module(nodes.File, PyCollector):\n         except skip.Exception as e:\n             if e.allow_module_level:\n                 raise\n+\n             raise self.CollectError(\n                 \"Using pytest.skip outside of a test is not allowed. \"\n                 \"To decorate a test function, use the @pytest.mark.skip \"\n-                \"or @pytest.mark.skipif decorators instead, and to skip a \"\n-                \"module use `pytestmark = pytest.mark.{skip,skipif}.\"\n+                \"or @pytest.mark.skipif decorators instead. To skip a \"\n+                \"module, use `pytestmark = pytest.mark.{skip,skipif}` or \"\n+                \"call `skip(msg='reason', allow_module_level=True)` for \"\n+                \"modules with syntax incompatible with older Python versions.\"\n+            ) from e\n             ) from e\n         self.config.pluginmanager.consider_module(mod)\n         return mod\ndiff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex f7a026ae7..125324f7f 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Support for skip/xfail functions and markers.\"\"\"\n import os\n import platform\n@@ -47,7 +48,6 @@ def pytest_configure(config: Config) -> None:\n     if config.option.runxfail:\n         # yay a hack\n         import pytest\n-\n         old = pytest.xfail\n         config._cleanup.append(lambda: setattr(pytest, \"xfail\", old))\n \n",
    "variant_5": "diff --git a/src/_pytest/outcomes.py b/src/_pytest/outcomes.py\nindex 2addf5572..531c465a5 100644\n--- a/src/_pytest/outcomes.py\n+++ b/src/_pytest/outcomes.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Exception classes and constants handling test outcomes as well as\n functions creating them.\"\"\"\n import sys\n@@ -7,18 +8,20 @@ from typing import cast\n from typing import Optional\n from typing import Type\n from typing import TypeVar\n+from typing import NoReturn\n+from typing_extensions import Protocol\n+from typing import Generic\n+import warnings\n+from packaging.version import Version\n \n TYPE_CHECKING = False  # Avoid circular import through compat.\n \n if TYPE_CHECKING:\n-    from typing import NoReturn\n-    from typing_extensions import Protocol\n+    pass\n else:\n     # typing.Protocol is only available starting from Python 3.8. It is also\n     # available from typing_extensions, but we don't want a runtime dependency\n     # on that. So use a dummy runtime implementation.\n-    from typing import Generic\n-\n     Protocol = Generic\n \n \n@@ -120,6 +123,8 @@ def exit(msg: str, returncode: Optional[int] = None) -> \"NoReturn\":\n     raise Exit(msg, returncode)\n \n \n+@_with_exception(Skipped)\n+\n @_with_exception(Skipped)\n def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n     \"\"\"Skip an executing test with the given message.\n@@ -144,6 +149,17 @@ def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n     raise Skipped(msg=msg, allow_module_level=allow_module_level)\n \n \n+def skip_module(msg: str = \"\") -> \"NoReturn\":\n+    \"\"\"Skip the entire module with the given message.\n+    \n+    This is a convenience function equivalent to skip(msg, allow_module_level=True).\n+    Use this when you need to skip a module due to syntax compatibility or\n+    missing dependencies that would prevent the module from being processed.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    skip(msg=msg, allow_module_level=True)\n+\n+\n @_with_exception(Failed)\n def fail(msg: str = \"\", pytrace: bool = True) -> \"NoReturn\":\n     \"\"\"Explicitly fail an executing test with the given message.\ndiff --git a/src/_pytest/python.py b/src/_pytest/python.py\nindex 79dfb7320..a7a4c5eb8 100644\n--- a/src/_pytest/python.py\n+++ b/src/_pytest/python.py\n@@ -607,11 +607,15 @@ class Module(nodes.File, PyCollector):\n         except skip.Exception as e:\n             if e.allow_module_level:\n                 raise\n+\n             raise self.CollectError(\n                 \"Using pytest.skip outside of a test is not allowed. \"\n                 \"To decorate a test function, use the @pytest.mark.skip \"\n-                \"or @pytest.mark.skipif decorators instead, and to skip a \"\n-                \"module use `pytestmark = pytest.mark.{skip,skipif}.\"\n+                \"or @pytest.mark.skipif decorators instead. To skip a \"\n+                \"module, use `pytestmark = pytest.mark.{skip,skipif}` or \"\n+                \"call `skip(msg='reason', allow_module_level=True)` for \"\n+                \"modules with syntax incompatible with older Python versions.\"\n+            ) from e\n             ) from e\n         self.config.pluginmanager.consider_module(mod)\n         return mod\ndiff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex f7a026ae7..26f30621b 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Support for skip/xfail functions and markers.\"\"\"\n import os\n import platform\n@@ -18,6 +19,7 @@ from _pytest.mark.structures import Mark\n from _pytest.nodes import Item\n from _pytest.outcomes import fail\n from _pytest.outcomes import skip\n+from _pytest.outcomes import skip_module\n from _pytest.outcomes import xfail\n from _pytest.reports import BaseReport\n from _pytest.runner import CallInfo\n@@ -47,7 +49,6 @@ def pytest_configure(config: Config) -> None:\n     if config.option.runxfail:\n         # yay a hack\n         import pytest\n-\n         old = pytest.xfail\n         config._cleanup.append(lambda: setattr(pytest, \"xfail\", old))\n \n",
    "variant_6": "diff --git a/src/_pytest/outcomes.py b/src/_pytest/outcomes.py\nindex 2addf5572..a742a68c6 100644\n--- a/src/_pytest/outcomes.py\n+++ b/src/_pytest/outcomes.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Exception classes and constants handling test outcomes as well as\n functions creating them.\"\"\"\n import sys\n@@ -7,18 +8,20 @@ from typing import cast\n from typing import Optional\n from typing import Type\n from typing import TypeVar\n+from typing import NoReturn\n+from typing_extensions import Protocol\n+from typing import Generic\n+import warnings\n+from packaging.version import Version\n \n TYPE_CHECKING = False  # Avoid circular import through compat.\n \n if TYPE_CHECKING:\n-    from typing import NoReturn\n-    from typing_extensions import Protocol\n+    pass\n else:\n     # typing.Protocol is only available starting from Python 3.8. It is also\n     # available from typing_extensions, but we don't want a runtime dependency\n     # on that. So use a dummy runtime implementation.\n-    from typing import Generic\n-\n     Protocol = Generic\n \n \n@@ -120,6 +123,8 @@ def exit(msg: str, returncode: Optional[int] = None) -> \"NoReturn\":\n     raise Exit(msg, returncode)\n \n \n+@_with_exception(Skipped)\n+\n @_with_exception(Skipped)\n def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n     \"\"\"Skip an executing test with the given message.\n@@ -144,6 +149,18 @@ def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n     raise Skipped(msg=msg, allow_module_level=allow_module_level)\n \n \n+@_with_exception(Skipped)\n+def skip_module(msg: str = \"\") -> \"NoReturn\":\n+    \"\"\"Skip the entire module with the given message.\n+    \n+    This is a convenience function equivalent to skip(msg, allow_module_level=True).\n+    Use this when you need to skip a module due to syntax compatibility or\n+    missing dependencies that would prevent the module from being processed.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    raise Skipped(msg=msg, allow_module_level=True)\n+\n+\n @_with_exception(Failed)\n def fail(msg: str = \"\", pytrace: bool = True) -> \"NoReturn\":\n     \"\"\"Explicitly fail an executing test with the given message.\ndiff --git a/src/_pytest/python.py b/src/_pytest/python.py\nindex 79dfb7320..a7a4c5eb8 100644\n--- a/src/_pytest/python.py\n+++ b/src/_pytest/python.py\n@@ -607,11 +607,15 @@ class Module(nodes.File, PyCollector):\n         except skip.Exception as e:\n             if e.allow_module_level:\n                 raise\n+\n             raise self.CollectError(\n                 \"Using pytest.skip outside of a test is not allowed. \"\n                 \"To decorate a test function, use the @pytest.mark.skip \"\n-                \"or @pytest.mark.skipif decorators instead, and to skip a \"\n-                \"module use `pytestmark = pytest.mark.{skip,skipif}.\"\n+                \"or @pytest.mark.skipif decorators instead. To skip a \"\n+                \"module, use `pytestmark = pytest.mark.{skip,skipif}` or \"\n+                \"call `skip(msg='reason', allow_module_level=True)` for \"\n+                \"modules with syntax incompatible with older Python versions.\"\n+            ) from e\n             ) from e\n         self.config.pluginmanager.consider_module(mod)\n         return mod\ndiff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex f7a026ae7..125324f7f 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Support for skip/xfail functions and markers.\"\"\"\n import os\n import platform\n@@ -47,7 +48,6 @@ def pytest_configure(config: Config) -> None:\n     if config.option.runxfail:\n         # yay a hack\n         import pytest\n-\n         old = pytest.xfail\n         config._cleanup.append(lambda: setattr(pytest, \"xfail\", old))\n \n",
    "variant_7": "diff --git a/src/_pytest/outcomes.py b/src/_pytest/outcomes.py\nindex 2addf5572..531c465a5 100644\n--- a/src/_pytest/outcomes.py\n+++ b/src/_pytest/outcomes.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Exception classes and constants handling test outcomes as well as\n functions creating them.\"\"\"\n import sys\n@@ -7,18 +8,20 @@ from typing import cast\n from typing import Optional\n from typing import Type\n from typing import TypeVar\n+from typing import NoReturn\n+from typing_extensions import Protocol\n+from typing import Generic\n+import warnings\n+from packaging.version import Version\n \n TYPE_CHECKING = False  # Avoid circular import through compat.\n \n if TYPE_CHECKING:\n-    from typing import NoReturn\n-    from typing_extensions import Protocol\n+    pass\n else:\n     # typing.Protocol is only available starting from Python 3.8. It is also\n     # available from typing_extensions, but we don't want a runtime dependency\n     # on that. So use a dummy runtime implementation.\n-    from typing import Generic\n-\n     Protocol = Generic\n \n \n@@ -120,6 +123,8 @@ def exit(msg: str, returncode: Optional[int] = None) -> \"NoReturn\":\n     raise Exit(msg, returncode)\n \n \n+@_with_exception(Skipped)\n+\n @_with_exception(Skipped)\n def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n     \"\"\"Skip an executing test with the given message.\n@@ -144,6 +149,17 @@ def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n     raise Skipped(msg=msg, allow_module_level=allow_module_level)\n \n \n+def skip_module(msg: str = \"\") -> \"NoReturn\":\n+    \"\"\"Skip the entire module with the given message.\n+    \n+    This is a convenience function equivalent to skip(msg, allow_module_level=True).\n+    Use this when you need to skip a module due to syntax compatibility or\n+    missing dependencies that would prevent the module from being processed.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    skip(msg=msg, allow_module_level=True)\n+\n+\n @_with_exception(Failed)\n def fail(msg: str = \"\", pytrace: bool = True) -> \"NoReturn\":\n     \"\"\"Explicitly fail an executing test with the given message.\ndiff --git a/src/_pytest/python.py b/src/_pytest/python.py\nindex 79dfb7320..a7a4c5eb8 100644\n--- a/src/_pytest/python.py\n+++ b/src/_pytest/python.py\n@@ -607,11 +607,15 @@ class Module(nodes.File, PyCollector):\n         except skip.Exception as e:\n             if e.allow_module_level:\n                 raise\n+\n             raise self.CollectError(\n                 \"Using pytest.skip outside of a test is not allowed. \"\n                 \"To decorate a test function, use the @pytest.mark.skip \"\n-                \"or @pytest.mark.skipif decorators instead, and to skip a \"\n-                \"module use `pytestmark = pytest.mark.{skip,skipif}.\"\n+                \"or @pytest.mark.skipif decorators instead. To skip a \"\n+                \"module, use `pytestmark = pytest.mark.{skip,skipif}` or \"\n+                \"call `skip(msg='reason', allow_module_level=True)` for \"\n+                \"modules with syntax incompatible with older Python versions.\"\n+            ) from e\n             ) from e\n         self.config.pluginmanager.consider_module(mod)\n         return mod\ndiff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex f7a026ae7..26f30621b 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Support for skip/xfail functions and markers.\"\"\"\n import os\n import platform\n@@ -18,6 +19,7 @@ from _pytest.mark.structures import Mark\n from _pytest.nodes import Item\n from _pytest.outcomes import fail\n from _pytest.outcomes import skip\n+from _pytest.outcomes import skip_module\n from _pytest.outcomes import xfail\n from _pytest.reports import BaseReport\n from _pytest.runner import CallInfo\n@@ -47,7 +49,6 @@ def pytest_configure(config: Config) -> None:\n     if config.option.runxfail:\n         # yay a hack\n         import pytest\n-\n         old = pytest.xfail\n         config._cleanup.append(lambda: setattr(pytest, \"xfail\", old))\n \n",
    "variant_8": "diff --git a/src/_pytest/outcomes.py b/src/_pytest/outcomes.py\nindex 2addf5572..53561ae60 100644\n--- a/src/_pytest/outcomes.py\n+++ b/src/_pytest/outcomes.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Exception classes and constants handling test outcomes as well as\n functions creating them.\"\"\"\n import sys\n@@ -7,20 +8,14 @@ from typing import cast\n from typing import Optional\n from typing import Type\n from typing import TypeVar\n+from typing import NoReturn\n+from typing_extensions import Protocol\n+from typing import Generic\n+import warnings\n+from packaging.version import Version\n \n TYPE_CHECKING = False  # Avoid circular import through compat.\n \n-if TYPE_CHECKING:\n-    from typing import NoReturn\n-    from typing_extensions import Protocol\n-else:\n-    # typing.Protocol is only available starting from Python 3.8. It is also\n-    # available from typing_extensions, but we don't want a runtime dependency\n-    # on that. So use a dummy runtime implementation.\n-    from typing import Generic\n-\n-    Protocol = Generic\n-\n \n class OutcomeException(BaseException):\n     \"\"\"OutcomeException and its subclass instances indicate and contain info\n@@ -28,6 +23,10 @@ class OutcomeException(BaseException):\n \n     def __init__(self, msg: Optional[str] = None, pytrace: bool = True) -> None:\n         if msg is not None and not isinstance(msg, str):\n+            error_msg = (  # type: ignore[unreachable]\n+                \"{} expected string as 'msg' parameter, got '{}' instead.\\n\"\n+                \"Perhaps you meant to use a mark?\"\n+            )\n             error_msg = (  # type: ignore[unreachable]\n                 \"{} expected string as 'msg' parameter, got '{}' instead.\\n\"\n                 \"Perhaps you meant to use a mark?\"\n@@ -120,6 +119,8 @@ def exit(msg: str, returncode: Optional[int] = None) -> \"NoReturn\":\n     raise Exit(msg, returncode)\n \n \n+@_with_exception(Skipped)\n+\n @_with_exception(Skipped)\n def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n     \"\"\"Skip an executing test with the given message.\n@@ -144,6 +145,17 @@ def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n     raise Skipped(msg=msg, allow_module_level=allow_module_level)\n \n \n+def skip_module(msg: str = \"\") -> \"NoReturn\":\n+    \"\"\"Skip the entire module with the given message.\n+    \n+    This is a convenience function equivalent to skip(msg, allow_module_level=True).\n+    Use this when you need to skip a module due to syntax compatibility or\n+    missing dependencies that would prevent the module from being processed.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    skip(msg=msg, allow_module_level=True)\n+\n+\n @_with_exception(Failed)\n def fail(msg: str = \"\", pytrace: bool = True) -> \"NoReturn\":\n     \"\"\"Explicitly fail an executing test with the given message.\ndiff --git a/src/_pytest/python.py b/src/_pytest/python.py\nindex 79dfb7320..a7a4c5eb8 100644\n--- a/src/_pytest/python.py\n+++ b/src/_pytest/python.py\n@@ -607,11 +607,15 @@ class Module(nodes.File, PyCollector):\n         except skip.Exception as e:\n             if e.allow_module_level:\n                 raise\n+\n             raise self.CollectError(\n                 \"Using pytest.skip outside of a test is not allowed. \"\n                 \"To decorate a test function, use the @pytest.mark.skip \"\n-                \"or @pytest.mark.skipif decorators instead, and to skip a \"\n-                \"module use `pytestmark = pytest.mark.{skip,skipif}.\"\n+                \"or @pytest.mark.skipif decorators instead. To skip a \"\n+                \"module, use `pytestmark = pytest.mark.{skip,skipif}` or \"\n+                \"call `skip(msg='reason', allow_module_level=True)` for \"\n+                \"modules with syntax incompatible with older Python versions.\"\n+            ) from e\n             ) from e\n         self.config.pluginmanager.consider_module(mod)\n         return mod\ndiff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex f7a026ae7..125324f7f 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Support for skip/xfail functions and markers.\"\"\"\n import os\n import platform\n@@ -47,7 +48,6 @@ def pytest_configure(config: Config) -> None:\n     if config.option.runxfail:\n         # yay a hack\n         import pytest\n-\n         old = pytest.xfail\n         config._cleanup.append(lambda: setattr(pytest, \"xfail\", old))\n \n"
  }
}