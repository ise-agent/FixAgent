{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/matplotlib/lib/matplotlib/axis.py lines 1240-1248)": "\n        if emit:\n            self.axes.callbacks.process(f\"{name}lim_changed\", self.axes)\n            # Call all of the other axes that are shared with this one\n            for other in self._get_shared_axes():\n                if other is not self.axes:\n                    other._axis_map[name]._set_lim(\n                        v0, v1, emit=False, auto=auto)\n                    # Emit callbacks for shared axes to ensure listeners are notified\n                    other.callbacks.process(f\"{name}lim_changed\", other)\n                    if other.figure != self.figure:\n                        other.figure.canvas.draw_idle()\n",
    "Location 2 (/root/hy/projects_3/matplotlib/lib/matplotlib/axes/_base.py lines 3636-3646)": "\n        if right is None and np.iterable(left):\n            left, right = left\n        if xmin is not None:\n            if left is not None:\n                raise TypeError(\"Cannot pass both 'left' and 'xmin'\")\n            left = xmin\n        if xmax is not None:\n            if right is not None:\n                raise TypeError(\"Cannot pass both 'right' and 'xmax'\")\n            right = xmax\n        return self.xaxis._set_lim(left, right, emit=emit, auto=auto)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/matplotlib/lib/matplotlib/axis.py lines 1240-1248)": [
      "\n        if emit:\n            self.axes.callbacks.process(f\"{name}lim_changed\", self.axes)\n            # Call all of the other axes that are shared with this one\n            for other in self._get_shared_axes():\n                if other is not self.axes:\n                    other._axis_map[name]._set_lim(\n                        v0, v1, emit=False, auto=auto)\n                    # Emit callbacks for shared axes after updating their limits\n                    other.callbacks.process(f\"{name}lim_changed\", other)\n                    if other.figure != self.figure:\n                        other.figure.canvas.draw_idle()\n",
      "\n        if emit:\n            self.axes.callbacks.process(f\"{name}lim_changed\", self.axes)\n            # Call all of the other axes that are shared with this one\n            for other in self._get_shared_axes():\n                if other is not self.axes:\n                    other._axis_map[name]._set_lim(\n                        v0, v1, emit=False, auto=auto)\n                    # Emit callbacks for shared axes after updating their limits\n                    other.callbacks.process(f\"{name}lim_changed\", other)\n                    if other.figure != self.figure:\n                        other.figure.canvas.draw_idle()\n",
      "\n        if emit:\n            self.axes.callbacks.process(f\"{name}lim_changed\", self.axes)\n            # Call all of the other axes that are shared with this one\n            for other in self._get_shared_axes():\n                if other is not self.axes:\n                    other._axis_map[name]._set_lim(\n                        v0, v1, emit=False, auto=auto)\n                    # Emit callback for shared axes after updating their limits\n                    other.callbacks.process(f\"{name}lim_changed\", other)\n                    if other.figure != self.figure:\n                        other.figure.canvas.draw_idle()\n",
      "\n        if emit:\n            self.axes.callbacks.process(f\"{name}lim_changed\", self.axes)\n            # Call all of the other axes that are shared with this one\n            for other in self._get_shared_axes():\n                if other is not self.axes:\n                    other._axis_map[name]._set_lim(\n                        v0, v1, emit=False, auto=auto)\n                    # Emit callbacks for shared axes after updating their limits\n                    other.callbacks.process(f\"{name}lim_changed\", other)\n                    if other.figure != self.figure:\n                        other.figure.canvas.draw_idle()\n",
      "\n        if emit:\n            self.axes.callbacks.process(f\"{name}lim_changed\", self.axes)\n            # Call all of the other axes that are shared with this one\n            for other in self._get_shared_axes():\n                if other is not self.axes:\n                    other._axis_map[name]._set_lim(\n                        v0, v1, emit=False, auto=auto)\n                    # Emit callback for shared axes after updating their limits\n                    other.callbacks.process(f\"{name}lim_changed\", other)\n                    if other.figure != self.figure:\n                        other.figure.canvas.draw_idle()\n",
      "\n        if emit:\n            self.axes.callbacks.process(f\"{name}lim_changed\", self.axes)\n            # Call all of the other axes that are shared with this one\n            for other in self._get_shared_axes():\n                if other is not self.axes:\n                    other._axis_map[name]._set_lim(\n                        v0, v1, emit=False, auto=auto)\n                    # Emit callbacks for shared axes after updating their limits\n                    other.callbacks.process(f\"{name}lim_changed\", other)\n                    if other.figure != self.figure:\n                        other.figure.canvas.draw_idle()\n",
      "\n        if emit:\n            self.axes.callbacks.process(f\"{name}lim_changed\", self.axes)\n            # Call all of the other axes that are shared with this one\n            for other in self._get_shared_axes():\n                if other is not self.axes:\n                    other._axis_map[name]._set_lim(\n                        v0, v1, emit=False, auto=auto)\n                    # Emit callback for shared axes after updating their limits\n                    other.callbacks.process(f\"{name}lim_changed\", other)\n                    if other.figure != self.figure:\n                        other.figure.canvas.draw_idle()\n",
      "\n        if emit:\n            self.axes.callbacks.process(f\"{name}lim_changed\", self.axes)\n            # Call all of the other axes that are shared with this one\n            for other in self._get_shared_axes():\n                if other is not self.axes:\n                    other._axis_map[name]._set_lim(\n                        v0, v1, emit=False, auto=auto)\n                    # Emit callback for shared axes after updating their limits\n                    other.callbacks.process(f\"{name}lim_changed\", other)\n                    if other.figure != self.figure:\n                        other.figure.canvas.draw_idle()\n"
    ],
    "Location 2 (/root/hy/projects_3/matplotlib/lib/matplotlib/axes/_base.py lines 3636-3646)": [
      "\n        if right is None and np.iterable(left):\n            left, right = left\n        if xmin is not None:\n            if left is not None:\n                raise TypeError(\"Cannot pass both 'left' and 'xmin'\")\n            left = xmin\n        if xmax is not None:\n            if right is not None:\n                raise TypeError(\"Cannot pass both 'right' and 'xmax'\")\n            right = xmax\n        return self.xaxis._set_lim(left, right, emit=emit, auto=auto)\n",
      "\n        if right is None and np.iterable(left):\n            left, right = left\n        if xmin is not None:\n            if left is not None:\n                raise TypeError(\"Cannot pass both 'left' and 'xmin'\")\n            left = xmin\n        if xmax is not None:\n            if right is not None:\n                raise TypeError(\"Cannot pass both 'right' and 'xmax'\")\n            right = xmax\n        return self.xaxis._set_lim(left, right, emit=emit, auto=auto)\n",
      "\n        if right is None and np.iterable(left):\n            left, right = left\n        if xmin is not None:\n            if left is not None:\n                raise TypeError(\"Cannot pass both 'left' and 'xmin'\")\n            left = xmin\n        if xmax is not None:\n            if right is not None:\n                raise TypeError(\"Cannot pass both 'right' and 'xmax'\")\n            right = xmax\n        return self.xaxis._set_lim(left, right, emit=emit, auto=auto)\n",
      "\n    def _set_lim(self, v0, v1, *, emit=True, auto):\n        \"\"\"\n        Set the lower and upper numerical limits of this axis.\n\n        This method is for internal use; end users should use\n        `~.axes.Axes.set_xlim` or `~.axes.Axes.set_ylim`.\n\n        Parameters\n        ----------\n        v0, v1 : float\n            The lower and upper bounds. If *auto* is True (the default),\n            None is interpreted as keeping the existing value.\n        emit : bool, default: True\n            Notify observers of limit change.\n        auto : bool or None, default: True\n            Turn *v0* and *v1* autoscaling on (True) or off (False).\n            If None, leave unchanged.\n        \"\"\"\n        if v0 is None and v1 is None:\n            # If both v0 and v1 are None, there's nothing to do.\n            return v0, v1\n\n        # In data coordinates, the axis limits are v0 and v1. In view\n        # coordinates, they are 0 and 1.\n        old_data_lim = self.get_view_interval()\n        if v0 is None:\n            v0 = old_data_lim[0]\n        if v1 is None:\n            v1 = old_data_lim[1]\n\n        if v0 == v1:\n            _api.warn_external(\n                f\"Attempting to set identical left == right == {v0} results \"\n                f\"in singular transformations; automatically expanding.\")\n\n        reverse = v0 > v1\n        if reverse:\n            v0, v1 = v1, v0\n        v0, v1 = self.get_major_locator().nonsingular(v0, v1)\n        if reverse:\n            v0, v1 = v1, v0\n        self.set_view_interval(v0, v1, ignore=True)\n\n        # Mark viewlims as no longer stale without triggering an autoscale.\n        for ax in self._get_axis_list():\n            ax._unstale_viewLim()\n\n        if auto is not None:\n            self.set_auto(auto)\n\n        # Emit callbacks on shared axes first to prevent recursion\n        if emit:\n            for other in self._get_shared_axis():\n                if other is not self:\n                    other.callbacks.process(f'{self.axis_name}lim_changed', other.axes)\n        \n        # Update shared axes without emitting their callbacks to prevent recursion\n        for other in self._get_shared_axis():\n            if other is not self:\n                other.set_view_interval(v0, v1, ignore=True)\n                if auto is not None:\n                    other.set_auto(auto)\n        \n        # Emit callback on the primary axis\n        if emit:\n            self.callbacks.process(f'{self.axis_name}lim_changed', self.axes)\n\n        return v0, v1\n",
      "\n    def _set_lim(self, v0, v1, *, emit=True, auto):\n        \"\"\"\n        Set the lower and upper numerical limits of this axis.\n\n        This method is for internal use; end users should use\n        `.set_xlim`, `.set_ylim`, etc.\n\n        Parameters\n        ----------\n        v0, v1 : float\n            The lower and upper bounds of the axis.\n        emit : bool, default: True\n            Whether to notify observers of limit change.\n        auto : bool or None\n            Whether to turn on autoscaling of the axis.  True turns on,\n            False turns off, None leaves unchanged.\n        \"\"\"\n        if v0 is None and v1 is None:\n            # If both limits are None, autoscale the view.\n            self._set_autoscale_on(True)\n            self.axes.autoscale_view(**{f\"scale{self.axis_name}\": True})\n            return\n\n        old_auto = self._get_autoscale_on()\n        if auto is not None:\n            self._set_autoscale_on(auto)\n        if self._get_autoscale_on():\n            # If autoscale is on, use the locator to get the view limits,\n            # instead of the data limits that we would get from\n            # update_datalim().  This also ensures that the view limits are\n            # \"reasonable\" values (e.g. AutoLocators will try to pick\n            # \"round\" values).\n            self.axes.autoscale_view(**{f\"scale{self.axis_name}\": False})\n        v0, v1 = self.get_view_interval()\n        if auto is None:\n            self._set_autoscale_on(old_auto)\n\n        if v0 != self.get_view_interval()[0] or v1 != self.get_view_interval()[1]:\n            self.set_view_interval(v0, v1, ignore=True)\n            \n            # Update shared axes without emitting callbacks to prevent recursion\n            for other in self._get_shared_axes().get_siblings(self.axes):\n                if other is not self.axes:\n                    getattr(other, f\"{self.axis_name}axis\")._set_lim(\n                        v0, v1, emit=False, auto=auto)\n            \n            # Emit callbacks for all axes (including shared ones) after all limits are set\n            if emit:\n                self.axes.callbacks.process(f'{self.axis_name}lim_changed', self.axes)\n                for other in self._get_shared_axes().get_siblings(self.axes):\n                    if other is not self.axes:\n                        other.callbacks.process(f'{self.axis_name}lim_changed', other)\n        return v0, v1\n",
      "\n        if right is None and np.iterable(left):\n            left, right = left\n        if xmin is not None:\n            if left is not None:\n                raise TypeError(\"Cannot pass both 'left' and 'xmin'\")\n            left = xmin\n        if xmax is not None:\n            if right is not None:\n                raise TypeError(\"Cannot pass both 'right' and 'xmax'\")\n            right = xmax\n        return self.xaxis._set_lim(left, right, emit=emit, auto=auto)\n",
      "\n        if right is None and np.iterable(left):\n            left, right = left\n        if xmin is not None:\n            if left is not None:\n                raise TypeError(\"Cannot pass both 'left' and 'xmin'\")\n            left = xmin\n        if xmax is not None:\n            if right is not None:\n                raise TypeError(\"Cannot pass both 'right' and 'xmax'\")\n            right = xmax\n        return self.xaxis._set_lim(left, right, emit=emit, auto=auto)\n",
      "\n        if left is None and right is None:\n            return self.get_view_interval()\n\n        old_left, old_right = self.get_view_interval()\n        if self._scale:\n            old_left, old_right = self._scale.limit_range_for_scale(\n                old_left, old_right, self.get_view_interval())\n        if left is None:\n            left = old_left\n        if right is None:\n            right = old_right\n\n        if self._scale:\n            left, right = self._scale.limit_range_for_scale(left, right,\n                                                           self.get_view_interval())\n        if left == old_left and right == old_right:\n            return (left, right)\n        # At this point we know the limits have changed\n        reverse = left > right\n        if reverse:\n            left, right = right, left\n        self.set_view_interval(left, right)\n        if reverse:\n            left, right = right, left\n        \n        # Handle shared axes updates without recursion\n        if emit and hasattr(self.axes, '_shared_axes'):\n            for ax in self._get_shared_axes():\n                if ax is not self.axes:\n                    getattr(ax, f'{self.axis_name}axis')._set_lim(\n                        left, right, emit=False, auto=auto)\n        \n        # Always emit callbacks after all axes are updated\n        if emit:\n            self._axis_callback()\n            # Also emit callbacks on shared axes that were updated with emit=False\n            if hasattr(self.axes, '_shared_axes'):\n                for ax in self._get_shared_axes():\n                    if ax is not self.axes:\n                        getattr(ax, f'{self.axis_name}axis')._axis_callback()\n\n        return (left, right)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 9c2ba63901..76666afa02 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -3633,6 +3633,7 @@ class _AxesBase(martist.Artist):\n \n         >>> set_xlim(5000, 0)\n         \"\"\"\n+\n         if right is None and np.iterable(left):\n             left, right = left\n         if xmin is not None:\ndiff --git a/lib/matplotlib/axis.py b/lib/matplotlib/axis.py\nindex e6e7e29f11..cd4f961a49 100644\n--- a/lib/matplotlib/axis.py\n+++ b/lib/matplotlib/axis.py\n@@ -1237,6 +1237,7 @@ class Axis(martist.Artist):\n         if auto is not None:\n             self._set_autoscale_on(bool(auto))\n \n+\n         if emit:\n             self.axes.callbacks.process(f\"{name}lim_changed\", self.axes)\n             # Call all of the other axes that are shared with this one\n@@ -1246,6 +1247,10 @@ class Axis(martist.Artist):\n                         v0, v1, emit=False, auto=auto)\n                     if other.figure != self.figure:\n                         other.figure.canvas.draw_idle()\n+            # Emit callbacks for all shared axes after updating their limits\n+            for other in self._get_shared_axes():\n+                if other is not self.axes:\n+                    other.callbacks.process(f\"{name}lim_changed\", other)\n \n         self.stale = True\n         return v0, v1\n",
    "variant_0": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 9c2ba63901..76666afa02 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -3633,6 +3633,7 @@ class _AxesBase(martist.Artist):\n \n         >>> set_xlim(5000, 0)\n         \"\"\"\n+\n         if right is None and np.iterable(left):\n             left, right = left\n         if xmin is not None:\ndiff --git a/lib/matplotlib/axis.py b/lib/matplotlib/axis.py\nindex e6e7e29f11..4ef041d526 100644\n--- a/lib/matplotlib/axis.py\n+++ b/lib/matplotlib/axis.py\n@@ -1237,6 +1237,7 @@ class Axis(martist.Artist):\n         if auto is not None:\n             self._set_autoscale_on(bool(auto))\n \n+\n         if emit:\n             self.axes.callbacks.process(f\"{name}lim_changed\", self.axes)\n             # Call all of the other axes that are shared with this one\n@@ -1244,6 +1245,8 @@ class Axis(martist.Artist):\n                 if other is not self.axes:\n                     other._axis_map[name]._set_lim(\n                         v0, v1, emit=False, auto=auto)\n+                    # Emit callbacks for shared axes to ensure listeners are notified\n+                    other.callbacks.process(f\"{name}lim_changed\", other)\n                     if other.figure != self.figure:\n                         other.figure.canvas.draw_idle()\n \n",
    "variant_1": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 9c2ba63901..76666afa02 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -3633,6 +3633,7 @@ class _AxesBase(martist.Artist):\n \n         >>> set_xlim(5000, 0)\n         \"\"\"\n+\n         if right is None and np.iterable(left):\n             left, right = left\n         if xmin is not None:\ndiff --git a/lib/matplotlib/axis.py b/lib/matplotlib/axis.py\nindex e6e7e29f11..de41724392 100644\n--- a/lib/matplotlib/axis.py\n+++ b/lib/matplotlib/axis.py\n@@ -1237,6 +1237,7 @@ class Axis(martist.Artist):\n         if auto is not None:\n             self._set_autoscale_on(bool(auto))\n \n+\n         if emit:\n             self.axes.callbacks.process(f\"{name}lim_changed\", self.axes)\n             # Call all of the other axes that are shared with this one\n@@ -1244,6 +1245,8 @@ class Axis(martist.Artist):\n                 if other is not self.axes:\n                     other._axis_map[name]._set_lim(\n                         v0, v1, emit=False, auto=auto)\n+                    # Emit callbacks for shared axes after updating their limits\n+                    other.callbacks.process(f\"{name}lim_changed\", other)\n                     if other.figure != self.figure:\n                         other.figure.canvas.draw_idle()\n \n",
    "variant_2": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 9c2ba63901..76666afa02 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -3633,6 +3633,7 @@ class _AxesBase(martist.Artist):\n \n         >>> set_xlim(5000, 0)\n         \"\"\"\n+\n         if right is None and np.iterable(left):\n             left, right = left\n         if xmin is not None:\ndiff --git a/lib/matplotlib/axis.py b/lib/matplotlib/axis.py\nindex e6e7e29f11..de41724392 100644\n--- a/lib/matplotlib/axis.py\n+++ b/lib/matplotlib/axis.py\n@@ -1237,6 +1237,7 @@ class Axis(martist.Artist):\n         if auto is not None:\n             self._set_autoscale_on(bool(auto))\n \n+\n         if emit:\n             self.axes.callbacks.process(f\"{name}lim_changed\", self.axes)\n             # Call all of the other axes that are shared with this one\n@@ -1244,6 +1245,8 @@ class Axis(martist.Artist):\n                 if other is not self.axes:\n                     other._axis_map[name]._set_lim(\n                         v0, v1, emit=False, auto=auto)\n+                    # Emit callbacks for shared axes after updating their limits\n+                    other.callbacks.process(f\"{name}lim_changed\", other)\n                     if other.figure != self.figure:\n                         other.figure.canvas.draw_idle()\n \n",
    "variant_3": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 9c2ba63901..76666afa02 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -3633,6 +3633,7 @@ class _AxesBase(martist.Artist):\n \n         >>> set_xlim(5000, 0)\n         \"\"\"\n+\n         if right is None and np.iterable(left):\n             left, right = left\n         if xmin is not None:\ndiff --git a/lib/matplotlib/axis.py b/lib/matplotlib/axis.py\nindex e6e7e29f11..a6fd0fb642 100644\n--- a/lib/matplotlib/axis.py\n+++ b/lib/matplotlib/axis.py\n@@ -1237,6 +1237,7 @@ class Axis(martist.Artist):\n         if auto is not None:\n             self._set_autoscale_on(bool(auto))\n \n+\n         if emit:\n             self.axes.callbacks.process(f\"{name}lim_changed\", self.axes)\n             # Call all of the other axes that are shared with this one\n@@ -1244,6 +1245,8 @@ class Axis(martist.Artist):\n                 if other is not self.axes:\n                     other._axis_map[name]._set_lim(\n                         v0, v1, emit=False, auto=auto)\n+                    # Emit callback for shared axes after updating their limits\n+                    other.callbacks.process(f\"{name}lim_changed\", other)\n                     if other.figure != self.figure:\n                         other.figure.canvas.draw_idle()\n \n",
    "variant_4": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 9c2ba63901..2f67beae53 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -3633,17 +3633,75 @@ class _AxesBase(martist.Artist):\n \n         >>> set_xlim(5000, 0)\n         \"\"\"\n-        if right is None and np.iterable(left):\n-            left, right = left\n-        if xmin is not None:\n-            if left is not None:\n-                raise TypeError(\"Cannot pass both 'left' and 'xmin'\")\n-            left = xmin\n-        if xmax is not None:\n-            if right is not None:\n-                raise TypeError(\"Cannot pass both 'right' and 'xmax'\")\n-            right = xmax\n-        return self.xaxis._set_lim(left, right, emit=emit, auto=auto)\n+\n+    def _set_lim(self, v0, v1, *, emit=True, auto):\n+        \"\"\"\n+        Set the lower and upper numerical limits of this axis.\n+\n+        This method is for internal use; end users should use\n+        `~.axes.Axes.set_xlim` or `~.axes.Axes.set_ylim`.\n+\n+        Parameters\n+        ----------\n+        v0, v1 : float\n+            The lower and upper bounds. If *auto* is True (the default),\n+            None is interpreted as keeping the existing value.\n+        emit : bool, default: True\n+            Notify observers of limit change.\n+        auto : bool or None, default: True\n+            Turn *v0* and *v1* autoscaling on (True) or off (False).\n+            If None, leave unchanged.\n+        \"\"\"\n+        if v0 is None and v1 is None:\n+            # If both v0 and v1 are None, there's nothing to do.\n+            return v0, v1\n+\n+        # In data coordinates, the axis limits are v0 and v1. In view\n+        # coordinates, they are 0 and 1.\n+        old_data_lim = self.get_view_interval()\n+        if v0 is None:\n+            v0 = old_data_lim[0]\n+        if v1 is None:\n+            v1 = old_data_lim[1]\n+\n+        if v0 == v1:\n+            _api.warn_external(\n+                f\"Attempting to set identical left == right == {v0} results \"\n+                f\"in singular transformations; automatically expanding.\")\n+\n+        reverse = v0 > v1\n+        if reverse:\n+            v0, v1 = v1, v0\n+        v0, v1 = self.get_major_locator().nonsingular(v0, v1)\n+        if reverse:\n+            v0, v1 = v1, v0\n+        self.set_view_interval(v0, v1, ignore=True)\n+\n+        # Mark viewlims as no longer stale without triggering an autoscale.\n+        for ax in self._get_axis_list():\n+            ax._unstale_viewLim()\n+\n+        if auto is not None:\n+            self.set_auto(auto)\n+\n+        # Emit callbacks on shared axes first to prevent recursion\n+        if emit:\n+            for other in self._get_shared_axis():\n+                if other is not self:\n+                    other.callbacks.process(f'{self.axis_name}lim_changed', other.axes)\n+        \n+        # Update shared axes without emitting their callbacks to prevent recursion\n+        for other in self._get_shared_axis():\n+            if other is not self:\n+                other.set_view_interval(v0, v1, ignore=True)\n+                if auto is not None:\n+                    other.set_auto(auto)\n+        \n+        # Emit callback on the primary axis\n+        if emit:\n+            self.callbacks.process(f'{self.axis_name}lim_changed', self.axes)\n+\n+        return v0, v1\n \n     get_xscale = _axis_method_wrapper(\"xaxis\", \"get_scale\")\n     set_xscale = _axis_method_wrapper(\"xaxis\", \"_set_axes_scale\")\ndiff --git a/lib/matplotlib/axis.py b/lib/matplotlib/axis.py\nindex e6e7e29f11..de41724392 100644\n--- a/lib/matplotlib/axis.py\n+++ b/lib/matplotlib/axis.py\n@@ -1237,6 +1237,7 @@ class Axis(martist.Artist):\n         if auto is not None:\n             self._set_autoscale_on(bool(auto))\n \n+\n         if emit:\n             self.axes.callbacks.process(f\"{name}lim_changed\", self.axes)\n             # Call all of the other axes that are shared with this one\n@@ -1244,6 +1245,8 @@ class Axis(martist.Artist):\n                 if other is not self.axes:\n                     other._axis_map[name]._set_lim(\n                         v0, v1, emit=False, auto=auto)\n+                    # Emit callbacks for shared axes after updating their limits\n+                    other.callbacks.process(f\"{name}lim_changed\", other)\n                     if other.figure != self.figure:\n                         other.figure.canvas.draw_idle()\n \n",
    "variant_5": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 9c2ba63901..16f35f18c5 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -3633,17 +3633,60 @@ class _AxesBase(martist.Artist):\n \n         >>> set_xlim(5000, 0)\n         \"\"\"\n-        if right is None and np.iterable(left):\n-            left, right = left\n-        if xmin is not None:\n-            if left is not None:\n-                raise TypeError(\"Cannot pass both 'left' and 'xmin'\")\n-            left = xmin\n-        if xmax is not None:\n-            if right is not None:\n-                raise TypeError(\"Cannot pass both 'right' and 'xmax'\")\n-            right = xmax\n-        return self.xaxis._set_lim(left, right, emit=emit, auto=auto)\n+\n+    def _set_lim(self, v0, v1, *, emit=True, auto):\n+        \"\"\"\n+        Set the lower and upper numerical limits of this axis.\n+\n+        This method is for internal use; end users should use\n+        `.set_xlim`, `.set_ylim`, etc.\n+\n+        Parameters\n+        ----------\n+        v0, v1 : float\n+            The lower and upper bounds of the axis.\n+        emit : bool, default: True\n+            Whether to notify observers of limit change.\n+        auto : bool or None\n+            Whether to turn on autoscaling of the axis.  True turns on,\n+            False turns off, None leaves unchanged.\n+        \"\"\"\n+        if v0 is None and v1 is None:\n+            # If both limits are None, autoscale the view.\n+            self._set_autoscale_on(True)\n+            self.axes.autoscale_view(**{f\"scale{self.axis_name}\": True})\n+            return\n+\n+        old_auto = self._get_autoscale_on()\n+        if auto is not None:\n+            self._set_autoscale_on(auto)\n+        if self._get_autoscale_on():\n+            # If autoscale is on, use the locator to get the view limits,\n+            # instead of the data limits that we would get from\n+            # update_datalim().  This also ensures that the view limits are\n+            # \"reasonable\" values (e.g. AutoLocators will try to pick\n+            # \"round\" values).\n+            self.axes.autoscale_view(**{f\"scale{self.axis_name}\": False})\n+        v0, v1 = self.get_view_interval()\n+        if auto is None:\n+            self._set_autoscale_on(old_auto)\n+\n+        if v0 != self.get_view_interval()[0] or v1 != self.get_view_interval()[1]:\n+            self.set_view_interval(v0, v1, ignore=True)\n+            \n+            # Update shared axes without emitting callbacks to prevent recursion\n+            for other in self._get_shared_axes().get_siblings(self.axes):\n+                if other is not self.axes:\n+                    getattr(other, f\"{self.axis_name}axis\")._set_lim(\n+                        v0, v1, emit=False, auto=auto)\n+            \n+            # Emit callbacks for all axes (including shared ones) after all limits are set\n+            if emit:\n+                self.axes.callbacks.process(f'{self.axis_name}lim_changed', self.axes)\n+                for other in self._get_shared_axes().get_siblings(self.axes):\n+                    if other is not self.axes:\n+                        other.callbacks.process(f'{self.axis_name}lim_changed', other)\n+        return v0, v1\n \n     get_xscale = _axis_method_wrapper(\"xaxis\", \"get_scale\")\n     set_xscale = _axis_method_wrapper(\"xaxis\", \"_set_axes_scale\")\ndiff --git a/lib/matplotlib/axis.py b/lib/matplotlib/axis.py\nindex e6e7e29f11..a6fd0fb642 100644\n--- a/lib/matplotlib/axis.py\n+++ b/lib/matplotlib/axis.py\n@@ -1237,6 +1237,7 @@ class Axis(martist.Artist):\n         if auto is not None:\n             self._set_autoscale_on(bool(auto))\n \n+\n         if emit:\n             self.axes.callbacks.process(f\"{name}lim_changed\", self.axes)\n             # Call all of the other axes that are shared with this one\n@@ -1244,6 +1245,8 @@ class Axis(martist.Artist):\n                 if other is not self.axes:\n                     other._axis_map[name]._set_lim(\n                         v0, v1, emit=False, auto=auto)\n+                    # Emit callback for shared axes after updating their limits\n+                    other.callbacks.process(f\"{name}lim_changed\", other)\n                     if other.figure != self.figure:\n                         other.figure.canvas.draw_idle()\n \n",
    "variant_6": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 9c2ba63901..76666afa02 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -3633,6 +3633,7 @@ class _AxesBase(martist.Artist):\n \n         >>> set_xlim(5000, 0)\n         \"\"\"\n+\n         if right is None and np.iterable(left):\n             left, right = left\n         if xmin is not None:\ndiff --git a/lib/matplotlib/axis.py b/lib/matplotlib/axis.py\nindex e6e7e29f11..de41724392 100644\n--- a/lib/matplotlib/axis.py\n+++ b/lib/matplotlib/axis.py\n@@ -1237,6 +1237,7 @@ class Axis(martist.Artist):\n         if auto is not None:\n             self._set_autoscale_on(bool(auto))\n \n+\n         if emit:\n             self.axes.callbacks.process(f\"{name}lim_changed\", self.axes)\n             # Call all of the other axes that are shared with this one\n@@ -1244,6 +1245,8 @@ class Axis(martist.Artist):\n                 if other is not self.axes:\n                     other._axis_map[name]._set_lim(\n                         v0, v1, emit=False, auto=auto)\n+                    # Emit callbacks for shared axes after updating their limits\n+                    other.callbacks.process(f\"{name}lim_changed\", other)\n                     if other.figure != self.figure:\n                         other.figure.canvas.draw_idle()\n \n",
    "variant_7": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 9c2ba63901..76666afa02 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -3633,6 +3633,7 @@ class _AxesBase(martist.Artist):\n \n         >>> set_xlim(5000, 0)\n         \"\"\"\n+\n         if right is None and np.iterable(left):\n             left, right = left\n         if xmin is not None:\ndiff --git a/lib/matplotlib/axis.py b/lib/matplotlib/axis.py\nindex e6e7e29f11..a6fd0fb642 100644\n--- a/lib/matplotlib/axis.py\n+++ b/lib/matplotlib/axis.py\n@@ -1237,6 +1237,7 @@ class Axis(martist.Artist):\n         if auto is not None:\n             self._set_autoscale_on(bool(auto))\n \n+\n         if emit:\n             self.axes.callbacks.process(f\"{name}lim_changed\", self.axes)\n             # Call all of the other axes that are shared with this one\n@@ -1244,6 +1245,8 @@ class Axis(martist.Artist):\n                 if other is not self.axes:\n                     other._axis_map[name]._set_lim(\n                         v0, v1, emit=False, auto=auto)\n+                    # Emit callback for shared axes after updating their limits\n+                    other.callbacks.process(f\"{name}lim_changed\", other)\n                     if other.figure != self.figure:\n                         other.figure.canvas.draw_idle()\n \n",
    "variant_8": "diff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 9c2ba63901..2150152ea6 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -3633,17 +3633,49 @@ class _AxesBase(martist.Artist):\n \n         >>> set_xlim(5000, 0)\n         \"\"\"\n-        if right is None and np.iterable(left):\n-            left, right = left\n-        if xmin is not None:\n-            if left is not None:\n-                raise TypeError(\"Cannot pass both 'left' and 'xmin'\")\n-            left = xmin\n-        if xmax is not None:\n-            if right is not None:\n-                raise TypeError(\"Cannot pass both 'right' and 'xmax'\")\n-            right = xmax\n-        return self.xaxis._set_lim(left, right, emit=emit, auto=auto)\n+\n+        if left is None and right is None:\n+            return self.get_view_interval()\n+\n+        old_left, old_right = self.get_view_interval()\n+        if self._scale:\n+            old_left, old_right = self._scale.limit_range_for_scale(\n+                old_left, old_right, self.get_view_interval())\n+        if left is None:\n+            left = old_left\n+        if right is None:\n+            right = old_right\n+\n+        if self._scale:\n+            left, right = self._scale.limit_range_for_scale(left, right,\n+                                                           self.get_view_interval())\n+        if left == old_left and right == old_right:\n+            return (left, right)\n+        # At this point we know the limits have changed\n+        reverse = left > right\n+        if reverse:\n+            left, right = right, left\n+        self.set_view_interval(left, right)\n+        if reverse:\n+            left, right = right, left\n+        \n+        # Handle shared axes updates without recursion\n+        if emit and hasattr(self.axes, '_shared_axes'):\n+            for ax in self._get_shared_axes():\n+                if ax is not self.axes:\n+                    getattr(ax, f'{self.axis_name}axis')._set_lim(\n+                        left, right, emit=False, auto=auto)\n+        \n+        # Always emit callbacks after all axes are updated\n+        if emit:\n+            self._axis_callback()\n+            # Also emit callbacks on shared axes that were updated with emit=False\n+            if hasattr(self.axes, '_shared_axes'):\n+                for ax in self._get_shared_axes():\n+                    if ax is not self.axes:\n+                        getattr(ax, f'{self.axis_name}axis')._axis_callback()\n+\n+        return (left, right)\n \n     get_xscale = _axis_method_wrapper(\"xaxis\", \"get_scale\")\n     set_xscale = _axis_method_wrapper(\"xaxis\", \"_set_axes_scale\")\ndiff --git a/lib/matplotlib/axis.py b/lib/matplotlib/axis.py\nindex e6e7e29f11..a6fd0fb642 100644\n--- a/lib/matplotlib/axis.py\n+++ b/lib/matplotlib/axis.py\n@@ -1237,6 +1237,7 @@ class Axis(martist.Artist):\n         if auto is not None:\n             self._set_autoscale_on(bool(auto))\n \n+\n         if emit:\n             self.axes.callbacks.process(f\"{name}lim_changed\", self.axes)\n             # Call all of the other axes that are shared with this one\n@@ -1244,6 +1245,8 @@ class Axis(martist.Artist):\n                 if other is not self.axes:\n                     other._axis_map[name]._set_lim(\n                         v0, v1, emit=False, auto=auto)\n+                    # Emit callback for shared axes after updating their limits\n+                    other.callbacks.process(f\"{name}lim_changed\", other)\n                     if other.figure != self.figure:\n                         other.figure.canvas.draw_idle()\n \n"
  }
}