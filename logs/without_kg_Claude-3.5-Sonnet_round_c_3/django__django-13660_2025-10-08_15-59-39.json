{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/django/django/core/management/commands/shell.py lines 86-88)": "\n    def handle(self, **options):\n        # Execute the command and exit.\n        if options['command']:\n            exec(options['command'], {})\n            return\n\n        # Execute stdin if it has anything to read and exit.\n        # Not supported on Windows due to select.select() limitations.\n        if sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n            exec(sys.stdin.read(), {})\n            return\n\n        available_shells = [options['interface']] if options['interface'] else self.shells\n\n        for shell in available_shells:\n",
    "Location 2 (/root/hy/projects_3/django/django/core/management/commands/shell.py lines 92-94)": "\n    def handle(self, **options):\n        # Execute the command and exit.\n        if options['command']:\n            exec(options['command'], {})\n            return\n\n        # Execute stdin if it has anything to read and exit.\n        # Not supported on Windows due to select.select() limitations.\n        if sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n            exec(sys.stdin.read(), {})\n            return\n\n        available_shells = [options['interface']] if options['interface'] else self.shells\n\n        for shell in available_shells:\n            try:\n                return getattr(self, shell)(options)\n            except ImportError:\n                pass\n        raise CommandError(\"Couldn't import {} interface.\".format(shell))\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/django/django/core/management/commands/shell.py lines 86-88)": [
      "\n    def handle(self, **options):\n        # Execute the command and exit.\n        if options['command']:\n            exec(options['command'], {})\n            return\n\n        # Execute stdin if it has anything to read and exit.\n        # Not supported on Windows due to select.select() limitations.\n        if sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n            exec(sys.stdin.read(), {})\n            return\n\n        available_shells = [options['interface']] if options['interface'] else self.shells\n\n        for shell in available_shells:\n",
      "\n    def handle(self, **options):\n        # Execute the command and exit.\n        if options['command']:\n            exec(options['command'], {})\n            return\n\n        # Execute stdin if it has anything to read and exit.\n        # Not supported on Windows due to select.select() limitations.\n        if sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n            exec(sys.stdin.read(), {})\n            return\n\n        available_shells = [options['interface']] if options['interface'] else self.shells\n\n        for shell in available_shells:\n",
      "\n    def handle(self, **options):\n        # Execute the command and exit.\n        if options['command']:\n            exec(options['command'], {})\n            return\n\n        # Execute stdin if it has anything to read and exit.\n        # Not supported on Windows due to select.select() limitations.\n        if sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n            exec(sys.stdin.read(), {})\n            return\n\n        available_shells = [options['interface']] if options['interface'] else self.shells\n\n        for shell in available_shells:\n",
      "\n    def handle(self, **options):\n        # Execute the command and exit.\n        if options['command']:\n            exec(options['command'], {})\n            return\n\n        # Execute stdin if it has anything to read and exit.\n        # Not supported on Windows due to select.select() limitations.\n        if sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n            exec(sys.stdin.read(), {})\n            return\n\n        available_shells = [options['interface']] if options['interface'] else self.shells\n\n        for shell in available_shells:\n",
      "\n    def handle(self, **options):\n        # Execute the command and exit.\n        if options['command']:\n            exec(options['command'], {})\n            return\n\n        # Execute stdin if it has anything to read and exit.\n        # Not supported on Windows due to select.select() limitations.\n        if sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n            exec(sys.stdin.read(), {})\n            return\n\n        available_shells = [options['interface']] if options['interface'] else self.shells\n\n        for shell in available_shells:\n",
      "\n    def handle(self, **options):\n        # Execute the command and exit.\n        if options['command']:\n            exec(options['command'], {})\n            return\n\n        # Execute stdin if it has anything to read and exit.\n        # Not supported on Windows due to select.select() limitations.\n        if sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n            exec(sys.stdin.read(), {})\n            return\n\n        available_shells = [options['interface']] if options['interface'] else self.shells\n\n        for shell in available_shells:\n",
      "\n    def handle(self, **options):\n        # Execute the command and exit.\n        if options['command']:\n            exec(options['command'], {})\n            return\n\n        # Execute stdin if it has anything to read and exit.\n        # Not supported on Windows due to select.select() limitations.\n        if sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n            exec(sys.stdin.read(), {})\n            return\n\n        available_shells = [options['interface']] if options['interface'] else self.shells\n\n        for shell in available_shells:\n",
      "\n    def handle(self, **options):\n        # Execute the command and exit.\n        if options['command']:\n            exec(options['command'], {})\n            return\n\n        # Execute stdin if it has anything to read and exit.\n        # Not supported on Windows due to select.select() limitations.\n        if sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n            exec(sys.stdin.read(), {})\n            return\n"
    ],
    "Location 2 (/root/hy/projects_3/django/django/core/management/commands/shell.py lines 92-94)": [
      "\n    def handle(self, **options):\n        # Execute the command and exit.\n        if options['command']:\n            exec(options['command'], {})\n            return\n\n        # Execute stdin if it has anything to read and exit.\n        # Not supported on Windows due to select.select() limitations.\n        if sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n            exec(sys.stdin.read(), {})\n            return\n\n        available_shells = [options['interface']] if options['interface'] else self.shells\n\n        for shell in available_shells:\n            try:\n                return getattr(self, shell)(options)\n            except ImportError:\n                pass\n        raise CommandError(\"Couldn't import {} interface.\".format(shell))\n",
      "\n    def handle(self, **options):\n        # Execute the command and exit.\n        if options['command']:\n            exec(options['command'], {})\n            return\n\n        # Execute stdin if it has anything to read and exit.\n        # Not supported on Windows due to select.select() limitations.\n        if sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n            exec(sys.stdin.read(), {})\n            return\n\n        available_shells = [options['interface']] if options['interface'] else self.shells\n\n        for shell in available_shells:\n            try:\n                return getattr(self, shell)(options)\n            except ImportError:\n                pass\n        raise CommandError(\"Couldn't import {} interface.\".format(shell))\n",
      "\n    def handle(self, **options):\n        # Execute the command and exit.\n        if options['command']:\n            exec(options['command'], {})\n            return\n\n        # Execute stdin if it has anything to read and exit.\n        # Not supported on Windows due to select.select() limitations.\n        if sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n            exec(sys.stdin.read(), {})\n            return\n\n        available_shells = [options['interface']] if options['interface'] else self.shells\n\n        for shell in available_shells:\n            try:\n                return getattr(self, shell)(options)\n            except ImportError:\n                pass\n        raise CommandError(\"Couldn't import {} interface.\".format(shell))\n",
      "\n    def handle(self, **options):\n        # Execute the command and exit.\n        if options['command']:\n            exec(options['command'], {})\n            return\n\n        # Execute stdin if it has anything to read and exit.\n        # Not supported on Windows due to select.select() limitations.\n        if sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n            exec(sys.stdin.read(), {})\n            return\n\n        available_shells = [options['interface']] if options['interface'] else self.shells\n\n        for shell in available_shells:\n            try:\n                return getattr(self, shell)(options)\n            except ImportError:\n                pass\n        raise CommandError(\"Couldn't import {} interface.\".format(shell))\n",
      "\n    def handle(self, **options):\n        # Execute the command and exit.\n        if options['command']:\n            exec(options['command'], {})\n            return\n\n        # Execute stdin if it has anything to read and exit.\n        # Not supported on Windows due to select.select() limitations.\n        if sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n            exec(sys.stdin.read(), {})\n            return\n\n        available_shells = [options['interface']] if options['interface'] else self.shells\n\n        for shell in available_shells:\n            try:\n                return getattr(self, shell)(options)\n            except ImportError:\n                pass\n        raise CommandError(\"Couldn't import {} interface.\".format(shell))\n",
      "\n    def handle(self, **options):\n        # Execute the command and exit.\n        if options['command']:\n            exec(options['command'], {})\n            return\n\n        # Execute stdin if it has anything to read and exit.\n        # Not supported on Windows due to select.select() limitations.\n        if sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n            exec(sys.stdin.read(), {})\n            return\n\n        available_shells = [options['interface']] if options['interface'] else self.shells\n\n        for shell in available_shells:\n            try:\n                return getattr(self, shell)(options)\n            except ImportError:\n                pass\n        raise CommandError(\"Couldn't import {} interface.\".format(shell))\n",
      "\n    def handle(self, **options):\n        # Execute the command and exit.\n        if options['command']:\n            exec(options['command'], {})\n            return\n\n        # Execute stdin if it has anything to read and exit.\n        # Not supported on Windows due to select.select() limitations.\n        if sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n            exec(sys.stdin.read(), {})\n            return\n",
      "\n    def handle(self, **options):\n        # Execute the command and exit.\n        if options['command']:\n            exec(options['command'], {})\n            return\n\n        # Execute stdin if it has anything to read and exit.\n        # Not supported on Windows due to select.select() limitations.\n        if sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n            exec(sys.stdin.read(), {})\n            return\n\n        available_shells = [options['interface']] if options['interface'] else self.shells\n\n        for shell in available_shells:\n            try:\n                return getattr(self, shell)(options)\n            except ImportError:\n                pass\n        raise CommandError(\"Couldn't import {} interface.\".format(shell))\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/core/management/commands/shell.py b/django/core/management/commands/shell.py\nindex 2b306a579e..707762825a 100644\n--- a/django/core/management/commands/shell.py\n+++ b/django/core/management/commands/shell.py\n@@ -83,14 +83,16 @@ class Command(BaseCommand):\n \n     def handle(self, **options):\n         # Execute the command and exit.\n+\n         if options['command']:\n-            exec(options['command'])\n+            exec(options['command'], {})\n             return\n \n         # Execute stdin if it has anything to read and exit.\n         # Not supported on Windows due to select.select() limitations.\n+\n         if sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n-            exec(sys.stdin.read())\n+            exec(sys.stdin.read(), {})\n             return\n \n         available_shells = [options['interface']] if options['interface'] else self.shells\n",
    "variant_0": "diff --git a/django/core/management/commands/shell.py b/django/core/management/commands/shell.py\nindex 2b306a579e..b7234168ed 100644\n--- a/django/core/management/commands/shell.py\n+++ b/django/core/management/commands/shell.py\n@@ -81,18 +81,49 @@ class Command(BaseCommand):\n \n         code.interact(local=imported_objects)\n \n+    def handle(self, **options):\n+        # Execute the command and exit.\n+\n     def handle(self, **options):\n         # Execute the command and exit.\n         if options['command']:\n-            exec(options['command'])\n+            exec(options['command'], {})\n             return\n \n         # Execute stdin if it has anything to read and exit.\n         # Not supported on Windows due to select.select() limitations.\n         if sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n-            exec(sys.stdin.read())\n+            exec(sys.stdin.read(), {})\n+            return\n+\n+        available_shells = [options['interface']] if options['interface'] else self.shells\n+\n+        for shell in available_shells:\n+\n+        # Execute stdin if it has anything to read and exit.\n+        # Not supported on Windows due to select.select() limitations.\n+\n+    def handle(self, **options):\n+        # Execute the command and exit.\n+        if options['command']:\n+            exec(options['command'], {})\n             return\n \n+        # Execute stdin if it has anything to read and exit.\n+        # Not supported on Windows due to select.select() limitations.\n+        if sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n+            exec(sys.stdin.read(), {})\n+            return\n+\n+        available_shells = [options['interface']] if options['interface'] else self.shells\n+\n+        for shell in available_shells:\n+            try:\n+                return getattr(self, shell)(options)\n+            except ImportError:\n+                pass\n+        raise CommandError(\"Couldn't import {} interface.\".format(shell))\n+\n         available_shells = [options['interface']] if options['interface'] else self.shells\n \n         for shell in available_shells:\n",
    "variant_1": "diff --git a/django/core/management/commands/shell.py b/django/core/management/commands/shell.py\nindex 2b306a579e..b7234168ed 100644\n--- a/django/core/management/commands/shell.py\n+++ b/django/core/management/commands/shell.py\n@@ -81,18 +81,49 @@ class Command(BaseCommand):\n \n         code.interact(local=imported_objects)\n \n+    def handle(self, **options):\n+        # Execute the command and exit.\n+\n     def handle(self, **options):\n         # Execute the command and exit.\n         if options['command']:\n-            exec(options['command'])\n+            exec(options['command'], {})\n             return\n \n         # Execute stdin if it has anything to read and exit.\n         # Not supported on Windows due to select.select() limitations.\n         if sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n-            exec(sys.stdin.read())\n+            exec(sys.stdin.read(), {})\n+            return\n+\n+        available_shells = [options['interface']] if options['interface'] else self.shells\n+\n+        for shell in available_shells:\n+\n+        # Execute stdin if it has anything to read and exit.\n+        # Not supported on Windows due to select.select() limitations.\n+\n+    def handle(self, **options):\n+        # Execute the command and exit.\n+        if options['command']:\n+            exec(options['command'], {})\n             return\n \n+        # Execute stdin if it has anything to read and exit.\n+        # Not supported on Windows due to select.select() limitations.\n+        if sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n+            exec(sys.stdin.read(), {})\n+            return\n+\n+        available_shells = [options['interface']] if options['interface'] else self.shells\n+\n+        for shell in available_shells:\n+            try:\n+                return getattr(self, shell)(options)\n+            except ImportError:\n+                pass\n+        raise CommandError(\"Couldn't import {} interface.\".format(shell))\n+\n         available_shells = [options['interface']] if options['interface'] else self.shells\n \n         for shell in available_shells:\n",
    "variant_2": "diff --git a/django/core/management/commands/shell.py b/django/core/management/commands/shell.py\nindex 2b306a579e..b7234168ed 100644\n--- a/django/core/management/commands/shell.py\n+++ b/django/core/management/commands/shell.py\n@@ -81,18 +81,49 @@ class Command(BaseCommand):\n \n         code.interact(local=imported_objects)\n \n+    def handle(self, **options):\n+        # Execute the command and exit.\n+\n     def handle(self, **options):\n         # Execute the command and exit.\n         if options['command']:\n-            exec(options['command'])\n+            exec(options['command'], {})\n             return\n \n         # Execute stdin if it has anything to read and exit.\n         # Not supported on Windows due to select.select() limitations.\n         if sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n-            exec(sys.stdin.read())\n+            exec(sys.stdin.read(), {})\n+            return\n+\n+        available_shells = [options['interface']] if options['interface'] else self.shells\n+\n+        for shell in available_shells:\n+\n+        # Execute stdin if it has anything to read and exit.\n+        # Not supported on Windows due to select.select() limitations.\n+\n+    def handle(self, **options):\n+        # Execute the command and exit.\n+        if options['command']:\n+            exec(options['command'], {})\n             return\n \n+        # Execute stdin if it has anything to read and exit.\n+        # Not supported on Windows due to select.select() limitations.\n+        if sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n+            exec(sys.stdin.read(), {})\n+            return\n+\n+        available_shells = [options['interface']] if options['interface'] else self.shells\n+\n+        for shell in available_shells:\n+            try:\n+                return getattr(self, shell)(options)\n+            except ImportError:\n+                pass\n+        raise CommandError(\"Couldn't import {} interface.\".format(shell))\n+\n         available_shells = [options['interface']] if options['interface'] else self.shells\n \n         for shell in available_shells:\n",
    "variant_3": "diff --git a/django/core/management/commands/shell.py b/django/core/management/commands/shell.py\nindex 2b306a579e..b7234168ed 100644\n--- a/django/core/management/commands/shell.py\n+++ b/django/core/management/commands/shell.py\n@@ -81,18 +81,49 @@ class Command(BaseCommand):\n \n         code.interact(local=imported_objects)\n \n+    def handle(self, **options):\n+        # Execute the command and exit.\n+\n     def handle(self, **options):\n         # Execute the command and exit.\n         if options['command']:\n-            exec(options['command'])\n+            exec(options['command'], {})\n             return\n \n         # Execute stdin if it has anything to read and exit.\n         # Not supported on Windows due to select.select() limitations.\n         if sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n-            exec(sys.stdin.read())\n+            exec(sys.stdin.read(), {})\n+            return\n+\n+        available_shells = [options['interface']] if options['interface'] else self.shells\n+\n+        for shell in available_shells:\n+\n+        # Execute stdin if it has anything to read and exit.\n+        # Not supported on Windows due to select.select() limitations.\n+\n+    def handle(self, **options):\n+        # Execute the command and exit.\n+        if options['command']:\n+            exec(options['command'], {})\n             return\n \n+        # Execute stdin if it has anything to read and exit.\n+        # Not supported on Windows due to select.select() limitations.\n+        if sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n+            exec(sys.stdin.read(), {})\n+            return\n+\n+        available_shells = [options['interface']] if options['interface'] else self.shells\n+\n+        for shell in available_shells:\n+            try:\n+                return getattr(self, shell)(options)\n+            except ImportError:\n+                pass\n+        raise CommandError(\"Couldn't import {} interface.\".format(shell))\n+\n         available_shells = [options['interface']] if options['interface'] else self.shells\n \n         for shell in available_shells:\n",
    "variant_4": "diff --git a/django/core/management/commands/shell.py b/django/core/management/commands/shell.py\nindex 2b306a579e..b7234168ed 100644\n--- a/django/core/management/commands/shell.py\n+++ b/django/core/management/commands/shell.py\n@@ -81,18 +81,49 @@ class Command(BaseCommand):\n \n         code.interact(local=imported_objects)\n \n+    def handle(self, **options):\n+        # Execute the command and exit.\n+\n     def handle(self, **options):\n         # Execute the command and exit.\n         if options['command']:\n-            exec(options['command'])\n+            exec(options['command'], {})\n             return\n \n         # Execute stdin if it has anything to read and exit.\n         # Not supported on Windows due to select.select() limitations.\n         if sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n-            exec(sys.stdin.read())\n+            exec(sys.stdin.read(), {})\n+            return\n+\n+        available_shells = [options['interface']] if options['interface'] else self.shells\n+\n+        for shell in available_shells:\n+\n+        # Execute stdin if it has anything to read and exit.\n+        # Not supported on Windows due to select.select() limitations.\n+\n+    def handle(self, **options):\n+        # Execute the command and exit.\n+        if options['command']:\n+            exec(options['command'], {})\n             return\n \n+        # Execute stdin if it has anything to read and exit.\n+        # Not supported on Windows due to select.select() limitations.\n+        if sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n+            exec(sys.stdin.read(), {})\n+            return\n+\n+        available_shells = [options['interface']] if options['interface'] else self.shells\n+\n+        for shell in available_shells:\n+            try:\n+                return getattr(self, shell)(options)\n+            except ImportError:\n+                pass\n+        raise CommandError(\"Couldn't import {} interface.\".format(shell))\n+\n         available_shells = [options['interface']] if options['interface'] else self.shells\n \n         for shell in available_shells:\n",
    "variant_5": "diff --git a/django/core/management/commands/shell.py b/django/core/management/commands/shell.py\nindex 2b306a579e..b7234168ed 100644\n--- a/django/core/management/commands/shell.py\n+++ b/django/core/management/commands/shell.py\n@@ -81,18 +81,49 @@ class Command(BaseCommand):\n \n         code.interact(local=imported_objects)\n \n+    def handle(self, **options):\n+        # Execute the command and exit.\n+\n     def handle(self, **options):\n         # Execute the command and exit.\n         if options['command']:\n-            exec(options['command'])\n+            exec(options['command'], {})\n             return\n \n         # Execute stdin if it has anything to read and exit.\n         # Not supported on Windows due to select.select() limitations.\n         if sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n-            exec(sys.stdin.read())\n+            exec(sys.stdin.read(), {})\n+            return\n+\n+        available_shells = [options['interface']] if options['interface'] else self.shells\n+\n+        for shell in available_shells:\n+\n+        # Execute stdin if it has anything to read and exit.\n+        # Not supported on Windows due to select.select() limitations.\n+\n+    def handle(self, **options):\n+        # Execute the command and exit.\n+        if options['command']:\n+            exec(options['command'], {})\n             return\n \n+        # Execute stdin if it has anything to read and exit.\n+        # Not supported on Windows due to select.select() limitations.\n+        if sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n+            exec(sys.stdin.read(), {})\n+            return\n+\n+        available_shells = [options['interface']] if options['interface'] else self.shells\n+\n+        for shell in available_shells:\n+            try:\n+                return getattr(self, shell)(options)\n+            except ImportError:\n+                pass\n+        raise CommandError(\"Couldn't import {} interface.\".format(shell))\n+\n         available_shells = [options['interface']] if options['interface'] else self.shells\n \n         for shell in available_shells:\n",
    "variant_6": "diff --git a/django/core/management/commands/shell.py b/django/core/management/commands/shell.py\nindex 2b306a579e..b7234168ed 100644\n--- a/django/core/management/commands/shell.py\n+++ b/django/core/management/commands/shell.py\n@@ -81,18 +81,49 @@ class Command(BaseCommand):\n \n         code.interact(local=imported_objects)\n \n+    def handle(self, **options):\n+        # Execute the command and exit.\n+\n     def handle(self, **options):\n         # Execute the command and exit.\n         if options['command']:\n-            exec(options['command'])\n+            exec(options['command'], {})\n             return\n \n         # Execute stdin if it has anything to read and exit.\n         # Not supported on Windows due to select.select() limitations.\n         if sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n-            exec(sys.stdin.read())\n+            exec(sys.stdin.read(), {})\n+            return\n+\n+        available_shells = [options['interface']] if options['interface'] else self.shells\n+\n+        for shell in available_shells:\n+\n+        # Execute stdin if it has anything to read and exit.\n+        # Not supported on Windows due to select.select() limitations.\n+\n+    def handle(self, **options):\n+        # Execute the command and exit.\n+        if options['command']:\n+            exec(options['command'], {})\n             return\n \n+        # Execute stdin if it has anything to read and exit.\n+        # Not supported on Windows due to select.select() limitations.\n+        if sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n+            exec(sys.stdin.read(), {})\n+            return\n+\n+        available_shells = [options['interface']] if options['interface'] else self.shells\n+\n+        for shell in available_shells:\n+            try:\n+                return getattr(self, shell)(options)\n+            except ImportError:\n+                pass\n+        raise CommandError(\"Couldn't import {} interface.\".format(shell))\n+\n         available_shells = [options['interface']] if options['interface'] else self.shells\n \n         for shell in available_shells:\n",
    "variant_7": "diff --git a/django/core/management/commands/shell.py b/django/core/management/commands/shell.py\nindex 2b306a579e..1af70063c6 100644\n--- a/django/core/management/commands/shell.py\n+++ b/django/core/management/commands/shell.py\n@@ -81,16 +81,38 @@ class Command(BaseCommand):\n \n         code.interact(local=imported_objects)\n \n+    def handle(self, **options):\n+        # Execute the command and exit.\n+\n+    def handle(self, **options):\n+        # Execute the command and exit.\n+        if options['command']:\n+            exec(options['command'], {})\n+            return\n+\n+        # Execute stdin if it has anything to read and exit.\n+        # Not supported on Windows due to select.select() limitations.\n+        if sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n+            exec(sys.stdin.read(), {})\n+            return\n+\n+        available_shells = [options['interface']] if options['interface'] else self.shells\n+\n+        for shell in available_shells:\n+\n+        # Execute stdin if it has anything to read and exit.\n+        # Not supported on Windows due to select.select() limitations.\n+\n     def handle(self, **options):\n         # Execute the command and exit.\n         if options['command']:\n-            exec(options['command'])\n+            exec(options['command'], {})\n             return\n \n         # Execute stdin if it has anything to read and exit.\n         # Not supported on Windows due to select.select() limitations.\n         if sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n-            exec(sys.stdin.read())\n+            exec(sys.stdin.read(), {})\n             return\n \n         available_shells = [options['interface']] if options['interface'] else self.shells\n",
    "variant_8": "diff --git a/django/core/management/commands/shell.py b/django/core/management/commands/shell.py\nindex 2b306a579e..669b57d8d9 100644\n--- a/django/core/management/commands/shell.py\n+++ b/django/core/management/commands/shell.py\n@@ -81,18 +81,45 @@ class Command(BaseCommand):\n \n         code.interact(local=imported_objects)\n \n+    def handle(self, **options):\n+        # Execute the command and exit.\n+\n     def handle(self, **options):\n         # Execute the command and exit.\n         if options['command']:\n-            exec(options['command'])\n+            exec(options['command'], {})\n             return\n \n         # Execute stdin if it has anything to read and exit.\n         # Not supported on Windows due to select.select() limitations.\n         if sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n-            exec(sys.stdin.read())\n+            exec(sys.stdin.read(), {})\n             return\n \n+        # Execute stdin if it has anything to read and exit.\n+        # Not supported on Windows due to select.select() limitations.\n+\n+    def handle(self, **options):\n+        # Execute the command and exit.\n+        if options['command']:\n+            exec(options['command'], {})\n+            return\n+\n+        # Execute stdin if it has anything to read and exit.\n+        # Not supported on Windows due to select.select() limitations.\n+        if sys.platform != 'win32' and not sys.stdin.isatty() and select.select([sys.stdin], [], [], 0)[0]:\n+            exec(sys.stdin.read(), {})\n+            return\n+\n+        available_shells = [options['interface']] if options['interface'] else self.shells\n+\n+        for shell in available_shells:\n+            try:\n+                return getattr(self, shell)(options)\n+            except ImportError:\n+                pass\n+        raise CommandError(\"Couldn't import {} interface.\".format(shell))\n+\n         available_shells = [options['interface']] if options['interface'] else self.shells\n \n         for shell in available_shells:\n"
  }
}