{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/sphinx/sphinx/domains/python.py lines 81-95)": "\ndef type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xref:\n    \"\"\"Convert a type string to a cross reference node.\"\"\"\n    if text == 'None':\n        reftype = 'obj'\n    else:\n        reftype = 'class'\n\n    # Handle module-qualified names (e.g., 'struct.Struct' -> module='struct', target='Struct')\n    if '.' in text and not text.startswith('.'):\n        # Split module.Class into components\n        parts = text.rsplit('.', 1)\n        if len(parts) == 2:\n            module_name, class_name = parts\n            target = class_name  # Use only class name as target\n            # Set module context for qualified names\n            if env:\n                kwargs = {'py:module': module_name,\n                         'py:class': env.ref_context.get('py:class')}\n            else:\n                kwargs = {'py:module': module_name}\n        else:\n            target = text\n            kwargs = {}\n    else:\n        target = text\n        kwargs = {}\n\n    # Add existing env context if available and not already set\n    if env and 'py:module' not in kwargs:\n        kwargs.update({'py:module': env.ref_context.get('py:module'),\n                      'py:class': env.ref_context.get('py:class')})\n\n    return pending_xref('', nodes.Text(text),\n                        refdomain='py', reftype=reftype, reftarget=target, **kwargs)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/sphinx/sphinx/domains/python.py lines 81-95)": [
      "\ndef type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xref:\n    \"\"\"Convert a type string to a cross reference node.\"\"\"\n    if text == 'None':\n        reftype = 'obj'\n    else:\n        reftype = 'class'\n\n    # Handle module-qualified names (e.g., 'struct.Struct' -> module='struct', target='Struct')\n    if '.' in text and not text.startswith('.'):\n        # Split module.Class into components\n        parts = text.rsplit('.', 1)\n        if len(parts) == 2:\n            module_name, class_name = parts\n            target = class_name  # Use only class name as target\n            # Set module context for qualified names\n            if env:\n                kwargs = {'py:module': module_name,\n                         'py:class': env.ref_context.get('py:class')}\n            else:\n                kwargs = {'py:module': module_name}\n        else:\n            target = text\n            if env:\n                kwargs = {'py:module': env.ref_context.get('py:module'),\n                         'py:class': env.ref_context.get('py:class')}\n            else:\n                kwargs = {}\n    else:\n        target = text\n        if env:\n            kwargs = {'py:module': env.ref_context.get('py:module'),\n                     'py:class': env.ref_context.get('py:class')}\n        else:\n            kwargs = {}\n\n    return pending_xref('', nodes.Text(text),\n                        refdomain='py', reftype=reftype, reftarget=target, **kwargs)\n",
      "\ndef type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xref:\n    \"\"\"Convert a type string to a cross reference node.\"\"\"\n    if text == 'None':\n        reftype = 'obj'\n    else:\n        reftype = 'class'\n\n    # Handle module-qualified names (e.g., 'struct.Struct' -> module='struct', target='Struct')\n    if '.' in text and not text.startswith('.'):\n        # Split module.Class into components\n        parts = text.rsplit('.', 1)\n        if len(parts) == 2:\n            module_name, class_name = parts\n            target = class_name  # Use only class name as target\n            # Set module context for qualified names\n            if env:\n                kwargs = {'py:module': module_name,\n                         'py:class': env.ref_context.get('py:class')}\n            else:\n                kwargs = {'py:module': module_name}\n        else:\n            target = text\n            kwargs = {}\n    else:\n        target = text\n        kwargs = {}\n\n    # Add existing env context if available and not already set\n    if env and 'py:module' not in kwargs:\n        kwargs.update({'py:module': env.ref_context.get('py:module'),\n                      'py:class': env.ref_context.get('py:class')})\n\n    return pending_xref('', nodes.Text(text),\n                        refdomain='py', reftype=reftype, reftarget=target, **kwargs)\n",
      "\ndef type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xref:\n    \"\"\"Convert a type string to a cross reference node.\"\"\"\n    if text == 'None':\n        reftype = 'obj'\n    else:\n        reftype = 'class'\n\n    # Handle module-qualified names (e.g., 'struct.Struct' -> module='struct', target='Struct')\n    if '.' in text and not text.startswith('.'):\n        # Split module.Class into components\n        parts = text.rsplit('.', 1)\n        if len(parts) == 2:\n            module_name, class_name = parts\n            target = class_name  # Use only class name as target\n            # Set module context for qualified names\n            if env:\n                kwargs = {'py:module': module_name,\n                         'py:class': env.ref_context.get('py:class')}\n            else:\n                kwargs = {'py:module': module_name}\n        else:\n            target = text\n            kwargs = {}\n    else:\n        target = text\n        kwargs = {}\n\n    # Add existing env context if available and not already set\n    if env and 'py:module' not in kwargs:\n        kwargs.update({'py:module': env.ref_context.get('py:module'),\n                      'py:class': env.ref_context.get('py:class')})\n\n    return pending_xref('', nodes.Text(text),\n                        refdomain='py', reftype=reftype, reftarget=target, **kwargs)\n",
      "\ndef type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xref:\n    \"\"\"Convert a type string to a cross reference node.\"\"\"\n    if text == 'None':\n        reftype = 'obj'\n    else:\n        reftype = 'class'\n\n    # Handle module-qualified names (e.g., 'struct.Struct' -> module='struct', target='Struct')\n    if '.' in text and not text.startswith('.'):\n        # Split module.Class into components\n        parts = text.rsplit('.', 1)\n        if len(parts) == 2:\n            module_name, class_name = parts\n            target = class_name  # Use only class name as target\n            # Set module context for qualified names\n            if env:\n                kwargs = {'py:module': module_name,\n                         'py:class': env.ref_context.get('py:class')}\n            else:\n                kwargs = {'py:module': module_name}\n        else:\n            target = text\n            kwargs = {}\n    else:\n        target = text\n        kwargs = {}\n\n    # Add existing env context if available and not already set\n    if env and 'py:module' not in kwargs:\n        kwargs.update({'py:module': env.ref_context.get('py:module'),\n                      'py:class': env.ref_context.get('py:class')})\n\n    return pending_xref('', nodes.Text(text),\n                        refdomain='py', reftype=reftype, reftarget=target, **kwargs)\n",
      "\ndef type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xref:\n    \"\"\"Convert a type string to a cross reference node.\"\"\"\n    if text == 'None':\n        reftype = 'obj'\n    else:\n        reftype = 'class'\n\n    # Handle module-qualified names (e.g., 'struct.Struct' -> module='struct', target='Struct')\n    if '.' in text and not text.startswith('.'):\n        # Split module.Class into components\n        parts = text.rsplit('.', 1)\n        if len(parts) == 2:\n            module_name, class_name = parts\n            target = class_name  # Use only class name as target\n            # Set module context for qualified names\n            if env:\n                kwargs = {'py:module': module_name,\n                         'py:class': env.ref_context.get('py:class')}\n            else:\n                kwargs = {'py:module': module_name}\n        else:\n            target = text\n            kwargs = {}\n    else:\n        target = text\n        kwargs = {}\n\n    # Add existing env context if available and not already set\n    if env and 'py:module' not in kwargs:\n        kwargs.update({'py:module': env.ref_context.get('py:module'),\n                      'py:class': env.ref_context.get('py:class')})\n\n    return pending_xref('', nodes.Text(text),\n                        refdomain='py', reftype=reftype, reftarget=target, **kwargs)\n",
      "\ndef type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xref:\n    \"\"\"Convert a type string to a cross reference node.\"\"\"\n    if text == 'None':\n        reftype = 'obj'\n    else:\n        reftype = 'class'\n\n    # Handle module-qualified names (e.g., 'struct.Struct' -> module='struct', target='Struct')\n    if '.' in text and not text.startswith('.'):\n        # Split module.Class into components\n        parts = text.rsplit('.', 1)\n        if len(parts) == 2:\n            module_name, class_name = parts\n            target = class_name  # Use only class name as target\n            # Set module context for qualified names\n            if env:\n                kwargs = {'py:module': module_name,\n                         'py:class': env.ref_context.get('py:class')}\n            else:\n                kwargs = {'py:module': module_name}\n        else:\n            target = text\n            kwargs = {}\n    else:\n        target = text\n        kwargs = {}\n\n    # Add existing env context if available and not already set\n    if env and 'py:module' not in kwargs:\n        kwargs.update({'py:module': env.ref_context.get('py:module'),\n                      'py:class': env.ref_context.get('py:class')})\n\n    return pending_xref('', nodes.Text(text),\n                        refdomain='py', reftype=reftype, reftarget=target, **kwargs)\n",
      "\ndef type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xref:\n    \"\"\"Convert a type string to a cross reference node.\"\"\"\n    if text == 'None':\n        reftype = 'obj'\n    else:\n        reftype = 'class'\n\n    # Handle module-qualified names (e.g., 'struct.Struct' -> module='struct', target='Struct')\n    if '.' in text and not text.startswith('.'):\n        # Split module.Class into components\n        parts = text.rsplit('.', 1)\n        if len(parts) == 2:\n            module_name, class_name = parts\n            target = class_name  # Use only class name as target\n            # Set module context for qualified names\n            if env:\n                kwargs = {'py:module': module_name,\n                         'py:class': env.ref_context.get('py:class')}\n            else:\n                kwargs = {'py:module': module_name}\n        else:\n            target = text\n            kwargs = {}\n    else:\n        target = text\n        kwargs = {}\n\n    # Add existing env context if available and not already set\n    if env and 'py:module' not in kwargs:\n        kwargs.update({'py:module': env.ref_context.get('py:module'),\n                      'py:class': env.ref_context.get('py:class')})\n\n    return pending_xref('', nodes.Text(text),\n                        refdomain='py', reftype=reftype, reftarget=target, **kwargs)\n",
      "\ndef type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xref:\n    \"\"\"Convert a type string to a cross reference node.\"\"\"\n    if text == 'None':\n        reftype = 'obj'\n    else:\n        reftype = 'class'\n\n    # Handle module-qualified names (e.g., 'struct.Struct' -> module='struct', target='Struct')\n    if '.' in text and not text.startswith('.'):\n        # Split module.Class into components\n        parts = text.rsplit('.', 1)\n        if len(parts) == 2:\n            module_name, class_name = parts\n            target = class_name  # Use only class name as target\n            # Set module context for qualified names\n            if env:\n                kwargs = {'py:module': module_name,\n                         'py:class': env.ref_context.get('py:class')}\n            else:\n                kwargs = {'py:module': module_name}\n        else:\n            target = text\n            kwargs = {}\n    else:\n        target = text\n        kwargs = {}\n\n    # Add existing env context if available and not already set\n    if env and 'py:module' not in kwargs:\n        kwargs.update({'py:module': env.ref_context.get('py:module'),\n                      'py:class': env.ref_context.get('py:class')})\n\n    return pending_xref('', nodes.Text(text),\n                        refdomain='py', reftype=reftype, reftarget=target, **kwargs)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex c4d134d08..733445fa9 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -78,6 +78,7 @@ ModuleEntry = NamedTuple('ModuleEntry', [('docname', str),\n                                          ('deprecated', bool)])\n \n \n+\n def type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xref:\n     \"\"\"Convert a type string to a cross reference node.\"\"\"\n     if text == 'None':\n@@ -85,14 +86,36 @@ def type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xr\n     else:\n         reftype = 'class'\n \n-    if env:\n-        kwargs = {'py:module': env.ref_context.get('py:module'),\n-                  'py:class': env.ref_context.get('py:class')}\n+    # Handle module-qualified names (e.g., 'struct.Struct' -> module='struct', target='Struct')\n+    if '.' in text and not text.startswith('.'):\n+        # Split module.Class into components\n+        parts = text.rsplit('.', 1)\n+        if len(parts) == 2:\n+            module_name, class_name = parts\n+            target = class_name  # Use only class name as target\n+            # Set module context for qualified names\n+            if env:\n+                kwargs = {'py:module': module_name,\n+                         'py:class': env.ref_context.get('py:class')}\n+            else:\n+                kwargs = {'py:module': module_name}\n+        else:\n+            target = text\n+            if env:\n+                kwargs = {'py:module': env.ref_context.get('py:module'),\n+                         'py:class': env.ref_context.get('py:class')}\n+            else:\n+                kwargs = {}\n     else:\n-        kwargs = {}\n+        target = text\n+        if env:\n+            kwargs = {'py:module': env.ref_context.get('py:module'),\n+                     'py:class': env.ref_context.get('py:class')}\n+        else:\n+            kwargs = {}\n \n     return pending_xref('', nodes.Text(text),\n-                        refdomain='py', reftype=reftype, reftarget=text, **kwargs)\n+                        refdomain='py', reftype=reftype, reftarget=target, **kwargs)\n \n \n def _parse_annotation(annotation: str, env: BuildEnvironment = None) -> List[Node]:\n",
    "variant_0": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex c4d134d08..876b3c3c8 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -78,6 +78,7 @@ ModuleEntry = NamedTuple('ModuleEntry', [('docname', str),\n                                          ('deprecated', bool)])\n \n \n+\n def type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xref:\n     \"\"\"Convert a type string to a cross reference node.\"\"\"\n     if text == 'None':\n@@ -85,14 +86,33 @@ def type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xr\n     else:\n         reftype = 'class'\n \n-    if env:\n-        kwargs = {'py:module': env.ref_context.get('py:module'),\n-                  'py:class': env.ref_context.get('py:class')}\n+    # Handle module-qualified names (e.g., 'struct.Struct' -> module='struct', target='Struct')\n+    if '.' in text and not text.startswith('.'):\n+        # Split module.Class into components\n+        parts = text.rsplit('.', 1)\n+        if len(parts) == 2:\n+            module_name, class_name = parts\n+            target = class_name  # Use only class name as target\n+            # Set module context for qualified names\n+            if env:\n+                kwargs = {'py:module': module_name,\n+                         'py:class': env.ref_context.get('py:class')}\n+            else:\n+                kwargs = {'py:module': module_name}\n+        else:\n+            target = text\n+            kwargs = {}\n     else:\n+        target = text\n         kwargs = {}\n \n+    # Add existing env context if available and not already set\n+    if env and 'py:module' not in kwargs:\n+        kwargs.update({'py:module': env.ref_context.get('py:module'),\n+                      'py:class': env.ref_context.get('py:class')})\n+\n     return pending_xref('', nodes.Text(text),\n-                        refdomain='py', reftype=reftype, reftarget=text, **kwargs)\n+                        refdomain='py', reftype=reftype, reftarget=target, **kwargs)\n \n \n def _parse_annotation(annotation: str, env: BuildEnvironment = None) -> List[Node]:\n",
    "variant_1": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex c4d134d08..733445fa9 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -78,6 +78,7 @@ ModuleEntry = NamedTuple('ModuleEntry', [('docname', str),\n                                          ('deprecated', bool)])\n \n \n+\n def type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xref:\n     \"\"\"Convert a type string to a cross reference node.\"\"\"\n     if text == 'None':\n@@ -85,14 +86,36 @@ def type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xr\n     else:\n         reftype = 'class'\n \n-    if env:\n-        kwargs = {'py:module': env.ref_context.get('py:module'),\n-                  'py:class': env.ref_context.get('py:class')}\n+    # Handle module-qualified names (e.g., 'struct.Struct' -> module='struct', target='Struct')\n+    if '.' in text and not text.startswith('.'):\n+        # Split module.Class into components\n+        parts = text.rsplit('.', 1)\n+        if len(parts) == 2:\n+            module_name, class_name = parts\n+            target = class_name  # Use only class name as target\n+            # Set module context for qualified names\n+            if env:\n+                kwargs = {'py:module': module_name,\n+                         'py:class': env.ref_context.get('py:class')}\n+            else:\n+                kwargs = {'py:module': module_name}\n+        else:\n+            target = text\n+            if env:\n+                kwargs = {'py:module': env.ref_context.get('py:module'),\n+                         'py:class': env.ref_context.get('py:class')}\n+            else:\n+                kwargs = {}\n     else:\n-        kwargs = {}\n+        target = text\n+        if env:\n+            kwargs = {'py:module': env.ref_context.get('py:module'),\n+                     'py:class': env.ref_context.get('py:class')}\n+        else:\n+            kwargs = {}\n \n     return pending_xref('', nodes.Text(text),\n-                        refdomain='py', reftype=reftype, reftarget=text, **kwargs)\n+                        refdomain='py', reftype=reftype, reftarget=target, **kwargs)\n \n \n def _parse_annotation(annotation: str, env: BuildEnvironment = None) -> List[Node]:\n",
    "variant_2": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex c4d134d08..876b3c3c8 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -78,6 +78,7 @@ ModuleEntry = NamedTuple('ModuleEntry', [('docname', str),\n                                          ('deprecated', bool)])\n \n \n+\n def type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xref:\n     \"\"\"Convert a type string to a cross reference node.\"\"\"\n     if text == 'None':\n@@ -85,14 +86,33 @@ def type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xr\n     else:\n         reftype = 'class'\n \n-    if env:\n-        kwargs = {'py:module': env.ref_context.get('py:module'),\n-                  'py:class': env.ref_context.get('py:class')}\n+    # Handle module-qualified names (e.g., 'struct.Struct' -> module='struct', target='Struct')\n+    if '.' in text and not text.startswith('.'):\n+        # Split module.Class into components\n+        parts = text.rsplit('.', 1)\n+        if len(parts) == 2:\n+            module_name, class_name = parts\n+            target = class_name  # Use only class name as target\n+            # Set module context for qualified names\n+            if env:\n+                kwargs = {'py:module': module_name,\n+                         'py:class': env.ref_context.get('py:class')}\n+            else:\n+                kwargs = {'py:module': module_name}\n+        else:\n+            target = text\n+            kwargs = {}\n     else:\n+        target = text\n         kwargs = {}\n \n+    # Add existing env context if available and not already set\n+    if env and 'py:module' not in kwargs:\n+        kwargs.update({'py:module': env.ref_context.get('py:module'),\n+                      'py:class': env.ref_context.get('py:class')})\n+\n     return pending_xref('', nodes.Text(text),\n-                        refdomain='py', reftype=reftype, reftarget=text, **kwargs)\n+                        refdomain='py', reftype=reftype, reftarget=target, **kwargs)\n \n \n def _parse_annotation(annotation: str, env: BuildEnvironment = None) -> List[Node]:\n",
    "variant_3": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex c4d134d08..876b3c3c8 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -78,6 +78,7 @@ ModuleEntry = NamedTuple('ModuleEntry', [('docname', str),\n                                          ('deprecated', bool)])\n \n \n+\n def type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xref:\n     \"\"\"Convert a type string to a cross reference node.\"\"\"\n     if text == 'None':\n@@ -85,14 +86,33 @@ def type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xr\n     else:\n         reftype = 'class'\n \n-    if env:\n-        kwargs = {'py:module': env.ref_context.get('py:module'),\n-                  'py:class': env.ref_context.get('py:class')}\n+    # Handle module-qualified names (e.g., 'struct.Struct' -> module='struct', target='Struct')\n+    if '.' in text and not text.startswith('.'):\n+        # Split module.Class into components\n+        parts = text.rsplit('.', 1)\n+        if len(parts) == 2:\n+            module_name, class_name = parts\n+            target = class_name  # Use only class name as target\n+            # Set module context for qualified names\n+            if env:\n+                kwargs = {'py:module': module_name,\n+                         'py:class': env.ref_context.get('py:class')}\n+            else:\n+                kwargs = {'py:module': module_name}\n+        else:\n+            target = text\n+            kwargs = {}\n     else:\n+        target = text\n         kwargs = {}\n \n+    # Add existing env context if available and not already set\n+    if env and 'py:module' not in kwargs:\n+        kwargs.update({'py:module': env.ref_context.get('py:module'),\n+                      'py:class': env.ref_context.get('py:class')})\n+\n     return pending_xref('', nodes.Text(text),\n-                        refdomain='py', reftype=reftype, reftarget=text, **kwargs)\n+                        refdomain='py', reftype=reftype, reftarget=target, **kwargs)\n \n \n def _parse_annotation(annotation: str, env: BuildEnvironment = None) -> List[Node]:\n",
    "variant_4": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex c4d134d08..876b3c3c8 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -78,6 +78,7 @@ ModuleEntry = NamedTuple('ModuleEntry', [('docname', str),\n                                          ('deprecated', bool)])\n \n \n+\n def type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xref:\n     \"\"\"Convert a type string to a cross reference node.\"\"\"\n     if text == 'None':\n@@ -85,14 +86,33 @@ def type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xr\n     else:\n         reftype = 'class'\n \n-    if env:\n-        kwargs = {'py:module': env.ref_context.get('py:module'),\n-                  'py:class': env.ref_context.get('py:class')}\n+    # Handle module-qualified names (e.g., 'struct.Struct' -> module='struct', target='Struct')\n+    if '.' in text and not text.startswith('.'):\n+        # Split module.Class into components\n+        parts = text.rsplit('.', 1)\n+        if len(parts) == 2:\n+            module_name, class_name = parts\n+            target = class_name  # Use only class name as target\n+            # Set module context for qualified names\n+            if env:\n+                kwargs = {'py:module': module_name,\n+                         'py:class': env.ref_context.get('py:class')}\n+            else:\n+                kwargs = {'py:module': module_name}\n+        else:\n+            target = text\n+            kwargs = {}\n     else:\n+        target = text\n         kwargs = {}\n \n+    # Add existing env context if available and not already set\n+    if env and 'py:module' not in kwargs:\n+        kwargs.update({'py:module': env.ref_context.get('py:module'),\n+                      'py:class': env.ref_context.get('py:class')})\n+\n     return pending_xref('', nodes.Text(text),\n-                        refdomain='py', reftype=reftype, reftarget=text, **kwargs)\n+                        refdomain='py', reftype=reftype, reftarget=target, **kwargs)\n \n \n def _parse_annotation(annotation: str, env: BuildEnvironment = None) -> List[Node]:\n",
    "variant_5": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex c4d134d08..876b3c3c8 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -78,6 +78,7 @@ ModuleEntry = NamedTuple('ModuleEntry', [('docname', str),\n                                          ('deprecated', bool)])\n \n \n+\n def type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xref:\n     \"\"\"Convert a type string to a cross reference node.\"\"\"\n     if text == 'None':\n@@ -85,14 +86,33 @@ def type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xr\n     else:\n         reftype = 'class'\n \n-    if env:\n-        kwargs = {'py:module': env.ref_context.get('py:module'),\n-                  'py:class': env.ref_context.get('py:class')}\n+    # Handle module-qualified names (e.g., 'struct.Struct' -> module='struct', target='Struct')\n+    if '.' in text and not text.startswith('.'):\n+        # Split module.Class into components\n+        parts = text.rsplit('.', 1)\n+        if len(parts) == 2:\n+            module_name, class_name = parts\n+            target = class_name  # Use only class name as target\n+            # Set module context for qualified names\n+            if env:\n+                kwargs = {'py:module': module_name,\n+                         'py:class': env.ref_context.get('py:class')}\n+            else:\n+                kwargs = {'py:module': module_name}\n+        else:\n+            target = text\n+            kwargs = {}\n     else:\n+        target = text\n         kwargs = {}\n \n+    # Add existing env context if available and not already set\n+    if env and 'py:module' not in kwargs:\n+        kwargs.update({'py:module': env.ref_context.get('py:module'),\n+                      'py:class': env.ref_context.get('py:class')})\n+\n     return pending_xref('', nodes.Text(text),\n-                        refdomain='py', reftype=reftype, reftarget=text, **kwargs)\n+                        refdomain='py', reftype=reftype, reftarget=target, **kwargs)\n \n \n def _parse_annotation(annotation: str, env: BuildEnvironment = None) -> List[Node]:\n",
    "variant_6": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex c4d134d08..876b3c3c8 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -78,6 +78,7 @@ ModuleEntry = NamedTuple('ModuleEntry', [('docname', str),\n                                          ('deprecated', bool)])\n \n \n+\n def type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xref:\n     \"\"\"Convert a type string to a cross reference node.\"\"\"\n     if text == 'None':\n@@ -85,14 +86,33 @@ def type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xr\n     else:\n         reftype = 'class'\n \n-    if env:\n-        kwargs = {'py:module': env.ref_context.get('py:module'),\n-                  'py:class': env.ref_context.get('py:class')}\n+    # Handle module-qualified names (e.g., 'struct.Struct' -> module='struct', target='Struct')\n+    if '.' in text and not text.startswith('.'):\n+        # Split module.Class into components\n+        parts = text.rsplit('.', 1)\n+        if len(parts) == 2:\n+            module_name, class_name = parts\n+            target = class_name  # Use only class name as target\n+            # Set module context for qualified names\n+            if env:\n+                kwargs = {'py:module': module_name,\n+                         'py:class': env.ref_context.get('py:class')}\n+            else:\n+                kwargs = {'py:module': module_name}\n+        else:\n+            target = text\n+            kwargs = {}\n     else:\n+        target = text\n         kwargs = {}\n \n+    # Add existing env context if available and not already set\n+    if env and 'py:module' not in kwargs:\n+        kwargs.update({'py:module': env.ref_context.get('py:module'),\n+                      'py:class': env.ref_context.get('py:class')})\n+\n     return pending_xref('', nodes.Text(text),\n-                        refdomain='py', reftype=reftype, reftarget=text, **kwargs)\n+                        refdomain='py', reftype=reftype, reftarget=target, **kwargs)\n \n \n def _parse_annotation(annotation: str, env: BuildEnvironment = None) -> List[Node]:\n",
    "variant_7": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex c4d134d08..876b3c3c8 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -78,6 +78,7 @@ ModuleEntry = NamedTuple('ModuleEntry', [('docname', str),\n                                          ('deprecated', bool)])\n \n \n+\n def type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xref:\n     \"\"\"Convert a type string to a cross reference node.\"\"\"\n     if text == 'None':\n@@ -85,14 +86,33 @@ def type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xr\n     else:\n         reftype = 'class'\n \n-    if env:\n-        kwargs = {'py:module': env.ref_context.get('py:module'),\n-                  'py:class': env.ref_context.get('py:class')}\n+    # Handle module-qualified names (e.g., 'struct.Struct' -> module='struct', target='Struct')\n+    if '.' in text and not text.startswith('.'):\n+        # Split module.Class into components\n+        parts = text.rsplit('.', 1)\n+        if len(parts) == 2:\n+            module_name, class_name = parts\n+            target = class_name  # Use only class name as target\n+            # Set module context for qualified names\n+            if env:\n+                kwargs = {'py:module': module_name,\n+                         'py:class': env.ref_context.get('py:class')}\n+            else:\n+                kwargs = {'py:module': module_name}\n+        else:\n+            target = text\n+            kwargs = {}\n     else:\n+        target = text\n         kwargs = {}\n \n+    # Add existing env context if available and not already set\n+    if env and 'py:module' not in kwargs:\n+        kwargs.update({'py:module': env.ref_context.get('py:module'),\n+                      'py:class': env.ref_context.get('py:class')})\n+\n     return pending_xref('', nodes.Text(text),\n-                        refdomain='py', reftype=reftype, reftarget=text, **kwargs)\n+                        refdomain='py', reftype=reftype, reftarget=target, **kwargs)\n \n \n def _parse_annotation(annotation: str, env: BuildEnvironment = None) -> List[Node]:\n",
    "variant_8": "diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex c4d134d08..876b3c3c8 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -78,6 +78,7 @@ ModuleEntry = NamedTuple('ModuleEntry', [('docname', str),\n                                          ('deprecated', bool)])\n \n \n+\n def type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xref:\n     \"\"\"Convert a type string to a cross reference node.\"\"\"\n     if text == 'None':\n@@ -85,14 +86,33 @@ def type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xr\n     else:\n         reftype = 'class'\n \n-    if env:\n-        kwargs = {'py:module': env.ref_context.get('py:module'),\n-                  'py:class': env.ref_context.get('py:class')}\n+    # Handle module-qualified names (e.g., 'struct.Struct' -> module='struct', target='Struct')\n+    if '.' in text and not text.startswith('.'):\n+        # Split module.Class into components\n+        parts = text.rsplit('.', 1)\n+        if len(parts) == 2:\n+            module_name, class_name = parts\n+            target = class_name  # Use only class name as target\n+            # Set module context for qualified names\n+            if env:\n+                kwargs = {'py:module': module_name,\n+                         'py:class': env.ref_context.get('py:class')}\n+            else:\n+                kwargs = {'py:module': module_name}\n+        else:\n+            target = text\n+            kwargs = {}\n     else:\n+        target = text\n         kwargs = {}\n \n+    # Add existing env context if available and not already set\n+    if env and 'py:module' not in kwargs:\n+        kwargs.update({'py:module': env.ref_context.get('py:module'),\n+                      'py:class': env.ref_context.get('py:class')})\n+\n     return pending_xref('', nodes.Text(text),\n-                        refdomain='py', reftype=reftype, reftarget=text, **kwargs)\n+                        refdomain='py', reftype=reftype, reftarget=target, **kwargs)\n \n \n def _parse_annotation(annotation: str, env: BuildEnvironment = None) -> List[Node]:\n"
  }
}