{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/django/django/db/models/base.py lines 1867-1872)": "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Validate fields in UniqueConstraints\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n",
    "Location 2 (/root/hy/projects_3/django/django/db/models/base.py lines 1562-1586)": "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Validate fields in UniqueConstraints\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                if (\n                    constraint.condition and\n                    not any(\n                        'supports_partial_indexes' in db.features.supported_features\n                        for db in [connections[db_alias] for db_alias in databases]\n                    )\n                ):\n                    errors.append(\n                        checks.Warning(\n                            '%s does not support unique constraints with '\n                            'conditions.' % ', '.join(\n                                connection.vendor for connection in\n                                (connections[db_alias] for db_alias in databases)\n                            ),\n                            hint=(\n                                'A constraint will not be created. Silence this '\n                                'warning if you don\\'t care about it.'\n                            ),\n                            obj=cls,\n                            id='models.W036',\n                        )\n                    )\n        return errors\n",
    "Location 3 (/root/hy/projects_3/django/django/db/models/base.py lines 1640-1680)": "\n    @classmethod\n    def _check_constraints(cls):\n        errors = []\n        \n        # Validate UniqueConstraint fields\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, models.UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, models.UniqueConstraint):\n                if (\n                    constraint.condition and\n                    not connections[DEFAULT_DB_ALIAS].features.supports_partial_indexes\n                ):\n                    errors.append(\n                        checks.Warning(\n                            '%s does not support unique constraints with '\n                            'conditions.' % connection.display_name,\n                            hint=(\n                                'A constraint will not be created. Silence this '\n                                'warning if you do not care about it.'\n                            ),\n                            obj=cls,\n                            id='models.W036',\n                        )\n                    )\n                if (\n                    constraint.include and\n                    not connections[DEFAULT_DB_ALIAS].features.supports_covering_indexes\n                ):\n                    errors.append(\n                        checks.Warning(\n                            '%s does not support unique constraints with '\n                            'non-key columns.' % connection.display_name,\n                            hint=(\n                                'A constraint will not be created. Silence this '\n                                'warning if you do not care about it.'\n                            ),\n                            obj=cls,\n                            id='models.W039',\n                        )\n                    )\n                if (\n                    constraint.opclasses and\n                    not connections[DEFAULT_DB_ALIAS].features.supports_covering_indexes\n                ):\n                    errors.append(\n                        checks.Warning(\n                            '%s does not support unique constraints with '\n                            'operator classes.' % connection.display_name,\n                            hint=(\n                                'A constraint will not be created. Silence this '\n                                'warning if you do not care about it.'\n                            ),\n                            obj=cls,\n                            id='models.W040',\n                        )\n                    )\n        return errors\n",
    "Location 4 (/root/hy/projects_3/django/django/db/models/base.py lines 1894-1896)": "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Validate UniqueConstraint fields\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(\n                    cls._check_local_fields(constraint.fields, \"constraints\")\n                )\n        \n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                'supports_table_check_constraints' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, CheckConstraint)\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support check constraints.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W027',\n                    )\n                )\n            if not (\n                connection.features.supports_partial_indexes or\n                'supports_partial_indexes' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support unique constraints with '\n                        'conditions.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W028',\n                    )\n                )\n        return errors\n",
    "Location 5 (/root/hy/projects_3/django/django/db/models/constraints.py lines 80-96)": "\n    def __init__(self, *, fields, name, condition=None, deferrable=None):\n        if not fields:\n            raise ValueError('At least one field is required to define a unique constraint.')\n        if not isinstance(condition, (type(None), Q)):\n            raise ValueError('UniqueConstraint.condition must be a Q instance.')\n        if condition and deferrable:\n            raise ValueError(\n                'UniqueConstraint with conditions cannot be deferred.'\n            )\n        if not isinstance(deferrable, (type(None), Deferrable)):\n            raise ValueError(\n                'UniqueConstraint.deferrable must be a Deferrable instance.'\n            )\n        self.fields = tuple(fields)\n        self.condition = condition\n        self.deferrable = deferrable\n        super().__init__(name)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/django/django/db/models/base.py lines 1867-1872)": [
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Check field existence for UniqueConstraint\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Validate fields in UniqueConstraint instances\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Check UniqueConstraint field validation\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        # Validate fields in UniqueConstraints\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Validate fields in UniqueConstraint instances\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        # Validate fields in UniqueConstraint instances\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        # Validate fields in UniqueConstraint instances\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Validate fields in UniqueConstraint instances\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n"
    ],
    "Location 2 (/root/hy/projects_3/django/django/db/models/base.py lines 1562-1586)": [
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Check field existence for UniqueConstraint\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                if not databases.intersection(constraint.include) and not databases.intersection(constraint.exclude):\n                    errors.extend(constraint.validate(model=cls, exclude=databases))\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Validate fields in UniqueConstraints\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                if constraint.condition and not databases:\n                    errors.append(\n                        checks.Warning(\n                            '%s does not support conditional constraints.' % connection.display_name,\n                            hint=(\n                                'A constraint will not be created. Silence this '\n                                'warning if you don\\'t care about it.'\n                            ),\n                            obj=cls,\n                            id='models.W040',\n                        )\n                    )\n                for db in databases:\n                    if not router.allow_migrate_model(db, cls):\n                        continue\n                    connection = connections[db]\n                    if not (\n                        'supports_partial_indexes' in self.features.__dict__ and\n                        connection.features.supports_partial_indexes\n                    ) or not connection.features.supports_partial_indexes:\n                        if constraint.condition is not None:\n                            errors.append(\n                                checks.Warning(\n                                    '%s does not support conditional unique constraints.'\n                                    % connection.display_name,\n                                    hint=(\n                                        'A constraint will not be created. Silence this '\n                                        'warning if you don\\'t care about it.'\n                                    ),\n                                    obj=cls,\n                                    id='models.W040',\n                                )\n                            )\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        # Add field validation for UniqueConstraint instances\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                if (\n                    constraint.condition and\n                    not any(\n                        'supports_partial_indexes' in db.features.__dict__ and\n                        db.features.supports_partial_indexes\n                        for db in map(connections.__getitem__, databases)\n                    )\n                ):\n                    errors.append(\n                        checks.Warning(\n                            '%s does not support unique constraints with '\n                            'conditions.' % ', '.join(\n                                db.display_name for db in map(\n                                    connections.__getitem__, databases\n                                )\n                            ),\n                            hint=(\n                                'A constraint will not be created. Silence this '\n                                'warning if you do not care about it.'\n                            ),\n                            obj=cls,\n                            id='models.W045',\n                        )\n                    )\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        # Add field validation for UniqueConstraint fields\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        for constraint in cls._meta.constraints:\n            errors.extend(constraint.check())\n        for constraint in cls._meta.constraints:\n            if not isinstance(constraint, UniqueConstraint):\n                continue\n            for db in databases:\n                if not router.allow_migrate_model(db, cls):\n                    continue\n                connection = connections[db]\n                if not (\n                    connection.features.supports_partial_indexes\n                    or 'condition' not in constraint.deconstruct()[2]\n                ):\n                    errors.append(\n                        checks.Warning(\n                            '%s does not support unique constraints with '\n                            'conditions.' % connection.display_name,\n                            hint=(\n                                'A constraint will not be created. Silence this '\n                                'warning if you don\\'t care about it.'\n                            ),\n                            obj=cls,\n                            id='models.W036',\n                        )\n                    )\n                if not (\n                    connection.features.supports_deferrable_unique_constraints or\n                    'deferrable' not in constraint.deconstruct()[2]\n                ):\n                    errors.append(\n                        checks.Warning(\n                            '%s does not support deferrable unique constraints.'\n                            % connection.display_name,\n                            hint=(\n                                'A constraint will not be created. Silence this '\n                                'warning if you don\\'t care about it.'\n                            ),\n                            obj=cls,\n                            id='models.W038',\n                        )\n                    )\n                if not connection.features.supports_covering_indexes:\n                    covering_columns = getattr(constraint, 'include', None)\n                    if covering_columns:\n                        errors.append(\n                            checks.Warning(\n                                'db_index on field(s) %r will not be created on %s '\n                                'because the database does not support covering '\n                                'indexes.' % (covering_columns, connection.display_name),\n                                hint=\"Silence this warning if you don't care about it.\",\n                                obj=cls,\n                                id='models.W042',\n                            )\n                        )\n                opclass = getattr(constraint, 'opclasses', None)\n                if opclass and not connection.features.supports_over_clause:\n                    errors.append(\n                        checks.Warning(\n                            'opclasses on constraint %r will not be created on %s '\n                            'because the database does not support operator classes.'\n                            % (constraint.name, connection.display_name),\n                            hint=\"Silence this warning if you don't care about it.\",\n                            obj=cls,\n                            id='models.W043',\n                        )\n                    )\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        # Check field existence for UniqueConstraints\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                for db in databases:\n                    if not router.allow_migrate_model(db, cls):\n                        continue\n                    connection = connections[db]\n                    if not (\n                        connection.features.supports_partial_indexes\n                        or 'supports_partial_indexes' in cls._meta.required_db_features\n                    ):\n                        if constraint.condition is not None:\n                            errors.append(\n                                checks.Warning(\n                                    '%s does not support unique constraints with '\n                                    'conditions.' % connection.display_name,\n                                    hint=(\n                                        'A constraint will be created without '\n                                        'a condition. You should add '\n                                        '\"supports_partial_indexes\" to '\n                                        'Meta.required_db_features.'\n                                    ),\n                                    obj=cls,\n                                    id='models.W045',\n                                )\n                            )\n                    if not (\n                        connection.features.supports_deferrable_unique_constraints\n                        or 'supports_deferrable_unique_constraints' in cls._meta.required_db_features\n                    ):\n                        if constraint.deferrable is not None:\n                            errors.append(\n                                checks.Warning(\n                                    '%s does not support deferrable unique constraints.'\n                                    % connection.display_name,\n                                    hint=(\n                                        'A constraint will be created without '\n                                        'deferrable. You should add '\n                                        '\"supports_deferrable_unique_constraints\" to '\n                                        'Meta.required_db_features.'\n                                    ),\n                                    obj=cls,\n                                    id='models.W046',\n                                )\n                            )\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Validate UniqueConstraint fields exist\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                if (\n                    constraint.condition and\n                    not any(\n                        'supports_partial_indexes' in db.features.__dict__ and\n                        db.features.supports_partial_indexes\n                        for db in [connections[db_alias] for db_alias in databases]\n                    )\n                ):\n                    errors.append(\n                        checks.Warning(\n                            '%s does not support unique constraints with '\n                            'conditions.' % connection.display_name,\n                            hint=(\n                                'A constraint will not be created. Silence this '\n                                'warning if you do not care about it.'\n                            ),\n                            obj=cls,\n                            id='models.W045',\n                        )\n                    )\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for constraint in cls._meta.constraints:\n            # Check field existence for UniqueConstraint\n            if constraint.__class__.__name__ == 'UniqueConstraint':\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n            \n            # Check database feature support\n            errors.extend(constraint.check(using=database) for database in databases)\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Validate fields in UniqueConstraints\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                if (\n                    constraint.condition and\n                    not any(\n                        'supports_partial_indexes' in db.introspection.get_storage_engine_info(db.connection) and\n                        db.introspection.get_storage_engine_info(db.connection)['supports_partial_indexes']\n                        for db_alias in databases\n                        for db in [connections[db_alias]]\n                    ) and\n                    not all(\n                        db.features.supports_partial_indexes\n                        for db_alias in databases\n                        for db in [connections[db_alias]]\n                    )\n                ):\n                    errors.append(\n                        checks.Warning(\n                            'Partial indexes are not supported on this database backend.',\n                            obj=cls,\n                            id='models.W039',\n                        )\n                    )\n        return errors\n"
    ],
    "Location 3 (/root/hy/projects_3/django/django/db/models/base.py lines 1640-1680)": [
      "\n    @classmethod\n    def _check_constraints(cls):\n        errors = []\n        \n        # Check field existence in UniqueConstraints\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                if (\n                    constraint.condition and\n                    not connections[DEFAULT_DB_ALIAS].features.supports_partial_indexes\n                ):\n                    errors.append(\n                        checks.Warning(\n                            '%s does not support unique constraints with '\n                            'conditions.' % connection.display_name,\n                            hint=(\n                                'A constraint will not be created. Silence this '\n                                'warning if you do not care about it.'\n                            ),\n                            obj=cls,\n                            id='models.W036',\n                        )\n                    )\n                if (\n                    constraint.include and\n                    not connections[DEFAULT_DB_ALIAS].features.supports_covering_indexes\n                ):\n                    errors.append(\n                        checks.Warning(\n                            '%s does not support unique constraints with non-key '\n                            'columns.' % connection.display_name,\n                            hint=(\n                                'A constraint will not be created. Silence this '\n                                'warning if you do not care about it.'\n                            ),\n                            obj=cls,\n                            id='models.W039',\n                        )\n                    )\n            if isinstance(constraint, CheckConstraint):\n                if (\n                    constraint.condition and\n                    not connections[DEFAULT_DB_ALIAS].features.supports_table_check_constraints\n                ):\n                    errors.append(\n                        checks.Warning(\n                            '%s does not support check constraints.' % connection.display_name,\n                            hint=(\n                                'A constraint will not be created. Silence this '\n                                'warning if you do not care about it.'\n                            ),\n                            obj=cls,\n                            id='models.W027',\n                        )\n                    )\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls):\n        errors = []\n        \n        # Validate fields in UniqueConstraints\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                if (\n                    constraint.condition and\n                    not connection.features.supports_partial_indexes\n                ):\n                    errors.append(\n                        checks.Warning(\n                            '%s does not support unique constraints with '\n                            'conditions.' % connection.display_name,\n                            hint=(\n                                'A constraint without a condition will be '\n                                'created instead.'\n                            ),\n                            obj=cls,\n                            id='models.W036',\n                        )\n                    )\n                if (\n                    constraint.include and\n                    not connection.features.supports_covering_indexes\n                ):\n                    errors.append(\n                        checks.Warning(\n                            '%s does not support unique constraints with '\n                            'non-key columns.' % connection.display_name,\n                            hint=(\n                                'A constraint without non-key columns will '\n                                'be created instead.'\n                            ),\n                            obj=cls,\n                            id='models.W039',\n                        )\n                    )\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls):\n        errors = []\n        \n        # Validate fields in UniqueConstraint\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        for constraint in cls._meta.constraints:\n            errors.extend(constraint.check())\n        for db_table in cls._meta.required_db_features:\n            if not router.allow_migrate_model(db_table, cls):\n                continue\n            connection = connections[db_table]\n            if not (\n                constraint.supports_validate\n                and connection.features.supports_over_clause\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support check constraints.'\n                        % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W027',\n                    )\n                )\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls):\n        errors = []\n        \n        # Check UniqueConstraint fields for existence\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        for db in settings.DATABASES:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                connection.features.supports_column_check_constraints\n            ):\n                continue\n            for constraint in cls._meta.constraints:\n                if isinstance(constraint, CheckConstraint):\n                    if not connection.features.supports_over_clause:\n                        if constraint.check.contains_over_clause:\n                            errors.append(\n                                checks.Warning(\n                                    '%s does not support check constraints with '\n                                    'Window expressions.' % connection.display_name,\n                                    hint=(\n                                        'A constraint will not be created. Silence '\n                                        'this warning if you don\\'t care about it.'\n                                    ),\n                                    obj=cls,\n                                    id='models.W039',\n                                )\n                            )\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls):\n        errors = []\n        \n        # Check field validation for UniqueConstraints\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                if (\n                    constraint.condition and\n                    not connection.features.supports_partial_indexes\n                ):\n                    errors.append(\n                        checks.Warning(\n                            '%s does not support unique constraints with '\n                            'conditions.' % connection.display_name,\n                            hint=(\n                                'A constraint will be created without a condition. '\n                                'A unique constraint may be violated.'\n                            ),\n                            obj=cls,\n                            id='models.W039',\n                        )\n                    )\n                if (\n                    constraint.include and\n                    not connection.features.supports_covering_indexes\n                ):\n                    errors.append(\n                        checks.Warning(\n                            '%s does not support unique constraints with INCLUDE '\n                            'fields.' % connection.display_name,\n                            obj=cls,\n                            id='models.W040',\n                        )\n                    )\n                if (\n                    constraint.opclasses and\n                    not connection.features.supports_covering_indexes\n                ):\n                    errors.append(\n                        checks.Warning(\n                            '%s does not support unique constraints with opclasses.'\n                            % connection.display_name,\n                            obj=cls,\n                            id='models.W041',\n                        )\n                    )\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls):\n        errors = []\n        \n        # Check UniqueConstraint field validation\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                if (\n                    constraint.condition and\n                    not connections[DEFAULT_DB_ALIAS].features.supports_partial_indexes\n                ):\n                    errors.append(\n                        checks.Warning(\n                            '%s does not support unique constraints with '\n                            'conditions.' % connection.display_name,\n                            hint=(\n                                'A constraint will not be created. Silence this '\n                                'warning if you do not care about it.'\n                            ),\n                            obj=cls,\n                            id='models.W036',\n                        )\n                    )\n                if (\n                    constraint.include and\n                    not connections[DEFAULT_DB_ALIAS].features.supports_covering_indexes\n                ):\n                    errors.append(\n                        checks.Warning(\n                            '%s does not support unique constraints with covering '\n                            'fields.' % connection.display_name,\n                            hint=(\n                                'A constraint will not be created. Silence this '\n                                'warning if you do not care about it.'\n                            ),\n                            obj=cls,\n                            id='models.W042',\n                        )\n                    )\n                if (\n                    constraint.include and constraint.condition and\n                    not connections[DEFAULT_DB_ALIAS].features.supports_covering_indexes\n                ):\n                    errors.append(\n                        checks.Warning(\n                            '%s does not support unique constraints with covering '\n                            'fields and conditions.' % connection.display_name,\n                            hint=(\n                                'A constraint will not be created. Silence this '\n                                'warning if you do not care about it.'\n                            ),\n                            obj=cls,\n                            id='models.W043',\n                        )\n                    )\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls):\n        errors = []\n        # Check field existence for UniqueConstraint instances\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                if (not constraint.condition and\n                        constraint.fields and\n                        not any(name in constraint.fields for name in cls._meta._non_pk_concrete_field_names) and\n                        not constraint.include and\n                        not constraint.opclasses):\n                    if not any(\n                            isinstance(field, (models.DateField, models.DateTimeField, models.TimeField))\n                            for field in (cls._meta.get_field(field_name) for field_name in constraint.fields)\n                    ):\n                        errors.append(\n                            checks.Warning(\n                                '%s constraint on model %s contains no concrete fields; '\n                                'perhaps you meant to use unique_together instead?' % (\n                                    constraint.__class__.__name__, cls.__name__,\n                                ),\n                                obj=cls,\n                                id='models.W039',\n                            )\n                        )\n            \n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls):\n        errors = []\n        # Check field existence for UniqueConstraints\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                if not cls._meta.managed or any(\n                    not connection.features.supports_partial_indexes or\n                    not connection.features.supports_functions_in_partial_indexes\n                    for connection in connections.all()\n                ):\n                    if constraint.condition is not None:\n                        errors.append(\n                            checks.Warning(\n                                '%s does not support unique constraints with '\n                                'conditions.' % connection.display_name,\n                                hint=(\n                                    'A constraint will not be created. Silence this '\n                                    'warning if you don\\'t care about it.'\n                                ),\n                                obj=cls,\n                                id='models.W036',\n                            )\n                        )\n        return errors\n"
    ],
    "Location 4 (/root/hy/projects_3/django/django/db/models/base.py lines 1894-1896)": [
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        # Validate fields in UniqueConstraint objects\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                'supports_table_check_constraints' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, CheckConstraint)\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support check constraints.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W027',\n                    )\n                )\n            if not (\n                connection.features.supports_partial_indexes or\n                'supports_partial_indexes' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n                for constraint in cls._meta.constraints\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Validate fields in UniqueConstraint instances\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                'supports_table_check_constraints' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, CheckConstraint)\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support check constraints.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W027',\n                    )\n                )\n            if not (\n                connection.features.supports_partial_indexes or\n                'supports_partial_indexes' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support unique constraints with '\n                        'conditions.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W028',\n                    )\n                )\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Validate fields in UniqueConstraint instances\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                'supports_table_check_constraints' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, CheckConstraint)\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support check constraints.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W027',\n                    )\n                )\n            if not (\n                connection.features.supports_partial_indexes or\n                'supports_partial_indexes' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support unique constraints with '\n                        'conditions.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W028',\n                    )\n                )\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Validate fields in UniqueConstraint instances\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(\n                    cls._check_local_fields(constraint.fields, \"constraints\")\n                )\n        \n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                'supports_table_check_constraints' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, CheckConstraint)\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support check constraints.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W027',\n                    )\n                )\n            if not (\n                connection.features.supports_partial_indexes or\n                'supports_partial_indexes' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n                for constraint in cls._meta.constraints\n            ):\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Validate fields in UniqueConstraints\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                'supports_table_check_constraints' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, CheckConstraint)\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support check constraints.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W027',\n                    )\n                )\n            if not (\n                connection.features.supports_partial_indexes or\n                'supports_partial_indexes' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n                for constraint in cls._meta.constraints\n            ):\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Validate fields in UniqueConstraint instances\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(\n                    cls._check_local_fields(constraint.fields, \"constraints\")\n                )\n        \n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                'supports_table_check_constraints' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, CheckConstraint)\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support check constraints.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W027',\n                    )\n                )\n            if not (\n                connection.features.supports_partial_indexes or\n                'supports_partial_indexes' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n                for constraint in cls._meta.constraints\n            ):\n",
      "\n    @classmethod\n    def _check_constraints(cls, **kwargs):\n        errors = []\n        # Check field validation for UniqueConstraint\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        # Check database feature support\n        for db in settings.DATABASES.values():\n            if db['ENGINE'] not in (\n                'django.db.backends.postgresql',\n                'django.db.backends.sqlite3',\n            ):\n                continue\n            connection = connections[db_alias] if 'db_alias' in locals() else connections[DEFAULT_DB_ALIAS]\n            if not (\n                connection.features.supports_table_check_constraints or\n                'supports_table_check_constraints' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, CheckConstraint) and constraint.check is not None\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support check constraints.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W027',\n                    )\n                )\n            if not (\n                connection.features.supports_partial_indexes or\n                'supports_partial_indexes' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support unique constraints with '\n                        'conditions.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W028',\n                    )\n                )\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Validate UniqueConstraint fields\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                'supports_table_check_constraints' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, CheckConstraint)\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support check constraints.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W027',\n                    )\n                )\n            if not (\n                connection.features.supports_partial_indexes or\n                'supports_partial_indexes' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n                for constraint in cls._meta.constraints\n            ):\n"
    ],
    "Location 5 (/root/hy/projects_3/django/django/db/models/constraints.py lines 80-96)": [
      "\n    @classmethod\n    def _check_constraints(cls, **kwargs):\n        errors = []\n        # Validate fields in UniqueConstraint instances\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, models.UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, models.UniqueConstraint):\n                if (\n                    constraint.condition and\n                    not connection.features.supports_partial_indexes\n                ):\n                    errors.append(\n                        checks.Warning(\n                            '%s does not support unique constraints with '\n                            'conditions.' % connection.display_name,\n                            hint=(\n                                'A constraint won\\'t be created. Silence this '\n                                'warning if you don\\'t care about it.'\n                            ),\n                            obj=cls,\n                            id='models.W036',\n                        )\n                    )\n                if (\n                    constraint.deferrable and\n                    not connection.features.supports_deferrable_unique_constraints\n                ):\n                    errors.append(\n                        checks.Warning(\n                            '%s does not support deferrable unique constraints.'\n                            % connection.display_name,\n                            hint=(\n                                'A constraint won\\'t be created. Silence this '\n                                'warning if you don\\'t care about it.'\n                            ),\n                            obj=cls,\n                            id='models.W038',\n                        )\n                    )\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Validate UniqueConstraint fields exist\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                connection.features.supports_column_check_constraints\n            ):\n                continue\n            for constraint in cls._meta.constraints:\n                if isinstance(constraint, UniqueConstraint):\n                    if (\n                        constraint.condition and\n                        not connection.features.supports_partial_indexes\n                    ):\n                        errors.append(\n                            checks.Warning(\n                                f'{constraint.__class__.__name__} with conditions is '\n                                f'ignored on {connection.display_name}.',\n                                hint=(\n                                    f'{connection.display_name} does not support indexes '\n                                    f'with conditions.'\n                                ),\n                                obj=cls,\n                                id='models.W037',\n                            )\n                        )\n                    if (\n                        constraint.deferrable and\n                        not connection.features.supports_deferrable_unique_constraints\n                    ):\n                        errors.append(\n                            checks.Warning(\n                                f'Deferrable {constraint.__class__.__name__} is ignored '\n                                f'on {connection.display_name}.',\n                                hint=(\n                                    f'{connection.display_name} does not support deferrable '\n                                    f'unique constraints.'\n                                ),\n                                obj=cls,\n                                id='models.W038',\n                            )\n                        )\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(\n                    cls._check_local_fields(constraint.fields, \"constraints\")\n                )\n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_partial_indexes or\n                connection.features.supports_deferrable_unique_constraints\n            ):\n                continue\n            for constraint in cls._meta.constraints:\n                if not isinstance(constraint, UniqueConstraint):\n                    continue\n                if (\n                    constraint.condition and\n                    not connection.features.supports_partial_indexes\n                ):\n                    errors.append(\n                        checks.Warning(\n                            '%s does not support unique constraints with '\n                            'conditions.' % connection.display_name,\n                            hint=(\n                                'A constraint will not be created. Silence this '\n                                'warning if you don\\'t care about it.'\n                            ),\n                            obj=cls,\n                            id='models.W036',\n                        )\n                    )\n                if (\n                    constraint.deferrable and\n                    not connection.features.supports_deferrable_unique_constraints\n                ):\n                    errors.append(\n                        checks.Warning(\n                            '%s does not support deferrable unique constraints.'\n                            % connection.display_name,\n                            hint=(\n                                'A constraint will not be created. Silence this '\n                                'warning if you don\\'t care about it.'\n                            ),\n                            obj=cls,\n                            id='models.W038',\n                        )\n                    )\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Validate UniqueConstraint fields\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            for constraint in cls._meta.constraints:\n                if isinstance(constraint, UniqueConstraint):\n                    if (\n                        connection.features.supports_partial_indexes or\n                        'supports_partial_indexes' in cls._meta.required_db_features\n                    ):\n                        continue\n                    if constraint.condition is not None:\n                        errors.append(\n                            checks.Warning(\n                                f'{constraint.__class__.__name__} with conditions ignored on {connection.vendor}.',\n                                hint=(\n                                    f'{connection.display_name} does not support unique constraints with conditions.'\n                                ),\n                                obj=cls,\n                                id='models.W036',\n                            )\n                        )\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Validate UniqueConstraint fields\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                connection.features.supports_column_check_constraints\n            ):\n                continue\n            for constraint in cls._meta.constraints:\n                if isinstance(constraint, UniqueConstraint):\n                    if (\n                        constraint.condition and\n                        not connection.features.supports_partial_indexes\n                    ):\n                        errors.append(\n                            checks.Warning(\n                                '%s does not support unique constraints with '\n                                'conditions.' % connection.display_name,\n                                hint=(\n                                    'A constraint without a condition will be '\n                                    'created. Silence this warning if this is '\n                                    'intended.'\n                                ),\n                                obj=cls,\n                                id='models.W040',\n                            )\n                        )\n                    if (\n                        constraint.deferrable and\n                        not connection.features.supports_deferrable_unique_constraints\n                    ):\n                        errors.append(\n                            checks.Warning(\n                                '%s does not support deferrable unique constraints.'\n                                % connection.display_name,\n                                hint=(\n                                    'A non-deferrable unique constraint will be '\n                                    'created. Silence this warning if this is '\n                                    'intended.'\n                                ),\n                                obj=cls,\n                                id='models.W041',\n                            )\n                        )\n                else:\n                    constraint.validate(model=cls, exclude=None)\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Validate UniqueConstraint fields exist on the model\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(\n                    cls._check_local_fields(constraint.fields, \"constraints\")\n                )\n        \n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                connection.features.supports_column_check_constraints\n            ):\n                continue\n            for constraint in cls._meta.constraints:\n                constraint_databases = getattr(constraint, 'databases', None)\n                if constraint_databases is not None and db not in constraint_databases:\n                    continue\n                if (\n                    isinstance(constraint, UniqueConstraint) and\n                    connection.features.supports_partial_indexes\n                ):\n                    continue\n                errors.extend(constraint.validate(model=cls, instance=None, exclude=None, using=db))\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Validate UniqueConstraint fields\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(\n                    cls._check_local_fields(constraint.fields, \"constraints\")\n                )\n        \n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                connection.features.supports_column_check_constraints\n            ):\n                continue\n            for constraint in cls._meta.constraints:\n                if isinstance(constraint, CheckConstraint):\n                    if not connection.features.supports_over_clause:\n                        constraint_sql = constraint.constraint.as_sql(\n                            compiler=connection.ops.compiler('SQLCompiler')(\n                                connection=connection,\n                                query=None,\n                            ),\n                            connection=connection,\n                        )[0]\n                        if constraint_sql is not None:\n                            if 'OVER' in constraint_sql.upper():\n                                errors.append(\n                                    checks.Error(\n                                        '%s does not support check constraints with '\n                                        'window expressions.' % connection.display_name,\n                                        obj=cls,\n                                        id='models.E026',\n                                    )\n                                )\n                elif isinstance(constraint, UniqueConstraint):\n                    if (\n                        constraint.condition and\n                        not connection.features.supports_partial_indexes\n                    ):\n                        errors.append(\n                            checks.Warning(\n                                '%s does not support unique constraints with '\n                                'conditions.' % connection.display_name,\n                                hint=(\n                                    'A constraint won\\'t be created. Silence this '\n                                    'warning if you don\\'t care about it.'\n                                ),\n                                obj=cls,\n                                id='models.W039',\n                            )\n                        )\n                    if (\n                        constraint.deferrable and\n                        not connection.features.supports_deferrable_unique_constraints\n                    ):\n                        errors.append(\n                            checks.Warning(\n                                '%s does not support deferrable unique constraints.'\n                                % connection.display_name,\n                                hint=(\n                                    'A constraint won\\'t be created. Silence this '\n                                    'warning if you don\\'t care about it.'\n                                ),\n                                obj=cls,\n                                id='models.W040',\n                            )\n                        )\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for constraint in cls._meta.constraints:\n            # Validate fields exist for UniqueConstraint instances\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                connection.features.supports_column_check_constraints\n            ):\n                errors.extend(cls._check_constraints_database_backends(\n                    databases=[db], ignore_backends=[\n                        'django.db.backends.dummy',\n                    ]\n                ))\n            if connection.features.supports_over_clause:\n                continue\n            for constraint in cls._meta.constraints:\n                if isinstance(constraint, UniqueConstraint):\n                    if (\n                        constraint.condition and\n                        constraint.condition.contains_over_clause\n                    ):\n                        errors.append(\n                            checks.Error(\n                                '%s cannot use conditions with Window '\n                                'expressions on this database backend.' % (\n                                    constraint.__class__.__name__,\n                                ),\n                                obj=cls,\n                                id='models.E041',\n                            )\n                        )\n        return errors\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7bb3fa4706..bd23369c82 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1559,6 +1559,7 @@ class Model(metaclass=ModelBase):\n             return errors\n \n     @classmethod\n+\n     def _check_unique_together(cls):\n         \"\"\"Check the value of \"unique_together\" option.\"\"\"\n         if not isinstance(cls._meta.unique_together, (tuple, list)):\n@@ -1637,6 +1638,7 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n+\n     def _check_local_fields(cls, fields, option):\n         from django.db import models\n \n@@ -1864,8 +1866,14 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n+\n     def _check_constraints(cls, databases):\n         errors = []\n+        # Add field validation for UniqueConstraints before database feature checks\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n         for db in databases:\n             if not router.allow_migrate_model(db, cls):\n                 continue\n@@ -1891,6 +1899,7 @@ class Model(metaclass=ModelBase):\n             if not (\n                 connection.features.supports_partial_indexes or\n                 'supports_partial_indexes' in cls._meta.required_db_features\n+\n             ) and any(\n                 isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n                 for constraint in cls._meta.constraints\ndiff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex 64bd60484e..8df16c4108 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -77,6 +77,7 @@ class Deferrable(Enum):\n \n \n class UniqueConstraint(BaseConstraint):\n+\n     def __init__(self, *, fields, name, condition=None, deferrable=None):\n         if not fields:\n             raise ValueError('At least one field is required to define a unique constraint.')\n",
    "variant_0": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7bb3fa4706..af6c251dd5 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1559,31 +1559,41 @@ class Model(metaclass=ModelBase):\n             return errors\n \n     @classmethod\n-    def _check_unique_together(cls):\n-        \"\"\"Check the value of \"unique_together\" option.\"\"\"\n-        if not isinstance(cls._meta.unique_together, (tuple, list)):\n-            return [\n-                checks.Error(\n-                    \"'unique_together' must be a list or tuple.\",\n-                    obj=cls,\n-                    id='models.E010',\n-                )\n-            ]\n-\n-        elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.unique_together):\n-            return [\n-                checks.Error(\n-                    \"All 'unique_together' elements must be lists or tuples.\",\n-                    obj=cls,\n-                    id='models.E011',\n-                )\n-            ]\n \n-        else:\n-            errors = []\n-            for fields in cls._meta.unique_together:\n-                errors.extend(cls._check_local_fields(fields, \"unique_together\"))\n-            return errors\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        \n+        # Validate fields in UniqueConstraints\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                if (\n+                    constraint.condition and\n+                    not any(\n+                        'supports_partial_indexes' in db.features.supported_features\n+                        for db in [connections[db_alias] for db_alias in databases]\n+                    )\n+                ):\n+                    errors.append(\n+                        checks.Warning(\n+                            '%s does not support unique constraints with '\n+                            'conditions.' % ', '.join(\n+                                connection.vendor for connection in\n+                                (connections[db_alias] for db_alias in databases)\n+                            ),\n+                            hint=(\n+                                'A constraint will not be created. Silence this '\n+                                'warning if you don\\'t care about it.'\n+                            ),\n+                            obj=cls,\n+                            id='models.W036',\n+                        )\n+                    )\n+        return errors\n \n     @classmethod\n     def _check_indexes(cls, databases):\n@@ -1637,47 +1647,67 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n-    def _check_local_fields(cls, fields, option):\n-        from django.db import models\n-\n-        # In order to avoid hitting the relation tree prematurely, we use our\n-        # own fields_map instead of using get_field()\n-        forward_fields_map = {}\n-        for field in cls._meta._get_fields(reverse=False):\n-            forward_fields_map[field.name] = field\n-            if hasattr(field, 'attname'):\n-                forward_fields_map[field.attname] = field\n \n+    @classmethod\n+    def _check_constraints(cls):\n         errors = []\n-        for field_name in fields:\n-            try:\n-                field = forward_fields_map[field_name]\n-            except KeyError:\n-                errors.append(\n-                    checks.Error(\n-                        \"'%s' refers to the nonexistent field '%s'.\" % (\n-                            option, field_name,\n-                        ),\n-                        obj=cls,\n-                        id='models.E012',\n+        \n+        # Validate UniqueConstraint fields\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, models.UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, models.UniqueConstraint):\n+                if (\n+                    constraint.condition and\n+                    not connections[DEFAULT_DB_ALIAS].features.supports_partial_indexes\n+                ):\n+                    errors.append(\n+                        checks.Warning(\n+                            '%s does not support unique constraints with '\n+                            'conditions.' % connection.display_name,\n+                            hint=(\n+                                'A constraint will not be created. Silence this '\n+                                'warning if you do not care about it.'\n+                            ),\n+                            obj=cls,\n+                            id='models.W036',\n+                        )\n                     )\n-                )\n-            else:\n-                if isinstance(field.remote_field, models.ManyToManyRel):\n+                if (\n+                    constraint.include and\n+                    not connections[DEFAULT_DB_ALIAS].features.supports_covering_indexes\n+                ):\n                     errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to a ManyToManyField '%s', but \"\n-                            \"ManyToManyFields are not permitted in '%s'.\" % (\n-                                option, field_name, option,\n+                        checks.Warning(\n+                            '%s does not support unique constraints with '\n+                            'non-key columns.' % connection.display_name,\n+                            hint=(\n+                                'A constraint will not be created. Silence this '\n+                                'warning if you do not care about it.'\n                             ),\n                             obj=cls,\n-                            id='models.E013',\n+                            id='models.W039',\n                         )\n                     )\n-                elif field not in cls._meta.local_fields:\n+                if (\n+                    constraint.opclasses and\n+                    not connections[DEFAULT_DB_ALIAS].features.supports_covering_indexes\n+                ):\n                     errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to field '%s' which is not local to model '%s'.\"\n+                        checks.Warning(\n+                            '%s does not support unique constraints with '\n+                            'operator classes.' % connection.display_name,\n+                            hint=(\n+                                'A constraint will not be created. Silence this '\n+                                'warning if you do not care about it.'\n+                            ),\n+                            obj=cls,\n+                            id='models.W040',\n+                        )\n+                    )\n+        return errors\n                             % (option, field_name, cls._meta.object_name),\n                             hint=\"This issue may be caused by multi-table inheritance.\",\n                             obj=cls,\n@@ -1863,9 +1893,54 @@ class Model(metaclass=ModelBase):\n \n         return errors\n \n+    @classmethod\n+\n     @classmethod\n     def _check_constraints(cls, databases):\n         errors = []\n+        \n+        # Validate fields in UniqueConstraints\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                'supports_table_check_constraints' in cls._meta.required_db_features\n+            ) and any(\n+                isinstance(constraint, CheckConstraint)\n+                for constraint in cls._meta.constraints\n+            ):\n+                errors.append(\n+                    checks.Warning(\n+                        '%s does not support check constraints.' % connection.display_name,\n+                        hint=(\n+                            \"A constraint won't be created. Silence this \"\n+                            \"warning if you don't care about it.\"\n+                        ),\n+                        obj=cls,\n+                        id='models.W027',\n+                    )\n+                )\n+            if not (\n+                connection.features.supports_partial_indexes or\n+                'supports_partial_indexes' in cls._meta.required_db_features\n+\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        \n+        # Validate UniqueConstraint fields\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(\n+                    cls._check_local_fields(constraint.fields, \"constraints\")\n+                )\n+        \n         for db in databases:\n             if not router.allow_migrate_model(db, cls):\n                 continue\n@@ -1894,6 +1969,20 @@ class Model(metaclass=ModelBase):\n             ) and any(\n                 isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n                 for constraint in cls._meta.constraints\n+            ):\n+                errors.append(\n+                    checks.Warning(\n+                        '%s does not support unique constraints with '\n+                        'conditions.' % connection.display_name,\n+                        hint=(\n+                            \"A constraint won't be created. Silence this \"\n+                            \"warning if you don't care about it.\"\n+                        ),\n+                        obj=cls,\n+                        id='models.W028',\n+                    )\n+                )\n+        return errors\n             ):\n                 errors.append(\n                     checks.Warning(\ndiff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex 64bd60484e..8df16c4108 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -77,6 +77,7 @@ class Deferrable(Enum):\n \n \n class UniqueConstraint(BaseConstraint):\n+\n     def __init__(self, *, fields, name, condition=None, deferrable=None):\n         if not fields:\n             raise ValueError('At least one field is required to define a unique constraint.')\n",
    "variant_1": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7bb3fa4706..1d86c9fd5a 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1559,31 +1559,21 @@ class Model(metaclass=ModelBase):\n             return errors\n \n     @classmethod\n-    def _check_unique_together(cls):\n-        \"\"\"Check the value of \"unique_together\" option.\"\"\"\n-        if not isinstance(cls._meta.unique_together, (tuple, list)):\n-            return [\n-                checks.Error(\n-                    \"'unique_together' must be a list or tuple.\",\n-                    obj=cls,\n-                    id='models.E010',\n-                )\n-            ]\n-\n-        elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.unique_together):\n-            return [\n-                checks.Error(\n-                    \"All 'unique_together' elements must be lists or tuples.\",\n-                    obj=cls,\n-                    id='models.E011',\n-                )\n-            ]\n \n-        else:\n-            errors = []\n-            for fields in cls._meta.unique_together:\n-                errors.extend(cls._check_local_fields(fields, \"unique_together\"))\n-            return errors\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        \n+        # Check field existence for UniqueConstraint\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                if not databases.intersection(constraint.include) and not databases.intersection(constraint.exclude):\n+                    errors.extend(constraint.validate(model=cls, exclude=databases))\n+        return errors\n \n     @classmethod\n     def _check_indexes(cls, databases):\n@@ -1637,47 +1627,67 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n-    def _check_local_fields(cls, fields, option):\n-        from django.db import models\n-\n-        # In order to avoid hitting the relation tree prematurely, we use our\n-        # own fields_map instead of using get_field()\n-        forward_fields_map = {}\n-        for field in cls._meta._get_fields(reverse=False):\n-            forward_fields_map[field.name] = field\n-            if hasattr(field, 'attname'):\n-                forward_fields_map[field.attname] = field\n \n+    @classmethod\n+    def _check_constraints(cls):\n         errors = []\n-        for field_name in fields:\n-            try:\n-                field = forward_fields_map[field_name]\n-            except KeyError:\n-                errors.append(\n-                    checks.Error(\n-                        \"'%s' refers to the nonexistent field '%s'.\" % (\n-                            option, field_name,\n-                        ),\n-                        obj=cls,\n-                        id='models.E012',\n+        \n+        # Check field existence in UniqueConstraints\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                if (\n+                    constraint.condition and\n+                    not connections[DEFAULT_DB_ALIAS].features.supports_partial_indexes\n+                ):\n+                    errors.append(\n+                        checks.Warning(\n+                            '%s does not support unique constraints with '\n+                            'conditions.' % connection.display_name,\n+                            hint=(\n+                                'A constraint will not be created. Silence this '\n+                                'warning if you do not care about it.'\n+                            ),\n+                            obj=cls,\n+                            id='models.W036',\n+                        )\n                     )\n-                )\n-            else:\n-                if isinstance(field.remote_field, models.ManyToManyRel):\n+                if (\n+                    constraint.include and\n+                    not connections[DEFAULT_DB_ALIAS].features.supports_covering_indexes\n+                ):\n                     errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to a ManyToManyField '%s', but \"\n-                            \"ManyToManyFields are not permitted in '%s'.\" % (\n-                                option, field_name, option,\n+                        checks.Warning(\n+                            '%s does not support unique constraints with non-key '\n+                            'columns.' % connection.display_name,\n+                            hint=(\n+                                'A constraint will not be created. Silence this '\n+                                'warning if you do not care about it.'\n                             ),\n                             obj=cls,\n-                            id='models.E013',\n+                            id='models.W039',\n                         )\n                     )\n-                elif field not in cls._meta.local_fields:\n+            if isinstance(constraint, CheckConstraint):\n+                if (\n+                    constraint.condition and\n+                    not connections[DEFAULT_DB_ALIAS].features.supports_table_check_constraints\n+                ):\n                     errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to field '%s' which is not local to model '%s'.\"\n+                        checks.Warning(\n+                            '%s does not support check constraints.' % connection.display_name,\n+                            hint=(\n+                                'A constraint will not be created. Silence this '\n+                                'warning if you do not care about it.'\n+                            ),\n+                            obj=cls,\n+                            id='models.W027',\n+                        )\n+                    )\n+        return errors\n                             % (option, field_name, cls._meta.object_name),\n                             hint=\"This issue may be caused by multi-table inheritance.\",\n                             obj=cls,\n@@ -1863,9 +1873,51 @@ class Model(metaclass=ModelBase):\n \n         return errors\n \n+    @classmethod\n+\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        \n+        # Check field existence for UniqueConstraint\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                'supports_table_check_constraints' in cls._meta.required_db_features\n+            ) and any(\n+                isinstance(constraint, CheckConstraint)\n+                for constraint in cls._meta.constraints\n+            ):\n+                errors.append(\n+                    checks.Warning(\n+                        '%s does not support check constraints.' % connection.display_name,\n+                        hint=(\n+                            \"A constraint won't be created. Silence this \"\n+                            \"warning if you don't care about it.\"\n+                        ),\n+                        obj=cls,\n+                        id='models.W027',\n+                    )\n+                )\n+            if not (\n+                connection.features.supports_partial_indexes or\n+                'supports_partial_indexes' in cls._meta.required_db_features\n+\n     @classmethod\n     def _check_constraints(cls, databases):\n         errors = []\n+        # Validate fields in UniqueConstraint objects\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n         for db in databases:\n             if not router.allow_migrate_model(db, cls):\n                 continue\ndiff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex 64bd60484e..49a6973656 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -77,23 +77,50 @@ class Deferrable(Enum):\n \n \n class UniqueConstraint(BaseConstraint):\n-    def __init__(self, *, fields, name, condition=None, deferrable=None):\n-        if not fields:\n-            raise ValueError('At least one field is required to define a unique constraint.')\n-        if not isinstance(condition, (type(None), Q)):\n-            raise ValueError('UniqueConstraint.condition must be a Q instance.')\n-        if condition and deferrable:\n-            raise ValueError(\n-                'UniqueConstraint with conditions cannot be deferred.'\n-            )\n-        if not isinstance(deferrable, (type(None), Deferrable)):\n-            raise ValueError(\n-                'UniqueConstraint.deferrable must be a Deferrable instance.'\n-            )\n-        self.fields = tuple(fields)\n-        self.condition = condition\n-        self.deferrable = deferrable\n-        super().__init__(name)\n+\n+    @classmethod\n+    def _check_constraints(cls, **kwargs):\n+        errors = []\n+        # Validate fields in UniqueConstraint instances\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, models.UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, models.UniqueConstraint):\n+                if (\n+                    constraint.condition and\n+                    not connection.features.supports_partial_indexes\n+                ):\n+                    errors.append(\n+                        checks.Warning(\n+                            '%s does not support unique constraints with '\n+                            'conditions.' % connection.display_name,\n+                            hint=(\n+                                'A constraint won\\'t be created. Silence this '\n+                                'warning if you don\\'t care about it.'\n+                            ),\n+                            obj=cls,\n+                            id='models.W036',\n+                        )\n+                    )\n+                if (\n+                    constraint.deferrable and\n+                    not connection.features.supports_deferrable_unique_constraints\n+                ):\n+                    errors.append(\n+                        checks.Warning(\n+                            '%s does not support deferrable unique constraints.'\n+                            % connection.display_name,\n+                            hint=(\n+                                'A constraint won\\'t be created. Silence this '\n+                                'warning if you don\\'t care about it.'\n+                            ),\n+                            obj=cls,\n+                            id='models.W038',\n+                        )\n+                    )\n+        return errors\n \n     def _get_condition_sql(self, model, schema_editor):\n         if self.condition is None:\n",
    "variant_2": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7bb3fa4706..38acea8bc9 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1559,31 +1559,52 @@ class Model(metaclass=ModelBase):\n             return errors\n \n     @classmethod\n-    def _check_unique_together(cls):\n-        \"\"\"Check the value of \"unique_together\" option.\"\"\"\n-        if not isinstance(cls._meta.unique_together, (tuple, list)):\n-            return [\n-                checks.Error(\n-                    \"'unique_together' must be a list or tuple.\",\n-                    obj=cls,\n-                    id='models.E010',\n-                )\n-            ]\n-\n-        elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.unique_together):\n-            return [\n-                checks.Error(\n-                    \"All 'unique_together' elements must be lists or tuples.\",\n-                    obj=cls,\n-                    id='models.E011',\n-                )\n-            ]\n \n-        else:\n-            errors = []\n-            for fields in cls._meta.unique_together:\n-                errors.extend(cls._check_local_fields(fields, \"unique_together\"))\n-            return errors\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        \n+        # Validate fields in UniqueConstraints\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                if constraint.condition and not databases:\n+                    errors.append(\n+                        checks.Warning(\n+                            '%s does not support conditional constraints.' % connection.display_name,\n+                            hint=(\n+                                'A constraint will not be created. Silence this '\n+                                'warning if you don\\'t care about it.'\n+                            ),\n+                            obj=cls,\n+                            id='models.W040',\n+                        )\n+                    )\n+                for db in databases:\n+                    if not router.allow_migrate_model(db, cls):\n+                        continue\n+                    connection = connections[db]\n+                    if not (\n+                        'supports_partial_indexes' in self.features.__dict__ and\n+                        connection.features.supports_partial_indexes\n+                    ) or not connection.features.supports_partial_indexes:\n+                        if constraint.condition is not None:\n+                            errors.append(\n+                                checks.Warning(\n+                                    '%s does not support conditional unique constraints.'\n+                                    % connection.display_name,\n+                                    hint=(\n+                                        'A constraint will not be created. Silence this '\n+                                        'warning if you don\\'t care about it.'\n+                                    ),\n+                                    obj=cls,\n+                                    id='models.W040',\n+                                )\n+                            )\n+        return errors\n \n     @classmethod\n     def _check_indexes(cls, databases):\n@@ -1637,47 +1658,51 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n-    def _check_local_fields(cls, fields, option):\n-        from django.db import models\n-\n-        # In order to avoid hitting the relation tree prematurely, we use our\n-        # own fields_map instead of using get_field()\n-        forward_fields_map = {}\n-        for field in cls._meta._get_fields(reverse=False):\n-            forward_fields_map[field.name] = field\n-            if hasattr(field, 'attname'):\n-                forward_fields_map[field.attname] = field\n \n+    @classmethod\n+    def _check_constraints(cls):\n         errors = []\n-        for field_name in fields:\n-            try:\n-                field = forward_fields_map[field_name]\n-            except KeyError:\n-                errors.append(\n-                    checks.Error(\n-                        \"'%s' refers to the nonexistent field '%s'.\" % (\n-                            option, field_name,\n-                        ),\n-                        obj=cls,\n-                        id='models.E012',\n-                    )\n-                )\n-            else:\n-                if isinstance(field.remote_field, models.ManyToManyRel):\n+        \n+        # Validate fields in UniqueConstraints\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                if (\n+                    constraint.condition and\n+                    not connection.features.supports_partial_indexes\n+                ):\n                     errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to a ManyToManyField '%s', but \"\n-                            \"ManyToManyFields are not permitted in '%s'.\" % (\n-                                option, field_name, option,\n+                        checks.Warning(\n+                            '%s does not support unique constraints with '\n+                            'conditions.' % connection.display_name,\n+                            hint=(\n+                                'A constraint without a condition will be '\n+                                'created instead.'\n                             ),\n                             obj=cls,\n-                            id='models.E013',\n+                            id='models.W036',\n                         )\n                     )\n-                elif field not in cls._meta.local_fields:\n+                if (\n+                    constraint.include and\n+                    not connection.features.supports_covering_indexes\n+                ):\n                     errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to field '%s' which is not local to model '%s'.\"\n+                        checks.Warning(\n+                            '%s does not support unique constraints with '\n+                            'non-key columns.' % connection.display_name,\n+                            hint=(\n+                                'A constraint without non-key columns will '\n+                                'be created instead.'\n+                            ),\n+                            obj=cls,\n+                            id='models.W039',\n+                        )\n+                    )\n+        return errors\n                             % (option, field_name, cls._meta.object_name),\n                             hint=\"This issue may be caused by multi-table inheritance.\",\n                             obj=cls,\n@@ -1863,9 +1888,52 @@ class Model(metaclass=ModelBase):\n \n         return errors\n \n+    @classmethod\n+\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        \n+        # Validate fields in UniqueConstraint instances\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                'supports_table_check_constraints' in cls._meta.required_db_features\n+            ) and any(\n+                isinstance(constraint, CheckConstraint)\n+                for constraint in cls._meta.constraints\n+            ):\n+                errors.append(\n+                    checks.Warning(\n+                        '%s does not support check constraints.' % connection.display_name,\n+                        hint=(\n+                            \"A constraint won't be created. Silence this \"\n+                            \"warning if you don't care about it.\"\n+                        ),\n+                        obj=cls,\n+                        id='models.W027',\n+                    )\n+                )\n+            if not (\n+                connection.features.supports_partial_indexes or\n+                'supports_partial_indexes' in cls._meta.required_db_features\n+\n     @classmethod\n     def _check_constraints(cls, databases):\n         errors = []\n+        \n+        # Validate fields in UniqueConstraint instances\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n         for db in databases:\n             if not router.allow_migrate_model(db, cls):\n                 continue\n@@ -1894,6 +1962,20 @@ class Model(metaclass=ModelBase):\n             ) and any(\n                 isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n                 for constraint in cls._meta.constraints\n+            ):\n+                errors.append(\n+                    checks.Warning(\n+                        '%s does not support unique constraints with '\n+                        'conditions.' % connection.display_name,\n+                        hint=(\n+                            \"A constraint won't be created. Silence this \"\n+                            \"warning if you don't care about it.\"\n+                        ),\n+                        obj=cls,\n+                        id='models.W028',\n+                    )\n+                )\n+        return errors\n             ):\n                 errors.append(\n                     checks.Warning(\ndiff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex 64bd60484e..473ea255a2 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -77,23 +77,60 @@ class Deferrable(Enum):\n \n \n class UniqueConstraint(BaseConstraint):\n-    def __init__(self, *, fields, name, condition=None, deferrable=None):\n-        if not fields:\n-            raise ValueError('At least one field is required to define a unique constraint.')\n-        if not isinstance(condition, (type(None), Q)):\n-            raise ValueError('UniqueConstraint.condition must be a Q instance.')\n-        if condition and deferrable:\n-            raise ValueError(\n-                'UniqueConstraint with conditions cannot be deferred.'\n-            )\n-        if not isinstance(deferrable, (type(None), Deferrable)):\n-            raise ValueError(\n-                'UniqueConstraint.deferrable must be a Deferrable instance.'\n-            )\n-        self.fields = tuple(fields)\n-        self.condition = condition\n-        self.deferrable = deferrable\n-        super().__init__(name)\n+\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        \n+        # Validate UniqueConstraint fields exist\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                connection.features.supports_column_check_constraints\n+            ):\n+                continue\n+            for constraint in cls._meta.constraints:\n+                if isinstance(constraint, UniqueConstraint):\n+                    if (\n+                        constraint.condition and\n+                        not connection.features.supports_partial_indexes\n+                    ):\n+                        errors.append(\n+                            checks.Warning(\n+                                f'{constraint.__class__.__name__} with conditions is '\n+                                f'ignored on {connection.display_name}.',\n+                                hint=(\n+                                    f'{connection.display_name} does not support indexes '\n+                                    f'with conditions.'\n+                                ),\n+                                obj=cls,\n+                                id='models.W037',\n+                            )\n+                        )\n+                    if (\n+                        constraint.deferrable and\n+                        not connection.features.supports_deferrable_unique_constraints\n+                    ):\n+                        errors.append(\n+                            checks.Warning(\n+                                f'Deferrable {constraint.__class__.__name__} is ignored '\n+                                f'on {connection.display_name}.',\n+                                hint=(\n+                                    f'{connection.display_name} does not support deferrable '\n+                                    f'unique constraints.'\n+                                ),\n+                                obj=cls,\n+                                id='models.W038',\n+                            )\n+                        )\n+        return errors\n \n     def _get_condition_sql(self, model, schema_editor):\n         if self.condition is None:\n",
    "variant_3": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7bb3fa4706..5544e61880 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1559,31 +1559,42 @@ class Model(metaclass=ModelBase):\n             return errors\n \n     @classmethod\n-    def _check_unique_together(cls):\n-        \"\"\"Check the value of \"unique_together\" option.\"\"\"\n-        if not isinstance(cls._meta.unique_together, (tuple, list)):\n-            return [\n-                checks.Error(\n-                    \"'unique_together' must be a list or tuple.\",\n-                    obj=cls,\n-                    id='models.E010',\n-                )\n-            ]\n-\n-        elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.unique_together):\n-            return [\n-                checks.Error(\n-                    \"All 'unique_together' elements must be lists or tuples.\",\n-                    obj=cls,\n-                    id='models.E011',\n-                )\n-            ]\n \n-        else:\n-            errors = []\n-            for fields in cls._meta.unique_together:\n-                errors.extend(cls._check_local_fields(fields, \"unique_together\"))\n-            return errors\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        # Add field validation for UniqueConstraint instances\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                if (\n+                    constraint.condition and\n+                    not any(\n+                        'supports_partial_indexes' in db.features.__dict__ and\n+                        db.features.supports_partial_indexes\n+                        for db in map(connections.__getitem__, databases)\n+                    )\n+                ):\n+                    errors.append(\n+                        checks.Warning(\n+                            '%s does not support unique constraints with '\n+                            'conditions.' % ', '.join(\n+                                db.display_name for db in map(\n+                                    connections.__getitem__, databases\n+                                )\n+                            ),\n+                            hint=(\n+                                'A constraint will not be created. Silence this '\n+                                'warning if you do not care about it.'\n+                            ),\n+                            obj=cls,\n+                            id='models.W045',\n+                        )\n+                    )\n+        return errors\n \n     @classmethod\n     def _check_indexes(cls, databases):\n@@ -1637,47 +1648,39 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n-    def _check_local_fields(cls, fields, option):\n-        from django.db import models\n-\n-        # In order to avoid hitting the relation tree prematurely, we use our\n-        # own fields_map instead of using get_field()\n-        forward_fields_map = {}\n-        for field in cls._meta._get_fields(reverse=False):\n-            forward_fields_map[field.name] = field\n-            if hasattr(field, 'attname'):\n-                forward_fields_map[field.attname] = field\n \n+    @classmethod\n+    def _check_constraints(cls):\n         errors = []\n-        for field_name in fields:\n-            try:\n-                field = forward_fields_map[field_name]\n-            except KeyError:\n+        \n+        # Validate fields in UniqueConstraint\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n+        for constraint in cls._meta.constraints:\n+            errors.extend(constraint.check())\n+        for db_table in cls._meta.required_db_features:\n+            if not router.allow_migrate_model(db_table, cls):\n+                continue\n+            connection = connections[db_table]\n+            if not (\n+                constraint.supports_validate\n+                and connection.features.supports_over_clause\n+            ):\n                 errors.append(\n-                    checks.Error(\n-                        \"'%s' refers to the nonexistent field '%s'.\" % (\n-                            option, field_name,\n+                    checks.Warning(\n+                        '%s does not support check constraints.'\n+                        % connection.display_name,\n+                        hint=(\n+                            \"A constraint won't be created. Silence this \"\n+                            \"warning if you don't care about it.\"\n                         ),\n                         obj=cls,\n-                        id='models.E012',\n+                        id='models.W027',\n                     )\n                 )\n-            else:\n-                if isinstance(field.remote_field, models.ManyToManyRel):\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to a ManyToManyField '%s', but \"\n-                            \"ManyToManyFields are not permitted in '%s'.\" % (\n-                                option, field_name, option,\n-                            ),\n-                            obj=cls,\n-                            id='models.E013',\n-                        )\n-                    )\n-                elif field not in cls._meta.local_fields:\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to field '%s' which is not local to model '%s'.\"\n+        return errors\n                             % (option, field_name, cls._meta.object_name),\n                             hint=\"This issue may be caused by multi-table inheritance.\",\n                             obj=cls,\n@@ -1863,9 +1866,52 @@ class Model(metaclass=ModelBase):\n \n         return errors\n \n+    @classmethod\n+\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        \n+        # Check UniqueConstraint field validation\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                'supports_table_check_constraints' in cls._meta.required_db_features\n+            ) and any(\n+                isinstance(constraint, CheckConstraint)\n+                for constraint in cls._meta.constraints\n+            ):\n+                errors.append(\n+                    checks.Warning(\n+                        '%s does not support check constraints.' % connection.display_name,\n+                        hint=(\n+                            \"A constraint won't be created. Silence this \"\n+                            \"warning if you don't care about it.\"\n+                        ),\n+                        obj=cls,\n+                        id='models.W027',\n+                    )\n+                )\n+            if not (\n+                connection.features.supports_partial_indexes or\n+                'supports_partial_indexes' in cls._meta.required_db_features\n+\n     @classmethod\n     def _check_constraints(cls, databases):\n         errors = []\n+        \n+        # Validate fields in UniqueConstraint instances\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n         for db in databases:\n             if not router.allow_migrate_model(db, cls):\n                 continue\n@@ -1894,6 +1940,20 @@ class Model(metaclass=ModelBase):\n             ) and any(\n                 isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n                 for constraint in cls._meta.constraints\n+            ):\n+                errors.append(\n+                    checks.Warning(\n+                        '%s does not support unique constraints with '\n+                        'conditions.' % connection.display_name,\n+                        hint=(\n+                            \"A constraint won't be created. Silence this \"\n+                            \"warning if you don't care about it.\"\n+                        ),\n+                        obj=cls,\n+                        id='models.W028',\n+                    )\n+                )\n+        return errors\n             ):\n                 errors.append(\n                     checks.Warning(\ndiff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex 64bd60484e..07fcb00ebb 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -77,23 +77,60 @@ class Deferrable(Enum):\n \n \n class UniqueConstraint(BaseConstraint):\n-    def __init__(self, *, fields, name, condition=None, deferrable=None):\n-        if not fields:\n-            raise ValueError('At least one field is required to define a unique constraint.')\n-        if not isinstance(condition, (type(None), Q)):\n-            raise ValueError('UniqueConstraint.condition must be a Q instance.')\n-        if condition and deferrable:\n-            raise ValueError(\n-                'UniqueConstraint with conditions cannot be deferred.'\n-            )\n-        if not isinstance(deferrable, (type(None), Deferrable)):\n-            raise ValueError(\n-                'UniqueConstraint.deferrable must be a Deferrable instance.'\n-            )\n-        self.fields = tuple(fields)\n-        self.condition = condition\n-        self.deferrable = deferrable\n-        super().__init__(name)\n+\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(\n+                    cls._check_local_fields(constraint.fields, \"constraints\")\n+                )\n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_partial_indexes or\n+                connection.features.supports_deferrable_unique_constraints\n+            ):\n+                continue\n+            for constraint in cls._meta.constraints:\n+                if not isinstance(constraint, UniqueConstraint):\n+                    continue\n+                if (\n+                    constraint.condition and\n+                    not connection.features.supports_partial_indexes\n+                ):\n+                    errors.append(\n+                        checks.Warning(\n+                            '%s does not support unique constraints with '\n+                            'conditions.' % connection.display_name,\n+                            hint=(\n+                                'A constraint will not be created. Silence this '\n+                                'warning if you don\\'t care about it.'\n+                            ),\n+                            obj=cls,\n+                            id='models.W036',\n+                        )\n+                    )\n+                if (\n+                    constraint.deferrable and\n+                    not connection.features.supports_deferrable_unique_constraints\n+                ):\n+                    errors.append(\n+                        checks.Warning(\n+                            '%s does not support deferrable unique constraints.'\n+                            % connection.display_name,\n+                            hint=(\n+                                'A constraint will not be created. Silence this '\n+                                'warning if you don\\'t care about it.'\n+                            ),\n+                            obj=cls,\n+                            id='models.W038',\n+                        )\n+                    )\n+        return errors\n \n     def _get_condition_sql(self, model, schema_editor):\n         if self.condition is None:\n",
    "variant_4": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7bb3fa4706..b0bb00188d 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1559,31 +1559,82 @@ class Model(metaclass=ModelBase):\n             return errors\n \n     @classmethod\n-    def _check_unique_together(cls):\n-        \"\"\"Check the value of \"unique_together\" option.\"\"\"\n-        if not isinstance(cls._meta.unique_together, (tuple, list)):\n-            return [\n-                checks.Error(\n-                    \"'unique_together' must be a list or tuple.\",\n-                    obj=cls,\n-                    id='models.E010',\n-                )\n-            ]\n \n-        elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.unique_together):\n-            return [\n-                checks.Error(\n-                    \"All 'unique_together' elements must be lists or tuples.\",\n-                    obj=cls,\n-                    id='models.E011',\n-                )\n-            ]\n-\n-        else:\n-            errors = []\n-            for fields in cls._meta.unique_together:\n-                errors.extend(cls._check_local_fields(fields, \"unique_together\"))\n-            return errors\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        # Add field validation for UniqueConstraint fields\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n+        for constraint in cls._meta.constraints:\n+            errors.extend(constraint.check())\n+        for constraint in cls._meta.constraints:\n+            if not isinstance(constraint, UniqueConstraint):\n+                continue\n+            for db in databases:\n+                if not router.allow_migrate_model(db, cls):\n+                    continue\n+                connection = connections[db]\n+                if not (\n+                    connection.features.supports_partial_indexes\n+                    or 'condition' not in constraint.deconstruct()[2]\n+                ):\n+                    errors.append(\n+                        checks.Warning(\n+                            '%s does not support unique constraints with '\n+                            'conditions.' % connection.display_name,\n+                            hint=(\n+                                'A constraint will not be created. Silence this '\n+                                'warning if you don\\'t care about it.'\n+                            ),\n+                            obj=cls,\n+                            id='models.W036',\n+                        )\n+                    )\n+                if not (\n+                    connection.features.supports_deferrable_unique_constraints or\n+                    'deferrable' not in constraint.deconstruct()[2]\n+                ):\n+                    errors.append(\n+                        checks.Warning(\n+                            '%s does not support deferrable unique constraints.'\n+                            % connection.display_name,\n+                            hint=(\n+                                'A constraint will not be created. Silence this '\n+                                'warning if you don\\'t care about it.'\n+                            ),\n+                            obj=cls,\n+                            id='models.W038',\n+                        )\n+                    )\n+                if not connection.features.supports_covering_indexes:\n+                    covering_columns = getattr(constraint, 'include', None)\n+                    if covering_columns:\n+                        errors.append(\n+                            checks.Warning(\n+                                'db_index on field(s) %r will not be created on %s '\n+                                'because the database does not support covering '\n+                                'indexes.' % (covering_columns, connection.display_name),\n+                                hint=\"Silence this warning if you don't care about it.\",\n+                                obj=cls,\n+                                id='models.W042',\n+                            )\n+                        )\n+                opclass = getattr(constraint, 'opclasses', None)\n+                if opclass and not connection.features.supports_over_clause:\n+                    errors.append(\n+                        checks.Warning(\n+                            'opclasses on constraint %r will not be created on %s '\n+                            'because the database does not support operator classes.'\n+                            % (constraint.name, connection.display_name),\n+                            hint=\"Silence this warning if you don't care about it.\",\n+                            obj=cls,\n+                            id='models.W043',\n+                        )\n+                    )\n+        return errors\n \n     @classmethod\n     def _check_indexes(cls, databases):\n@@ -1637,47 +1688,42 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n-    def _check_local_fields(cls, fields, option):\n-        from django.db import models\n-\n-        # In order to avoid hitting the relation tree prematurely, we use our\n-        # own fields_map instead of using get_field()\n-        forward_fields_map = {}\n-        for field in cls._meta._get_fields(reverse=False):\n-            forward_fields_map[field.name] = field\n-            if hasattr(field, 'attname'):\n-                forward_fields_map[field.attname] = field\n \n+    @classmethod\n+    def _check_constraints(cls):\n         errors = []\n-        for field_name in fields:\n-            try:\n-                field = forward_fields_map[field_name]\n-            except KeyError:\n-                errors.append(\n-                    checks.Error(\n-                        \"'%s' refers to the nonexistent field '%s'.\" % (\n-                            option, field_name,\n-                        ),\n-                        obj=cls,\n-                        id='models.E012',\n-                    )\n-                )\n-            else:\n-                if isinstance(field.remote_field, models.ManyToManyRel):\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to a ManyToManyField '%s', but \"\n-                            \"ManyToManyFields are not permitted in '%s'.\" % (\n-                                option, field_name, option,\n-                            ),\n-                            obj=cls,\n-                            id='models.E013',\n-                        )\n-                    )\n-                elif field not in cls._meta.local_fields:\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to field '%s' which is not local to model '%s'.\"\n+        \n+        # Check UniqueConstraint fields for existence\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n+        for db in settings.DATABASES:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                connection.features.supports_column_check_constraints\n+            ):\n+                continue\n+            for constraint in cls._meta.constraints:\n+                if isinstance(constraint, CheckConstraint):\n+                    if not connection.features.supports_over_clause:\n+                        if constraint.check.contains_over_clause:\n+                            errors.append(\n+                                checks.Warning(\n+                                    '%s does not support check constraints with '\n+                                    'Window expressions.' % connection.display_name,\n+                                    hint=(\n+                                        'A constraint will not be created. Silence '\n+                                        'this warning if you don\\'t care about it.'\n+                                    ),\n+                                    obj=cls,\n+                                    id='models.W039',\n+                                )\n+                            )\n+        return errors\n                             % (option, field_name, cls._meta.object_name),\n                             hint=\"This issue may be caused by multi-table inheritance.\",\n                             obj=cls,\n@@ -1863,9 +1909,53 @@ class Model(metaclass=ModelBase):\n \n         return errors\n \n+    @classmethod\n+\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        # Validate fields in UniqueConstraints\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                'supports_table_check_constraints' in cls._meta.required_db_features\n+            ) and any(\n+                isinstance(constraint, CheckConstraint)\n+                for constraint in cls._meta.constraints\n+            ):\n+                errors.append(\n+                    checks.Warning(\n+                        '%s does not support check constraints.' % connection.display_name,\n+                        hint=(\n+                            \"A constraint won't be created. Silence this \"\n+                            \"warning if you don't care about it.\"\n+                        ),\n+                        obj=cls,\n+                        id='models.W027',\n+                    )\n+                )\n+            if not (\n+                connection.features.supports_partial_indexes or\n+                'supports_partial_indexes' in cls._meta.required_db_features\n+\n     @classmethod\n     def _check_constraints(cls, databases):\n         errors = []\n+        \n+        # Validate fields in UniqueConstraint instances\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(\n+                    cls._check_local_fields(constraint.fields, \"constraints\")\n+                )\n+        \n         for db in databases:\n             if not router.allow_migrate_model(db, cls):\n                 continue\n@@ -1894,6 +1984,7 @@ class Model(metaclass=ModelBase):\n             ) and any(\n                 isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n                 for constraint in cls._meta.constraints\n+            ):\n             ):\n                 errors.append(\n                     checks.Warning(\ndiff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex 64bd60484e..636cbee93f 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -77,23 +77,39 @@ class Deferrable(Enum):\n \n \n class UniqueConstraint(BaseConstraint):\n-    def __init__(self, *, fields, name, condition=None, deferrable=None):\n-        if not fields:\n-            raise ValueError('At least one field is required to define a unique constraint.')\n-        if not isinstance(condition, (type(None), Q)):\n-            raise ValueError('UniqueConstraint.condition must be a Q instance.')\n-        if condition and deferrable:\n-            raise ValueError(\n-                'UniqueConstraint with conditions cannot be deferred.'\n-            )\n-        if not isinstance(deferrable, (type(None), Deferrable)):\n-            raise ValueError(\n-                'UniqueConstraint.deferrable must be a Deferrable instance.'\n-            )\n-        self.fields = tuple(fields)\n-        self.condition = condition\n-        self.deferrable = deferrable\n-        super().__init__(name)\n+\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        \n+        # Validate UniqueConstraint fields\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            for constraint in cls._meta.constraints:\n+                if isinstance(constraint, UniqueConstraint):\n+                    if (\n+                        connection.features.supports_partial_indexes or\n+                        'supports_partial_indexes' in cls._meta.required_db_features\n+                    ):\n+                        continue\n+                    if constraint.condition is not None:\n+                        errors.append(\n+                            checks.Warning(\n+                                f'{constraint.__class__.__name__} with conditions ignored on {connection.vendor}.',\n+                                hint=(\n+                                    f'{connection.display_name} does not support unique constraints with conditions.'\n+                                ),\n+                                obj=cls,\n+                                id='models.W036',\n+                            )\n+                        )\n+        return errors\n \n     def _get_condition_sql(self, model, schema_editor):\n         if self.condition is None:\n",
    "variant_5": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7bb3fa4706..54fd5f6892 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1559,31 +1559,60 @@ class Model(metaclass=ModelBase):\n             return errors\n \n     @classmethod\n-    def _check_unique_together(cls):\n-        \"\"\"Check the value of \"unique_together\" option.\"\"\"\n-        if not isinstance(cls._meta.unique_together, (tuple, list)):\n-            return [\n-                checks.Error(\n-                    \"'unique_together' must be a list or tuple.\",\n-                    obj=cls,\n-                    id='models.E010',\n-                )\n-            ]\n \n-        elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.unique_together):\n-            return [\n-                checks.Error(\n-                    \"All 'unique_together' elements must be lists or tuples.\",\n-                    obj=cls,\n-                    id='models.E011',\n-                )\n-            ]\n-\n-        else:\n-            errors = []\n-            for fields in cls._meta.unique_together:\n-                errors.extend(cls._check_local_fields(fields, \"unique_together\"))\n-            return errors\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        # Check field existence for UniqueConstraints\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                for db in databases:\n+                    if not router.allow_migrate_model(db, cls):\n+                        continue\n+                    connection = connections[db]\n+                    if not (\n+                        connection.features.supports_partial_indexes\n+                        or 'supports_partial_indexes' in cls._meta.required_db_features\n+                    ):\n+                        if constraint.condition is not None:\n+                            errors.append(\n+                                checks.Warning(\n+                                    '%s does not support unique constraints with '\n+                                    'conditions.' % connection.display_name,\n+                                    hint=(\n+                                        'A constraint will be created without '\n+                                        'a condition. You should add '\n+                                        '\"supports_partial_indexes\" to '\n+                                        'Meta.required_db_features.'\n+                                    ),\n+                                    obj=cls,\n+                                    id='models.W045',\n+                                )\n+                            )\n+                    if not (\n+                        connection.features.supports_deferrable_unique_constraints\n+                        or 'supports_deferrable_unique_constraints' in cls._meta.required_db_features\n+                    ):\n+                        if constraint.deferrable is not None:\n+                            errors.append(\n+                                checks.Warning(\n+                                    '%s does not support deferrable unique constraints.'\n+                                    % connection.display_name,\n+                                    hint=(\n+                                        'A constraint will be created without '\n+                                        'deferrable. You should add '\n+                                        '\"supports_deferrable_unique_constraints\" to '\n+                                        'Meta.required_db_features.'\n+                                    ),\n+                                    obj=cls,\n+                                    id='models.W046',\n+                                )\n+                            )\n+        return errors\n \n     @classmethod\n     def _check_indexes(cls, databases):\n@@ -1637,47 +1666,59 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n-    def _check_local_fields(cls, fields, option):\n-        from django.db import models\n-\n-        # In order to avoid hitting the relation tree prematurely, we use our\n-        # own fields_map instead of using get_field()\n-        forward_fields_map = {}\n-        for field in cls._meta._get_fields(reverse=False):\n-            forward_fields_map[field.name] = field\n-            if hasattr(field, 'attname'):\n-                forward_fields_map[field.attname] = field\n \n+    @classmethod\n+    def _check_constraints(cls):\n         errors = []\n-        for field_name in fields:\n-            try:\n-                field = forward_fields_map[field_name]\n-            except KeyError:\n-                errors.append(\n-                    checks.Error(\n-                        \"'%s' refers to the nonexistent field '%s'.\" % (\n-                            option, field_name,\n-                        ),\n-                        obj=cls,\n-                        id='models.E012',\n-                    )\n-                )\n-            else:\n-                if isinstance(field.remote_field, models.ManyToManyRel):\n+        \n+        # Check field validation for UniqueConstraints\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                if (\n+                    constraint.condition and\n+                    not connection.features.supports_partial_indexes\n+                ):\n                     errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to a ManyToManyField '%s', but \"\n-                            \"ManyToManyFields are not permitted in '%s'.\" % (\n-                                option, field_name, option,\n+                        checks.Warning(\n+                            '%s does not support unique constraints with '\n+                            'conditions.' % connection.display_name,\n+                            hint=(\n+                                'A constraint will be created without a condition. '\n+                                'A unique constraint may be violated.'\n                             ),\n                             obj=cls,\n-                            id='models.E013',\n+                            id='models.W039',\n                         )\n                     )\n-                elif field not in cls._meta.local_fields:\n+                if (\n+                    constraint.include and\n+                    not connection.features.supports_covering_indexes\n+                ):\n                     errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to field '%s' which is not local to model '%s'.\"\n+                        checks.Warning(\n+                            '%s does not support unique constraints with INCLUDE '\n+                            'fields.' % connection.display_name,\n+                            obj=cls,\n+                            id='models.W040',\n+                        )\n+                    )\n+                if (\n+                    constraint.opclasses and\n+                    not connection.features.supports_covering_indexes\n+                ):\n+                    errors.append(\n+                        checks.Warning(\n+                            '%s does not support unique constraints with opclasses.'\n+                            % connection.display_name,\n+                            obj=cls,\n+                            id='models.W041',\n+                        )\n+                    )\n+        return errors\n                             % (option, field_name, cls._meta.object_name),\n                             hint=\"This issue may be caused by multi-table inheritance.\",\n                             obj=cls,\n@@ -1863,9 +1904,52 @@ class Model(metaclass=ModelBase):\n \n         return errors\n \n+    @classmethod\n+\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        \n+        # Validate fields in UniqueConstraint instances\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                'supports_table_check_constraints' in cls._meta.required_db_features\n+            ) and any(\n+                isinstance(constraint, CheckConstraint)\n+                for constraint in cls._meta.constraints\n+            ):\n+                errors.append(\n+                    checks.Warning(\n+                        '%s does not support check constraints.' % connection.display_name,\n+                        hint=(\n+                            \"A constraint won't be created. Silence this \"\n+                            \"warning if you don't care about it.\"\n+                        ),\n+                        obj=cls,\n+                        id='models.W027',\n+                    )\n+                )\n+            if not (\n+                connection.features.supports_partial_indexes or\n+                'supports_partial_indexes' in cls._meta.required_db_features\n+\n     @classmethod\n     def _check_constraints(cls, databases):\n         errors = []\n+        \n+        # Validate fields in UniqueConstraints\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n         for db in databases:\n             if not router.allow_migrate_model(db, cls):\n                 continue\n@@ -1894,6 +1978,7 @@ class Model(metaclass=ModelBase):\n             ) and any(\n                 isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n                 for constraint in cls._meta.constraints\n+            ):\n             ):\n                 errors.append(\n                     checks.Warning(\ndiff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex 64bd60484e..86c2869844 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -77,23 +77,64 @@ class Deferrable(Enum):\n \n \n class UniqueConstraint(BaseConstraint):\n-    def __init__(self, *, fields, name, condition=None, deferrable=None):\n-        if not fields:\n-            raise ValueError('At least one field is required to define a unique constraint.')\n-        if not isinstance(condition, (type(None), Q)):\n-            raise ValueError('UniqueConstraint.condition must be a Q instance.')\n-        if condition and deferrable:\n-            raise ValueError(\n-                'UniqueConstraint with conditions cannot be deferred.'\n-            )\n-        if not isinstance(deferrable, (type(None), Deferrable)):\n-            raise ValueError(\n-                'UniqueConstraint.deferrable must be a Deferrable instance.'\n-            )\n-        self.fields = tuple(fields)\n-        self.condition = condition\n-        self.deferrable = deferrable\n-        super().__init__(name)\n+\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        \n+        # Validate UniqueConstraint fields\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                connection.features.supports_column_check_constraints\n+            ):\n+                continue\n+            for constraint in cls._meta.constraints:\n+                if isinstance(constraint, UniqueConstraint):\n+                    if (\n+                        constraint.condition and\n+                        not connection.features.supports_partial_indexes\n+                    ):\n+                        errors.append(\n+                            checks.Warning(\n+                                '%s does not support unique constraints with '\n+                                'conditions.' % connection.display_name,\n+                                hint=(\n+                                    'A constraint without a condition will be '\n+                                    'created. Silence this warning if this is '\n+                                    'intended.'\n+                                ),\n+                                obj=cls,\n+                                id='models.W040',\n+                            )\n+                        )\n+                    if (\n+                        constraint.deferrable and\n+                        not connection.features.supports_deferrable_unique_constraints\n+                    ):\n+                        errors.append(\n+                            checks.Warning(\n+                                '%s does not support deferrable unique constraints.'\n+                                % connection.display_name,\n+                                hint=(\n+                                    'A non-deferrable unique constraint will be '\n+                                    'created. Silence this warning if this is '\n+                                    'intended.'\n+                                ),\n+                                obj=cls,\n+                                id='models.W041',\n+                            )\n+                        )\n+                else:\n+                    constraint.validate(model=cls, exclude=None)\n+        return errors\n \n     def _get_condition_sql(self, model, schema_editor):\n         if self.condition is None:\n",
    "variant_6": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7bb3fa4706..f7fe9c2676 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1559,31 +1559,39 @@ class Model(metaclass=ModelBase):\n             return errors\n \n     @classmethod\n-    def _check_unique_together(cls):\n-        \"\"\"Check the value of \"unique_together\" option.\"\"\"\n-        if not isinstance(cls._meta.unique_together, (tuple, list)):\n-            return [\n-                checks.Error(\n-                    \"'unique_together' must be a list or tuple.\",\n-                    obj=cls,\n-                    id='models.E010',\n-                )\n-            ]\n-\n-        elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.unique_together):\n-            return [\n-                checks.Error(\n-                    \"All 'unique_together' elements must be lists or tuples.\",\n-                    obj=cls,\n-                    id='models.E011',\n-                )\n-            ]\n \n-        else:\n-            errors = []\n-            for fields in cls._meta.unique_together:\n-                errors.extend(cls._check_local_fields(fields, \"unique_together\"))\n-            return errors\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        \n+        # Validate UniqueConstraint fields exist\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                if (\n+                    constraint.condition and\n+                    not any(\n+                        'supports_partial_indexes' in db.features.__dict__ and\n+                        db.features.supports_partial_indexes\n+                        for db in [connections[db_alias] for db_alias in databases]\n+                    )\n+                ):\n+                    errors.append(\n+                        checks.Warning(\n+                            '%s does not support unique constraints with '\n+                            'conditions.' % connection.display_name,\n+                            hint=(\n+                                'A constraint will not be created. Silence this '\n+                                'warning if you do not care about it.'\n+                            ),\n+                            obj=cls,\n+                            id='models.W045',\n+                        )\n+                    )\n+        return errors\n \n     @classmethod\n     def _check_indexes(cls, databases):\n@@ -1637,47 +1645,67 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n-    def _check_local_fields(cls, fields, option):\n-        from django.db import models\n-\n-        # In order to avoid hitting the relation tree prematurely, we use our\n-        # own fields_map instead of using get_field()\n-        forward_fields_map = {}\n-        for field in cls._meta._get_fields(reverse=False):\n-            forward_fields_map[field.name] = field\n-            if hasattr(field, 'attname'):\n-                forward_fields_map[field.attname] = field\n \n+    @classmethod\n+    def _check_constraints(cls):\n         errors = []\n-        for field_name in fields:\n-            try:\n-                field = forward_fields_map[field_name]\n-            except KeyError:\n-                errors.append(\n-                    checks.Error(\n-                        \"'%s' refers to the nonexistent field '%s'.\" % (\n-                            option, field_name,\n-                        ),\n-                        obj=cls,\n-                        id='models.E012',\n+        \n+        # Check UniqueConstraint field validation\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                if (\n+                    constraint.condition and\n+                    not connections[DEFAULT_DB_ALIAS].features.supports_partial_indexes\n+                ):\n+                    errors.append(\n+                        checks.Warning(\n+                            '%s does not support unique constraints with '\n+                            'conditions.' % connection.display_name,\n+                            hint=(\n+                                'A constraint will not be created. Silence this '\n+                                'warning if you do not care about it.'\n+                            ),\n+                            obj=cls,\n+                            id='models.W036',\n+                        )\n                     )\n-                )\n-            else:\n-                if isinstance(field.remote_field, models.ManyToManyRel):\n+                if (\n+                    constraint.include and\n+                    not connections[DEFAULT_DB_ALIAS].features.supports_covering_indexes\n+                ):\n                     errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to a ManyToManyField '%s', but \"\n-                            \"ManyToManyFields are not permitted in '%s'.\" % (\n-                                option, field_name, option,\n+                        checks.Warning(\n+                            '%s does not support unique constraints with covering '\n+                            'fields.' % connection.display_name,\n+                            hint=(\n+                                'A constraint will not be created. Silence this '\n+                                'warning if you do not care about it.'\n                             ),\n                             obj=cls,\n-                            id='models.E013',\n+                            id='models.W042',\n                         )\n                     )\n-                elif field not in cls._meta.local_fields:\n+                if (\n+                    constraint.include and constraint.condition and\n+                    not connections[DEFAULT_DB_ALIAS].features.supports_covering_indexes\n+                ):\n                     errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to field '%s' which is not local to model '%s'.\"\n+                        checks.Warning(\n+                            '%s does not support unique constraints with covering '\n+                            'fields and conditions.' % connection.display_name,\n+                            hint=(\n+                                'A constraint will not be created. Silence this '\n+                                'warning if you do not care about it.'\n+                            ),\n+                            obj=cls,\n+                            id='models.W043',\n+                        )\n+                    )\n+        return errors\n                             % (option, field_name, cls._meta.object_name),\n                             hint=\"This issue may be caused by multi-table inheritance.\",\n                             obj=cls,\n@@ -1863,9 +1891,53 @@ class Model(metaclass=ModelBase):\n \n         return errors\n \n+    @classmethod\n+\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        # Validate fields in UniqueConstraint instances\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                'supports_table_check_constraints' in cls._meta.required_db_features\n+            ) and any(\n+                isinstance(constraint, CheckConstraint)\n+                for constraint in cls._meta.constraints\n+            ):\n+                errors.append(\n+                    checks.Warning(\n+                        '%s does not support check constraints.' % connection.display_name,\n+                        hint=(\n+                            \"A constraint won't be created. Silence this \"\n+                            \"warning if you don't care about it.\"\n+                        ),\n+                        obj=cls,\n+                        id='models.W027',\n+                    )\n+                )\n+            if not (\n+                connection.features.supports_partial_indexes or\n+                'supports_partial_indexes' in cls._meta.required_db_features\n+\n     @classmethod\n     def _check_constraints(cls, databases):\n         errors = []\n+        \n+        # Validate fields in UniqueConstraint instances\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(\n+                    cls._check_local_fields(constraint.fields, \"constraints\")\n+                )\n+        \n         for db in databases:\n             if not router.allow_migrate_model(db, cls):\n                 continue\n@@ -1894,6 +1966,7 @@ class Model(metaclass=ModelBase):\n             ) and any(\n                 isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n                 for constraint in cls._meta.constraints\n+            ):\n             ):\n                 errors.append(\n                     checks.Warning(\ndiff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex 64bd60484e..beb584909b 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -77,23 +77,38 @@ class Deferrable(Enum):\n \n \n class UniqueConstraint(BaseConstraint):\n-    def __init__(self, *, fields, name, condition=None, deferrable=None):\n-        if not fields:\n-            raise ValueError('At least one field is required to define a unique constraint.')\n-        if not isinstance(condition, (type(None), Q)):\n-            raise ValueError('UniqueConstraint.condition must be a Q instance.')\n-        if condition and deferrable:\n-            raise ValueError(\n-                'UniqueConstraint with conditions cannot be deferred.'\n-            )\n-        if not isinstance(deferrable, (type(None), Deferrable)):\n-            raise ValueError(\n-                'UniqueConstraint.deferrable must be a Deferrable instance.'\n-            )\n-        self.fields = tuple(fields)\n-        self.condition = condition\n-        self.deferrable = deferrable\n-        super().__init__(name)\n+\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        \n+        # Validate UniqueConstraint fields exist on the model\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(\n+                    cls._check_local_fields(constraint.fields, \"constraints\")\n+                )\n+        \n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                connection.features.supports_column_check_constraints\n+            ):\n+                continue\n+            for constraint in cls._meta.constraints:\n+                constraint_databases = getattr(constraint, 'databases', None)\n+                if constraint_databases is not None and db not in constraint_databases:\n+                    continue\n+                if (\n+                    isinstance(constraint, UniqueConstraint) and\n+                    connection.features.supports_partial_indexes\n+                ):\n+                    continue\n+                errors.extend(constraint.validate(model=cls, instance=None, exclude=None, using=db))\n+        return errors\n \n     def _get_condition_sql(self, model, schema_editor):\n         if self.condition is None:\n",
    "variant_7": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7bb3fa4706..5a3e8a75f1 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1559,31 +1559,18 @@ class Model(metaclass=ModelBase):\n             return errors\n \n     @classmethod\n-    def _check_unique_together(cls):\n-        \"\"\"Check the value of \"unique_together\" option.\"\"\"\n-        if not isinstance(cls._meta.unique_together, (tuple, list)):\n-            return [\n-                checks.Error(\n-                    \"'unique_together' must be a list or tuple.\",\n-                    obj=cls,\n-                    id='models.E010',\n-                )\n-            ]\n-\n-        elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.unique_together):\n-            return [\n-                checks.Error(\n-                    \"All 'unique_together' elements must be lists or tuples.\",\n-                    obj=cls,\n-                    id='models.E011',\n-                )\n-            ]\n \n-        else:\n-            errors = []\n-            for fields in cls._meta.unique_together:\n-                errors.extend(cls._check_local_fields(fields, \"unique_together\"))\n-            return errors\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        for constraint in cls._meta.constraints:\n+            # Check field existence for UniqueConstraint\n+            if constraint.__class__.__name__ == 'UniqueConstraint':\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+            \n+            # Check database feature support\n+            errors.extend(constraint.check(using=database) for database in databases)\n+        return errors\n \n     @classmethod\n     def _check_indexes(cls, databases):\n@@ -1637,47 +1624,38 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n-    def _check_local_fields(cls, fields, option):\n-        from django.db import models\n-\n-        # In order to avoid hitting the relation tree prematurely, we use our\n-        # own fields_map instead of using get_field()\n-        forward_fields_map = {}\n-        for field in cls._meta._get_fields(reverse=False):\n-            forward_fields_map[field.name] = field\n-            if hasattr(field, 'attname'):\n-                forward_fields_map[field.attname] = field\n \n+    @classmethod\n+    def _check_constraints(cls):\n         errors = []\n-        for field_name in fields:\n-            try:\n-                field = forward_fields_map[field_name]\n-            except KeyError:\n-                errors.append(\n-                    checks.Error(\n-                        \"'%s' refers to the nonexistent field '%s'.\" % (\n-                            option, field_name,\n-                        ),\n-                        obj=cls,\n-                        id='models.E012',\n-                    )\n-                )\n-            else:\n-                if isinstance(field.remote_field, models.ManyToManyRel):\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to a ManyToManyField '%s', but \"\n-                            \"ManyToManyFields are not permitted in '%s'.\" % (\n-                                option, field_name, option,\n-                            ),\n-                            obj=cls,\n-                            id='models.E013',\n+        # Check field existence for UniqueConstraint instances\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                if (not constraint.condition and\n+                        constraint.fields and\n+                        not any(name in constraint.fields for name in cls._meta._non_pk_concrete_field_names) and\n+                        not constraint.include and\n+                        not constraint.opclasses):\n+                    if not any(\n+                            isinstance(field, (models.DateField, models.DateTimeField, models.TimeField))\n+                            for field in (cls._meta.get_field(field_name) for field_name in constraint.fields)\n+                    ):\n+                        errors.append(\n+                            checks.Warning(\n+                                '%s constraint on model %s contains no concrete fields; '\n+                                'perhaps you meant to use unique_together instead?' % (\n+                                    constraint.__class__.__name__, cls.__name__,\n+                                ),\n+                                obj=cls,\n+                                id='models.W039',\n+                            )\n                         )\n-                    )\n-                elif field not in cls._meta.local_fields:\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to field '%s' which is not local to model '%s'.\"\n+            \n+        return errors\n                             % (option, field_name, cls._meta.object_name),\n                             hint=\"This issue may be caused by multi-table inheritance.\",\n                             obj=cls,\n@@ -1863,9 +1841,16 @@ class Model(metaclass=ModelBase):\n \n         return errors\n \n+    @classmethod\n+\n     @classmethod\n     def _check_constraints(cls, databases):\n         errors = []\n+        # Validate fields in UniqueConstraint instances\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n         for db in databases:\n             if not router.allow_migrate_model(db, cls):\n                 continue\n@@ -1891,9 +1876,61 @@ class Model(metaclass=ModelBase):\n             if not (\n                 connection.features.supports_partial_indexes or\n                 'supports_partial_indexes' in cls._meta.required_db_features\n+\n+    @classmethod\n+    def _check_constraints(cls, **kwargs):\n+        errors = []\n+        # Check field validation for UniqueConstraint\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n+        # Check database feature support\n+        for db in settings.DATABASES.values():\n+            if db['ENGINE'] not in (\n+                'django.db.backends.postgresql',\n+                'django.db.backends.sqlite3',\n+            ):\n+                continue\n+            connection = connections[db_alias] if 'db_alias' in locals() else connections[DEFAULT_DB_ALIAS]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                'supports_table_check_constraints' in cls._meta.required_db_features\n+            ) and any(\n+                isinstance(constraint, CheckConstraint) and constraint.check is not None\n+                for constraint in cls._meta.constraints\n+            ):\n+                errors.append(\n+                    checks.Warning(\n+                        '%s does not support check constraints.' % connection.display_name,\n+                        hint=(\n+                            \"A constraint won't be created. Silence this \"\n+                            \"warning if you don't care about it.\"\n+                        ),\n+                        obj=cls,\n+                        id='models.W027',\n+                    )\n+                )\n+            if not (\n+                connection.features.supports_partial_indexes or\n+                'supports_partial_indexes' in cls._meta.required_db_features\n             ) and any(\n                 isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n                 for constraint in cls._meta.constraints\n+            ):\n+                errors.append(\n+                    checks.Warning(\n+                        '%s does not support unique constraints with '\n+                        'conditions.' % connection.display_name,\n+                        hint=(\n+                            \"A constraint won't be created. Silence this \"\n+                            \"warning if you don't care about it.\"\n+                        ),\n+                        obj=cls,\n+                        id='models.W028',\n+                    )\n+                )\n+        return errors\n             ):\n                 errors.append(\n                     checks.Warning(\ndiff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex 64bd60484e..e633649898 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -77,23 +77,81 @@ class Deferrable(Enum):\n \n \n class UniqueConstraint(BaseConstraint):\n-    def __init__(self, *, fields, name, condition=None, deferrable=None):\n-        if not fields:\n-            raise ValueError('At least one field is required to define a unique constraint.')\n-        if not isinstance(condition, (type(None), Q)):\n-            raise ValueError('UniqueConstraint.condition must be a Q instance.')\n-        if condition and deferrable:\n-            raise ValueError(\n-                'UniqueConstraint with conditions cannot be deferred.'\n-            )\n-        if not isinstance(deferrable, (type(None), Deferrable)):\n-            raise ValueError(\n-                'UniqueConstraint.deferrable must be a Deferrable instance.'\n-            )\n-        self.fields = tuple(fields)\n-        self.condition = condition\n-        self.deferrable = deferrable\n-        super().__init__(name)\n+\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        \n+        # Validate UniqueConstraint fields\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(\n+                    cls._check_local_fields(constraint.fields, \"constraints\")\n+                )\n+        \n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                connection.features.supports_column_check_constraints\n+            ):\n+                continue\n+            for constraint in cls._meta.constraints:\n+                if isinstance(constraint, CheckConstraint):\n+                    if not connection.features.supports_over_clause:\n+                        constraint_sql = constraint.constraint.as_sql(\n+                            compiler=connection.ops.compiler('SQLCompiler')(\n+                                connection=connection,\n+                                query=None,\n+                            ),\n+                            connection=connection,\n+                        )[0]\n+                        if constraint_sql is not None:\n+                            if 'OVER' in constraint_sql.upper():\n+                                errors.append(\n+                                    checks.Error(\n+                                        '%s does not support check constraints with '\n+                                        'window expressions.' % connection.display_name,\n+                                        obj=cls,\n+                                        id='models.E026',\n+                                    )\n+                                )\n+                elif isinstance(constraint, UniqueConstraint):\n+                    if (\n+                        constraint.condition and\n+                        not connection.features.supports_partial_indexes\n+                    ):\n+                        errors.append(\n+                            checks.Warning(\n+                                '%s does not support unique constraints with '\n+                                'conditions.' % connection.display_name,\n+                                hint=(\n+                                    'A constraint won\\'t be created. Silence this '\n+                                    'warning if you don\\'t care about it.'\n+                                ),\n+                                obj=cls,\n+                                id='models.W039',\n+                            )\n+                        )\n+                    if (\n+                        constraint.deferrable and\n+                        not connection.features.supports_deferrable_unique_constraints\n+                    ):\n+                        errors.append(\n+                            checks.Warning(\n+                                '%s does not support deferrable unique constraints.'\n+                                % connection.display_name,\n+                                hint=(\n+                                    'A constraint won\\'t be created. Silence this '\n+                                    'warning if you don\\'t care about it.'\n+                                ),\n+                                obj=cls,\n+                                id='models.W040',\n+                            )\n+                        )\n+        return errors\n \n     def _get_condition_sql(self, model, schema_editor):\n         if self.condition is None:\n",
    "variant_8": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7bb3fa4706..43971d257d 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1559,31 +1559,40 @@ class Model(metaclass=ModelBase):\n             return errors\n \n     @classmethod\n-    def _check_unique_together(cls):\n-        \"\"\"Check the value of \"unique_together\" option.\"\"\"\n-        if not isinstance(cls._meta.unique_together, (tuple, list)):\n-            return [\n-                checks.Error(\n-                    \"'unique_together' must be a list or tuple.\",\n-                    obj=cls,\n-                    id='models.E010',\n-                )\n-            ]\n \n-        elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.unique_together):\n-            return [\n-                checks.Error(\n-                    \"All 'unique_together' elements must be lists or tuples.\",\n-                    obj=cls,\n-                    id='models.E011',\n-                )\n-            ]\n-\n-        else:\n-            errors = []\n-            for fields in cls._meta.unique_together:\n-                errors.extend(cls._check_local_fields(fields, \"unique_together\"))\n-            return errors\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        \n+        # Validate fields in UniqueConstraints\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                if (\n+                    constraint.condition and\n+                    not any(\n+                        'supports_partial_indexes' in db.introspection.get_storage_engine_info(db.connection) and\n+                        db.introspection.get_storage_engine_info(db.connection)['supports_partial_indexes']\n+                        for db_alias in databases\n+                        for db in [connections[db_alias]]\n+                    ) and\n+                    not all(\n+                        db.features.supports_partial_indexes\n+                        for db_alias in databases\n+                        for db in [connections[db_alias]]\n+                    )\n+                ):\n+                    errors.append(\n+                        checks.Warning(\n+                            'Partial indexes are not supported on this database backend.',\n+                            obj=cls,\n+                            id='models.W039',\n+                        )\n+                    )\n+        return errors\n \n     @classmethod\n     def _check_indexes(cls, databases):\n@@ -1637,47 +1646,35 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n-    def _check_local_fields(cls, fields, option):\n-        from django.db import models\n-\n-        # In order to avoid hitting the relation tree prematurely, we use our\n-        # own fields_map instead of using get_field()\n-        forward_fields_map = {}\n-        for field in cls._meta._get_fields(reverse=False):\n-            forward_fields_map[field.name] = field\n-            if hasattr(field, 'attname'):\n-                forward_fields_map[field.attname] = field\n \n+    @classmethod\n+    def _check_constraints(cls):\n         errors = []\n-        for field_name in fields:\n-            try:\n-                field = forward_fields_map[field_name]\n-            except KeyError:\n-                errors.append(\n-                    checks.Error(\n-                        \"'%s' refers to the nonexistent field '%s'.\" % (\n-                            option, field_name,\n-                        ),\n-                        obj=cls,\n-                        id='models.E012',\n-                    )\n-                )\n-            else:\n-                if isinstance(field.remote_field, models.ManyToManyRel):\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to a ManyToManyField '%s', but \"\n-                            \"ManyToManyFields are not permitted in '%s'.\" % (\n-                                option, field_name, option,\n-                            ),\n-                            obj=cls,\n-                            id='models.E013',\n+        # Check field existence for UniqueConstraints\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                if not cls._meta.managed or any(\n+                    not connection.features.supports_partial_indexes or\n+                    not connection.features.supports_functions_in_partial_indexes\n+                    for connection in connections.all()\n+                ):\n+                    if constraint.condition is not None:\n+                        errors.append(\n+                            checks.Warning(\n+                                '%s does not support unique constraints with '\n+                                'conditions.' % connection.display_name,\n+                                hint=(\n+                                    'A constraint will not be created. Silence this '\n+                                    'warning if you don\\'t care about it.'\n+                                ),\n+                                obj=cls,\n+                                id='models.W036',\n+                            )\n                         )\n-                    )\n-                elif field not in cls._meta.local_fields:\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to field '%s' which is not local to model '%s'.\"\n+        return errors\n                             % (option, field_name, cls._meta.object_name),\n                             hint=\"This issue may be caused by multi-table inheritance.\",\n                             obj=cls,\n@@ -1863,9 +1860,52 @@ class Model(metaclass=ModelBase):\n \n         return errors\n \n+    @classmethod\n+\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        \n+        # Validate fields in UniqueConstraint instances\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                'supports_table_check_constraints' in cls._meta.required_db_features\n+            ) and any(\n+                isinstance(constraint, CheckConstraint)\n+                for constraint in cls._meta.constraints\n+            ):\n+                errors.append(\n+                    checks.Warning(\n+                        '%s does not support check constraints.' % connection.display_name,\n+                        hint=(\n+                            \"A constraint won't be created. Silence this \"\n+                            \"warning if you don't care about it.\"\n+                        ),\n+                        obj=cls,\n+                        id='models.W027',\n+                    )\n+                )\n+            if not (\n+                connection.features.supports_partial_indexes or\n+                'supports_partial_indexes' in cls._meta.required_db_features\n+\n     @classmethod\n     def _check_constraints(cls, databases):\n         errors = []\n+        \n+        # Validate UniqueConstraint fields\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n         for db in databases:\n             if not router.allow_migrate_model(db, cls):\n                 continue\n@@ -1894,6 +1934,7 @@ class Model(metaclass=ModelBase):\n             ) and any(\n                 isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n                 for constraint in cls._meta.constraints\n+            ):\n             ):\n                 errors.append(\n                     checks.Warning(\ndiff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex 64bd60484e..36bb19cfff 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -77,23 +77,46 @@ class Deferrable(Enum):\n \n \n class UniqueConstraint(BaseConstraint):\n-    def __init__(self, *, fields, name, condition=None, deferrable=None):\n-        if not fields:\n-            raise ValueError('At least one field is required to define a unique constraint.')\n-        if not isinstance(condition, (type(None), Q)):\n-            raise ValueError('UniqueConstraint.condition must be a Q instance.')\n-        if condition and deferrable:\n-            raise ValueError(\n-                'UniqueConstraint with conditions cannot be deferred.'\n-            )\n-        if not isinstance(deferrable, (type(None), Deferrable)):\n-            raise ValueError(\n-                'UniqueConstraint.deferrable must be a Deferrable instance.'\n-            )\n-        self.fields = tuple(fields)\n-        self.condition = condition\n-        self.deferrable = deferrable\n-        super().__init__(name)\n+\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        for constraint in cls._meta.constraints:\n+            # Validate fields exist for UniqueConstraint instances\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                connection.features.supports_column_check_constraints\n+            ):\n+                errors.extend(cls._check_constraints_database_backends(\n+                    databases=[db], ignore_backends=[\n+                        'django.db.backends.dummy',\n+                    ]\n+                ))\n+            if connection.features.supports_over_clause:\n+                continue\n+            for constraint in cls._meta.constraints:\n+                if isinstance(constraint, UniqueConstraint):\n+                    if (\n+                        constraint.condition and\n+                        constraint.condition.contains_over_clause\n+                    ):\n+                        errors.append(\n+                            checks.Error(\n+                                '%s cannot use conditions with Window '\n+                                'expressions on this database backend.' % (\n+                                    constraint.__class__.__name__,\n+                                ),\n+                                obj=cls,\n+                                id='models.E041',\n+                            )\n+                        )\n+        return errors\n \n     def _get_condition_sql(self, model, schema_editor):\n         if self.condition is None:\n"
  }
}