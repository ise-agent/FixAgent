{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/sympy/sympy/printing/latex.py lines 359-360)": "\n        # Manual term processing to preserve expression structure\n        a = []  # numerator terms\n        b = []  # denominator terms\n        \n        for item in Mul.make_args(expr):\n            if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp.is_negative:\n                if item.exp != -1:\n                    b.append(Pow(item.base, -item.exp, evaluate=False))\n                else:\n                    b.append(item.base)\n            elif item.is_Rational and item is not S.Infinity:\n                if item.p != 1:\n                    a.append(Rational(item.p))\n                if item.q != 1:\n                    b.append(Rational(item.q))\n            else:\n                a.append(item)\n        \n        a = a or [S.One]\n        numer = Mul(*a, evaluate=False)\n        denom = Mul(*b, evaluate=False) if b else S.One\n",
    "Location 2 (/root/hy/projects_3/sympy/sympy/printing/latex.py lines 348-370)": "\n    def _print_Mul(self, expr):\n        include_parens = False\n        if _coeff_isneg(expr):\n            expr = -expr\n            tex = \"- \"\n            if expr.is_Add:\n                tex += \"(\"\n                include_parens = True\n        else:\n            tex = \"\"\n\n        # Manual term processing to preserve structure like pretty printer\n        a = []  # numerator terms\n        b = []  # denominator terms\n        \n        if self.order not in ('old', 'none'):\n            args = expr.as_ordered_factors()\n        else:\n            args = expr.args\n            \n        # Process each term manually instead of using fraction()\n        for term in args:\n            if term.is_Rational and term.q != 1:\n                if term.p != 1:\n                    a.append(term.p)\n                b.append(term.q)\n            elif term.is_Pow and term.exp.is_negative:\n                b.append(term.base**(-term.exp))\n            else:\n                a.append(term)\n        \n        # Create numerator and denominator expressions\n        if not a:\n            numer = S.One\n        else:\n            numer = Mul(*a)\n        \n        if not b:\n            denom = S.One\n        else:\n            denom = Mul(*b)\n            \n        separator = self._settings['mul_symbol_latex']\n        numbersep = self._settings['mul_symbol_latex_numbers']\n\n        def convert(expr):\n            if not expr.is_Mul:\n                return str(self._print(expr))\n            else:\n                _tex = last_term_tex = \"\"\n\n                if self.order not in ('old', 'none'):\n                    args = expr.as_ordered_factors()\n                else:\n                    args = expr.args\n",
    "Location 3 (/root/hy/projects_3/sympy/sympy/printing/latex.py lines 397-430)": "\n        else:\n            # Manual term processing to preserve expression structure\n            # Similar to pretty printer approach\n            a = S.One\n            b = S.One\n            \n            for item in expr.args:\n                if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp < 0:\n                    if item.exp != -1:\n                        b *= item.base**(-item.exp)\n                    else:\n                        b *= item.base\n                elif item.is_Rational and item < 0:\n                    a *= -1\n                    b *= -1/item\n                else:\n                    a *= item\n            \n            numer = a\n            denom = b\n            \n            snumer = convert(numer)\n            sdenom = convert(denom)\n            ldenom = len(sdenom.split())\n            ratio = self._settings['long_frac_ratio']\n            if self._settings['fold_short_frac'] \\\n                    and ldenom <= 2 and not \"^\" in sdenom:\n                # handle short fractions\n                if self._needs_mul_brackets(numer, last=False):\n                    tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n                else:\n                    tex += r\"%s / %s\" % (snumer, sdenom)\n            elif len(snumer.split()) > ratio*ldenom:\n                # handle long fractions\n                if self._needs_mul_brackets(numer, last=True):\n                    tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n                        % (sdenom, separator, snumer)\n                elif numer.is_Mul:\n                    # split a long numerator\n                    a = S.One\n                    b = S.One\n                    for x in numer.args:\n                        if self._needs_mul_brackets(x, last=False) or \\\n                                len(convert(a*x).split()) > ratio*ldenom or \\\n                                (b.is_commutative is x.is_commutative is False):\n                            b *= x\n                        else:\n                            a *= x\n                    if self._needs_mul_brackets(b, last=True):\n                        tex += r\"\\frac{%s}{%s}%s\\left(%s\\right)\" \\\n                            % (convert(a), sdenom, separator, convert(b))\n                    else:\n                        tex += r\"\\frac{%s}{%s}%s%s\" \\\n                            % (convert(a), sdenom, separator, convert(b))\n",
    "Location 4 (/root/hy/projects_3/sympy/sympy/printing/latex.py lines 883-887)": "\n    def _print_ExpBase(self, expr, exp=None):\n        # TODO should exp_polar be printed differently?\n        #      what about exp_polar(0), exp_polar(1)?\n        tex = r\"e^{%s}\" % self._print(expr.args[0])\n        return self._do_exponent(tex, exp)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/sympy/sympy/printing/latex.py lines 359-360)": [
      "\n        # Manual term processing to preserve expression structure\n        a = []  # numerator terms\n        b = []  # denominator terms\n        \n        for item in Mul.make_args(expr):\n            if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp.is_negative:\n                if item.exp != -1:\n                    b.append(Pow(item.base, -item.exp, evaluate=False))\n                else:\n                    b.append(item.base)\n            elif item.is_Rational and item is not S.Infinity:\n                if item.p != 1:\n                    a.append(Rational(item.p))\n                if item.q != 1:\n                    b.append(Rational(item.q))\n            else:\n                a.append(item)\n        \n        a = a or [S.One]\n        \n        if len(b) == 0:\n            numer = Mul(*a)\n            denom = S.One\n        else:\n            numer = Mul(*a)\n            denom = Mul(*b)\n",
      "\n        # Manual term processing to preserve expression structure\n        a = []  # numerator terms\n        b = []  # denominator terms\n        \n        # Process each argument in the multiplication\n        for item in expr.args:\n            if item.is_Rational and item.p != 1:\n                if item.p != -1:\n                    a.append(item.p)\n                if item.q != 1:\n                    b.append(item.q)\n            elif item.is_Pow and item.exp.is_Rational and item.exp.is_negative:\n                # Move negative powers to denominator\n                b.append(item.base**(-item.exp))\n            else:\n                a.append(item)\n        \n        # Build numerator and denominator from collected terms\n        if len(a) == 0:\n            numer = S.One\n        elif len(a) == 1:\n            numer = a[0]\n        else:\n            numer = expr.func(*a)\n            \n        if len(b) == 0:\n            denom = S.One\n        elif len(b) == 1:\n            denom = b[0]\n        else:\n            denom = expr.func(*b)\n",
      "\n        from sympy.simplify import fraction\n        # Process terms manually to preserve expression structure\n        a = []  # numerator terms\n        b = []  # denominator terms\n        \n        for item in Mul.make_args(expr):\n            if item.is_Rational and item.p != 1:\n                if item.p != -1:\n                    a.append(Rational(item.p))\n                if item.q != 1:\n                    b.append(Rational(item.q))\n            elif item.is_Pow and item.exp.is_negative:\n                b.append(Pow(item.base, -item.exp, evaluate=False))\n            else:\n                a.append(item)\n        \n        if not a:\n            a = [S.One]\n        if not b:\n            b = [S.One]\n            \n        numer = a[0] if len(a) == 1 else Mul(*a, evaluate=False)\n        denom = b[0] if len(b) == 1 else Mul(*b, evaluate=False)\n",
      "\n        # Manual term processing to preserve expression structure\n        a = []  # numerator terms\n        b = []  # denominator terms\n        \n        if expr.is_Rational:\n            if expr.p != 1:\n                a.append(expr.p)\n            if expr.q != 1:\n                b.append(expr.q)\n        else:\n            for item in expr.args:\n                if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp.is_negative:\n                    if item.exp != -1:\n                        b.append(Pow(item.base, -item.exp, evaluate=False))\n                    else:\n                        b.append(item.base)\n                elif item.is_Rational and item is not S.Infinity:\n                    if item.p != 1:\n                        a.append(item.p)\n                    if item.q != 1:\n                        b.append(item.q)\n                else:\n                    a.append(item)\n        \n        if not a:\n            a = [S.One]\n        \n        numer = a[0] if len(a) == 1 else Mul(*a, evaluate=False)\n        denom = b[0] if len(b) == 1 else Mul(*b, evaluate=False) if b else S.One\n",
      "\n        # Process terms manually to preserve structure like pretty printer\n        a = []  # numerator terms\n        b = []  # denominator terms\n        \n        # Handle rational numbers separately\n        if expr.is_Rational:\n            if expr.p != 1:\n                a.append(expr.p)\n            if expr.q != 1:\n                b.append(expr.q)\n        else:\n            # Process each term in the multiplication\n            for item in expr.args:\n                if item.is_Rational:\n                    if item.p != 1:\n                        a.append(item.p)\n                    if item.q != 1:\n                        b.append(item.q)\n                elif item.is_Pow and item.exp.is_Rational and item.exp < 0:\n                    # Move negative powers to denominator\n                    if item.exp == -1:\n                        b.append(item.base)\n                    else:\n                        b.append(item.base**(-item.exp))\n                else:\n                    a.append(item)\n        \n        # Build numerator and denominator expressions\n        if not a:\n            numer = S.One\n        elif len(a) == 1:\n            numer = a[0]\n        else:\n            numer = expr.func(*a)\n            \n        if not b:\n            denom = S.One\n        elif len(b) == 1:\n            denom = b[0]\n        else:\n            denom = expr.func(*b)\n",
      "\n        # Manually separate terms instead of using fraction() to preserve structure\n        a = []  # numerator terms\n        b = []  # denominator terms\n        \n        if expr.is_Rational:\n            if expr.p != 1:\n                a.append(expr.p)\n            if expr.q != 1:\n                b.append(expr.q)\n        else:\n            for item in expr.args:\n                if item.is_Pow and item.exp.is_Rational and item.exp < 0:\n                    if item.exp != -1:\n                        b.append(Pow(item.base, -item.exp, evaluate=False))\n                    else:\n                        b.append(item.base)\n                elif item.is_Rational and item < 0:\n                    a.append(-item)\n                else:\n                    a.append(item)\n        \n        # Create numerator and denominator from collected terms\n        if not a:\n            numer = S.One\n        elif len(a) == 1:\n            numer = a[0]\n        else:\n            numer = Mul(*a, evaluate=False)\n            \n        if not b:\n            denom = S.One\n        elif len(b) == 1:\n            denom = b[0]\n        else:\n            denom = Mul(*b, evaluate=False)\n",
      "\n        from sympy.simplify import fraction\n        \n        # Manual term processing to preserve expression structure\n        a = []  # numerator terms\n        b = []  # denominator terms\n        \n        if expr.is_Rational:\n            if expr.p != 1:\n                a.append(expr.p)\n            if expr.q != 1:\n                b.append(expr.q)\n        else:\n            for item in expr.args:\n                if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp.is_negative:\n                    if item.exp != -1:\n                        b.append(item.base**(-item.exp))\n                    else:\n                        b.append(item.base)\n                else:\n                    a.append(item)\n        \n        numer = self._mul_class(*a) if a else S.One\n        denom = self._mul_class(*b) if b else S.One\n",
      "\n        # Manual term processing to preserve expression structure\n        from sympy.core.numbers import Rational\n        \n        a = []  # numerator terms\n        b = []  # denominator terms\n        \n        for item in expr.args:\n            if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp.is_negative:\n                if item.exp != -1:\n                    b.append(Pow(item.base, -item.exp, evaluate=False))\n                else:\n                    b.append(item.base)\n            elif item.is_Rational and item is not S.Infinity:\n                if item.p != 1:\n                    a.append(Rational(item.p))\n                if item.q != 1:\n                    b.append(Rational(item.q))\n            else:\n                a.append(item)\n        \n        a = a or [S.One]\n        numer = Mul(*a, evaluate=False)\n        denom = Mul(*b, evaluate=False) if b else S.One\n"
    ],
    "Location 2 (/root/hy/projects_3/sympy/sympy/printing/latex.py lines 348-370)": [
      "\n    def _print_Mul(self, expr):\n        include_parens = False\n        if _coeff_isneg(expr):\n            expr = -expr\n            tex = \"- \"\n            if expr.is_Add:\n                tex += \"(\"\n                include_parens = True\n        else:\n            tex = \"\"\n\n        # Manual term processing to preserve structure like pretty printer\n        a = []  # numerator terms\n        b = []  # denominator terms\n        \n        if self.order not in ('old', 'none'):\n            args = expr.as_ordered_factors()\n        else:\n            args = expr.args\n            \n        # Process each term manually to preserve original structure\n        for item in args:\n            if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp < 0:\n                if item.exp != -1:\n                    b.append(Pow(item.base, -item.exp, evaluate=False))\n                else:\n                    b.append(item.base)\n            elif item.is_Rational and item is not S.Infinity:\n                if item.p != 1:\n                    a.append(Rational(item.p))\n                if item.q != 1:\n                    b.append(Rational(item.q))\n            else:\n                a.append(item)\n        \n        # Convert lists back to expressions\n        if not a:\n            numer = S.One\n        elif len(a) == 1:\n            numer = a[0]\n        else:\n            numer = Mul(*a, evaluate=False)\n            \n        if not b:\n            denom = S.One\n        elif len(b) == 1:\n            denom = b[0]\n        else:\n            denom = Mul(*b, evaluate=False)\n            \n        separator = self._settings['mul_symbol_latex']\n        numbersep = self._settings['mul_symbol_latex_numbers']\n\n        def convert(expr):\n            if not expr.is_Mul:\n                return str(self._print(expr))\n            else:\n                _tex = last_term_tex = \"\"\n",
      "\n    def _print_Mul(self, expr):\n        include_parens = False\n        if _coeff_isneg(expr):\n            expr = -expr\n            tex = \"- \"\n            if expr.is_Add:\n                tex += \"(\"\n                include_parens = True\n        else:\n            tex = \"\"\n\n        # Manual term processing to preserve expression structure\n        a = []  # numerator terms\n        b = []  # denominator terms\n        \n        if self.order not in ('old', 'none'):\n            args = expr.as_ordered_factors()\n        else:\n            args = expr.args\n            \n        for item in args:\n            if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp.is_negative:\n                if item.exp != -1:\n                    b.append(item.base**(-item.exp))\n                else:\n                    b.append(item.base)\n            elif item.is_Rational and item is not S.Infinity:\n                if item.p != 1:\n                    a.append(item.p)\n                if item.q != 1:\n                    b.append(item.q)\n            else:\n                a.append(item)\n        \n        # If no denominator terms, use simpler multiplication logic\n        if not b:\n            numer = expr\n            denom = S.One\n        else:\n            from sympy import Mul\n            numer = Mul(*a) if a else S.One\n            denom = Mul(*b)\n        \n        separator = self._settings['mul_symbol_latex']\n        numbersep = self._settings['mul_symbol_latex_numbers']\n\n        def convert(expr):\n            if not expr.is_Mul:\n                return str(self._print(expr))\n            else:\n                _tex = last_term_tex = \"\"\n\n                if self.order not in ('old', 'none'):\n                    args = expr.as_ordered_factors()\n                else:\n                    args = expr.args\n",
      "\n    def _print_Mul(self, expr):\n        include_parens = False\n        if _coeff_isneg(expr):\n            expr = -expr\n            tex = \"- \"\n            if expr.is_Add:\n                tex += \"(\"\n                include_parens = True\n        else:\n            tex = \"\"\n\n        # Manual term processing to preserve structure like pretty printer\n        a = []  # numerator terms\n        b = []  # denominator terms\n        \n        if self.order not in ('old', 'none'):\n            args = expr.as_ordered_factors()\n        else:\n            args = expr.args\n            \n        # Process each term manually to avoid unwanted algebraic transformations\n        for term in args:\n            if term.is_Rational and term.q != 1:\n                # Handle rational numbers\n                if term.p != 1:\n                    a.append(term.p)\n                if term.q != 1:\n                    b.append(term.q)\n            elif term.is_Pow and term.exp.is_negative:\n                # Handle negative exponents - put in denominator with positive exponent\n                b.append(term.base ** (-term.exp))\n            else:\n                # All other terms go in numerator\n                a.append(term)\n        \n        # Create numerator and denominator expressions\n        if not a:\n            numer = S.One\n        elif len(a) == 1:\n            numer = a[0]\n        else:\n            numer = expr.func(*a)\n            \n        if not b:\n            denom = S.One\n        elif len(b) == 1:\n            denom = b[0]\n        else:\n            denom = expr.func(*b)\n\n        separator = self._settings['mul_symbol_latex']\n        numbersep = self._settings['mul_symbol_latex_numbers']\n\n        def convert(expr):\n            if not expr.is_Mul:\n                return str(self._print(expr))\n            else:\n                _tex = last_term_tex = \"\"\n\n                if self.order not in ('old', 'none'):\n                    args = expr.as_ordered_factors()\n                else:\n                    args = expr.args\n",
      "\n    def _print_Mul(self, expr):\n        include_parens = False\n        if _coeff_isneg(expr):\n            expr = -expr\n            tex = \"- \"\n            if expr.is_Add:\n                tex += \"(\"\n                include_parens = True\n        else:\n            tex = \"\"\n\n        # Manual term processing to preserve expression structure\n        a = []  # numerator terms\n        b = []  # denominator terms\n        \n        if self.order not in ('old', 'none'):\n            args = expr.as_ordered_factors()\n        else:\n            args = expr.args\n            \n        for item in args:\n            if item.is_Rational and item is not S.Infinity:\n                if item.p != 1:\n                    a.append(item.p)\n                if item.q != 1:\n                    b.append(item.q)\n            elif item.is_Pow and item.exp.is_Rational and item.exp < 0:\n                if item.exp != -1:\n                    b.append(Pow(item.base, -item.exp, evaluate=False))\n                else:\n                    b.append(item.base)\n            else:\n                a.append(item)\n        \n        numer = Mul(*a) if a else S.One\n        denom = Mul(*b) if b else S.One\n        \n        separator = self._settings['mul_symbol_latex']\n        numbersep = self._settings['mul_symbol_latex_numbers']\n\n        def convert(expr):\n            if not expr.is_Mul:\n                return str(self._print(expr))\n            else:\n                _tex = last_term_tex = \"\"\n\n                if self.order not in ('old', 'none'):\n                    args = expr.as_ordered_factors()\n                else:\n                    args = expr.args\n",
      "\n    def _print_Mul(self, expr):\n        include_parens = False\n        if _coeff_isneg(expr):\n            expr = -expr\n            tex = \"- \"\n            if expr.is_Add:\n                tex += \"(\"\n                include_parens = True\n        else:\n            tex = \"\"\n\n        # Manual term processing to preserve expression structure\n        a = []  # numerator terms\n        b = []  # denominator terms\n        \n        if self.order not in ('old', 'none'):\n            args = expr.as_ordered_factors()\n        else:\n            args = expr.args\n            \n        for item in args:\n            if item.is_Rational and item.is_negative:\n                a.append(S.One)\n                b.append(-item)\n            elif item.is_Pow and item.exp.is_Rational and item.exp.is_negative:\n                if item.exp != -1:\n                    b.append(item.base**(-item.exp))\n                else:\n                    b.append(item.base)\n            else:\n                a.append(item)\n        \n        numer = Mul(*a) if len(a) > 1 else (a[0] if a else S.One)\n        denom = Mul(*b) if len(b) > 1 else (b[0] if b else S.One)\n        \n        separator = self._settings['mul_symbol_latex']\n        numbersep = self._settings['mul_symbol_latex_numbers']\n\n        def convert(expr):\n            if not expr.is_Mul:\n                return str(self._print(expr))\n            else:\n                _tex = last_term_tex = \"\"\n\n                if self.order not in ('old', 'none'):\n                    args = expr.as_ordered_factors()\n                else:\n                    args = expr.args\n",
      "\n    def _print_Mul(self, expr):\n        include_parens = False\n        if _coeff_isneg(expr):\n            expr = -expr\n            tex = \"- \"\n            if expr.is_Add:\n                tex += \"(\"\n                include_parens = True\n        else:\n            tex = \"\"\n\n        # Manual term processing to preserve expression structure\n        # Similar to pretty printer approach\n        a = []  # numerator terms\n        b = []  # denominator terms\n        \n        if self.order not in ('old', 'none'):\n            args = expr.as_ordered_factors()\n        else:\n            args = expr.args\n            \n        # Process each term manually instead of using fraction()\n        for term in args:\n            if term.is_Rational and term.q != 1:\n                # Handle rational numbers\n                if term.p != 1:\n                    a.append(term.p)\n                if term.q != 1:\n                    b.append(term.q)\n            elif term.is_Pow and term.exp.is_negative:\n                # Handle negative exponents - keep in denominator\n                b.append(term.base ** (-term.exp))\n            else:\n                # All other terms go to numerator\n                a.append(term)\n        \n        # Convert to expressions\n        from sympy import Mul\n        if not a:\n            numer = S.One\n        else:\n            numer = Mul(*a)\n        \n        if not b:\n            denom = S.One\n        else:\n            denom = Mul(*b)\n            \n        separator = self._settings['mul_symbol_latex']\n        numbersep = self._settings['mul_symbol_latex_numbers']\n\n        def convert(expr):\n            if not expr.is_Mul:\n                return str(self._print(expr))\n            else:\n                _tex = last_term_tex = \"\"\n\n                if self.order not in ('old', 'none'):\n                    args = expr.as_ordered_factors()\n                else:\n                    args = expr.args\n",
      "\n    def _print_Mul(self, expr):\n        include_parens = False\n        if _coeff_isneg(expr):\n            expr = -expr\n            tex = \"- \"\n            if expr.is_Add:\n                tex += \"(\"\n                include_parens = True\n        else:\n            tex = \"\"\n\n        # Manual term processing to preserve expression structure\n        a = []  # numerator terms\n        b = []  # denominator terms\n        \n        if self.order not in ('old', 'none'):\n            args = expr.as_ordered_factors()\n        else:\n            args = expr.args\n            \n        for item in args:\n            if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp.is_negative:\n                if item.exp != -1:\n                    b.append(item.base**(-item.exp))\n                else:\n                    b.append(item.base)\n            elif item.is_Rational and item is not S.Infinity:\n                if item.p != 1:\n                    a.append(item.p)\n                if item.q != 1:\n                    b.append(item.q)\n            else:\n                a.append(item)\n        \n        a = a or [S.One]\n        \n        separator = self._settings['mul_symbol_latex']\n        numbersep = self._settings['mul_symbol_latex_numbers']\n\n        def convert(expr):\n            if not expr.is_Mul:\n                return str(self._print(expr))\n            else:\n                _tex = last_term_tex = \"\"\n\n                if self.order not in ('old', 'none'):\n                    args = expr.as_ordered_factors()\n                else:\n                    args = expr.args\n\n                for i, term in enumerate(args):\n                    term_tex = self._print(term)\n\n                    if self._needs_mul_brackets(term, first=(i == 0),\n                                                last=(i == len(args) - 1)):\n                        term_tex = r\"\\left(%s\\right)\" % term_tex\n",
      "\n    def _print_Mul(self, expr):\n        include_parens = False\n        if _coeff_isneg(expr):\n            expr = -expr\n            tex = \"- \"\n            if expr.is_Add:\n                tex += \"(\"\n                include_parens = True\n        else:\n            tex = \"\"\n\n        # Manual term processing to preserve structure like pretty printer\n        a = []  # numerator terms\n        b = []  # denominator terms\n        \n        if self.order not in ('old', 'none'):\n            args = expr.as_ordered_factors()\n        else:\n            args = expr.args\n            \n        # Process each term to separate numerator/denominator while preserving structure\n        for item in args:\n            if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp.is_negative:\n                if item.exp != -1:\n                    b.append(item.base**(-item.exp))\n                else:\n                    b.append(item.base)\n            elif item.is_Rational and item is not S.Infinity:\n                if item.p != 1:\n                    a.append(item.p)\n                if item.q != 1:\n                    b.append(item.q)\n            else:\n                a.append(item)\n        \n        # Create numerator and denominator expressions\n        if not a:\n            numer = S.One\n        elif len(a) == 1:\n            numer = a[0]\n        else:\n            numer = expr.func(*a)\n            \n        if not b:\n            denom = S.One\n        elif len(b) == 1:\n            denom = b[0]\n        else:\n            denom = expr.func(*b)\n            \n        separator = self._settings['mul_symbol_latex']\n        numbersep = self._settings['mul_symbol_latex_numbers']\n\n        def convert(expr):\n            if not expr.is_Mul:\n                return str(self._print(expr))\n            else:\n                _tex = last_term_tex = \"\"\n\n                if self.order not in ('old', 'none'):\n                    args = expr.as_ordered_factors()\n                else:\n                    args = expr.args\n"
    ],
    "Location 3 (/root/hy/projects_3/sympy/sympy/printing/latex.py lines 397-430)": [
      "\n        else:\n            # Manual term processing to preserve expression structure\n            # Split terms based on negative exponents, similar to pretty printer\n            a = []  # numerator terms\n            b = []  # denominator terms\n            \n            for item in expr.args:\n                if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp.is_negative:\n                    if item.exp != -1:\n                        b.append(Pow(item.base, -item.exp, evaluate=False))\n                    else:\n                        b.append(item.base)\n                elif item.is_Rational and item.is_negative:\n                    a.append(-item)\n                    b.append(S.One)\n                else:\n                    a.append(item)\n            \n            if len(b) == 0:\n                # No denominator terms, use original expression\n                snumer = convert(expr)\n                sdenom = \"1\"\n            else:\n                # Construct numerator and denominator\n                if len(a) == 0:\n                    numer = S.One\n                else:\n                    numer = Mul(*a)\n                denom = Mul(*b)\n                \n                snumer = convert(numer)\n                sdenom = convert(denom)\n            \n            if len(b) == 0:\n                tex += snumer\n            else:\n                ldenom = len(sdenom.split())\n                ratio = self._settings['long_frac_ratio']\n                if self._settings['fold_short_frac'] \\\n                        and ldenom <= 2 and not \"^\" in sdenom:\n                    # handle short fractions\n                    if self._needs_mul_brackets(numer, last=False):\n                        tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n                    else:\n                        tex += r\"%s / %s\" % (snumer, sdenom)\n                elif len(snumer.split()) > ratio*ldenom:\n                    # handle long fractions\n                    if self._needs_mul_brackets(numer, last=True):\n                        tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n                            % (sdenom, separator, snumer)\n                    elif numer.is_Mul:\n                        # split a long numerator\n                        a_split = S.One\n                        b_split = S.One\n                        for x in numer.args:\n                            if self._needs_mul_brackets(x, last=False) or \\\n                                    len(convert(a_split*x).split()) > ratio*ldenom or \\\n                                    (b_split.is_commutative is x.is_commutative is False):\n                                b_split *= x\n                            else:\n                                a_split *= x\n                        if self._needs_mul_brackets(b_split, last=True):\n                            tex += r\"\\frac{%s}{%s}%s\\left(%s\\right)\" \\\n                                % (convert(a_split), sdenom, separator, convert(b_split))\n                        else:\n                            tex += r\"\\frac{%s}{%s}%s%s\" \\\n                                % (convert(a_split), sdenom, separator, convert(b_split))\n                    else:\n                        tex += r\"\\frac{1}{%s}%s%s\" % (sdenom, separator, snumer)\n                else:\n                    tex += r\"\\frac{%s}{%s}\" % (snumer, sdenom)\n",
      "\n        else:\n            # Manual term processing to preserve structure like pretty printer\n            a = S.One  # numerator terms\n            b = S.One  # denominator terms\n            \n            for item in expr.args:\n                if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp.is_negative:\n                    if item.exp is S.NegativeOne:\n                        b *= item.base\n                    else:\n                        b *= item.base**(-item.exp)\n                elif item.is_Rational and item.is_negative:\n                    a *= -item\n                    b *= S.NegativeOne\n                else:\n                    a *= item\n            \n            # Now a is numerator, b is denominator\n            if b is S.One:\n                # No actual fraction, just render as multiplication\n                tex += convert(expr)\n            else:\n                snumer = convert(a)\n                sdenom = convert(b)\n                ldenom = len(sdenom.split())\n                ratio = self._settings['long_frac_ratio']\n                if self._settings['fold_short_frac'] \\\n                        and ldenom <= 2 and not \"^\" in sdenom:\n                    # handle short fractions\n                    if self._needs_mul_brackets(a, last=False):\n                        tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n                    else:\n                        tex += r\"%s / %s\" % (snumer, sdenom)\n                elif len(snumer.split()) > ratio*ldenom:\n                    # handle long fractions\n                    if self._needs_mul_brackets(a, last=True):\n                        tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n                            % (sdenom, separator, snumer)\n                    elif a.is_Mul:\n                        # split a long numerator\n                        a_part = S.One\n                        b_part = S.One\n                        for x in a.args:\n                            if self._needs_mul_brackets(x, last=False) or \\\n                                    len(convert(a_part*x).split()) > ratio*ldenom or \\\n                                    (b_part.is_commutative is x.is_commutative is False):\n                                b_part *= x\n                            else:\n                                a_part *= x\n                        if self._needs_mul_brackets(b_part, last=True):\n                            tex += r\"\\frac{%s}{%s}%s\\left(%s\\right)\" \\\n                                % (convert(a_part), sdenom, separator, convert(b_part))\n                        else:\n                            tex += r\"\\frac{%s}{%s}%s%s\" \\\n                                % (convert(a_part), sdenom, separator, convert(b_part))\n                    else:\n                        tex += r\"\\frac{1}{%s}%s%s\" % (sdenom, separator, snumer)\n                else:\n                    tex += r\"\\frac{%s}{%s}\" % (snumer, sdenom)\n",
      "\n        else:\n            # Manual term processing to preserve expression structure\n            # Similar to pretty printer approach\n            a = []  # numerator terms\n            b = []  # denominator terms\n            \n            for item in expr.args:\n                if item.is_Rational and item.is_negative:\n                    if item is not S.NegativeOne:\n                        a.append(Rational(-item.p, item.q))\n                    b.append(S.One)\n                elif item.is_Pow and item.exp.is_Rational and item.exp.is_negative:\n                    if item.exp is not S.NegativeOne:\n                        b.append(Pow(item.base, -item.exp, evaluate=False))\n                    else:\n                        b.append(item.base)\n                else:\n                    a.append(item)\n            \n            if len(b) == 0:\n                # No denominator terms, use original expression\n                tex += convert(expr)\n            else:\n                # Build numerator and denominator\n                if len(a) == 0:\n                    numer = S.One\n                else:\n                    numer = Mul(*a, evaluate=False) if len(a) > 1 else a[0]\n                \n                denom = Mul(*b, evaluate=False) if len(b) > 1 else b[0]\n                \n                snumer = convert(numer)\n                sdenom = convert(denom)\n                ldenom = len(sdenom.split())\n                ratio = self._settings['long_frac_ratio']\n                if self._settings['fold_short_frac'] \\\n                        and ldenom <= 2 and not \"^\" in sdenom:\n                    # handle short fractions\n                    if self._needs_mul_brackets(numer, last=False):\n                        tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n                    else:\n                        tex += r\"%s / %s\" % (snumer, sdenom)\n                elif len(snumer.split()) > ratio*ldenom:\n                    # handle long fractions\n                    if self._needs_mul_brackets(numer, last=True):\n                        tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n                            % (sdenom, separator, snumer)\n                    elif numer.is_Mul:\n                        # split a long numerator\n                        a_split = S.One\n                        b_split = S.One\n                        for x in numer.args:\n                            if self._needs_mul_brackets(x, last=False) or \\\n                                    len(convert(a_split*x).split()) > ratio*ldenom or \\\n                                    (b_split.is_commutative is x.is_commutative is False):\n                                b_split *= x\n                            else:\n                                a_split *= x\n                        if self._needs_mul_brackets(b_split, last=True):\n                            tex += r\"\\frac{%s}{%s}%s\\left(%s\\right)\" \\\n                                % (convert(a_split), sdenom, separator, convert(b_split))\n                        else:\n                            tex += r\"\\frac{%s}{%s}%s%s\" \\\n                                % (convert(a_split), sdenom, separator, convert(b_split))\n                    else:\n                        tex += r\"\\frac{1}{%s}%s%s\" % (sdenom, separator, snumer)\n                else:\n                    tex += r\"\\frac{%s}{%s}\" % (snumer, sdenom)\n",
      "\n        else:\n            # Manual term processing to preserve original structure\n            a = S.One  # numerator terms\n            b = S.One  # denominator terms\n            \n            for item in expr.args:\n                if item.is_commutative is False:\n                    # Handle non-commutative terms in numerator\n                    a = a * item\n                elif item.is_Rational and item.is_negative:\n                    # Handle negative rationals\n                    a = a * item\n                elif item.is_Pow and item.exp.is_Rational and item.exp.is_negative:\n                    # Move negative powers to denominator\n                    if item.exp is S.NegativeOne:\n                        b = b * item.base\n                    else:\n                        b = b * item.base**(-item.exp)\n                elif item.is_Rational and item is not S.One:\n                    # Handle positive rationals\n                    if item.p != 1:\n                        a = a * item.p\n                    if item.q != 1:\n                        b = b * item.q\n                else:\n                    # All other terms go in numerator\n                    a = a * item\n            \n            # Set numer and denom based on manual processing\n            if b is S.One:\n                numer = a\n                denom = S.One\n            else:\n                numer = a\n                denom = b\n            \n            snumer = convert(numer)\n            sdenom = convert(denom)\n            ldenom = len(sdenom.split())\n            ratio = self._settings['long_frac_ratio']\n            if self._settings['fold_short_frac'] \\\n                    and ldenom <= 2 and not \"^\" in sdenom:\n                # handle short fractions\n                if self._needs_mul_brackets(numer, last=False):\n                    tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n                else:\n                    tex += r\"%s / %s\" % (snumer, sdenom)\n            elif len(snumer.split()) > ratio*ldenom:\n                # handle long fractions\n                if self._needs_mul_brackets(numer, last=True):\n                    tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n                        % (sdenom, separator, snumer)\n                elif numer.is_Mul:\n                    # split a long numerator\n                    a = S.One\n                    b = S.One\n                    for x in numer.args:\n                        if self._needs_mul_brackets(x, last=False) or \\\n                                len(convert(a*x).split()) > ratio*ldenom or \\\n                                (b.is_commutative is x.is_commutative is False):\n                            b *= x\n                        else:\n                            a *= x\n                    if self._needs_mul_brackets(b, last=True):\n                        tex += r\"\\frac{%s}{%s}%s\\left(%s\\right)\" \\\n                            % (convert(a), sdenom, separator, convert(b))\n                    else:\n                        tex += r\"\\frac{%s}{%s}%s%s\" \\\n                            % (convert(a), sdenom, separator, convert(b))\n                else:\n                    tex += r\"\\frac{1}{%s}%s%s\" % (sdenom, separator, snumer)\n            else:\n                tex += r\"\\frac{%s}{%s}\" % (snumer, sdenom)\n",
      "\n        else:\n            snumer = convert(numer)\n            sdenom = convert(denom)\n            ldenom = len(sdenom.split())\n            ratio = self._settings['long_frac_ratio']\n            if self._settings['fold_short_frac'] \\\n                    and ldenom <= 2 and not \"^\" in sdenom:\n                # handle short fractions\n                if self._needs_mul_brackets(numer, last=False):\n                    tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n                else:\n                    tex += r\"%s / %s\" % (snumer, sdenom)\n            elif len(snumer.split()) > ratio*ldenom:\n                # handle long fractions\n                if self._needs_mul_brackets(numer, last=True):\n                    tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n                        % (sdenom, separator, snumer)\n                elif numer.is_Mul:\n                    # split a long numerator\n                    a = S.One\n                    b = S.One\n                    for x in numer.args:\n                        if self._needs_mul_brackets(x, last=False) or \\\n                                len(convert(a*x).split()) > ratio*ldenom or \\\n                                (b.is_commutative is x.is_commutative is False):\n                            b *= x\n                        else:\n                            a *= x\n                    if self._needs_mul_brackets(b, last=True):\n                        tex += r\"\\frac{%s}{%s}%s\\left(%s\\right)\" \\\n                            % (convert(a), sdenom, separator, convert(b))\n                    else:\n                        tex += r\"\\frac{%s}{%s}%s%s\" \\\n                            % (convert(a), sdenom, separator, convert(b))\n                else:\n                    tex += r\"\\frac{1}{%s}%s%s\" % (sdenom, separator, snumer)\n            else:\n                tex += r\"\\frac{%s}{%s}\" % (snumer, sdenom)\n",
      "\n        else:\n            # Manual term processing to preserve expression structure\n            # Similar to pretty printer approach\n            a = S.One\n            b = S.One\n            \n            for item in expr.args:\n                if item.is_Rational and item.is_negative:\n                    a *= -item\n                elif item.is_Pow and item.exp.is_Rational and item.exp.is_negative:\n                    b *= item**-1\n                elif item.is_Pow and item.exp.is_negative:\n                    b *= item**-1\n                else:\n                    a *= item\n            \n            snumer = convert(a)\n            sdenom = convert(b)\n            ldenom = len(sdenom.split())\n            ratio = self._settings['long_frac_ratio']\n            if self._settings['fold_short_frac'] \\\n                    and ldenom <= 2 and not \"^\" in sdenom:\n                # handle short fractions\n                if self._needs_mul_brackets(a, last=False):\n                    tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n                else:\n                    tex += r\"%s / %s\" % (snumer, sdenom)\n            elif len(snumer.split()) > ratio*ldenom:\n                # handle long fractions\n                if self._needs_mul_brackets(a, last=True):\n                    tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n                        % (sdenom, separator, snumer)\n                elif a.is_Mul:\n                    # split a long numerator\n                    a_part = S.One\n                    b_part = S.One\n                    for x in a.args:\n                        if self._needs_mul_brackets(x, last=False) or \\\n                                len(convert(a_part*x).split()) > ratio*ldenom or \\\n                                (b_part.is_commutative is x.is_commutative is False):\n                            b_part *= x\n                        else:\n                            a_part *= x\n                    if self._needs_mul_brackets(b_part, last=True):\n                        tex += r\"\\frac{%s}{%s}%s\\left(%s\\right)\" \\\n                            % (convert(a_part), sdenom, separator, convert(b_part))\n                    else:\n                        tex += r\"\\frac{%s}{%s}%s%s\" \\\n                            % (convert(a_part), sdenom, separator, convert(b_part))\n                else:\n                    tex += r\"\\frac{1}{%s}%s%s\" % (sdenom, separator, snumer)\n            else:\n                tex += r\"\\frac{%s}{%s}\" % (snumer, sdenom)\n",
      "\n        else:\n            # Manual term processing to preserve original structure\n            a = S.One  # numerator terms\n            b = S.One  # denominator terms\n            \n            for item in expr.args:\n                if item.is_commutative is False:\n                    # Handle non-commutative terms\n                    if a.is_commutative is False:\n                        b *= item\n                    else:\n                        a *= item\n                elif item.is_Rational and item.is_negative:\n                    a *= -item\n                    sign = -sign\n                elif item.is_Pow and item.exp.is_Rational and item.exp.is_negative:\n                    if item.exp != -1:\n                        b *= Pow(item.base, -item.exp, evaluate=False)\n                    else:\n                        b *= item.base\n                else:\n                    a *= item\n            \n            # Set numer and denom based on manual processing\n            if b == S.One:\n                numer = a\n                denom = S.One\n            else:\n                numer = a\n                denom = b\n            \n            snumer = convert(numer)\n            sdenom = convert(denom)\n            ldenom = len(sdenom.split())\n            ratio = self._settings['long_frac_ratio']\n            if self._settings['fold_short_frac'] \\\n                    and ldenom <= 2 and not \"^\" in sdenom:\n                # handle short fractions\n                if self._needs_mul_brackets(numer, last=False):\n                    tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n                else:\n                    tex += r\"%s / %s\" % (snumer, sdenom)\n            elif len(snumer.split()) > ratio*ldenom:\n                # handle long fractions\n                if self._needs_mul_brackets(numer, last=True):\n                    tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n                        % (sdenom, separator, snumer)\n                elif numer.is_Mul:\n                    # split a long numerator\n                    a_split = S.One\n                    b_split = S.One\n                    for x in numer.args:\n                        if self._needs_mul_brackets(x, last=False) or \\\n                                len(convert(a_split*x).split()) > ratio*ldenom or \\\n                                (b_split.is_commutative is x.is_commutative is False):\n                            b_split *= x\n                        else:\n                            a_split *= x\n                    if self._needs_mul_brackets(b_split, last=True):\n                        tex += r\"\\frac{%s}{%s}%s\\left(%s\\right)\" \\\n                            % (convert(a_split), sdenom, separator, convert(b_split))\n                    else:\n                        tex += r\"\\frac{%s}{%s}%s%s\" \\\n                            % (convert(a_split), sdenom, separator, convert(b_split))\n                else:\n                    tex += r\"\\frac{1}{%s}%s%s\" % (sdenom, separator, snumer)\n            else:\n                tex += r\"\\frac{%s}{%s}\" % (snumer, sdenom)\n",
      "\n        else:\n            # Manual term processing to preserve expression structure\n            # similar to pretty printer approach\n            a = S.One\n            b = S.One\n            \n            for item in expr.args:\n                if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp < 0:\n                    # Negative exponent goes to denominator\n                    if item.exp == -1:\n                        b *= item.base\n                    else:\n                        b *= item.base**(-item.exp)\n                elif item.is_Rational and item < 0:\n                    # Negative rational number\n                    a *= -1\n                    if item != -1:\n                        b *= -item\n                else:\n                    # Everything else goes to numerator\n                    a *= item\n            \n            numer = a\n            denom = b\n            \n            snumer = convert(numer)\n            sdenom = convert(denom)\n            ldenom = len(sdenom.split())\n            ratio = self._settings['long_frac_ratio']\n            if self._settings['fold_short_frac'] \\\n                    and ldenom <= 2 and not \"^\" in sdenom:\n                # handle short fractions\n                if self._needs_mul_brackets(numer, last=False):\n                    tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n                else:\n                    tex += r\"%s / %s\" % (snumer, sdenom)\n            elif len(snumer.split()) > ratio*ldenom:\n                # handle long fractions\n                if self._needs_mul_brackets(numer, last=True):\n                    tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n                        % (sdenom, separator, snumer)\n                elif numer.is_Mul:\n                    # split a long numerator\n                    a = S.One\n                    b = S.One\n                    for x in numer.args:\n                        if self._needs_mul_brackets(x, last=False) or \\\n                                len(convert(a*x).split()) > ratio*ldenom or \\\n                                (b.is_commutative is x.is_commutative is False):\n                            b *= x\n                        else:\n                            a *= x\n                    if self._needs_mul_brackets(b, last=True):\n                        tex += r\"\\frac{%s}{%s}%s\\left(%s\\right)\" \\\n                            % (convert(a), sdenom, separator, convert(b))\n                    else:\n                        tex += r\"\\frac{%s}{%s}%s%s\" \\\n                            % (convert(a), sdenom, separator, convert(b))\n                else:\n                    tex += r\"\\frac{1}{%s}%s%s\" % (sdenom, separator, snumer)\n            else:\n                tex += r\"\\frac{%s}{%s}\" % (snumer, sdenom)\n"
    ],
    "Location 4 (/root/hy/projects_3/sympy/sympy/printing/latex.py lines 883-887)": [
      "\n    def _print_ExpBase(self, expr, exp=None):\n        # TODO should exp_polar be printed differently?\n        #      what about exp_polar(0), exp_polar(1)?\n        tex = r\"e^{%s}\" % self._print(expr.args[0])\n        return self._do_exponent(tex, exp)\n",
      "\n    def _print_ExpBase(self, expr, exp=None):\n        # TODO should exp_polar be printed differently?\n        #      what about exp_polar(0), exp_polar(1)?\n        tex = r\"e^{%s}\" % self._print(expr.args[0])\n        return self._do_exponent(tex, exp)\n",
      "\n    def _print_ExpBase(self, expr, exp=None):\n        # TODO should exp_polar be printed differently?\n        #      what about exp_polar(0), exp_polar(1)?\n        tex = r\"e^{%s}\" % self._print(expr.args[0])\n        return self._do_exponent(tex, exp)\n",
      "\n    def _print_ExpBase(self, expr, exp=None):\n        # TODO should exp_polar be printed differently?\n        #      what about exp_polar(0), exp_polar(1)?\n        tex = r\"e^{%s}\" % self._print(expr.args[0])\n        return self._do_exponent(tex, exp)\n",
      "\n    def _print_ExpBase(self, expr, exp=None):\n        # TODO should exp_polar be printed differently?\n        #      what about exp_polar(0), exp_polar(1)?\n        tex = r\"e^{%s}\" % self._print(expr.args[0])\n        return self._do_exponent(tex, exp)\n",
      "\n    def _print_ExpBase(self, expr, exp=None):\n        # TODO should exp_polar be printed differently?\n        #      what about exp_polar(0), exp_polar(1)?\n        tex = r\"e^{%s}\" % self._print(expr.args[0])\n        return self._do_exponent(tex, exp)\n",
      "\n    def _print_ExpBase(self, expr, exp=None):\n        # TODO should exp_polar be printed differently?\n        #      what about exp_polar(0), exp_polar(1)?\n        tex = r\"e^{%s}\" % self._print(expr.args[0])\n        return self._do_exponent(tex, exp)\n",
      "\n    def _print_ExpBase(self, expr, exp=None):\n        # TODO should exp_polar be printed differently?\n        #      what about exp_polar(0), exp_polar(1)?\n        tex = r\"e^{%s}\" % self._print(expr.args[0])\n        return self._do_exponent(tex, exp)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex 1edc712358..2925d254d4 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -345,6 +345,7 @@ def _print_Float(self, expr):\n         else:\n             return str_real\n \n+\n     def _print_Mul(self, expr):\n         include_parens = False\n         if _coeff_isneg(expr):\n@@ -356,8 +357,96 @@ def _print_Mul(self, expr):\n         else:\n             tex = \"\"\n \n-        from sympy.simplify import fraction\n-        numer, denom = fraction(expr, exact=True)\n+        # Manual term processing to preserve expression structure\n+        # Separate numerator and denominator terms without using fraction()\n+        a = []  # numerator terms\n+        b = []  # denominator terms\n+        \n+        if self.order not in ('old', 'none'):\n+            args = expr.as_ordered_factors()\n+        else:\n+            args = expr.args\n+            \n+        for item in args:\n+            if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp.is_negative:\n+                # Handle negative powers - move to denominator\n+                if item.exp != -1:\n+                    from sympy.core.power import Pow\n+                    b.append(Pow(item.base, -item.exp, evaluate=False))\n+                else:\n+                    b.append(item.base)\n+            elif item.is_Rational and item is not S.Infinity:\n+                # Handle rational numbers\n+                if item.p != 1:\n+                    from sympy.core.numbers import Rational\n+                    a.append(Rational(item.p))\n+                if item.q != 1:\n+                    from sympy.core.numbers import Rational\n+                    b.append(Rational(item.q))\n+            else:\n+                a.append(item)\n+        \n+        # Create numerator and denominator expressions\n+        if not a:\n+            numer = S.One\n+        elif len(a) == 1:\n+            numer = a[0]\n+        else:\n+            from sympy.core.mul import Mul\n+            numer = Mul(*a, evaluate=False)\n+            \n+        if not b:\n+            denom = S.One\n+        elif len(b) == 1:\n+            denom = b[0]\n+        else:\n+            from sympy.core.mul import Mul\n+            denom = Mul(*b, evaluate=False)\n+            \n+        separator = self._settings['mul_symbol_latex']\n+        numbersep = self._settings['mul_symbol_latex_numbers']\n+\n+        def convert(expr):\n+            if not expr.is_Mul:\n+                return str(self._print(expr))\n+            else:\n+                _tex = last_term_tex = \"\"\n+\n+                if self.order not in ('old', 'none'):\n+            if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp.is_negative:\n+                # Handle negative powers - move to denominator\n+                if item.exp != -1:\n+                    from sympy.core.power import Pow\n+                    b.append(Pow(item.base, -item.exp, evaluate=False))\n+                else:\n+                    b.append(item.base)\n+            elif item.is_Rational and item is not S.Infinity:\n+                # Handle rational numbers\n+                if item.p != 1:\n+                    from sympy.core.numbers import Rational\n+                    a.append(Rational(item.p))\n+                if item.q != 1:\n+                    from sympy.core.numbers import Rational\n+                    b.append(Rational(item.q))\n+            else:\n+                a.append(item)\n+        \n+        # Create numerator and denominator expressions\n+        if not a:\n+            numer = S.One\n+        elif len(a) == 1:\n+            numer = a[0]\n+        else:\n+            from sympy.core.mul import Mul\n+            numer = Mul(*a, evaluate=False)\n+            \n+        if not b:\n+            denom = S.One\n+        elif len(b) == 1:\n+            denom = b[0]\n+        else:\n+            from sympy.core.mul import Mul\n+            denom = Mul(*b, evaluate=False)\n         separator = self._settings['mul_symbol_latex']\n         numbersep = self._settings['mul_symbol_latex_numbers']\n \n@@ -394,6 +483,7 @@ def convert(expr):\n             # use the original expression here, since fraction() may have\n             # altered it when producing numer and denom\n             tex += convert(expr)\n+\n         else:\n             snumer = convert(numer)\n             sdenom = convert(denom)\n@@ -880,6 +970,7 @@ def _print_polar_lift(self, expr, exp=None):\n         else:\n             return r\"%s%s\" % (func, arg)\n \n+\n     def _print_ExpBase(self, expr, exp=None):\n         # TODO should exp_polar be printed differently?\n         #      what about exp_polar(0), exp_polar(1)?\n",
    "variant_0": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex 1edc712358..cf495082a7 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -345,6 +345,7 @@ def _print_Float(self, expr):\n         else:\n             return str_real\n \n+\n     def _print_Mul(self, expr):\n         include_parens = False\n         if _coeff_isneg(expr):\n@@ -356,8 +357,60 @@ def _print_Mul(self, expr):\n         else:\n             tex = \"\"\n \n-        from sympy.simplify import fraction\n-        numer, denom = fraction(expr, exact=True)\n+        # Manual term processing to preserve structure like pretty printer\n+        a = []  # numerator terms\n+        b = []  # denominator terms\n+        \n+        if self.order not in ('old', 'none'):\n+            args = expr.as_ordered_factors()\n+        else:\n+            args = expr.args\n+            \n+        # Process each term manually instead of using fraction()\n+        for term in args:\n+            if term.is_Rational and term.q != 1:\n+                if term.p != 1:\n+                    a.append(term.p)\n+                b.append(term.q)\n+            elif term.is_Pow and term.exp.is_negative:\n+                b.append(term.base**(-term.exp))\n+            else:\n+                a.append(term)\n+        \n+        # Create numerator and denominator expressions\n+        if not a:\n+            numer = S.One\n+        else:\n+            numer = Mul(*a)\n+        \n+        if not b:\n+            denom = S.One\n+        else:\n+            denom = Mul(*b)\n+            \n+        separator = self._settings['mul_symbol_latex']\n+        numbersep = self._settings['mul_symbol_latex_numbers']\n+\n+        def convert(expr):\n+            if not expr.is_Mul:\n+                return str(self._print(expr))\n+            else:\n+                _tex = last_term_tex = \"\"\n+\n+                if self.order not in ('old', 'none'):\n+                    args = expr.as_ordered_factors()\n+                else:\n+                    args = expr.args\n+                if item.p != 1:\n+                    a.append(Rational(item.p))\n+                if item.q != 1:\n+                    b.append(Rational(item.q))\n+            else:\n+                a.append(item)\n+        \n+        a = a or [S.One]\n+        numer = Mul(*a, evaluate=False)\n+        denom = Mul(*b, evaluate=False) if b else S.One\n         separator = self._settings['mul_symbol_latex']\n         numbersep = self._settings['mul_symbol_latex_numbers']\n \n@@ -394,7 +447,28 @@ def convert(expr):\n             # use the original expression here, since fraction() may have\n             # altered it when producing numer and denom\n             tex += convert(expr)\n+\n         else:\n+            # Manual term processing to preserve expression structure\n+            # Similar to pretty printer approach\n+            a = S.One\n+            b = S.One\n+            \n+            for item in expr.args:\n+                if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp < 0:\n+                    if item.exp != -1:\n+                        b *= item.base**(-item.exp)\n+                    else:\n+                        b *= item.base\n+                elif item.is_Rational and item < 0:\n+                    a *= -1\n+                    b *= -1/item\n+                else:\n+                    a *= item\n+            \n+            numer = a\n+            denom = b\n+            \n             snumer = convert(numer)\n             sdenom = convert(denom)\n             ldenom = len(sdenom.split())\n@@ -880,6 +954,7 @@ def _print_polar_lift(self, expr, exp=None):\n         else:\n             return r\"%s%s\" % (func, arg)\n \n+\n     def _print_ExpBase(self, expr, exp=None):\n         # TODO should exp_polar be printed differently?\n         #      what about exp_polar(0), exp_polar(1)?\n",
    "variant_1": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex 1edc712358..f0f2c2d2bf 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -345,6 +345,7 @@ def _print_Float(self, expr):\n         else:\n             return str_real\n \n+\n     def _print_Mul(self, expr):\n         include_parens = False\n         if _coeff_isneg(expr):\n@@ -356,8 +357,68 @@ def _print_Mul(self, expr):\n         else:\n             tex = \"\"\n \n-        from sympy.simplify import fraction\n-        numer, denom = fraction(expr, exact=True)\n+        # Manual term processing to preserve structure like pretty printer\n+        a = []  # numerator terms\n+        b = []  # denominator terms\n+        \n+        if self.order not in ('old', 'none'):\n+            args = expr.as_ordered_factors()\n+        else:\n+            args = expr.args\n+            \n+        # Process each term manually to preserve original structure\n+        for item in args:\n+            if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp < 0:\n+                if item.exp != -1:\n+                    b.append(Pow(item.base, -item.exp, evaluate=False))\n+                else:\n+                    b.append(item.base)\n+            elif item.is_Rational and item is not S.Infinity:\n+                if item.p != 1:\n+                    a.append(Rational(item.p))\n+                if item.q != 1:\n+                    b.append(Rational(item.q))\n+            else:\n+                a.append(item)\n+        \n+        # Convert lists back to expressions\n+        if not a:\n+            numer = S.One\n+        elif len(a) == 1:\n+            numer = a[0]\n+        else:\n+            numer = Mul(*a, evaluate=False)\n+            \n+        if not b:\n+            denom = S.One\n+        elif len(b) == 1:\n+            denom = b[0]\n+        else:\n+            denom = Mul(*b, evaluate=False)\n+            \n+        separator = self._settings['mul_symbol_latex']\n+        numbersep = self._settings['mul_symbol_latex_numbers']\n+\n+        def convert(expr):\n+            if not expr.is_Mul:\n+                return str(self._print(expr))\n+            else:\n+                _tex = last_term_tex = \"\"\n+                if item.p != 1:\n+                    a.append(Rational(item.p))\n+                if item.q != 1:\n+                    b.append(Rational(item.q))\n+            else:\n+                a.append(item)\n+        \n+        a = a or [S.One]\n+        \n+        if len(b) == 0:\n+            numer = Mul(*a)\n+            denom = S.One\n+        else:\n+            numer = Mul(*a)\n+            denom = Mul(*b)\n         separator = self._settings['mul_symbol_latex']\n         numbersep = self._settings['mul_symbol_latex_numbers']\n \n@@ -394,40 +455,78 @@ def convert(expr):\n             # use the original expression here, since fraction() may have\n             # altered it when producing numer and denom\n             tex += convert(expr)\n+\n         else:\n-            snumer = convert(numer)\n-            sdenom = convert(denom)\n-            ldenom = len(sdenom.split())\n-            ratio = self._settings['long_frac_ratio']\n-            if self._settings['fold_short_frac'] \\\n-                    and ldenom <= 2 and not \"^\" in sdenom:\n-                # handle short fractions\n-                if self._needs_mul_brackets(numer, last=False):\n-                    tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n+            # Manual term processing to preserve expression structure\n+            # Split terms based on negative exponents, similar to pretty printer\n+            a = []  # numerator terms\n+            b = []  # denominator terms\n+            \n+            for item in expr.args:\n+                if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp.is_negative:\n+                    if item.exp != -1:\n+                        b.append(Pow(item.base, -item.exp, evaluate=False))\n+                    else:\n+                        b.append(item.base)\n+                elif item.is_Rational and item.is_negative:\n+                    a.append(-item)\n+                    b.append(S.One)\n+                else:\n+                    a.append(item)\n+            \n+            if len(b) == 0:\n+                # No denominator terms, use original expression\n+                snumer = convert(expr)\n+                sdenom = \"1\"\n+            else:\n+                # Construct numerator and denominator\n+                if len(a) == 0:\n+                    numer = S.One\n                 else:\n-                    tex += r\"%s / %s\" % (snumer, sdenom)\n-            elif len(snumer.split()) > ratio*ldenom:\n-                # handle long fractions\n-                if self._needs_mul_brackets(numer, last=True):\n-                    tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n-                        % (sdenom, separator, snumer)\n-                elif numer.is_Mul:\n-                    # split a long numerator\n-                    a = S.One\n-                    b = S.One\n-                    for x in numer.args:\n-                        if self._needs_mul_brackets(x, last=False) or \\\n-                                len(convert(a*x).split()) > ratio*ldenom or \\\n-                                (b.is_commutative is x.is_commutative is False):\n-                            b *= x\n+                    numer = Mul(*a)\n+                denom = Mul(*b)\n+                \n+                snumer = convert(numer)\n+                sdenom = convert(denom)\n+            \n+            if len(b) == 0:\n+                tex += snumer\n+            else:\n+                ldenom = len(sdenom.split())\n+                ratio = self._settings['long_frac_ratio']\n+                if self._settings['fold_short_frac'] \\\n+                        and ldenom <= 2 and not \"^\" in sdenom:\n+                    # handle short fractions\n+                    if self._needs_mul_brackets(numer, last=False):\n+                        tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n+                    else:\n+                        tex += r\"%s / %s\" % (snumer, sdenom)\n+                elif len(snumer.split()) > ratio*ldenom:\n+                    # handle long fractions\n+                    if self._needs_mul_brackets(numer, last=True):\n+                        tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n+                            % (sdenom, separator, snumer)\n+                    elif numer.is_Mul:\n+                        # split a long numerator\n+                        a_split = S.One\n+                        b_split = S.One\n+                        for x in numer.args:\n+                            if self._needs_mul_brackets(x, last=False) or \\\n+                                    len(convert(a_split*x).split()) > ratio*ldenom or \\\n+                                    (b_split.is_commutative is x.is_commutative is False):\n+                                b_split *= x\n+                            else:\n+                                a_split *= x\n+                        if self._needs_mul_brackets(b_split, last=True):\n+                            tex += r\"\\frac{%s}{%s}%s\\left(%s\\right)\" \\\n+                                % (convert(a_split), sdenom, separator, convert(b_split))\n                         else:\n-                            a *= x\n-                    if self._needs_mul_brackets(b, last=True):\n-                        tex += r\"\\frac{%s}{%s}%s\\left(%s\\right)\" \\\n-                            % (convert(a), sdenom, separator, convert(b))\n+                            tex += r\"\\frac{%s}{%s}%s%s\" \\\n+                                % (convert(a_split), sdenom, separator, convert(b_split))\n                     else:\n-                        tex += r\"\\frac{%s}{%s}%s%s\" \\\n-                            % (convert(a), sdenom, separator, convert(b))\n+                        tex += r\"\\frac{1}{%s}%s%s\" % (sdenom, separator, snumer)\n+                else:\n+                    tex += r\"\\frac{%s}{%s}\" % (snumer, sdenom)\n                 else:\n                     tex += r\"\\frac{1}{%s}%s%s\" % (sdenom, separator, snumer)\n             else:\n@@ -880,6 +979,7 @@ def _print_polar_lift(self, expr, exp=None):\n         else:\n             return r\"%s%s\" % (func, arg)\n \n+\n     def _print_ExpBase(self, expr, exp=None):\n         # TODO should exp_polar be printed differently?\n         #      what about exp_polar(0), exp_polar(1)?\n",
    "variant_2": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex 1edc712358..033aa89e32 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -345,6 +345,7 @@ def _print_Float(self, expr):\n         else:\n             return str_real\n \n+\n     def _print_Mul(self, expr):\n         include_parens = False\n         if _coeff_isneg(expr):\n@@ -356,8 +357,71 @@ def _print_Mul(self, expr):\n         else:\n             tex = \"\"\n \n-        from sympy.simplify import fraction\n-        numer, denom = fraction(expr, exact=True)\n+        # Manual term processing to preserve expression structure\n+        a = []  # numerator terms\n+        b = []  # denominator terms\n+        \n+        if self.order not in ('old', 'none'):\n+            args = expr.as_ordered_factors()\n+        else:\n+            args = expr.args\n+            \n+        for item in args:\n+            if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp.is_negative:\n+                if item.exp != -1:\n+                    b.append(item.base**(-item.exp))\n+                else:\n+                    b.append(item.base)\n+            elif item.is_Rational and item is not S.Infinity:\n+                if item.p != 1:\n+                    a.append(item.p)\n+                if item.q != 1:\n+                    b.append(item.q)\n+            else:\n+                a.append(item)\n+        \n+        # If no denominator terms, use simpler multiplication logic\n+        if not b:\n+            numer = expr\n+            denom = S.One\n+        else:\n+            from sympy import Mul\n+            numer = Mul(*a) if a else S.One\n+            denom = Mul(*b)\n+        \n+        separator = self._settings['mul_symbol_latex']\n+        numbersep = self._settings['mul_symbol_latex_numbers']\n+\n+        def convert(expr):\n+            if not expr.is_Mul:\n+                return str(self._print(expr))\n+            else:\n+                _tex = last_term_tex = \"\"\n+\n+                if self.order not in ('old', 'none'):\n+                    args = expr.as_ordered_factors()\n+                else:\n+                    args = expr.args\n+            elif item.is_Pow and item.exp.is_Rational and item.exp.is_negative:\n+                # Move negative powers to denominator\n+                b.append(item.base**(-item.exp))\n+            else:\n+                a.append(item)\n+        \n+        # Build numerator and denominator from collected terms\n+        if len(a) == 0:\n+            numer = S.One\n+        elif len(a) == 1:\n+            numer = a[0]\n+        else:\n+            numer = expr.func(*a)\n+            \n+        if len(b) == 0:\n+            denom = S.One\n+        elif len(b) == 1:\n+            denom = b[0]\n+        else:\n+            denom = expr.func(*b)\n         separator = self._settings['mul_symbol_latex']\n         numbersep = self._settings['mul_symbol_latex_numbers']\n \n@@ -394,40 +458,66 @@ def convert(expr):\n             # use the original expression here, since fraction() may have\n             # altered it when producing numer and denom\n             tex += convert(expr)\n+\n         else:\n-            snumer = convert(numer)\n-            sdenom = convert(denom)\n-            ldenom = len(sdenom.split())\n-            ratio = self._settings['long_frac_ratio']\n-            if self._settings['fold_short_frac'] \\\n-                    and ldenom <= 2 and not \"^\" in sdenom:\n-                # handle short fractions\n-                if self._needs_mul_brackets(numer, last=False):\n-                    tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n+            # Manual term processing to preserve structure like pretty printer\n+            a = S.One  # numerator terms\n+            b = S.One  # denominator terms\n+            \n+            for item in expr.args:\n+                if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp.is_negative:\n+                    if item.exp is S.NegativeOne:\n+                        b *= item.base\n+                    else:\n+                        b *= item.base**(-item.exp)\n+                elif item.is_Rational and item.is_negative:\n+                    a *= -item\n+                    b *= S.NegativeOne\n                 else:\n-                    tex += r\"%s / %s\" % (snumer, sdenom)\n-            elif len(snumer.split()) > ratio*ldenom:\n-                # handle long fractions\n-                if self._needs_mul_brackets(numer, last=True):\n-                    tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n-                        % (sdenom, separator, snumer)\n-                elif numer.is_Mul:\n-                    # split a long numerator\n-                    a = S.One\n-                    b = S.One\n-                    for x in numer.args:\n-                        if self._needs_mul_brackets(x, last=False) or \\\n-                                len(convert(a*x).split()) > ratio*ldenom or \\\n-                                (b.is_commutative is x.is_commutative is False):\n-                            b *= x\n+                    a *= item\n+            \n+            # Now a is numerator, b is denominator\n+            if b is S.One:\n+                # No actual fraction, just render as multiplication\n+                tex += convert(expr)\n+            else:\n+                snumer = convert(a)\n+                sdenom = convert(b)\n+                ldenom = len(sdenom.split())\n+                ratio = self._settings['long_frac_ratio']\n+                if self._settings['fold_short_frac'] \\\n+                        and ldenom <= 2 and not \"^\" in sdenom:\n+                    # handle short fractions\n+                    if self._needs_mul_brackets(a, last=False):\n+                        tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n+                    else:\n+                        tex += r\"%s / %s\" % (snumer, sdenom)\n+                elif len(snumer.split()) > ratio*ldenom:\n+                    # handle long fractions\n+                    if self._needs_mul_brackets(a, last=True):\n+                        tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n+                            % (sdenom, separator, snumer)\n+                    elif a.is_Mul:\n+                        # split a long numerator\n+                        a_part = S.One\n+                        b_part = S.One\n+                        for x in a.args:\n+                            if self._needs_mul_brackets(x, last=False) or \\\n+                                    len(convert(a_part*x).split()) > ratio*ldenom or \\\n+                                    (b_part.is_commutative is x.is_commutative is False):\n+                                b_part *= x\n+                            else:\n+                                a_part *= x\n+                        if self._needs_mul_brackets(b_part, last=True):\n+                            tex += r\"\\frac{%s}{%s}%s\\left(%s\\right)\" \\\n+                                % (convert(a_part), sdenom, separator, convert(b_part))\n                         else:\n-                            a *= x\n-                    if self._needs_mul_brackets(b, last=True):\n-                        tex += r\"\\frac{%s}{%s}%s\\left(%s\\right)\" \\\n-                            % (convert(a), sdenom, separator, convert(b))\n+                            tex += r\"\\frac{%s}{%s}%s%s\" \\\n+                                % (convert(a_part), sdenom, separator, convert(b_part))\n                     else:\n-                        tex += r\"\\frac{%s}{%s}%s%s\" \\\n-                            % (convert(a), sdenom, separator, convert(b))\n+                        tex += r\"\\frac{1}{%s}%s%s\" % (sdenom, separator, snumer)\n+                else:\n+                    tex += r\"\\frac{%s}{%s}\" % (snumer, sdenom)\n                 else:\n                     tex += r\"\\frac{1}{%s}%s%s\" % (sdenom, separator, snumer)\n             else:\n@@ -880,6 +970,7 @@ def _print_polar_lift(self, expr, exp=None):\n         else:\n             return r\"%s%s\" % (func, arg)\n \n+\n     def _print_ExpBase(self, expr, exp=None):\n         # TODO should exp_polar be printed differently?\n         #      what about exp_polar(0), exp_polar(1)?\n",
    "variant_3": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex 1edc712358..d1980b2abe 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -345,6 +345,7 @@ def _print_Float(self, expr):\n         else:\n             return str_real\n \n+\n     def _print_Mul(self, expr):\n         include_parens = False\n         if _coeff_isneg(expr):\n@@ -356,8 +357,70 @@ def _print_Mul(self, expr):\n         else:\n             tex = \"\"\n \n-        from sympy.simplify import fraction\n-        numer, denom = fraction(expr, exact=True)\n+        # Manual term processing to preserve structure like pretty printer\n+        a = []  # numerator terms\n+        b = []  # denominator terms\n+        \n+        if self.order not in ('old', 'none'):\n+            args = expr.as_ordered_factors()\n+        else:\n+            args = expr.args\n+            \n+        # Process each term manually to avoid unwanted algebraic transformations\n+        for term in args:\n+            if term.is_Rational and term.q != 1:\n+                # Handle rational numbers\n+                if term.p != 1:\n+                    a.append(term.p)\n+                if term.q != 1:\n+                    b.append(term.q)\n+            elif term.is_Pow and term.exp.is_negative:\n+                # Handle negative exponents - put in denominator with positive exponent\n+                b.append(term.base ** (-term.exp))\n+            else:\n+                # All other terms go in numerator\n+                a.append(term)\n+        \n+        # Create numerator and denominator expressions\n+        if not a:\n+            numer = S.One\n+        elif len(a) == 1:\n+            numer = a[0]\n+        else:\n+            numer = expr.func(*a)\n+            \n+        if not b:\n+            denom = S.One\n+        elif len(b) == 1:\n+            denom = b[0]\n+        else:\n+            denom = expr.func(*b)\n+\n+        separator = self._settings['mul_symbol_latex']\n+        numbersep = self._settings['mul_symbol_latex_numbers']\n+\n+        def convert(expr):\n+            if not expr.is_Mul:\n+                return str(self._print(expr))\n+            else:\n+                _tex = last_term_tex = \"\"\n+\n+                if self.order not in ('old', 'none'):\n+                    args = expr.as_ordered_factors()\n+                else:\n+                    args = expr.args\n+            elif item.is_Pow and item.exp.is_negative:\n+                b.append(Pow(item.base, -item.exp, evaluate=False))\n+            else:\n+                a.append(item)\n+        \n+        if not a:\n+            a = [S.One]\n+        if not b:\n+            b = [S.One]\n+            \n+        numer = a[0] if len(a) == 1 else Mul(*a, evaluate=False)\n+        denom = b[0] if len(b) == 1 else Mul(*b, evaluate=False)\n         separator = self._settings['mul_symbol_latex']\n         numbersep = self._settings['mul_symbol_latex_numbers']\n \n@@ -394,40 +457,75 @@ def convert(expr):\n             # use the original expression here, since fraction() may have\n             # altered it when producing numer and denom\n             tex += convert(expr)\n+\n         else:\n-            snumer = convert(numer)\n-            sdenom = convert(denom)\n-            ldenom = len(sdenom.split())\n-            ratio = self._settings['long_frac_ratio']\n-            if self._settings['fold_short_frac'] \\\n-                    and ldenom <= 2 and not \"^\" in sdenom:\n-                # handle short fractions\n-                if self._needs_mul_brackets(numer, last=False):\n-                    tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n+            # Manual term processing to preserve expression structure\n+            # Similar to pretty printer approach\n+            a = []  # numerator terms\n+            b = []  # denominator terms\n+            \n+            for item in expr.args:\n+                if item.is_Rational and item.is_negative:\n+                    if item is not S.NegativeOne:\n+                        a.append(Rational(-item.p, item.q))\n+                    b.append(S.One)\n+                elif item.is_Pow and item.exp.is_Rational and item.exp.is_negative:\n+                    if item.exp is not S.NegativeOne:\n+                        b.append(Pow(item.base, -item.exp, evaluate=False))\n+                    else:\n+                        b.append(item.base)\n+                else:\n+                    a.append(item)\n+            \n+            if len(b) == 0:\n+                # No denominator terms, use original expression\n+                tex += convert(expr)\n+            else:\n+                # Build numerator and denominator\n+                if len(a) == 0:\n+                    numer = S.One\n                 else:\n-                    tex += r\"%s / %s\" % (snumer, sdenom)\n-            elif len(snumer.split()) > ratio*ldenom:\n-                # handle long fractions\n-                if self._needs_mul_brackets(numer, last=True):\n-                    tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n-                        % (sdenom, separator, snumer)\n-                elif numer.is_Mul:\n-                    # split a long numerator\n-                    a = S.One\n-                    b = S.One\n-                    for x in numer.args:\n-                        if self._needs_mul_brackets(x, last=False) or \\\n-                                len(convert(a*x).split()) > ratio*ldenom or \\\n-                                (b.is_commutative is x.is_commutative is False):\n-                            b *= x\n+                    numer = Mul(*a, evaluate=False) if len(a) > 1 else a[0]\n+                \n+                denom = Mul(*b, evaluate=False) if len(b) > 1 else b[0]\n+                \n+                snumer = convert(numer)\n+                sdenom = convert(denom)\n+                ldenom = len(sdenom.split())\n+                ratio = self._settings['long_frac_ratio']\n+                if self._settings['fold_short_frac'] \\\n+                        and ldenom <= 2 and not \"^\" in sdenom:\n+                    # handle short fractions\n+                    if self._needs_mul_brackets(numer, last=False):\n+                        tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n+                    else:\n+                        tex += r\"%s / %s\" % (snumer, sdenom)\n+                elif len(snumer.split()) > ratio*ldenom:\n+                    # handle long fractions\n+                    if self._needs_mul_brackets(numer, last=True):\n+                        tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n+                            % (sdenom, separator, snumer)\n+                    elif numer.is_Mul:\n+                        # split a long numerator\n+                        a_split = S.One\n+                        b_split = S.One\n+                        for x in numer.args:\n+                            if self._needs_mul_brackets(x, last=False) or \\\n+                                    len(convert(a_split*x).split()) > ratio*ldenom or \\\n+                                    (b_split.is_commutative is x.is_commutative is False):\n+                                b_split *= x\n+                            else:\n+                                a_split *= x\n+                        if self._needs_mul_brackets(b_split, last=True):\n+                            tex += r\"\\frac{%s}{%s}%s\\left(%s\\right)\" \\\n+                                % (convert(a_split), sdenom, separator, convert(b_split))\n                         else:\n-                            a *= x\n-                    if self._needs_mul_brackets(b, last=True):\n-                        tex += r\"\\frac{%s}{%s}%s\\left(%s\\right)\" \\\n-                            % (convert(a), sdenom, separator, convert(b))\n+                            tex += r\"\\frac{%s}{%s}%s%s\" \\\n+                                % (convert(a_split), sdenom, separator, convert(b_split))\n                     else:\n-                        tex += r\"\\frac{%s}{%s}%s%s\" \\\n-                            % (convert(a), sdenom, separator, convert(b))\n+                        tex += r\"\\frac{1}{%s}%s%s\" % (sdenom, separator, snumer)\n+                else:\n+                    tex += r\"\\frac{%s}{%s}\" % (snumer, sdenom)\n                 else:\n                     tex += r\"\\frac{1}{%s}%s%s\" % (sdenom, separator, snumer)\n             else:\n@@ -880,6 +978,7 @@ def _print_polar_lift(self, expr, exp=None):\n         else:\n             return r\"%s%s\" % (func, arg)\n \n+\n     def _print_ExpBase(self, expr, exp=None):\n         # TODO should exp_polar be printed differently?\n         #      what about exp_polar(0), exp_polar(1)?\n",
    "variant_4": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex 1edc712358..4863435f3f 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -345,6 +345,7 @@ def _print_Float(self, expr):\n         else:\n             return str_real\n \n+\n     def _print_Mul(self, expr):\n         include_parens = False\n         if _coeff_isneg(expr):\n@@ -356,8 +357,63 @@ def _print_Mul(self, expr):\n         else:\n             tex = \"\"\n \n-        from sympy.simplify import fraction\n-        numer, denom = fraction(expr, exact=True)\n+        # Manual term processing to preserve expression structure\n+        a = []  # numerator terms\n+        b = []  # denominator terms\n+        \n+        if self.order not in ('old', 'none'):\n+            args = expr.as_ordered_factors()\n+        else:\n+            args = expr.args\n+            \n+        for item in args:\n+            if item.is_Rational and item is not S.Infinity:\n+                if item.p != 1:\n+                    a.append(item.p)\n+                if item.q != 1:\n+                    b.append(item.q)\n+            elif item.is_Pow and item.exp.is_Rational and item.exp < 0:\n+                if item.exp != -1:\n+                    b.append(Pow(item.base, -item.exp, evaluate=False))\n+                else:\n+                    b.append(item.base)\n+            else:\n+                a.append(item)\n+        \n+        numer = Mul(*a) if a else S.One\n+        denom = Mul(*b) if b else S.One\n+        \n+        separator = self._settings['mul_symbol_latex']\n+        numbersep = self._settings['mul_symbol_latex_numbers']\n+\n+        def convert(expr):\n+            if not expr.is_Mul:\n+                return str(self._print(expr))\n+            else:\n+                _tex = last_term_tex = \"\"\n+\n+                if self.order not in ('old', 'none'):\n+                    args = expr.as_ordered_factors()\n+                else:\n+                    args = expr.args\n+                if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp.is_negative:\n+                    if item.exp != -1:\n+                        b.append(Pow(item.base, -item.exp, evaluate=False))\n+                    else:\n+                        b.append(item.base)\n+                elif item.is_Rational and item is not S.Infinity:\n+                    if item.p != 1:\n+                        a.append(item.p)\n+                    if item.q != 1:\n+                        b.append(item.q)\n+                else:\n+                    a.append(item)\n+        \n+        if not a:\n+            a = [S.One]\n+        \n+        numer = a[0] if len(a) == 1 else Mul(*a, evaluate=False)\n+        denom = b[0] if len(b) == 1 else Mul(*b, evaluate=False) if b else S.One\n         separator = self._settings['mul_symbol_latex']\n         numbersep = self._settings['mul_symbol_latex_numbers']\n \n@@ -394,7 +450,43 @@ def convert(expr):\n             # use the original expression here, since fraction() may have\n             # altered it when producing numer and denom\n             tex += convert(expr)\n+\n         else:\n+            # Manual term processing to preserve original structure\n+            a = S.One  # numerator terms\n+            b = S.One  # denominator terms\n+            \n+            for item in expr.args:\n+                if item.is_commutative is False:\n+                    # Handle non-commutative terms in numerator\n+                    a = a * item\n+                elif item.is_Rational and item.is_negative:\n+                    # Handle negative rationals\n+                    a = a * item\n+                elif item.is_Pow and item.exp.is_Rational and item.exp.is_negative:\n+                    # Move negative powers to denominator\n+                    if item.exp is S.NegativeOne:\n+                        b = b * item.base\n+                    else:\n+                        b = b * item.base**(-item.exp)\n+                elif item.is_Rational and item is not S.One:\n+                    # Handle positive rationals\n+                    if item.p != 1:\n+                        a = a * item.p\n+                    if item.q != 1:\n+                        b = b * item.q\n+                else:\n+                    # All other terms go in numerator\n+                    a = a * item\n+            \n+            # Set numer and denom based on manual processing\n+            if b is S.One:\n+                numer = a\n+                denom = S.One\n+            else:\n+                numer = a\n+                denom = b\n+            \n             snumer = convert(numer)\n             sdenom = convert(denom)\n             ldenom = len(sdenom.split())\n@@ -432,6 +524,10 @@ def convert(expr):\n                     tex += r\"\\frac{1}{%s}%s%s\" % (sdenom, separator, snumer)\n             else:\n                 tex += r\"\\frac{%s}{%s}\" % (snumer, sdenom)\n+                else:\n+                    tex += r\"\\frac{1}{%s}%s%s\" % (sdenom, separator, snumer)\n+            else:\n+                tex += r\"\\frac{%s}{%s}\" % (snumer, sdenom)\n \n         if include_parens:\n             tex += \")\"\n@@ -880,6 +976,7 @@ def _print_polar_lift(self, expr, exp=None):\n         else:\n             return r\"%s%s\" % (func, arg)\n \n+\n     def _print_ExpBase(self, expr, exp=None):\n         # TODO should exp_polar be printed differently?\n         #      what about exp_polar(0), exp_polar(1)?\n",
    "variant_5": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex 1edc712358..5c0d5b121f 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -345,6 +345,7 @@ def _print_Float(self, expr):\n         else:\n             return str_real\n \n+\n     def _print_Mul(self, expr):\n         include_parens = False\n         if _coeff_isneg(expr):\n@@ -356,8 +357,73 @@ def _print_Mul(self, expr):\n         else:\n             tex = \"\"\n \n-        from sympy.simplify import fraction\n-        numer, denom = fraction(expr, exact=True)\n+        # Manual term processing to preserve expression structure\n+        a = []  # numerator terms\n+        b = []  # denominator terms\n+        \n+        if self.order not in ('old', 'none'):\n+            args = expr.as_ordered_factors()\n+        else:\n+            args = expr.args\n+            \n+        for item in args:\n+            if item.is_Rational and item.is_negative:\n+                a.append(S.One)\n+                b.append(-item)\n+            elif item.is_Pow and item.exp.is_Rational and item.exp.is_negative:\n+                if item.exp != -1:\n+                    b.append(item.base**(-item.exp))\n+                else:\n+                    b.append(item.base)\n+            else:\n+                a.append(item)\n+        \n+        numer = Mul(*a) if len(a) > 1 else (a[0] if a else S.One)\n+        denom = Mul(*b) if len(b) > 1 else (b[0] if b else S.One)\n+        \n+        separator = self._settings['mul_symbol_latex']\n+        numbersep = self._settings['mul_symbol_latex_numbers']\n+\n+        def convert(expr):\n+            if not expr.is_Mul:\n+                return str(self._print(expr))\n+            else:\n+                _tex = last_term_tex = \"\"\n+\n+                if self.order not in ('old', 'none'):\n+                    args = expr.as_ordered_factors()\n+                else:\n+                    args = expr.args\n+            # Process each term in the multiplication\n+            for item in expr.args:\n+                if item.is_Rational:\n+                    if item.p != 1:\n+                        a.append(item.p)\n+                    if item.q != 1:\n+                        b.append(item.q)\n+                elif item.is_Pow and item.exp.is_Rational and item.exp < 0:\n+                    # Move negative powers to denominator\n+                    if item.exp == -1:\n+                        b.append(item.base)\n+                    else:\n+                        b.append(item.base**(-item.exp))\n+                else:\n+                    a.append(item)\n+        \n+        # Build numerator and denominator expressions\n+        if not a:\n+            numer = S.One\n+        elif len(a) == 1:\n+            numer = a[0]\n+        else:\n+            numer = expr.func(*a)\n+            \n+        if not b:\n+            denom = S.One\n+        elif len(b) == 1:\n+            denom = b[0]\n+        else:\n+            denom = expr.func(*b)\n         separator = self._settings['mul_symbol_latex']\n         numbersep = self._settings['mul_symbol_latex_numbers']\n \n@@ -394,6 +460,7 @@ def convert(expr):\n             # use the original expression here, since fraction() may have\n             # altered it when producing numer and denom\n             tex += convert(expr)\n+\n         else:\n             snumer = convert(numer)\n             sdenom = convert(denom)\n@@ -432,6 +499,10 @@ def convert(expr):\n                     tex += r\"\\frac{1}{%s}%s%s\" % (sdenom, separator, snumer)\n             else:\n                 tex += r\"\\frac{%s}{%s}\" % (snumer, sdenom)\n+                else:\n+                    tex += r\"\\frac{1}{%s}%s%s\" % (sdenom, separator, snumer)\n+            else:\n+                tex += r\"\\frac{%s}{%s}\" % (snumer, sdenom)\n \n         if include_parens:\n             tex += \")\"\n@@ -880,6 +951,7 @@ def _print_polar_lift(self, expr, exp=None):\n         else:\n             return r\"%s%s\" % (func, arg)\n \n+\n     def _print_ExpBase(self, expr, exp=None):\n         # TODO should exp_polar be printed differently?\n         #      what about exp_polar(0), exp_polar(1)?\n",
    "variant_6": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex 1edc712358..628e2c0920 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -345,6 +345,7 @@ def _print_Float(self, expr):\n         else:\n             return str_real\n \n+\n     def _print_Mul(self, expr):\n         include_parens = False\n         if _coeff_isneg(expr):\n@@ -356,8 +357,80 @@ def _print_Mul(self, expr):\n         else:\n             tex = \"\"\n \n-        from sympy.simplify import fraction\n-        numer, denom = fraction(expr, exact=True)\n+        # Manual term processing to preserve expression structure\n+        # Similar to pretty printer approach\n+        a = []  # numerator terms\n+        b = []  # denominator terms\n+        \n+        if self.order not in ('old', 'none'):\n+            args = expr.as_ordered_factors()\n+        else:\n+            args = expr.args\n+            \n+        # Process each term manually instead of using fraction()\n+        for term in args:\n+            if term.is_Rational and term.q != 1:\n+                # Handle rational numbers\n+                if term.p != 1:\n+                    a.append(term.p)\n+                if term.q != 1:\n+                    b.append(term.q)\n+            elif term.is_Pow and term.exp.is_negative:\n+                # Handle negative exponents - keep in denominator\n+                b.append(term.base ** (-term.exp))\n+            else:\n+                # All other terms go to numerator\n+                a.append(term)\n+        \n+        # Convert to expressions\n+        from sympy import Mul\n+        if not a:\n+            numer = S.One\n+        else:\n+            numer = Mul(*a)\n+        \n+        if not b:\n+            denom = S.One\n+        else:\n+            denom = Mul(*b)\n+            \n+        separator = self._settings['mul_symbol_latex']\n+        numbersep = self._settings['mul_symbol_latex_numbers']\n+\n+        def convert(expr):\n+            if not expr.is_Mul:\n+                return str(self._print(expr))\n+            else:\n+                _tex = last_term_tex = \"\"\n+\n+                if self.order not in ('old', 'none'):\n+                    args = expr.as_ordered_factors()\n+                else:\n+                    args = expr.args\n+                if item.is_Pow and item.exp.is_Rational and item.exp < 0:\n+                    if item.exp != -1:\n+                        b.append(Pow(item.base, -item.exp, evaluate=False))\n+                    else:\n+                        b.append(item.base)\n+                elif item.is_Rational and item < 0:\n+                    a.append(-item)\n+                else:\n+                    a.append(item)\n+        \n+        # Create numerator and denominator from collected terms\n+        if not a:\n+            numer = S.One\n+        elif len(a) == 1:\n+            numer = a[0]\n+        else:\n+            numer = Mul(*a, evaluate=False)\n+            \n+        if not b:\n+            denom = S.One\n+        elif len(b) == 1:\n+            denom = b[0]\n+        else:\n+            denom = Mul(*b, evaluate=False)\n         separator = self._settings['mul_symbol_latex']\n         numbersep = self._settings['mul_symbol_latex_numbers']\n \n@@ -394,40 +467,60 @@ def convert(expr):\n             # use the original expression here, since fraction() may have\n             # altered it when producing numer and denom\n             tex += convert(expr)\n+\n         else:\n-            snumer = convert(numer)\n-            sdenom = convert(denom)\n+            # Manual term processing to preserve expression structure\n+            # Similar to pretty printer approach\n+            a = S.One\n+            b = S.One\n+            \n+            for item in expr.args:\n+                if item.is_Rational and item.is_negative:\n+                    a *= -item\n+                elif item.is_Pow and item.exp.is_Rational and item.exp.is_negative:\n+                    b *= item**-1\n+                elif item.is_Pow and item.exp.is_negative:\n+                    b *= item**-1\n+                else:\n+                    a *= item\n+            \n+            snumer = convert(a)\n+            sdenom = convert(b)\n             ldenom = len(sdenom.split())\n             ratio = self._settings['long_frac_ratio']\n             if self._settings['fold_short_frac'] \\\n                     and ldenom <= 2 and not \"^\" in sdenom:\n                 # handle short fractions\n-                if self._needs_mul_brackets(numer, last=False):\n+                if self._needs_mul_brackets(a, last=False):\n                     tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n                 else:\n                     tex += r\"%s / %s\" % (snumer, sdenom)\n             elif len(snumer.split()) > ratio*ldenom:\n                 # handle long fractions\n-                if self._needs_mul_brackets(numer, last=True):\n+                if self._needs_mul_brackets(a, last=True):\n                     tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n                         % (sdenom, separator, snumer)\n-                elif numer.is_Mul:\n+                elif a.is_Mul:\n                     # split a long numerator\n-                    a = S.One\n-                    b = S.One\n-                    for x in numer.args:\n+                    a_part = S.One\n+                    b_part = S.One\n+                    for x in a.args:\n                         if self._needs_mul_brackets(x, last=False) or \\\n-                                len(convert(a*x).split()) > ratio*ldenom or \\\n-                                (b.is_commutative is x.is_commutative is False):\n-                            b *= x\n+                                len(convert(a_part*x).split()) > ratio*ldenom or \\\n+                                (b_part.is_commutative is x.is_commutative is False):\n+                            b_part *= x\n                         else:\n-                            a *= x\n-                    if self._needs_mul_brackets(b, last=True):\n+                            a_part *= x\n+                    if self._needs_mul_brackets(b_part, last=True):\n                         tex += r\"\\frac{%s}{%s}%s\\left(%s\\right)\" \\\n-                            % (convert(a), sdenom, separator, convert(b))\n+                            % (convert(a_part), sdenom, separator, convert(b_part))\n                     else:\n                         tex += r\"\\frac{%s}{%s}%s%s\" \\\n-                            % (convert(a), sdenom, separator, convert(b))\n+                            % (convert(a_part), sdenom, separator, convert(b_part))\n+                else:\n+                    tex += r\"\\frac{1}{%s}%s%s\" % (sdenom, separator, snumer)\n+            else:\n+                tex += r\"\\frac{%s}{%s}\" % (snumer, sdenom)\n                 else:\n                     tex += r\"\\frac{1}{%s}%s%s\" % (sdenom, separator, snumer)\n             else:\n@@ -880,6 +973,7 @@ def _print_polar_lift(self, expr, exp=None):\n         else:\n             return r\"%s%s\" % (func, arg)\n \n+\n     def _print_ExpBase(self, expr, exp=None):\n         # TODO should exp_polar be printed differently?\n         #      what about exp_polar(0), exp_polar(1)?\n",
    "variant_7": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex 1edc712358..ecd2b422b0 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -345,6 +345,7 @@ def _print_Float(self, expr):\n         else:\n             return str_real\n \n+\n     def _print_Mul(self, expr):\n         include_parens = False\n         if _coeff_isneg(expr):\n@@ -356,8 +357,63 @@ def _print_Mul(self, expr):\n         else:\n             tex = \"\"\n \n-        from sympy.simplify import fraction\n-        numer, denom = fraction(expr, exact=True)\n+        # Manual term processing to preserve expression structure\n+        a = []  # numerator terms\n+        b = []  # denominator terms\n+        \n+        if self.order not in ('old', 'none'):\n+            args = expr.as_ordered_factors()\n+        else:\n+            args = expr.args\n+            \n+        for item in args:\n+            if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp.is_negative:\n+                if item.exp != -1:\n+                    b.append(item.base**(-item.exp))\n+                else:\n+                    b.append(item.base)\n+            elif item.is_Rational and item is not S.Infinity:\n+                if item.p != 1:\n+                    a.append(item.p)\n+                if item.q != 1:\n+                    b.append(item.q)\n+            else:\n+                a.append(item)\n+        \n+        a = a or [S.One]\n+        \n+        separator = self._settings['mul_symbol_latex']\n+        numbersep = self._settings['mul_symbol_latex_numbers']\n+\n+        def convert(expr):\n+            if not expr.is_Mul:\n+                return str(self._print(expr))\n+            else:\n+                _tex = last_term_tex = \"\"\n+\n+                if self.order not in ('old', 'none'):\n+                    args = expr.as_ordered_factors()\n+                else:\n+                    args = expr.args\n+\n+                for i, term in enumerate(args):\n+                    term_tex = self._print(term)\n+\n+                    if self._needs_mul_brackets(term, first=(i == 0),\n+                                                last=(i == len(args) - 1)):\n+                        term_tex = r\"\\left(%s\\right)\" % term_tex\n+        else:\n+            for item in expr.args:\n+                if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp.is_negative:\n+                    if item.exp != -1:\n+                        b.append(item.base**(-item.exp))\n+                    else:\n+                        b.append(item.base)\n+                else:\n+                    a.append(item)\n+        \n+        numer = self._mul_class(*a) if a else S.One\n+        denom = self._mul_class(*b) if b else S.One\n         separator = self._settings['mul_symbol_latex']\n         numbersep = self._settings['mul_symbol_latex_numbers']\n \n@@ -394,7 +450,38 @@ def convert(expr):\n             # use the original expression here, since fraction() may have\n             # altered it when producing numer and denom\n             tex += convert(expr)\n+\n         else:\n+            # Manual term processing to preserve original structure\n+            a = S.One  # numerator terms\n+            b = S.One  # denominator terms\n+            \n+            for item in expr.args:\n+                if item.is_commutative is False:\n+                    # Handle non-commutative terms\n+                    if a.is_commutative is False:\n+                        b *= item\n+                    else:\n+                        a *= item\n+                elif item.is_Rational and item.is_negative:\n+                    a *= -item\n+                    sign = -sign\n+                elif item.is_Pow and item.exp.is_Rational and item.exp.is_negative:\n+                    if item.exp != -1:\n+                        b *= Pow(item.base, -item.exp, evaluate=False)\n+                    else:\n+                        b *= item.base\n+                else:\n+                    a *= item\n+            \n+            # Set numer and denom based on manual processing\n+            if b == S.One:\n+                numer = a\n+                denom = S.One\n+            else:\n+                numer = a\n+                denom = b\n+            \n             snumer = convert(numer)\n             sdenom = convert(denom)\n             ldenom = len(sdenom.split())\n@@ -413,21 +500,25 @@ def convert(expr):\n                         % (sdenom, separator, snumer)\n                 elif numer.is_Mul:\n                     # split a long numerator\n-                    a = S.One\n-                    b = S.One\n+                    a_split = S.One\n+                    b_split = S.One\n                     for x in numer.args:\n                         if self._needs_mul_brackets(x, last=False) or \\\n-                                len(convert(a*x).split()) > ratio*ldenom or \\\n-                                (b.is_commutative is x.is_commutative is False):\n-                            b *= x\n+                                len(convert(a_split*x).split()) > ratio*ldenom or \\\n+                                (b_split.is_commutative is x.is_commutative is False):\n+                            b_split *= x\n                         else:\n-                            a *= x\n-                    if self._needs_mul_brackets(b, last=True):\n+                            a_split *= x\n+                    if self._needs_mul_brackets(b_split, last=True):\n                         tex += r\"\\frac{%s}{%s}%s\\left(%s\\right)\" \\\n-                            % (convert(a), sdenom, separator, convert(b))\n+                            % (convert(a_split), sdenom, separator, convert(b_split))\n                     else:\n                         tex += r\"\\frac{%s}{%s}%s%s\" \\\n-                            % (convert(a), sdenom, separator, convert(b))\n+                            % (convert(a_split), sdenom, separator, convert(b_split))\n+                else:\n+                    tex += r\"\\frac{1}{%s}%s%s\" % (sdenom, separator, snumer)\n+            else:\n+                tex += r\"\\frac{%s}{%s}\" % (snumer, sdenom)\n                 else:\n                     tex += r\"\\frac{1}{%s}%s%s\" % (sdenom, separator, snumer)\n             else:\n@@ -880,6 +971,7 @@ def _print_polar_lift(self, expr, exp=None):\n         else:\n             return r\"%s%s\" % (func, arg)\n \n+\n     def _print_ExpBase(self, expr, exp=None):\n         # TODO should exp_polar be printed differently?\n         #      what about exp_polar(0), exp_polar(1)?\n",
    "variant_8": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex 1edc712358..a212efb274 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -345,6 +345,7 @@ def _print_Float(self, expr):\n         else:\n             return str_real\n \n+\n     def _print_Mul(self, expr):\n         include_parens = False\n         if _coeff_isneg(expr):\n@@ -356,8 +357,70 @@ def _print_Mul(self, expr):\n         else:\n             tex = \"\"\n \n-        from sympy.simplify import fraction\n-        numer, denom = fraction(expr, exact=True)\n+        # Manual term processing to preserve structure like pretty printer\n+        a = []  # numerator terms\n+        b = []  # denominator terms\n+        \n+        if self.order not in ('old', 'none'):\n+            args = expr.as_ordered_factors()\n+        else:\n+            args = expr.args\n+            \n+        # Process each term to separate numerator/denominator while preserving structure\n+        for item in args:\n+            if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp.is_negative:\n+                if item.exp != -1:\n+                    b.append(item.base**(-item.exp))\n+                else:\n+                    b.append(item.base)\n+            elif item.is_Rational and item is not S.Infinity:\n+                if item.p != 1:\n+                    a.append(item.p)\n+                if item.q != 1:\n+                    b.append(item.q)\n+            else:\n+                a.append(item)\n+        \n+        # Create numerator and denominator expressions\n+        if not a:\n+            numer = S.One\n+        elif len(a) == 1:\n+            numer = a[0]\n+        else:\n+            numer = expr.func(*a)\n+            \n+        if not b:\n+            denom = S.One\n+        elif len(b) == 1:\n+            denom = b[0]\n+        else:\n+            denom = expr.func(*b)\n+            \n+        separator = self._settings['mul_symbol_latex']\n+        numbersep = self._settings['mul_symbol_latex_numbers']\n+\n+        def convert(expr):\n+            if not expr.is_Mul:\n+                return str(self._print(expr))\n+            else:\n+                _tex = last_term_tex = \"\"\n+\n+                if self.order not in ('old', 'none'):\n+                    args = expr.as_ordered_factors()\n+                else:\n+                    args = expr.args\n+                    b.append(item.base)\n+            elif item.is_Rational and item is not S.Infinity:\n+                if item.p != 1:\n+                    a.append(Rational(item.p))\n+                if item.q != 1:\n+                    b.append(Rational(item.q))\n+            else:\n+                a.append(item)\n+        \n+        a = a or [S.One]\n+        numer = Mul(*a, evaluate=False)\n+        denom = Mul(*b, evaluate=False) if b else S.One\n         separator = self._settings['mul_symbol_latex']\n         numbersep = self._settings['mul_symbol_latex_numbers']\n \n@@ -394,7 +457,32 @@ def convert(expr):\n             # use the original expression here, since fraction() may have\n             # altered it when producing numer and denom\n             tex += convert(expr)\n+\n         else:\n+            # Manual term processing to preserve expression structure\n+            # similar to pretty printer approach\n+            a = S.One\n+            b = S.One\n+            \n+            for item in expr.args:\n+                if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp < 0:\n+                    # Negative exponent goes to denominator\n+                    if item.exp == -1:\n+                        b *= item.base\n+                    else:\n+                        b *= item.base**(-item.exp)\n+                elif item.is_Rational and item < 0:\n+                    # Negative rational number\n+                    a *= -1\n+                    if item != -1:\n+                        b *= -item\n+                else:\n+                    # Everything else goes to numerator\n+                    a *= item\n+            \n+            numer = a\n+            denom = b\n+            \n             snumer = convert(numer)\n             sdenom = convert(denom)\n             ldenom = len(sdenom.split())\n@@ -432,6 +520,10 @@ def convert(expr):\n                     tex += r\"\\frac{1}{%s}%s%s\" % (sdenom, separator, snumer)\n             else:\n                 tex += r\"\\frac{%s}{%s}\" % (snumer, sdenom)\n+                else:\n+                    tex += r\"\\frac{1}{%s}%s%s\" % (sdenom, separator, snumer)\n+            else:\n+                tex += r\"\\frac{%s}{%s}\" % (snumer, sdenom)\n \n         if include_parens:\n             tex += \")\"\n@@ -880,6 +972,7 @@ def _print_polar_lift(self, expr, exp=None):\n         else:\n             return r\"%s%s\" % (func, arg)\n \n+\n     def _print_ExpBase(self, expr, exp=None):\n         # TODO should exp_polar be printed differently?\n         #      what about exp_polar(0), exp_polar(1)?\n"
  }
}