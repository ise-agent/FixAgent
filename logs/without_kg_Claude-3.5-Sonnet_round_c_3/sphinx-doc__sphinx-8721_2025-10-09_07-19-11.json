{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/sphinx/sphinx/ext/viewcode.py lines 181-185)": "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    highlighter = app.builder.highlighter  # type: ignore\n",
    "Location 2 (/root/hy/projects_3/sphinx/sphinx/ext/viewcode.py lines 59-60)": "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    if not env._viewcode_modules:  # type: ignore\n        return\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)  # type: ignore\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/sphinx/sphinx/ext/viewcode.py lines 181-185)": [
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    highlighter = app.builder.highlighter  # type: ignore\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    highlighter = app.builder.highlighter  # type: ignore\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    highlighter = app.builder.highlighter  # type: ignore\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    highlighter = app.builder.highlighter  # type: ignore\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    highlighter = app.builder.highlighter  # type: ignore\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    highlighter = app.builder.highlighter  # type: ignore\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    highlighter = app.builder.highlighter  # type: ignore\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    highlighter = app.builder.highlighter  # type: ignore\n"
    ],
    "Location 2 (/root/hy/projects_3/sphinx/sphinx/ext/viewcode.py lines 59-60)": [
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    if not env._viewcode_modules:  # type: ignore\n        return\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)  # type: ignore\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),  # type: ignore\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),  # type: ignore\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        code, tags, used, refname = entry\n        # construct a page name for the highlighted source\n        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        # highlight the source using the builder's highlighter\n        if env.config.highlight_language in ('python3', 'default', 'none'):\n            lexer = env.config.highlight_language\n        else:\n            lexer = 'python'\n        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n        # split the code into lines\n        lines = highlighted.splitlines()\n        # split off wrap markup from the first line of the actual code\n        before, after = lines[0].split('<pre>')\n        lines[0:1] = [before + '<pre>', after]\n        # nothing to do with the last line; it always starts with </pre> anyway\n        # now that we have code lines (starting at index 1), insert anchors for\n        # the collected tags (HACK: this only works if the tag boundaries are\n        # properly nested!)\n        max_index = len(lines) - 1\n        for name, docname in used.items():\n            type, start, end = tags[name]\n            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n            lines[start] = (\n                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n                lines[start])\n            lines[min(end, max_index)] += '</div>'\n        # try to find parents (for submodules)\n        parents = []\n        parent = modname\n        while '.' in parent:\n            parent = parent.rsplit('.', 1)[0]\n            if parent in modnames:\n                parents.append({\n                    'link': urito(pagename,\n                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n                    'title': parent})\n        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n                        'title': _('Module code')})\n        parents.reverse()\n        # putting it all together\n        context = {\n            'parents': parents,\n            'title': modname,\n            'body': (_('<h1>Source code for %s</h1>') % modname +\n                     '\\n'.join(lines)),\n        }\n        yield (pagename, context, 'page.html')\n\n    if not modnames:\n        return\n\n    html = ['\\n']\n    # the stack logic is needed for using nested lists for submodules\n    stack = ['']\n    for modname in sorted(modnames):\n        if modname.startswith(stack[-1]):\n            stack.append(modname + '.')\n            html.append('<ul>')\n        else:\n            stack.pop()\n            while not modname.startswith(stack[-1]):\n                stack.pop()\n                html.append('</ul>')\n            stack.append(modname + '.')\n            html.append('<ul>')\n\n        urlpath = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        html.append('<li><a href=\"%s\">%s</a></li>\\n' % (\n            urito(posixpath.join(OUTPUT_DIRNAME, 'index'), urlpath),\n            modname))\n    html.append('</ul>' * (len(stack) - 1))\n    context = {\n        'title': _('Overview: module code'),\n        'body': (_('<h1>All modules for which code is available</h1>') +\n                 ''.join(html)),\n    }\n\n    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    if not env._viewcode_modules:  # type: ignore\n        return\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)  # type: ignore\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    if not env._viewcode_modules:  # type: ignore\n        return\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    if not env._viewcode_modules:  # type: ignore\n        return\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)  # type: ignore\n\n    for modname in status_iterator(\n            modnames, __('highlighting module code... '), \"blue\",\n            len(modnames), app.verbosity, lambda x: x):\n        if not env._viewcode_modules[modname]:  # type: ignore\n            continue\n        code, tags, used, refname = env._viewcode_modules[modname]  # type: ignore\n        # construct a page name for the highlighted source\n        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        # highlight the source using the builder's highlighter\n        if env.config.highlight_language in ('python3', 'default', 'none'):\n            lexer = env.config.highlight_language\n        else:\n            lexer = 'python'\n        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n        # split the code into lines\n        lines = highlighted.splitlines()\n        # split off wrap markup from the first line of the actual code\n        before, after = lines[0].split('<pre>')\n        lines[0:1] = [before + '<pre>', after]\n        # nothing to do for the last line; it always starts with </pre> anyway\n        # now that we have code lines (starting at index 1), insert anchors for\n        # the collected tags (HACK: this only works if the tag boundaries are\n        # properly nested!)\n        max_index = len(lines) - 1\n        for name, docname in used.items():\n            type, start, end = tags[name]\n            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n            lines[start] = (\n                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n                lines[start])\n            lines[min(end, max_index)] += '</div>'\n        # try to find parents (for submodules)\n        parents = []\n        parent = modname\n        while '.' in parent:\n            parent = parent.rsplit('.', 1)[0]\n            if parent in modnames:\n                parents.append({\n                    'link': urito(pagename,\n                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n                    'title': parent})\n        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n                        'title': _('Module code')})\n        parents.reverse()\n        # putting it all together\n        context = {\n            'parents': parents,\n            'title': modname,\n            'body': (_('<h1>Source code for %s</h1>') % modname +\n                     '\\n'.join(lines)),\n        }\n        yield (pagename, context, 'page.html')\n\n    if not modnames:\n        return\n\n    html = ['\\n']\n    # the stack logic is needed for using nested lists for submodules\n    stack = ['']\n    for modname in sorted(modnames):\n        if not env._viewcode_modules[modname]:  # type: ignore\n            continue\n        parts = modname.split('.')\n        levels = len(parts)\n        # remove common parts of the module name on the stack\n        stack = stack[:levels]\n        stack.extend([''] * (levels - len(stack)))\n        level = levels\n        for p in parts:\n            if stack[level - 1]:\n                break\n            stack[level - 1] = p\n            level -= 1\n        # create a nested list of links\n        for i in range(levels):\n            level = levels - i - 1\n            if level < len(stack) - 1:\n                html.append('<ul>')\n            if level == 0:\n                link = urito(posixpath.join(OUTPUT_DIRNAME, 'index'),\n                             posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/')))\n                html.append('<li><a href=\"%s\">%s</a></li>\\n' % (link, modname))\n            else:\n                if level < len(stack) - 1:\n                    html.append('</ul>')\n\n    html.append('</ul>' * (len(stack) - 1))\n    context = {\n        'title': _('Overview: module code'),\n        'body': (_('<h1>All modules for which code is available</h1>') +\n                 ''.join(html)),\n    }\n\n    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    if not env._viewcode_modules:  # type: ignore\n        return\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)  # type: ignore\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),  # type: ignore\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),  # type: ignore\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        code, tags, used, refname = entry\n        # construct a page name for the highlighted source\n        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        # highlight the source using the builder's highlighter\n        if env.config.highlight_language in ('python3', 'default', 'none'):\n            lexer = env.config.highlight_language\n        else:\n            lexer = 'python'\n        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n        # split the code into lines\n        lines = highlighted.splitlines()\n        # split off wrap markup from the first line of the actual code\n        before, after = lines[0].split('<pre>')\n        lines[0:1] = [before + '<pre>', after]\n        # nothing to do for the last line; it always starts with </pre> anyway\n        # now that we have code lines (starting at index 1), insert anchors for\n        # the collected tags (HACK: this only works if the tag boundaries are\n        # properly nested!)\n        max_index = len(lines) - 1\n        for name, docname in used.items():\n            type, start, end = tags[name]\n            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n            lines[start] = (\n                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n                lines[start])\n            lines[min(end, max_index)] += '</div>'\n        # try to find parents (for submodules)\n        parents = []\n        parent = modname\n        while '.' in parent:\n            parent = parent.rsplit('.', 1)[0]\n            if parent in modnames:\n                parents.append({\n                    'link': urito(pagename,\n                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n                    'title': parent})\n        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n                        'title': _('Module code')})\n        parents.reverse()\n        # putting it all together\n        context = {\n            'parents': parents,\n            'title': modname,\n            'body': (_('<h1>Source code for %s</h1>') % modname +\n                     '\\n'.join(lines)),\n        }\n        yield (pagename, context, 'page.html')\n\n    if not modnames:\n        return\n\n    html = ['\\n']\n    # the stack logic is needed for using nested lists for submodules\n    stack = ['']\n    for modname in sorted(modnames):\n        if modname.startswith(stack[-1]):\n            stack.append(modname + '.')\n            html.append('<ul>')\n        else:\n            stack.pop()\n            while not modname.startswith(stack[-1]):\n                stack.pop()\n                html.append('</ul>')\n            stack.append(modname + '.')\n            html.append('<ul>')\n\n        link = urito(posixpath.join(OUTPUT_DIRNAME, 'index'),\n                     posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/')))\n        html.append('<li><a href=\"%s\">%s</a></li>\\n' % (link, modname))\n\n    html.append('</ul>' * (len(stack) - 1))\n    context = {\n        'title': _('Overview: module code'),\n        'body': (_('<h1>All modules for which code is available</h1>') +\n                 ''.join(html)),\n    }\n\n    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    if not env._viewcode_modules:  # type: ignore\n        return\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)  # type: ignore\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),  # type: ignore\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),  # type: ignore\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        code, tags, used, refname = entry\n        # construct a page name for the highlighted source\n        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        # highlight the source using the builder's highlighter\n        if env.config.highlight_language in ('python3', 'default', 'none'):\n            lexer = env.config.highlight_language\n        else:\n            lexer = 'python'\n        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n        # split the code into lines\n        lines = highlighted.splitlines()\n        # split off wrap markup from the first line of the actual code\n        before, after = lines[0].split('<pre>')\n        lines[0:1] = [before + '<pre>', after]\n        # nothing to do with the last line; it always starts with </pre> anyway\n        # now that we have code lines (starting at index 1), insert anchors for\n        # the collected tags (HACK: this only works if the tag boundaries are\n        # properly nested!)\n        maxindex = len(lines) - 1\n        for name, docname in used.items():\n            type, start, end = tags[name]\n            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n            lines[start] = (\n                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n                lines[start])\n            lines[min(end, maxindex)] += '</div>'\n        # try to find parents (for submodules)\n        parents = []\n        parent = modname\n        while '.' in parent:\n            parent = parent.rsplit('.', 1)[0]\n            if parent in modnames:\n                parents.append({\n                    'link': urito(pagename,\n                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n                    'title': parent})\n        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n                        'title': _('Module code')})\n        parents.reverse()\n        # putting it all together\n        context = {\n            'parents': parents,\n            'title': modname,\n            'body': (_('<h1>Source code for %s</h1>') % modname +\n                     '\\n'.join(lines)),\n        }\n        yield (pagename, context, 'page.html')\n\n    if not modnames:\n        return\n\n    html = ['\\n']\n    # the stack logic is needed for using nested lists for submodules\n    stack = ['']\n    for modname in sorted(modnames):\n        if modname.startswith(stack[-1]):\n            stack.append(modname + '.')\n            html.append('<ul>')\n        else:\n            stack.pop()\n            while not modname.startswith(stack[-1]):\n                stack.pop()\n                html.append('</ul>')\n            stack.append(modname + '.')\n            html.append('<ul>')\n\n        urlpath = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        html.append('<li><a href=\"%s\">%s</a></li>\\n' % (\n            urito(posixpath.join(OUTPUT_DIRNAME, 'index'), urlpath),\n            modname))\n    html.append('</ul>' * (len(stack) - 1))\n    context = {\n        'title': _('Overview: module code'),\n        'body': (_('<h1>All modules for which code is available</h1>') +\n                 ''.join(html)),\n    }\n\n    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    if not env._viewcode_modules:  # type: ignore\n        return\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)  # type: ignore\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),  # type: ignore\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),  # type: ignore\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        if not should_generate_module_page(app, modname):\n            continue\n\n        code, tags, used, refname = entry\n        # construct a page name for the highlighted source\n        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        # highlight the source using the builder's highlighter\n        if env.config.highlight_language in ('python3', 'default', 'none'):\n            lexer = env.config.highlight_language\n        else:\n            lexer = 'python'\n        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n        # split the code into lines\n        lines = highlighted.splitlines()\n        # split off wrap markup from the first line of the actual code\n        before, after = lines[0].split('<pre>')\n        lines[0:1] = [before + '<pre>', after]\n        # nothing to do for the last line; it always starts with </pre> anyway\n        # now that we have code lines (starting at index 1), insert anchors for\n        # the collected tags (HACK: this only works if the tag boundaries are\n        # properly nested!)\n        max_idx = len(lines) - 1\n        for name, docname in used.items():\n            type, start, end = tags[name]\n            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n            lines[start] = (\n                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n                lines[start])\n            lines[min(end, max_idx)] += '</div>'\n        # try to find parents (for submodules)\n        parents = []\n        parent = modname\n        while '.' in parent:\n            parent = parent.rsplit('.', 1)[0]\n            if parent in modnames:\n                parents.append({\n                    'link': urito(pagename,\n                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n                    'title': parent})\n        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n                        'title': _('Module code')})\n        parents.reverse()\n        # putting it all together\n        context = {\n            'parents': parents,\n            'title': modname,\n            'body': (_('<h1>Source code for %s</h1>') % modname +\n                     '\\n'.join(lines)),\n        }\n        yield (pagename, context, 'page.html')\n\n    if not modnames:\n        return\n\n    html = ['\\n']\n    # the stack logic is needed for using nested lists for submodules\n    stack = ['']\n    for modname in sorted(modnames):\n        if not should_generate_module_page(app, modname):\n            continue\n\n        parts = modname.split('.')\n        levels = len(parts)\n        for i in range(levels):\n            level = '.'.join(parts[:i + 1])\n            if level not in stack:\n                stack.append(level)\n                level_parts = level.split('.')\n                indent = 4 * (len(level_parts) - 1)\n                if should_generate_module_page(app, level):\n                    html.append('%s<li><a href=\"%s\">%s</a></li>\\n' % (\n                        ' ' * indent,\n                        urito('index', posixpath.join(OUTPUT_DIRNAME, level.replace('.', '/'))),\n                        level_parts[-1]))\n                else:\n                    html.append('%s<li>%s</li>\\n' % (\n                        ' ' * indent, level_parts[-1]))\n                    stack.append(level + '.<list>')\n                if i < levels - 1:\n                    html.append('%s<ul>\\n' % (' ' * (indent + 2)))\n                    stack.append(level + '.<list>')\n        if should_generate_module_page(app, modname):\n            html.append('%s<li><a href=\"%s\">%s</a></li>\\n' % (\n                ' ' * 4 * (levels - 1),\n                urito('index', posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))),\n                parts[-1]))\n\n    # Create closing tags for nested lists\n    while len(stack) > 1:\n        if stack[-1].endswith('.<list>'):\n            html.append('%s</ul>\\n' % (' ' * (4 * (len(stack) - 2))))\n        stack.pop()\n\n    context = {\n        'title': _('Overview: module code'),\n        'body': (_('<h1>All modules for which code is available</h1>') +\n                 ''.join(html)),\n    }\n\n    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    if not env._viewcode_modules:  # type: ignore\n        return\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)  # type: ignore\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),  # type: ignore\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),  # type: ignore\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        code, tags, used, refname = entry\n        # construct a page name for the highlighted source\n        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        # highlight the source using the builder's highlighter\n        if env.config.highlight_language in ('python3', 'default', 'none'):\n            lexer = env.config.highlight_language\n        else:\n            lexer = 'python'\n        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n        # split the code into lines\n        lines = highlighted.splitlines()\n        # split off wrap markup from the first line of the actual code\n        before, after = lines[0].split('<pre>')\n        lines[0:1] = [before + '<pre>', after]\n        # nothing to do for the last line; it always starts with </pre> anyway\n        # now that we have code lines (starting at index 1), insert anchors for\n        # the collected tags (HACK: this only works if the tag boundaries are\n        # properly nested!)\n        max_index = len(lines) - 1\n        for name, docname in used.items():\n            type, start, end = tags[name]\n            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n            lines[start] = (\n                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n                lines[start])\n            lines[min(end, max_index)] += '</div>'\n        # try to find parents (for submodules)\n        parents = []\n        parent = modname\n        while '.' in parent:\n            parent = parent.rsplit('.', 1)[0]\n            if parent in modnames:\n                parents.append({\n                    'link': urito(pagename,\n                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n                    'title': parent})\n        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n                        'title': _('Module code')})\n        parents.reverse()\n        # putting it all together\n        context = {\n            'parents': parents,\n            'title': modname,\n            'body': (_('<h1>Source code for %s</h1>') % modname +\n                     '\\n'.join(lines)),\n        }\n        yield (pagename, context, 'page.html')\n\n    if not modnames:\n        return\n\n    html = ['\\n']\n    # the stack logic is needed for using nested lists for submodules\n    stack = ['']\n    for modname in sorted(modnames):\n        if modname.startswith(stack[-1]):\n            stack.append(modname + '.')\n            html.append('<ul>')\n        else:\n            stack.pop()\n            while not modname.startswith(stack[-1]):\n                stack.pop()\n                html.append('</ul>')\n            stack.append(modname + '.')\n            html.append('<ul>')\n\n        urlpath = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        html.append('<li><a href=\"%s\">%s</a></li>\\n' % (\n            urito(posixpath.join(OUTPUT_DIRNAME, 'index'), urlpath),\n            modname))\n    html.append('</ul>' * (len(stack) - 1))\n    context = {\n        'title': _('Overview: module code'),\n        'body': (_('<h1>All modules for which code is available</h1>') +\n                 ''.join(html)),\n    }\n\n    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sphinx/ext/viewcode.py b/sphinx/ext/viewcode.py\nindex a7d52a91c..6caeb2f96 100644\n--- a/sphinx/ext/viewcode.py\n+++ b/sphinx/ext/viewcode.py\n@@ -56,6 +56,7 @@ def doctree_read(app: Sphinx, doctree: Node) -> None:\n         env._viewcode_modules = {}  # type: ignore\n     if app.builder.name == \"singlehtml\":\n         return\n+\n     if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n         return\n \n@@ -178,10 +179,13 @@ def should_generate_module_page(app: Sphinx, modname: str) -> bool:\n     return True\n \n \n+\n def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n     env = app.builder.env\n     if not hasattr(env, '_viewcode_modules'):\n         return\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n     highlighter = app.builder.highlighter  # type: ignore\n     urito = app.builder.get_relative_uri\n \n",
    "variant_0": "diff --git a/sphinx/ext/viewcode.py b/sphinx/ext/viewcode.py\nindex a7d52a91c..c1c349758 100644\n--- a/sphinx/ext/viewcode.py\n+++ b/sphinx/ext/viewcode.py\n@@ -56,8 +56,19 @@ def doctree_read(app: Sphinx, doctree: Node) -> None:\n         env._viewcode_modules = {}  # type: ignore\n     if app.builder.name == \"singlehtml\":\n         return\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.builder.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n     if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n         return\n+    if not env._viewcode_modules:  # type: ignore\n+        return\n+    highlighter = app.builder.highlighter  # type: ignore\n+    urito = app.builder.get_relative_uri\n+\n+    modnames = set(env._viewcode_modules)  # type: ignore\n \n     def has_tag(modname: str, fullname: str, docname: str, refname: str) -> bool:\n         entry = env._viewcode_modules.get(modname, None)  # type: ignore\n@@ -178,10 +189,13 @@ def should_generate_module_page(app: Sphinx, modname: str) -> bool:\n     return True\n \n \n+\n def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n     env = app.builder.env\n     if not hasattr(env, '_viewcode_modules'):\n         return\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n     highlighter = app.builder.highlighter  # type: ignore\n     urito = app.builder.get_relative_uri\n \n",
    "variant_1": "diff --git a/sphinx/ext/viewcode.py b/sphinx/ext/viewcode.py\nindex a7d52a91c..91a9a2dba 100644\n--- a/sphinx/ext/viewcode.py\n+++ b/sphinx/ext/viewcode.py\n@@ -56,8 +56,106 @@ def doctree_read(app: Sphinx, doctree: Node) -> None:\n         env._viewcode_modules = {}  # type: ignore\n     if app.builder.name == \"singlehtml\":\n         return\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.builder.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n     if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n         return\n+    if not env._viewcode_modules:  # type: ignore\n+        return\n+    highlighter = app.builder.highlighter  # type: ignore\n+    urito = app.builder.get_relative_uri\n+\n+    modnames = set(env._viewcode_modules)  # type: ignore\n+\n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),  # type: ignore\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),  # type: ignore\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+        code, tags, used, refname = entry\n+        # construct a page name for the highlighted source\n+        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        # highlight the source using the builder's highlighter\n+        if env.config.highlight_language in ('python3', 'default', 'none'):\n+            lexer = env.config.highlight_language\n+        else:\n+            lexer = 'python'\n+        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n+        # split the code into lines\n+        lines = highlighted.splitlines()\n+        # split off wrap markup from the first line of the actual code\n+        before, after = lines[0].split('<pre>')\n+        lines[0:1] = [before + '<pre>', after]\n+        # nothing to do with the last line; it always starts with </pre> anyway\n+        # now that we have code lines (starting at index 1), insert anchors for\n+        # the collected tags (HACK: this only works if the tag boundaries are\n+        # properly nested!)\n+        max_index = len(lines) - 1\n+        for name, docname in used.items():\n+            type, start, end = tags[name]\n+            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n+            lines[start] = (\n+                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n+                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n+                lines[start])\n+            lines[min(end, max_index)] += '</div>'\n+        # try to find parents (for submodules)\n+        parents = []\n+        parent = modname\n+        while '.' in parent:\n+            parent = parent.rsplit('.', 1)[0]\n+            if parent in modnames:\n+                parents.append({\n+                    'link': urito(pagename,\n+                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n+                    'title': parent})\n+        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n+                        'title': _('Module code')})\n+        parents.reverse()\n+        # putting it all together\n+        context = {\n+            'parents': parents,\n+            'title': modname,\n+            'body': (_('<h1>Source code for %s</h1>') % modname +\n+                     '\\n'.join(lines)),\n+        }\n+        yield (pagename, context, 'page.html')\n+\n+    if not modnames:\n+        return\n+\n+    html = ['\\n']\n+    # the stack logic is needed for using nested lists for submodules\n+    stack = ['']\n+    for modname in sorted(modnames):\n+        if modname.startswith(stack[-1]):\n+            stack.append(modname + '.')\n+            html.append('<ul>')\n+        else:\n+            stack.pop()\n+            while not modname.startswith(stack[-1]):\n+                stack.pop()\n+                html.append('</ul>')\n+            stack.append(modname + '.')\n+            html.append('<ul>')\n+\n+        urlpath = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        html.append('<li><a href=\"%s\">%s</a></li>\\n' % (\n+            urito(posixpath.join(OUTPUT_DIRNAME, 'index'), urlpath),\n+            modname))\n+    html.append('</ul>' * (len(stack) - 1))\n+    context = {\n+        'title': _('Overview: module code'),\n+        'body': (_('<h1>All modules for which code is available</h1>') +\n+                 ''.join(html)),\n+    }\n+\n+    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n \n     def has_tag(modname: str, fullname: str, docname: str, refname: str) -> bool:\n         entry = env._viewcode_modules.get(modname, None)  # type: ignore\n@@ -178,10 +276,13 @@ def should_generate_module_page(app: Sphinx, modname: str) -> bool:\n     return True\n \n \n+\n def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n     env = app.builder.env\n     if not hasattr(env, '_viewcode_modules'):\n         return\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n     highlighter = app.builder.highlighter  # type: ignore\n     urito = app.builder.get_relative_uri\n \n",
    "variant_2": "diff --git a/sphinx/ext/viewcode.py b/sphinx/ext/viewcode.py\nindex a7d52a91c..c1c349758 100644\n--- a/sphinx/ext/viewcode.py\n+++ b/sphinx/ext/viewcode.py\n@@ -56,8 +56,19 @@ def doctree_read(app: Sphinx, doctree: Node) -> None:\n         env._viewcode_modules = {}  # type: ignore\n     if app.builder.name == \"singlehtml\":\n         return\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.builder.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n     if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n         return\n+    if not env._viewcode_modules:  # type: ignore\n+        return\n+    highlighter = app.builder.highlighter  # type: ignore\n+    urito = app.builder.get_relative_uri\n+\n+    modnames = set(env._viewcode_modules)  # type: ignore\n \n     def has_tag(modname: str, fullname: str, docname: str, refname: str) -> bool:\n         entry = env._viewcode_modules.get(modname, None)  # type: ignore\n@@ -178,10 +189,13 @@ def should_generate_module_page(app: Sphinx, modname: str) -> bool:\n     return True\n \n \n+\n def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n     env = app.builder.env\n     if not hasattr(env, '_viewcode_modules'):\n         return\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n     highlighter = app.builder.highlighter  # type: ignore\n     urito = app.builder.get_relative_uri\n \n",
    "variant_3": "diff --git a/sphinx/ext/viewcode.py b/sphinx/ext/viewcode.py\nindex a7d52a91c..a11b00fc3 100644\n--- a/sphinx/ext/viewcode.py\n+++ b/sphinx/ext/viewcode.py\n@@ -56,8 +56,17 @@ def doctree_read(app: Sphinx, doctree: Node) -> None:\n         env._viewcode_modules = {}  # type: ignore\n     if app.builder.name == \"singlehtml\":\n         return\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.builder.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n     if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n         return\n+    if not env._viewcode_modules:  # type: ignore\n+        return\n+    highlighter = app.builder.highlighter  # type: ignore\n+    urito = app.builder.get_relative_uri\n \n     def has_tag(modname: str, fullname: str, docname: str, refname: str) -> bool:\n         entry = env._viewcode_modules.get(modname, None)  # type: ignore\n@@ -178,10 +187,13 @@ def should_generate_module_page(app: Sphinx, modname: str) -> bool:\n     return True\n \n \n+\n def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n     env = app.builder.env\n     if not hasattr(env, '_viewcode_modules'):\n         return\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n     highlighter = app.builder.highlighter  # type: ignore\n     urito = app.builder.get_relative_uri\n \n",
    "variant_4": "diff --git a/sphinx/ext/viewcode.py b/sphinx/ext/viewcode.py\nindex a7d52a91c..c15fd3a29 100644\n--- a/sphinx/ext/viewcode.py\n+++ b/sphinx/ext/viewcode.py\n@@ -56,8 +56,115 @@ def doctree_read(app: Sphinx, doctree: Node) -> None:\n         env._viewcode_modules = {}  # type: ignore\n     if app.builder.name == \"singlehtml\":\n         return\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.builder.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n     if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n         return\n+    if not env._viewcode_modules:  # type: ignore\n+        return\n+    highlighter = app.builder.highlighter  # type: ignore\n+    urito = app.builder.get_relative_uri\n+\n+    modnames = set(env._viewcode_modules)  # type: ignore\n+\n+    for modname in status_iterator(\n+            modnames, __('highlighting module code... '), \"blue\",\n+            len(modnames), app.verbosity, lambda x: x):\n+        if not env._viewcode_modules[modname]:  # type: ignore\n+            continue\n+        code, tags, used, refname = env._viewcode_modules[modname]  # type: ignore\n+        # construct a page name for the highlighted source\n+        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        # highlight the source using the builder's highlighter\n+        if env.config.highlight_language in ('python3', 'default', 'none'):\n+            lexer = env.config.highlight_language\n+        else:\n+            lexer = 'python'\n+        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n+        # split the code into lines\n+        lines = highlighted.splitlines()\n+        # split off wrap markup from the first line of the actual code\n+        before, after = lines[0].split('<pre>')\n+        lines[0:1] = [before + '<pre>', after]\n+        # nothing to do for the last line; it always starts with </pre> anyway\n+        # now that we have code lines (starting at index 1), insert anchors for\n+        # the collected tags (HACK: this only works if the tag boundaries are\n+        # properly nested!)\n+        max_index = len(lines) - 1\n+        for name, docname in used.items():\n+            type, start, end = tags[name]\n+            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n+            lines[start] = (\n+                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n+                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n+                lines[start])\n+            lines[min(end, max_index)] += '</div>'\n+        # try to find parents (for submodules)\n+        parents = []\n+        parent = modname\n+        while '.' in parent:\n+            parent = parent.rsplit('.', 1)[0]\n+            if parent in modnames:\n+                parents.append({\n+                    'link': urito(pagename,\n+                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n+                    'title': parent})\n+        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n+                        'title': _('Module code')})\n+        parents.reverse()\n+        # putting it all together\n+        context = {\n+            'parents': parents,\n+            'title': modname,\n+            'body': (_('<h1>Source code for %s</h1>') % modname +\n+                     '\\n'.join(lines)),\n+        }\n+        yield (pagename, context, 'page.html')\n+\n+    if not modnames:\n+        return\n+\n+    html = ['\\n']\n+    # the stack logic is needed for using nested lists for submodules\n+    stack = ['']\n+    for modname in sorted(modnames):\n+        if not env._viewcode_modules[modname]:  # type: ignore\n+            continue\n+        parts = modname.split('.')\n+        levels = len(parts)\n+        # remove common parts of the module name on the stack\n+        stack = stack[:levels]\n+        stack.extend([''] * (levels - len(stack)))\n+        level = levels\n+        for p in parts:\n+            if stack[level - 1]:\n+                break\n+            stack[level - 1] = p\n+            level -= 1\n+        # create a nested list of links\n+        for i in range(levels):\n+            level = levels - i - 1\n+            if level < len(stack) - 1:\n+                html.append('<ul>')\n+            if level == 0:\n+                link = urito(posixpath.join(OUTPUT_DIRNAME, 'index'),\n+                             posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/')))\n+                html.append('<li><a href=\"%s\">%s</a></li>\\n' % (link, modname))\n+            else:\n+                if level < len(stack) - 1:\n+                    html.append('</ul>')\n+\n+    html.append('</ul>' * (len(stack) - 1))\n+    context = {\n+        'title': _('Overview: module code'),\n+        'body': (_('<h1>All modules for which code is available</h1>') +\n+                 ''.join(html)),\n+    }\n+\n+    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n \n     def has_tag(modname: str, fullname: str, docname: str, refname: str) -> bool:\n         entry = env._viewcode_modules.get(modname, None)  # type: ignore\n@@ -178,10 +285,13 @@ def should_generate_module_page(app: Sphinx, modname: str) -> bool:\n     return True\n \n \n+\n def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n     env = app.builder.env\n     if not hasattr(env, '_viewcode_modules'):\n         return\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n     highlighter = app.builder.highlighter  # type: ignore\n     urito = app.builder.get_relative_uri\n \n",
    "variant_5": "diff --git a/sphinx/ext/viewcode.py b/sphinx/ext/viewcode.py\nindex a7d52a91c..6ce983909 100644\n--- a/sphinx/ext/viewcode.py\n+++ b/sphinx/ext/viewcode.py\n@@ -56,8 +56,106 @@ def doctree_read(app: Sphinx, doctree: Node) -> None:\n         env._viewcode_modules = {}  # type: ignore\n     if app.builder.name == \"singlehtml\":\n         return\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.builder.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n     if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n         return\n+    if not env._viewcode_modules:  # type: ignore\n+        return\n+    highlighter = app.builder.highlighter  # type: ignore\n+    urito = app.builder.get_relative_uri\n+\n+    modnames = set(env._viewcode_modules)  # type: ignore\n+\n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),  # type: ignore\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),  # type: ignore\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+        code, tags, used, refname = entry\n+        # construct a page name for the highlighted source\n+        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        # highlight the source using the builder's highlighter\n+        if env.config.highlight_language in ('python3', 'default', 'none'):\n+            lexer = env.config.highlight_language\n+        else:\n+            lexer = 'python'\n+        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n+        # split the code into lines\n+        lines = highlighted.splitlines()\n+        # split off wrap markup from the first line of the actual code\n+        before, after = lines[0].split('<pre>')\n+        lines[0:1] = [before + '<pre>', after]\n+        # nothing to do for the last line; it always starts with </pre> anyway\n+        # now that we have code lines (starting at index 1), insert anchors for\n+        # the collected tags (HACK: this only works if the tag boundaries are\n+        # properly nested!)\n+        max_index = len(lines) - 1\n+        for name, docname in used.items():\n+            type, start, end = tags[name]\n+            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n+            lines[start] = (\n+                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n+                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n+                lines[start])\n+            lines[min(end, max_index)] += '</div>'\n+        # try to find parents (for submodules)\n+        parents = []\n+        parent = modname\n+        while '.' in parent:\n+            parent = parent.rsplit('.', 1)[0]\n+            if parent in modnames:\n+                parents.append({\n+                    'link': urito(pagename,\n+                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n+                    'title': parent})\n+        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n+                        'title': _('Module code')})\n+        parents.reverse()\n+        # putting it all together\n+        context = {\n+            'parents': parents,\n+            'title': modname,\n+            'body': (_('<h1>Source code for %s</h1>') % modname +\n+                     '\\n'.join(lines)),\n+        }\n+        yield (pagename, context, 'page.html')\n+\n+    if not modnames:\n+        return\n+\n+    html = ['\\n']\n+    # the stack logic is needed for using nested lists for submodules\n+    stack = ['']\n+    for modname in sorted(modnames):\n+        if modname.startswith(stack[-1]):\n+            stack.append(modname + '.')\n+            html.append('<ul>')\n+        else:\n+            stack.pop()\n+            while not modname.startswith(stack[-1]):\n+                stack.pop()\n+                html.append('</ul>')\n+            stack.append(modname + '.')\n+            html.append('<ul>')\n+\n+        link = urito(posixpath.join(OUTPUT_DIRNAME, 'index'),\n+                     posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/')))\n+        html.append('<li><a href=\"%s\">%s</a></li>\\n' % (link, modname))\n+\n+    html.append('</ul>' * (len(stack) - 1))\n+    context = {\n+        'title': _('Overview: module code'),\n+        'body': (_('<h1>All modules for which code is available</h1>') +\n+                 ''.join(html)),\n+    }\n+\n+    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n \n     def has_tag(modname: str, fullname: str, docname: str, refname: str) -> bool:\n         entry = env._viewcode_modules.get(modname, None)  # type: ignore\n@@ -178,10 +276,13 @@ def should_generate_module_page(app: Sphinx, modname: str) -> bool:\n     return True\n \n \n+\n def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n     env = app.builder.env\n     if not hasattr(env, '_viewcode_modules'):\n         return\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n     highlighter = app.builder.highlighter  # type: ignore\n     urito = app.builder.get_relative_uri\n \n",
    "variant_6": "diff --git a/sphinx/ext/viewcode.py b/sphinx/ext/viewcode.py\nindex a7d52a91c..4ec5c5f8f 100644\n--- a/sphinx/ext/viewcode.py\n+++ b/sphinx/ext/viewcode.py\n@@ -56,8 +56,106 @@ def doctree_read(app: Sphinx, doctree: Node) -> None:\n         env._viewcode_modules = {}  # type: ignore\n     if app.builder.name == \"singlehtml\":\n         return\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.builder.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n     if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n         return\n+    if not env._viewcode_modules:  # type: ignore\n+        return\n+    highlighter = app.builder.highlighter  # type: ignore\n+    urito = app.builder.get_relative_uri\n+\n+    modnames = set(env._viewcode_modules)  # type: ignore\n+\n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),  # type: ignore\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),  # type: ignore\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+        code, tags, used, refname = entry\n+        # construct a page name for the highlighted source\n+        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        # highlight the source using the builder's highlighter\n+        if env.config.highlight_language in ('python3', 'default', 'none'):\n+            lexer = env.config.highlight_language\n+        else:\n+            lexer = 'python'\n+        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n+        # split the code into lines\n+        lines = highlighted.splitlines()\n+        # split off wrap markup from the first line of the actual code\n+        before, after = lines[0].split('<pre>')\n+        lines[0:1] = [before + '<pre>', after]\n+        # nothing to do with the last line; it always starts with </pre> anyway\n+        # now that we have code lines (starting at index 1), insert anchors for\n+        # the collected tags (HACK: this only works if the tag boundaries are\n+        # properly nested!)\n+        maxindex = len(lines) - 1\n+        for name, docname in used.items():\n+            type, start, end = tags[name]\n+            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n+            lines[start] = (\n+                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n+                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n+                lines[start])\n+            lines[min(end, maxindex)] += '</div>'\n+        # try to find parents (for submodules)\n+        parents = []\n+        parent = modname\n+        while '.' in parent:\n+            parent = parent.rsplit('.', 1)[0]\n+            if parent in modnames:\n+                parents.append({\n+                    'link': urito(pagename,\n+                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n+                    'title': parent})\n+        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n+                        'title': _('Module code')})\n+        parents.reverse()\n+        # putting it all together\n+        context = {\n+            'parents': parents,\n+            'title': modname,\n+            'body': (_('<h1>Source code for %s</h1>') % modname +\n+                     '\\n'.join(lines)),\n+        }\n+        yield (pagename, context, 'page.html')\n+\n+    if not modnames:\n+        return\n+\n+    html = ['\\n']\n+    # the stack logic is needed for using nested lists for submodules\n+    stack = ['']\n+    for modname in sorted(modnames):\n+        if modname.startswith(stack[-1]):\n+            stack.append(modname + '.')\n+            html.append('<ul>')\n+        else:\n+            stack.pop()\n+            while not modname.startswith(stack[-1]):\n+                stack.pop()\n+                html.append('</ul>')\n+            stack.append(modname + '.')\n+            html.append('<ul>')\n+\n+        urlpath = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        html.append('<li><a href=\"%s\">%s</a></li>\\n' % (\n+            urito(posixpath.join(OUTPUT_DIRNAME, 'index'), urlpath),\n+            modname))\n+    html.append('</ul>' * (len(stack) - 1))\n+    context = {\n+        'title': _('Overview: module code'),\n+        'body': (_('<h1>All modules for which code is available</h1>') +\n+                 ''.join(html)),\n+    }\n+\n+    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n \n     def has_tag(modname: str, fullname: str, docname: str, refname: str) -> bool:\n         entry = env._viewcode_modules.get(modname, None)  # type: ignore\n@@ -178,10 +276,13 @@ def should_generate_module_page(app: Sphinx, modname: str) -> bool:\n     return True\n \n \n+\n def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n     env = app.builder.env\n     if not hasattr(env, '_viewcode_modules'):\n         return\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n     highlighter = app.builder.highlighter  # type: ignore\n     urito = app.builder.get_relative_uri\n \n",
    "variant_7": "diff --git a/sphinx/ext/viewcode.py b/sphinx/ext/viewcode.py\nindex a7d52a91c..d8d6018e1 100644\n--- a/sphinx/ext/viewcode.py\n+++ b/sphinx/ext/viewcode.py\n@@ -56,8 +56,128 @@ def doctree_read(app: Sphinx, doctree: Node) -> None:\n         env._viewcode_modules = {}  # type: ignore\n     if app.builder.name == \"singlehtml\":\n         return\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.builder.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n     if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n         return\n+    if not env._viewcode_modules:  # type: ignore\n+        return\n+    highlighter = app.builder.highlighter  # type: ignore\n+    urito = app.builder.get_relative_uri\n+\n+    modnames = set(env._viewcode_modules)  # type: ignore\n+\n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),  # type: ignore\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),  # type: ignore\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+        if not should_generate_module_page(app, modname):\n+            continue\n+\n+        code, tags, used, refname = entry\n+        # construct a page name for the highlighted source\n+        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        # highlight the source using the builder's highlighter\n+        if env.config.highlight_language in ('python3', 'default', 'none'):\n+            lexer = env.config.highlight_language\n+        else:\n+            lexer = 'python'\n+        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n+        # split the code into lines\n+        lines = highlighted.splitlines()\n+        # split off wrap markup from the first line of the actual code\n+        before, after = lines[0].split('<pre>')\n+        lines[0:1] = [before + '<pre>', after]\n+        # nothing to do for the last line; it always starts with </pre> anyway\n+        # now that we have code lines (starting at index 1), insert anchors for\n+        # the collected tags (HACK: this only works if the tag boundaries are\n+        # properly nested!)\n+        max_idx = len(lines) - 1\n+        for name, docname in used.items():\n+            type, start, end = tags[name]\n+            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n+            lines[start] = (\n+                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n+                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n+                lines[start])\n+            lines[min(end, max_idx)] += '</div>'\n+        # try to find parents (for submodules)\n+        parents = []\n+        parent = modname\n+        while '.' in parent:\n+            parent = parent.rsplit('.', 1)[0]\n+            if parent in modnames:\n+                parents.append({\n+                    'link': urito(pagename,\n+                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n+                    'title': parent})\n+        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n+                        'title': _('Module code')})\n+        parents.reverse()\n+        # putting it all together\n+        context = {\n+            'parents': parents,\n+            'title': modname,\n+            'body': (_('<h1>Source code for %s</h1>') % modname +\n+                     '\\n'.join(lines)),\n+        }\n+        yield (pagename, context, 'page.html')\n+\n+    if not modnames:\n+        return\n+\n+    html = ['\\n']\n+    # the stack logic is needed for using nested lists for submodules\n+    stack = ['']\n+    for modname in sorted(modnames):\n+        if not should_generate_module_page(app, modname):\n+            continue\n+\n+        parts = modname.split('.')\n+        levels = len(parts)\n+        for i in range(levels):\n+            level = '.'.join(parts[:i + 1])\n+            if level not in stack:\n+                stack.append(level)\n+                level_parts = level.split('.')\n+                indent = 4 * (len(level_parts) - 1)\n+                if should_generate_module_page(app, level):\n+                    html.append('%s<li><a href=\"%s\">%s</a></li>\\n' % (\n+                        ' ' * indent,\n+                        urito('index', posixpath.join(OUTPUT_DIRNAME, level.replace('.', '/'))),\n+                        level_parts[-1]))\n+                else:\n+                    html.append('%s<li>%s</li>\\n' % (\n+                        ' ' * indent, level_parts[-1]))\n+                    stack.append(level + '.<list>')\n+                if i < levels - 1:\n+                    html.append('%s<ul>\\n' % (' ' * (indent + 2)))\n+                    stack.append(level + '.<list>')\n+        if should_generate_module_page(app, modname):\n+            html.append('%s<li><a href=\"%s\">%s</a></li>\\n' % (\n+                ' ' * 4 * (levels - 1),\n+                urito('index', posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))),\n+                parts[-1]))\n+\n+    # Create closing tags for nested lists\n+    while len(stack) > 1:\n+        if stack[-1].endswith('.<list>'):\n+            html.append('%s</ul>\\n' % (' ' * (4 * (len(stack) - 2))))\n+        stack.pop()\n+\n+    context = {\n+        'title': _('Overview: module code'),\n+        'body': (_('<h1>All modules for which code is available</h1>') +\n+                 ''.join(html)),\n+    }\n+\n+    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n \n     def has_tag(modname: str, fullname: str, docname: str, refname: str) -> bool:\n         entry = env._viewcode_modules.get(modname, None)  # type: ignore\n@@ -178,10 +298,13 @@ def should_generate_module_page(app: Sphinx, modname: str) -> bool:\n     return True\n \n \n+\n def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n     env = app.builder.env\n     if not hasattr(env, '_viewcode_modules'):\n         return\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n     highlighter = app.builder.highlighter  # type: ignore\n     urito = app.builder.get_relative_uri\n \n",
    "variant_8": "diff --git a/sphinx/ext/viewcode.py b/sphinx/ext/viewcode.py\nindex a7d52a91c..d79873bb1 100644\n--- a/sphinx/ext/viewcode.py\n+++ b/sphinx/ext/viewcode.py\n@@ -56,8 +56,106 @@ def doctree_read(app: Sphinx, doctree: Node) -> None:\n         env._viewcode_modules = {}  # type: ignore\n     if app.builder.name == \"singlehtml\":\n         return\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.builder.env\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n     if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n         return\n+    if not env._viewcode_modules:  # type: ignore\n+        return\n+    highlighter = app.builder.highlighter  # type: ignore\n+    urito = app.builder.get_relative_uri\n+\n+    modnames = set(env._viewcode_modules)  # type: ignore\n+\n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),  # type: ignore\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),  # type: ignore\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+        code, tags, used, refname = entry\n+        # construct a page name for the highlighted source\n+        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        # highlight the source using the builder's highlighter\n+        if env.config.highlight_language in ('python3', 'default', 'none'):\n+            lexer = env.config.highlight_language\n+        else:\n+            lexer = 'python'\n+        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n+        # split the code into lines\n+        lines = highlighted.splitlines()\n+        # split off wrap markup from the first line of the actual code\n+        before, after = lines[0].split('<pre>')\n+        lines[0:1] = [before + '<pre>', after]\n+        # nothing to do for the last line; it always starts with </pre> anyway\n+        # now that we have code lines (starting at index 1), insert anchors for\n+        # the collected tags (HACK: this only works if the tag boundaries are\n+        # properly nested!)\n+        max_index = len(lines) - 1\n+        for name, docname in used.items():\n+            type, start, end = tags[name]\n+            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n+            lines[start] = (\n+                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n+                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n+                lines[start])\n+            lines[min(end, max_index)] += '</div>'\n+        # try to find parents (for submodules)\n+        parents = []\n+        parent = modname\n+        while '.' in parent:\n+            parent = parent.rsplit('.', 1)[0]\n+            if parent in modnames:\n+                parents.append({\n+                    'link': urito(pagename,\n+                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n+                    'title': parent})\n+        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n+                        'title': _('Module code')})\n+        parents.reverse()\n+        # putting it all together\n+        context = {\n+            'parents': parents,\n+            'title': modname,\n+            'body': (_('<h1>Source code for %s</h1>') % modname +\n+                     '\\n'.join(lines)),\n+        }\n+        yield (pagename, context, 'page.html')\n+\n+    if not modnames:\n+        return\n+\n+    html = ['\\n']\n+    # the stack logic is needed for using nested lists for submodules\n+    stack = ['']\n+    for modname in sorted(modnames):\n+        if modname.startswith(stack[-1]):\n+            stack.append(modname + '.')\n+            html.append('<ul>')\n+        else:\n+            stack.pop()\n+            while not modname.startswith(stack[-1]):\n+                stack.pop()\n+                html.append('</ul>')\n+            stack.append(modname + '.')\n+            html.append('<ul>')\n+\n+        urlpath = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        html.append('<li><a href=\"%s\">%s</a></li>\\n' % (\n+            urito(posixpath.join(OUTPUT_DIRNAME, 'index'), urlpath),\n+            modname))\n+    html.append('</ul>' * (len(stack) - 1))\n+    context = {\n+        'title': _('Overview: module code'),\n+        'body': (_('<h1>All modules for which code is available</h1>') +\n+                 ''.join(html)),\n+    }\n+\n+    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n \n     def has_tag(modname: str, fullname: str, docname: str, refname: str) -> bool:\n         entry = env._viewcode_modules.get(modname, None)  # type: ignore\n@@ -178,10 +276,13 @@ def should_generate_module_page(app: Sphinx, modname: str) -> bool:\n     return True\n \n \n+\n def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n     env = app.builder.env\n     if not hasattr(env, '_viewcode_modules'):\n         return\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n     highlighter = app.builder.highlighter  # type: ignore\n     urito = app.builder.get_relative_uri\n \n"
  }
}