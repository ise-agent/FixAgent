{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/matplotlib/lib/mpl_toolkits/mplot3d/art3d.py lines 221-225)": "\ndef line_2d_to_3d(line, zs=0, zdir='z'):\n    \"\"\"Convert a 2D line to 3D.\"\"\"\n    line.__class__ = Line3D\n    # Ensure _verts3d is always initialized as a safety measure\n    # This prevents AttributeError if set_3d_properties fails\n    if not hasattr(line, '_verts3d'):\n        line._verts3d = ([], [], [])\n    line.set_3d_properties(zs, zdir)\n",
    "Location 2 (/root/hy/projects_3/matplotlib/lib/mpl_toolkits/mplot3d/art3d.py lines 214-214)": "\ndef line_2d_to_3d(line, zs=0, zdir='z'):\n    \"\"\"Convert a 2D line to 3D.\"\"\"\n    line.__class__ = Line3D\n    # Ensure _verts3d is always initialized as a safety measure\n    # This prevents AttributeError if set_3d_properties fails\n    if not hasattr(line, '_verts3d'):\n        line._verts3d = ([], [], [])\n    line.set_3d_properties(zs, zdir)\n",
    "Location 3 (/root/hy/projects_3/matplotlib/lib/mpl_toolkits/mplot3d/art3d.py lines 174-176)": "\ndef set_3d_properties(self, zs=0, zdir='z'):\n    # Ensure _verts3d exists before any operations\n    if not hasattr(self, '_verts3d'):\n        self._verts3d = ([], [], [])\n    \n    xs = self.get_xdata()\n    ys = self.get_ydata()\n    try:\n        zs = np.broadcast_to(zs, len(xs))\n        self._verts3d = juggle_axes(xs, ys, zs, zdir)\n        self.stale = True\n    except Exception:\n        # If coordinate processing fails, maintain a valid but empty state\n        if not hasattr(self, '_verts3d') or self._verts3d is None:\n            self._verts3d = ([], [], [])\n        raise  # Re-raise the original exception\n",
    "Location 4 (/root/hy/projects_3/matplotlib/lib/mpl_toolkits/mplot3d/art3d.py lines 196-198)": "\ndef set_data_3d(self, *args):\n    \"\"\"\n    Set the x, y and z data\n\n    Parameters\n    ----------\n    x : array-like\n        The x-data to be plotted.\n    y : array-like\n        The y-data to be plotted.\n    z : array-like\n        The z-data to be plotted.\n\n    Notes\n    -----\n    Accepts x, y, z arguments or a single array-like (x, y, z)\n    \"\"\"\n    # Validate input dimensions before processing\n    for i, arg in enumerate(args):\n        if hasattr(arg, 'ndim') and arg.ndim > 1:\n            raise ValueError(f\"Argument {i} has {arg.ndim} dimensions, expected 1D array\")\n    \n    # Ensure _verts3d exists\n    if not hasattr(self, '_verts3d'):\n        self._verts3d = ([], [], [])\n    \n    # Process the data\n    if len(args) == 1:\n        self._verts3d = args[0]\n    else:\n        self._verts3d = args[:3]\n    self.stale = True\n",
    "Location 5 (/root/hy/projects_3/matplotlib/lib/mpl_toolkits/mplot3d/art3d.py lines 169-169)": "\ndef __init__(self, xs, ys, zs, *args, **kwargs):\n    \"\"\"\n    Keyword arguments are passed onto :func:`~matplotlib.lines.Line2D`.\n    \"\"\"\n    # Always initialize _verts3d first as a safety measure\n    self._verts3d = ([], [], [])\n    super().__init__([], [], *args, **kwargs)\n    self._verts3d = xs, ys, zs\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/matplotlib/lib/mpl_toolkits/mplot3d/art3d.py lines 221-225)": [
      "\ndef line_2d_to_3d(line, zs=0, zdir='z'):\n    \"\"\"Convert a 2D line to 3D.\"\"\"\n    line.__class__ = Line3D\n    # Ensure _verts3d is always initialized as a safety measure\n    # This prevents AttributeError if set_3d_properties fails\n    if not hasattr(line, '_verts3d'):\n        line._verts3d = ([], [], [])\n    line.set_3d_properties(zs, zdir)\n",
      "\ndef line_2d_to_3d(line, zs=0, zdir='z'):\n    \"\"\"Convert a 2D line to 3D.\"\"\"\n    line.__class__ = Line3D\n    # Ensure _verts3d is always initialized as a safety measure\n    # This prevents AttributeError if set_3d_properties fails\n    if not hasattr(line, '_verts3d'):\n        line._verts3d = ([], [], [])\n    line.set_3d_properties(zs, zdir)\n",
      "\ndef line_2d_to_3d(line, zs=0, zdir='z'):\n    \"\"\"Convert a 2D line to 3D.\"\"\"\n    line.__class__ = Line3D\n    # Ensure _verts3d is always initialized as a safety measure\n    # This prevents AttributeError if set_3d_properties fails\n    if not hasattr(line, '_verts3d'):\n        line._verts3d = ([], [], [])\n    line.set_3d_properties(zs, zdir)\n",
      "\ndef line_2d_to_3d(line, zs=0, zdir='z'):\n    \"\"\"Convert a 2D line to 3D.\"\"\"\n    # Ensure _verts3d is always initialized before class mutation\n    # This prevents AttributeError if set_3d_properties fails\n    if not hasattr(line, '_verts3d'):\n        line._verts3d = ([], [], [])\n    \n    line.__class__ = Line3D\n    line.set_3d_properties(zs, zdir)\n",
      "\ndef line_2d_to_3d(line, zs=0, zdir='z'):\n    \"\"\"Convert a 2D line to 3D.\"\"\"\n    line.__class__ = Line3D\n    # Ensure _verts3d is always initialized as a safety measure\n    # This prevents AttributeError if set_3d_properties fails\n    if not hasattr(line, '_verts3d'):\n        line._verts3d = ([], [], [])\n    line.set_3d_properties(zs, zdir)\n",
      "\ndef line_2d_to_3d(line, zs=0, zdir='z'):\n    \"\"\"Convert a 2D line to 3D.\"\"\"\n    line.__class__ = Line3D\n    # Ensure _verts3d is always initialized as a safety measure\n    # This prevents AttributeError if set_3d_properties fails\n    if not hasattr(line, '_verts3d'):\n        line._verts3d = ([], [], [])\n    line.set_3d_properties(zs, zdir)\n",
      "\ndef line_2d_to_3d(line, zs=0, zdir='z'):\n    \"\"\"Convert a 2D line to 3D.\"\"\"\n    # Ensure _verts3d is always initialized before class mutation\n    # This prevents AttributeError if set_3d_properties fails\n    if not hasattr(line, '_verts3d'):\n        line._verts3d = ([], [], [])\n    \n    line.__class__ = Line3D\n    line.set_3d_properties(zs, zdir)\n",
      "\ndef line_2d_to_3d(line, zs=0, zdir='z'):\n    \"\"\"Convert a 2D line to 3D.\"\"\"\n    line.__class__ = Line3D\n    # Ensure _verts3d is always initialized as a safety measure\n    # This prevents AttributeError if set_3d_properties fails\n    if not hasattr(line, '_verts3d'):\n        line._verts3d = ([], [], [])\n    line.set_3d_properties(zs, zdir)\n"
    ],
    "Location 2 (/root/hy/projects_3/matplotlib/lib/mpl_toolkits/mplot3d/art3d.py lines 214-214)": [
      "\ndef line_2d_to_3d(line, zs=0, zdir='z'):\n    \"\"\"Convert a 2D line to 3D.\"\"\"\n    # Ensure _verts3d is always initialized before class mutation\n    # This prevents AttributeError if set_3d_properties fails\n    if not hasattr(line, '_verts3d'):\n        line._verts3d = ([], [], [])\n    \n    line.__class__ = Line3D\n    line.set_3d_properties(zs, zdir)\n",
      "\ndef line_2d_to_3d(line, zs=0, zdir='z'):\n    \"\"\"Convert a 2D line to 3D.\"\"\"\n    # Ensure _verts3d is always initialized before class mutation\n    # This prevents AttributeError if set_3d_properties fails\n    if not hasattr(line, '_verts3d'):\n        line._verts3d = ([], [], [])\n    \n    line.__class__ = Line3D\n    line.set_3d_properties(zs, zdir)\n",
      "\ndef line_2d_to_3d(line, zs=0, zdir='z'):\n    \"\"\"Convert a 2D line to 3D.\"\"\"\n    \n    line.__class__ = Line3D\n    # Ensure _verts3d is always initialized as a safety measure\n    # This prevents AttributeError if set_3d_properties fails\n    if not hasattr(line, '_verts3d'):\n        line._verts3d = ([], [], [])\n    line.set_3d_properties(zs, zdir)\n",
      "\ndef line_2d_to_3d(line, zs=0, zdir='z'):\n    \"\"\"Convert a 2D line to 3D.\"\"\"\n    \n    line.__class__ = Line3D\n    # Ensure _verts3d is always initialized as a safety measure\n    # This prevents AttributeError if set_3d_properties fails\n    if not hasattr(line, '_verts3d'):\n        line._verts3d = ([], [], [])\n    line.set_3d_properties(zs, zdir)\n",
      "\ndef line_2d_to_3d(line, zs=0, zdir='z'):\n    \"\"\"Convert a 2D line to 3D.\"\"\"\n    line.__class__ = Line3D\n    # Ensure _verts3d is always initialized as a safety measure\n    # This prevents AttributeError if set_3d_properties fails\n    if not hasattr(line, '_verts3d'):\n        line._verts3d = ([], [], [])\n    line.set_3d_properties(zs, zdir)\n",
      "\ndef line_2d_to_3d(line, zs=0, zdir='z'):\n    \"\"\"Convert a 2D line to 3D.\"\"\"\n    line.__class__ = Line3D\n    # Ensure _verts3d is always initialized as a safety measure\n    # This prevents AttributeError if set_3d_properties fails\n    if not hasattr(line, '_verts3d'):\n        line._verts3d = ([], [], [])\n    line.set_3d_properties(zs, zdir)\n",
      "\ndef line_2d_to_3d(line, zs=0, zdir='z'):\n    \"\"\"Convert a 2D line to 3D.\"\"\"\n    \n    line.__class__ = Line3D\n    # Ensure _verts3d is always initialized as a safety measure\n    # This prevents AttributeError if set_3d_properties fails\n    if not hasattr(line, '_verts3d'):\n        line._verts3d = ([], [], [])\n    line.set_3d_properties(zs, zdir)\n",
      "\ndef line_2d_to_3d(line, zs=0, zdir='z'):\n    \"\"\"Convert a 2D line to 3D.\"\"\"\n    \n    line.__class__ = Line3D\n    # Ensure _verts3d is always initialized as a safety measure\n    # This prevents AttributeError if set_3d_properties fails\n    if not hasattr(line, '_verts3d'):\n        line._verts3d = ([], [], [])\n    line.set_3d_properties(zs, zdir)\n"
    ],
    "Location 3 (/root/hy/projects_3/matplotlib/lib/mpl_toolkits/mplot3d/art3d.py lines 174-176)": [
      "\n    def set_3d_properties(self, zs=0, zdir='z'):\n        xs = self.get_xdata()\n        ys = self.get_ydata()\n        try:\n            zs = np.broadcast_to(zs, len(xs))\n            self._verts3d = juggle_axes(xs, ys, zs, zdir)\n            self.stale = True\n        except Exception:\n            # If coordinate processing fails, ensure _verts3d exists\n            if not hasattr(self, '_verts3d'):\n                self._verts3d = ([], [], [])\n            raise\n",
      "\ndef set_3d_properties(self, zs=0, zdir='z'):\n    # Ensure _verts3d exists before any operations\n    if not hasattr(self, '_verts3d'):\n        self._verts3d = ([], [], [])\n    \n    xs = self.get_xdata()\n    ys = self.get_ydata()\n    try:\n        zs = np.broadcast_to(zs, len(xs))\n        self._verts3d = juggle_axes(xs, ys, zs, zdir)\n        self.stale = True\n    except Exception:\n        # If coordinate processing fails, maintain a valid but empty state\n        if not hasattr(self, '_verts3d') or self._verts3d is None:\n            self._verts3d = ([], [], [])\n        raise  # Re-raise the original exception\n",
      "\ndef set_3d_properties(self, zs=0, zdir='z'):\n    # Ensure _verts3d exists before any operations\n    if not hasattr(self, '_verts3d'):\n        self._verts3d = ([], [], [])\n    \n    xs = self.get_xdata()\n    ys = self.get_ydata()\n    \n    try:\n        zs = np.broadcast_to(zs, len(xs))\n        self._verts3d = juggle_axes(xs, ys, zs, zdir)\n        self.stale = True\n    except Exception:\n        # If coordinate processing fails, maintain a valid but empty state\n        if not hasattr(self, '_verts3d') or self._verts3d is None:\n            self._verts3d = ([], [], [])\n        raise  # Re-raise the original exception\n",
      "\ndef set_3d_properties(self, zs=0, zdir='z'):\n    # Ensure _verts3d exists before any operations\n    if not hasattr(self, '_verts3d'):\n        self._verts3d = ([], [], [])\n    \n    xs = self.get_xdata()\n    ys = self.get_ydata()\n    try:\n        zs = np.broadcast_to(zs, len(xs))\n        self._verts3d = juggle_axes(xs, ys, zs, zdir)\n        self.stale = True\n    except Exception:\n        # If coordinate processing fails, maintain a valid but empty state\n        if not hasattr(self, '_verts3d') or self._verts3d is None:\n            self._verts3d = ([], [], [])\n        raise  # Re-raise the original exception\n",
      "\ndef set_3d_properties(self, zs=0, zdir='z'):\n    # Ensure _verts3d exists before any operations\n    if not hasattr(self, '_verts3d'):\n        self._verts3d = ([], [], [])\n    \n    xs = self.get_xdata()\n    ys = self.get_ydata()\n    try:\n        zs = np.broadcast_to(zs, len(xs))\n        self._verts3d = juggle_axes(xs, ys, zs, zdir)\n        self.stale = True\n    except Exception:\n        # If coordinate processing fails, maintain a valid but empty state\n        if not hasattr(self, '_verts3d') or self._verts3d is None:\n            self._verts3d = ([], [], [])\n        raise  # Re-raise the original exception\n",
      "\ndef set_3d_properties(self, zs=0, zdir='z'):\n    # Ensure _verts3d exists before any operations\n    if not hasattr(self, '_verts3d'):\n        self._verts3d = ([], [], [])\n    \n    xs = self.get_xdata()\n    ys = self.get_ydata()\n    \n    try:\n        zs = np.broadcast_to(zs, len(xs))\n        self._verts3d = juggle_axes(xs, ys, zs, zdir)\n        self.stale = True\n    except Exception:\n        # If coordinate processing fails, maintain a valid but empty state\n        if not hasattr(self, '_verts3d') or self._verts3d is None:\n            self._verts3d = ([], [], [])\n        raise  # Re-raise the original exception\n",
      "\ndef set_3d_properties(self, zs=0, zdir='z'):\n    # Ensure _verts3d exists before any operations\n    if not hasattr(self, '_verts3d'):\n        self._verts3d = ([], [], [])\n    \n    xs = self.get_xdata()\n    ys = self.get_ydata()\n    try:\n        zs = np.broadcast_to(zs, len(xs))\n        self._verts3d = juggle_axes(xs, ys, zs, zdir)\n        self.stale = True\n    except Exception:\n        # If coordinate processing fails, maintain a valid but empty state\n        if not hasattr(self, '_verts3d') or self._verts3d is None:\n            self._verts3d = ([], [], [])\n        raise  # Re-raise the original exception\n",
      "\ndef set_3d_properties(self, zs=0, zdir='z'):\n    # Ensure _verts3d exists before any operations\n    if not hasattr(self, '_verts3d'):\n        self._verts3d = ([], [], [])\n    \n    xs = self.get_xdata()\n    ys = self.get_ydata()\n    try:\n        zs = np.broadcast_to(zs, len(xs))\n        self._verts3d = juggle_axes(xs, ys, zs, zdir)\n        self.stale = True\n    except Exception:\n        # If coordinate processing fails, maintain a valid but empty state\n        if not hasattr(self, '_verts3d') or self._verts3d is None:\n            self._verts3d = ([], [], [])\n        raise  # Re-raise the original exception\n"
    ],
    "Location 4 (/root/hy/projects_3/matplotlib/lib/mpl_toolkits/mplot3d/art3d.py lines 196-198)": [
      "\ndef set_data_3d(self, *args):\n    \"\"\"\n    Set the x, y and z data\n\n    Parameters\n    ----------\n    x : array-like\n        The x-data to be plotted.\n    y : array-like\n        The y-data to be plotted.\n    z : array-like\n        The z-data to be plotted.\n\n    Notes\n    -----\n    Accepts x, y, z arguments or a single array-like (x, y, z)\n    \"\"\"\n    # Validate input dimensions before processing\n    for i, arg in enumerate(args):\n        if hasattr(arg, 'ndim') and arg.ndim > 1:\n            raise ValueError(f\"Argument {i} has {arg.ndim} dimensions, expected 1D array\")\n    \n    # Ensure _verts3d exists\n    if not hasattr(self, '_verts3d'):\n        self._verts3d = ([], [], [])\n    \n    # Process the data\n    if len(args) == 1:\n        self._verts3d = args[0]\n    else:\n        self._verts3d = args[:3]\n    self.stale = True\n",
      "\ndef set_data_3d(self, *args):\n    \"\"\"\n    Set the x, y and z data\n\n    Parameters\n    ----------\n    x : array-like\n        The x-data to be plotted.\n    y : array-like\n        The y-data to be plotted.\n    z : array-like\n        The z-data to be plotted.\n\n    Notes\n    -----\n    Accepts x, y, z arguments or a single array-like (x, y, z)\n    \"\"\"\n    # Validate input dimensions before processing\n    for i, arg in enumerate(args):\n        if hasattr(arg, 'ndim') and arg.ndim > 1:\n            raise ValueError(f\"Argument {i} has {arg.ndim} dimensions, expected 1D array\")\n    \n    # Ensure _verts3d exists\n    if not hasattr(self, '_verts3d'):\n        self._verts3d = ([], [], [])\n    \n    if len(args) == 1:\n        self._verts3d = args[0]\n    else:\n        self._verts3d = args[:3]\n    self.stale = True\n",
      "\ndef set_data_3d(self, *args):\n    \"\"\"\n    Set the x, y and z data\n\n    Parameters\n    ----------\n    x : array-like\n        The x-data to be plotted.\n    y : array-like\n        The y-data to be plotted.\n    z : array-like\n        The z-data to be plotted.\n\n    Notes\n    -----\n    Accepts x, y, z arguments or a single array-like (x, y, z)\n    \"\"\"\n    # Validate input dimensions before processing\n    for i, arg in enumerate(args):\n        if hasattr(arg, 'ndim') and arg.ndim > 1:\n            raise ValueError(f\"Argument {i} has {arg.ndim} dimensions, expected 1D array\")\n    \n    # Ensure _verts3d exists\n    if not hasattr(self, '_verts3d'):\n        self._verts3d = ([], [], [])\n    \n    # Process the data\n    if len(args) == 1:\n        self._verts3d = args[0]\n    else:\n        self._verts3d = args[:3]\n    self.stale = True\n",
      "\n    def set_data_3d(self, *args):\n        \"\"\"\n        Set the x, y and z data\n\n        Parameters\n        ----------\n        x : array-like\n            The x-data to be plotted.\n        y : array-like\n            The y-data to be plotted.\n        z : array-like\n            The z-data to be plotted.\n\n        Notes\n        -----\n        Accepts x, y, z arguments or a single array-like (x, y, z)\n        \"\"\"\n        # Validate input dimensions before processing\n        for i, arg in enumerate(args):\n            if hasattr(arg, 'ndim') and arg.ndim > 1:\n                raise ValueError(f\"Argument {i} has {arg.ndim} dimensions, expected 1D array\")\n        \n        # Ensure _verts3d exists\n        if not hasattr(self, '_verts3d'):\n            self._verts3d = ([], [], [])\n        \n        # Process the data\n        if len(args) == 1:\n            self._verts3d = args[0]\n        else:\n            self._verts3d = args[:3]\n        self.stale = True\n",
      "\ndef set_data_3d(self, *args):\n    \"\"\"\n    Set the x, y and z data\n\n    Parameters\n    ----------\n    x : array-like\n        The x-data to be plotted.\n    y : array-like\n        The y-data to be plotted.\n    z : array-like\n        The z-data to be plotted.\n\n    Notes\n    -----\n    Accepts x, y, z arguments or a single array-like (x, y, z)\n    \"\"\"\n    # Validate input dimensions before processing\n    for i, arg in enumerate(args):\n        if hasattr(arg, 'ndim') and arg.ndim > 1:\n            raise ValueError(f\"Argument {i} has {arg.ndim} dimensions, expected 1D array\")\n    \n    # Ensure _verts3d exists\n    if not hasattr(self, '_verts3d'):\n        self._verts3d = ([], [], [])\n    \n    if len(args) == 1:\n        self._verts3d = args[0]\n    else:\n        self._verts3d = args[:3]\n    self.stale = True\n",
      "\ndef set_data_3d(self, *args):\n    \"\"\"\n    Set the x, y and z data\n\n    Parameters\n    ----------\n    x : array-like\n        The x-data to be plotted.\n    y : array-like\n        The y-data to be plotted.\n    z : array-like\n        The z-data to be plotted.\n\n    Notes\n    -----\n    Accepts x, y, z arguments or a single array-like (x, y, z)\n    \"\"\"\n    # Validate input dimensions before processing\n    for i, arg in enumerate(args):\n        if hasattr(arg, 'ndim') and arg.ndim > 1:\n            raise ValueError(f\"Argument {i} has {arg.ndim} dimensions, expected 1D array\")\n    \n    # Ensure _verts3d exists\n    if not hasattr(self, '_verts3d'):\n        self._verts3d = ([], [], [])\n    \n    # Process the data\n    if len(args) == 1:\n        self._verts3d = args[0]\n    else:\n        self._verts3d = args[:3]\n    self.stale = True\n",
      "\n    def set_data_3d(self, *args):\n        \"\"\"\n        Set the x, y and z data\n\n        Parameters\n        ----------\n        x : array-like\n            The x-data to be plotted.\n        y : array-like\n            The y-data to be plotted.\n        z : array-like\n            The z-data to be plotted.\n\n        Notes\n        -----\n        Accepts x, y, z arguments or a single array-like (x, y, z)\n        \"\"\"\n        # Validate input dimensions before processing\n        for i, arg in enumerate(args):\n            if hasattr(arg, 'ndim') and arg.ndim > 1:\n                raise ValueError(f\"Argument {i} has {arg.ndim} dimensions, expected 1D array\")\n        \n        # Ensure _verts3d exists\n        if not hasattr(self, '_verts3d'):\n            self._verts3d = ([], [], [])\n        \n        # Process the data\n        if len(args) == 1:\n            self._verts3d = args[0]\n        else:\n            self._verts3d = args[:3]\n        self.stale = True\n",
      "\n    def set_data_3d(self, *args):\n        \"\"\"\n        Set the x, y and z data\n\n        Parameters\n        ----------\n        x : array-like\n            The x-data to be plotted.\n        y : array-like\n            The y-data to be plotted.\n        z : array-like\n            The z-data to be plotted.\n\n        Notes\n        -----\n        Accepts x, y, z arguments or a single array-like (x, y, z)\n        \"\"\"\n        # Validate input dimensions before processing\n        for i, arg in enumerate(args):\n            if hasattr(arg, 'ndim') and arg.ndim > 1:\n                raise ValueError(f\"Argument {i} has {arg.ndim} dimensions, expected 1D array\")\n        \n        # Ensure _verts3d exists\n        if not hasattr(self, '_verts3d'):\n            self._verts3d = ([], [], [])\n        \n        # Process the data\n        if len(args) == 1:\n            self._verts3d = args[0]\n        else:\n            self._verts3d = args[:3]\n        self.stale = True\n"
    ],
    "Location 5 (/root/hy/projects_3/matplotlib/lib/mpl_toolkits/mplot3d/art3d.py lines 169-169)": [
      "\ndef __init__(self, xs, ys, zs, *args, **kwargs):\n    \"\"\"\n    Keyword arguments are passed onto :func:`~matplotlib.lines.Line2D`.\n    \"\"\"\n    # Always initialize _verts3d first, even if parent init fails\n    self._verts3d = ([], [], [])\n    super().__init__([], [], *args, **kwargs)\n    self._verts3d = xs, ys, zs\n",
      "\ndef __init__(self, xs, ys, zs, *args, **kwargs):\n    \"\"\"\n    Keyword arguments are passed onto :func:`~matplotlib.lines.Line2D`.\n    \"\"\"\n    # Always initialize _verts3d first, even if parent init fails\n    self._verts3d = ([], [], [])\n    super().__init__([], [], *args, **kwargs)\n    self._verts3d = xs, ys, zs\n",
      "\ndef __init__(self, xs, ys, zs, *args, **kwargs):\n    \"\"\"\n    Keyword arguments are passed onto :func:`~matplotlib.lines.Line2D`.\n    \"\"\"\n    # Always initialize _verts3d first as a safety measure\n    self._verts3d = ([], [], [])\n    super().__init__([], [], *args, **kwargs)\n    # Set the actual 3D vertices after successful parent initialization\n    self._verts3d = xs, ys, zs\n",
      "\ndef __init__(self, xs, ys, zs, *args, **kwargs):\n    \"\"\"\n    Keyword arguments are passed onto :func:`~matplotlib.lines.Line2D`.\n    \"\"\"\n    # Always initialize _verts3d first to ensure object consistency\n    self._verts3d = ([], [], [])\n    super().__init__([], [], *args, **kwargs)\n    try:\n        self._verts3d = juggle_axes(xs, ys, zs, 'z')\n    except Exception:\n        # If coordinate processing fails, maintain valid empty state\n        self._verts3d = ([], [], [])\n        raise\n",
      "\ndef __init__(self, xs, ys, zs, *args, **kwargs):\n    \"\"\"\n    Keyword arguments are passed onto :func:`~matplotlib.lines.Line2D`.\n    \"\"\"\n    # Always initialize _verts3d first as a safety measure\n    self._verts3d = ([], [], [])\n    super().__init__([], [], *args, **kwargs)\n    self._verts3d = xs, ys, zs\n",
      "\ndef __init__(self, xs, ys, zs, *args, **kwargs):\n    \"\"\"\n    Keyword arguments are passed onto :func:`~matplotlib.lines.Line2D`.\n    \"\"\"\n    # Always initialize _verts3d first, even if parent init fails\n    self._verts3d = ([], [], [])\n    super().__init__([], [], *args, **kwargs)\n    self._verts3d = xs, ys, zs\n",
      "\n    def __init__(self, xs, ys, zs, *args, **kwargs):\n        \"\"\"\n        Keyword arguments are passed onto :func:`~matplotlib.lines.Line2D`.\n        \"\"\"\n        # Always initialize _verts3d first to prevent AttributeError\n        self._verts3d = ([], [], [])\n        super().__init__([], [], *args, **kwargs)\n        self._verts3d = xs, ys, zs\n",
      "\ndef __init__(self, xs, ys, zs, *args, **kwargs):\n    \"\"\"\n    Keyword arguments are passed onto :func:`~matplotlib.lines.Line2D`.\n    \"\"\"\n    # Always initialize _verts3d first as a safety measure\n    self._verts3d = ([], [], [])\n    super().__init__([], [], *args, **kwargs)\n    self._verts3d = xs, ys, zs\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/lib/mpl_toolkits/mplot3d/art3d.py b/lib/mpl_toolkits/mplot3d/art3d.py\nindex 8fe6e7a9c1..f56c91ecff 100644\n--- a/lib/mpl_toolkits/mplot3d/art3d.py\n+++ b/lib/mpl_toolkits/mplot3d/art3d.py\n@@ -166,14 +166,28 @@ class Line3D(lines.Line2D):\n         Keyword arguments are passed onto :func:`~matplotlib.lines.Line2D`.\n         \"\"\"\n         super().__init__([], [], *args, **kwargs)\n+\n         self._verts3d = xs, ys, zs\n \n     def set_3d_properties(self, zs=0, zdir='z'):\n         xs = self.get_xdata()\n         ys = self.get_ydata()\n-        zs = np.broadcast_to(zs, len(xs))\n-        self._verts3d = juggle_axes(xs, ys, zs, zdir)\n-        self.stale = True\n+\n+        # Ensure _verts3d exists before any operations\n+        if not hasattr(self, '_verts3d'):\n+            self._verts3d = ([], [], [])\n+        \n+        xs = self.get_xdata()\n+        ys = self.get_ydata()\n+        try:\n+            zs = np.broadcast_to(zs, len(xs))\n+            self._verts3d = juggle_axes(xs, ys, zs, zdir)\n+            self.stale = True\n+        except Exception:\n+            # If coordinate processing fails, maintain a valid but empty state\n+            if not hasattr(self, '_verts3d') or self._verts3d is None:\n+                self._verts3d = ([], [], [])\n+            raise  # Re-raise the original exception\n \n     def set_data_3d(self, *args):\n         \"\"\"\n@@ -192,10 +206,16 @@ class Line3D(lines.Line2D):\n         -----\n         Accepts x, y, z arguments or a single array-like (x, y, z)\n         \"\"\"\n+        if len(args) == 1:\n+\n+        # Ensure _verts3d exists\n+        if not hasattr(self, '_verts3d'):\n+            self._verts3d = ([], [], [])\n+        \n         if len(args) == 1:\n             self._verts3d = args[0]\n         else:\n-            self._verts3d = args\n+            self._verts3d = args[:3]\n         self.stale = True\n \n     def get_data_3d(self):\n@@ -211,6 +231,14 @@ class Line3D(lines.Line2D):\n \n     @artist.allow_rasterization\n     def draw(self, renderer):\n+\n+        # Safety check for missing _verts3d attribute\n+        if not hasattr(self, '_verts3d') or self._verts3d is None:\n+            # Attempt to reconstruct from available data\n+            if hasattr(self, '_x') and hasattr(self, '_y'):\n+                self._verts3d = (self._x, self._y, [0] * len(self._x))\n+            else:\n+                self._verts3d = ([], [], [])\n         xs3d, ys3d, zs3d = self._verts3d\n         xs, ys, zs = proj3d.proj_transform(xs3d, ys3d, zs3d, self.axes.M)\n         self.set_data(xs, ys)\n@@ -218,10 +246,15 @@ class Line3D(lines.Line2D):\n         self.stale = False\n \n \n+\n def line_2d_to_3d(line, zs=0, zdir='z'):\n     \"\"\"Convert a 2D line to 3D.\"\"\"\n \n     line.__class__ = Line3D\n+    # Ensure _verts3d is always initialized as a safety measure\n+    # This prevents AttributeError if set_3d_properties fails\n+    if not hasattr(line, '_verts3d'):\n+        line._verts3d = ([], [], [])\n     line.set_3d_properties(zs, zdir)\n \n \n",
    "variant_0": "diff --git a/lib/mpl_toolkits/mplot3d/art3d.py b/lib/mpl_toolkits/mplot3d/art3d.py\nindex 8fe6e7a9c1..2b16f37106 100644\n--- a/lib/mpl_toolkits/mplot3d/art3d.py\n+++ b/lib/mpl_toolkits/mplot3d/art3d.py\n@@ -166,14 +166,36 @@ class Line3D(lines.Line2D):\n         Keyword arguments are passed onto :func:`~matplotlib.lines.Line2D`.\n         \"\"\"\n         super().__init__([], [], *args, **kwargs)\n-        self._verts3d = xs, ys, zs\n+\n+def __init__(self, xs, ys, zs, *args, **kwargs):\n+    \"\"\"\n+    Keyword arguments are passed onto :func:`~matplotlib.lines.Line2D`.\n+    \"\"\"\n+    # Always initialize _verts3d first as a safety measure\n+    self._verts3d = ([], [], [])\n+    super().__init__([], [], *args, **kwargs)\n+    self._verts3d = xs, ys, zs\n \n     def set_3d_properties(self, zs=0, zdir='z'):\n         xs = self.get_xdata()\n         ys = self.get_ydata()\n+\n+def set_3d_properties(self, zs=0, zdir='z'):\n+    # Ensure _verts3d exists before any operations\n+    if not hasattr(self, '_verts3d'):\n+        self._verts3d = ([], [], [])\n+    \n+    xs = self.get_xdata()\n+    ys = self.get_ydata()\n+    try:\n         zs = np.broadcast_to(zs, len(xs))\n         self._verts3d = juggle_axes(xs, ys, zs, zdir)\n         self.stale = True\n+    except Exception:\n+        # If coordinate processing fails, maintain a valid but empty state\n+        if not hasattr(self, '_verts3d') or self._verts3d is None:\n+            self._verts3d = ([], [], [])\n+        raise  # Re-raise the original exception\n \n     def set_data_3d(self, *args):\n         \"\"\"\n@@ -193,9 +215,39 @@ class Line3D(lines.Line2D):\n         Accepts x, y, z arguments or a single array-like (x, y, z)\n         \"\"\"\n         if len(args) == 1:\n-            self._verts3d = args[0]\n-        else:\n-            self._verts3d = args\n+\n+def set_data_3d(self, *args):\n+    \"\"\"\n+    Set the x, y and z data\n+\n+    Parameters\n+    ----------\n+    x : array-like\n+        The x-data to be plotted.\n+    y : array-like\n+        The y-data to be plotted.\n+    z : array-like\n+        The z-data to be plotted.\n+\n+    Notes\n+    -----\n+    Accepts x, y, z arguments or a single array-like (x, y, z)\n+    \"\"\"\n+    # Validate input dimensions before processing\n+    for i, arg in enumerate(args):\n+        if hasattr(arg, 'ndim') and arg.ndim > 1:\n+            raise ValueError(f\"Argument {i} has {arg.ndim} dimensions, expected 1D array\")\n+    \n+    # Ensure _verts3d exists\n+    if not hasattr(self, '_verts3d'):\n+        self._verts3d = ([], [], [])\n+    \n+    # Process the data\n+    if len(args) == 1:\n+        self._verts3d = args[0]\n+    else:\n+        self._verts3d = args[:3]\n+    self.stale = True\n         self.stale = True\n \n     def get_data_3d(self):\n@@ -211,17 +263,29 @@ class Line3D(lines.Line2D):\n \n     @artist.allow_rasterization\n     def draw(self, renderer):\n-        xs3d, ys3d, zs3d = self._verts3d\n+\n+def line_2d_to_3d(line, zs=0, zdir='z'):\n+    \"\"\"Convert a 2D line to 3D.\"\"\"\n+    line.__class__ = Line3D\n+    # Ensure _verts3d is always initialized as a safety measure\n+    # This prevents AttributeError if set_3d_properties fails\n+    if not hasattr(line, '_verts3d'):\n+        line._verts3d = ([], [], [])\n+    line.set_3d_properties(zs, zdir)\n         xs, ys, zs = proj3d.proj_transform(xs3d, ys3d, zs3d, self.axes.M)\n         self.set_data(xs, ys)\n         super().draw(renderer)\n         self.stale = False\n \n \n+\n def line_2d_to_3d(line, zs=0, zdir='z'):\n     \"\"\"Convert a 2D line to 3D.\"\"\"\n-\n     line.__class__ = Line3D\n+    # Ensure _verts3d is always initialized as a safety measure\n+    # This prevents AttributeError if set_3d_properties fails\n+    if not hasattr(line, '_verts3d'):\n+        line._verts3d = ([], [], [])\n     line.set_3d_properties(zs, zdir)\n \n \n",
    "variant_1": "diff --git a/lib/mpl_toolkits/mplot3d/art3d.py b/lib/mpl_toolkits/mplot3d/art3d.py\nindex 8fe6e7a9c1..7337aac14b 100644\n--- a/lib/mpl_toolkits/mplot3d/art3d.py\n+++ b/lib/mpl_toolkits/mplot3d/art3d.py\n@@ -166,14 +166,32 @@ class Line3D(lines.Line2D):\n         Keyword arguments are passed onto :func:`~matplotlib.lines.Line2D`.\n         \"\"\"\n         super().__init__([], [], *args, **kwargs)\n-        self._verts3d = xs, ys, zs\n+\n+def __init__(self, xs, ys, zs, *args, **kwargs):\n+    \"\"\"\n+    Keyword arguments are passed onto :func:`~matplotlib.lines.Line2D`.\n+    \"\"\"\n+    # Always initialize _verts3d first, even if parent init fails\n+    self._verts3d = ([], [], [])\n+    super().__init__([], [], *args, **kwargs)\n+    self._verts3d = xs, ys, zs\n \n     def set_3d_properties(self, zs=0, zdir='z'):\n         xs = self.get_xdata()\n         ys = self.get_ydata()\n-        zs = np.broadcast_to(zs, len(xs))\n-        self._verts3d = juggle_axes(xs, ys, zs, zdir)\n-        self.stale = True\n+\n+    def set_3d_properties(self, zs=0, zdir='z'):\n+        xs = self.get_xdata()\n+        ys = self.get_ydata()\n+        try:\n+            zs = np.broadcast_to(zs, len(xs))\n+            self._verts3d = juggle_axes(xs, ys, zs, zdir)\n+            self.stale = True\n+        except Exception:\n+            # If coordinate processing fails, ensure _verts3d exists\n+            if not hasattr(self, '_verts3d'):\n+                self._verts3d = ([], [], [])\n+            raise\n \n     def set_data_3d(self, *args):\n         \"\"\"\n@@ -193,9 +211,39 @@ class Line3D(lines.Line2D):\n         Accepts x, y, z arguments or a single array-like (x, y, z)\n         \"\"\"\n         if len(args) == 1:\n-            self._verts3d = args[0]\n-        else:\n-            self._verts3d = args\n+\n+def set_data_3d(self, *args):\n+    \"\"\"\n+    Set the x, y and z data\n+\n+    Parameters\n+    ----------\n+    x : array-like\n+        The x-data to be plotted.\n+    y : array-like\n+        The y-data to be plotted.\n+    z : array-like\n+        The z-data to be plotted.\n+\n+    Notes\n+    -----\n+    Accepts x, y, z arguments or a single array-like (x, y, z)\n+    \"\"\"\n+    # Validate input dimensions before processing\n+    for i, arg in enumerate(args):\n+        if hasattr(arg, 'ndim') and arg.ndim > 1:\n+            raise ValueError(f\"Argument {i} has {arg.ndim} dimensions, expected 1D array\")\n+    \n+    # Ensure _verts3d exists\n+    if not hasattr(self, '_verts3d'):\n+        self._verts3d = ([], [], [])\n+    \n+    # Process the data\n+    if len(args) == 1:\n+        self._verts3d = args[0]\n+    else:\n+        self._verts3d = args[:3]\n+    self.stale = True\n         self.stale = True\n \n     def get_data_3d(self):\n@@ -211,17 +259,30 @@ class Line3D(lines.Line2D):\n \n     @artist.allow_rasterization\n     def draw(self, renderer):\n-        xs3d, ys3d, zs3d = self._verts3d\n+\n+def line_2d_to_3d(line, zs=0, zdir='z'):\n+    \"\"\"Convert a 2D line to 3D.\"\"\"\n+    # Ensure _verts3d is always initialized before class mutation\n+    # This prevents AttributeError if set_3d_properties fails\n+    if not hasattr(line, '_verts3d'):\n+        line._verts3d = ([], [], [])\n+    \n+    line.__class__ = Line3D\n+    line.set_3d_properties(zs, zdir)\n         xs, ys, zs = proj3d.proj_transform(xs3d, ys3d, zs3d, self.axes.M)\n         self.set_data(xs, ys)\n         super().draw(renderer)\n         self.stale = False\n \n \n+\n def line_2d_to_3d(line, zs=0, zdir='z'):\n     \"\"\"Convert a 2D line to 3D.\"\"\"\n-\n     line.__class__ = Line3D\n+    # Ensure _verts3d is always initialized as a safety measure\n+    # This prevents AttributeError if set_3d_properties fails\n+    if not hasattr(line, '_verts3d'):\n+        line._verts3d = ([], [], [])\n     line.set_3d_properties(zs, zdir)\n \n \n",
    "variant_2": "diff --git a/lib/mpl_toolkits/mplot3d/art3d.py b/lib/mpl_toolkits/mplot3d/art3d.py\nindex 8fe6e7a9c1..2b30d29193 100644\n--- a/lib/mpl_toolkits/mplot3d/art3d.py\n+++ b/lib/mpl_toolkits/mplot3d/art3d.py\n@@ -166,14 +166,36 @@ class Line3D(lines.Line2D):\n         Keyword arguments are passed onto :func:`~matplotlib.lines.Line2D`.\n         \"\"\"\n         super().__init__([], [], *args, **kwargs)\n-        self._verts3d = xs, ys, zs\n+\n+def __init__(self, xs, ys, zs, *args, **kwargs):\n+    \"\"\"\n+    Keyword arguments are passed onto :func:`~matplotlib.lines.Line2D`.\n+    \"\"\"\n+    # Always initialize _verts3d first, even if parent init fails\n+    self._verts3d = ([], [], [])\n+    super().__init__([], [], *args, **kwargs)\n+    self._verts3d = xs, ys, zs\n \n     def set_3d_properties(self, zs=0, zdir='z'):\n         xs = self.get_xdata()\n         ys = self.get_ydata()\n+\n+def set_3d_properties(self, zs=0, zdir='z'):\n+    # Ensure _verts3d exists before any operations\n+    if not hasattr(self, '_verts3d'):\n+        self._verts3d = ([], [], [])\n+    \n+    xs = self.get_xdata()\n+    ys = self.get_ydata()\n+    try:\n         zs = np.broadcast_to(zs, len(xs))\n         self._verts3d = juggle_axes(xs, ys, zs, zdir)\n         self.stale = True\n+    except Exception:\n+        # If coordinate processing fails, maintain a valid but empty state\n+        if not hasattr(self, '_verts3d') or self._verts3d is None:\n+            self._verts3d = ([], [], [])\n+        raise  # Re-raise the original exception\n \n     def set_data_3d(self, *args):\n         \"\"\"\n@@ -193,9 +215,38 @@ class Line3D(lines.Line2D):\n         Accepts x, y, z arguments or a single array-like (x, y, z)\n         \"\"\"\n         if len(args) == 1:\n-            self._verts3d = args[0]\n-        else:\n-            self._verts3d = args\n+\n+def set_data_3d(self, *args):\n+    \"\"\"\n+    Set the x, y and z data\n+\n+    Parameters\n+    ----------\n+    x : array-like\n+        The x-data to be plotted.\n+    y : array-like\n+        The y-data to be plotted.\n+    z : array-like\n+        The z-data to be plotted.\n+\n+    Notes\n+    -----\n+    Accepts x, y, z arguments or a single array-like (x, y, z)\n+    \"\"\"\n+    # Validate input dimensions before processing\n+    for i, arg in enumerate(args):\n+        if hasattr(arg, 'ndim') and arg.ndim > 1:\n+            raise ValueError(f\"Argument {i} has {arg.ndim} dimensions, expected 1D array\")\n+    \n+    # Ensure _verts3d exists\n+    if not hasattr(self, '_verts3d'):\n+        self._verts3d = ([], [], [])\n+    \n+    if len(args) == 1:\n+        self._verts3d = args[0]\n+    else:\n+        self._verts3d = args[:3]\n+    self.stale = True\n         self.stale = True\n \n     def get_data_3d(self):\n@@ -211,17 +262,30 @@ class Line3D(lines.Line2D):\n \n     @artist.allow_rasterization\n     def draw(self, renderer):\n-        xs3d, ys3d, zs3d = self._verts3d\n+\n+def line_2d_to_3d(line, zs=0, zdir='z'):\n+    \"\"\"Convert a 2D line to 3D.\"\"\"\n+    # Ensure _verts3d is always initialized before class mutation\n+    # This prevents AttributeError if set_3d_properties fails\n+    if not hasattr(line, '_verts3d'):\n+        line._verts3d = ([], [], [])\n+    \n+    line.__class__ = Line3D\n+    line.set_3d_properties(zs, zdir)\n         xs, ys, zs = proj3d.proj_transform(xs3d, ys3d, zs3d, self.axes.M)\n         self.set_data(xs, ys)\n         super().draw(renderer)\n         self.stale = False\n \n \n+\n def line_2d_to_3d(line, zs=0, zdir='z'):\n     \"\"\"Convert a 2D line to 3D.\"\"\"\n-\n     line.__class__ = Line3D\n+    # Ensure _verts3d is always initialized as a safety measure\n+    # This prevents AttributeError if set_3d_properties fails\n+    if not hasattr(line, '_verts3d'):\n+        line._verts3d = ([], [], [])\n     line.set_3d_properties(zs, zdir)\n \n \n",
    "variant_3": "diff --git a/lib/mpl_toolkits/mplot3d/art3d.py b/lib/mpl_toolkits/mplot3d/art3d.py\nindex 8fe6e7a9c1..7b613ebc99 100644\n--- a/lib/mpl_toolkits/mplot3d/art3d.py\n+++ b/lib/mpl_toolkits/mplot3d/art3d.py\n@@ -166,14 +166,38 @@ class Line3D(lines.Line2D):\n         Keyword arguments are passed onto :func:`~matplotlib.lines.Line2D`.\n         \"\"\"\n         super().__init__([], [], *args, **kwargs)\n-        self._verts3d = xs, ys, zs\n+\n+def __init__(self, xs, ys, zs, *args, **kwargs):\n+    \"\"\"\n+    Keyword arguments are passed onto :func:`~matplotlib.lines.Line2D`.\n+    \"\"\"\n+    # Always initialize _verts3d first as a safety measure\n+    self._verts3d = ([], [], [])\n+    super().__init__([], [], *args, **kwargs)\n+    # Set the actual 3D vertices after successful parent initialization\n+    self._verts3d = xs, ys, zs\n \n     def set_3d_properties(self, zs=0, zdir='z'):\n         xs = self.get_xdata()\n         ys = self.get_ydata()\n+\n+def set_3d_properties(self, zs=0, zdir='z'):\n+    # Ensure _verts3d exists before any operations\n+    if not hasattr(self, '_verts3d'):\n+        self._verts3d = ([], [], [])\n+    \n+    xs = self.get_xdata()\n+    ys = self.get_ydata()\n+    \n+    try:\n         zs = np.broadcast_to(zs, len(xs))\n         self._verts3d = juggle_axes(xs, ys, zs, zdir)\n         self.stale = True\n+    except Exception:\n+        # If coordinate processing fails, maintain a valid but empty state\n+        if not hasattr(self, '_verts3d') or self._verts3d is None:\n+            self._verts3d = ([], [], [])\n+        raise  # Re-raise the original exception\n \n     def set_data_3d(self, *args):\n         \"\"\"\n@@ -193,9 +217,39 @@ class Line3D(lines.Line2D):\n         Accepts x, y, z arguments or a single array-like (x, y, z)\n         \"\"\"\n         if len(args) == 1:\n-            self._verts3d = args[0]\n-        else:\n-            self._verts3d = args\n+\n+def set_data_3d(self, *args):\n+    \"\"\"\n+    Set the x, y and z data\n+\n+    Parameters\n+    ----------\n+    x : array-like\n+        The x-data to be plotted.\n+    y : array-like\n+        The y-data to be plotted.\n+    z : array-like\n+        The z-data to be plotted.\n+\n+    Notes\n+    -----\n+    Accepts x, y, z arguments or a single array-like (x, y, z)\n+    \"\"\"\n+    # Validate input dimensions before processing\n+    for i, arg in enumerate(args):\n+        if hasattr(arg, 'ndim') and arg.ndim > 1:\n+            raise ValueError(f\"Argument {i} has {arg.ndim} dimensions, expected 1D array\")\n+    \n+    # Ensure _verts3d exists\n+    if not hasattr(self, '_verts3d'):\n+        self._verts3d = ([], [], [])\n+    \n+    # Process the data\n+    if len(args) == 1:\n+        self._verts3d = args[0]\n+    else:\n+        self._verts3d = args[:3]\n+    self.stale = True\n         self.stale = True\n \n     def get_data_3d(self):\n@@ -211,17 +265,30 @@ class Line3D(lines.Line2D):\n \n     @artist.allow_rasterization\n     def draw(self, renderer):\n-        xs3d, ys3d, zs3d = self._verts3d\n+\n+def line_2d_to_3d(line, zs=0, zdir='z'):\n+    \"\"\"Convert a 2D line to 3D.\"\"\"\n+    \n+    line.__class__ = Line3D\n+    # Ensure _verts3d is always initialized as a safety measure\n+    # This prevents AttributeError if set_3d_properties fails\n+    if not hasattr(line, '_verts3d'):\n+        line._verts3d = ([], [], [])\n+    line.set_3d_properties(zs, zdir)\n         xs, ys, zs = proj3d.proj_transform(xs3d, ys3d, zs3d, self.axes.M)\n         self.set_data(xs, ys)\n         super().draw(renderer)\n         self.stale = False\n \n \n+\n def line_2d_to_3d(line, zs=0, zdir='z'):\n     \"\"\"Convert a 2D line to 3D.\"\"\"\n-\n     line.__class__ = Line3D\n+    # Ensure _verts3d is always initialized as a safety measure\n+    # This prevents AttributeError if set_3d_properties fails\n+    if not hasattr(line, '_verts3d'):\n+        line._verts3d = ([], [], [])\n     line.set_3d_properties(zs, zdir)\n \n \n",
    "variant_4": "diff --git a/lib/mpl_toolkits/mplot3d/art3d.py b/lib/mpl_toolkits/mplot3d/art3d.py\nindex 8fe6e7a9c1..0647732d37 100644\n--- a/lib/mpl_toolkits/mplot3d/art3d.py\n+++ b/lib/mpl_toolkits/mplot3d/art3d.py\n@@ -166,14 +166,41 @@ class Line3D(lines.Line2D):\n         Keyword arguments are passed onto :func:`~matplotlib.lines.Line2D`.\n         \"\"\"\n         super().__init__([], [], *args, **kwargs)\n-        self._verts3d = xs, ys, zs\n+\n+def __init__(self, xs, ys, zs, *args, **kwargs):\n+    \"\"\"\n+    Keyword arguments are passed onto :func:`~matplotlib.lines.Line2D`.\n+    \"\"\"\n+    # Always initialize _verts3d first to ensure object consistency\n+    self._verts3d = ([], [], [])\n+    super().__init__([], [], *args, **kwargs)\n+    try:\n+        self._verts3d = juggle_axes(xs, ys, zs, 'z')\n+    except Exception:\n+        # If coordinate processing fails, maintain valid empty state\n+        self._verts3d = ([], [], [])\n+        raise\n \n     def set_3d_properties(self, zs=0, zdir='z'):\n         xs = self.get_xdata()\n         ys = self.get_ydata()\n+\n+def set_3d_properties(self, zs=0, zdir='z'):\n+    # Ensure _verts3d exists before any operations\n+    if not hasattr(self, '_verts3d'):\n+        self._verts3d = ([], [], [])\n+    \n+    xs = self.get_xdata()\n+    ys = self.get_ydata()\n+    try:\n         zs = np.broadcast_to(zs, len(xs))\n         self._verts3d = juggle_axes(xs, ys, zs, zdir)\n         self.stale = True\n+    except Exception:\n+        # If coordinate processing fails, maintain a valid but empty state\n+        if not hasattr(self, '_verts3d') or self._verts3d is None:\n+            self._verts3d = ([], [], [])\n+        raise  # Re-raise the original exception\n \n     def set_data_3d(self, *args):\n         \"\"\"\n@@ -193,9 +220,39 @@ class Line3D(lines.Line2D):\n         Accepts x, y, z arguments or a single array-like (x, y, z)\n         \"\"\"\n         if len(args) == 1:\n+\n+    def set_data_3d(self, *args):\n+        \"\"\"\n+        Set the x, y and z data\n+\n+        Parameters\n+        ----------\n+        x : array-like\n+            The x-data to be plotted.\n+        y : array-like\n+            The y-data to be plotted.\n+        z : array-like\n+            The z-data to be plotted.\n+\n+        Notes\n+        -----\n+        Accepts x, y, z arguments or a single array-like (x, y, z)\n+        \"\"\"\n+        # Validate input dimensions before processing\n+        for i, arg in enumerate(args):\n+            if hasattr(arg, 'ndim') and arg.ndim > 1:\n+                raise ValueError(f\"Argument {i} has {arg.ndim} dimensions, expected 1D array\")\n+        \n+        # Ensure _verts3d exists\n+        if not hasattr(self, '_verts3d'):\n+            self._verts3d = ([], [], [])\n+        \n+        # Process the data\n+        if len(args) == 1:\n             self._verts3d = args[0]\n         else:\n-            self._verts3d = args\n+            self._verts3d = args[:3]\n+        self.stale = True\n         self.stale = True\n \n     def get_data_3d(self):\n@@ -211,16 +268,30 @@ class Line3D(lines.Line2D):\n \n     @artist.allow_rasterization\n     def draw(self, renderer):\n-        xs3d, ys3d, zs3d = self._verts3d\n+\n+def line_2d_to_3d(line, zs=0, zdir='z'):\n+    \"\"\"Convert a 2D line to 3D.\"\"\"\n+    \n+    line.__class__ = Line3D\n+    # Ensure _verts3d is always initialized as a safety measure\n+    # This prevents AttributeError if set_3d_properties fails\n+    if not hasattr(line, '_verts3d'):\n+        line._verts3d = ([], [], [])\n+    line.set_3d_properties(zs, zdir)\n         xs, ys, zs = proj3d.proj_transform(xs3d, ys3d, zs3d, self.axes.M)\n         self.set_data(xs, ys)\n         super().draw(renderer)\n         self.stale = False\n \n \n+\n def line_2d_to_3d(line, zs=0, zdir='z'):\n     \"\"\"Convert a 2D line to 3D.\"\"\"\n-\n+    # Ensure _verts3d is always initialized before class mutation\n+    # This prevents AttributeError if set_3d_properties fails\n+    if not hasattr(line, '_verts3d'):\n+        line._verts3d = ([], [], [])\n+    \n     line.__class__ = Line3D\n     line.set_3d_properties(zs, zdir)\n \n",
    "variant_5": "diff --git a/lib/mpl_toolkits/mplot3d/art3d.py b/lib/mpl_toolkits/mplot3d/art3d.py\nindex 8fe6e7a9c1..239ef7d312 100644\n--- a/lib/mpl_toolkits/mplot3d/art3d.py\n+++ b/lib/mpl_toolkits/mplot3d/art3d.py\n@@ -166,14 +166,36 @@ class Line3D(lines.Line2D):\n         Keyword arguments are passed onto :func:`~matplotlib.lines.Line2D`.\n         \"\"\"\n         super().__init__([], [], *args, **kwargs)\n-        self._verts3d = xs, ys, zs\n+\n+def __init__(self, xs, ys, zs, *args, **kwargs):\n+    \"\"\"\n+    Keyword arguments are passed onto :func:`~matplotlib.lines.Line2D`.\n+    \"\"\"\n+    # Always initialize _verts3d first as a safety measure\n+    self._verts3d = ([], [], [])\n+    super().__init__([], [], *args, **kwargs)\n+    self._verts3d = xs, ys, zs\n \n     def set_3d_properties(self, zs=0, zdir='z'):\n         xs = self.get_xdata()\n         ys = self.get_ydata()\n+\n+def set_3d_properties(self, zs=0, zdir='z'):\n+    # Ensure _verts3d exists before any operations\n+    if not hasattr(self, '_verts3d'):\n+        self._verts3d = ([], [], [])\n+    \n+    xs = self.get_xdata()\n+    ys = self.get_ydata()\n+    try:\n         zs = np.broadcast_to(zs, len(xs))\n         self._verts3d = juggle_axes(xs, ys, zs, zdir)\n         self.stale = True\n+    except Exception:\n+        # If coordinate processing fails, maintain a valid but empty state\n+        if not hasattr(self, '_verts3d') or self._verts3d is None:\n+            self._verts3d = ([], [], [])\n+        raise  # Re-raise the original exception\n \n     def set_data_3d(self, *args):\n         \"\"\"\n@@ -193,9 +215,38 @@ class Line3D(lines.Line2D):\n         Accepts x, y, z arguments or a single array-like (x, y, z)\n         \"\"\"\n         if len(args) == 1:\n-            self._verts3d = args[0]\n-        else:\n-            self._verts3d = args\n+\n+def set_data_3d(self, *args):\n+    \"\"\"\n+    Set the x, y and z data\n+\n+    Parameters\n+    ----------\n+    x : array-like\n+        The x-data to be plotted.\n+    y : array-like\n+        The y-data to be plotted.\n+    z : array-like\n+        The z-data to be plotted.\n+\n+    Notes\n+    -----\n+    Accepts x, y, z arguments or a single array-like (x, y, z)\n+    \"\"\"\n+    # Validate input dimensions before processing\n+    for i, arg in enumerate(args):\n+        if hasattr(arg, 'ndim') and arg.ndim > 1:\n+            raise ValueError(f\"Argument {i} has {arg.ndim} dimensions, expected 1D array\")\n+    \n+    # Ensure _verts3d exists\n+    if not hasattr(self, '_verts3d'):\n+        self._verts3d = ([], [], [])\n+    \n+    if len(args) == 1:\n+        self._verts3d = args[0]\n+    else:\n+        self._verts3d = args[:3]\n+    self.stale = True\n         self.stale = True\n \n     def get_data_3d(self):\n@@ -211,17 +262,29 @@ class Line3D(lines.Line2D):\n \n     @artist.allow_rasterization\n     def draw(self, renderer):\n-        xs3d, ys3d, zs3d = self._verts3d\n+\n+def line_2d_to_3d(line, zs=0, zdir='z'):\n+    \"\"\"Convert a 2D line to 3D.\"\"\"\n+    line.__class__ = Line3D\n+    # Ensure _verts3d is always initialized as a safety measure\n+    # This prevents AttributeError if set_3d_properties fails\n+    if not hasattr(line, '_verts3d'):\n+        line._verts3d = ([], [], [])\n+    line.set_3d_properties(zs, zdir)\n         xs, ys, zs = proj3d.proj_transform(xs3d, ys3d, zs3d, self.axes.M)\n         self.set_data(xs, ys)\n         super().draw(renderer)\n         self.stale = False\n \n \n+\n def line_2d_to_3d(line, zs=0, zdir='z'):\n     \"\"\"Convert a 2D line to 3D.\"\"\"\n-\n     line.__class__ = Line3D\n+    # Ensure _verts3d is always initialized as a safety measure\n+    # This prevents AttributeError if set_3d_properties fails\n+    if not hasattr(line, '_verts3d'):\n+        line._verts3d = ([], [], [])\n     line.set_3d_properties(zs, zdir)\n \n \n",
    "variant_6": "diff --git a/lib/mpl_toolkits/mplot3d/art3d.py b/lib/mpl_toolkits/mplot3d/art3d.py\nindex 8fe6e7a9c1..1eaef306ca 100644\n--- a/lib/mpl_toolkits/mplot3d/art3d.py\n+++ b/lib/mpl_toolkits/mplot3d/art3d.py\n@@ -166,14 +166,37 @@ class Line3D(lines.Line2D):\n         Keyword arguments are passed onto :func:`~matplotlib.lines.Line2D`.\n         \"\"\"\n         super().__init__([], [], *args, **kwargs)\n-        self._verts3d = xs, ys, zs\n+\n+def __init__(self, xs, ys, zs, *args, **kwargs):\n+    \"\"\"\n+    Keyword arguments are passed onto :func:`~matplotlib.lines.Line2D`.\n+    \"\"\"\n+    # Always initialize _verts3d first, even if parent init fails\n+    self._verts3d = ([], [], [])\n+    super().__init__([], [], *args, **kwargs)\n+    self._verts3d = xs, ys, zs\n \n     def set_3d_properties(self, zs=0, zdir='z'):\n         xs = self.get_xdata()\n         ys = self.get_ydata()\n+\n+def set_3d_properties(self, zs=0, zdir='z'):\n+    # Ensure _verts3d exists before any operations\n+    if not hasattr(self, '_verts3d'):\n+        self._verts3d = ([], [], [])\n+    \n+    xs = self.get_xdata()\n+    ys = self.get_ydata()\n+    \n+    try:\n         zs = np.broadcast_to(zs, len(xs))\n         self._verts3d = juggle_axes(xs, ys, zs, zdir)\n         self.stale = True\n+    except Exception:\n+        # If coordinate processing fails, maintain a valid but empty state\n+        if not hasattr(self, '_verts3d') or self._verts3d is None:\n+            self._verts3d = ([], [], [])\n+        raise  # Re-raise the original exception\n \n     def set_data_3d(self, *args):\n         \"\"\"\n@@ -193,9 +216,39 @@ class Line3D(lines.Line2D):\n         Accepts x, y, z arguments or a single array-like (x, y, z)\n         \"\"\"\n         if len(args) == 1:\n-            self._verts3d = args[0]\n-        else:\n-            self._verts3d = args\n+\n+def set_data_3d(self, *args):\n+    \"\"\"\n+    Set the x, y and z data\n+\n+    Parameters\n+    ----------\n+    x : array-like\n+        The x-data to be plotted.\n+    y : array-like\n+        The y-data to be plotted.\n+    z : array-like\n+        The z-data to be plotted.\n+\n+    Notes\n+    -----\n+    Accepts x, y, z arguments or a single array-like (x, y, z)\n+    \"\"\"\n+    # Validate input dimensions before processing\n+    for i, arg in enumerate(args):\n+        if hasattr(arg, 'ndim') and arg.ndim > 1:\n+            raise ValueError(f\"Argument {i} has {arg.ndim} dimensions, expected 1D array\")\n+    \n+    # Ensure _verts3d exists\n+    if not hasattr(self, '_verts3d'):\n+        self._verts3d = ([], [], [])\n+    \n+    # Process the data\n+    if len(args) == 1:\n+        self._verts3d = args[0]\n+    else:\n+        self._verts3d = args[:3]\n+    self.stale = True\n         self.stale = True\n \n     def get_data_3d(self):\n@@ -211,17 +264,29 @@ class Line3D(lines.Line2D):\n \n     @artist.allow_rasterization\n     def draw(self, renderer):\n-        xs3d, ys3d, zs3d = self._verts3d\n+\n+def line_2d_to_3d(line, zs=0, zdir='z'):\n+    \"\"\"Convert a 2D line to 3D.\"\"\"\n+    line.__class__ = Line3D\n+    # Ensure _verts3d is always initialized as a safety measure\n+    # This prevents AttributeError if set_3d_properties fails\n+    if not hasattr(line, '_verts3d'):\n+        line._verts3d = ([], [], [])\n+    line.set_3d_properties(zs, zdir)\n         xs, ys, zs = proj3d.proj_transform(xs3d, ys3d, zs3d, self.axes.M)\n         self.set_data(xs, ys)\n         super().draw(renderer)\n         self.stale = False\n \n \n+\n def line_2d_to_3d(line, zs=0, zdir='z'):\n     \"\"\"Convert a 2D line to 3D.\"\"\"\n-\n     line.__class__ = Line3D\n+    # Ensure _verts3d is always initialized as a safety measure\n+    # This prevents AttributeError if set_3d_properties fails\n+    if not hasattr(line, '_verts3d'):\n+        line._verts3d = ([], [], [])\n     line.set_3d_properties(zs, zdir)\n \n \n",
    "variant_7": "diff --git a/lib/mpl_toolkits/mplot3d/art3d.py b/lib/mpl_toolkits/mplot3d/art3d.py\nindex 8fe6e7a9c1..55cab13c6e 100644\n--- a/lib/mpl_toolkits/mplot3d/art3d.py\n+++ b/lib/mpl_toolkits/mplot3d/art3d.py\n@@ -166,14 +166,55 @@ class Line3D(lines.Line2D):\n         Keyword arguments are passed onto :func:`~matplotlib.lines.Line2D`.\n         \"\"\"\n         super().__init__([], [], *args, **kwargs)\n+\n+    def __init__(self, xs, ys, zs, *args, **kwargs):\n+        \"\"\"\n+        Keyword arguments are passed onto :func:`~matplotlib.lines.Line2D`.\n+        \"\"\"\n+        # Always initialize _verts3d first to prevent AttributeError\n+        self._verts3d = ([], [], [])\n+        super().__init__([], [], *args, **kwargs)\n         self._verts3d = xs, ys, zs\n \n     def set_3d_properties(self, zs=0, zdir='z'):\n         xs = self.get_xdata()\n         ys = self.get_ydata()\n+\n+def set_3d_properties(self, zs=0, zdir='z'):\n+    # Ensure _verts3d exists before any operations\n+    if not hasattr(self, '_verts3d'):\n+        self._verts3d = ([], [], [])\n+    \n+    xs = self.get_xdata()\n+    ys = self.get_ydata()\n+    try:\n         zs = np.broadcast_to(zs, len(xs))\n         self._verts3d = juggle_axes(xs, ys, zs, zdir)\n         self.stale = True\n+    except Exception:\n+        # If coordinate processing fails, maintain a valid but empty state\n+        if not hasattr(self, '_verts3d') or self._verts3d is None:\n+            self._verts3d = ([], [], [])\n+        raise  # Re-raise the original exception\n+\n+    def set_data_3d(self, *args):\n+        \"\"\"\n+        Set the x, y and z data\n+\n+        Parameters\n+        ----------\n+        x : array-like\n+            The x-data to be plotted.\n+        y : array-like\n+            The y-data to be plotted.\n+        z : array-like\n+            The z-data to be plotted.\n+\n+        Notes\n+        -----\n+        Accepts x, y, z arguments or a single array-like (x, y, z)\n+        \"\"\"\n+        if len(args) == 1:\n \n     def set_data_3d(self, *args):\n         \"\"\"\n@@ -192,10 +233,21 @@ class Line3D(lines.Line2D):\n         -----\n         Accepts x, y, z arguments or a single array-like (x, y, z)\n         \"\"\"\n+        # Validate input dimensions before processing\n+        for i, arg in enumerate(args):\n+            if hasattr(arg, 'ndim') and arg.ndim > 1:\n+                raise ValueError(f\"Argument {i} has {arg.ndim} dimensions, expected 1D array\")\n+        \n+        # Ensure _verts3d exists\n+        if not hasattr(self, '_verts3d'):\n+            self._verts3d = ([], [], [])\n+        \n+        # Process the data\n         if len(args) == 1:\n             self._verts3d = args[0]\n         else:\n-            self._verts3d = args\n+            self._verts3d = args[:3]\n+        self.stale = True\n         self.stale = True\n \n     def get_data_3d(self):\n@@ -211,16 +263,30 @@ class Line3D(lines.Line2D):\n \n     @artist.allow_rasterization\n     def draw(self, renderer):\n-        xs3d, ys3d, zs3d = self._verts3d\n+\n+def line_2d_to_3d(line, zs=0, zdir='z'):\n+    \"\"\"Convert a 2D line to 3D.\"\"\"\n+    \n+    line.__class__ = Line3D\n+    # Ensure _verts3d is always initialized as a safety measure\n+    # This prevents AttributeError if set_3d_properties fails\n+    if not hasattr(line, '_verts3d'):\n+        line._verts3d = ([], [], [])\n+    line.set_3d_properties(zs, zdir)\n         xs, ys, zs = proj3d.proj_transform(xs3d, ys3d, zs3d, self.axes.M)\n         self.set_data(xs, ys)\n         super().draw(renderer)\n         self.stale = False\n \n \n+\n def line_2d_to_3d(line, zs=0, zdir='z'):\n     \"\"\"Convert a 2D line to 3D.\"\"\"\n-\n+    # Ensure _verts3d is always initialized before class mutation\n+    # This prevents AttributeError if set_3d_properties fails\n+    if not hasattr(line, '_verts3d'):\n+        line._verts3d = ([], [], [])\n+    \n     line.__class__ = Line3D\n     line.set_3d_properties(zs, zdir)\n \n",
    "variant_8": "diff --git a/lib/mpl_toolkits/mplot3d/art3d.py b/lib/mpl_toolkits/mplot3d/art3d.py\nindex 8fe6e7a9c1..a56bf6cd5c 100644\n--- a/lib/mpl_toolkits/mplot3d/art3d.py\n+++ b/lib/mpl_toolkits/mplot3d/art3d.py\n@@ -166,14 +166,36 @@ class Line3D(lines.Line2D):\n         Keyword arguments are passed onto :func:`~matplotlib.lines.Line2D`.\n         \"\"\"\n         super().__init__([], [], *args, **kwargs)\n-        self._verts3d = xs, ys, zs\n+\n+def __init__(self, xs, ys, zs, *args, **kwargs):\n+    \"\"\"\n+    Keyword arguments are passed onto :func:`~matplotlib.lines.Line2D`.\n+    \"\"\"\n+    # Always initialize _verts3d first as a safety measure\n+    self._verts3d = ([], [], [])\n+    super().__init__([], [], *args, **kwargs)\n+    self._verts3d = xs, ys, zs\n \n     def set_3d_properties(self, zs=0, zdir='z'):\n         xs = self.get_xdata()\n         ys = self.get_ydata()\n+\n+def set_3d_properties(self, zs=0, zdir='z'):\n+    # Ensure _verts3d exists before any operations\n+    if not hasattr(self, '_verts3d'):\n+        self._verts3d = ([], [], [])\n+    \n+    xs = self.get_xdata()\n+    ys = self.get_ydata()\n+    try:\n         zs = np.broadcast_to(zs, len(xs))\n         self._verts3d = juggle_axes(xs, ys, zs, zdir)\n         self.stale = True\n+    except Exception:\n+        # If coordinate processing fails, maintain a valid but empty state\n+        if not hasattr(self, '_verts3d') or self._verts3d is None:\n+            self._verts3d = ([], [], [])\n+        raise  # Re-raise the original exception\n \n     def set_data_3d(self, *args):\n         \"\"\"\n@@ -193,9 +215,39 @@ class Line3D(lines.Line2D):\n         Accepts x, y, z arguments or a single array-like (x, y, z)\n         \"\"\"\n         if len(args) == 1:\n+\n+    def set_data_3d(self, *args):\n+        \"\"\"\n+        Set the x, y and z data\n+\n+        Parameters\n+        ----------\n+        x : array-like\n+            The x-data to be plotted.\n+        y : array-like\n+            The y-data to be plotted.\n+        z : array-like\n+            The z-data to be plotted.\n+\n+        Notes\n+        -----\n+        Accepts x, y, z arguments or a single array-like (x, y, z)\n+        \"\"\"\n+        # Validate input dimensions before processing\n+        for i, arg in enumerate(args):\n+            if hasattr(arg, 'ndim') and arg.ndim > 1:\n+                raise ValueError(f\"Argument {i} has {arg.ndim} dimensions, expected 1D array\")\n+        \n+        # Ensure _verts3d exists\n+        if not hasattr(self, '_verts3d'):\n+            self._verts3d = ([], [], [])\n+        \n+        # Process the data\n+        if len(args) == 1:\n             self._verts3d = args[0]\n         else:\n-            self._verts3d = args\n+            self._verts3d = args[:3]\n+        self.stale = True\n         self.stale = True\n \n     def get_data_3d(self):\n@@ -211,17 +263,30 @@ class Line3D(lines.Line2D):\n \n     @artist.allow_rasterization\n     def draw(self, renderer):\n-        xs3d, ys3d, zs3d = self._verts3d\n+\n+def line_2d_to_3d(line, zs=0, zdir='z'):\n+    \"\"\"Convert a 2D line to 3D.\"\"\"\n+    \n+    line.__class__ = Line3D\n+    # Ensure _verts3d is always initialized as a safety measure\n+    # This prevents AttributeError if set_3d_properties fails\n+    if not hasattr(line, '_verts3d'):\n+        line._verts3d = ([], [], [])\n+    line.set_3d_properties(zs, zdir)\n         xs, ys, zs = proj3d.proj_transform(xs3d, ys3d, zs3d, self.axes.M)\n         self.set_data(xs, ys)\n         super().draw(renderer)\n         self.stale = False\n \n \n+\n def line_2d_to_3d(line, zs=0, zdir='z'):\n     \"\"\"Convert a 2D line to 3D.\"\"\"\n-\n     line.__class__ = Line3D\n+    # Ensure _verts3d is always initialized as a safety measure\n+    # This prevents AttributeError if set_3d_properties fails\n+    if not hasattr(line, '_verts3d'):\n+        line._verts3d = ([], [], [])\n     line.set_3d_properties(zs, zdir)\n \n \n"
  }
}