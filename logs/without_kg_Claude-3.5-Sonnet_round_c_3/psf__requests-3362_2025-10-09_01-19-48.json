{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/requests/requests/utils.py lines 362-365)": "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    # Use the same encoding fallback logic as the text property\n    encoding = r.encoding\n    if encoding is None:\n        encoding = r.apparent_encoding\n\n    # If we still don't have an encoding, return raw bytes\n    if encoding is None:\n        for item in iterator:\n            yield item\n        return\n\n    # Handle encoding errors gracefully like the text property does\n    try:\n        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    except (LookupError, TypeError):\n        # Fallback to replace errors if encoding is problematic\n        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    \n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
    "Location 2 (/root/hy/projects_3/requests/requests/utils.py lines 367-374)": "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    # Use the same encoding fallback logic as the text property\n    encoding = r.encoding\n    if encoding is None:\n        encoding = r.apparent_encoding\n\n    # If we still don't have an encoding, yield raw bytes\n    if encoding is None:\n        for item in iterator:\n            yield item\n        return\n\n    try:\n        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    except (LookupError, TypeError):\n        # Fall back to blind encoding with error replacement\n        decoder = codecs.getincrementaldecoder('utf-8')(errors='replace')\n    \n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
    "Location 3 (/root/hy/projects_3/requests/requests/models.py lines 777-779)": "\n        # Fallback to auto-detected encoding.\n        if self.encoding is None:\n            encoding = self.apparent_encoding\n",
    "Location 4 (/root/hy/projects_3/requests/requests/models.py lines 648-651)": "\n@property\ndef apparent_encoding(self):\n    \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n    return chardet.detect(self.content)['encoding']\n",
    "Location 5 (/root/hy/projects_3/requests/requests/models.py lines 781-791)": "\n        # Decode unicode from given encoding.\n        try:\n            content = str(self.content, encoding, errors='replace')\n        except (LookupError, TypeError):\n            # A LookupError is raised if the encoding was not found which could\n            # indicate a misspelling or similar mistake.\n            #\n            # A TypeError can be raised if encoding is None\n            #\n            # So we try blindly encoding.\n            content = str(self.content, errors='replace')\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/requests/requests/utils.py lines 362-365)": [
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    encoding = r.encoding\n    if encoding is None:\n        encoding = r.apparent_encoding\n\n    try:\n        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    except (LookupError, TypeError):\n        decoder = codecs.getincrementaldecoder('utf-8')(errors='replace')\n    \n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    encoding = r.encoding\n    if encoding is None:\n        encoding = r.apparent_encoding\n\n    if encoding is None:\n        for item in iterator:\n            yield item\n        return\n\n    try:\n        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    except (LookupError, TypeError):\n        decoder = codecs.getincrementaldecoder('utf-8')(errors='replace')\n    \n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    encoding = r.encoding\n    if encoding is None:\n        encoding = r.apparent_encoding\n\n    try:\n        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    except (LookupError, TypeError):\n        decoder = codecs.getincrementaldecoder('utf-8')(errors='replace')\n\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    encoding = r.encoding\n    if encoding is None:\n        encoding = r.apparent_encoding\n\n    try:\n        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    except (LookupError, TypeError):\n        decoder = codecs.getincrementaldecoder('utf-8')(errors='replace')\n    \n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    encoding = r.encoding\n    if encoding is None:\n        encoding = r.apparent_encoding\n\n    try:\n        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    except (LookupError, TypeError):\n        decoder = codecs.getincrementaldecoder('utf-8')(errors='replace')\n    \n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    # Use the same fallback logic as the text property\n    encoding = r.encoding\n    if encoding is None:\n        encoding = r.apparent_encoding\n\n    # If still no encoding, return raw bytes (should be rare)\n    if encoding is None:\n        for item in iterator:\n            yield item\n        return\n\n    # Try to get decoder with error handling like text property\n    try:\n        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    except (LookupError, TypeError):\n        # Fallback to replace errors if encoding is problematic\n        decoder = codecs.getincrementaldecoder('utf-8')(errors='replace')\n    \n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    encoding = r.encoding\n    if encoding is None:\n        encoding = r.apparent_encoding\n\n    try:\n        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    except (LookupError, TypeError):\n        decoder = codecs.getincrementaldecoder('utf-8')(errors='replace')\n\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    encoding = r.encoding\n    if encoding is None:\n        encoding = r.apparent_encoding\n\n    try:\n        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    except (LookupError, TypeError):\n        decoder = codecs.getincrementaldecoder('utf-8')(errors='replace')\n    \n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n"
    ],
    "Location 2 (/root/hy/projects_3/requests/requests/utils.py lines 367-374)": [
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    encoding = r.encoding\n    if encoding is None:\n        encoding = r.apparent_encoding\n\n    try:\n        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    except (LookupError, TypeError):\n        decoder = codecs.getincrementaldecoder('utf-8')(errors='replace')\n    \n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    encoding = r.encoding\n    if encoding is None:\n        encoding = r.apparent_encoding\n\n    if encoding is None:\n        for item in iterator:\n            yield item\n        return\n\n    try:\n        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    except (LookupError, TypeError):\n        decoder = codecs.getincrementaldecoder('utf-8')(errors='replace')\n    \n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    encoding = r.encoding\n    if encoding is None:\n        encoding = r.apparent_encoding\n\n    try:\n        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    except (LookupError, TypeError):\n        decoder = codecs.getincrementaldecoder('utf-8')(errors='replace')\n    \n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    # Use the same encoding fallback logic as the text property\n    encoding = r.encoding\n    if encoding is None:\n        encoding = r.apparent_encoding\n\n    # Handle case where no encoding can be determined\n    if encoding is None:\n        for item in iterator:\n            yield item\n        return\n\n    try:\n        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    except (LookupError, TypeError):\n        # Fallback to replace errors if encoding is invalid\n        decoder = codecs.getincrementaldecoder('utf-8')(errors='replace')\n    \n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    # Use the same encoding logic as the text property\n    encoding = r.encoding\n    if encoding is None:\n        encoding = r.apparent_encoding\n\n    # If we still don't have an encoding, yield raw bytes\n    if encoding is None:\n        for item in iterator:\n            yield item\n        return\n\n    # Try to create decoder with error handling similar to text property\n    try:\n        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    except (LookupError, TypeError):\n        # Fallback to replace errors if encoding is problematic\n        decoder = codecs.getincrementaldecoder('utf-8')(errors='replace')\n    \n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    # Use the same encoding fallback logic as r.text\n    encoding = r.encoding\n    if encoding is None:\n        encoding = r.apparent_encoding\n\n    # If we still don't have an encoding, yield raw bytes\n    if encoding is None:\n        for item in iterator:\n            yield item\n        return\n\n    try:\n        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    except (LookupError, TypeError):\n        # Fall back to blind encoding with error replacement\n        decoder = codecs.getincrementaldecoder('utf-8')(errors='replace')\n    \n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    # Use the same fallback logic as the text property\n    encoding = r.encoding\n    if encoding is None:\n        encoding = r.apparent_encoding\n\n    # If we still don't have an encoding, yield raw bytes\n    if encoding is None:\n        for item in iterator:\n            yield item\n        return\n\n    try:\n        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    except (LookupError, TypeError):\n        # Fallback to replace mode if encoding is invalid\n        decoder = codecs.getincrementaldecoder('utf-8')(errors='replace')\n    \n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    # Use the same encoding fallback logic as r.text\n    encoding = r.encoding\n    if encoding is None:\n        encoding = r.apparent_encoding\n\n    # If we still don't have an encoding, yield raw bytes\n    if encoding is None:\n        for item in iterator:\n            yield item\n        return\n\n    try:\n        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    except (LookupError, TypeError):\n        # Fall back to blind encoding with error replacement\n        decoder = codecs.getincrementaldecoder('utf-8')(errors='replace')\n    \n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n"
    ],
    "Location 3 (/root/hy/projects_3/requests/requests/models.py lines 777-779)": [
      "\n        # Fallback to auto-detected encoding.\n        if self.encoding is None:\n            encoding = self.apparent_encoding\n",
      "\n        # Fallback to auto-detected encoding.\n        if self.encoding is None:\n            encoding = self.apparent_encoding\n",
      "\n        # Fallback to auto-detected encoding.\n        if self.encoding is None:\n            encoding = self.apparent_encoding\n",
      "\n        # Fallback to auto-detected encoding.\n        if self.encoding is None:\n            encoding = self.apparent_encoding\n",
      "\n        # Fallback to auto-detected encoding.\n        if self.encoding is None:\n            encoding = self.apparent_encoding\n",
      "\n        # Fallback to auto-detected encoding.\n        if self.encoding is None:\n            encoding = self.apparent_encoding\n",
      "\n        # Fallback to auto-detected encoding.\n        if self.encoding is None:\n            encoding = self.apparent_encoding\n",
      "\n        # Fallback to auto-detected encoding.\n        if self.encoding is None:\n            encoding = self.apparent_encoding\n"
    ],
    "Location 4 (/root/hy/projects_3/requests/requests/models.py lines 648-651)": [
      "\n    @property\n    def apparent_encoding(self):\n        \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n        return chardet.detect(self.content)['encoding']\n",
      "\n    @property\n    def apparent_encoding(self):\n        \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n        return chardet.detect(self.content)['encoding']\n",
      "\n@property\ndef apparent_encoding(self):\n    \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n    return chardet.detect(self.content)['encoding']\n",
      "\n@property\ndef apparent_encoding(self):\n    \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n    return chardet.detect(self.content)['encoding']\n",
      "\n    @property\n    def apparent_encoding(self):\n        \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n        return chardet.detect(self.content)['encoding']\n",
      "\n@property\ndef apparent_encoding(self):\n    \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n    return chardet.detect(self.content)['encoding']\n",
      "\n@property\ndef apparent_encoding(self):\n    \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n    return chardet.detect(self.content)['encoding']\n",
      "\n    @property\n    def apparent_encoding(self):\n        \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n        return chardet.detect(self.content)['encoding']\n"
    ],
    "Location 5 (/root/hy/projects_3/requests/requests/models.py lines 781-791)": [
      "\n        # Decode unicode from given encoding.\n        try:\n            content = str(self.content, encoding, errors='replace')\n        except (LookupError, TypeError):\n            # A LookupError is raised if the encoding was not found which could\n            # indicate a misspelling or similar mistake.\n            #\n            # A TypeError can be raised if encoding is None\n            #\n            # So we try blindly encoding.\n            content = str(self.content, errors='replace')\n",
      "\n        # Decode unicode from given encoding.\n        try:\n            content = str(self.content, encoding, errors='replace')\n        except (LookupError, TypeError):\n            # A LookupError is raised if the encoding was not found which could\n            # indicate a misspelling or similar mistake.\n            #\n            # A TypeError can be raised if encoding is None\n            #\n            # So we try blindly encoding.\n            content = str(self.content, errors='replace')\n",
      "\n        # Decode unicode from given encoding.\n        try:\n            content = str(self.content, encoding, errors='replace')\n        except (LookupError, TypeError):\n            # A LookupError is raised if the encoding was not found which could\n            # indicate a misspelling or similar mistake.\n            #\n            # A TypeError can be raised if encoding is None\n            #\n            # So we try blindly encoding.\n            content = str(self.content, errors='replace')\n",
      "\n        # Decode unicode from given encoding.\n        try:\n            content = str(self.content, encoding, errors='replace')\n        except (LookupError, TypeError):\n            # A LookupError is raised if the encoding was not found which could\n            # indicate a misspelling or similar mistake.\n            #\n            # A TypeError can be raised if encoding is None\n            #\n            # So we try blindly encoding.\n            content = str(self.content, errors='replace')\n",
      "\n        # Decode unicode from given encoding.\n        try:\n            content = str(self.content, encoding, errors='replace')\n        except (LookupError, TypeError):\n            # A LookupError is raised if the encoding was not found which could\n            # indicate a misspelling or similar mistake.\n            #\n            # A TypeError can be raised if encoding is None\n            #\n            # So we try blindly encoding.\n            content = str(self.content, errors='replace')\n",
      "\n        # Decode unicode from given encoding.\n        try:\n            content = str(self.content, encoding, errors='replace')\n        except (LookupError, TypeError):\n            # A LookupError is raised if the encoding was not found which could\n            # indicate a misspelling or similar mistake.\n            #\n            # A TypeError can be raised if encoding is None\n            #\n            # So we try blindly encoding.\n            content = str(self.content, errors='replace')\n",
      "\n        # Decode unicode from given encoding.\n        try:\n            content = str(self.content, encoding, errors='replace')\n        except (LookupError, TypeError):\n            # A LookupError is raised if the encoding was not found which could\n            # indicate a misspelling or similar mistake.\n            #\n            # A TypeError can be raised if encoding is None\n            #\n            # So we try blindly encoding.\n            content = str(self.content, errors='replace')\n",
      "\n        # Decode unicode from given encoding.\n        try:\n            content = str(self.content, encoding, errors='replace')\n        except (LookupError, TypeError):\n            # A LookupError is raised if the encoding was not found which could\n            # indicate a misspelling or similar mistake.\n            #\n            # A TypeError can be raised if encoding is None\n            #\n            # So we try blindly encoding.\n            content = str(self.content, errors='replace')\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/requests/models.py b/requests/models.py\nindex fbb3c7e6..9dd2a80e 100644\n--- a/requests/models.py\n+++ b/requests/models.py\n@@ -645,6 +645,7 @@ class Response(object):\n         \"\"\"True if this Response one of the permanent versions of redirect\"\"\"\n         return ('location' in self.headers and self.status_code in (codes.moved_permanently, codes.permanent_redirect))\n \n+\n     @property\n     def apparent_encoding(self):\n         \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n@@ -774,10 +775,12 @@ class Response(object):\n         if not self.content:\n             return str('')\n \n+\n         # Fallback to auto-detected encoding.\n         if self.encoding is None:\n             encoding = self.apparent_encoding\n \n+\n         # Decode unicode from given encoding.\n         try:\n             content = str(self.content, encoding, errors='replace')\ndiff --git a/requests/utils.py b/requests/utils.py\nindex 8d17b6b2..54f7fa17 100644\n--- a/requests/utils.py\n+++ b/requests/utils.py\n@@ -359,19 +359,37 @@ def get_encoding_from_headers(headers):\n def stream_decode_response_unicode(iterator, r):\n     \"\"\"Stream decodes a iterator.\"\"\"\n \n+\n+    # Fallback to auto-detected encoding.\n     if r.encoding is None:\n-        for item in iterator:\n-            yield item\n-        return\n+        encoding = r.apparent_encoding\n+    else:\n+        encoding = r.encoding\n+\n \n-    decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')\n-    for chunk in iterator:\n-        rv = decoder.decode(chunk)\n+    # Decode unicode from given encoding.\n+    try:\n+        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+        for chunk in iterator:\n+            rv = decoder.decode(chunk)\n+            if rv:\n+                yield rv\n+        rv = decoder.decode(b'', final=True)\n         if rv:\n             yield rv\n-    rv = decoder.decode(b'', final=True)\n-    if rv:\n-        yield rv\n+    except (LookupError, TypeError):\n+        # A LookupError is raised if the encoding was not found which could\n+        # indicate a misspelling or similar mistake.\n+        #\n+        # A TypeError can be raised if encoding is None\n+        #\n+        # So we try blindly encoding.\n+        for chunk in iterator:\n+            try:\n+                yield str(chunk, errors='replace')\n+            except TypeError:\n+                # chunk might already be a string\n+                yield chunk\n \n \n def iter_slices(string, slice_length):\n",
    "variant_0": "diff --git a/requests/models.py b/requests/models.py\nindex fbb3c7e6..c58748c5 100644\n--- a/requests/models.py\n+++ b/requests/models.py\n@@ -645,10 +645,11 @@ class Response(object):\n         \"\"\"True if this Response one of the permanent versions of redirect\"\"\"\n         return ('location' in self.headers and self.status_code in (codes.moved_permanently, codes.permanent_redirect))\n \n-    @property\n-    def apparent_encoding(self):\n-        \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n-        return chardet.detect(self.content)['encoding']\n+\n+@property\n+def apparent_encoding(self):\n+    \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n+    return chardet.detect(self.content)['encoding']\n \n     def iter_content(self, chunk_size=1, decode_unicode=False):\n         \"\"\"Iterates over the response data.  When stream=True is set on the\n@@ -774,10 +775,12 @@ class Response(object):\n         if not self.content:\n             return str('')\n \n+\n         # Fallback to auto-detected encoding.\n         if self.encoding is None:\n             encoding = self.apparent_encoding\n \n+\n         # Decode unicode from given encoding.\n         try:\n             content = str(self.content, encoding, errors='replace')\ndiff --git a/requests/utils.py b/requests/utils.py\nindex 8d17b6b2..5463e755 100644\n--- a/requests/utils.py\n+++ b/requests/utils.py\n@@ -359,12 +359,57 @@ def get_encoding_from_headers(headers):\n def stream_decode_response_unicode(iterator, r):\n     \"\"\"Stream decodes a iterator.\"\"\"\n \n-    if r.encoding is None:\n+\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Stream decodes a iterator.\"\"\"\n+\n+    # Use the same encoding fallback logic as the text property\n+    encoding = r.encoding\n+    if encoding is None:\n+        encoding = r.apparent_encoding\n+\n+    # If we still don't have an encoding, return raw bytes\n+    if encoding is None:\n+        for item in iterator:\n+            yield item\n+        return\n+\n+    # Handle encoding errors gracefully like the text property does\n+    try:\n+        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    except (LookupError, TypeError):\n+        # Fallback to replace errors if encoding is problematic\n+        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    \n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n+\n+\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Stream decodes a iterator.\"\"\"\n+\n+    # Use the same encoding fallback logic as the text property\n+    encoding = r.encoding\n+    if encoding is None:\n+        encoding = r.apparent_encoding\n+\n+    # If we still don't have an encoding, yield raw bytes\n+    if encoding is None:\n         for item in iterator:\n             yield item\n         return\n \n-    decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')\n+    try:\n+        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    except (LookupError, TypeError):\n+        # Fall back to blind encoding with error replacement\n+        decoder = codecs.getincrementaldecoder('utf-8')(errors='replace')\n+    \n     for chunk in iterator:\n         rv = decoder.decode(chunk)\n         if rv:\n",
    "variant_1": "diff --git a/requests/models.py b/requests/models.py\nindex fbb3c7e6..9dd2a80e 100644\n--- a/requests/models.py\n+++ b/requests/models.py\n@@ -645,6 +645,7 @@ class Response(object):\n         \"\"\"True if this Response one of the permanent versions of redirect\"\"\"\n         return ('location' in self.headers and self.status_code in (codes.moved_permanently, codes.permanent_redirect))\n \n+\n     @property\n     def apparent_encoding(self):\n         \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n@@ -774,10 +775,12 @@ class Response(object):\n         if not self.content:\n             return str('')\n \n+\n         # Fallback to auto-detected encoding.\n         if self.encoding is None:\n             encoding = self.apparent_encoding\n \n+\n         # Decode unicode from given encoding.\n         try:\n             content = str(self.content, encoding, errors='replace')\ndiff --git a/requests/utils.py b/requests/utils.py\nindex 8d17b6b2..8560c9f6 100644\n--- a/requests/utils.py\n+++ b/requests/utils.py\n@@ -359,12 +359,40 @@ def get_encoding_from_headers(headers):\n def stream_decode_response_unicode(iterator, r):\n     \"\"\"Stream decodes a iterator.\"\"\"\n \n-    if r.encoding is None:\n-        for item in iterator:\n-            yield item\n-        return\n \n-    decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Stream decodes a iterator.\"\"\"\n+\n+    encoding = r.encoding\n+    if encoding is None:\n+        encoding = r.apparent_encoding\n+\n+    try:\n+        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    except (LookupError, TypeError):\n+        decoder = codecs.getincrementaldecoder('utf-8')(errors='replace')\n+    \n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n+\n+\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Stream decodes a iterator.\"\"\"\n+\n+    encoding = r.encoding\n+    if encoding is None:\n+        encoding = r.apparent_encoding\n+\n+    try:\n+        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    except (LookupError, TypeError):\n+        decoder = codecs.getincrementaldecoder('utf-8')(errors='replace')\n+    \n     for chunk in iterator:\n         rv = decoder.decode(chunk)\n         if rv:\n",
    "variant_2": "diff --git a/requests/models.py b/requests/models.py\nindex fbb3c7e6..9dd2a80e 100644\n--- a/requests/models.py\n+++ b/requests/models.py\n@@ -645,6 +645,7 @@ class Response(object):\n         \"\"\"True if this Response one of the permanent versions of redirect\"\"\"\n         return ('location' in self.headers and self.status_code in (codes.moved_permanently, codes.permanent_redirect))\n \n+\n     @property\n     def apparent_encoding(self):\n         \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n@@ -774,10 +775,12 @@ class Response(object):\n         if not self.content:\n             return str('')\n \n+\n         # Fallback to auto-detected encoding.\n         if self.encoding is None:\n             encoding = self.apparent_encoding\n \n+\n         # Decode unicode from given encoding.\n         try:\n             content = str(self.content, encoding, errors='replace')\ndiff --git a/requests/utils.py b/requests/utils.py\nindex 8d17b6b2..3dd85eb1 100644\n--- a/requests/utils.py\n+++ b/requests/utils.py\n@@ -359,12 +359,50 @@ def get_encoding_from_headers(headers):\n def stream_decode_response_unicode(iterator, r):\n     \"\"\"Stream decodes a iterator.\"\"\"\n \n-    if r.encoding is None:\n+\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Stream decodes a iterator.\"\"\"\n+\n+    encoding = r.encoding\n+    if encoding is None:\n+        encoding = r.apparent_encoding\n+\n+    if encoding is None:\n+        for item in iterator:\n+            yield item\n+        return\n+\n+    try:\n+        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    except (LookupError, TypeError):\n+        decoder = codecs.getincrementaldecoder('utf-8')(errors='replace')\n+    \n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n+\n+\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Stream decodes a iterator.\"\"\"\n+\n+    encoding = r.encoding\n+    if encoding is None:\n+        encoding = r.apparent_encoding\n+\n+    if encoding is None:\n         for item in iterator:\n             yield item\n         return\n \n-    decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')\n+    try:\n+        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    except (LookupError, TypeError):\n+        decoder = codecs.getincrementaldecoder('utf-8')(errors='replace')\n+    \n     for chunk in iterator:\n         rv = decoder.decode(chunk)\n         if rv:\n",
    "variant_3": "diff --git a/requests/models.py b/requests/models.py\nindex fbb3c7e6..c58748c5 100644\n--- a/requests/models.py\n+++ b/requests/models.py\n@@ -645,10 +645,11 @@ class Response(object):\n         \"\"\"True if this Response one of the permanent versions of redirect\"\"\"\n         return ('location' in self.headers and self.status_code in (codes.moved_permanently, codes.permanent_redirect))\n \n-    @property\n-    def apparent_encoding(self):\n-        \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n-        return chardet.detect(self.content)['encoding']\n+\n+@property\n+def apparent_encoding(self):\n+    \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n+    return chardet.detect(self.content)['encoding']\n \n     def iter_content(self, chunk_size=1, decode_unicode=False):\n         \"\"\"Iterates over the response data.  When stream=True is set on the\n@@ -774,10 +775,12 @@ class Response(object):\n         if not self.content:\n             return str('')\n \n+\n         # Fallback to auto-detected encoding.\n         if self.encoding is None:\n             encoding = self.apparent_encoding\n \n+\n         # Decode unicode from given encoding.\n         try:\n             content = str(self.content, encoding, errors='replace')\ndiff --git a/requests/utils.py b/requests/utils.py\nindex 8d17b6b2..48346d2d 100644\n--- a/requests/utils.py\n+++ b/requests/utils.py\n@@ -359,12 +359,40 @@ def get_encoding_from_headers(headers):\n def stream_decode_response_unicode(iterator, r):\n     \"\"\"Stream decodes a iterator.\"\"\"\n \n-    if r.encoding is None:\n-        for item in iterator:\n-            yield item\n-        return\n \n-    decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Stream decodes a iterator.\"\"\"\n+\n+    encoding = r.encoding\n+    if encoding is None:\n+        encoding = r.apparent_encoding\n+\n+    try:\n+        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    except (LookupError, TypeError):\n+        decoder = codecs.getincrementaldecoder('utf-8')(errors='replace')\n+\n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n+\n+\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Stream decodes a iterator.\"\"\"\n+\n+    encoding = r.encoding\n+    if encoding is None:\n+        encoding = r.apparent_encoding\n+\n+    try:\n+        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    except (LookupError, TypeError):\n+        decoder = codecs.getincrementaldecoder('utf-8')(errors='replace')\n+    \n     for chunk in iterator:\n         rv = decoder.decode(chunk)\n         if rv:\n",
    "variant_4": "diff --git a/requests/models.py b/requests/models.py\nindex fbb3c7e6..c58748c5 100644\n--- a/requests/models.py\n+++ b/requests/models.py\n@@ -645,10 +645,11 @@ class Response(object):\n         \"\"\"True if this Response one of the permanent versions of redirect\"\"\"\n         return ('location' in self.headers and self.status_code in (codes.moved_permanently, codes.permanent_redirect))\n \n-    @property\n-    def apparent_encoding(self):\n-        \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n-        return chardet.detect(self.content)['encoding']\n+\n+@property\n+def apparent_encoding(self):\n+    \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n+    return chardet.detect(self.content)['encoding']\n \n     def iter_content(self, chunk_size=1, decode_unicode=False):\n         \"\"\"Iterates over the response data.  When stream=True is set on the\n@@ -774,10 +775,12 @@ class Response(object):\n         if not self.content:\n             return str('')\n \n+\n         # Fallback to auto-detected encoding.\n         if self.encoding is None:\n             encoding = self.apparent_encoding\n \n+\n         # Decode unicode from given encoding.\n         try:\n             content = str(self.content, encoding, errors='replace')\ndiff --git a/requests/utils.py b/requests/utils.py\nindex 8d17b6b2..c1796994 100644\n--- a/requests/utils.py\n+++ b/requests/utils.py\n@@ -359,12 +359,48 @@ def get_encoding_from_headers(headers):\n def stream_decode_response_unicode(iterator, r):\n     \"\"\"Stream decodes a iterator.\"\"\"\n \n-    if r.encoding is None:\n+\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Stream decodes a iterator.\"\"\"\n+\n+    encoding = r.encoding\n+    if encoding is None:\n+        encoding = r.apparent_encoding\n+\n+    try:\n+        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    except (LookupError, TypeError):\n+        decoder = codecs.getincrementaldecoder('utf-8')(errors='replace')\n+    \n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n+\n+\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Stream decodes a iterator.\"\"\"\n+\n+    # Use the same encoding fallback logic as the text property\n+    encoding = r.encoding\n+    if encoding is None:\n+        encoding = r.apparent_encoding\n+\n+    # Handle case where no encoding can be determined\n+    if encoding is None:\n         for item in iterator:\n             yield item\n         return\n \n-    decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')\n+    try:\n+        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    except (LookupError, TypeError):\n+        # Fallback to replace errors if encoding is invalid\n+        decoder = codecs.getincrementaldecoder('utf-8')(errors='replace')\n+    \n     for chunk in iterator:\n         rv = decoder.decode(chunk)\n         if rv:\n",
    "variant_5": "diff --git a/requests/models.py b/requests/models.py\nindex fbb3c7e6..9dd2a80e 100644\n--- a/requests/models.py\n+++ b/requests/models.py\n@@ -645,6 +645,7 @@ class Response(object):\n         \"\"\"True if this Response one of the permanent versions of redirect\"\"\"\n         return ('location' in self.headers and self.status_code in (codes.moved_permanently, codes.permanent_redirect))\n \n+\n     @property\n     def apparent_encoding(self):\n         \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n@@ -774,10 +775,12 @@ class Response(object):\n         if not self.content:\n             return str('')\n \n+\n         # Fallback to auto-detected encoding.\n         if self.encoding is None:\n             encoding = self.apparent_encoding\n \n+\n         # Decode unicode from given encoding.\n         try:\n             content = str(self.content, encoding, errors='replace')\ndiff --git a/requests/utils.py b/requests/utils.py\nindex 8d17b6b2..86546a5d 100644\n--- a/requests/utils.py\n+++ b/requests/utils.py\n@@ -359,12 +359,49 @@ def get_encoding_from_headers(headers):\n def stream_decode_response_unicode(iterator, r):\n     \"\"\"Stream decodes a iterator.\"\"\"\n \n-    if r.encoding is None:\n+\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Stream decodes a iterator.\"\"\"\n+\n+    encoding = r.encoding\n+    if encoding is None:\n+        encoding = r.apparent_encoding\n+\n+    try:\n+        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    except (LookupError, TypeError):\n+        decoder = codecs.getincrementaldecoder('utf-8')(errors='replace')\n+    \n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n+\n+\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Stream decodes a iterator.\"\"\"\n+\n+    # Use the same encoding logic as the text property\n+    encoding = r.encoding\n+    if encoding is None:\n+        encoding = r.apparent_encoding\n+\n+    # If we still don't have an encoding, yield raw bytes\n+    if encoding is None:\n         for item in iterator:\n             yield item\n         return\n \n-    decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')\n+    # Try to create decoder with error handling similar to text property\n+    try:\n+        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    except (LookupError, TypeError):\n+        # Fallback to replace errors if encoding is problematic\n+        decoder = codecs.getincrementaldecoder('utf-8')(errors='replace')\n+    \n     for chunk in iterator:\n         rv = decoder.decode(chunk)\n         if rv:\n",
    "variant_6": "diff --git a/requests/models.py b/requests/models.py\nindex fbb3c7e6..c58748c5 100644\n--- a/requests/models.py\n+++ b/requests/models.py\n@@ -645,10 +645,11 @@ class Response(object):\n         \"\"\"True if this Response one of the permanent versions of redirect\"\"\"\n         return ('location' in self.headers and self.status_code in (codes.moved_permanently, codes.permanent_redirect))\n \n-    @property\n-    def apparent_encoding(self):\n-        \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n-        return chardet.detect(self.content)['encoding']\n+\n+@property\n+def apparent_encoding(self):\n+    \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n+    return chardet.detect(self.content)['encoding']\n \n     def iter_content(self, chunk_size=1, decode_unicode=False):\n         \"\"\"Iterates over the response data.  When stream=True is set on the\n@@ -774,10 +775,12 @@ class Response(object):\n         if not self.content:\n             return str('')\n \n+\n         # Fallback to auto-detected encoding.\n         if self.encoding is None:\n             encoding = self.apparent_encoding\n \n+\n         # Decode unicode from given encoding.\n         try:\n             content = str(self.content, encoding, errors='replace')\ndiff --git a/requests/utils.py b/requests/utils.py\nindex 8d17b6b2..8532e103 100644\n--- a/requests/utils.py\n+++ b/requests/utils.py\n@@ -359,12 +359,57 @@ def get_encoding_from_headers(headers):\n def stream_decode_response_unicode(iterator, r):\n     \"\"\"Stream decodes a iterator.\"\"\"\n \n-    if r.encoding is None:\n+\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Stream decodes a iterator.\"\"\"\n+\n+    # Use the same fallback logic as the text property\n+    encoding = r.encoding\n+    if encoding is None:\n+        encoding = r.apparent_encoding\n+\n+    # If still no encoding, return raw bytes (should be rare)\n+    if encoding is None:\n+        for item in iterator:\n+            yield item\n+        return\n+\n+    # Try to get decoder with error handling like text property\n+    try:\n+        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    except (LookupError, TypeError):\n+        # Fallback to replace errors if encoding is problematic\n+        decoder = codecs.getincrementaldecoder('utf-8')(errors='replace')\n+    \n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n+\n+\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Stream decodes a iterator.\"\"\"\n+\n+    # Use the same encoding fallback logic as r.text\n+    encoding = r.encoding\n+    if encoding is None:\n+        encoding = r.apparent_encoding\n+\n+    # If we still don't have an encoding, yield raw bytes\n+    if encoding is None:\n         for item in iterator:\n             yield item\n         return\n \n-    decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')\n+    try:\n+        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    except (LookupError, TypeError):\n+        # Fall back to blind encoding with error replacement\n+        decoder = codecs.getincrementaldecoder('utf-8')(errors='replace')\n+    \n     for chunk in iterator:\n         rv = decoder.decode(chunk)\n         if rv:\n",
    "variant_7": "diff --git a/requests/models.py b/requests/models.py\nindex fbb3c7e6..c58748c5 100644\n--- a/requests/models.py\n+++ b/requests/models.py\n@@ -645,10 +645,11 @@ class Response(object):\n         \"\"\"True if this Response one of the permanent versions of redirect\"\"\"\n         return ('location' in self.headers and self.status_code in (codes.moved_permanently, codes.permanent_redirect))\n \n-    @property\n-    def apparent_encoding(self):\n-        \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n-        return chardet.detect(self.content)['encoding']\n+\n+@property\n+def apparent_encoding(self):\n+    \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n+    return chardet.detect(self.content)['encoding']\n \n     def iter_content(self, chunk_size=1, decode_unicode=False):\n         \"\"\"Iterates over the response data.  When stream=True is set on the\n@@ -774,10 +775,12 @@ class Response(object):\n         if not self.content:\n             return str('')\n \n+\n         # Fallback to auto-detected encoding.\n         if self.encoding is None:\n             encoding = self.apparent_encoding\n \n+\n         # Decode unicode from given encoding.\n         try:\n             content = str(self.content, encoding, errors='replace')\ndiff --git a/requests/utils.py b/requests/utils.py\nindex 8d17b6b2..e79cbad3 100644\n--- a/requests/utils.py\n+++ b/requests/utils.py\n@@ -359,12 +359,48 @@ def get_encoding_from_headers(headers):\n def stream_decode_response_unicode(iterator, r):\n     \"\"\"Stream decodes a iterator.\"\"\"\n \n-    if r.encoding is None:\n+\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Stream decodes a iterator.\"\"\"\n+\n+    encoding = r.encoding\n+    if encoding is None:\n+        encoding = r.apparent_encoding\n+\n+    try:\n+        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    except (LookupError, TypeError):\n+        decoder = codecs.getincrementaldecoder('utf-8')(errors='replace')\n+\n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n+\n+\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Stream decodes a iterator.\"\"\"\n+\n+    # Use the same fallback logic as the text property\n+    encoding = r.encoding\n+    if encoding is None:\n+        encoding = r.apparent_encoding\n+\n+    # If we still don't have an encoding, yield raw bytes\n+    if encoding is None:\n         for item in iterator:\n             yield item\n         return\n \n-    decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')\n+    try:\n+        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    except (LookupError, TypeError):\n+        # Fallback to replace mode if encoding is invalid\n+        decoder = codecs.getincrementaldecoder('utf-8')(errors='replace')\n+    \n     for chunk in iterator:\n         rv = decoder.decode(chunk)\n         if rv:\n",
    "variant_8": "diff --git a/requests/models.py b/requests/models.py\nindex fbb3c7e6..9dd2a80e 100644\n--- a/requests/models.py\n+++ b/requests/models.py\n@@ -645,6 +645,7 @@ class Response(object):\n         \"\"\"True if this Response one of the permanent versions of redirect\"\"\"\n         return ('location' in self.headers and self.status_code in (codes.moved_permanently, codes.permanent_redirect))\n \n+\n     @property\n     def apparent_encoding(self):\n         \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n@@ -774,10 +775,12 @@ class Response(object):\n         if not self.content:\n             return str('')\n \n+\n         # Fallback to auto-detected encoding.\n         if self.encoding is None:\n             encoding = self.apparent_encoding\n \n+\n         # Decode unicode from given encoding.\n         try:\n             content = str(self.content, encoding, errors='replace')\ndiff --git a/requests/utils.py b/requests/utils.py\nindex 8d17b6b2..50471430 100644\n--- a/requests/utils.py\n+++ b/requests/utils.py\n@@ -359,12 +359,48 @@ def get_encoding_from_headers(headers):\n def stream_decode_response_unicode(iterator, r):\n     \"\"\"Stream decodes a iterator.\"\"\"\n \n-    if r.encoding is None:\n+\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Stream decodes a iterator.\"\"\"\n+\n+    encoding = r.encoding\n+    if encoding is None:\n+        encoding = r.apparent_encoding\n+\n+    try:\n+        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    except (LookupError, TypeError):\n+        decoder = codecs.getincrementaldecoder('utf-8')(errors='replace')\n+    \n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n+\n+\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Stream decodes a iterator.\"\"\"\n+\n+    # Use the same encoding fallback logic as r.text\n+    encoding = r.encoding\n+    if encoding is None:\n+        encoding = r.apparent_encoding\n+\n+    # If we still don't have an encoding, yield raw bytes\n+    if encoding is None:\n         for item in iterator:\n             yield item\n         return\n \n-    decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')\n+    try:\n+        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    except (LookupError, TypeError):\n+        # Fall back to blind encoding with error replacement\n+        decoder = codecs.getincrementaldecoder('utf-8')(errors='replace')\n+    \n     for chunk in iterator:\n         rv = decoder.decode(chunk)\n         if rv:\n"
  }
}