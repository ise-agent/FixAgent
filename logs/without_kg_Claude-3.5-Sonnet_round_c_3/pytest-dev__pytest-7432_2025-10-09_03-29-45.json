{
  "zero_patches": {
    "Location 1 (/root/hy/projects_3/pytest/src/_pytest/skipping.py lines 273-274)": "\n    elif item.config.option.runxfail:\n        # When runxfail is enabled, we still need to allow skip location correction\n        # to run, so we don't use 'pass' here which would skip all processing\n        if call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n            # Let xfail exceptions be handled normally when runxfail is enabled\n            pass\n",
    "Location 2 (/root/hy/projects_3/pytest/src/_pytest/skipping.py lines 294-305)": "\n    elif (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason\n",
    "Location 3 (/root/hy/projects_3/pytest/src/_pytest/skipping.py lines 261-275)": "\n@hookimpl(hookwrapper=True)\ndef pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n    outcome = yield\n    rep = outcome.get_result()\n    xfailed = item._store.get(xfailed_key, None)\n    # unittest special case, see setting of unexpectedsuccess_key\n    if unexpectedsuccess_key in item._store and rep.when == \"call\":\n        reason = item._store[unexpectedsuccess_key]\n        if reason:\n            rep.longrepr = \"Unexpected success: {}\".format(reason)\n        else:\n            rep.longrepr = \"Unexpected success\"\n        rep.outcome = \"failed\"\n    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n        assert call.excinfo.value.msg is not None\n        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n        rep.outcome = \"skipped\"\n    elif not rep.skipped and xfailed:\n        if call.excinfo:\n            raises = xfailed.raises\n            if raises is not None and not isinstance(call.excinfo.value, raises):\n                rep.outcome = \"failed\"\n            else:\n                rep.outcome = \"skipped\"\n                rep.wasxfail = xfailed.reason\n        else:\n            rep.outcome = \"skipped\"\n            rep.wasxfail = xfailed.reason\n\n    # Always check for skip location correction, independent of runxfail\n    if (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason\n",
    "Location 4 (/root/hy/projects_3/pytest/src/_pytest/skipping.py lines 238-239)": "\n@hookimpl(tryfirst=True)\ndef pytest_runtest_setup(item: Item) -> None:\n    item._store[skipped_by_mark_key] = False\n\n    skipped = evaluate_skip_marks(item)\n    if skipped:\n        item._store[skipped_by_mark_key] = True\n        skip(skipped.reason)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_3/pytest/src/_pytest/skipping.py lines 273-274)": [
      "\n    elif item.config.option.runxfail:\n        # For --runxfail, we still need to allow skip location correction\n        # so don't completely bypass all processing\n        if call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n            # Let xfail exceptions run normally when --runxfail is used\n            pass\n",
      "\n    elif item.config.option.runxfail:\n        # When --runxfail is used, we still need to allow skip location correction\n        # to run, so we don't use 'pass' here which would skip all processing\n        if call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n            # Let xfail exceptions run normally under --runxfail\n            pass\n",
      "\n    elif item.config.option.runxfail:\n        # When runxfail is enabled, don't interfere with xfail processing\n        # but still allow skip location correction to run later\n        pass\n",
      "\n    elif item.config.option.runxfail:\n        # When runxfail is enabled, don't process xfail behavior but still allow\n        # skip location correction to run\n        pass\n",
      "\n    elif item.config.option.runxfail:\n        # When runxfail is enabled, we still need to allow skip location correction\n        # to run, so we don't use 'pass' here which would skip all subsequent processing\n        if call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n            # Let xfail exceptions be handled normally when runxfail is active\n            pass\n",
      "\n    elif item.config.option.runxfail:\n        # When --runxfail is used, we still need to allow skip location correction\n        # to work properly, so we don't use 'pass' here anymore\n        if call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n            # Let xfail exceptions be handled normally when --runxfail is active\n            pass\n",
      "\n    elif item.config.option.runxfail:\n        # When runxfail is enabled, we still need to allow skip location correction\n        # so we don't early exit here - continue to process the skip logic below\n        if not (call.excinfo and isinstance(call.excinfo.value, xfail.Exception)):\n            # Only skip xfail processing, but allow skip location correction\n            pass\n",
      "\n    elif item.config.option.runxfail:\n        # When runxfail is enabled, don't interfere with xfail processing\n        # but still allow skip location correction to run below\n        pass\n    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n        assert call.excinfo.value.msg is not None\n        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n        rep.outcome = \"skipped\"\n    elif not rep.skipped and xfailed:\n        if call.excinfo:\n            raises = xfailed.raises\n            if raises is not None and not isinstance(call.excinfo.value, raises):\n                rep.outcome = \"failed\"\n            else:\n                if xfailed.reason:\n                    rep.wasxfail = \"reason: \" + xfailed.reason\n                else:\n                    rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n                rep.outcome = \"skipped\"\n        elif xfailed.strict:\n            rep.outcome = \"failed\"\n            rep.longrepr = \"[NOTRUN] \" + xfailed.reason\n        else:\n            rep.outcome = \"skipped\"\n            if xfailed.reason:\n                rep.wasxfail = \"reason: \" + xfailed.reason\n            else:\n                rep.wasxfail = \"\"\n\n    # Skip location correction - runs independently of xfail processing\n    if (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason\n"
    ],
    "Location 2 (/root/hy/projects_3/pytest/src/_pytest/skipping.py lines 294-305)": [
      "\n    elif (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason\n",
      "\n    elif (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason\n",
      "\n    elif (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason\n",
      "\n    elif (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason\n",
      "\n    elif (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason\n",
      "\n    elif (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason\n",
      "\n    elif (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason\n",
      "\n    elif (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason\n"
    ],
    "Location 3 (/root/hy/projects_3/pytest/src/_pytest/skipping.py lines 261-275)": [
      "\n@hookimpl(hookwrapper=True)\ndef pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n    outcome = yield\n    rep = outcome.get_result()\n    xfailed = item._store.get(xfailed_key, None)\n    # unittest special case, see setting of unexpectedsuccess_key\n    if unexpectedsuccess_key in item._store and rep.when == \"call\":\n        reason = item._store[unexpectedsuccess_key]\n        if reason:\n            rep.longrepr = \"Unexpected success: {}\".format(reason)\n        else:\n            rep.longrepr = \"Unexpected success\"\n        rep.outcome = \"failed\"\n    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n        assert call.excinfo.value.msg is not None\n        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n        rep.outcome = \"skipped\"\n    elif not rep.skipped and xfailed:\n        if call.excinfo:\n            raises = xfailed.raises\n            if raises is not None and not isinstance(call.excinfo.value, raises):\n                rep.outcome = \"failed\"\n            else:\n                rep.outcome = \"skipped\"\n                rep.wasxfail = xfailed.reason\n        elif call.when == \"call\":\n            rep.outcome = \"skipped\"\n            rep.wasxfail = xfailed.reason\n    elif (\n        call.excinfo\n        and isinstance(call.excinfo.value, skip.Exception)\n        and not item.config.option.runxfail\n    ):\n        assert call.excinfo.value.msg is not None\n        rep.outcome = \"skipped\"\n        rep.longrepr = call.excinfo.value.msg\n\n    # Skip location correction - runs independently of xfail processing\n    if (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason\n",
      "\n@hookimpl(hookwrapper=True)\ndef pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n    outcome = yield\n    rep = outcome.get_result()\n    xfailed = item._store.get(xfailed_key, None)\n    # unittest special case, see setting of unexpectedsuccess_key\n    if unexpectedsuccess_key in item._store and rep.when == \"call\":\n        reason = item._store[unexpectedsuccess_key]\n        if reason:\n            rep.longrepr = \"Unexpected success: {}\".format(reason)\n        else:\n            rep.longrepr = \"Unexpected success\"\n        rep.outcome = \"failed\"\n    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n        assert call.excinfo.value.msg is not None\n        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n        rep.outcome = \"skipped\"\n    elif not rep.skipped and xfailed:\n        if call.excinfo:\n            raises = xfailed.raises\n            if raises is not None and not isinstance(call.excinfo.value, raises):\n                rep.outcome = \"failed\"\n            else:\n                rep.outcome = \"skipped\"\n                rep.wasxfail = \"reason: \" + xfailed.reason\n        else:\n            rep.outcome = \"skipped\"\n            rep.wasxfail = \"reason: \" + xfailed.reason\n\n    # Skip location correction - runs independently of runxfail option\n    if (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason\n",
      "\n@hookimpl(hookwrapper=True)\ndef pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n    outcome = yield\n    rep = outcome.get_result()\n    xfailed = item._store.get(xfailed_key, None)\n    # unittest special case, see setting of unexpectedsuccess_key\n    if unexpectedsuccess_key in item._store and rep.when == \"call\":\n        reason = item._store[unexpectedsuccess_key]\n        if reason:\n            rep.longrepr = \"Unexpected success: {}\".format(reason)\n        else:\n            rep.longrepr = \"Unexpected success\"\n        rep.outcome = \"failed\"\n    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n        assert call.excinfo.value.msg is not None\n        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n        rep.outcome = \"skipped\"\n    elif not rep.skipped and xfailed:\n        if call.excinfo:\n            raises = xfailed.raises\n            if raises is not None and not isinstance(call.excinfo.value, raises):\n                rep.outcome = \"failed\"\n            else:\n                rep.outcome = \"skipped\"\n                rep.wasxfail = xfailed.reason\n        else:\n            rep.outcome = \"skipped\"\n            rep.wasxfail = xfailed.reason\n\n    # Skip location correction - runs independently of --runxfail\n    if (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason\n",
      "\n@hookimpl(hookwrapper=True)\ndef pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n    outcome = yield\n    rep = outcome.get_result()\n    xfailed = item._store.get(xfailed_key, None)\n    # unittest special case, see setting of unexpectedsuccess_key\n    if unexpectedsuccess_key in item._store and rep.when == \"call\":\n        reason = item._store[unexpectedsuccess_key]\n        if reason:\n            rep.longrepr = \"Unexpected success: {}\".format(reason)\n        else:\n            rep.longrepr = \"Unexpected success\"\n        rep.outcome = \"failed\"\n    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n        assert call.excinfo.value.msg is not None\n        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n        rep.outcome = \"skipped\"\n    elif not rep.skipped and xfailed:\n        if call.excinfo:\n            raises = xfailed.raises\n            if raises is not None and not isinstance(call.excinfo.value, raises):\n                rep.outcome = \"failed\"\n            else:\n                rep.outcome = \"skipped\"\n                rep.wasxfail = xfailed.reason\n        elif call.when == \"call\":\n            rep.outcome = \"skipped\"\n            rep.wasxfail = xfailed.reason\n    elif (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason\n\n    # Apply skip location correction independently of runxfail option\n    if (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n        and not hasattr(rep, 'wasxfail')\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason\n",
      "\n@hookimpl(hookwrapper=True)\ndef pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n    outcome = yield\n    rep = outcome.get_result()\n    xfailed = item._store.get(xfailed_key, None)\n    # unittest special case, see setting of unexpectedsuccess_key\n    if unexpectedsuccess_key in item._store and rep.when == \"call\":\n        reason = item._store[unexpectedsuccess_key]\n        if reason:\n            rep.longrepr = \"Unexpected success: {}\".format(reason)\n        else:\n            rep.longrepr = \"Unexpected success\"\n        rep.outcome = \"failed\"\n    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n        assert call.excinfo.value.msg is not None\n        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n        rep.outcome = \"skipped\"\n    elif not rep.skipped and xfailed:\n        if call.excinfo:\n            raises = xfailed.raises\n            if raises is not None and not isinstance(call.excinfo.value, raises):\n                rep.outcome = \"failed\"\n            else:\n                rep.outcome = \"skipped\"\n                rep.wasxfail = xfailed.reason\n        else:\n            rep.outcome = \"skipped\"\n            rep.wasxfail = xfailed.reason\n\n    # Apply skip location correction independently of runxfail processing\n    if (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason\n",
      "\n@hookimpl(hookwrapper=True)\ndef pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n    outcome = yield\n    rep = outcome.get_result()\n    xfailed = item._store.get(xfailed_key, None)\n    # unittest special case, see setting of unexpectedsuccess_key\n    if unexpectedsuccess_key in item._store and rep.when == \"call\":\n        reason = item._store[unexpectedsuccess_key]\n        if reason:\n            rep.longrepr = \"Unexpected success: {}\".format(reason)\n        else:\n            rep.longrepr = \"Unexpected success\"\n        rep.outcome = \"failed\"\n    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n        assert call.excinfo.value.msg is not None\n        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n        rep.outcome = \"skipped\"\n    elif not rep.skipped and xfailed:\n        if call.excinfo:\n            raises = xfailed.raises\n            if raises is not None and not isinstance(call.excinfo.value, raises):\n                rep.outcome = \"failed\"\n            else:\n                rep.outcome = \"skipped\"\n                rep.wasxfail = xfailed.reason\n        else:\n            rep.outcome = \"skipped\"\n            rep.wasxfail = xfailed.reason\n    elif (\n        call.excinfo\n        and isinstance(call.excinfo.value, skip.Exception)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason\n\n    # Skip location correction - runs independently of xfail processing\n    if (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason\n",
      "\n@hookimpl(hookwrapper=True)\ndef pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n    outcome = yield\n    rep = outcome.get_result()\n    xfailed = item._store.get(xfailed_key, None)\n    # unittest special case, see setting of unexpectedsuccess_key\n    if unexpectedsuccess_key in item._store and rep.when == \"call\":\n        reason = item._store[unexpectedsuccess_key]\n        if reason:\n            rep.longrepr = \"Unexpected success: {}\".format(reason)\n        else:\n            rep.longrepr = \"Unexpected success\"\n        rep.outcome = \"failed\"\n    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n        assert call.excinfo.value.msg is not None\n        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n        rep.outcome = \"skipped\"\n    elif not rep.skipped and xfailed:\n        if call.excinfo:\n            raises = xfailed.raises\n            if raises is not None and not isinstance(call.excinfo.value, raises):\n                rep.outcome = \"failed\"\n            else:\n                rep.outcome = \"skipped\"\n                rep.wasxfail = xfailed.reason\n        else:\n            rep.outcome = \"skipped\"\n            rep.wasxfail = xfailed.reason\n\n    # Skip location correction - runs independently of runxfail option\n    if (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason\n",
      "\n@hookimpl(hookwrapper=True)\ndef pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n    outcome = yield\n    rep = outcome.get_result()\n    xfailed = item._store.get(xfailed_key, None)\n    # unittest special case, see setting of unexpectedsuccess_key\n    if unexpectedsuccess_key in item._store and rep.when == \"call\":\n        reason = item._store[unexpectedsuccess_key]\n        if reason:\n            rep.longrepr = \"Unexpected success: {}\".format(reason)\n        else:\n            rep.longrepr = \"Unexpected success\"\n        rep.outcome = \"failed\"\n    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n        assert call.excinfo.value.msg is not None\n        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n        rep.outcome = \"skipped\"\n    elif not rep.skipped and xfailed:\n        if call.excinfo:\n            raises = xfailed.raises\n            if raises is not None and not isinstance(call.excinfo.value, raises):\n                rep.outcome = \"failed\"\n            else:\n                rep.outcome = \"skipped\"\n                rep.wasxfail = xfailed.reason\n        else:\n            rep.outcome = \"skipped\"\n            rep.wasxfail = xfailed.reason\n\n    # Skip location correction - runs independently of xfail processing\n    if (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason\n"
    ],
    "Location 4 (/root/hy/projects_3/pytest/src/_pytest/skipping.py lines 238-239)": [
      "\n@hookimpl(tryfirst=True)\ndef pytest_runtest_setup(item: Item) -> None:\n    item._store[skipped_by_mark_key] = False\n\n    skipped = evaluate_skip_marks(item)\n    if skipped:\n        item._store[skipped_by_mark_key] = True\n        skip(skipped.reason)\n",
      "\n@hookimpl(tryfirst=True)\ndef pytest_runtest_setup(item: Item) -> None:\n    item._store[skipped_by_mark_key] = False\n\n    skipped = evaluate_skip_marks(item)\n    if skipped:\n        item._store[skipped_by_mark_key] = True\n        skip(skipped.reason)\n",
      "\n@hookimpl(tryfirst=True)\ndef pytest_runtest_setup(item: Item) -> None:\n    item._store[skipped_by_mark_key] = False\n\n    skipped = evaluate_skip_marks(item)\n    if skipped:\n        item._store[skipped_by_mark_key] = True\n        skip(skipped.reason)\n",
      "\n@hookimpl(tryfirst=True)\ndef pytest_runtest_setup(item: Item) -> None:\n    item._store[skipped_by_mark_key] = False\n\n    skipped = evaluate_skip_marks(item)\n    if skipped:\n        item._store[skipped_by_mark_key] = True\n        skip(skipped.reason)\n",
      "\n@hookimpl(tryfirst=True)\ndef pytest_runtest_setup(item: Item) -> None:\n    item._store[skipped_by_mark_key] = False\n\n    skipped = evaluate_skip_marks(item)\n    if skipped:\n        item._store[skipped_by_mark_key] = True\n        skip(skipped.reason)\n",
      "\n@hookimpl(tryfirst=True)\ndef pytest_runtest_setup(item: Item) -> None:\n    item._store[skipped_by_mark_key] = False\n\n    skipped = evaluate_skip_marks(item)\n    if skipped:\n        item._store[skipped_by_mark_key] = True\n        skip(skipped.reason)\n",
      "\n@hookimpl(tryfirst=True)\ndef pytest_runtest_setup(item: Item) -> None:\n    item._store[skipped_by_mark_key] = False\n\n    skipped = evaluate_skip_marks(item)\n    if skipped:\n        item._store[skipped_by_mark_key] = True\n        skip(skipped.reason)\n",
      "\n@hookimpl(tryfirst=True)\ndef pytest_runtest_setup(item: Item) -> None:\n    item._store[skipped_by_mark_key] = False\n\n    skipped = evaluate_skip_marks(item)\n    if skipped:\n        item._store[skipped_by_mark_key] = True\n        skip(skipped.reason)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex 7bd975e5a..1dd4f6aea 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -235,6 +235,7 @@ def pytest_runtest_setup(item: Item) -> None:\n \n     skipped = evaluate_skip_marks(item)\n     if skipped:\n+\n         item._store[skipped_by_mark_key] = True\n         skip(skipped.reason)\n \n@@ -258,6 +259,7 @@ def pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n \n \n @hookimpl(hookwrapper=True)\n+\n def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n     outcome = yield\n     rep = outcome.get_result()\n@@ -291,7 +293,42 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n             else:\n                 rep.outcome = \"passed\"\n                 rep.wasxfail = xfailed.reason\n-    elif (\n+\n+    # Skip location correction - moved outside elif chain to run independently of --runxfail\n+    if (\n+        item._store.get(skipped_by_mark_key, True)\n+        and rep.skipped\n+        and type(rep.longrepr) is tuple\n+    ):\n+        # skipped by mark.skipif; change the location of the failure\n+        # to point to the item definition, otherwise it will display\n+        # the location of where the skip exception was raised within pytest\n+        _, _, reason = rep.longrepr\n+        filename, line = item.reportinfo()[:2]\n+        assert line is not None\n+        rep.longrepr = str(filename), line + 1, reason\n+    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n+        assert call.excinfo.value.msg is not None\n+        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n+        rep.outcome = \"skipped\"\n+    elif not rep.skipped and xfailed:\n+        if call.excinfo:\n+            raises = xfailed.raises\n+            if raises is not None and not isinstance(call.excinfo.value, raises):\n+                rep.outcome = \"failed\"\n+            else:\n+                rep.outcome = \"skipped\"\n+                rep.wasxfail = xfailed.reason\n+        elif call.when == \"call\":\n+            if xfailed.strict:\n+                rep.outcome = \"failed\"\n+                rep.longrepr = \"[XPASS(strict)] \" + xfailed.reason\n+            else:\n+                rep.outcome = \"passed\"\n+                rep.wasxfail = xfailed.reason\n+\n+    # Skip location correction - moved outside elif chain to run independently of --runxfail\n+    if (\n         item._store.get(skipped_by_mark_key, True)\n         and rep.skipped\n         and type(rep.longrepr) is tuple\n",
    "variant_0": "diff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex 7bd975e5a..d7c2bf1e0 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -229,6 +229,13 @@ xfailed_key = StoreKey[Optional[Xfail]]()\n unexpectedsuccess_key = StoreKey[str]()\n \n \n+@hookimpl(tryfirst=True)\n+def pytest_runtest_setup(item: Item) -> None:\n+    item._store[skipped_by_mark_key] = False\n+\n+    skipped = evaluate_skip_marks(item)\n+    if skipped:\n+\n @hookimpl(tryfirst=True)\n def pytest_runtest_setup(item: Item) -> None:\n     item._store[skipped_by_mark_key] = False\n@@ -257,6 +264,8 @@ def pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n     yield\n \n \n+@hookimpl(hookwrapper=True)\n+\n @hookimpl(hookwrapper=True)\n def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n     outcome = yield\n@@ -270,8 +279,39 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n         else:\n             rep.longrepr = \"Unexpected success\"\n         rep.outcome = \"failed\"\n-    elif item.config.option.runxfail:\n-        pass  # don't interfere\n+    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n+        assert call.excinfo.value.msg is not None\n+        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n+        rep.outcome = \"skipped\"\n+    elif not rep.skipped and xfailed:\n+        if call.excinfo:\n+            raises = xfailed.raises\n+            if raises is not None and not isinstance(call.excinfo.value, raises):\n+                rep.outcome = \"failed\"\n+            else:\n+                rep.outcome = \"skipped\"\n+                rep.wasxfail = xfailed.reason\n+        else:\n+            rep.outcome = \"skipped\"\n+            rep.wasxfail = xfailed.reason\n+\n+    # Always check for skip location correction, independent of runxfail\n+    if (\n+        item._store.get(skipped_by_mark_key, True)\n+        and rep.skipped\n+        and type(rep.longrepr) is tuple\n+    ):\n+        # skipped by mark.skipif; change the location of the failure\n+        # to point to the item definition, otherwise it will display\n+        # the location of where the skip exception was raised within pytest\n+        _, _, reason = rep.longrepr\n+        filename, line = item.reportinfo()[:2]\n+        assert line is not None\n+        rep.longrepr = str(filename), line + 1, reason\n+        # to run, so we don't use 'pass' here which would skip all processing\n+        if call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n+            # Let xfail exceptions be handled normally when runxfail is enabled\n+            pass\n     elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n         assert call.excinfo.value.msg is not None\n         rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n@@ -291,6 +331,7 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n             else:\n                 rep.outcome = \"passed\"\n                 rep.wasxfail = xfailed.reason\n+\n     elif (\n         item._store.get(skipped_by_mark_key, True)\n         and rep.skipped\n",
    "variant_1": "diff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex 7bd975e5a..6f86febdd 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -229,6 +229,13 @@ xfailed_key = StoreKey[Optional[Xfail]]()\n unexpectedsuccess_key = StoreKey[str]()\n \n \n+@hookimpl(tryfirst=True)\n+def pytest_runtest_setup(item: Item) -> None:\n+    item._store[skipped_by_mark_key] = False\n+\n+    skipped = evaluate_skip_marks(item)\n+    if skipped:\n+\n @hookimpl(tryfirst=True)\n def pytest_runtest_setup(item: Item) -> None:\n     item._store[skipped_by_mark_key] = False\n@@ -257,6 +264,8 @@ def pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n     yield\n \n \n+@hookimpl(hookwrapper=True)\n+\n @hookimpl(hookwrapper=True)\n def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n     outcome = yield\n@@ -270,8 +279,47 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n         else:\n             rep.longrepr = \"Unexpected success\"\n         rep.outcome = \"failed\"\n-    elif item.config.option.runxfail:\n-        pass  # don't interfere\n+    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n+        assert call.excinfo.value.msg is not None\n+        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n+        rep.outcome = \"skipped\"\n+    elif not rep.skipped and xfailed:\n+        if call.excinfo:\n+            raises = xfailed.raises\n+            if raises is not None and not isinstance(call.excinfo.value, raises):\n+                rep.outcome = \"failed\"\n+            else:\n+                rep.outcome = \"skipped\"\n+                rep.wasxfail = xfailed.reason\n+        elif call.when == \"call\":\n+            rep.outcome = \"skipped\"\n+            rep.wasxfail = xfailed.reason\n+    elif (\n+        call.excinfo\n+        and isinstance(call.excinfo.value, skip.Exception)\n+        and not item.config.option.runxfail\n+    ):\n+        assert call.excinfo.value.msg is not None\n+        rep.outcome = \"skipped\"\n+        rep.longrepr = call.excinfo.value.msg\n+\n+    # Skip location correction - runs independently of xfail processing\n+    if (\n+        item._store.get(skipped_by_mark_key, True)\n+        and rep.skipped\n+        and type(rep.longrepr) is tuple\n+    ):\n+        # skipped by mark.skipif; change the location of the failure\n+        # to point to the item definition, otherwise it will display\n+        # the location of where the skip exception was raised within pytest\n+        _, _, reason = rep.longrepr\n+        filename, line = item.reportinfo()[:2]\n+        assert line is not None\n+        rep.longrepr = str(filename), line + 1, reason\n+        # so don't completely bypass all processing\n+        if call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n+            # Let xfail exceptions run normally when --runxfail is used\n+            pass\n     elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n         assert call.excinfo.value.msg is not None\n         rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n@@ -291,6 +339,7 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n             else:\n                 rep.outcome = \"passed\"\n                 rep.wasxfail = xfailed.reason\n+\n     elif (\n         item._store.get(skipped_by_mark_key, True)\n         and rep.skipped\n",
    "variant_2": "diff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex 7bd975e5a..1255e6a0f 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -229,6 +229,13 @@ xfailed_key = StoreKey[Optional[Xfail]]()\n unexpectedsuccess_key = StoreKey[str]()\n \n \n+@hookimpl(tryfirst=True)\n+def pytest_runtest_setup(item: Item) -> None:\n+    item._store[skipped_by_mark_key] = False\n+\n+    skipped = evaluate_skip_marks(item)\n+    if skipped:\n+\n @hookimpl(tryfirst=True)\n def pytest_runtest_setup(item: Item) -> None:\n     item._store[skipped_by_mark_key] = False\n@@ -257,6 +264,8 @@ def pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n     yield\n \n \n+@hookimpl(hookwrapper=True)\n+\n @hookimpl(hookwrapper=True)\n def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n     outcome = yield\n@@ -270,8 +279,39 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n         else:\n             rep.longrepr = \"Unexpected success\"\n         rep.outcome = \"failed\"\n-    elif item.config.option.runxfail:\n-        pass  # don't interfere\n+    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n+        assert call.excinfo.value.msg is not None\n+        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n+        rep.outcome = \"skipped\"\n+    elif not rep.skipped and xfailed:\n+        if call.excinfo:\n+            raises = xfailed.raises\n+            if raises is not None and not isinstance(call.excinfo.value, raises):\n+                rep.outcome = \"failed\"\n+            else:\n+                rep.outcome = \"skipped\"\n+                rep.wasxfail = \"reason: \" + xfailed.reason\n+        else:\n+            rep.outcome = \"skipped\"\n+            rep.wasxfail = \"reason: \" + xfailed.reason\n+\n+    # Skip location correction - runs independently of runxfail option\n+    if (\n+        item._store.get(skipped_by_mark_key, True)\n+        and rep.skipped\n+        and type(rep.longrepr) is tuple\n+    ):\n+        # skipped by mark.skipif; change the location of the failure\n+        # to point to the item definition, otherwise it will display\n+        # the location of where the skip exception was raised within pytest\n+        _, _, reason = rep.longrepr\n+        filename, line = item.reportinfo()[:2]\n+        assert line is not None\n+        rep.longrepr = str(filename), line + 1, reason\n+        # to run, so we don't use 'pass' here which would skip all processing\n+        if call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n+            # Let xfail exceptions run normally under --runxfail\n+            pass\n     elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n         assert call.excinfo.value.msg is not None\n         rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n@@ -291,6 +331,7 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n             else:\n                 rep.outcome = \"passed\"\n                 rep.wasxfail = xfailed.reason\n+\n     elif (\n         item._store.get(skipped_by_mark_key, True)\n         and rep.skipped\n",
    "variant_3": "diff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex 7bd975e5a..c90ad254d 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -229,6 +229,13 @@ xfailed_key = StoreKey[Optional[Xfail]]()\n unexpectedsuccess_key = StoreKey[str]()\n \n \n+@hookimpl(tryfirst=True)\n+def pytest_runtest_setup(item: Item) -> None:\n+    item._store[skipped_by_mark_key] = False\n+\n+    skipped = evaluate_skip_marks(item)\n+    if skipped:\n+\n @hookimpl(tryfirst=True)\n def pytest_runtest_setup(item: Item) -> None:\n     item._store[skipped_by_mark_key] = False\n@@ -257,6 +264,8 @@ def pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n     yield\n \n \n+@hookimpl(hookwrapper=True)\n+\n @hookimpl(hookwrapper=True)\n def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n     outcome = yield\n@@ -270,8 +279,37 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n         else:\n             rep.longrepr = \"Unexpected success\"\n         rep.outcome = \"failed\"\n-    elif item.config.option.runxfail:\n-        pass  # don't interfere\n+    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n+        assert call.excinfo.value.msg is not None\n+        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n+        rep.outcome = \"skipped\"\n+    elif not rep.skipped and xfailed:\n+        if call.excinfo:\n+            raises = xfailed.raises\n+            if raises is not None and not isinstance(call.excinfo.value, raises):\n+                rep.outcome = \"failed\"\n+            else:\n+                rep.outcome = \"skipped\"\n+                rep.wasxfail = xfailed.reason\n+        else:\n+            rep.outcome = \"skipped\"\n+            rep.wasxfail = xfailed.reason\n+\n+    # Skip location correction - runs independently of --runxfail\n+    if (\n+        item._store.get(skipped_by_mark_key, True)\n+        and rep.skipped\n+        and type(rep.longrepr) is tuple\n+    ):\n+        # skipped by mark.skipif; change the location of the failure\n+        # to point to the item definition, otherwise it will display\n+        # the location of where the skip exception was raised within pytest\n+        _, _, reason = rep.longrepr\n+        filename, line = item.reportinfo()[:2]\n+        assert line is not None\n+        rep.longrepr = str(filename), line + 1, reason\n+        # but still allow skip location correction to run later\n+        pass\n     elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n         assert call.excinfo.value.msg is not None\n         rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n@@ -291,6 +329,7 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n             else:\n                 rep.outcome = \"passed\"\n                 rep.wasxfail = xfailed.reason\n+\n     elif (\n         item._store.get(skipped_by_mark_key, True)\n         and rep.skipped\n",
    "variant_4": "diff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex 7bd975e5a..ff750a02f 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -229,6 +229,13 @@ xfailed_key = StoreKey[Optional[Xfail]]()\n unexpectedsuccess_key = StoreKey[str]()\n \n \n+@hookimpl(tryfirst=True)\n+def pytest_runtest_setup(item: Item) -> None:\n+    item._store[skipped_by_mark_key] = False\n+\n+    skipped = evaluate_skip_marks(item)\n+    if skipped:\n+\n @hookimpl(tryfirst=True)\n def pytest_runtest_setup(item: Item) -> None:\n     item._store[skipped_by_mark_key] = False\n@@ -257,6 +264,8 @@ def pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n     yield\n \n \n+@hookimpl(hookwrapper=True)\n+\n @hookimpl(hookwrapper=True)\n def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n     outcome = yield\n@@ -270,8 +279,50 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n         else:\n             rep.longrepr = \"Unexpected success\"\n         rep.outcome = \"failed\"\n-    elif item.config.option.runxfail:\n-        pass  # don't interfere\n+    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n+        assert call.excinfo.value.msg is not None\n+        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n+        rep.outcome = \"skipped\"\n+    elif not rep.skipped and xfailed:\n+        if call.excinfo:\n+            raises = xfailed.raises\n+            if raises is not None and not isinstance(call.excinfo.value, raises):\n+                rep.outcome = \"failed\"\n+            else:\n+                rep.outcome = \"skipped\"\n+                rep.wasxfail = xfailed.reason\n+        elif call.when == \"call\":\n+            rep.outcome = \"skipped\"\n+            rep.wasxfail = xfailed.reason\n+    elif (\n+        item._store.get(skipped_by_mark_key, True)\n+        and rep.skipped\n+        and type(rep.longrepr) is tuple\n+    ):\n+        # skipped by mark.skipif; change the location of the failure\n+        # to point to the item definition, otherwise it will display\n+        # the location of where the skip exception was raised within pytest\n+        _, _, reason = rep.longrepr\n+        filename, line = item.reportinfo()[:2]\n+        assert line is not None\n+        rep.longrepr = str(filename), line + 1, reason\n+\n+    # Apply skip location correction independently of runxfail option\n+    if (\n+        item._store.get(skipped_by_mark_key, True)\n+        and rep.skipped\n+        and type(rep.longrepr) is tuple\n+        and not hasattr(rep, 'wasxfail')\n+    ):\n+        # skipped by mark.skipif; change the location of the failure\n+        # to point to the item definition, otherwise it will display\n+        # the location of where the skip exception was raised within pytest\n+        _, _, reason = rep.longrepr\n+        filename, line = item.reportinfo()[:2]\n+        assert line is not None\n+        rep.longrepr = str(filename), line + 1, reason\n+        # skip location correction to run\n+        pass\n     elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n         assert call.excinfo.value.msg is not None\n         rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n@@ -291,6 +342,7 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n             else:\n                 rep.outcome = \"passed\"\n                 rep.wasxfail = xfailed.reason\n+\n     elif (\n         item._store.get(skipped_by_mark_key, True)\n         and rep.skipped\n",
    "variant_5": "diff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex 7bd975e5a..a6e02c47e 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -229,6 +229,13 @@ xfailed_key = StoreKey[Optional[Xfail]]()\n unexpectedsuccess_key = StoreKey[str]()\n \n \n+@hookimpl(tryfirst=True)\n+def pytest_runtest_setup(item: Item) -> None:\n+    item._store[skipped_by_mark_key] = False\n+\n+    skipped = evaluate_skip_marks(item)\n+    if skipped:\n+\n @hookimpl(tryfirst=True)\n def pytest_runtest_setup(item: Item) -> None:\n     item._store[skipped_by_mark_key] = False\n@@ -257,6 +264,8 @@ def pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n     yield\n \n \n+@hookimpl(hookwrapper=True)\n+\n @hookimpl(hookwrapper=True)\n def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n     outcome = yield\n@@ -270,8 +279,39 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n         else:\n             rep.longrepr = \"Unexpected success\"\n         rep.outcome = \"failed\"\n-    elif item.config.option.runxfail:\n-        pass  # don't interfere\n+    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n+        assert call.excinfo.value.msg is not None\n+        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n+        rep.outcome = \"skipped\"\n+    elif not rep.skipped and xfailed:\n+        if call.excinfo:\n+            raises = xfailed.raises\n+            if raises is not None and not isinstance(call.excinfo.value, raises):\n+                rep.outcome = \"failed\"\n+            else:\n+                rep.outcome = \"skipped\"\n+                rep.wasxfail = xfailed.reason\n+        else:\n+            rep.outcome = \"skipped\"\n+            rep.wasxfail = xfailed.reason\n+\n+    # Apply skip location correction independently of runxfail processing\n+    if (\n+        item._store.get(skipped_by_mark_key, True)\n+        and rep.skipped\n+        and type(rep.longrepr) is tuple\n+    ):\n+        # skipped by mark.skipif; change the location of the failure\n+        # to point to the item definition, otherwise it will display\n+        # the location of where the skip exception was raised within pytest\n+        _, _, reason = rep.longrepr\n+        filename, line = item.reportinfo()[:2]\n+        assert line is not None\n+        rep.longrepr = str(filename), line + 1, reason\n+        # to run, so we don't use 'pass' here which would skip all subsequent processing\n+        if call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n+            # Let xfail exceptions be handled normally when runxfail is active\n+            pass\n     elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n         assert call.excinfo.value.msg is not None\n         rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n@@ -291,6 +331,7 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n             else:\n                 rep.outcome = \"passed\"\n                 rep.wasxfail = xfailed.reason\n+\n     elif (\n         item._store.get(skipped_by_mark_key, True)\n         and rep.skipped\n",
    "variant_6": "diff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex 7bd975e5a..57040edbd 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -229,6 +229,13 @@ xfailed_key = StoreKey[Optional[Xfail]]()\n unexpectedsuccess_key = StoreKey[str]()\n \n \n+@hookimpl(tryfirst=True)\n+def pytest_runtest_setup(item: Item) -> None:\n+    item._store[skipped_by_mark_key] = False\n+\n+    skipped = evaluate_skip_marks(item)\n+    if skipped:\n+\n @hookimpl(tryfirst=True)\n def pytest_runtest_setup(item: Item) -> None:\n     item._store[skipped_by_mark_key] = False\n@@ -257,6 +264,8 @@ def pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n     yield\n \n \n+@hookimpl(hookwrapper=True)\n+\n @hookimpl(hookwrapper=True)\n def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n     outcome = yield\n@@ -270,8 +279,52 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n         else:\n             rep.longrepr = \"Unexpected success\"\n         rep.outcome = \"failed\"\n-    elif item.config.option.runxfail:\n-        pass  # don't interfere\n+    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n+        assert call.excinfo.value.msg is not None\n+        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n+        rep.outcome = \"skipped\"\n+    elif not rep.skipped and xfailed:\n+        if call.excinfo:\n+            raises = xfailed.raises\n+            if raises is not None and not isinstance(call.excinfo.value, raises):\n+                rep.outcome = \"failed\"\n+            else:\n+                rep.outcome = \"skipped\"\n+                rep.wasxfail = xfailed.reason\n+        else:\n+            rep.outcome = \"skipped\"\n+            rep.wasxfail = xfailed.reason\n+    elif (\n+        call.excinfo\n+        and isinstance(call.excinfo.value, skip.Exception)\n+        and rep.skipped\n+        and type(rep.longrepr) is tuple\n+    ):\n+        # skipped by mark.skipif; change the location of the failure\n+        # to point to the item definition, otherwise it will display\n+        # the location of where the skip exception was raised within pytest\n+        _, _, reason = rep.longrepr\n+        filename, line = item.reportinfo()[:2]\n+        assert line is not None\n+        rep.longrepr = str(filename), line + 1, reason\n+\n+    # Skip location correction - runs independently of xfail processing\n+    if (\n+        item._store.get(skipped_by_mark_key, True)\n+        and rep.skipped\n+        and type(rep.longrepr) is tuple\n+    ):\n+        # skipped by mark.skipif; change the location of the failure\n+        # to point to the item definition, otherwise it will display\n+        # the location of where the skip exception was raised within pytest\n+        _, _, reason = rep.longrepr\n+        filename, line = item.reportinfo()[:2]\n+        assert line is not None\n+        rep.longrepr = str(filename), line + 1, reason\n+        # to work properly, so we don't use 'pass' here anymore\n+        if call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n+            # Let xfail exceptions be handled normally when --runxfail is active\n+            pass\n     elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n         assert call.excinfo.value.msg is not None\n         rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n@@ -291,6 +344,7 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n             else:\n                 rep.outcome = \"passed\"\n                 rep.wasxfail = xfailed.reason\n+\n     elif (\n         item._store.get(skipped_by_mark_key, True)\n         and rep.skipped\n",
    "variant_7": "diff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex 7bd975e5a..d4449404f 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -229,6 +229,13 @@ xfailed_key = StoreKey[Optional[Xfail]]()\n unexpectedsuccess_key = StoreKey[str]()\n \n \n+@hookimpl(tryfirst=True)\n+def pytest_runtest_setup(item: Item) -> None:\n+    item._store[skipped_by_mark_key] = False\n+\n+    skipped = evaluate_skip_marks(item)\n+    if skipped:\n+\n @hookimpl(tryfirst=True)\n def pytest_runtest_setup(item: Item) -> None:\n     item._store[skipped_by_mark_key] = False\n@@ -257,6 +264,8 @@ def pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n     yield\n \n \n+@hookimpl(hookwrapper=True)\n+\n @hookimpl(hookwrapper=True)\n def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n     outcome = yield\n@@ -270,8 +279,39 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n         else:\n             rep.longrepr = \"Unexpected success\"\n         rep.outcome = \"failed\"\n-    elif item.config.option.runxfail:\n-        pass  # don't interfere\n+    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n+        assert call.excinfo.value.msg is not None\n+        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n+        rep.outcome = \"skipped\"\n+    elif not rep.skipped and xfailed:\n+        if call.excinfo:\n+            raises = xfailed.raises\n+            if raises is not None and not isinstance(call.excinfo.value, raises):\n+                rep.outcome = \"failed\"\n+            else:\n+                rep.outcome = \"skipped\"\n+                rep.wasxfail = xfailed.reason\n+        else:\n+            rep.outcome = \"skipped\"\n+            rep.wasxfail = xfailed.reason\n+\n+    # Skip location correction - runs independently of runxfail option\n+    if (\n+        item._store.get(skipped_by_mark_key, True)\n+        and rep.skipped\n+        and type(rep.longrepr) is tuple\n+    ):\n+        # skipped by mark.skipif; change the location of the failure\n+        # to point to the item definition, otherwise it will display\n+        # the location of where the skip exception was raised within pytest\n+        _, _, reason = rep.longrepr\n+        filename, line = item.reportinfo()[:2]\n+        assert line is not None\n+        rep.longrepr = str(filename), line + 1, reason\n+        # so we don't early exit here - continue to process the skip logic below\n+        if not (call.excinfo and isinstance(call.excinfo.value, xfail.Exception)):\n+            # Only skip xfail processing, but allow skip location correction\n+            pass\n     elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n         assert call.excinfo.value.msg is not None\n         rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n@@ -291,6 +331,7 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n             else:\n                 rep.outcome = \"passed\"\n                 rep.wasxfail = xfailed.reason\n+\n     elif (\n         item._store.get(skipped_by_mark_key, True)\n         and rep.skipped\n",
    "variant_8": "diff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex 7bd975e5a..767b5dd1e 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -229,6 +229,13 @@ xfailed_key = StoreKey[Optional[Xfail]]()\n unexpectedsuccess_key = StoreKey[str]()\n \n \n+@hookimpl(tryfirst=True)\n+def pytest_runtest_setup(item: Item) -> None:\n+    item._store[skipped_by_mark_key] = False\n+\n+    skipped = evaluate_skip_marks(item)\n+    if skipped:\n+\n @hookimpl(tryfirst=True)\n def pytest_runtest_setup(item: Item) -> None:\n     item._store[skipped_by_mark_key] = False\n@@ -257,6 +264,8 @@ def pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n     yield\n \n \n+@hookimpl(hookwrapper=True)\n+\n @hookimpl(hookwrapper=True)\n def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n     outcome = yield\n@@ -270,8 +279,75 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n         else:\n             rep.longrepr = \"Unexpected success\"\n         rep.outcome = \"failed\"\n-    elif item.config.option.runxfail:\n-        pass  # don't interfere\n+    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n+        assert call.excinfo.value.msg is not None\n+        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n+        rep.outcome = \"skipped\"\n+    elif not rep.skipped and xfailed:\n+        if call.excinfo:\n+            raises = xfailed.raises\n+            if raises is not None and not isinstance(call.excinfo.value, raises):\n+                rep.outcome = \"failed\"\n+            else:\n+                rep.outcome = \"skipped\"\n+                rep.wasxfail = xfailed.reason\n+        else:\n+            rep.outcome = \"skipped\"\n+            rep.wasxfail = xfailed.reason\n+\n+    # Skip location correction - runs independently of xfail processing\n+    if (\n+        item._store.get(skipped_by_mark_key, True)\n+        and rep.skipped\n+        and type(rep.longrepr) is tuple\n+    ):\n+        # skipped by mark.skipif; change the location of the failure\n+        # to point to the item definition, otherwise it will display\n+        # the location of where the skip exception was raised within pytest\n+        _, _, reason = rep.longrepr\n+        filename, line = item.reportinfo()[:2]\n+        assert line is not None\n+        rep.longrepr = str(filename), line + 1, reason\n+        # but still allow skip location correction to run below\n+        pass\n+    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n+        assert call.excinfo.value.msg is not None\n+        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n+        rep.outcome = \"skipped\"\n+    elif not rep.skipped and xfailed:\n+        if call.excinfo:\n+            raises = xfailed.raises\n+            if raises is not None and not isinstance(call.excinfo.value, raises):\n+                rep.outcome = \"failed\"\n+            else:\n+                if xfailed.reason:\n+                    rep.wasxfail = \"reason: \" + xfailed.reason\n+                else:\n+                    rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n+                rep.outcome = \"skipped\"\n+        elif xfailed.strict:\n+            rep.outcome = \"failed\"\n+            rep.longrepr = \"[NOTRUN] \" + xfailed.reason\n+        else:\n+            rep.outcome = \"skipped\"\n+            if xfailed.reason:\n+                rep.wasxfail = \"reason: \" + xfailed.reason\n+            else:\n+                rep.wasxfail = \"\"\n+\n+    # Skip location correction - runs independently of xfail processing\n+    if (\n+        item._store.get(skipped_by_mark_key, True)\n+        and rep.skipped\n+        and type(rep.longrepr) is tuple\n+    ):\n+        # skipped by mark.skipif; change the location of the failure\n+        # to point to the item definition, otherwise it will display\n+        # the location of where the skip exception was raised within pytest\n+        _, _, reason = rep.longrepr\n+        filename, line = item.reportinfo()[:2]\n+        assert line is not None\n+        rep.longrepr = str(filename), line + 1, reason\n     elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n         assert call.excinfo.value.msg is not None\n         rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n@@ -291,6 +367,7 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n             else:\n                 rep.outcome = \"passed\"\n                 rep.wasxfail = xfailed.reason\n+\n     elif (\n         item._store.get(skipped_by_mark_key, True)\n         and rep.skipped\n"
  }
}