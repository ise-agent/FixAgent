{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/matplotlib/lib/matplotlib/colors.py lines 1695-1697)": "\n            t_value = self._trf.transform(value).reshape(np.shape(value))\n            # For LogNorm with nonpositive=\"mask\", check original vmin/vmax validity\n            # instead of just transformed values to handle masking behavior properly\n            if hasattr(self._trf, '_transform') and hasattr(self._trf._transform, '_nonpositive'):\n                # For LogTransform, validate original values are positive\n                if self.vmin <= 0 or self.vmax <= 0:\n                    raise ValueError(\"Invalid vmin or vmax for logarithmic scale\")\n            else:\n                # For other transforms, check transformed values are finite\n                t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n                if not np.isfinite([t_vmin, t_vmax]).all():\n                    raise ValueError(\"Invalid vmin or vmax\")\n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n",
    "Location 2 (/root/hy/projects_2/matplotlib/lib/matplotlib/colors.py lines 1708-1710)": "\n        def inverse(self, value):\n            if not self.scaled():\n                raise ValueError(\"Not invertible until scaled\")\n            if self.vmin > self.vmax:\n                raise ValueError(\"vmin must be less or equal to vmax\")\n            \n            # For LogNorm, check if original vmin/vmax are valid for log transform\n            if hasattr(self._trf, 'base') and hasattr(self._trf, 'nonpositive'):\n                if self.vmin <= 0 or self.vmax <= 0:\n                    raise ValueError(\"Invalid vmin or vmax\")\n            else:\n                t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n                if not np.isfinite([t_vmin, t_vmax]).all():\n                    raise ValueError(\"Invalid vmin or vmax\")\n            \n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n",
    "Location 3 (/root/hy/projects_2/matplotlib/lib/matplotlib/colors.py lines 1674-1676)": "\n        def __call__(self, value, clip=None):\n            value, is_scalar = self.process_value(value)\n            if self.vmin is None or self.vmax is None:\n                self.autoscale_None(value)\n            # For LogNorm, check if vmin/vmax are positive before transform validation\n            if hasattr(self._scale, 'nonpositive') and self._scale.nonpositive == 'mask':\n                if self.vmin is not None and self.vmax is not None:\n                    if self.vmin <= 0 or self.vmax <= 0:\n                        raise ValueError(\"Invalid vmin or vmax\")\n            else:\n                if self.vmin > self.vmax:\n                    raise ValueError(\"vmin must be less or equal to vmax\")\n                t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n                if not np.isfinite([t_vmin, t_vmax]).all():\n                    raise ValueError(\"Invalid vmin or vmax\")\n            t_value = self._trf.transform(value).filled(np.nan)\n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            \n            if clip is None:\n                clip = self.clip\n\n            if clip:\n                t_value = np.clip(t_value, t_vmin, t_vmax)\n\n            # Linearly interpolate the transformed value between 0 and 1.\n            with np.errstate(invalid=\"ignore\", divide=\"ignore\"):\n                if np.any(t_vmax <= t_vmin):\n                    # Avoid zero-division.\n                    return np.full_like(t_value, np.nan)\n                else:\n                    return (t_value - t_vmin) / (t_vmax - t_vmin)\n",
    "Location 4 (/root/hy/projects_2/matplotlib/lib/matplotlib/colors.py lines 1780-1783)": "\nLogNorm = make_norm_from_scale(\n    functools.partial(scale.LogScale, nonpositive=\"mask\"))(Normalize)\nLogNorm.__name__ = LogNorm.__qualname__ = \"LogNorm\"\nLogNorm.__doc__ = \"Normalize a given value to the 0-1 range on a log scale.\"\n",
    "Location 5 (/root/hy/projects_2/matplotlib/lib/matplotlib/scale.py lines 216-236)": "\n    def transform_non_affine(self, a):\n        # Ignore invalid values due to nans being passed to the transform.\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            log = {np.e: np.log, 2: np.log2, 10: np.log10}.get(self.base)\n            if log:  # If possible, do everything in a single call to NumPy.\n                out = log(a)\n            else:\n                out = np.log(a)\n                out /= np.log(self.base)\n            if self._clip:\n                # SVG spec says that conforming viewers must support values up\n                # to 3.4e38 (C float); however experiments suggest that\n                # Inkscape (which uses cairo for rendering) runs into cairo's\n                # 24-bit limit (which is apparently shared by Agg).\n                # Ghostscript (used for pdf rendering appears to overflow even\n                # earlier, with the max value around 2 ** 15 for the tests to\n                # pass. On the other hand, in practice, we want to clip beyond\n                #     np.log10(np.nextafter(0, 1)) ~ -323\n                # so 1000 seems safe.\n                out[a <= 0] = -1000\n            else:\n                # For mask mode, set invalid values to nan instead of -inf\n                # This ensures that validation logic can distinguish between\n                # legitimately transformed values and masked invalid inputs\n                out[a <= 0] = np.nan\n        return out\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/matplotlib/lib/matplotlib/colors.py lines 1695-1697)": [
      "\n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            # For LogNorm with nonpositive=\"mask\", check original values are valid\n            if hasattr(self._trf, 'base') and self.vmin > 0 and self.vmax > 0:\n                # Valid positive values for log transform - proceed even if transform gives non-finite\n                pass\n            elif not np.isfinite([t_vmin, t_vmax]).all():\n                raise ValueError(\"Invalid vmin or vmax\")\n",
      "\n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            # For LogNorm with nonpositive=\"mask\", check original values are positive\n            # before validating transformed values\n            if hasattr(self._trf, 'base') and hasattr(self._trf, 'nonpositive'):\n                # This is a LogTransform - validate original values are positive\n                if self.vmin <= 0 or self.vmax <= 0:\n                    raise ValueError(\"Invalid vmin or vmax for logarithmic scale\")\n            elif not np.isfinite([t_vmin, t_vmax]).all():\n                raise ValueError(\"Invalid vmin or vmax\")\n",
      "\n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            # For LogNorm with nonpositive=\"mask\", check original values are valid for log transform\n            if hasattr(self._trf, 'base') and self.vmin > 0 and self.vmax > 0:\n                # Valid positive values for log transform, proceed even if transform gives non-finite\n                pass\n            elif not np.isfinite([t_vmin, t_vmax]).all():\n                raise ValueError(\"Invalid vmin or vmax\")\n",
      "\n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            # For LogNorm with nonpositive=\"mask\", check original values are positive\n            if hasattr(self._trf, 'base') and hasattr(self._trf, 'nonpositive'):\n                # This is a LogTransform - validate original values are positive\n                if self.vmin <= 0 or self.vmax <= 0:\n                    raise ValueError(\"Invalid vmin or vmax for logarithmic scale\")\n            elif not np.isfinite([t_vmin, t_vmax]).all():\n                raise ValueError(\"Invalid vmin or vmax\")\n",
      "\n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            # For LogNorm with nonpositive=\"mask\", check original values are positive\n            if hasattr(self._trf, 'base') and self.vmin > 0 and self.vmax > 0:\n                # Valid positive values for log transform\n                pass\n            elif not np.isfinite([t_vmin, t_vmax]).all():\n                raise ValueError(\"Invalid vmin or vmax\")\n",
      "\n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            # For LogNorm with nonpositive=\"mask\", check original values are positive\n            # before validating transformed values\n            if hasattr(self._trf, 'base') and hasattr(self._trf, 'nonpositive'):\n                # This is a LogTransform - validate original values are positive\n                if self.vmin <= 0 or self.vmax <= 0:\n                    raise ValueError(\"Invalid vmin or vmax for logarithmic scale\")\n            elif not np.isfinite([t_vmin, t_vmax]).all():\n                raise ValueError(\"Invalid vmin or vmax\")\n",
      "\n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            # For LogNorm with nonpositive=\"mask\", check original values are valid for log transform\n            if hasattr(self._trf, 'base') and self.vmin > 0 and self.vmax > 0:\n                # Valid positive values for log transform, proceed even if transformed values aren't finite\n                pass\n            elif not np.isfinite([t_vmin, t_vmax]).all():\n                raise ValueError(\"Invalid vmin or vmax\")\n",
      "\n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            # For LogNorm with nonpositive=\"mask\", check original values are positive\n            # before validating transformed values\n            if hasattr(self._trf, 'base') and hasattr(self._trf, 'nonpositive'):\n                # This is a LogTransform - validate original values are positive\n                if self.vmin <= 0 or self.vmax <= 0:\n                    raise ValueError(\"Invalid vmin or vmax for logarithmic scale\")\n            elif not np.isfinite([t_vmin, t_vmax]).all():\n                raise ValueError(\"Invalid vmin or vmax\")\n"
    ],
    "Location 2 (/root/hy/projects_2/matplotlib/lib/matplotlib/colors.py lines 1708-1710)": [
      "\n        def inverse(self, value):\n            if not self.scaled():\n                raise ValueError(\"Not invertible until scaled\")\n            if self.vmin > self.vmax:\n                raise ValueError(\"vmin must be less or equal to vmax\")\n            # For LogNorm, check if original vmin/vmax are positive before transform validation\n            if hasattr(self._trf, 'nonpositive') and self._trf.nonpositive == 'mask':\n                if self.vmin <= 0 or self.vmax <= 0:\n                    raise ValueError(\"Invalid vmin or vmax\")\n            else:\n                t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n                if not np.isfinite([t_vmin, t_vmax]).all():\n                    raise ValueError(\"Invalid vmin or vmax\")\n",
      "\n        def inverse(self, value):\n            if not self.scaled():\n                raise ValueError(\"Not invertible until scaled\")\n            if self.vmin > self.vmax:\n                raise ValueError(\"vmin must be less or equal to vmax\")\n            # For LogNorm, check if original vmin/vmax are positive before transform validation\n            if hasattr(self._trf, 'base') and hasattr(self._trf, 'nonpositive'):\n                if self.vmin <= 0 or self.vmax <= 0:\n                    raise ValueError(\"Invalid vmin or vmax for logarithmic scale\")\n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            if not np.isfinite([t_vmin, t_vmax]).all():\n                # Only raise for non-log transforms or when original values are invalid\n                if not (hasattr(self._trf, 'base') and hasattr(self._trf, 'nonpositive')):\n                    raise ValueError(\"Invalid vmin or vmax\")\n",
      "\n        def inverse(self, value):\n            if not self.scaled():\n                raise ValueError(\"Not invertible until scaled\")\n            if self.vmin > self.vmax:\n                raise ValueError(\"vmin must be less or equal to vmax\")\n            # For LogNorm, check if original vmin/vmax are valid for log transform\n            if hasattr(self._trf, '_base') and hasattr(self._trf, '_nonpositive'):\n                if self.vmin <= 0 or self.vmax <= 0:\n                    raise ValueError(\"Invalid vmin or vmax for logarithmic scale\")\n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            if not np.isfinite([t_vmin, t_vmax]).all():\n                # Only raise error if not a LogNorm with nonpositive=\"mask\"\n                if not (hasattr(self._trf, '_base') and hasattr(self._trf, '_nonpositive')):\n                    raise ValueError(\"Invalid vmin or vmax\")\n",
      "\n        def inverse(self, value):\n            if not self.scaled():\n                raise ValueError(\"Not invertible until scaled\")\n            if self.vmin > self.vmax:\n                raise ValueError(\"vmin must be less or equal to vmax\")\n            \n            # For LogNorm, check if original vmin/vmax are valid for log transform\n            if hasattr(self._trf, 'base') and hasattr(self._trf, 'nonpositive'):\n                # This is a LogTransform - validate original values are positive\n                if self.vmin <= 0 or self.vmax <= 0:\n                    raise ValueError(\"Invalid vmin or vmax for logarithmic scale\")\n            \n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            if not np.isfinite([t_vmin, t_vmax]).all():\n                # Only raise error if we're not dealing with LogNorm with nonpositive=\"mask\"\n                if not (hasattr(self._trf, 'base') and hasattr(self._trf, 'nonpositive')):\n                    raise ValueError(\"Invalid vmin or vmax\")\n",
      "\n        def inverse(self, value):\n            if not self.scaled():\n                raise ValueError(\"Not invertible until scaled\")\n            if self.vmin > self.vmax:\n                raise ValueError(\"vmin must be less or equal to vmax\")\n            # For LogNorm, check if original vmin/vmax are valid for log transform\n            if hasattr(self._trf, 'base') and hasattr(self._trf, 'nonpositive'):\n                if self.vmin <= 0 or self.vmax <= 0:\n                    raise ValueError(\"Invalid vmin or vmax for logarithmic scale\")\n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            if not np.isfinite([t_vmin, t_vmax]).all():\n                # Only raise error if original values were also invalid\n                if not (hasattr(self._trf, 'base') and hasattr(self._trf, 'nonpositive')):\n                    raise ValueError(\"Invalid vmin or vmax\")\n",
      "\n        def inverse(self, value):\n            if not self.scaled():\n                raise ValueError(\"Not invertible until scaled\")\n            if self.vmin > self.vmax:\n                raise ValueError(\"vmin must be less or equal to vmax\")\n            # For LogNorm, check if vmin and vmax are positive before transform\n            if hasattr(self._trf, 'base') and self.vmin <= 0:\n                raise ValueError(\"vmin must be positive for logarithmic scale\")\n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            if not np.isfinite([t_vmin, t_vmax]).all():\n                raise ValueError(\"Invalid vmin or vmax\")\n",
      "\n        def inverse(self, value):\n            if not self.scaled():\n                raise ValueError(\"Not invertible until scaled\")\n            if self.vmin > self.vmax:\n                raise ValueError(\"vmin must be less or equal to vmax\")\n            # For LogNorm, check if original vmin/vmax are valid for log transform\n            if hasattr(self._trf, 'nonpositive') and self._trf.nonpositive == 'mask':\n                if self.vmin <= 0 or self.vmax <= 0:\n                    raise ValueError(\"Invalid vmin or vmax for logarithmic scale\")\n            else:\n                t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n                if not np.isfinite([t_vmin, t_vmax]).all():\n                    raise ValueError(\"Invalid vmin or vmax\")\n",
      "\n        def inverse(self, value):\n            if not self.scaled():\n                raise ValueError(\"Not invertible until scaled\")\n            if self.vmin > self.vmax:\n                raise ValueError(\"vmin must be less or equal to vmax\")\n            \n            # For LogNorm, check if original vmin/vmax are positive before transform validation\n            if hasattr(self._trf, 'nonpositive') and self._trf.nonpositive == 'mask':\n                if self.vmin <= 0 or self.vmax <= 0:\n                    raise ValueError(\"Invalid vmin or vmax for logarithmic scale\")\n            \n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            if not np.isfinite([t_vmin, t_vmax]).all():\n                # Only raise error if not using LogNorm with nonpositive='mask'\n                if not (hasattr(self._trf, 'nonpositive') and self._trf.nonpositive == 'mask'):\n                    raise ValueError(\"Invalid vmin or vmax\")\n"
    ],
    "Location 3 (/root/hy/projects_2/matplotlib/lib/matplotlib/colors.py lines 1674-1676)": [
      "\n        def __call__(self, value, clip=None):\n            value, is_scalar = self.process_value(value)\n            if self.vmin is None or self.vmax is None:\n                self.autoscale_None(value)\n            # For LogNorm, check if vmin/vmax are valid for log scale (positive)\n            # before applying transform validation\n            if hasattr(self._scale, 'nonpositive') and self._scale.nonpositive == 'mask':\n                if self.vmin is not None and self.vmax is not None:\n                    if self.vmin <= 0 or self.vmax <= 0:\n                        raise ValueError(\"Invalid vmin or vmax\")\n            else:\n                if self.vmin > self.vmax:\n                    raise ValueError(\"vmin must be less than or equal to vmax\")\n                vmin, vmax = self._trf.transform([self.vmin, self.vmax])\n                if not np.isfinite([vmin, vmax]).all():\n                    raise ValueError(\"Invalid vmin or vmax\")\n            value = self._trf.transform(value)\n            value = np.ma.masked_invalid(value)\n            ret = self._trf.inverted().transform(\n                np.interp(np.ma.filled(value, np.nan),\n                          [vmin if 'vmin' in locals() else self._trf.transform(self.vmin), \n                           vmax if 'vmax' in locals() else self._trf.transform(self.vmax)], \n                          [0, 1]))\n            if is_scalar:\n                ret = ret.item()\n            return ret\n",
      "\n        def __init__(self, *args, **kwargs):\n            ba = bound_init_signature.bind(*args, **kwargs)\n            ba.apply_defaults()\n            super().__init__(\n                **{k: ba.arguments.pop(k) for k in [\"vmin\", \"vmax\", \"clip\"]})\n            # Ensure scale creation handles edge cases properly\n            try:\n                self._scale = functools.partial(\n                    scale_cls, *scale_args, **dict(scale_kwargs_items))(\n                        axis=None, **ba.arguments)\n                self._trf = self._scale.get_transform()\n            except Exception:\n                # Fallback to basic scale creation if advanced options fail\n                self._scale = scale_cls(*scale_args)(axis=None)\n                self._trf = self._scale.get_transform()\n",
      "\n        def __call__(self, value, clip=None):\n            value, is_scalar = self.process_value(value)\n            if self.vmin is None or self.vmax is None:\n                self.autoscale_None(value)\n            # For LogNorm with nonpositive=\"mask\", check if vmin/vmax are valid\n            # for logarithmic transformation (positive) before applying transform validation\n            if hasattr(self._scale, 'nonpositive') and self._scale.nonpositive == \"mask\":\n                if self.vmin is not None and self.vmin <= 0:\n                    raise ValueError(\"Invalid vmin for LogNorm: must be positive\")\n                if self.vmax is not None and self.vmax <= 0:\n                    raise ValueError(\"Invalid vmax for LogNorm: must be positive\")\n            else:\n                if self.vmin > self.vmax:\n                    raise ValueError(\"vmin must be less than or equal to vmax\")\n                vmin, vmax = self._trf.transform([self.vmin, self.vmax])\n                if not np.isfinite([vmin, vmax]).all():\n                    raise ValueError(\"Invalid vmin or vmax\")\n            value = self._trf.transform(value)\n            value = np.ma.masked_invalid(value, copy=False)\n            return self._normalize_vmin_vmax(value, vmin=self._trf.transform(self.vmin),\n                                           vmax=self._trf.transform(self.vmax),\n                                           clip=clip, is_scalar=is_scalar)\n",
      "\n        def __init__(self, *args, **kwargs):\n            ba = bound_init_signature.bind(*args, **kwargs)\n            ba.apply_defaults()\n            super().__init__(\n                **{k: ba.arguments.pop(k) for k in [\"vmin\", \"vmax\", \"clip\"]})\n            self._scale = functools.partial(\n                scale_cls, *scale_args, **dict(scale_kwargs_items))(\n                    axis=None, **ba.arguments)\n            self._trf = self._scale.get_transform()\n",
      "\n        def __call__(self, value, clip=None):\n            value, is_scalar = self.process_value(value)\n            if self.vmin is None or self.vmax is None:\n                self.autoscale_None(value)\n            # For LogNorm, check if vmin/vmax are valid for log scale (positive) before transform validation\n            if hasattr(self._scale, 'base') and self._scale.base is not None:  # LogScale check\n                if self.vmin is not None and self.vmin <= 0:\n                    raise ValueError(\"Invalid vmin for log scale\")\n                if self.vmax is not None and self.vmax <= 0:\n                    raise ValueError(\"Invalid vmax for log scale\")\n            elif self.vmin > self.vmax:\n                raise ValueError(\"vmin must be less than or equal to vmax\")\n            else:\n                # Original validation for non-log scales\n                if self.vmin > self.vmax:\n                    raise ValueError(\"vmin must be less than or equal to vmax\")\n                vmin, vmax = self._trf.transform([self.vmin, self.vmax])\n                if not np.isfinite([vmin, vmax]).all():\n                    raise ValueError(\"Invalid vmin or vmax\")\n",
      "\n        def __call__(self, value, clip=None):\n            value, is_scalar = self.process_value(value)\n            if self.vmin is None or self.vmax is None:\n                self.autoscale_None(value)\n            if self.vmin > self.vmax:\n                raise ValueError(\"vmin must be less than or equal to vmax\")\n            # For LogNorm, check if vmin and vmax are positive before transformation\n            if hasattr(self._scale, 'nonpositive') and self._scale.nonpositive == 'mask':\n                if self.vmin is not None and self.vmin <= 0:\n                    raise ValueError(\"vmin must be positive for logarithmic normalization\")\n                if self.vmax is not None and self.vmax <= 0:\n                    raise ValueError(\"vmax must be positive for logarithmic normalization\")\n            else:\n                # Original validation logic for other normalizations\n                t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n                if not np.isfinite([t_vmin, t_vmax]).all():\n                    raise ValueError(\"Invalid vmin or vmax\")\n            value = self._trf.transform(value).reshape(np.shape(value))\n            value = np.ma.array(value, copy=False)\n            if clip is None:\n                clip = self.clip\n            if clip:\n                value = np.ma.clip(value, t_vmin, t_vmax)\n            # Always fill masked values with 0.\n            return np.ma.filled(value, 0)\n",
      "\n        def __call__(self, value, clip=None):\n            value, is_scalar = self.process_value(value)\n            if self.vmin is None or self.vmax is None:\n                self.autoscale_None(value)\n            # For LogNorm, check if vmin/vmax are valid for log scale before transform validation\n            if hasattr(self._scale, 'nonpositive') and isinstance(self._scale, scale.LogScale):\n                if self.vmin is not None and self.vmin <= 0:\n                    raise ValueError(\"Invalid vmin for LogNorm: vmin must be positive\")\n                if self.vmax is not None and self.vmax <= 0:\n                    raise ValueError(\"Invalid vmax for LogNorm: vmax must be positive\")\n            elif self.vmin > self.vmax:\n                raise ValueError(\"vmin must be less than or equal to vmax\")\n            # Apply transform validation for non-LogNorm or when original values are valid\n            if not (hasattr(self._scale, 'nonpositive') and isinstance(self._scale, scale.LogScale)) or (\n                self.vmin is not None and self.vmin > 0 and self.vmax is not None and self.vmax > 0):\n                if self.vmin > self.vmax:\n                    raise ValueError(\"vmin must be less than or equal to vmax\")\n                t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n                if not np.isfinite([t_vmin, t_vmax]).all():\n                    raise ValueError(\"Invalid vmin or vmax\")\n",
      "\n        def __call__(self, value, clip=None):\n            value, is_scalar = self.process_value(value)\n            if self.vmin is None or self.vmax is None:\n                self.autoscale_None(value)\n            # For LogNorm with nonpositive=\"mask\", check original vmin/vmax validity\n            # before applying transform validation\n            if hasattr(self._scale, 'nonpositive') and self._scale.nonpositive == \"mask\":\n                if self.vmin is not None and self.vmin <= 0:\n                    raise ValueError(\"Invalid vmin for LogNorm: must be positive\")\n                if self.vmax is not None and self.vmax <= 0:\n                    raise ValueError(\"Invalid vmax for LogNorm: must be positive\")\n            else:\n                # Original validation for other scale types\n                if self.vmin > self.vmax:\n                    raise ValueError(\"vmin must be less than or equal to vmax\")\n                t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n                if not np.isfinite([t_vmin, t_vmax]).all():\n                    raise ValueError(\"Invalid vmin or vmax\")\n            \n            if self.vmin > self.vmax:\n                raise ValueError(\"vmin must be less than or equal to vmax\")\n            t_value = self._trf.transform(value)\n            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n            if clip is None:\n                clip = self.clip\n            if clip:\n                t_value = np.clip(t_value, t_vmin, t_vmax)\n            t_value = np.ma.filled(self._trf.inverted().transform(\n                np.interp(t_value, [t_vmin, t_vmax], [0, 1])), np.nan)\n            if is_scalar:\n                t_value = float(t_value)\n            return t_value\n"
    ],
    "Location 4 (/root/hy/projects_2/matplotlib/lib/matplotlib/colors.py lines 1780-1783)": [
      "\nLogNorm = make_norm_from_scale(\n    functools.partial(scale.LogScale, nonpositive=\"mask\"))(Normalize)\nLogNorm.__name__ = LogNorm.__qualname__ = \"LogNorm\"\nLogNorm.__doc__ = \"Normalize a given value to the 0-1 range on a log scale.\"\n",
      "\nLogNorm = make_norm_from_scale(\n    functools.partial(scale.LogScale, nonpositive=\"mask\"))(Normalize)\nLogNorm.__name__ = LogNorm.__qualname__ = \"LogNorm\"\nLogNorm.__doc__ = \"Normalize a given value to the 0-1 range on a log scale.\"\n",
      "\nLogNorm = make_norm_from_scale(\n    functools.partial(scale.LogScale, nonpositive=\"mask\"))(Normalize)\nLogNorm.__name__ = LogNorm.__qualname__ = \"LogNorm\"\nLogNorm.__doc__ = \"Normalize a given value to the 0-1 range on a log scale.\"\n",
      "\nLogNorm = make_norm_from_scale(\n    functools.partial(scale.LogScale, nonpositive=\"mask\"))(Normalize)\nLogNorm.__name__ = LogNorm.__qualname__ = \"LogNorm\"\nLogNorm.__doc__ = \"Normalize a given value to the 0-1 range on a log scale.\"\n",
      "\nLogNorm = make_norm_from_scale(\n    functools.partial(scale.LogScale, nonpositive=\"mask\"))(Normalize)\nLogNorm.__name__ = LogNorm.__qualname__ = \"LogNorm\"\nLogNorm.__doc__ = \"Normalize a given value to the 0-1 range on a log scale.\"\n",
      "\nLogNorm = make_norm_from_scale(\n    functools.partial(scale.LogScale, nonpositive=\"mask\"))(Normalize)\nLogNorm.__name__ = LogNorm.__qualname__ = \"LogNorm\"\nLogNorm.__doc__ = \"Normalize a given value to the 0-1 range on a log scale.\"\n",
      "\nLogNorm = make_norm_from_scale(\n    functools.partial(scale.LogScale, nonpositive=\"mask\"))(Normalize)\nLogNorm.__name__ = LogNorm.__qualname__ = \"LogNorm\"\nLogNorm.__doc__ = \"Normalize a given value to the 0-1 range on a log scale.\"\n",
      "\nLogNorm = make_norm_from_scale(\n    functools.partial(scale.LogScale, nonpositive=\"mask\"))(Normalize)\nLogNorm.__name__ = LogNorm.__qualname__ = \"LogNorm\"\nLogNorm.__doc__ = \"Normalize a given value to the 0-1 range on a log scale.\"\n"
    ],
    "Location 5 (/root/hy/projects_2/matplotlib/lib/matplotlib/scale.py lines 216-236)": [
      "\n    def transform_non_affine(self, a):\n        # Ignore invalid values due to nans being passed to the transform.\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            log = {np.e: np.log, 2: np.log2, 10: np.log10}.get(self.base)\n            if log:  # If possible, do everything in a single call to NumPy.\n                out = log(a)\n            else:\n                out = np.log(a)\n                out /= np.log(self.base)\n            if self._clip:\n                # SVG spec says that conforming viewers must support values up\n                # to 3.4e38 (C float); however experiments suggest that\n                # Inkscape (which uses cairo for rendering) runs into cairo's\n                # 24-bit limit (which is apparently shared by Agg).\n                # Ghostscript (used for pdf rendering appears to overflow even\n                # earlier, with the max value around 2 ** 15 for the tests to\n                # pass. On the other hand, in practice, we want to clip beyond\n                #     np.log10(np.nextafter(0, 1)) ~ -323\n                # so 1000 seems safe.\n                out[a <= 0] = -1000\n            else:\n                # For nonpositive=\"mask\", set non-positive values to NaN\n                # instead of clipping them to a finite value\n                out[a <= 0] = np.nan\n        return out\n",
      "\n    def transform_non_affine(self, a):\n        # Ignore invalid values due to nans being passed to the transform.\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            log = {np.e: np.log, 2: np.log2, 10: np.log10}.get(self.base)\n            if log:  # If possible, do everything in a single call to NumPy.\n                out = log(a)\n            else:\n                out = np.log(a)\n                out /= np.log(self.base)\n            if self._clip:\n                # SVG spec says that conforming viewers must support values up\n                # to 3.4e38 (C float); however experiments suggest that\n                # Inkscape (which uses cairo for rendering) runs into cairo's\n                # 24-bit limit (which is apparently shared by Agg).\n                # Ghostscript (used for pdf rendering appears to overflow even\n                # earlier, with the max value around 2 ** 15 for the tests to\n                # pass. On the other hand, in practice, we want to clip beyond\n                #     np.log10(np.nextafter(0, 1)) ~ -323\n                # so 1000 seems safe.\n                out[a <= 0] = -1000\n            else:\n                # For mask mode, set invalid values to nan instead of clipping\n                out[a <= 0] = np.nan\n        return out\n",
      "\n    def transform_non_affine(self, a):\n        # Ignore invalid values due to nans being passed to the transform.\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            log = {np.e: np.log, 2: np.log2, 10: np.log10}.get(self.base)\n            if log:  # If possible, do everything in a single call to NumPy.\n                out = log(a)\n            else:\n                out = np.log(a)\n                out /= np.log(self.base)\n            if self._clip:\n                # SVG spec says that conforming viewers must support values up\n                # to 3.4e38 (C float); however experiments suggest that\n                # Inkscape (which uses cairo for rendering) runs into cairo's\n                # 24-bit limit (which is apparently shared by Agg).\n                # Ghostscript (used for pdf rendering appears to overflow even\n                # earlier, with the max value around 2 ** 15 for the tests to\n                # pass. On the other hand, in practice, we want to clip beyond\n                #     np.log10(np.nextafter(0, 1)) ~ -323\n                # so 1000 seems safe.\n                out = np.where(a <= 0, -1000, out)\n            else:\n                # For mask mode, set invalid values to NaN instead of clipping\n                out = np.where(a <= 0, np.nan, out)\n        return out\n",
      "\n    def transform_non_affine(self, a):\n        # Ignore invalid values due to nans being passed to the transform.\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            log = {np.e: np.log, 2: np.log2, 10: np.log10}.get(self.base)\n            if log:  # If possible, do everything in a single call to NumPy.\n                out = log(a)\n            else:\n                out = np.log(a)\n                out /= np.log(self.base)\n            if self._clip:\n                # SVG spec says that conforming viewers must support values up\n                # to 3.4e38 (C float); however experiments suggest that\n                # Inkscape (which uses cairo for rendering) runs into cairo's\n                # 24-bit limit (which is apparently shared by Agg).\n                # Ghostscript (used for pdf rendering appears to overflow even\n                # earlier, with the max value around 2 ** 15 for the tests to\n                # pass. On the other hand, in practice, we want to clip beyond\n                #     np.log10(np.nextafter(0, 1)) ~ -323\n                # so 1000 seems safe.\n                out[a <= 0] = -1000\n            else:\n                # For mask mode, set invalid values to NaN instead of clipping\n                out[a <= 0] = np.nan\n        return out\n",
      "\n    def transform_non_affine(self, a):\n        # Ignore invalid values due to nans being passed to the transform.\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            log = {np.e: np.log, 2: np.log2, 10: np.log10}.get(self.base)\n            if log:  # If possible, do everything in a single call to NumPy.\n                out = log(a)\n            else:\n                out = np.log(a)\n                out /= np.log(self.base)\n            if self._clip:\n                # SVG spec says that conforming viewers must support values up\n                # to 3.4e38 (C float); however experiments suggest that\n                # Inkscape (which uses cairo for rendering) runs into cairo's\n                # 24-bit limit (which is apparently shared by Agg).\n                # Ghostscript (used for pdf rendering appears to overflow even\n                # earlier, with the max value around 2 ** 15 for the tests to\n                # pass. On the other hand, in practice, we want to clip beyond\n                #     np.log10(np.nextafter(0, 1)) ~ -323\n                # so 1000 seems safe.\n                out[a <= 0] = -1000\n            else:\n                # For mask mode, set invalid values (non-positive) to NaN\n                out[a <= 0] = np.nan\n        return out\n",
      "\n    def transform_non_affine(self, a):\n        # Ignore invalid values due to nans being passed to the transform.\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            log = {np.e: np.log, 2: np.log2, 10: np.log10}.get(self.base)\n            if log:  # If possible, do everything in a single call to NumPy.\n                out = log(a)\n            else:\n                out = np.log(a)\n                out /= np.log(self.base)\n            if self._clip:\n                # SVG spec says that conforming viewers must support values up\n                # to 3.4e38 (C float); however experiments suggest that\n                # Inkscape (which uses cairo for rendering) runs into cairo's\n                # 24-bit limit (which is apparently shared by Agg).\n                # Ghostscript (used for pdf rendering appears to overflow even\n                # earlier, with the max value around 2 ** 15 for the tests to\n                # pass. On the other hand, in practice, we want to clip beyond\n                #     np.log10(np.nextafter(0, 1)) ~ -323\n                # so 1000 seems safe.\n                out[a <= 0] = -1000\n            else:\n                # For mask mode, set invalid values to NaN instead of clipping\n                out[a <= 0] = np.nan\n        return out\n",
      "\n    def transform_non_affine(self, a):\n        # Ignore invalid values due to nans being passed to the transform.\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            log = {np.e: np.log, 2: np.log2, 10: np.log10}.get(self.base)\n            if log:  # If possible, do everything in a single call to NumPy.\n                out = log(a)\n            else:\n                out = np.log(a)\n                out /= np.log(self.base)\n            if self._clip:\n                # SVG spec says that conforming viewers must support values up\n                # to 3.4e38 (C float); however experiments suggest that\n                # Inkscape (which uses cairo for rendering) runs into cairo's\n                # 24-bit limit (which is apparently shared by Agg).\n                # Ghostscript (used for pdf rendering appears to overflow even\n                # earlier, with the max value around 2 ** 15 for the tests to\n                # pass. On the other hand, in practice, we want to clip beyond\n                #     np.log10(np.nextafter(0, 1)) ~ -323\n                # so 1000 seems safe.\n                out[a <= 0] = -1000\n            else:\n                # For mask mode, set invalid values to NaN instead of clipping\n                out[a <= 0] = np.nan\n        return out\n",
      "\n    def transform_non_affine(self, a):\n        # Ignore invalid values due to nans being passed to the transform.\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            log = {np.e: np.log, 2: np.log2, 10: np.log10}.get(self.base)\n            if log:  # If possible, do everything in a single call to NumPy.\n                out = log(a)\n            else:\n                out = np.log(a)\n                out /= np.log(self.base)\n            if self._clip:\n                # SVG spec says that conforming viewers must support values up\n                # to 3.4e38 (C float); however experiments suggest that\n                # Inkscape (which uses cairo for rendering) runs into cairo's\n                # 24-bit limit (which is apparently shared by Agg).\n                # Ghostscript (used for pdf rendering appears to overflow even\n                # earlier, with the max value around 2 ** 15 for the tests to\n                # pass. On the other hand, in practice, we want to clip beyond\n                #     np.log10(np.nextafter(0, 1)) ~ -323\n                # so 1000 seems safe.\n                out[a <= 0] = -1000\n            else:\n                # For mask mode, set invalid values to NaN instead of clipping\n                out[a <= 0] = np.nan\n        return out\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex f9e4dcbd62..bdaae3b83a 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1671,6 +1671,7 @@ def _make_norm_from_scale(\n             super().__init__(\n                 **{k: ba.arguments.pop(k) for k in [\"vmin\", \"vmax\", \"clip\"]})\n             self._scale = functools.partial(\n+\n                 scale_cls, *scale_args, **dict(scale_kwargs_items))(\n                     axis=None, **ba.arguments)\n             self._trf = self._scale.get_transform()\n@@ -1692,8 +1693,16 @@ def _make_norm_from_scale(\n             if clip:\n                 value = np.clip(value, self.vmin, self.vmax)\n             t_value = self._trf.transform(value).reshape(np.shape(value))\n+\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n-            if not np.isfinite([t_vmin, t_vmax]).all():\n+            # For LogNorm with nonpositive=\"mask\", check original values are valid for log transform\n+            if (hasattr(self._scale, '_transform') and \n+                hasattr(self._scale._transform, '_clip') and \n+                not self._scale._transform._clip):\n+                # For mask mode, validate original values are positive\n+                if self.vmin <= 0 or self.vmax <= 0:\n+                    raise ValueError(\"Invalid vmin or vmax\")\n+            elif not np.isfinite([t_vmin, t_vmax]).all():\n                 raise ValueError(\"Invalid vmin or vmax\")\n             t_value -= t_vmin\n             t_value /= (t_vmax - t_vmin)\n@@ -1705,8 +1714,16 @@ def _make_norm_from_scale(\n                 raise ValueError(\"Not invertible until scaled\")\n             if self.vmin > self.vmax:\n                 raise ValueError(\"vmin must be less or equal to vmax\")\n+\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n-            if not np.isfinite([t_vmin, t_vmax]).all():\n+            # For LogNorm with nonpositive=\"mask\", check original values are valid for log transform\n+            if (hasattr(self._scale, '_transform') and \n+                hasattr(self._scale._transform, '_clip') and \n+                not self._scale._transform._clip):\n+                # For mask mode, validate original values are positive\n+                if self.vmin <= 0 or self.vmax <= 0:\n+                    raise ValueError(\"Invalid vmin or vmax\")\n+            elif not np.isfinite([t_vmin, t_vmax]).all():\n                 raise ValueError(\"Invalid vmin or vmax\")\n             value, is_scalar = self.process_value(value)\n             rescaled = value * (t_vmax - t_vmin)\n@@ -1777,6 +1794,7 @@ class FuncNorm(Normalize):\n     \"\"\"\n \n \n+\n LogNorm = make_norm_from_scale(\n     functools.partial(scale.LogScale, nonpositive=\"mask\"))(Normalize)\n LogNorm.__name__ = LogNorm.__qualname__ = \"LogNorm\"\ndiff --git a/lib/matplotlib/scale.py b/lib/matplotlib/scale.py\nindex e278c7464c..e2d7c504e5 100644\n--- a/lib/matplotlib/scale.py\n+++ b/lib/matplotlib/scale.py\n@@ -213,6 +213,7 @@ class LogTransform(Transform):\n         return \"{}(base={}, nonpositive={!r})\".format(\n             type(self).__name__, self.base, \"clip\" if self._clip else \"mask\")\n \n+\n     def transform_non_affine(self, a):\n         # Ignore invalid values due to nans being passed to the transform.\n         with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n",
    "variant_0": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex f9e4dcbd62..c292547d24 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1671,9 +1671,38 @@ def _make_norm_from_scale(\n             super().__init__(\n                 **{k: ba.arguments.pop(k) for k in [\"vmin\", \"vmax\", \"clip\"]})\n             self._scale = functools.partial(\n-                scale_cls, *scale_args, **dict(scale_kwargs_items))(\n-                    axis=None, **ba.arguments)\n-            self._trf = self._scale.get_transform()\n+\n+        def __call__(self, value, clip=None):\n+            value, is_scalar = self.process_value(value)\n+            if self.vmin is None or self.vmax is None:\n+                self.autoscale_None(value)\n+            # For LogNorm, check if vmin/vmax are positive before transform validation\n+            if hasattr(self._scale, 'nonpositive') and self._scale.nonpositive == 'mask':\n+                if self.vmin is not None and self.vmax is not None:\n+                    if self.vmin <= 0 or self.vmax <= 0:\n+                        raise ValueError(\"Invalid vmin or vmax\")\n+            else:\n+                if self.vmin > self.vmax:\n+                    raise ValueError(\"vmin must be less or equal to vmax\")\n+                t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n+                if not np.isfinite([t_vmin, t_vmax]).all():\n+                    raise ValueError(\"Invalid vmin or vmax\")\n+            t_value = self._trf.transform(value).filled(np.nan)\n+            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n+            \n+            if clip is None:\n+                clip = self.clip\n+\n+            if clip:\n+                t_value = np.clip(t_value, t_vmin, t_vmax)\n+\n+            # Linearly interpolate the transformed value between 0 and 1.\n+            with np.errstate(invalid=\"ignore\", divide=\"ignore\"):\n+                if np.any(t_vmax <= t_vmin):\n+                    # Avoid zero-division.\n+                    return np.full_like(t_value, np.nan)\n+                else:\n+                    return (t_value - t_vmin) / (t_vmax - t_vmin)\n \n         __init__.__signature__ = bound_init_signature.replace(parameters=[\n             inspect.Parameter(\"self\", inspect.Parameter.POSITIONAL_OR_KEYWORD),\n@@ -1692,9 +1721,20 @@ def _make_norm_from_scale(\n             if clip:\n                 value = np.clip(value, self.vmin, self.vmax)\n             t_value = self._trf.transform(value).reshape(np.shape(value))\n+\n+            t_value = self._trf.transform(value).reshape(np.shape(value))\n+            # For LogNorm with nonpositive=\"mask\", check original vmin/vmax validity\n+            # instead of just transformed values to handle masking behavior properly\n+            if hasattr(self._trf, '_transform') and hasattr(self._trf._transform, '_nonpositive'):\n+                # For LogTransform, validate original values are positive\n+                if self.vmin <= 0 or self.vmax <= 0:\n+                    raise ValueError(\"Invalid vmin or vmax for logarithmic scale\")\n+            else:\n+                # For other transforms, check transformed values are finite\n+                t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n+                if not np.isfinite([t_vmin, t_vmax]).all():\n+                    raise ValueError(\"Invalid vmin or vmax\")\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n-            if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n             t_value -= t_vmin\n             t_value /= (t_vmax - t_vmin)\n             t_value = np.ma.masked_invalid(t_value, copy=False)\n@@ -1705,9 +1745,23 @@ def _make_norm_from_scale(\n                 raise ValueError(\"Not invertible until scaled\")\n             if self.vmin > self.vmax:\n                 raise ValueError(\"vmin must be less or equal to vmax\")\n+\n+        def inverse(self, value):\n+            if not self.scaled():\n+                raise ValueError(\"Not invertible until scaled\")\n+            if self.vmin > self.vmax:\n+                raise ValueError(\"vmin must be less or equal to vmax\")\n+            \n+            # For LogNorm, check if original vmin/vmax are valid for log transform\n+            if hasattr(self._trf, 'base') and hasattr(self._trf, 'nonpositive'):\n+                if self.vmin <= 0 or self.vmax <= 0:\n+                    raise ValueError(\"Invalid vmin or vmax\")\n+            else:\n+                t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n+                if not np.isfinite([t_vmin, t_vmax]).all():\n+                    raise ValueError(\"Invalid vmin or vmax\")\n+            \n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n-            if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n             value, is_scalar = self.process_value(value)\n             rescaled = value * (t_vmax - t_vmin)\n             rescaled += t_vmin\n@@ -1777,6 +1831,7 @@ class FuncNorm(Normalize):\n     \"\"\"\n \n \n+\n LogNorm = make_norm_from_scale(\n     functools.partial(scale.LogScale, nonpositive=\"mask\"))(Normalize)\n LogNorm.__name__ = LogNorm.__qualname__ = \"LogNorm\"\ndiff --git a/lib/matplotlib/scale.py b/lib/matplotlib/scale.py\nindex e278c7464c..d230a63dd8 100644\n--- a/lib/matplotlib/scale.py\n+++ b/lib/matplotlib/scale.py\n@@ -213,6 +213,7 @@ class LogTransform(Transform):\n         return \"{}(base={}, nonpositive={!r})\".format(\n             type(self).__name__, self.base, \"clip\" if self._clip else \"mask\")\n \n+\n     def transform_non_affine(self, a):\n         # Ignore invalid values due to nans being passed to the transform.\n         with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n@@ -233,6 +234,11 @@ class LogTransform(Transform):\n                 #     np.log10(np.nextafter(0, 1)) ~ -323\n                 # so 1000 seems safe.\n                 out[a <= 0] = -1000\n+            else:\n+                # For mask mode, set invalid values to nan instead of -inf\n+                # This ensures that validation logic can distinguish between\n+                # legitimately transformed values and masked invalid inputs\n+                out[a <= 0] = np.nan\n         return out\n \n     def inverted(self):\n",
    "variant_1": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex f9e4dcbd62..af65666e37 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1671,9 +1671,33 @@ def _make_norm_from_scale(\n             super().__init__(\n                 **{k: ba.arguments.pop(k) for k in [\"vmin\", \"vmax\", \"clip\"]})\n             self._scale = functools.partial(\n-                scale_cls, *scale_args, **dict(scale_kwargs_items))(\n-                    axis=None, **ba.arguments)\n-            self._trf = self._scale.get_transform()\n+\n+        def __call__(self, value, clip=None):\n+            value, is_scalar = self.process_value(value)\n+            if self.vmin is None or self.vmax is None:\n+                self.autoscale_None(value)\n+            # For LogNorm, check if vmin/vmax are valid for log scale (positive)\n+            # before applying transform validation\n+            if hasattr(self._scale, 'nonpositive') and self._scale.nonpositive == 'mask':\n+                if self.vmin is not None and self.vmax is not None:\n+                    if self.vmin <= 0 or self.vmax <= 0:\n+                        raise ValueError(\"Invalid vmin or vmax\")\n+            else:\n+                if self.vmin > self.vmax:\n+                    raise ValueError(\"vmin must be less than or equal to vmax\")\n+                vmin, vmax = self._trf.transform([self.vmin, self.vmax])\n+                if not np.isfinite([vmin, vmax]).all():\n+                    raise ValueError(\"Invalid vmin or vmax\")\n+            value = self._trf.transform(value)\n+            value = np.ma.masked_invalid(value)\n+            ret = self._trf.inverted().transform(\n+                np.interp(np.ma.filled(value, np.nan),\n+                          [vmin if 'vmin' in locals() else self._trf.transform(self.vmin), \n+                           vmax if 'vmax' in locals() else self._trf.transform(self.vmax)], \n+                          [0, 1]))\n+            if is_scalar:\n+                ret = ret.item()\n+            return ret\n \n         __init__.__signature__ = bound_init_signature.replace(parameters=[\n             inspect.Parameter(\"self\", inspect.Parameter.POSITIONAL_OR_KEYWORD),\n@@ -1692,8 +1716,13 @@ def _make_norm_from_scale(\n             if clip:\n                 value = np.clip(value, self.vmin, self.vmax)\n             t_value = self._trf.transform(value).reshape(np.shape(value))\n+\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n-            if not np.isfinite([t_vmin, t_vmax]).all():\n+            # For LogNorm with nonpositive=\"mask\", check original values are valid\n+            if hasattr(self._trf, 'base') and self.vmin > 0 and self.vmax > 0:\n+                # Valid positive values for log transform - proceed even if transform gives non-finite\n+                pass\n+            elif not np.isfinite([t_vmin, t_vmax]).all():\n                 raise ValueError(\"Invalid vmin or vmax\")\n             t_value -= t_vmin\n             t_value /= (t_vmax - t_vmin)\n@@ -1705,9 +1734,20 @@ def _make_norm_from_scale(\n                 raise ValueError(\"Not invertible until scaled\")\n             if self.vmin > self.vmax:\n                 raise ValueError(\"vmin must be less or equal to vmax\")\n-            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n-            if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n+\n+        def inverse(self, value):\n+            if not self.scaled():\n+                raise ValueError(\"Not invertible until scaled\")\n+            if self.vmin > self.vmax:\n+                raise ValueError(\"vmin must be less or equal to vmax\")\n+            # For LogNorm, check if original vmin/vmax are positive before transform validation\n+            if hasattr(self._trf, 'nonpositive') and self._trf.nonpositive == 'mask':\n+                if self.vmin <= 0 or self.vmax <= 0:\n+                    raise ValueError(\"Invalid vmin or vmax\")\n+            else:\n+                t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n+                if not np.isfinite([t_vmin, t_vmax]).all():\n+                    raise ValueError(\"Invalid vmin or vmax\")\n             value, is_scalar = self.process_value(value)\n             rescaled = value * (t_vmax - t_vmin)\n             rescaled += t_vmin\n@@ -1777,6 +1817,7 @@ class FuncNorm(Normalize):\n     \"\"\"\n \n \n+\n LogNorm = make_norm_from_scale(\n     functools.partial(scale.LogScale, nonpositive=\"mask\"))(Normalize)\n LogNorm.__name__ = LogNorm.__qualname__ = \"LogNorm\"\ndiff --git a/lib/matplotlib/scale.py b/lib/matplotlib/scale.py\nindex e278c7464c..aa58e9b789 100644\n--- a/lib/matplotlib/scale.py\n+++ b/lib/matplotlib/scale.py\n@@ -213,6 +213,7 @@ class LogTransform(Transform):\n         return \"{}(base={}, nonpositive={!r})\".format(\n             type(self).__name__, self.base, \"clip\" if self._clip else \"mask\")\n \n+\n     def transform_non_affine(self, a):\n         # Ignore invalid values due to nans being passed to the transform.\n         with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n@@ -233,6 +234,10 @@ class LogTransform(Transform):\n                 #     np.log10(np.nextafter(0, 1)) ~ -323\n                 # so 1000 seems safe.\n                 out[a <= 0] = -1000\n+            else:\n+                # For nonpositive=\"mask\", set non-positive values to NaN\n+                # instead of clipping them to a finite value\n+                out[a <= 0] = np.nan\n         return out\n \n     def inverted(self):\n",
    "variant_2": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex f9e4dcbd62..f2a6c6ec6e 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1671,9 +1671,22 @@ def _make_norm_from_scale(\n             super().__init__(\n                 **{k: ba.arguments.pop(k) for k in [\"vmin\", \"vmax\", \"clip\"]})\n             self._scale = functools.partial(\n-                scale_cls, *scale_args, **dict(scale_kwargs_items))(\n-                    axis=None, **ba.arguments)\n-            self._trf = self._scale.get_transform()\n+\n+        def __init__(self, *args, **kwargs):\n+            ba = bound_init_signature.bind(*args, **kwargs)\n+            ba.apply_defaults()\n+            super().__init__(\n+                **{k: ba.arguments.pop(k) for k in [\"vmin\", \"vmax\", \"clip\"]})\n+            # Ensure scale creation handles edge cases properly\n+            try:\n+                self._scale = functools.partial(\n+                    scale_cls, *scale_args, **dict(scale_kwargs_items))(\n+                        axis=None, **ba.arguments)\n+                self._trf = self._scale.get_transform()\n+            except Exception:\n+                # Fallback to basic scale creation if advanced options fail\n+                self._scale = scale_cls(*scale_args)(axis=None)\n+                self._trf = self._scale.get_transform()\n \n         __init__.__signature__ = bound_init_signature.replace(parameters=[\n             inspect.Parameter(\"self\", inspect.Parameter.POSITIONAL_OR_KEYWORD),\n@@ -1692,8 +1705,15 @@ def _make_norm_from_scale(\n             if clip:\n                 value = np.clip(value, self.vmin, self.vmax)\n             t_value = self._trf.transform(value).reshape(np.shape(value))\n+\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n-            if not np.isfinite([t_vmin, t_vmax]).all():\n+            # For LogNorm with nonpositive=\"mask\", check original values are positive\n+            # before validating transformed values\n+            if hasattr(self._trf, 'base') and hasattr(self._trf, 'nonpositive'):\n+                # This is a LogTransform - validate original values are positive\n+                if self.vmin <= 0 or self.vmax <= 0:\n+                    raise ValueError(\"Invalid vmin or vmax for logarithmic scale\")\n+            elif not np.isfinite([t_vmin, t_vmax]).all():\n                 raise ValueError(\"Invalid vmin or vmax\")\n             t_value -= t_vmin\n             t_value /= (t_vmax - t_vmin)\n@@ -1705,9 +1725,21 @@ def _make_norm_from_scale(\n                 raise ValueError(\"Not invertible until scaled\")\n             if self.vmin > self.vmax:\n                 raise ValueError(\"vmin must be less or equal to vmax\")\n+\n+        def inverse(self, value):\n+            if not self.scaled():\n+                raise ValueError(\"Not invertible until scaled\")\n+            if self.vmin > self.vmax:\n+                raise ValueError(\"vmin must be less or equal to vmax\")\n+            # For LogNorm, check if original vmin/vmax are positive before transform validation\n+            if hasattr(self._trf, 'base') and hasattr(self._trf, 'nonpositive'):\n+                if self.vmin <= 0 or self.vmax <= 0:\n+                    raise ValueError(\"Invalid vmin or vmax for logarithmic scale\")\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n             if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n+                # Only raise for non-log transforms or when original values are invalid\n+                if not (hasattr(self._trf, 'base') and hasattr(self._trf, 'nonpositive')):\n+                    raise ValueError(\"Invalid vmin or vmax\")\n             value, is_scalar = self.process_value(value)\n             rescaled = value * (t_vmax - t_vmin)\n             rescaled += t_vmin\n@@ -1777,6 +1809,7 @@ class FuncNorm(Normalize):\n     \"\"\"\n \n \n+\n LogNorm = make_norm_from_scale(\n     functools.partial(scale.LogScale, nonpositive=\"mask\"))(Normalize)\n LogNorm.__name__ = LogNorm.__qualname__ = \"LogNorm\"\ndiff --git a/lib/matplotlib/scale.py b/lib/matplotlib/scale.py\nindex e278c7464c..2993cf824a 100644\n--- a/lib/matplotlib/scale.py\n+++ b/lib/matplotlib/scale.py\n@@ -213,6 +213,7 @@ class LogTransform(Transform):\n         return \"{}(base={}, nonpositive={!r})\".format(\n             type(self).__name__, self.base, \"clip\" if self._clip else \"mask\")\n \n+\n     def transform_non_affine(self, a):\n         # Ignore invalid values due to nans being passed to the transform.\n         with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n@@ -233,6 +234,9 @@ class LogTransform(Transform):\n                 #     np.log10(np.nextafter(0, 1)) ~ -323\n                 # so 1000 seems safe.\n                 out[a <= 0] = -1000\n+            else:\n+                # For mask mode, set invalid values to nan instead of clipping\n+                out[a <= 0] = np.nan\n         return out\n \n     def inverted(self):\n",
    "variant_3": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex f9e4dcbd62..ecd3a073c6 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1671,9 +1671,29 @@ def _make_norm_from_scale(\n             super().__init__(\n                 **{k: ba.arguments.pop(k) for k in [\"vmin\", \"vmax\", \"clip\"]})\n             self._scale = functools.partial(\n-                scale_cls, *scale_args, **dict(scale_kwargs_items))(\n-                    axis=None, **ba.arguments)\n-            self._trf = self._scale.get_transform()\n+\n+        def __call__(self, value, clip=None):\n+            value, is_scalar = self.process_value(value)\n+            if self.vmin is None or self.vmax is None:\n+                self.autoscale_None(value)\n+            # For LogNorm with nonpositive=\"mask\", check if vmin/vmax are valid\n+            # for logarithmic transformation (positive) before applying transform validation\n+            if hasattr(self._scale, 'nonpositive') and self._scale.nonpositive == \"mask\":\n+                if self.vmin is not None and self.vmin <= 0:\n+                    raise ValueError(\"Invalid vmin for LogNorm: must be positive\")\n+                if self.vmax is not None and self.vmax <= 0:\n+                    raise ValueError(\"Invalid vmax for LogNorm: must be positive\")\n+            else:\n+                if self.vmin > self.vmax:\n+                    raise ValueError(\"vmin must be less than or equal to vmax\")\n+                vmin, vmax = self._trf.transform([self.vmin, self.vmax])\n+                if not np.isfinite([vmin, vmax]).all():\n+                    raise ValueError(\"Invalid vmin or vmax\")\n+            value = self._trf.transform(value)\n+            value = np.ma.masked_invalid(value, copy=False)\n+            return self._normalize_vmin_vmax(value, vmin=self._trf.transform(self.vmin),\n+                                           vmax=self._trf.transform(self.vmax),\n+                                           clip=clip, is_scalar=is_scalar)\n \n         __init__.__signature__ = bound_init_signature.replace(parameters=[\n             inspect.Parameter(\"self\", inspect.Parameter.POSITIONAL_OR_KEYWORD),\n@@ -1692,8 +1712,13 @@ def _make_norm_from_scale(\n             if clip:\n                 value = np.clip(value, self.vmin, self.vmax)\n             t_value = self._trf.transform(value).reshape(np.shape(value))\n+\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n-            if not np.isfinite([t_vmin, t_vmax]).all():\n+            # For LogNorm with nonpositive=\"mask\", check original values are valid for log transform\n+            if hasattr(self._trf, 'base') and self.vmin > 0 and self.vmax > 0:\n+                # Valid positive values for log transform, proceed even if transform gives non-finite\n+                pass\n+            elif not np.isfinite([t_vmin, t_vmax]).all():\n                 raise ValueError(\"Invalid vmin or vmax\")\n             t_value -= t_vmin\n             t_value /= (t_vmax - t_vmin)\n@@ -1705,9 +1730,21 @@ def _make_norm_from_scale(\n                 raise ValueError(\"Not invertible until scaled\")\n             if self.vmin > self.vmax:\n                 raise ValueError(\"vmin must be less or equal to vmax\")\n+\n+        def inverse(self, value):\n+            if not self.scaled():\n+                raise ValueError(\"Not invertible until scaled\")\n+            if self.vmin > self.vmax:\n+                raise ValueError(\"vmin must be less or equal to vmax\")\n+            # For LogNorm, check if original vmin/vmax are valid for log transform\n+            if hasattr(self._trf, '_base') and hasattr(self._trf, '_nonpositive'):\n+                if self.vmin <= 0 or self.vmax <= 0:\n+                    raise ValueError(\"Invalid vmin or vmax for logarithmic scale\")\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n             if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n+                # Only raise error if not a LogNorm with nonpositive=\"mask\"\n+                if not (hasattr(self._trf, '_base') and hasattr(self._trf, '_nonpositive')):\n+                    raise ValueError(\"Invalid vmin or vmax\")\n             value, is_scalar = self.process_value(value)\n             rescaled = value * (t_vmax - t_vmin)\n             rescaled += t_vmin\n@@ -1777,6 +1814,7 @@ class FuncNorm(Normalize):\n     \"\"\"\n \n \n+\n LogNorm = make_norm_from_scale(\n     functools.partial(scale.LogScale, nonpositive=\"mask\"))(Normalize)\n LogNorm.__name__ = LogNorm.__qualname__ = \"LogNorm\"\ndiff --git a/lib/matplotlib/scale.py b/lib/matplotlib/scale.py\nindex e278c7464c..d161d22c27 100644\n--- a/lib/matplotlib/scale.py\n+++ b/lib/matplotlib/scale.py\n@@ -213,6 +213,7 @@ class LogTransform(Transform):\n         return \"{}(base={}, nonpositive={!r})\".format(\n             type(self).__name__, self.base, \"clip\" if self._clip else \"mask\")\n \n+\n     def transform_non_affine(self, a):\n         # Ignore invalid values due to nans being passed to the transform.\n         with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n@@ -232,7 +233,10 @@ class LogTransform(Transform):\n                 # pass. On the other hand, in practice, we want to clip beyond\n                 #     np.log10(np.nextafter(0, 1)) ~ -323\n                 # so 1000 seems safe.\n-                out[a <= 0] = -1000\n+                out = np.where(a <= 0, -1000, out)\n+            else:\n+                # For mask mode, set invalid values to NaN instead of clipping\n+                out = np.where(a <= 0, np.nan, out)\n         return out\n \n     def inverted(self):\n",
    "variant_4": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex f9e4dcbd62..61c1b72542 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1665,6 +1665,13 @@ def _make_norm_from_scale(\n                      base_norm_cls, bound_init_signature),\n                     vars(self))\n \n+        def __init__(self, *args, **kwargs):\n+            ba = bound_init_signature.bind(*args, **kwargs)\n+            ba.apply_defaults()\n+            super().__init__(\n+                **{k: ba.arguments.pop(k) for k in [\"vmin\", \"vmax\", \"clip\"]})\n+            self._scale = functools.partial(\n+\n         def __init__(self, *args, **kwargs):\n             ba = bound_init_signature.bind(*args, **kwargs)\n             ba.apply_defaults()\n@@ -1692,8 +1699,14 @@ def _make_norm_from_scale(\n             if clip:\n                 value = np.clip(value, self.vmin, self.vmax)\n             t_value = self._trf.transform(value).reshape(np.shape(value))\n+\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n-            if not np.isfinite([t_vmin, t_vmax]).all():\n+            # For LogNorm with nonpositive=\"mask\", check original values are positive\n+            if hasattr(self._trf, 'base') and hasattr(self._trf, 'nonpositive'):\n+                # This is a LogTransform - validate original values are positive\n+                if self.vmin <= 0 or self.vmax <= 0:\n+                    raise ValueError(\"Invalid vmin or vmax for logarithmic scale\")\n+            elif not np.isfinite([t_vmin, t_vmax]).all():\n                 raise ValueError(\"Invalid vmin or vmax\")\n             t_value -= t_vmin\n             t_value /= (t_vmax - t_vmin)\n@@ -1705,9 +1718,24 @@ def _make_norm_from_scale(\n                 raise ValueError(\"Not invertible until scaled\")\n             if self.vmin > self.vmax:\n                 raise ValueError(\"vmin must be less or equal to vmax\")\n+\n+        def inverse(self, value):\n+            if not self.scaled():\n+                raise ValueError(\"Not invertible until scaled\")\n+            if self.vmin > self.vmax:\n+                raise ValueError(\"vmin must be less or equal to vmax\")\n+            \n+            # For LogNorm, check if original vmin/vmax are valid for log transform\n+            if hasattr(self._trf, 'base') and hasattr(self._trf, 'nonpositive'):\n+                # This is a LogTransform - validate original values are positive\n+                if self.vmin <= 0 or self.vmax <= 0:\n+                    raise ValueError(\"Invalid vmin or vmax for logarithmic scale\")\n+            \n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n             if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n+                # Only raise error if we're not dealing with LogNorm with nonpositive=\"mask\"\n+                if not (hasattr(self._trf, 'base') and hasattr(self._trf, 'nonpositive')):\n+                    raise ValueError(\"Invalid vmin or vmax\")\n             value, is_scalar = self.process_value(value)\n             rescaled = value * (t_vmax - t_vmin)\n             rescaled += t_vmin\n@@ -1777,6 +1805,7 @@ class FuncNorm(Normalize):\n     \"\"\"\n \n \n+\n LogNorm = make_norm_from_scale(\n     functools.partial(scale.LogScale, nonpositive=\"mask\"))(Normalize)\n LogNorm.__name__ = LogNorm.__qualname__ = \"LogNorm\"\ndiff --git a/lib/matplotlib/scale.py b/lib/matplotlib/scale.py\nindex e278c7464c..9117c953ad 100644\n--- a/lib/matplotlib/scale.py\n+++ b/lib/matplotlib/scale.py\n@@ -213,6 +213,7 @@ class LogTransform(Transform):\n         return \"{}(base={}, nonpositive={!r})\".format(\n             type(self).__name__, self.base, \"clip\" if self._clip else \"mask\")\n \n+\n     def transform_non_affine(self, a):\n         # Ignore invalid values due to nans being passed to the transform.\n         with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n@@ -233,6 +234,9 @@ class LogTransform(Transform):\n                 #     np.log10(np.nextafter(0, 1)) ~ -323\n                 # so 1000 seems safe.\n                 out[a <= 0] = -1000\n+            else:\n+                # For mask mode, set invalid values to NaN instead of clipping\n+                out[a <= 0] = np.nan\n         return out\n \n     def inverted(self):\n",
    "variant_5": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex f9e4dcbd62..aed5585e01 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1671,9 +1671,26 @@ def _make_norm_from_scale(\n             super().__init__(\n                 **{k: ba.arguments.pop(k) for k in [\"vmin\", \"vmax\", \"clip\"]})\n             self._scale = functools.partial(\n-                scale_cls, *scale_args, **dict(scale_kwargs_items))(\n-                    axis=None, **ba.arguments)\n-            self._trf = self._scale.get_transform()\n+\n+        def __call__(self, value, clip=None):\n+            value, is_scalar = self.process_value(value)\n+            if self.vmin is None or self.vmax is None:\n+                self.autoscale_None(value)\n+            # For LogNorm, check if vmin/vmax are valid for log scale (positive) before transform validation\n+            if hasattr(self._scale, 'base') and self._scale.base is not None:  # LogScale check\n+                if self.vmin is not None and self.vmin <= 0:\n+                    raise ValueError(\"Invalid vmin for log scale\")\n+                if self.vmax is not None and self.vmax <= 0:\n+                    raise ValueError(\"Invalid vmax for log scale\")\n+            elif self.vmin > self.vmax:\n+                raise ValueError(\"vmin must be less than or equal to vmax\")\n+            else:\n+                # Original validation for non-log scales\n+                if self.vmin > self.vmax:\n+                    raise ValueError(\"vmin must be less than or equal to vmax\")\n+                vmin, vmax = self._trf.transform([self.vmin, self.vmax])\n+                if not np.isfinite([vmin, vmax]).all():\n+                    raise ValueError(\"Invalid vmin or vmax\")\n \n         __init__.__signature__ = bound_init_signature.replace(parameters=[\n             inspect.Parameter(\"self\", inspect.Parameter.POSITIONAL_OR_KEYWORD),\n@@ -1692,8 +1709,13 @@ def _make_norm_from_scale(\n             if clip:\n                 value = np.clip(value, self.vmin, self.vmax)\n             t_value = self._trf.transform(value).reshape(np.shape(value))\n+\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n-            if not np.isfinite([t_vmin, t_vmax]).all():\n+            # For LogNorm with nonpositive=\"mask\", check original values are positive\n+            if hasattr(self._trf, 'base') and self.vmin > 0 and self.vmax > 0:\n+                # Valid positive values for log transform\n+                pass\n+            elif not np.isfinite([t_vmin, t_vmax]).all():\n                 raise ValueError(\"Invalid vmin or vmax\")\n             t_value -= t_vmin\n             t_value /= (t_vmax - t_vmin)\n@@ -1705,9 +1727,21 @@ def _make_norm_from_scale(\n                 raise ValueError(\"Not invertible until scaled\")\n             if self.vmin > self.vmax:\n                 raise ValueError(\"vmin must be less or equal to vmax\")\n+\n+        def inverse(self, value):\n+            if not self.scaled():\n+                raise ValueError(\"Not invertible until scaled\")\n+            if self.vmin > self.vmax:\n+                raise ValueError(\"vmin must be less or equal to vmax\")\n+            # For LogNorm, check if original vmin/vmax are valid for log transform\n+            if hasattr(self._trf, 'base') and hasattr(self._trf, 'nonpositive'):\n+                if self.vmin <= 0 or self.vmax <= 0:\n+                    raise ValueError(\"Invalid vmin or vmax for logarithmic scale\")\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n             if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n+                # Only raise error if original values were also invalid\n+                if not (hasattr(self._trf, 'base') and hasattr(self._trf, 'nonpositive')):\n+                    raise ValueError(\"Invalid vmin or vmax\")\n             value, is_scalar = self.process_value(value)\n             rescaled = value * (t_vmax - t_vmin)\n             rescaled += t_vmin\n@@ -1777,6 +1811,7 @@ class FuncNorm(Normalize):\n     \"\"\"\n \n \n+\n LogNorm = make_norm_from_scale(\n     functools.partial(scale.LogScale, nonpositive=\"mask\"))(Normalize)\n LogNorm.__name__ = LogNorm.__qualname__ = \"LogNorm\"\ndiff --git a/lib/matplotlib/scale.py b/lib/matplotlib/scale.py\nindex e278c7464c..ab0a679a9a 100644\n--- a/lib/matplotlib/scale.py\n+++ b/lib/matplotlib/scale.py\n@@ -213,6 +213,7 @@ class LogTransform(Transform):\n         return \"{}(base={}, nonpositive={!r})\".format(\n             type(self).__name__, self.base, \"clip\" if self._clip else \"mask\")\n \n+\n     def transform_non_affine(self, a):\n         # Ignore invalid values due to nans being passed to the transform.\n         with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n@@ -233,6 +234,9 @@ class LogTransform(Transform):\n                 #     np.log10(np.nextafter(0, 1)) ~ -323\n                 # so 1000 seems safe.\n                 out[a <= 0] = -1000\n+            else:\n+                # For mask mode, set invalid values (non-positive) to NaN\n+                out[a <= 0] = np.nan\n         return out\n \n     def inverted(self):\n",
    "variant_6": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex f9e4dcbd62..e317a969b1 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1671,9 +1671,32 @@ def _make_norm_from_scale(\n             super().__init__(\n                 **{k: ba.arguments.pop(k) for k in [\"vmin\", \"vmax\", \"clip\"]})\n             self._scale = functools.partial(\n-                scale_cls, *scale_args, **dict(scale_kwargs_items))(\n-                    axis=None, **ba.arguments)\n-            self._trf = self._scale.get_transform()\n+\n+        def __call__(self, value, clip=None):\n+            value, is_scalar = self.process_value(value)\n+            if self.vmin is None or self.vmax is None:\n+                self.autoscale_None(value)\n+            if self.vmin > self.vmax:\n+                raise ValueError(\"vmin must be less than or equal to vmax\")\n+            # For LogNorm, check if vmin and vmax are positive before transformation\n+            if hasattr(self._scale, 'nonpositive') and self._scale.nonpositive == 'mask':\n+                if self.vmin is not None and self.vmin <= 0:\n+                    raise ValueError(\"vmin must be positive for logarithmic normalization\")\n+                if self.vmax is not None and self.vmax <= 0:\n+                    raise ValueError(\"vmax must be positive for logarithmic normalization\")\n+            else:\n+                # Original validation logic for other normalizations\n+                t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n+                if not np.isfinite([t_vmin, t_vmax]).all():\n+                    raise ValueError(\"Invalid vmin or vmax\")\n+            value = self._trf.transform(value).reshape(np.shape(value))\n+            value = np.ma.array(value, copy=False)\n+            if clip is None:\n+                clip = self.clip\n+            if clip:\n+                value = np.ma.clip(value, t_vmin, t_vmax)\n+            # Always fill masked values with 0.\n+            return np.ma.filled(value, 0)\n \n         __init__.__signature__ = bound_init_signature.replace(parameters=[\n             inspect.Parameter(\"self\", inspect.Parameter.POSITIONAL_OR_KEYWORD),\n@@ -1692,8 +1715,15 @@ def _make_norm_from_scale(\n             if clip:\n                 value = np.clip(value, self.vmin, self.vmax)\n             t_value = self._trf.transform(value).reshape(np.shape(value))\n+\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n-            if not np.isfinite([t_vmin, t_vmax]).all():\n+            # For LogNorm with nonpositive=\"mask\", check original values are positive\n+            # before validating transformed values\n+            if hasattr(self._trf, 'base') and hasattr(self._trf, 'nonpositive'):\n+                # This is a LogTransform - validate original values are positive\n+                if self.vmin <= 0 or self.vmax <= 0:\n+                    raise ValueError(\"Invalid vmin or vmax for logarithmic scale\")\n+            elif not np.isfinite([t_vmin, t_vmax]).all():\n                 raise ValueError(\"Invalid vmin or vmax\")\n             t_value -= t_vmin\n             t_value /= (t_vmax - t_vmin)\n@@ -1705,6 +1735,15 @@ def _make_norm_from_scale(\n                 raise ValueError(\"Not invertible until scaled\")\n             if self.vmin > self.vmax:\n                 raise ValueError(\"vmin must be less or equal to vmax\")\n+\n+        def inverse(self, value):\n+            if not self.scaled():\n+                raise ValueError(\"Not invertible until scaled\")\n+            if self.vmin > self.vmax:\n+                raise ValueError(\"vmin must be less or equal to vmax\")\n+            # For LogNorm, check if vmin and vmax are positive before transform\n+            if hasattr(self._trf, 'base') and self.vmin <= 0:\n+                raise ValueError(\"vmin must be positive for logarithmic scale\")\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n             if not np.isfinite([t_vmin, t_vmax]).all():\n                 raise ValueError(\"Invalid vmin or vmax\")\n@@ -1777,6 +1816,7 @@ class FuncNorm(Normalize):\n     \"\"\"\n \n \n+\n LogNorm = make_norm_from_scale(\n     functools.partial(scale.LogScale, nonpositive=\"mask\"))(Normalize)\n LogNorm.__name__ = LogNorm.__qualname__ = \"LogNorm\"\ndiff --git a/lib/matplotlib/scale.py b/lib/matplotlib/scale.py\nindex e278c7464c..9117c953ad 100644\n--- a/lib/matplotlib/scale.py\n+++ b/lib/matplotlib/scale.py\n@@ -213,6 +213,7 @@ class LogTransform(Transform):\n         return \"{}(base={}, nonpositive={!r})\".format(\n             type(self).__name__, self.base, \"clip\" if self._clip else \"mask\")\n \n+\n     def transform_non_affine(self, a):\n         # Ignore invalid values due to nans being passed to the transform.\n         with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n@@ -233,6 +234,9 @@ class LogTransform(Transform):\n                 #     np.log10(np.nextafter(0, 1)) ~ -323\n                 # so 1000 seems safe.\n                 out[a <= 0] = -1000\n+            else:\n+                # For mask mode, set invalid values to NaN instead of clipping\n+                out[a <= 0] = np.nan\n         return out\n \n     def inverted(self):\n",
    "variant_7": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex f9e4dcbd62..95719dc38e 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1671,9 +1671,27 @@ def _make_norm_from_scale(\n             super().__init__(\n                 **{k: ba.arguments.pop(k) for k in [\"vmin\", \"vmax\", \"clip\"]})\n             self._scale = functools.partial(\n-                scale_cls, *scale_args, **dict(scale_kwargs_items))(\n-                    axis=None, **ba.arguments)\n-            self._trf = self._scale.get_transform()\n+\n+        def __call__(self, value, clip=None):\n+            value, is_scalar = self.process_value(value)\n+            if self.vmin is None or self.vmax is None:\n+                self.autoscale_None(value)\n+            # For LogNorm, check if vmin/vmax are valid for log scale before transform validation\n+            if hasattr(self._scale, 'nonpositive') and isinstance(self._scale, scale.LogScale):\n+                if self.vmin is not None and self.vmin <= 0:\n+                    raise ValueError(\"Invalid vmin for LogNorm: vmin must be positive\")\n+                if self.vmax is not None and self.vmax <= 0:\n+                    raise ValueError(\"Invalid vmax for LogNorm: vmax must be positive\")\n+            elif self.vmin > self.vmax:\n+                raise ValueError(\"vmin must be less than or equal to vmax\")\n+            # Apply transform validation for non-LogNorm or when original values are valid\n+            if not (hasattr(self._scale, 'nonpositive') and isinstance(self._scale, scale.LogScale)) or (\n+                self.vmin is not None and self.vmin > 0 and self.vmax is not None and self.vmax > 0):\n+                if self.vmin > self.vmax:\n+                    raise ValueError(\"vmin must be less than or equal to vmax\")\n+                t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n+                if not np.isfinite([t_vmin, t_vmax]).all():\n+                    raise ValueError(\"Invalid vmin or vmax\")\n \n         __init__.__signature__ = bound_init_signature.replace(parameters=[\n             inspect.Parameter(\"self\", inspect.Parameter.POSITIONAL_OR_KEYWORD),\n@@ -1692,8 +1710,13 @@ def _make_norm_from_scale(\n             if clip:\n                 value = np.clip(value, self.vmin, self.vmax)\n             t_value = self._trf.transform(value).reshape(np.shape(value))\n+\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n-            if not np.isfinite([t_vmin, t_vmax]).all():\n+            # For LogNorm with nonpositive=\"mask\", check original values are valid for log transform\n+            if hasattr(self._trf, 'base') and self.vmin > 0 and self.vmax > 0:\n+                # Valid positive values for log transform, proceed even if transformed values aren't finite\n+                pass\n+            elif not np.isfinite([t_vmin, t_vmax]).all():\n                 raise ValueError(\"Invalid vmin or vmax\")\n             t_value -= t_vmin\n             t_value /= (t_vmax - t_vmin)\n@@ -1705,9 +1728,20 @@ def _make_norm_from_scale(\n                 raise ValueError(\"Not invertible until scaled\")\n             if self.vmin > self.vmax:\n                 raise ValueError(\"vmin must be less or equal to vmax\")\n-            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n-            if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n+\n+        def inverse(self, value):\n+            if not self.scaled():\n+                raise ValueError(\"Not invertible until scaled\")\n+            if self.vmin > self.vmax:\n+                raise ValueError(\"vmin must be less or equal to vmax\")\n+            # For LogNorm, check if original vmin/vmax are valid for log transform\n+            if hasattr(self._trf, 'nonpositive') and self._trf.nonpositive == 'mask':\n+                if self.vmin <= 0 or self.vmax <= 0:\n+                    raise ValueError(\"Invalid vmin or vmax for logarithmic scale\")\n+            else:\n+                t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n+                if not np.isfinite([t_vmin, t_vmax]).all():\n+                    raise ValueError(\"Invalid vmin or vmax\")\n             value, is_scalar = self.process_value(value)\n             rescaled = value * (t_vmax - t_vmin)\n             rescaled += t_vmin\n@@ -1777,6 +1811,7 @@ class FuncNorm(Normalize):\n     \"\"\"\n \n \n+\n LogNorm = make_norm_from_scale(\n     functools.partial(scale.LogScale, nonpositive=\"mask\"))(Normalize)\n LogNorm.__name__ = LogNorm.__qualname__ = \"LogNorm\"\ndiff --git a/lib/matplotlib/scale.py b/lib/matplotlib/scale.py\nindex e278c7464c..9117c953ad 100644\n--- a/lib/matplotlib/scale.py\n+++ b/lib/matplotlib/scale.py\n@@ -213,6 +213,7 @@ class LogTransform(Transform):\n         return \"{}(base={}, nonpositive={!r})\".format(\n             type(self).__name__, self.base, \"clip\" if self._clip else \"mask\")\n \n+\n     def transform_non_affine(self, a):\n         # Ignore invalid values due to nans being passed to the transform.\n         with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n@@ -233,6 +234,9 @@ class LogTransform(Transform):\n                 #     np.log10(np.nextafter(0, 1)) ~ -323\n                 # so 1000 seems safe.\n                 out[a <= 0] = -1000\n+            else:\n+                # For mask mode, set invalid values to NaN instead of clipping\n+                out[a <= 0] = np.nan\n         return out\n \n     def inverted(self):\n",
    "variant_8": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex f9e4dcbd62..39e99c675a 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1671,9 +1671,39 @@ def _make_norm_from_scale(\n             super().__init__(\n                 **{k: ba.arguments.pop(k) for k in [\"vmin\", \"vmax\", \"clip\"]})\n             self._scale = functools.partial(\n-                scale_cls, *scale_args, **dict(scale_kwargs_items))(\n-                    axis=None, **ba.arguments)\n-            self._trf = self._scale.get_transform()\n+\n+        def __call__(self, value, clip=None):\n+            value, is_scalar = self.process_value(value)\n+            if self.vmin is None or self.vmax is None:\n+                self.autoscale_None(value)\n+            # For LogNorm with nonpositive=\"mask\", check original vmin/vmax validity\n+            # before applying transform validation\n+            if hasattr(self._scale, 'nonpositive') and self._scale.nonpositive == \"mask\":\n+                if self.vmin is not None and self.vmin <= 0:\n+                    raise ValueError(\"Invalid vmin for LogNorm: must be positive\")\n+                if self.vmax is not None and self.vmax <= 0:\n+                    raise ValueError(\"Invalid vmax for LogNorm: must be positive\")\n+            else:\n+                # Original validation for other scale types\n+                if self.vmin > self.vmax:\n+                    raise ValueError(\"vmin must be less than or equal to vmax\")\n+                t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n+                if not np.isfinite([t_vmin, t_vmax]).all():\n+                    raise ValueError(\"Invalid vmin or vmax\")\n+            \n+            if self.vmin > self.vmax:\n+                raise ValueError(\"vmin must be less than or equal to vmax\")\n+            t_value = self._trf.transform(value)\n+            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n+            if clip is None:\n+                clip = self.clip\n+            if clip:\n+                t_value = np.clip(t_value, t_vmin, t_vmax)\n+            t_value = np.ma.filled(self._trf.inverted().transform(\n+                np.interp(t_value, [t_vmin, t_vmax], [0, 1])), np.nan)\n+            if is_scalar:\n+                t_value = float(t_value)\n+            return t_value\n \n         __init__.__signature__ = bound_init_signature.replace(parameters=[\n             inspect.Parameter(\"self\", inspect.Parameter.POSITIONAL_OR_KEYWORD),\n@@ -1692,8 +1722,15 @@ def _make_norm_from_scale(\n             if clip:\n                 value = np.clip(value, self.vmin, self.vmax)\n             t_value = self._trf.transform(value).reshape(np.shape(value))\n+\n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n-            if not np.isfinite([t_vmin, t_vmax]).all():\n+            # For LogNorm with nonpositive=\"mask\", check original values are positive\n+            # before validating transformed values\n+            if hasattr(self._trf, 'base') and hasattr(self._trf, 'nonpositive'):\n+                # This is a LogTransform - validate original values are positive\n+                if self.vmin <= 0 or self.vmax <= 0:\n+                    raise ValueError(\"Invalid vmin or vmax for logarithmic scale\")\n+            elif not np.isfinite([t_vmin, t_vmax]).all():\n                 raise ValueError(\"Invalid vmin or vmax\")\n             t_value -= t_vmin\n             t_value /= (t_vmax - t_vmin)\n@@ -1705,9 +1742,23 @@ def _make_norm_from_scale(\n                 raise ValueError(\"Not invertible until scaled\")\n             if self.vmin > self.vmax:\n                 raise ValueError(\"vmin must be less or equal to vmax\")\n+\n+        def inverse(self, value):\n+            if not self.scaled():\n+                raise ValueError(\"Not invertible until scaled\")\n+            if self.vmin > self.vmax:\n+                raise ValueError(\"vmin must be less or equal to vmax\")\n+            \n+            # For LogNorm, check if original vmin/vmax are positive before transform validation\n+            if hasattr(self._trf, 'nonpositive') and self._trf.nonpositive == 'mask':\n+                if self.vmin <= 0 or self.vmax <= 0:\n+                    raise ValueError(\"Invalid vmin or vmax for logarithmic scale\")\n+            \n             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n             if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n+                # Only raise error if not using LogNorm with nonpositive='mask'\n+                if not (hasattr(self._trf, 'nonpositive') and self._trf.nonpositive == 'mask'):\n+                    raise ValueError(\"Invalid vmin or vmax\")\n             value, is_scalar = self.process_value(value)\n             rescaled = value * (t_vmax - t_vmin)\n             rescaled += t_vmin\n@@ -1777,6 +1828,7 @@ class FuncNorm(Normalize):\n     \"\"\"\n \n \n+\n LogNorm = make_norm_from_scale(\n     functools.partial(scale.LogScale, nonpositive=\"mask\"))(Normalize)\n LogNorm.__name__ = LogNorm.__qualname__ = \"LogNorm\"\ndiff --git a/lib/matplotlib/scale.py b/lib/matplotlib/scale.py\nindex e278c7464c..9117c953ad 100644\n--- a/lib/matplotlib/scale.py\n+++ b/lib/matplotlib/scale.py\n@@ -213,6 +213,7 @@ class LogTransform(Transform):\n         return \"{}(base={}, nonpositive={!r})\".format(\n             type(self).__name__, self.base, \"clip\" if self._clip else \"mask\")\n \n+\n     def transform_non_affine(self, a):\n         # Ignore invalid values due to nans being passed to the transform.\n         with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n@@ -233,6 +234,9 @@ class LogTransform(Transform):\n                 #     np.log10(np.nextafter(0, 1)) ~ -323\n                 # so 1000 seems safe.\n                 out[a <= 0] = -1000\n+            else:\n+                # For mask mode, set invalid values to NaN instead of clipping\n+                out[a <= 0] = np.nan\n         return out\n \n     def inverted(self):\n"
  }
}