{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/django/django/db/backends/sqlite3/creation.py lines 23-49)": "\ndef _create_test_db(self, verbosity, autoclobber, keepdb=False):\n    test_database_name = self._get_test_db_name()\n\n    if keepdb:\n        # When keepdb is True and we're using a file-based database,\n        # ensure any existing connections are properly closed to prevent locking\n        if not self.is_in_memory_db(test_database_name):\n            # Close the current connection to avoid SQLite locking issues\n            if self.connection.connection is not None:\n                self.connection.close()\n            \n            # Also close any other connections to this database in the connection handler\n            from django.db import connections\n            for alias, conn in connections.all():\n                if (hasattr(conn, 'settings_dict') and \n                    conn.settings_dict.get('NAME') == test_database_name and\n                    conn.connection is not None):\n                    conn.close()\n        \n        return test_database_name\n    \n    if not self.is_in_memory_db(test_database_name):\n        # Erase the old test database\n        if verbosity >= 1:\n            self.log('Destroying old test database for alias %s...' % (\n                self._get_database_display_str(verbosity, test_database_name),\n            ))\n        if os.access(test_database_name, os.F_OK):\n            if not autoclobber:\n                confirm = input(\n                    \"Type 'yes' if you would like to try deleting the test \"\n                    \"database '%s', or 'no' to cancel: \" % test_database_name\n                )\n            if autoclobber or confirm == 'yes':\n                try:\n                    os.remove(test_database_name)\n                except Exception as e:\n                    self.log('Got an error deleting the old test database: %s' % e)\n                    sys.exit(2)\n            else:\n                self.log('Tests cancelled.')\n                sys.exit(1)\n    return test_database_name\n",
    "Location 2 (/root/hy/projects_2/django/django/test/utils.py lines 154-195)": "\ndef setup_databases(verbosity, interactive, keepdb=False, debug_sql=False, parallel=0, aliases=None, **kwargs):\n    \"\"\"Create the test databases.\"\"\"\n    test_databases, mirrored_aliases = get_unique_databases_and_mirrors(aliases)\n\n    old_names = []\n\n    for db_name, aliases in test_databases.values():\n        first_alias = None\n        for alias in aliases:\n            connection = connections[alias]\n            old_names.append((connection, db_name, first_alias is None))\n\n            # Actually create the database for the first connection\n            if first_alias is None:\n                first_alias = alias\n                # For SQLite with keepdb, ensure existing connections are closed\n                # to prevent file locking issues\n                if keepdb and connection.vendor == 'sqlite':\n                    # Close any existing connection to the database file\n                    if connection.connection is not None:\n                        connection.close()\n                    # Also close any other connections that might be using the same database file\n                    test_db_name = connection.creation._get_test_db_name()\n                    for conn_alias in connections:\n                        other_conn = connections[conn_alias]\n                        if (other_conn.vendor == 'sqlite' and \n                            other_conn.connection is not None and\n                            other_conn.creation._get_test_db_name() == test_db_name):\n                            other_conn.close()\n                \n                connection.creation.create_test_db(\n                    verbosity=verbosity,\n                    autoclobber=not interactive,\n                    keepdb=keepdb,\n                    serialize=connection.settings_dict.get('TEST', {}).get('SERIALIZE', True),\n                )\n                if parallel > 1:\n                    for index in range(parallel):\n                        connection.creation.clone_test_db(\n                            suffix=str(index + 1),\n                            verbosity=verbosity,\n                            keepdb=keepdb,\n                        )\n            # Configure all other connections as mirrors of the first one\n            else:\n                connections[alias].creation.set_as_test_mirror(connections[first_alias].settings_dict)\n\n    # Configure the test mirrors.\n    for alias, mirror_alias in mirrored_aliases.items():\n        connections[alias].creation.set_as_test_mirror(\n            connections[mirror_alias].settings_dict)\n\n    if debug_sql:\n        for alias in connections:\n            connections[alias].force_debug_cursor = True\n\n    return old_names\n",
    "Location 3 (/root/hy/projects_2/django/django/db/backends/sqlite3/base.py lines 261-267)": "\n    @async_unsafe\n    def close(self):\n        self.validate_thread_sharing()\n        # If database is in memory, closing the connection destroys the\n        # database. To prevent accidental data loss, ignore close requests on\n        # an in-memory db.\n        if not self.is_in_memory_db():\n            # For persistent test databases, ensure complete connection cleanup\n            # to prevent SQLite file locking issues\n            if hasattr(self, 'connection') and self.connection:\n                try:\n                    # Commit any pending transactions before closing\n                    if not self.connection.in_transaction:\n                        self.connection.commit()\n                    # Close the connection properly\n                    self.connection.close()\n                except Database.Error:\n                    # Ignore errors during cleanup\n                    pass\n                finally:\n                    self.connection = None\n            BaseDatabaseWrapper.close(self)\n",
    "Location 4 (/root/hy/projects_2/django/tests/admin_views/test_multidb.py lines 34-44)": "\n    @classmethod\n    def setUpTestData(cls):\n        cls.superusers = {}\n        cls.test_book_ids = {}\n        for db in connections:\n            Router.target_db = db\n            # Ensure connection is properly established before creating objects\n            connection = connections[db]\n            connection.ensure_connection()\n            cls.superusers[db] = User.objects.create_superuser(\n                username='admin', password='something', email='test@test.org',\n            )\n            b = Book(name='Test Book')\n            b.save(using=db)\n            cls.test_book_ids[db] = b.id\n",
    "Location 5 (/root/hy/projects_2/django/django/test/testcases.py lines 1078-1092)": "\n@classmethod\ndef _enter_atomics(cls):\n    \"\"\"Open atomic blocks for multiple databases.\"\"\"\n    atomics = {}\n    for db_name in cls._databases_names():\n        # For SQLite with persistent databases, ensure connection is fresh\n        if hasattr(connections[db_name], 'ensure_connection'):\n            connections[db_name].ensure_connection()\n        atomics[db_name] = transaction.atomic(using=db_name)\n        atomics[db_name].__enter__()\n    return atomics\n\n@classmethod\ndef _rollback_atomics(cls, atomics):\n    \"\"\"Rollback atomic blocks opened by the previous method.\"\"\"\n    for db_name in reversed(cls._databases_names()):\n        transaction.set_rollback(True, using=db_name)\n        atomics[db_name].__exit__(None, None, None)\n        # For SQLite with persistent databases, ensure clean connection state\n        if (hasattr(connections[db_name].vendor, '__eq__') and \n            connections[db_name].vendor == 'sqlite' and\n            hasattr(connections[db_name], 'close_if_unusable_or_obsolete')):\n            connections[db_name].close_if_unusable_or_obsolete()\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/django/django/db/backends/sqlite3/creation.py lines 23-49)": [
      "\ndef _create_test_db(self, verbosity, autoclobber, keepdb=False):\n    test_database_name = self._get_test_db_name()\n\n    if keepdb:\n        # When keeping the database, ensure any existing connections are closed\n        # to prevent SQLite locking issues\n        if not self.is_in_memory_db(test_database_name):\n            # Close any existing connections to this database file\n            from django.db import connections\n            for alias, conn in connections.all():\n                if (hasattr(conn, 'settings_dict') and \n                    conn.settings_dict.get('NAME') == test_database_name and\n                    conn.connection is not None):\n                    conn.close()\n        return test_database_name\n    if not self.is_in_memory_db(test_database_name):\n        # Erase the old test database\n        if verbosity >= 1:\n            self.log('Destroying old test database for alias %s...' % (\n                self._get_database_display_str(verbosity, test_database_name),\n            ))\n        if os.access(test_database_name, os.F_OK):\n            if not autoclobber:\n                confirm = input(\n                    \"Type 'yes' if you would like to try deleting the test \"\n                    \"database '%s', or 'no' to cancel: \" % test_database_name\n                )\n            if autoclobber or confirm == 'yes':\n                try:\n                    os.remove(test_database_name)\n                except Exception as e:\n                    self.log('Got an error deleting the old test database: %s' % e)\n                    sys.exit(2)\n            else:\n                self.log('Tests cancelled.')\n                sys.exit(1)\n    return test_database_name\n",
      "\ndef _create_test_db(self, verbosity, autoclobber, keepdb=False):\n    test_database_name = self._get_test_db_name()\n\n    if keepdb:\n        # When keeping the database, ensure any existing connections are closed\n        # to prevent SQLite file locking issues\n        if not self.is_in_memory_db(test_database_name):\n            # Close any existing connections to this database file\n            from django.db import connections\n            for alias, conn in connections.all():\n                if (hasattr(conn, 'settings_dict') and \n                    conn.settings_dict.get('NAME') == test_database_name and\n                    conn.connection is not None):\n                    try:\n                        conn.close()\n                    except Exception:\n                        pass  # Ignore errors when closing stale connections\n        return test_database_name\n        \n    if not self.is_in_memory_db(test_database_name):\n        # Erase the old test database\n        if verbosity >= 1:\n            self.log('Destroying old test database for alias %s...' % (\n                self._get_database_display_str(verbosity, test_database_name),\n            ))\n        if os.access(test_database_name, os.F_OK):\n            if not autoclobber:\n                confirm = input(\n                    \"Type 'yes' if you would like to try deleting the test \"\n                    \"database '%s', or 'no' to cancel: \" % test_database_name\n                )\n            if autoclobber or confirm == 'yes':\n                try:\n                    os.remove(test_database_name)\n                except Exception as e:\n                    self.log('Got an error deleting the old test database: %s' % e)\n                    sys.exit(2)\n            else:\n                self.log('Tests cancelled.')\n                sys.exit(1)\n    return test_database_name\n",
      "\n    def _create_test_db(self, verbosity, autoclobber, keepdb=False):\n        test_database_name = self._get_test_db_name()\n\n        if keepdb:\n            # When keepdb is True, ensure any existing connections are properly closed\n            # to prevent SQLite file locking issues\n            if not self.is_in_memory_db(test_database_name):\n                # Close the current connection to release any file locks\n                if hasattr(self.connection, '_close'):\n                    self.connection._close()\n                # Also ensure the connection wrapper is reset\n                self.connection.close()\n                # Verify the database file is accessible\n                if os.access(test_database_name, os.F_OK):\n                    # Test that we can open and close the database to ensure no locks\n                    try:\n                        test_conn = self.connection.__class__(\n                            self.connection.settings_dict.copy(),\n                            alias=self.connection.alias + '_test_access'\n                        )\n                        test_conn.ensure_connection()\n                        test_conn.close()\n                    except Exception as e:\n                        self.log('Warning: Could not verify test database access: %s' % e)\n            return test_database_name\n            \n        if not self.is_in_memory_db(test_database_name):\n            # Erase the old test database\n            if verbosity >= 1:\n                self.log('Destroying old test database for alias %s...' % (\n                    self._get_database_display_str(verbosity, test_database_name),\n                ))\n            if os.access(test_database_name, os.F_OK):\n                if not autoclobber:\n                    confirm = input(\n                        \"Type 'yes' if you would like to try deleting the test \"\n                        \"database '%s', or 'no' to cancel: \" % test_database_name\n                    )\n                if autoclobber or confirm == 'yes':\n                    try:\n                        os.remove(test_database_name)\n                    except Exception as e:\n                        self.log('Got an error deleting the old test database: %s' % e)\n                        sys.exit(2)\n                else:\n                    self.log('Tests cancelled.')\n                    sys.exit(1)\n        return test_database_name\n",
      "\n    def _create_test_db(self, verbosity, autoclobber, keepdb=False):\n        test_database_name = self._get_test_db_name()\n\n        if keepdb:\n            # For persistent test databases, ensure any existing connections are properly closed\n            if not self.is_in_memory_db(test_database_name):\n                # Close any existing connections to this database to prevent SQLite locks\n                from django.db import connections\n                for conn_alias, conn in connections.all():\n                    if (hasattr(conn, 'settings_dict') and \n                        conn.settings_dict.get('ENGINE') == 'django.db.backends.sqlite3' and\n                        conn.settings_dict.get('NAME') == test_database_name):\n                        conn.close()\n            return test_database_name\n        if not self.is_in_memory_db(test_database_name):\n            # Erase the old test database\n            if verbosity >= 1:\n                self.log('Destroying old test database for alias %s...' % (\n                    self._get_database_display_str(verbosity, test_database_name),\n                ))\n            if os.access(test_database_name, os.F_OK):\n                if not autoclobber:\n                    confirm = input(\n                        \"Type 'yes' if you would like to try deleting the test \"\n                        \"database '%s', or 'no' to cancel: \" % test_database_name\n                    )\n                if autoclobber or confirm == 'yes':\n                    try:\n                        os.remove(test_database_name)\n                    except Exception as e:\n                        self.log('Got an error deleting the old test database: %s' % e)\n                        sys.exit(2)\n                else:\n                    self.log('Tests cancelled.')\n                    sys.exit(1)\n        return test_database_name\n",
      "\n    def _create_test_db(self, verbosity, autoclobber, keepdb=False):\n        test_database_name = self._get_test_db_name()\n\n        if keepdb:\n            # When keeping the database, ensure any existing connections are closed\n            # to prevent SQLite file locking issues\n            if not self.is_in_memory_db(test_database_name):\n                # Close any existing connections to this database file\n                from django.db import connections\n                for alias, conn in connections.all():\n                    if (hasattr(conn, 'settings_dict') and \n                        conn.settings_dict.get('NAME') == test_database_name and\n                        conn.connection is not None):\n                        conn.close()\n            return test_database_name\n        if not self.is_in_memory_db(test_database_name):\n            # Erase the old test database\n            if verbosity >= 1:\n                self.log('Destroying old test database for alias %s...' % (\n                    self._get_database_display_str(verbosity, test_database_name),\n                ))\n            if os.access(test_database_name, os.F_OK):\n                if not autoclobber:\n                    confirm = input(\n                        \"Type 'yes' if you would like to try deleting the test \"\n                        \"database '%s', or 'no' to cancel: \" % test_database_name\n                    )\n                if autoclobber or confirm == 'yes':\n                    try:\n                        os.remove(test_database_name)\n                    except Exception as e:\n                        self.log('Got an error deleting the old test database: %s' % e)\n                        sys.exit(2)\n                else:\n                    self.log('Tests cancelled.')\n                    sys.exit(1)\n        return test_database_name\n",
      "\n    def _create_test_db(self, verbosity, autoclobber, keepdb=False):\n        test_database_name = self._get_test_db_name()\n\n        if keepdb:\n            # When keeping the database, ensure any existing connections are closed\n            # to prevent SQLite file locking issues\n            if not self.is_in_memory_db(test_database_name):\n                # Close any existing connections to this database file\n                from django.db import connections\n                for alias, conn in connections.all():\n                    if (hasattr(conn, 'settings_dict') and \n                        conn.settings_dict.get('NAME') == test_database_name):\n                        conn.close()\n                \n                # Verify the database file is accessible\n                if os.path.exists(test_database_name):\n                    try:\n                        # Test file access to ensure it's not locked\n                        with open(test_database_name, 'r+b'):\n                            pass\n                    except (OSError, IOError) as e:\n                        if verbosity >= 1:\n                            self.log('Warning: Test database file may be locked: %s' % e)\n            return test_database_name\n            \n        if not self.is_in_memory_db(test_database_name):\n            # Erase the old test database\n            if verbosity >= 1:\n                self.log('Destroying old test database for alias %s...' % (\n                    self._get_database_display_str(verbosity, test_database_name),\n                ))\n            if os.access(test_database_name, os.F_OK):\n                if not autoclobber:\n                    confirm = input(\n                        \"Type 'yes' if you would like to try deleting the test \"\n                        \"database '%s', or 'no' to cancel: \" % test_database_name\n                    )\n                if autoclobber or confirm == 'yes':\n                    try:\n                        os.remove(test_database_name)\n                    except Exception as e:\n                        self.log('Got an error deleting the old test database: %s' % e)\n                        sys.exit(2)\n                else:\n                    self.log('Tests cancelled.')\n                    sys.exit(1)\n        return test_database_name\n",
      "\n    def _create_test_db(self, verbosity, autoclobber, keepdb=False):\n        test_database_name = self._get_test_db_name()\n\n        if keepdb:\n            # When keeping the database, ensure any existing connections are closed\n            # to prevent SQLite file locking issues\n            if not self.is_in_memory_db(test_database_name):\n                # Close any existing connections to this database file\n                from django.db import connections\n                for alias, conn in connections.all():\n                    if (hasattr(conn, 'settings_dict') and \n                        conn.settings_dict.get('NAME') == test_database_name):\n                        conn.close()\n                \n                # Verify the database file is accessible\n                if os.access(test_database_name, os.F_OK):\n                    try:\n                        # Test that we can open the database without locks\n                        import sqlite3\n                        test_conn = sqlite3.connect(test_database_name, timeout=1.0)\n                        test_conn.close()\n                    except sqlite3.OperationalError as e:\n                        if 'locked' in str(e).lower():\n                            self.log('Database file is locked, cannot reuse: %s' % e)\n                            sys.exit(2)\n                        # Re-raise other operational errors\n                        raise\n            return test_database_name\n            \n        if not self.is_in_memory_db(test_database_name):\n            # Erase the old test database\n            if verbosity >= 1:\n                self.log('Destroying old test database for alias %s...' % (\n                    self._get_database_display_str(verbosity, test_database_name),\n                ))\n            if os.access(test_database_name, os.F_OK):\n                if not autoclobber:\n                    confirm = input(\n                        \"Type 'yes' if you would like to try deleting the test \"\n                        \"database '%s', or 'no' to cancel: \" % test_database_name\n                    )\n                if autoclobber or confirm == 'yes':\n                    try:\n                        os.remove(test_database_name)\n                    except Exception as e:\n                        self.log('Got an error deleting the old test database: %s' % e)\n                        sys.exit(2)\n                else:\n                    self.log('Tests cancelled.')\n                    sys.exit(1)\n        return test_database_name\n",
      "\n    def _create_test_db(self, verbosity, autoclobber, keepdb=False):\n        test_database_name = self._get_test_db_name()\n\n        if keepdb:\n            # When keeping the database, ensure any existing connections are closed\n            # to prevent SQLite file locking issues\n            if not self.is_in_memory_db(test_database_name):\n                # Close the current connection if it exists\n                if hasattr(self.connection, 'connection') and self.connection.connection:\n                    self.connection.close()\n                \n                # Import here to avoid circular imports\n                from django.db import connections\n                \n                # Close any other connections to this database file\n                for alias, conn in connections.all():\n                    if (hasattr(conn, 'settings_dict') and \n                        conn.settings_dict.get('NAME') == test_database_name and\n                        hasattr(conn, 'connection') and conn.connection):\n                        conn.close()\n            return test_database_name\n            \n        if not self.is_in_memory_db(test_database_name):\n            # Erase the old test database\n            if verbosity >= 1:\n                self.log('Destroying old test database for alias %s...' % (\n                    self._get_database_display_str(verbosity, test_database_name),\n                ))\n            if os.access(test_database_name, os.F_OK):\n                if not autoclobber:\n                    confirm = input(\n                        \"Type 'yes' if you would like to try deleting the test \"\n                        \"database '%s', or 'no' to cancel: \" % test_database_name\n                    )\n                if autoclobber or confirm == 'yes':\n                    try:\n                        os.remove(test_database_name)\n                    except Exception as e:\n                        self.log('Got an error deleting the old test database: %s' % e)\n                        sys.exit(2)\n                else:\n                    self.log('Tests cancelled.')\n                    sys.exit(1)\n        return test_database_name\n"
    ],
    "Location 2 (/root/hy/projects_2/django/django/test/utils.py lines 154-195)": [
      "\ndef setup_databases(verbosity, interactive, keepdb=False, debug_sql=False, parallel=0, aliases=None, **kwargs):\n    \"\"\"Create the test databases.\"\"\"\n    test_databases, mirrored_aliases = get_unique_databases_and_mirrors(aliases)\n\n    old_names = []\n\n    for db_name, aliases in test_databases.values():\n        first_alias = None\n        for alias in aliases:\n            connection = connections[alias]\n            old_names.append((connection, db_name, first_alias is None))\n\n            # Actually create the database for the first connection\n            if first_alias is None:\n                first_alias = alias\n                \n                # For SQLite with keepdb, ensure any existing connections are closed\n                # to prevent database locking issues\n                if keepdb and connection.vendor == 'sqlite':\n                    # Close any existing connection to the database file\n                    if hasattr(connection, 'close'):\n                        connection.close()\n                    # Reset the connection to ensure clean state\n                    connection.connect()\n                \n                connection.creation.create_test_db(\n                    verbosity=verbosity,\n                    autoclobber=not interactive,\n                    keepdb=keepdb,\n                    serialize=connection.settings_dict.get('TEST', {}).get('SERIALIZE', True),\n                )\n                if parallel > 1:\n                    for index in range(parallel):\n                        connection.creation.clone_test_db(\n                            suffix=str(index + 1),\n                            verbosity=verbosity,\n                            keepdb=keepdb,\n                        )\n            # Configure all other connections as mirrors of the first one\n            else:\n                # For SQLite mirrors with keepdb, also ensure clean connection state\n                if keepdb and connections[alias].vendor == 'sqlite':\n                    if hasattr(connections[alias], 'close'):\n                        connections[alias].close()\n                connections[alias].creation.set_as_test_mirror(connections[first_alias].settings_dict)\n\n    # Configure the test mirrors.\n    for alias, mirror_alias in mirrored_aliases.items():\n        # For SQLite mirrors with keepdb, ensure clean connection state\n        if keepdb and connections[alias].vendor == 'sqlite':\n            if hasattr(connections[alias], 'close'):\n                connections[alias].close()\n        connections[alias].creation.set_as_test_mirror(\n            connections[mirror_alias].settings_dict)\n\n    if debug_sql:\n        for alias in connections:\n            connections[alias].force_debug_cursor = True\n\n    return old_names\n",
      "\ndef setup_databases(verbosity, interactive, keepdb=False, debug_sql=False, parallel=0, aliases=None, **kwargs):\n    \"\"\"Create the test databases.\"\"\"\n    test_databases, mirrored_aliases = get_unique_databases_and_mirrors(aliases)\n\n    old_names = []\n\n    for db_name, aliases in test_databases.values():\n        first_alias = None\n        for alias in aliases:\n            connection = connections[alias]\n            old_names.append((connection, db_name, first_alias is None))\n\n            # For SQLite with keepdb, ensure existing connections are closed\n            # to prevent database locking issues\n            if keepdb and connection.vendor == 'sqlite':\n                # Close any existing connection to the database file\n                if connection.connection is not None:\n                    connection.close()\n                # Force a fresh connection setup\n                connection.ensure_connection()\n\n            # Actually create the database for the first connection\n            if first_alias is None:\n                first_alias = alias\n                connection.creation.create_test_db(\n                    verbosity=verbosity,\n                    autoclobber=not interactive,\n                    keepdb=keepdb,\n                    serialize=connection.settings_dict.get('TEST', {}).get('SERIALIZE', True),\n                )\n                if parallel > 1:\n                    for index in range(parallel):\n                        connection.creation.clone_test_db(\n                            suffix=str(index + 1),\n                            verbosity=verbosity,\n                            keepdb=keepdb,\n                        )\n            # Configure all other connections as mirrors of the first one\n            else:\n                connections[alias].creation.set_as_test_mirror(connections[first_alias].settings_dict)\n\n    # Configure the test mirrors.\n    for alias, mirror_alias in mirrored_aliases.items():\n        connections[alias].creation.set_as_test_mirror(\n            connections[mirror_alias].settings_dict)\n\n    if debug_sql:\n        for alias in connections:\n            connections[alias].force_debug_cursor = True\n\n    return old_names\n",
      "\ndef setup_databases(verbosity, interactive, keepdb=False, debug_sql=False, parallel=0, aliases=None, **kwargs):\n    \"\"\"Create the test databases.\"\"\"\n    test_databases, mirrored_aliases = get_unique_databases_and_mirrors(aliases)\n\n    old_names = []\n\n    for db_name, aliases in test_databases.values():\n        first_alias = None\n        for alias in aliases:\n            connection = connections[alias]\n            old_names.append((connection, db_name, first_alias is None))\n\n            # Actually create the database for the first connection\n            if first_alias is None:\n                first_alias = alias\n                \n                # For SQLite with keepdb, ensure any existing connections are closed\n                # to prevent file locking issues\n                if keepdb and connection.vendor == 'sqlite':\n                    # Close the connection if it's open\n                    if hasattr(connection, 'connection') and connection.connection is not None:\n                        connection.close()\n                    \n                    # Also close any other connections to the same database file\n                    test_db_name = connection.creation._get_test_db_name()\n                    for conn_alias in connections:\n                        other_conn = connections[conn_alias]\n                        if (other_conn.vendor == 'sqlite' and \n                            hasattr(other_conn, 'connection') and \n                            other_conn.connection is not None and\n                            other_conn.creation._get_test_db_name() == test_db_name):\n                            other_conn.close()\n                \n                connection.creation.create_test_db(\n                    verbosity=verbosity,\n                    autoclobber=not interactive,\n                    keepdb=keepdb,\n                    serialize=connection.settings_dict.get('TEST', {}).get('SERIALIZE', True),\n                )\n                if parallel > 1:\n                    for index in range(parallel):\n                        connection.creation.clone_test_db(\n                            suffix=str(index + 1),\n                            verbosity=verbosity,\n                            keepdb=keepdb,\n                        )\n            # Configure all other connections as mirrors of the first one\n            else:\n                connections[alias].creation.set_as_test_mirror(connections[first_alias].settings_dict)\n\n    # Configure the test mirrors.\n    for alias, mirror_alias in mirrored_aliases.items():\n        connections[alias].creation.set_as_test_mirror(\n            connections[mirror_alias].settings_dict)\n\n    if debug_sql:\n        for alias in connections:\n            connections[alias].force_debug_cursor = True\n\n    return old_names\n",
      "\ndef setup_databases(verbosity, interactive, keepdb=False, debug_sql=False, parallel=0, aliases=None, **kwargs):\n    \"\"\"Create the test databases.\"\"\"\n    test_databases, mirrored_aliases = get_unique_databases_and_mirrors(aliases)\n\n    old_names = []\n\n    for db_name, aliases in test_databases.values():\n        first_alias = None\n        for alias in aliases:\n            connection = connections[alias]\n            old_names.append((connection, db_name, first_alias is None))\n\n            # Actually create the database for the first connection\n            if first_alias is None:\n                first_alias = alias\n                \n                # For SQLite with keepdb, ensure any existing connections are closed\n                # to prevent database locking issues\n                if keepdb and connection.vendor == 'sqlite':\n                    # Close any existing connection to the database file\n                    if hasattr(connection, 'close'):\n                        connection.close()\n                    # Force a new connection to be created\n                    connection.connect()\n                \n                connection.creation.create_test_db(\n                    verbosity=verbosity,\n                    autoclobber=not interactive,\n                    keepdb=keepdb,\n                    serialize=connection.settings_dict.get('TEST', {}).get('SERIALIZE', True),\n                )\n                if parallel > 1:\n                    for index in range(parallel):\n                        connection.creation.clone_test_db(\n                            suffix=str(index + 1),\n                            verbosity=verbosity,\n                            keepdb=keepdb,\n                        )\n            # Configure all other connections as mirrors of the first one\n            else:\n                # For SQLite with keepdb, ensure connection cleanup for mirror databases too\n                if keepdb and connections[alias].vendor == 'sqlite':\n                    if hasattr(connections[alias], 'close'):\n                        connections[alias].close()\n                \n                connections[alias].creation.set_as_test_mirror(connections[first_alias].settings_dict)\n\n    # Configure the test mirrors.\n    for alias, mirror_alias in mirrored_aliases.items():\n        # For SQLite with keepdb, ensure connection cleanup for mirrored aliases\n        if keepdb and connections[alias].vendor == 'sqlite':\n            if hasattr(connections[alias], 'close'):\n                connections[alias].close()\n        \n        connections[alias].creation.set_as_test_mirror(\n            connections[mirror_alias].settings_dict)\n\n    if debug_sql:\n        for alias in connections:\n            connections[alias].force_debug_cursor = True\n\n    return old_names\n",
      "\ndef setup_databases(verbosity, interactive, keepdb=False, debug_sql=False, parallel=0, aliases=None, **kwargs):\n    \"\"\"Create the test databases.\"\"\"\n    test_databases, mirrored_aliases = get_unique_databases_and_mirrors(aliases)\n\n    old_names = []\n\n    for db_name, aliases in test_databases.values():\n        first_alias = None\n        for alias in aliases:\n            connection = connections[alias]\n            old_names.append((connection, db_name, first_alias is None))\n\n            # Actually create the database for the first connection\n            if first_alias is None:\n                first_alias = alias\n                # For SQLite with keepdb, ensure any existing connections are properly closed\n                if keepdb and connection.vendor == 'sqlite':\n                    # Close the connection to release any file locks\n                    connection.close()\n                    # Force a new connection to be created\n                    connection.connection = None\n                    connection.queries_log.clear()\n                \n                connection.creation.create_test_db(\n                    verbosity=verbosity,\n                    autoclobber=not interactive,\n                    keepdb=keepdb,\n                    serialize=connection.settings_dict.get('TEST', {}).get('SERIALIZE', True),\n                )\n                if parallel > 1:\n                    for index in range(parallel):\n                        connection.creation.clone_test_db(\n                            suffix=str(index + 1),\n                            verbosity=verbosity,\n                            keepdb=keepdb,\n                        )\n            # Configure all other connections as mirrors of the first one\n            else:\n                # For SQLite with keepdb, ensure mirror connections are also properly cleaned\n                if keepdb and connection.vendor == 'sqlite':\n                    connection.close()\n                    connection.connection = None\n                    connection.queries_log.clear()\n                connections[alias].creation.set_as_test_mirror(connections[first_alias].settings_dict)\n\n    # Configure the test mirrors.\n    for alias, mirror_alias in mirrored_aliases.items():\n        connection = connections[alias]\n        # For SQLite with keepdb, ensure mirrored connections are properly cleaned\n        if keepdb and connection.vendor == 'sqlite':\n            connection.close()\n            connection.connection = None\n            connection.queries_log.clear()\n        connections[alias].creation.set_as_test_mirror(\n            connections[mirror_alias].settings_dict)\n\n    if debug_sql:\n        for alias in connections:\n            connections[alias].force_debug_cursor = True\n\n    return old_names\n",
      "\ndef setup_databases(verbosity, interactive, keepdb=False, debug_sql=False, parallel=0, aliases=None, **kwargs):\n    \"\"\"Create the test databases.\"\"\"\n    test_databases, mirrored_aliases = get_unique_databases_and_mirrors(aliases)\n\n    old_names = []\n\n    for db_name, aliases in test_databases.values():\n        first_alias = None\n        for alias in aliases:\n            connection = connections[alias]\n            old_names.append((connection, db_name, first_alias is None))\n\n            # For SQLite with keepdb, close any existing connections to prevent locking\n            if keepdb and connection.vendor == 'sqlite':\n                # Close the connection if it exists\n                if hasattr(connection, 'connection') and connection.connection is not None:\n                    connection.close()\n\n            # Actually create the database for the first connection\n            if first_alias is None:\n                first_alias = alias\n                connection.creation.create_test_db(\n                    verbosity=verbosity,\n                    autoclobber=not interactive,\n                    keepdb=keepdb,\n                    serialize=connection.settings_dict.get('TEST', {}).get('SERIALIZE', True),\n                )\n                if parallel > 1:\n                    for index in range(parallel):\n                        connection.creation.clone_test_db(\n                            suffix=str(index + 1),\n                            verbosity=verbosity,\n                            keepdb=keepdb,\n                        )\n            # Configure all other connections as mirrors of the first one\n            else:\n                connections[alias].creation.set_as_test_mirror(connections[first_alias].settings_dict)\n\n    # Configure the test mirrors.\n    for alias, mirror_alias in mirrored_aliases.items():\n        connections[alias].creation.set_as_test_mirror(\n            connections[mirror_alias].settings_dict)\n\n    if debug_sql:\n        for alias in connections:\n            connections[alias].force_debug_cursor = True\n\n    return old_names\n",
      "\ndef setup_databases(verbosity, interactive, keepdb=False, debug_sql=False, parallel=0, aliases=None, **kwargs):\n    \"\"\"Create the test databases.\"\"\"\n    test_databases, mirrored_aliases = get_unique_databases_and_mirrors(aliases)\n\n    old_names = []\n\n    for db_name, aliases in test_databases.values():\n        first_alias = None\n        for alias in aliases:\n            connection = connections[alias]\n            old_names.append((connection, db_name, first_alias is None))\n\n            # Actually create the database for the first connection\n            if first_alias is None:\n                first_alias = alias\n                \n                # For SQLite with keepdb, ensure any existing connections are closed\n                if keepdb and connection.vendor == 'sqlite':\n                    # Close any existing connection to the database file\n                    if connection.connection is not None:\n                        connection.close()\n                    # Also close any other connections that might be using the same database\n                    for other_alias in connections:\n                        other_conn = connections[other_alias]\n                        if (other_conn.vendor == 'sqlite' and \n                            other_conn.settings_dict['NAME'] == connection.settings_dict['NAME']):\n                            if other_conn.connection is not None:\n                                other_conn.close()\n                \n                connection.creation.create_test_db(\n                    verbosity=verbosity,\n                    autoclobber=not interactive,\n                    keepdb=keepdb,\n                    serialize=connection.settings_dict.get('TEST', {}).get('SERIALIZE', True),\n                )\n                if parallel > 1:\n                    for index in range(parallel):\n                        connection.creation.clone_test_db(\n                            suffix=str(index + 1),\n                            verbosity=verbosity,\n                            keepdb=keepdb,\n                        )\n            # Configure all other connections as mirrors of the first one\n            else:\n                connections[alias].creation.set_as_test_mirror(connections[first_alias].settings_dict)\n\n    # Configure the test mirrors.\n    for alias, mirror_alias in mirrored_aliases.items():\n        connections[alias].creation.set_as_test_mirror(\n            connections[mirror_alias].settings_dict)\n\n    if debug_sql:\n        for alias in connections:\n            connections[alias].force_debug_cursor = True\n\n    return old_names\n",
      "\ndef setup_databases(verbosity, interactive, keepdb=False, debug_sql=False, parallel=0, aliases=None, **kwargs):\n    \"\"\"Create the test databases.\"\"\"\n    test_databases, mirrored_aliases = get_unique_databases_and_mirrors(aliases)\n\n    old_names = []\n\n    for db_name, aliases in test_databases.values():\n        first_alias = None\n        for alias in aliases:\n            connection = connections[alias]\n            old_names.append((connection, db_name, first_alias is None))\n\n            # Actually create the database for the first connection\n            if first_alias is None:\n                first_alias = alias\n                \n                # For SQLite with keepdb, ensure any existing connections are properly closed\n                if keepdb and connection.vendor == 'sqlite':\n                    # Close existing connection if it exists\n                    if hasattr(connection, 'connection') and connection.connection is not None:\n                        connection.close()\n                    # Also close any other connections to the same database\n                    for other_alias in connections:\n                        other_conn = connections[other_alias]\n                        if (other_conn.vendor == 'sqlite' and \n                            other_conn.settings_dict.get('NAME') == connection.settings_dict.get('NAME') and\n                            hasattr(other_conn, 'connection') and other_conn.connection is not None):\n                            other_conn.close()\n                \n                connection.creation.create_test_db(\n                    verbosity=verbosity,\n                    autoclobber=not interactive,\n                    keepdb=keepdb,\n                    serialize=connection.settings_dict.get('TEST', {}).get('SERIALIZE', True),\n                )\n                if parallel > 1:\n                    for index in range(parallel):\n                        connection.creation.clone_test_db(\n                            suffix=str(index + 1),\n                            verbosity=verbosity,\n                            keepdb=keepdb,\n                        )\n            # Configure all other connections as mirrors of the first one\n            else:\n                connections[alias].creation.set_as_test_mirror(connections[first_alias].settings_dict)\n\n    # Configure the test mirrors.\n    for alias, mirror_alias in mirrored_aliases.items():\n        connections[alias].creation.set_as_test_mirror(\n            connections[mirror_alias].settings_dict)\n\n    if debug_sql:\n        for alias in connections:\n            connections[alias].force_debug_cursor = True\n\n    return old_names\n"
    ],
    "Location 3 (/root/hy/projects_2/django/django/db/backends/sqlite3/base.py lines 261-267)": [
      "\n    @async_unsafe\n    def close(self):\n        self.validate_thread_sharing()\n        # If database is in memory, closing the connection destroys the\n        # database. To prevent accidental data loss, ignore close requests on\n        # an in-memory db.\n        if not self.is_in_memory_db():\n            # For persistent test databases, ensure complete cleanup\n            # to prevent SQLite file locking issues\n            if hasattr(self, 'connection') and self.connection is not None:\n                try:\n                    # Force close any pending transactions\n                    if hasattr(self.connection, 'rollback'):\n                        self.connection.rollback()\n                except Exception:\n                    # Ignore errors during rollback as connection may already be closed\n                    pass\n            BaseDatabaseWrapper.close(self)\n",
      "\n    @async_unsafe\n    def close(self):\n        self.validate_thread_sharing()\n        # If database is in memory, closing the connection destroys the\n        # database. To prevent accidental data loss, ignore close requests on\n        # an in-memory db.\n        if not self.is_in_memory_db():\n            # For persistent test databases, ensure complete cleanup\n            if hasattr(self, '_test_database') and self._test_database:\n                # Force close the connection to release file locks\n                if self.connection is not None:\n                    try:\n                        self.connection.close()\n                    except Database.Error:\n                        pass\n                    self.connection = None\n            BaseDatabaseWrapper.close(self)\n",
      "\n    @async_unsafe\n    def close(self):\n        self.validate_thread_sharing()\n        # If database is in memory, closing the connection destroys the\n        # database. To prevent accidental data loss, ignore close requests on\n        # an in-memory db.\n        if not self.is_in_memory_db():\n            # For persistent test databases, ensure complete connection cleanup\n            if hasattr(self, '_test_database') and self._test_database:\n                # Force close the connection to release file locks\n                if self.connection is not None:\n                    try:\n                        self.connection.close()\n                    except Database.Error:\n                        pass\n                    self.connection = None\n            BaseDatabaseWrapper.close(self)\n",
      "\n    @async_unsafe\n    def close(self):\n        self.validate_thread_sharing()\n        # If database is in memory, closing the connection destroys the\n        # database. To prevent accidental data loss, ignore close requests on\n        # an in-memory db.\n        if not self.is_in_memory_db():\n            # For persistent test databases, ensure complete connection cleanup\n            # to prevent SQLite file locking issues when using --keepdb\n            if hasattr(self, '_test_database') and self._test_database:\n                if self.connection:\n                    try:\n                        self.connection.close()\n                    except Database.ProgrammingError:\n                        pass\n                    self.connection = None\n            BaseDatabaseWrapper.close(self)\n",
      "\n    @async_unsafe\n    def close(self):\n        self.validate_thread_sharing()\n        # If database is in memory, closing the connection destroys the\n        # database. To prevent accidental data loss, ignore close requests on\n        # an in-memory db.\n        if not self.is_in_memory_db():\n            # For persistent test databases, ensure complete connection cleanup\n            # to prevent SQLite file locking issues when using --keepdb\n            if hasattr(self, '_test_database_name'):\n                # Force close any remaining connections and release file locks\n                if self.connection is not None:\n                    try:\n                        self.connection.close()\n                    except Database.Error:\n                        pass\n                    self.connection = None\n            BaseDatabaseWrapper.close(self)\n",
      "\n    @async_unsafe\n    def close(self):\n        self.validate_thread_sharing()\n        # If database is in memory, closing the connection destroys the\n        # database. To prevent accidental data loss, ignore close requests on\n        # an in-memory db.\n        if not self.is_in_memory_db():\n            # For persistent test databases, ensure complete cleanup\n            # to prevent file locking issues when using --keepdb\n            if hasattr(self, '_test_database') and self._test_database:\n                # Force close the underlying connection to release file locks\n                if self.connection is not None:\n                    try:\n                        self.connection.close()\n                    except Database.Error:\n                        pass\n                    self.connection = None\n            BaseDatabaseWrapper.close(self)\n",
      "\n    @async_unsafe\n    def close(self):\n        self.validate_thread_sharing()\n        # If database is in memory, closing the connection destroys the\n        # database. To prevent accidental data loss, ignore close requests on\n        # an in-memory db.\n        if not self.is_in_memory_db():\n            # For persistent test databases, ensure complete connection cleanup\n            # to prevent SQLite file locking issues when using --keepdb\n            if hasattr(self, 'settings_dict') and self.settings_dict.get('NAME'):\n                # Force connection cleanup for file-based databases\n                if hasattr(self, 'connection') and self.connection:\n                    try:\n                        self.connection.close()\n                    except Exception:\n                        pass\n                    self.connection = None\n            BaseDatabaseWrapper.close(self)\n",
      "\n    @async_unsafe\n    def close(self):\n        self.validate_thread_sharing()\n        # If database is in memory, closing the connection destroys the\n        # database. To prevent accidental data loss, ignore close requests on\n        # an in-memory db.\n        if not self.is_in_memory_db():\n            # For persistent test databases, ensure complete connection cleanup\n            # to prevent SQLite file locking issues with --keepdb\n            if hasattr(self, 'connection') and self.connection:\n                try:\n                    # Ensure all pending transactions are committed or rolled back\n                    if self.connection.in_transaction:\n                        self.connection.rollback()\n                    # Close the underlying SQLite connection\n                    self.connection.close()\n                except Database.Error:\n                    # Ignore errors during cleanup\n                    pass\n                finally:\n                    self.connection = None\n            BaseDatabaseWrapper.close(self)\n"
    ],
    "Location 4 (/root/hy/projects_2/django/tests/admin_views/test_multidb.py lines 34-44)": [
      "\n@classmethod\ndef setUpTestData(cls):\n    cls.superusers = {}\n    cls.test_book_ids = {}\n    for db in connections:\n        Router.target_db = db\n        # Ensure connection is properly established before creating objects\n        connection = connections[db]\n        connection.ensure_connection()\n        cls.superusers[db] = User.objects.create_superuser(\n            username='admin', password='something', email='test@test.org',\n        )\n        b = Book(name='Test Book')\n        b.save(using=db)\n        cls.test_book_ids[db] = b.id\n",
      "\n@classmethod\ndef setUpTestData(cls):\n    cls.superusers = {}\n    cls.test_book_ids = {}\n    for db in connections:\n        Router.target_db = db\n        # Ensure clean connection state for each database\n        connection = connections[db]\n        if connection.vendor == 'sqlite':\n            connection.close()\n            connection.connect()\n        cls.superusers[db] = User.objects.create_superuser(\n            username='admin', password='something', email='test@test.org',\n        )\n        b = Book(name='Test Book')\n        b.save(using=db)\n        cls.test_book_ids[db] = b.id\n",
      "\n    @classmethod\n    def setUpTestData(cls):\n        cls.superusers = {}\n        cls.test_book_ids = {}\n        for db in connections:\n            Router.target_db = db\n            # Close any existing connections to prevent SQLite locking issues\n            # when using persistent test databases with --keepdb\n            if hasattr(connections[db], 'close'):\n                connections[db].close()\n            cls.superusers[db] = User.objects.create_superuser(\n                username='admin', password='something', email='test@test.org',\n            )\n            b = Book(name='Test Book')\n            b.save(using=db)\n            cls.test_book_ids[db] = b.id\n",
      "\n    @classmethod\n    def setUpTestData(cls):\n        cls.superusers = {}\n        cls.test_book_ids = {}\n        for db in connections:\n            Router.target_db = db\n            # Ensure connection is fresh and not locked\n            connections[db].close()\n            cls.superusers[db] = User.objects.create_superuser(\n                username='admin', password='something', email='test@test.org',\n            )\n            b = Book(name='Test Book')\n            b.save(using=db)\n            cls.test_book_ids[db] = b.id\n",
      "\n    @classmethod\n    def setUpTestData(cls):\n        cls.superusers = {}\n        cls.test_book_ids = {}\n        for db in connections:\n            Router.target_db = db\n            # Ensure database connection is properly initialized\n            connection = connections[db]\n            if connection.vendor == 'sqlite' and hasattr(connection, 'ensure_connection'):\n                connection.ensure_connection()\n            cls.superusers[db] = User.objects.create_superuser(\n                username='admin', password='something', email='test@test.org',\n            )\n            b = Book(name='Test Book')\n            b.save(using=db)\n            cls.test_book_ids[db] = b.id\n",
      "\n    @classmethod\n    def setUpTestData(cls):\n        cls.superusers = {}\n        cls.test_book_ids = {}\n        for db in connections:\n            Router.target_db = db\n            # Ensure connection is properly established before creating objects\n            connection = connections[db]\n            if connection.vendor == 'sqlite':\n                # For SQLite, ensure the connection is fresh and not locked\n                connection.close()\n                connection.ensure_connection()\n            cls.superusers[db] = User.objects.create_superuser(\n                username='admin', password='something', email='test@test.org',\n            )\n            b = Book(name='Test Book')\n            b.save(using=db)\n            cls.test_book_ids[db] = b.id\n",
      "\n    @classmethod\n    def setUpTestData(cls):\n        cls.superusers = {}\n        cls.test_book_ids = {}\n        for db in connections:\n            Router.target_db = db\n            # Ensure connection is properly initialized for this database\n            connection = connections[db]\n            connection.ensure_connection()\n            cls.superusers[db] = User.objects.create_superuser(\n                username='admin', password='something', email='test@test.org',\n            )\n            b = Book(name='Test Book')\n            b.save(using=db)\n            cls.test_book_ids[db] = b.id\n",
      "\n    @classmethod\n    def setUpTestData(cls):\n        cls.superusers = {}\n        cls.test_book_ids = {}\n        for db in connections:\n            Router.target_db = db\n            # Ensure connection is properly initialized for persistent databases\n            connection = connections[db]\n            if connection.vendor == 'sqlite' and hasattr(connection, 'ensure_connection'):\n                connection.ensure_connection()\n            cls.superusers[db] = User.objects.create_superuser(\n                username='admin', password='something', email='test@test.org',\n            )\n            b = Book(name='Test Book')\n            b.save(using=db)\n            cls.test_book_ids[db] = b.id\n"
    ],
    "Location 5 (/root/hy/projects_2/django/django/test/testcases.py lines 1078-1092)": [
      "\n@classmethod\ndef _enter_atomics(cls):\n    \"\"\"Open atomic blocks for multiple databases.\"\"\"\n    atomics = {}\n    for db_name in cls._databases_names():\n        # Ensure connection is properly established before entering atomic block\n        connection_obj = connections[db_name]\n        if hasattr(connection_obj, 'ensure_connection'):\n            connection_obj.ensure_connection()\n        \n        atomics[db_name] = transaction.atomic(using=db_name)\n        atomics[db_name].__enter__()\n    return atomics\n\n@classmethod\ndef _rollback_atomics(cls, atomics):\n    \"\"\"Rollback atomic blocks opened by the previous method.\"\"\"\n    for db_name in reversed(cls._databases_names()):\n        try:\n            transaction.set_rollback(True, using=db_name)\n            atomics[db_name].__exit__(None, None, None)\n        except Exception:\n            # Ensure we attempt to close all atomic blocks even if one fails\n            # This is particularly important for SQLite with keepdb where\n            # connection issues might occur\n            pass\n",
      "\n@classmethod\ndef _enter_atomics(cls):\n    \"\"\"Open atomic blocks for multiple databases.\"\"\"\n    atomics = {}\n    for db_name in cls._databases_names():\n        # For SQLite databases in test scenarios, ensure connection is fresh\n        # to avoid file locking issues with persistent databases\n        conn = connections[db_name]\n        if conn.vendor == 'sqlite' and hasattr(conn, 'close_if_unusable_or_obsolete'):\n            conn.close_if_unusable_or_obsolete()\n        \n        atomics[db_name] = transaction.atomic(using=db_name)\n        atomics[db_name].__enter__()\n    return atomics\n\n@classmethod\ndef _rollback_atomics(cls, atomics):\n    \"\"\"Rollback atomic blocks opened by the previous method.\"\"\"\n    for db_name in reversed(cls._databases_names()):\n        transaction.set_rollback(True, using=db_name)\n        atomics[db_name].__exit__(None, None, None)\n        \n        # For SQLite databases, ensure clean connection state after rollback\n        # to prevent file locking issues in subsequent operations\n        conn = connections[db_name]\n        if conn.vendor == 'sqlite':\n            conn.close()\n",
      "\n    @classmethod\n    def _enter_atomics(cls):\n        \"\"\"Open atomic blocks for multiple databases.\"\"\"\n        atomics = {}\n        for db_name in cls._databases_names():\n            # Ensure connection is properly established before creating atomic block\n            connection_obj = connections[db_name]\n            if connection_obj.vendor == 'sqlite' and hasattr(connection_obj, 'ensure_connection'):\n                connection_obj.ensure_connection()\n            atomics[db_name] = transaction.atomic(using=db_name)\n            atomics[db_name].__enter__()\n        return atomics\n\n    @classmethod\n    def _rollback_atomics(cls, atomics):\n        \"\"\"Rollback atomic blocks opened by the previous method.\"\"\"\n        for db_name in reversed(cls._databases_names()):\n            transaction.set_rollback(True, using=db_name)\n            atomics[db_name].__exit__(None, None, None)\n            # For SQLite, ensure connection state is clean after atomic rollback\n            connection_obj = connections[db_name]\n            if connection_obj.vendor == 'sqlite' and connection_obj.in_atomic_block:\n                connection_obj.validate_thread_sharing()\n",
      "\n    @classmethod\n    def _enter_atomics(cls):\n        \"\"\"Open atomic blocks for multiple databases.\"\"\"\n        atomics = {}\n        for db_name in cls._databases_names():\n            # Ensure connection is properly initialized for persistent test databases\n            conn = connections[db_name]\n            if hasattr(conn, 'ensure_connection'):\n                conn.ensure_connection()\n            atomics[db_name] = transaction.atomic(using=db_name)\n            atomics[db_name].__enter__()\n        return atomics\n\n    @classmethod\n    def _rollback_atomics(cls, atomics):\n        \"\"\"Rollback atomic blocks opened by the previous method.\"\"\"\n        for db_name in reversed(cls._databases_names()):\n            transaction.set_rollback(True, using=db_name)\n            atomics[db_name].__exit__(None, None, None)\n            # For SQLite persistent test databases, ensure connection cleanup\n            conn = connections[db_name]\n            if (hasattr(conn, 'vendor') and conn.vendor == 'sqlite' and \n                hasattr(conn, 'settings_dict') and \n                conn.settings_dict.get('NAME', '').startswith('test_')):\n                conn.close()\n",
      "\n    @classmethod\n    def _enter_atomics(cls):\n        \"\"\"Open atomic blocks for multiple databases.\"\"\"\n        atomics = {}\n        for db_name in cls._databases_names():\n            # Ensure connection is properly established before creating atomic block\n            connection = connections[db_name]\n            if connection.vendor == 'sqlite' and hasattr(connection, 'ensure_connection'):\n                connection.ensure_connection()\n            atomics[db_name] = transaction.atomic(using=db_name)\n            atomics[db_name].__enter__()\n        return atomics\n\n    @classmethod\n    def _rollback_atomics(cls, atomics):\n        \"\"\"Rollback atomic blocks opened by the previous method.\"\"\"\n        for db_name in reversed(cls._databases_names()):\n            transaction.set_rollback(True, using=db_name)\n            atomics[db_name].__exit__(None, None, None)\n            # For SQLite, ensure connection state is clean after rollback\n            connection = connections[db_name]\n            if connection.vendor == 'sqlite' and connection.in_atomic_block:\n                connection.in_atomic_block = False\n",
      "\n@classmethod\ndef _enter_atomics(cls):\n    \"\"\"Open atomic blocks for multiple databases.\"\"\"\n    atomics = {}\n    for db_name in cls._databases_names():\n        # Ensure connection is fresh for persistent test databases\n        connection_obj = connections[db_name]\n        if (hasattr(connection_obj, 'creation') and \n            hasattr(connection_obj.creation, '_test_database_name') and\n            connection_obj.creation._test_database_name and\n            connection_obj.vendor == 'sqlite'):\n            # For SQLite persistent test databases, ensure clean connection state\n            if connection_obj.connection is not None:\n                connection_obj.close()\n        \n        atomics[db_name] = transaction.atomic(using=db_name)\n        atomics[db_name].__enter__()\n    return atomics\n\n@classmethod\ndef _rollback_atomics(cls, atomics):\n    \"\"\"Rollback atomic blocks opened by the previous method.\"\"\"\n    for db_name in reversed(cls._databases_names()):\n        transaction.set_rollback(True, using=db_name)\n        atomics[db_name].__exit__(None, None, None)\n        \n        # Ensure clean connection state after rollback for persistent test databases\n        connection_obj = connections[db_name]\n        if (hasattr(connection_obj, 'creation') and \n            hasattr(connection_obj.creation, '_test_database_name') and\n            connection_obj.creation._test_database_name and\n            connection_obj.vendor == 'sqlite'):\n            # For SQLite persistent test databases, ensure connection is properly closed\n            if connection_obj.connection is not None:\n                connection_obj.close()\n",
      "\n    @classmethod\n    def _enter_atomics(cls):\n        \"\"\"Open atomic blocks for multiple databases.\"\"\"\n        atomics = {}\n        for db_name in cls._databases_names():\n            # Ensure connection is properly established before entering atomic block\n            connection_obj = connections[db_name]\n            if hasattr(connection_obj, 'ensure_connection'):\n                connection_obj.ensure_connection()\n            atomics[db_name] = transaction.atomic(using=db_name)\n            atomics[db_name].__enter__()\n        return atomics\n\n    @classmethod\n    def _rollback_atomics(cls, atomics):\n        \"\"\"Rollback atomic blocks opened by the previous method.\"\"\"\n        for db_name in reversed(cls._databases_names()):\n            try:\n                transaction.set_rollback(True, using=db_name)\n                atomics[db_name].__exit__(None, None, None)\n            except Exception:\n                # If rollback fails, ensure connection is closed to prevent locks\n                connection_obj = connections[db_name]\n                if hasattr(connection_obj, 'close'):\n                    connection_obj.close()\n                raise\n",
      "\n    @classmethod\n    def _enter_atomics(cls):\n        \"\"\"Open atomic blocks for multiple databases.\"\"\"\n        atomics = {}\n        for db_name in cls._databases_names():\n            # Ensure connection is properly established before entering atomic block\n            connection = connections[db_name]\n            if connection.vendor == 'sqlite' and hasattr(connection, 'ensure_connection'):\n                connection.ensure_connection()\n            atomics[db_name] = transaction.atomic(using=db_name)\n            atomics[db_name].__enter__()\n        return atomics\n\n    @classmethod\n    def _rollback_atomics(cls, atomics):\n        \"\"\"Rollback atomic blocks opened by the previous method.\"\"\"\n        for db_name in reversed(cls._databases_names()):\n            try:\n                transaction.set_rollback(True, using=db_name)\n                atomics[db_name].__exit__(None, None, None)\n            except Exception:\n                # Ensure cleanup continues even if one database fails\n                connection = connections[db_name]\n                if connection.vendor == 'sqlite':\n                    # Force close SQLite connection to release locks\n                    connection.close()\n                raise\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/backends/sqlite3/base.py b/django/db/backends/sqlite3/base.py\nindex a3ae1f048e..a495e15797 100644\n--- a/django/db/backends/sqlite3/base.py\n+++ b/django/db/backends/sqlite3/base.py\n@@ -258,6 +258,7 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n         return self.connection.cursor(factory=SQLiteCursorWrapper)\n \n     @async_unsafe\n+\n     def close(self):\n         self.validate_thread_sharing()\n         # If database is in memory, closing the connection destroys the\ndiff --git a/django/db/backends/sqlite3/creation.py b/django/db/backends/sqlite3/creation.py\nindex d97052f52d..59387518d2 100644\n--- a/django/db/backends/sqlite3/creation.py\n+++ b/django/db/backends/sqlite3/creation.py\n@@ -20,10 +20,27 @@ class DatabaseCreation(BaseDatabaseCreation):\n             return 'file:memorydb_%s?mode=memory&cache=shared' % self.connection.alias\n         return test_database_name\n \n+\n     def _create_test_db(self, verbosity, autoclobber, keepdb=False):\n         test_database_name = self._get_test_db_name()\n \n         if keepdb:\n+            # When keeping the database, ensure any existing connections are closed\n+            # to prevent SQLite file locking issues with persistent databases\n+            if not self.is_in_memory_db(test_database_name):\n+                # Close the current connection if it exists and is open\n+                if hasattr(self.connection, 'connection') and self.connection.connection is not None:\n+                    self.connection.close()\n+                \n+                # Also close any other connections to the same database file\n+                from django.db import connections\n+                for alias, conn in connections.all():\n+                    if (hasattr(conn, 'settings_dict') and \n+                        conn.settings_dict.get('ENGINE') == 'django.db.backends.sqlite3' and\n+                        hasattr(conn.creation, '_get_test_db_name') and\n+                        conn.creation._get_test_db_name() == test_database_name and\n+                        hasattr(conn, 'connection') and conn.connection is not None):\n+                        conn.close()\n             return test_database_name\n         if not self.is_in_memory_db(test_database_name):\n             # Erase the old test database\ndiff --git a/django/test/testcases.py b/django/test/testcases.py\nindex 23459f22cd..95aeead75f 100644\n--- a/django/test/testcases.py\n+++ b/django/test/testcases.py\n@@ -1075,6 +1075,7 @@ class TestCase(TransactionTestCase):\n     On database backends with no transaction support, TestCase behaves as\n     TransactionTestCase.\n     \"\"\"\n+\n     @classmethod\n     def _enter_atomics(cls):\n         \"\"\"Open atomic blocks for multiple databases.\"\"\"\ndiff --git a/django/test/utils.py b/django/test/utils.py\nindex 819e423326..0712fd5873 100644\n--- a/django/test/utils.py\n+++ b/django/test/utils.py\n@@ -151,12 +151,22 @@ def teardown_test_environment():\n     del mail.outbox\n \n \n+\n def setup_databases(verbosity, interactive, keepdb=False, debug_sql=False, parallel=0, aliases=None, **kwargs):\n     \"\"\"Create the test databases.\"\"\"\n     test_databases, mirrored_aliases = get_unique_databases_and_mirrors(aliases)\n \n     old_names = []\n \n+    # When using keepdb with SQLite, ensure connections are cleaned up first\n+    if keepdb:\n+        for db_name, aliases_list in test_databases.values():\n+            for alias in aliases_list:\n+                connection = connections[alias]\n+                if (connection.settings_dict.get('ENGINE') == 'django.db.backends.sqlite3' and\n+                    hasattr(connection, 'connection') and connection.connection is not None):\n+                    connection.close()\n+\n     for db_name, aliases in test_databases.values():\n         first_alias = None\n         for alias in aliases:\ndiff --git a/tests/admin_views/test_multidb.py b/tests/admin_views/test_multidb.py\nindex a02b637d34..e047168bde 100644\n--- a/tests/admin_views/test_multidb.py\n+++ b/tests/admin_views/test_multidb.py\n@@ -31,6 +31,7 @@ class MultiDatabaseTests(TestCase):\n     databases = {'default', 'other'}\n \n     @classmethod\n+\n     def setUpTestData(cls):\n         cls.superusers = {}\n         cls.test_book_ids = {}\n",
    "variant_0": "diff --git a/django/db/backends/sqlite3/base.py b/django/db/backends/sqlite3/base.py\nindex a3ae1f048e..a5a0319c75 100644\n--- a/django/db/backends/sqlite3/base.py\n+++ b/django/db/backends/sqlite3/base.py\n@@ -257,6 +257,8 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n     def create_cursor(self, name=None):\n         return self.connection.cursor(factory=SQLiteCursorWrapper)\n \n+    @async_unsafe\n+\n     @async_unsafe\n     def close(self):\n         self.validate_thread_sharing()\n@@ -264,6 +266,20 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n         # database. To prevent accidental data loss, ignore close requests on\n         # an in-memory db.\n         if not self.is_in_memory_db():\n+            # For persistent test databases, ensure complete connection cleanup\n+            # to prevent SQLite file locking issues\n+            if hasattr(self, 'connection') and self.connection:\n+                try:\n+                    # Commit any pending transactions before closing\n+                    if not self.connection.in_transaction:\n+                        self.connection.commit()\n+                    # Close the connection properly\n+                    self.connection.close()\n+                except Database.Error:\n+                    # Ignore errors during cleanup\n+                    pass\n+                finally:\n+                    self.connection = None\n             BaseDatabaseWrapper.close(self)\n \n     def _savepoint_allowed(self):\ndiff --git a/django/db/backends/sqlite3/creation.py b/django/db/backends/sqlite3/creation.py\nindex d97052f52d..4a95bc000f 100644\n--- a/django/db/backends/sqlite3/creation.py\n+++ b/django/db/backends/sqlite3/creation.py\n@@ -20,33 +20,50 @@ class DatabaseCreation(BaseDatabaseCreation):\n             return 'file:memorydb_%s?mode=memory&cache=shared' % self.connection.alias\n         return test_database_name\n \n-    def _create_test_db(self, verbosity, autoclobber, keepdb=False):\n-        test_database_name = self._get_test_db_name()\n \n-        if keepdb:\n-            return test_database_name\n+def _create_test_db(self, verbosity, autoclobber, keepdb=False):\n+    test_database_name = self._get_test_db_name()\n+\n+    if keepdb:\n+        # When keepdb is True and we're using a file-based database,\n+        # ensure any existing connections are properly closed to prevent locking\n         if not self.is_in_memory_db(test_database_name):\n-            # Erase the old test database\n-            if verbosity >= 1:\n-                self.log('Destroying old test database for alias %s...' % (\n-                    self._get_database_display_str(verbosity, test_database_name),\n-                ))\n-            if os.access(test_database_name, os.F_OK):\n-                if not autoclobber:\n-                    confirm = input(\n-                        \"Type 'yes' if you would like to try deleting the test \"\n-                        \"database '%s', or 'no' to cancel: \" % test_database_name\n-                    )\n-                if autoclobber or confirm == 'yes':\n-                    try:\n-                        os.remove(test_database_name)\n-                    except Exception as e:\n-                        self.log('Got an error deleting the old test database: %s' % e)\n-                        sys.exit(2)\n-                else:\n-                    self.log('Tests cancelled.')\n-                    sys.exit(1)\n+            # Close the current connection to avoid SQLite locking issues\n+            if self.connection.connection is not None:\n+                self.connection.close()\n+            \n+            # Also close any other connections to this database in the connection handler\n+            from django.db import connections\n+            for alias, conn in connections.all():\n+                if (hasattr(conn, 'settings_dict') and \n+                    conn.settings_dict.get('NAME') == test_database_name and\n+                    conn.connection is not None):\n+                    conn.close()\n+        \n         return test_database_name\n+    \n+    if not self.is_in_memory_db(test_database_name):\n+        # Erase the old test database\n+        if verbosity >= 1:\n+            self.log('Destroying old test database for alias %s...' % (\n+                self._get_database_display_str(verbosity, test_database_name),\n+            ))\n+        if os.access(test_database_name, os.F_OK):\n+            if not autoclobber:\n+                confirm = input(\n+                    \"Type 'yes' if you would like to try deleting the test \"\n+                    \"database '%s', or 'no' to cancel: \" % test_database_name\n+                )\n+            if autoclobber or confirm == 'yes':\n+                try:\n+                    os.remove(test_database_name)\n+                except Exception as e:\n+                    self.log('Got an error deleting the old test database: %s' % e)\n+                    sys.exit(2)\n+            else:\n+                self.log('Tests cancelled.')\n+                sys.exit(1)\n+    return test_database_name\n \n     def get_test_db_clone_settings(self, suffix):\n         orig_settings_dict = self.connection.settings_dict\ndiff --git a/django/test/testcases.py b/django/test/testcases.py\nindex 23459f22cd..4566e816e3 100644\n--- a/django/test/testcases.py\n+++ b/django/test/testcases.py\n@@ -1075,21 +1075,30 @@ class TestCase(TransactionTestCase):\n     On database backends with no transaction support, TestCase behaves as\n     TransactionTestCase.\n     \"\"\"\n-    @classmethod\n-    def _enter_atomics(cls):\n-        \"\"\"Open atomic blocks for multiple databases.\"\"\"\n-        atomics = {}\n-        for db_name in cls._databases_names():\n-            atomics[db_name] = transaction.atomic(using=db_name)\n-            atomics[db_name].__enter__()\n-        return atomics\n \n-    @classmethod\n-    def _rollback_atomics(cls, atomics):\n-        \"\"\"Rollback atomic blocks opened by the previous method.\"\"\"\n-        for db_name in reversed(cls._databases_names()):\n-            transaction.set_rollback(True, using=db_name)\n-            atomics[db_name].__exit__(None, None, None)\n+@classmethod\n+def _enter_atomics(cls):\n+    \"\"\"Open atomic blocks for multiple databases.\"\"\"\n+    atomics = {}\n+    for db_name in cls._databases_names():\n+        # For SQLite with persistent databases, ensure connection is fresh\n+        if hasattr(connections[db_name], 'ensure_connection'):\n+            connections[db_name].ensure_connection()\n+        atomics[db_name] = transaction.atomic(using=db_name)\n+        atomics[db_name].__enter__()\n+    return atomics\n+\n+@classmethod\n+def _rollback_atomics(cls, atomics):\n+    \"\"\"Rollback atomic blocks opened by the previous method.\"\"\"\n+    for db_name in reversed(cls._databases_names()):\n+        transaction.set_rollback(True, using=db_name)\n+        atomics[db_name].__exit__(None, None, None)\n+        # For SQLite with persistent databases, ensure clean connection state\n+        if (hasattr(connections[db_name].vendor, '__eq__') and \n+            connections[db_name].vendor == 'sqlite' and\n+            hasattr(connections[db_name], 'close_if_unusable_or_obsolete')):\n+            connections[db_name].close_if_unusable_or_obsolete()\n \n     @classmethod\n     def _databases_support_transactions(cls):\ndiff --git a/django/test/utils.py b/django/test/utils.py\nindex 819e423326..1b6b82c78f 100644\n--- a/django/test/utils.py\n+++ b/django/test/utils.py\n@@ -151,6 +151,7 @@ def teardown_test_environment():\n     del mail.outbox\n \n \n+\n def setup_databases(verbosity, interactive, keepdb=False, debug_sql=False, parallel=0, aliases=None, **kwargs):\n     \"\"\"Create the test databases.\"\"\"\n     test_databases, mirrored_aliases = get_unique_databases_and_mirrors(aliases)\n@@ -166,6 +167,21 @@ def setup_databases(verbosity, interactive, keepdb=False, debug_sql=False, paral\n             # Actually create the database for the first connection\n             if first_alias is None:\n                 first_alias = alias\n+                # For SQLite with keepdb, ensure existing connections are closed\n+                # to prevent file locking issues\n+                if keepdb and connection.vendor == 'sqlite':\n+                    # Close any existing connection to the database file\n+                    if connection.connection is not None:\n+                        connection.close()\n+                    # Also close any other connections that might be using the same database file\n+                    test_db_name = connection.creation._get_test_db_name()\n+                    for conn_alias in connections:\n+                        other_conn = connections[conn_alias]\n+                        if (other_conn.vendor == 'sqlite' and \n+                            other_conn.connection is not None and\n+                            other_conn.creation._get_test_db_name() == test_db_name):\n+                            other_conn.close()\n+                \n                 connection.creation.create_test_db(\n                     verbosity=verbosity,\n                     autoclobber=not interactive,\ndiff --git a/tests/admin_views/test_multidb.py b/tests/admin_views/test_multidb.py\nindex a02b637d34..9c08f399f1 100644\n--- a/tests/admin_views/test_multidb.py\n+++ b/tests/admin_views/test_multidb.py\n@@ -30,12 +30,17 @@ urlpatterns = [\n class MultiDatabaseTests(TestCase):\n     databases = {'default', 'other'}\n \n+    @classmethod\n+\n     @classmethod\n     def setUpTestData(cls):\n         cls.superusers = {}\n         cls.test_book_ids = {}\n         for db in connections:\n             Router.target_db = db\n+            # Ensure connection is properly established before creating objects\n+            connection = connections[db]\n+            connection.ensure_connection()\n             cls.superusers[db] = User.objects.create_superuser(\n                 username='admin', password='something', email='test@test.org',\n             )\n",
    "variant_1": "diff --git a/django/db/backends/sqlite3/base.py b/django/db/backends/sqlite3/base.py\nindex a3ae1f048e..01a71861ca 100644\n--- a/django/db/backends/sqlite3/base.py\n+++ b/django/db/backends/sqlite3/base.py\n@@ -257,6 +257,8 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n     def create_cursor(self, name=None):\n         return self.connection.cursor(factory=SQLiteCursorWrapper)\n \n+    @async_unsafe\n+\n     @async_unsafe\n     def close(self):\n         self.validate_thread_sharing()\n@@ -264,6 +266,16 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n         # database. To prevent accidental data loss, ignore close requests on\n         # an in-memory db.\n         if not self.is_in_memory_db():\n+            # For persistent test databases, ensure complete cleanup\n+            # to prevent SQLite file locking issues\n+            if hasattr(self, 'connection') and self.connection is not None:\n+                try:\n+                    # Force close any pending transactions\n+                    if hasattr(self.connection, 'rollback'):\n+                        self.connection.rollback()\n+                except Exception:\n+                    # Ignore errors during rollback as connection may already be closed\n+                    pass\n             BaseDatabaseWrapper.close(self)\n \n     def _savepoint_allowed(self):\ndiff --git a/django/db/backends/sqlite3/creation.py b/django/db/backends/sqlite3/creation.py\nindex d97052f52d..044390c73d 100644\n--- a/django/db/backends/sqlite3/creation.py\n+++ b/django/db/backends/sqlite3/creation.py\n@@ -20,33 +20,44 @@ class DatabaseCreation(BaseDatabaseCreation):\n             return 'file:memorydb_%s?mode=memory&cache=shared' % self.connection.alias\n         return test_database_name\n \n-    def _create_test_db(self, verbosity, autoclobber, keepdb=False):\n-        test_database_name = self._get_test_db_name()\n \n-        if keepdb:\n-            return test_database_name\n+def _create_test_db(self, verbosity, autoclobber, keepdb=False):\n+    test_database_name = self._get_test_db_name()\n+\n+    if keepdb:\n+        # When keeping the database, ensure any existing connections are closed\n+        # to prevent SQLite locking issues\n         if not self.is_in_memory_db(test_database_name):\n-            # Erase the old test database\n-            if verbosity >= 1:\n-                self.log('Destroying old test database for alias %s...' % (\n-                    self._get_database_display_str(verbosity, test_database_name),\n-                ))\n-            if os.access(test_database_name, os.F_OK):\n-                if not autoclobber:\n-                    confirm = input(\n-                        \"Type 'yes' if you would like to try deleting the test \"\n-                        \"database '%s', or 'no' to cancel: \" % test_database_name\n-                    )\n-                if autoclobber or confirm == 'yes':\n-                    try:\n-                        os.remove(test_database_name)\n-                    except Exception as e:\n-                        self.log('Got an error deleting the old test database: %s' % e)\n-                        sys.exit(2)\n-                else:\n-                    self.log('Tests cancelled.')\n-                    sys.exit(1)\n+            # Close any existing connections to this database file\n+            from django.db import connections\n+            for alias, conn in connections.all():\n+                if (hasattr(conn, 'settings_dict') and \n+                    conn.settings_dict.get('NAME') == test_database_name and\n+                    conn.connection is not None):\n+                    conn.close()\n         return test_database_name\n+    if not self.is_in_memory_db(test_database_name):\n+        # Erase the old test database\n+        if verbosity >= 1:\n+            self.log('Destroying old test database for alias %s...' % (\n+                self._get_database_display_str(verbosity, test_database_name),\n+            ))\n+        if os.access(test_database_name, os.F_OK):\n+            if not autoclobber:\n+                confirm = input(\n+                    \"Type 'yes' if you would like to try deleting the test \"\n+                    \"database '%s', or 'no' to cancel: \" % test_database_name\n+                )\n+            if autoclobber or confirm == 'yes':\n+                try:\n+                    os.remove(test_database_name)\n+                except Exception as e:\n+                    self.log('Got an error deleting the old test database: %s' % e)\n+                    sys.exit(2)\n+            else:\n+                self.log('Tests cancelled.')\n+                sys.exit(1)\n+    return test_database_name\n \n     def get_test_db_clone_settings(self, suffix):\n         orig_settings_dict = self.connection.settings_dict\ndiff --git a/django/test/testcases.py b/django/test/testcases.py\nindex 23459f22cd..d159ea46c8 100644\n--- a/django/test/testcases.py\n+++ b/django/test/testcases.py\n@@ -1075,21 +1075,33 @@ class TestCase(TransactionTestCase):\n     On database backends with no transaction support, TestCase behaves as\n     TransactionTestCase.\n     \"\"\"\n-    @classmethod\n-    def _enter_atomics(cls):\n-        \"\"\"Open atomic blocks for multiple databases.\"\"\"\n-        atomics = {}\n-        for db_name in cls._databases_names():\n-            atomics[db_name] = transaction.atomic(using=db_name)\n-            atomics[db_name].__enter__()\n-        return atomics\n \n-    @classmethod\n-    def _rollback_atomics(cls, atomics):\n-        \"\"\"Rollback atomic blocks opened by the previous method.\"\"\"\n-        for db_name in reversed(cls._databases_names()):\n+@classmethod\n+def _enter_atomics(cls):\n+    \"\"\"Open atomic blocks for multiple databases.\"\"\"\n+    atomics = {}\n+    for db_name in cls._databases_names():\n+        # Ensure connection is properly established before entering atomic block\n+        connection_obj = connections[db_name]\n+        if hasattr(connection_obj, 'ensure_connection'):\n+            connection_obj.ensure_connection()\n+        \n+        atomics[db_name] = transaction.atomic(using=db_name)\n+        atomics[db_name].__enter__()\n+    return atomics\n+\n+@classmethod\n+def _rollback_atomics(cls, atomics):\n+    \"\"\"Rollback atomic blocks opened by the previous method.\"\"\"\n+    for db_name in reversed(cls._databases_names()):\n+        try:\n             transaction.set_rollback(True, using=db_name)\n             atomics[db_name].__exit__(None, None, None)\n+        except Exception:\n+            # Ensure we attempt to close all atomic blocks even if one fails\n+            # This is particularly important for SQLite with keepdb where\n+            # connection issues might occur\n+            pass\n \n     @classmethod\n     def _databases_support_transactions(cls):\ndiff --git a/django/test/utils.py b/django/test/utils.py\nindex 819e423326..1516295ed9 100644\n--- a/django/test/utils.py\n+++ b/django/test/utils.py\n@@ -151,6 +151,7 @@ def teardown_test_environment():\n     del mail.outbox\n \n \n+\n def setup_databases(verbosity, interactive, keepdb=False, debug_sql=False, parallel=0, aliases=None, **kwargs):\n     \"\"\"Create the test databases.\"\"\"\n     test_databases, mirrored_aliases = get_unique_databases_and_mirrors(aliases)\n@@ -166,6 +167,16 @@ def setup_databases(verbosity, interactive, keepdb=False, debug_sql=False, paral\n             # Actually create the database for the first connection\n             if first_alias is None:\n                 first_alias = alias\n+                \n+                # For SQLite with keepdb, ensure any existing connections are closed\n+                # to prevent database locking issues\n+                if keepdb and connection.vendor == 'sqlite':\n+                    # Close any existing connection to the database file\n+                    if hasattr(connection, 'close'):\n+                        connection.close()\n+                    # Reset the connection to ensure clean state\n+                    connection.connect()\n+                \n                 connection.creation.create_test_db(\n                     verbosity=verbosity,\n                     autoclobber=not interactive,\n@@ -181,10 +192,18 @@ def setup_databases(verbosity, interactive, keepdb=False, debug_sql=False, paral\n                         )\n             # Configure all other connections as mirrors of the first one\n             else:\n+                # For SQLite mirrors with keepdb, also ensure clean connection state\n+                if keepdb and connections[alias].vendor == 'sqlite':\n+                    if hasattr(connections[alias], 'close'):\n+                        connections[alias].close()\n                 connections[alias].creation.set_as_test_mirror(connections[first_alias].settings_dict)\n \n     # Configure the test mirrors.\n     for alias, mirror_alias in mirrored_aliases.items():\n+        # For SQLite mirrors with keepdb, ensure clean connection state\n+        if keepdb and connections[alias].vendor == 'sqlite':\n+            if hasattr(connections[alias], 'close'):\n+                connections[alias].close()\n         connections[alias].creation.set_as_test_mirror(\n             connections[mirror_alias].settings_dict)\n \ndiff --git a/tests/admin_views/test_multidb.py b/tests/admin_views/test_multidb.py\nindex a02b637d34..4d188a8598 100644\n--- a/tests/admin_views/test_multidb.py\n+++ b/tests/admin_views/test_multidb.py\n@@ -31,17 +31,22 @@ class MultiDatabaseTests(TestCase):\n     databases = {'default', 'other'}\n \n     @classmethod\n-    def setUpTestData(cls):\n-        cls.superusers = {}\n-        cls.test_book_ids = {}\n-        for db in connections:\n-            Router.target_db = db\n-            cls.superusers[db] = User.objects.create_superuser(\n-                username='admin', password='something', email='test@test.org',\n-            )\n-            b = Book(name='Test Book')\n-            b.save(using=db)\n-            cls.test_book_ids[db] = b.id\n+\n+@classmethod\n+def setUpTestData(cls):\n+    cls.superusers = {}\n+    cls.test_book_ids = {}\n+    for db in connections:\n+        Router.target_db = db\n+        # Ensure connection is properly established before creating objects\n+        connection = connections[db]\n+        connection.ensure_connection()\n+        cls.superusers[db] = User.objects.create_superuser(\n+            username='admin', password='something', email='test@test.org',\n+        )\n+        b = Book(name='Test Book')\n+        b.save(using=db)\n+        cls.test_book_ids[db] = b.id\n \n     @mock.patch('django.contrib.admin.options.transaction')\n     def test_add_view(self, mock):\n",
    "variant_2": "diff --git a/django/db/backends/sqlite3/base.py b/django/db/backends/sqlite3/base.py\nindex a3ae1f048e..1210b81bb9 100644\n--- a/django/db/backends/sqlite3/base.py\n+++ b/django/db/backends/sqlite3/base.py\n@@ -257,6 +257,8 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n     def create_cursor(self, name=None):\n         return self.connection.cursor(factory=SQLiteCursorWrapper)\n \n+    @async_unsafe\n+\n     @async_unsafe\n     def close(self):\n         self.validate_thread_sharing()\n@@ -264,6 +266,15 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n         # database. To prevent accidental data loss, ignore close requests on\n         # an in-memory db.\n         if not self.is_in_memory_db():\n+            # For persistent test databases, ensure complete cleanup\n+            if hasattr(self, '_test_database') and self._test_database:\n+                # Force close the connection to release file locks\n+                if self.connection is not None:\n+                    try:\n+                        self.connection.close()\n+                    except Database.Error:\n+                        pass\n+                    self.connection = None\n             BaseDatabaseWrapper.close(self)\n \n     def _savepoint_allowed(self):\ndiff --git a/django/db/backends/sqlite3/creation.py b/django/db/backends/sqlite3/creation.py\nindex d97052f52d..9eb1d04c5e 100644\n--- a/django/db/backends/sqlite3/creation.py\n+++ b/django/db/backends/sqlite3/creation.py\n@@ -20,33 +20,48 @@ class DatabaseCreation(BaseDatabaseCreation):\n             return 'file:memorydb_%s?mode=memory&cache=shared' % self.connection.alias\n         return test_database_name\n \n-    def _create_test_db(self, verbosity, autoclobber, keepdb=False):\n-        test_database_name = self._get_test_db_name()\n \n-        if keepdb:\n-            return test_database_name\n+def _create_test_db(self, verbosity, autoclobber, keepdb=False):\n+    test_database_name = self._get_test_db_name()\n+\n+    if keepdb:\n+        # When keeping the database, ensure any existing connections are closed\n+        # to prevent SQLite file locking issues\n         if not self.is_in_memory_db(test_database_name):\n-            # Erase the old test database\n-            if verbosity >= 1:\n-                self.log('Destroying old test database for alias %s...' % (\n-                    self._get_database_display_str(verbosity, test_database_name),\n-                ))\n-            if os.access(test_database_name, os.F_OK):\n-                if not autoclobber:\n-                    confirm = input(\n-                        \"Type 'yes' if you would like to try deleting the test \"\n-                        \"database '%s', or 'no' to cancel: \" % test_database_name\n-                    )\n-                if autoclobber or confirm == 'yes':\n+            # Close any existing connections to this database file\n+            from django.db import connections\n+            for alias, conn in connections.all():\n+                if (hasattr(conn, 'settings_dict') and \n+                    conn.settings_dict.get('NAME') == test_database_name and\n+                    conn.connection is not None):\n                     try:\n-                        os.remove(test_database_name)\n-                    except Exception as e:\n-                        self.log('Got an error deleting the old test database: %s' % e)\n-                        sys.exit(2)\n-                else:\n-                    self.log('Tests cancelled.')\n-                    sys.exit(1)\n+                        conn.close()\n+                    except Exception:\n+                        pass  # Ignore errors when closing stale connections\n         return test_database_name\n+        \n+    if not self.is_in_memory_db(test_database_name):\n+        # Erase the old test database\n+        if verbosity >= 1:\n+            self.log('Destroying old test database for alias %s...' % (\n+                self._get_database_display_str(verbosity, test_database_name),\n+            ))\n+        if os.access(test_database_name, os.F_OK):\n+            if not autoclobber:\n+                confirm = input(\n+                    \"Type 'yes' if you would like to try deleting the test \"\n+                    \"database '%s', or 'no' to cancel: \" % test_database_name\n+                )\n+            if autoclobber or confirm == 'yes':\n+                try:\n+                    os.remove(test_database_name)\n+                except Exception as e:\n+                    self.log('Got an error deleting the old test database: %s' % e)\n+                    sys.exit(2)\n+            else:\n+                self.log('Tests cancelled.')\n+                sys.exit(1)\n+    return test_database_name\n \n     def get_test_db_clone_settings(self, suffix):\n         orig_settings_dict = self.connection.settings_dict\ndiff --git a/django/test/testcases.py b/django/test/testcases.py\nindex 23459f22cd..bf948bde7b 100644\n--- a/django/test/testcases.py\n+++ b/django/test/testcases.py\n@@ -1075,21 +1075,34 @@ class TestCase(TransactionTestCase):\n     On database backends with no transaction support, TestCase behaves as\n     TransactionTestCase.\n     \"\"\"\n-    @classmethod\n-    def _enter_atomics(cls):\n-        \"\"\"Open atomic blocks for multiple databases.\"\"\"\n-        atomics = {}\n-        for db_name in cls._databases_names():\n-            atomics[db_name] = transaction.atomic(using=db_name)\n-            atomics[db_name].__enter__()\n-        return atomics\n \n-    @classmethod\n-    def _rollback_atomics(cls, atomics):\n-        \"\"\"Rollback atomic blocks opened by the previous method.\"\"\"\n-        for db_name in reversed(cls._databases_names()):\n-            transaction.set_rollback(True, using=db_name)\n-            atomics[db_name].__exit__(None, None, None)\n+@classmethod\n+def _enter_atomics(cls):\n+    \"\"\"Open atomic blocks for multiple databases.\"\"\"\n+    atomics = {}\n+    for db_name in cls._databases_names():\n+        # For SQLite databases in test scenarios, ensure connection is fresh\n+        # to avoid file locking issues with persistent databases\n+        conn = connections[db_name]\n+        if conn.vendor == 'sqlite' and hasattr(conn, 'close_if_unusable_or_obsolete'):\n+            conn.close_if_unusable_or_obsolete()\n+        \n+        atomics[db_name] = transaction.atomic(using=db_name)\n+        atomics[db_name].__enter__()\n+    return atomics\n+\n+@classmethod\n+def _rollback_atomics(cls, atomics):\n+    \"\"\"Rollback atomic blocks opened by the previous method.\"\"\"\n+    for db_name in reversed(cls._databases_names()):\n+        transaction.set_rollback(True, using=db_name)\n+        atomics[db_name].__exit__(None, None, None)\n+        \n+        # For SQLite databases, ensure clean connection state after rollback\n+        # to prevent file locking issues in subsequent operations\n+        conn = connections[db_name]\n+        if conn.vendor == 'sqlite':\n+            conn.close()\n \n     @classmethod\n     def _databases_support_transactions(cls):\ndiff --git a/django/test/utils.py b/django/test/utils.py\nindex 819e423326..eb46cceb0d 100644\n--- a/django/test/utils.py\n+++ b/django/test/utils.py\n@@ -151,6 +151,7 @@ def teardown_test_environment():\n     del mail.outbox\n \n \n+\n def setup_databases(verbosity, interactive, keepdb=False, debug_sql=False, parallel=0, aliases=None, **kwargs):\n     \"\"\"Create the test databases.\"\"\"\n     test_databases, mirrored_aliases = get_unique_databases_and_mirrors(aliases)\n@@ -163,6 +164,15 @@ def setup_databases(verbosity, interactive, keepdb=False, debug_sql=False, paral\n             connection = connections[alias]\n             old_names.append((connection, db_name, first_alias is None))\n \n+            # For SQLite with keepdb, ensure existing connections are closed\n+            # to prevent database locking issues\n+            if keepdb and connection.vendor == 'sqlite':\n+                # Close any existing connection to the database file\n+                if connection.connection is not None:\n+                    connection.close()\n+                # Force a fresh connection setup\n+                connection.ensure_connection()\n+\n             # Actually create the database for the first connection\n             if first_alias is None:\n                 first_alias = alias\ndiff --git a/tests/admin_views/test_multidb.py b/tests/admin_views/test_multidb.py\nindex a02b637d34..498028fb19 100644\n--- a/tests/admin_views/test_multidb.py\n+++ b/tests/admin_views/test_multidb.py\n@@ -31,17 +31,24 @@ class MultiDatabaseTests(TestCase):\n     databases = {'default', 'other'}\n \n     @classmethod\n-    def setUpTestData(cls):\n-        cls.superusers = {}\n-        cls.test_book_ids = {}\n-        for db in connections:\n-            Router.target_db = db\n-            cls.superusers[db] = User.objects.create_superuser(\n-                username='admin', password='something', email='test@test.org',\n-            )\n-            b = Book(name='Test Book')\n-            b.save(using=db)\n-            cls.test_book_ids[db] = b.id\n+\n+@classmethod\n+def setUpTestData(cls):\n+    cls.superusers = {}\n+    cls.test_book_ids = {}\n+    for db in connections:\n+        Router.target_db = db\n+        # Ensure clean connection state for each database\n+        connection = connections[db]\n+        if connection.vendor == 'sqlite':\n+            connection.close()\n+            connection.connect()\n+        cls.superusers[db] = User.objects.create_superuser(\n+            username='admin', password='something', email='test@test.org',\n+        )\n+        b = Book(name='Test Book')\n+        b.save(using=db)\n+        cls.test_book_ids[db] = b.id\n \n     @mock.patch('django.contrib.admin.options.transaction')\n     def test_add_view(self, mock):\n",
    "variant_3": "diff --git a/django/db/backends/sqlite3/base.py b/django/db/backends/sqlite3/base.py\nindex a3ae1f048e..a8c2a4c56d 100644\n--- a/django/db/backends/sqlite3/base.py\n+++ b/django/db/backends/sqlite3/base.py\n@@ -257,6 +257,8 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n     def create_cursor(self, name=None):\n         return self.connection.cursor(factory=SQLiteCursorWrapper)\n \n+    @async_unsafe\n+\n     @async_unsafe\n     def close(self):\n         self.validate_thread_sharing()\n@@ -264,6 +266,15 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n         # database. To prevent accidental data loss, ignore close requests on\n         # an in-memory db.\n         if not self.is_in_memory_db():\n+            # For persistent test databases, ensure complete connection cleanup\n+            if hasattr(self, '_test_database') and self._test_database:\n+                # Force close the connection to release file locks\n+                if self.connection is not None:\n+                    try:\n+                        self.connection.close()\n+                    except Database.Error:\n+                        pass\n+                    self.connection = None\n             BaseDatabaseWrapper.close(self)\n \n     def _savepoint_allowed(self):\ndiff --git a/django/db/backends/sqlite3/creation.py b/django/db/backends/sqlite3/creation.py\nindex d97052f52d..e93006edab 100644\n--- a/django/db/backends/sqlite3/creation.py\n+++ b/django/db/backends/sqlite3/creation.py\n@@ -20,11 +20,33 @@ class DatabaseCreation(BaseDatabaseCreation):\n             return 'file:memorydb_%s?mode=memory&cache=shared' % self.connection.alias\n         return test_database_name\n \n+\n     def _create_test_db(self, verbosity, autoclobber, keepdb=False):\n         test_database_name = self._get_test_db_name()\n \n         if keepdb:\n+            # When keepdb is True, ensure any existing connections are properly closed\n+            # to prevent SQLite file locking issues\n+            if not self.is_in_memory_db(test_database_name):\n+                # Close the current connection to release any file locks\n+                if hasattr(self.connection, '_close'):\n+                    self.connection._close()\n+                # Also ensure the connection wrapper is reset\n+                self.connection.close()\n+                # Verify the database file is accessible\n+                if os.access(test_database_name, os.F_OK):\n+                    # Test that we can open and close the database to ensure no locks\n+                    try:\n+                        test_conn = self.connection.__class__(\n+                            self.connection.settings_dict.copy(),\n+                            alias=self.connection.alias + '_test_access'\n+                        )\n+                        test_conn.ensure_connection()\n+                        test_conn.close()\n+                    except Exception as e:\n+                        self.log('Warning: Could not verify test database access: %s' % e)\n             return test_database_name\n+            \n         if not self.is_in_memory_db(test_database_name):\n             # Erase the old test database\n             if verbosity >= 1:\ndiff --git a/django/test/testcases.py b/django/test/testcases.py\nindex 23459f22cd..4477c8df19 100644\n--- a/django/test/testcases.py\n+++ b/django/test/testcases.py\n@@ -1075,11 +1075,16 @@ class TestCase(TransactionTestCase):\n     On database backends with no transaction support, TestCase behaves as\n     TransactionTestCase.\n     \"\"\"\n+\n     @classmethod\n     def _enter_atomics(cls):\n         \"\"\"Open atomic blocks for multiple databases.\"\"\"\n         atomics = {}\n         for db_name in cls._databases_names():\n+            # Ensure connection is properly established before creating atomic block\n+            connection_obj = connections[db_name]\n+            if connection_obj.vendor == 'sqlite' and hasattr(connection_obj, 'ensure_connection'):\n+                connection_obj.ensure_connection()\n             atomics[db_name] = transaction.atomic(using=db_name)\n             atomics[db_name].__enter__()\n         return atomics\n@@ -1090,6 +1095,10 @@ class TestCase(TransactionTestCase):\n         for db_name in reversed(cls._databases_names()):\n             transaction.set_rollback(True, using=db_name)\n             atomics[db_name].__exit__(None, None, None)\n+            # For SQLite, ensure connection state is clean after atomic rollback\n+            connection_obj = connections[db_name]\n+            if connection_obj.vendor == 'sqlite' and connection_obj.in_atomic_block:\n+                connection_obj.validate_thread_sharing()\n \n     @classmethod\n     def _databases_support_transactions(cls):\ndiff --git a/django/test/utils.py b/django/test/utils.py\nindex 819e423326..74c0f5c592 100644\n--- a/django/test/utils.py\n+++ b/django/test/utils.py\n@@ -151,6 +151,7 @@ def teardown_test_environment():\n     del mail.outbox\n \n \n+\n def setup_databases(verbosity, interactive, keepdb=False, debug_sql=False, parallel=0, aliases=None, **kwargs):\n     \"\"\"Create the test databases.\"\"\"\n     test_databases, mirrored_aliases = get_unique_databases_and_mirrors(aliases)\n@@ -166,6 +167,24 @@ def setup_databases(verbosity, interactive, keepdb=False, debug_sql=False, paral\n             # Actually create the database for the first connection\n             if first_alias is None:\n                 first_alias = alias\n+                \n+                # For SQLite with keepdb, ensure any existing connections are closed\n+                # to prevent file locking issues\n+                if keepdb and connection.vendor == 'sqlite':\n+                    # Close the connection if it's open\n+                    if hasattr(connection, 'connection') and connection.connection is not None:\n+                        connection.close()\n+                    \n+                    # Also close any other connections to the same database file\n+                    test_db_name = connection.creation._get_test_db_name()\n+                    for conn_alias in connections:\n+                        other_conn = connections[conn_alias]\n+                        if (other_conn.vendor == 'sqlite' and \n+                            hasattr(other_conn, 'connection') and \n+                            other_conn.connection is not None and\n+                            other_conn.creation._get_test_db_name() == test_db_name):\n+                            other_conn.close()\n+                \n                 connection.creation.create_test_db(\n                     verbosity=verbosity,\n                     autoclobber=not interactive,\ndiff --git a/tests/admin_views/test_multidb.py b/tests/admin_views/test_multidb.py\nindex a02b637d34..aa406d3500 100644\n--- a/tests/admin_views/test_multidb.py\n+++ b/tests/admin_views/test_multidb.py\n@@ -30,12 +30,18 @@ urlpatterns = [\n class MultiDatabaseTests(TestCase):\n     databases = {'default', 'other'}\n \n+    @classmethod\n+\n     @classmethod\n     def setUpTestData(cls):\n         cls.superusers = {}\n         cls.test_book_ids = {}\n         for db in connections:\n             Router.target_db = db\n+            # Close any existing connections to prevent SQLite locking issues\n+            # when using persistent test databases with --keepdb\n+            if hasattr(connections[db], 'close'):\n+                connections[db].close()\n             cls.superusers[db] = User.objects.create_superuser(\n                 username='admin', password='something', email='test@test.org',\n             )\n",
    "variant_4": "diff --git a/django/db/backends/sqlite3/base.py b/django/db/backends/sqlite3/base.py\nindex a3ae1f048e..db0b95fdaa 100644\n--- a/django/db/backends/sqlite3/base.py\n+++ b/django/db/backends/sqlite3/base.py\n@@ -257,6 +257,8 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n     def create_cursor(self, name=None):\n         return self.connection.cursor(factory=SQLiteCursorWrapper)\n \n+    @async_unsafe\n+\n     @async_unsafe\n     def close(self):\n         self.validate_thread_sharing()\n@@ -264,6 +266,15 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n         # database. To prevent accidental data loss, ignore close requests on\n         # an in-memory db.\n         if not self.is_in_memory_db():\n+            # For persistent test databases, ensure complete connection cleanup\n+            # to prevent SQLite file locking issues when using --keepdb\n+            if hasattr(self, '_test_database') and self._test_database:\n+                if self.connection:\n+                    try:\n+                        self.connection.close()\n+                    except Database.ProgrammingError:\n+                        pass\n+                    self.connection = None\n             BaseDatabaseWrapper.close(self)\n \n     def _savepoint_allowed(self):\ndiff --git a/django/db/backends/sqlite3/creation.py b/django/db/backends/sqlite3/creation.py\nindex d97052f52d..92a99dd477 100644\n--- a/django/db/backends/sqlite3/creation.py\n+++ b/django/db/backends/sqlite3/creation.py\n@@ -20,10 +20,20 @@ class DatabaseCreation(BaseDatabaseCreation):\n             return 'file:memorydb_%s?mode=memory&cache=shared' % self.connection.alias\n         return test_database_name\n \n+\n     def _create_test_db(self, verbosity, autoclobber, keepdb=False):\n         test_database_name = self._get_test_db_name()\n \n         if keepdb:\n+            # For persistent test databases, ensure any existing connections are properly closed\n+            if not self.is_in_memory_db(test_database_name):\n+                # Close any existing connections to this database to prevent SQLite locks\n+                from django.db import connections\n+                for conn_alias, conn in connections.all():\n+                    if (hasattr(conn, 'settings_dict') and \n+                        conn.settings_dict.get('ENGINE') == 'django.db.backends.sqlite3' and\n+                        conn.settings_dict.get('NAME') == test_database_name):\n+                        conn.close()\n             return test_database_name\n         if not self.is_in_memory_db(test_database_name):\n             # Erase the old test database\ndiff --git a/django/test/testcases.py b/django/test/testcases.py\nindex 23459f22cd..23dad3d2c5 100644\n--- a/django/test/testcases.py\n+++ b/django/test/testcases.py\n@@ -1075,11 +1075,16 @@ class TestCase(TransactionTestCase):\n     On database backends with no transaction support, TestCase behaves as\n     TransactionTestCase.\n     \"\"\"\n+\n     @classmethod\n     def _enter_atomics(cls):\n         \"\"\"Open atomic blocks for multiple databases.\"\"\"\n         atomics = {}\n         for db_name in cls._databases_names():\n+            # Ensure connection is properly initialized for persistent test databases\n+            conn = connections[db_name]\n+            if hasattr(conn, 'ensure_connection'):\n+                conn.ensure_connection()\n             atomics[db_name] = transaction.atomic(using=db_name)\n             atomics[db_name].__enter__()\n         return atomics\n@@ -1090,6 +1095,12 @@ class TestCase(TransactionTestCase):\n         for db_name in reversed(cls._databases_names()):\n             transaction.set_rollback(True, using=db_name)\n             atomics[db_name].__exit__(None, None, None)\n+            # For SQLite persistent test databases, ensure connection cleanup\n+            conn = connections[db_name]\n+            if (hasattr(conn, 'vendor') and conn.vendor == 'sqlite' and \n+                hasattr(conn, 'settings_dict') and \n+                conn.settings_dict.get('NAME', '').startswith('test_')):\n+                conn.close()\n \n     @classmethod\n     def _databases_support_transactions(cls):\ndiff --git a/django/test/utils.py b/django/test/utils.py\nindex 819e423326..ab22133d7e 100644\n--- a/django/test/utils.py\n+++ b/django/test/utils.py\n@@ -151,6 +151,7 @@ def teardown_test_environment():\n     del mail.outbox\n \n \n+\n def setup_databases(verbosity, interactive, keepdb=False, debug_sql=False, parallel=0, aliases=None, **kwargs):\n     \"\"\"Create the test databases.\"\"\"\n     test_databases, mirrored_aliases = get_unique_databases_and_mirrors(aliases)\n@@ -166,6 +167,16 @@ def setup_databases(verbosity, interactive, keepdb=False, debug_sql=False, paral\n             # Actually create the database for the first connection\n             if first_alias is None:\n                 first_alias = alias\n+                \n+                # For SQLite with keepdb, ensure any existing connections are closed\n+                # to prevent database locking issues\n+                if keepdb and connection.vendor == 'sqlite':\n+                    # Close any existing connection to the database file\n+                    if hasattr(connection, 'close'):\n+                        connection.close()\n+                    # Force a new connection to be created\n+                    connection.connect()\n+                \n                 connection.creation.create_test_db(\n                     verbosity=verbosity,\n                     autoclobber=not interactive,\n@@ -181,10 +192,20 @@ def setup_databases(verbosity, interactive, keepdb=False, debug_sql=False, paral\n                         )\n             # Configure all other connections as mirrors of the first one\n             else:\n+                # For SQLite with keepdb, ensure connection cleanup for mirror databases too\n+                if keepdb and connections[alias].vendor == 'sqlite':\n+                    if hasattr(connections[alias], 'close'):\n+                        connections[alias].close()\n+                \n                 connections[alias].creation.set_as_test_mirror(connections[first_alias].settings_dict)\n \n     # Configure the test mirrors.\n     for alias, mirror_alias in mirrored_aliases.items():\n+        # For SQLite with keepdb, ensure connection cleanup for mirrored aliases\n+        if keepdb and connections[alias].vendor == 'sqlite':\n+            if hasattr(connections[alias], 'close'):\n+                connections[alias].close()\n+        \n         connections[alias].creation.set_as_test_mirror(\n             connections[mirror_alias].settings_dict)\n \ndiff --git a/tests/admin_views/test_multidb.py b/tests/admin_views/test_multidb.py\nindex a02b637d34..0b66847287 100644\n--- a/tests/admin_views/test_multidb.py\n+++ b/tests/admin_views/test_multidb.py\n@@ -30,12 +30,16 @@ urlpatterns = [\n class MultiDatabaseTests(TestCase):\n     databases = {'default', 'other'}\n \n+    @classmethod\n+\n     @classmethod\n     def setUpTestData(cls):\n         cls.superusers = {}\n         cls.test_book_ids = {}\n         for db in connections:\n             Router.target_db = db\n+            # Ensure connection is fresh and not locked\n+            connections[db].close()\n             cls.superusers[db] = User.objects.create_superuser(\n                 username='admin', password='something', email='test@test.org',\n             )\n",
    "variant_5": "diff --git a/django/db/backends/sqlite3/base.py b/django/db/backends/sqlite3/base.py\nindex a3ae1f048e..372c3fd042 100644\n--- a/django/db/backends/sqlite3/base.py\n+++ b/django/db/backends/sqlite3/base.py\n@@ -257,6 +257,8 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n     def create_cursor(self, name=None):\n         return self.connection.cursor(factory=SQLiteCursorWrapper)\n \n+    @async_unsafe\n+\n     @async_unsafe\n     def close(self):\n         self.validate_thread_sharing()\n@@ -264,6 +266,16 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n         # database. To prevent accidental data loss, ignore close requests on\n         # an in-memory db.\n         if not self.is_in_memory_db():\n+            # For persistent test databases, ensure complete connection cleanup\n+            # to prevent SQLite file locking issues when using --keepdb\n+            if hasattr(self, '_test_database_name'):\n+                # Force close any remaining connections and release file locks\n+                if self.connection is not None:\n+                    try:\n+                        self.connection.close()\n+                    except Database.Error:\n+                        pass\n+                    self.connection = None\n             BaseDatabaseWrapper.close(self)\n \n     def _savepoint_allowed(self):\ndiff --git a/django/db/backends/sqlite3/creation.py b/django/db/backends/sqlite3/creation.py\nindex d97052f52d..3ec8749308 100644\n--- a/django/db/backends/sqlite3/creation.py\n+++ b/django/db/backends/sqlite3/creation.py\n@@ -20,10 +20,21 @@ class DatabaseCreation(BaseDatabaseCreation):\n             return 'file:memorydb_%s?mode=memory&cache=shared' % self.connection.alias\n         return test_database_name\n \n+\n     def _create_test_db(self, verbosity, autoclobber, keepdb=False):\n         test_database_name = self._get_test_db_name()\n \n         if keepdb:\n+            # When keeping the database, ensure any existing connections are closed\n+            # to prevent SQLite file locking issues\n+            if not self.is_in_memory_db(test_database_name):\n+                # Close any existing connections to this database file\n+                from django.db import connections\n+                for alias, conn in connections.all():\n+                    if (hasattr(conn, 'settings_dict') and \n+                        conn.settings_dict.get('NAME') == test_database_name and\n+                        conn.connection is not None):\n+                        conn.close()\n             return test_database_name\n         if not self.is_in_memory_db(test_database_name):\n             # Erase the old test database\ndiff --git a/django/test/testcases.py b/django/test/testcases.py\nindex 23459f22cd..741c5564c3 100644\n--- a/django/test/testcases.py\n+++ b/django/test/testcases.py\n@@ -1075,11 +1075,16 @@ class TestCase(TransactionTestCase):\n     On database backends with no transaction support, TestCase behaves as\n     TransactionTestCase.\n     \"\"\"\n+\n     @classmethod\n     def _enter_atomics(cls):\n         \"\"\"Open atomic blocks for multiple databases.\"\"\"\n         atomics = {}\n         for db_name in cls._databases_names():\n+            # Ensure connection is properly established before creating atomic block\n+            connection = connections[db_name]\n+            if connection.vendor == 'sqlite' and hasattr(connection, 'ensure_connection'):\n+                connection.ensure_connection()\n             atomics[db_name] = transaction.atomic(using=db_name)\n             atomics[db_name].__enter__()\n         return atomics\n@@ -1090,6 +1095,10 @@ class TestCase(TransactionTestCase):\n         for db_name in reversed(cls._databases_names()):\n             transaction.set_rollback(True, using=db_name)\n             atomics[db_name].__exit__(None, None, None)\n+            # For SQLite, ensure connection state is clean after rollback\n+            connection = connections[db_name]\n+            if connection.vendor == 'sqlite' and connection.in_atomic_block:\n+                connection.in_atomic_block = False\n \n     @classmethod\n     def _databases_support_transactions(cls):\ndiff --git a/django/test/utils.py b/django/test/utils.py\nindex 819e423326..a30b12a27e 100644\n--- a/django/test/utils.py\n+++ b/django/test/utils.py\n@@ -151,6 +151,7 @@ def teardown_test_environment():\n     del mail.outbox\n \n \n+\n def setup_databases(verbosity, interactive, keepdb=False, debug_sql=False, parallel=0, aliases=None, **kwargs):\n     \"\"\"Create the test databases.\"\"\"\n     test_databases, mirrored_aliases = get_unique_databases_and_mirrors(aliases)\n@@ -166,6 +167,14 @@ def setup_databases(verbosity, interactive, keepdb=False, debug_sql=False, paral\n             # Actually create the database for the first connection\n             if first_alias is None:\n                 first_alias = alias\n+                # For SQLite with keepdb, ensure any existing connections are properly closed\n+                if keepdb and connection.vendor == 'sqlite':\n+                    # Close the connection to release any file locks\n+                    connection.close()\n+                    # Force a new connection to be created\n+                    connection.connection = None\n+                    connection.queries_log.clear()\n+                \n                 connection.creation.create_test_db(\n                     verbosity=verbosity,\n                     autoclobber=not interactive,\n@@ -181,10 +190,21 @@ def setup_databases(verbosity, interactive, keepdb=False, debug_sql=False, paral\n                         )\n             # Configure all other connections as mirrors of the first one\n             else:\n+                # For SQLite with keepdb, ensure mirror connections are also properly cleaned\n+                if keepdb and connection.vendor == 'sqlite':\n+                    connection.close()\n+                    connection.connection = None\n+                    connection.queries_log.clear()\n                 connections[alias].creation.set_as_test_mirror(connections[first_alias].settings_dict)\n \n     # Configure the test mirrors.\n     for alias, mirror_alias in mirrored_aliases.items():\n+        connection = connections[alias]\n+        # For SQLite with keepdb, ensure mirrored connections are properly cleaned\n+        if keepdb and connection.vendor == 'sqlite':\n+            connection.close()\n+            connection.connection = None\n+            connection.queries_log.clear()\n         connections[alias].creation.set_as_test_mirror(\n             connections[mirror_alias].settings_dict)\n \ndiff --git a/tests/admin_views/test_multidb.py b/tests/admin_views/test_multidb.py\nindex a02b637d34..a72690dfec 100644\n--- a/tests/admin_views/test_multidb.py\n+++ b/tests/admin_views/test_multidb.py\n@@ -30,12 +30,18 @@ urlpatterns = [\n class MultiDatabaseTests(TestCase):\n     databases = {'default', 'other'}\n \n+    @classmethod\n+\n     @classmethod\n     def setUpTestData(cls):\n         cls.superusers = {}\n         cls.test_book_ids = {}\n         for db in connections:\n             Router.target_db = db\n+            # Ensure database connection is properly initialized\n+            connection = connections[db]\n+            if connection.vendor == 'sqlite' and hasattr(connection, 'ensure_connection'):\n+                connection.ensure_connection()\n             cls.superusers[db] = User.objects.create_superuser(\n                 username='admin', password='something', email='test@test.org',\n             )\n",
    "variant_6": "diff --git a/django/db/backends/sqlite3/base.py b/django/db/backends/sqlite3/base.py\nindex a3ae1f048e..02a67f1ac6 100644\n--- a/django/db/backends/sqlite3/base.py\n+++ b/django/db/backends/sqlite3/base.py\n@@ -257,6 +257,8 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n     def create_cursor(self, name=None):\n         return self.connection.cursor(factory=SQLiteCursorWrapper)\n \n+    @async_unsafe\n+\n     @async_unsafe\n     def close(self):\n         self.validate_thread_sharing()\n@@ -264,6 +266,16 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n         # database. To prevent accidental data loss, ignore close requests on\n         # an in-memory db.\n         if not self.is_in_memory_db():\n+            # For persistent test databases, ensure complete cleanup\n+            # to prevent file locking issues when using --keepdb\n+            if hasattr(self, '_test_database') and self._test_database:\n+                # Force close the underlying connection to release file locks\n+                if self.connection is not None:\n+                    try:\n+                        self.connection.close()\n+                    except Database.Error:\n+                        pass\n+                    self.connection = None\n             BaseDatabaseWrapper.close(self)\n \n     def _savepoint_allowed(self):\ndiff --git a/django/db/backends/sqlite3/creation.py b/django/db/backends/sqlite3/creation.py\nindex d97052f52d..975baf6bf8 100644\n--- a/django/db/backends/sqlite3/creation.py\n+++ b/django/db/backends/sqlite3/creation.py\n@@ -20,11 +20,32 @@ class DatabaseCreation(BaseDatabaseCreation):\n             return 'file:memorydb_%s?mode=memory&cache=shared' % self.connection.alias\n         return test_database_name\n \n+\n     def _create_test_db(self, verbosity, autoclobber, keepdb=False):\n         test_database_name = self._get_test_db_name()\n \n         if keepdb:\n+            # When keeping the database, ensure any existing connections are closed\n+            # to prevent SQLite file locking issues\n+            if not self.is_in_memory_db(test_database_name):\n+                # Close any existing connections to this database file\n+                from django.db import connections\n+                for alias, conn in connections.all():\n+                    if (hasattr(conn, 'settings_dict') and \n+                        conn.settings_dict.get('NAME') == test_database_name):\n+                        conn.close()\n+                \n+                # Verify the database file is accessible\n+                if os.path.exists(test_database_name):\n+                    try:\n+                        # Test file access to ensure it's not locked\n+                        with open(test_database_name, 'r+b'):\n+                            pass\n+                    except (OSError, IOError) as e:\n+                        if verbosity >= 1:\n+                            self.log('Warning: Test database file may be locked: %s' % e)\n             return test_database_name\n+            \n         if not self.is_in_memory_db(test_database_name):\n             # Erase the old test database\n             if verbosity >= 1:\ndiff --git a/django/test/testcases.py b/django/test/testcases.py\nindex 23459f22cd..e378e3e30e 100644\n--- a/django/test/testcases.py\n+++ b/django/test/testcases.py\n@@ -1075,21 +1075,42 @@ class TestCase(TransactionTestCase):\n     On database backends with no transaction support, TestCase behaves as\n     TransactionTestCase.\n     \"\"\"\n-    @classmethod\n-    def _enter_atomics(cls):\n-        \"\"\"Open atomic blocks for multiple databases.\"\"\"\n-        atomics = {}\n-        for db_name in cls._databases_names():\n-            atomics[db_name] = transaction.atomic(using=db_name)\n-            atomics[db_name].__enter__()\n-        return atomics\n \n-    @classmethod\n-    def _rollback_atomics(cls, atomics):\n-        \"\"\"Rollback atomic blocks opened by the previous method.\"\"\"\n-        for db_name in reversed(cls._databases_names()):\n-            transaction.set_rollback(True, using=db_name)\n-            atomics[db_name].__exit__(None, None, None)\n+@classmethod\n+def _enter_atomics(cls):\n+    \"\"\"Open atomic blocks for multiple databases.\"\"\"\n+    atomics = {}\n+    for db_name in cls._databases_names():\n+        # Ensure connection is fresh for persistent test databases\n+        connection_obj = connections[db_name]\n+        if (hasattr(connection_obj, 'creation') and \n+            hasattr(connection_obj.creation, '_test_database_name') and\n+            connection_obj.creation._test_database_name and\n+            connection_obj.vendor == 'sqlite'):\n+            # For SQLite persistent test databases, ensure clean connection state\n+            if connection_obj.connection is not None:\n+                connection_obj.close()\n+        \n+        atomics[db_name] = transaction.atomic(using=db_name)\n+        atomics[db_name].__enter__()\n+    return atomics\n+\n+@classmethod\n+def _rollback_atomics(cls, atomics):\n+    \"\"\"Rollback atomic blocks opened by the previous method.\"\"\"\n+    for db_name in reversed(cls._databases_names()):\n+        transaction.set_rollback(True, using=db_name)\n+        atomics[db_name].__exit__(None, None, None)\n+        \n+        # Ensure clean connection state after rollback for persistent test databases\n+        connection_obj = connections[db_name]\n+        if (hasattr(connection_obj, 'creation') and \n+            hasattr(connection_obj.creation, '_test_database_name') and\n+            connection_obj.creation._test_database_name and\n+            connection_obj.vendor == 'sqlite'):\n+            # For SQLite persistent test databases, ensure connection is properly closed\n+            if connection_obj.connection is not None:\n+                connection_obj.close()\n \n     @classmethod\n     def _databases_support_transactions(cls):\ndiff --git a/django/test/utils.py b/django/test/utils.py\nindex 819e423326..899b0dcbc0 100644\n--- a/django/test/utils.py\n+++ b/django/test/utils.py\n@@ -151,6 +151,7 @@ def teardown_test_environment():\n     del mail.outbox\n \n \n+\n def setup_databases(verbosity, interactive, keepdb=False, debug_sql=False, parallel=0, aliases=None, **kwargs):\n     \"\"\"Create the test databases.\"\"\"\n     test_databases, mirrored_aliases = get_unique_databases_and_mirrors(aliases)\n@@ -163,6 +164,12 @@ def setup_databases(verbosity, interactive, keepdb=False, debug_sql=False, paral\n             connection = connections[alias]\n             old_names.append((connection, db_name, first_alias is None))\n \n+            # For SQLite with keepdb, close any existing connections to prevent locking\n+            if keepdb and connection.vendor == 'sqlite':\n+                # Close the connection if it exists\n+                if hasattr(connection, 'connection') and connection.connection is not None:\n+                    connection.close()\n+\n             # Actually create the database for the first connection\n             if first_alias is None:\n                 first_alias = alias\ndiff --git a/tests/admin_views/test_multidb.py b/tests/admin_views/test_multidb.py\nindex a02b637d34..d4d35d9c93 100644\n--- a/tests/admin_views/test_multidb.py\n+++ b/tests/admin_views/test_multidb.py\n@@ -30,12 +30,20 @@ urlpatterns = [\n class MultiDatabaseTests(TestCase):\n     databases = {'default', 'other'}\n \n+    @classmethod\n+\n     @classmethod\n     def setUpTestData(cls):\n         cls.superusers = {}\n         cls.test_book_ids = {}\n         for db in connections:\n             Router.target_db = db\n+            # Ensure connection is properly established before creating objects\n+            connection = connections[db]\n+            if connection.vendor == 'sqlite':\n+                # For SQLite, ensure the connection is fresh and not locked\n+                connection.close()\n+                connection.ensure_connection()\n             cls.superusers[db] = User.objects.create_superuser(\n                 username='admin', password='something', email='test@test.org',\n             )\n",
    "variant_7": "diff --git a/django/db/backends/sqlite3/base.py b/django/db/backends/sqlite3/base.py\nindex a3ae1f048e..09843326cd 100644\n--- a/django/db/backends/sqlite3/base.py\n+++ b/django/db/backends/sqlite3/base.py\n@@ -257,6 +257,8 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n     def create_cursor(self, name=None):\n         return self.connection.cursor(factory=SQLiteCursorWrapper)\n \n+    @async_unsafe\n+\n     @async_unsafe\n     def close(self):\n         self.validate_thread_sharing()\n@@ -264,6 +266,16 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n         # database. To prevent accidental data loss, ignore close requests on\n         # an in-memory db.\n         if not self.is_in_memory_db():\n+            # For persistent test databases, ensure complete connection cleanup\n+            # to prevent SQLite file locking issues when using --keepdb\n+            if hasattr(self, 'settings_dict') and self.settings_dict.get('NAME'):\n+                # Force connection cleanup for file-based databases\n+                if hasattr(self, 'connection') and self.connection:\n+                    try:\n+                        self.connection.close()\n+                    except Exception:\n+                        pass\n+                    self.connection = None\n             BaseDatabaseWrapper.close(self)\n \n     def _savepoint_allowed(self):\ndiff --git a/django/db/backends/sqlite3/creation.py b/django/db/backends/sqlite3/creation.py\nindex d97052f52d..ffd902636e 100644\n--- a/django/db/backends/sqlite3/creation.py\n+++ b/django/db/backends/sqlite3/creation.py\n@@ -20,11 +20,36 @@ class DatabaseCreation(BaseDatabaseCreation):\n             return 'file:memorydb_%s?mode=memory&cache=shared' % self.connection.alias\n         return test_database_name\n \n+\n     def _create_test_db(self, verbosity, autoclobber, keepdb=False):\n         test_database_name = self._get_test_db_name()\n \n         if keepdb:\n+            # When keeping the database, ensure any existing connections are closed\n+            # to prevent SQLite file locking issues\n+            if not self.is_in_memory_db(test_database_name):\n+                # Close any existing connections to this database file\n+                from django.db import connections\n+                for alias, conn in connections.all():\n+                    if (hasattr(conn, 'settings_dict') and \n+                        conn.settings_dict.get('NAME') == test_database_name):\n+                        conn.close()\n+                \n+                # Verify the database file is accessible\n+                if os.access(test_database_name, os.F_OK):\n+                    try:\n+                        # Test that we can open the database without locks\n+                        import sqlite3\n+                        test_conn = sqlite3.connect(test_database_name, timeout=1.0)\n+                        test_conn.close()\n+                    except sqlite3.OperationalError as e:\n+                        if 'locked' in str(e).lower():\n+                            self.log('Database file is locked, cannot reuse: %s' % e)\n+                            sys.exit(2)\n+                        # Re-raise other operational errors\n+                        raise\n             return test_database_name\n+            \n         if not self.is_in_memory_db(test_database_name):\n             # Erase the old test database\n             if verbosity >= 1:\ndiff --git a/django/test/testcases.py b/django/test/testcases.py\nindex 23459f22cd..85e2684cca 100644\n--- a/django/test/testcases.py\n+++ b/django/test/testcases.py\n@@ -1075,11 +1075,16 @@ class TestCase(TransactionTestCase):\n     On database backends with no transaction support, TestCase behaves as\n     TransactionTestCase.\n     \"\"\"\n+\n     @classmethod\n     def _enter_atomics(cls):\n         \"\"\"Open atomic blocks for multiple databases.\"\"\"\n         atomics = {}\n         for db_name in cls._databases_names():\n+            # Ensure connection is properly established before entering atomic block\n+            connection_obj = connections[db_name]\n+            if hasattr(connection_obj, 'ensure_connection'):\n+                connection_obj.ensure_connection()\n             atomics[db_name] = transaction.atomic(using=db_name)\n             atomics[db_name].__enter__()\n         return atomics\n@@ -1088,8 +1093,15 @@ class TestCase(TransactionTestCase):\n     def _rollback_atomics(cls, atomics):\n         \"\"\"Rollback atomic blocks opened by the previous method.\"\"\"\n         for db_name in reversed(cls._databases_names()):\n-            transaction.set_rollback(True, using=db_name)\n-            atomics[db_name].__exit__(None, None, None)\n+            try:\n+                transaction.set_rollback(True, using=db_name)\n+                atomics[db_name].__exit__(None, None, None)\n+            except Exception:\n+                # If rollback fails, ensure connection is closed to prevent locks\n+                connection_obj = connections[db_name]\n+                if hasattr(connection_obj, 'close'):\n+                    connection_obj.close()\n+                raise\n \n     @classmethod\n     def _databases_support_transactions(cls):\ndiff --git a/django/test/utils.py b/django/test/utils.py\nindex 819e423326..38a19fa7bf 100644\n--- a/django/test/utils.py\n+++ b/django/test/utils.py\n@@ -151,6 +151,7 @@ def teardown_test_environment():\n     del mail.outbox\n \n \n+\n def setup_databases(verbosity, interactive, keepdb=False, debug_sql=False, parallel=0, aliases=None, **kwargs):\n     \"\"\"Create the test databases.\"\"\"\n     test_databases, mirrored_aliases = get_unique_databases_and_mirrors(aliases)\n@@ -166,6 +167,20 @@ def setup_databases(verbosity, interactive, keepdb=False, debug_sql=False, paral\n             # Actually create the database for the first connection\n             if first_alias is None:\n                 first_alias = alias\n+                \n+                # For SQLite with keepdb, ensure any existing connections are closed\n+                if keepdb and connection.vendor == 'sqlite':\n+                    # Close any existing connection to the database file\n+                    if connection.connection is not None:\n+                        connection.close()\n+                    # Also close any other connections that might be using the same database\n+                    for other_alias in connections:\n+                        other_conn = connections[other_alias]\n+                        if (other_conn.vendor == 'sqlite' and \n+                            other_conn.settings_dict['NAME'] == connection.settings_dict['NAME']):\n+                            if other_conn.connection is not None:\n+                                other_conn.close()\n+                \n                 connection.creation.create_test_db(\n                     verbosity=verbosity,\n                     autoclobber=not interactive,\ndiff --git a/tests/admin_views/test_multidb.py b/tests/admin_views/test_multidb.py\nindex a02b637d34..836853fde9 100644\n--- a/tests/admin_views/test_multidb.py\n+++ b/tests/admin_views/test_multidb.py\n@@ -30,12 +30,17 @@ urlpatterns = [\n class MultiDatabaseTests(TestCase):\n     databases = {'default', 'other'}\n \n+    @classmethod\n+\n     @classmethod\n     def setUpTestData(cls):\n         cls.superusers = {}\n         cls.test_book_ids = {}\n         for db in connections:\n             Router.target_db = db\n+            # Ensure connection is properly initialized for this database\n+            connection = connections[db]\n+            connection.ensure_connection()\n             cls.superusers[db] = User.objects.create_superuser(\n                 username='admin', password='something', email='test@test.org',\n             )\n",
    "variant_8": "diff --git a/django/db/backends/sqlite3/base.py b/django/db/backends/sqlite3/base.py\nindex a3ae1f048e..f55d421fd8 100644\n--- a/django/db/backends/sqlite3/base.py\n+++ b/django/db/backends/sqlite3/base.py\n@@ -257,6 +257,8 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n     def create_cursor(self, name=None):\n         return self.connection.cursor(factory=SQLiteCursorWrapper)\n \n+    @async_unsafe\n+\n     @async_unsafe\n     def close(self):\n         self.validate_thread_sharing()\n@@ -264,6 +266,20 @@ class DatabaseWrapper(BaseDatabaseWrapper):\n         # database. To prevent accidental data loss, ignore close requests on\n         # an in-memory db.\n         if not self.is_in_memory_db():\n+            # For persistent test databases, ensure complete connection cleanup\n+            # to prevent SQLite file locking issues with --keepdb\n+            if hasattr(self, 'connection') and self.connection:\n+                try:\n+                    # Ensure all pending transactions are committed or rolled back\n+                    if self.connection.in_transaction:\n+                        self.connection.rollback()\n+                    # Close the underlying SQLite connection\n+                    self.connection.close()\n+                except Database.Error:\n+                    # Ignore errors during cleanup\n+                    pass\n+                finally:\n+                    self.connection = None\n             BaseDatabaseWrapper.close(self)\n \n     def _savepoint_allowed(self):\ndiff --git a/django/db/backends/sqlite3/creation.py b/django/db/backends/sqlite3/creation.py\nindex d97052f52d..1d434192cb 100644\n--- a/django/db/backends/sqlite3/creation.py\n+++ b/django/db/backends/sqlite3/creation.py\n@@ -20,11 +20,29 @@ class DatabaseCreation(BaseDatabaseCreation):\n             return 'file:memorydb_%s?mode=memory&cache=shared' % self.connection.alias\n         return test_database_name\n \n+\n     def _create_test_db(self, verbosity, autoclobber, keepdb=False):\n         test_database_name = self._get_test_db_name()\n \n         if keepdb:\n+            # When keeping the database, ensure any existing connections are closed\n+            # to prevent SQLite file locking issues\n+            if not self.is_in_memory_db(test_database_name):\n+                # Close the current connection if it exists\n+                if hasattr(self.connection, 'connection') and self.connection.connection:\n+                    self.connection.close()\n+                \n+                # Import here to avoid circular imports\n+                from django.db import connections\n+                \n+                # Close any other connections to this database file\n+                for alias, conn in connections.all():\n+                    if (hasattr(conn, 'settings_dict') and \n+                        conn.settings_dict.get('NAME') == test_database_name and\n+                        hasattr(conn, 'connection') and conn.connection):\n+                        conn.close()\n             return test_database_name\n+            \n         if not self.is_in_memory_db(test_database_name):\n             # Erase the old test database\n             if verbosity >= 1:\ndiff --git a/django/test/testcases.py b/django/test/testcases.py\nindex 23459f22cd..a754b957b6 100644\n--- a/django/test/testcases.py\n+++ b/django/test/testcases.py\n@@ -1075,11 +1075,16 @@ class TestCase(TransactionTestCase):\n     On database backends with no transaction support, TestCase behaves as\n     TransactionTestCase.\n     \"\"\"\n+\n     @classmethod\n     def _enter_atomics(cls):\n         \"\"\"Open atomic blocks for multiple databases.\"\"\"\n         atomics = {}\n         for db_name in cls._databases_names():\n+            # Ensure connection is properly established before entering atomic block\n+            connection = connections[db_name]\n+            if connection.vendor == 'sqlite' and hasattr(connection, 'ensure_connection'):\n+                connection.ensure_connection()\n             atomics[db_name] = transaction.atomic(using=db_name)\n             atomics[db_name].__enter__()\n         return atomics\n@@ -1088,8 +1093,16 @@ class TestCase(TransactionTestCase):\n     def _rollback_atomics(cls, atomics):\n         \"\"\"Rollback atomic blocks opened by the previous method.\"\"\"\n         for db_name in reversed(cls._databases_names()):\n-            transaction.set_rollback(True, using=db_name)\n-            atomics[db_name].__exit__(None, None, None)\n+            try:\n+                transaction.set_rollback(True, using=db_name)\n+                atomics[db_name].__exit__(None, None, None)\n+            except Exception:\n+                # Ensure cleanup continues even if one database fails\n+                connection = connections[db_name]\n+                if connection.vendor == 'sqlite':\n+                    # Force close SQLite connection to release locks\n+                    connection.close()\n+                raise\n \n     @classmethod\n     def _databases_support_transactions(cls):\ndiff --git a/django/test/utils.py b/django/test/utils.py\nindex 819e423326..d0adc978f9 100644\n--- a/django/test/utils.py\n+++ b/django/test/utils.py\n@@ -151,6 +151,7 @@ def teardown_test_environment():\n     del mail.outbox\n \n \n+\n def setup_databases(verbosity, interactive, keepdb=False, debug_sql=False, parallel=0, aliases=None, **kwargs):\n     \"\"\"Create the test databases.\"\"\"\n     test_databases, mirrored_aliases = get_unique_databases_and_mirrors(aliases)\n@@ -166,6 +167,20 @@ def setup_databases(verbosity, interactive, keepdb=False, debug_sql=False, paral\n             # Actually create the database for the first connection\n             if first_alias is None:\n                 first_alias = alias\n+                \n+                # For SQLite with keepdb, ensure any existing connections are properly closed\n+                if keepdb and connection.vendor == 'sqlite':\n+                    # Close existing connection if it exists\n+                    if hasattr(connection, 'connection') and connection.connection is not None:\n+                        connection.close()\n+                    # Also close any other connections to the same database\n+                    for other_alias in connections:\n+                        other_conn = connections[other_alias]\n+                        if (other_conn.vendor == 'sqlite' and \n+                            other_conn.settings_dict.get('NAME') == connection.settings_dict.get('NAME') and\n+                            hasattr(other_conn, 'connection') and other_conn.connection is not None):\n+                            other_conn.close()\n+                \n                 connection.creation.create_test_db(\n                     verbosity=verbosity,\n                     autoclobber=not interactive,\ndiff --git a/tests/admin_views/test_multidb.py b/tests/admin_views/test_multidb.py\nindex a02b637d34..8cb4959b0d 100644\n--- a/tests/admin_views/test_multidb.py\n+++ b/tests/admin_views/test_multidb.py\n@@ -30,12 +30,18 @@ urlpatterns = [\n class MultiDatabaseTests(TestCase):\n     databases = {'default', 'other'}\n \n+    @classmethod\n+\n     @classmethod\n     def setUpTestData(cls):\n         cls.superusers = {}\n         cls.test_book_ids = {}\n         for db in connections:\n             Router.target_db = db\n+            # Ensure connection is properly initialized for persistent databases\n+            connection = connections[db]\n+            if connection.vendor == 'sqlite' and hasattr(connection, 'ensure_connection'):\n+                connection.ensure_connection()\n             cls.superusers[db] = User.objects.create_superuser(\n                 username='admin', password='something', email='test@test.org',\n             )\n"
  }
}