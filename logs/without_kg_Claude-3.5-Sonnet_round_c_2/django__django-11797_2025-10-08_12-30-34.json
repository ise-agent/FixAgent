{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/django/django/db/models/sql/query.py lines 455-456)": "\n                if inner_query.default_cols and has_existing_aggregate_annotations and not inner_query.group_by:\n                    inner_query.group_by = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)\n",
    "Location 2 (/root/hy/projects_2/django/django/db/models/sql/query.py lines 432-433)": "\n        if (isinstance(self.group_by, tuple) or self.is_sliced or existing_annotations or\n                self.distinct or self.combinator):\n",
    "Location 3 (/root/hy/projects_2/django/django/db/models/sql/query.py lines 445-457)": "\n            if not inner_query.distinct:\n                # If the inner query uses default select and it has some\n                # aggregate annotations, then we must make sure the inner\n                # query is grouped by the main model's primary key. However,\n                # clearing the select clause can alter results if distinct is\n                # used.\n                has_existing_aggregate_annotations = any(\n                    annotation for annotation in existing_annotations\n                    if getattr(annotation, 'contains_aggregate', True)\n                )\n                if inner_query.default_cols and has_existing_aggregate_annotations and not inner_query.group_by:\n                    inner_query.group_by = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)\n                inner_query.default_cols = False\n",
    "Location 4 (/root/hy/projects_2/django/django/db/models/sql/query.py lines 183-189)": "\n        # The group_by attribute can have one of the following forms:\n        #  - None: no group by at all in the query\n        #  - A tuple of expressions: group by (at least) those expressions.\n        #    String refs are also allowed for now.\n        #  - True: group by all select fields of the model\n        # See compiler.get_group_by() for details.\n        self.group_by = None\n",
    "Location 5 (/root/hy/projects_2/django/django/db/models/sql/query.py lines 1911-1936)": "\n    def set_group_by(self):\n        \"\"\"\n        Expand the GROUP BY clause required by the query.\n\n        This will usually be the set of all non-aggregate fields in the\n        return data. If the database backend supports grouping by the\n        primary key, and the query would be equivalent, the optimization\n        will be made automatically.\n        \"\"\"\n        group_by = list(self.select)\n        if self.annotation_select:\n            for alias, annotation in self.annotation_select.items():\n                try:\n                    inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n                except TypeError:\n                    annotation_class = annotation.__class__\n                    msg = (\n                        '`alias=None` must be added to the signature of '\n                        '%s.%s.get_group_by_cols().'\n                    ) % (annotation_class.__module__, annotation_class.__qualname__)\n                    warnings.warn(msg, category=RemovedInDjango40Warning)\n                    group_by_cols = annotation.get_group_by_cols()\n                else:\n                    group_by_cols = annotation.get_group_by_cols(alias=alias)\n                group_by.extend(group_by_cols)\n        self.group_by = tuple(group_by)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/django/django/db/models/sql/query.py lines 455-456)": [
      "\n            if not inner_query.distinct:\n                # If the inner query uses default select and it has some\n                # aggregate annotations, then we must make sure the inner\n                # query is grouped by the main model's primary key. However,\n                # clearing the select clause can alter results if distinct is\n                # used.\n                has_existing_aggregate_annotations = any(\n                    annotation for annotation in existing_annotations\n                    if getattr(annotation, 'contains_aggregate', True)\n                )\n                if inner_query.default_cols and has_existing_aggregate_annotations and not inner_query.group_by:\n                    inner_query.group_by = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)\n",
      "\n                if inner_query.default_cols and has_existing_aggregate_annotations and not inner_query.group_by:\n                    inner_query.group_by = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)\n",
      "\n            if not inner_query.distinct:\n                # If the inner query uses default select and it has some\n                # aggregate annotations, then we must make sure the inner\n                # query is grouped by the main model's primary key. However,\n                # clearing the select clause can alter results if distinct is\n                # used.\n                has_existing_aggregate_annotations = any(\n                    annotation for annotation in existing_annotations\n                    if getattr(annotation, 'contains_aggregate', True)\n                )\n                if inner_query.default_cols and has_existing_aggregate_annotations and not inner_query.group_by:\n                    inner_query.group_by = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)\n                inner_query.default_cols = False\n",
      "\n                if inner_query.default_cols and has_existing_aggregate_annotations and not inner_query.group_by:\n                    inner_query.group_by = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)\n",
      "\n                if inner_query.default_cols and has_existing_aggregate_annotations and not inner_query.group_by:\n                    inner_query.group_by = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)\n",
      "\n                if inner_query.default_cols and has_existing_aggregate_annotations and not inner_query.group_by:\n                    inner_query.group_by = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)\n",
      "\n                if inner_query.default_cols and has_existing_aggregate_annotations and not inner_query.group_by:\n                    inner_query.group_by = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)\n",
      "\n                if inner_query.default_cols and has_existing_aggregate_annotations and not inner_query.group_by:\n                    inner_query.group_by = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)\n"
    ],
    "Location 2 (/root/hy/projects_2/django/django/db/models/sql/query.py lines 432-433)": [
      "\n        if (isinstance(self.group_by, tuple) or self.is_sliced or existing_annotations or\n                self.distinct or self.combinator):\n",
      "\n        if (isinstance(self.group_by, tuple) or self.is_sliced or existing_annotations or\n                self.distinct or self.combinator):\n",
      "\n        if (isinstance(self.group_by, tuple) or self.is_sliced or existing_annotations or\n                self.distinct or self.combinator):\n",
      "\n        if (isinstance(self.group_by, tuple) or self.is_sliced or existing_annotations or\n                self.distinct or self.combinator):\n",
      "\n        if (isinstance(self.group_by, tuple) or self.is_sliced or existing_annotations or\n                self.distinct or self.combinator):\n",
      "\n        if (isinstance(self.group_by, tuple) or self.is_sliced or existing_annotations or\n                self.distinct or self.combinator):\n",
      "\n        if (isinstance(self.group_by, tuple) or self.is_sliced or existing_annotations or\n                self.distinct or self.combinator):\n",
      "\n        if (isinstance(self.group_by, tuple) or self.is_sliced or existing_annotations or\n                self.distinct or self.combinator):\n"
    ],
    "Location 3 (/root/hy/projects_2/django/django/db/models/sql/query.py lines 445-457)": [
      "\n            if not inner_query.distinct:\n                # If the inner query uses default select and it has some\n                # aggregate annotations, then we must make sure the inner\n                # query is grouped by the main model's primary key. However,\n                # clearing the select clause can alter results if distinct is\n                # used.\n                has_existing_aggregate_annotations = any(\n                    annotation for annotation in existing_annotations\n                    if getattr(annotation, 'contains_aggregate', True)\n                )\n                if inner_query.default_cols and has_existing_aggregate_annotations and not inner_query.group_by:\n                    inner_query.group_by = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)\n                inner_query.default_cols = False\n",
      "\n            if not inner_query.distinct:\n                # If the inner query uses default select and it has some\n                # aggregate annotations, then we must make sure the inner\n                # query is grouped by the main model's primary key. However,\n                # clearing the select clause can alter results if distinct is\n                # used.\n                has_existing_aggregate_annotations = any(\n                    annotation for annotation in existing_annotations\n                    if getattr(annotation, 'contains_aggregate', True)\n                )\n                if inner_query.default_cols and has_existing_aggregate_annotations and not inner_query.group_by:\n                    inner_query.group_by = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)\n                inner_query.default_cols = False\n",
      "\n            if not inner_query.distinct:\n                # If the inner query uses default select and it has some\n                # aggregate annotations, then we must make sure the inner\n                # query is grouped by the main model's primary key. However,\n                # clearing the select clause can alter results if distinct is\n                # used.\n                has_existing_aggregate_annotations = any(\n                    annotation for annotation in existing_annotations\n                    if getattr(annotation, 'contains_aggregate', True)\n                )\n                if inner_query.default_cols and has_existing_aggregate_annotations and not inner_query.group_by:\n                    inner_query.group_by = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)\n                inner_query.default_cols = False\n",
      "\n            if not inner_query.distinct:\n                # If the inner query uses default select and it has some\n                # aggregate annotations, then we must make sure the inner\n                # query is grouped by the main model's primary key. However,\n                # clearing the select clause can alter results if distinct is\n                # used.\n                has_existing_aggregate_annotations = any(\n                    annotation for annotation in existing_annotations\n                    if getattr(annotation, 'contains_aggregate', True)\n                )\n                if inner_query.default_cols and has_existing_aggregate_annotations and not inner_query.group_by:\n                    inner_query.group_by = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)\n                inner_query.default_cols = False\n",
      "\n            if not inner_query.distinct:\n                # If the inner query uses default select and it has some\n                # aggregate annotations, then we must make sure the inner\n                # query is grouped by the main model's primary key. However,\n                # clearing the select clause can alter results if distinct is\n                # used.\n                has_existing_aggregate_annotations = any(\n                    annotation for annotation in existing_annotations\n                    if getattr(annotation, 'contains_aggregate', True)\n                )\n                if inner_query.default_cols and has_existing_aggregate_annotations and not inner_query.group_by:\n                    inner_query.group_by = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)\n                inner_query.default_cols = False\n",
      "\n            if not inner_query.distinct:\n                # If the inner query uses default select and it has some\n                # aggregate annotations, then we must make sure the inner\n                # query is grouped by the main model's primary key. However,\n                # clearing the select clause can alter results if distinct is\n                # used.\n                has_existing_aggregate_annotations = any(\n                    annotation for annotation in existing_annotations\n                    if getattr(annotation, 'contains_aggregate', True)\n                )\n                if inner_query.default_cols and has_existing_aggregate_annotations and not inner_query.group_by:\n                    inner_query.group_by = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)\n                inner_query.default_cols = False\n",
      "\n            if not inner_query.distinct:\n                # If the inner query uses default select and it has some\n                # aggregate annotations, then we must make sure the inner\n                # query is grouped by the main model's primary key. However,\n                # clearing the select clause can alter results if distinct is\n                # used.\n                has_existing_aggregate_annotations = any(\n                    annotation for annotation in existing_annotations\n                    if getattr(annotation, 'contains_aggregate', True)\n                )\n                if inner_query.default_cols and has_existing_aggregate_annotations and not inner_query.group_by:\n                    inner_query.group_by = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)\n                inner_query.default_cols = False\n",
      "\n            if not inner_query.distinct:\n                # If the inner query uses default select and it has some\n                # aggregate annotations, then we must make sure the inner\n                # query is grouped by the main model's primary key. However,\n                # clearing the select clause can alter results if distinct is\n                # used.\n                has_existing_aggregate_annotations = any(\n                    annotation for annotation in existing_annotations\n                    if getattr(annotation, 'contains_aggregate', True)\n                )\n                if inner_query.default_cols and has_existing_aggregate_annotations and not inner_query.group_by:\n                    inner_query.group_by = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)\n                inner_query.default_cols = False\n"
    ],
    "Location 4 (/root/hy/projects_2/django/django/db/models/sql/query.py lines 183-189)": [
      "\n        # The group_by attribute can have one of the following forms:\n        #  - None: no group by at all in the query\n        #  - A tuple of expressions: group by (at least) those expressions.\n        #    String refs are also allowed for now.\n        #  - True: group by all select fields of the model\n        # See compiler.get_group_by() for details.\n        self.group_by = None\n",
      "\n        # The group_by attribute can have one of the following forms:\n        #  - None: no group by at all in the query\n        #  - A tuple of expressions: group by (at least) those expressions.\n        #    String refs are also allowed for now.\n        #  - True: group by all select fields of the model\n        # See compiler.get_group_by() for details.\n        self.group_by = None\n",
      "\n        # The group_by attribute can have one of the following forms:\n        #  - None: no group by at all in the query\n        #  - A tuple of expressions: group by (at least) those expressions.\n        #    String refs are also allowed for now.\n        #  - True: group by all select fields of the model\n        # See compiler.get_group_by() for details.\n        self.group_by = None\n",
      "\n        # The group_by attribute can have one of the following forms:\n        #  - None: no group by at all in the query\n        #  - A tuple of expressions: group by (at least) those expressions.\n        #    String refs are also allowed for now.\n        #  - True: group by all select fields of the model\n        # See compiler.get_group_by() for details.\n        self.group_by = None\n",
      "\n        # The group_by attribute can have one of the following forms:\n        #  - None: no group by at all in the query\n        #  - A tuple of expressions: group by (at least) those expressions.\n        #    String refs are also allowed for now.\n        #  - True: group by all select fields of the model\n        # See compiler.get_group_by() for details.\n        self.group_by = None\n",
      "\n        # The group_by attribute can have one of the following forms:\n        #  - None: no group by at all in the query\n        #  - A tuple of expressions: group by (at least) those expressions.\n        #    String refs are also allowed for now.\n        #  - True: group by all select fields of the model\n        # See compiler.get_group_by() for details.\n        self.group_by = None\n",
      "\n        # The group_by attribute can have one of the following forms:\n        #  - None: no group by at all in the query\n        #  - A tuple of expressions: group by (at least) those expressions.\n        #    String refs are also allowed for now.\n        #  - True: group by all select fields of the model\n        # See compiler.get_group_by() for details.\n        self.group_by = None\n",
      "\n        # The group_by attribute can have one of the following forms:\n        #  - None: no group by at all in the query\n        #  - A tuple of expressions: group by (at least) those expressions.\n        #    String refs are also allowed for now.\n        #  - True: group by all select fields of the model\n        # See compiler.get_group_by() for details.\n        self.group_by = None\n"
    ],
    "Location 5 (/root/hy/projects_2/django/django/db/models/sql/query.py lines 1911-1936)": [
      "\n    def set_group_by(self):\n        \"\"\"\n        Expand the GROUP BY clause required by the query.\n\n        This will usually be the set of all non-aggregate fields in the\n        return data. If the database backend supports grouping by the\n        primary key, and the query would be equivalent, the optimization\n        will be made automatically.\n        \"\"\"\n        group_by = list(self.select)\n        if self.annotation_select:\n            for alias, annotation in self.annotation_select.items():\n                try:\n                    inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n                except TypeError:\n                    annotation_class = annotation.__class__\n                    msg = (\n                        '`alias=None` must be added to the signature of '\n                        '%s.%s.get_group_by_cols().'\n                    ) % (annotation_class.__module__, annotation_class.__qualname__)\n                    warnings.warn(msg, category=RemovedInDjango40Warning)\n                    group_by_cols = annotation.get_group_by_cols()\n                else:\n                    group_by_cols = annotation.get_group_by_cols(alias=alias)\n                group_by.extend(group_by_cols)\n        self.group_by = tuple(group_by)\n",
      "\n    def set_group_by(self):\n        \"\"\"\n        Expand the GROUP BY clause required by the query.\n\n        This will usually be the set of all non-aggregate fields in the\n        return data. If the database backend supports grouping by the\n        primary key, and the query would be equivalent, the optimization\n        will be made automatically.\n        \"\"\"\n        group_by = list(self.select)\n        if self.annotation_select:\n            for alias, annotation in self.annotation_select.items():\n                try:\n                    inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n                except TypeError:\n                    annotation_class = annotation.__class__\n                    msg = (\n                        '`alias=None` must be added to the signature of '\n                        '%s.%s.get_group_by_cols().'\n                    ) % (annotation_class.__module__, annotation_class.__qualname__)\n                    warnings.warn(msg, category=RemovedInDjango40Warning)\n                    group_by_cols = annotation.get_group_by_cols()\n                else:\n                    group_by_cols = annotation.get_group_by_cols(alias=alias)\n                group_by.extend(group_by_cols)\n        self.group_by = tuple(group_by)\n",
      "\n    def set_group_by(self):\n        \"\"\"\n        Expand the GROUP BY clause required by the query.\n\n        This will usually be the set of all non-aggregate fields in the\n        return data. If the database backend supports grouping by the\n        primary key, and the query would be equivalent, the optimization\n        will be made automatically.\n        \"\"\"\n        group_by = list(self.select)\n        if self.annotation_select:\n            for alias, annotation in self.annotation_select.items():\n                try:\n                    inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n                except TypeError:\n                    annotation_class = annotation.__class__\n                    msg = (\n                        '`alias=None` must be added to the signature of '\n                        '%s.%s.get_group_by_cols().'\n                    ) % (annotation_class.__module__, annotation_class.__qualname__)\n                    warnings.warn(msg, category=RemovedInDjango40Warning)\n                    group_by_cols = annotation.get_group_by_cols()\n                else:\n                    group_by_cols = annotation.get_group_by_cols(alias=alias)\n                group_by.extend(group_by_cols)\n        self.group_by = tuple(group_by)\n",
      "\n    def set_group_by(self):\n        \"\"\"\n        Expand the GROUP BY clause required by the query.\n\n        This will usually be the set of all non-aggregate fields in the\n        return data. If the database backend supports grouping by the\n        primary key, and the query would be equivalent, the optimization\n        will be made automatically.\n        \"\"\"\n        group_by = list(self.select)\n        if self.annotation_select:\n            for alias, annotation in self.annotation_select.items():\n                try:\n                    inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n                except TypeError:\n                    annotation_class = annotation.__class__\n                    msg = (\n                        '`alias=None` must be added to the signature of '\n                        '%s.%s.get_group_by_cols().'\n                    ) % (annotation_class.__module__, annotation_class.__qualname__)\n                    warnings.warn(msg, category=RemovedInDjango40Warning)\n                    group_by_cols = annotation.get_group_by_cols()\n                else:\n                    group_by_cols = annotation.get_group_by_cols(alias=alias)\n                group_by.extend(group_by_cols)\n        self.group_by = tuple(group_by)\n",
      "\n    def set_group_by(self):\n        \"\"\"\n        Expand the GROUP BY clause required by the query.\n\n        This will usually be the set of all non-aggregate fields in the\n        return data. If the database backend supports grouping by the\n        primary key, and the query would be equivalent, the optimization\n        will be made automatically.\n        \"\"\"\n        group_by = list(self.select)\n        if self.annotation_select:\n            for alias, annotation in self.annotation_select.items():\n                try:\n                    inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n                except TypeError:\n                    annotation_class = annotation.__class__\n                    msg = (\n                        '`alias=None` must be added to the signature of '\n                        '%s.%s.get_group_by_cols().'\n                    ) % (annotation_class.__module__, annotation_class.__qualname__)\n                    warnings.warn(msg, category=RemovedInDjango40Warning)\n                    group_by_cols = annotation.get_group_by_cols()\n                else:\n                    group_by_cols = annotation.get_group_by_cols(alias=alias)\n                group_by.extend(group_by_cols)\n        self.group_by = tuple(group_by)\n",
      "\n    def set_group_by(self):\n        \"\"\"\n        Expand the GROUP BY clause required by the query.\n\n        This will usually be the set of all non-aggregate fields in the\n        return data. If the database backend supports grouping by the\n        primary key, and the query would be equivalent, the optimization\n        will be made automatically.\n        \"\"\"\n        group_by = list(self.select)\n        if self.annotation_select:\n            for alias, annotation in self.annotation_select.items():\n                try:\n                    inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n                except TypeError:\n                    annotation_class = annotation.__class__\n                    msg = (\n                        '`alias=None` must be added to the signature of '\n                        '%s.%s.get_group_by_cols().'\n                    ) % (annotation_class.__module__, annotation_class.__qualname__)\n                    warnings.warn(msg, category=RemovedInDjango40Warning)\n                    group_by_cols = annotation.get_group_by_cols()\n                else:\n                    group_by_cols = annotation.get_group_by_cols(alias=alias)\n                group_by.extend(group_by_cols)\n        self.group_by = tuple(group_by)\n",
      "\n    def set_group_by(self):\n        \"\"\"\n        Expand the GROUP BY clause required by the query.\n\n        This will usually be the set of all non-aggregate fields in the\n        return data. If the database backend supports grouping by the\n        primary key, and the query would be equivalent, the optimization\n        will be made automatically.\n        \"\"\"\n        group_by = list(self.select)\n        if self.annotation_select:\n            for alias, annotation in self.annotation_select.items():\n                try:\n                    inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n                except TypeError:\n                    annotation_class = annotation.__class__\n                    msg = (\n                        '`alias=None` must be added to the signature of '\n                        '%s.%s.get_group_by_cols().'\n                    ) % (annotation_class.__module__, annotation_class.__qualname__)\n                    warnings.warn(msg, category=RemovedInDjango40Warning)\n                    group_by_cols = annotation.get_group_by_cols()\n                else:\n                    group_by_cols = annotation.get_group_by_cols(alias=alias)\n                group_by.extend(group_by_cols)\n        self.group_by = tuple(group_by)\n",
      "\n    def set_group_by(self):\n        \"\"\"\n        Expand the GROUP BY clause required by the query.\n\n        This will usually be the set of all non-aggregate fields in the\n        return data. If the database backend supports grouping by the\n        primary key, and the query would be equivalent, the optimization\n        will be made automatically.\n        \"\"\"\n        group_by = list(self.select)\n        if self.annotation_select:\n            for alias, annotation in self.annotation_select.items():\n                try:\n                    inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n                except TypeError:\n                    annotation_class = annotation.__class__\n                    msg = (\n                        '`alias=None` must be added to the signature of '\n                        '%s.%s.get_group_by_cols().'\n                    ) % (annotation_class.__module__, annotation_class.__qualname__)\n                    warnings.warn(msg, category=RemovedInDjango40Warning)\n                    group_by_cols = annotation.get_group_by_cols()\n                else:\n                    group_by_cols = annotation.get_group_by_cols(alias=alias)\n                group_by.extend(group_by_cols)\n        self.group_by = tuple(group_by)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8e55bd092d..49445bb981 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -180,6 +180,7 @@ class Query(BaseExpression):\n         self.select = ()\n         self.where = where()\n         self.where_class = where\n+\n         # The group_by attribute can have one of the following forms:\n         #  - None: no group by at all in the query\n         #  - A tuple of expressions: group by (at least) those expressions.\n@@ -429,6 +430,7 @@ class Query(BaseExpression):\n         # those operations must be done in a subquery so that the query\n         # aggregates on the limit and/or distinct results instead of applying\n         # the distinct and limit after the aggregation.\n+\n         if (isinstance(self.group_by, tuple) or self.is_sliced or existing_annotations or\n                 self.distinct or self.combinator):\n             from django.db.models.sql.subqueries import AggregateQuery\n@@ -442,6 +444,7 @@ class Query(BaseExpression):\n                 # is applied we must take the slice from the ordered query.\n                 # Otherwise no need for ordering.\n                 inner_query.clear_ordering(True)\n+\n             if not inner_query.distinct:\n                 # If the inner query uses default select and it has some\n                 # aggregate annotations, then we must make sure the inner\n@@ -452,9 +455,10 @@ class Query(BaseExpression):\n                     annotation for annotation in existing_annotations\n                     if getattr(annotation, 'contains_aggregate', True)\n                 )\n-                if inner_query.default_cols and has_existing_aggregate_annotations:\n+                if inner_query.default_cols and has_existing_aggregate_annotations and not inner_query.group_by:\n                     inner_query.group_by = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)\n                 inner_query.default_cols = False\n+                inner_query.default_cols = False\n \n             relabels = {t: 'subquery' for t in inner_query.alias_map}\n             relabels[None] = 'subquery'\n@@ -1908,6 +1912,7 @@ class Query(BaseExpression):\n         if force_empty:\n             self.default_ordering = False\n \n+\n     def set_group_by(self):\n         \"\"\"\n         Expand the GROUP BY clause required by the query.\n",
    "variant_0": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8e55bd092d..49445bb981 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -180,6 +180,7 @@ class Query(BaseExpression):\n         self.select = ()\n         self.where = where()\n         self.where_class = where\n+\n         # The group_by attribute can have one of the following forms:\n         #  - None: no group by at all in the query\n         #  - A tuple of expressions: group by (at least) those expressions.\n@@ -429,6 +430,7 @@ class Query(BaseExpression):\n         # those operations must be done in a subquery so that the query\n         # aggregates on the limit and/or distinct results instead of applying\n         # the distinct and limit after the aggregation.\n+\n         if (isinstance(self.group_by, tuple) or self.is_sliced or existing_annotations or\n                 self.distinct or self.combinator):\n             from django.db.models.sql.subqueries import AggregateQuery\n@@ -442,6 +444,7 @@ class Query(BaseExpression):\n                 # is applied we must take the slice from the ordered query.\n                 # Otherwise no need for ordering.\n                 inner_query.clear_ordering(True)\n+\n             if not inner_query.distinct:\n                 # If the inner query uses default select and it has some\n                 # aggregate annotations, then we must make sure the inner\n@@ -452,9 +455,10 @@ class Query(BaseExpression):\n                     annotation for annotation in existing_annotations\n                     if getattr(annotation, 'contains_aggregate', True)\n                 )\n-                if inner_query.default_cols and has_existing_aggregate_annotations:\n+                if inner_query.default_cols and has_existing_aggregate_annotations and not inner_query.group_by:\n                     inner_query.group_by = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)\n                 inner_query.default_cols = False\n+                inner_query.default_cols = False\n \n             relabels = {t: 'subquery' for t in inner_query.alias_map}\n             relabels[None] = 'subquery'\n@@ -1908,6 +1912,7 @@ class Query(BaseExpression):\n         if force_empty:\n             self.default_ordering = False\n \n+\n     def set_group_by(self):\n         \"\"\"\n         Expand the GROUP BY clause required by the query.\n",
    "variant_1": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8e55bd092d..54d4f5d62b 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -180,6 +180,7 @@ class Query(BaseExpression):\n         self.select = ()\n         self.where = where()\n         self.where_class = where\n+\n         # The group_by attribute can have one of the following forms:\n         #  - None: no group by at all in the query\n         #  - A tuple of expressions: group by (at least) those expressions.\n@@ -429,6 +430,7 @@ class Query(BaseExpression):\n         # those operations must be done in a subquery so that the query\n         # aggregates on the limit and/or distinct results instead of applying\n         # the distinct and limit after the aggregation.\n+\n         if (isinstance(self.group_by, tuple) or self.is_sliced or existing_annotations or\n                 self.distinct or self.combinator):\n             from django.db.models.sql.subqueries import AggregateQuery\n@@ -442,6 +444,7 @@ class Query(BaseExpression):\n                 # is applied we must take the slice from the ordered query.\n                 # Otherwise no need for ordering.\n                 inner_query.clear_ordering(True)\n+\n             if not inner_query.distinct:\n                 # If the inner query uses default select and it has some\n                 # aggregate annotations, then we must make sure the inner\n@@ -452,7 +455,18 @@ class Query(BaseExpression):\n                     annotation for annotation in existing_annotations\n                     if getattr(annotation, 'contains_aggregate', True)\n                 )\n-                if inner_query.default_cols and has_existing_aggregate_annotations:\n+                if inner_query.default_cols and has_existing_aggregate_annotations and not inner_query.group_by:\n+                    inner_query.group_by = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)\n+                inner_query.default_cols = False\n+                # aggregate annotations, then we must make sure the inner\n+                # query is grouped by the main model's primary key. However,\n+                # clearing the select clause can alter results if distinct is\n+                # used.\n+                has_existing_aggregate_annotations = any(\n+                    annotation for annotation in existing_annotations\n+                    if getattr(annotation, 'contains_aggregate', True)\n+                )\n+                if inner_query.default_cols and has_existing_aggregate_annotations and not inner_query.group_by:\n                     inner_query.group_by = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)\n                 inner_query.default_cols = False\n \n@@ -1908,6 +1922,7 @@ class Query(BaseExpression):\n         if force_empty:\n             self.default_ordering = False\n \n+\n     def set_group_by(self):\n         \"\"\"\n         Expand the GROUP BY clause required by the query.\n",
    "variant_2": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8e55bd092d..49445bb981 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -180,6 +180,7 @@ class Query(BaseExpression):\n         self.select = ()\n         self.where = where()\n         self.where_class = where\n+\n         # The group_by attribute can have one of the following forms:\n         #  - None: no group by at all in the query\n         #  - A tuple of expressions: group by (at least) those expressions.\n@@ -429,6 +430,7 @@ class Query(BaseExpression):\n         # those operations must be done in a subquery so that the query\n         # aggregates on the limit and/or distinct results instead of applying\n         # the distinct and limit after the aggregation.\n+\n         if (isinstance(self.group_by, tuple) or self.is_sliced or existing_annotations or\n                 self.distinct or self.combinator):\n             from django.db.models.sql.subqueries import AggregateQuery\n@@ -442,6 +444,7 @@ class Query(BaseExpression):\n                 # is applied we must take the slice from the ordered query.\n                 # Otherwise no need for ordering.\n                 inner_query.clear_ordering(True)\n+\n             if not inner_query.distinct:\n                 # If the inner query uses default select and it has some\n                 # aggregate annotations, then we must make sure the inner\n@@ -452,9 +455,10 @@ class Query(BaseExpression):\n                     annotation for annotation in existing_annotations\n                     if getattr(annotation, 'contains_aggregate', True)\n                 )\n-                if inner_query.default_cols and has_existing_aggregate_annotations:\n+                if inner_query.default_cols and has_existing_aggregate_annotations and not inner_query.group_by:\n                     inner_query.group_by = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)\n                 inner_query.default_cols = False\n+                inner_query.default_cols = False\n \n             relabels = {t: 'subquery' for t in inner_query.alias_map}\n             relabels[None] = 'subquery'\n@@ -1908,6 +1912,7 @@ class Query(BaseExpression):\n         if force_empty:\n             self.default_ordering = False\n \n+\n     def set_group_by(self):\n         \"\"\"\n         Expand the GROUP BY clause required by the query.\n",
    "variant_3": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8e55bd092d..82073099d1 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -180,6 +180,7 @@ class Query(BaseExpression):\n         self.select = ()\n         self.where = where()\n         self.where_class = where\n+\n         # The group_by attribute can have one of the following forms:\n         #  - None: no group by at all in the query\n         #  - A tuple of expressions: group by (at least) those expressions.\n@@ -429,6 +430,7 @@ class Query(BaseExpression):\n         # those operations must be done in a subquery so that the query\n         # aggregates on the limit and/or distinct results instead of applying\n         # the distinct and limit after the aggregation.\n+\n         if (isinstance(self.group_by, tuple) or self.is_sliced or existing_annotations or\n                 self.distinct or self.combinator):\n             from django.db.models.sql.subqueries import AggregateQuery\n@@ -442,6 +444,7 @@ class Query(BaseExpression):\n                 # is applied we must take the slice from the ordered query.\n                 # Otherwise no need for ordering.\n                 inner_query.clear_ordering(True)\n+\n             if not inner_query.distinct:\n                 # If the inner query uses default select and it has some\n                 # aggregate annotations, then we must make sure the inner\n@@ -452,9 +455,21 @@ class Query(BaseExpression):\n                     annotation for annotation in existing_annotations\n                     if getattr(annotation, 'contains_aggregate', True)\n                 )\n-                if inner_query.default_cols and has_existing_aggregate_annotations:\n+                if inner_query.default_cols and has_existing_aggregate_annotations and not inner_query.group_by:\n                     inner_query.group_by = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)\n                 inner_query.default_cols = False\n+                # aggregate annotations, then we must make sure the inner\n+                # query is grouped by the main model's primary key. However,\n+                # clearing the select clause can alter results if distinct is\n+                # used.\n+                has_existing_aggregate_annotations = any(\n+                    annotation for annotation in existing_annotations\n+                    if getattr(annotation, 'contains_aggregate', True)\n+                )\n+                if inner_query.default_cols and has_existing_aggregate_annotations and not inner_query.group_by:\n+                    inner_query.group_by = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)\n+                inner_query.default_cols = False\n+                inner_query.default_cols = False\n \n             relabels = {t: 'subquery' for t in inner_query.alias_map}\n             relabels[None] = 'subquery'\n@@ -1908,6 +1923,7 @@ class Query(BaseExpression):\n         if force_empty:\n             self.default_ordering = False\n \n+\n     def set_group_by(self):\n         \"\"\"\n         Expand the GROUP BY clause required by the query.\n",
    "variant_4": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8e55bd092d..49445bb981 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -180,6 +180,7 @@ class Query(BaseExpression):\n         self.select = ()\n         self.where = where()\n         self.where_class = where\n+\n         # The group_by attribute can have one of the following forms:\n         #  - None: no group by at all in the query\n         #  - A tuple of expressions: group by (at least) those expressions.\n@@ -429,6 +430,7 @@ class Query(BaseExpression):\n         # those operations must be done in a subquery so that the query\n         # aggregates on the limit and/or distinct results instead of applying\n         # the distinct and limit after the aggregation.\n+\n         if (isinstance(self.group_by, tuple) or self.is_sliced or existing_annotations or\n                 self.distinct or self.combinator):\n             from django.db.models.sql.subqueries import AggregateQuery\n@@ -442,6 +444,7 @@ class Query(BaseExpression):\n                 # is applied we must take the slice from the ordered query.\n                 # Otherwise no need for ordering.\n                 inner_query.clear_ordering(True)\n+\n             if not inner_query.distinct:\n                 # If the inner query uses default select and it has some\n                 # aggregate annotations, then we must make sure the inner\n@@ -452,9 +455,10 @@ class Query(BaseExpression):\n                     annotation for annotation in existing_annotations\n                     if getattr(annotation, 'contains_aggregate', True)\n                 )\n-                if inner_query.default_cols and has_existing_aggregate_annotations:\n+                if inner_query.default_cols and has_existing_aggregate_annotations and not inner_query.group_by:\n                     inner_query.group_by = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)\n                 inner_query.default_cols = False\n+                inner_query.default_cols = False\n \n             relabels = {t: 'subquery' for t in inner_query.alias_map}\n             relabels[None] = 'subquery'\n@@ -1908,6 +1912,7 @@ class Query(BaseExpression):\n         if force_empty:\n             self.default_ordering = False\n \n+\n     def set_group_by(self):\n         \"\"\"\n         Expand the GROUP BY clause required by the query.\n",
    "variant_5": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8e55bd092d..49445bb981 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -180,6 +180,7 @@ class Query(BaseExpression):\n         self.select = ()\n         self.where = where()\n         self.where_class = where\n+\n         # The group_by attribute can have one of the following forms:\n         #  - None: no group by at all in the query\n         #  - A tuple of expressions: group by (at least) those expressions.\n@@ -429,6 +430,7 @@ class Query(BaseExpression):\n         # those operations must be done in a subquery so that the query\n         # aggregates on the limit and/or distinct results instead of applying\n         # the distinct and limit after the aggregation.\n+\n         if (isinstance(self.group_by, tuple) or self.is_sliced or existing_annotations or\n                 self.distinct or self.combinator):\n             from django.db.models.sql.subqueries import AggregateQuery\n@@ -442,6 +444,7 @@ class Query(BaseExpression):\n                 # is applied we must take the slice from the ordered query.\n                 # Otherwise no need for ordering.\n                 inner_query.clear_ordering(True)\n+\n             if not inner_query.distinct:\n                 # If the inner query uses default select and it has some\n                 # aggregate annotations, then we must make sure the inner\n@@ -452,9 +455,10 @@ class Query(BaseExpression):\n                     annotation for annotation in existing_annotations\n                     if getattr(annotation, 'contains_aggregate', True)\n                 )\n-                if inner_query.default_cols and has_existing_aggregate_annotations:\n+                if inner_query.default_cols and has_existing_aggregate_annotations and not inner_query.group_by:\n                     inner_query.group_by = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)\n                 inner_query.default_cols = False\n+                inner_query.default_cols = False\n \n             relabels = {t: 'subquery' for t in inner_query.alias_map}\n             relabels[None] = 'subquery'\n@@ -1908,6 +1912,7 @@ class Query(BaseExpression):\n         if force_empty:\n             self.default_ordering = False\n \n+\n     def set_group_by(self):\n         \"\"\"\n         Expand the GROUP BY clause required by the query.\n",
    "variant_6": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8e55bd092d..49445bb981 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -180,6 +180,7 @@ class Query(BaseExpression):\n         self.select = ()\n         self.where = where()\n         self.where_class = where\n+\n         # The group_by attribute can have one of the following forms:\n         #  - None: no group by at all in the query\n         #  - A tuple of expressions: group by (at least) those expressions.\n@@ -429,6 +430,7 @@ class Query(BaseExpression):\n         # those operations must be done in a subquery so that the query\n         # aggregates on the limit and/or distinct results instead of applying\n         # the distinct and limit after the aggregation.\n+\n         if (isinstance(self.group_by, tuple) or self.is_sliced or existing_annotations or\n                 self.distinct or self.combinator):\n             from django.db.models.sql.subqueries import AggregateQuery\n@@ -442,6 +444,7 @@ class Query(BaseExpression):\n                 # is applied we must take the slice from the ordered query.\n                 # Otherwise no need for ordering.\n                 inner_query.clear_ordering(True)\n+\n             if not inner_query.distinct:\n                 # If the inner query uses default select and it has some\n                 # aggregate annotations, then we must make sure the inner\n@@ -452,9 +455,10 @@ class Query(BaseExpression):\n                     annotation for annotation in existing_annotations\n                     if getattr(annotation, 'contains_aggregate', True)\n                 )\n-                if inner_query.default_cols and has_existing_aggregate_annotations:\n+                if inner_query.default_cols and has_existing_aggregate_annotations and not inner_query.group_by:\n                     inner_query.group_by = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)\n                 inner_query.default_cols = False\n+                inner_query.default_cols = False\n \n             relabels = {t: 'subquery' for t in inner_query.alias_map}\n             relabels[None] = 'subquery'\n@@ -1908,6 +1912,7 @@ class Query(BaseExpression):\n         if force_empty:\n             self.default_ordering = False\n \n+\n     def set_group_by(self):\n         \"\"\"\n         Expand the GROUP BY clause required by the query.\n",
    "variant_7": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8e55bd092d..49445bb981 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -180,6 +180,7 @@ class Query(BaseExpression):\n         self.select = ()\n         self.where = where()\n         self.where_class = where\n+\n         # The group_by attribute can have one of the following forms:\n         #  - None: no group by at all in the query\n         #  - A tuple of expressions: group by (at least) those expressions.\n@@ -429,6 +430,7 @@ class Query(BaseExpression):\n         # those operations must be done in a subquery so that the query\n         # aggregates on the limit and/or distinct results instead of applying\n         # the distinct and limit after the aggregation.\n+\n         if (isinstance(self.group_by, tuple) or self.is_sliced or existing_annotations or\n                 self.distinct or self.combinator):\n             from django.db.models.sql.subqueries import AggregateQuery\n@@ -442,6 +444,7 @@ class Query(BaseExpression):\n                 # is applied we must take the slice from the ordered query.\n                 # Otherwise no need for ordering.\n                 inner_query.clear_ordering(True)\n+\n             if not inner_query.distinct:\n                 # If the inner query uses default select and it has some\n                 # aggregate annotations, then we must make sure the inner\n@@ -452,9 +455,10 @@ class Query(BaseExpression):\n                     annotation for annotation in existing_annotations\n                     if getattr(annotation, 'contains_aggregate', True)\n                 )\n-                if inner_query.default_cols and has_existing_aggregate_annotations:\n+                if inner_query.default_cols and has_existing_aggregate_annotations and not inner_query.group_by:\n                     inner_query.group_by = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)\n                 inner_query.default_cols = False\n+                inner_query.default_cols = False\n \n             relabels = {t: 'subquery' for t in inner_query.alias_map}\n             relabels[None] = 'subquery'\n@@ -1908,6 +1912,7 @@ class Query(BaseExpression):\n         if force_empty:\n             self.default_ordering = False\n \n+\n     def set_group_by(self):\n         \"\"\"\n         Expand the GROUP BY clause required by the query.\n",
    "variant_8": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8e55bd092d..49445bb981 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -180,6 +180,7 @@ class Query(BaseExpression):\n         self.select = ()\n         self.where = where()\n         self.where_class = where\n+\n         # The group_by attribute can have one of the following forms:\n         #  - None: no group by at all in the query\n         #  - A tuple of expressions: group by (at least) those expressions.\n@@ -429,6 +430,7 @@ class Query(BaseExpression):\n         # those operations must be done in a subquery so that the query\n         # aggregates on the limit and/or distinct results instead of applying\n         # the distinct and limit after the aggregation.\n+\n         if (isinstance(self.group_by, tuple) or self.is_sliced or existing_annotations or\n                 self.distinct or self.combinator):\n             from django.db.models.sql.subqueries import AggregateQuery\n@@ -442,6 +444,7 @@ class Query(BaseExpression):\n                 # is applied we must take the slice from the ordered query.\n                 # Otherwise no need for ordering.\n                 inner_query.clear_ordering(True)\n+\n             if not inner_query.distinct:\n                 # If the inner query uses default select and it has some\n                 # aggregate annotations, then we must make sure the inner\n@@ -452,9 +455,10 @@ class Query(BaseExpression):\n                     annotation for annotation in existing_annotations\n                     if getattr(annotation, 'contains_aggregate', True)\n                 )\n-                if inner_query.default_cols and has_existing_aggregate_annotations:\n+                if inner_query.default_cols and has_existing_aggregate_annotations and not inner_query.group_by:\n                     inner_query.group_by = (self.model._meta.pk.get_col(inner_query.get_initial_alias()),)\n                 inner_query.default_cols = False\n+                inner_query.default_cols = False\n \n             relabels = {t: 'subquery' for t in inner_query.alias_map}\n             relabels[None] = 'subquery'\n@@ -1908,6 +1912,7 @@ class Query(BaseExpression):\n         if force_empty:\n             self.default_ordering = False\n \n+\n     def set_group_by(self):\n         \"\"\"\n         Expand the GROUP BY clause required by the query.\n"
  }
}