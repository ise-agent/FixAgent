{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/django/django/db/models/query_utils.py lines 151-152)": "\n    def _check_parent_chain(self, instance):\n        \"\"\"\n        Check if the field value can be fetched from a parent field already\n        loaded in the instance. This can be done if the to-be fetched\n        field is a primary key field.\n        \"\"\"\n        opts = instance._meta\n        link_field = opts.get_ancestor_link(self.field.model)\n        if self.field.primary_key and self.field != link_field:\n            return getattr(instance, link_field.attname)\n        return None\n\n    def __set__(self, instance, value):\n        \"\"\"\n        Set the field value, converting enum instances to their underlying values\n        to ensure consistency between fresh objects and database-retrieved objects.\n        \"\"\"\n        # Convert enum instances to their underlying values\n        if hasattr(value, 'name') and hasattr(value, 'value'):\n            value = value.value\n        instance.__dict__[self.field.attname] = value\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/django/django/db/models/query_utils.py lines 151-152)": [
      "\n    def _check_parent_chain(self, instance):\n        \"\"\"\n        Check if the field value can be fetched from a parent field already\n        loaded in the instance. This can be done if the to-be fetched\n        field is a primary key field.\n        \"\"\"\n        opts = instance._meta\n        link_field = opts.get_ancestor_link(self.field.model)\n        if self.field.primary_key and self.field != link_field:\n            return getattr(instance, link_field.attname)\n        return None\n\n    def __set__(self, instance, value):\n        \"\"\"\n        Set the field value, converting enum instances to their underlying values\n        to maintain consistency between fresh and retrieved objects.\n        \"\"\"\n        # Convert enum instances to their underlying values\n        if value is not None and hasattr(value, 'name') and hasattr(value, 'value'):\n            value = value.value\n        instance.__dict__[self.field.attname] = value\n",
      "\n    def _check_parent_chain(self, instance):\n        \"\"\"\n        Check if the field value can be fetched from a parent field already\n        loaded in the instance. This can be done if the to-be fetched\n        field is a primary key field.\n        \"\"\"\n        opts = instance._meta\n        link_field = opts.get_ancestor_link(self.field.model)\n        if self.field.primary_key and self.field != link_field:\n            return getattr(instance, link_field.attname)\n        return None\n\n    def __set__(self, instance, value):\n        \"\"\"\n        Set the field value, converting enum instances to their underlying values.\n        \"\"\"\n        # Convert enum instances to their underlying values\n        if hasattr(value, 'name') and hasattr(value, 'value'):\n            value = value.value\n        instance.__dict__[self.field.attname] = value\n",
      "\n    def _check_parent_chain(self, instance):\n        \"\"\"\n        Check if the field value can be fetched from a parent field already\n        loaded in the instance. This can be done if the to-be fetched\n        field is a primary key field.\n        \"\"\"\n        opts = instance._meta\n        link_field = opts.get_ancestor_link(self.field.model)\n        if self.field.primary_key and self.field != link_field:\n            return getattr(instance, link_field.attname)\n        return None\n\n    def __set__(self, instance, value):\n        \"\"\"\n        Set the field value on the instance, converting enum objects to their\n        underlying values to maintain consistency with database-retrieved objects.\n        \"\"\"\n        # Convert enum objects to their underlying values\n        if hasattr(value, 'name') and hasattr(value, 'value'):\n            value = value.value\n        instance.__dict__[self.field.attname] = value\n",
      "\n    def _check_parent_chain(self, instance):\n        \"\"\"\n        Check if the field value can be fetched from a parent field already\n        loaded in the instance. This can be done if the to-be fetched\n        field is a primary key field.\n        \"\"\"\n        opts = instance._meta\n        link_field = opts.get_ancestor_link(self.field.model)\n        if self.field.primary_key and self.field != link_field:\n            return getattr(instance, link_field.attname)\n        return None\n\n    def __set__(self, instance, value):\n        \"\"\"\n        Set the field value on the instance, converting enum values to their\n        underlying values to ensure consistency with database-retrieved objects.\n        \"\"\"\n        # Convert enum instances to their underlying values\n        if hasattr(value, 'name') and hasattr(value, 'value'):\n            value = value.value\n        \n        # Store the (possibly converted) value directly in instance.__dict__\n        instance.__dict__[self.field.attname] = value\n",
      "\n    def _check_parent_chain(self, instance):\n        \"\"\"\n        Check if the field value can be fetched from a parent field already\n        loaded in the instance. This can be done if the to-be fetched\n        field is a primary key field.\n        \"\"\"\n        opts = instance._meta\n        link_field = opts.get_ancestor_link(self.field.model)\n        if self.field.primary_key and self.field != link_field:\n            return getattr(instance, link_field.attname)\n        return None\n\n    def __set__(self, instance, value):\n        \"\"\"\n        Set the value for this field on the instance.\n        Convert enum instances to their underlying values to ensure consistency.\n        \"\"\"\n        # Check if value is an enum instance (has both name and value attributes)\n        if hasattr(value, 'name') and hasattr(value, 'value'):\n            value = value.value\n        instance.__dict__[self.field.attname] = value\n",
      "\n    def _check_parent_chain(self, instance):\n        \"\"\"\n        Check if the field value can be fetched from a parent field already\n        loaded in the instance. This can be done if the to-be fetched\n        field is a primary key field.\n        \"\"\"\n        opts = instance._meta\n        link_field = opts.get_ancestor_link(self.field.model)\n        if self.field.primary_key and self.field != link_field:\n            return getattr(instance, link_field.attname)\n        return None\n\n    def __set__(self, instance, value):\n        \"\"\"\n        Set the field value, converting enum instances to their underlying values\n        to ensure consistency between freshly created and database-retrieved objects.\n        \"\"\"\n        # Convert enum instances to their underlying values\n        if hasattr(value, 'name') and hasattr(value, 'value'):\n            value = value.value\n        instance.__dict__[self.field.attname] = value\n",
      "\n    def _check_parent_chain(self, instance):\n        \"\"\"\n        Check if the field value can be fetched from a parent field already\n        loaded in the instance. This can be done if the to-be fetched\n        field is a primary key field.\n        \"\"\"\n        opts = instance._meta\n        link_field = opts.get_ancestor_link(self.field.model)\n        if self.field.primary_key and self.field != link_field:\n            return getattr(instance, link_field.attname)\n        return None\n\n    def __set__(self, instance, value):\n        \"\"\"\n        Set the field value, converting enum instances to their underlying values\n        to ensure consistency between freshly created and database-retrieved objects.\n        \"\"\"\n        # Convert enum instances to their underlying values\n        if hasattr(value, 'name') and hasattr(value, 'value'):\n            value = value.value\n        instance.__dict__[self.field.attname] = value\n",
      "\n    def _check_parent_chain(self, instance):\n        \"\"\"\n        Check if the field value can be fetched from a parent field already\n        loaded in the instance. This can be done if the to-be fetched\n        field is a primary key field.\n        \"\"\"\n        opts = instance._meta\n        link_field = opts.get_ancestor_link(self.field.model)\n        if self.field.primary_key and self.field != link_field:\n            return getattr(instance, link_field.attname)\n        return None\n\n    def __set__(self, instance, value):\n        \"\"\"\n        Set the field value, converting enum instances to their underlying values.\n        \"\"\"\n        # Convert enum instances to their underlying values\n        if hasattr(value, 'name') and hasattr(value, 'value'):\n            value = value.value\n        instance.__dict__[self.field.attname] = value\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 189fb4fa44..39a6fe3250 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -148,8 +148,22 @@ class DeferredAttribute:\n         link_field = opts.get_ancestor_link(self.field.model)\n         if self.field.primary_key and self.field != link_field:\n             return getattr(instance, link_field.attname)\n+\n         return None\n \n+    def __set__(self, instance, value):\n+        \"\"\"\n+        Set the field value, converting enum objects to their underlying values\n+        to ensure consistency between direct assignment and database retrieval.\n+        \"\"\"\n+        # Check if the value is an enum instance by checking for both 'name' and 'value' attributes\n+        if hasattr(value, 'name') and hasattr(value, 'value'):\n+            # Convert enum to its underlying value\n+            value = value.value\n+        \n+        # Store the value in the instance's __dict__\n+        instance.__dict__[self.field.attname] = value\n+\n \n class RegisterLookupMixin:\n \n",
    "variant_0": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 189fb4fa44..463baf2957 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -138,6 +138,17 @@ class DeferredAttribute:\n             data[field_name] = val\n         return data[field_name]\n \n+    def _check_parent_chain(self, instance):\n+        \"\"\"\n+        Check if the field value can be fetched from a parent field already\n+        loaded in the instance. This can be done if the to-be fetched\n+        field is a primary key field.\n+        \"\"\"\n+        opts = instance._meta\n+        link_field = opts.get_ancestor_link(self.field.model)\n+        if self.field.primary_key and self.field != link_field:\n+            return getattr(instance, link_field.attname)\n+\n     def _check_parent_chain(self, instance):\n         \"\"\"\n         Check if the field value can be fetched from a parent field already\n@@ -150,6 +161,15 @@ class DeferredAttribute:\n             return getattr(instance, link_field.attname)\n         return None\n \n+    def __set__(self, instance, value):\n+        \"\"\"\n+        Set the field value, converting enum instances to their underlying values\n+        to ensure consistency between fresh objects and database-retrieved objects.\n+        \"\"\"\n+        # Convert enum instances to their underlying values\n+        if hasattr(value, 'name') and hasattr(value, 'value'):\n+            value = value.value\n+        instance.__dict__[self.field.attname] = value\n \n class RegisterLookupMixin:\n \n",
    "variant_1": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 189fb4fa44..1100671a5b 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -138,6 +138,17 @@ class DeferredAttribute:\n             data[field_name] = val\n         return data[field_name]\n \n+    def _check_parent_chain(self, instance):\n+        \"\"\"\n+        Check if the field value can be fetched from a parent field already\n+        loaded in the instance. This can be done if the to-be fetched\n+        field is a primary key field.\n+        \"\"\"\n+        opts = instance._meta\n+        link_field = opts.get_ancestor_link(self.field.model)\n+        if self.field.primary_key and self.field != link_field:\n+            return getattr(instance, link_field.attname)\n+\n     def _check_parent_chain(self, instance):\n         \"\"\"\n         Check if the field value can be fetched from a parent field already\n@@ -150,6 +161,15 @@ class DeferredAttribute:\n             return getattr(instance, link_field.attname)\n         return None\n \n+    def __set__(self, instance, value):\n+        \"\"\"\n+        Set the field value, converting enum instances to their underlying values\n+        to maintain consistency between fresh and retrieved objects.\n+        \"\"\"\n+        # Convert enum instances to their underlying values\n+        if value is not None and hasattr(value, 'name') and hasattr(value, 'value'):\n+            value = value.value\n+        instance.__dict__[self.field.attname] = value\n \n class RegisterLookupMixin:\n \n",
    "variant_2": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 189fb4fa44..8275af4951 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -138,6 +138,17 @@ class DeferredAttribute:\n             data[field_name] = val\n         return data[field_name]\n \n+    def _check_parent_chain(self, instance):\n+        \"\"\"\n+        Check if the field value can be fetched from a parent field already\n+        loaded in the instance. This can be done if the to-be fetched\n+        field is a primary key field.\n+        \"\"\"\n+        opts = instance._meta\n+        link_field = opts.get_ancestor_link(self.field.model)\n+        if self.field.primary_key and self.field != link_field:\n+            return getattr(instance, link_field.attname)\n+\n     def _check_parent_chain(self, instance):\n         \"\"\"\n         Check if the field value can be fetched from a parent field already\n@@ -150,6 +161,14 @@ class DeferredAttribute:\n             return getattr(instance, link_field.attname)\n         return None\n \n+    def __set__(self, instance, value):\n+        \"\"\"\n+        Set the field value, converting enum instances to their underlying values.\n+        \"\"\"\n+        # Convert enum instances to their underlying values\n+        if hasattr(value, 'name') and hasattr(value, 'value'):\n+            value = value.value\n+        instance.__dict__[self.field.attname] = value\n \n class RegisterLookupMixin:\n \n",
    "variant_3": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 189fb4fa44..a06aed4fbd 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -138,6 +138,17 @@ class DeferredAttribute:\n             data[field_name] = val\n         return data[field_name]\n \n+    def _check_parent_chain(self, instance):\n+        \"\"\"\n+        Check if the field value can be fetched from a parent field already\n+        loaded in the instance. This can be done if the to-be fetched\n+        field is a primary key field.\n+        \"\"\"\n+        opts = instance._meta\n+        link_field = opts.get_ancestor_link(self.field.model)\n+        if self.field.primary_key and self.field != link_field:\n+            return getattr(instance, link_field.attname)\n+\n     def _check_parent_chain(self, instance):\n         \"\"\"\n         Check if the field value can be fetched from a parent field already\n@@ -150,6 +161,15 @@ class DeferredAttribute:\n             return getattr(instance, link_field.attname)\n         return None\n \n+    def __set__(self, instance, value):\n+        \"\"\"\n+        Set the field value on the instance, converting enum objects to their\n+        underlying values to maintain consistency with database-retrieved objects.\n+        \"\"\"\n+        # Convert enum objects to their underlying values\n+        if hasattr(value, 'name') and hasattr(value, 'value'):\n+            value = value.value\n+        instance.__dict__[self.field.attname] = value\n \n class RegisterLookupMixin:\n \n",
    "variant_4": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 189fb4fa44..7a6eb1f476 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -138,6 +138,17 @@ class DeferredAttribute:\n             data[field_name] = val\n         return data[field_name]\n \n+    def _check_parent_chain(self, instance):\n+        \"\"\"\n+        Check if the field value can be fetched from a parent field already\n+        loaded in the instance. This can be done if the to-be fetched\n+        field is a primary key field.\n+        \"\"\"\n+        opts = instance._meta\n+        link_field = opts.get_ancestor_link(self.field.model)\n+        if self.field.primary_key and self.field != link_field:\n+            return getattr(instance, link_field.attname)\n+\n     def _check_parent_chain(self, instance):\n         \"\"\"\n         Check if the field value can be fetched from a parent field already\n@@ -150,6 +161,17 @@ class DeferredAttribute:\n             return getattr(instance, link_field.attname)\n         return None\n \n+    def __set__(self, instance, value):\n+        \"\"\"\n+        Set the field value on the instance, converting enum values to their\n+        underlying values to ensure consistency with database-retrieved objects.\n+        \"\"\"\n+        # Convert enum instances to their underlying values\n+        if hasattr(value, 'name') and hasattr(value, 'value'):\n+            value = value.value\n+        \n+        # Store the (possibly converted) value directly in instance.__dict__\n+        instance.__dict__[self.field.attname] = value\n \n class RegisterLookupMixin:\n \n",
    "variant_5": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 189fb4fa44..b5e7819e62 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -138,6 +138,17 @@ class DeferredAttribute:\n             data[field_name] = val\n         return data[field_name]\n \n+    def _check_parent_chain(self, instance):\n+        \"\"\"\n+        Check if the field value can be fetched from a parent field already\n+        loaded in the instance. This can be done if the to-be fetched\n+        field is a primary key field.\n+        \"\"\"\n+        opts = instance._meta\n+        link_field = opts.get_ancestor_link(self.field.model)\n+        if self.field.primary_key and self.field != link_field:\n+            return getattr(instance, link_field.attname)\n+\n     def _check_parent_chain(self, instance):\n         \"\"\"\n         Check if the field value can be fetched from a parent field already\n@@ -150,6 +161,15 @@ class DeferredAttribute:\n             return getattr(instance, link_field.attname)\n         return None\n \n+    def __set__(self, instance, value):\n+        \"\"\"\n+        Set the value for this field on the instance.\n+        Convert enum instances to their underlying values to ensure consistency.\n+        \"\"\"\n+        # Check if value is an enum instance (has both name and value attributes)\n+        if hasattr(value, 'name') and hasattr(value, 'value'):\n+            value = value.value\n+        instance.__dict__[self.field.attname] = value\n \n class RegisterLookupMixin:\n \n",
    "variant_6": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 189fb4fa44..6f2e3b9bf2 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -138,6 +138,17 @@ class DeferredAttribute:\n             data[field_name] = val\n         return data[field_name]\n \n+    def _check_parent_chain(self, instance):\n+        \"\"\"\n+        Check if the field value can be fetched from a parent field already\n+        loaded in the instance. This can be done if the to-be fetched\n+        field is a primary key field.\n+        \"\"\"\n+        opts = instance._meta\n+        link_field = opts.get_ancestor_link(self.field.model)\n+        if self.field.primary_key and self.field != link_field:\n+            return getattr(instance, link_field.attname)\n+\n     def _check_parent_chain(self, instance):\n         \"\"\"\n         Check if the field value can be fetched from a parent field already\n@@ -150,6 +161,15 @@ class DeferredAttribute:\n             return getattr(instance, link_field.attname)\n         return None\n \n+    def __set__(self, instance, value):\n+        \"\"\"\n+        Set the field value, converting enum instances to their underlying values\n+        to ensure consistency between freshly created and database-retrieved objects.\n+        \"\"\"\n+        # Convert enum instances to their underlying values\n+        if hasattr(value, 'name') and hasattr(value, 'value'):\n+            value = value.value\n+        instance.__dict__[self.field.attname] = value\n \n class RegisterLookupMixin:\n \n",
    "variant_7": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 189fb4fa44..6f2e3b9bf2 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -138,6 +138,17 @@ class DeferredAttribute:\n             data[field_name] = val\n         return data[field_name]\n \n+    def _check_parent_chain(self, instance):\n+        \"\"\"\n+        Check if the field value can be fetched from a parent field already\n+        loaded in the instance. This can be done if the to-be fetched\n+        field is a primary key field.\n+        \"\"\"\n+        opts = instance._meta\n+        link_field = opts.get_ancestor_link(self.field.model)\n+        if self.field.primary_key and self.field != link_field:\n+            return getattr(instance, link_field.attname)\n+\n     def _check_parent_chain(self, instance):\n         \"\"\"\n         Check if the field value can be fetched from a parent field already\n@@ -150,6 +161,15 @@ class DeferredAttribute:\n             return getattr(instance, link_field.attname)\n         return None\n \n+    def __set__(self, instance, value):\n+        \"\"\"\n+        Set the field value, converting enum instances to their underlying values\n+        to ensure consistency between freshly created and database-retrieved objects.\n+        \"\"\"\n+        # Convert enum instances to their underlying values\n+        if hasattr(value, 'name') and hasattr(value, 'value'):\n+            value = value.value\n+        instance.__dict__[self.field.attname] = value\n \n class RegisterLookupMixin:\n \n",
    "variant_8": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 189fb4fa44..8275af4951 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -138,6 +138,17 @@ class DeferredAttribute:\n             data[field_name] = val\n         return data[field_name]\n \n+    def _check_parent_chain(self, instance):\n+        \"\"\"\n+        Check if the field value can be fetched from a parent field already\n+        loaded in the instance. This can be done if the to-be fetched\n+        field is a primary key field.\n+        \"\"\"\n+        opts = instance._meta\n+        link_field = opts.get_ancestor_link(self.field.model)\n+        if self.field.primary_key and self.field != link_field:\n+            return getattr(instance, link_field.attname)\n+\n     def _check_parent_chain(self, instance):\n         \"\"\"\n         Check if the field value can be fetched from a parent field already\n@@ -150,6 +161,14 @@ class DeferredAttribute:\n             return getattr(instance, link_field.attname)\n         return None\n \n+    def __set__(self, instance, value):\n+        \"\"\"\n+        Set the field value, converting enum instances to their underlying values.\n+        \"\"\"\n+        # Convert enum instances to their underlying values\n+        if hasattr(value, 'name') and hasattr(value, 'value'):\n+            value = value.value\n+        instance.__dict__[self.field.attname] = value\n \n class RegisterLookupMixin:\n \n"
  }
}