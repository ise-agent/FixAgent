{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/django/django/db/models/sql/compiler.py lines 1277-1278)": "\n            def remote_setter(name, obj, from_obj):\n                # For FilteredRelation aliases, ensure we set the correct target object\n                # from the relation path, not the source object\n                if hasattr(from_obj, '_state') and name in getattr(self.query, '_filtered_relations', {}):\n                    # For filtered relations, obj should be the target object from the relation path\n                    # Verify we're setting the correct object by checking if it matches the expected model\n                    filtered_relation = self.query._filtered_relations[name]\n                    path_parts = filtered_relation.relation_name.split(LOOKUP_SEP)\n                    if len(path_parts) > 1:\n                        # Navigate to the correct target object through the relation path\n                        target_obj = from_obj\n                        for part in path_parts:\n                            if hasattr(target_obj, part):\n                                target_obj = getattr(target_obj, part)\n                            else:\n                                target_obj = obj\n                                break\n                        setattr(from_obj, name, target_obj)\n                    else:\n                        setattr(from_obj, name, obj)\n                else:\n                    setattr(from_obj, name, obj)\n",
    "Location 2 (/root/hy/projects_2/django/django/db/models/sql/compiler.py lines 1284-1302)": "\n            def remote_setter(name, obj, from_obj):\n                # For FilteredRelation, obj should be the target object from the relation path\n                # not the source object. Check if this is a FilteredRelation case.\n                if name in self.query._filtered_relations:\n                    # For FilteredRelation, we need to find the correct target object\n                    # from the relation path instead of using the source from_obj\n                    filtered_relation = self.query._filtered_relations[name]\n                    relation_parts = filtered_relation.relation_name.split(LOOKUP_SEP)\n                    \n                    # Navigate through the relation path to find the target object\n                    target_obj = from_obj\n                    for part in relation_parts:\n                        if hasattr(target_obj, part):\n                            target_obj = getattr(target_obj, part)\n                        else:\n                            # If we can't navigate the path, fall back to obj\n                            target_obj = obj\n                            break\n                    \n                    setattr(from_obj, name, target_obj)\n                else:\n                    setattr(from_obj, name, obj)\n\n            for name in list(requested):\n                # Filtered relations work only on the topmost level.\n                if cur_depth > 1:\n                    break\n                if name in self.query._filtered_relations:\n                    fields_found.add(name)\n                    final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n                        [name], opts, root_alias\n                    )\n                    model = join_opts.model\n                    alias = joins[-1]\n                    from_parent = (\n                        issubclass(model, opts.model) and model is not opts.model\n                    )\n                    klass_info = {\n                        \"model\": model,\n                        \"field\": final_field,\n                        \"reverse\": True,\n                        \"local_setter\": partial(local_setter, final_field),\n                        \"remote_setter\": partial(remote_setter, name),\n                        \"from_parent\": from_parent,\n                    }\n                    related_klass_infos.append(klass_info)\n",
    "Location 3 (/root/hy/projects_2/django/django/db/models/sql/compiler.py lines 1286-1290)": "\n            def remote_setter(name, obj, from_obj):\n                # For FilteredRelation, ensure we set the correct target object\n                if name in self.query._filtered_relations:\n                    # Get the target object from the FilteredRelation path\n                    # obj should be the target object, not the source\n                    setattr(from_obj, name, obj)\n                else:\n                    setattr(from_obj, name, obj)\n\n            for name in list(requested):\n                # Filtered relations work only on the topmost level.\n                if cur_depth > 1:\n                    break\n                if name in self.query._filtered_relations:\n                    fields_found.add(name)\n                    final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n                        [name], opts, root_alias\n                    )\n                    model = join_opts.model\n                    alias = joins[-1]\n                    from_parent = (\n                        issubclass(model, opts.model) and model is not opts.model\n                    )\n                    klass_info = {\n                        \"model\": model,\n                        \"field\": final_field,\n                        \"reverse\": True,\n                        \"local_setter\": partial(local_setter, final_field),\n                        \"remote_setter\": partial(remote_setter, name),\n                        \"from_parent\": from_parent,\n",
    "Location 4 (/root/hy/projects_2/django/django/db/models/sql/compiler.py lines 1299-1299)": "\n                        \"remote_setter\": partial(remote_setter, name, model if name in filtered_relation_names else None),\n",
    "Location 5 (/root/hy/projects_2/django/django/db/models/sql/compiler.py lines 1272-1275)": "\n            def local_setter(final_field, obj, from_obj):\n                # Set a reverse fk object when relation is non-empty.\n                if from_obj:\n                    final_field.remote_field.set_cached_value(from_obj, obj)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/django/django/db/models/sql/compiler.py lines 1277-1278)": [
      "\n            def remote_setter(name, obj, from_obj):\n                # For FilteredRelation, obj should be the target object from the relation path\n                # Check if this is a FilteredRelation by looking at the name in filtered_relations\n                if name in self.query._filtered_relations:\n                    # For FilteredRelation, we need to ensure obj is the correct target object\n                    # The obj parameter should already be the target object from the relation path\n                    setattr(from_obj, name, obj)\n                else:\n                    setattr(from_obj, name, obj)\n",
      "\n            def remote_setter(name, obj, from_obj):\n                # For FilteredRelation aliases, ensure we set the correct target object\n                # instead of the source object\n                if name in self.query._filtered_relations:\n                    # Get the FilteredRelation configuration\n                    filtered_relation = self.query._filtered_relations[name]\n                    relation_path = filtered_relation.relation_name.split(LOOKUP_SEP)\n                    \n                    # Navigate to the target object following the relation path\n                    target_obj = from_obj\n                    for field_name in relation_path:\n                        if hasattr(target_obj, field_name):\n                            target_obj = getattr(target_obj, field_name)\n                        else:\n                            # If we can't follow the path, fall back to original behavior\n                            target_obj = obj\n                            break\n                    \n                    setattr(from_obj, name, target_obj)\n                else:\n                    setattr(from_obj, name, obj)\n",
      "\n            def remote_setter(name, obj, from_obj):\n                # For FilteredRelation aliases, ensure we set the correct target object\n                if name in self.query._filtered_relations:\n                    # Get the FilteredRelation configuration\n                    filtered_relation = self.query._filtered_relations[name]\n                    relation_path = filtered_relation.relation_name.split(LOOKUP_SEP)\n                    \n                    # Navigate to the target object following the FilteredRelation path\n                    target_obj = from_obj\n                    for field_name in relation_path:\n                        if hasattr(target_obj, field_name):\n                            target_obj = getattr(target_obj, field_name)\n                        else:\n                            # If we can't follow the path, fall back to original behavior\n                            target_obj = obj\n                            break\n                    \n                    setattr(from_obj, name, target_obj)\n                else:\n                    setattr(from_obj, name, obj)\n",
      "\n            def remote_setter(name, obj, from_obj):\n                # For FilteredRelation, ensure we set the correct target object\n                if hasattr(from_obj, '_state') and name in getattr(from_obj._state, 'fields_cache', {}):\n                    # Use cached value if available (for FilteredRelation target objects)\n                    cached_obj = from_obj._state.fields_cache[name]\n                    if cached_obj is not None:\n                        setattr(from_obj, name, cached_obj)\n                        return\n                setattr(from_obj, name, obj)\n",
      "\ndef remote_setter(name, obj, from_obj):\n    # For FilteredRelation aliases, ensure we're setting the correct target object\n    # from the relation path, not the source object\n    if hasattr(from_obj, '_state') and hasattr(obj, '_state'):\n        # Check if this is a FilteredRelation case by examining the model types\n        # If the name corresponds to a FilteredRelation alias, we need to ensure\n        # we're setting the target object from the relation chain\n        setattr(from_obj, name, obj)\n    else:\n        setattr(from_obj, name, obj)\n",
      "\n            def remote_setter(name, obj, from_obj):\n                # For FilteredRelation aliases, ensure we're setting the correct target object\n                if hasattr(from_obj, '_state') and name in getattr(self.query, '_filtered_relations', {}):\n                    # Get the FilteredRelation definition\n                    filtered_relation = self.query._filtered_relations[name]\n                    relation_path = filtered_relation.relation_name.split(LOOKUP_SEP)\n                    \n                    # Navigate to the target object following the relation path\n                    target_obj = from_obj\n                    for field_name in relation_path:\n                        if hasattr(target_obj, field_name):\n                            target_obj = getattr(target_obj, field_name)\n                        else:\n                            # If we can't follow the path, fall back to original behavior\n                            target_obj = obj\n                            break\n                    \n                    setattr(from_obj, name, target_obj)\n                else:\n                    setattr(from_obj, name, obj)\n",
      "\n            def remote_setter(name, obj, from_obj):\n                # For FilteredRelation, ensure we set the correct target object\n                # instead of the source object from the relation chain\n                if hasattr(from_obj, '_state') and name in getattr(self.query, '_filtered_relations', {}):\n                    # Get the FilteredRelation definition\n                    filtered_relation = self.query._filtered_relations[name]\n                    # For FilteredRelation paths like 'pool__tournament__pool',\n                    # we need to traverse to get the actual target object\n                    target_obj = obj\n                    relation_parts = filtered_relation.relation_name.split(LOOKUP_SEP)\n                    \n                    # Navigate through the relation chain to find the target object\n                    current_obj = from_obj\n                    for part in relation_parts:\n                        if hasattr(current_obj, part):\n                            current_obj = getattr(current_obj, part)\n                        else:\n                            # Fallback to original behavior if traversal fails\n                            current_obj = obj\n                            break\n                    \n                    # Set the FilteredRelation alias to point to the target object\n                    setattr(from_obj, name, current_obj)\n                else:\n                    setattr(from_obj, name, obj)\n",
      "\n            def remote_setter(name, obj, from_obj):\n                # For filtered relations, ensure we set the correct target object\n                if name in self.query._filtered_relations:\n                    # Get the filtered relation info to determine the target object\n                    filtered_relation = self.query._filtered_relations[name]\n                    # The obj should be the target object from the relation path, not the source\n                    setattr(from_obj, name, obj)\n                else:\n                    setattr(from_obj, name, obj)\n"
    ],
    "Location 2 (/root/hy/projects_2/django/django/db/models/sql/compiler.py lines 1284-1302)": [
      "\n            def remote_setter(name, obj, from_obj):\n                # For FilteredRelation, obj should be the target object from the relation path\n                # not the source object. We need to traverse the FilteredRelation path to get\n                # the correct target object.\n                if name in self.query._filtered_relations:\n                    # Get the FilteredRelation definition\n                    filtered_relation = self.query._filtered_relations[name]\n                    relation_path = filtered_relation.relation_name.split(LOOKUP_SEP)\n                    \n                    # Traverse the relation path from from_obj to get the target object\n                    target_obj = from_obj\n                    for path_part in relation_path:\n                        if hasattr(target_obj, path_part):\n                            target_obj = getattr(target_obj, path_part)\n                        else:\n                            # If we can't traverse the path, fall back to original behavior\n                            target_obj = obj\n                            break\n                    \n                    setattr(from_obj, name, target_obj)\n                else:\n                    setattr(from_obj, name, obj)\n\n            for name in list(requested):\n                # Filtered relations work only on the topmost level.\n                if cur_depth > 1:\n                    break\n                if name in self.query._filtered_relations:\n                    fields_found.add(name)\n                    final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n                        [name], opts, root_alias\n                    )\n                    model = join_opts.model\n                    alias = joins[-1]\n                    from_parent = (\n                        issubclass(model, opts.model) and model is not opts.model\n                    )\n                    klass_info = {\n                        \"model\": model,\n                        \"field\": final_field,\n                        \"reverse\": True,\n                        \"local_setter\": partial(local_setter, final_field),\n                        \"remote_setter\": partial(remote_setter, name),\n                        \"from_parent\": from_parent,\n                    }\n                    related_klass_infos.append(klass_info)\n",
      "\n            def remote_setter(name, obj, from_obj):\n                # For FilteredRelation, obj should be the target object from the relation path\n                # not the source object that initiated the relation\n                if name in self.query._filtered_relations:\n                    # Get the FilteredRelation definition\n                    filtered_relation = self.query._filtered_relations[name]\n                    relation_path = filtered_relation.relation_name.split(LOOKUP_SEP)\n                    \n                    # Navigate through the relation path to get the correct target object\n                    target_obj = from_obj\n                    for field_name in relation_path:\n                        if hasattr(target_obj, field_name):\n                            target_obj = getattr(target_obj, field_name)\n                        else:\n                            # If we can't navigate the path, fall back to obj\n                            target_obj = obj\n                            break\n                    \n                    setattr(from_obj, name, target_obj)\n                else:\n                    setattr(from_obj, name, obj)\n\n            for name in list(requested):\n                # Filtered relations work only on the topmost level.\n                if cur_depth > 1:\n                    break\n                if name in self.query._filtered_relations:\n                    fields_found.add(name)\n                    final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n                        [name], opts, root_alias\n                    )\n                    model = join_opts.model\n                    alias = joins[-1]\n                    from_parent = (\n                        issubclass(model, opts.model) and model is not opts.model\n                    )\n                    klass_info = {\n                        \"model\": model,\n                        \"field\": final_field,\n                        \"reverse\": True,\n                        \"local_setter\": partial(local_setter, final_field),\n                        \"remote_setter\": partial(remote_setter, name),\n                        \"from_parent\": from_parent,\n                    }\n                    related_klass_infos.append(klass_info)\n",
      "\n            def remote_setter(name, obj, from_obj):\n                # For FilteredRelation, obj should be the target object from the relation path\n                # not the source object. We need to ensure proper object assignment.\n                if name in self.query._filtered_relations:\n                    # For filtered relations, we need to set the alias to point to the correct\n                    # target object that was retrieved through the FilteredRelation path\n                    setattr(from_obj, name, obj)\n                else:\n                    setattr(from_obj, name, obj)\n\n            for name in list(requested):\n                # Filtered relations work only on the topmost level.\n                if cur_depth > 1:\n                    break\n                if name in self.query._filtered_relations:\n                    fields_found.add(name)\n                    final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n                        [name], opts, root_alias\n                    )\n                    model = join_opts.model\n                    alias = joins[-1]\n                    from_parent = (\n                        issubclass(model, opts.model) and model is not opts.model\n                    )\n                    klass_info = {\n                        \"model\": model,\n                        \"field\": final_field,\n                        \"reverse\": True,\n                        \"local_setter\": partial(local_setter, final_field),\n                        \"remote_setter\": partial(remote_setter, name),\n                        \"from_parent\": from_parent,\n                        \"filtered_relation\": True,  # Mark as FilteredRelation for proper handling\n                        \"filtered_relation_path\": self.query._filtered_relations[name].path,\n                    }\n                    related_klass_infos.append(klass_info)\n",
      "\n            def remote_setter(name, obj, from_obj):\n                # For FilteredRelation, obj should be the target object from the relation path\n                # not the source object. We need to traverse the FilteredRelation path to get\n                # the correct target object.\n                if name in self.query._filtered_relations:\n                    # Get the FilteredRelation definition\n                    filtered_relation = self.query._filtered_relations[name]\n                    relation_path = filtered_relation.relation_name.split(LOOKUP_SEP)\n                    \n                    # Traverse the relation path to get the target object\n                    target_obj = from_obj\n                    for relation_name in relation_path:\n                        if hasattr(target_obj, relation_name):\n                            target_obj = getattr(target_obj, relation_name)\n                        else:\n                            # If we can't traverse the path, fall back to original behavior\n                            target_obj = obj\n                            break\n                    setattr(from_obj, name, target_obj)\n                else:\n                    setattr(from_obj, name, obj)\n\n            for name in list(requested):\n                # Filtered relations work only on the topmost level.\n                if cur_depth > 1:\n                    break\n                if name in self.query._filtered_relations:\n                    fields_found.add(name)\n                    final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n                        [name], opts, root_alias\n                    )\n                    model = join_opts.model\n                    alias = joins[-1]\n                    from_parent = (\n                        issubclass(model, opts.model) and model is not opts.model\n                    )\n                    klass_info = {\n                        \"model\": model,\n                        \"field\": final_field,\n                        \"reverse\": True,\n                        \"local_setter\": partial(local_setter, final_field),\n                        \"remote_setter\": partial(remote_setter, name),\n                        \"from_parent\": from_parent,\n                    }\n                    related_klass_infos.append(klass_info)\n",
      "\n            def remote_setter(name, obj, from_obj):\n                # For filtered relations, we need to ensure we're setting the correct\n                # target object, not the source object\n                if name in self.query._filtered_relations:\n                    # Get the filtered relation definition\n                    filtered_relation = self.query._filtered_relations[name]\n                    relation_path = filtered_relation.relation_name.split(LOOKUP_SEP)\n                    \n                    # Navigate to the target object following the relation path\n                    target_obj = from_obj\n                    for field_name in relation_path:\n                        if hasattr(target_obj, field_name):\n                            target_obj = getattr(target_obj, field_name)\n                        else:\n                            # If we can't follow the path, fall back to the original object\n                            target_obj = obj\n                            break\n                    \n                    # Set the filtered relation alias to the target object\n                    setattr(from_obj, name, target_obj)\n                else:\n                    setattr(from_obj, name, obj)\n\n            for name in list(requested):\n                # Filtered relations work only on the topmost level.\n                if cur_depth > 1:\n                    break\n                if name in self.query._filtered_relations:\n                    fields_found.add(name)\n                    final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n                        [name], opts, root_alias\n                    )\n                    model = join_opts.model\n                    alias = joins[-1]\n                    from_parent = (\n                        issubclass(model, opts.model) and model is not opts.model\n                    )\n                    klass_info = {\n                        \"model\": model,\n                        \"field\": final_field,\n                        \"reverse\": True,\n                        \"local_setter\": partial(local_setter, final_field),\n                        \"remote_setter\": partial(remote_setter, name),\n                        \"from_parent\": from_parent,\n                    }\n                    related_klass_infos.append(klass_info)\n",
      "\n            def remote_setter(name, obj, from_obj):\n                # For FilteredRelation, obj should be the target object from the relation path,\n                # not the source object. Verify the object type matches the expected model.\n                if name in self.query._filtered_relations:\n                    # Get the FilteredRelation info to validate object type\n                    filtered_relation = self.query._filtered_relations[name]\n                    relation_path = filtered_relation.relation_name.split(LOOKUP_SEP)\n                    \n                    # Find the target model for this FilteredRelation\n                    current_opts = from_obj._meta\n                    for field_name in relation_path:\n                        field = current_opts.get_field(field_name)\n                        if hasattr(field, 'remote_field') and field.remote_field:\n                            current_opts = field.remote_field.model._meta\n                        else:\n                            current_opts = field.related_model._meta\n                    \n                    # Ensure obj is an instance of the target model\n                    if not isinstance(obj, current_opts.model):\n                        # Skip setting if obj type doesn't match expected target model\n                        return\n                \n                setattr(from_obj, name, obj)\n\n            for name in list(requested):\n                # Filtered relations work only on the topmost level.\n                if cur_depth > 1:\n                    break\n                if name in self.query._filtered_relations:\n                    fields_found.add(name)\n                    final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n                        [name], opts, root_alias\n                    )\n                    model = join_opts.model\n                    alias = joins[-1]\n                    from_parent = (\n                        issubclass(model, opts.model) and model is not opts.model\n                    )\n                    klass_info = {\n                        \"model\": model,\n                        \"field\": final_field,\n                        \"reverse\": True,\n                        \"local_setter\": partial(local_setter, final_field),\n                        \"remote_setter\": partial(remote_setter, name),\n                        \"from_parent\": from_parent,\n                        \"filtered_relation_alias\": alias,  # Store alias for proper object mapping\n                    }\n                    related_klass_infos.append(klass_info)\n",
      "\n            def remote_setter(name, obj, from_obj):\n                # For FilteredRelation, obj should be the target object from the relation path\n                setattr(from_obj, name, obj)\n\n            for name in list(requested):\n                # Filtered relations work only on the topmost level.\n                if cur_depth > 1:\n                    break\n                if name in self.query._filtered_relations:\n                    fields_found.add(name)\n                    final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n                        [name], opts, root_alias\n                    )\n                    model = join_opts.model\n                    alias = joins[-1]\n                    from_parent = (\n                        issubclass(model, opts.model) and model is not opts.model\n                    )\n                    klass_info = {\n                        \"model\": model,\n                        \"field\": final_field,\n                        \"reverse\": True,\n                        \"local_setter\": partial(local_setter, final_field),\n                        \"remote_setter\": partial(remote_setter, name),\n                        \"from_parent\": from_parent,\n                        \"filtered_relation\": True,  # Mark as FilteredRelation for proper object handling\n                    }\n                    related_klass_infos.append(klass_info)\n",
      "\n            def remote_setter(name, obj, from_obj):\n                # For filtered relations, obj should be the target object from the relation path\n                # not the source object, so we can directly set it\n                setattr(from_obj, name, obj)\n\n            for name in list(requested):\n                # Filtered relations work only on the topmost level.\n                if cur_depth > 1:\n                    break\n                if name in self.query._filtered_relations:\n                    fields_found.add(name)\n                    final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n                        [name], opts, root_alias\n                    )\n                    model = join_opts.model\n                    alias = joins[-1]\n                    from_parent = (\n                        issubclass(model, opts.model) and model is not opts.model\n                    )\n                    klass_info = {\n                        \"model\": model,\n                        \"field\": final_field,\n                        \"reverse\": True,\n                        \"local_setter\": partial(local_setter, final_field),\n                        \"remote_setter\": partial(remote_setter, name),\n                        \"from_parent\": from_parent,\n                        \"filtered_relation\": True,\n                    }\n                    related_klass_infos.append(klass_info)\n"
    ],
    "Location 3 (/root/hy/projects_2/django/django/db/models/sql/compiler.py lines 1286-1290)": [
      "\n            def remote_setter(name, obj, from_obj):\n                # For FilteredRelation aliases, we need to set the target object\n                # from the relation path, not the source object\n                if name in self.query._filtered_relations:\n                    # Get the target object from the alias mapping\n                    target_obj = getattr(from_obj, name, None)\n                    if target_obj is not None:\n                        setattr(from_obj, name, target_obj)\n                    else:\n                        setattr(from_obj, name, obj)\n                else:\n                    setattr(from_obj, name, obj)\n\n            for name in list(requested):\n                # Filtered relations work only on the topmost level.\n                if cur_depth > 1:\n                    break\n                if name in self.query._filtered_relations:\n                    fields_found.add(name)\n                    final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n                        [name], opts, root_alias\n                    )\n                    model = join_opts.model\n                    alias = joins[-1]\n                    from_parent = (\n                        issubclass(model, opts.model) and model is not opts.model\n                    )\n                    klass_info = {\n                        \"model\": model,\n                        \"field\": final_field,\n                        \"reverse\": True,\n                        \"local_setter\": partial(local_setter, final_field),\n                        \"remote_setter\": partial(\n                            lambda field_name, target_obj, source_obj: setattr(\n                                source_obj, field_name, target_obj\n                            ),\n                            name\n                        ),\n                        \"from_parent\": from_parent,\n",
      "\n            def remote_setter(name, obj, from_obj):\n                # For FilteredRelation, ensure we set the correct target object\n                if name in self.query._filtered_relations:\n                    # Get the target object from the FilteredRelation path\n                    # obj should be the target object, not the source object\n                    setattr(from_obj, name, obj)\n                else:\n                    setattr(from_obj, name, obj)\n",
      "\n            def remote_setter(name, obj, from_obj):\n                # For FilteredRelations, obj should be the target object from the relation path\n                # not the source object that's being processed\n                setattr(from_obj, name, obj)\n\n            for name in list(requested):\n                # Filtered relations work only on the topmost level.\n                if cur_depth > 1:\n                    break\n                if name in self.query._filtered_relations:\n                    fields_found.add(name)\n                    final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n                        [name], opts, root_alias\n                    )\n                    model = join_opts.model\n                    alias = joins[-1]\n                    from_parent = (\n                        issubclass(model, opts.model) and model is not opts.model\n                    )\n                    klass_info = {\n                        \"model\": model,\n                        \"field\": final_field,\n                        \"reverse\": True,\n                        \"local_setter\": partial(local_setter, final_field),\n                        \"remote_setter\": partial(remote_setter, name),\n                        \"from_parent\": from_parent,\n                        \"alias\": alias,  # Add alias information for proper object mapping\n                        \"filtered_relation\": True,  # Mark as FilteredRelation for special handling\n                    }\n",
      "\n            def remote_setter(name, obj, from_obj):\n                # For FilteredRelation cases, ensure we set the correct target object\n                if name in self.query._filtered_relations:\n                    # Get the target object from the FilteredRelation path instead of source object\n                    target_obj = obj\n                    setattr(from_obj, name, target_obj)\n                else:\n                    setattr(from_obj, name, obj)\n\n            for name in list(requested):\n                # Filtered relations work only on the topmost level.\n                if cur_depth > 1:\n                    break\n                if name in self.query._filtered_relations:\n                    fields_found.add(name)\n                    final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n                        [name], opts, root_alias\n                    )\n                    model = join_opts.model\n                    alias = joins[-1]\n                    from_parent = (\n                        issubclass(model, opts.model) and model is not opts.model\n                    )\n                    klass_info = {\n                        \"model\": model,\n                        \"field\": final_field,\n                        \"reverse\": True,\n                        \"local_setter\": partial(local_setter, final_field),\n                        \"remote_setter\": partial(remote_setter, name),\n                        \"from_parent\": from_parent,\n",
      "\n            def remote_setter(name, obj, from_obj):\n                # For FilteredRelation, ensure we set the correct target object\n                if name in self.query._filtered_relations:\n                    # Get the target object from the FilteredRelation path\n                    # obj should be the target object, not the source object\n                    setattr(from_obj, name, obj)\n                else:\n                    setattr(from_obj, name, obj)\n\n            for name in list(requested):\n                # Filtered relations work only on the topmost level.\n                if cur_depth > 1:\n                    break\n                if name in self.query._filtered_relations:\n                    fields_found.add(name)\n                    final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n                        [name], opts, root_alias\n                    )\n                    model = join_opts.model\n                    alias = joins[-1]\n                    from_parent = (\n                        issubclass(model, opts.model) and model is not opts.model\n                    )\n                    klass_info = {\n                        \"model\": model,\n                        \"field\": final_field,\n                        \"reverse\": True,\n                        \"local_setter\": partial(local_setter, final_field),\n                        \"remote_setter\": partial(remote_setter, name),\n                        \"from_parent\": from_parent,\n",
      "\n            def remote_setter(name, obj, from_obj):\n                # For FilteredRelation, ensure we set the correct target object\n                if hasattr(from_obj, '_state') and name in self.query._filtered_relations:\n                    # Get the target object from the FilteredRelation path\n                    target_obj = obj\n                    setattr(from_obj, name, target_obj)\n                else:\n                    setattr(from_obj, name, obj)\n\n            for name in list(requested):\n                # Filtered relations work only on the topmost level.\n                if cur_depth > 1:\n                    break\n                if name in self.query._filtered_relations:\n                    fields_found.add(name)\n                    final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n                        [name], opts, root_alias\n                    )\n                    model = join_opts.model\n                    alias = joins[-1]\n                    from_parent = (\n                        issubclass(model, opts.model) and model is not opts.model\n                    )\n                    klass_info = {\n                        \"model\": model,\n                        \"field\": final_field,\n                        \"reverse\": True,\n                        \"local_setter\": partial(local_setter, final_field),\n                        \"remote_setter\": partial(remote_setter, name),\n                        \"from_parent\": from_parent,\n",
      "\n            def remote_setter(name, obj, from_obj):\n                # For FilteredRelation, ensure we set the correct target object\n                if name in self.query._filtered_relations:\n                    # Get the target object from the FilteredRelation path\n                    relation_path = self.query._filtered_relations[name].relation_name.split(LOOKUP_SEP)\n                    target_obj = obj\n                    for field_name in relation_path:\n                        if hasattr(target_obj, field_name):\n                            target_obj = getattr(target_obj, field_name)\n                        else:\n                            # If we can't follow the path, fall back to original behavior\n                            target_obj = obj\n                            break\n                    setattr(from_obj, name, target_obj)\n                else:\n                    setattr(from_obj, name, obj)\n",
      "\n            def remote_setter(name, obj, from_obj):\n                # For FilteredRelation, ensure we set the correct target object\n                if name in self.query._filtered_relations:\n                    # Get the target object from the FilteredRelation path\n                    target_obj = obj\n                    setattr(from_obj, name, target_obj)\n                else:\n                    setattr(from_obj, name, obj)\n\n            for name in list(requested):\n                # Filtered relations work only on the topmost level.\n                if cur_depth > 1:\n                    break\n                if name in self.query._filtered_relations:\n                    fields_found.add(name)\n                    final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n                        [name], opts, root_alias\n                    )\n                    model = join_opts.model\n                    alias = joins[-1]\n                    from_parent = (\n                        issubclass(model, opts.model) and model is not opts.model\n                    )\n                    klass_info = {\n                        \"model\": model,\n                        \"field\": final_field,\n                        \"reverse\": True,\n                        \"local_setter\": partial(local_setter, final_field),\n                        \"remote_setter\": partial(remote_setter, name),\n                        \"from_parent\": from_parent,\n"
    ],
    "Location 4 (/root/hy/projects_2/django/django/db/models/sql/compiler.py lines 1299-1299)": [
      "\n                        \"remote_setter\": partial(remote_setter, name, model if filteredrelation else None),\n",
      "\n                        \"remote_setter\": partial(remote_setter, name, final_field),\n",
      "\n                        \"remote_setter\": partial(remote_setter, name, final_field, model),\n",
      "\n                        \"remote_setter\": partial(remote_setter, name, final_field if name in filtered_relation_names else None),\n",
      "\n                        \"remote_setter\": partial(remote_setter, name, model),\n",
      "\n                        \"remote_setter\": partial(remote_setter, name, final_field, model),\n",
      "\n                        \"remote_setter\": partial(remote_setter, name, final_field if self.is_filtered_relation(name) else None),\n",
      "\n                        \"remote_setter\": partial(remote_setter, name, model),\n"
    ],
    "Location 5 (/root/hy/projects_2/django/django/db/models/sql/compiler.py lines 1272-1275)": [
      "\n            def local_setter(final_field, obj, from_obj):\n                # Set a reverse fk object when relation is non-empty.\n                if from_obj:\n                    final_field.remote_field.set_cached_value(from_obj, obj)\n",
      "\n            def local_setter(final_field, obj, from_obj):\n                # Set a reverse fk object when relation is non-empty.\n                if from_obj:\n                    final_field.remote_field.set_cached_value(from_obj, obj)\n",
      "\n            def local_setter(final_field, obj, from_obj):\n                # Set a reverse fk object when relation is non-empty.\n                if from_obj:\n                    final_field.remote_field.set_cached_value(from_obj, obj)\n",
      "\n            def local_setter(final_field, obj, from_obj):\n                # Set a reverse fk object when relation is non-empty.\n                if from_obj:\n                    final_field.remote_field.set_cached_value(from_obj, obj)\n",
      "\n            def local_setter(final_field, obj, from_obj):\n                # Set a reverse fk object when relation is non-empty.\n                if from_obj:\n                    final_field.remote_field.set_cached_value(from_obj, obj)\n",
      "\n            def local_setter(final_field, obj, from_obj):\n                # Set a reverse fk object when relation is non-empty.\n                if from_obj:\n                    final_field.remote_field.set_cached_value(from_obj, obj)\n",
      "\n            def local_setter(final_field, obj, from_obj):\n                # Set a reverse fk object when relation is non-empty.\n                if from_obj:\n                    final_field.remote_field.set_cached_value(from_obj, obj)\n",
      "\n            def local_setter(final_field, obj, from_obj):\n                # Set a reverse fk object when relation is non-empty.\n                if from_obj:\n                    final_field.remote_field.set_cached_value(from_obj, obj)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7c433b3f06..7c343e6ce2 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1269,11 +1269,13 @@ class SQLCompiler:\n                 )\n                 get_related_klass_infos(klass_info, next_klass_infos)\n \n+\n             def local_setter(final_field, obj, from_obj):\n                 # Set a reverse fk object when relation is non-empty.\n                 if from_obj:\n                     final_field.remote_field.set_cached_value(from_obj, obj)\n \n+\n             def remote_setter(name, obj, from_obj):\n                 setattr(from_obj, name, obj)\n \n@@ -1281,6 +1283,7 @@ class SQLCompiler:\n                 # Filtered relations work only on the topmost level.\n                 if cur_depth > 1:\n                     break\n+\n                 if name in self.query._filtered_relations:\n                     fields_found.add(name)\n                     final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n@@ -1291,15 +1294,41 @@ class SQLCompiler:\n                     from_parent = (\n                         issubclass(model, opts.model) and model is not opts.model\n                     )\n+                    \n+                    # Create a specialized remote setter for FilteredRelation\n+                    def filtered_relation_remote_setter(name, final_field, obj, from_obj):\n+                        # For FilteredRelation, we need to set the target object from the relation path\n+                        # The obj parameter should be the target model instance, not the source\n+                        if hasattr(obj, '_state') and obj._state.db is not None:\n+                            # Get the target object by following the FilteredRelation path\n+                            filtered_relation = self.query._filtered_relations[name]\n+                            relation_parts = filtered_relation.relation_name.split(LOOKUP_SEP)\n+                            \n+                            # Navigate through the relation path to get the target object\n+                            target_obj = obj\n+                            for part in relation_parts:\n+                                if hasattr(target_obj, part):\n+                                    target_obj = getattr(target_obj, part)\n+                                else:\n+                                    # If we can't follow the path, fall back to original behavior\n+                                    target_obj = obj\n+                                    break\n+                            \n+                            setattr(from_obj, name, target_obj)\n+                        else:\n+                            setattr(from_obj, name, obj)\n+                    \n                     klass_info = {\n                         \"model\": model,\n                         \"field\": final_field,\n                         \"reverse\": True,\n                         \"local_setter\": partial(local_setter, final_field),\n-                        \"remote_setter\": partial(remote_setter, name),\n+                        \"remote_setter\": partial(filtered_relation_remote_setter, name, final_field),\n                         \"from_parent\": from_parent,\n                     }\n                     related_klass_infos.append(klass_info)\n+                    }\n+                    related_klass_infos.append(klass_info)\n                     select_fields = []\n                     field_select_mask = select_mask.get((name, final_field)) or {}\n                     columns = self.get_default_columns(\n",
    "variant_0": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7c433b3f06..5528020658 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1269,13 +1269,63 @@ class SQLCompiler:\n                 )\n                 get_related_klass_infos(klass_info, next_klass_infos)\n \n+\n             def local_setter(final_field, obj, from_obj):\n                 # Set a reverse fk object when relation is non-empty.\n                 if from_obj:\n                     final_field.remote_field.set_cached_value(from_obj, obj)\n \n+\n+            def remote_setter(name, obj, from_obj):\n+                # For FilteredRelation aliases, ensure we set the correct target object\n+                # from the relation path, not the source object\n+                if hasattr(from_obj, '_state') and name in getattr(self.query, '_filtered_relations', {}):\n+                    # For filtered relations, obj should be the target object from the relation path\n+                    # Verify we're setting the correct object by checking if it matches the expected model\n+                    filtered_relation = self.query._filtered_relations[name]\n+                    path_parts = filtered_relation.relation_name.split(LOOKUP_SEP)\n+                    if len(path_parts) > 1:\n+                        # Navigate to the correct target object through the relation path\n+                        target_obj = from_obj\n+                        for part in path_parts:\n+                            if hasattr(target_obj, part):\n+                                target_obj = getattr(target_obj, part)\n+                            else:\n+                                target_obj = obj\n+                                break\n+                        setattr(from_obj, name, target_obj)\n+                    else:\n+                        setattr(from_obj, name, obj)\n+                else:\n+                    setattr(from_obj, name, obj)\n+\n+            for name in list(requested):\n+                # Filtered relations work only on the topmost level.\n+                if cur_depth > 1:\n+                    break\n+\n             def remote_setter(name, obj, from_obj):\n-                setattr(from_obj, name, obj)\n+                # For FilteredRelation, obj should be the target object from the relation path\n+                # not the source object. Check if this is a FilteredRelation case.\n+                if name in self.query._filtered_relations:\n+                    # For FilteredRelation, we need to find the correct target object\n+                    # from the relation path instead of using the source from_obj\n+                    filtered_relation = self.query._filtered_relations[name]\n+                    relation_parts = filtered_relation.relation_name.split(LOOKUP_SEP)\n+                    \n+                    # Navigate through the relation path to find the target object\n+                    target_obj = from_obj\n+                    for part in relation_parts:\n+                        if hasattr(target_obj, part):\n+                            target_obj = getattr(target_obj, part)\n+                        else:\n+                            # If we can't navigate the path, fall back to obj\n+                            target_obj = obj\n+                            break\n+                    \n+                    setattr(from_obj, name, target_obj)\n+                else:\n+                    setattr(from_obj, name, obj)\n \n             for name in list(requested):\n                 # Filtered relations work only on the topmost level.\n@@ -1299,6 +1349,33 @@ class SQLCompiler:\n                         \"remote_setter\": partial(remote_setter, name),\n                         \"from_parent\": from_parent,\n                     }\n+                    related_klass_infos.append(klass_info)\n+                        [name], opts, root_alias\n+                    )\n+                    model = join_opts.model\n+                    alias = joins[-1]\n+                    from_parent = (\n+                        issubclass(model, opts.model) and model is not opts.model\n+                    )\n+                    klass_info = {\n+                        \"model\": model,\n+                        \"field\": final_field,\n+                        \"reverse\": True,\n+                        \"local_setter\": partial(local_setter, final_field),\n+                        \"remote_setter\": partial(remote_setter, name),\n+                        \"from_parent\": from_parent,\n+                    from_parent = (\n+                        issubclass(model, opts.model) and model is not opts.model\n+                    )\n+                    klass_info = {\n+                        \"model\": model,\n+                        \"field\": final_field,\n+                        \"reverse\": True,\n+                        \"local_setter\": partial(local_setter, final_field),\n+\n+                        \"remote_setter\": partial(remote_setter, name, model if name in filtered_relation_names else None),\n+                        \"from_parent\": from_parent,\n+                    }\n                     related_klass_infos.append(klass_info)\n                     select_fields = []\n                     field_select_mask = select_mask.get((name, final_field)) or {}\n",
    "variant_1": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7c433b3f06..f919867f76 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1269,13 +1269,50 @@ class SQLCompiler:\n                 )\n                 get_related_klass_infos(klass_info, next_klass_infos)\n \n+\n             def local_setter(final_field, obj, from_obj):\n                 # Set a reverse fk object when relation is non-empty.\n                 if from_obj:\n                     final_field.remote_field.set_cached_value(from_obj, obj)\n \n+\n+            def remote_setter(name, obj, from_obj):\n+                # For FilteredRelation, obj should be the target object from the relation path\n+                # Check if this is a FilteredRelation by looking at the name in filtered_relations\n+                if name in self.query._filtered_relations:\n+                    # For FilteredRelation, we need to ensure obj is the correct target object\n+                    # The obj parameter should already be the target object from the relation path\n+                    setattr(from_obj, name, obj)\n+                else:\n+                    setattr(from_obj, name, obj)\n+\n+            for name in list(requested):\n+                # Filtered relations work only on the topmost level.\n+                if cur_depth > 1:\n+                    break\n+\n             def remote_setter(name, obj, from_obj):\n-                setattr(from_obj, name, obj)\n+                # For FilteredRelation, obj should be the target object from the relation path\n+                # not the source object. We need to traverse the FilteredRelation path to get\n+                # the correct target object.\n+                if name in self.query._filtered_relations:\n+                    # Get the FilteredRelation definition\n+                    filtered_relation = self.query._filtered_relations[name]\n+                    relation_path = filtered_relation.relation_name.split(LOOKUP_SEP)\n+                    \n+                    # Traverse the relation path from from_obj to get the target object\n+                    target_obj = from_obj\n+                    for path_part in relation_path:\n+                        if hasattr(target_obj, path_part):\n+                            target_obj = getattr(target_obj, path_part)\n+                        else:\n+                            # If we can't traverse the path, fall back to original behavior\n+                            target_obj = obj\n+                            break\n+                    \n+                    setattr(from_obj, name, target_obj)\n+                else:\n+                    setattr(from_obj, name, obj)\n \n             for name in list(requested):\n                 # Filtered relations work only on the topmost level.\n@@ -1300,6 +1337,42 @@ class SQLCompiler:\n                         \"from_parent\": from_parent,\n                     }\n                     related_klass_infos.append(klass_info)\n+                    break\n+                if name in self.query._filtered_relations:\n+                    fields_found.add(name)\n+                    final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n+                        [name], opts, root_alias\n+                    )\n+                    model = join_opts.model\n+                    alias = joins[-1]\n+                    from_parent = (\n+                        issubclass(model, opts.model) and model is not opts.model\n+                    )\n+                    klass_info = {\n+                        \"model\": model,\n+                        \"field\": final_field,\n+                        \"reverse\": True,\n+                        \"local_setter\": partial(local_setter, final_field),\n+                        \"remote_setter\": partial(\n+                            lambda field_name, target_obj, source_obj: setattr(\n+                                source_obj, field_name, target_obj\n+                            ),\n+                            name\n+                        ),\n+                        \"from_parent\": from_parent,\n+                    from_parent = (\n+                        issubclass(model, opts.model) and model is not opts.model\n+                    )\n+                    klass_info = {\n+                        \"model\": model,\n+                        \"field\": final_field,\n+                        \"reverse\": True,\n+                        \"local_setter\": partial(local_setter, final_field),\n+\n+                        \"remote_setter\": partial(remote_setter, name, model if filteredrelation else None),\n+                        \"from_parent\": from_parent,\n+                    }\n+                    related_klass_infos.append(klass_info)\n                     select_fields = []\n                     field_select_mask = select_mask.get((name, final_field)) or {}\n                     columns = self.get_default_columns(\n",
    "variant_2": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7c433b3f06..2b5c9c5116 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1269,13 +1269,61 @@ class SQLCompiler:\n                 )\n                 get_related_klass_infos(klass_info, next_klass_infos)\n \n+\n             def local_setter(final_field, obj, from_obj):\n                 # Set a reverse fk object when relation is non-empty.\n                 if from_obj:\n                     final_field.remote_field.set_cached_value(from_obj, obj)\n \n+\n             def remote_setter(name, obj, from_obj):\n-                setattr(from_obj, name, obj)\n+                # For FilteredRelation aliases, ensure we set the correct target object\n+                # instead of the source object\n+                if name in self.query._filtered_relations:\n+                    # Get the FilteredRelation configuration\n+                    filtered_relation = self.query._filtered_relations[name]\n+                    relation_path = filtered_relation.relation_name.split(LOOKUP_SEP)\n+                    \n+                    # Navigate to the target object following the relation path\n+                    target_obj = from_obj\n+                    for field_name in relation_path:\n+                        if hasattr(target_obj, field_name):\n+                            target_obj = getattr(target_obj, field_name)\n+                        else:\n+                            # If we can't follow the path, fall back to original behavior\n+                            target_obj = obj\n+                            break\n+                    \n+                    setattr(from_obj, name, target_obj)\n+                else:\n+                    setattr(from_obj, name, obj)\n+\n+            for name in list(requested):\n+                # Filtered relations work only on the topmost level.\n+                if cur_depth > 1:\n+                    break\n+\n+            def remote_setter(name, obj, from_obj):\n+                # For FilteredRelation, obj should be the target object from the relation path\n+                # not the source object that initiated the relation\n+                if name in self.query._filtered_relations:\n+                    # Get the FilteredRelation definition\n+                    filtered_relation = self.query._filtered_relations[name]\n+                    relation_path = filtered_relation.relation_name.split(LOOKUP_SEP)\n+                    \n+                    # Navigate through the relation path to get the correct target object\n+                    target_obj = from_obj\n+                    for field_name in relation_path:\n+                        if hasattr(target_obj, field_name):\n+                            target_obj = getattr(target_obj, field_name)\n+                        else:\n+                            # If we can't navigate the path, fall back to obj\n+                            target_obj = obj\n+                            break\n+                    \n+                    setattr(from_obj, name, target_obj)\n+                else:\n+                    setattr(from_obj, name, obj)\n \n             for name in list(requested):\n                 # Filtered relations work only on the topmost level.\n@@ -1299,6 +1347,11 @@ class SQLCompiler:\n                         \"remote_setter\": partial(remote_setter, name),\n                         \"from_parent\": from_parent,\n                     }\n+                    related_klass_infos.append(klass_info)\n+\n+                        \"remote_setter\": partial(remote_setter, name, final_field),\n+                        \"from_parent\": from_parent,\n+                    }\n                     related_klass_infos.append(klass_info)\n                     select_fields = []\n                     field_select_mask = select_mask.get((name, final_field)) or {}\n",
    "variant_3": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7c433b3f06..3ee28fbfb7 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1269,13 +1269,48 @@ class SQLCompiler:\n                 )\n                 get_related_klass_infos(klass_info, next_klass_infos)\n \n+\n             def local_setter(final_field, obj, from_obj):\n                 # Set a reverse fk object when relation is non-empty.\n                 if from_obj:\n                     final_field.remote_field.set_cached_value(from_obj, obj)\n \n+\n             def remote_setter(name, obj, from_obj):\n-                setattr(from_obj, name, obj)\n+                # For FilteredRelation aliases, ensure we set the correct target object\n+                if name in self.query._filtered_relations:\n+                    # Get the FilteredRelation configuration\n+                    filtered_relation = self.query._filtered_relations[name]\n+                    relation_path = filtered_relation.relation_name.split(LOOKUP_SEP)\n+                    \n+                    # Navigate to the target object following the FilteredRelation path\n+                    target_obj = from_obj\n+                    for field_name in relation_path:\n+                        if hasattr(target_obj, field_name):\n+                            target_obj = getattr(target_obj, field_name)\n+                        else:\n+                            # If we can't follow the path, fall back to original behavior\n+                            target_obj = obj\n+                            break\n+                    \n+                    setattr(from_obj, name, target_obj)\n+                else:\n+                    setattr(from_obj, name, obj)\n+\n+            for name in list(requested):\n+                # Filtered relations work only on the topmost level.\n+                if cur_depth > 1:\n+                    break\n+\n+            def remote_setter(name, obj, from_obj):\n+                # For FilteredRelation, obj should be the target object from the relation path\n+                # not the source object. We need to ensure proper object assignment.\n+                if name in self.query._filtered_relations:\n+                    # For filtered relations, we need to set the alias to point to the correct\n+                    # target object that was retrieved through the FilteredRelation path\n+                    setattr(from_obj, name, obj)\n+                else:\n+                    setattr(from_obj, name, obj)\n \n             for name in list(requested):\n                 # Filtered relations work only on the topmost level.\n@@ -1298,6 +1333,34 @@ class SQLCompiler:\n                         \"local_setter\": partial(local_setter, final_field),\n                         \"remote_setter\": partial(remote_setter, name),\n                         \"from_parent\": from_parent,\n+                        \"filtered_relation\": True,  # Mark as FilteredRelation for proper handling\n+                        \"filtered_relation_path\": self.query._filtered_relations[name].path,\n+                    }\n+                    related_klass_infos.append(klass_info)\n+                    from_parent = (\n+                        issubclass(model, opts.model) and model is not opts.model\n+                    )\n+                    klass_info = {\n+                        \"model\": model,\n+                        \"field\": final_field,\n+                        \"reverse\": True,\n+                        \"local_setter\": partial(local_setter, final_field),\n+                        \"remote_setter\": partial(remote_setter, name),\n+                        \"from_parent\": from_parent,\n+                        \"alias\": alias,  # Add alias information for proper object mapping\n+                        \"filtered_relation\": True,  # Mark as FilteredRelation for special handling\n+                    }\n+                    from_parent = (\n+                        issubclass(model, opts.model) and model is not opts.model\n+                    )\n+                    klass_info = {\n+                        \"model\": model,\n+                        \"field\": final_field,\n+                        \"reverse\": True,\n+                        \"local_setter\": partial(local_setter, final_field),\n+\n+                        \"remote_setter\": partial(remote_setter, name, final_field, model),\n+                        \"from_parent\": from_parent,\n                     }\n                     related_klass_infos.append(klass_info)\n                     select_fields = []\n",
    "variant_4": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7c433b3f06..61347df821 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1269,14 +1269,50 @@ class SQLCompiler:\n                 )\n                 get_related_klass_infos(klass_info, next_klass_infos)\n \n+\n             def local_setter(final_field, obj, from_obj):\n                 # Set a reverse fk object when relation is non-empty.\n                 if from_obj:\n                     final_field.remote_field.set_cached_value(from_obj, obj)\n \n+\n             def remote_setter(name, obj, from_obj):\n+                # For FilteredRelation, ensure we set the correct target object\n+                if hasattr(from_obj, '_state') and name in getattr(from_obj._state, 'fields_cache', {}):\n+                    # Use cached value if available (for FilteredRelation target objects)\n+                    cached_obj = from_obj._state.fields_cache[name]\n+                    if cached_obj is not None:\n+                        setattr(from_obj, name, cached_obj)\n+                        return\n                 setattr(from_obj, name, obj)\n \n+            for name in list(requested):\n+                # Filtered relations work only on the topmost level.\n+                if cur_depth > 1:\n+                    break\n+\n+            def remote_setter(name, obj, from_obj):\n+                # For FilteredRelation, obj should be the target object from the relation path\n+                # not the source object. We need to traverse the FilteredRelation path to get\n+                # the correct target object.\n+                if name in self.query._filtered_relations:\n+                    # Get the FilteredRelation definition\n+                    filtered_relation = self.query._filtered_relations[name]\n+                    relation_path = filtered_relation.relation_name.split(LOOKUP_SEP)\n+                    \n+                    # Traverse the relation path to get the target object\n+                    target_obj = from_obj\n+                    for relation_name in relation_path:\n+                        if hasattr(target_obj, relation_name):\n+                            target_obj = getattr(target_obj, relation_name)\n+                        else:\n+                            # If we can't traverse the path, fall back to original behavior\n+                            target_obj = obj\n+                            break\n+                    setattr(from_obj, name, target_obj)\n+                else:\n+                    setattr(from_obj, name, obj)\n+\n             for name in list(requested):\n                 # Filtered relations work only on the topmost level.\n                 if cur_depth > 1:\n@@ -1299,6 +1335,33 @@ class SQLCompiler:\n                         \"remote_setter\": partial(remote_setter, name),\n                         \"from_parent\": from_parent,\n                     }\n+                    related_klass_infos.append(klass_info)\n+                        [name], opts, root_alias\n+                    )\n+                    model = join_opts.model\n+                    alias = joins[-1]\n+                    from_parent = (\n+                        issubclass(model, opts.model) and model is not opts.model\n+                    )\n+                    klass_info = {\n+                        \"model\": model,\n+                        \"field\": final_field,\n+                        \"reverse\": True,\n+                        \"local_setter\": partial(local_setter, final_field),\n+                        \"remote_setter\": partial(remote_setter, name),\n+                        \"from_parent\": from_parent,\n+                    from_parent = (\n+                        issubclass(model, opts.model) and model is not opts.model\n+                    )\n+                    klass_info = {\n+                        \"model\": model,\n+                        \"field\": final_field,\n+                        \"reverse\": True,\n+                        \"local_setter\": partial(local_setter, final_field),\n+\n+                        \"remote_setter\": partial(remote_setter, name, final_field if name in filtered_relation_names else None),\n+                        \"from_parent\": from_parent,\n+                    }\n                     related_klass_infos.append(klass_info)\n                     select_fields = []\n                     field_select_mask = select_mask.get((name, final_field)) or {}\n",
    "variant_5": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7c433b3f06..6ad548972e 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1269,13 +1269,51 @@ class SQLCompiler:\n                 )\n                 get_related_klass_infos(klass_info, next_klass_infos)\n \n+\n             def local_setter(final_field, obj, from_obj):\n                 # Set a reverse fk object when relation is non-empty.\n                 if from_obj:\n                     final_field.remote_field.set_cached_value(from_obj, obj)\n \n+\n+def remote_setter(name, obj, from_obj):\n+    # For FilteredRelation aliases, ensure we're setting the correct target object\n+    # from the relation path, not the source object\n+    if hasattr(from_obj, '_state') and hasattr(obj, '_state'):\n+        # Check if this is a FilteredRelation case by examining the model types\n+        # If the name corresponds to a FilteredRelation alias, we need to ensure\n+        # we're setting the target object from the relation chain\n+        setattr(from_obj, name, obj)\n+    else:\n+        setattr(from_obj, name, obj)\n+\n+            for name in list(requested):\n+                # Filtered relations work only on the topmost level.\n+                if cur_depth > 1:\n+                    break\n+\n             def remote_setter(name, obj, from_obj):\n-                setattr(from_obj, name, obj)\n+                # For filtered relations, we need to ensure we're setting the correct\n+                # target object, not the source object\n+                if name in self.query._filtered_relations:\n+                    # Get the filtered relation definition\n+                    filtered_relation = self.query._filtered_relations[name]\n+                    relation_path = filtered_relation.relation_name.split(LOOKUP_SEP)\n+                    \n+                    # Navigate to the target object following the relation path\n+                    target_obj = from_obj\n+                    for field_name in relation_path:\n+                        if hasattr(target_obj, field_name):\n+                            target_obj = getattr(target_obj, field_name)\n+                        else:\n+                            # If we can't follow the path, fall back to the original object\n+                            target_obj = obj\n+                            break\n+                    \n+                    # Set the filtered relation alias to the target object\n+                    setattr(from_obj, name, target_obj)\n+                else:\n+                    setattr(from_obj, name, obj)\n \n             for name in list(requested):\n                 # Filtered relations work only on the topmost level.\n@@ -1299,6 +1337,33 @@ class SQLCompiler:\n                         \"remote_setter\": partial(remote_setter, name),\n                         \"from_parent\": from_parent,\n                     }\n+                    related_klass_infos.append(klass_info)\n+                        [name], opts, root_alias\n+                    )\n+                    model = join_opts.model\n+                    alias = joins[-1]\n+                    from_parent = (\n+                        issubclass(model, opts.model) and model is not opts.model\n+                    )\n+                    klass_info = {\n+                        \"model\": model,\n+                        \"field\": final_field,\n+                        \"reverse\": True,\n+                        \"local_setter\": partial(local_setter, final_field),\n+                        \"remote_setter\": partial(remote_setter, name),\n+                        \"from_parent\": from_parent,\n+                    from_parent = (\n+                        issubclass(model, opts.model) and model is not opts.model\n+                    )\n+                    klass_info = {\n+                        \"model\": model,\n+                        \"field\": final_field,\n+                        \"reverse\": True,\n+                        \"local_setter\": partial(local_setter, final_field),\n+\n+                        \"remote_setter\": partial(remote_setter, name, model),\n+                        \"from_parent\": from_parent,\n+                    }\n                     related_klass_infos.append(klass_info)\n                     select_fields = []\n                     field_select_mask = select_mask.get((name, final_field)) or {}\n",
    "variant_6": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7c433b3f06..c84b1782a2 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1269,12 +1269,61 @@ class SQLCompiler:\n                 )\n                 get_related_klass_infos(klass_info, next_klass_infos)\n \n+\n             def local_setter(final_field, obj, from_obj):\n                 # Set a reverse fk object when relation is non-empty.\n                 if from_obj:\n                     final_field.remote_field.set_cached_value(from_obj, obj)\n \n+\n             def remote_setter(name, obj, from_obj):\n+                # For FilteredRelation aliases, ensure we're setting the correct target object\n+                if hasattr(from_obj, '_state') and name in getattr(self.query, '_filtered_relations', {}):\n+                    # Get the FilteredRelation definition\n+                    filtered_relation = self.query._filtered_relations[name]\n+                    relation_path = filtered_relation.relation_name.split(LOOKUP_SEP)\n+                    \n+                    # Navigate to the target object following the relation path\n+                    target_obj = from_obj\n+                    for field_name in relation_path:\n+                        if hasattr(target_obj, field_name):\n+                            target_obj = getattr(target_obj, field_name)\n+                        else:\n+                            # If we can't follow the path, fall back to original behavior\n+                            target_obj = obj\n+                            break\n+                    \n+                    setattr(from_obj, name, target_obj)\n+                else:\n+                    setattr(from_obj, name, obj)\n+\n+            for name in list(requested):\n+                # Filtered relations work only on the topmost level.\n+                if cur_depth > 1:\n+                    break\n+\n+            def remote_setter(name, obj, from_obj):\n+                # For FilteredRelation, obj should be the target object from the relation path,\n+                # not the source object. Verify the object type matches the expected model.\n+                if name in self.query._filtered_relations:\n+                    # Get the FilteredRelation info to validate object type\n+                    filtered_relation = self.query._filtered_relations[name]\n+                    relation_path = filtered_relation.relation_name.split(LOOKUP_SEP)\n+                    \n+                    # Find the target model for this FilteredRelation\n+                    current_opts = from_obj._meta\n+                    for field_name in relation_path:\n+                        field = current_opts.get_field(field_name)\n+                        if hasattr(field, 'remote_field') and field.remote_field:\n+                            current_opts = field.remote_field.model._meta\n+                        else:\n+                            current_opts = field.related_model._meta\n+                    \n+                    # Ensure obj is an instance of the target model\n+                    if not isinstance(obj, current_opts.model):\n+                        # Skip setting if obj type doesn't match expected target model\n+                        return\n+                \n                 setattr(from_obj, name, obj)\n \n             for name in list(requested):\n@@ -1298,6 +1347,34 @@ class SQLCompiler:\n                         \"local_setter\": partial(local_setter, final_field),\n                         \"remote_setter\": partial(remote_setter, name),\n                         \"from_parent\": from_parent,\n+                        \"filtered_relation_alias\": alias,  # Store alias for proper object mapping\n+                    }\n+                    related_klass_infos.append(klass_info)\n+                        [name], opts, root_alias\n+                    )\n+                    model = join_opts.model\n+                    alias = joins[-1]\n+                    from_parent = (\n+                        issubclass(model, opts.model) and model is not opts.model\n+                    )\n+                    klass_info = {\n+                        \"model\": model,\n+                        \"field\": final_field,\n+                        \"reverse\": True,\n+                        \"local_setter\": partial(local_setter, final_field),\n+                        \"remote_setter\": partial(remote_setter, name),\n+                        \"from_parent\": from_parent,\n+                    from_parent = (\n+                        issubclass(model, opts.model) and model is not opts.model\n+                    )\n+                    klass_info = {\n+                        \"model\": model,\n+                        \"field\": final_field,\n+                        \"reverse\": True,\n+                        \"local_setter\": partial(local_setter, final_field),\n+\n+                        \"remote_setter\": partial(remote_setter, name, final_field, model),\n+                        \"from_parent\": from_parent,\n                     }\n                     related_klass_infos.append(klass_info)\n                     select_fields = []\n",
    "variant_7": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7c433b3f06..1ca8354a2b 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1269,12 +1269,46 @@ class SQLCompiler:\n                 )\n                 get_related_klass_infos(klass_info, next_klass_infos)\n \n+\n             def local_setter(final_field, obj, from_obj):\n                 # Set a reverse fk object when relation is non-empty.\n                 if from_obj:\n                     final_field.remote_field.set_cached_value(from_obj, obj)\n \n+\n+            def remote_setter(name, obj, from_obj):\n+                # For FilteredRelation, ensure we set the correct target object\n+                # instead of the source object from the relation chain\n+                if hasattr(from_obj, '_state') and name in getattr(self.query, '_filtered_relations', {}):\n+                    # Get the FilteredRelation definition\n+                    filtered_relation = self.query._filtered_relations[name]\n+                    # For FilteredRelation paths like 'pool__tournament__pool',\n+                    # we need to traverse to get the actual target object\n+                    target_obj = obj\n+                    relation_parts = filtered_relation.relation_name.split(LOOKUP_SEP)\n+                    \n+                    # Navigate through the relation chain to find the target object\n+                    current_obj = from_obj\n+                    for part in relation_parts:\n+                        if hasattr(current_obj, part):\n+                            current_obj = getattr(current_obj, part)\n+                        else:\n+                            # Fallback to original behavior if traversal fails\n+                            current_obj = obj\n+                            break\n+                    \n+                    # Set the FilteredRelation alias to point to the target object\n+                    setattr(from_obj, name, current_obj)\n+                else:\n+                    setattr(from_obj, name, obj)\n+\n+            for name in list(requested):\n+                # Filtered relations work only on the topmost level.\n+                if cur_depth > 1:\n+                    break\n+\n             def remote_setter(name, obj, from_obj):\n+                # For FilteredRelation, obj should be the target object from the relation path\n                 setattr(from_obj, name, obj)\n \n             for name in list(requested):\n@@ -1298,6 +1332,20 @@ class SQLCompiler:\n                         \"local_setter\": partial(local_setter, final_field),\n                         \"remote_setter\": partial(remote_setter, name),\n                         \"from_parent\": from_parent,\n+                        \"filtered_relation\": True,  # Mark as FilteredRelation for proper object handling\n+                    }\n+                    related_klass_infos.append(klass_info)\n+                    from_parent = (\n+                        issubclass(model, opts.model) and model is not opts.model\n+                    )\n+                    klass_info = {\n+                        \"model\": model,\n+                        \"field\": final_field,\n+                        \"reverse\": True,\n+                        \"local_setter\": partial(local_setter, final_field),\n+\n+                        \"remote_setter\": partial(remote_setter, name, final_field if self.is_filtered_relation(name) else None),\n+                        \"from_parent\": from_parent,\n                     }\n                     related_klass_infos.append(klass_info)\n                     select_fields = []\n",
    "variant_8": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7c433b3f06..fc171c50c6 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1269,12 +1269,31 @@ class SQLCompiler:\n                 )\n                 get_related_klass_infos(klass_info, next_klass_infos)\n \n+\n             def local_setter(final_field, obj, from_obj):\n                 # Set a reverse fk object when relation is non-empty.\n                 if from_obj:\n                     final_field.remote_field.set_cached_value(from_obj, obj)\n \n+\n             def remote_setter(name, obj, from_obj):\n+                # For filtered relations, ensure we set the correct target object\n+                if name in self.query._filtered_relations:\n+                    # Get the filtered relation info to determine the target object\n+                    filtered_relation = self.query._filtered_relations[name]\n+                    # The obj should be the target object from the relation path, not the source\n+                    setattr(from_obj, name, obj)\n+                else:\n+                    setattr(from_obj, name, obj)\n+\n+            for name in list(requested):\n+                # Filtered relations work only on the topmost level.\n+                if cur_depth > 1:\n+                    break\n+\n+            def remote_setter(name, obj, from_obj):\n+                # For filtered relations, obj should be the target object from the relation path\n+                # not the source object, so we can directly set it\n                 setattr(from_obj, name, obj)\n \n             for name in list(requested):\n@@ -1298,6 +1317,34 @@ class SQLCompiler:\n                         \"local_setter\": partial(local_setter, final_field),\n                         \"remote_setter\": partial(remote_setter, name),\n                         \"from_parent\": from_parent,\n+                        \"filtered_relation\": True,\n+                    }\n+                    related_klass_infos.append(klass_info)\n+                        [name], opts, root_alias\n+                    )\n+                    model = join_opts.model\n+                    alias = joins[-1]\n+                    from_parent = (\n+                        issubclass(model, opts.model) and model is not opts.model\n+                    )\n+                    klass_info = {\n+                        \"model\": model,\n+                        \"field\": final_field,\n+                        \"reverse\": True,\n+                        \"local_setter\": partial(local_setter, final_field),\n+                        \"remote_setter\": partial(remote_setter, name),\n+                        \"from_parent\": from_parent,\n+                    from_parent = (\n+                        issubclass(model, opts.model) and model is not opts.model\n+                    )\n+                    klass_info = {\n+                        \"model\": model,\n+                        \"field\": final_field,\n+                        \"reverse\": True,\n+                        \"local_setter\": partial(local_setter, final_field),\n+\n+                        \"remote_setter\": partial(remote_setter, name, model),\n+                        \"from_parent\": from_parent,\n                     }\n                     related_klass_infos.append(klass_info)\n                     select_fields = []\n"
  }
}