{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/scikit-learn/sklearn/svm/base.py lines 289-294)": "\n        if hasattr(self, \"classes_\"):\n            n_class = len(self.classes_) - 1\n        else:  # regression\n            n_class = 1\n        n_SV = self.support_vectors_.shape[0]\n\n        # Check if we have any support vectors\n        if n_SV == 0:\n            # Handle empty support vectors case - create empty CSR matrix\n            self.dual_coef_ = sp.csr_matrix((n_class, 0))\n        else:\n            # Original logic for non-empty case\n            dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n            if n_class > 0:\n                dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n                                             dual_coef_indices.size / n_class)\n            else:\n                # Fallback for edge case where n_class is 0\n                dual_coef_indptr = np.array([0, dual_coef_indices.size])\n            \n            self.dual_coef_ = sp.csr_matrix(\n                (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n                (n_class, n_SV))\n",
    "Location 2 (/root/hy/projects_2/scikit-learn/sklearn/svm/base.py lines 283-287)": "\n        if hasattr(self, \"classes_\"):\n            n_class = len(self.classes_) - 1\n        else:  # regression\n            n_class = 1\n        n_SV = self.support_vectors_.shape[0]\n\n        # Check if we have any support vectors\n        if n_SV == 0:\n            # Handle empty support vectors case - create empty CSR matrix\n            self.dual_coef_ = sp.csr_matrix((n_class, 0))\n        else:\n            # Original logic for non-empty case\n            dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n            if n_class > 0:\n                dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n                                             dual_coef_indices.size / n_class)\n            else:\n                # Fallback for edge case where n_class is 0\n                dual_coef_indptr = np.array([0, dual_coef_indices.size])\n            \n            self.dual_coef_ = sp.csr_matrix(\n                (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n                (n_class, n_SV))\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/scikit-learn/sklearn/svm/base.py lines 289-294)": [
      "\n        if hasattr(self, \"classes_\"):\n            n_class = len(self.classes_) - 1\n        else:  # regression\n            n_class = 1\n        n_SV = self.support_vectors_.shape[0]\n\n        # Check if we have any support vectors\n        if n_SV == 0:\n            # Handle empty support vectors case - create empty CSR matrix\n            self.dual_coef_ = sp.csr_matrix((n_class, 0))\n        else:\n            # Original logic for non-empty case\n            dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n            if n_class > 0:\n                dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n                                             dual_coef_indices.size / n_class)\n            else:\n                # Fallback for edge case where n_class is 0\n                dual_coef_indptr = np.array([0, dual_coef_indices.size])\n            \n            self.dual_coef_ = sp.csr_matrix(\n                (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n                (n_class, n_SV))\n",
      "\n        if hasattr(self, \"classes_\"):\n            n_class = len(self.classes_) - 1\n        else:  # regression\n            n_class = 1\n        n_SV = self.support_vectors_.shape[0]\n\n        # Check if we have any support vectors\n        if n_SV == 0:\n            # Handle empty support vectors case - create empty CSR matrix\n            self.dual_coef_ = sp.csr_matrix((n_class, 0))\n        else:\n            # Original logic for non-empty case\n            dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n            if n_class > 0:\n                dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n                                             dual_coef_indices.size / n_class)\n            else:\n                # Fallback for edge case where n_class is 0\n                dual_coef_indptr = np.array([0, dual_coef_indices.size])\n            \n            self.dual_coef_ = sp.csr_matrix(\n                (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n                (n_class, n_SV))\n",
      "\n        # Check if we have any support vectors\n        if n_SV == 0:\n            # Handle empty support vectors case - create empty CSR matrix\n            self.dual_coef_ = sp.csr_matrix((n_class, 0))\n        else:\n            # Original logic for non-empty case\n            dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n            if n_class > 0:\n                dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n                                             dual_coef_indices.size / n_class)\n            else:\n                # Fallback for edge case where n_class is 0\n                dual_coef_indptr = np.array([0, dual_coef_indices.size])\n            \n            self.dual_coef_ = sp.csr_matrix(\n                (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n                (n_class, n_SV))\n",
      "\n        if hasattr(self, \"classes_\"):\n            n_class = len(self.classes_) - 1\n        else:  # regression\n            n_class = 1\n        n_SV = self.support_vectors_.shape[0]\n\n        # Check if we have any support vectors\n        if n_SV == 0:\n            # Handle empty support vectors case - create empty CSR matrix\n            self.dual_coef_ = sp.csr_matrix((n_class, 0))\n        else:\n            # Original logic for non-empty case\n            dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n            if n_class > 0:\n                dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n                                             dual_coef_indices.size / n_class)\n            else:\n                # Fallback for edge case where n_class is 0\n                dual_coef_indptr = np.array([0, dual_coef_indices.size])\n            \n            self.dual_coef_ = sp.csr_matrix(\n                (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n                (n_class, n_SV))\n",
      "\n        if hasattr(self, \"classes_\"):\n            n_class = len(self.classes_) - 1\n        else:  # regression\n            n_class = 1\n        n_SV = self.support_vectors_.shape[0]\n\n        # Check if we have any support vectors\n        if n_SV == 0:\n            # Handle empty support vectors case - create empty CSR matrix\n            self.dual_coef_ = sp.csr_matrix((n_class, 0))\n        else:\n            # Original logic for non-empty case\n            dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n            if n_class > 0:\n                dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n                                             dual_coef_indices.size / n_class)\n            else:\n                # Fallback for edge case where n_class is 0\n                dual_coef_indptr = np.array([0, dual_coef_indices.size])\n            \n            self.dual_coef_ = sp.csr_matrix(\n                (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n                (n_class, n_SV))\n",
      "\n        if hasattr(self, \"classes_\"):\n            n_class = len(self.classes_) - 1\n        else:  # regression\n            n_class = 1\n        n_SV = self.support_vectors_.shape[0]\n\n        # Check if we have any support vectors\n        if n_SV == 0:\n            # Handle empty support vectors case - create empty CSR matrix\n            self.dual_coef_ = sp.csr_matrix((n_class, 0))\n        else:\n            # Original logic for non-empty case\n            dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n            if n_class > 0:\n                dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n                                             dual_coef_indices.size / n_class)\n            else:\n                # Fallback for edge case where n_class is 0\n                dual_coef_indptr = np.array([0, dual_coef_indices.size])\n            \n            self.dual_coef_ = sp.csr_matrix(\n                (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n                (n_class, n_SV))\n",
      "\n        # Check if we have any support vectors\n        if n_SV == 0:\n            # Handle empty support vectors case - create empty CSR matrix\n            self.dual_coef_ = sp.csr_matrix((n_class, 0))\n        else:\n            # Original logic for non-empty case\n            dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n            if n_class > 0:\n                dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n                                             dual_coef_indices.size / n_class)\n            else:\n                # Fallback for edge case where n_class is 0\n                dual_coef_indptr = np.array([0, dual_coef_indices.size])\n            \n            self.dual_coef_ = sp.csr_matrix(\n                (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n                (n_class, n_SV))\n",
      "\n        if hasattr(self, \"classes_\"):\n            n_class = len(self.classes_) - 1\n        else:  # regression\n            n_class = 1\n        n_SV = self.support_vectors_.shape[0]\n\n        # Check if we have any support vectors\n        if n_SV == 0:\n            # Handle empty support vectors case - create empty CSR matrix\n            self.dual_coef_ = sp.csr_matrix((n_class, 0))\n        else:\n            # Original logic for non-empty case\n            dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n            if n_class > 0:\n                dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n                                             dual_coef_indices.size / n_class)\n            else:\n                # Fallback for edge case where n_class is 0\n                dual_coef_indptr = np.array([0, dual_coef_indices.size])\n            \n            self.dual_coef_ = sp.csr_matrix(\n                (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n                (n_class, n_SV))\n"
    ],
    "Location 2 (/root/hy/projects_2/scikit-learn/sklearn/svm/base.py lines 283-287)": [
      "\n        if hasattr(self, \"classes_\"):\n            n_class = len(self.classes_) - 1\n        else:  # regression\n            n_class = 1\n        n_SV = self.support_vectors_.shape[0]\n\n        # Check if we have any support vectors\n        if n_SV == 0:\n            # Handle empty support vectors case - create empty CSR matrix\n            self.dual_coef_ = sp.csr_matrix((n_class, 0))\n        else:\n            # Original logic for non-empty case\n            dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n            if n_class > 0:\n                dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n                                             dual_coef_indices.size / n_class)\n            else:\n                # Fallback for edge case where n_class is 0\n                dual_coef_indptr = np.array([0, dual_coef_indices.size])\n            \n            self.dual_coef_ = sp.csr_matrix(\n                (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n                (n_class, n_SV))\n",
      "\n        if hasattr(self, \"classes_\"):\n            n_class = len(self.classes_) - 1\n        else:  # regression\n            n_class = 1\n        n_SV = self.support_vectors_.shape[0]\n\n        # Check if we have any support vectors\n        if n_SV == 0:\n            # Handle empty support vectors case - create empty CSR matrix\n            self.dual_coef_ = sp.csr_matrix((n_class, 0))\n        else:\n            # Original logic for non-empty case\n            dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n            if n_class > 0:\n                dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n                                             dual_coef_indices.size / n_class)\n            else:\n                # Fallback for edge case where n_class is 0\n                dual_coef_indptr = np.array([0, dual_coef_indices.size])\n            \n            self.dual_coef_ = sp.csr_matrix(\n                (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n                (n_class, n_SV))\n",
      "\n        if hasattr(self, \"classes_\"):\n            n_class = len(self.classes_) - 1\n        else:  # regression\n            n_class = 1\n        n_SV = self.support_vectors_.shape[0]\n\n        # Check if we have any support vectors\n        if n_SV == 0:\n            # Handle empty support vectors case - create empty CSR matrix\n            self.dual_coef_ = sp.csr_matrix((n_class, 0))\n        else:\n            # Original logic for non-empty case\n            dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n            if n_class > 0:\n                dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n                                             dual_coef_indices.size / n_class)\n            else:\n                # Fallback for edge case where n_class is 0\n                dual_coef_indptr = np.array([0, dual_coef_indices.size])\n            \n            self.dual_coef_ = sp.csr_matrix(\n                (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n                (n_class, n_SV))\n",
      "\n        if hasattr(self, \"classes_\"):\n            n_class = len(self.classes_) - 1\n        else:  # regression\n            n_class = 1\n        n_SV = self.support_vectors_.shape[0]\n\n        # Check if we have any support vectors\n        if n_SV == 0:\n            # Handle empty support vectors case - create empty CSR matrix\n            self.dual_coef_ = sp.csr_matrix((n_class, 0))\n        else:\n            # Original logic for non-empty case\n            dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n            if n_class > 0:\n                dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n                                             dual_coef_indices.size / n_class)\n            else:\n                # Fallback for edge case where n_class is 0\n                dual_coef_indptr = np.array([0, dual_coef_indices.size])\n            \n            self.dual_coef_ = sp.csr_matrix(\n                (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n                (n_class, n_SV))\n",
      "\n        if hasattr(self, \"classes_\"):\n            n_class = len(self.classes_) - 1\n        else:  # regression\n            n_class = 1\n        n_SV = self.support_vectors_.shape[0]\n\n        # Check if we have any support vectors\n        if n_SV == 0:\n            # Handle empty support vectors case - create empty CSR matrix\n            self.dual_coef_ = sp.csr_matrix((n_class, 0))\n        else:\n            # Original logic for non-empty case\n            dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n            if n_class > 0:\n                dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n                                             dual_coef_indices.size / n_class)\n            else:\n                # Fallback for edge case where n_class is 0\n                dual_coef_indptr = np.array([0, dual_coef_indices.size])\n            \n            self.dual_coef_ = sp.csr_matrix(\n                (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n                (n_class, n_SV))\n",
      "\n        if hasattr(self, \"classes_\"):\n            n_class = len(self.classes_) - 1\n        else:  # regression\n            n_class = 1\n        n_SV = self.support_vectors_.shape[0]\n\n        # Check if we have any support vectors\n        if n_SV == 0:\n            # Handle empty support vectors case - create empty CSR matrix\n            self.dual_coef_ = sp.csr_matrix((n_class, 0))\n        else:\n            # Original logic for non-empty case\n            dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n            if n_class > 0:\n                dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n                                             dual_coef_indices.size / n_class)\n            else:\n                # Fallback for edge case where n_class is 0\n                dual_coef_indptr = np.array([0, dual_coef_indices.size])\n            \n            self.dual_coef_ = sp.csr_matrix(\n                (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n                (n_class, n_SV))\n",
      "\n        if hasattr(self, \"classes_\"):\n            n_class = len(self.classes_) - 1\n        else:  # regression\n            n_class = 1\n        n_SV = self.support_vectors_.shape[0]\n\n        # Check if we have any support vectors\n        if n_SV == 0:\n            # Handle empty support vectors case - create empty CSR matrix\n            self.dual_coef_ = sp.csr_matrix((n_class, 0))\n        else:\n            # Original logic for non-empty case\n            dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n            if n_class > 0:\n                dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n                                             dual_coef_indices.size / n_class)\n            else:\n                # Fallback for edge case where n_class is 0\n                dual_coef_indptr = np.array([0, dual_coef_indices.size])\n            \n            self.dual_coef_ = sp.csr_matrix(\n                (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n                (n_class, n_SV))\n",
      "\n        if hasattr(self, \"classes_\"):\n            n_class = len(self.classes_) - 1\n        else:  # regression\n            n_class = 1\n        n_SV = self.support_vectors_.shape[0]\n\n        # Check if we have any support vectors\n        if n_SV == 0:\n            # Handle empty support vectors case - create empty CSR matrix\n            self.dual_coef_ = sp.csr_matrix((n_class, 0))\n        else:\n            # Original logic for non-empty case\n            dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n            if n_class > 0:\n                dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n                                             dual_coef_indices.size / n_class)\n            else:\n                # Fallback for edge case where n_class is 0\n                dual_coef_indptr = np.array([0, dual_coef_indices.size])\n            \n            self.dual_coef_ = sp.csr_matrix(\n                (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n                (n_class, n_SV))\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sklearn/svm/base.py b/sklearn/svm/base.py\nindex 64cebe837..937377412 100644\n--- a/sklearn/svm/base.py\n+++ b/sklearn/svm/base.py\n@@ -280,19 +280,26 @@ class BaseLibSVM(BaseEstimator, metaclass=ABCMeta):\n \n         self._warn_from_fit_status()\n \n+\n+        # Handle edge cases to prevent ZeroDivisionError\n+        if n_SV == 0 or n_class == 0:\n+            # Create empty CSR matrix when no support vectors or single class\n+            self.dual_coef_ = sp.csr_matrix((max(n_class, 1), 0))\n+        else:\n+            dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n+            dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n+                                         dual_coef_indices.size / n_class)\n+            self.dual_coef_ = sp.csr_matrix(\n+                (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n+                (n_class, n_SV))\n+\n+\n         if hasattr(self, \"classes_\"):\n             n_class = len(self.classes_) - 1\n         else:  # regression\n             n_class = 1\n         n_SV = self.support_vectors_.shape[0]\n \n-        dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n-        dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n-                                     dual_coef_indices.size / n_class)\n-        self.dual_coef_ = sp.csr_matrix(\n-            (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n-            (n_class, n_SV))\n-\n     def predict(self, X):\n         \"\"\"Perform regression on samples in X.\n \n",
    "variant_0": "diff --git a/sklearn/svm/base.py b/sklearn/svm/base.py\nindex 64cebe837..edc904c39 100644\n--- a/sklearn/svm/base.py\n+++ b/sklearn/svm/base.py\n@@ -280,18 +280,55 @@ class BaseLibSVM(BaseEstimator, metaclass=ABCMeta):\n \n         self._warn_from_fit_status()\n \n+\n         if hasattr(self, \"classes_\"):\n             n_class = len(self.classes_) - 1\n         else:  # regression\n             n_class = 1\n         n_SV = self.support_vectors_.shape[0]\n \n-        dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n-        dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n-                                     dual_coef_indices.size / n_class)\n-        self.dual_coef_ = sp.csr_matrix(\n-            (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n-            (n_class, n_SV))\n+        # Check if we have any support vectors\n+        if n_SV == 0:\n+            # Handle empty support vectors case - create empty CSR matrix\n+            self.dual_coef_ = sp.csr_matrix((n_class, 0))\n+        else:\n+            # Original logic for non-empty case\n+            dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n+            if n_class > 0:\n+                dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n+                                             dual_coef_indices.size / n_class)\n+            else:\n+                # Fallback for edge case where n_class is 0\n+                dual_coef_indptr = np.array([0, dual_coef_indices.size])\n+            \n+            self.dual_coef_ = sp.csr_matrix(\n+                (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n+                (n_class, n_SV))\n+\n+\n+        if hasattr(self, \"classes_\"):\n+            n_class = len(self.classes_) - 1\n+        else:  # regression\n+            n_class = 1\n+        n_SV = self.support_vectors_.shape[0]\n+\n+        # Check if we have any support vectors\n+        if n_SV == 0:\n+            # Handle empty support vectors case - create empty CSR matrix\n+            self.dual_coef_ = sp.csr_matrix((n_class, 0))\n+        else:\n+            # Original logic for non-empty case\n+            dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n+            if n_class > 0:\n+                dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n+                                             dual_coef_indices.size / n_class)\n+            else:\n+                # Fallback for edge case where n_class is 0\n+                dual_coef_indptr = np.array([0, dual_coef_indices.size])\n+            \n+            self.dual_coef_ = sp.csr_matrix(\n+                (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n+                (n_class, n_SV))\n \n     def predict(self, X):\n         \"\"\"Perform regression on samples in X.\n",
    "variant_1": "diff --git a/sklearn/svm/base.py b/sklearn/svm/base.py\nindex 64cebe837..edc904c39 100644\n--- a/sklearn/svm/base.py\n+++ b/sklearn/svm/base.py\n@@ -280,18 +280,55 @@ class BaseLibSVM(BaseEstimator, metaclass=ABCMeta):\n \n         self._warn_from_fit_status()\n \n+\n         if hasattr(self, \"classes_\"):\n             n_class = len(self.classes_) - 1\n         else:  # regression\n             n_class = 1\n         n_SV = self.support_vectors_.shape[0]\n \n-        dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n-        dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n-                                     dual_coef_indices.size / n_class)\n-        self.dual_coef_ = sp.csr_matrix(\n-            (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n-            (n_class, n_SV))\n+        # Check if we have any support vectors\n+        if n_SV == 0:\n+            # Handle empty support vectors case - create empty CSR matrix\n+            self.dual_coef_ = sp.csr_matrix((n_class, 0))\n+        else:\n+            # Original logic for non-empty case\n+            dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n+            if n_class > 0:\n+                dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n+                                             dual_coef_indices.size / n_class)\n+            else:\n+                # Fallback for edge case where n_class is 0\n+                dual_coef_indptr = np.array([0, dual_coef_indices.size])\n+            \n+            self.dual_coef_ = sp.csr_matrix(\n+                (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n+                (n_class, n_SV))\n+\n+\n+        if hasattr(self, \"classes_\"):\n+            n_class = len(self.classes_) - 1\n+        else:  # regression\n+            n_class = 1\n+        n_SV = self.support_vectors_.shape[0]\n+\n+        # Check if we have any support vectors\n+        if n_SV == 0:\n+            # Handle empty support vectors case - create empty CSR matrix\n+            self.dual_coef_ = sp.csr_matrix((n_class, 0))\n+        else:\n+            # Original logic for non-empty case\n+            dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n+            if n_class > 0:\n+                dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n+                                             dual_coef_indices.size / n_class)\n+            else:\n+                # Fallback for edge case where n_class is 0\n+                dual_coef_indptr = np.array([0, dual_coef_indices.size])\n+            \n+            self.dual_coef_ = sp.csr_matrix(\n+                (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n+                (n_class, n_SV))\n \n     def predict(self, X):\n         \"\"\"Perform regression on samples in X.\n",
    "variant_2": "diff --git a/sklearn/svm/base.py b/sklearn/svm/base.py\nindex 64cebe837..edc904c39 100644\n--- a/sklearn/svm/base.py\n+++ b/sklearn/svm/base.py\n@@ -280,18 +280,55 @@ class BaseLibSVM(BaseEstimator, metaclass=ABCMeta):\n \n         self._warn_from_fit_status()\n \n+\n         if hasattr(self, \"classes_\"):\n             n_class = len(self.classes_) - 1\n         else:  # regression\n             n_class = 1\n         n_SV = self.support_vectors_.shape[0]\n \n-        dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n-        dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n-                                     dual_coef_indices.size / n_class)\n-        self.dual_coef_ = sp.csr_matrix(\n-            (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n-            (n_class, n_SV))\n+        # Check if we have any support vectors\n+        if n_SV == 0:\n+            # Handle empty support vectors case - create empty CSR matrix\n+            self.dual_coef_ = sp.csr_matrix((n_class, 0))\n+        else:\n+            # Original logic for non-empty case\n+            dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n+            if n_class > 0:\n+                dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n+                                             dual_coef_indices.size / n_class)\n+            else:\n+                # Fallback for edge case where n_class is 0\n+                dual_coef_indptr = np.array([0, dual_coef_indices.size])\n+            \n+            self.dual_coef_ = sp.csr_matrix(\n+                (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n+                (n_class, n_SV))\n+\n+\n+        if hasattr(self, \"classes_\"):\n+            n_class = len(self.classes_) - 1\n+        else:  # regression\n+            n_class = 1\n+        n_SV = self.support_vectors_.shape[0]\n+\n+        # Check if we have any support vectors\n+        if n_SV == 0:\n+            # Handle empty support vectors case - create empty CSR matrix\n+            self.dual_coef_ = sp.csr_matrix((n_class, 0))\n+        else:\n+            # Original logic for non-empty case\n+            dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n+            if n_class > 0:\n+                dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n+                                             dual_coef_indices.size / n_class)\n+            else:\n+                # Fallback for edge case where n_class is 0\n+                dual_coef_indptr = np.array([0, dual_coef_indices.size])\n+            \n+            self.dual_coef_ = sp.csr_matrix(\n+                (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n+                (n_class, n_SV))\n \n     def predict(self, X):\n         \"\"\"Perform regression on samples in X.\n",
    "variant_3": "diff --git a/sklearn/svm/base.py b/sklearn/svm/base.py\nindex 64cebe837..95df9d258 100644\n--- a/sklearn/svm/base.py\n+++ b/sklearn/svm/base.py\n@@ -280,18 +280,49 @@ class BaseLibSVM(BaseEstimator, metaclass=ABCMeta):\n \n         self._warn_from_fit_status()\n \n+\n         if hasattr(self, \"classes_\"):\n             n_class = len(self.classes_) - 1\n         else:  # regression\n             n_class = 1\n         n_SV = self.support_vectors_.shape[0]\n \n-        dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n-        dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n-                                     dual_coef_indices.size / n_class)\n-        self.dual_coef_ = sp.csr_matrix(\n-            (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n-            (n_class, n_SV))\n+        # Check if we have any support vectors\n+        if n_SV == 0:\n+            # Handle empty support vectors case - create empty CSR matrix\n+            self.dual_coef_ = sp.csr_matrix((n_class, 0))\n+        else:\n+            # Original logic for non-empty case\n+            dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n+            if n_class > 0:\n+                dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n+                                             dual_coef_indices.size / n_class)\n+            else:\n+                # Fallback for edge case where n_class is 0\n+                dual_coef_indptr = np.array([0, dual_coef_indices.size])\n+            \n+            self.dual_coef_ = sp.csr_matrix(\n+                (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n+                (n_class, n_SV))\n+\n+\n+        # Check if we have any support vectors\n+        if n_SV == 0:\n+            # Handle empty support vectors case - create empty CSR matrix\n+            self.dual_coef_ = sp.csr_matrix((n_class, 0))\n+        else:\n+            # Original logic for non-empty case\n+            dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n+            if n_class > 0:\n+                dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n+                                             dual_coef_indices.size / n_class)\n+            else:\n+                # Fallback for edge case where n_class is 0\n+                dual_coef_indptr = np.array([0, dual_coef_indices.size])\n+            \n+            self.dual_coef_ = sp.csr_matrix(\n+                (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n+                (n_class, n_SV))\n \n     def predict(self, X):\n         \"\"\"Perform regression on samples in X.\n",
    "variant_4": "diff --git a/sklearn/svm/base.py b/sklearn/svm/base.py\nindex 64cebe837..edc904c39 100644\n--- a/sklearn/svm/base.py\n+++ b/sklearn/svm/base.py\n@@ -280,18 +280,55 @@ class BaseLibSVM(BaseEstimator, metaclass=ABCMeta):\n \n         self._warn_from_fit_status()\n \n+\n         if hasattr(self, \"classes_\"):\n             n_class = len(self.classes_) - 1\n         else:  # regression\n             n_class = 1\n         n_SV = self.support_vectors_.shape[0]\n \n-        dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n-        dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n-                                     dual_coef_indices.size / n_class)\n-        self.dual_coef_ = sp.csr_matrix(\n-            (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n-            (n_class, n_SV))\n+        # Check if we have any support vectors\n+        if n_SV == 0:\n+            # Handle empty support vectors case - create empty CSR matrix\n+            self.dual_coef_ = sp.csr_matrix((n_class, 0))\n+        else:\n+            # Original logic for non-empty case\n+            dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n+            if n_class > 0:\n+                dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n+                                             dual_coef_indices.size / n_class)\n+            else:\n+                # Fallback for edge case where n_class is 0\n+                dual_coef_indptr = np.array([0, dual_coef_indices.size])\n+            \n+            self.dual_coef_ = sp.csr_matrix(\n+                (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n+                (n_class, n_SV))\n+\n+\n+        if hasattr(self, \"classes_\"):\n+            n_class = len(self.classes_) - 1\n+        else:  # regression\n+            n_class = 1\n+        n_SV = self.support_vectors_.shape[0]\n+\n+        # Check if we have any support vectors\n+        if n_SV == 0:\n+            # Handle empty support vectors case - create empty CSR matrix\n+            self.dual_coef_ = sp.csr_matrix((n_class, 0))\n+        else:\n+            # Original logic for non-empty case\n+            dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n+            if n_class > 0:\n+                dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n+                                             dual_coef_indices.size / n_class)\n+            else:\n+                # Fallback for edge case where n_class is 0\n+                dual_coef_indptr = np.array([0, dual_coef_indices.size])\n+            \n+            self.dual_coef_ = sp.csr_matrix(\n+                (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n+                (n_class, n_SV))\n \n     def predict(self, X):\n         \"\"\"Perform regression on samples in X.\n",
    "variant_5": "diff --git a/sklearn/svm/base.py b/sklearn/svm/base.py\nindex 64cebe837..edc904c39 100644\n--- a/sklearn/svm/base.py\n+++ b/sklearn/svm/base.py\n@@ -280,18 +280,55 @@ class BaseLibSVM(BaseEstimator, metaclass=ABCMeta):\n \n         self._warn_from_fit_status()\n \n+\n         if hasattr(self, \"classes_\"):\n             n_class = len(self.classes_) - 1\n         else:  # regression\n             n_class = 1\n         n_SV = self.support_vectors_.shape[0]\n \n-        dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n-        dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n-                                     dual_coef_indices.size / n_class)\n-        self.dual_coef_ = sp.csr_matrix(\n-            (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n-            (n_class, n_SV))\n+        # Check if we have any support vectors\n+        if n_SV == 0:\n+            # Handle empty support vectors case - create empty CSR matrix\n+            self.dual_coef_ = sp.csr_matrix((n_class, 0))\n+        else:\n+            # Original logic for non-empty case\n+            dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n+            if n_class > 0:\n+                dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n+                                             dual_coef_indices.size / n_class)\n+            else:\n+                # Fallback for edge case where n_class is 0\n+                dual_coef_indptr = np.array([0, dual_coef_indices.size])\n+            \n+            self.dual_coef_ = sp.csr_matrix(\n+                (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n+                (n_class, n_SV))\n+\n+\n+        if hasattr(self, \"classes_\"):\n+            n_class = len(self.classes_) - 1\n+        else:  # regression\n+            n_class = 1\n+        n_SV = self.support_vectors_.shape[0]\n+\n+        # Check if we have any support vectors\n+        if n_SV == 0:\n+            # Handle empty support vectors case - create empty CSR matrix\n+            self.dual_coef_ = sp.csr_matrix((n_class, 0))\n+        else:\n+            # Original logic for non-empty case\n+            dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n+            if n_class > 0:\n+                dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n+                                             dual_coef_indices.size / n_class)\n+            else:\n+                # Fallback for edge case where n_class is 0\n+                dual_coef_indptr = np.array([0, dual_coef_indices.size])\n+            \n+            self.dual_coef_ = sp.csr_matrix(\n+                (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n+                (n_class, n_SV))\n \n     def predict(self, X):\n         \"\"\"Perform regression on samples in X.\n",
    "variant_6": "diff --git a/sklearn/svm/base.py b/sklearn/svm/base.py\nindex 64cebe837..edc904c39 100644\n--- a/sklearn/svm/base.py\n+++ b/sklearn/svm/base.py\n@@ -280,18 +280,55 @@ class BaseLibSVM(BaseEstimator, metaclass=ABCMeta):\n \n         self._warn_from_fit_status()\n \n+\n         if hasattr(self, \"classes_\"):\n             n_class = len(self.classes_) - 1\n         else:  # regression\n             n_class = 1\n         n_SV = self.support_vectors_.shape[0]\n \n-        dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n-        dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n-                                     dual_coef_indices.size / n_class)\n-        self.dual_coef_ = sp.csr_matrix(\n-            (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n-            (n_class, n_SV))\n+        # Check if we have any support vectors\n+        if n_SV == 0:\n+            # Handle empty support vectors case - create empty CSR matrix\n+            self.dual_coef_ = sp.csr_matrix((n_class, 0))\n+        else:\n+            # Original logic for non-empty case\n+            dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n+            if n_class > 0:\n+                dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n+                                             dual_coef_indices.size / n_class)\n+            else:\n+                # Fallback for edge case where n_class is 0\n+                dual_coef_indptr = np.array([0, dual_coef_indices.size])\n+            \n+            self.dual_coef_ = sp.csr_matrix(\n+                (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n+                (n_class, n_SV))\n+\n+\n+        if hasattr(self, \"classes_\"):\n+            n_class = len(self.classes_) - 1\n+        else:  # regression\n+            n_class = 1\n+        n_SV = self.support_vectors_.shape[0]\n+\n+        # Check if we have any support vectors\n+        if n_SV == 0:\n+            # Handle empty support vectors case - create empty CSR matrix\n+            self.dual_coef_ = sp.csr_matrix((n_class, 0))\n+        else:\n+            # Original logic for non-empty case\n+            dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n+            if n_class > 0:\n+                dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n+                                             dual_coef_indices.size / n_class)\n+            else:\n+                # Fallback for edge case where n_class is 0\n+                dual_coef_indptr = np.array([0, dual_coef_indices.size])\n+            \n+            self.dual_coef_ = sp.csr_matrix(\n+                (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n+                (n_class, n_SV))\n \n     def predict(self, X):\n         \"\"\"Perform regression on samples in X.\n",
    "variant_7": "diff --git a/sklearn/svm/base.py b/sklearn/svm/base.py\nindex 64cebe837..95df9d258 100644\n--- a/sklearn/svm/base.py\n+++ b/sklearn/svm/base.py\n@@ -280,18 +280,49 @@ class BaseLibSVM(BaseEstimator, metaclass=ABCMeta):\n \n         self._warn_from_fit_status()\n \n+\n         if hasattr(self, \"classes_\"):\n             n_class = len(self.classes_) - 1\n         else:  # regression\n             n_class = 1\n         n_SV = self.support_vectors_.shape[0]\n \n-        dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n-        dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n-                                     dual_coef_indices.size / n_class)\n-        self.dual_coef_ = sp.csr_matrix(\n-            (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n-            (n_class, n_SV))\n+        # Check if we have any support vectors\n+        if n_SV == 0:\n+            # Handle empty support vectors case - create empty CSR matrix\n+            self.dual_coef_ = sp.csr_matrix((n_class, 0))\n+        else:\n+            # Original logic for non-empty case\n+            dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n+            if n_class > 0:\n+                dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n+                                             dual_coef_indices.size / n_class)\n+            else:\n+                # Fallback for edge case where n_class is 0\n+                dual_coef_indptr = np.array([0, dual_coef_indices.size])\n+            \n+            self.dual_coef_ = sp.csr_matrix(\n+                (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n+                (n_class, n_SV))\n+\n+\n+        # Check if we have any support vectors\n+        if n_SV == 0:\n+            # Handle empty support vectors case - create empty CSR matrix\n+            self.dual_coef_ = sp.csr_matrix((n_class, 0))\n+        else:\n+            # Original logic for non-empty case\n+            dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n+            if n_class > 0:\n+                dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n+                                             dual_coef_indices.size / n_class)\n+            else:\n+                # Fallback for edge case where n_class is 0\n+                dual_coef_indptr = np.array([0, dual_coef_indices.size])\n+            \n+            self.dual_coef_ = sp.csr_matrix(\n+                (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n+                (n_class, n_SV))\n \n     def predict(self, X):\n         \"\"\"Perform regression on samples in X.\n",
    "variant_8": "diff --git a/sklearn/svm/base.py b/sklearn/svm/base.py\nindex 64cebe837..edc904c39 100644\n--- a/sklearn/svm/base.py\n+++ b/sklearn/svm/base.py\n@@ -280,18 +280,55 @@ class BaseLibSVM(BaseEstimator, metaclass=ABCMeta):\n \n         self._warn_from_fit_status()\n \n+\n         if hasattr(self, \"classes_\"):\n             n_class = len(self.classes_) - 1\n         else:  # regression\n             n_class = 1\n         n_SV = self.support_vectors_.shape[0]\n \n-        dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n-        dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n-                                     dual_coef_indices.size / n_class)\n-        self.dual_coef_ = sp.csr_matrix(\n-            (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n-            (n_class, n_SV))\n+        # Check if we have any support vectors\n+        if n_SV == 0:\n+            # Handle empty support vectors case - create empty CSR matrix\n+            self.dual_coef_ = sp.csr_matrix((n_class, 0))\n+        else:\n+            # Original logic for non-empty case\n+            dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n+            if n_class > 0:\n+                dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n+                                             dual_coef_indices.size / n_class)\n+            else:\n+                # Fallback for edge case where n_class is 0\n+                dual_coef_indptr = np.array([0, dual_coef_indices.size])\n+            \n+            self.dual_coef_ = sp.csr_matrix(\n+                (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n+                (n_class, n_SV))\n+\n+\n+        if hasattr(self, \"classes_\"):\n+            n_class = len(self.classes_) - 1\n+        else:  # regression\n+            n_class = 1\n+        n_SV = self.support_vectors_.shape[0]\n+\n+        # Check if we have any support vectors\n+        if n_SV == 0:\n+            # Handle empty support vectors case - create empty CSR matrix\n+            self.dual_coef_ = sp.csr_matrix((n_class, 0))\n+        else:\n+            # Original logic for non-empty case\n+            dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n+            if n_class > 0:\n+                dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n+                                             dual_coef_indices.size / n_class)\n+            else:\n+                # Fallback for edge case where n_class is 0\n+                dual_coef_indptr = np.array([0, dual_coef_indices.size])\n+            \n+            self.dual_coef_ = sp.csr_matrix(\n+                (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n+                (n_class, n_SV))\n \n     def predict(self, X):\n         \"\"\"Perform regression on samples in X.\n"
  }
}