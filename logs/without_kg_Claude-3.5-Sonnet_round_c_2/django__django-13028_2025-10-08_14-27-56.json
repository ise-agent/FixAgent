{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/django/django/db/models/sql/query.py lines 1125-1131)": "\n    def check_filterable(self, expression):\n        \"\"\"Raise an error if expression cannot be used in a WHERE clause.\"\"\"\n        from django.db import models\n        \n        # Skip filterability check for model instances - they're always valid filter values\n        if isinstance(expression, models.Model):\n            return\n            \n        if not getattr(expression, 'filterable', True):\n            raise NotSupportedError(\n                expression.__class__.__name__ + ' is disallowed in the filter '\n                'clause.'\n            )\n",
    "Location 2 (/root/hy/projects_2/django/django/db/models/sql/query.py lines 1268-1270)": "\n    def check_filterable(self, expression):\n        \"\"\"Check that the given expression is filterable.\"\"\"\n        from django.db import models\n        \n        # Skip filterability check for model instances - they're always valid filter values\n        if isinstance(expression, models.Model):\n            return\n            \n        if hasattr(expression, 'resolve_expression'):\n            expression = expression.resolve_expression(\n                allow_joins=self.allow_joins, reuse=self.reuse_set)\n        if not getattr(expression, 'filterable', True):\n            raise NotSupportedError(\n                expression.__class__.__name__ + ' is disallowed in the filter clause.'\n            )\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/django/django/db/models/sql/query.py lines 1125-1131)": [
      "\n    def check_filterable(self, expression):\n        \"\"\"Raise an error if expression cannot be used in a WHERE clause.\"\"\"\n        from django.db import models\n        \n        # Skip filterability check for model instances - they're always valid filter values\n        if isinstance(expression, models.Model):\n            return\n            \n        if not getattr(expression, 'filterable', True):\n            raise NotSupportedError(\n                expression.__class__.__name__ + ' is disallowed in the filter '\n                'clause.'\n            )\n        if hasattr(expression, 'get_source_expressions'):\n            for expr in expression.get_source_expressions():\n                self.check_filterable(expr)\n",
      "\n    def check_filterable(self, expression):\n        \"\"\"Raise an error if expression cannot be used in a WHERE clause.\"\"\"\n        from django.db import models\n        \n        # Skip filterability check for model instances - they're always valid filter values\n        if isinstance(expression, models.Model):\n            return\n            \n        if not getattr(expression, 'filterable', True):\n            raise NotSupportedError(\n                expression.__class__.__name__ + ' is disallowed in the filter '\n                'clause.'\n            )\n        if hasattr(expression, 'get_source_expressions'):\n            for expr in expression.get_source_expressions():\n                self.check_filterable(expr)\n",
      "\n    def check_filterable(self, expression):\n        \"\"\"Raise an error if expression cannot be used in a WHERE clause.\"\"\"\n        from django.db import models\n        \n        # Skip filterability check for model instances - they're always valid filter values\n        if isinstance(expression, models.Model):\n            return\n            \n        if not getattr(expression, 'filterable', True):\n            raise NotSupportedError(\n                expression.__class__.__name__ + ' is disallowed in the filter '\n                'clause.'\n            )\n        if hasattr(expression, 'get_source_expressions'):\n            for expr in expression.get_source_expressions():\n                self.check_filterable(expr)\n",
      "\n    def check_filterable(self, expression):\n        \"\"\"Raise an error if expression cannot be used in a WHERE clause.\"\"\"\n        from django.db import models\n        \n        # Skip filterability check for model instances - they're always valid filter values\n        if isinstance(expression, models.Model):\n            return\n            \n        if not getattr(expression, 'filterable', True):\n            raise NotSupportedError(\n                expression.__class__.__name__ + ' is disallowed in the filter '\n                'clause.'\n            )\n        if hasattr(expression, 'get_source_expressions'):\n            for expr in expression.get_source_expressions():\n                self.check_filterable(expr)\n",
      "\ndef check_filterable(self, expression):\n    \"\"\"Raise an error if expression cannot be used in a WHERE clause.\"\"\"\n    from django.db import models\n    \n    # Skip filterability check for model instances - they're always valid filter values\n    if isinstance(expression, models.Model):\n        return\n        \n    if not getattr(expression, 'filterable', True):\n        raise NotSupportedError(\n            expression.__class__.__name__ + ' is disallowed in the filter '\n            'clause.'\n        )\n",
      "\n    def check_filterable(self, expression):\n        \"\"\"Raise an error if expression cannot be used in a WHERE clause.\"\"\"\n        from django.db import models\n        \n        # Skip filterability check for model instances - they're always valid filter values\n        if isinstance(expression, models.Model):\n            return\n            \n        if not getattr(expression, 'filterable', True):\n            raise NotSupportedError(\n                expression.__class__.__name__ + ' is disallowed in the filter '\n                'clause.'\n            )\n        if hasattr(expression, 'get_source_expressions'):\n            for expr in expression.get_source_expressions():\n                self.check_filterable(expr)\n",
      "\n    def check_filterable(self, expression):\n        \"\"\"Raise an error if expression cannot be used in a WHERE clause.\"\"\"\n        from django.db import models\n        \n        # Skip filterability check for model instances - they're always valid filter values\n        if isinstance(expression, models.Model):\n            return\n            \n        if not getattr(expression, 'filterable', True):\n            raise NotSupportedError(\n                expression.__class__.__name__ + ' is disallowed in the filter '\n                'clause.'\n            )\n        if hasattr(expression, 'get_source_expressions'):\n            for expr in expression.get_source_expressions():\n                self.check_filterable(expr)\n",
      "\n    def check_filterable(self, expression):\n        \"\"\"Raise an error if expression cannot be used in a WHERE clause.\"\"\"\n        from django.db import models\n        \n        # Skip filterability check for model instances - they're always valid filter values\n        if isinstance(expression, models.Model):\n            return\n            \n        if not getattr(expression, 'filterable', True):\n            raise NotSupportedError(\n                expression.__class__.__name__ + ' is disallowed in the filter '\n                'clause.'\n            )\n        if hasattr(expression, 'get_source_expressions'):\n            for expr in expression.get_source_expressions():\n                self.check_filterable(expr)\n"
    ],
    "Location 2 (/root/hy/projects_2/django/django/db/models/sql/query.py lines 1268-1270)": [
      "\n        if check_filterable:\n            # Skip filterability check for model instances - they're always valid filter values\n            from django.db import models\n            if not isinstance(value, models.Model):\n                self.check_filterable(value)\n",
      "\n        if check_filterable:\n            # Skip filterability check for model instances - they're always valid filter values\n            from django.db import models\n            if not isinstance(value, models.Model):\n                self.check_filterable(value)\n",
      "\n        if check_filterable:\n            # Skip filterability check for model instances - they're always valid filter values\n            from django.db import models\n            if not isinstance(value, models.Model):\n                self.check_filterable(value)\n",
      "\n        if check_filterable:\n            # Skip filterability check for model instances - they're always valid filter values\n            from django.db import models\n            if not isinstance(value, models.Model):\n                self.check_filterable(value)\n",
      "\n        if check_filterable:\n            from django.db import models\n            # Skip filterability check for model instances - they're always valid filter values\n            if not isinstance(value, models.Model):\n                self.check_filterable(value)\n",
      "\n        if check_filterable:\n            # Skip filterability check for model instances - they're always valid filter values\n            from django.db import models\n            if not isinstance(value, models.Model):\n                self.check_filterable(value)\n",
      "\n        if check_filterable:\n            # Skip filterability check for model instances - they're always valid filter values\n            from django.db import models\n            if not isinstance(value, models.Model):\n                self.check_filterable(value)\n",
      "\ndef check_filterable(self, expression):\n    \"\"\"Check that the given expression is filterable.\"\"\"\n    from django.db import models\n    \n    # Skip filterability check for model instances - they're always valid filter values\n    if isinstance(expression, models.Model):\n        return\n        \n    if hasattr(expression, 'resolve_expression'):\n        expression = expression.resolve_expression(\n            allow_joins=self.allow_joins, reuse=self.reuse_set)\n    if not getattr(expression, 'filterable', True):\n        raise NotSupportedError(\n            expression.__class__.__name__ + ' is disallowed in the filter clause.'\n        )\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex ce18098fd2..e38a694029 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1122,8 +1122,16 @@ class Query(BaseExpression):\n                 for v in value:\n                     self.check_query_object_type(v, opts, field)\n \n+\n     def check_filterable(self, expression):\n         \"\"\"Raise an error if expression cannot be used in a WHERE clause.\"\"\"\n+        # Import Model class to distinguish model instances from database expressions\n+        from django.db.models import Model\n+        \n+        # Skip filterability check for model instances - they're always valid filter values\n+        if isinstance(expression, Model):\n+            return\n+            \n         if not getattr(expression, 'filterable', True):\n             raise NotSupportedError(\n                 expression.__class__.__name__ + ' is disallowed in the filter '\n@@ -1265,9 +1273,9 @@ class Query(BaseExpression):\n         value = self.resolve_lookup_value(value, can_reuse, allow_joins)\n         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}\n \n+\n         if check_filterable:\n             self.check_filterable(value)\n-\n         clause = self.where_class()\n         if reffed_expression:\n             condition = self.build_lookup(lookups, reffed_expression, value)\n",
    "variant_0": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex ce18098fd2..446cb9f1b8 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1122,8 +1122,15 @@ class Query(BaseExpression):\n                 for v in value:\n                     self.check_query_object_type(v, opts, field)\n \n+\n     def check_filterable(self, expression):\n         \"\"\"Raise an error if expression cannot be used in a WHERE clause.\"\"\"\n+        from django.db import models\n+        \n+        # Skip filterability check for model instances - they're always valid filter values\n+        if isinstance(expression, models.Model):\n+            return\n+            \n         if not getattr(expression, 'filterable', True):\n             raise NotSupportedError(\n                 expression.__class__.__name__ + ' is disallowed in the filter '\n@@ -1265,9 +1272,22 @@ class Query(BaseExpression):\n         value = self.resolve_lookup_value(value, can_reuse, allow_joins)\n         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}\n \n-        if check_filterable:\n-            self.check_filterable(value)\n \n+    def check_filterable(self, expression):\n+        \"\"\"Check that the given expression is filterable.\"\"\"\n+        from django.db import models\n+        \n+        # Skip filterability check for model instances - they're always valid filter values\n+        if isinstance(expression, models.Model):\n+            return\n+            \n+        if hasattr(expression, 'resolve_expression'):\n+            expression = expression.resolve_expression(\n+                allow_joins=self.allow_joins, reuse=self.reuse_set)\n+        if not getattr(expression, 'filterable', True):\n+            raise NotSupportedError(\n+                expression.__class__.__name__ + ' is disallowed in the filter clause.'\n+            )\n         clause = self.where_class()\n         if reffed_expression:\n             condition = self.build_lookup(lookups, reffed_expression, value)\n",
    "variant_1": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex ce18098fd2..0f2c5e88bf 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1122,8 +1122,15 @@ class Query(BaseExpression):\n                 for v in value:\n                     self.check_query_object_type(v, opts, field)\n \n+\n     def check_filterable(self, expression):\n         \"\"\"Raise an error if expression cannot be used in a WHERE clause.\"\"\"\n+        from django.db import models\n+        \n+        # Skip filterability check for model instances - they're always valid filter values\n+        if isinstance(expression, models.Model):\n+            return\n+            \n         if not getattr(expression, 'filterable', True):\n             raise NotSupportedError(\n                 expression.__class__.__name__ + ' is disallowed in the filter '\n@@ -1132,6 +1139,9 @@ class Query(BaseExpression):\n         if hasattr(expression, 'get_source_expressions'):\n             for expr in expression.get_source_expressions():\n                 self.check_filterable(expr)\n+        if hasattr(expression, 'get_source_expressions'):\n+            for expr in expression.get_source_expressions():\n+                self.check_filterable(expr)\n \n     def build_lookup(self, lookups, lhs, rhs):\n         \"\"\"\n@@ -1265,9 +1275,12 @@ class Query(BaseExpression):\n         value = self.resolve_lookup_value(value, can_reuse, allow_joins)\n         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}\n \n-        if check_filterable:\n-            self.check_filterable(value)\n \n+        if check_filterable:\n+            # Skip filterability check for model instances - they're always valid filter values\n+            from django.db import models\n+            if not isinstance(value, models.Model):\n+                self.check_filterable(value)\n         clause = self.where_class()\n         if reffed_expression:\n             condition = self.build_lookup(lookups, reffed_expression, value)\n",
    "variant_2": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex ce18098fd2..0f2c5e88bf 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1122,8 +1122,15 @@ class Query(BaseExpression):\n                 for v in value:\n                     self.check_query_object_type(v, opts, field)\n \n+\n     def check_filterable(self, expression):\n         \"\"\"Raise an error if expression cannot be used in a WHERE clause.\"\"\"\n+        from django.db import models\n+        \n+        # Skip filterability check for model instances - they're always valid filter values\n+        if isinstance(expression, models.Model):\n+            return\n+            \n         if not getattr(expression, 'filterable', True):\n             raise NotSupportedError(\n                 expression.__class__.__name__ + ' is disallowed in the filter '\n@@ -1132,6 +1139,9 @@ class Query(BaseExpression):\n         if hasattr(expression, 'get_source_expressions'):\n             for expr in expression.get_source_expressions():\n                 self.check_filterable(expr)\n+        if hasattr(expression, 'get_source_expressions'):\n+            for expr in expression.get_source_expressions():\n+                self.check_filterable(expr)\n \n     def build_lookup(self, lookups, lhs, rhs):\n         \"\"\"\n@@ -1265,9 +1275,12 @@ class Query(BaseExpression):\n         value = self.resolve_lookup_value(value, can_reuse, allow_joins)\n         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}\n \n-        if check_filterable:\n-            self.check_filterable(value)\n \n+        if check_filterable:\n+            # Skip filterability check for model instances - they're always valid filter values\n+            from django.db import models\n+            if not isinstance(value, models.Model):\n+                self.check_filterable(value)\n         clause = self.where_class()\n         if reffed_expression:\n             condition = self.build_lookup(lookups, reffed_expression, value)\n",
    "variant_3": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex ce18098fd2..0f2c5e88bf 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1122,8 +1122,15 @@ class Query(BaseExpression):\n                 for v in value:\n                     self.check_query_object_type(v, opts, field)\n \n+\n     def check_filterable(self, expression):\n         \"\"\"Raise an error if expression cannot be used in a WHERE clause.\"\"\"\n+        from django.db import models\n+        \n+        # Skip filterability check for model instances - they're always valid filter values\n+        if isinstance(expression, models.Model):\n+            return\n+            \n         if not getattr(expression, 'filterable', True):\n             raise NotSupportedError(\n                 expression.__class__.__name__ + ' is disallowed in the filter '\n@@ -1132,6 +1139,9 @@ class Query(BaseExpression):\n         if hasattr(expression, 'get_source_expressions'):\n             for expr in expression.get_source_expressions():\n                 self.check_filterable(expr)\n+        if hasattr(expression, 'get_source_expressions'):\n+            for expr in expression.get_source_expressions():\n+                self.check_filterable(expr)\n \n     def build_lookup(self, lookups, lhs, rhs):\n         \"\"\"\n@@ -1265,9 +1275,12 @@ class Query(BaseExpression):\n         value = self.resolve_lookup_value(value, can_reuse, allow_joins)\n         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}\n \n-        if check_filterable:\n-            self.check_filterable(value)\n \n+        if check_filterable:\n+            # Skip filterability check for model instances - they're always valid filter values\n+            from django.db import models\n+            if not isinstance(value, models.Model):\n+                self.check_filterable(value)\n         clause = self.where_class()\n         if reffed_expression:\n             condition = self.build_lookup(lookups, reffed_expression, value)\n",
    "variant_4": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex ce18098fd2..0f2c5e88bf 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1122,8 +1122,15 @@ class Query(BaseExpression):\n                 for v in value:\n                     self.check_query_object_type(v, opts, field)\n \n+\n     def check_filterable(self, expression):\n         \"\"\"Raise an error if expression cannot be used in a WHERE clause.\"\"\"\n+        from django.db import models\n+        \n+        # Skip filterability check for model instances - they're always valid filter values\n+        if isinstance(expression, models.Model):\n+            return\n+            \n         if not getattr(expression, 'filterable', True):\n             raise NotSupportedError(\n                 expression.__class__.__name__ + ' is disallowed in the filter '\n@@ -1132,6 +1139,9 @@ class Query(BaseExpression):\n         if hasattr(expression, 'get_source_expressions'):\n             for expr in expression.get_source_expressions():\n                 self.check_filterable(expr)\n+        if hasattr(expression, 'get_source_expressions'):\n+            for expr in expression.get_source_expressions():\n+                self.check_filterable(expr)\n \n     def build_lookup(self, lookups, lhs, rhs):\n         \"\"\"\n@@ -1265,9 +1275,12 @@ class Query(BaseExpression):\n         value = self.resolve_lookup_value(value, can_reuse, allow_joins)\n         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}\n \n-        if check_filterable:\n-            self.check_filterable(value)\n \n+        if check_filterable:\n+            # Skip filterability check for model instances - they're always valid filter values\n+            from django.db import models\n+            if not isinstance(value, models.Model):\n+                self.check_filterable(value)\n         clause = self.where_class()\n         if reffed_expression:\n             condition = self.build_lookup(lookups, reffed_expression, value)\n",
    "variant_5": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex ce18098fd2..294b62408d 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1122,13 +1122,20 @@ class Query(BaseExpression):\n                 for v in value:\n                     self.check_query_object_type(v, opts, field)\n \n-    def check_filterable(self, expression):\n-        \"\"\"Raise an error if expression cannot be used in a WHERE clause.\"\"\"\n-        if not getattr(expression, 'filterable', True):\n-            raise NotSupportedError(\n-                expression.__class__.__name__ + ' is disallowed in the filter '\n-                'clause.'\n-            )\n+\n+def check_filterable(self, expression):\n+    \"\"\"Raise an error if expression cannot be used in a WHERE clause.\"\"\"\n+    from django.db import models\n+    \n+    # Skip filterability check for model instances - they're always valid filter values\n+    if isinstance(expression, models.Model):\n+        return\n+        \n+    if not getattr(expression, 'filterable', True):\n+        raise NotSupportedError(\n+            expression.__class__.__name__ + ' is disallowed in the filter '\n+            'clause.'\n+        )\n         if hasattr(expression, 'get_source_expressions'):\n             for expr in expression.get_source_expressions():\n                 self.check_filterable(expr)\n@@ -1265,9 +1272,12 @@ class Query(BaseExpression):\n         value = self.resolve_lookup_value(value, can_reuse, allow_joins)\n         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}\n \n-        if check_filterable:\n-            self.check_filterable(value)\n \n+        if check_filterable:\n+            from django.db import models\n+            # Skip filterability check for model instances - they're always valid filter values\n+            if not isinstance(value, models.Model):\n+                self.check_filterable(value)\n         clause = self.where_class()\n         if reffed_expression:\n             condition = self.build_lookup(lookups, reffed_expression, value)\n",
    "variant_6": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex ce18098fd2..0f2c5e88bf 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1122,8 +1122,15 @@ class Query(BaseExpression):\n                 for v in value:\n                     self.check_query_object_type(v, opts, field)\n \n+\n     def check_filterable(self, expression):\n         \"\"\"Raise an error if expression cannot be used in a WHERE clause.\"\"\"\n+        from django.db import models\n+        \n+        # Skip filterability check for model instances - they're always valid filter values\n+        if isinstance(expression, models.Model):\n+            return\n+            \n         if not getattr(expression, 'filterable', True):\n             raise NotSupportedError(\n                 expression.__class__.__name__ + ' is disallowed in the filter '\n@@ -1132,6 +1139,9 @@ class Query(BaseExpression):\n         if hasattr(expression, 'get_source_expressions'):\n             for expr in expression.get_source_expressions():\n                 self.check_filterable(expr)\n+        if hasattr(expression, 'get_source_expressions'):\n+            for expr in expression.get_source_expressions():\n+                self.check_filterable(expr)\n \n     def build_lookup(self, lookups, lhs, rhs):\n         \"\"\"\n@@ -1265,9 +1275,12 @@ class Query(BaseExpression):\n         value = self.resolve_lookup_value(value, can_reuse, allow_joins)\n         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}\n \n-        if check_filterable:\n-            self.check_filterable(value)\n \n+        if check_filterable:\n+            # Skip filterability check for model instances - they're always valid filter values\n+            from django.db import models\n+            if not isinstance(value, models.Model):\n+                self.check_filterable(value)\n         clause = self.where_class()\n         if reffed_expression:\n             condition = self.build_lookup(lookups, reffed_expression, value)\n",
    "variant_7": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex ce18098fd2..0f2c5e88bf 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1122,8 +1122,15 @@ class Query(BaseExpression):\n                 for v in value:\n                     self.check_query_object_type(v, opts, field)\n \n+\n     def check_filterable(self, expression):\n         \"\"\"Raise an error if expression cannot be used in a WHERE clause.\"\"\"\n+        from django.db import models\n+        \n+        # Skip filterability check for model instances - they're always valid filter values\n+        if isinstance(expression, models.Model):\n+            return\n+            \n         if not getattr(expression, 'filterable', True):\n             raise NotSupportedError(\n                 expression.__class__.__name__ + ' is disallowed in the filter '\n@@ -1132,6 +1139,9 @@ class Query(BaseExpression):\n         if hasattr(expression, 'get_source_expressions'):\n             for expr in expression.get_source_expressions():\n                 self.check_filterable(expr)\n+        if hasattr(expression, 'get_source_expressions'):\n+            for expr in expression.get_source_expressions():\n+                self.check_filterable(expr)\n \n     def build_lookup(self, lookups, lhs, rhs):\n         \"\"\"\n@@ -1265,9 +1275,12 @@ class Query(BaseExpression):\n         value = self.resolve_lookup_value(value, can_reuse, allow_joins)\n         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}\n \n-        if check_filterable:\n-            self.check_filterable(value)\n \n+        if check_filterable:\n+            # Skip filterability check for model instances - they're always valid filter values\n+            from django.db import models\n+            if not isinstance(value, models.Model):\n+                self.check_filterable(value)\n         clause = self.where_class()\n         if reffed_expression:\n             condition = self.build_lookup(lookups, reffed_expression, value)\n",
    "variant_8": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex ce18098fd2..9e388c308b 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1122,8 +1122,15 @@ class Query(BaseExpression):\n                 for v in value:\n                     self.check_query_object_type(v, opts, field)\n \n+\n     def check_filterable(self, expression):\n         \"\"\"Raise an error if expression cannot be used in a WHERE clause.\"\"\"\n+        from django.db import models\n+        \n+        # Skip filterability check for model instances - they're always valid filter values\n+        if isinstance(expression, models.Model):\n+            return\n+            \n         if not getattr(expression, 'filterable', True):\n             raise NotSupportedError(\n                 expression.__class__.__name__ + ' is disallowed in the filter '\n@@ -1132,6 +1139,9 @@ class Query(BaseExpression):\n         if hasattr(expression, 'get_source_expressions'):\n             for expr in expression.get_source_expressions():\n                 self.check_filterable(expr)\n+        if hasattr(expression, 'get_source_expressions'):\n+            for expr in expression.get_source_expressions():\n+                self.check_filterable(expr)\n \n     def build_lookup(self, lookups, lhs, rhs):\n         \"\"\"\n@@ -1265,9 +1275,22 @@ class Query(BaseExpression):\n         value = self.resolve_lookup_value(value, can_reuse, allow_joins)\n         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}\n \n-        if check_filterable:\n-            self.check_filterable(value)\n \n+def check_filterable(self, expression):\n+    \"\"\"Check that the given expression is filterable.\"\"\"\n+    from django.db import models\n+    \n+    # Skip filterability check for model instances - they're always valid filter values\n+    if isinstance(expression, models.Model):\n+        return\n+        \n+    if hasattr(expression, 'resolve_expression'):\n+        expression = expression.resolve_expression(\n+            allow_joins=self.allow_joins, reuse=self.reuse_set)\n+    if not getattr(expression, 'filterable', True):\n+        raise NotSupportedError(\n+            expression.__class__.__name__ + ' is disallowed in the filter clause.'\n+        )\n         clause = self.where_class()\n         if reffed_expression:\n             condition = self.build_lookup(lookups, reffed_expression, value)\n"
  }
}