{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/sphinx/sphinx/ext/viewcode.py lines 181-184)": "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    if not hasattr(env, '_viewcode_modules'):\n        return\n",
    "Location 2 (/root/hy/projects_2/sphinx/sphinx/ext/viewcode.py lines 59-60)": "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not isinstance(app.builder, StandaloneHTMLBuilder):\n        return\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)  # type: ignore\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),  # type: ignore\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),  # type: ignore\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        code, tags, used, refname = entry\n        # construct a page name for the highlighted source\n        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        # highlight the source using the builder's highlighter\n        if env.config.highlight_language in ('python3', 'default', 'none'):\n            lexer = env.config.highlight_language\n        else:\n            lexer = 'python'\n        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n        # split the code into lines\n        lines = highlighted.splitlines()\n        # split off wrap markup from the first line of the actual code\n        before, after = lines[0].split('<pre>')\n        lines[0:1] = [before + '<pre>', after]\n        # nothing to do for the last line; it always starts with </pre> anyway\n        # now that we have code lines (starting at index 1), insert anchors for\n        # the collected tags (HACK: this only works if the tag boundaries are\n        # properly nested!)\n        maxindex = len(lines) - 1\n        for name, docname in used.items():\n            type, start, end = tags[name]\n            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n            lines[start] = (\n                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n                lines[start])\n            lines[min(end, maxindex)] += '</div>'\n        # try to find parents (for submodules)\n        parents = []\n        parent = modname\n        while '.' in parent:\n            parent = parent.rsplit('.', 1)[0]\n            if parent in modnames:\n                parents.append({\n                    'link': urito(pagename,\n                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n                    'title': parent})\n        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n                        'title': _('Module code')})\n        parents.reverse()\n        # putting it all together\n        context = {\n            'parents': parents,\n            'title': modname,\n            'body': (_('<h1>Source code for %s</h1>') % modname +\n                     '\\n'.join(lines)),\n        }\n        yield (pagename, context, 'page.html')\n\n    if not modnames:\n        return\n\n    html = ['\\n']\n    # the stack logic is needed for using nested lists for submodules\n    stack = ['']\n    for modname in sorted(modnames):\n        if modname.startswith(stack[-1]):\n            stack.append(modname + '.')\n            html.append('<ul>')\n        else:\n            stack.pop()\n            while not modname.startswith(stack[-1]):\n                stack.pop()\n                html.append('</ul>')\n            stack.append(modname + '.')\n            html.append('<ul>')\n\n        html.append('<li><a href=\"%s\">%s</a></li>\\n' % (\n            urito(posixpath.join(OUTPUT_DIRNAME, 'index'),\n                  posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))),\n            modname))\n\n    html.append('</ul>' * (len(stack) - 1))\n    context = {\n        'title': _('Overview: module code'),\n        'body': (_('<h1>All modules for which code is available</h1>') +\n                 ''.join(html)),\n    }\n\n    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/sphinx/sphinx/ext/viewcode.py lines 181-184)": [
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    if not hasattr(env, '_viewcode_modules'):\n        return\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    if not hasattr(env, '_viewcode_modules'):\n        return\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    if not hasattr(env, '_viewcode_modules'):\n        return\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    if not hasattr(env, '_viewcode_modules'):\n        return\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    if not hasattr(env, '_viewcode_modules'):\n        return\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    if not hasattr(env, '_viewcode_modules'):\n        return\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    if not hasattr(env, '_viewcode_modules'):\n        return\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    if not hasattr(env, '_viewcode_modules'):\n        return\n"
    ],
    "Location 2 (/root/hy/projects_2/sphinx/sphinx/ext/viewcode.py lines 59-60)": [
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not isinstance(app.builder, StandaloneHTMLBuilder):\n        return\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not isinstance(app.builder, StandaloneHTMLBuilder):\n        return\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)  # type: ignore\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),  # type: ignore\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),  # type: ignore\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        code, tags, used, refname = entry\n        # construct a page name for the highlighted source\n        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        # highlight the source using the builder's highlighter\n        if env.config.highlight_language in ('python3', 'default', 'none'):\n            lexer = env.config.highlight_language\n        else:\n            lexer = 'python'\n        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n        # split the code into lines\n        lines = highlighted.splitlines()\n        # split off wrap markup from the first line of the actual code\n        before, after = lines[0].split('<pre>')\n        lines[0:1] = [before + '<pre>', after]\n        # nothing to do for the last line; it always starts with </pre> anyway\n        # now that we have code lines (starting at index 1), insert anchors for\n        # the collected tags (HACK: this only works if the tag boundaries are\n        # properly nested!)\n        max_index = len(lines) - 1\n        for name, docname in used.items():\n            type, start, end = tags[name]\n            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n            lines[start] = (\n                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n                lines[start])\n            lines[min(end, max_index)] += '</div>'\n        # try to find parents (for submodules)\n        parents = []\n        parent = modname\n        while '.' in parent:\n            parent = parent.rsplit('.', 1)[0]\n            if parent in modnames:\n                parents.append({\n                    'link': urito(pagename,\n                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n                    'title': parent})\n        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n                        'title': _('Module code')})\n        parents.reverse()\n        # putting it all together\n        context = {\n            'parents': parents,\n            'title': modname,\n            'body': (_('<h1>Source code for %s</h1>') % modname +\n                     '\\n'.join(lines)),\n        }\n        yield (pagename, context, 'page.html')\n\n    if not modnames:\n        return\n\n    html = ['\\n']\n    # the stack logic is needed for using nested lists for submodules\n    stack = ['']\n    for modname in sorted(modnames):\n        if modname.startswith(stack[-1]):\n            stack.append(modname + '.')\n            html.append('<ul>')\n        else:\n            stack.pop()\n            while not modname.startswith(stack[-1]):\n                stack.pop()\n                html.append('</ul>')\n            stack.append(modname + '.')\n            html.append('<ul>')\n\n        link = urito(posixpath.join(OUTPUT_DIRNAME, 'index'),\n                     posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/')))\n        html.append('<li><a href=\"%s\">%s</a></li>\\n' % (link, modname))\n\n    html.append('</ul>' * (len(stack) - 1))\n    context = {\n        'title': _('Overview: module code'),\n        'body': (_('<h1>All modules for which code is available</h1>') +\n                 ''.join(html)),\n    }\n\n    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not isinstance(app.builder, StandaloneHTMLBuilder):\n        return\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)  # type: ignore\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),  # type: ignore\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),  # type: ignore\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        code, tags, used, refname = entry\n        # construct a page name for the highlighted source\n        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        # highlight the source using the builder's highlighter\n        if env.config.highlight_language in ('python3', 'default', 'none'):\n            lexer = env.config.highlight_language\n        else:\n            lexer = 'python'\n        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n        # split the code into lines\n        lines = highlighted.splitlines()\n        # split off wrap markup from the first line of the actual code\n        before, after = lines[0].split('<pre>')\n        lines[0:1] = [before + '<pre>', after]\n        # nothing to do, if no function or class found\n        if not tags:\n            continue\n        higher = sorted(used, key=lambda x: x.split('.'))\n        # now that we have code lines (starting at index 1), insert anchors for\n        # the collected tags (HACK: this only works if the tag boundaries are\n        # properly nested!)\n        max_index = len(lines) - 1\n        for name, docname in higher:\n            type, start, end = tags[name]\n            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n            lines[start] = (\n                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n                lines[start])\n            lines[min(end, max_index)] += '</div>'\n        # try to find parents (for submodules)\n        parents = []\n        parent = modname\n        while '.' in parent:\n            parent = parent.rsplit('.', 1)[0]\n            if parent in modnames:\n                parents.append({\n                    'link': urito(pagename,\n                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n                    'title': parent})\n        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n                        'title': _('Module code')})\n        parents.reverse()\n        # putting it all together\n        context = {\n            'parents': parents,\n            'title': modname,\n            'body': (_('<h1>Source code for %s</h1>') % modname +\n                     '\\n'.join(lines)),\n        }\n        yield (pagename, context, 'page.html')\n\n    if not modnames:\n        return\n\n    html = ['\\n']\n    # the stack logic is needed for using nested lists for submodules\n    stack = ['']\n    for modname in sorted(modnames):\n        if modname.startswith('_'):\n            continue\n        parts = modname.split('.')\n        levels = len(parts)\n        for i in range(levels):\n            level = '.'.join(parts[:i + 1])\n            if level not in stack:\n                stack.append(level)\n                if i < levels - 1:\n                    # submodule\n                    html.append('<ul>')\n                    html.append('<li><strong>%s</strong></li>' % parts[i])\n                else:\n                    # actual module\n                    pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n                    link = urito('', pagename)\n                    html.append('<li><a href=\"%s\">%s</a></li>\\n' % (link, modname))\n            else:\n                break\n\n        # remove stack entries we're no longer under\n        for i in range(stack.index(level) + 1, len(stack)):\n            if i < len(stack) - 1:\n                html.append('</ul>')\n            stack.pop()\n    html.append('</ul>' * (len(stack) - 1))\n    context = {\n        'title': _('Overview: module code'),\n        'body': '<h1>%s</h1>%s' % (_('All modules for which code is available'),\n                                   ''.join(html)),\n    }\n\n    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not isinstance(app.builder, StandaloneHTMLBuilder):\n        return\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)  # type: ignore\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),  # type: ignore\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),  # type: ignore\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        code, tags, used, refname = entry\n        # construct a page name for the highlighted source\n        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        # highlight the source using the builder's highlighter\n        if env.config.highlight_language in ('python3', 'default', 'none'):\n            lexer = env.config.highlight_language\n        else:\n            lexer = 'python'\n        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n        # split the code into lines\n        lines = highlighted.splitlines()\n        # split off wrap markup from the first line of the actual code\n        before, after = lines[0].split('<pre>')\n        lines[0:1] = [before + '<pre>', after]\n        # nothing to do for the last line; it always starts with </pre> anyway\n        # now that we have code lines (starting at index 1), insert anchors for\n        # the collected tags (HACK: this only works if the tag boundaries are\n        # properly nested!)\n        max_index = len(lines) - 1\n        for name, docname in used.items():\n            type, start, end = tags[name]\n            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n            lines[start] = (\n                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n                lines[start])\n            lines[min(end, max_index)] += '</div>'\n        # try to find parents (for submodules)\n        parents = []\n        parent = modname\n        while '.' in parent:\n            parent = parent.rsplit('.', 1)[0]\n            if parent in modnames:\n                parents.append({\n                    'link': urito(pagename,\n                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n                    'title': parent})\n        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n                        'title': _('Module code')})\n        parents.reverse()\n        # putting it all together\n        context = {\n            'parents': parents,\n            'title': modname,\n            'body': (_('<h1>Source code for %s</h1>') % modname +\n                     '\\n'.join(lines)),\n        }\n        yield (pagename, context, 'page.html')\n\n    if not modnames:\n        return\n\n    html = ['\\n']\n    # the stack logic is needed for using nested lists for submodules\n    stack = ['']\n    for modname in sorted(modnames):\n        if modname.startswith(stack[-1]):\n            stack.append(modname + '.')\n            html.append('<ul>')\n        else:\n            stack.pop()\n            while not modname.startswith(stack[-1]):\n                stack.pop()\n                html.append('</ul>')\n            stack.append(modname + '.')\n            html.append('<ul>')\n\n        html.append('<li><a href=\"%s\">%s</a></li>\\n' % (\n            urito(posixpath.join(OUTPUT_DIRNAME, 'index'),\n                  posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))),\n            modname))\n\n    html.append('</ul>' * (len(stack) - 1))\n    context = {\n        'title': _('Overview: module code'),\n        'body': (_('<h1>All modules for which code is available</h1>') +\n                 ''.join(html)),\n    }\n\n    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not isinstance(app.builder, StandaloneHTMLBuilder):\n        return\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)  # type: ignore\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),  # type: ignore\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),  # type: ignore\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        code, tags, used, refname = entry\n        # construct a page name for the highlighted source\n        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        # highlight the source using the builder's highlighter\n        if env.config.highlight_language in ('python3', 'default', 'none'):\n            lexer = env.config.highlight_language\n        else:\n            lexer = 'python'\n        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n        # split the code into lines\n        lines = highlighted.splitlines()\n        # split off wrap markup from the first line of the actual code\n        before, after = lines[0].split('<pre>')\n        lines[0:1] = [before + '<pre>', after]\n        # nothing to do if only function names are highlighted\n        if set(tags) == {''} or not tags:\n            continue\n        elif len(lines) != len(tags):\n            logger.warning(__('failed to format %s: %s lines vs %s tags'), modname,\n                           len(lines), len(tags), location=pagename)\n            continue\n\n        # insert anchors before the lines that are referenced\n        for i, tag in enumerate(tags):\n            if tag:\n                lines[i] = ('<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n                            'href=\"#%s\">%s</a>' % (tag, tag, _('[docs]'))) + lines[i]\n        # try to find parents (for submodules)\n        parents = []\n        parent = modname\n        while '.' in parent:\n            parent = parent.rsplit('.', 1)[0]\n            if parent in modnames:\n                parents.append({\n                    'link': urito(pagename,\n                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n                    'title': parent})\n        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n                        'title': _('Module code')})\n        parents.reverse()\n        # putting it all together\n        context = {\n            'parents': parents,\n            'title': modname,\n            'body': (_('<h1>Source code for %s</h1>') % modname +\n                     '\\n'.join(lines)),\n        }\n        yield (pagename, context, 'page.html')\n\n    if not modnames:\n        return\n\n    html = ['\\n']\n    # the stack logic is needed for using nested lists for submodules\n    stack = ['']\n    for modname in sorted(modnames):\n        if modname.startswith('_'):\n            continue\n        parts = modname.split('.')\n        levels = len(parts)\n        for i in range(levels):\n            level = '.'.join(parts[:i + 1])\n            if level not in stack:\n                stack.append(level)\n                indent = 4 * (i + 1)\n                html.append('%s<li><a href=\"%s\">%s</a></li>\\n' % (\n                    ' ' * indent,\n                    urito('index', posixpath.join(OUTPUT_DIRNAME, level.replace('.', '/'))),\n                    level))\n\n    html.append('\\n')\n\n    context = {\n        'title': _('Overview: module code'),\n        'body': (_('<h1>All modules for which code is available</h1>') +\n                 ''.join(html)),\n    }\n\n    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not isinstance(app.builder, StandaloneHTMLBuilder):\n        return\n    highlighter = app.builder.highlighter  # type: ignore\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not isinstance(app.builder, StandaloneHTMLBuilder):\n        return\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)  # type: ignore\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),  # type: ignore\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),  # type: ignore\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        if not isinstance(entry, tuple):\n            continue\n        code, tags, used, refname = entry\n        # construct a page name for the highlighted source\n        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        # highlight the source using the builder's highlighter\n        if env.config.highlight_language in ('python3', 'default', 'none'):\n            lexer = env.config.highlight_language\n        else:\n            lexer = 'python'\n        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n        # split the code into lines\n        lines = highlighted.splitlines()\n        # split off wrap markup from the first line of the actual code\n        before, after = lines[0].split('<pre>')\n        lines[0:1] = [before + '<pre>', after]\n        # nothing to do for the last line; it always starts with </pre> anyway\n        # now that we have code lines (starting at index 1), insert anchors for\n        # the collected tags (HACK: this only works if the tag boundaries are\n        # properly nested!)\n        max_index = len(lines) - 1\n        for name, docname in used.items():\n            type, start, end = tags[name]\n            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n            lines[start] = (\n                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n                lines[start])\n            lines[min(end, max_index)] += '</div>'\n        # try to find parents (for submodules)\n        parents = []\n        parent = modname\n        while '.' in parent:\n            parent = parent.rsplit('.', 1)[0]\n            if parent in modnames:\n                parents.append({\n                    'link': urito(pagename,\n                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n                    'title': parent})\n        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n                        'title': _('Module code')})\n        parents.reverse()\n        # putting it all together\n        context = {\n            'parents': parents,\n            'title': modname,\n            'body': (_('<h1>Source code for %s</h1>') % modname +\n                     '\\n'.join(lines)),\n        }\n        yield (pagename, context, 'page.html')\n\n    if not modnames:\n        return\n\n    html = ['\\n']\n    # the stack logic is needed for using nested lists for submodules\n    stack = ['']\n    for modname in sorted(modnames):\n        if modname.startswith(stack[-1]):\n            stack.append(modname + '.')\n            html.append('<ul>')\n        else:\n            stack.pop()\n            while not modname.startswith(stack[-1]):\n                stack.pop()\n                html.append('</ul>')\n            stack.append(modname + '.')\n            html.append('<ul>')\n\n        urlpath = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        html.append('<li><a href=\"%s\">%s</a></li>\\n' % (\n            urito(posixpath.join(OUTPUT_DIRNAME, 'index'), urlpath),\n            modname))\n    html.append('</ul>' * (len(stack) - 1))\n    context = {\n        'title': _('Overview: module code'),\n        'body': (_('<h1>All modules for which code is available</h1>') +\n                 ''.join(html)),\n    }\n\n    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n",
      "\ndef collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n    env = app.builder.env\n    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n        return\n    if not hasattr(env, '_viewcode_modules'):\n        return\n    if not isinstance(app.builder, StandaloneHTMLBuilder):\n        return\n    highlighter = app.builder.highlighter  # type: ignore\n    urito = app.builder.get_relative_uri\n\n    modnames = set(env._viewcode_modules)  # type: ignore\n\n    for modname, entry in status_iterator(\n            sorted(env._viewcode_modules.items()),  # type: ignore\n            __('highlighting module code... '), \"blue\",\n            len(env._viewcode_modules),  # type: ignore\n            app.verbosity, lambda x: x[0]):\n        if not entry:\n            continue\n        if not should_generate_module_page(app, modname):\n            continue\n\n        code, tags, used, refname = entry\n        # construct a page name for the highlighted source\n        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n        # highlight the source using the builder's highlighter\n        if env.config.highlight_language in ('python3', 'default', 'none'):\n            lexer = env.config.highlight_language\n        else:\n            lexer = 'python'\n        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n        # split the code into lines\n        lines = highlighted.splitlines()\n        # split off wrap markup from the first line of the actual code\n        before, after = lines[0].split('<pre>')\n        lines[0:1] = [before + '<pre>', after]\n        # nothing to do for the last line; it always starts with </pre> anyway\n        # now that we have code lines (starting at index 1), insert anchors for\n        # the collected tags (HACK: this only works if the tag boundaries are\n        # properly nested!)\n        max_index = len(lines) - 1\n        for name, docname in used.items():\n            type, start, end = tags[name]\n            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n            lines[start] = (\n                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n                lines[start])\n            lines[min(end, max_index)] += '</div>'\n        # try to find parents (for submodules)\n        parents = []\n        parent = modname\n        while '.' in parent:\n            parent = parent.rsplit('.', 1)[0]\n            if parent in modnames:\n                parents.append({\n                    'link': urito(pagename,\n                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n                    'title': parent})\n        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n                        'title': _('Module code')})\n        parents.reverse()\n        # putting it all together\n        context = {\n            'parents': parents,\n            'title': modname,\n            'body': (_('<h1>Source code for %s</h1>') % modname +\n                     '\\n'.join(lines)),\n        }\n        yield (pagename, context, 'page.html')\n\n    if not modnames:\n        return\n\n    html = ['\\n']\n    # the stack logic is needed for using nested lists for submodules\n    stack = ['']\n    for modname in sorted(modnames):\n        if not should_generate_module_page(app, modname):\n            continue\n\n        parts = modname.split('.')\n        levels = len(parts)\n        # remove stack entries equal or deeper than this level\n        stack = stack[:levels]\n        # add new stack entries equal or deeper than this level\n        stack.extend([''] * (levels - len(stack)))\n        level = levels - 1\n        if stack[level]:\n            html.append('</ul>')\n        if level == 0:\n            html.append('<li><a href=\"%s\">%s</a></li>\\n' % (\n                urito('index', posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))),\n                modname))\n        else:\n            html.append('<li>%s<ul>' % parts[-1])\n            html.append('<li><a href=\"%s\">%s</a></li>\\n' % (\n                urito('index', posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))),\n                modname))\n        stack[level] = True\n    for i in range(len(stack) - 1):\n        if stack[i + 1]:\n            html.append('</ul>')\n    html.append('\\n')\n\n    context = {\n        'title': _('Overview: module code'),\n        'body': (_('<h1>All modules for which code is available</h1>') +\n                 ''.join(html)),\n    }\n\n    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sphinx/ext/viewcode.py b/sphinx/ext/viewcode.py\nindex a7d52a91c..6caeb2f96 100644\n--- a/sphinx/ext/viewcode.py\n+++ b/sphinx/ext/viewcode.py\n@@ -56,6 +56,7 @@ def doctree_read(app: Sphinx, doctree: Node) -> None:\n         env._viewcode_modules = {}  # type: ignore\n     if app.builder.name == \"singlehtml\":\n         return\n+\n     if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n         return\n \n@@ -178,10 +179,13 @@ def should_generate_module_page(app: Sphinx, modname: str) -> bool:\n     return True\n \n \n+\n def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n     env = app.builder.env\n     if not hasattr(env, '_viewcode_modules'):\n         return\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n     highlighter = app.builder.highlighter  # type: ignore\n     urito = app.builder.get_relative_uri\n \n",
    "variant_0": "diff --git a/sphinx/ext/viewcode.py b/sphinx/ext/viewcode.py\nindex a7d52a91c..e2cbad17a 100644\n--- a/sphinx/ext/viewcode.py\n+++ b/sphinx/ext/viewcode.py\n@@ -56,8 +56,107 @@ def doctree_read(app: Sphinx, doctree: Node) -> None:\n         env._viewcode_modules = {}  # type: ignore\n     if app.builder.name == \"singlehtml\":\n         return\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.builder.env\n     if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n         return\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    if not isinstance(app.builder, StandaloneHTMLBuilder):\n+        return\n+    highlighter = app.builder.highlighter  # type: ignore\n+    urito = app.builder.get_relative_uri\n+\n+    modnames = set(env._viewcode_modules)  # type: ignore\n+\n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),  # type: ignore\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),  # type: ignore\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+        code, tags, used, refname = entry\n+        # construct a page name for the highlighted source\n+        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        # highlight the source using the builder's highlighter\n+        if env.config.highlight_language in ('python3', 'default', 'none'):\n+            lexer = env.config.highlight_language\n+        else:\n+            lexer = 'python'\n+        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n+        # split the code into lines\n+        lines = highlighted.splitlines()\n+        # split off wrap markup from the first line of the actual code\n+        before, after = lines[0].split('<pre>')\n+        lines[0:1] = [before + '<pre>', after]\n+        # nothing to do for the last line; it always starts with </pre> anyway\n+        # now that we have code lines (starting at index 1), insert anchors for\n+        # the collected tags (HACK: this only works if the tag boundaries are\n+        # properly nested!)\n+        maxindex = len(lines) - 1\n+        for name, docname in used.items():\n+            type, start, end = tags[name]\n+            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n+            lines[start] = (\n+                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n+                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n+                lines[start])\n+            lines[min(end, maxindex)] += '</div>'\n+        # try to find parents (for submodules)\n+        parents = []\n+        parent = modname\n+        while '.' in parent:\n+            parent = parent.rsplit('.', 1)[0]\n+            if parent in modnames:\n+                parents.append({\n+                    'link': urito(pagename,\n+                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n+                    'title': parent})\n+        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n+                        'title': _('Module code')})\n+        parents.reverse()\n+        # putting it all together\n+        context = {\n+            'parents': parents,\n+            'title': modname,\n+            'body': (_('<h1>Source code for %s</h1>') % modname +\n+                     '\\n'.join(lines)),\n+        }\n+        yield (pagename, context, 'page.html')\n+\n+    if not modnames:\n+        return\n+\n+    html = ['\\n']\n+    # the stack logic is needed for using nested lists for submodules\n+    stack = ['']\n+    for modname in sorted(modnames):\n+        if modname.startswith(stack[-1]):\n+            stack.append(modname + '.')\n+            html.append('<ul>')\n+        else:\n+            stack.pop()\n+            while not modname.startswith(stack[-1]):\n+                stack.pop()\n+                html.append('</ul>')\n+            stack.append(modname + '.')\n+            html.append('<ul>')\n+\n+        html.append('<li><a href=\"%s\">%s</a></li>\\n' % (\n+            urito(posixpath.join(OUTPUT_DIRNAME, 'index'),\n+                  posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))),\n+            modname))\n+\n+    html.append('</ul>' * (len(stack) - 1))\n+    context = {\n+        'title': _('Overview: module code'),\n+        'body': (_('<h1>All modules for which code is available</h1>') +\n+                 ''.join(html)),\n+    }\n+\n+    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n \n     def has_tag(modname: str, fullname: str, docname: str, refname: str) -> bool:\n         entry = env._viewcode_modules.get(modname, None)  # type: ignore\n@@ -178,8 +277,11 @@ def should_generate_module_page(app: Sphinx, modname: str) -> bool:\n     return True\n \n \n+\n def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n     env = app.builder.env\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n     if not hasattr(env, '_viewcode_modules'):\n         return\n     highlighter = app.builder.highlighter  # type: ignore\n",
    "variant_1": "diff --git a/sphinx/ext/viewcode.py b/sphinx/ext/viewcode.py\nindex a7d52a91c..54af569d0 100644\n--- a/sphinx/ext/viewcode.py\n+++ b/sphinx/ext/viewcode.py\n@@ -56,8 +56,17 @@ def doctree_read(app: Sphinx, doctree: Node) -> None:\n         env._viewcode_modules = {}  # type: ignore\n     if app.builder.name == \"singlehtml\":\n         return\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.builder.env\n     if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n         return\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    if not isinstance(app.builder, StandaloneHTMLBuilder):\n+        return\n+    highlighter = app.builder.highlighter  # type: ignore\n+    urito = app.builder.get_relative_uri\n \n     def has_tag(modname: str, fullname: str, docname: str, refname: str) -> bool:\n         entry = env._viewcode_modules.get(modname, None)  # type: ignore\n@@ -178,8 +187,11 @@ def should_generate_module_page(app: Sphinx, modname: str) -> bool:\n     return True\n \n \n+\n def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n     env = app.builder.env\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n     if not hasattr(env, '_viewcode_modules'):\n         return\n     highlighter = app.builder.highlighter  # type: ignore\n",
    "variant_2": "diff --git a/sphinx/ext/viewcode.py b/sphinx/ext/viewcode.py\nindex a7d52a91c..a7e111140 100644\n--- a/sphinx/ext/viewcode.py\n+++ b/sphinx/ext/viewcode.py\n@@ -56,8 +56,106 @@ def doctree_read(app: Sphinx, doctree: Node) -> None:\n         env._viewcode_modules = {}  # type: ignore\n     if app.builder.name == \"singlehtml\":\n         return\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.builder.env\n     if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n         return\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    if not isinstance(app.builder, StandaloneHTMLBuilder):\n+        return\n+    highlighter = app.builder.highlighter  # type: ignore\n+    urito = app.builder.get_relative_uri\n+\n+    modnames = set(env._viewcode_modules)  # type: ignore\n+\n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),  # type: ignore\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),  # type: ignore\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+        code, tags, used, refname = entry\n+        # construct a page name for the highlighted source\n+        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        # highlight the source using the builder's highlighter\n+        if env.config.highlight_language in ('python3', 'default', 'none'):\n+            lexer = env.config.highlight_language\n+        else:\n+            lexer = 'python'\n+        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n+        # split the code into lines\n+        lines = highlighted.splitlines()\n+        # split off wrap markup from the first line of the actual code\n+        before, after = lines[0].split('<pre>')\n+        lines[0:1] = [before + '<pre>', after]\n+        # nothing to do for the last line; it always starts with </pre> anyway\n+        # now that we have code lines (starting at index 1), insert anchors for\n+        # the collected tags (HACK: this only works if the tag boundaries are\n+        # properly nested!)\n+        max_index = len(lines) - 1\n+        for name, docname in used.items():\n+            type, start, end = tags[name]\n+            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n+            lines[start] = (\n+                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n+                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n+                lines[start])\n+            lines[min(end, max_index)] += '</div>'\n+        # try to find parents (for submodules)\n+        parents = []\n+        parent = modname\n+        while '.' in parent:\n+            parent = parent.rsplit('.', 1)[0]\n+            if parent in modnames:\n+                parents.append({\n+                    'link': urito(pagename,\n+                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n+                    'title': parent})\n+        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n+                        'title': _('Module code')})\n+        parents.reverse()\n+        # putting it all together\n+        context = {\n+            'parents': parents,\n+            'title': modname,\n+            'body': (_('<h1>Source code for %s</h1>') % modname +\n+                     '\\n'.join(lines)),\n+        }\n+        yield (pagename, context, 'page.html')\n+\n+    if not modnames:\n+        return\n+\n+    html = ['\\n']\n+    # the stack logic is needed for using nested lists for submodules\n+    stack = ['']\n+    for modname in sorted(modnames):\n+        if modname.startswith(stack[-1]):\n+            stack.append(modname + '.')\n+            html.append('<ul>')\n+        else:\n+            stack.pop()\n+            while not modname.startswith(stack[-1]):\n+                stack.pop()\n+                html.append('</ul>')\n+            stack.append(modname + '.')\n+            html.append('<ul>')\n+\n+        link = urito(posixpath.join(OUTPUT_DIRNAME, 'index'),\n+                     posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/')))\n+        html.append('<li><a href=\"%s\">%s</a></li>\\n' % (link, modname))\n+\n+    html.append('</ul>' * (len(stack) - 1))\n+    context = {\n+        'title': _('Overview: module code'),\n+        'body': (_('<h1>All modules for which code is available</h1>') +\n+                 ''.join(html)),\n+    }\n+\n+    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n \n     def has_tag(modname: str, fullname: str, docname: str, refname: str) -> bool:\n         entry = env._viewcode_modules.get(modname, None)  # type: ignore\n@@ -178,8 +276,11 @@ def should_generate_module_page(app: Sphinx, modname: str) -> bool:\n     return True\n \n \n+\n def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n     env = app.builder.env\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n     if not hasattr(env, '_viewcode_modules'):\n         return\n     highlighter = app.builder.highlighter  # type: ignore\n",
    "variant_3": "diff --git a/sphinx/ext/viewcode.py b/sphinx/ext/viewcode.py\nindex a7d52a91c..05eb6dea5 100644\n--- a/sphinx/ext/viewcode.py\n+++ b/sphinx/ext/viewcode.py\n@@ -56,8 +56,119 @@ def doctree_read(app: Sphinx, doctree: Node) -> None:\n         env._viewcode_modules = {}  # type: ignore\n     if app.builder.name == \"singlehtml\":\n         return\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.builder.env\n     if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n         return\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    if not isinstance(app.builder, StandaloneHTMLBuilder):\n+        return\n+    highlighter = app.builder.highlighter  # type: ignore\n+    urito = app.builder.get_relative_uri\n+\n+    modnames = set(env._viewcode_modules)  # type: ignore\n+\n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),  # type: ignore\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),  # type: ignore\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+        code, tags, used, refname = entry\n+        # construct a page name for the highlighted source\n+        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        # highlight the source using the builder's highlighter\n+        if env.config.highlight_language in ('python3', 'default', 'none'):\n+            lexer = env.config.highlight_language\n+        else:\n+            lexer = 'python'\n+        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n+        # split the code into lines\n+        lines = highlighted.splitlines()\n+        # split off wrap markup from the first line of the actual code\n+        before, after = lines[0].split('<pre>')\n+        lines[0:1] = [before + '<pre>', after]\n+        # nothing to do, if no function or class found\n+        if not tags:\n+            continue\n+        higher = sorted(used, key=lambda x: x.split('.'))\n+        # now that we have code lines (starting at index 1), insert anchors for\n+        # the collected tags (HACK: this only works if the tag boundaries are\n+        # properly nested!)\n+        max_index = len(lines) - 1\n+        for name, docname in higher:\n+            type, start, end = tags[name]\n+            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n+            lines[start] = (\n+                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n+                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n+                lines[start])\n+            lines[min(end, max_index)] += '</div>'\n+        # try to find parents (for submodules)\n+        parents = []\n+        parent = modname\n+        while '.' in parent:\n+            parent = parent.rsplit('.', 1)[0]\n+            if parent in modnames:\n+                parents.append({\n+                    'link': urito(pagename,\n+                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n+                    'title': parent})\n+        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n+                        'title': _('Module code')})\n+        parents.reverse()\n+        # putting it all together\n+        context = {\n+            'parents': parents,\n+            'title': modname,\n+            'body': (_('<h1>Source code for %s</h1>') % modname +\n+                     '\\n'.join(lines)),\n+        }\n+        yield (pagename, context, 'page.html')\n+\n+    if not modnames:\n+        return\n+\n+    html = ['\\n']\n+    # the stack logic is needed for using nested lists for submodules\n+    stack = ['']\n+    for modname in sorted(modnames):\n+        if modname.startswith('_'):\n+            continue\n+        parts = modname.split('.')\n+        levels = len(parts)\n+        for i in range(levels):\n+            level = '.'.join(parts[:i + 1])\n+            if level not in stack:\n+                stack.append(level)\n+                if i < levels - 1:\n+                    # submodule\n+                    html.append('<ul>')\n+                    html.append('<li><strong>%s</strong></li>' % parts[i])\n+                else:\n+                    # actual module\n+                    pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+                    link = urito('', pagename)\n+                    html.append('<li><a href=\"%s\">%s</a></li>\\n' % (link, modname))\n+            else:\n+                break\n+\n+        # remove stack entries we're no longer under\n+        for i in range(stack.index(level) + 1, len(stack)):\n+            if i < len(stack) - 1:\n+                html.append('</ul>')\n+            stack.pop()\n+    html.append('</ul>' * (len(stack) - 1))\n+    context = {\n+        'title': _('Overview: module code'),\n+        'body': '<h1>%s</h1>%s' % (_('All modules for which code is available'),\n+                                   ''.join(html)),\n+    }\n+\n+    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n \n     def has_tag(modname: str, fullname: str, docname: str, refname: str) -> bool:\n         entry = env._viewcode_modules.get(modname, None)  # type: ignore\n@@ -178,8 +289,11 @@ def should_generate_module_page(app: Sphinx, modname: str) -> bool:\n     return True\n \n \n+\n def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n     env = app.builder.env\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n     if not hasattr(env, '_viewcode_modules'):\n         return\n     highlighter = app.builder.highlighter  # type: ignore\n",
    "variant_4": "diff --git a/sphinx/ext/viewcode.py b/sphinx/ext/viewcode.py\nindex a7d52a91c..4c999f092 100644\n--- a/sphinx/ext/viewcode.py\n+++ b/sphinx/ext/viewcode.py\n@@ -56,8 +56,107 @@ def doctree_read(app: Sphinx, doctree: Node) -> None:\n         env._viewcode_modules = {}  # type: ignore\n     if app.builder.name == \"singlehtml\":\n         return\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.builder.env\n     if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n         return\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    if not isinstance(app.builder, StandaloneHTMLBuilder):\n+        return\n+    highlighter = app.builder.highlighter  # type: ignore\n+    urito = app.builder.get_relative_uri\n+\n+    modnames = set(env._viewcode_modules)  # type: ignore\n+\n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),  # type: ignore\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),  # type: ignore\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+        code, tags, used, refname = entry\n+        # construct a page name for the highlighted source\n+        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        # highlight the source using the builder's highlighter\n+        if env.config.highlight_language in ('python3', 'default', 'none'):\n+            lexer = env.config.highlight_language\n+        else:\n+            lexer = 'python'\n+        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n+        # split the code into lines\n+        lines = highlighted.splitlines()\n+        # split off wrap markup from the first line of the actual code\n+        before, after = lines[0].split('<pre>')\n+        lines[0:1] = [before + '<pre>', after]\n+        # nothing to do for the last line; it always starts with </pre> anyway\n+        # now that we have code lines (starting at index 1), insert anchors for\n+        # the collected tags (HACK: this only works if the tag boundaries are\n+        # properly nested!)\n+        max_index = len(lines) - 1\n+        for name, docname in used.items():\n+            type, start, end = tags[name]\n+            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n+            lines[start] = (\n+                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n+                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n+                lines[start])\n+            lines[min(end, max_index)] += '</div>'\n+        # try to find parents (for submodules)\n+        parents = []\n+        parent = modname\n+        while '.' in parent:\n+            parent = parent.rsplit('.', 1)[0]\n+            if parent in modnames:\n+                parents.append({\n+                    'link': urito(pagename,\n+                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n+                    'title': parent})\n+        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n+                        'title': _('Module code')})\n+        parents.reverse()\n+        # putting it all together\n+        context = {\n+            'parents': parents,\n+            'title': modname,\n+            'body': (_('<h1>Source code for %s</h1>') % modname +\n+                     '\\n'.join(lines)),\n+        }\n+        yield (pagename, context, 'page.html')\n+\n+    if not modnames:\n+        return\n+\n+    html = ['\\n']\n+    # the stack logic is needed for using nested lists for submodules\n+    stack = ['']\n+    for modname in sorted(modnames):\n+        if modname.startswith(stack[-1]):\n+            stack.append(modname + '.')\n+            html.append('<ul>')\n+        else:\n+            stack.pop()\n+            while not modname.startswith(stack[-1]):\n+                stack.pop()\n+                html.append('</ul>')\n+            stack.append(modname + '.')\n+            html.append('<ul>')\n+\n+        html.append('<li><a href=\"%s\">%s</a></li>\\n' % (\n+            urito(posixpath.join(OUTPUT_DIRNAME, 'index'),\n+                  posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))),\n+            modname))\n+\n+    html.append('</ul>' * (len(stack) - 1))\n+    context = {\n+        'title': _('Overview: module code'),\n+        'body': (_('<h1>All modules for which code is available</h1>') +\n+                 ''.join(html)),\n+    }\n+\n+    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n \n     def has_tag(modname: str, fullname: str, docname: str, refname: str) -> bool:\n         entry = env._viewcode_modules.get(modname, None)  # type: ignore\n@@ -178,8 +277,11 @@ def should_generate_module_page(app: Sphinx, modname: str) -> bool:\n     return True\n \n \n+\n def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n     env = app.builder.env\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n     if not hasattr(env, '_viewcode_modules'):\n         return\n     highlighter = app.builder.highlighter  # type: ignore\n",
    "variant_5": "diff --git a/sphinx/ext/viewcode.py b/sphinx/ext/viewcode.py\nindex a7d52a91c..f4225d595 100644\n--- a/sphinx/ext/viewcode.py\n+++ b/sphinx/ext/viewcode.py\n@@ -56,8 +56,106 @@ def doctree_read(app: Sphinx, doctree: Node) -> None:\n         env._viewcode_modules = {}  # type: ignore\n     if app.builder.name == \"singlehtml\":\n         return\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.builder.env\n     if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n         return\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    if not isinstance(app.builder, StandaloneHTMLBuilder):\n+        return\n+    highlighter = app.builder.highlighter  # type: ignore\n+    urito = app.builder.get_relative_uri\n+\n+    modnames = set(env._viewcode_modules)  # type: ignore\n+\n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),  # type: ignore\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),  # type: ignore\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+        code, tags, used, refname = entry\n+        # construct a page name for the highlighted source\n+        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        # highlight the source using the builder's highlighter\n+        if env.config.highlight_language in ('python3', 'default', 'none'):\n+            lexer = env.config.highlight_language\n+        else:\n+            lexer = 'python'\n+        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n+        # split the code into lines\n+        lines = highlighted.splitlines()\n+        # split off wrap markup from the first line of the actual code\n+        before, after = lines[0].split('<pre>')\n+        lines[0:1] = [before + '<pre>', after]\n+        # nothing to do if only function names are highlighted\n+        if set(tags) == {''} or not tags:\n+            continue\n+        elif len(lines) != len(tags):\n+            logger.warning(__('failed to format %s: %s lines vs %s tags'), modname,\n+                           len(lines), len(tags), location=pagename)\n+            continue\n+\n+        # insert anchors before the lines that are referenced\n+        for i, tag in enumerate(tags):\n+            if tag:\n+                lines[i] = ('<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n+                            'href=\"#%s\">%s</a>' % (tag, tag, _('[docs]'))) + lines[i]\n+        # try to find parents (for submodules)\n+        parents = []\n+        parent = modname\n+        while '.' in parent:\n+            parent = parent.rsplit('.', 1)[0]\n+            if parent in modnames:\n+                parents.append({\n+                    'link': urito(pagename,\n+                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n+                    'title': parent})\n+        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n+                        'title': _('Module code')})\n+        parents.reverse()\n+        # putting it all together\n+        context = {\n+            'parents': parents,\n+            'title': modname,\n+            'body': (_('<h1>Source code for %s</h1>') % modname +\n+                     '\\n'.join(lines)),\n+        }\n+        yield (pagename, context, 'page.html')\n+\n+    if not modnames:\n+        return\n+\n+    html = ['\\n']\n+    # the stack logic is needed for using nested lists for submodules\n+    stack = ['']\n+    for modname in sorted(modnames):\n+        if modname.startswith('_'):\n+            continue\n+        parts = modname.split('.')\n+        levels = len(parts)\n+        for i in range(levels):\n+            level = '.'.join(parts[:i + 1])\n+            if level not in stack:\n+                stack.append(level)\n+                indent = 4 * (i + 1)\n+                html.append('%s<li><a href=\"%s\">%s</a></li>\\n' % (\n+                    ' ' * indent,\n+                    urito('index', posixpath.join(OUTPUT_DIRNAME, level.replace('.', '/'))),\n+                    level))\n+\n+    html.append('\\n')\n+\n+    context = {\n+        'title': _('Overview: module code'),\n+        'body': (_('<h1>All modules for which code is available</h1>') +\n+                 ''.join(html)),\n+    }\n+\n+    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n \n     def has_tag(modname: str, fullname: str, docname: str, refname: str) -> bool:\n         entry = env._viewcode_modules.get(modname, None)  # type: ignore\n@@ -178,8 +276,11 @@ def should_generate_module_page(app: Sphinx, modname: str) -> bool:\n     return True\n \n \n+\n def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n     env = app.builder.env\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n     if not hasattr(env, '_viewcode_modules'):\n         return\n     highlighter = app.builder.highlighter  # type: ignore\n",
    "variant_6": "diff --git a/sphinx/ext/viewcode.py b/sphinx/ext/viewcode.py\nindex a7d52a91c..c0e078973 100644\n--- a/sphinx/ext/viewcode.py\n+++ b/sphinx/ext/viewcode.py\n@@ -56,8 +56,16 @@ def doctree_read(app: Sphinx, doctree: Node) -> None:\n         env._viewcode_modules = {}  # type: ignore\n     if app.builder.name == \"singlehtml\":\n         return\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.builder.env\n     if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n         return\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    if not isinstance(app.builder, StandaloneHTMLBuilder):\n+        return\n+    highlighter = app.builder.highlighter  # type: ignore\n \n     def has_tag(modname: str, fullname: str, docname: str, refname: str) -> bool:\n         entry = env._viewcode_modules.get(modname, None)  # type: ignore\n@@ -178,8 +186,11 @@ def should_generate_module_page(app: Sphinx, modname: str) -> bool:\n     return True\n \n \n+\n def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n     env = app.builder.env\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n     if not hasattr(env, '_viewcode_modules'):\n         return\n     highlighter = app.builder.highlighter  # type: ignore\n",
    "variant_7": "diff --git a/sphinx/ext/viewcode.py b/sphinx/ext/viewcode.py\nindex a7d52a91c..fd360aab7 100644\n--- a/sphinx/ext/viewcode.py\n+++ b/sphinx/ext/viewcode.py\n@@ -56,8 +56,108 @@ def doctree_read(app: Sphinx, doctree: Node) -> None:\n         env._viewcode_modules = {}  # type: ignore\n     if app.builder.name == \"singlehtml\":\n         return\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.builder.env\n     if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n         return\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    if not isinstance(app.builder, StandaloneHTMLBuilder):\n+        return\n+    highlighter = app.builder.highlighter  # type: ignore\n+    urito = app.builder.get_relative_uri\n+\n+    modnames = set(env._viewcode_modules)  # type: ignore\n+\n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),  # type: ignore\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),  # type: ignore\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+        if not isinstance(entry, tuple):\n+            continue\n+        code, tags, used, refname = entry\n+        # construct a page name for the highlighted source\n+        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        # highlight the source using the builder's highlighter\n+        if env.config.highlight_language in ('python3', 'default', 'none'):\n+            lexer = env.config.highlight_language\n+        else:\n+            lexer = 'python'\n+        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n+        # split the code into lines\n+        lines = highlighted.splitlines()\n+        # split off wrap markup from the first line of the actual code\n+        before, after = lines[0].split('<pre>')\n+        lines[0:1] = [before + '<pre>', after]\n+        # nothing to do for the last line; it always starts with </pre> anyway\n+        # now that we have code lines (starting at index 1), insert anchors for\n+        # the collected tags (HACK: this only works if the tag boundaries are\n+        # properly nested!)\n+        max_index = len(lines) - 1\n+        for name, docname in used.items():\n+            type, start, end = tags[name]\n+            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n+            lines[start] = (\n+                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n+                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n+                lines[start])\n+            lines[min(end, max_index)] += '</div>'\n+        # try to find parents (for submodules)\n+        parents = []\n+        parent = modname\n+        while '.' in parent:\n+            parent = parent.rsplit('.', 1)[0]\n+            if parent in modnames:\n+                parents.append({\n+                    'link': urito(pagename,\n+                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n+                    'title': parent})\n+        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n+                        'title': _('Module code')})\n+        parents.reverse()\n+        # putting it all together\n+        context = {\n+            'parents': parents,\n+            'title': modname,\n+            'body': (_('<h1>Source code for %s</h1>') % modname +\n+                     '\\n'.join(lines)),\n+        }\n+        yield (pagename, context, 'page.html')\n+\n+    if not modnames:\n+        return\n+\n+    html = ['\\n']\n+    # the stack logic is needed for using nested lists for submodules\n+    stack = ['']\n+    for modname in sorted(modnames):\n+        if modname.startswith(stack[-1]):\n+            stack.append(modname + '.')\n+            html.append('<ul>')\n+        else:\n+            stack.pop()\n+            while not modname.startswith(stack[-1]):\n+                stack.pop()\n+                html.append('</ul>')\n+            stack.append(modname + '.')\n+            html.append('<ul>')\n+\n+        urlpath = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        html.append('<li><a href=\"%s\">%s</a></li>\\n' % (\n+            urito(posixpath.join(OUTPUT_DIRNAME, 'index'), urlpath),\n+            modname))\n+    html.append('</ul>' * (len(stack) - 1))\n+    context = {\n+        'title': _('Overview: module code'),\n+        'body': (_('<h1>All modules for which code is available</h1>') +\n+                 ''.join(html)),\n+    }\n+\n+    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n \n     def has_tag(modname: str, fullname: str, docname: str, refname: str) -> bool:\n         entry = env._viewcode_modules.get(modname, None)  # type: ignore\n@@ -178,8 +278,11 @@ def should_generate_module_page(app: Sphinx, modname: str) -> bool:\n     return True\n \n \n+\n def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n     env = app.builder.env\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n     if not hasattr(env, '_viewcode_modules'):\n         return\n     highlighter = app.builder.highlighter  # type: ignore\n",
    "variant_8": "diff --git a/sphinx/ext/viewcode.py b/sphinx/ext/viewcode.py\nindex a7d52a91c..c0544033c 100644\n--- a/sphinx/ext/viewcode.py\n+++ b/sphinx/ext/viewcode.py\n@@ -56,8 +56,120 @@ def doctree_read(app: Sphinx, doctree: Node) -> None:\n         env._viewcode_modules = {}  # type: ignore\n     if app.builder.name == \"singlehtml\":\n         return\n+\n+def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n+    env = app.builder.env\n     if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n         return\n+    if not hasattr(env, '_viewcode_modules'):\n+        return\n+    if not isinstance(app.builder, StandaloneHTMLBuilder):\n+        return\n+    highlighter = app.builder.highlighter  # type: ignore\n+    urito = app.builder.get_relative_uri\n+\n+    modnames = set(env._viewcode_modules)  # type: ignore\n+\n+    for modname, entry in status_iterator(\n+            sorted(env._viewcode_modules.items()),  # type: ignore\n+            __('highlighting module code... '), \"blue\",\n+            len(env._viewcode_modules),  # type: ignore\n+            app.verbosity, lambda x: x[0]):\n+        if not entry:\n+            continue\n+        if not should_generate_module_page(app, modname):\n+            continue\n+\n+        code, tags, used, refname = entry\n+        # construct a page name for the highlighted source\n+        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))\n+        # highlight the source using the builder's highlighter\n+        if env.config.highlight_language in ('python3', 'default', 'none'):\n+            lexer = env.config.highlight_language\n+        else:\n+            lexer = 'python'\n+        highlighted = highlighter.highlight_block(code, lexer, linenos=False)\n+        # split the code into lines\n+        lines = highlighted.splitlines()\n+        # split off wrap markup from the first line of the actual code\n+        before, after = lines[0].split('<pre>')\n+        lines[0:1] = [before + '<pre>', after]\n+        # nothing to do for the last line; it always starts with </pre> anyway\n+        # now that we have code lines (starting at index 1), insert anchors for\n+        # the collected tags (HACK: this only works if the tag boundaries are\n+        # properly nested!)\n+        max_index = len(lines) - 1\n+        for name, docname in used.items():\n+            type, start, end = tags[name]\n+            backlink = urito(pagename, docname) + '#' + refname + '.' + name\n+            lines[start] = (\n+                '<div class=\"viewcode-block\" id=\"%s\"><a class=\"viewcode-back\" '\n+                'href=\"%s\">%s</a>' % (name, backlink, _('[docs]')) +\n+                lines[start])\n+            lines[min(end, max_index)] += '</div>'\n+        # try to find parents (for submodules)\n+        parents = []\n+        parent = modname\n+        while '.' in parent:\n+            parent = parent.rsplit('.', 1)[0]\n+            if parent in modnames:\n+                parents.append({\n+                    'link': urito(pagename,\n+                                  posixpath.join(OUTPUT_DIRNAME, parent.replace('.', '/'))),\n+                    'title': parent})\n+        parents.append({'link': urito(pagename, posixpath.join(OUTPUT_DIRNAME, 'index')),\n+                        'title': _('Module code')})\n+        parents.reverse()\n+        # putting it all together\n+        context = {\n+            'parents': parents,\n+            'title': modname,\n+            'body': (_('<h1>Source code for %s</h1>') % modname +\n+                     '\\n'.join(lines)),\n+        }\n+        yield (pagename, context, 'page.html')\n+\n+    if not modnames:\n+        return\n+\n+    html = ['\\n']\n+    # the stack logic is needed for using nested lists for submodules\n+    stack = ['']\n+    for modname in sorted(modnames):\n+        if not should_generate_module_page(app, modname):\n+            continue\n+\n+        parts = modname.split('.')\n+        levels = len(parts)\n+        # remove stack entries equal or deeper than this level\n+        stack = stack[:levels]\n+        # add new stack entries equal or deeper than this level\n+        stack.extend([''] * (levels - len(stack)))\n+        level = levels - 1\n+        if stack[level]:\n+            html.append('</ul>')\n+        if level == 0:\n+            html.append('<li><a href=\"%s\">%s</a></li>\\n' % (\n+                urito('index', posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))),\n+                modname))\n+        else:\n+            html.append('<li>%s<ul>' % parts[-1])\n+            html.append('<li><a href=\"%s\">%s</a></li>\\n' % (\n+                urito('index', posixpath.join(OUTPUT_DIRNAME, modname.replace('.', '/'))),\n+                modname))\n+        stack[level] = True\n+    for i in range(len(stack) - 1):\n+        if stack[i + 1]:\n+            html.append('</ul>')\n+    html.append('\\n')\n+\n+    context = {\n+        'title': _('Overview: module code'),\n+        'body': (_('<h1>All modules for which code is available</h1>') +\n+                 ''.join(html)),\n+    }\n+\n+    yield (posixpath.join(OUTPUT_DIRNAME, 'index'), context, 'page.html')\n \n     def has_tag(modname: str, fullname: str, docname: str, refname: str) -> bool:\n         entry = env._viewcode_modules.get(modname, None)  # type: ignore\n@@ -178,8 +290,11 @@ def should_generate_module_page(app: Sphinx, modname: str) -> bool:\n     return True\n \n \n+\n def collect_pages(app: Sphinx) -> Generator[Tuple[str, Dict[str, Any], str], None, None]:\n     env = app.builder.env\n+    if app.builder.name.startswith(\"epub\") and not env.config.viewcode_enable_epub:\n+        return\n     if not hasattr(env, '_viewcode_modules'):\n         return\n     highlighter = app.builder.highlighter  # type: ignore\n"
  }
}