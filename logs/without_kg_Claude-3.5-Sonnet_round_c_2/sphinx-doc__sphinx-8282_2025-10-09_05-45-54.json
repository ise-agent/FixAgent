{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/sphinx/sphinx/ext/autodoc/__init__.py lines 1241-1272)": "\ndef format_signature(self, **kwargs: Any) -> str:\n    sigs = []\n    if self.env.config.autodoc_typehints in ('none', 'description'):\n        kwargs.setdefault('show_annotation', False)\n    \n    if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:\n        # Use signatures for overloaded functions instead of the implementation function.\n        overloaded = True\n    else:\n        overloaded = False\n        sig = super().format_signature(**kwargs)\n        sigs.append(sig)\n\n    if inspect.is_singledispatch_function(self.object):\n        # append signature of singledispatch'ed functions\n        for typ, func in self.object.registry.items():\n            if typ is object:\n                pass  # default implementation. skipped.\n            else:\n                self.annotate_to_first_argument(func, typ)\n\n                documenter = FunctionDocumenter(self.directive, '')\n                documenter.object = func\n                documenter.objpath = [None]\n                sigs.append(documenter.format_signature())\n    if overloaded:\n        __globals__ = safe_getattr(self.object, '__globals__', {})\n        for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n            overload = evaluate_signature(overload, __globals__,\n                                          self.env.config.autodoc_type_aliases)\n\n            sig = stringify_signature(overload, **kwargs)\n            sigs.append(sig)\n\n    return \"\\n\".join(sigs)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/sphinx/sphinx/ext/autodoc/__init__.py lines 1241-1272)": [
      "\n    def format_signature(self, **kwargs: Any) -> str:\n        sigs = []\n        if self.env.config.autodoc_typehints in ('none', 'description'):\n            kwargs.setdefault('show_annotation', False)\n        if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:\n            # Use signatures for overloaded functions instead of the implementation function.\n            overloaded = True\n        else:\n            overloaded = False\n            sig = super().format_signature(**kwargs)\n            sigs.append(sig)\n\n        if inspect.is_singledispatch_function(self.object):\n            # append signature of singledispatch'ed functions\n            for typ, func in self.object.registry.items():\n                if typ is object:\n                    pass  # default implementation. skipped.\n                else:\n                    self.annotate_to_first_argument(func, typ)\n\n                    documenter = FunctionDocumenter(self.directive, '')\n                    documenter.object = func\n                    documenter.objpath = [None]\n                    sigs.append(documenter.format_signature())\n        if overloaded:\n            __globals__ = safe_getattr(self.object, '__globals__', {})\n            for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                overload = evaluate_signature(overload, __globals__,\n                                              self.env.config.autodoc_type_aliases)\n\n                sig = stringify_signature(overload, **kwargs)\n                sigs.append(sig)\n\n        return \"\\n\".join(sigs)\n",
      "\ndef format_signature(self, **kwargs: Any) -> str:\n    sigs = []\n    if self.env.config.autodoc_typehints in ('none', 'description'):\n        kwargs.setdefault('show_annotation', False)\n    \n    if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:\n        # Use signatures for overloaded functions instead of the implementation function.\n        overloaded = True\n    else:\n        overloaded = False\n        sig = super().format_signature(**kwargs)\n        sigs.append(sig)\n\n    if inspect.is_singledispatch_function(self.object):\n        # append signature of singledispatch'ed functions\n        for typ, func in self.object.registry.items():\n            if typ is object:\n                pass  # default implementation. skipped.\n            else:\n                self.annotate_to_first_argument(func, typ)\n\n                documenter = FunctionDocumenter(self.directive, '')\n                documenter.object = func\n                documenter.objpath = [None]\n                sigs.append(documenter.format_signature())\n    if overloaded:\n        __globals__ = safe_getattr(self.object, '__globals__', {})\n        for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n            overload = evaluate_signature(overload, __globals__,\n                                          self.env.config.autodoc_type_aliases)\n\n            sig = stringify_signature(overload, **kwargs)\n            sigs.append(sig)\n\n    return \"\\n\".join(sigs)\n",
      "\n    def format_signature(self, **kwargs: Any) -> str:\n        sigs = []\n        if self.env.config.autodoc_typehints in ('none', 'description'):\n            kwargs.setdefault('show_annotation', False)\n        if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:\n            # Use signatures for overloaded functions instead of the implementation function.\n            overloaded = True\n        else:\n            overloaded = False\n            sig = super().format_signature(**kwargs)\n            sigs.append(sig)\n\n        if inspect.is_singledispatch_function(self.object):\n            # append signature of singledispatch'ed functions\n            for typ, func in self.object.registry.items():\n                if typ is object:\n                    pass  # default implementation. skipped.\n                else:\n                    self.annotate_to_first_argument(func, typ)\n\n                    documenter = FunctionDocumenter(self.directive, '')\n                    documenter.object = func\n                    documenter.objpath = [None]\n                    sigs.append(documenter.format_signature())\n        if overloaded:\n            __globals__ = safe_getattr(self.object, '__globals__', {})\n            for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                overload = evaluate_signature(overload, __globals__,\n                                              self.env.config.autodoc_type_aliases)\n\n                sig = stringify_signature(overload, **kwargs)\n                sigs.append(sig)\n\n        return \"\\n\".join(sigs)\n",
      "\n    def format_signature(self, **kwargs: Any) -> str:\n        sigs = []\n        if self.env.config.autodoc_typehints in ('none', 'description'):\n            kwargs.setdefault('show_annotation', False)\n        if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:\n            # Use signatures for overloaded functions instead of the implementation function.\n            overloaded = True\n        else:\n            overloaded = False\n            sig = super().format_signature(**kwargs)\n            sigs.append(sig)\n\n        if inspect.is_singledispatch_function(self.object):\n            # append signature of singledispatch'ed functions\n            for typ, func in self.object.registry.items():\n                if typ is object:\n                    pass  # default implementation. skipped.\n                else:\n                    self.annotate_to_first_argument(func, typ)\n\n                    documenter = FunctionDocumenter(self.directive, '')\n                    documenter.object = func\n                    documenter.objpath = [None]\n                    sigs.append(documenter.format_signature())\n        if overloaded:\n            __globals__ = safe_getattr(self.object, '__globals__', {})\n            for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                overload = evaluate_signature(overload, __globals__,\n                                              self.env.config.autodoc_type_aliases)\n\n                sig = stringify_signature(overload, **kwargs)\n                sigs.append(sig)\n\n        return \"\\n\".join(sigs)\n",
      "\n    def format_signature(self, **kwargs: Any) -> str:\n        sigs = []\n        if self.env.config.autodoc_typehints in ('none', 'description'):\n            kwargs.setdefault('show_annotation', False)\n        if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:\n            # Use signatures for overloaded functions instead of the implementation function.\n            overloaded = True\n        else:\n            overloaded = False\n            sig = super().format_signature(**kwargs)\n            sigs.append(sig)\n\n        if inspect.is_singledispatch_function(self.object):\n            # append signature of singledispatch'ed functions\n            for typ, func in self.object.registry.items():\n                if typ is object:\n                    pass  # default implementation. skipped.\n                else:\n                    self.annotate_to_first_argument(func, typ)\n\n                    documenter = FunctionDocumenter(self.directive, '')\n                    documenter.object = func\n                    documenter.objpath = [None]\n                    sigs.append(documenter.format_signature())\n        if overloaded:\n            __globals__ = safe_getattr(self.object, '__globals__', {})\n            for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                overload = evaluate_signature(overload, __globals__,\n                                              self.env.config.autodoc_type_aliases)\n\n                sig = stringify_signature(overload, **kwargs)\n                sigs.append(sig)\n\n        return \"\\n\".join(sigs)\n",
      "\n    def format_signature(self, **kwargs: Any) -> str:\n        sigs = []\n        if self.env.config.autodoc_typehints in ('none', 'description'):\n            kwargs.setdefault('show_annotation', False)\n        if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:\n            # Use signatures for overloaded functions instead of the implementation function.\n            overloaded = True\n        else:\n            overloaded = False\n            sig = super().format_signature(**kwargs)\n            sigs.append(sig)\n\n        if inspect.is_singledispatch_function(self.object):\n            # append signature of singledispatch'ed functions\n            for typ, func in self.object.registry.items():\n                if typ is object:\n                    pass  # default implementation. skipped.\n                else:\n                    self.annotate_to_first_argument(func, typ)\n\n                    documenter = FunctionDocumenter(self.directive, '')\n                    documenter.object = func\n                    documenter.objpath = [None]\n                    sigs.append(documenter.format_signature())\n        if overloaded:\n            __globals__ = safe_getattr(self.object, '__globals__', {})\n            for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                overload = evaluate_signature(overload, __globals__,\n                                              self.env.config.autodoc_type_aliases)\n\n                sig = stringify_signature(overload, **kwargs)\n                sigs.append(sig)\n\n        return \"\\n\".join(sigs)\n",
      "\n    def format_signature(self, **kwargs: Any) -> str:\n        sigs = []\n        if self.env.config.autodoc_typehints in ('none', 'description'):\n            kwargs.setdefault('show_annotation', False)\n        if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:\n            # Use signatures for overloaded functions instead of the implementation function.\n            overloaded = True\n        else:\n            overloaded = False\n            sig = super().format_signature(**kwargs)\n            sigs.append(sig)\n\n        if inspect.is_singledispatch_function(self.object):\n            # append signature of singledispatch'ed functions\n            for typ, func in self.object.registry.items():\n                if typ is object:\n                    pass  # default implementation. skipped.\n                else:\n                    self.annotate_to_first_argument(func, typ)\n\n                    documenter = FunctionDocumenter(self.directive, '')\n                    documenter.object = func\n                    documenter.objpath = [None]\n                    sigs.append(documenter.format_signature())\n        if overloaded:\n            __globals__ = safe_getattr(self.object, '__globals__', {})\n            for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                overload = evaluate_signature(overload, __globals__,\n                                              self.env.config.autodoc_type_aliases)\n\n                sig = stringify_signature(overload, **kwargs)\n                sigs.append(sig)\n\n        return \"\\n\".join(sigs)\n",
      "\n    def format_signature(self, **kwargs: Any) -> str:\n        sigs = []\n        if self.env.config.autodoc_typehints in ('none', 'description'):\n            kwargs.setdefault('show_annotation', False)\n        \n        if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:\n            # Use signatures for overloaded functions instead of the implementation function.\n            overloaded = True\n        else:\n            overloaded = False\n            sig = super().format_signature(**kwargs)\n            sigs.append(sig)\n\n        if inspect.is_singledispatch_function(self.object):\n            # append signature of singledispatch'ed functions\n            for typ, func in self.object.registry.items():\n                if typ is object:\n                    pass  # default implementation. skipped.\n                else:\n                    self.annotate_to_first_argument(func, typ)\n\n                    documenter = FunctionDocumenter(self.directive, '')\n                    documenter.object = func\n                    documenter.objpath = [None]\n                    sigs.append(documenter.format_signature())\n        if overloaded:\n            __globals__ = safe_getattr(self.object, '__globals__', {})\n            for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                overload = evaluate_signature(overload, __globals__,\n                                              self.env.config.autodoc_type_aliases)\n\n                sig = stringify_signature(overload, **kwargs)\n                sigs.append(sig)\n\n        return \"\\n\".join(sigs)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 978fd5df8..a3c7a8c31 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1238,8 +1238,11 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n         if inspect.iscoroutinefunction(self.object):\n             self.add_line('   :async:', sourcename)\n \n+\n     def format_signature(self, **kwargs: Any) -> str:\n         sigs = []\n+        if self.env.config.autodoc_typehints in ('none', 'description'):\n+            kwargs.setdefault('show_annotation', False)\n         if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:\n             # Use signatures for overloaded functions instead of the implementation function.\n             overloaded = True\n",
    "variant_0": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 978fd5df8..7e897c72b 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1238,38 +1238,42 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n         if inspect.iscoroutinefunction(self.object):\n             self.add_line('   :async:', sourcename)\n \n-    def format_signature(self, **kwargs: Any) -> str:\n-        sigs = []\n-        if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:\n-            # Use signatures for overloaded functions instead of the implementation function.\n-            overloaded = True\n-        else:\n-            overloaded = False\n-            sig = super().format_signature(**kwargs)\n-            sigs.append(sig)\n \n-        if inspect.is_singledispatch_function(self.object):\n-            # append signature of singledispatch'ed functions\n-            for typ, func in self.object.registry.items():\n-                if typ is object:\n-                    pass  # default implementation. skipped.\n-                else:\n-                    self.annotate_to_first_argument(func, typ)\n-\n-                    documenter = FunctionDocumenter(self.directive, '')\n-                    documenter.object = func\n-                    documenter.objpath = [None]\n-                    sigs.append(documenter.format_signature())\n-        if overloaded:\n-            __globals__ = safe_getattr(self.object, '__globals__', {})\n-            for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n-                overload = evaluate_signature(overload, __globals__,\n-                                              self.env.config.autodoc_type_aliases)\n-\n-                sig = stringify_signature(overload, **kwargs)\n-                sigs.append(sig)\n+def format_signature(self, **kwargs: Any) -> str:\n+    sigs = []\n+    if self.env.config.autodoc_typehints in ('none', 'description'):\n+        kwargs.setdefault('show_annotation', False)\n+    \n+    if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:\n+        # Use signatures for overloaded functions instead of the implementation function.\n+        overloaded = True\n+    else:\n+        overloaded = False\n+        sig = super().format_signature(**kwargs)\n+        sigs.append(sig)\n+\n+    if inspect.is_singledispatch_function(self.object):\n+        # append signature of singledispatch'ed functions\n+        for typ, func in self.object.registry.items():\n+            if typ is object:\n+                pass  # default implementation. skipped.\n+            else:\n+                self.annotate_to_first_argument(func, typ)\n+\n+                documenter = FunctionDocumenter(self.directive, '')\n+                documenter.object = func\n+                documenter.objpath = [None]\n+                sigs.append(documenter.format_signature())\n+    if overloaded:\n+        __globals__ = safe_getattr(self.object, '__globals__', {})\n+        for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n+            overload = evaluate_signature(overload, __globals__,\n+                                          self.env.config.autodoc_type_aliases)\n+\n+            sig = stringify_signature(overload, **kwargs)\n+            sigs.append(sig)\n \n-        return \"\\n\".join(sigs)\n+    return \"\\n\".join(sigs)\n \n     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:\n         \"\"\"Annotate type hint to the first argument of function if needed.\"\"\"\n",
    "variant_1": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 978fd5df8..a3c7a8c31 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1238,8 +1238,11 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n         if inspect.iscoroutinefunction(self.object):\n             self.add_line('   :async:', sourcename)\n \n+\n     def format_signature(self, **kwargs: Any) -> str:\n         sigs = []\n+        if self.env.config.autodoc_typehints in ('none', 'description'):\n+            kwargs.setdefault('show_annotation', False)\n         if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:\n             # Use signatures for overloaded functions instead of the implementation function.\n             overloaded = True\n",
    "variant_2": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 978fd5df8..7e897c72b 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1238,38 +1238,42 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n         if inspect.iscoroutinefunction(self.object):\n             self.add_line('   :async:', sourcename)\n \n-    def format_signature(self, **kwargs: Any) -> str:\n-        sigs = []\n-        if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:\n-            # Use signatures for overloaded functions instead of the implementation function.\n-            overloaded = True\n-        else:\n-            overloaded = False\n-            sig = super().format_signature(**kwargs)\n-            sigs.append(sig)\n \n-        if inspect.is_singledispatch_function(self.object):\n-            # append signature of singledispatch'ed functions\n-            for typ, func in self.object.registry.items():\n-                if typ is object:\n-                    pass  # default implementation. skipped.\n-                else:\n-                    self.annotate_to_first_argument(func, typ)\n-\n-                    documenter = FunctionDocumenter(self.directive, '')\n-                    documenter.object = func\n-                    documenter.objpath = [None]\n-                    sigs.append(documenter.format_signature())\n-        if overloaded:\n-            __globals__ = safe_getattr(self.object, '__globals__', {})\n-            for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n-                overload = evaluate_signature(overload, __globals__,\n-                                              self.env.config.autodoc_type_aliases)\n-\n-                sig = stringify_signature(overload, **kwargs)\n-                sigs.append(sig)\n+def format_signature(self, **kwargs: Any) -> str:\n+    sigs = []\n+    if self.env.config.autodoc_typehints in ('none', 'description'):\n+        kwargs.setdefault('show_annotation', False)\n+    \n+    if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:\n+        # Use signatures for overloaded functions instead of the implementation function.\n+        overloaded = True\n+    else:\n+        overloaded = False\n+        sig = super().format_signature(**kwargs)\n+        sigs.append(sig)\n+\n+    if inspect.is_singledispatch_function(self.object):\n+        # append signature of singledispatch'ed functions\n+        for typ, func in self.object.registry.items():\n+            if typ is object:\n+                pass  # default implementation. skipped.\n+            else:\n+                self.annotate_to_first_argument(func, typ)\n+\n+                documenter = FunctionDocumenter(self.directive, '')\n+                documenter.object = func\n+                documenter.objpath = [None]\n+                sigs.append(documenter.format_signature())\n+    if overloaded:\n+        __globals__ = safe_getattr(self.object, '__globals__', {})\n+        for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n+            overload = evaluate_signature(overload, __globals__,\n+                                          self.env.config.autodoc_type_aliases)\n+\n+            sig = stringify_signature(overload, **kwargs)\n+            sigs.append(sig)\n \n-        return \"\\n\".join(sigs)\n+    return \"\\n\".join(sigs)\n \n     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:\n         \"\"\"Annotate type hint to the first argument of function if needed.\"\"\"\n",
    "variant_3": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 978fd5df8..a3c7a8c31 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1238,8 +1238,11 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n         if inspect.iscoroutinefunction(self.object):\n             self.add_line('   :async:', sourcename)\n \n+\n     def format_signature(self, **kwargs: Any) -> str:\n         sigs = []\n+        if self.env.config.autodoc_typehints in ('none', 'description'):\n+            kwargs.setdefault('show_annotation', False)\n         if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:\n             # Use signatures for overloaded functions instead of the implementation function.\n             overloaded = True\n",
    "variant_4": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 978fd5df8..a3c7a8c31 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1238,8 +1238,11 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n         if inspect.iscoroutinefunction(self.object):\n             self.add_line('   :async:', sourcename)\n \n+\n     def format_signature(self, **kwargs: Any) -> str:\n         sigs = []\n+        if self.env.config.autodoc_typehints in ('none', 'description'):\n+            kwargs.setdefault('show_annotation', False)\n         if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:\n             # Use signatures for overloaded functions instead of the implementation function.\n             overloaded = True\n",
    "variant_5": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 978fd5df8..a3c7a8c31 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1238,8 +1238,11 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n         if inspect.iscoroutinefunction(self.object):\n             self.add_line('   :async:', sourcename)\n \n+\n     def format_signature(self, **kwargs: Any) -> str:\n         sigs = []\n+        if self.env.config.autodoc_typehints in ('none', 'description'):\n+            kwargs.setdefault('show_annotation', False)\n         if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:\n             # Use signatures for overloaded functions instead of the implementation function.\n             overloaded = True\n",
    "variant_6": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 978fd5df8..a3c7a8c31 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1238,8 +1238,11 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n         if inspect.iscoroutinefunction(self.object):\n             self.add_line('   :async:', sourcename)\n \n+\n     def format_signature(self, **kwargs: Any) -> str:\n         sigs = []\n+        if self.env.config.autodoc_typehints in ('none', 'description'):\n+            kwargs.setdefault('show_annotation', False)\n         if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:\n             # Use signatures for overloaded functions instead of the implementation function.\n             overloaded = True\n",
    "variant_7": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 978fd5df8..a3c7a8c31 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1238,8 +1238,11 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n         if inspect.iscoroutinefunction(self.object):\n             self.add_line('   :async:', sourcename)\n \n+\n     def format_signature(self, **kwargs: Any) -> str:\n         sigs = []\n+        if self.env.config.autodoc_typehints in ('none', 'description'):\n+            kwargs.setdefault('show_annotation', False)\n         if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:\n             # Use signatures for overloaded functions instead of the implementation function.\n             overloaded = True\n",
    "variant_8": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 978fd5df8..a053ded3d 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1238,8 +1238,12 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n         if inspect.iscoroutinefunction(self.object):\n             self.add_line('   :async:', sourcename)\n \n+\n     def format_signature(self, **kwargs: Any) -> str:\n         sigs = []\n+        if self.env.config.autodoc_typehints in ('none', 'description'):\n+            kwargs.setdefault('show_annotation', False)\n+        \n         if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:\n             # Use signatures for overloaded functions instead of the implementation function.\n             overloaded = True\n"
  }
}