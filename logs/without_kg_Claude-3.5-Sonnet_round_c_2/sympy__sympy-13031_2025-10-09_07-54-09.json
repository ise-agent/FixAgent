{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/sympy/sympy/matrices/common.py lines 2157-2180)": "\n    def __init__(self, rows, cols=None, mat=None):\n        if isinstance(mat, FunctionType):\n            # if we passed in a function, use that to populate the indices\n            if rows == 0:\n                # For zero-height matrices, create empty list but preserve column structure\n                mat = []\n            else:\n                mat = list(mat(i, j) for i in range(rows) for j in range(cols))\n        try:\n            if cols is None and mat is None:\n                mat = rows\n            rows, cols = mat.shape\n        except AttributeError:\n            pass\n        try:\n            # if we passed in a list of lists, flatten it and set the size\n            if cols is None and mat is None:\n                mat = rows\n            cols = len(mat[0])\n            rows = len(mat)\n            mat = [x for l in mat for x in l]\n        except (IndexError, TypeError):\n            pass\n        self.mat = tuple(self._sympify(x) for x in mat)\n        self.rows, self.cols = rows, cols\n        if self.rows is None or self.cols is None:\n            raise NotImplementedError(\"Cannot initialize matrix with given parameters\")\n",
    "Location 2 (/root/hy/projects_2/sympy/sympy/matrices/common.py lines 149-158)": "\n    def _eval_row_join(self, other):\n        cols = self.cols\n\n        def entry(i, j):\n            if j < cols:\n                return self[i, j]\n            return other[i, j - cols]\n\n        return classof(self, other)._new(self.rows, self.cols + other.cols,\n                                         lambda i, j: entry(i, j))\n",
    "Location 3 (/root/hy/projects_2/sympy/sympy/matrices/common.py lines 363-381)": "\n    @classmethod\n    def hstack(cls, *args):\n        \"\"\"Return a matrix formed by joining args horizontally (i.e.\n        by repeated application of row_join).\n\n        Examples\n        ========\n\n        >>> from sympy.matrices import Matrix, eye\n        >>> Matrix.hstack(eye(2), 2*eye(2))\n        Matrix([\n        [1, 0, 2, 0],\n        [0, 1, 0, 2]])\n        \"\"\"\n        if len(args) == 0:\n            return cls._new()\n\n        kls = type(args[0])\n        return reduce(kls.row_join, args)\n",
    "Location 4 (/root/hy/projects_2/sympy/sympy/matrices/common.py lines 457-485)": "\n    def row_join(self, other):\n        \"\"\"Concatenates two matrices along self's last and rhs's first column\n\n        Examples\n        ========\n\n        >>> from sympy import zeros, ones\n        >>> M = zeros(3)\n        >>> V = ones(3, 1)\n        >>> M.row_join(V)\n        Matrix([\n        [0, 0, 0, 1],\n        [0, 0, 0, 1],\n        [0, 0, 0, 1]])\n\n        See Also\n        ========\n\n        row\n        col_join\n        \"\"\"\n        # A null matrix can always be stacked (see  #10770)\n        if self.cols == 0 and self.rows != other.rows:\n            return self._new(other.rows, 0, []).row_join(other)\n\n        if self.rows != other.rows:\n            raise ShapeError(\n                \"`self` and `rhs` must have the same number of rows.\")\n        return self._eval_row_join(other)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/sympy/sympy/matrices/common.py lines 2157-2180)": [
      "\n    def __init__(self, rows, cols=None, mat=None):\n        if isinstance(mat, FunctionType):\n            # if we passed in a function, use that to populate the indices\n            if rows == 0:\n                # For zero-height matrices, create empty list but preserve column structure\n                mat = []\n            else:\n                mat = list(mat(i, j) for i in range(rows) for j in range(cols))\n        try:\n            if cols is None and mat is None:\n                mat = rows\n            rows, cols = mat.shape\n        except AttributeError:\n            pass\n        try:\n            # if we passed in a list of lists, flatten it and set the size\n            if cols is None and mat is None:\n                mat = rows\n            cols = len(mat[0])\n            rows = len(mat)\n            mat = [x for l in mat for x in l]\n        except (IndexError, TypeError):\n            pass\n        self.mat = tuple(self._sympify(x) for x in mat)\n        self.rows, self.cols = rows, cols\n        if self.rows is None or self.cols is None:\n            raise NotImplementedError(\"Cannot initialize matrix with given parameters\")\n",
      "\n    def __init__(self, rows, cols=None, mat=None):\n        if isinstance(mat, FunctionType):\n            # if we passed in a function, use that to populate the indices\n            if rows == 0:\n                # For zero-height matrices, create empty list but preserve column structure\n                mat = []\n            else:\n                mat = list(mat(i, j) for i in range(rows) for j in range(cols))\n        try:\n            if cols is None and mat is None:\n                mat = rows\n            rows, cols = mat.shape\n        except AttributeError:\n            pass\n        try:\n            # if we passed in a list of lists, flatten it and set the size\n            if cols is None and mat is None:\n                mat = rows\n            cols = len(mat[0])\n            rows = len(mat)\n            mat = [x for l in mat for x in l]\n        except (IndexError, TypeError):\n            pass\n        self.mat = tuple(self._sympify(x) for x in mat)\n        self.rows, self.cols = rows, cols\n        if self.rows is None or self.cols is None:\n            raise NotImplementedError(\"Cannot initialize matrix with given parameters\")\n",
      "\n    def __init__(self, rows, cols=None, mat=None):\n        if isinstance(mat, FunctionType):\n            # if we passed in a function, use that to populate the indices\n            if rows == 0:\n                # For zero-height matrices, create empty list but preserve column structure\n                mat = []\n            else:\n                mat = list(mat(i, j) for i in range(rows) for j in range(cols))\n        try:\n            if cols is None and mat is None:\n                mat = rows\n            rows, cols = mat.shape\n        except AttributeError:\n            pass\n        try:\n            # if we passed in a list of lists, flatten it and set the size\n            if cols is None and mat is None:\n                mat = rows\n            cols = len(mat[0])\n            rows = len(mat)\n            mat = [x for l in mat for x in l]\n        except (IndexError, TypeError):\n            pass\n        self.mat = tuple(self._sympify(x) for x in mat)\n        self.rows, self.cols = rows, cols\n        if self.rows is None or self.cols is None:\n            raise NotImplementedError(\"Cannot initialize matrix with given parameters\")\n",
      "\ndef __init__(self, rows, cols=None, mat=None):\n    if isinstance(mat, FunctionType):\n        # if we passed in a function, use that to populate the indices\n        if rows == 0:\n            # For zero-height matrices, create empty list but preserve column structure\n            mat = []\n        else:\n            mat = list(mat(i, j) for i in range(rows) for j in range(cols))\n    try:\n        if cols is None and mat is None:\n            mat = rows\n        rows, cols = mat.shape\n    except AttributeError:\n        pass\n    try:\n        # if we passed in a list of lists, flatten it and set the size\n        if cols is None and mat is None:\n            mat = rows\n        cols = len(mat[0])\n        rows = len(mat)\n        mat = [x for l in mat for x in l]\n    except (IndexError, TypeError):\n        pass\n    self.mat = tuple(self._sympify(x) for x in mat)\n    self.rows, self.cols = rows, cols\n    if self.rows is None or self.cols is None:\n        raise NotImplementedError(\"Cannot initialize matrix with given parameters\")\n",
      "\n    def __init__(self, rows, cols=None, mat=None):\n        if isinstance(mat, FunctionType):\n            # if we passed in a function, use that to populate the indices\n            if rows == 0:\n                # For zero-height matrices, create empty list but preserve column structure\n                mat = []\n            else:\n                mat = list(mat(i, j) for i in range(rows) for j in range(cols))\n        try:\n            if cols is None and mat is None:\n                mat = rows\n            rows, cols = mat.shape\n        except AttributeError:\n            pass\n        try:\n            # if we passed in a list of lists, flatten it and set the size\n            if cols is None and mat is None:\n                mat = rows\n            cols = len(mat[0])\n            rows = len(mat)\n            mat = [x for l in mat for x in l]\n        except (IndexError, TypeError):\n            pass\n        self.mat = tuple(self._sympify(x) for x in mat)\n        self.rows, self.cols = rows, cols\n        if self.rows is None or self.cols is None:\n            raise NotImplementedError(\"Cannot initialize matrix with given parameters\")\n",
      "\n    def __init__(self, rows, cols=None, mat=None):\n        if isinstance(mat, FunctionType):\n            # if we passed in a function, use that to populate the indices\n            if rows == 0:\n                # For zero-height matrices, create empty list but preserve column structure\n                mat = []\n            else:\n                mat = list(mat(i, j) for i in range(rows) for j in range(cols))\n        try:\n            if cols is None and mat is None:\n                mat = rows\n            rows, cols = mat.shape\n        except AttributeError:\n            pass\n        try:\n            # if we passed in a list of lists, flatten it and set the size\n            if cols is None and mat is None:\n                mat = rows\n            cols = len(mat[0])\n            rows = len(mat)\n            mat = [x for l in mat for x in l]\n        except (IndexError, TypeError):\n            pass\n        self.mat = tuple(self._sympify(x) for x in mat)\n        self.rows, self.cols = rows, cols\n        if self.rows is None or self.cols is None:\n            raise NotImplementedError(\"Cannot initialize matrix with given parameters\")\n",
      "\ndef __init__(self, rows, cols=None, mat=None):\n    if isinstance(mat, FunctionType):\n        # if we passed in a function, use that to populate the indices\n        if rows == 0:\n            # For zero-height matrices, create empty list but preserve column structure\n            mat = []\n        else:\n            mat = list(mat(i, j) for i in range(rows) for j in range(cols))\n    try:\n        if cols is None and mat is None:\n            mat = rows\n        rows, cols = mat.shape\n    except AttributeError:\n        pass\n    try:\n        # if we passed in a list of lists, flatten it and set the size\n        if cols is None and mat is None:\n            mat = rows\n        cols = len(mat[0])\n        rows = len(mat)\n        mat = [x for l in mat for x in l]\n    except (IndexError, TypeError):\n        pass\n    self.mat = tuple(self._sympify(x) for x in mat)\n    self.rows, self.cols = rows, cols\n    if self.rows is None or self.cols is None:\n        raise NotImplementedError(\"Cannot initialize matrix with given parameters\")\n",
      "\ndef __init__(self, rows, cols=None, mat=None):\n    if isinstance(mat, FunctionType):\n        # if we passed in a function, use that to populate the indices\n        if rows == 0:\n            # For zero-height matrices, create empty list but preserve column structure\n            mat = []\n        else:\n            mat = list(mat(i, j) for i in range(rows) for j in range(cols))\n    try:\n        if cols is None and mat is None:\n            mat = rows\n        rows, cols = mat.shape\n    except AttributeError:\n        pass\n    try:\n        # if we passed in a list of lists, flatten it and set the size\n        if cols is None and mat is None:\n            mat = rows\n        cols = len(mat[0])\n        rows = len(mat)\n        mat = [x for l in mat for x in l]\n    except (IndexError, TypeError):\n        pass\n    self.mat = tuple(self._sympify(x) for x in mat)\n    self.rows, self.cols = rows, cols\n    if self.rows is None or self.cols is None:\n        raise NotImplementedError(\"Cannot initialize matrix with given parameters\")\n"
    ],
    "Location 2 (/root/hy/projects_2/sympy/sympy/matrices/common.py lines 149-158)": [
      "\n    def _eval_row_join(self, other):\n        cols = self.cols\n\n        def entry(i, j):\n            if j < cols:\n                return self[i, j]\n            return other[i, j - cols]\n\n        return classof(self, other)._new(self.rows, self.cols + other.cols,\n                                         lambda i, j: entry(i, j))\n",
      "\n    def _eval_row_join(self, other):\n        cols = self.cols\n\n        def entry(i, j):\n            if j < cols:\n                return self[i, j]\n            return other[i, j - cols]\n\n        return classof(self, other)._new(self.rows, self.cols + other.cols,\n                                         lambda i, j: entry(i, j))\n",
      "\n    def _eval_row_join(self, other):\n        cols = self.cols\n\n        def entry(i, j):\n            if j < cols:\n                return self[i, j]\n            return other[i, j - cols]\n\n        return classof(self, other)._new(self.rows, self.cols + other.cols,\n                                         lambda i, j: entry(i, j))\n",
      "\n    def _eval_row_join(self, other):\n        cols = self.cols\n\n        def entry(i, j):\n            if j < cols:\n                return self[i, j]\n            return other[i, j - cols]\n\n        return classof(self, other)._new(self.rows, self.cols + other.cols,\n                                         lambda i, j: entry(i, j))\n",
      "\n    def _eval_row_join(self, other):\n        cols = self.cols\n\n        def entry(i, j):\n            if j < cols:\n                return self[i, j]\n            return other[i, j - cols]\n\n        return classof(self, other)._new(self.rows, self.cols + other.cols,\n                                         lambda i, j: entry(i, j))\n",
      "\n    def _eval_row_join(self, other):\n        cols = self.cols\n\n        def entry(i, j):\n            if j < cols:\n                return self[i, j]\n            return other[i, j - cols]\n\n        return classof(self, other)._new(self.rows, self.cols + other.cols,\n                                         lambda i, j: entry(i, j))\n",
      "\n    def _eval_row_join(self, other):\n        cols = self.cols\n\n        def entry(i, j):\n            if j < cols:\n                return self[i, j]\n            return other[i, j - cols]\n\n        return classof(self, other)._new(self.rows, self.cols + other.cols,\n                                         lambda i, j: entry(i, j))\n",
      "\n    def _eval_row_join(self, other):\n        cols = self.cols\n\n        def entry(i, j):\n            if j < cols:\n                return self[i, j]\n            return other[i, j - cols]\n\n        return classof(self, other)._new(self.rows, self.cols + other.cols,\n                                         lambda i, j: entry(i, j))\n"
    ],
    "Location 3 (/root/hy/projects_2/sympy/sympy/matrices/common.py lines 363-381)": [
      "\n    @classmethod\n    def hstack(cls, *args):\n        \"\"\"Return a matrix formed by joining args horizontally (i.e.\n        by repeated application of row_join).\n\n        Examples\n        ========\n\n        >>> from sympy.matrices import Matrix, eye\n        >>> Matrix.hstack(eye(2), 2*eye(2))\n        Matrix([\n        [1, 0, 2, 0],\n        [0, 1, 0, 2]])\n        \"\"\"\n        if len(args) == 0:\n            return cls._new()\n\n        kls = type(args[0])\n        return reduce(kls.row_join, args)\n",
      "\n    @classmethod\n    def hstack(cls, *args):\n        \"\"\"Return a matrix formed by joining args horizontally (i.e.\n        by repeated application of row_join).\n\n        Examples\n        ========\n\n        >>> from sympy.matrices import Matrix, eye\n        >>> Matrix.hstack(eye(2), 2*eye(2))\n        Matrix([\n        [1, 0, 2, 0],\n        [0, 1, 0, 2]])\n        \"\"\"\n        if len(args) == 0:\n            return cls._new()\n\n        kls = type(args[0])\n        return reduce(kls.row_join, args)\n",
      "\n    @classmethod\n    def hstack(cls, *args):\n        \"\"\"Return a matrix formed by joining args horizontally (i.e.\n        by repeated application of row_join).\n\n        Examples\n        ========\n\n        >>> from sympy.matrices import Matrix, eye\n        >>> Matrix.hstack(eye(2), 2*eye(2))\n        Matrix([\n        [1, 0, 2, 0],\n        [0, 1, 0, 2]])\n        \"\"\"\n        if len(args) == 0:\n            return cls._new()\n\n        kls = type(args[0])\n        return reduce(kls.row_join, args)\n",
      "\n    @classmethod\n    def hstack(cls, *args):\n        \"\"\"Return a matrix formed by joining args horizontally (i.e.\n        by repeated application of row_join).\n\n        Examples\n        ========\n\n        >>> from sympy.matrices import Matrix, eye\n        >>> Matrix.hstack(eye(2), 2*eye(2))\n        Matrix([\n        [1, 0, 2, 0],\n        [0, 1, 0, 2]])\n        \"\"\"\n        if len(args) == 0:\n            return cls._new()\n\n        kls = type(args[0])\n        return reduce(kls.row_join, args)\n",
      "\n    @classmethod\n    def hstack(cls, *args):\n        \"\"\"Return a matrix formed by joining args horizontally (i.e.\n        by repeated application of row_join).\n\n        Examples\n        ========\n\n        >>> from sympy.matrices import Matrix, eye\n        >>> Matrix.hstack(eye(2), 2*eye(2))\n        Matrix([\n        [1, 0, 2, 0],\n        [0, 1, 0, 2]])\n        \"\"\"\n        if len(args) == 0:\n            return cls._new()\n\n        kls = type(args[0])\n        result = reduce(kls.row_join, args)\n        return result\n",
      "\n    @classmethod\n    def hstack(cls, *args):\n        \"\"\"Return a matrix formed by joining args horizontally (i.e.\n        by repeated application of row_join).\n\n        Examples\n        ========\n\n        >>> from sympy.matrices import Matrix, eye\n        >>> Matrix.hstack(eye(2), 2*eye(2))\n        Matrix([\n        [1, 0, 2, 0],\n        [0, 1, 0, 2]])\n        \"\"\"\n        if len(args) == 0:\n            return cls._new()\n\n        kls = type(args[0])\n        return reduce(kls.row_join, args)\n",
      "\n    @classmethod\n    def hstack(cls, *args):\n        \"\"\"Return a matrix formed by joining args horizontally (i.e.\n        by repeated application of row_join).\n\n        Examples\n        ========\n\n        >>> from sympy.matrices import Matrix, eye\n        >>> Matrix.hstack(eye(2), 2*eye(2))\n        Matrix([\n        [1, 0, 2, 0],\n        [0, 1, 0, 2]])\n        \"\"\"\n        if len(args) == 0:\n            return cls._new()\n\n        kls = type(args[0])\n        result = reduce(kls.row_join, args)\n        return result\n",
      "\n    @classmethod\n    def hstack(cls, *args):\n        \"\"\"Return a matrix formed by joining args horizontally (i.e.\n        by repeated application of row_join).\n\n        Examples\n        ========\n\n        >>> from sympy.matrices import Matrix, eye\n        >>> Matrix.hstack(eye(2), 2*eye(2))\n        Matrix([\n        [1, 0, 2, 0],\n        [0, 1, 0, 2]])\n        \"\"\"\n        if len(args) == 0:\n            return cls._new()\n\n        kls = type(args[0])\n        result = reduce(kls.row_join, args)\n        return result\n"
    ],
    "Location 4 (/root/hy/projects_2/sympy/sympy/matrices/common.py lines 457-485)": [
      "\n    def row_join(self, other):\n        \"\"\"Concatenates two matrices along self's last and rhs's first column\n\n        Examples\n        ========\n\n        >>> from sympy import zeros, ones\n        >>> M = zeros(3)\n        >>> V = ones(3, 1)\n        >>> M.row_join(V)\n        Matrix([\n        [0, 0, 0, 1],\n        [0, 0, 0, 1],\n        [0, 0, 0, 1]])\n\n        See Also\n        ========\n\n        row\n        col_join\n        \"\"\"\n        # A null matrix can always be stacked (see  #10770)\n        if self.cols == 0 and self.rows != other.rows:\n            return self._new(other.rows, 0, []).row_join(other)\n\n        if self.rows != other.rows:\n            raise ShapeError(\n                \"`self` and `rhs` must have the same number of rows.\")\n        return self._eval_row_join(other)\n",
      "\n    def row_join(self, other):\n        \"\"\"Concatenates two matrices along self's last and rhs's first column\n\n        Examples\n        ========\n\n        >>> from sympy import zeros, ones\n        >>> M = zeros(3)\n        >>> V = ones(3, 1)\n        >>> M.row_join(V)\n        Matrix([\n        [0, 0, 0, 1],\n        [0, 0, 0, 1],\n        [0, 0, 0, 1]])\n\n        See Also\n        ========\n\n        row\n        col_join\n        \"\"\"\n        # A null matrix can always be stacked (see  #10770)\n        if self.cols == 0 and self.rows != other.rows:\n            return self._new(other.rows, 0, []).row_join(other)\n\n        if self.rows != other.rows:\n            raise ShapeError(\n                \"`self` and `rhs` must have the same number of rows.\")\n        return self._eval_row_join(other)\n",
      "\n    def row_join(self, other):\n        \"\"\"Concatenates two matrices along self's last and rhs's first column\n\n        Examples\n        ========\n\n        >>> from sympy import zeros, ones\n        >>> M = zeros(3)\n        >>> V = ones(3, 1)\n        >>> M.row_join(V)\n        Matrix([\n        [0, 0, 0, 1],\n        [0, 0, 0, 1],\n        [0, 0, 0, 1]])\n\n        See Also\n        ========\n\n        row\n        col_join\n        \"\"\"\n        # A null matrix can always be stacked (see  #10770)\n        if self.cols == 0 and self.rows != other.rows:\n            return self._new(other.rows, 0, []).row_join(other)\n\n        if self.rows != other.rows:\n            raise ShapeError(\n                \"`self` and `rhs` must have the same number of rows.\")\n        return self._eval_row_join(other)\n",
      "\n    def row_join(self, other):\n        \"\"\"Concatenates two matrices along self's last and rhs's first column\n\n        Examples\n        ========\n\n        >>> from sympy import zeros, ones\n        >>> M = zeros(3)\n        >>> V = ones(3, 1)\n        >>> M.row_join(V)\n        Matrix([\n        [0, 0, 0, 1],\n        [0, 0, 0, 1],\n        [0, 0, 0, 1]])\n\n        See Also\n        ========\n\n        row\n        col_join\n        \"\"\"\n        # A null matrix can always be stacked (see  #10770)\n        if self.cols == 0 and self.rows != other.rows:\n            return self._new(other.rows, 0, []).row_join(other)\n\n        if self.rows != other.rows:\n            raise ShapeError(\n                \"`self` and `rhs` must have the same number of rows.\")\n        return self._eval_row_join(other)\n",
      "\n    def row_join(self, other):\n        \"\"\"Concatenates two matrices along self's last and rhs's first column\n\n        Examples\n        ========\n\n        >>> from sympy import zeros, ones\n        >>> M = zeros(3)\n        >>> V = ones(3, 1)\n        >>> M.row_join(V)\n        Matrix([\n        [0, 0, 0, 1],\n        [0, 0, 0, 1],\n        [0, 0, 0, 1]])\n\n        See Also\n        ========\n\n        row\n        col_join\n        \"\"\"\n        # A null matrix can always be stacked (see  #10770)\n        if self.cols == 0 and self.rows != other.rows:\n            return self._new(other.rows, 0, []).row_join(other)\n\n        if self.rows != other.rows:\n            raise ShapeError(\n                \"`self` and `rhs` must have the same number of rows.\")\n        return self._eval_row_join(other)\n",
      "\n    def row_join(self, other):\n        \"\"\"Concatenates two matrices along self's last and rhs's first column\n\n        Examples\n        ========\n\n        >>> from sympy import zeros, ones\n        >>> M = zeros(3)\n        >>> V = ones(3, 1)\n        >>> M.row_join(V)\n        Matrix([\n        [0, 0, 0, 1],\n        [0, 0, 0, 1],\n        [0, 0, 0, 1]])\n\n        See Also\n        ========\n\n        row\n        col_join\n        \"\"\"\n        # A null matrix can always be stacked (see  #10770)\n        if self.cols == 0 and self.rows != other.rows:\n            return self._new(other.rows, 0, []).row_join(other)\n\n        if self.rows != other.rows:\n            raise ShapeError(\n                \"`self` and `rhs` must have the same number of rows.\")\n        return self._eval_row_join(other)\n",
      "\n    def row_join(self, other):\n        \"\"\"Concatenates two matrices along self's last and rhs's first column\n\n        Examples\n        ========\n\n        >>> from sympy import zeros, ones\n        >>> M = zeros(3)\n        >>> V = ones(3, 1)\n        >>> M.row_join(V)\n        Matrix([\n        [0, 0, 0, 1],\n        [0, 0, 0, 1],\n        [0, 0, 0, 1]])\n\n        See Also\n        ========\n\n        row\n        col_join\n        \"\"\"\n        # A null matrix can always be stacked (see  #10770)\n        if self.cols == 0 and self.rows != other.rows:\n            return self._new(other.rows, 0, []).row_join(other)\n\n        if self.rows != other.rows:\n            raise ShapeError(\n                \"`self` and `rhs` must have the same number of rows.\")\n        return self._eval_row_join(other)\n",
      "\ndef row_join(self, other):\n    \"\"\"Concatenates two matrices along self's last and rhs's first column\n\n    Examples\n    ========\n\n    >>> from sympy import zeros, ones\n    >>> M = zeros(3)\n    >>> V = ones(3, 1)\n    >>> M.row_join(V)\n    Matrix([\n    [0, 0, 0, 1],\n    [0, 0, 0, 1],\n    [0, 0, 0, 1]])\n\n    See Also\n    ========\n\n    row\n    col_join\n    \"\"\"\n    # A null matrix can always be stacked (see  #10770)\n    if self.cols == 0 and self.rows != other.rows:\n        return self._new(other.rows, 0, []).row_join(other)\n\n    if self.rows != other.rows:\n        raise ShapeError(\n            \"`self` and `rhs` must have the same number of rows.\")\n    return self._eval_row_join(other)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sympy/matrices/common.py b/sympy/matrices/common.py\nindex 7ef51bc847..a0e00a16d2 100644\n--- a/sympy/matrices/common.py\n+++ b/sympy/matrices/common.py\n@@ -146,6 +146,7 @@ def _eval_row_insert(self, pos, other):\n         entries[insert_pos:insert_pos] = list(other)\n         return self._new(self.rows + other.rows, self.cols, entries)\n \n+\n     def _eval_row_join(self, other):\n         cols = self.cols\n \n@@ -360,6 +361,7 @@ def get_diag_blocks(self):\n         \"\"\"\n         return self._eval_get_diag_blocks()\n \n+\n     @classmethod\n     def hstack(cls, *args):\n         \"\"\"Return a matrix formed by joining args horizontally (i.e.\n@@ -454,6 +456,7 @@ def row_insert(self, pos, other):\n \n         return self._eval_row_insert(pos, other)\n \n+\n     def row_join(self, other):\n         \"\"\"Concatenates two matrices along self's last and rhs's first column\n \n@@ -2154,10 +2157,15 @@ class _MinimalMatrix(object):\n     def _new(cls, *args, **kwargs):\n         return cls(*args, **kwargs)\n \n+\n     def __init__(self, rows, cols=None, mat=None):\n         if isinstance(mat, FunctionType):\n             # if we passed in a function, use that to populate the indices\n-            mat = list(mat(i, j) for i in range(rows) for j in range(cols))\n+            if rows == 0:\n+                # For zero-height matrices, create empty list but preserve column structure\n+                mat = []\n+            else:\n+                mat = list(mat(i, j) for i in range(rows) for j in range(cols))\n         try:\n             if cols is None and mat is None:\n                 mat = rows\n@@ -2177,7 +2185,6 @@ def __init__(self, rows, cols=None, mat=None):\n         self.rows, self.cols = rows, cols\n         if self.rows is None or self.cols is None:\n             raise NotImplementedError(\"Cannot initialize matrix with given parameters\")\n-\n     def __getitem__(self, key):\n         def _normalize_slices(row_slice, col_slice):\n             \"\"\"Ensure that row_slice and col_slice don't have\n",
    "variant_0": "diff --git a/sympy/matrices/common.py b/sympy/matrices/common.py\nindex 7ef51bc847..a0e00a16d2 100644\n--- a/sympy/matrices/common.py\n+++ b/sympy/matrices/common.py\n@@ -146,6 +146,7 @@ def _eval_row_insert(self, pos, other):\n         entries[insert_pos:insert_pos] = list(other)\n         return self._new(self.rows + other.rows, self.cols, entries)\n \n+\n     def _eval_row_join(self, other):\n         cols = self.cols\n \n@@ -360,6 +361,7 @@ def get_diag_blocks(self):\n         \"\"\"\n         return self._eval_get_diag_blocks()\n \n+\n     @classmethod\n     def hstack(cls, *args):\n         \"\"\"Return a matrix formed by joining args horizontally (i.e.\n@@ -454,6 +456,7 @@ def row_insert(self, pos, other):\n \n         return self._eval_row_insert(pos, other)\n \n+\n     def row_join(self, other):\n         \"\"\"Concatenates two matrices along self's last and rhs's first column\n \n@@ -2154,10 +2157,15 @@ class _MinimalMatrix(object):\n     def _new(cls, *args, **kwargs):\n         return cls(*args, **kwargs)\n \n+\n     def __init__(self, rows, cols=None, mat=None):\n         if isinstance(mat, FunctionType):\n             # if we passed in a function, use that to populate the indices\n-            mat = list(mat(i, j) for i in range(rows) for j in range(cols))\n+            if rows == 0:\n+                # For zero-height matrices, create empty list but preserve column structure\n+                mat = []\n+            else:\n+                mat = list(mat(i, j) for i in range(rows) for j in range(cols))\n         try:\n             if cols is None and mat is None:\n                 mat = rows\n@@ -2177,7 +2185,6 @@ def __init__(self, rows, cols=None, mat=None):\n         self.rows, self.cols = rows, cols\n         if self.rows is None or self.cols is None:\n             raise NotImplementedError(\"Cannot initialize matrix with given parameters\")\n-\n     def __getitem__(self, key):\n         def _normalize_slices(row_slice, col_slice):\n             \"\"\"Ensure that row_slice and col_slice don't have\n",
    "variant_1": "diff --git a/sympy/matrices/common.py b/sympy/matrices/common.py\nindex 7ef51bc847..a0e00a16d2 100644\n--- a/sympy/matrices/common.py\n+++ b/sympy/matrices/common.py\n@@ -146,6 +146,7 @@ def _eval_row_insert(self, pos, other):\n         entries[insert_pos:insert_pos] = list(other)\n         return self._new(self.rows + other.rows, self.cols, entries)\n \n+\n     def _eval_row_join(self, other):\n         cols = self.cols\n \n@@ -360,6 +361,7 @@ def get_diag_blocks(self):\n         \"\"\"\n         return self._eval_get_diag_blocks()\n \n+\n     @classmethod\n     def hstack(cls, *args):\n         \"\"\"Return a matrix formed by joining args horizontally (i.e.\n@@ -454,6 +456,7 @@ def row_insert(self, pos, other):\n \n         return self._eval_row_insert(pos, other)\n \n+\n     def row_join(self, other):\n         \"\"\"Concatenates two matrices along self's last and rhs's first column\n \n@@ -2154,10 +2157,15 @@ class _MinimalMatrix(object):\n     def _new(cls, *args, **kwargs):\n         return cls(*args, **kwargs)\n \n+\n     def __init__(self, rows, cols=None, mat=None):\n         if isinstance(mat, FunctionType):\n             # if we passed in a function, use that to populate the indices\n-            mat = list(mat(i, j) for i in range(rows) for j in range(cols))\n+            if rows == 0:\n+                # For zero-height matrices, create empty list but preserve column structure\n+                mat = []\n+            else:\n+                mat = list(mat(i, j) for i in range(rows) for j in range(cols))\n         try:\n             if cols is None and mat is None:\n                 mat = rows\n@@ -2177,7 +2185,6 @@ def __init__(self, rows, cols=None, mat=None):\n         self.rows, self.cols = rows, cols\n         if self.rows is None or self.cols is None:\n             raise NotImplementedError(\"Cannot initialize matrix with given parameters\")\n-\n     def __getitem__(self, key):\n         def _normalize_slices(row_slice, col_slice):\n             \"\"\"Ensure that row_slice and col_slice don't have\n",
    "variant_2": "diff --git a/sympy/matrices/common.py b/sympy/matrices/common.py\nindex 7ef51bc847..a0e00a16d2 100644\n--- a/sympy/matrices/common.py\n+++ b/sympy/matrices/common.py\n@@ -146,6 +146,7 @@ def _eval_row_insert(self, pos, other):\n         entries[insert_pos:insert_pos] = list(other)\n         return self._new(self.rows + other.rows, self.cols, entries)\n \n+\n     def _eval_row_join(self, other):\n         cols = self.cols\n \n@@ -360,6 +361,7 @@ def get_diag_blocks(self):\n         \"\"\"\n         return self._eval_get_diag_blocks()\n \n+\n     @classmethod\n     def hstack(cls, *args):\n         \"\"\"Return a matrix formed by joining args horizontally (i.e.\n@@ -454,6 +456,7 @@ def row_insert(self, pos, other):\n \n         return self._eval_row_insert(pos, other)\n \n+\n     def row_join(self, other):\n         \"\"\"Concatenates two matrices along self's last and rhs's first column\n \n@@ -2154,10 +2157,15 @@ class _MinimalMatrix(object):\n     def _new(cls, *args, **kwargs):\n         return cls(*args, **kwargs)\n \n+\n     def __init__(self, rows, cols=None, mat=None):\n         if isinstance(mat, FunctionType):\n             # if we passed in a function, use that to populate the indices\n-            mat = list(mat(i, j) for i in range(rows) for j in range(cols))\n+            if rows == 0:\n+                # For zero-height matrices, create empty list but preserve column structure\n+                mat = []\n+            else:\n+                mat = list(mat(i, j) for i in range(rows) for j in range(cols))\n         try:\n             if cols is None and mat is None:\n                 mat = rows\n@@ -2177,7 +2185,6 @@ def __init__(self, rows, cols=None, mat=None):\n         self.rows, self.cols = rows, cols\n         if self.rows is None or self.cols is None:\n             raise NotImplementedError(\"Cannot initialize matrix with given parameters\")\n-\n     def __getitem__(self, key):\n         def _normalize_slices(row_slice, col_slice):\n             \"\"\"Ensure that row_slice and col_slice don't have\n",
    "variant_3": "diff --git a/sympy/matrices/common.py b/sympy/matrices/common.py\nindex 7ef51bc847..a0e00a16d2 100644\n--- a/sympy/matrices/common.py\n+++ b/sympy/matrices/common.py\n@@ -146,6 +146,7 @@ def _eval_row_insert(self, pos, other):\n         entries[insert_pos:insert_pos] = list(other)\n         return self._new(self.rows + other.rows, self.cols, entries)\n \n+\n     def _eval_row_join(self, other):\n         cols = self.cols\n \n@@ -360,6 +361,7 @@ def get_diag_blocks(self):\n         \"\"\"\n         return self._eval_get_diag_blocks()\n \n+\n     @classmethod\n     def hstack(cls, *args):\n         \"\"\"Return a matrix formed by joining args horizontally (i.e.\n@@ -454,6 +456,7 @@ def row_insert(self, pos, other):\n \n         return self._eval_row_insert(pos, other)\n \n+\n     def row_join(self, other):\n         \"\"\"Concatenates two matrices along self's last and rhs's first column\n \n@@ -2154,10 +2157,15 @@ class _MinimalMatrix(object):\n     def _new(cls, *args, **kwargs):\n         return cls(*args, **kwargs)\n \n+\n     def __init__(self, rows, cols=None, mat=None):\n         if isinstance(mat, FunctionType):\n             # if we passed in a function, use that to populate the indices\n-            mat = list(mat(i, j) for i in range(rows) for j in range(cols))\n+            if rows == 0:\n+                # For zero-height matrices, create empty list but preserve column structure\n+                mat = []\n+            else:\n+                mat = list(mat(i, j) for i in range(rows) for j in range(cols))\n         try:\n             if cols is None and mat is None:\n                 mat = rows\n@@ -2177,7 +2185,6 @@ def __init__(self, rows, cols=None, mat=None):\n         self.rows, self.cols = rows, cols\n         if self.rows is None or self.cols is None:\n             raise NotImplementedError(\"Cannot initialize matrix with given parameters\")\n-\n     def __getitem__(self, key):\n         def _normalize_slices(row_slice, col_slice):\n             \"\"\"Ensure that row_slice and col_slice don't have\n",
    "variant_4": "diff --git a/sympy/matrices/common.py b/sympy/matrices/common.py\nindex 7ef51bc847..61f10c7170 100644\n--- a/sympy/matrices/common.py\n+++ b/sympy/matrices/common.py\n@@ -146,6 +146,7 @@ def _eval_row_insert(self, pos, other):\n         entries[insert_pos:insert_pos] = list(other)\n         return self._new(self.rows + other.rows, self.cols, entries)\n \n+\n     def _eval_row_join(self, other):\n         cols = self.cols\n \n@@ -360,6 +361,7 @@ def get_diag_blocks(self):\n         \"\"\"\n         return self._eval_get_diag_blocks()\n \n+\n     @classmethod\n     def hstack(cls, *args):\n         \"\"\"Return a matrix formed by joining args horizontally (i.e.\n@@ -454,6 +456,7 @@ def row_insert(self, pos, other):\n \n         return self._eval_row_insert(pos, other)\n \n+\n     def row_join(self, other):\n         \"\"\"Concatenates two matrices along self's last and rhs's first column\n \n@@ -2154,30 +2157,34 @@ class _MinimalMatrix(object):\n     def _new(cls, *args, **kwargs):\n         return cls(*args, **kwargs)\n \n-    def __init__(self, rows, cols=None, mat=None):\n-        if isinstance(mat, FunctionType):\n-            # if we passed in a function, use that to populate the indices\n-            mat = list(mat(i, j) for i in range(rows) for j in range(cols))\n-        try:\n-            if cols is None and mat is None:\n-                mat = rows\n-            rows, cols = mat.shape\n-        except AttributeError:\n-            pass\n-        try:\n-            # if we passed in a list of lists, flatten it and set the size\n-            if cols is None and mat is None:\n-                mat = rows\n-            cols = len(mat[0])\n-            rows = len(mat)\n-            mat = [x for l in mat for x in l]\n-        except (IndexError, TypeError):\n-            pass\n-        self.mat = tuple(self._sympify(x) for x in mat)\n-        self.rows, self.cols = rows, cols\n-        if self.rows is None or self.cols is None:\n-            raise NotImplementedError(\"Cannot initialize matrix with given parameters\")\n \n+def __init__(self, rows, cols=None, mat=None):\n+    if isinstance(mat, FunctionType):\n+        # if we passed in a function, use that to populate the indices\n+        if rows == 0:\n+            # For zero-height matrices, create empty list but preserve column structure\n+            mat = []\n+        else:\n+            mat = list(mat(i, j) for i in range(rows) for j in range(cols))\n+    try:\n+        if cols is None and mat is None:\n+            mat = rows\n+        rows, cols = mat.shape\n+    except AttributeError:\n+        pass\n+    try:\n+        # if we passed in a list of lists, flatten it and set the size\n+        if cols is None and mat is None:\n+            mat = rows\n+        cols = len(mat[0])\n+        rows = len(mat)\n+        mat = [x for l in mat for x in l]\n+    except (IndexError, TypeError):\n+        pass\n+    self.mat = tuple(self._sympify(x) for x in mat)\n+    self.rows, self.cols = rows, cols\n+    if self.rows is None or self.cols is None:\n+        raise NotImplementedError(\"Cannot initialize matrix with given parameters\")\n     def __getitem__(self, key):\n         def _normalize_slices(row_slice, col_slice):\n             \"\"\"Ensure that row_slice and col_slice don't have\n",
    "variant_5": "diff --git a/sympy/matrices/common.py b/sympy/matrices/common.py\nindex 7ef51bc847..b9d4c9819f 100644\n--- a/sympy/matrices/common.py\n+++ b/sympy/matrices/common.py\n@@ -146,6 +146,7 @@ def _eval_row_insert(self, pos, other):\n         entries[insert_pos:insert_pos] = list(other)\n         return self._new(self.rows + other.rows, self.cols, entries)\n \n+\n     def _eval_row_join(self, other):\n         cols = self.cols\n \n@@ -360,6 +361,7 @@ def get_diag_blocks(self):\n         \"\"\"\n         return self._eval_get_diag_blocks()\n \n+\n     @classmethod\n     def hstack(cls, *args):\n         \"\"\"Return a matrix formed by joining args horizontally (i.e.\n@@ -378,7 +380,8 @@ def hstack(cls, *args):\n             return cls._new()\n \n         kls = type(args[0])\n-        return reduce(kls.row_join, args)\n+        result = reduce(kls.row_join, args)\n+        return result\n \n     def reshape(self, rows, cols):\n         \"\"\"Reshape the matrix. Total number of elements must remain the same.\n@@ -454,6 +457,7 @@ def row_insert(self, pos, other):\n \n         return self._eval_row_insert(pos, other)\n \n+\n     def row_join(self, other):\n         \"\"\"Concatenates two matrices along self's last and rhs's first column\n \n@@ -2154,10 +2158,15 @@ class _MinimalMatrix(object):\n     def _new(cls, *args, **kwargs):\n         return cls(*args, **kwargs)\n \n+\n     def __init__(self, rows, cols=None, mat=None):\n         if isinstance(mat, FunctionType):\n             # if we passed in a function, use that to populate the indices\n-            mat = list(mat(i, j) for i in range(rows) for j in range(cols))\n+            if rows == 0:\n+                # For zero-height matrices, create empty list but preserve column structure\n+                mat = []\n+            else:\n+                mat = list(mat(i, j) for i in range(rows) for j in range(cols))\n         try:\n             if cols is None and mat is None:\n                 mat = rows\n@@ -2177,7 +2186,6 @@ def __init__(self, rows, cols=None, mat=None):\n         self.rows, self.cols = rows, cols\n         if self.rows is None or self.cols is None:\n             raise NotImplementedError(\"Cannot initialize matrix with given parameters\")\n-\n     def __getitem__(self, key):\n         def _normalize_slices(row_slice, col_slice):\n             \"\"\"Ensure that row_slice and col_slice don't have\n",
    "variant_6": "diff --git a/sympy/matrices/common.py b/sympy/matrices/common.py\nindex 7ef51bc847..a0e00a16d2 100644\n--- a/sympy/matrices/common.py\n+++ b/sympy/matrices/common.py\n@@ -146,6 +146,7 @@ def _eval_row_insert(self, pos, other):\n         entries[insert_pos:insert_pos] = list(other)\n         return self._new(self.rows + other.rows, self.cols, entries)\n \n+\n     def _eval_row_join(self, other):\n         cols = self.cols\n \n@@ -360,6 +361,7 @@ def get_diag_blocks(self):\n         \"\"\"\n         return self._eval_get_diag_blocks()\n \n+\n     @classmethod\n     def hstack(cls, *args):\n         \"\"\"Return a matrix formed by joining args horizontally (i.e.\n@@ -454,6 +456,7 @@ def row_insert(self, pos, other):\n \n         return self._eval_row_insert(pos, other)\n \n+\n     def row_join(self, other):\n         \"\"\"Concatenates two matrices along self's last and rhs's first column\n \n@@ -2154,10 +2157,15 @@ class _MinimalMatrix(object):\n     def _new(cls, *args, **kwargs):\n         return cls(*args, **kwargs)\n \n+\n     def __init__(self, rows, cols=None, mat=None):\n         if isinstance(mat, FunctionType):\n             # if we passed in a function, use that to populate the indices\n-            mat = list(mat(i, j) for i in range(rows) for j in range(cols))\n+            if rows == 0:\n+                # For zero-height matrices, create empty list but preserve column structure\n+                mat = []\n+            else:\n+                mat = list(mat(i, j) for i in range(rows) for j in range(cols))\n         try:\n             if cols is None and mat is None:\n                 mat = rows\n@@ -2177,7 +2185,6 @@ def __init__(self, rows, cols=None, mat=None):\n         self.rows, self.cols = rows, cols\n         if self.rows is None or self.cols is None:\n             raise NotImplementedError(\"Cannot initialize matrix with given parameters\")\n-\n     def __getitem__(self, key):\n         def _normalize_slices(row_slice, col_slice):\n             \"\"\"Ensure that row_slice and col_slice don't have\n",
    "variant_7": "diff --git a/sympy/matrices/common.py b/sympy/matrices/common.py\nindex 7ef51bc847..3131174276 100644\n--- a/sympy/matrices/common.py\n+++ b/sympy/matrices/common.py\n@@ -146,6 +146,7 @@ def _eval_row_insert(self, pos, other):\n         entries[insert_pos:insert_pos] = list(other)\n         return self._new(self.rows + other.rows, self.cols, entries)\n \n+\n     def _eval_row_join(self, other):\n         cols = self.cols\n \n@@ -360,6 +361,7 @@ def get_diag_blocks(self):\n         \"\"\"\n         return self._eval_get_diag_blocks()\n \n+\n     @classmethod\n     def hstack(cls, *args):\n         \"\"\"Return a matrix formed by joining args horizontally (i.e.\n@@ -378,7 +380,8 @@ def hstack(cls, *args):\n             return cls._new()\n \n         kls = type(args[0])\n-        return reduce(kls.row_join, args)\n+        result = reduce(kls.row_join, args)\n+        return result\n \n     def reshape(self, rows, cols):\n         \"\"\"Reshape the matrix. Total number of elements must remain the same.\n@@ -454,6 +457,7 @@ def row_insert(self, pos, other):\n \n         return self._eval_row_insert(pos, other)\n \n+\n     def row_join(self, other):\n         \"\"\"Concatenates two matrices along self's last and rhs's first column\n \n@@ -2154,30 +2158,34 @@ class _MinimalMatrix(object):\n     def _new(cls, *args, **kwargs):\n         return cls(*args, **kwargs)\n \n-    def __init__(self, rows, cols=None, mat=None):\n-        if isinstance(mat, FunctionType):\n-            # if we passed in a function, use that to populate the indices\n-            mat = list(mat(i, j) for i in range(rows) for j in range(cols))\n-        try:\n-            if cols is None and mat is None:\n-                mat = rows\n-            rows, cols = mat.shape\n-        except AttributeError:\n-            pass\n-        try:\n-            # if we passed in a list of lists, flatten it and set the size\n-            if cols is None and mat is None:\n-                mat = rows\n-            cols = len(mat[0])\n-            rows = len(mat)\n-            mat = [x for l in mat for x in l]\n-        except (IndexError, TypeError):\n-            pass\n-        self.mat = tuple(self._sympify(x) for x in mat)\n-        self.rows, self.cols = rows, cols\n-        if self.rows is None or self.cols is None:\n-            raise NotImplementedError(\"Cannot initialize matrix with given parameters\")\n \n+def __init__(self, rows, cols=None, mat=None):\n+    if isinstance(mat, FunctionType):\n+        # if we passed in a function, use that to populate the indices\n+        if rows == 0:\n+            # For zero-height matrices, create empty list but preserve column structure\n+            mat = []\n+        else:\n+            mat = list(mat(i, j) for i in range(rows) for j in range(cols))\n+    try:\n+        if cols is None and mat is None:\n+            mat = rows\n+        rows, cols = mat.shape\n+    except AttributeError:\n+        pass\n+    try:\n+        # if we passed in a list of lists, flatten it and set the size\n+        if cols is None and mat is None:\n+            mat = rows\n+        cols = len(mat[0])\n+        rows = len(mat)\n+        mat = [x for l in mat for x in l]\n+    except (IndexError, TypeError):\n+        pass\n+    self.mat = tuple(self._sympify(x) for x in mat)\n+    self.rows, self.cols = rows, cols\n+    if self.rows is None or self.cols is None:\n+        raise NotImplementedError(\"Cannot initialize matrix with given parameters\")\n     def __getitem__(self, key):\n         def _normalize_slices(row_slice, col_slice):\n             \"\"\"Ensure that row_slice and col_slice don't have\n",
    "variant_8": "diff --git a/sympy/matrices/common.py b/sympy/matrices/common.py\nindex 7ef51bc847..954be39696 100644\n--- a/sympy/matrices/common.py\n+++ b/sympy/matrices/common.py\n@@ -146,6 +146,7 @@ def _eval_row_insert(self, pos, other):\n         entries[insert_pos:insert_pos] = list(other)\n         return self._new(self.rows + other.rows, self.cols, entries)\n \n+\n     def _eval_row_join(self, other):\n         cols = self.cols\n \n@@ -360,6 +361,7 @@ def get_diag_blocks(self):\n         \"\"\"\n         return self._eval_get_diag_blocks()\n \n+\n     @classmethod\n     def hstack(cls, *args):\n         \"\"\"Return a matrix formed by joining args horizontally (i.e.\n@@ -378,7 +380,8 @@ def hstack(cls, *args):\n             return cls._new()\n \n         kls = type(args[0])\n-        return reduce(kls.row_join, args)\n+        result = reduce(kls.row_join, args)\n+        return result\n \n     def reshape(self, rows, cols):\n         \"\"\"Reshape the matrix. Total number of elements must remain the same.\n@@ -454,35 +457,36 @@ def row_insert(self, pos, other):\n \n         return self._eval_row_insert(pos, other)\n \n-    def row_join(self, other):\n-        \"\"\"Concatenates two matrices along self's last and rhs's first column\n \n-        Examples\n-        ========\n+def row_join(self, other):\n+    \"\"\"Concatenates two matrices along self's last and rhs's first column\n \n-        >>> from sympy import zeros, ones\n-        >>> M = zeros(3)\n-        >>> V = ones(3, 1)\n-        >>> M.row_join(V)\n-        Matrix([\n-        [0, 0, 0, 1],\n-        [0, 0, 0, 1],\n-        [0, 0, 0, 1]])\n+    Examples\n+    ========\n \n-        See Also\n-        ========\n+    >>> from sympy import zeros, ones\n+    >>> M = zeros(3)\n+    >>> V = ones(3, 1)\n+    >>> M.row_join(V)\n+    Matrix([\n+    [0, 0, 0, 1],\n+    [0, 0, 0, 1],\n+    [0, 0, 0, 1]])\n \n-        row\n-        col_join\n-        \"\"\"\n-        # A null matrix can always be stacked (see  #10770)\n-        if self.cols == 0 and self.rows != other.rows:\n-            return self._new(other.rows, 0, []).row_join(other)\n+    See Also\n+    ========\n \n-        if self.rows != other.rows:\n-            raise ShapeError(\n-                \"`self` and `rhs` must have the same number of rows.\")\n-        return self._eval_row_join(other)\n+    row\n+    col_join\n+    \"\"\"\n+    # A null matrix can always be stacked (see  #10770)\n+    if self.cols == 0 and self.rows != other.rows:\n+        return self._new(other.rows, 0, []).row_join(other)\n+\n+    if self.rows != other.rows:\n+        raise ShapeError(\n+            \"`self` and `rhs` must have the same number of rows.\")\n+    return self._eval_row_join(other)\n \n     def row(self, i):\n         \"\"\"Elementary row selector.\n@@ -2154,30 +2158,34 @@ class _MinimalMatrix(object):\n     def _new(cls, *args, **kwargs):\n         return cls(*args, **kwargs)\n \n-    def __init__(self, rows, cols=None, mat=None):\n-        if isinstance(mat, FunctionType):\n-            # if we passed in a function, use that to populate the indices\n-            mat = list(mat(i, j) for i in range(rows) for j in range(cols))\n-        try:\n-            if cols is None and mat is None:\n-                mat = rows\n-            rows, cols = mat.shape\n-        except AttributeError:\n-            pass\n-        try:\n-            # if we passed in a list of lists, flatten it and set the size\n-            if cols is None and mat is None:\n-                mat = rows\n-            cols = len(mat[0])\n-            rows = len(mat)\n-            mat = [x for l in mat for x in l]\n-        except (IndexError, TypeError):\n-            pass\n-        self.mat = tuple(self._sympify(x) for x in mat)\n-        self.rows, self.cols = rows, cols\n-        if self.rows is None or self.cols is None:\n-            raise NotImplementedError(\"Cannot initialize matrix with given parameters\")\n \n+def __init__(self, rows, cols=None, mat=None):\n+    if isinstance(mat, FunctionType):\n+        # if we passed in a function, use that to populate the indices\n+        if rows == 0:\n+            # For zero-height matrices, create empty list but preserve column structure\n+            mat = []\n+        else:\n+            mat = list(mat(i, j) for i in range(rows) for j in range(cols))\n+    try:\n+        if cols is None and mat is None:\n+            mat = rows\n+        rows, cols = mat.shape\n+    except AttributeError:\n+        pass\n+    try:\n+        # if we passed in a list of lists, flatten it and set the size\n+        if cols is None and mat is None:\n+            mat = rows\n+        cols = len(mat[0])\n+        rows = len(mat)\n+        mat = [x for l in mat for x in l]\n+    except (IndexError, TypeError):\n+        pass\n+    self.mat = tuple(self._sympify(x) for x in mat)\n+    self.rows, self.cols = rows, cols\n+    if self.rows is None or self.cols is None:\n+        raise NotImplementedError(\"Cannot initialize matrix with given parameters\")\n     def __getitem__(self, key):\n         def _normalize_slices(row_slice, col_slice):\n             \"\"\"Ensure that row_slice and col_slice don't have\n"
  }
}