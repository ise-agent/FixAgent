{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/matplotlib/lib/matplotlib/__init__.py lines 133-151)": "\ndef __getattr__(name):\n    if name == \"__version__\":\n        import setuptools_scm\n        global __version__  # cache it.\n        # Only shell out to a git subprocess if really needed, and not on a\n        # shallow clone, such as those used by CI, as the latter would trigger\n        # a warning from setuptools_scm.\n        root = Path(__file__).resolve().parents[2]\n        if (root / \".git\").exists() and not (root / \".git/shallow\").exists():\n            __version__ = setuptools_scm.get_version(\n                root=root,\n                version_scheme=\"post-release\",\n                local_scheme=\"node-and-date\",\n                fallback_version=_version.version,\n            )\n        else:  # Get the version from the _version.py setuptools_scm file.\n            __version__ = _version.version\n        return __version__\n    elif name == \"version_info\":\n        global __version_info__  # cache it.\n        try:\n            return __version_info__\n        except NameError:\n            # Get the version string using the same logic as __version__\n            version_str = __getattr__(\"__version__\")\n            \n            # Parse version using packaging.version\n            parsed = parse_version(version_str)\n            \n            # Extract components\n            major = parsed.major or 0\n            minor = parsed.minor or 0\n            micro = parsed.micro or 0\n            \n            # Determine release level and serial\n            if parsed.is_prerelease:\n                pre = parsed.pre\n                if pre:\n                    if pre[0] == 'a':\n                        releaselevel = 'alpha'\n                    elif pre[0] == 'b':\n                        releaselevel = 'beta'\n                    elif pre[0] == 'rc':\n                        releaselevel = 'candidate'\n                    else:\n                        releaselevel = 'alpha'\n                    serial = pre[1]\n                else:\n                    releaselevel = 'alpha'\n                    serial = 0\n            else:\n                releaselevel = 'final'\n                serial = 0\n            \n            __version_info__ = (major, minor, micro, releaselevel, serial)\n            return __version_info__\n    raise AttributeError(f\"module {__name__!r} has no attribute {name!r}\")\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/matplotlib/lib/matplotlib/__init__.py lines 133-151)": [
      "\ndef __getattr__(name):\n    if name == \"__version__\":\n        import setuptools_scm\n        global __version__  # cache it.\n        # Only shell out to a git subprocess if really needed, and not on a\n        # shallow clone, such as those used by CI, as the latter would trigger\n        # a warning from setuptools_scm.\n        root = Path(__file__).resolve().parents[2]\n        if (root / \".git\").exists() and not (root / \".git/shallow\").exists():\n            __version__ = setuptools_scm.get_version(\n                root=root,\n                version_scheme=\"post-release\",\n                local_scheme=\"node-and-date\",\n                fallback_version=_version.version,\n            )\n        else:  # Get the version from the _version.py setuptools_scm file.\n            __version__ = _version.version\n        return __version__\n    elif name == \"version_info\":\n        global __version_info__  # cache it.\n        try:\n            return __version_info__\n        except NameError:\n            pass\n        # Get version string using same logic as __version__\n        import setuptools_scm\n        root = Path(__file__).resolve().parents[2]\n        if (root / \".git\").exists() and not (root / \".git/shallow\").exists():\n            version_str = setuptools_scm.get_version(\n                root=root,\n                version_scheme=\"post-release\",\n                local_scheme=\"node-and-date\",\n                fallback_version=_version.version,\n            )\n        else:\n            version_str = _version.version\n        \n        # Parse version string into tuple\n        parsed = parse_version(version_str)\n        \n        # Convert to version_info tuple format (major, minor, micro, releaselevel, serial)\n        base_version = parsed.base_version.split('.')\n        major = int(base_version[0])\n        minor = int(base_version[1]) if len(base_version) > 1 else 0\n        micro = int(base_version[2]) if len(base_version) > 2 else 0\n        \n        # Determine release level and serial\n        if parsed.is_prerelease:\n            if parsed.pre:\n                pre_type, pre_num = parsed.pre\n                if pre_type == 'a':\n                    releaselevel, serial = 'alpha', pre_num\n                elif pre_type == 'b':\n                    releaselevel, serial = 'beta', pre_num\n                elif pre_type == 'rc':\n                    releaselevel, serial = 'candidate', pre_num\n                else:\n                    releaselevel, serial = 'alpha', 0\n            else:\n                releaselevel, serial = 'alpha', 0\n        else:\n            releaselevel, serial = 'final', 0\n            \n        __version_info__ = (major, minor, micro, releaselevel, serial)\n        return __version_info__\n    raise AttributeError(f\"module {__name__!r} has no attribute {name!r}\")\n",
      "\ndef __getattr__(name):\n    if name == \"__version__\":\n        import setuptools_scm\n        global __version__  # cache it.\n        # Only shell out to a git subprocess if really needed, and not on a\n        # shallow clone, such as those used by CI, as the latter would trigger\n        # a warning from setuptools_scm.\n        root = Path(__file__).resolve().parents[2]\n        if (root / \".git\").exists() and not (root / \".git/shallow\").exists():\n            __version__ = setuptools_scm.get_version(\n                root=root,\n                version_scheme=\"post-release\",\n                local_scheme=\"node-and-date\",\n                fallback_version=_version.version,\n            )\n        else:  # Get the version from the _version.py setuptools_scm file.\n            __version__ = _version.version\n        return __version__\n    elif name == \"version_info\":\n        global __version_info__  # cache it.\n        if '__version_info__' not in globals():\n            # Get the version string first\n            version_str = __getattr__(\"__version__\")\n            parsed = parse_version(version_str)\n            \n            # Extract major, minor, micro from base version\n            base_version = parsed.base_version.split('.')\n            major = int(base_version[0])\n            minor = int(base_version[1]) if len(base_version) > 1 else 0\n            micro = int(base_version[2]) if len(base_version) > 2 else 0\n            \n            # Determine release level and serial\n            if parsed.is_prerelease:\n                if parsed.pre:\n                    if parsed.pre[0] == 'a':\n                        releaselevel = 'alpha'\n                        serial = parsed.pre[1]\n                    elif parsed.pre[0] == 'b':\n                        releaselevel = 'beta'\n                        serial = parsed.pre[1]\n                    elif parsed.pre[0] == 'rc':\n                        releaselevel = 'candidate'\n                        serial = parsed.pre[1]\n                    else:\n                        releaselevel = 'alpha'\n                        serial = 0\n                else:\n                    releaselevel = 'alpha'\n                    serial = 0\n            else:\n                releaselevel = 'final'\n                serial = 0\n                \n            __version_info__ = (major, minor, micro, releaselevel, serial)\n        return __version_info__\n    raise AttributeError(f\"module {__name__!r} has no attribute {name!r}\")\n",
      "\ndef __getattr__(name):\n    if name == \"__version__\":\n        import setuptools_scm\n        global __version__  # cache it.\n        # Only shell out to a git subprocess if really needed, and not on a\n        # shallow clone, such as those used by CI, as the latter would trigger\n        # a warning from setuptools_scm.\n        root = Path(__file__).resolve().parents[2]\n        if (root / \".git\").exists() and not (root / \".git/shallow\").exists():\n            __version__ = setuptools_scm.get_version(\n                root=root,\n                version_scheme=\"post-release\",\n                local_scheme=\"node-and-date\",\n                fallback_version=_version.version,\n            )\n        else:  # Get the version from the _version.py setuptools_scm file.\n            __version__ = _version.version\n        return __version__\n    elif name == \"version_info\":\n        global __version_info__  # cache it.\n        if '__version_info__' not in globals():\n            # Get the version string first\n            version_str = __getattr__(\"__version__\")\n            parsed = parse_version(version_str)\n            \n            # Extract major, minor, micro from the base version\n            base_version = parsed.base_version.split('.')\n            major = int(base_version[0])\n            minor = int(base_version[1]) if len(base_version) > 1 else 0\n            micro = int(base_version[2]) if len(base_version) > 2 else 0\n            \n            # Determine release level and serial\n            if parsed.is_prerelease:\n                pre = parsed.pre\n                if pre[0] == 'a':\n                    releaselevel = 'alpha'\n                elif pre[0] == 'b':\n                    releaselevel = 'beta'\n                elif pre[0] == 'rc':\n                    releaselevel = 'candidate'\n                else:\n                    releaselevel = 'alpha'  # fallback\n                serial = pre[1]\n            else:\n                releaselevel = 'final'\n                serial = 0\n            \n            __version_info__ = (major, minor, micro, releaselevel, serial)\n        return __version_info__\n    raise AttributeError(f\"module {__name__!r} has no attribute {name!r}\")\n",
      "\ndef __getattr__(name):\n    if name == \"__version__\":\n        import setuptools_scm\n        global __version__  # cache it.\n        # Only shell out to a git subprocess if really needed, and not on a\n        # shallow clone, such as those used by CI, as the latter would trigger\n        # a warning from setuptools_scm.\n        root = Path(__file__).resolve().parents[2]\n        if (root / \".git\").exists() and not (root / \".git/shallow\").exists():\n            __version__ = setuptools_scm.get_version(\n                root=root,\n                version_scheme=\"post-release\",\n                local_scheme=\"node-and-date\",\n                fallback_version=_version.version,\n            )\n        else:  # Get the version from the _version.py setuptools_scm file.\n            __version__ = _version.version\n        return __version__\n    elif name == \"version_info\":\n        global __version_info__  # cache it.\n        if \"__version_info__\" not in globals():\n            # Get the version string first\n            version_str = __getattr__(\"__version__\")\n            parsed = parse_version(version_str)\n            \n            # Extract major, minor, micro\n            release = parsed.release\n            major = release[0] if len(release) > 0 else 0\n            minor = release[1] if len(release) > 1 else 0\n            micro = release[2] if len(release) > 2 else 0\n            \n            # Determine release level and serial\n            if parsed.is_prerelease:\n                if parsed.pre:\n                    pre_type, pre_num = parsed.pre\n                    if pre_type == 'a':\n                        releaselevel, serial = 'alpha', pre_num\n                    elif pre_type == 'b':\n                        releaselevel, serial = 'beta', pre_num\n                    elif pre_type == 'rc':\n                        releaselevel, serial = 'candidate', pre_num\n                    else:\n                        releaselevel, serial = 'alpha', 0\n                else:\n                    releaselevel, serial = 'alpha', 0\n            else:\n                releaselevel, serial = 'final', 0\n                \n            __version_info__ = (major, minor, micro, releaselevel, serial)\n        return __version_info__\n    raise AttributeError(f\"module {__name__!r} has no attribute {name!r}\")\n",
      "\ndef __getattr__(name):\n    if name == \"__version__\":\n        import setuptools_scm\n        global __version__  # cache it.\n        # Only shell out to a git subprocess if really needed, and not on a\n        # shallow clone, such as those used by CI, as the latter would trigger\n        # a warning from setuptools_scm.\n        root = Path(__file__).resolve().parents[2]\n        if (root / \".git\").exists() and not (root / \".git/shallow\").exists():\n            __version__ = setuptools_scm.get_version(\n                root=root,\n                version_scheme=\"post-release\",\n                local_scheme=\"node-and-date\",\n                fallback_version=_version.version,\n            )\n        else:  # Get the version from the _version.py setuptools_scm file.\n            __version__ = _version.version\n        return __version__\n    elif name == \"version_info\":\n        global __version_info__  # cache it.\n        if \"__version_info__\" not in globals():\n            # Get __version__ first (using the same logic as above)\n            version_str = __getattr__(\"__version__\")\n            __version_info__ = _parse_version_info(version_str)\n        return __version_info__\n    raise AttributeError(f\"module {__name__!r} has no attribute {name!r}\")\n\n\ndef _parse_version_info(version_string):\n    \"\"\"Parse a version string into a version_info tuple.\"\"\"\n    parsed = parse_version(version_string)\n    \n    # Extract base version components\n    base_version = parsed.base_version.split('.')\n    major = int(base_version[0])\n    minor = int(base_version[1]) if len(base_version) > 1 else 0\n    micro = int(base_version[2]) if len(base_version) > 2 else 0\n    \n    # Determine release level and serial\n    if parsed.is_prerelease:\n        if parsed.pre:\n            pre_type, pre_num = parsed.pre\n            if pre_type == 'a':\n                releaselevel = 'alpha'\n            elif pre_type == 'b':\n                releaselevel = 'beta'\n            elif pre_type in ('rc', 'c'):\n                releaselevel = 'candidate'\n            else:\n                releaselevel = 'alpha'  # fallback\n            serial = pre_num\n        else:\n            releaselevel = 'alpha'\n            serial = 0\n    else:\n        releaselevel = 'final'\n        serial = 0\n    \n    return (major, minor, micro, releaselevel, serial)\n",
      "\ndef __getattr__(name):\n    if name == \"__version__\":\n        import setuptools_scm\n        global __version__  # cache it.\n        # Only shell out to a git subprocess if really needed, and not on a\n        # shallow clone, such as those used by CI, as the latter would trigger\n        # a warning from setuptools_scm.\n        root = Path(__file__).resolve().parents[2]\n        if (root / \".git\").exists() and not (root / \".git/shallow\").exists():\n            __version__ = setuptools_scm.get_version(\n                root=root,\n                version_scheme=\"post-release\",\n                local_scheme=\"node-and-date\",\n                fallback_version=_version.version,\n            )\n        else:  # Get the version from the _version.py setuptools_scm file.\n            __version__ = _version.version\n        return __version__\n    elif name == \"version_info\":\n        global __version_info__  # cache it.\n        if '__version_info__' not in globals():\n            # Get the version string first\n            version_str = __getattr__(\"__version__\")\n            parsed = parse_version(version_str)\n            \n            # Extract major, minor, micro from base version\n            parts = parsed.base_version.split('.')\n            major = int(parts[0])\n            minor = int(parts[1]) if len(parts) > 1 else 0\n            micro = int(parts[2]) if len(parts) > 2 else 0\n            \n            # Determine release level and serial\n            if parsed.is_prerelease:\n                pre = parsed.pre\n                if pre:\n                    if pre[0] == 'a':\n                        releaselevel = 'alpha'\n                    elif pre[0] == 'b':\n                        releaselevel = 'beta'\n                    elif pre[0] == 'rc':\n                        releaselevel = 'candidate'\n                    else:\n                        releaselevel = 'alpha'\n                    serial = pre[1]\n                else:\n                    releaselevel = 'alpha'\n                    serial = 0\n            else:\n                releaselevel = 'final'\n                serial = 0\n            \n            __version_info__ = (major, minor, micro, releaselevel, serial)\n        return __version_info__\n    raise AttributeError(f\"module {__name__!r} has no attribute {name!r}\")\n",
      "\ndef __getattr__(name):\n    if name == \"__version__\":\n        import setuptools_scm\n        global __version__  # cache it.\n        # Only shell out to a git subprocess if really needed, and not on a\n        # shallow clone, such as those used by CI, as the latter would trigger\n        # a warning from setuptools_scm.\n        root = Path(__file__).resolve().parents[2]\n        if (root / \".git\").exists() and not (root / \".git/shallow\").exists():\n            __version__ = setuptools_scm.get_version(\n                root=root,\n                version_scheme=\"post-release\",\n                local_scheme=\"node-and-date\",\n                fallback_version=_version.version,\n            )\n        else:  # Get the version from the _version.py setuptools_scm file.\n            __version__ = _version.version\n        return __version__\n    elif name == \"version_info\":\n        global __version_info__  # cache it.\n        if '__version_info__' not in globals():\n            # Get the version string first\n            version_str = __getattr__(\"__version__\")\n            \n            # Parse version using packaging.version\n            parsed = parse_version(version_str)\n            \n            # Extract components\n            major = parsed.major\n            minor = parsed.minor\n            micro = parsed.micro\n            \n            # Determine release level and serial\n            if parsed.is_prerelease:\n                pre = parsed.pre\n                if pre:\n                    if pre[0] == 'a':\n                        releaselevel = 'alpha'\n                        serial = pre[1]\n                    elif pre[0] == 'b':\n                        releaselevel = 'beta'\n                        serial = pre[1]\n                    elif pre[0] == 'rc':\n                        releaselevel = 'candidate'\n                        serial = pre[1]\n                    else:\n                        releaselevel = 'alpha'\n                        serial = 0\n                else:\n                    releaselevel = 'alpha'\n                    serial = 0\n            else:\n                releaselevel = 'final'\n                serial = 0\n            \n            __version_info__ = (major, minor, micro, releaselevel, serial)\n        \n        return __version_info__\n    raise AttributeError(f\"module {__name__!r} has no attribute {name!r}\")\n",
      "\ndef __getattr__(name):\n    if name == \"__version__\":\n        import setuptools_scm\n        global __version__  # cache it.\n        # Only shell out to a git subprocess if really needed, and not on a\n        # shallow clone, such as those used by CI, as the latter would trigger\n        # a warning from setuptools_scm.\n        root = Path(__file__).resolve().parents[2]\n        if (root / \".git\").exists() and not (root / \".git/shallow\").exists():\n            __version__ = setuptools_scm.get_version(\n                root=root,\n                version_scheme=\"post-release\",\n                local_scheme=\"node-and-date\",\n                fallback_version=_version.version,\n            )\n        else:  # Get the version from the _version.py setuptools_scm file.\n            __version__ = _version.version\n        return __version__\n    elif name == \"version_info\":\n        global __version_info__  # cache it.\n        try:\n            return __version_info__\n        except NameError:\n            pass\n        \n        # Get the version string first\n        version_str = __getattr__(\"__version__\")\n        \n        # Parse version using packaging.version\n        parsed = parse_version(version_str)\n        \n        # Convert to version_info tuple format\n        base_version = parsed.base_version.split('.')\n        major = int(base_version[0])\n        minor = int(base_version[1]) if len(base_version) > 1 else 0\n        micro = int(base_version[2]) if len(base_version) > 2 else 0\n        \n        # Determine release level and serial\n        if parsed.is_prerelease:\n            if parsed.pre:\n                releaselevel = 'alpha' if parsed.pre[0] == 'a' else 'beta' if parsed.pre[0] == 'b' else 'candidate'\n                serial = parsed.pre[1]\n            else:\n                releaselevel = 'alpha'\n                serial = 0\n        else:\n            releaselevel = 'final'\n            serial = 0\n            \n        __version_info__ = (major, minor, micro, releaselevel, serial)\n        return __version_info__\n    raise AttributeError(f\"module {__name__!r} has no attribute {name!r}\")\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex b657a35cf7..ceb11374d4 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -130,6 +130,7 @@ __bibtex__ = r\"\"\"@Article{Hunter:2007,\n }\"\"\"\n \n \n+\n def __getattr__(name):\n     if name == \"__version__\":\n         import setuptools_scm\n@@ -148,6 +149,55 @@ def __getattr__(name):\n         else:  # Get the version from the _version.py setuptools_scm file.\n             __version__ = _version.version\n         return __version__\n+    elif name == \"version_info\":\n+        import setuptools_scm\n+        global __version_info__  # cache it.\n+        \n+        # Get the version string using the same logic as __version__\n+        root = Path(__file__).resolve().parents[2]\n+        if (root / \".git\").exists() and not (root / \".git/shallow\").exists():\n+            version_string = setuptools_scm.get_version(\n+                root=root,\n+                version_scheme=\"post-release\",\n+                local_scheme=\"node-and-date\",\n+                fallback_version=_version.version,\n+            )\n+        else:  # Get the version from the _version.py setuptools_scm file.\n+            version_string = _version.version\n+        \n+        # Parse version string into comparable tuple\n+        parsed = parse_version(version_string)\n+        \n+        # Convert to version_info tuple format: (major, minor, micro, releaselevel, serial)\n+        major = parsed.major or 0\n+        minor = parsed.minor or 0\n+        micro = parsed.micro or 0\n+        \n+        # Handle pre-release and development versions\n+        if parsed.is_prerelease:\n+            if parsed.pre:\n+                pre_type, pre_num = parsed.pre\n+                if pre_type == 'a':\n+                    releaselevel = 'alpha'\n+                elif pre_type == 'b':\n+                    releaselevel = 'beta'\n+                elif pre_type == 'rc':\n+                    releaselevel = 'candidate'\n+                else:\n+                    releaselevel = 'alpha'  # fallback\n+                serial = pre_num\n+            else:\n+                releaselevel = 'alpha'\n+                serial = 0\n+        elif parsed.is_devrelease:\n+            releaselevel = 'alpha'\n+            serial = parsed.dev or 0\n+        else:\n+            releaselevel = 'final'\n+            serial = 0\n+        \n+        __version_info__ = (major, minor, micro, releaselevel, serial)\n+        return __version_info__\n     raise AttributeError(f\"module {__name__!r} has no attribute {name!r}\")\n \n \n",
    "variant_0": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex b657a35cf7..fce2ef9ab6 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -130,6 +130,7 @@ __bibtex__ = r\"\"\"@Article{Hunter:2007,\n }\"\"\"\n \n \n+\n def __getattr__(name):\n     if name == \"__version__\":\n         import setuptools_scm\n@@ -148,6 +149,44 @@ def __getattr__(name):\n         else:  # Get the version from the _version.py setuptools_scm file.\n             __version__ = _version.version\n         return __version__\n+    elif name == \"version_info\":\n+        global __version_info__  # cache it.\n+        try:\n+            return __version_info__\n+        except NameError:\n+            # Get the version string using the same logic as __version__\n+            version_str = __getattr__(\"__version__\")\n+            \n+            # Parse version using packaging.version\n+            parsed = parse_version(version_str)\n+            \n+            # Extract components\n+            major = parsed.major or 0\n+            minor = parsed.minor or 0\n+            micro = parsed.micro or 0\n+            \n+            # Determine release level and serial\n+            if parsed.is_prerelease:\n+                pre = parsed.pre\n+                if pre:\n+                    if pre[0] == 'a':\n+                        releaselevel = 'alpha'\n+                    elif pre[0] == 'b':\n+                        releaselevel = 'beta'\n+                    elif pre[0] == 'rc':\n+                        releaselevel = 'candidate'\n+                    else:\n+                        releaselevel = 'alpha'\n+                    serial = pre[1]\n+                else:\n+                    releaselevel = 'alpha'\n+                    serial = 0\n+            else:\n+                releaselevel = 'final'\n+                serial = 0\n+            \n+            __version_info__ = (major, minor, micro, releaselevel, serial)\n+            return __version_info__\n     raise AttributeError(f\"module {__name__!r} has no attribute {name!r}\")\n \n \n",
    "variant_1": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex b657a35cf7..6a5c7f1e22 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -130,6 +130,7 @@ __bibtex__ = r\"\"\"@Article{Hunter:2007,\n }\"\"\"\n \n \n+\n def __getattr__(name):\n     if name == \"__version__\":\n         import setuptools_scm\n@@ -148,6 +149,53 @@ def __getattr__(name):\n         else:  # Get the version from the _version.py setuptools_scm file.\n             __version__ = _version.version\n         return __version__\n+    elif name == \"version_info\":\n+        global __version_info__  # cache it.\n+        try:\n+            return __version_info__\n+        except NameError:\n+            pass\n+        # Get version string using same logic as __version__\n+        import setuptools_scm\n+        root = Path(__file__).resolve().parents[2]\n+        if (root / \".git\").exists() and not (root / \".git/shallow\").exists():\n+            version_str = setuptools_scm.get_version(\n+                root=root,\n+                version_scheme=\"post-release\",\n+                local_scheme=\"node-and-date\",\n+                fallback_version=_version.version,\n+            )\n+        else:\n+            version_str = _version.version\n+        \n+        # Parse version string into tuple\n+        parsed = parse_version(version_str)\n+        \n+        # Convert to version_info tuple format (major, minor, micro, releaselevel, serial)\n+        base_version = parsed.base_version.split('.')\n+        major = int(base_version[0])\n+        minor = int(base_version[1]) if len(base_version) > 1 else 0\n+        micro = int(base_version[2]) if len(base_version) > 2 else 0\n+        \n+        # Determine release level and serial\n+        if parsed.is_prerelease:\n+            if parsed.pre:\n+                pre_type, pre_num = parsed.pre\n+                if pre_type == 'a':\n+                    releaselevel, serial = 'alpha', pre_num\n+                elif pre_type == 'b':\n+                    releaselevel, serial = 'beta', pre_num\n+                elif pre_type == 'rc':\n+                    releaselevel, serial = 'candidate', pre_num\n+                else:\n+                    releaselevel, serial = 'alpha', 0\n+            else:\n+                releaselevel, serial = 'alpha', 0\n+        else:\n+            releaselevel, serial = 'final', 0\n+            \n+        __version_info__ = (major, minor, micro, releaselevel, serial)\n+        return __version_info__\n     raise AttributeError(f\"module {__name__!r} has no attribute {name!r}\")\n \n \n",
    "variant_2": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex b657a35cf7..b76291d213 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -130,6 +130,7 @@ __bibtex__ = r\"\"\"@Article{Hunter:2007,\n }\"\"\"\n \n \n+\n def __getattr__(name):\n     if name == \"__version__\":\n         import setuptools_scm\n@@ -148,6 +149,43 @@ def __getattr__(name):\n         else:  # Get the version from the _version.py setuptools_scm file.\n             __version__ = _version.version\n         return __version__\n+    elif name == \"version_info\":\n+        global __version_info__  # cache it.\n+        if '__version_info__' not in globals():\n+            # Get the version string first\n+            version_str = __getattr__(\"__version__\")\n+            parsed = parse_version(version_str)\n+            \n+            # Extract major, minor, micro from base version\n+            base_version = parsed.base_version.split('.')\n+            major = int(base_version[0])\n+            minor = int(base_version[1]) if len(base_version) > 1 else 0\n+            micro = int(base_version[2]) if len(base_version) > 2 else 0\n+            \n+            # Determine release level and serial\n+            if parsed.is_prerelease:\n+                if parsed.pre:\n+                    if parsed.pre[0] == 'a':\n+                        releaselevel = 'alpha'\n+                        serial = parsed.pre[1]\n+                    elif parsed.pre[0] == 'b':\n+                        releaselevel = 'beta'\n+                        serial = parsed.pre[1]\n+                    elif parsed.pre[0] == 'rc':\n+                        releaselevel = 'candidate'\n+                        serial = parsed.pre[1]\n+                    else:\n+                        releaselevel = 'alpha'\n+                        serial = 0\n+                else:\n+                    releaselevel = 'alpha'\n+                    serial = 0\n+            else:\n+                releaselevel = 'final'\n+                serial = 0\n+                \n+            __version_info__ = (major, minor, micro, releaselevel, serial)\n+        return __version_info__\n     raise AttributeError(f\"module {__name__!r} has no attribute {name!r}\")\n \n \n",
    "variant_3": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex b657a35cf7..6b03b65d9f 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -130,6 +130,7 @@ __bibtex__ = r\"\"\"@Article{Hunter:2007,\n }\"\"\"\n \n \n+\n def __getattr__(name):\n     if name == \"__version__\":\n         import setuptools_scm\n@@ -148,6 +149,37 @@ def __getattr__(name):\n         else:  # Get the version from the _version.py setuptools_scm file.\n             __version__ = _version.version\n         return __version__\n+    elif name == \"version_info\":\n+        global __version_info__  # cache it.\n+        if '__version_info__' not in globals():\n+            # Get the version string first\n+            version_str = __getattr__(\"__version__\")\n+            parsed = parse_version(version_str)\n+            \n+            # Extract major, minor, micro from the base version\n+            base_version = parsed.base_version.split('.')\n+            major = int(base_version[0])\n+            minor = int(base_version[1]) if len(base_version) > 1 else 0\n+            micro = int(base_version[2]) if len(base_version) > 2 else 0\n+            \n+            # Determine release level and serial\n+            if parsed.is_prerelease:\n+                pre = parsed.pre\n+                if pre[0] == 'a':\n+                    releaselevel = 'alpha'\n+                elif pre[0] == 'b':\n+                    releaselevel = 'beta'\n+                elif pre[0] == 'rc':\n+                    releaselevel = 'candidate'\n+                else:\n+                    releaselevel = 'alpha'  # fallback\n+                serial = pre[1]\n+            else:\n+                releaselevel = 'final'\n+                serial = 0\n+            \n+            __version_info__ = (major, minor, micro, releaselevel, serial)\n+        return __version_info__\n     raise AttributeError(f\"module {__name__!r} has no attribute {name!r}\")\n \n \n",
    "variant_4": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex b657a35cf7..ff9598ff97 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -130,6 +130,7 @@ __bibtex__ = r\"\"\"@Article{Hunter:2007,\n }\"\"\"\n \n \n+\n def __getattr__(name):\n     if name == \"__version__\":\n         import setuptools_scm\n@@ -148,6 +149,38 @@ def __getattr__(name):\n         else:  # Get the version from the _version.py setuptools_scm file.\n             __version__ = _version.version\n         return __version__\n+    elif name == \"version_info\":\n+        global __version_info__  # cache it.\n+        if \"__version_info__\" not in globals():\n+            # Get the version string first\n+            version_str = __getattr__(\"__version__\")\n+            parsed = parse_version(version_str)\n+            \n+            # Extract major, minor, micro\n+            release = parsed.release\n+            major = release[0] if len(release) > 0 else 0\n+            minor = release[1] if len(release) > 1 else 0\n+            micro = release[2] if len(release) > 2 else 0\n+            \n+            # Determine release level and serial\n+            if parsed.is_prerelease:\n+                if parsed.pre:\n+                    pre_type, pre_num = parsed.pre\n+                    if pre_type == 'a':\n+                        releaselevel, serial = 'alpha', pre_num\n+                    elif pre_type == 'b':\n+                        releaselevel, serial = 'beta', pre_num\n+                    elif pre_type == 'rc':\n+                        releaselevel, serial = 'candidate', pre_num\n+                    else:\n+                        releaselevel, serial = 'alpha', 0\n+                else:\n+                    releaselevel, serial = 'alpha', 0\n+            else:\n+                releaselevel, serial = 'final', 0\n+                \n+            __version_info__ = (major, minor, micro, releaselevel, serial)\n+        return __version_info__\n     raise AttributeError(f\"module {__name__!r} has no attribute {name!r}\")\n \n \n",
    "variant_5": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex b657a35cf7..90689de65b 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -130,6 +130,7 @@ __bibtex__ = r\"\"\"@Article{Hunter:2007,\n }\"\"\"\n \n \n+\n def __getattr__(name):\n     if name == \"__version__\":\n         import setuptools_scm\n@@ -148,9 +149,49 @@ def __getattr__(name):\n         else:  # Get the version from the _version.py setuptools_scm file.\n             __version__ = _version.version\n         return __version__\n+    elif name == \"version_info\":\n+        global __version_info__  # cache it.\n+        if \"__version_info__\" not in globals():\n+            # Get __version__ first (using the same logic as above)\n+            version_str = __getattr__(\"__version__\")\n+            __version_info__ = _parse_version_info(version_str)\n+        return __version_info__\n     raise AttributeError(f\"module {__name__!r} has no attribute {name!r}\")\n \n \n+def _parse_version_info(version_string):\n+    \"\"\"Parse a version string into a version_info tuple.\"\"\"\n+    parsed = parse_version(version_string)\n+    \n+    # Extract base version components\n+    base_version = parsed.base_version.split('.')\n+    major = int(base_version[0])\n+    minor = int(base_version[1]) if len(base_version) > 1 else 0\n+    micro = int(base_version[2]) if len(base_version) > 2 else 0\n+    \n+    # Determine release level and serial\n+    if parsed.is_prerelease:\n+        if parsed.pre:\n+            pre_type, pre_num = parsed.pre\n+            if pre_type == 'a':\n+                releaselevel = 'alpha'\n+            elif pre_type == 'b':\n+                releaselevel = 'beta'\n+            elif pre_type in ('rc', 'c'):\n+                releaselevel = 'candidate'\n+            else:\n+                releaselevel = 'alpha'  # fallback\n+            serial = pre_num\n+        else:\n+            releaselevel = 'alpha'\n+            serial = 0\n+    else:\n+        releaselevel = 'final'\n+        serial = 0\n+    \n+    return (major, minor, micro, releaselevel, serial)\n+\n+\n def _check_versions():\n \n     # Quickfix to ensure Microsoft Visual C++ redistributable\n",
    "variant_6": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex b657a35cf7..21ee5d7bc0 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -130,6 +130,7 @@ __bibtex__ = r\"\"\"@Article{Hunter:2007,\n }\"\"\"\n \n \n+\n def __getattr__(name):\n     if name == \"__version__\":\n         import setuptools_scm\n@@ -148,6 +149,41 @@ def __getattr__(name):\n         else:  # Get the version from the _version.py setuptools_scm file.\n             __version__ = _version.version\n         return __version__\n+    elif name == \"version_info\":\n+        global __version_info__  # cache it.\n+        if '__version_info__' not in globals():\n+            # Get the version string first\n+            version_str = __getattr__(\"__version__\")\n+            parsed = parse_version(version_str)\n+            \n+            # Extract major, minor, micro from base version\n+            parts = parsed.base_version.split('.')\n+            major = int(parts[0])\n+            minor = int(parts[1]) if len(parts) > 1 else 0\n+            micro = int(parts[2]) if len(parts) > 2 else 0\n+            \n+            # Determine release level and serial\n+            if parsed.is_prerelease:\n+                pre = parsed.pre\n+                if pre:\n+                    if pre[0] == 'a':\n+                        releaselevel = 'alpha'\n+                    elif pre[0] == 'b':\n+                        releaselevel = 'beta'\n+                    elif pre[0] == 'rc':\n+                        releaselevel = 'candidate'\n+                    else:\n+                        releaselevel = 'alpha'\n+                    serial = pre[1]\n+                else:\n+                    releaselevel = 'alpha'\n+                    serial = 0\n+            else:\n+                releaselevel = 'final'\n+                serial = 0\n+            \n+            __version_info__ = (major, minor, micro, releaselevel, serial)\n+        return __version_info__\n     raise AttributeError(f\"module {__name__!r} has no attribute {name!r}\")\n \n \n",
    "variant_7": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex b657a35cf7..eb6e1d8180 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -130,6 +130,7 @@ __bibtex__ = r\"\"\"@Article{Hunter:2007,\n }\"\"\"\n \n \n+\n def __getattr__(name):\n     if name == \"__version__\":\n         import setuptools_scm\n@@ -148,6 +149,46 @@ def __getattr__(name):\n         else:  # Get the version from the _version.py setuptools_scm file.\n             __version__ = _version.version\n         return __version__\n+    elif name == \"version_info\":\n+        global __version_info__  # cache it.\n+        if '__version_info__' not in globals():\n+            # Get the version string first\n+            version_str = __getattr__(\"__version__\")\n+            \n+            # Parse version using packaging.version\n+            parsed = parse_version(version_str)\n+            \n+            # Extract components\n+            major = parsed.major\n+            minor = parsed.minor\n+            micro = parsed.micro\n+            \n+            # Determine release level and serial\n+            if parsed.is_prerelease:\n+                pre = parsed.pre\n+                if pre:\n+                    if pre[0] == 'a':\n+                        releaselevel = 'alpha'\n+                        serial = pre[1]\n+                    elif pre[0] == 'b':\n+                        releaselevel = 'beta'\n+                        serial = pre[1]\n+                    elif pre[0] == 'rc':\n+                        releaselevel = 'candidate'\n+                        serial = pre[1]\n+                    else:\n+                        releaselevel = 'alpha'\n+                        serial = 0\n+                else:\n+                    releaselevel = 'alpha'\n+                    serial = 0\n+            else:\n+                releaselevel = 'final'\n+                serial = 0\n+            \n+            __version_info__ = (major, minor, micro, releaselevel, serial)\n+        \n+        return __version_info__\n     raise AttributeError(f\"module {__name__!r} has no attribute {name!r}\")\n \n \n",
    "variant_8": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex b657a35cf7..5f929bc57a 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -130,6 +130,7 @@ __bibtex__ = r\"\"\"@Article{Hunter:2007,\n }\"\"\"\n \n \n+\n def __getattr__(name):\n     if name == \"__version__\":\n         import setuptools_scm\n@@ -148,6 +149,39 @@ def __getattr__(name):\n         else:  # Get the version from the _version.py setuptools_scm file.\n             __version__ = _version.version\n         return __version__\n+    elif name == \"version_info\":\n+        global __version_info__  # cache it.\n+        try:\n+            return __version_info__\n+        except NameError:\n+            pass\n+        \n+        # Get the version string first\n+        version_str = __getattr__(\"__version__\")\n+        \n+        # Parse version using packaging.version\n+        parsed = parse_version(version_str)\n+        \n+        # Convert to version_info tuple format\n+        base_version = parsed.base_version.split('.')\n+        major = int(base_version[0])\n+        minor = int(base_version[1]) if len(base_version) > 1 else 0\n+        micro = int(base_version[2]) if len(base_version) > 2 else 0\n+        \n+        # Determine release level and serial\n+        if parsed.is_prerelease:\n+            if parsed.pre:\n+                releaselevel = 'alpha' if parsed.pre[0] == 'a' else 'beta' if parsed.pre[0] == 'b' else 'candidate'\n+                serial = parsed.pre[1]\n+            else:\n+                releaselevel = 'alpha'\n+                serial = 0\n+        else:\n+            releaselevel = 'final'\n+            serial = 0\n+            \n+        __version_info__ = (major, minor, micro, releaselevel, serial)\n+        return __version_info__\n     raise AttributeError(f\"module {__name__!r} has no attribute {name!r}\")\n \n \n"
  }
}