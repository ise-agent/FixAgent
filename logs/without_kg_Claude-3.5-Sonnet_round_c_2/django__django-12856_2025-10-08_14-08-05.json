{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/django/django/db/models/base.py lines 1867-1929)": "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Check UniqueConstraint field existence\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                'supports_table_check_constraints' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, CheckConstraint)\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support check constraints.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W027',\n                    )\n                )\n            if not (\n                connection.features.supports_partial_indexes or\n                'supports_partial_indexes' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support unique constraints with '\n                        'conditions.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W036',\n                    )\n                )\n            if not (\n                connection.features.supports_deferrable_unique_constraints or\n                'supports_deferrable_unique_constraints' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, UniqueConstraint) and constraint.deferrable is not None\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support deferrable unique constraints.'\n                        % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W038',\n                    )\n                )\n        return errors\n",
    "Location 2 (/root/hy/projects_2/django/django/db/models/base.py lines 1640-1680)": "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                connection.features.supports_column_check_constraints\n            ):\n                errors.extend(cls._check_constraints_database_backends(db))\n            if connection.features.supports_over_clause:\n                errors.extend(cls._check_constraints_sql_funcs(db))\n        \n        # Validate UniqueConstraint fields exist\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        return errors\n",
    "Location 3 (/root/hy/projects_2/django/django/db/models/base.py lines 1582-1586)": "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for constraint in cls._meta.constraints:\n            if hasattr(constraint, 'check'):\n                constraint_databases = constraint.check.get_group_by_cols()\n            else:\n                constraint_databases = None\n            if not databases.intersection(constraint_databases or [DEFAULT_DB_ALIAS]):\n                continue\n            errors.extend(constraint.check(databases))\n            # Check UniqueConstraint field existence\n            if constraint.__class__.__name__ == 'UniqueConstraint':\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        return errors\n",
    "Location 4 (/root/hy/projects_2/django/django/db/models/constraints.py lines 79-98)": "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            for constraint in cls._meta.constraints:\n                # Validate UniqueConstraint fields\n                if hasattr(constraint, 'fields') and constraint.__class__.__name__ == 'UniqueConstraint':\n                    errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n                errors.extend(constraint.validate(model=cls, exclude=None, using=db))\n        return errors\n",
    "Location 5 (/root/hy/projects_2/django/django/db/models/constraints.py lines 107-108)": "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            for constraint in cls._meta.constraints:\n                # Check field existence for UniqueConstraint\n                if constraint.__class__.__name__ == 'UniqueConstraint':\n                    errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n                errors.extend(constraint.validate(model=cls, exclude=None))\n        return errors\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/django/django/db/models/base.py lines 1867-1929)": [
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        # Check field existence for UniqueConstraints\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                'supports_table_check_constraints' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, CheckConstraint)\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support check constraints.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W027',\n                    )\n                )\n            if not (\n                connection.features.supports_partial_indexes or\n                'supports_partial_indexes' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support unique constraints with '\n                        'conditions.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W036',\n                    )\n                )\n            if not (\n                connection.features.supports_deferrable_unique_constraints or\n                'supports_deferrable_unique_constraints' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, UniqueConstraint) and constraint.deferrable is not None\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support deferrable unique constraints.'\n                        % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W038',\n                    )\n                )\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Validate UniqueConstraint fields exist\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                'supports_table_check_constraints' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, CheckConstraint)\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support check constraints.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W027',\n                    )\n                )\n            if not (\n                connection.features.supports_partial_indexes or\n                'supports_partial_indexes' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support unique constraints with '\n                        'conditions.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W036',\n                    )\n                )\n            if not (\n                connection.features.supports_deferrable_unique_constraints or\n                'supports_deferrable_unique_constraints' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, UniqueConstraint) and constraint.deferrable is not None\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support deferrable unique constraints.'\n                        % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W038',\n                    )\n                )\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Check UniqueConstraint field validation\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                'supports_table_check_constraints' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, CheckConstraint)\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support check constraints.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W027',\n                    )\n                )\n            if not (\n                connection.features.supports_partial_indexes or\n                'supports_partial_indexes' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support unique constraints with '\n                        'conditions.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W036',\n                    )\n                )\n            if not (\n                connection.features.supports_deferrable_unique_constraints or\n                'supports_deferrable_unique_constraints' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, UniqueConstraint) and constraint.deferrable is not None\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support deferrable unique constraints.'\n                        % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W038',\n                    )\n                )\n        return errors\n",
      "\n@classmethod\ndef _check_constraints(cls, databases):\n    errors = []\n    \n    # Validate UniqueConstraint fields exist\n    for constraint in cls._meta.constraints:\n        if isinstance(constraint, UniqueConstraint):\n            errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n    \n    for db in databases:\n        if not router.allow_migrate_model(db, cls):\n            continue\n        connection = connections[db]\n        if not (\n            connection.features.supports_table_check_constraints or\n            'supports_table_check_constraints' in cls._meta.required_db_features\n        ) and any(\n            isinstance(constraint, CheckConstraint)\n            for constraint in cls._meta.constraints\n        ):\n            errors.append(\n                checks.Warning(\n                    '%s does not support check constraints.' % connection.display_name,\n                    hint=(\n                        \"A constraint won't be created. Silence this \"\n                        \"warning if you don't care about it.\"\n                    ),\n                    obj=cls,\n                    id='models.W027',\n                )\n            )\n        if not (\n            connection.features.supports_partial_indexes or\n            'supports_partial_indexes' in cls._meta.required_db_features\n        ) and any(\n            isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n            for constraint in cls._meta.constraints\n        ):\n            errors.append(\n                checks.Warning(\n                    '%s does not support unique constraints with '\n                    'conditions.' % connection.display_name,\n                    hint=(\n                        \"A constraint won't be created. Silence this \"\n                        \"warning if you don't care about it.\"\n                    ),\n                    obj=cls,\n                    id='models.W036',\n                )\n            )\n        if not (\n            connection.features.supports_deferrable_unique_constraints or\n            'supports_deferrable_unique_constraints' in cls._meta.required_db_features\n        ) and any(\n            isinstance(constraint, UniqueConstraint) and constraint.deferrable is not None\n            for constraint in cls._meta.constraints\n        ):\n            errors.append(\n                checks.Warning(\n                    '%s does not support deferrable unique constraints.'\n                    % connection.display_name,\n                    hint=(\n                        \"A constraint won't be created. Silence this \"\n                        \"warning if you don't care about it.\"\n                    ),\n                    obj=cls,\n                    id='models.W038',\n                )\n            )\n    return errors\n",
      "\n@classmethod\ndef _check_constraints(cls, databases):\n    errors = []\n    \n    # Validate UniqueConstraint fields exist\n    for constraint in cls._meta.constraints:\n        if isinstance(constraint, UniqueConstraint):\n            errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n    \n    for db in databases:\n        if not router.allow_migrate_model(db, cls):\n            continue\n        connection = connections[db]\n        if not (\n            connection.features.supports_table_check_constraints or\n            'supports_table_check_constraints' in cls._meta.required_db_features\n        ) and any(\n            isinstance(constraint, CheckConstraint)\n            for constraint in cls._meta.constraints\n        ):\n            errors.append(\n                checks.Warning(\n                    '%s does not support check constraints.' % connection.display_name,\n                    hint=(\n                        \"A constraint won't be created. Silence this \"\n                        \"warning if you don't care about it.\"\n                    ),\n                    obj=cls,\n                    id='models.W027',\n                )\n            )\n        if not (\n            connection.features.supports_partial_indexes or\n            'supports_partial_indexes' in cls._meta.required_db_features\n        ) and any(\n            isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n            for constraint in cls._meta.constraints\n        ):\n            errors.append(\n                checks.Warning(\n                    '%s does not support unique constraints with '\n                    'conditions.' % connection.display_name,\n                    hint=(\n                        \"A constraint won't be created. Silence this \"\n                        \"warning if you don't care about it.\"\n                    ),\n                    obj=cls,\n                    id='models.W036',\n                )\n            )\n        if not (\n            connection.features.supports_deferrable_unique_constraints or\n            'supports_deferrable_unique_constraints' in cls._meta.required_db_features\n        ) and any(\n            isinstance(constraint, UniqueConstraint) and constraint.deferrable is not None\n            for constraint in cls._meta.constraints\n        ):\n            errors.append(\n                checks.Warning(\n                    '%s does not support deferrable unique constraints.'\n                    % connection.display_name,\n                    hint=(\n                        \"A constraint won't be created. Silence this \"\n                        \"warning if you don't care about it.\"\n                    ),\n                    obj=cls,\n                    id='models.W038',\n                )\n            )\n    return errors\n",
      "\n@classmethod\ndef _check_constraints(cls, databases):\n    errors = []\n    \n    # Check UniqueConstraint fields exist\n    for constraint in cls._meta.constraints:\n        if isinstance(constraint, UniqueConstraint):\n            errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n    \n    for db in databases:\n        if not router.allow_migrate_model(db, cls):\n            continue\n        connection = connections[db]\n        if not (\n            connection.features.supports_table_check_constraints or\n            'supports_table_check_constraints' in cls._meta.required_db_features\n        ) and any(\n            isinstance(constraint, CheckConstraint)\n            for constraint in cls._meta.constraints\n        ):\n            errors.append(\n                checks.Warning(\n                    '%s does not support check constraints.' % connection.display_name,\n                    hint=(\n                        \"A constraint won't be created. Silence this \"\n                        \"warning if you don't care about it.\"\n                    ),\n                    obj=cls,\n                    id='models.W027',\n                )\n            )\n        if not (\n            connection.features.supports_partial_indexes or\n            'supports_partial_indexes' in cls._meta.required_db_features\n        ) and any(\n            isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n            for constraint in cls._meta.constraints\n        ):\n            errors.append(\n                checks.Warning(\n                    '%s does not support unique constraints with '\n                    'conditions.' % connection.display_name,\n                    hint=(\n                        \"A constraint won't be created. Silence this \"\n                        \"warning if you don't care about it.\"\n                    ),\n                    obj=cls,\n                    id='models.W036',\n                )\n            )\n        if not (\n            connection.features.supports_deferrable_unique_constraints or\n            'supports_deferrable_unique_constraints' in cls._meta.required_db_features\n        ) and any(\n            isinstance(constraint, UniqueConstraint) and constraint.deferrable is not None\n            for constraint in cls._meta.constraints\n        ):\n            errors.append(\n                checks.Warning(\n                    '%s does not support deferrable unique constraints.'\n                    % connection.display_name,\n                    hint=(\n                        \"A constraint won't be created. Silence this \"\n                        \"warning if you don't care about it.\"\n                    ),\n                    obj=cls,\n                    id='models.W038',\n                )\n            )\n    return errors\n",
      "\n@classmethod\ndef _check_constraints(cls, databases):\n    errors = []\n    \n    # Validate UniqueConstraint fields exist\n    for constraint in cls._meta.constraints:\n        if isinstance(constraint, UniqueConstraint):\n            errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n    \n    for db in databases:\n        if not router.allow_migrate_model(db, cls):\n            continue\n        connection = connections[db]\n        if not (\n            connection.features.supports_table_check_constraints or\n            'supports_table_check_constraints' in cls._meta.required_db_features\n        ) and any(\n            isinstance(constraint, CheckConstraint)\n            for constraint in cls._meta.constraints\n        ):\n            errors.append(\n                checks.Warning(\n                    '%s does not support check constraints.' % connection.display_name,\n                    hint=(\n                        \"A constraint won't be created. Silence this \"\n                        \"warning if you don't care about it.\"\n                    ),\n                    obj=cls,\n                    id='models.W027',\n                )\n            )\n        if not (\n            connection.features.supports_partial_indexes or\n            'supports_partial_indexes' in cls._meta.required_db_features\n        ) and any(\n            isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n            for constraint in cls._meta.constraints\n        ):\n            errors.append(\n                checks.Warning(\n                    '%s does not support unique constraints with '\n                    'conditions.' % connection.display_name,\n                    hint=(\n                        \"A constraint won't be created. Silence this \"\n                        \"warning if you don't care about it.\"\n                    ),\n                    obj=cls,\n                    id='models.W036',\n                )\n            )\n        if not (\n            connection.features.supports_deferrable_unique_constraints or\n            'supports_deferrable_unique_constraints' in cls._meta.required_db_features\n        ) and any(\n            isinstance(constraint, UniqueConstraint) and constraint.deferrable is not None\n            for constraint in cls._meta.constraints\n        ):\n            errors.append(\n                checks.Warning(\n                    '%s does not support deferrable unique constraints.'\n                    % connection.display_name,\n                    hint=(\n                        \"A constraint won't be created. Silence this \"\n                        \"warning if you don't care about it.\"\n                    ),\n                    obj=cls,\n                    id='models.W038',\n                )\n            )\n    return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        \n        # Validate fields in UniqueConstraints\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                'supports_table_check_constraints' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, CheckConstraint)\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support check constraints.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W027',\n                    )\n                )\n            if not (\n                connection.features.supports_partial_indexes or\n                'supports_partial_indexes' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support unique constraints with '\n                        'conditions.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W036',\n                    )\n                )\n            if not (\n                connection.features.supports_deferrable_unique_constraints or\n                'supports_deferrable_unique_constraints' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, UniqueConstraint) and constraint.deferrable is not None\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support deferrable unique constraints.'\n                        % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W038',\n                    )\n                )\n        return errors\n"
    ],
    "Location 2 (/root/hy/projects_2/django/django/db/models/base.py lines 1640-1680)": [
      "\n    @classmethod\n    def _check_constraints(cls, **kwargs):\n        errors = []\n        for constraint in cls._meta.constraints:\n            errors.extend(constraint.check(cls, **kwargs))\n            # Validate UniqueConstraint fields exist on the model\n            if hasattr(constraint, 'fields') and constraint.__class__.__name__ == 'UniqueConstraint':\n                errors.extend(cls._check_local_fields(constraint.fields, 'constraints'))\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                connection.features.supports_column_check_constraints\n            ):\n                continue\n            if any(\n                not connection.features.supports_over_clause and\n                isinstance(constraint, UniqueConstraint) and\n                (\n                    constraint.condition or\n                    constraint.contains_expressions or\n                    constraint.include or\n                    constraint.deferrable\n                )\n                for constraint in cls._meta.constraints\n                if isinstance(constraint, UniqueConstraint)\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support unique constraints with '\n                        'conditions, expressions, include fields, or '\n                        'deferrable unique constraints.' % connection.display_name,\n                        hint=(\n                            'A constraint won\\'t be created. Silence this '\n                            'warning if you don\\'t care about it.'\n                        ),\n                        obj=cls,\n                        id='models.W036',\n                    )\n                )\n        \n        # Validate UniqueConstraint fields exist\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, **kwargs):\n        errors = []\n        for constraint in cls._meta.constraints:\n            errors.extend(constraint.validate(model=cls, **kwargs))\n            # Validate fields for UniqueConstraint\n            if hasattr(constraint, 'fields') and constraint.__class__.__name__ == 'UniqueConstraint':\n                errors.extend(cls._check_local_fields(constraint.fields, 'constraints'))\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                connection.features.supports_column_check_constraints\n            ):\n                continue\n            if any(\n                isinstance(constraint, CheckConstraint)\n                and constraint.check.contains_aggregate\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s contains a CheckConstraint with a contains_aggregate '\n                        'Lookup. This may not be supported on some databases.' % cls.__name__,\n                        hint=(\n                            'Ensure that you are not using this constraint '\n                            'validation in databases that do not support it.'\n                        ),\n                        obj=cls,\n                        id='models.W044',\n                    )\n                )\n        \n        # Check UniqueConstraint fields exist\n        for constraint in cls._meta.constraints:\n            if hasattr(constraint, 'fields'):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                connection.features.supports_column_check_constraints\n            ):\n                continue\n            if any(\n                isinstance(constraint, CheckConstraint)\n                and constraint.check.contains_aggregate\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s contains a constraint with aggregates which is '\n                        'only supported on PostgreSQL and MySQL.' % cls.__name__,\n                        obj=cls,\n                        id='models.W039',\n                    )\n                )\n            break\n        \n        # Check that fields in UniqueConstraint exist\n        for constraint in cls._meta.constraints:\n            if hasattr(constraint, 'fields'):  # UniqueConstraint has fields attribute\n                # Check if this is a UniqueConstraint by checking for fields attribute\n                # and ensuring it's not a CheckConstraint\n                if not isinstance(constraint, CheckConstraint):\n                    errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                connection.features.supports_column_check_constraints\n            ):\n                continue\n            if any(\n                isinstance(constraint, CheckConstraint)\n                and constraint.condition.contains_aggregate\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s contains a check constraint with a condition '\n                        'that contains an aggregate function. This may result '\n                        'in incorrect behavior on some database backends.' % cls._meta.label,\n                        hint=(\n                            'Ensure your check constraint condition does not '\n                            'contain any aggregate functions.'\n                        ),\n                        obj=cls,\n                        id='models.W045',\n                    )\n                )\n            for constraint in cls._meta.constraints:\n                if isinstance(constraint, UniqueConstraint):\n                    errors.extend(cls._check_local_fields(constraint.fields, 'constraints'))\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, **kwargs):\n        errors = []\n        for constraint in cls._meta.constraints:\n            errors.extend(constraint.validate(cls, exclude=kwargs.get('exclude')))\n            # Validate UniqueConstraint fields exist\n            if hasattr(constraint, 'fields') and constraint.fields:\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                connection.features.supports_column_check_constraints\n            ):\n                continue\n            if any(isinstance(constraint, CheckConstraint) for constraint in cls._meta.constraints):\n                if not connection.features.supports_table_check_constraints:\n                    errors.append(\n                        checks.Warning(\n                            '%s does not support check constraints.' % connection.display_name,\n                            hint=(\n                                \"A constraint won't be created. Silence this \"\n                                \"warning if you don't care about it.\"\n                            ),\n                            obj=cls,\n                            id='models.W027',\n                        )\n                    )\n                else:\n                    for constraint in cls._meta.constraints:\n                        if isinstance(constraint, CheckConstraint):\n                            if constraint.condition is None:\n                                errors.append(\n                                    checks.Error(\n                                        'CheckConstraints with a Q object condition have '\n                                        'their check property set to None.',\n                                        hint='Use a Q object for the condition.',\n                                        obj=cls,\n                                        id='models.E031',\n                                    )\n                                )\n                            else:\n                                # Check Q object validity\n                                constraint_check = constraint.check\n                                # Only validate if we have a check attribute to validate\n                                if hasattr(constraint, 'check') and constraint_check:\n                                    if not isinstance(constraint_check, Q):\n                                        errors.append(\n                                            checks.Error(\n                                                'CheckConstraints.check must be a Q instance.',\n                                                obj=cls,\n                                                id='models.E028',\n                                            )\n                                        )\n        \n        # Validate fields in UniqueConstraint objects\n        from django.db.models.constraints import UniqueConstraint\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                errors.extend(cls._check_local_fields(constraint.fields, 'constraints'))\n        \n        return errors\n"
    ],
    "Location 3 (/root/hy/projects_2/django/django/db/models/base.py lines 1582-1586)": [
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for constraint in cls._meta.constraints:\n            # Check that constraint fields exist on the model\n            if hasattr(constraint, 'fields') and constraint.fields:\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n            \n            errors.extend(constraint.check(model=cls, databases=databases))\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for constraint in cls._meta.constraints:\n            errors.extend(constraint.validate(model=cls, instance=None, exclude=None, using=databases[0]))\n            # Check that UniqueConstraint fields exist on the model\n            if hasattr(constraint, 'fields') and hasattr(constraint, 'condition') and constraint.condition is None:\n                # This is a UniqueConstraint without conditions\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for constraint in cls._meta.constraints:\n            errors.extend(constraint.check(cls, databases=databases))\n            # Check that UniqueConstraint fields exist on the model\n            if hasattr(constraint, 'fields') and constraint.__class__.__name__ == 'UniqueConstraint':\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for constraint in cls._meta.constraints:\n            errors.extend(constraint.validate(model=cls, instance=None, exclude=None, using=databases[0]))\n            # Check that UniqueConstraint fields exist on the model\n            if hasattr(constraint, 'fields') and constraint.__class__.__name__ == 'UniqueConstraint':\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for constraint in cls._meta.constraints:\n            # Check that constraint fields exist on the model\n            if hasattr(constraint, 'fields'):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n            errors.extend(constraint.check(databases=databases))\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for constraint in cls._meta.constraints:\n            errors.extend(constraint.check(cls, databases=databases))\n            # Check that UniqueConstraint fields exist on the model\n            if hasattr(constraint, 'fields') and constraint.__class__.__name__ == 'UniqueConstraint':\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for constraint in cls._meta.constraints:\n            # Validate fields in UniqueConstraint\n            if hasattr(constraint, 'fields') and constraint.__class__.__name__ == 'UniqueConstraint':\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n            errors.extend(constraint.check(databases=databases))\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for constraint in cls._meta.constraints:\n            constraint_databases = constraint.databases\n            if (\n                constraint_databases is not None and\n                constraint_databases.isdisjoint(databases)\n            ):\n                continue\n            errors.extend(constraint.check(cls, databases=databases))\n            \n            # Check that UniqueConstraint fields exist on the model\n            if hasattr(constraint, 'fields') and constraint.__class__.__name__ == 'UniqueConstraint':\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        return errors\n"
    ],
    "Location 4 (/root/hy/projects_2/django/django/db/models/constraints.py lines 79-98)": [
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                connection.features.supports_column_check_constraints\n            ):\n                continue\n            for constraint in cls._meta.constraints:\n                if hasattr(constraint, 'check') and constraint.check:\n                    constraint_sql = constraint.constraint_sql(cls, None)\n                    if constraint_sql is None:\n                        continue\n                    try:\n                        connection.ops.check_expression_support(constraint.check)\n                    except NotSupportedError as e:\n                        errors.append(\n                            checks.Error(\n                                '%s' % e,\n                                hint=(\n                                    'A constraint is supported, if supported by the database.'\n                                ),\n                                obj=cls,\n                                id='models.E023',\n                            )\n                        )\n                # Check UniqueConstraint fields exist\n                if constraint.__class__.__name__ == 'UniqueConstraint':\n                    errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                connection.features.supports_column_check_constraints\n            ):\n                continue\n            for constraint in cls._meta.constraints:\n                # Add field validation for UniqueConstraint\n                if hasattr(constraint, 'fields') and hasattr(constraint, '__class__') and constraint.__class__.__name__ == 'UniqueConstraint':\n                    errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n                # Existing constraint SQL validation\n                constraint_sql = constraint.constraint_sql(cls, connection.schema_editor())\n                if not constraint_sql:\n                    continue\n                if not connection.features.supports_over_clause and 'OVER' in constraint_sql:\n                    errors.append(\n                        checks.Warning(\n                            '%s does not support window expressions in constraints.'\n                            % connection.display_name,\n                            obj=cls,\n                            id='models.W045',\n                        )\n                    )\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for constraint in cls._meta.constraints:\n            # Check UniqueConstraint field existence\n            if hasattr(constraint, 'fields'):\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for constraint in cls._meta.constraints:\n            errors.extend(constraint.check(cls, databases=databases))\n            # Validate UniqueConstraint fields exist on the model\n            if hasattr(constraint, 'fields') and constraint.__class__.__name__ == 'UniqueConstraint':\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            for constraint in cls._meta.constraints:\n                # Validate UniqueConstraint fields\n                if constraint.__class__.__name__ == 'UniqueConstraint':\n                    errors.extend(\n                        cls._check_local_fields(constraint.fields, \"constraints\")\n                    )\n                errors.extend(constraint.validate(model=cls, instance=None, exclude=None, using=db))\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                connection.features.supports_column_check_constraints\n            ):\n                continue\n            for constraint in cls._meta.constraints:\n                if hasattr(constraint, 'check') and constraint.check:\n                    constraint_sql = constraint.constraint_sql(cls, None)\n                    if constraint_sql:\n                        check_sql = constraint_sql.split(' CHECK ', 1)[-1]\n                        try:\n                            connection.ops.check_expression_support(\n                                CheckConstraint(check=Q(), name='')\n                            )\n                        except NotSupportedError as e:\n                            errors.append(\n                                checks.Error(\n                                    '%s are not supported on this database backend.' % e,\n                                    obj=cls,\n                                    id='models.E027',\n                                )\n                            )\n                        except DatabaseError:\n                            errors.append(\n                                checks.Error(\n                                    'Check constraint contains invalid SQL.',\n                                    obj=cls,\n                                    id='models.E026',\n                                )\n                            )\n                # Add field validation for UniqueConstraint\n                if hasattr(constraint, 'fields') and constraint.__class__.__name__ == 'UniqueConstraint':\n                    errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                connection.features.supports_column_check_constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support check constraints.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W027',\n                    )\n                )\n        \n        # Validate fields in UniqueConstraint\n        for constraint in cls._meta.constraints:\n            if hasattr(constraint, 'fields') and hasattr(constraint, 'condition'):  # UniqueConstraint\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        \n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            for constraint in cls._meta.constraints:\n                # Validate fields exist for UniqueConstraint\n                if hasattr(constraint, 'fields') and constraint.__class__.__name__ == 'UniqueConstraint':\n                    errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n                errors.extend(constraint.validate(model=cls, instance=None, exclude=None, using=db))\n        return errors\n"
    ],
    "Location 5 (/root/hy/projects_2/django/django/db/models/constraints.py lines 107-108)": [
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            for constraint in cls._meta.constraints:\n                # Validate UniqueConstraint fields exist on the model\n                if hasattr(constraint, 'fields') and constraint.__class__.__name__ == 'UniqueConstraint':\n                    errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n                errors.extend(constraint.validate(model=cls, instance=None, exclude=None, using=db))\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            for constraint in cls._meta.constraints:\n                # Validate UniqueConstraint fields exist on the model\n                if constraint.__class__.__name__ == 'UniqueConstraint':\n                    errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n                errors.extend(constraint.validate(model=cls, instance=None, exclude=None, using=db))\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            for constraint in cls._meta.constraints:\n                # Check UniqueConstraint fields exist\n                if constraint.__class__.__name__ == 'UniqueConstraint':\n                    errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n                errors.extend(constraint.validate(model=cls, exclude=None))\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, **kwargs):\n        errors = []\n        for constraint in cls._meta.constraints:\n            errors.extend(constraint.check(cls, **kwargs))\n            # Check that UniqueConstraint fields exist on the model\n            if hasattr(constraint, 'fields') and constraint.__class__.__name__ == 'UniqueConstraint':\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for constraint in cls._meta.constraints:\n            # Validate UniqueConstraint fields exist on the model\n            if hasattr(constraint, 'fields') and hasattr(constraint, '__class__') and constraint.__class__.__name__ == 'UniqueConstraint':\n                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n            errors.extend(constraint.check())\n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                connection.features.supports_column_check_constraints\n            ):\n                errors.extend(cls._check_check_constraints(connection))\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            for constraint in cls._meta.constraints:\n                # Check that UniqueConstraint fields exist on the model\n                if hasattr(constraint, 'fields') and constraint.__class__.__name__ == 'UniqueConstraint':\n                    errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n                errors.extend(constraint.validate(model=cls, instance=None, exclude=None, using=db))\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            for constraint in cls._meta.constraints:\n                # Validate UniqueConstraint fields exist on the model\n                if hasattr(constraint, 'fields') and constraint.__class__.__name__ == 'UniqueConstraint':\n                    errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n                errors.extend(constraint.validate(model=cls, instance=None, exclude=None, using=db))\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            for constraint in cls._meta.constraints:\n                # Validate UniqueConstraint fields exist on the model\n                if hasattr(constraint, 'fields') and constraint.__class__.__name__ == 'UniqueConstraint':\n                    errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n                \n                errors.extend(constraint.validate(model=cls, instance=None, exclude=None, using=db))\n        return errors\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7bb3fa4706..5aef0fb9aa 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1579,6 +1579,7 @@ class Model(metaclass=ModelBase):\n                 )\n             ]\n \n+\n         else:\n             errors = []\n             for fields in cls._meta.unique_together:\n@@ -1636,6 +1637,8 @@ class Model(metaclass=ModelBase):\n         errors.extend(cls._check_local_fields(fields, 'indexes'))\n         return errors\n \n+    @classmethod\n+\n     @classmethod\n     def _check_local_fields(cls, fields, option):\n         from django.db import models\n@@ -1684,6 +1687,13 @@ class Model(metaclass=ModelBase):\n                             id='models.E016',\n                         )\n                     )\n+        return errors\n+                            % (option, field_name, cls._meta.object_name),\n+                            hint=\"This issue may be caused by multi-table inheritance.\",\n+                            obj=cls,\n+                            id='models.E016',\n+                        )\n+                    )\n         return errors\n \n     @classmethod\n@@ -1863,9 +1873,17 @@ class Model(metaclass=ModelBase):\n \n         return errors\n \n+    @classmethod\n+\n     @classmethod\n     def _check_constraints(cls, databases):\n         errors = []\n+        \n+        # Add field validation for UniqueConstraint objects\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n         for db in databases:\n             if not router.allow_migrate_model(db, cls):\n                 continue\ndiff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex 64bd60484e..cf576e5b92 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -76,6 +76,7 @@ class Deferrable(Enum):\n     IMMEDIATE = 'immediate'\n \n \n+\n class UniqueConstraint(BaseConstraint):\n     def __init__(self, *, fields, name, condition=None, deferrable=None):\n         if not fields:\n@@ -104,6 +105,7 @@ class UniqueConstraint(BaseConstraint):\n         sql, params = where.as_sql(compiler, schema_editor.connection)\n         return sql % tuple(schema_editor.quote_value(p) for p in params)\n \n+\n     def constraint_sql(self, model, schema_editor):\n         fields = [model._meta.get_field(field_name).column for field_name in self.fields]\n         condition = self._get_condition_sql(model, schema_editor)\n",
    "variant_0": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7bb3fa4706..a2b75ae502 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1579,11 +1579,22 @@ class Model(metaclass=ModelBase):\n                 )\n             ]\n \n-        else:\n-            errors = []\n-            for fields in cls._meta.unique_together:\n-                errors.extend(cls._check_local_fields(fields, \"unique_together\"))\n-            return errors\n+\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        for constraint in cls._meta.constraints:\n+            if hasattr(constraint, 'check'):\n+                constraint_databases = constraint.check.get_group_by_cols()\n+            else:\n+                constraint_databases = None\n+            if not databases.intersection(constraint_databases or [DEFAULT_DB_ALIAS]):\n+                continue\n+            errors.extend(constraint.check(databases))\n+            # Check UniqueConstraint field existence\n+            if constraint.__class__.__name__ == 'UniqueConstraint':\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        return errors\n \n     @classmethod\n     def _check_indexes(cls, databases):\n@@ -1637,47 +1648,28 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n-    def _check_local_fields(cls, fields, option):\n-        from django.db import models\n-\n-        # In order to avoid hitting the relation tree prematurely, we use our\n-        # own fields_map instead of using get_field()\n-        forward_fields_map = {}\n-        for field in cls._meta._get_fields(reverse=False):\n-            forward_fields_map[field.name] = field\n-            if hasattr(field, 'attname'):\n-                forward_fields_map[field.attname] = field\n \n+    @classmethod\n+    def _check_constraints(cls, databases):\n         errors = []\n-        for field_name in fields:\n-            try:\n-                field = forward_fields_map[field_name]\n-            except KeyError:\n-                errors.append(\n-                    checks.Error(\n-                        \"'%s' refers to the nonexistent field '%s'.\" % (\n-                            option, field_name,\n-                        ),\n-                        obj=cls,\n-                        id='models.E012',\n-                    )\n-                )\n-            else:\n-                if isinstance(field.remote_field, models.ManyToManyRel):\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to a ManyToManyField '%s', but \"\n-                            \"ManyToManyFields are not permitted in '%s'.\" % (\n-                                option, field_name, option,\n-                            ),\n-                            obj=cls,\n-                            id='models.E013',\n-                        )\n-                    )\n-                elif field not in cls._meta.local_fields:\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to field '%s' which is not local to model '%s'.\"\n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                connection.features.supports_column_check_constraints\n+            ):\n+                errors.extend(cls._check_constraints_database_backends(db))\n+            if connection.features.supports_over_clause:\n+                errors.extend(cls._check_constraints_sql_funcs(db))\n+        \n+        # Validate UniqueConstraint fields exist\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n+        return errors\n                             % (option, field_name, cls._meta.object_name),\n                             hint=\"This issue may be caused by multi-table inheritance.\",\n                             obj=cls,\n@@ -1863,9 +1855,17 @@ class Model(metaclass=ModelBase):\n \n         return errors\n \n+    @classmethod\n+\n     @classmethod\n     def _check_constraints(cls, databases):\n         errors = []\n+        \n+        # Check UniqueConstraint field existence\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n         for db in databases:\n             if not router.allow_migrate_model(db, cls):\n                 continue\ndiff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex 64bd60484e..b22c0c3a94 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -76,26 +76,19 @@ class Deferrable(Enum):\n     IMMEDIATE = 'immediate'\n \n \n-class UniqueConstraint(BaseConstraint):\n-    def __init__(self, *, fields, name, condition=None, deferrable=None):\n-        if not fields:\n-            raise ValueError('At least one field is required to define a unique constraint.')\n-        if not isinstance(condition, (type(None), Q)):\n-            raise ValueError('UniqueConstraint.condition must be a Q instance.')\n-        if condition and deferrable:\n-            raise ValueError(\n-                'UniqueConstraint with conditions cannot be deferred.'\n-            )\n-        if not isinstance(deferrable, (type(None), Deferrable)):\n-            raise ValueError(\n-                'UniqueConstraint.deferrable must be a Deferrable instance.'\n-            )\n-        self.fields = tuple(fields)\n-        self.condition = condition\n-        self.deferrable = deferrable\n-        super().__init__(name)\n \n-    def _get_condition_sql(self, model, schema_editor):\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            for constraint in cls._meta.constraints:\n+                # Validate UniqueConstraint fields\n+                if hasattr(constraint, 'fields') and constraint.__class__.__name__ == 'UniqueConstraint':\n+                    errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+                errors.extend(constraint.validate(model=cls, exclude=None, using=db))\n+        return errors\n         if self.condition is None:\n             return None\n         query = Query(model=model, alias_cols=False)\n@@ -104,8 +97,19 @@ class UniqueConstraint(BaseConstraint):\n         sql, params = where.as_sql(compiler, schema_editor.connection)\n         return sql % tuple(schema_editor.quote_value(p) for p in params)\n \n-    def constraint_sql(self, model, schema_editor):\n-        fields = [model._meta.get_field(field_name).column for field_name in self.fields]\n+\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            for constraint in cls._meta.constraints:\n+                # Check field existence for UniqueConstraint\n+                if constraint.__class__.__name__ == 'UniqueConstraint':\n+                    errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+                errors.extend(constraint.validate(model=cls, exclude=None))\n+        return errors\n         condition = self._get_condition_sql(model, schema_editor)\n         return schema_editor._unique_sql(\n             model, fields, self.name, condition=condition,\n",
    "variant_1": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7bb3fa4706..7b5e19328f 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1579,11 +1579,17 @@ class Model(metaclass=ModelBase):\n                 )\n             ]\n \n-        else:\n-            errors = []\n-            for fields in cls._meta.unique_together:\n-                errors.extend(cls._check_local_fields(fields, \"unique_together\"))\n-            return errors\n+\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        for constraint in cls._meta.constraints:\n+            # Check that constraint fields exist on the model\n+            if hasattr(constraint, 'fields') and constraint.fields:\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+            \n+            errors.extend(constraint.check(model=cls, databases=databases))\n+        return errors\n \n     @classmethod\n     def _check_indexes(cls, databases):\n@@ -1637,47 +1643,16 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n-    def _check_local_fields(cls, fields, option):\n-        from django.db import models\n-\n-        # In order to avoid hitting the relation tree prematurely, we use our\n-        # own fields_map instead of using get_field()\n-        forward_fields_map = {}\n-        for field in cls._meta._get_fields(reverse=False):\n-            forward_fields_map[field.name] = field\n-            if hasattr(field, 'attname'):\n-                forward_fields_map[field.attname] = field\n \n+    @classmethod\n+    def _check_constraints(cls, **kwargs):\n         errors = []\n-        for field_name in fields:\n-            try:\n-                field = forward_fields_map[field_name]\n-            except KeyError:\n-                errors.append(\n-                    checks.Error(\n-                        \"'%s' refers to the nonexistent field '%s'.\" % (\n-                            option, field_name,\n-                        ),\n-                        obj=cls,\n-                        id='models.E012',\n-                    )\n-                )\n-            else:\n-                if isinstance(field.remote_field, models.ManyToManyRel):\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to a ManyToManyField '%s', but \"\n-                            \"ManyToManyFields are not permitted in '%s'.\" % (\n-                                option, field_name, option,\n-                            ),\n-                            obj=cls,\n-                            id='models.E013',\n-                        )\n-                    )\n-                elif field not in cls._meta.local_fields:\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to field '%s' which is not local to model '%s'.\"\n+        for constraint in cls._meta.constraints:\n+            errors.extend(constraint.check(cls, **kwargs))\n+            # Validate UniqueConstraint fields exist on the model\n+            if hasattr(constraint, 'fields') and constraint.__class__.__name__ == 'UniqueConstraint':\n+                errors.extend(cls._check_local_fields(constraint.fields, 'constraints'))\n+        return errors\n                             % (option, field_name, cls._meta.object_name),\n                             hint=\"This issue may be caused by multi-table inheritance.\",\n                             obj=cls,\n@@ -1863,9 +1838,16 @@ class Model(metaclass=ModelBase):\n \n         return errors\n \n+    @classmethod\n+\n     @classmethod\n     def _check_constraints(cls, databases):\n         errors = []\n+        # Check field existence for UniqueConstraints\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n         for db in databases:\n             if not router.allow_migrate_model(db, cls):\n                 continue\ndiff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex 64bd60484e..82e7866b85 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -76,26 +76,41 @@ class Deferrable(Enum):\n     IMMEDIATE = 'immediate'\n \n \n-class UniqueConstraint(BaseConstraint):\n-    def __init__(self, *, fields, name, condition=None, deferrable=None):\n-        if not fields:\n-            raise ValueError('At least one field is required to define a unique constraint.')\n-        if not isinstance(condition, (type(None), Q)):\n-            raise ValueError('UniqueConstraint.condition must be a Q instance.')\n-        if condition and deferrable:\n-            raise ValueError(\n-                'UniqueConstraint with conditions cannot be deferred.'\n-            )\n-        if not isinstance(deferrable, (type(None), Deferrable)):\n-            raise ValueError(\n-                'UniqueConstraint.deferrable must be a Deferrable instance.'\n-            )\n-        self.fields = tuple(fields)\n-        self.condition = condition\n-        self.deferrable = deferrable\n-        super().__init__(name)\n \n-    def _get_condition_sql(self, model, schema_editor):\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                connection.features.supports_column_check_constraints\n+            ):\n+                continue\n+            for constraint in cls._meta.constraints:\n+                if hasattr(constraint, 'check') and constraint.check:\n+                    constraint_sql = constraint.constraint_sql(cls, None)\n+                    if constraint_sql is None:\n+                        continue\n+                    try:\n+                        connection.ops.check_expression_support(constraint.check)\n+                    except NotSupportedError as e:\n+                        errors.append(\n+                            checks.Error(\n+                                '%s' % e,\n+                                hint=(\n+                                    'A constraint is supported, if supported by the database.'\n+                                ),\n+                                obj=cls,\n+                                id='models.E023',\n+                            )\n+                        )\n+                # Check UniqueConstraint fields exist\n+                if constraint.__class__.__name__ == 'UniqueConstraint':\n+                    errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        return errors\n         if self.condition is None:\n             return None\n         query = Query(model=model, alias_cols=False)\n@@ -104,8 +119,19 @@ class UniqueConstraint(BaseConstraint):\n         sql, params = where.as_sql(compiler, schema_editor.connection)\n         return sql % tuple(schema_editor.quote_value(p) for p in params)\n \n-    def constraint_sql(self, model, schema_editor):\n-        fields = [model._meta.get_field(field_name).column for field_name in self.fields]\n+\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            for constraint in cls._meta.constraints:\n+                # Validate UniqueConstraint fields exist on the model\n+                if hasattr(constraint, 'fields') and constraint.__class__.__name__ == 'UniqueConstraint':\n+                    errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+                errors.extend(constraint.validate(model=cls, instance=None, exclude=None, using=db))\n+        return errors\n         condition = self._get_condition_sql(model, schema_editor)\n         return schema_editor._unique_sql(\n             model, fields, self.name, condition=condition,\n",
    "variant_2": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7bb3fa4706..5be1231851 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1579,11 +1579,17 @@ class Model(metaclass=ModelBase):\n                 )\n             ]\n \n-        else:\n-            errors = []\n-            for fields in cls._meta.unique_together:\n-                errors.extend(cls._check_local_fields(fields, \"unique_together\"))\n-            return errors\n+\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        for constraint in cls._meta.constraints:\n+            errors.extend(constraint.validate(model=cls, instance=None, exclude=None, using=databases[0]))\n+            # Check that UniqueConstraint fields exist on the model\n+            if hasattr(constraint, 'fields') and hasattr(constraint, 'condition') and constraint.condition is None:\n+                # This is a UniqueConstraint without conditions\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        return errors\n \n     @classmethod\n     def _check_indexes(cls, databases):\n@@ -1637,47 +1643,51 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n-    def _check_local_fields(cls, fields, option):\n-        from django.db import models\n-\n-        # In order to avoid hitting the relation tree prematurely, we use our\n-        # own fields_map instead of using get_field()\n-        forward_fields_map = {}\n-        for field in cls._meta._get_fields(reverse=False):\n-            forward_fields_map[field.name] = field\n-            if hasattr(field, 'attname'):\n-                forward_fields_map[field.attname] = field\n \n+    @classmethod\n+    def _check_constraints(cls, databases):\n         errors = []\n-        for field_name in fields:\n-            try:\n-                field = forward_fields_map[field_name]\n-            except KeyError:\n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                connection.features.supports_column_check_constraints\n+            ):\n+                continue\n+            if any(\n+                not connection.features.supports_over_clause and\n+                isinstance(constraint, UniqueConstraint) and\n+                (\n+                    constraint.condition or\n+                    constraint.contains_expressions or\n+                    constraint.include or\n+                    constraint.deferrable\n+                )\n+                for constraint in cls._meta.constraints\n+                if isinstance(constraint, UniqueConstraint)\n+            ):\n                 errors.append(\n-                    checks.Error(\n-                        \"'%s' refers to the nonexistent field '%s'.\" % (\n-                            option, field_name,\n+                    checks.Warning(\n+                        '%s does not support unique constraints with '\n+                        'conditions, expressions, include fields, or '\n+                        'deferrable unique constraints.' % connection.display_name,\n+                        hint=(\n+                            'A constraint won\\'t be created. Silence this '\n+                            'warning if you don\\'t care about it.'\n                         ),\n                         obj=cls,\n-                        id='models.E012',\n+                        id='models.W036',\n                     )\n                 )\n-            else:\n-                if isinstance(field.remote_field, models.ManyToManyRel):\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to a ManyToManyField '%s', but \"\n-                            \"ManyToManyFields are not permitted in '%s'.\" % (\n-                                option, field_name, option,\n-                            ),\n-                            obj=cls,\n-                            id='models.E013',\n-                        )\n-                    )\n-                elif field not in cls._meta.local_fields:\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to field '%s' which is not local to model '%s'.\"\n+        \n+        # Validate UniqueConstraint fields exist\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n+        return errors\n                             % (option, field_name, cls._meta.object_name),\n                             hint=\"This issue may be caused by multi-table inheritance.\",\n                             obj=cls,\n@@ -1863,9 +1873,17 @@ class Model(metaclass=ModelBase):\n \n         return errors\n \n+    @classmethod\n+\n     @classmethod\n     def _check_constraints(cls, databases):\n         errors = []\n+        \n+        # Validate UniqueConstraint fields exist\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n         for db in databases:\n             if not router.allow_migrate_model(db, cls):\n                 continue\ndiff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex 64bd60484e..b74a8d57d3 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -76,26 +76,37 @@ class Deferrable(Enum):\n     IMMEDIATE = 'immediate'\n \n \n-class UniqueConstraint(BaseConstraint):\n-    def __init__(self, *, fields, name, condition=None, deferrable=None):\n-        if not fields:\n-            raise ValueError('At least one field is required to define a unique constraint.')\n-        if not isinstance(condition, (type(None), Q)):\n-            raise ValueError('UniqueConstraint.condition must be a Q instance.')\n-        if condition and deferrable:\n-            raise ValueError(\n-                'UniqueConstraint with conditions cannot be deferred.'\n-            )\n-        if not isinstance(deferrable, (type(None), Deferrable)):\n-            raise ValueError(\n-                'UniqueConstraint.deferrable must be a Deferrable instance.'\n-            )\n-        self.fields = tuple(fields)\n-        self.condition = condition\n-        self.deferrable = deferrable\n-        super().__init__(name)\n \n-    def _get_condition_sql(self, model, schema_editor):\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                connection.features.supports_column_check_constraints\n+            ):\n+                continue\n+            for constraint in cls._meta.constraints:\n+                # Add field validation for UniqueConstraint\n+                if hasattr(constraint, 'fields') and hasattr(constraint, '__class__') and constraint.__class__.__name__ == 'UniqueConstraint':\n+                    errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+                # Existing constraint SQL validation\n+                constraint_sql = constraint.constraint_sql(cls, connection.schema_editor())\n+                if not constraint_sql:\n+                    continue\n+                if not connection.features.supports_over_clause and 'OVER' in constraint_sql:\n+                    errors.append(\n+                        checks.Warning(\n+                            '%s does not support window expressions in constraints.'\n+                            % connection.display_name,\n+                            obj=cls,\n+                            id='models.W045',\n+                        )\n+                    )\n+        return errors\n         if self.condition is None:\n             return None\n         query = Query(model=model, alias_cols=False)\n@@ -104,8 +115,19 @@ class UniqueConstraint(BaseConstraint):\n         sql, params = where.as_sql(compiler, schema_editor.connection)\n         return sql % tuple(schema_editor.quote_value(p) for p in params)\n \n-    def constraint_sql(self, model, schema_editor):\n-        fields = [model._meta.get_field(field_name).column for field_name in self.fields]\n+\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            for constraint in cls._meta.constraints:\n+                # Validate UniqueConstraint fields exist on the model\n+                if constraint.__class__.__name__ == 'UniqueConstraint':\n+                    errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+                errors.extend(constraint.validate(model=cls, instance=None, exclude=None, using=db))\n+        return errors\n         condition = self._get_condition_sql(model, schema_editor)\n         return schema_editor._unique_sql(\n             model, fields, self.name, condition=condition,\n",
    "variant_3": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7bb3fa4706..9854ad0c32 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1579,11 +1579,16 @@ class Model(metaclass=ModelBase):\n                 )\n             ]\n \n-        else:\n-            errors = []\n-            for fields in cls._meta.unique_together:\n-                errors.extend(cls._check_local_fields(fields, \"unique_together\"))\n-            return errors\n+\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        for constraint in cls._meta.constraints:\n+            errors.extend(constraint.check(cls, databases=databases))\n+            # Check that UniqueConstraint fields exist on the model\n+            if hasattr(constraint, 'fields') and constraint.__class__.__name__ == 'UniqueConstraint':\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        return errors\n \n     @classmethod\n     def _check_indexes(cls, databases):\n@@ -1637,47 +1642,16 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n-    def _check_local_fields(cls, fields, option):\n-        from django.db import models\n-\n-        # In order to avoid hitting the relation tree prematurely, we use our\n-        # own fields_map instead of using get_field()\n-        forward_fields_map = {}\n-        for field in cls._meta._get_fields(reverse=False):\n-            forward_fields_map[field.name] = field\n-            if hasattr(field, 'attname'):\n-                forward_fields_map[field.attname] = field\n \n+    @classmethod\n+    def _check_constraints(cls, **kwargs):\n         errors = []\n-        for field_name in fields:\n-            try:\n-                field = forward_fields_map[field_name]\n-            except KeyError:\n-                errors.append(\n-                    checks.Error(\n-                        \"'%s' refers to the nonexistent field '%s'.\" % (\n-                            option, field_name,\n-                        ),\n-                        obj=cls,\n-                        id='models.E012',\n-                    )\n-                )\n-            else:\n-                if isinstance(field.remote_field, models.ManyToManyRel):\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to a ManyToManyField '%s', but \"\n-                            \"ManyToManyFields are not permitted in '%s'.\" % (\n-                                option, field_name, option,\n-                            ),\n-                            obj=cls,\n-                            id='models.E013',\n-                        )\n-                    )\n-                elif field not in cls._meta.local_fields:\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to field '%s' which is not local to model '%s'.\"\n+        for constraint in cls._meta.constraints:\n+            errors.extend(constraint.validate(model=cls, **kwargs))\n+            # Validate fields for UniqueConstraint\n+            if hasattr(constraint, 'fields') and constraint.__class__.__name__ == 'UniqueConstraint':\n+                errors.extend(cls._check_local_fields(constraint.fields, 'constraints'))\n+        return errors\n                             % (option, field_name, cls._meta.object_name),\n                             hint=\"This issue may be caused by multi-table inheritance.\",\n                             obj=cls,\n@@ -1863,9 +1837,17 @@ class Model(metaclass=ModelBase):\n \n         return errors\n \n+    @classmethod\n+\n     @classmethod\n     def _check_constraints(cls, databases):\n         errors = []\n+        \n+        # Check UniqueConstraint field validation\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n         for db in databases:\n             if not router.allow_migrate_model(db, cls):\n                 continue\ndiff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex 64bd60484e..e4129d2ef0 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -76,26 +76,15 @@ class Deferrable(Enum):\n     IMMEDIATE = 'immediate'\n \n \n-class UniqueConstraint(BaseConstraint):\n-    def __init__(self, *, fields, name, condition=None, deferrable=None):\n-        if not fields:\n-            raise ValueError('At least one field is required to define a unique constraint.')\n-        if not isinstance(condition, (type(None), Q)):\n-            raise ValueError('UniqueConstraint.condition must be a Q instance.')\n-        if condition and deferrable:\n-            raise ValueError(\n-                'UniqueConstraint with conditions cannot be deferred.'\n-            )\n-        if not isinstance(deferrable, (type(None), Deferrable)):\n-            raise ValueError(\n-                'UniqueConstraint.deferrable must be a Deferrable instance.'\n-            )\n-        self.fields = tuple(fields)\n-        self.condition = condition\n-        self.deferrable = deferrable\n-        super().__init__(name)\n \n-    def _get_condition_sql(self, model, schema_editor):\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        for constraint in cls._meta.constraints:\n+            # Check UniqueConstraint field existence\n+            if hasattr(constraint, 'fields'):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        return errors\n         if self.condition is None:\n             return None\n         query = Query(model=model, alias_cols=False)\n@@ -104,8 +93,19 @@ class UniqueConstraint(BaseConstraint):\n         sql, params = where.as_sql(compiler, schema_editor.connection)\n         return sql % tuple(schema_editor.quote_value(p) for p in params)\n \n-    def constraint_sql(self, model, schema_editor):\n-        fields = [model._meta.get_field(field_name).column for field_name in self.fields]\n+\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            for constraint in cls._meta.constraints:\n+                # Check UniqueConstraint fields exist\n+                if constraint.__class__.__name__ == 'UniqueConstraint':\n+                    errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+                errors.extend(constraint.validate(model=cls, exclude=None))\n+        return errors\n         condition = self._get_condition_sql(model, schema_editor)\n         return schema_editor._unique_sql(\n             model, fields, self.name, condition=condition,\n",
    "variant_4": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7bb3fa4706..714cb599a1 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1579,11 +1579,16 @@ class Model(metaclass=ModelBase):\n                 )\n             ]\n \n-        else:\n-            errors = []\n-            for fields in cls._meta.unique_together:\n-                errors.extend(cls._check_local_fields(fields, \"unique_together\"))\n-            return errors\n+\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        for constraint in cls._meta.constraints:\n+            errors.extend(constraint.validate(model=cls, instance=None, exclude=None, using=databases[0]))\n+            # Check that UniqueConstraint fields exist on the model\n+            if hasattr(constraint, 'fields') and constraint.__class__.__name__ == 'UniqueConstraint':\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        return errors\n \n     @classmethod\n     def _check_indexes(cls, databases):\n@@ -1637,47 +1642,43 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n-    def _check_local_fields(cls, fields, option):\n-        from django.db import models\n-\n-        # In order to avoid hitting the relation tree prematurely, we use our\n-        # own fields_map instead of using get_field()\n-        forward_fields_map = {}\n-        for field in cls._meta._get_fields(reverse=False):\n-            forward_fields_map[field.name] = field\n-            if hasattr(field, 'attname'):\n-                forward_fields_map[field.attname] = field\n \n+    @classmethod\n+    def _check_constraints(cls, databases):\n         errors = []\n-        for field_name in fields:\n-            try:\n-                field = forward_fields_map[field_name]\n-            except KeyError:\n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                connection.features.supports_column_check_constraints\n+            ):\n+                continue\n+            if any(\n+                isinstance(constraint, CheckConstraint)\n+                and constraint.check.contains_aggregate\n+                for constraint in cls._meta.constraints\n+            ):\n                 errors.append(\n-                    checks.Error(\n-                        \"'%s' refers to the nonexistent field '%s'.\" % (\n-                            option, field_name,\n+                    checks.Warning(\n+                        '%s contains a CheckConstraint with a contains_aggregate '\n+                        'Lookup. This may not be supported on some databases.' % cls.__name__,\n+                        hint=(\n+                            'Ensure that you are not using this constraint '\n+                            'validation in databases that do not support it.'\n                         ),\n                         obj=cls,\n-                        id='models.E012',\n+                        id='models.W044',\n                     )\n                 )\n-            else:\n-                if isinstance(field.remote_field, models.ManyToManyRel):\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to a ManyToManyField '%s', but \"\n-                            \"ManyToManyFields are not permitted in '%s'.\" % (\n-                                option, field_name, option,\n-                            ),\n-                            obj=cls,\n-                            id='models.E013',\n-                        )\n-                    )\n-                elif field not in cls._meta.local_fields:\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to field '%s' which is not local to model '%s'.\"\n+        \n+        # Check UniqueConstraint fields exist\n+        for constraint in cls._meta.constraints:\n+            if hasattr(constraint, 'fields'):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n+        return errors\n                             % (option, field_name, cls._meta.object_name),\n                             hint=\"This issue may be caused by multi-table inheritance.\",\n                             obj=cls,\n@@ -1864,69 +1865,77 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n-    def _check_constraints(cls, databases):\n-        errors = []\n-        for db in databases:\n-            if not router.allow_migrate_model(db, cls):\n-                continue\n-            connection = connections[db]\n-            if not (\n-                connection.features.supports_table_check_constraints or\n-                'supports_table_check_constraints' in cls._meta.required_db_features\n-            ) and any(\n-                isinstance(constraint, CheckConstraint)\n-                for constraint in cls._meta.constraints\n-            ):\n-                errors.append(\n-                    checks.Warning(\n-                        '%s does not support check constraints.' % connection.display_name,\n-                        hint=(\n-                            \"A constraint won't be created. Silence this \"\n-                            \"warning if you don't care about it.\"\n-                        ),\n-                        obj=cls,\n-                        id='models.W027',\n-                    )\n+\n+@classmethod\n+def _check_constraints(cls, databases):\n+    errors = []\n+    \n+    # Validate UniqueConstraint fields exist\n+    for constraint in cls._meta.constraints:\n+        if isinstance(constraint, UniqueConstraint):\n+            errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+    \n+    for db in databases:\n+        if not router.allow_migrate_model(db, cls):\n+            continue\n+        connection = connections[db]\n+        if not (\n+            connection.features.supports_table_check_constraints or\n+            'supports_table_check_constraints' in cls._meta.required_db_features\n+        ) and any(\n+            isinstance(constraint, CheckConstraint)\n+            for constraint in cls._meta.constraints\n+        ):\n+            errors.append(\n+                checks.Warning(\n+                    '%s does not support check constraints.' % connection.display_name,\n+                    hint=(\n+                        \"A constraint won't be created. Silence this \"\n+                        \"warning if you don't care about it.\"\n+                    ),\n+                    obj=cls,\n+                    id='models.W027',\n                 )\n-            if not (\n-                connection.features.supports_partial_indexes or\n-                'supports_partial_indexes' in cls._meta.required_db_features\n-            ) and any(\n-                isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n-                for constraint in cls._meta.constraints\n-            ):\n-                errors.append(\n-                    checks.Warning(\n-                        '%s does not support unique constraints with '\n-                        'conditions.' % connection.display_name,\n-                        hint=(\n-                            \"A constraint won't be created. Silence this \"\n-                            \"warning if you don't care about it.\"\n-                        ),\n-                        obj=cls,\n-                        id='models.W036',\n-                    )\n+            )\n+        if not (\n+            connection.features.supports_partial_indexes or\n+            'supports_partial_indexes' in cls._meta.required_db_features\n+        ) and any(\n+            isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n+            for constraint in cls._meta.constraints\n+        ):\n+            errors.append(\n+                checks.Warning(\n+                    '%s does not support unique constraints with '\n+                    'conditions.' % connection.display_name,\n+                    hint=(\n+                        \"A constraint won't be created. Silence this \"\n+                        \"warning if you don't care about it.\"\n+                    ),\n+                    obj=cls,\n+                    id='models.W036',\n                 )\n-            if not (\n-                connection.features.supports_deferrable_unique_constraints or\n-                'supports_deferrable_unique_constraints' in cls._meta.required_db_features\n-            ) and any(\n-                isinstance(constraint, UniqueConstraint) and constraint.deferrable is not None\n-                for constraint in cls._meta.constraints\n-            ):\n-                errors.append(\n-                    checks.Warning(\n-                        '%s does not support deferrable unique constraints.'\n-                        % connection.display_name,\n-                        hint=(\n-                            \"A constraint won't be created. Silence this \"\n-                            \"warning if you don't care about it.\"\n-                        ),\n-                        obj=cls,\n-                        id='models.W038',\n-                    )\n+            )\n+        if not (\n+            connection.features.supports_deferrable_unique_constraints or\n+            'supports_deferrable_unique_constraints' in cls._meta.required_db_features\n+        ) and any(\n+            isinstance(constraint, UniqueConstraint) and constraint.deferrable is not None\n+            for constraint in cls._meta.constraints\n+        ):\n+            errors.append(\n+                checks.Warning(\n+                    '%s does not support deferrable unique constraints.'\n+                    % connection.display_name,\n+                    hint=(\n+                        \"A constraint won't be created. Silence this \"\n+                        \"warning if you don't care about it.\"\n+                    ),\n+                    obj=cls,\n+                    id='models.W038',\n                 )\n-        return errors\n+            )\n+    return errors\n \n \n ############################################\ndiff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex 64bd60484e..6b6c029122 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -76,26 +76,16 @@ class Deferrable(Enum):\n     IMMEDIATE = 'immediate'\n \n \n-class UniqueConstraint(BaseConstraint):\n-    def __init__(self, *, fields, name, condition=None, deferrable=None):\n-        if not fields:\n-            raise ValueError('At least one field is required to define a unique constraint.')\n-        if not isinstance(condition, (type(None), Q)):\n-            raise ValueError('UniqueConstraint.condition must be a Q instance.')\n-        if condition and deferrable:\n-            raise ValueError(\n-                'UniqueConstraint with conditions cannot be deferred.'\n-            )\n-        if not isinstance(deferrable, (type(None), Deferrable)):\n-            raise ValueError(\n-                'UniqueConstraint.deferrable must be a Deferrable instance.'\n-            )\n-        self.fields = tuple(fields)\n-        self.condition = condition\n-        self.deferrable = deferrable\n-        super().__init__(name)\n \n-    def _get_condition_sql(self, model, schema_editor):\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        for constraint in cls._meta.constraints:\n+            errors.extend(constraint.check(cls, databases=databases))\n+            # Validate UniqueConstraint fields exist on the model\n+            if hasattr(constraint, 'fields') and constraint.__class__.__name__ == 'UniqueConstraint':\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        return errors\n         if self.condition is None:\n             return None\n         query = Query(model=model, alias_cols=False)\n@@ -104,8 +94,16 @@ class UniqueConstraint(BaseConstraint):\n         sql, params = where.as_sql(compiler, schema_editor.connection)\n         return sql % tuple(schema_editor.quote_value(p) for p in params)\n \n-    def constraint_sql(self, model, schema_editor):\n-        fields = [model._meta.get_field(field_name).column for field_name in self.fields]\n+\n+    @classmethod\n+    def _check_constraints(cls, **kwargs):\n+        errors = []\n+        for constraint in cls._meta.constraints:\n+            errors.extend(constraint.check(cls, **kwargs))\n+            # Check that UniqueConstraint fields exist on the model\n+            if hasattr(constraint, 'fields') and constraint.__class__.__name__ == 'UniqueConstraint':\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        return errors\n         condition = self._get_condition_sql(model, schema_editor)\n         return schema_editor._unique_sql(\n             model, fields, self.name, condition=condition,\n",
    "variant_5": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7bb3fa4706..6118429e12 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1579,11 +1579,16 @@ class Model(metaclass=ModelBase):\n                 )\n             ]\n \n-        else:\n-            errors = []\n-            for fields in cls._meta.unique_together:\n-                errors.extend(cls._check_local_fields(fields, \"unique_together\"))\n-            return errors\n+\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        for constraint in cls._meta.constraints:\n+            # Check that constraint fields exist on the model\n+            if hasattr(constraint, 'fields'):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+            errors.extend(constraint.check(databases=databases))\n+        return errors\n \n     @classmethod\n     def _check_indexes(cls, databases):\n@@ -1637,47 +1642,43 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n-    def _check_local_fields(cls, fields, option):\n-        from django.db import models\n-\n-        # In order to avoid hitting the relation tree prematurely, we use our\n-        # own fields_map instead of using get_field()\n-        forward_fields_map = {}\n-        for field in cls._meta._get_fields(reverse=False):\n-            forward_fields_map[field.name] = field\n-            if hasattr(field, 'attname'):\n-                forward_fields_map[field.attname] = field\n \n+    @classmethod\n+    def _check_constraints(cls, databases):\n         errors = []\n-        for field_name in fields:\n-            try:\n-                field = forward_fields_map[field_name]\n-            except KeyError:\n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                connection.features.supports_column_check_constraints\n+            ):\n+                continue\n+            if any(\n+                isinstance(constraint, CheckConstraint)\n+                and constraint.check.contains_aggregate\n+                for constraint in cls._meta.constraints\n+            ):\n                 errors.append(\n-                    checks.Error(\n-                        \"'%s' refers to the nonexistent field '%s'.\" % (\n-                            option, field_name,\n-                        ),\n+                    checks.Warning(\n+                        '%s contains a constraint with aggregates which is '\n+                        'only supported on PostgreSQL and MySQL.' % cls.__name__,\n                         obj=cls,\n-                        id='models.E012',\n+                        id='models.W039',\n                     )\n                 )\n-            else:\n-                if isinstance(field.remote_field, models.ManyToManyRel):\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to a ManyToManyField '%s', but \"\n-                            \"ManyToManyFields are not permitted in '%s'.\" % (\n-                                option, field_name, option,\n-                            ),\n-                            obj=cls,\n-                            id='models.E013',\n-                        )\n-                    )\n-                elif field not in cls._meta.local_fields:\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to field '%s' which is not local to model '%s'.\"\n+            break\n+        \n+        # Check that fields in UniqueConstraint exist\n+        for constraint in cls._meta.constraints:\n+            if hasattr(constraint, 'fields'):  # UniqueConstraint has fields attribute\n+                # Check if this is a UniqueConstraint by checking for fields attribute\n+                # and ensuring it's not a CheckConstraint\n+                if not isinstance(constraint, CheckConstraint):\n+                    errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n+        return errors\n                             % (option, field_name, cls._meta.object_name),\n                             hint=\"This issue may be caused by multi-table inheritance.\",\n                             obj=cls,\n@@ -1864,69 +1865,77 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n-    def _check_constraints(cls, databases):\n-        errors = []\n-        for db in databases:\n-            if not router.allow_migrate_model(db, cls):\n-                continue\n-            connection = connections[db]\n-            if not (\n-                connection.features.supports_table_check_constraints or\n-                'supports_table_check_constraints' in cls._meta.required_db_features\n-            ) and any(\n-                isinstance(constraint, CheckConstraint)\n-                for constraint in cls._meta.constraints\n-            ):\n-                errors.append(\n-                    checks.Warning(\n-                        '%s does not support check constraints.' % connection.display_name,\n-                        hint=(\n-                            \"A constraint won't be created. Silence this \"\n-                            \"warning if you don't care about it.\"\n-                        ),\n-                        obj=cls,\n-                        id='models.W027',\n-                    )\n+\n+@classmethod\n+def _check_constraints(cls, databases):\n+    errors = []\n+    \n+    # Validate UniqueConstraint fields exist\n+    for constraint in cls._meta.constraints:\n+        if isinstance(constraint, UniqueConstraint):\n+            errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+    \n+    for db in databases:\n+        if not router.allow_migrate_model(db, cls):\n+            continue\n+        connection = connections[db]\n+        if not (\n+            connection.features.supports_table_check_constraints or\n+            'supports_table_check_constraints' in cls._meta.required_db_features\n+        ) and any(\n+            isinstance(constraint, CheckConstraint)\n+            for constraint in cls._meta.constraints\n+        ):\n+            errors.append(\n+                checks.Warning(\n+                    '%s does not support check constraints.' % connection.display_name,\n+                    hint=(\n+                        \"A constraint won't be created. Silence this \"\n+                        \"warning if you don't care about it.\"\n+                    ),\n+                    obj=cls,\n+                    id='models.W027',\n                 )\n-            if not (\n-                connection.features.supports_partial_indexes or\n-                'supports_partial_indexes' in cls._meta.required_db_features\n-            ) and any(\n-                isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n-                for constraint in cls._meta.constraints\n-            ):\n-                errors.append(\n-                    checks.Warning(\n-                        '%s does not support unique constraints with '\n-                        'conditions.' % connection.display_name,\n-                        hint=(\n-                            \"A constraint won't be created. Silence this \"\n-                            \"warning if you don't care about it.\"\n-                        ),\n-                        obj=cls,\n-                        id='models.W036',\n-                    )\n+            )\n+        if not (\n+            connection.features.supports_partial_indexes or\n+            'supports_partial_indexes' in cls._meta.required_db_features\n+        ) and any(\n+            isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n+            for constraint in cls._meta.constraints\n+        ):\n+            errors.append(\n+                checks.Warning(\n+                    '%s does not support unique constraints with '\n+                    'conditions.' % connection.display_name,\n+                    hint=(\n+                        \"A constraint won't be created. Silence this \"\n+                        \"warning if you don't care about it.\"\n+                    ),\n+                    obj=cls,\n+                    id='models.W036',\n                 )\n-            if not (\n-                connection.features.supports_deferrable_unique_constraints or\n-                'supports_deferrable_unique_constraints' in cls._meta.required_db_features\n-            ) and any(\n-                isinstance(constraint, UniqueConstraint) and constraint.deferrable is not None\n-                for constraint in cls._meta.constraints\n-            ):\n-                errors.append(\n-                    checks.Warning(\n-                        '%s does not support deferrable unique constraints.'\n-                        % connection.display_name,\n-                        hint=(\n-                            \"A constraint won't be created. Silence this \"\n-                            \"warning if you don't care about it.\"\n-                        ),\n-                        obj=cls,\n-                        id='models.W038',\n-                    )\n+            )\n+        if not (\n+            connection.features.supports_deferrable_unique_constraints or\n+            'supports_deferrable_unique_constraints' in cls._meta.required_db_features\n+        ) and any(\n+            isinstance(constraint, UniqueConstraint) and constraint.deferrable is not None\n+            for constraint in cls._meta.constraints\n+        ):\n+            errors.append(\n+                checks.Warning(\n+                    '%s does not support deferrable unique constraints.'\n+                    % connection.display_name,\n+                    hint=(\n+                        \"A constraint won't be created. Silence this \"\n+                        \"warning if you don't care about it.\"\n+                    ),\n+                    obj=cls,\n+                    id='models.W038',\n                 )\n-        return errors\n+            )\n+    return errors\n \n \n ############################################\ndiff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex 64bd60484e..ac408bf474 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -76,26 +76,21 @@ class Deferrable(Enum):\n     IMMEDIATE = 'immediate'\n \n \n-class UniqueConstraint(BaseConstraint):\n-    def __init__(self, *, fields, name, condition=None, deferrable=None):\n-        if not fields:\n-            raise ValueError('At least one field is required to define a unique constraint.')\n-        if not isinstance(condition, (type(None), Q)):\n-            raise ValueError('UniqueConstraint.condition must be a Q instance.')\n-        if condition and deferrable:\n-            raise ValueError(\n-                'UniqueConstraint with conditions cannot be deferred.'\n-            )\n-        if not isinstance(deferrable, (type(None), Deferrable)):\n-            raise ValueError(\n-                'UniqueConstraint.deferrable must be a Deferrable instance.'\n-            )\n-        self.fields = tuple(fields)\n-        self.condition = condition\n-        self.deferrable = deferrable\n-        super().__init__(name)\n \n-    def _get_condition_sql(self, model, schema_editor):\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            for constraint in cls._meta.constraints:\n+                # Validate UniqueConstraint fields\n+                if constraint.__class__.__name__ == 'UniqueConstraint':\n+                    errors.extend(\n+                        cls._check_local_fields(constraint.fields, \"constraints\")\n+                    )\n+                errors.extend(constraint.validate(model=cls, instance=None, exclude=None, using=db))\n+        return errors\n         if self.condition is None:\n             return None\n         query = Query(model=model, alias_cols=False)\n@@ -104,8 +99,25 @@ class UniqueConstraint(BaseConstraint):\n         sql, params = where.as_sql(compiler, schema_editor.connection)\n         return sql % tuple(schema_editor.quote_value(p) for p in params)\n \n-    def constraint_sql(self, model, schema_editor):\n-        fields = [model._meta.get_field(field_name).column for field_name in self.fields]\n+\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        for constraint in cls._meta.constraints:\n+            # Validate UniqueConstraint fields exist on the model\n+            if hasattr(constraint, 'fields') and hasattr(constraint, '__class__') and constraint.__class__.__name__ == 'UniqueConstraint':\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+            errors.extend(constraint.check())\n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                connection.features.supports_column_check_constraints\n+            ):\n+                errors.extend(cls._check_check_constraints(connection))\n+        return errors\n         condition = self._get_condition_sql(model, schema_editor)\n         return schema_editor._unique_sql(\n             model, fields, self.name, condition=condition,\n",
    "variant_6": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7bb3fa4706..7b2142e8f2 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1579,11 +1579,16 @@ class Model(metaclass=ModelBase):\n                 )\n             ]\n \n-        else:\n-            errors = []\n-            for fields in cls._meta.unique_together:\n-                errors.extend(cls._check_local_fields(fields, \"unique_together\"))\n-            return errors\n+\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        for constraint in cls._meta.constraints:\n+            errors.extend(constraint.check(cls, databases=databases))\n+            # Check that UniqueConstraint fields exist on the model\n+            if hasattr(constraint, 'fields') and constraint.__class__.__name__ == 'UniqueConstraint':\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        return errors\n \n     @classmethod\n     def _check_indexes(cls, databases):\n@@ -1637,47 +1642,41 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n-    def _check_local_fields(cls, fields, option):\n-        from django.db import models\n-\n-        # In order to avoid hitting the relation tree prematurely, we use our\n-        # own fields_map instead of using get_field()\n-        forward_fields_map = {}\n-        for field in cls._meta._get_fields(reverse=False):\n-            forward_fields_map[field.name] = field\n-            if hasattr(field, 'attname'):\n-                forward_fields_map[field.attname] = field\n \n+    @classmethod\n+    def _check_constraints(cls, databases):\n         errors = []\n-        for field_name in fields:\n-            try:\n-                field = forward_fields_map[field_name]\n-            except KeyError:\n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                connection.features.supports_column_check_constraints\n+            ):\n+                continue\n+            if any(\n+                isinstance(constraint, CheckConstraint)\n+                and constraint.condition.contains_aggregate\n+                for constraint in cls._meta.constraints\n+            ):\n                 errors.append(\n-                    checks.Error(\n-                        \"'%s' refers to the nonexistent field '%s'.\" % (\n-                            option, field_name,\n+                    checks.Warning(\n+                        '%s contains a check constraint with a condition '\n+                        'that contains an aggregate function. This may result '\n+                        'in incorrect behavior on some database backends.' % cls._meta.label,\n+                        hint=(\n+                            'Ensure your check constraint condition does not '\n+                            'contain any aggregate functions.'\n                         ),\n                         obj=cls,\n-                        id='models.E012',\n+                        id='models.W045',\n                     )\n                 )\n-            else:\n-                if isinstance(field.remote_field, models.ManyToManyRel):\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to a ManyToManyField '%s', but \"\n-                            \"ManyToManyFields are not permitted in '%s'.\" % (\n-                                option, field_name, option,\n-                            ),\n-                            obj=cls,\n-                            id='models.E013',\n-                        )\n-                    )\n-                elif field not in cls._meta.local_fields:\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to field '%s' which is not local to model '%s'.\"\n+            for constraint in cls._meta.constraints:\n+                if isinstance(constraint, UniqueConstraint):\n+                    errors.extend(cls._check_local_fields(constraint.fields, 'constraints'))\n+        return errors\n                             % (option, field_name, cls._meta.object_name),\n                             hint=\"This issue may be caused by multi-table inheritance.\",\n                             obj=cls,\n@@ -1864,69 +1863,77 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n-    def _check_constraints(cls, databases):\n-        errors = []\n-        for db in databases:\n-            if not router.allow_migrate_model(db, cls):\n-                continue\n-            connection = connections[db]\n-            if not (\n-                connection.features.supports_table_check_constraints or\n-                'supports_table_check_constraints' in cls._meta.required_db_features\n-            ) and any(\n-                isinstance(constraint, CheckConstraint)\n-                for constraint in cls._meta.constraints\n-            ):\n-                errors.append(\n-                    checks.Warning(\n-                        '%s does not support check constraints.' % connection.display_name,\n-                        hint=(\n-                            \"A constraint won't be created. Silence this \"\n-                            \"warning if you don't care about it.\"\n-                        ),\n-                        obj=cls,\n-                        id='models.W027',\n-                    )\n+\n+@classmethod\n+def _check_constraints(cls, databases):\n+    errors = []\n+    \n+    # Check UniqueConstraint fields exist\n+    for constraint in cls._meta.constraints:\n+        if isinstance(constraint, UniqueConstraint):\n+            errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+    \n+    for db in databases:\n+        if not router.allow_migrate_model(db, cls):\n+            continue\n+        connection = connections[db]\n+        if not (\n+            connection.features.supports_table_check_constraints or\n+            'supports_table_check_constraints' in cls._meta.required_db_features\n+        ) and any(\n+            isinstance(constraint, CheckConstraint)\n+            for constraint in cls._meta.constraints\n+        ):\n+            errors.append(\n+                checks.Warning(\n+                    '%s does not support check constraints.' % connection.display_name,\n+                    hint=(\n+                        \"A constraint won't be created. Silence this \"\n+                        \"warning if you don't care about it.\"\n+                    ),\n+                    obj=cls,\n+                    id='models.W027',\n                 )\n-            if not (\n-                connection.features.supports_partial_indexes or\n-                'supports_partial_indexes' in cls._meta.required_db_features\n-            ) and any(\n-                isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n-                for constraint in cls._meta.constraints\n-            ):\n-                errors.append(\n-                    checks.Warning(\n-                        '%s does not support unique constraints with '\n-                        'conditions.' % connection.display_name,\n-                        hint=(\n-                            \"A constraint won't be created. Silence this \"\n-                            \"warning if you don't care about it.\"\n-                        ),\n-                        obj=cls,\n-                        id='models.W036',\n-                    )\n+            )\n+        if not (\n+            connection.features.supports_partial_indexes or\n+            'supports_partial_indexes' in cls._meta.required_db_features\n+        ) and any(\n+            isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n+            for constraint in cls._meta.constraints\n+        ):\n+            errors.append(\n+                checks.Warning(\n+                    '%s does not support unique constraints with '\n+                    'conditions.' % connection.display_name,\n+                    hint=(\n+                        \"A constraint won't be created. Silence this \"\n+                        \"warning if you don't care about it.\"\n+                    ),\n+                    obj=cls,\n+                    id='models.W036',\n                 )\n-            if not (\n-                connection.features.supports_deferrable_unique_constraints or\n-                'supports_deferrable_unique_constraints' in cls._meta.required_db_features\n-            ) and any(\n-                isinstance(constraint, UniqueConstraint) and constraint.deferrable is not None\n-                for constraint in cls._meta.constraints\n-            ):\n-                errors.append(\n-                    checks.Warning(\n-                        '%s does not support deferrable unique constraints.'\n-                        % connection.display_name,\n-                        hint=(\n-                            \"A constraint won't be created. Silence this \"\n-                            \"warning if you don't care about it.\"\n-                        ),\n-                        obj=cls,\n-                        id='models.W038',\n-                    )\n+            )\n+        if not (\n+            connection.features.supports_deferrable_unique_constraints or\n+            'supports_deferrable_unique_constraints' in cls._meta.required_db_features\n+        ) and any(\n+            isinstance(constraint, UniqueConstraint) and constraint.deferrable is not None\n+            for constraint in cls._meta.constraints\n+        ):\n+            errors.append(\n+                checks.Warning(\n+                    '%s does not support deferrable unique constraints.'\n+                    % connection.display_name,\n+                    hint=(\n+                        \"A constraint won't be created. Silence this \"\n+                        \"warning if you don't care about it.\"\n+                    ),\n+                    obj=cls,\n+                    id='models.W038',\n                 )\n-        return errors\n+            )\n+    return errors\n \n \n ############################################\ndiff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex 64bd60484e..5cbc1dd361 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -76,26 +76,48 @@ class Deferrable(Enum):\n     IMMEDIATE = 'immediate'\n \n \n-class UniqueConstraint(BaseConstraint):\n-    def __init__(self, *, fields, name, condition=None, deferrable=None):\n-        if not fields:\n-            raise ValueError('At least one field is required to define a unique constraint.')\n-        if not isinstance(condition, (type(None), Q)):\n-            raise ValueError('UniqueConstraint.condition must be a Q instance.')\n-        if condition and deferrable:\n-            raise ValueError(\n-                'UniqueConstraint with conditions cannot be deferred.'\n-            )\n-        if not isinstance(deferrable, (type(None), Deferrable)):\n-            raise ValueError(\n-                'UniqueConstraint.deferrable must be a Deferrable instance.'\n-            )\n-        self.fields = tuple(fields)\n-        self.condition = condition\n-        self.deferrable = deferrable\n-        super().__init__(name)\n \n-    def _get_condition_sql(self, model, schema_editor):\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                connection.features.supports_column_check_constraints\n+            ):\n+                continue\n+            for constraint in cls._meta.constraints:\n+                if hasattr(constraint, 'check') and constraint.check:\n+                    constraint_sql = constraint.constraint_sql(cls, None)\n+                    if constraint_sql:\n+                        check_sql = constraint_sql.split(' CHECK ', 1)[-1]\n+                        try:\n+                            connection.ops.check_expression_support(\n+                                CheckConstraint(check=Q(), name='')\n+                            )\n+                        except NotSupportedError as e:\n+                            errors.append(\n+                                checks.Error(\n+                                    '%s are not supported on this database backend.' % e,\n+                                    obj=cls,\n+                                    id='models.E027',\n+                                )\n+                            )\n+                        except DatabaseError:\n+                            errors.append(\n+                                checks.Error(\n+                                    'Check constraint contains invalid SQL.',\n+                                    obj=cls,\n+                                    id='models.E026',\n+                                )\n+                            )\n+                # Add field validation for UniqueConstraint\n+                if hasattr(constraint, 'fields') and constraint.__class__.__name__ == 'UniqueConstraint':\n+                    errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        return errors\n         if self.condition is None:\n             return None\n         query = Query(model=model, alias_cols=False)\n@@ -104,8 +126,19 @@ class UniqueConstraint(BaseConstraint):\n         sql, params = where.as_sql(compiler, schema_editor.connection)\n         return sql % tuple(schema_editor.quote_value(p) for p in params)\n \n-    def constraint_sql(self, model, schema_editor):\n-        fields = [model._meta.get_field(field_name).column for field_name in self.fields]\n+\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            for constraint in cls._meta.constraints:\n+                # Check that UniqueConstraint fields exist on the model\n+                if hasattr(constraint, 'fields') and constraint.__class__.__name__ == 'UniqueConstraint':\n+                    errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+                errors.extend(constraint.validate(model=cls, instance=None, exclude=None, using=db))\n+        return errors\n         condition = self._get_condition_sql(model, schema_editor)\n         return schema_editor._unique_sql(\n             model, fields, self.name, condition=condition,\n",
    "variant_7": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7bb3fa4706..d9d337e9f0 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1579,11 +1579,16 @@ class Model(metaclass=ModelBase):\n                 )\n             ]\n \n-        else:\n-            errors = []\n-            for fields in cls._meta.unique_together:\n-                errors.extend(cls._check_local_fields(fields, \"unique_together\"))\n-            return errors\n+\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        for constraint in cls._meta.constraints:\n+            # Validate fields in UniqueConstraint\n+            if hasattr(constraint, 'fields') and constraint.__class__.__name__ == 'UniqueConstraint':\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+            errors.extend(constraint.check(databases=databases))\n+        return errors\n \n     @classmethod\n     def _check_indexes(cls, databases):\n@@ -1637,47 +1642,16 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n-    def _check_local_fields(cls, fields, option):\n-        from django.db import models\n-\n-        # In order to avoid hitting the relation tree prematurely, we use our\n-        # own fields_map instead of using get_field()\n-        forward_fields_map = {}\n-        for field in cls._meta._get_fields(reverse=False):\n-            forward_fields_map[field.name] = field\n-            if hasattr(field, 'attname'):\n-                forward_fields_map[field.attname] = field\n \n+    @classmethod\n+    def _check_constraints(cls, **kwargs):\n         errors = []\n-        for field_name in fields:\n-            try:\n-                field = forward_fields_map[field_name]\n-            except KeyError:\n-                errors.append(\n-                    checks.Error(\n-                        \"'%s' refers to the nonexistent field '%s'.\" % (\n-                            option, field_name,\n-                        ),\n-                        obj=cls,\n-                        id='models.E012',\n-                    )\n-                )\n-            else:\n-                if isinstance(field.remote_field, models.ManyToManyRel):\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to a ManyToManyField '%s', but \"\n-                            \"ManyToManyFields are not permitted in '%s'.\" % (\n-                                option, field_name, option,\n-                            ),\n-                            obj=cls,\n-                            id='models.E013',\n-                        )\n-                    )\n-                elif field not in cls._meta.local_fields:\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to field '%s' which is not local to model '%s'.\"\n+        for constraint in cls._meta.constraints:\n+            errors.extend(constraint.validate(cls, exclude=kwargs.get('exclude')))\n+            # Validate UniqueConstraint fields exist\n+            if hasattr(constraint, 'fields') and constraint.fields:\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        return errors\n                             % (option, field_name, cls._meta.object_name),\n                             hint=\"This issue may be caused by multi-table inheritance.\",\n                             obj=cls,\n@@ -1864,69 +1838,77 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n-    def _check_constraints(cls, databases):\n-        errors = []\n-        for db in databases:\n-            if not router.allow_migrate_model(db, cls):\n-                continue\n-            connection = connections[db]\n-            if not (\n-                connection.features.supports_table_check_constraints or\n-                'supports_table_check_constraints' in cls._meta.required_db_features\n-            ) and any(\n-                isinstance(constraint, CheckConstraint)\n-                for constraint in cls._meta.constraints\n-            ):\n-                errors.append(\n-                    checks.Warning(\n-                        '%s does not support check constraints.' % connection.display_name,\n-                        hint=(\n-                            \"A constraint won't be created. Silence this \"\n-                            \"warning if you don't care about it.\"\n-                        ),\n-                        obj=cls,\n-                        id='models.W027',\n-                    )\n+\n+@classmethod\n+def _check_constraints(cls, databases):\n+    errors = []\n+    \n+    # Validate UniqueConstraint fields exist\n+    for constraint in cls._meta.constraints:\n+        if isinstance(constraint, UniqueConstraint):\n+            errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+    \n+    for db in databases:\n+        if not router.allow_migrate_model(db, cls):\n+            continue\n+        connection = connections[db]\n+        if not (\n+            connection.features.supports_table_check_constraints or\n+            'supports_table_check_constraints' in cls._meta.required_db_features\n+        ) and any(\n+            isinstance(constraint, CheckConstraint)\n+            for constraint in cls._meta.constraints\n+        ):\n+            errors.append(\n+                checks.Warning(\n+                    '%s does not support check constraints.' % connection.display_name,\n+                    hint=(\n+                        \"A constraint won't be created. Silence this \"\n+                        \"warning if you don't care about it.\"\n+                    ),\n+                    obj=cls,\n+                    id='models.W027',\n                 )\n-            if not (\n-                connection.features.supports_partial_indexes or\n-                'supports_partial_indexes' in cls._meta.required_db_features\n-            ) and any(\n-                isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n-                for constraint in cls._meta.constraints\n-            ):\n-                errors.append(\n-                    checks.Warning(\n-                        '%s does not support unique constraints with '\n-                        'conditions.' % connection.display_name,\n-                        hint=(\n-                            \"A constraint won't be created. Silence this \"\n-                            \"warning if you don't care about it.\"\n-                        ),\n-                        obj=cls,\n-                        id='models.W036',\n-                    )\n+            )\n+        if not (\n+            connection.features.supports_partial_indexes or\n+            'supports_partial_indexes' in cls._meta.required_db_features\n+        ) and any(\n+            isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n+            for constraint in cls._meta.constraints\n+        ):\n+            errors.append(\n+                checks.Warning(\n+                    '%s does not support unique constraints with '\n+                    'conditions.' % connection.display_name,\n+                    hint=(\n+                        \"A constraint won't be created. Silence this \"\n+                        \"warning if you don't care about it.\"\n+                    ),\n+                    obj=cls,\n+                    id='models.W036',\n                 )\n-            if not (\n-                connection.features.supports_deferrable_unique_constraints or\n-                'supports_deferrable_unique_constraints' in cls._meta.required_db_features\n-            ) and any(\n-                isinstance(constraint, UniqueConstraint) and constraint.deferrable is not None\n-                for constraint in cls._meta.constraints\n-            ):\n-                errors.append(\n-                    checks.Warning(\n-                        '%s does not support deferrable unique constraints.'\n-                        % connection.display_name,\n-                        hint=(\n-                            \"A constraint won't be created. Silence this \"\n-                            \"warning if you don't care about it.\"\n-                        ),\n-                        obj=cls,\n-                        id='models.W038',\n-                    )\n+            )\n+        if not (\n+            connection.features.supports_deferrable_unique_constraints or\n+            'supports_deferrable_unique_constraints' in cls._meta.required_db_features\n+        ) and any(\n+            isinstance(constraint, UniqueConstraint) and constraint.deferrable is not None\n+            for constraint in cls._meta.constraints\n+        ):\n+            errors.append(\n+                checks.Warning(\n+                    '%s does not support deferrable unique constraints.'\n+                    % connection.display_name,\n+                    hint=(\n+                        \"A constraint won't be created. Silence this \"\n+                        \"warning if you don't care about it.\"\n+                    ),\n+                    obj=cls,\n+                    id='models.W038',\n                 )\n-        return errors\n+            )\n+    return errors\n \n \n ############################################\ndiff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex 64bd60484e..2d7e2f1c34 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -76,26 +76,36 @@ class Deferrable(Enum):\n     IMMEDIATE = 'immediate'\n \n \n-class UniqueConstraint(BaseConstraint):\n-    def __init__(self, *, fields, name, condition=None, deferrable=None):\n-        if not fields:\n-            raise ValueError('At least one field is required to define a unique constraint.')\n-        if not isinstance(condition, (type(None), Q)):\n-            raise ValueError('UniqueConstraint.condition must be a Q instance.')\n-        if condition and deferrable:\n-            raise ValueError(\n-                'UniqueConstraint with conditions cannot be deferred.'\n-            )\n-        if not isinstance(deferrable, (type(None), Deferrable)):\n-            raise ValueError(\n-                'UniqueConstraint.deferrable must be a Deferrable instance.'\n-            )\n-        self.fields = tuple(fields)\n-        self.condition = condition\n-        self.deferrable = deferrable\n-        super().__init__(name)\n \n-    def _get_condition_sql(self, model, schema_editor):\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                connection.features.supports_column_check_constraints\n+            ):\n+                errors.append(\n+                    checks.Warning(\n+                        '%s does not support check constraints.' % connection.display_name,\n+                        hint=(\n+                            \"A constraint won't be created. Silence this \"\n+                            \"warning if you don't care about it.\"\n+                        ),\n+                        obj=cls,\n+                        id='models.W027',\n+                    )\n+                )\n+        \n+        # Validate fields in UniqueConstraint\n+        for constraint in cls._meta.constraints:\n+            if hasattr(constraint, 'fields') and hasattr(constraint, 'condition'):  # UniqueConstraint\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n+        return errors\n         if self.condition is None:\n             return None\n         query = Query(model=model, alias_cols=False)\n@@ -104,8 +114,19 @@ class UniqueConstraint(BaseConstraint):\n         sql, params = where.as_sql(compiler, schema_editor.connection)\n         return sql % tuple(schema_editor.quote_value(p) for p in params)\n \n-    def constraint_sql(self, model, schema_editor):\n-        fields = [model._meta.get_field(field_name).column for field_name in self.fields]\n+\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            for constraint in cls._meta.constraints:\n+                # Validate UniqueConstraint fields exist on the model\n+                if hasattr(constraint, 'fields') and constraint.__class__.__name__ == 'UniqueConstraint':\n+                    errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+                errors.extend(constraint.validate(model=cls, instance=None, exclude=None, using=db))\n+        return errors\n         condition = self._get_condition_sql(model, schema_editor)\n         return schema_editor._unique_sql(\n             model, fields, self.name, condition=condition,\n",
    "variant_8": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7bb3fa4706..9c113e4216 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1579,11 +1579,23 @@ class Model(metaclass=ModelBase):\n                 )\n             ]\n \n-        else:\n-            errors = []\n-            for fields in cls._meta.unique_together:\n-                errors.extend(cls._check_local_fields(fields, \"unique_together\"))\n-            return errors\n+\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        for constraint in cls._meta.constraints:\n+            constraint_databases = constraint.databases\n+            if (\n+                constraint_databases is not None and\n+                constraint_databases.isdisjoint(databases)\n+            ):\n+                continue\n+            errors.extend(constraint.check(cls, databases=databases))\n+            \n+            # Check that UniqueConstraint fields exist on the model\n+            if hasattr(constraint, 'fields') and constraint.__class__.__name__ == 'UniqueConstraint':\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        return errors\n \n     @classmethod\n     def _check_indexes(cls, databases):\n@@ -1637,47 +1649,66 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n-    def _check_local_fields(cls, fields, option):\n-        from django.db import models\n-\n-        # In order to avoid hitting the relation tree prematurely, we use our\n-        # own fields_map instead of using get_field()\n-        forward_fields_map = {}\n-        for field in cls._meta._get_fields(reverse=False):\n-            forward_fields_map[field.name] = field\n-            if hasattr(field, 'attname'):\n-                forward_fields_map[field.attname] = field\n \n+    @classmethod\n+    def _check_constraints(cls, databases):\n         errors = []\n-        for field_name in fields:\n-            try:\n-                field = forward_fields_map[field_name]\n-            except KeyError:\n-                errors.append(\n-                    checks.Error(\n-                        \"'%s' refers to the nonexistent field '%s'.\" % (\n-                            option, field_name,\n-                        ),\n-                        obj=cls,\n-                        id='models.E012',\n-                    )\n-                )\n-            else:\n-                if isinstance(field.remote_field, models.ManyToManyRel):\n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                connection.features.supports_column_check_constraints\n+            ):\n+                continue\n+            if any(isinstance(constraint, CheckConstraint) for constraint in cls._meta.constraints):\n+                if not connection.features.supports_table_check_constraints:\n                     errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to a ManyToManyField '%s', but \"\n-                            \"ManyToManyFields are not permitted in '%s'.\" % (\n-                                option, field_name, option,\n+                        checks.Warning(\n+                            '%s does not support check constraints.' % connection.display_name,\n+                            hint=(\n+                                \"A constraint won't be created. Silence this \"\n+                                \"warning if you don't care about it.\"\n                             ),\n                             obj=cls,\n-                            id='models.E013',\n+                            id='models.W027',\n                         )\n                     )\n-                elif field not in cls._meta.local_fields:\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to field '%s' which is not local to model '%s'.\"\n+                else:\n+                    for constraint in cls._meta.constraints:\n+                        if isinstance(constraint, CheckConstraint):\n+                            if constraint.condition is None:\n+                                errors.append(\n+                                    checks.Error(\n+                                        'CheckConstraints with a Q object condition have '\n+                                        'their check property set to None.',\n+                                        hint='Use a Q object for the condition.',\n+                                        obj=cls,\n+                                        id='models.E031',\n+                                    )\n+                                )\n+                            else:\n+                                # Check Q object validity\n+                                constraint_check = constraint.check\n+                                # Only validate if we have a check attribute to validate\n+                                if hasattr(constraint, 'check') and constraint_check:\n+                                    if not isinstance(constraint_check, Q):\n+                                        errors.append(\n+                                            checks.Error(\n+                                                'CheckConstraints.check must be a Q instance.',\n+                                                obj=cls,\n+                                                id='models.E028',\n+                                            )\n+                                        )\n+        \n+        # Validate fields in UniqueConstraint objects\n+        from django.db.models.constraints import UniqueConstraint\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, 'constraints'))\n+        \n+        return errors\n                             % (option, field_name, cls._meta.object_name),\n                             hint=\"This issue may be caused by multi-table inheritance.\",\n                             obj=cls,\n@@ -1863,9 +1894,17 @@ class Model(metaclass=ModelBase):\n \n         return errors\n \n+    @classmethod\n+\n     @classmethod\n     def _check_constraints(cls, databases):\n         errors = []\n+        \n+        # Validate fields in UniqueConstraints\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+        \n         for db in databases:\n             if not router.allow_migrate_model(db, cls):\n                 continue\ndiff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex 64bd60484e..d487a73f5a 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -76,26 +76,19 @@ class Deferrable(Enum):\n     IMMEDIATE = 'immediate'\n \n \n-class UniqueConstraint(BaseConstraint):\n-    def __init__(self, *, fields, name, condition=None, deferrable=None):\n-        if not fields:\n-            raise ValueError('At least one field is required to define a unique constraint.')\n-        if not isinstance(condition, (type(None), Q)):\n-            raise ValueError('UniqueConstraint.condition must be a Q instance.')\n-        if condition and deferrable:\n-            raise ValueError(\n-                'UniqueConstraint with conditions cannot be deferred.'\n-            )\n-        if not isinstance(deferrable, (type(None), Deferrable)):\n-            raise ValueError(\n-                'UniqueConstraint.deferrable must be a Deferrable instance.'\n-            )\n-        self.fields = tuple(fields)\n-        self.condition = condition\n-        self.deferrable = deferrable\n-        super().__init__(name)\n \n-    def _get_condition_sql(self, model, schema_editor):\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            for constraint in cls._meta.constraints:\n+                # Validate fields exist for UniqueConstraint\n+                if hasattr(constraint, 'fields') and constraint.__class__.__name__ == 'UniqueConstraint':\n+                    errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+                errors.extend(constraint.validate(model=cls, instance=None, exclude=None, using=db))\n+        return errors\n         if self.condition is None:\n             return None\n         query = Query(model=model, alias_cols=False)\n@@ -104,8 +97,20 @@ class UniqueConstraint(BaseConstraint):\n         sql, params = where.as_sql(compiler, schema_editor.connection)\n         return sql % tuple(schema_editor.quote_value(p) for p in params)\n \n-    def constraint_sql(self, model, schema_editor):\n-        fields = [model._meta.get_field(field_name).column for field_name in self.fields]\n+\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            for constraint in cls._meta.constraints:\n+                # Validate UniqueConstraint fields exist on the model\n+                if hasattr(constraint, 'fields') and constraint.__class__.__name__ == 'UniqueConstraint':\n+                    errors.extend(cls._check_local_fields(constraint.fields, \"constraints\"))\n+                \n+                errors.extend(constraint.validate(model=cls, instance=None, exclude=None, using=db))\n+        return errors\n         condition = self._get_condition_sql(model, schema_editor)\n         return schema_editor._unique_sql(\n             model, fields, self.name, condition=condition,\n"
  }
}