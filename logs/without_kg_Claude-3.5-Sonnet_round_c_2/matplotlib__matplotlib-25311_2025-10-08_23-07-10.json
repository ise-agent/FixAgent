{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/matplotlib/lib/matplotlib/offsetbox.py lines 1503-1515)": "\n    def __init__(self, ref_artist, use_blit=False):\n        self.ref_artist = ref_artist\n        if not ref_artist.pickable():\n            ref_artist.set_picker(True)\n        self.got_artist = False\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = use_blit and self.canvas.supports_blit\n        self.cids = [\n            self.canvas.callbacks._connect_picklable(\n                'pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable(\n                'button_release_event', self.on_release),\n        ]\n\n    def __getstate__(self):\n        # Exclude non-picklable attributes during serialization\n        state = self.__dict__.copy()\n        # Remove non-picklable canvas and callback references\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        # Restore the object state\n        self.__dict__.update(state)\n        # Set non-picklable attributes to None - they will be re-initialized if needed\n        self.canvas = None\n        self.cids = []\n        self._c1 = None\n        self.background = None\n",
    "Location 2 (/root/hy/projects_2/matplotlib/lib/matplotlib/offsetbox.py lines 1570-1573)": "\n    def disconnect(self):\n        \"\"\"Disconnect the callbacks.\"\"\"\n        for cid in self.cids:\n            self.canvas.mpl_disconnect(cid)\n        try:\n            c1 = self._c1\n        except AttributeError:\n            pass\n        else:\n            self.canvas.mpl_disconnect(c1)\n\n    def __getstate__(self):\n        \"\"\"Prepare object for pickling by excluding non-picklable attributes.\"\"\"\n        state = self.__dict__.copy()\n        # Remove non-picklable attributes\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object from pickled state.\"\"\"\n        self.__dict__.update(state)\n        # Set non-picklable attributes to None/empty defaults\n        self.canvas = None\n        self.cids = []\n        # Don't set _c1 or background as they may not exist\n",
    "Location 3 (/root/hy/projects_2/matplotlib/lib/matplotlib/legend.py lines 614-615)": "\n        self._draggable = None\n        self.set_draggable(state=draggable)\n\n    def __getstate__(self):\n        \"\"\"Custom pickling to handle non-picklable draggable objects.\"\"\"\n        state = self.__dict__.copy()\n        # Remove the unpicklable draggable object\n        state['_draggable'] = None\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Custom unpickling to restore legend state.\"\"\"\n        self.__dict__.update(state)\n        # Draggable functionality will need to be re-enabled manually if needed\n        self._draggable = None\n",
    "Location 4 (/root/hy/projects_2/matplotlib/lib/matplotlib/legend.py lines 1196-1205)": "\n        if state:\n            if self._draggable is None:\n                self._draggable = DraggableLegend(self,\n                                                  use_blit,\n                                                  update=update)\n        else:\n            if self._draggable is not None:\n                self._draggable.disconnect()\n            self._draggable = None\n        return self._draggable\n",
    "Location 5 (/root/hy/projects_2/matplotlib/lib/matplotlib/legend.py lines 53-95)": "\nclass DraggableLegend(DraggableOffsetBox):\n    def __init__(self, legend, use_blit=False, update=\"loc\"):\n        \"\"\"\n        Wrapper around a `.Legend` to support mouse dragging.\n\n        Parameters\n        ----------\n        legend : `.Legend`\n            The `.Legend` instance to wrap.\n        use_blit : bool, optional\n            Use blitting for faster image composition. For details see\n            :ref:`func-animation`.\n        update : {'loc', 'bbox'}, optional\n            If \"loc\", update the *loc* parameter of the legend upon finalizing.\n            If \"bbox\", update the *bbox_to_anchor* parameter.\n        \"\"\"\n        self.legend = legend\n\n        _api.check_in_list([\"loc\", \"bbox\"], update=update)\n        self._update = update\n\n        super().__init__(legend, legend._legend_box, use_blit=use_blit)\n\n    def finalize_offset(self):\n        if self._update == \"loc\":\n            self._update_loc(self.get_loc_in_canvas())\n        elif self._update == \"bbox\":\n            self._bbox_to_anchor(self.get_loc_in_canvas())\n\n    def _update_loc(self, loc_in_canvas):\n        bbox = self.legend.get_bbox_to_anchor()\n        # if bbox has zero width or height, the transformation is\n        # ill-defined. Fall back to the default bbox_to_anchor.\n        if bbox.width == 0 or bbox.height == 0:\n            self.legend.set_bbox_to_anchor(None)\n            bbox = self.legend.get_bbox_to_anchor()\n        _bbox_transform = BboxTransformFrom(bbox)\n        self.legend._loc = tuple(_bbox_transform.transform(loc_in_canvas))\n\n    def _update_bbox_to_anchor(self, loc_in_canvas):\n        loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n        self.legend.set_bbox_to_anchor(loc_in_bbox)\n\n    def __getstate__(self):\n        state = self.__dict__.copy()\n        # Remove non-picklable attributes that are handled by parent class\n        return state\n\n    def __setstate__(self, state):\n        self.__dict__.update(state)\n        # The parent class DraggableBase will handle restoration of canvas-related attributes\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/matplotlib/lib/matplotlib/offsetbox.py lines 1503-1515)": [
      "\n    def __init__(self, ref_artist, use_blit=False):\n        self.ref_artist = ref_artist\n        if not ref_artist.pickable():\n            ref_artist.set_picker(True)\n        self.got_artist = False\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = use_blit and self.canvas.supports_blit\n        self.cids = [\n            self.canvas.callbacks._connect_picklable(\n                'pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable(\n                'button_release_event', self.on_release),\n        ]\n\n    def __getstate__(self):\n        \"\"\"Return state for pickling, excluding non-picklable canvas references.\"\"\"\n        state = self.__dict__.copy()\n        # Remove non-picklable attributes\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore state from pickling.\"\"\"\n        self.__dict__.update(state)\n        # Set excluded attributes to None - they will be reinitialized if dragging is re-enabled\n        self.canvas = None\n        self.cids = []\n        self._c1 = None\n        self.background = None\n",
      "\n    def __init__(self, ref_artist, use_blit=False):\n        self.ref_artist = ref_artist\n        if not ref_artist.pickable():\n            ref_artist.set_picker(True)\n        self.got_artist = False\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = use_blit and self.canvas.supports_blit\n        self.cids = [\n            self.canvas.callbacks._connect_picklable(\n                'pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable(\n                'button_release_event', self.on_release),\n        ]\n\n    def __getstate__(self):\n        state = self.__dict__.copy()\n        # Remove unpicklable entries\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        self.__dict__.update(state)\n        # Set unpicklable attributes to None - they will be reinitialized if needed\n        self.canvas = None\n        self.cids = []\n        self._c1 = None\n        self.background = None\n",
      "\n    def __init__(self, ref_artist, use_blit=False):\n        self.ref_artist = ref_artist\n        if not ref_artist.pickable():\n            ref_artist.set_picker(True)\n        self.got_artist = False\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = use_blit and self.canvas.supports_blit\n        self.cids = [\n            self.canvas.callbacks._connect_picklable(\n                'pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable(\n                'button_release_event', self.on_release),\n        ]\n\n    def __getstate__(self):\n        # Exclude non-picklable attributes from the pickled state\n        state = self.__dict__.copy()\n        # Remove unpicklable canvas and callback references\n        state.pop('canvas', None)\n        state.pop('cids', None) \n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        # Restore the pickled state\n        self.__dict__.update(state)\n        # Set non-picklable attributes to None - they will be reinitialized if dragging is re-enabled\n        self.canvas = None\n        self.cids = []\n        self._c1 = None\n        self.background = None\n",
      "\n    def __init__(self, ref_artist, use_blit=False):\n        self.ref_artist = ref_artist\n        if not ref_artist.pickable():\n            ref_artist.set_picker(True)\n        self.got_artist = False\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = use_blit and self.canvas.supports_blit\n        self.cids = [\n            self.canvas.callbacks._connect_picklable(\n                'pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable(\n                'button_release_event', self.on_release),\n        ]\n\n    def __getstate__(self):\n        # Remove non-picklable attributes for serialization\n        state = self.__dict__.copy()\n        # Remove canvas and callback IDs which cannot be pickled\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)  # motion event callback\n        state.pop('background', None)  # blit background\n        return state\n\n    def __setstate__(self, state):\n        # Restore state and set non-picklable attributes to None\n        self.__dict__.update(state)\n        self.canvas = None\n        self.cids = []\n        self._c1 = None\n        self.background = None\n        self.got_artist = False\n",
      "\n    def __init__(self, ref_artist, use_blit=False):\n        self.ref_artist = ref_artist\n        if not ref_artist.pickable():\n            ref_artist.set_picker(True)\n        self.got_artist = False\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = use_blit and self.canvas.supports_blit\n        self.cids = [\n            self.canvas.callbacks._connect_picklable(\n                'pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable(\n                'button_release_event', self.on_release),\n        ]\n\n    def __getstate__(self):\n        \"\"\"Return state for pickling, excluding non-picklable attributes.\"\"\"\n        state = self.__dict__.copy()\n        # Remove non-picklable attributes\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore state from pickling.\"\"\"\n        self.__dict__.update(state)\n        # Set excluded attributes to None\n        self.canvas = None\n        self.cids = []\n        self._c1 = None\n        self.background = None\n",
      "\n    def __init__(self, ref_artist, use_blit=False):\n        self.ref_artist = ref_artist\n        if not ref_artist.pickable():\n            ref_artist.set_picker(True)\n        self.got_artist = False\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = use_blit and self.canvas.supports_blit\n        self.cids = [\n            self.canvas.callbacks._connect_picklable(\n                'pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable(\n                'button_release_event', self.on_release),\n        ]\n\n    def __getstate__(self):\n        # Create a copy of the instance dictionary\n        state = self.__dict__.copy()\n        # Remove unpicklable attributes\n        state['canvas'] = None\n        state['cids'] = []\n        if hasattr(self, '_c1'):\n            state['_c1'] = None\n        if hasattr(self, 'background'):\n            state['background'] = None\n        return state\n\n    def __setstate__(self, state):\n        # Restore the instance dictionary\n        self.__dict__.update(state)\n        # Set unpicklable attributes to None - they will be reinitialized if dragging is re-enabled\n        self.canvas = None\n        self.cids = []\n        self._c1 = None\n        if hasattr(self, 'background'):\n            self.background = None\n",
      "\n    def __init__(self, ref_artist, use_blit=False):\n        self.ref_artist = ref_artist\n        if not ref_artist.pickable():\n            ref_artist.set_picker(True)\n        self.got_artist = False\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = use_blit and self.canvas.supports_blit\n        self.cids = [\n            self.canvas.callbacks._connect_picklable(\n                'pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable(\n                'button_release_event', self.on_release),\n        ]\n\n    def __getstate__(self):\n        # Exclude non-picklable attributes from the pickled state\n        state = self.__dict__.copy()\n        # Remove unpicklable attributes\n        state.pop('canvas', None)\n        state.pop('cids', None) \n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        # Restore the object state\n        self.__dict__.update(state)\n        # Set excluded attributes to None - they will be re-initialized if dragging is re-enabled\n        self.canvas = None\n        self.cids = []\n        self._c1 = None\n        self.background = None\n",
      "\n    def __init__(self, ref_artist, use_blit=False):\n        self.ref_artist = ref_artist\n        if not ref_artist.pickable():\n            ref_artist.set_picker(True)\n        self.got_artist = False\n        self.canvas = self.ref_artist.figure.canvas\n        self._use_blit = use_blit and self.canvas.supports_blit\n        self.cids = [\n            self.canvas.callbacks._connect_picklable(\n                'pick_event', self.on_pick),\n            self.canvas.callbacks._connect_picklable(\n                'button_release_event', self.on_release),\n        ]\n\n    def __getstate__(self):\n        # Exclude non-picklable attributes from the state\n        state = self.__dict__.copy()\n        # Remove the unpicklable entries\n        state['canvas'] = None\n        state['cids'] = []\n        if hasattr(self, '_c1'):\n            state['_c1'] = None\n        if hasattr(self, 'background'):\n            state['background'] = None\n        return state\n\n    def __setstate__(self, state):\n        # Restore the object state\n        self.__dict__.update(state)\n        # Set canvas and cids to None - they will need to be re-initialized\n        # if draggable functionality is needed again\n        self.canvas = None\n        self.cids = []\n        self.got_artist = False\n"
    ],
    "Location 2 (/root/hy/projects_2/matplotlib/lib/matplotlib/offsetbox.py lines 1570-1573)": [
      "\n    def disconnect(self):\n        \"\"\"Disconnect the callbacks.\"\"\"\n        for cid in self.cids:\n            self.canvas.mpl_disconnect(cid)\n        try:\n            c1 = self._c1\n        except AttributeError:\n            pass\n        else:\n            self.canvas.mpl_disconnect(c1)\n\n    def __getstate__(self):\n        \"\"\"Return state for pickling, excluding non-picklable attributes.\"\"\"\n        state = self.__dict__.copy()\n        # Remove non-picklable attributes\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore state from pickling.\"\"\"\n        self.__dict__.update(state)\n        # Set non-picklable attributes to None/default values\n        self.canvas = None\n        self.cids = []\n        self.background = None\n",
      "\n    def disconnect(self):\n        \"\"\"Disconnect the callbacks.\"\"\"\n        for cid in self.cids:\n            self.canvas.mpl_disconnect(cid)\n        try:\n            c1 = self._c1\n        except AttributeError:\n            pass\n        else:\n            self.canvas.mpl_disconnect(c1)\n\n    def __getstate__(self):\n        \"\"\"Support for pickle by excluding non-picklable attributes.\"\"\"\n        state = self.__dict__.copy()\n        # Remove non-picklable attributes\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore state from pickle, setting non-picklable attributes to None.\"\"\"\n        self.__dict__.update(state)\n        # Set non-picklable attributes to appropriate defaults\n        self.canvas = None\n        self.cids = []\n        # Don't set _c1 since it may not exist\n        self.background = None\n",
      "\n    def disconnect(self):\n        \"\"\"Disconnect the callbacks.\"\"\"\n        for cid in self.cids:\n            self.canvas.mpl_disconnect(cid)\n        try:\n            c1 = self._c1\n        except AttributeError:\n            pass\n        else:\n            self.canvas.mpl_disconnect(c1)\n\n    def __getstate__(self):\n        \"\"\"Get state for pickling, excluding non-picklable canvas references.\"\"\"\n        state = self.__dict__.copy()\n        # Remove non-picklable attributes\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore state from pickling.\"\"\"\n        self.__dict__.update(state)\n        # Set non-picklable attributes to None\n        self.canvas = None\n        self.cids = []\n        self.background = None\n",
      "\n    def disconnect(self):\n        \"\"\"Disconnect the callbacks.\"\"\"\n        for cid in self.cids:\n            self.canvas.mpl_disconnect(cid)\n        try:\n            c1 = self._c1\n        except AttributeError:\n            pass\n        else:\n            self.canvas.mpl_disconnect(c1)\n\n    def __getstate__(self):\n        \"\"\"Return state for pickling, excluding non-picklable canvas and callbacks.\"\"\"\n        state = self.__dict__.copy()\n        # Remove non-picklable attributes\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore state from pickling.\"\"\"\n        self.__dict__.update(state)\n        # Set non-picklable attributes to None\n        self.canvas = None\n        self.cids = []\n        self.background = None\n",
      "\n    def disconnect(self):\n        \"\"\"Disconnect the callbacks.\"\"\"\n        for cid in self.cids:\n            self.canvas.mpl_disconnect(cid)\n        try:\n            c1 = self._c1\n        except AttributeError:\n            pass\n        else:\n            self.canvas.mpl_disconnect(c1)\n\n    def __getstate__(self):\n        \"\"\"Return state for pickling, excluding non-picklable attributes.\"\"\"\n        state = self.__dict__.copy()\n        # Remove non-picklable attributes\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore state from pickling.\"\"\"\n        self.__dict__.update(state)\n        # Set non-picklable attributes to None/defaults\n        self.canvas = None\n        self.cids = []\n        self.background = None\n",
      "\n    def disconnect(self):\n        \"\"\"Disconnect the callbacks.\"\"\"\n        for cid in self.cids:\n            self.canvas.mpl_disconnect(cid)\n        try:\n            c1 = self._c1\n        except AttributeError:\n            pass\n        else:\n            self.canvas.mpl_disconnect(c1)\n\n    def __getstate__(self):\n        \"\"\"Custom pickle state that excludes non-picklable attributes.\"\"\"\n        state = self.__dict__.copy()\n        # Remove non-picklable attributes\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore state from pickle, setting excluded attributes to None.\"\"\"\n        self.__dict__.update(state)\n        # Set non-picklable attributes to None/defaults\n        self.canvas = None\n        self.cids = []\n        self.background = None\n",
      "\n    def disconnect(self):\n        \"\"\"Disconnect the callbacks.\"\"\"\n        for cid in self.cids:\n            self.canvas.mpl_disconnect(cid)\n        try:\n            c1 = self._c1\n        except AttributeError:\n            pass\n        else:\n            self.canvas.mpl_disconnect(c1)\n\n    def __getstate__(self):\n        \"\"\"Get state for pickling, excluding non-picklable attributes.\"\"\"\n        state = self.__dict__.copy()\n        # Remove non-picklable attributes\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore state from pickling.\"\"\"\n        self.__dict__.update(state)\n        # Set excluded attributes to None/empty defaults\n        self.canvas = None\n        self.cids = []\n        self.background = None\n",
      "\n    def disconnect(self):\n        \"\"\"Disconnect the callbacks.\"\"\"\n        for cid in self.cids:\n            self.canvas.mpl_disconnect(cid)\n        try:\n            c1 = self._c1\n        except AttributeError:\n            pass\n        else:\n            self.canvas.mpl_disconnect(c1)\n\n    def __getstate__(self):\n        \"\"\"Prepare object state for pickling by excluding non-picklable attributes.\"\"\"\n        state = self.__dict__.copy()\n        # Remove non-picklable attributes\n        state.pop('canvas', None)\n        state.pop('cids', None)\n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore object state after unpickling.\"\"\"\n        self.__dict__.update(state)\n        # Set non-picklable attributes to None/defaults\n        self.canvas = None\n        self.cids = []\n        self.background = None\n"
    ],
    "Location 3 (/root/hy/projects_2/matplotlib/lib/matplotlib/legend.py lines 614-615)": [
      "\n        self._draggable = None\n        self.set_draggable(state=draggable)\n\n    def __getstate__(self):\n        \"\"\"Support pickling by excluding non-picklable draggable state.\"\"\"\n        state = self.__dict__.copy()\n        # Remove the draggable instance as it contains non-picklable canvas reference\n        state['_draggable'] = None\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore state after unpickling.\"\"\"\n        self.__dict__.update(state)\n        # _draggable is already None from __getstate__, no additional setup needed\n",
      "\n        self._draggable = None\n        self.set_draggable(state=draggable)\n\n    def __getstate__(self):\n        # Get the default state\n        state = self.__dict__.copy()\n        # Remove the unpicklable _draggable attribute\n        state['_draggable'] = None\n        return state\n\n    def __setstate__(self, state):\n        # Restore the state\n        self.__dict__.update(state)\n        # Initialize _draggable to None - it can be re-enabled via set_draggable() if needed\n        self._draggable = None\n",
      "\n        self._draggable = None\n        self.set_draggable(state=draggable)\n\n    def __getstate__(self):\n        \"\"\"Exclude non-picklable attributes during pickling.\"\"\"\n        state = self.__dict__.copy()\n        # Remove the _draggable attribute as it contains non-picklable canvas references\n        state['_draggable'] = None\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore state and reset _draggable to None after unpickling.\"\"\"\n        self.__dict__.update(state)\n        self._draggable = None\n",
      "\n        self._draggable = None\n        self.set_draggable(state=draggable)\n\n    def __getstate__(self):\n        state = self.__dict__.copy()\n        # Remove the unpicklable _draggable attribute\n        state['_draggable'] = None\n        return state\n\n    def __setstate__(self, state):\n        self.__dict__.update(state)\n        # Ensure _draggable is None after unpickling\n        self._draggable = None\n",
      "\n        self._draggable = None\n        self.set_draggable(state=draggable)\n    \n    def __getstate__(self):\n        # Get the default state\n        state = self.__dict__.copy()\n        # Remove the non-picklable _draggable attribute\n        state['_draggable'] = None\n        return state\n    \n    def __setstate__(self, state):\n        # Restore the state\n        self.__dict__.update(state)\n        # Ensure _draggable is None after unpickling\n        self._draggable = None\n",
      "\n        self._draggable = None\n        self.set_draggable(state=draggable)\n\n    def __getstate__(self):\n        state = self.__dict__.copy()\n        # Remove the unpicklable _draggable attribute\n        state['_draggable'] = None\n        return state\n\n    def __setstate__(self, state):\n        self.__dict__.update(state)\n        # Ensure _draggable is None after unpickling\n        self._draggable = None\n",
      "\n        self._draggable = None\n        self.set_draggable(state=draggable)\n\n    def __getstate__(self):\n        \"\"\"Customize pickling to exclude non-picklable draggable state.\"\"\"\n        state = self.__dict__.copy()\n        # Remove the unpicklable _draggable attribute\n        state['_draggable'] = None\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Customize unpickling to restore draggable state.\"\"\"\n        self.__dict__.update(state)\n        # _draggable is already set to None from __getstate__\n",
      "\n        self._draggable = None\n        self.set_draggable(state=draggable)\n\n    def __getstate__(self):\n        \"\"\"Custom pickling to handle non-picklable draggable objects.\"\"\"\n        state = self.__dict__.copy()\n        # Remove the unpicklable _draggable attribute\n        state['_draggable'] = None\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Custom unpickling to restore state without draggable functionality.\"\"\"\n        self.__dict__.update(state)\n        # Draggable functionality will need to be re-enabled manually after unpickling\n        self._draggable = None\n"
    ],
    "Location 4 (/root/hy/projects_2/matplotlib/lib/matplotlib/legend.py lines 1196-1205)": [
      "\n    def set_draggable(self, state, use_blit=False, update='loc'):\n        \"\"\"\n        Enable or disable mouse dragging support of the legend.\n\n        Parameters\n        ----------\n        state : bool\n            Whether mouse dragging is enabled.\n        use_blit : bool, optional\n            Use blitting for faster image composition. For details see\n            :ref:`func-animation`.\n        update : {'loc', 'bbox'}, optional\n            The legend parameter to be changed when dragged:\n\n            - 'loc': update the *loc* parameter of the legend\n            - 'bbox': update the *bbox_to_anchor* parameter of the legend\n\n        Returns\n        -------\n        `.DraggableLegend` or *None*\n            If *state* is ``True`` this returns the `.DraggableLegend` helper\n            instance. Otherwise this returns *None*.\n        \"\"\"\n        if state:\n            if self._draggable is None:\n                self._draggable = DraggableLegend(self,\n                                                  use_blit,\n                                                  update=update)\n        else:\n            if self._draggable is not None:\n                self._draggable.disconnect()\n            self._draggable = None\n        return self._draggable\n",
      "\n    def set_draggable(self, state, use_blit=False, update='loc'):\n        \"\"\"\n        Enable or disable mouse dragging support of the legend.\n\n        Parameters\n        ----------\n        state : bool\n            Whether mouse dragging is enabled.\n        use_blit : bool, optional\n            Use blitting for faster image composition. For details see\n            :ref:`func-animation`.\n        update : {'loc', 'bbox'}, optional\n            The legend parameter to be changed when dragged:\n\n            - 'loc': update the *loc* parameter of the legend\n            - 'bbox': update the *bbox_to_anchor* parameter of the legend\n\n        Returns\n        -------\n        `.DraggableLegend` or *None*\n            If *state* is ``True`` this returns the `.DraggableLegend` helper\n            instance. Otherwise this returns *None*.\n        \"\"\"\n        if state:\n            if self._draggable is None:\n                self._draggable = DraggableLegend(self,\n                                                  use_blit,\n                                                  update=update)\n        else:\n            if self._draggable is not None:\n                self._draggable.disconnect()\n            self._draggable = None\n        return self._draggable\n",
      "\n        if state:\n            if self._draggable is None:\n                self._draggable = DraggableLegend(self,\n                                                  use_blit,\n                                                  update=update)\n        else:\n            if self._draggable is not None:\n                self._draggable.disconnect()\n            self._draggable = None\n        return self._draggable\n",
      "\n    def set_draggable(self, state, use_blit=False, update='loc'):\n        \"\"\"\n        Enable or disable mouse dragging support of the legend.\n\n        Parameters\n        ----------\n        state : bool\n            Whether mouse dragging is enabled.\n        use_blit : bool, optional\n            Use blitting for faster image composition. For details see\n            :ref:`func-animation`.\n        update : {'loc', 'bbox'}, optional\n            The legend parameter to be changed when dragged:\n\n            - 'loc': update the *loc* parameter of the legend\n            - 'bbox': update the *bbox_to_anchor* parameter of the legend\n\n        Returns\n        -------\n        `.DraggableLegend` or *None*\n            If *state* is ``True`` this returns the `.DraggableLegend` helper\n            instance. Otherwise this returns *None*.\n        \"\"\"\n        if state:\n            if self._draggable is None:\n                self._draggable = DraggableLegend(self,\n                                                  use_blit,\n                                                  update=update)\n        else:\n            if self._draggable is not None:\n                self._draggable.disconnect()\n            self._draggable = None\n        return self._draggable\n",
      "\n    def set_draggable(self, state, use_blit=False, update='loc'):\n        \"\"\"\n        Enable or disable mouse dragging support of the legend.\n\n        Parameters\n        ----------\n        state : bool\n            Whether mouse dragging is enabled.\n        use_blit : bool, optional\n            Use blitting for faster image composition. For details see\n            :ref:`func-animation`.\n        update : {'loc', 'bbox'}, optional\n            The legend parameter to be changed when dragged:\n\n            - 'loc': update the *loc* parameter of the legend\n            - 'bbox': update the *bbox_to_anchor* parameter of the legend\n\n        Returns\n        -------\n        `.DraggableLegend` or *None*\n            If *state* is ``True`` this returns the `.DraggableLegend` helper\n            instance. Otherwise this returns *None*.\n        \"\"\"\n        if state:\n            if self._draggable is None:\n                self._draggable = DraggableLegend(self,\n                                                  use_blit,\n                                                  update=update)\n        else:\n            if self._draggable is not None:\n                self._draggable.disconnect()\n            self._draggable = None\n        return self._draggable\n",
      "\n    def set_draggable(self, state, use_blit=False, update='loc'):\n        \"\"\"\n        Enable or disable mouse dragging support of the legend.\n\n        Parameters\n        ----------\n        state : bool\n            Whether mouse dragging is enabled.\n        use_blit : bool, optional\n            Use blitting for faster image composition. For details see\n            :ref:`func-animation`.\n        update : {'loc', 'bbox'}, optional\n            The legend parameter to be changed when dragged:\n\n            - 'loc': update the *loc* parameter of the legend\n            - 'bbox': update the *bbox_to_anchor* parameter of the legend\n\n        Returns\n        -------\n        `.DraggableLegend` or *None*\n            If *state* is ``True`` this returns the `.DraggableLegend` helper\n            instance. Otherwise this returns *None*.\n        \"\"\"\n        if state:\n            if self._draggable is None:\n                self._draggable = DraggableLegend(self,\n                                                  use_blit,\n                                                  update=update)\n        else:\n            if self._draggable is not None:\n                self._draggable.disconnect()\n            self._draggable = None\n        return self._draggable\n",
      "\n    def set_draggable(self, state, use_blit=False, update='loc'):\n        \"\"\"\n        Enable or disable mouse dragging support of the legend.\n\n        Parameters\n        ----------\n        state : bool\n            Whether mouse dragging is enabled.\n        use_blit : bool, optional\n            Use blitting for faster image composition. For details see\n            :ref:`func-animation`.\n        update : {'loc', 'bbox'}, optional\n            The legend parameter to be changed when dragged:\n\n            - 'loc': update the *loc* parameter of the legend\n            - 'bbox': update the *bbox_to_anchor* parameter of the legend\n\n        Returns\n        -------\n        `.DraggableLegend` or *None*\n            If *state* is ``True`` this returns the `.DraggableLegend` helper\n            instance. Otherwise this returns *None*.\n        \"\"\"\n        if state:\n            if self._draggable is None:\n                self._draggable = DraggableLegend(self,\n                                                  use_blit,\n                                                  update=update)\n        else:\n            if self._draggable is not None:\n                self._draggable.disconnect()\n            self._draggable = None\n        return self._draggable\n\n    def __getstate__(self):\n        \"\"\"Custom pickle support that excludes non-picklable draggable state.\"\"\"\n        state = self.__dict__.copy()\n        # Remove the draggable object as it contains non-picklable canvas references\n        if '_draggable' in state and state['_draggable'] is not None:\n            state['_draggable'] = None\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Custom unpickle support that properly restores the legend state.\"\"\"\n        self.__dict__.update(state)\n        # Ensure _draggable is properly initialized as None after unpickling\n        self._draggable = None\n",
      "\n    def set_draggable(self, state, use_blit=False, update='loc'):\n        \"\"\"\n        Enable or disable mouse dragging support of the legend.\n\n        Parameters\n        ----------\n        state : bool\n            Whether mouse dragging is enabled.\n        use_blit : bool, optional\n            Use blitting for faster image composition. For details see\n            :ref:`func-animation`.\n        update : {'loc', 'bbox'}, optional\n            The legend parameter to be changed when dragged:\n\n            - 'loc': update the *loc* parameter of the legend\n            - 'bbox': update the *bbox_to_anchor* parameter of the legend\n\n        Returns\n        -------\n        `.DraggableLegend` or *None*\n            If *state* is ``True`` this returns the `.DraggableLegend` helper\n            instance. Otherwise this returns *None*.\n        \"\"\"\n        if state:\n            if self._draggable is None:\n                self._draggable = DraggableLegend(self,\n                                                  use_blit,\n                                                  update=update)\n        else:\n            if self._draggable is not None:\n                self._draggable.disconnect()\n            self._draggable = None\n        return self._draggable\n"
    ],
    "Location 5 (/root/hy/projects_2/matplotlib/lib/matplotlib/legend.py lines 53-95)": [
      "\nclass DraggableLegend(DraggableOffsetBox):\n    def __init__(self, legend, use_blit=False, update=\"loc\"):\n        \"\"\"\n        Wrapper around a `.Legend` to support mouse dragging.\n\n        Parameters\n        ----------\n        legend : `.Legend`\n            The `.Legend` instance to wrap.\n        use_blit : bool, optional\n            Use blitting for faster image composition. For details see\n            :ref:`func-animation`.\n        update : {'loc', 'bbox'}, optional\n            If \"loc\", update the *loc* parameter of the legend upon finalizing.\n            If \"bbox\", update the *bbox_to_anchor* parameter.\n        \"\"\"\n        self.legend = legend\n\n        _api.check_in_list([\"loc\", \"bbox\"], update=update)\n        self._update = update\n\n        super().__init__(legend, legend._legend_box, use_blit=use_blit)\n\n    def finalize_offset(self):\n        if self._update == \"loc\":\n            self._update_loc(self.get_loc_in_canvas())\n        elif self._update == \"bbox\":\n            self._bbox_to_anchor(self.get_loc_in_canvas())\n\n    def _update_loc(self, loc_in_canvas):\n        bbox = self.legend.get_bbox_to_anchor()\n        # if bbox has zero width or height, the transformation is\n        # ill-defined. Fall back to the default bbox_to_anchor.\n        if bbox.width == 0 or bbox.height == 0:\n            self.legend.set_bbox_to_anchor(None)\n            bbox = self.legend.get_bbox_to_anchor()\n        _bbox_transform = BboxTransformFrom(bbox)\n        self.legend._loc = tuple(_bbox_transform.transform(loc_in_canvas))\n\n    def _update_bbox_to_anchor(self, loc_in_canvas):\n        loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n        self.legend.set_bbox_to_anchor(loc_in_bbox)\n\n    def __getstate__(self):\n        state = self.__dict__.copy()\n        # Remove non-picklable attributes if they exist\n        state.pop('canvas', None)\n        state.pop('cids', None) \n        state.pop('_c1', None)\n        state.pop('background', None)\n        return state\n\n    def __setstate__(self, state):\n        self.__dict__.update(state)\n        # Initialize non-picklable attributes to None\n        self.canvas = None\n        self.cids = []\n        self._c1 = None\n        self.background = None\n",
      "\nclass DraggableLegend(DraggableOffsetBox):\n    def __init__(self, legend, use_blit=False, update=\"loc\"):\n        \"\"\"\n        Wrapper around a `.Legend` to support mouse dragging.\n\n        Parameters\n        ----------\n        legend : `.Legend`\n            The `.Legend` instance to wrap.\n        use_blit : bool, optional\n            Use blitting for faster image composition. For details see\n            :ref:`func-animation`.\n        update : {'loc', 'bbox'}, optional\n            If \"loc\", update the *loc* parameter of the legend upon finalizing.\n            If \"bbox\", update the *bbox_to_anchor* parameter.\n        \"\"\"\n        self.legend = legend\n\n        _api.check_in_list([\"loc\", \"bbox\"], update=update)\n        self._update = update\n\n        super().__init__(legend, legend._legend_box, use_blit=use_blit)\n\n    def finalize_offset(self):\n        if self._update == \"loc\":\n            self._update_loc(self.get_loc_in_canvas())\n        elif self._update == \"bbox\":\n            self._bbox_to_anchor(self.get_loc_in_canvas())\n\n    def _update_loc(self, loc_in_canvas):\n        bbox = self.legend.get_bbox_to_anchor()\n        # if bbox has zero width or height, the transformation is\n        # ill-defined. Fall back to the default bbox_to_anchor.\n        if bbox.width == 0 or bbox.height == 0:\n            self.legend.set_bbox_to_anchor(None)\n            bbox = self.legend.get_bbox_to_anchor()\n        _bbox_transform = BboxTransformFrom(bbox)\n        self.legend._loc = tuple(_bbox_transform.transform(loc_in_canvas))\n\n    def _update_bbox_to_anchor(self, loc_in_canvas):\n        loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n        self.legend.set_bbox_to_anchor(loc_in_bbox)\n\n    def __getstate__(self):\n        state = self.__dict__.copy()\n        # Remove non-picklable attributes that will be handled by parent class\n        return state\n\n    def __setstate__(self, state):\n        self.__dict__.update(state)\n",
      "\nclass DraggableLegend(DraggableOffsetBox):\n    def __init__(self, legend, use_blit=False, update=\"loc\"):\n        \"\"\"\n        Wrapper around a `.Legend` to support mouse dragging.\n\n        Parameters\n        ----------\n        legend : `.Legend`\n            The `.Legend` instance to wrap.\n        use_blit : bool, optional\n            Use blitting for faster image composition. For details see\n            :ref:`func-animation`.\n        update : {'loc', 'bbox'}, optional\n            If \"loc\", update the *loc* parameter of the legend upon finalizing.\n            If \"bbox\", update the *bbox_to_anchor* parameter.\n        \"\"\"\n        self.legend = legend\n\n        _api.check_in_list([\"loc\", \"bbox\"], update=update)\n        self._update = update\n\n        super().__init__(legend, legend._legend_box, use_blit=use_blit)\n\n    def finalize_offset(self):\n        if self._update == \"loc\":\n            self._update_loc(self.get_loc_in_canvas())\n        elif self._update == \"bbox\":\n            self._update_bbox_to_anchor(self.get_loc_in_canvas())\n\n    def _update_loc(self, loc_in_canvas):\n        bbox = self.legend.get_bbox_to_anchor()\n        # if bbox has zero width or height, the transformation is\n        # ill-defined. Fall back to the default bbox_to_anchor.\n        if bbox.width == 0 or bbox.height == 0:\n            self.legend.set_bbox_to_anchor(None)\n            bbox = self.legend.get_bbox_to_anchor()\n        _bbox_transform = BboxTransformFrom(bbox)\n        self.legend._loc = tuple(_bbox_transform.transform(loc_in_canvas))\n\n    def _update_bbox_to_anchor(self, loc_in_canvas):\n        loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n        self.legend.set_bbox_to_anchor(loc_in_bbox)\n\n    def __getstate__(self):\n        state = super().__getstate__()\n        # Store the update mode and legend reference\n        state['_update'] = self._update\n        state['legend'] = self.legend\n        return state\n\n    def __setstate__(self, state):\n        # Restore the legend and update mode first\n        self.legend = state.pop('legend')\n        self._update = state.pop('_update')\n        # Let the parent class handle the rest\n        super().__setstate__(state)\n",
      "\nclass DraggableLegend(DraggableOffsetBox):\n    def __init__(self, legend, use_blit=False, update=\"loc\"):\n        \"\"\"\n        Wrapper around a `.Legend` to support mouse dragging.\n\n        Parameters\n        ----------\n        legend : `.Legend`\n            The `.Legend` instance to wrap.\n        use_blit : bool, optional\n            Use blitting for faster image composition. For details see\n            :ref:`func-animation`.\n        update : {'loc', 'bbox'}, optional\n            If \"loc\", update the *loc* parameter of the legend upon finalizing.\n            If \"bbox\", update the *bbox_to_anchor* parameter.\n        \"\"\"\n        self.legend = legend\n\n        _api.check_in_list([\"loc\", \"bbox\"], update=update)\n        self._update = update\n\n        super().__init__(legend, legend._legend_box, use_blit=use_blit)\n\n    def finalize_offset(self):\n        if self._update == \"loc\":\n            self._update_loc(self.get_loc_in_canvas())\n        elif self._update == \"bbox\":\n            self._update_bbox_to_anchor(self.get_loc_in_canvas())\n\n    def _update_loc(self, loc_in_canvas):\n        bbox = self.legend.get_bbox_to_anchor()\n        # if bbox has zero width or height, the transformation is\n        # ill-defined. Fall back to the default bbox_to_anchor.\n        if bbox.width == 0 or bbox.height == 0:\n            self.legend.set_bbox_to_anchor(None)\n            bbox = self.legend.get_bbox_to_anchor()\n        _bbox_transform = BboxTransformFrom(bbox)\n        self.legend._loc = tuple(_bbox_transform.transform(loc_in_canvas))\n\n    def _update_bbox_to_anchor(self, loc_in_canvas):\n        loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n        self.legend.set_bbox_to_anchor(loc_in_bbox)\n\n    def __getstate__(self):\n        # Get the state from the parent class, which handles the non-picklable attributes\n        state = super().__getstate__()\n        # Add our own attributes\n        state.update({\n            'legend': self.legend,\n            '_update': self._update\n        })\n        return state\n\n    def __setstate__(self, state):\n        # Restore our attributes\n        self.legend = state['legend']\n        self._update = state['_update']\n        # Let the parent class handle its state restoration\n        super().__setstate__(state)\n",
      "\nclass DraggableLegend(DraggableOffsetBox):\n    def __init__(self, legend, use_blit=False, update=\"loc\"):\n        \"\"\"\n        Wrapper around a `.Legend` to support mouse dragging.\n\n        Parameters\n        ----------\n        legend : `.Legend`\n            The `.Legend` instance to wrap.\n        use_blit : bool, optional\n            Use blitting for faster image composition. For details see\n            :ref:`func-animation`.\n        update : {'loc', 'bbox'}, optional\n            If \"loc\", update the *loc* parameter of the legend upon finalizing.\n            If \"bbox\", update the *bbox_to_anchor* parameter.\n        \"\"\"\n        self.legend = legend\n\n        _api.check_in_list([\"loc\", \"bbox\"], update=update)\n        self._update = update\n\n        super().__init__(legend, legend._legend_box, use_blit=use_blit)\n\n    def finalize_offset(self):\n        if self._update == \"loc\":\n            self._update_loc(self.get_loc_in_canvas())\n        elif self._update == \"bbox\":\n            self._update_bbox_to_anchor(self.get_loc_in_canvas())\n\n    def _update_loc(self, loc_in_canvas):\n        bbox = self.legend.get_bbox_to_anchor()\n        # if bbox has zero width or height, the transformation is\n        # ill-defined. Fall back to the default bbox_to_anchor.\n        if bbox.width == 0 or bbox.height == 0:\n            self.legend.set_bbox_to_anchor(None)\n            bbox = self.legend.get_bbox_to_anchor()\n        _bbox_transform = BboxTransformFrom(bbox)\n        self.legend._loc = tuple(_bbox_transform.transform(loc_in_canvas))\n\n    def _update_bbox_to_anchor(self, loc_in_canvas):\n        loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n        self.legend.set_bbox_to_anchor(loc_in_bbox)\n\n    def __getstate__(self):\n        state = self.__dict__.copy()\n        # Remove non-picklable attributes that will be handled by DraggableBase\n        return state\n\n    def __setstate__(self, state):\n        self.__dict__.update(state)\n        # The DraggableBase.__setstate__ will handle canvas and callback restoration\n",
      "\nclass DraggableLegend(DraggableOffsetBox):\n    def __init__(self, legend, use_blit=False, update=\"loc\"):\n        \"\"\"\n        Wrapper around a `.Legend` to support mouse dragging.\n\n        Parameters\n        ----------\n        legend : `.Legend`\n            The `.Legend` instance to wrap.\n        use_blit : bool, optional\n            Use blitting for faster image composition. For details see\n            :ref:`func-animation`.\n        update : {'loc', 'bbox'}, optional\n            If \"loc\", update the *loc* parameter of the legend upon finalizing.\n            If \"bbox\", update the *bbox_to_anchor* parameter.\n        \"\"\"\n        self.legend = legend\n\n        _api.check_in_list([\"loc\", \"bbox\"], update=update)\n        self._update = update\n\n        super().__init__(legend, legend._legend_box, use_blit=use_blit)\n\n    def finalize_offset(self):\n        if self._update == \"loc\":\n            self._update_loc(self.get_loc_in_canvas())\n        elif self._update == \"bbox\":\n            self._update_bbox_to_anchor(self.get_loc_in_canvas())\n\n    def _update_loc(self, loc_in_canvas):\n        bbox = self.legend.get_bbox_to_anchor()\n        # if bbox has zero width or height, the transformation is\n        # ill-defined. Fall back to the default bbox_to_anchor.\n        if bbox.width == 0 or bbox.height == 0:\n            self.legend.set_bbox_to_anchor(None)\n            bbox = self.legend.get_bbox_to_anchor()\n        _bbox_transform = BboxTransformFrom(bbox)\n        self.legend._loc = tuple(_bbox_transform.transform(loc_in_canvas))\n\n    def _update_bbox_to_anchor(self, loc_in_canvas):\n        loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n        self.legend.set_bbox_to_anchor(loc_in_bbox)\n\n    def __getstate__(self):\n        state = self.__dict__.copy()\n        # Remove or reset non-picklable attributes\n        state['canvas'] = None\n        state['cids'] = []\n        state['_c1'] = None\n        state['background'] = None\n        return state\n\n    def __setstate__(self, state):\n        self.__dict__.update(state)\n        # Initialize non-picklable attributes to safe defaults\n        self.canvas = None\n        self.cids = []\n        self._c1 = None\n        self.background = None\n",
      "\nclass DraggableLegend(DraggableOffsetBox):\n    def __init__(self, legend, use_blit=False, update=\"loc\"):\n        \"\"\"\n        Wrapper around a `.Legend` to support mouse dragging.\n\n        Parameters\n        ----------\n        legend : `.Legend`\n            The `.Legend` instance to wrap.\n        use_blit : bool, optional\n            Use blitting for faster image composition. For details see\n            :ref:`func-animation`.\n        update : {'loc', 'bbox'}, optional\n            If \"loc\", update the *loc* parameter of the legend upon finalizing.\n            If \"bbox\", update the *bbox_to_anchor* parameter.\n        \"\"\"\n        self.legend = legend\n\n        _api.check_in_list([\"loc\", \"bbox\"], update=update)\n        self._update = update\n\n        super().__init__(legend, legend._legend_box, use_blit=use_blit)\n\n    def finalize_offset(self):\n        if self._update == \"loc\":\n            self._update_loc(self.get_loc_in_canvas())\n        elif self._update == \"bbox\":\n            self._update_bbox_to_anchor(self.get_loc_in_canvas())\n\n    def _update_loc(self, loc_in_canvas):\n        bbox = self.legend.get_bbox_to_anchor()\n        # if bbox has zero width or height, the transformation is\n        # ill-defined. Fall back to the default bbox_to_anchor.\n        if bbox.width == 0 or bbox.height == 0:\n            self.legend.set_bbox_to_anchor(None)\n            bbox = self.legend.get_bbox_to_anchor()\n        _bbox_transform = BboxTransformFrom(bbox)\n        self.legend._loc = tuple(_bbox_transform.transform(loc_in_canvas))\n\n    def _update_bbox_to_anchor(self, loc_in_canvas):\n        loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n        self.legend.set_bbox_to_anchor(loc_in_bbox)\n\n    def __getstate__(self):\n        state = self.__dict__.copy()\n        # Remove non-picklable attributes (handled by parent class)\n        return state\n\n    def __setstate__(self, state):\n        self.__dict__.update(state)\n        # The DraggableBase parent class will handle restoration of canvas connections\n",
      "\nclass DraggableLegend(DraggableOffsetBox):\n    def __init__(self, legend, use_blit=False, update=\"loc\"):\n        \"\"\"\n        Wrapper around a `.Legend` to support mouse dragging.\n\n        Parameters\n        ----------\n        legend : `.Legend`\n            The `.Legend` instance to wrap.\n        use_blit : bool, optional\n            Use blitting for faster image composition. For details see\n            :ref:`func-animation`.\n        update : {'loc', 'bbox'}, optional\n            If \"loc\", update the *loc* parameter of the legend upon finalizing.\n            If \"bbox\", update the *bbox_to_anchor* parameter.\n        \"\"\"\n        self.legend = legend\n\n        _api.check_in_list([\"loc\", \"bbox\"], update=update)\n        self._update = update\n\n        super().__init__(legend, legend._legend_box, use_blit=use_blit)\n\n    def finalize_offset(self):\n        if self._update == \"loc\":\n            self._update_loc(self.get_loc_in_canvas())\n        elif self._update == \"bbox\":\n            self._update_bbox_to_anchor(self.get_loc_in_canvas())\n\n    def _update_loc(self, loc_in_canvas):\n        bbox = self.legend.get_bbox_to_anchor()\n        # if bbox has zero width or height, the transformation is\n        # ill-defined. Fall back to the default bbox_to_anchor.\n        if bbox.width == 0 or bbox.height == 0:\n            self.legend.set_bbox_to_anchor(None)\n            bbox = self.legend.get_bbox_to_anchor()\n        _bbox_transform = BboxTransformFrom(bbox)\n        self.legend._loc = tuple(_bbox_transform.transform(loc_in_canvas))\n\n    def _update_bbox_to_anchor(self, loc_in_canvas):\n        loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n        self.legend.set_bbox_to_anchor(loc_in_bbox)\n\n    def __getstate__(self):\n        # Get the state from parent class which handles the non-picklable canvas\n        state = super().__getstate__()\n        # Add our own attributes\n        state['legend'] = self.legend\n        state['_update'] = self._update\n        return state\n\n    def __setstate__(self, state):\n        # Restore our attributes\n        self.legend = state['legend']\n        self._update = state['_update']\n        # Let parent class handle its state restoration\n        super().__setstate__(state)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/lib/matplotlib/legend.py b/lib/matplotlib/legend.py\nindex ff6abdb958..104fa11cbe 100644\n--- a/lib/matplotlib/legend.py\n+++ b/lib/matplotlib/legend.py\n@@ -50,6 +50,7 @@ from matplotlib.container import ErrorbarContainer, BarContainer, StemContainer\n from . import legend_handler\n \n \n+\n class DraggableLegend(DraggableOffsetBox):\n     def __init__(self, legend, use_blit=False, update=\"loc\"):\n         \"\"\"\n@@ -93,7 +94,6 @@ class DraggableLegend(DraggableOffsetBox):\n         loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n         self.legend.set_bbox_to_anchor(loc_in_bbox)\n \n-\n _legend_kw_doc_base = \"\"\"\n bbox_to_anchor : `.BboxBase`, 2-tuple, or 4-tuple of floats\n     Box that is used to position the legend in conjunction with *loc*.\n@@ -611,6 +611,7 @@ class Legend(Artist):\n \n         self.set_title(title, prop=title_prop_fp)\n \n+\n         self._draggable = None\n         self.set_draggable(state=draggable)\n \n@@ -1193,6 +1194,7 @@ class Legend(Artist):\n             If *state* is ``True`` this returns the `.DraggableLegend` helper\n             instance. Otherwise this returns *None*.\n         \"\"\"\n+\n         if state:\n             if self._draggable is None:\n                 self._draggable = DraggableLegend(self,\ndiff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 1dee8a23d9..a48963dbc7 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1500,6 +1500,7 @@ class DraggableBase:\n     coordinate and set a relevant attribute.\n     \"\"\"\n \n+\n     def __init__(self, ref_artist, use_blit=False):\n         self.ref_artist = ref_artist\n         if not ref_artist.pickable():\n@@ -1567,10 +1568,31 @@ class DraggableBase:\n         try:\n             c1 = self._c1\n         except AttributeError:\n+\n             pass\n         else:\n             self.canvas.mpl_disconnect(c1)\n \n+    def __getstate__(self):\n+        \"\"\"Return state for pickling, excluding non-picklable canvas references.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove non-picklable attributes\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore state from pickling.\"\"\"\n+        self.__dict__.update(state)\n+        # Set non-picklable attributes to None - they will be re-initialized if needed\n+        self.canvas = None\n+        self.cids = []\n+        if hasattr(self, '_c1'):\n+            self._c1 = None\n+        if hasattr(self, 'background'):\n+            self.background = None\n     def save_offset(self):\n         pass\n \n",
    "variant_0": "diff --git a/lib/matplotlib/legend.py b/lib/matplotlib/legend.py\nindex ff6abdb958..3afeb0c1ae 100644\n--- a/lib/matplotlib/legend.py\n+++ b/lib/matplotlib/legend.py\n@@ -50,6 +50,7 @@ from matplotlib.container import ErrorbarContainer, BarContainer, StemContainer\n from . import legend_handler\n \n \n+\n class DraggableLegend(DraggableOffsetBox):\n     def __init__(self, legend, use_blit=False, update=\"loc\"):\n         \"\"\"\n@@ -93,6 +94,14 @@ class DraggableLegend(DraggableOffsetBox):\n         loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n         self.legend.set_bbox_to_anchor(loc_in_bbox)\n \n+    def __getstate__(self):\n+        state = self.__dict__.copy()\n+        # Remove non-picklable attributes that are handled by parent class\n+        return state\n+\n+    def __setstate__(self, state):\n+        self.__dict__.update(state)\n+        # The parent class DraggableBase will handle restoration of canvas-related attributes\n \n _legend_kw_doc_base = \"\"\"\n bbox_to_anchor : `.BboxBase`, 2-tuple, or 4-tuple of floats\n@@ -611,9 +620,23 @@ class Legend(Artist):\n \n         self.set_title(title, prop=title_prop_fp)\n \n+\n         self._draggable = None\n         self.set_draggable(state=draggable)\n \n+    def __getstate__(self):\n+        \"\"\"Custom pickling to handle non-picklable draggable objects.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove the unpicklable draggable object\n+        state['_draggable'] = None\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Custom unpickling to restore legend state.\"\"\"\n+        self.__dict__.update(state)\n+        # Draggable functionality will need to be re-enabled manually if needed\n+        self._draggable = None\n+\n         # set the text color\n \n         color_getters = {  # getter function depends on line or patch\n@@ -1193,6 +1216,7 @@ class Legend(Artist):\n             If *state* is ``True`` this returns the `.DraggableLegend` helper\n             instance. Otherwise this returns *None*.\n         \"\"\"\n+\n         if state:\n             if self._draggable is None:\n                 self._draggable = DraggableLegend(self,\ndiff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 1dee8a23d9..45321157d2 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1500,6 +1500,7 @@ class DraggableBase:\n     coordinate and set a relevant attribute.\n     \"\"\"\n \n+\n     def __init__(self, ref_artist, use_blit=False):\n         self.ref_artist = ref_artist\n         if not ref_artist.pickable():\n@@ -1514,6 +1515,25 @@ class DraggableBase:\n                 'button_release_event', self.on_release),\n         ]\n \n+    def __getstate__(self):\n+        # Exclude non-picklable attributes during serialization\n+        state = self.__dict__.copy()\n+        # Remove non-picklable canvas and callback references\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        # Restore the object state\n+        self.__dict__.update(state)\n+        # Set non-picklable attributes to None - they will be re-initialized if needed\n+        self.canvas = None\n+        self.cids = []\n+        self._c1 = None\n+        self.background = None\n+\n     def on_motion(self, evt):\n         if self._check_still_parented() and self.got_artist:\n             dx = evt.x - self.mouse_x\n@@ -1560,6 +1580,14 @@ class DraggableBase:\n         else:\n             return True\n \n+    def disconnect(self):\n+        \"\"\"Disconnect the callbacks.\"\"\"\n+        for cid in self.cids:\n+            self.canvas.mpl_disconnect(cid)\n+        try:\n+            c1 = self._c1\n+        except AttributeError:\n+\n     def disconnect(self):\n         \"\"\"Disconnect the callbacks.\"\"\"\n         for cid in self.cids:\n@@ -1571,6 +1599,23 @@ class DraggableBase:\n         else:\n             self.canvas.mpl_disconnect(c1)\n \n+    def __getstate__(self):\n+        \"\"\"Prepare object for pickling by excluding non-picklable attributes.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove non-picklable attributes\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object from pickled state.\"\"\"\n+        self.__dict__.update(state)\n+        # Set non-picklable attributes to None/empty defaults\n+        self.canvas = None\n+        self.cids = []\n+        # Don't set _c1 or background as they may not exist\n     def save_offset(self):\n         pass\n \n",
    "variant_1": "diff --git a/lib/matplotlib/legend.py b/lib/matplotlib/legend.py\nindex ff6abdb958..98b9ee3ed3 100644\n--- a/lib/matplotlib/legend.py\n+++ b/lib/matplotlib/legend.py\n@@ -50,6 +50,7 @@ from matplotlib.container import ErrorbarContainer, BarContainer, StemContainer\n from . import legend_handler\n \n \n+\n class DraggableLegend(DraggableOffsetBox):\n     def __init__(self, legend, use_blit=False, update=\"loc\"):\n         \"\"\"\n@@ -93,6 +94,22 @@ class DraggableLegend(DraggableOffsetBox):\n         loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n         self.legend.set_bbox_to_anchor(loc_in_bbox)\n \n+    def __getstate__(self):\n+        state = self.__dict__.copy()\n+        # Remove non-picklable attributes if they exist\n+        state.pop('canvas', None)\n+        state.pop('cids', None) \n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        self.__dict__.update(state)\n+        # Initialize non-picklable attributes to None\n+        self.canvas = None\n+        self.cids = []\n+        self._c1 = None\n+        self.background = None\n \n _legend_kw_doc_base = \"\"\"\n bbox_to_anchor : `.BboxBase`, 2-tuple, or 4-tuple of floats\n@@ -611,9 +628,22 @@ class Legend(Artist):\n \n         self.set_title(title, prop=title_prop_fp)\n \n+\n         self._draggable = None\n         self.set_draggable(state=draggable)\n \n+    def __getstate__(self):\n+        \"\"\"Support pickling by excluding non-picklable draggable state.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove the draggable instance as it contains non-picklable canvas reference\n+        state['_draggable'] = None\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore state after unpickling.\"\"\"\n+        self.__dict__.update(state)\n+        # _draggable is already None from __getstate__, no additional setup needed\n+\n         # set the text color\n \n         color_getters = {  # getter function depends on line or patch\n@@ -1170,6 +1200,30 @@ class Legend(Artist):\n             return inside, info\n         return self.legendPatch.contains(event)\n \n+    def set_draggable(self, state, use_blit=False, update='loc'):\n+        \"\"\"\n+        Enable or disable mouse dragging support of the legend.\n+\n+        Parameters\n+        ----------\n+        state : bool\n+            Whether mouse dragging is enabled.\n+        use_blit : bool, optional\n+            Use blitting for faster image composition. For details see\n+            :ref:`func-animation`.\n+        update : {'loc', 'bbox'}, optional\n+            The legend parameter to be changed when dragged:\n+\n+            - 'loc': update the *loc* parameter of the legend\n+            - 'bbox': update the *bbox_to_anchor* parameter of the legend\n+\n+        Returns\n+        -------\n+        `.DraggableLegend` or *None*\n+            If *state* is ``True`` this returns the `.DraggableLegend` helper\n+            instance. Otherwise this returns *None*.\n+        \"\"\"\n+\n     def set_draggable(self, state, use_blit=False, update='loc'):\n         \"\"\"\n         Enable or disable mouse dragging support of the legend.\ndiff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 1dee8a23d9..7b3005dcf8 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1500,6 +1500,7 @@ class DraggableBase:\n     coordinate and set a relevant attribute.\n     \"\"\"\n \n+\n     def __init__(self, ref_artist, use_blit=False):\n         self.ref_artist = ref_artist\n         if not ref_artist.pickable():\n@@ -1514,6 +1515,25 @@ class DraggableBase:\n                 'button_release_event', self.on_release),\n         ]\n \n+    def __getstate__(self):\n+        \"\"\"Return state for pickling, excluding non-picklable canvas references.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove non-picklable attributes\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore state from pickling.\"\"\"\n+        self.__dict__.update(state)\n+        # Set excluded attributes to None - they will be reinitialized if dragging is re-enabled\n+        self.canvas = None\n+        self.cids = []\n+        self._c1 = None\n+        self.background = None\n+\n     def on_motion(self, evt):\n         if self._check_still_parented() and self.got_artist:\n             dx = evt.x - self.mouse_x\n@@ -1560,6 +1580,14 @@ class DraggableBase:\n         else:\n             return True\n \n+    def disconnect(self):\n+        \"\"\"Disconnect the callbacks.\"\"\"\n+        for cid in self.cids:\n+            self.canvas.mpl_disconnect(cid)\n+        try:\n+            c1 = self._c1\n+        except AttributeError:\n+\n     def disconnect(self):\n         \"\"\"Disconnect the callbacks.\"\"\"\n         for cid in self.cids:\n@@ -1571,6 +1599,23 @@ class DraggableBase:\n         else:\n             self.canvas.mpl_disconnect(c1)\n \n+    def __getstate__(self):\n+        \"\"\"Return state for pickling, excluding non-picklable attributes.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove non-picklable attributes\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore state from pickling.\"\"\"\n+        self.__dict__.update(state)\n+        # Set non-picklable attributes to None/default values\n+        self.canvas = None\n+        self.cids = []\n+        self.background = None\n     def save_offset(self):\n         pass\n \n",
    "variant_2": "diff --git a/lib/matplotlib/legend.py b/lib/matplotlib/legend.py\nindex ff6abdb958..0a5401f10a 100644\n--- a/lib/matplotlib/legend.py\n+++ b/lib/matplotlib/legend.py\n@@ -50,6 +50,7 @@ from matplotlib.container import ErrorbarContainer, BarContainer, StemContainer\n from . import legend_handler\n \n \n+\n class DraggableLegend(DraggableOffsetBox):\n     def __init__(self, legend, use_blit=False, update=\"loc\"):\n         \"\"\"\n@@ -93,6 +94,13 @@ class DraggableLegend(DraggableOffsetBox):\n         loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n         self.legend.set_bbox_to_anchor(loc_in_bbox)\n \n+    def __getstate__(self):\n+        state = self.__dict__.copy()\n+        # Remove non-picklable attributes that will be handled by parent class\n+        return state\n+\n+    def __setstate__(self, state):\n+        self.__dict__.update(state)\n \n _legend_kw_doc_base = \"\"\"\n bbox_to_anchor : `.BboxBase`, 2-tuple, or 4-tuple of floats\n@@ -611,9 +619,23 @@ class Legend(Artist):\n \n         self.set_title(title, prop=title_prop_fp)\n \n+\n         self._draggable = None\n         self.set_draggable(state=draggable)\n \n+    def __getstate__(self):\n+        # Get the default state\n+        state = self.__dict__.copy()\n+        # Remove the unpicklable _draggable attribute\n+        state['_draggable'] = None\n+        return state\n+\n+    def __setstate__(self, state):\n+        # Restore the state\n+        self.__dict__.update(state)\n+        # Initialize _draggable to None - it can be re-enabled via set_draggable() if needed\n+        self._draggable = None\n+\n         # set the text color\n \n         color_getters = {  # getter function depends on line or patch\n@@ -1170,6 +1192,30 @@ class Legend(Artist):\n             return inside, info\n         return self.legendPatch.contains(event)\n \n+    def set_draggable(self, state, use_blit=False, update='loc'):\n+        \"\"\"\n+        Enable or disable mouse dragging support of the legend.\n+\n+        Parameters\n+        ----------\n+        state : bool\n+            Whether mouse dragging is enabled.\n+        use_blit : bool, optional\n+            Use blitting for faster image composition. For details see\n+            :ref:`func-animation`.\n+        update : {'loc', 'bbox'}, optional\n+            The legend parameter to be changed when dragged:\n+\n+            - 'loc': update the *loc* parameter of the legend\n+            - 'bbox': update the *bbox_to_anchor* parameter of the legend\n+\n+        Returns\n+        -------\n+        `.DraggableLegend` or *None*\n+            If *state* is ``True`` this returns the `.DraggableLegend` helper\n+            instance. Otherwise this returns *None*.\n+        \"\"\"\n+\n     def set_draggable(self, state, use_blit=False, update='loc'):\n         \"\"\"\n         Enable or disable mouse dragging support of the legend.\ndiff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 1dee8a23d9..4efef0ae94 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1500,6 +1500,7 @@ class DraggableBase:\n     coordinate and set a relevant attribute.\n     \"\"\"\n \n+\n     def __init__(self, ref_artist, use_blit=False):\n         self.ref_artist = ref_artist\n         if not ref_artist.pickable():\n@@ -1514,6 +1515,23 @@ class DraggableBase:\n                 'button_release_event', self.on_release),\n         ]\n \n+    def __getstate__(self):\n+        state = self.__dict__.copy()\n+        # Remove unpicklable entries\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        self.__dict__.update(state)\n+        # Set unpicklable attributes to None - they will be reinitialized if needed\n+        self.canvas = None\n+        self.cids = []\n+        self._c1 = None\n+        self.background = None\n+\n     def on_motion(self, evt):\n         if self._check_still_parented() and self.got_artist:\n             dx = evt.x - self.mouse_x\n@@ -1560,6 +1578,14 @@ class DraggableBase:\n         else:\n             return True\n \n+    def disconnect(self):\n+        \"\"\"Disconnect the callbacks.\"\"\"\n+        for cid in self.cids:\n+            self.canvas.mpl_disconnect(cid)\n+        try:\n+            c1 = self._c1\n+        except AttributeError:\n+\n     def disconnect(self):\n         \"\"\"Disconnect the callbacks.\"\"\"\n         for cid in self.cids:\n@@ -1571,6 +1597,24 @@ class DraggableBase:\n         else:\n             self.canvas.mpl_disconnect(c1)\n \n+    def __getstate__(self):\n+        \"\"\"Support for pickle by excluding non-picklable attributes.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove non-picklable attributes\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore state from pickle, setting non-picklable attributes to None.\"\"\"\n+        self.__dict__.update(state)\n+        # Set non-picklable attributes to appropriate defaults\n+        self.canvas = None\n+        self.cids = []\n+        # Don't set _c1 since it may not exist\n+        self.background = None\n     def save_offset(self):\n         pass\n \n",
    "variant_3": "diff --git a/lib/matplotlib/legend.py b/lib/matplotlib/legend.py\nindex ff6abdb958..68dd664a67 100644\n--- a/lib/matplotlib/legend.py\n+++ b/lib/matplotlib/legend.py\n@@ -50,6 +50,7 @@ from matplotlib.container import ErrorbarContainer, BarContainer, StemContainer\n from . import legend_handler\n \n \n+\n class DraggableLegend(DraggableOffsetBox):\n     def __init__(self, legend, use_blit=False, update=\"loc\"):\n         \"\"\"\n@@ -77,7 +78,7 @@ class DraggableLegend(DraggableOffsetBox):\n         if self._update == \"loc\":\n             self._update_loc(self.get_loc_in_canvas())\n         elif self._update == \"bbox\":\n-            self._bbox_to_anchor(self.get_loc_in_canvas())\n+            self._update_bbox_to_anchor(self.get_loc_in_canvas())\n \n     def _update_loc(self, loc_in_canvas):\n         bbox = self.legend.get_bbox_to_anchor()\n@@ -93,6 +94,19 @@ class DraggableLegend(DraggableOffsetBox):\n         loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n         self.legend.set_bbox_to_anchor(loc_in_bbox)\n \n+    def __getstate__(self):\n+        state = super().__getstate__()\n+        # Store the update mode and legend reference\n+        state['_update'] = self._update\n+        state['legend'] = self.legend\n+        return state\n+\n+    def __setstate__(self, state):\n+        # Restore the legend and update mode first\n+        self.legend = state.pop('legend')\n+        self._update = state.pop('_update')\n+        # Let the parent class handle the rest\n+        super().__setstate__(state)\n \n _legend_kw_doc_base = \"\"\"\n bbox_to_anchor : `.BboxBase`, 2-tuple, or 4-tuple of floats\n@@ -611,9 +625,22 @@ class Legend(Artist):\n \n         self.set_title(title, prop=title_prop_fp)\n \n+\n         self._draggable = None\n         self.set_draggable(state=draggable)\n \n+    def __getstate__(self):\n+        \"\"\"Exclude non-picklable attributes during pickling.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove the _draggable attribute as it contains non-picklable canvas references\n+        state['_draggable'] = None\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore state and reset _draggable to None after unpickling.\"\"\"\n+        self.__dict__.update(state)\n+        self._draggable = None\n+\n         # set the text color\n \n         color_getters = {  # getter function depends on line or patch\n@@ -1193,6 +1220,7 @@ class Legend(Artist):\n             If *state* is ``True`` this returns the `.DraggableLegend` helper\n             instance. Otherwise this returns *None*.\n         \"\"\"\n+\n         if state:\n             if self._draggable is None:\n                 self._draggable = DraggableLegend(self,\ndiff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 1dee8a23d9..32777fe552 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1500,6 +1500,7 @@ class DraggableBase:\n     coordinate and set a relevant attribute.\n     \"\"\"\n \n+\n     def __init__(self, ref_artist, use_blit=False):\n         self.ref_artist = ref_artist\n         if not ref_artist.pickable():\n@@ -1514,6 +1515,25 @@ class DraggableBase:\n                 'button_release_event', self.on_release),\n         ]\n \n+    def __getstate__(self):\n+        # Exclude non-picklable attributes from the pickled state\n+        state = self.__dict__.copy()\n+        # Remove unpicklable canvas and callback references\n+        state.pop('canvas', None)\n+        state.pop('cids', None) \n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        # Restore the pickled state\n+        self.__dict__.update(state)\n+        # Set non-picklable attributes to None - they will be reinitialized if dragging is re-enabled\n+        self.canvas = None\n+        self.cids = []\n+        self._c1 = None\n+        self.background = None\n+\n     def on_motion(self, evt):\n         if self._check_still_parented() and self.got_artist:\n             dx = evt.x - self.mouse_x\n@@ -1560,6 +1580,14 @@ class DraggableBase:\n         else:\n             return True\n \n+    def disconnect(self):\n+        \"\"\"Disconnect the callbacks.\"\"\"\n+        for cid in self.cids:\n+            self.canvas.mpl_disconnect(cid)\n+        try:\n+            c1 = self._c1\n+        except AttributeError:\n+\n     def disconnect(self):\n         \"\"\"Disconnect the callbacks.\"\"\"\n         for cid in self.cids:\n@@ -1571,6 +1599,23 @@ class DraggableBase:\n         else:\n             self.canvas.mpl_disconnect(c1)\n \n+    def __getstate__(self):\n+        \"\"\"Get state for pickling, excluding non-picklable canvas references.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove non-picklable attributes\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore state from pickling.\"\"\"\n+        self.__dict__.update(state)\n+        # Set non-picklable attributes to None\n+        self.canvas = None\n+        self.cids = []\n+        self.background = None\n     def save_offset(self):\n         pass\n \n",
    "variant_4": "diff --git a/lib/matplotlib/legend.py b/lib/matplotlib/legend.py\nindex ff6abdb958..0443ea51f1 100644\n--- a/lib/matplotlib/legend.py\n+++ b/lib/matplotlib/legend.py\n@@ -50,6 +50,7 @@ from matplotlib.container import ErrorbarContainer, BarContainer, StemContainer\n from . import legend_handler\n \n \n+\n class DraggableLegend(DraggableOffsetBox):\n     def __init__(self, legend, use_blit=False, update=\"loc\"):\n         \"\"\"\n@@ -77,7 +78,7 @@ class DraggableLegend(DraggableOffsetBox):\n         if self._update == \"loc\":\n             self._update_loc(self.get_loc_in_canvas())\n         elif self._update == \"bbox\":\n-            self._bbox_to_anchor(self.get_loc_in_canvas())\n+            self._update_bbox_to_anchor(self.get_loc_in_canvas())\n \n     def _update_loc(self, loc_in_canvas):\n         bbox = self.legend.get_bbox_to_anchor()\n@@ -93,6 +94,22 @@ class DraggableLegend(DraggableOffsetBox):\n         loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n         self.legend.set_bbox_to_anchor(loc_in_bbox)\n \n+    def __getstate__(self):\n+        # Get the state from the parent class, which handles the non-picklable attributes\n+        state = super().__getstate__()\n+        # Add our own attributes\n+        state.update({\n+            'legend': self.legend,\n+            '_update': self._update\n+        })\n+        return state\n+\n+    def __setstate__(self, state):\n+        # Restore our attributes\n+        self.legend = state['legend']\n+        self._update = state['_update']\n+        # Let the parent class handle its state restoration\n+        super().__setstate__(state)\n \n _legend_kw_doc_base = \"\"\"\n bbox_to_anchor : `.BboxBase`, 2-tuple, or 4-tuple of floats\n@@ -611,9 +628,21 @@ class Legend(Artist):\n \n         self.set_title(title, prop=title_prop_fp)\n \n+\n         self._draggable = None\n         self.set_draggable(state=draggable)\n \n+    def __getstate__(self):\n+        state = self.__dict__.copy()\n+        # Remove the unpicklable _draggable attribute\n+        state['_draggable'] = None\n+        return state\n+\n+    def __setstate__(self, state):\n+        self.__dict__.update(state)\n+        # Ensure _draggable is None after unpickling\n+        self._draggable = None\n+\n         # set the text color\n \n         color_getters = {  # getter function depends on line or patch\n@@ -1170,6 +1199,30 @@ class Legend(Artist):\n             return inside, info\n         return self.legendPatch.contains(event)\n \n+    def set_draggable(self, state, use_blit=False, update='loc'):\n+        \"\"\"\n+        Enable or disable mouse dragging support of the legend.\n+\n+        Parameters\n+        ----------\n+        state : bool\n+            Whether mouse dragging is enabled.\n+        use_blit : bool, optional\n+            Use blitting for faster image composition. For details see\n+            :ref:`func-animation`.\n+        update : {'loc', 'bbox'}, optional\n+            The legend parameter to be changed when dragged:\n+\n+            - 'loc': update the *loc* parameter of the legend\n+            - 'bbox': update the *bbox_to_anchor* parameter of the legend\n+\n+        Returns\n+        -------\n+        `.DraggableLegend` or *None*\n+            If *state* is ``True`` this returns the `.DraggableLegend` helper\n+            instance. Otherwise this returns *None*.\n+        \"\"\"\n+\n     def set_draggable(self, state, use_blit=False, update='loc'):\n         \"\"\"\n         Enable or disable mouse dragging support of the legend.\ndiff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 1dee8a23d9..979e1dbddf 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1500,6 +1500,7 @@ class DraggableBase:\n     coordinate and set a relevant attribute.\n     \"\"\"\n \n+\n     def __init__(self, ref_artist, use_blit=False):\n         self.ref_artist = ref_artist\n         if not ref_artist.pickable():\n@@ -1514,6 +1515,25 @@ class DraggableBase:\n                 'button_release_event', self.on_release),\n         ]\n \n+    def __getstate__(self):\n+        # Remove non-picklable attributes for serialization\n+        state = self.__dict__.copy()\n+        # Remove canvas and callback IDs which cannot be pickled\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)  # motion event callback\n+        state.pop('background', None)  # blit background\n+        return state\n+\n+    def __setstate__(self, state):\n+        # Restore state and set non-picklable attributes to None\n+        self.__dict__.update(state)\n+        self.canvas = None\n+        self.cids = []\n+        self._c1 = None\n+        self.background = None\n+        self.got_artist = False\n+\n     def on_motion(self, evt):\n         if self._check_still_parented() and self.got_artist:\n             dx = evt.x - self.mouse_x\n@@ -1560,6 +1580,14 @@ class DraggableBase:\n         else:\n             return True\n \n+    def disconnect(self):\n+        \"\"\"Disconnect the callbacks.\"\"\"\n+        for cid in self.cids:\n+            self.canvas.mpl_disconnect(cid)\n+        try:\n+            c1 = self._c1\n+        except AttributeError:\n+\n     def disconnect(self):\n         \"\"\"Disconnect the callbacks.\"\"\"\n         for cid in self.cids:\n@@ -1571,6 +1599,23 @@ class DraggableBase:\n         else:\n             self.canvas.mpl_disconnect(c1)\n \n+    def __getstate__(self):\n+        \"\"\"Return state for pickling, excluding non-picklable canvas and callbacks.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove non-picklable attributes\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore state from pickling.\"\"\"\n+        self.__dict__.update(state)\n+        # Set non-picklable attributes to None\n+        self.canvas = None\n+        self.cids = []\n+        self.background = None\n     def save_offset(self):\n         pass\n \n",
    "variant_5": "diff --git a/lib/matplotlib/legend.py b/lib/matplotlib/legend.py\nindex ff6abdb958..f6d13ba18e 100644\n--- a/lib/matplotlib/legend.py\n+++ b/lib/matplotlib/legend.py\n@@ -50,6 +50,7 @@ from matplotlib.container import ErrorbarContainer, BarContainer, StemContainer\n from . import legend_handler\n \n \n+\n class DraggableLegend(DraggableOffsetBox):\n     def __init__(self, legend, use_blit=False, update=\"loc\"):\n         \"\"\"\n@@ -77,7 +78,7 @@ class DraggableLegend(DraggableOffsetBox):\n         if self._update == \"loc\":\n             self._update_loc(self.get_loc_in_canvas())\n         elif self._update == \"bbox\":\n-            self._bbox_to_anchor(self.get_loc_in_canvas())\n+            self._update_bbox_to_anchor(self.get_loc_in_canvas())\n \n     def _update_loc(self, loc_in_canvas):\n         bbox = self.legend.get_bbox_to_anchor()\n@@ -93,6 +94,14 @@ class DraggableLegend(DraggableOffsetBox):\n         loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n         self.legend.set_bbox_to_anchor(loc_in_bbox)\n \n+    def __getstate__(self):\n+        state = self.__dict__.copy()\n+        # Remove non-picklable attributes that will be handled by DraggableBase\n+        return state\n+\n+    def __setstate__(self, state):\n+        self.__dict__.update(state)\n+        # The DraggableBase.__setstate__ will handle canvas and callback restoration\n \n _legend_kw_doc_base = \"\"\"\n bbox_to_anchor : `.BboxBase`, 2-tuple, or 4-tuple of floats\n@@ -611,8 +620,22 @@ class Legend(Artist):\n \n         self.set_title(title, prop=title_prop_fp)\n \n+\n         self._draggable = None\n         self.set_draggable(state=draggable)\n+    \n+    def __getstate__(self):\n+        # Get the default state\n+        state = self.__dict__.copy()\n+        # Remove the non-picklable _draggable attribute\n+        state['_draggable'] = None\n+        return state\n+    \n+    def __setstate__(self, state):\n+        # Restore the state\n+        self.__dict__.update(state)\n+        # Ensure _draggable is None after unpickling\n+        self._draggable = None\n \n         # set the text color\n \n@@ -1170,6 +1193,30 @@ class Legend(Artist):\n             return inside, info\n         return self.legendPatch.contains(event)\n \n+    def set_draggable(self, state, use_blit=False, update='loc'):\n+        \"\"\"\n+        Enable or disable mouse dragging support of the legend.\n+\n+        Parameters\n+        ----------\n+        state : bool\n+            Whether mouse dragging is enabled.\n+        use_blit : bool, optional\n+            Use blitting for faster image composition. For details see\n+            :ref:`func-animation`.\n+        update : {'loc', 'bbox'}, optional\n+            The legend parameter to be changed when dragged:\n+\n+            - 'loc': update the *loc* parameter of the legend\n+            - 'bbox': update the *bbox_to_anchor* parameter of the legend\n+\n+        Returns\n+        -------\n+        `.DraggableLegend` or *None*\n+            If *state* is ``True`` this returns the `.DraggableLegend` helper\n+            instance. Otherwise this returns *None*.\n+        \"\"\"\n+\n     def set_draggable(self, state, use_blit=False, update='loc'):\n         \"\"\"\n         Enable or disable mouse dragging support of the legend.\ndiff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 1dee8a23d9..53ab611e53 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1500,6 +1500,7 @@ class DraggableBase:\n     coordinate and set a relevant attribute.\n     \"\"\"\n \n+\n     def __init__(self, ref_artist, use_blit=False):\n         self.ref_artist = ref_artist\n         if not ref_artist.pickable():\n@@ -1514,6 +1515,25 @@ class DraggableBase:\n                 'button_release_event', self.on_release),\n         ]\n \n+    def __getstate__(self):\n+        \"\"\"Return state for pickling, excluding non-picklable attributes.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove non-picklable attributes\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore state from pickling.\"\"\"\n+        self.__dict__.update(state)\n+        # Set excluded attributes to None\n+        self.canvas = None\n+        self.cids = []\n+        self._c1 = None\n+        self.background = None\n+\n     def on_motion(self, evt):\n         if self._check_still_parented() and self.got_artist:\n             dx = evt.x - self.mouse_x\n@@ -1560,6 +1580,14 @@ class DraggableBase:\n         else:\n             return True\n \n+    def disconnect(self):\n+        \"\"\"Disconnect the callbacks.\"\"\"\n+        for cid in self.cids:\n+            self.canvas.mpl_disconnect(cid)\n+        try:\n+            c1 = self._c1\n+        except AttributeError:\n+\n     def disconnect(self):\n         \"\"\"Disconnect the callbacks.\"\"\"\n         for cid in self.cids:\n@@ -1571,6 +1599,23 @@ class DraggableBase:\n         else:\n             self.canvas.mpl_disconnect(c1)\n \n+    def __getstate__(self):\n+        \"\"\"Return state for pickling, excluding non-picklable attributes.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove non-picklable attributes\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore state from pickling.\"\"\"\n+        self.__dict__.update(state)\n+        # Set non-picklable attributes to None/defaults\n+        self.canvas = None\n+        self.cids = []\n+        self.background = None\n     def save_offset(self):\n         pass\n \n",
    "variant_6": "diff --git a/lib/matplotlib/legend.py b/lib/matplotlib/legend.py\nindex ff6abdb958..a2b257115c 100644\n--- a/lib/matplotlib/legend.py\n+++ b/lib/matplotlib/legend.py\n@@ -50,6 +50,7 @@ from matplotlib.container import ErrorbarContainer, BarContainer, StemContainer\n from . import legend_handler\n \n \n+\n class DraggableLegend(DraggableOffsetBox):\n     def __init__(self, legend, use_blit=False, update=\"loc\"):\n         \"\"\"\n@@ -77,7 +78,7 @@ class DraggableLegend(DraggableOffsetBox):\n         if self._update == \"loc\":\n             self._update_loc(self.get_loc_in_canvas())\n         elif self._update == \"bbox\":\n-            self._bbox_to_anchor(self.get_loc_in_canvas())\n+            self._update_bbox_to_anchor(self.get_loc_in_canvas())\n \n     def _update_loc(self, loc_in_canvas):\n         bbox = self.legend.get_bbox_to_anchor()\n@@ -93,6 +94,22 @@ class DraggableLegend(DraggableOffsetBox):\n         loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n         self.legend.set_bbox_to_anchor(loc_in_bbox)\n \n+    def __getstate__(self):\n+        state = self.__dict__.copy()\n+        # Remove or reset non-picklable attributes\n+        state['canvas'] = None\n+        state['cids'] = []\n+        state['_c1'] = None\n+        state['background'] = None\n+        return state\n+\n+    def __setstate__(self, state):\n+        self.__dict__.update(state)\n+        # Initialize non-picklable attributes to safe defaults\n+        self.canvas = None\n+        self.cids = []\n+        self._c1 = None\n+        self.background = None\n \n _legend_kw_doc_base = \"\"\"\n bbox_to_anchor : `.BboxBase`, 2-tuple, or 4-tuple of floats\n@@ -611,9 +628,21 @@ class Legend(Artist):\n \n         self.set_title(title, prop=title_prop_fp)\n \n+\n         self._draggable = None\n         self.set_draggable(state=draggable)\n \n+    def __getstate__(self):\n+        state = self.__dict__.copy()\n+        # Remove the unpicklable _draggable attribute\n+        state['_draggable'] = None\n+        return state\n+\n+    def __setstate__(self, state):\n+        self.__dict__.update(state)\n+        # Ensure _draggable is None after unpickling\n+        self._draggable = None\n+\n         # set the text color\n \n         color_getters = {  # getter function depends on line or patch\n@@ -1170,6 +1199,30 @@ class Legend(Artist):\n             return inside, info\n         return self.legendPatch.contains(event)\n \n+    def set_draggable(self, state, use_blit=False, update='loc'):\n+        \"\"\"\n+        Enable or disable mouse dragging support of the legend.\n+\n+        Parameters\n+        ----------\n+        state : bool\n+            Whether mouse dragging is enabled.\n+        use_blit : bool, optional\n+            Use blitting for faster image composition. For details see\n+            :ref:`func-animation`.\n+        update : {'loc', 'bbox'}, optional\n+            The legend parameter to be changed when dragged:\n+\n+            - 'loc': update the *loc* parameter of the legend\n+            - 'bbox': update the *bbox_to_anchor* parameter of the legend\n+\n+        Returns\n+        -------\n+        `.DraggableLegend` or *None*\n+            If *state* is ``True`` this returns the `.DraggableLegend` helper\n+            instance. Otherwise this returns *None*.\n+        \"\"\"\n+\n     def set_draggable(self, state, use_blit=False, update='loc'):\n         \"\"\"\n         Enable or disable mouse dragging support of the legend.\ndiff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 1dee8a23d9..4422474ccf 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1500,6 +1500,7 @@ class DraggableBase:\n     coordinate and set a relevant attribute.\n     \"\"\"\n \n+\n     def __init__(self, ref_artist, use_blit=False):\n         self.ref_artist = ref_artist\n         if not ref_artist.pickable():\n@@ -1514,6 +1515,28 @@ class DraggableBase:\n                 'button_release_event', self.on_release),\n         ]\n \n+    def __getstate__(self):\n+        # Create a copy of the instance dictionary\n+        state = self.__dict__.copy()\n+        # Remove unpicklable attributes\n+        state['canvas'] = None\n+        state['cids'] = []\n+        if hasattr(self, '_c1'):\n+            state['_c1'] = None\n+        if hasattr(self, 'background'):\n+            state['background'] = None\n+        return state\n+\n+    def __setstate__(self, state):\n+        # Restore the instance dictionary\n+        self.__dict__.update(state)\n+        # Set unpicklable attributes to None - they will be reinitialized if dragging is re-enabled\n+        self.canvas = None\n+        self.cids = []\n+        self._c1 = None\n+        if hasattr(self, 'background'):\n+            self.background = None\n+\n     def on_motion(self, evt):\n         if self._check_still_parented() and self.got_artist:\n             dx = evt.x - self.mouse_x\n@@ -1560,6 +1583,14 @@ class DraggableBase:\n         else:\n             return True\n \n+    def disconnect(self):\n+        \"\"\"Disconnect the callbacks.\"\"\"\n+        for cid in self.cids:\n+            self.canvas.mpl_disconnect(cid)\n+        try:\n+            c1 = self._c1\n+        except AttributeError:\n+\n     def disconnect(self):\n         \"\"\"Disconnect the callbacks.\"\"\"\n         for cid in self.cids:\n@@ -1571,6 +1602,23 @@ class DraggableBase:\n         else:\n             self.canvas.mpl_disconnect(c1)\n \n+    def __getstate__(self):\n+        \"\"\"Custom pickle state that excludes non-picklable attributes.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove non-picklable attributes\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore state from pickle, setting excluded attributes to None.\"\"\"\n+        self.__dict__.update(state)\n+        # Set non-picklable attributes to None/defaults\n+        self.canvas = None\n+        self.cids = []\n+        self.background = None\n     def save_offset(self):\n         pass\n \n",
    "variant_7": "diff --git a/lib/matplotlib/legend.py b/lib/matplotlib/legend.py\nindex ff6abdb958..807db18029 100644\n--- a/lib/matplotlib/legend.py\n+++ b/lib/matplotlib/legend.py\n@@ -50,6 +50,7 @@ from matplotlib.container import ErrorbarContainer, BarContainer, StemContainer\n from . import legend_handler\n \n \n+\n class DraggableLegend(DraggableOffsetBox):\n     def __init__(self, legend, use_blit=False, update=\"loc\"):\n         \"\"\"\n@@ -77,7 +78,7 @@ class DraggableLegend(DraggableOffsetBox):\n         if self._update == \"loc\":\n             self._update_loc(self.get_loc_in_canvas())\n         elif self._update == \"bbox\":\n-            self._bbox_to_anchor(self.get_loc_in_canvas())\n+            self._update_bbox_to_anchor(self.get_loc_in_canvas())\n \n     def _update_loc(self, loc_in_canvas):\n         bbox = self.legend.get_bbox_to_anchor()\n@@ -93,6 +94,14 @@ class DraggableLegend(DraggableOffsetBox):\n         loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n         self.legend.set_bbox_to_anchor(loc_in_bbox)\n \n+    def __getstate__(self):\n+        state = self.__dict__.copy()\n+        # Remove non-picklable attributes (handled by parent class)\n+        return state\n+\n+    def __setstate__(self, state):\n+        self.__dict__.update(state)\n+        # The DraggableBase parent class will handle restoration of canvas connections\n \n _legend_kw_doc_base = \"\"\"\n bbox_to_anchor : `.BboxBase`, 2-tuple, or 4-tuple of floats\n@@ -611,9 +620,22 @@ class Legend(Artist):\n \n         self.set_title(title, prop=title_prop_fp)\n \n+\n         self._draggable = None\n         self.set_draggable(state=draggable)\n \n+    def __getstate__(self):\n+        \"\"\"Customize pickling to exclude non-picklable draggable state.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove the unpicklable _draggable attribute\n+        state['_draggable'] = None\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Customize unpickling to restore draggable state.\"\"\"\n+        self.__dict__.update(state)\n+        # _draggable is already set to None from __getstate__\n+\n         # set the text color\n \n         color_getters = {  # getter function depends on line or patch\n@@ -1170,6 +1192,30 @@ class Legend(Artist):\n             return inside, info\n         return self.legendPatch.contains(event)\n \n+    def set_draggable(self, state, use_blit=False, update='loc'):\n+        \"\"\"\n+        Enable or disable mouse dragging support of the legend.\n+\n+        Parameters\n+        ----------\n+        state : bool\n+            Whether mouse dragging is enabled.\n+        use_blit : bool, optional\n+            Use blitting for faster image composition. For details see\n+            :ref:`func-animation`.\n+        update : {'loc', 'bbox'}, optional\n+            The legend parameter to be changed when dragged:\n+\n+            - 'loc': update the *loc* parameter of the legend\n+            - 'bbox': update the *bbox_to_anchor* parameter of the legend\n+\n+        Returns\n+        -------\n+        `.DraggableLegend` or *None*\n+            If *state* is ``True`` this returns the `.DraggableLegend` helper\n+            instance. Otherwise this returns *None*.\n+        \"\"\"\n+\n     def set_draggable(self, state, use_blit=False, update='loc'):\n         \"\"\"\n         Enable or disable mouse dragging support of the legend.\n@@ -1204,6 +1250,20 @@ class Legend(Artist):\n             self._draggable = None\n         return self._draggable\n \n+    def __getstate__(self):\n+        \"\"\"Custom pickle support that excludes non-picklable draggable state.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove the draggable object as it contains non-picklable canvas references\n+        if '_draggable' in state and state['_draggable'] is not None:\n+            state['_draggable'] = None\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Custom unpickle support that properly restores the legend state.\"\"\"\n+        self.__dict__.update(state)\n+        # Ensure _draggable is properly initialized as None after unpickling\n+        self._draggable = None\n+\n     def get_draggable(self):\n         \"\"\"Return ``True`` if the legend is draggable, ``False`` otherwise.\"\"\"\n         return self._draggable is not None\ndiff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 1dee8a23d9..956dd5a344 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1500,6 +1500,7 @@ class DraggableBase:\n     coordinate and set a relevant attribute.\n     \"\"\"\n \n+\n     def __init__(self, ref_artist, use_blit=False):\n         self.ref_artist = ref_artist\n         if not ref_artist.pickable():\n@@ -1514,6 +1515,25 @@ class DraggableBase:\n                 'button_release_event', self.on_release),\n         ]\n \n+    def __getstate__(self):\n+        # Exclude non-picklable attributes from the pickled state\n+        state = self.__dict__.copy()\n+        # Remove unpicklable attributes\n+        state.pop('canvas', None)\n+        state.pop('cids', None) \n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        # Restore the object state\n+        self.__dict__.update(state)\n+        # Set excluded attributes to None - they will be re-initialized if dragging is re-enabled\n+        self.canvas = None\n+        self.cids = []\n+        self._c1 = None\n+        self.background = None\n+\n     def on_motion(self, evt):\n         if self._check_still_parented() and self.got_artist:\n             dx = evt.x - self.mouse_x\n@@ -1560,6 +1580,14 @@ class DraggableBase:\n         else:\n             return True\n \n+    def disconnect(self):\n+        \"\"\"Disconnect the callbacks.\"\"\"\n+        for cid in self.cids:\n+            self.canvas.mpl_disconnect(cid)\n+        try:\n+            c1 = self._c1\n+        except AttributeError:\n+\n     def disconnect(self):\n         \"\"\"Disconnect the callbacks.\"\"\"\n         for cid in self.cids:\n@@ -1571,6 +1599,23 @@ class DraggableBase:\n         else:\n             self.canvas.mpl_disconnect(c1)\n \n+    def __getstate__(self):\n+        \"\"\"Get state for pickling, excluding non-picklable attributes.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove non-picklable attributes\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore state from pickling.\"\"\"\n+        self.__dict__.update(state)\n+        # Set excluded attributes to None/empty defaults\n+        self.canvas = None\n+        self.cids = []\n+        self.background = None\n     def save_offset(self):\n         pass\n \n",
    "variant_8": "diff --git a/lib/matplotlib/legend.py b/lib/matplotlib/legend.py\nindex ff6abdb958..6e59f47ce2 100644\n--- a/lib/matplotlib/legend.py\n+++ b/lib/matplotlib/legend.py\n@@ -50,6 +50,7 @@ from matplotlib.container import ErrorbarContainer, BarContainer, StemContainer\n from . import legend_handler\n \n \n+\n class DraggableLegend(DraggableOffsetBox):\n     def __init__(self, legend, use_blit=False, update=\"loc\"):\n         \"\"\"\n@@ -77,7 +78,7 @@ class DraggableLegend(DraggableOffsetBox):\n         if self._update == \"loc\":\n             self._update_loc(self.get_loc_in_canvas())\n         elif self._update == \"bbox\":\n-            self._bbox_to_anchor(self.get_loc_in_canvas())\n+            self._update_bbox_to_anchor(self.get_loc_in_canvas())\n \n     def _update_loc(self, loc_in_canvas):\n         bbox = self.legend.get_bbox_to_anchor()\n@@ -93,6 +94,20 @@ class DraggableLegend(DraggableOffsetBox):\n         loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\n         self.legend.set_bbox_to_anchor(loc_in_bbox)\n \n+    def __getstate__(self):\n+        # Get the state from parent class which handles the non-picklable canvas\n+        state = super().__getstate__()\n+        # Add our own attributes\n+        state['legend'] = self.legend\n+        state['_update'] = self._update\n+        return state\n+\n+    def __setstate__(self, state):\n+        # Restore our attributes\n+        self.legend = state['legend']\n+        self._update = state['_update']\n+        # Let parent class handle its state restoration\n+        super().__setstate__(state)\n \n _legend_kw_doc_base = \"\"\"\n bbox_to_anchor : `.BboxBase`, 2-tuple, or 4-tuple of floats\n@@ -611,9 +626,23 @@ class Legend(Artist):\n \n         self.set_title(title, prop=title_prop_fp)\n \n+\n         self._draggable = None\n         self.set_draggable(state=draggable)\n \n+    def __getstate__(self):\n+        \"\"\"Custom pickling to handle non-picklable draggable objects.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove the unpicklable _draggable attribute\n+        state['_draggable'] = None\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Custom unpickling to restore state without draggable functionality.\"\"\"\n+        self.__dict__.update(state)\n+        # Draggable functionality will need to be re-enabled manually after unpickling\n+        self._draggable = None\n+\n         # set the text color\n \n         color_getters = {  # getter function depends on line or patch\n@@ -1170,6 +1199,30 @@ class Legend(Artist):\n             return inside, info\n         return self.legendPatch.contains(event)\n \n+    def set_draggable(self, state, use_blit=False, update='loc'):\n+        \"\"\"\n+        Enable or disable mouse dragging support of the legend.\n+\n+        Parameters\n+        ----------\n+        state : bool\n+            Whether mouse dragging is enabled.\n+        use_blit : bool, optional\n+            Use blitting for faster image composition. For details see\n+            :ref:`func-animation`.\n+        update : {'loc', 'bbox'}, optional\n+            The legend parameter to be changed when dragged:\n+\n+            - 'loc': update the *loc* parameter of the legend\n+            - 'bbox': update the *bbox_to_anchor* parameter of the legend\n+\n+        Returns\n+        -------\n+        `.DraggableLegend` or *None*\n+            If *state* is ``True`` this returns the `.DraggableLegend` helper\n+            instance. Otherwise this returns *None*.\n+        \"\"\"\n+\n     def set_draggable(self, state, use_blit=False, update='loc'):\n         \"\"\"\n         Enable or disable mouse dragging support of the legend.\ndiff --git a/lib/matplotlib/offsetbox.py b/lib/matplotlib/offsetbox.py\nindex 1dee8a23d9..e3a6690bde 100644\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -1500,6 +1500,7 @@ class DraggableBase:\n     coordinate and set a relevant attribute.\n     \"\"\"\n \n+\n     def __init__(self, ref_artist, use_blit=False):\n         self.ref_artist = ref_artist\n         if not ref_artist.pickable():\n@@ -1514,6 +1515,27 @@ class DraggableBase:\n                 'button_release_event', self.on_release),\n         ]\n \n+    def __getstate__(self):\n+        # Exclude non-picklable attributes from the state\n+        state = self.__dict__.copy()\n+        # Remove the unpicklable entries\n+        state['canvas'] = None\n+        state['cids'] = []\n+        if hasattr(self, '_c1'):\n+            state['_c1'] = None\n+        if hasattr(self, 'background'):\n+            state['background'] = None\n+        return state\n+\n+    def __setstate__(self, state):\n+        # Restore the object state\n+        self.__dict__.update(state)\n+        # Set canvas and cids to None - they will need to be re-initialized\n+        # if draggable functionality is needed again\n+        self.canvas = None\n+        self.cids = []\n+        self.got_artist = False\n+\n     def on_motion(self, evt):\n         if self._check_still_parented() and self.got_artist:\n             dx = evt.x - self.mouse_x\n@@ -1560,6 +1582,14 @@ class DraggableBase:\n         else:\n             return True\n \n+    def disconnect(self):\n+        \"\"\"Disconnect the callbacks.\"\"\"\n+        for cid in self.cids:\n+            self.canvas.mpl_disconnect(cid)\n+        try:\n+            c1 = self._c1\n+        except AttributeError:\n+\n     def disconnect(self):\n         \"\"\"Disconnect the callbacks.\"\"\"\n         for cid in self.cids:\n@@ -1571,6 +1601,23 @@ class DraggableBase:\n         else:\n             self.canvas.mpl_disconnect(c1)\n \n+    def __getstate__(self):\n+        \"\"\"Prepare object state for pickling by excluding non-picklable attributes.\"\"\"\n+        state = self.__dict__.copy()\n+        # Remove non-picklable attributes\n+        state.pop('canvas', None)\n+        state.pop('cids', None)\n+        state.pop('_c1', None)\n+        state.pop('background', None)\n+        return state\n+\n+    def __setstate__(self, state):\n+        \"\"\"Restore object state after unpickling.\"\"\"\n+        self.__dict__.update(state)\n+        # Set non-picklable attributes to None/defaults\n+        self.canvas = None\n+        self.cids = []\n+        self.background = None\n     def save_offset(self):\n         pass\n \n"
  }
}