{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/requests/requests/utils.py lines 359-374)": "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    # Use apparent_encoding as fallback when encoding is None, matching text property behavior\n    encoding = r.encoding or r.apparent_encoding\n    \n    if encoding is None:\n        for item in iterator:\n            yield item\n        return\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
    "Location 2 (/root/hy/projects_2/requests/requests/models.py lines 777-779)": "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Given an iterator and a requests response, decode the response into Unicode.\n\n    :param iterator: An iterator over the response data.\n    :param r: A response object.\n    \"\"\"\n\n    if r.encoding is None:\n        encoding = r.apparent_encoding\n    else:\n        encoding = r.encoding\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/requests/requests/utils.py lines 359-374)": [
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    encoding = r.encoding or r.apparent_encoding\n    if encoding is None:\n        for item in iterator:\n            yield item\n        return\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    encoding = r.encoding or r.apparent_encoding\n    if encoding is None:\n        for item in iterator:\n            yield item\n        return\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    # Use apparent_encoding as fallback when encoding is None, \n    # matching the behavior of the text property\n    encoding = r.encoding or r.apparent_encoding\n    \n    if encoding is None:\n        for item in iterator:\n            yield item\n        return\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    encoding = r.encoding or r.apparent_encoding\n    if encoding is None:\n        for item in iterator:\n            yield item\n        return\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    encoding = r.encoding or r.apparent_encoding\n    if encoding is None:\n        for item in iterator:\n            yield item\n        return\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    # Use the same fallback logic as the text property\n    encoding = r.encoding or r.apparent_encoding\n\n    if encoding is None:\n        for item in iterator:\n            yield item\n        return\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    # Use the same fallback logic as the text property\n    encoding = r.encoding or r.apparent_encoding\n\n    if encoding is None:\n        for item in iterator:\n            yield item\n        return\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    encoding = r.encoding or r.apparent_encoding\n    if encoding is None:\n        for item in iterator:\n            yield item\n        return\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n"
    ],
    "Location 2 (/root/hy/projects_2/requests/requests/models.py lines 777-779)": [
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Given an iterator and a requests response, decode the response into Unicode.\n\n    :param iterator: The iterator to decode.\n    :param r: The response object.\n    \"\"\"\n    \n    # Determine encoding - use same fallback logic as text property\n    encoding = r.encoding\n    if encoding is None:\n        encoding = r.apparent_encoding\n    \n    if encoding is None:\n        # If we still don't have encoding, yield raw bytes as fallback\n        for chunk in iterator:\n            yield chunk\n    else:\n        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n        for chunk in iterator:\n            rv = decoder.decode(chunk)\n            if rv:\n                yield rv\n        rv = decoder.decode(b'', final=True)\n        if rv:\n            yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Given an iterator and a request, attempt to decode the response as unicode.\n\n    This is a generator wrapper around the given iterator, yielding each chunk\n    as unicode.\n\n    This will fail if the response is not actually text, or if the encoding\n    is not actually accurate.\n    \"\"\"\n\n    if r.encoding is None:\n        encoding = r.apparent_encoding\n    else:\n        encoding = r.encoding\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Given an iterator and a requests response, decode the response into Unicode.\n\n    :param iterator: The iterator to decode.\n    :param r: The response object.\n    \"\"\"\n\n    if r.encoding is None:\n        # Use apparent_encoding as fallback, same as text property\n        encoding = r.apparent_encoding\n    else:\n        encoding = r.encoding\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Given an iterator and a requests response, decode the response into Unicode.\n\n    :param iterator: An iterator over the response data.\n    :param r: A requests Response object.\n    \"\"\"\n\n    if r.encoding is None:\n        # Use apparent_encoding fallback like the text property does\n        encoding = r.apparent_encoding\n    else:\n        encoding = r.encoding\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Given an iterator and a requests response, decode the response into Unicode.\n\n    :param iterator: An iterator over the response data.\n    :param r: A requests Response object.\n    \"\"\"\n\n    # Determine encoding - use apparent_encoding fallback when encoding is None\n    encoding = r.encoding\n    if encoding is None:\n        encoding = r.apparent_encoding\n\n    if encoding is None:\n        for chunk in iterator:\n            yield chunk\n        return\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Given an iterator and a requests response, decode the response into Unicode.\n\n    This is pulled from `requests.models.Response.iter_content`, in order\n    to avoid calling `requests.models.Response.iter_content` twice.\n    \"\"\"\n    if r.encoding is None:\n        # Use the same fallback logic as the text property\n        encoding = r.apparent_encoding\n    else:\n        encoding = r.encoding\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Given an iterator and a request, attempt to decode the response as unicode.\n\n    This is a generator.  You should not use this if the response's content-type\n    is not text or a similar text-based content type.\n\n    Warning: In general, requests will attempt to decode unicode url results\n             based on their HTTP headers.  However, some servers may choose to\n             mislead requests by advertising an incorrect encoding.  In this\n             case, the .apparent_encoding attribute on the response object can\n             be used instead.  Please exercise caution when using this option.\n    \"\"\"\n    if r.encoding is None:\n        # Use the same fallback logic as the text property\n        encoding = r.apparent_encoding\n        for chunk in iterator:\n            yield str(chunk, encoding, errors='replace')\n    else:\n        decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')\n        for chunk in iterator:\n            rv = decoder.decode(chunk)\n            if rv:\n                yield rv\n        rv = decoder.decode(b'', final=True)\n        if rv:\n            yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Given an iterator and a request, attempt to decode the response as unicode.\n\n    This code is based on http://stackoverflow.com/a/15729036/190597\n\n    \"\"\"\n\n    if r.encoding is None:\n        encoding = r.apparent_encoding\n    else:\n        encoding = r.encoding\n\n    try:\n        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    except (LookupError, TypeError):\n        decoder = codecs.getincrementaldecoder('utf-8')(errors='replace')\n\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/requests/models.py b/requests/models.py\nindex fbb3c7e6..ab1556e2 100644\n--- a/requests/models.py\n+++ b/requests/models.py\n@@ -774,6 +774,7 @@ class Response(object):\n         if not self.content:\n             return str('')\n \n+\n         # Fallback to auto-detected encoding.\n         if self.encoding is None:\n             encoding = self.apparent_encoding\ndiff --git a/requests/utils.py b/requests/utils.py\nindex 8d17b6b2..35f69d89 100644\n--- a/requests/utils.py\n+++ b/requests/utils.py\n@@ -356,15 +356,16 @@ def get_encoding_from_headers(headers):\n         return 'ISO-8859-1'\n \n \n+\n def stream_decode_response_unicode(iterator, r):\n     \"\"\"Stream decodes a iterator.\"\"\"\n \n-    if r.encoding is None:\n-        for item in iterator:\n-            yield item\n-        return\n+    # Use the same fallback logic as the text property\n+    encoding = r.encoding\n+    if encoding is None:\n+        encoding = r.apparent_encoding\n \n-    decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')\n+    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n     for chunk in iterator:\n         rv = decoder.decode(chunk)\n         if rv:\n",
    "variant_0": "diff --git a/requests/models.py b/requests/models.py\nindex fbb3c7e6..46fbb02d 100644\n--- a/requests/models.py\n+++ b/requests/models.py\n@@ -774,9 +774,29 @@ class Response(object):\n         if not self.content:\n             return str('')\n \n-        # Fallback to auto-detected encoding.\n-        if self.encoding is None:\n-            encoding = self.apparent_encoding\n+\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Given an iterator and a requests response, decode the response into Unicode.\n+\n+    :param iterator: An iterator over the response data.\n+    :param r: A response object.\n+    \"\"\"\n+\n+    if r.encoding is None:\n+        encoding = r.apparent_encoding\n+    else:\n+        encoding = r.encoding\n+\n+    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+\n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n \n         # Decode unicode from given encoding.\n         try:\ndiff --git a/requests/utils.py b/requests/utils.py\nindex 8d17b6b2..0218c97f 100644\n--- a/requests/utils.py\n+++ b/requests/utils.py\n@@ -356,15 +356,19 @@ def get_encoding_from_headers(headers):\n         return 'ISO-8859-1'\n \n \n+\n def stream_decode_response_unicode(iterator, r):\n     \"\"\"Stream decodes a iterator.\"\"\"\n \n-    if r.encoding is None:\n+    # Use apparent_encoding as fallback when encoding is None, matching text property behavior\n+    encoding = r.encoding or r.apparent_encoding\n+    \n+    if encoding is None:\n         for item in iterator:\n             yield item\n         return\n \n-    decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')\n+    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n     for chunk in iterator:\n         rv = decoder.decode(chunk)\n         if rv:\n",
    "variant_1": "diff --git a/requests/models.py b/requests/models.py\nindex fbb3c7e6..2a452de1 100644\n--- a/requests/models.py\n+++ b/requests/models.py\n@@ -774,9 +774,32 @@ class Response(object):\n         if not self.content:\n             return str('')\n \n-        # Fallback to auto-detected encoding.\n-        if self.encoding is None:\n-            encoding = self.apparent_encoding\n+\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Given an iterator and a requests response, decode the response into Unicode.\n+\n+    :param iterator: The iterator to decode.\n+    :param r: The response object.\n+    \"\"\"\n+    \n+    # Determine encoding - use same fallback logic as text property\n+    encoding = r.encoding\n+    if encoding is None:\n+        encoding = r.apparent_encoding\n+    \n+    if encoding is None:\n+        # If we still don't have encoding, yield raw bytes as fallback\n+        for chunk in iterator:\n+            yield chunk\n+    else:\n+        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+        for chunk in iterator:\n+            rv = decoder.decode(chunk)\n+            if rv:\n+                yield rv\n+        rv = decoder.decode(b'', final=True)\n+        if rv:\n+            yield rv\n \n         # Decode unicode from given encoding.\n         try:\ndiff --git a/requests/utils.py b/requests/utils.py\nindex 8d17b6b2..3e92457d 100644\n--- a/requests/utils.py\n+++ b/requests/utils.py\n@@ -356,15 +356,17 @@ def get_encoding_from_headers(headers):\n         return 'ISO-8859-1'\n \n \n+\n def stream_decode_response_unicode(iterator, r):\n     \"\"\"Stream decodes a iterator.\"\"\"\n \n-    if r.encoding is None:\n+    encoding = r.encoding or r.apparent_encoding\n+    if encoding is None:\n         for item in iterator:\n             yield item\n         return\n \n-    decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')\n+    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n     for chunk in iterator:\n         rv = decoder.decode(chunk)\n         if rv:\n",
    "variant_2": "diff --git a/requests/models.py b/requests/models.py\nindex fbb3c7e6..ef192c91 100644\n--- a/requests/models.py\n+++ b/requests/models.py\n@@ -774,9 +774,32 @@ class Response(object):\n         if not self.content:\n             return str('')\n \n-        # Fallback to auto-detected encoding.\n-        if self.encoding is None:\n-            encoding = self.apparent_encoding\n+\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Given an iterator and a request, attempt to decode the response as unicode.\n+\n+    This is a generator wrapper around the given iterator, yielding each chunk\n+    as unicode.\n+\n+    This will fail if the response is not actually text, or if the encoding\n+    is not actually accurate.\n+    \"\"\"\n+\n+    if r.encoding is None:\n+        encoding = r.apparent_encoding\n+    else:\n+        encoding = r.encoding\n+\n+    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+\n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n \n         # Decode unicode from given encoding.\n         try:\ndiff --git a/requests/utils.py b/requests/utils.py\nindex 8d17b6b2..3e92457d 100644\n--- a/requests/utils.py\n+++ b/requests/utils.py\n@@ -356,15 +356,17 @@ def get_encoding_from_headers(headers):\n         return 'ISO-8859-1'\n \n \n+\n def stream_decode_response_unicode(iterator, r):\n     \"\"\"Stream decodes a iterator.\"\"\"\n \n-    if r.encoding is None:\n+    encoding = r.encoding or r.apparent_encoding\n+    if encoding is None:\n         for item in iterator:\n             yield item\n         return\n \n-    decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')\n+    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n     for chunk in iterator:\n         rv = decoder.decode(chunk)\n         if rv:\n",
    "variant_3": "diff --git a/requests/models.py b/requests/models.py\nindex fbb3c7e6..2e3358ce 100644\n--- a/requests/models.py\n+++ b/requests/models.py\n@@ -774,9 +774,30 @@ class Response(object):\n         if not self.content:\n             return str('')\n \n-        # Fallback to auto-detected encoding.\n-        if self.encoding is None:\n-            encoding = self.apparent_encoding\n+\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Given an iterator and a requests response, decode the response into Unicode.\n+\n+    :param iterator: The iterator to decode.\n+    :param r: The response object.\n+    \"\"\"\n+\n+    if r.encoding is None:\n+        # Use apparent_encoding as fallback, same as text property\n+        encoding = r.apparent_encoding\n+    else:\n+        encoding = r.encoding\n+\n+    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+\n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n \n         # Decode unicode from given encoding.\n         try:\ndiff --git a/requests/utils.py b/requests/utils.py\nindex 8d17b6b2..90917d65 100644\n--- a/requests/utils.py\n+++ b/requests/utils.py\n@@ -356,15 +356,20 @@ def get_encoding_from_headers(headers):\n         return 'ISO-8859-1'\n \n \n+\n def stream_decode_response_unicode(iterator, r):\n     \"\"\"Stream decodes a iterator.\"\"\"\n \n-    if r.encoding is None:\n+    # Use apparent_encoding as fallback when encoding is None, \n+    # matching the behavior of the text property\n+    encoding = r.encoding or r.apparent_encoding\n+    \n+    if encoding is None:\n         for item in iterator:\n             yield item\n         return\n \n-    decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')\n+    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n     for chunk in iterator:\n         rv = decoder.decode(chunk)\n         if rv:\n",
    "variant_4": "diff --git a/requests/models.py b/requests/models.py\nindex fbb3c7e6..17f145ff 100644\n--- a/requests/models.py\n+++ b/requests/models.py\n@@ -774,9 +774,28 @@ class Response(object):\n         if not self.content:\n             return str('')\n \n-        # Fallback to auto-detected encoding.\n-        if self.encoding is None:\n-            encoding = self.apparent_encoding\n+\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Given an iterator and a requests response, decode the response into Unicode.\n+\n+    :param iterator: An iterator over the response data.\n+    :param r: A requests Response object.\n+    \"\"\"\n+\n+    if r.encoding is None:\n+        # Use apparent_encoding fallback like the text property does\n+        encoding = r.apparent_encoding\n+    else:\n+        encoding = r.encoding\n+\n+    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n \n         # Decode unicode from given encoding.\n         try:\ndiff --git a/requests/utils.py b/requests/utils.py\nindex 8d17b6b2..3e92457d 100644\n--- a/requests/utils.py\n+++ b/requests/utils.py\n@@ -356,15 +356,17 @@ def get_encoding_from_headers(headers):\n         return 'ISO-8859-1'\n \n \n+\n def stream_decode_response_unicode(iterator, r):\n     \"\"\"Stream decodes a iterator.\"\"\"\n \n-    if r.encoding is None:\n+    encoding = r.encoding or r.apparent_encoding\n+    if encoding is None:\n         for item in iterator:\n             yield item\n         return\n \n-    decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')\n+    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n     for chunk in iterator:\n         rv = decoder.decode(chunk)\n         if rv:\n",
    "variant_5": "diff --git a/requests/models.py b/requests/models.py\nindex fbb3c7e6..81e94e90 100644\n--- a/requests/models.py\n+++ b/requests/models.py\n@@ -774,9 +774,32 @@ class Response(object):\n         if not self.content:\n             return str('')\n \n-        # Fallback to auto-detected encoding.\n-        if self.encoding is None:\n-            encoding = self.apparent_encoding\n+\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Given an iterator and a requests response, decode the response into Unicode.\n+\n+    :param iterator: An iterator over the response data.\n+    :param r: A requests Response object.\n+    \"\"\"\n+\n+    # Determine encoding - use apparent_encoding fallback when encoding is None\n+    encoding = r.encoding\n+    if encoding is None:\n+        encoding = r.apparent_encoding\n+\n+    if encoding is None:\n+        for chunk in iterator:\n+            yield chunk\n+        return\n+\n+    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n \n         # Decode unicode from given encoding.\n         try:\ndiff --git a/requests/utils.py b/requests/utils.py\nindex 8d17b6b2..3e92457d 100644\n--- a/requests/utils.py\n+++ b/requests/utils.py\n@@ -356,15 +356,17 @@ def get_encoding_from_headers(headers):\n         return 'ISO-8859-1'\n \n \n+\n def stream_decode_response_unicode(iterator, r):\n     \"\"\"Stream decodes a iterator.\"\"\"\n \n-    if r.encoding is None:\n+    encoding = r.encoding or r.apparent_encoding\n+    if encoding is None:\n         for item in iterator:\n             yield item\n         return\n \n-    decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')\n+    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n     for chunk in iterator:\n         rv = decoder.decode(chunk)\n         if rv:\n",
    "variant_6": "diff --git a/requests/models.py b/requests/models.py\nindex fbb3c7e6..a2fafaf3 100644\n--- a/requests/models.py\n+++ b/requests/models.py\n@@ -774,9 +774,27 @@ class Response(object):\n         if not self.content:\n             return str('')\n \n-        # Fallback to auto-detected encoding.\n-        if self.encoding is None:\n-            encoding = self.apparent_encoding\n+\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Given an iterator and a requests response, decode the response into Unicode.\n+\n+    This is pulled from `requests.models.Response.iter_content`, in order\n+    to avoid calling `requests.models.Response.iter_content` twice.\n+    \"\"\"\n+    if r.encoding is None:\n+        # Use the same fallback logic as the text property\n+        encoding = r.apparent_encoding\n+    else:\n+        encoding = r.encoding\n+\n+    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n \n         # Decode unicode from given encoding.\n         try:\ndiff --git a/requests/utils.py b/requests/utils.py\nindex 8d17b6b2..36967456 100644\n--- a/requests/utils.py\n+++ b/requests/utils.py\n@@ -356,15 +356,19 @@ def get_encoding_from_headers(headers):\n         return 'ISO-8859-1'\n \n \n+\n def stream_decode_response_unicode(iterator, r):\n     \"\"\"Stream decodes a iterator.\"\"\"\n \n-    if r.encoding is None:\n+    # Use the same fallback logic as the text property\n+    encoding = r.encoding or r.apparent_encoding\n+\n+    if encoding is None:\n         for item in iterator:\n             yield item\n         return\n \n-    decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')\n+    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n     for chunk in iterator:\n         rv = decoder.decode(chunk)\n         if rv:\n",
    "variant_7": "diff --git a/requests/models.py b/requests/models.py\nindex fbb3c7e6..35bf9968 100644\n--- a/requests/models.py\n+++ b/requests/models.py\n@@ -774,9 +774,33 @@ class Response(object):\n         if not self.content:\n             return str('')\n \n-        # Fallback to auto-detected encoding.\n-        if self.encoding is None:\n-            encoding = self.apparent_encoding\n+\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Given an iterator and a request, attempt to decode the response as unicode.\n+\n+    This is a generator.  You should not use this if the response's content-type\n+    is not text or a similar text-based content type.\n+\n+    Warning: In general, requests will attempt to decode unicode url results\n+             based on their HTTP headers.  However, some servers may choose to\n+             mislead requests by advertising an incorrect encoding.  In this\n+             case, the .apparent_encoding attribute on the response object can\n+             be used instead.  Please exercise caution when using this option.\n+    \"\"\"\n+    if r.encoding is None:\n+        # Use the same fallback logic as the text property\n+        encoding = r.apparent_encoding\n+        for chunk in iterator:\n+            yield str(chunk, encoding, errors='replace')\n+    else:\n+        decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')\n+        for chunk in iterator:\n+            rv = decoder.decode(chunk)\n+            if rv:\n+                yield rv\n+        rv = decoder.decode(b'', final=True)\n+        if rv:\n+            yield rv\n \n         # Decode unicode from given encoding.\n         try:\ndiff --git a/requests/utils.py b/requests/utils.py\nindex 8d17b6b2..36967456 100644\n--- a/requests/utils.py\n+++ b/requests/utils.py\n@@ -356,15 +356,19 @@ def get_encoding_from_headers(headers):\n         return 'ISO-8859-1'\n \n \n+\n def stream_decode_response_unicode(iterator, r):\n     \"\"\"Stream decodes a iterator.\"\"\"\n \n-    if r.encoding is None:\n+    # Use the same fallback logic as the text property\n+    encoding = r.encoding or r.apparent_encoding\n+\n+    if encoding is None:\n         for item in iterator:\n             yield item\n         return\n \n-    decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')\n+    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n     for chunk in iterator:\n         rv = decoder.decode(chunk)\n         if rv:\n",
    "variant_8": "diff --git a/requests/models.py b/requests/models.py\nindex fbb3c7e6..e1b30221 100644\n--- a/requests/models.py\n+++ b/requests/models.py\n@@ -774,9 +774,32 @@ class Response(object):\n         if not self.content:\n             return str('')\n \n-        # Fallback to auto-detected encoding.\n-        if self.encoding is None:\n-            encoding = self.apparent_encoding\n+\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Given an iterator and a request, attempt to decode the response as unicode.\n+\n+    This code is based on http://stackoverflow.com/a/15729036/190597\n+\n+    \"\"\"\n+\n+    if r.encoding is None:\n+        encoding = r.apparent_encoding\n+    else:\n+        encoding = r.encoding\n+\n+    try:\n+        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    except (LookupError, TypeError):\n+        decoder = codecs.getincrementaldecoder('utf-8')(errors='replace')\n+\n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n \n         # Decode unicode from given encoding.\n         try:\ndiff --git a/requests/utils.py b/requests/utils.py\nindex 8d17b6b2..3e92457d 100644\n--- a/requests/utils.py\n+++ b/requests/utils.py\n@@ -356,15 +356,17 @@ def get_encoding_from_headers(headers):\n         return 'ISO-8859-1'\n \n \n+\n def stream_decode_response_unicode(iterator, r):\n     \"\"\"Stream decodes a iterator.\"\"\"\n \n-    if r.encoding is None:\n+    encoding = r.encoding or r.apparent_encoding\n+    if encoding is None:\n         for item in iterator:\n             yield item\n         return\n \n-    decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')\n+    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n     for chunk in iterator:\n         rv = decoder.decode(chunk)\n         if rv:\n"
  }
}