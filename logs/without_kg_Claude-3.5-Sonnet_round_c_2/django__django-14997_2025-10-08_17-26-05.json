{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/django/django/db/backends/sqlite3/schema.py lines 300-304)": "\n\n    def _create_unique_sql(self, model, columns, name=None, condition=None, deferrable=None, include=None, opclasses=None):\n        \"\"\"\n        Override to handle expressions in unique constraints for SQLite.\n        SQLite doesn't allow table-qualified column names in constraint expressions.\n        \"\"\"\n        if not any(hasattr(col, 'target') for col in columns):\n            # No expressions, use the standard implementation\n            return super()._create_unique_sql(model, columns, name, condition, deferrable, include, opclasses)\n        \n        # Handle expressions by using unqualified column names\n        compiler = self.connection.ops.compiler('SQLCompiler')(\n            self.connection.ops.compiler('SQLCompiler').query_class(model), self.connection, None\n        )\n        \n        # Create SQLite-specific expressions handler\n        expressions = SQLiteExpressions(model._meta.db_table, columns, compiler, self.quote_value)\n        \n        return self._create_unique_sql_for_field(\n            model, columns, name, condition, deferrable, include, opclasses, expressions\n        )\n\n\nclass SQLiteExpressions:\n    \"\"\"\n    SQLite-specific expressions handler that avoids table-qualified column names\n    in constraint definitions.\n    \"\"\"\n    def __init__(self, table, expressions, compiler, quote_value):\n        self.table = table\n        self.expressions = expressions\n        self.compiler = compiler\n        self.quote_value = quote_value\n\n    def __str__(self):\n        sql = []\n        for col in self.compiler.query._gen_cols([self.expressions]):\n            # Strip table qualification for SQLite\n            column_name = col.target.column\n            if hasattr(col, 'output_field') and hasattr(col.output_field, 'get_col'):\n                # Handle expression columns by getting just the column name\n                sql.append(self.quote_value(column_name))\n            else:\n                sql.append(self.quote_value(column_name))\n        return ', '.join(sql)\n",
    "Location 2 (/root/hy/projects_2/django/django/db/backends/base/schema.py lines 1246-1287)": "\n    def _create_unique_sql(\n        self, model, fields, name=None, condition=None, deferrable=None,\n        include=None, opclasses=None, expressions=None,\n    ):\n        if (\n            (\n                deferrable and\n                not self.connection.features.supports_deferrable_unique_constraints\n            ) or\n            (condition and not self.connection.features.supports_partial_indexes) or\n            (include and not self.connection.features.supports_covering_indexes) or\n            (expressions and not self.connection.features.supports_expression_indexes)\n        ):\n            return None\n\n        def create_unique_name(*args, **kwargs):\n            return self.quote_name(self._create_index_name(*args, **kwargs))\n\n        compiler = Query(model, alias_cols=False).get_compiler(connection=self.connection)\n        table = model._meta.db_table\n        columns = [field.column for field in fields]\n        if name is None:\n            name = IndexName(table, columns, '_uniq', create_unique_name)\n        else:\n            name = self.quote_name(name)\n        if condition or include or opclasses or expressions:\n            sql = self.sql_create_unique_index\n        else:\n            sql = self.sql_create_unique\n        if columns:\n            columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n        else:\n            # Use SQLite-specific Expressions class that strips table qualifiers\n            columns = SQLiteExpressions(table, expressions, compiler, self.quote_value)\n        return Statement(\n            sql,\n            table=Table(table, self.quote_name),\n            name=name,\n            columns=columns,\n            condition=self._index_condition_sql(condition),\n            deferrable=self._deferrable_constraint_sql(deferrable),\n            include=self._index_include_sql(model, include),\n        )\n\n\nclass SQLiteExpressions(Expressions):\n    \"\"\"SQLite-specific Expressions class that strips table qualifiers from column references.\"\"\"\n    \n    def __str__(self):\n        expressions_sql = []\n        for expression in self.expressions:\n            expression_sql = str(expression.resolve_expression(\n                Query(self.table, alias_cols=False), allow_joins=False, reuse=None, summarize=False\n            ).as_sql(self.compiler, self.connection)[0])\n            expressions_sql.append(expression_sql)\n        return ', '.join(expressions_sql)\n",
    "Location 3 (/root/hy/projects_2/django/django/db/backends/ddl_references.py lines 204-230)": "\nclass SQLiteExpressions(Expressions):\n    def __init__(self, table, expressions, compiler, quote_value):\n        super().__init__(table, expressions, compiler, quote_value)\n        # Strip table qualifiers from column names for SQLite compatibility\n        self.columns = [col.split('.')[-1] if '.' in col else col for col in self.columns]\n\ndef _create_unique_sql(self, model, columns, name=None, condition=None,\n                      deferrable=None, include=None, opclasses=None,\n                      expressions=None):\n    if expressions:\n        # Use SQLite-specific Expressions class to avoid table qualifiers\n        compiler = Query(model, alias_cols=False).get_compiler(connection=self.connection)\n        expressions_part = SQLiteExpressions(\n            Table(model._meta.db_table, self.quote_name),\n            expressions,\n            compiler,\n            self.quote_value\n        )\n        template = 'CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)%(condition)s'\n        sql = Statement(\n            template,\n            name=self._create_index_name(model._meta.db_table, [None], suffix=''),\n            table=Table(model._meta.db_table, self.quote_name),\n            columns=expressions_part,\n            condition=' WHERE %s' % condition if condition else '',\n        )\n        return sql\n    else:\n        # Use parent implementation for non-expression constraints\n        return super()._create_unique_sql(\n            model, columns, name, condition, deferrable, include, opclasses, expressions\n        )\n",
    "Location 4 (/root/hy/projects_2/django/django/db/backends/sqlite3/schema.py lines 421-441)": "\n    def add_constraint(self, model, constraint):\n        if isinstance(constraint, UniqueConstraint) and (\n            constraint.condition or\n            constraint.contains_expressions or\n            constraint.include or\n            constraint.deferrable\n        ):\n            super().add_constraint(model, constraint)\n        else:\n            self._remake_table(model)\n\n    def remove_constraint(self, model, constraint):\n        if isinstance(constraint, UniqueConstraint) and (\n            constraint.condition or\n            constraint.contains_expressions or\n            constraint.include or\n            constraint.deferrable\n        ):\n            super().remove_constraint(model, constraint)\n        else:\n            self._remake_table(model)\n\n    def _create_unique_sql(self, model, columns, name=None, condition=None,\n                          deferrable=None, include=None, opclasses=None,\n                          expressions=None):\n        \"\"\"\n        Override to handle expression-based unique constraints for SQLite.\n        SQLite doesn't support table-qualified column names in constraint expressions.\n        \"\"\"\n        from django.db.backends.ddl_references import Expressions\n        \n        class SQLiteExpressions(Expressions):\n            def __str__(self):\n                # Get the original expression string\n                original = super().__str__()\n                # Remove table qualifiers (table_name.column_name -> column_name)\n                # This handles the case where expressions contain table-qualified column names\n                table_name = self.quote_name(self.table)\n                qualified_prefix = f\"{table_name}.\"\n                return original.replace(qualified_prefix, \"\")\n        \n        if expressions:\n            # Use our custom Expressions class for SQLite\n            compiler = self.connection.ops.compiler('SQLCompiler')(\n                self.connection.ops.quote_name, self.connection\n            )\n            expressions_obj = SQLiteExpressions(\n                model._meta.db_table, expressions, compiler, self.quote_value\n            )\n            return Statement(\n                self.sql_create_unique_index,\n                table=model._meta.db_table,\n                name=name,\n                columns=expressions_obj,\n                condition=condition and ' WHERE %s' % condition,\n                deferrable=deferrable,\n                include=include and ' INCLUDE (%s)' % ', '.join(include),\n                opclasses=opclasses,\n            )\n        else:\n            # For non-expression constraints, use the base implementation\n            return super()._create_unique_sql(\n                model, columns, name, condition, deferrable, include, opclasses, expressions\n            )\n",
    "Location 5 (/root/hy/projects_2/django/django/db/backends/sqlite3/schema.py lines 444-444)": "\n    def _collate_sql(self, collation):\n        return 'COLLATE ' + collation\n\n    def _create_unique_sql(self, model, columns, name=None, condition=None,\n                          deferrable=None, include=None, opclasses=None,\n                          expressions=None):\n        if expressions:\n            # SQLite doesn't support table-qualified column names in unique constraints\n            # Use a custom Expressions class that strips table qualifiers\n            compiler = self.connection.ops.compiler('SQLCompiler')(\n                self.connection.ops.compiler('SQLCompiler').query_class(model), self.connection, None\n            )\n            expressions_sql = SQLiteExpressions(\n                model._meta.db_table, expressions, compiler, self.quote_value\n            )\n            columns = [expressions_sql]\n        \n        return super()._create_unique_sql(\n            model, columns, name, condition, deferrable, include, opclasses\n        )\n\n\nclass SQLiteExpressions:\n    \"\"\"\n    SQLite-specific expressions class that generates column references\n    without table qualifiers for use in unique constraints.\n    \"\"\"\n    def __init__(self, table, expressions, compiler, quote_value):\n        self.table = table\n        self.expressions = expressions\n        self.compiler = compiler\n        self.quote_value = quote_value\n\n    def __str__(self):\n        # Generate column names without table qualifiers for SQLite\n        columns = []\n        for expression in self.expressions:\n            if hasattr(expression, 'target') and hasattr(expression.target, 'column'):\n                # This is a column reference, use only the column name\n                columns.append(self.quote_value(expression.target.column))\n            else:\n                # For other expressions, compile them normally\n                # This handles cases like functions, literals, etc.\n                sql, params = expression.as_sql(self.compiler, self.compiler.connection)\n                columns.append(sql % params if params else sql)\n        return ', '.join(columns)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/django/django/db/backends/sqlite3/schema.py lines 300-304)": [
      "\n\n        # Run deferred SQL on correct table\n        for sql in self.deferred_sql:\n            self.execute(sql)\n        self.deferred_sql = []\n",
      "\n\n    def _create_unique_sql(self, model, columns, name=None, condition=None,\n                          deferrable=None, include=None, opclasses=None, expressions=None):\n        \"\"\"\n        Override to handle expressions without table qualification for SQLite.\n        SQLite doesn't support table-qualified column names in unique constraint expressions.\n        \"\"\"\n        if expressions:\n            # Use SQLite-specific Expressions class that strips table qualifiers\n            compiler = self.connection.ops.compiler('SQLCompiler')(\n                self.connection.ops.compiler('SQLCompiler').query_class(model), \n                self.connection, 'default'\n            )\n            expressions_sql = SQLiteExpressions(\n                Table(model._meta.db_table, self.quote_name), \n                expressions, \n                compiler, \n                self.quote_value\n            )\n            columns = [expressions_sql]\n        \n        return super()._create_unique_sql(\n            model, columns, name, condition, deferrable, include, opclasses, expressions\n        )\n\n\nclass SQLiteExpressions:\n    \"\"\"\n    SQLite-specific Expressions class that generates column references without table qualification.\n    SQLite prohibits table-qualified column names in unique constraint expressions.\n    \"\"\"\n    def __init__(self, table, expressions, compiler, quote_value):\n        self.table = table\n        self.expressions = expressions  \n        self.compiler = compiler\n        self.quote_value = quote_value\n\n    def __str__(self):\n        # Generate expression SQL without table qualifiers\n        sql_parts = []\n        for expression in self.expressions:\n            if hasattr(expression, 'as_sql'):\n                sql, params = expression.as_sql(self.compiler, self.compiler.connection)\n                # Strip table qualifiers from column references\n                # Replace \"table\".\"column\" with just \"column\" \n                import re\n                sql = re.sub(r'\"[^\"]+\"\\.\"([^\"]+)\"', r'\"\\1\"', sql)\n                sql_parts.append(sql % tuple(self.quote_value(p) for p in params))\n            else:\n                # Handle simple column names\n                sql_parts.append(str(expression))\n        return ', '.join(sql_parts)\n",
      "\n\n        # Run deferred SQL on correct table\n        for sql in self.deferred_sql:\n            self.execute(sql)\n        self.deferred_sql = []\n        \n    def _create_unique_sql(self, model, columns, name, condition=None, deferrable=None, include=None, opclasses=None, expressions=None):\n        \"\"\"\n        Override to handle SQLite's restriction on table-qualified column names in unique constraints.\n        \"\"\"\n        if expressions:\n            # For expressions, use SQLite-specific handling to avoid table qualification\n            compiler = self.connection.ops.compiler('SQLCompiler')(\n                self.connection.ops.quote_name, self.connection\n            )\n            \n            # Create a custom expressions handler that doesn't include table names\n            class SQLiteExpressions:\n                def __init__(self, table, expressions, compiler, quote_value):\n                    self.expressions = expressions\n                    self.compiler = compiler\n                    \n                def __str__(self):\n                    # Generate expression SQL without table qualification\n                    sql_parts = []\n                    for expression in self.expressions:\n                        # Clone and compile the expression without table references\n                        expr_clone = expression.copy()\n                        expr_clone.set_source_expressions([\n                            expr.copy() for expr in expr_clone.get_source_expressions()\n                        ])\n                        sql, params = expr_clone.as_sql(self.compiler, self.compiler.connection)\n                        # Remove table qualifications from the SQL\n                        sql = sql.replace(f'\"{model._meta.db_table}\".', '')\n                        sql_parts.append(sql)\n                    return ', '.join(sql_parts)\n            \n            expressions_obj = SQLiteExpressions(model._meta.db_table, expressions, compiler, self.quote_value)\n            \n            sql = self.sql_create_unique % {\n                'table': self.quote_name(model._meta.db_table),\n                'name': self.quote_name(name),\n                'columns': expressions_obj,\n            }\n            \n            if condition:\n                sql += ' WHERE ' + condition\n                \n            return Statement(sql, table=model._meta.db_table, name=name)\n        else:\n            # For regular columns, use the parent implementation\n            return super()._create_unique_sql(\n                model, columns, name, condition, deferrable, include, opclasses, expressions\n            )\n",
      "\n\n    def _create_unique_sql(self, model, columns, name=None, condition=None,\n                          deferrable=None, include=None, opclasses=None):\n        \"\"\"\n        Override to handle expressions in unique constraints for SQLite.\n        SQLite doesn't support table-qualified column names in constraint expressions.\n        \"\"\"\n        if not name:\n            name = self._create_index_name(model._meta.db_table, columns, suffix=\"_uniq\")\n        \n        def _get_index_columns(columns):\n            # Handle expressions by removing table qualifiers for SQLite\n            index_columns = []\n            for column in columns:\n                if hasattr(column, 'resolve_expression'):\n                    # This is an expression, use SQLite-specific handling\n                    compiler = self.connection.ops.compiler('SQLCompiler')(\n                        query=None, connection=self.connection, using=None\n                    )\n                    # Create a mock query for the compiler\n                    from django.db.models.sql import Query\n                    query = Query(model)\n                    compiler.query = query\n                    \n                    # Use our custom SQLiteExpressions class\n                    expr_sql = SQLiteExpressions(\n                        model._meta.db_table, [column], compiler, self.quote_value\n                    )\n                    index_columns.append(str(expr_sql))\n                else:\n                    # Regular column name\n                    index_columns.append(self.quote_name(column))\n            return index_columns\n        \n        index_columns = _get_index_columns(columns)\n        \n        sql = self.sql_create_unique % {\n            \"table\": self.quote_name(model._meta.db_table),\n            \"name\": self.quote_name(name),\n            \"columns\": \", \".join(index_columns),\n        }\n        \n        if condition:\n            sql += \" WHERE \" + condition\n            \n        return Statement(sql, [], [])\n\n\nclass SQLiteExpressions:\n    \"\"\"\n    SQLite-specific expressions handler that removes table qualifiers\n    from column references in constraint expressions.\n    \"\"\"\n    def __init__(self, table, expressions, compiler, quote_value):\n        self.table = table\n        self.expressions = expressions  \n        self.compiler = compiler\n        self.quote_value = quote_value\n\n    def __str__(self):\n        # Generate column references without table qualifiers for SQLite\n        if not self.compiler.query:\n            from django.db.models.sql import Query\n            # Create a minimal query context if needed\n            self.compiler.query = Query(None)\n            \n        sql_parts = []\n        for expr in self.expressions:\n            if hasattr(expr, 'resolve_expression'):\n                # For expressions, compile them and strip table qualifiers\n                resolved_expr = expr.resolve_expression(self.compiler.query)\n                expr_sql, params = resolved_expr.as_sql(self.compiler, self.compiler.connection)\n                # Remove table qualifiers (everything before the last dot)\n                if '.' in expr_sql and not expr_sql.startswith('\"'):\n                    # Handle case like \"table\".\"column\" -> \"column\"  \n                    parts = expr_sql.split('.')\n                    if len(parts) > 1:\n                        expr_sql = parts[-1]  # Take only the column part\n                sql_parts.append(expr_sql)\n            else:\n                # Simple column name\n                sql_parts.append(str(expr))\n        \n        return \", \".join(sql_parts)\n",
      "\n    def _create_unique_sql(self, model, columns, name=None, condition=None,\n                          deferrable=None, include=None, opclasses=None, expressions=None):\n        \"\"\"\n        Return the SQL to create a unique constraint for the given columns.\n        For SQLite, we need to handle expressions specially to avoid table-qualified column names.\n        \"\"\"\n        if expressions:\n            # Use SQLite-specific Expressions class that strips table qualifiers\n            compiler = Query(model, alias_cols=False).get_compiler(connection=self.connection)\n            expressions_sql = SQLiteExpressions(\n                model._meta.db_table, expressions, compiler, self.quote_value\n            )\n        else:\n            expressions_sql = None\n            \n        return super()._create_unique_sql(\n            model, columns, name, condition, deferrable, include, opclasses, expressions_sql\n        )\n\n\nclass SQLiteExpressions(Expressions):\n    \"\"\"\n    SQLite-specific Expressions class that strips table qualifiers from column names\n    to avoid \"table name prefix not allowed\" errors in constraint expressions.\n    \"\"\"\n    def __str__(self):\n        # Get the base column references\n        cols = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n        # Strip table qualifiers - only use column names for SQLite\n        return ', '.join(self.quote_value(col.split('.')[-1]) if '.' in col else self.quote_value(col) for col in cols)\n",
      "\n    def _create_unique_sql(self, model, columns, name=None, condition=None,\n                          deferrable=None, include=None, opclasses=None, expressions=None):\n        \"\"\"\n        Generate SQL to create a unique constraint, handling SQLite's restriction\n        on table-qualified column names in expressions.\n        \"\"\"\n        if expressions:\n            # SQLite doesn't allow table-qualified column names in constraint expressions\n            # Use a custom Expressions class that strips table qualifiers\n            compiler = Query(model, alias_cols=False).get_compiler(connection=self.connection)\n            expressions_sql = SQLiteExpressions(model._meta.db_table, expressions, compiler, self.quote_value)\n            sql = self._create_unique_constraint_sql(model, name, expressions_sql, condition, deferrable, include, opclasses)\n        else:\n            # For non-expression constraints, use the standard approach\n            sql = super()._create_unique_sql(model, columns, name, condition, deferrable, include, opclasses)\n        return sql\n\n\nclass SQLiteExpressions(Expressions):\n    \"\"\"\n    SQLite-specific Expressions class that generates column references\n    without table qualifiers to comply with SQLite's constraint syntax.\n    \"\"\"\n    def __str__(self):\n        # Generate expressions without table qualification\n        expressions = []\n        for expr in self.expressions:\n            if hasattr(expr, 'resolve_expression'):\n                resolved = expr.resolve_expression(self.compiler.query)\n                if hasattr(resolved, 'target') and hasattr(resolved.target, 'column'):\n                    # Simple column reference - use just the column name\n                    expressions.append(self.quote_value(resolved.target.column))\n                else:\n                    # Complex expression - let SQLite handle it\n                    expressions.append(str(resolved))\n            else:\n                expressions.append(str(expr))\n        return ', '.join(expressions)\n",
      "\n\n    def _create_unique_sql(self, model, columns, name=None, condition=None,\n                          deferrable=None, include=None, opclasses=None, expressions=None):\n        if expressions:\n            # SQLite doesn't support table-qualified column names in constraint expressions\n            # Create a custom Expressions handler that strips table qualifiers\n            class SQLiteExpressions(Expressions):\n                def __str__(self):\n                    # Get the base column references without table qualification\n                    cols = []\n                    for col in self.compiler.query._gen_cols([self.expressions]):\n                        # Strip table qualifier if present, keep only column name\n                        col_name = col.target.column\n                        cols.append(self.compiler.quote_name_unless_alias(col_name))\n                    return ', '.join(cols)\n            \n            # Use our custom expressions handler\n            compiler = self.connection.ops.compiler('SQLCompiler')(\n                self.connection.ops.compiler('SQLCompiler').query_class(model), self.connection, 'default'\n            )\n            expressions_sql = SQLiteExpressions(None, expressions, compiler, self.quote_value)\n            \n            # Build the constraint SQL manually for SQLite\n            sql = self.sql_create_unique_index if condition else self.sql_create_unique\n            return Statement(\n                sql,\n                table=Table(model._meta.db_table, self.quote_name),\n                name=self.quote_name(name) if name else self._create_index_name(model._meta.db_table, [str(expressions_sql)], suffix='_uniq'),\n                columns=expressions_sql,\n                condition=' WHERE ' + condition if condition else '',\n            )\n        else:\n            # Use the base implementation for non-expression constraints\n            return super()._create_unique_sql(model, columns, name, condition, deferrable, include, opclasses, expressions)\n",
      "\n    def _create_unique_sql(self, model, columns, name=None, condition=None,\n                          deferrable=None, include=None, expressions=None):\n        \"\"\"\n        Return the SQL for creating a unique constraint. Override to handle\n        expressions without table qualification for SQLite compatibility.\n        \"\"\"\n        if expressions:\n            # Use SQLite-specific Expressions class that strips table qualifiers\n            expressions_sql = SQLiteExpressions(\n                model._meta.db_table, expressions, self.connection.ops.compiler(\"SQLCompiler\")(\n                    self.connection.ops.query_class(model), self.connection, \"default\"\n                ), self.quote_value\n            )\n        else:\n            expressions_sql = None\n        \n        return super()._create_unique_sql(\n            model, columns, name, condition, deferrable, include, expressions_sql\n        )\n\n\nclass SQLiteExpressions:\n    \"\"\"\n    SQLite-specific expressions class that strips table qualifiers from column references.\n    \"\"\"\n    def __init__(self, table, expressions, compiler, quote_value):\n        self.table = table\n        self.expressions = expressions\n        self.compiler = compiler\n        self.quote_value = quote_value\n\n    def __str__(self):\n        # Generate column references without table qualification\n        cols = []\n        for col in self.compiler.query._gen_cols([self.expressions]):\n            # Strip table qualifier from column name\n            column_name = col.target.column\n            if '.' in column_name:\n                column_name = column_name.split('.', 1)[1]\n            cols.append(column_name)\n        return ', '.join(cols)\n"
    ],
    "Location 2 (/root/hy/projects_2/django/django/db/backends/base/schema.py lines 1246-1287)": [
      "\n    def _create_unique_sql(\n        self, model, fields, name=None, condition=None, deferrable=None,\n        include=None, opclasses=None, expressions=None,\n    ):\n        if (\n            (\n                deferrable and\n                not self.connection.features.supports_deferrable_unique_constraints\n            ) or\n            (condition and not self.connection.features.supports_partial_indexes) or\n            (include and not self.connection.features.supports_covering_indexes) or\n            (expressions and not self.connection.features.supports_expression_indexes)\n        ):\n            return None\n\n        def create_unique_name(*args, **kwargs):\n            return self.quote_name(self._create_index_name(*args, **kwargs))\n\n        compiler = Query(model, alias_cols=False).get_compiler(connection=self.connection)\n        table = model._meta.db_table\n        columns = [field.column for field in fields]\n        if name is None:\n            name = IndexName(table, columns, '_uniq', create_unique_name)\n        else:\n            name = self.quote_name(name)\n        if condition or include or opclasses or expressions:\n            sql = self.sql_create_unique_index\n        else:\n            sql = self.sql_create_unique\n        if columns:\n            columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n        else:\n            # For SQLite, use custom Expressions class to avoid table qualifiers\n            from django.db.backends.sqlite3.schema import SQLiteExpressions\n            columns = SQLiteExpressions(table, expressions, compiler, self.quote_value)\n        return Statement(\n            sql,\n            table=Table(table, self.quote_name),\n            name=name,\n            columns=columns,\n            condition=self._index_condition_sql(condition),\n            deferrable=self._deferrable_constraint_sql(deferrable),\n            include=self._index_include_sql(model, include),\n        )\n",
      "\n    def _create_unique_sql(\n        self, model, fields, name=None, condition=None, deferrable=None,\n        include=None, opclasses=None, expressions=None,\n    ):\n        if (\n            (\n                deferrable and\n                not self.connection.features.supports_deferrable_unique_constraints\n            ) or\n            (condition and not self.connection.features.supports_partial_indexes) or\n            (include and not self.connection.features.supports_covering_indexes) or\n            (expressions and not self.connection.features.supports_expression_indexes)\n        ):\n            return None\n\n        def create_unique_name(*args, **kwargs):\n            return self.quote_name(self._create_index_name(*args, **kwargs))\n\n        compiler = Query(model, alias_cols=False).get_compiler(connection=self.connection)\n        table = model._meta.db_table\n        columns = [field.column for field in fields]\n        if name is None:\n            name = IndexName(table, columns, '_uniq', create_unique_name)\n        else:\n            name = self.quote_name(name)\n        if condition or include or opclasses or expressions:\n            sql = self.sql_create_unique_index\n        else:\n            sql = self.sql_create_unique\n        if columns:\n            columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n        else:\n            # SQLite-specific: Use custom Expressions class to avoid table qualifiers\n            from django.db.backends.sqlite3.schema import SQLiteExpressions\n            columns = SQLiteExpressions(table, expressions, compiler, self.quote_value)\n        return Statement(\n            sql,\n            table=Table(table, self.quote_name),\n            name=name,\n            columns=columns,\n            condition=self._index_condition_sql(condition),\n            deferrable=self._deferrable_constraint_sql(deferrable),\n            include=self._index_include_sql(model, include),\n        )\n",
      "\n    def _create_unique_sql(\n        self, model, fields, name=None, condition=None, deferrable=None,\n        include=None, opclasses=None, expressions=None,\n    ):\n        if (\n            (\n                deferrable and\n                not self.connection.features.supports_deferrable_unique_constraints\n            ) or\n            (condition and not self.connection.features.supports_partial_indexes) or\n            (include and not self.connection.features.supports_covering_indexes) or\n            (expressions and not self.connection.features.supports_expression_indexes)\n        ):\n            return None\n\n        def create_unique_name(*args, **kwargs):\n            return self.quote_name(self._create_index_name(*args, **kwargs))\n\n        compiler = Query(model, alias_cols=False).get_compiler(connection=self.connection)\n        table = model._meta.db_table\n        columns = [field.column for field in fields]\n        if name is None:\n            name = IndexName(table, columns, '_uniq', create_unique_name)\n        else:\n            name = self.quote_name(name)\n        if condition or include or opclasses or expressions:\n            sql = self.sql_create_unique_index\n        else:\n            sql = self.sql_create_unique\n        if columns:\n            columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n        else:\n            # Use SQLite-specific Expressions class that doesn't include table qualifiers\n            columns = SQLiteExpressions(table, expressions, compiler, self.quote_value)\n        return Statement(\n            sql,\n            table=Table(table, self.quote_name),\n            name=name,\n            columns=columns,\n            condition=self._index_condition_sql(condition),\n            deferrable=self._deferrable_constraint_sql(deferrable),\n            include=self._index_include_sql(model, include),\n        )\n\n\nclass SQLiteExpressions(Expressions):\n    def __str__(self):\n        expressions = []\n        for expression in self.expressions:\n            expression = expression.resolve_expression(\n                Query(self.table, alias_cols=False), allow_joins=False, reuse=None, summarize=False,\n            )\n            expression_sql, params = self.compiler.compile(expression)\n            # Remove table qualifiers from column references for SQLite\n            # Replace \"table_name\".\"column_name\" with just \"column_name\"\n            import re\n            expression_sql = re.sub(r'\"[^\"]+\"\\.\"([^\"]+)\"', r'\"\\1\"', expression_sql)\n            expressions.append(expression_sql % tuple(self.quote_value(p) for p in params))\n        return ', '.join(expressions)\n",
      "\n    def _create_unique_sql(\n        self, model, fields, name=None, condition=None, deferrable=None,\n        include=None, opclasses=None, expressions=None,\n    ):\n        if (\n            (\n                deferrable and\n                not self.connection.features.supports_deferrable_unique_constraints\n            ) or\n            (condition and not self.connection.features.supports_partial_indexes) or\n            (include and not self.connection.features.supports_covering_indexes) or\n            (expressions and not self.connection.features.supports_expression_indexes)\n        ):\n            return None\n\n        def create_unique_name(*args, **kwargs):\n            return self.quote_name(self._create_index_name(*args, **kwargs))\n\n        compiler = Query(model, alias_cols=False).get_compiler(connection=self.connection)\n        table = model._meta.db_table\n        columns = [field.column for field in fields]\n        if name is None:\n            name = IndexName(table, columns, '_uniq', create_unique_name)\n        else:\n            name = self.quote_name(name)\n        if condition or include or opclasses or expressions:\n            sql = self.sql_create_unique_index\n        else:\n            sql = self.sql_create_unique\n        if columns:\n            columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n        else:\n            # Use SQLite-specific Expressions class to avoid table qualification\n            from django.db.backends.sqlite3.schema import SQLiteExpressions\n            columns = SQLiteExpressions(table, expressions, compiler, self.quote_value)\n        return Statement(\n            sql,\n            table=Table(table, self.quote_name),\n            name=name,\n            columns=columns,\n            condition=self._index_condition_sql(condition),\n            deferrable=self._deferrable_constraint_sql(deferrable),\n            include=self._index_include_sql(model, include),\n        )\n",
      "\n    def _create_unique_sql(\n        self, model, fields, name=None, condition=None, deferrable=None,\n        include=None, opclasses=None, expressions=None,\n    ):\n        if (\n            (\n                deferrable and\n                not self.connection.features.supports_deferrable_unique_constraints\n            ) or\n            (condition and not self.connection.features.supports_partial_indexes) or\n            (include and not self.connection.features.supports_covering_indexes) or\n            (expressions and not self.connection.features.supports_expression_indexes)\n        ):\n            return None\n\n        def create_unique_name(*args, **kwargs):\n            return self.quote_name(self._create_index_name(*args, **kwargs))\n\n        compiler = Query(model, alias_cols=False).get_compiler(connection=self.connection)\n        table = model._meta.db_table\n        columns = [field.column for field in fields]\n        if name is None:\n            name = IndexName(table, columns, '_uniq', create_unique_name)\n        else:\n            name = self.quote_name(name)\n        if condition or include or opclasses or expressions:\n            sql = self.sql_create_unique_index\n        else:\n            sql = self.sql_create_unique\n        if columns:\n            columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n        else:\n            # Use SQLite-specific Expressions that strips table qualifiers\n            from django.db.backends.ddl_references import Expressions\n            \n            class SQLiteExpressions(Expressions):\n                def __str__(self):\n                    # Get the original column references\n                    cols = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n                    # Strip table qualifiers for SQLite\n                    return ', '.join([col.split('.')[-1] if '.' in col else col for col in cols])\n            \n            columns = SQLiteExpressions(table, expressions, compiler, self.quote_value)\n        return Statement(\n            sql,\n            table=Table(table, self.quote_name),\n            name=name,\n            columns=columns,\n            condition=self._index_condition_sql(condition),\n            deferrable=self._deferrable_constraint_sql(deferrable),\n            include=self._index_include_sql(model, include),\n        )\n",
      "\n    def _create_unique_sql(\n        self, model, fields, name=None, condition=None, deferrable=None,\n        include=None, opclasses=None, expressions=None,\n    ):\n        if (\n            (\n                deferrable and\n                not self.connection.features.supports_deferrable_unique_constraints\n            ) or\n            (condition and not self.connection.features.supports_partial_indexes) or\n            (include and not self.connection.features.supports_covering_indexes) or\n            (expressions and not self.connection.features.supports_expression_indexes)\n        ):\n            return None\n\n        def create_unique_name(*args, **kwargs):\n            return self.quote_name(self._create_index_name(*args, **kwargs))\n\n        compiler = Query(model, alias_cols=False).get_compiler(connection=self.connection)\n        table = model._meta.db_table\n        columns = [field.column for field in fields]\n        if name is None:\n            name = IndexName(table, columns, '_uniq', create_unique_name)\n        else:\n            name = self.quote_name(name)\n        if condition or include or opclasses or expressions:\n            sql = self.sql_create_unique_index\n        else:\n            sql = self.sql_create_unique\n        if columns:\n            columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n        else:\n            # Use SQLite-specific Expressions class to avoid table-qualified column names\n            from django.db.backends.sqlite3.schema import SQLiteExpressions\n            columns = SQLiteExpressions(table, expressions, compiler, self.quote_value)\n        return Statement(\n            sql,\n            table=Table(table, self.quote_name),\n            name=name,\n            columns=columns,\n            condition=self._index_condition_sql(condition),\n            deferrable=self._deferrable_constraint_sql(deferrable),\n            include=self._index_include_sql(model, include),\n        )\n",
      "\n    def _create_unique_sql(\n        self, model, fields, name=None, condition=None, deferrable=None,\n        include=None, opclasses=None, expressions=None,\n    ):\n        if (\n            (\n                deferrable and\n                not self.connection.features.supports_deferrable_unique_constraints\n            ) or\n            (condition and not self.connection.features.supports_partial_indexes) or\n            (include and not self.connection.features.supports_covering_indexes) or\n            (expressions and not self.connection.features.supports_expression_indexes)\n        ):\n            return None\n\n        def create_unique_name(*args, **kwargs):\n            return self.quote_name(self._create_index_name(*args, **kwargs))\n\n        compiler = Query(model, alias_cols=False).get_compiler(connection=self.connection)\n        table = model._meta.db_table\n        columns = [field.column for field in fields]\n        if name is None:\n            name = IndexName(table, columns, '_uniq', create_unique_name)\n        else:\n            name = self.quote_name(name)\n        if condition or include or opclasses or expressions:\n            sql = self.sql_create_unique_index\n        else:\n            sql = self.sql_create_unique\n        if columns:\n            columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n        else:\n            # Use SQLite-specific expressions that don't include table qualifiers\n            columns = SQLiteExpressions(table, expressions, compiler, self.quote_value)\n        return Statement(\n            sql,\n            table=Table(table, self.quote_name),\n            name=name,\n            columns=columns,\n            condition=self._index_condition_sql(condition),\n            deferrable=self._deferrable_constraint_sql(deferrable),\n            include=self._index_include_sql(model, include),\n        )\n\n\nclass SQLiteExpressions(Expressions):\n    def __str__(self):\n        # Generate column references without table qualifiers for SQLite\n        cols = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n        return ', '.join([self.quote_value(col) for col in cols])\n",
      "\n    def _create_unique_sql(\n        self, model, fields, name=None, condition=None, deferrable=None,\n        include=None, opclasses=None, expressions=None,\n    ):\n        if (\n            (\n                deferrable and\n                not self.connection.features.supports_deferrable_unique_constraints\n            ) or\n            (condition and not self.connection.features.supports_partial_indexes) or\n            (include and not self.connection.features.supports_covering_indexes) or\n            (expressions and not self.connection.features.supports_expression_indexes)\n        ):\n            return None\n\n        def create_unique_name(*args, **kwargs):\n            return self.quote_name(self._create_index_name(*args, **kwargs))\n\n        compiler = Query(model, alias_cols=False).get_compiler(connection=self.connection)\n        table = model._meta.db_table\n        columns = [field.column for field in fields]\n        if name is None:\n            name = IndexName(table, columns, '_uniq', create_unique_name)\n        else:\n            name = self.quote_name(name)\n        if condition or include or opclasses or expressions:\n            sql = self.sql_create_unique_index\n        else:\n            sql = self.sql_create_unique\n        if columns:\n            columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n        else:\n            # Use SQLite-specific Expressions class to avoid table-qualified column names\n            from django.db.backends.sqlite3.schema import SQLiteExpressions\n            columns = SQLiteExpressions(table, expressions, compiler, self.quote_value)\n        return Statement(\n            sql,\n            table=Table(table, self.quote_name),\n            name=name,\n            columns=columns,\n            condition=self._index_condition_sql(condition),\n            deferrable=self._deferrable_constraint_sql(deferrable),\n            include=self._index_include_sql(model, include),\n        )\n"
    ],
    "Location 3 (/root/hy/projects_2/django/django/db/backends/ddl_references.py lines 204-230)": [
      "\nclass Expressions(TableColumns):\n    def __init__(self, table, expressions, compiler, quote_value):\n        self.compiler = compiler\n        self.expressions = expressions\n        self.quote_value = quote_value\n        columns = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n        super().__init__(table, columns)\n\n    def rename_table_references(self, old_table, new_table):\n        if self.table != old_table:\n            return\n        expressions = deepcopy(self.expressions)\n        self.columns = []\n        for col in self.compiler.query._gen_cols([expressions]):\n            col.alias = new_table\n            self.columns.append(col.target.column)\n        self.expressions = expressions\n        super().rename_table_references(old_table, new_table)\n\n    def rename_column_references(self, table, old_column, new_column):\n        if self.table != table:\n            return\n        expressions = deepcopy(self.expressions)\n        self.columns = []\n        for col in self.compiler.query._gen_cols([expressions]):\n            if col.target.column == old_column:\n                col.target.column = new_column\n            self.columns.append(col.target.column)\n        self.expressions = expressions\n",
      "\nclass Expressions(TableColumns):\n    def __init__(self, table, expressions, compiler, quote_value):\n        self.compiler = compiler\n        self.expressions = expressions\n        self.quote_value = quote_value\n        columns = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n        super().__init__(table, columns)\n\n    def rename_table_references(self, old_table, new_table):\n        if self.table != old_table:\n            return\n        expressions = deepcopy(self.expressions)\n        self.columns = []\n        for col in self.compiler.query._gen_cols([expressions]):\n            col.alias = new_table\n            self.columns.append(col.target.column)\n        self.expressions = expressions\n        super().rename_table_references(old_table, new_table)\n\n    def rename_column_references(self, table, old_column, new_column):\n        if self.table != table:\n            return\n        expressions = deepcopy(self.expressions)\n        self.columns = []\n        for col in self.compiler.query._gen_cols([expressions]):\n            if col.target.column == old_column:\n                col.target.column = new_column\n            self.columns.append(col.target.column)\n        self.expressions = expressions\n",
      "\nclass SQLiteExpressions(Expressions):\n    \"\"\"\n    SQLite-specific Expressions class that generates column references \n    without table qualifiers, which SQLite doesn't allow in unique constraints.\n    \"\"\"\n    def __str__(self):\n        sql, params = self.compiler.compile(self.expressions)\n        # Remove table qualifiers from column references for SQLite\n        # This handles cases like \"table\".\"column\" -> \"column\"\n        import re\n        sql = re.sub(r'\"[^\"]+\"\\.\"([^\"]+)\"', r'\"\\1\"', sql)\n        params = map(self.quote_value, params)\n        return sql % tuple(params)\n\ndef _create_unique_sql(self, model, columns, name=None, condition=None,\n                      deferrable=None, include=None, opclasses=None, expressions=None):\n    if expressions:\n        # Use SQLite-specific Expressions class to avoid table qualifiers\n        compiler = Query(model, alias_cols=False).get_compiler(connection=self.connection)\n        expressions_instance = SQLiteExpressions(\n            Table(model._meta.db_table, self.quote_name), \n            expressions, \n            compiler, \n            self.quote_value\n        )\n        template = 'CONSTRAINT %(name)s UNIQUE (%(columns)s)%(condition)s%(deferrable)s'\n        sql = Statement(\n            template,\n            name=self.quote_name(name),\n            columns=expressions_instance,\n            condition=(' WHERE (%s)' % condition) if condition else '',\n            deferrable=self._deferrable_constraint_sql(deferrable),\n        )\n        return sql\n    else:\n        # Use parent implementation for non-expression constraints\n        return super()._create_unique_sql(\n            model, columns, name, condition, deferrable, include, opclasses, expressions\n        )\n",
      "\nclass SQLiteExpressions(Expressions):\n    \"\"\"SQLite-specific Expressions that strips table qualifiers from column names.\"\"\"\n    \n    def __init__(self, table, expressions, compiler, quote_value):\n        self.compiler = compiler\n        self.expressions = expressions\n        self.quote_value = quote_value\n        # Generate columns without table qualification for SQLite\n        columns = []\n        for col in self.compiler.query._gen_cols([self.expressions]):\n            # Strip table qualifier - only use the column name\n            column_name = col.target.column\n            if '.' in column_name:\n                column_name = column_name.split('.')[-1]\n            columns.append(column_name)\n        # Initialize TableColumns directly, bypassing Expressions.__init__\n        TableColumns.__init__(self, table, columns)\n\n    def __str__(self):\n        # Generate SQL without table qualifiers\n        sql, params = self.compiler.compile(self.expressions)\n        # Remove table qualifiers from the SQL string\n        # This handles cases where table names appear in the compiled SQL\n        if self.table and f'\"{self.table}\".' in sql:\n            sql = sql.replace(f'\"{self.table}\".', '')\n        elif self.table and f'{self.table}.' in sql:\n            sql = sql.replace(f'{self.table}.', '')\n        params = map(self.quote_value, params)\n        return sql % tuple(params)\n\n\ndef _create_unique_sql(self, model, columns, name=None, condition=None, deferrable=None, include=None, opclasses=None, expressions=None):\n    \"\"\"Override to handle expressions without table qualification for SQLite.\"\"\"\n    if expressions:\n        # Use SQLite-specific Expressions class to avoid table qualification\n        compiler = Query(model, alias_cols=False).get_compiler(connection=self.connection)\n        expressions_instance = SQLiteExpressions(\n            Table(model._meta.db_table, self.quote_name),\n            expressions,\n            compiler,\n            self.quote_value,\n        )\n        template = self.sql_create_unique_index if condition or include or opclasses else self.sql_create_unique\n        sql = Statement(\n            template,\n            table=Table(model._meta.db_table, self.quote_name),\n            name=self.quote_name(name or self._create_index_name(model._meta.db_table, [expressions_instance], suffix=\"_uniq\")),\n            columns=expressions_instance,\n            condition=(\" WHERE \" + condition) if condition else \"\",\n            deferrable=self._deferrable_constraint_sql(deferrable),\n            include=self._index_include_sql(model, include),\n            opclasses=self._index_opclasses_sql(opclasses),\n        )\n        return sql\n    else:\n        # For non-expression constraints, use the parent implementation\n        return super()._create_unique_sql(\n            model, columns, name, condition, deferrable, include, opclasses, expressions\n        )\n",
      "\nclass Expressions(TableColumns):\n    def __init__(self, table, expressions, compiler, quote_value):\n        self.compiler = compiler\n        self.expressions = expressions\n        self.quote_value = quote_value\n        columns = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n        super().__init__(table, columns)\n\n    def rename_table_references(self, old_table, new_table):\n        if self.table != old_table:\n            return\n        expressions = deepcopy(self.expressions)\n        self.columns = []\n        for col in self.compiler.query._gen_cols([expressions]):\n            col.alias = new_table\n            self.columns.append(col.target.column)\n        self.expressions = expressions\n        super().rename_table_references(old_table, new_table)\n\n    def rename_column_references(self, table, old_column, new_column):\n        if self.table != table:\n            return\n        expressions = deepcopy(self.expressions)\n        self.columns = []\n        for col in self.compiler.query._gen_cols([expressions]):\n            if col.target.column == old_column:\n                col.target.column = new_column\n            self.columns.append(col.target.column)\n        self.expressions = expressions\n",
      "\nclass SQLiteExpressions(Expressions):\n    \"\"\"\n    SQLite-specific Expressions class that generates column references without table qualifiers.\n    SQLite doesn't allow table-qualified column names in unique constraint expressions.\n    \"\"\"\n    def __str__(self):\n        sql, params = self.compiler.compile(self.expressions)\n        params = map(self.quote_value, params)\n        # Remove table qualifiers from the SQL to make it SQLite-compatible\n        # This handles cases like \"table\".\"column\" -> \"column\"\n        import re\n        sql = re.sub(r'\"[^\"]+\"\\.\"([^\"]+)\"', r'\"\\1\"', sql)\n        return sql % tuple(params)\n\n\ndef _create_unique_sql(self, model, columns, name=None, condition=None,\n                      deferrable=None, include=None, opclasses=None,\n                      expressions=None):\n    \"\"\"\n    Override to handle expressions without table qualifiers for SQLite.\n    \"\"\"\n    if expressions:\n        # Use SQLite-specific Expressions class to avoid table qualifiers\n        compiler = Query(model).get_compiler(self.connection.alias)\n        expressions_instance = SQLiteExpressions(\n            Table(model._meta.db_table, self.quote_name),\n            expressions,\n            compiler,\n            self.quote_value\n        )\n        return Statement(\n            self.sql_create_unique,\n            table=Table(model._meta.db_table, self.quote_name),\n            name=self.quote_name(name) if name else None,\n            columns=expressions_instance,\n        )\n    else:\n        # For non-expression constraints, use the base implementation\n        return super()._create_unique_sql(\n            model, columns, name, condition, deferrable, include, opclasses\n        )\n",
      "\nclass SQLiteExpressions(Expressions):\n    \"\"\"SQLite-specific Expressions that strips table qualifiers from column names.\"\"\"\n    \n    def __init__(self, table, expressions, compiler, quote_value):\n        super().__init__(table, expressions, compiler, quote_value)\n        # Strip table qualifiers from column names for SQLite compatibility\n        self.columns = [col.split('.')[-1] if '.' in col else col for col in self.columns]\n    \n    def rename_table_references(self, old_table, new_table):\n        if self.table != old_table:\n            return\n        expressions = deepcopy(self.expressions)\n        self.columns = []\n        for col in self.compiler.query._gen_cols([expressions]):\n            col.alias = new_table\n            # Strip table qualifier for SQLite\n            column_name = col.target.column.split('.')[-1] if '.' in col.target.column else col.target.column\n            self.columns.append(column_name)\n        self.expressions = expressions\n        super(Expressions, self).rename_table_references(old_table, new_table)\n    \n    def rename_column_references(self, table, old_column, new_column):\n        if self.table != table:\n            return\n        expressions = deepcopy(self.expressions)\n        self.columns = []\n        for col in self.compiler.query._gen_cols([expressions]):\n            column_name = col.target.column.split('.')[-1] if '.' in col.target.column else col.target.column\n            if column_name == old_column:\n                col.target.column = new_column\n                self.columns.append(new_column)\n            else:\n                self.columns.append(column_name)\n        self.expressions = expressions\n\ndef _create_unique_sql(self, model, columns, name=None, condition=None, deferrable=None, include=None, opclasses=None, expressions=None):\n    \"\"\"Override to use SQLite-compatible Expressions that strips table qualifiers.\"\"\"\n    if expressions:\n        compiler = Query(model, alias_cols=False).get_compiler(\n            connection=self.connection,\n        )\n        # Use SQLite-specific Expressions class\n        expressions = SQLiteExpressions(Table(model._meta.db_table, self.quote_name), expressions, compiler, self.quote_value)\n    return super()._create_unique_sql(\n        model, columns, name=name, condition=condition, deferrable=deferrable,\n        include=include, opclasses=opclasses, expressions=expressions\n    )\n",
      "\nclass Expressions(TableColumns):\n    def __init__(self, table, expressions, compiler, quote_value):\n        self.compiler = compiler\n        self.expressions = expressions\n        self.quote_value = quote_value\n        columns = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n        super().__init__(table, columns)\n\n    def rename_table_references(self, old_table, new_table):\n        if self.table != old_table:\n            return\n        expressions = deepcopy(self.expressions)\n        self.columns = []\n        for col in self.compiler.query._gen_cols([expressions]):\n            col.alias = new_table\n            self.columns.append(col.target.column)\n        self.expressions = expressions\n        super().rename_table_references(old_table, new_table)\n\n    def rename_column_references(self, table, old_column, new_column):\n        if self.table != table:\n            return\n        expressions = deepcopy(self.expressions)\n        self.columns = []\n        for col in self.compiler.query._gen_cols([expressions]):\n            if col.target.column == old_column:\n                col.target.column = new_column\n            self.columns.append(col.target.column)\n        self.expressions = expressions\n"
    ],
    "Location 4 (/root/hy/projects_2/django/django/db/backends/sqlite3/schema.py lines 421-441)": [
      "\n    def add_constraint(self, model, constraint):\n        if isinstance(constraint, UniqueConstraint) and (\n            constraint.condition or\n            constraint.contains_expressions or\n            constraint.include or\n            constraint.deferrable\n        ):\n            super().add_constraint(model, constraint)\n        else:\n            self._remake_table(model)\n\n    def remove_constraint(self, model, constraint):\n        if isinstance(constraint, UniqueConstraint) and (\n            constraint.condition or\n            constraint.contains_expressions or\n            constraint.include or\n            constraint.deferrable\n        ):\n            super().remove_constraint(model, constraint)\n        else:\n            self._remake_table(model)\n\n    def _create_unique_sql(self, model, columns, name=None, condition=None, \n                          deferrable=None, include=None, opclasses=None, expressions=None):\n        if expressions:\n            # For SQLite, create a custom Expressions handler that doesn't include table qualifiers\n            compiler = self.connection.ops.compiler('SQLCompiler')(\n                query=None, connection=self.connection, using=None\n            )\n            table = model._meta.db_table\n            \n            # Create SQLite-specific expressions without table qualification\n            sqlite_expressions = SQLiteExpressions(table, expressions, compiler, self.quote_value)\n            \n            return Statement(\n                'CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)%(condition)s%(deferrable)s',\n                table=table,\n                name=name,\n                columns=sqlite_expressions,\n                condition=' WHERE %s' % condition if condition else '',\n                deferrable=' DEFERRABLE INITIALLY DEFERRED' if deferrable else '',\n            )\n        else:\n            return super()._create_unique_sql(\n                model, columns, name=name, condition=condition,\n                deferrable=deferrable, include=include, opclasses=opclasses,\n                expressions=expressions\n            )\n\n    def _collate_sql(self, collation):\n        return 'COLLATE ' + collation\n\n\nclass SQLiteExpressions:\n    def __init__(self, table, expressions, compiler, quote_value):\n        self.table = table\n        self.expressions = expressions\n        self.compiler = compiler\n        self.quote_value = quote_value\n\n    def __str__(self):\n        # Generate column references without table qualification for SQLite\n        from django.db.backends.ddl_references import Expressions\n        \n        # Use the original Expressions to get the columns, then strip table qualifiers\n        original_expressions = Expressions(self.table, self.expressions, self.compiler, self.quote_value)\n        columns_sql = str(original_expressions)\n        \n        # Remove table qualifications (table_name.column_name -> column_name)\n        # This handles cases where the table name is quoted or unquoted\n        import re\n        table_name = self.table\n        quoted_table = self.quote_value(table_name)\n        \n        # Pattern to match both quoted and unquoted table references\n        patterns = [\n            rf'{re.escape(quoted_table)}\\.',  # \"table_name\".\n            rf'{re.escape(table_name)}\\.',    # table_name.\n        ]\n        \n        for pattern in patterns:\n            columns_sql = re.sub(pattern, '', columns_sql)\n        \n        return columns_sql\n",
      "\n    def add_constraint(self, model, constraint):\n        if isinstance(constraint, UniqueConstraint) and (\n            constraint.condition or\n            constraint.contains_expressions or\n            constraint.include or\n            constraint.deferrable\n        ):\n            super().add_constraint(model, constraint)\n        else:\n            self._remake_table(model)\n\n    def remove_constraint(self, model, constraint):\n        if isinstance(constraint, UniqueConstraint) and (\n            constraint.condition or\n            constraint.contains_expressions or\n            constraint.include or\n            constraint.deferrable\n        ):\n            super().remove_constraint(model, constraint)\n        else:\n            self._remake_table(model)\n\n    def _create_unique_sql(self, model, columns, name=None, condition=None,\n                          deferrable=None, include=None, opclasses=None,\n                          expressions=None):\n        if expressions:\n            # Use SQLite-specific expression handling to avoid table qualifiers\n            compiler = self.connection.ops.compiler('SQLCompiler')(\n                self.connection.ops.quote_name, self.connection\n            )\n            expressions_sql = SQLiteExpressions(\n                None, expressions, compiler, self.quote_value\n            ).references_column\n        else:\n            expressions_sql = None\n        \n        return super()._create_unique_sql(\n            model, columns, name, condition, deferrable, include, \n            opclasses, expressions_sql\n        )\n\n\nclass SQLiteExpressions:\n    \"\"\"SQLite-specific expressions handler that strips table qualifiers.\"\"\"\n    \n    def __init__(self, table, expressions, compiler, quote_value):\n        self.table = table\n        self.expressions = expressions\n        self.compiler = compiler\n        self.quote_value = quote_value\n\n    @property\n    def references_column(self):\n        if not self.expressions:\n            return []\n        # Generate column references without table qualifiers for SQLite\n        cols = []\n        for col in self.compiler.query._gen_cols([self.expressions]):\n            # Strip table qualifier if present\n            column_name = col.target.column\n            if '.' in column_name:\n                column_name = column_name.split('.', 1)[1]\n            cols.append(column_name)\n        return cols\n",
      "\n    def add_constraint(self, model, constraint):\n        if isinstance(constraint, UniqueConstraint) and (\n            constraint.condition or\n            constraint.contains_expressions or\n            constraint.include or\n            constraint.deferrable\n        ):\n            super().add_constraint(model, constraint)\n        else:\n            self._remake_table(model)\n\n    def remove_constraint(self, model, constraint):\n        if isinstance(constraint, UniqueConstraint) and (\n            constraint.condition or\n            constraint.contains_expressions or\n            constraint.include or\n            constraint.deferrable\n        ):\n            super().remove_constraint(model, constraint)\n        else:\n            self._remake_table(model)\n\n    def _create_unique_sql(self, model, columns, name=None, condition=None,\n                          deferrable=None, include=None, opclasses=None,\n                          expressions=None):\n        if expressions:\n            # Use SQLite-specific expressions handling to avoid table qualifiers\n            from django.db.backends.ddl_references import Columns\n            \n            class SQLiteExpressions:\n                def __init__(self, table, expressions, compiler, quote_value):\n                    self.expressions = expressions\n                    self.compiler = compiler\n                    self.quote_value = quote_value\n\n                def __str__(self):\n                    # Generate expression SQL without table qualifiers for SQLite\n                    sql_parts = []\n                    for expression in self.expressions:\n                        # Get the SQL for the expression\n                        sql, params = self.compiler.compile(expression)\n                        # Remove table qualifiers (anything before the last dot)\n                        # This handles cases like \"table\".\"column\" -> \"column\"\n                        import re\n                        sql = re.sub(r'\"[^\"]*\"\\.\"([^\"]*)\"', r'\"\\1\"', sql)\n                        sql_parts.append(sql % tuple(self.quote_value(p) for p in params))\n                    return ', '.join(sql_parts)\n\n            # Create a modified version of the base method's logic\n            compiler = model._meta.default_manager.db.ops.compiler('SQLCompiler')(\n                model._meta.default_manager.db.ops.compiler('SQLCompiler').query_class(model), \n                model._meta.default_manager.db, \n                None\n            )\n            \n            expressions_sql = SQLiteExpressions(\n                model._meta.db_table, expressions, compiler, self.quote_value\n            )\n            \n            sql = self.sql_create_unique_index if name else self.sql_create_unique\n            return Statement(\n                sql,\n                table=model._meta.db_table,\n                name=name,\n                columns=expressions_sql,\n                condition=condition,\n                deferrable=deferrable,\n                include=include,\n            )\n        else:\n            # Use parent implementation for non-expression constraints\n            return super()._create_unique_sql(\n                model, columns, name, condition, deferrable, include, opclasses\n            )\n",
      "\n    def add_constraint(self, model, constraint):\n        if isinstance(constraint, UniqueConstraint) and (\n            constraint.condition or\n            constraint.contains_expressions or\n            constraint.include or\n            constraint.deferrable\n        ):\n            super().add_constraint(model, constraint)\n        else:\n            self._remake_table(model)\n\n    def remove_constraint(self, model, constraint):\n        if isinstance(constraint, UniqueConstraint) and (\n            constraint.condition or\n            constraint.contains_expressions or\n            constraint.include or\n            constraint.deferrable\n        ):\n            super().remove_constraint(model, constraint)\n        else:\n            self._remake_table(model)\n\n    def _create_unique_sql(self, model, columns, name=None, condition=None,\n                          deferrable=None, include=None, expressions=None):\n        \"\"\"\n        Override to handle expressions without table qualification for SQLite.\n        \"\"\"\n        if expressions:\n            # Use SQLite-specific Expressions that strips table qualifiers\n            compiler = self.connection.ops.compiler('SQLCompiler')(\n                self.connection.ops.compiler('SQLCompiler').query_class(model), \n                self.connection, \n                'default'\n            )\n            expressions_sql = SQLiteExpressions(\n                model._meta.db_table, expressions, compiler, self.quote_value\n            )\n            return Statement(\n                'CREATE UNIQUE INDEX %(name)s ON %(table)s (%(expressions)s)%(condition)s',\n                name=name or self._create_index_name(model._meta.db_table, expressions, suffix='_uniq'),\n                table=Table(model._meta.db_table, self.quote_name),\n                expressions=expressions_sql,\n                condition=' WHERE ' + condition if condition else '',\n            )\n        else:\n            return super()._create_unique_sql(\n                model, columns, name, condition, deferrable, include, expressions\n            )\n\n\nclass SQLiteExpressions:\n    \"\"\"\n    SQLite-specific expressions handler that strips table qualifiers.\n    \"\"\"\n    def __init__(self, table, expressions, compiler, quote_value):\n        self.table = table\n        self.expressions = expressions\n        self.compiler = compiler\n        self.quote_value = quote_value\n\n    def __str__(self):\n        expressions_sql = []\n        for expression in self.expressions:\n            expression_sql = str(expression.resolve_expression(\n                self.compiler.query, allow_joins=False, for_save=False\n            ))\n            # Strip table qualifiers - remove 'table_name.' prefixes\n            if '.' in expression_sql and not expression_sql.startswith('\"'):\n                parts = expression_sql.split('.')\n                if len(parts) == 2:\n                    expression_sql = parts[1]  # Keep only column name\n            expressions_sql.append(expression_sql)\n        return ', '.join(expressions_sql)\n",
      "\n    def add_constraint(self, model, constraint):\n        if isinstance(constraint, UniqueConstraint) and (\n            constraint.condition or\n            constraint.contains_expressions or\n            constraint.include or\n            constraint.deferrable\n        ):\n            super().add_constraint(model, constraint)\n        else:\n            self._remake_table(model)\n\n    def remove_constraint(self, model, constraint):\n        if isinstance(constraint, UniqueConstraint) and (\n            constraint.condition or\n            constraint.contains_expressions or\n            constraint.include or\n            constraint.deferrable\n        ):\n            super().remove_constraint(model, constraint)\n        else:\n            self._remake_table(model)\n\n    def _create_unique_sql(self, model, columns, name, condition=None,\n                          deferrable=None, include=None, expressions=None):\n        if expressions:\n            # SQLite doesn't support table-qualified expressions in constraints\n            from django.db.backends.ddl_references import Expressions\n            \n            class SQLiteExpressions(Expressions):\n                def __str__(self):\n                    # Generate column references without table qualification\n                    compiler = self.compiler\n                    columns = []\n                    for expr in self.expressions:\n                        # Use the compiler to render the expression without table prefix\n                        sql, params = compiler.compile(expr)\n                        # Remove table qualifiers (anything before a dot)\n                        if '.' in sql:\n                            sql = sql.split('.')[-1]\n                        columns.append(sql)\n                    return ', '.join(columns)\n            \n            # Use our custom expressions class\n            expressions_ref = SQLiteExpressions(\n                model._meta.db_table, expressions, self.connection.ops.quote_name, self.quote_value\n            )\n            \n            return Statement(\n                'CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)%(condition)s',\n                name=name,\n                table=self.quote_name(model._meta.db_table),\n                columns=expressions_ref,\n                condition=' WHERE %s' % condition if condition else '',\n            )\n        else:\n            return super()._create_unique_sql(\n                model, columns, name, condition, deferrable, include, expressions\n            )\n",
      "\n    def add_constraint(self, model, constraint):\n        if isinstance(constraint, UniqueConstraint) and (\n            constraint.condition or\n            constraint.contains_expressions or\n            constraint.include or\n            constraint.deferrable\n        ):\n            super().add_constraint(model, constraint)\n        else:\n            self._remake_table(model)\n\n    def remove_constraint(self, model, constraint):\n        if isinstance(constraint, UniqueConstraint) and (\n            constraint.condition or\n            constraint.contains_expressions or\n            constraint.include or\n            constraint.deferrable\n        ):\n            super().remove_constraint(model, constraint)\n        else:\n            self._remake_table(model)\n\n    def _create_unique_sql(self, model, columns, name, condition=None,\n                          deferrable=None, include=None, expressions=None):\n        \"\"\"\n        Override to handle expressions without table qualification for SQLite.\n        \"\"\"\n        if expressions:\n            # Use SQLite-specific Expressions class that strips table qualifiers\n            compiler = model._meta.apps.get_app_config('contenttypes').models_module.ContentType._meta.apps._apps['django.db.models.sql.compiler'].SQLCompiler\n            from django.db import connection\n            from django.db.models.sql.query import Query\n            \n            query = Query(model)\n            compiler = connection.ops.compiler('SQLCompiler')(query, connection, 'default')\n            \n            sqlite_expressions = SQLiteExpressions(model._meta.db_table, expressions, compiler, self.quote_value)\n            \n            return Statement(\n                \"CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)%(condition)s\",\n                name=self.quote_name(name),\n                table=self.quote_name(model._meta.db_table),\n                columns=sqlite_expressions,\n                condition=' WHERE ' + condition if condition else '',\n            )\n        else:\n            return super()._create_unique_sql(model, columns, name, condition, deferrable, include, expressions)\n\n\nclass SQLiteExpressions:\n    \"\"\"\n    SQLite-specific expressions handler that strips table qualifiers.\n    \"\"\"\n    def __init__(self, table, expressions, compiler, quote_value):\n        self.table = table\n        self.expressions = expressions\n        self.compiler = compiler\n        self.quote_value = quote_value\n\n    def __str__(self):\n        expressions = []\n        for expr in self.expressions:\n            if hasattr(expr, 'target') and hasattr(expr.target, 'column'):\n                # Strip table qualifier for SQLite compatibility\n                expressions.append(self.compiler.quote_name_unless_alias(expr.target.column))\n            else:\n                # For complex expressions, compile without table prefix\n                sql, params = expr.as_sql(self.compiler, self.compiler.connection)\n                # Remove table prefix if present (format: \"table\".\"column\")\n                if '.' in sql and sql.count('\"') >= 2:\n                    parts = sql.split('.')\n                    if len(parts) == 2:\n                        sql = parts[1]  # Take only the column part\n                expressions.append(sql)\n        return ', '.join(expressions)\n",
      "\n    def add_constraint(self, model, constraint):\n        if isinstance(constraint, UniqueConstraint) and (\n            constraint.condition or\n            constraint.contains_expressions or\n            constraint.include or\n            constraint.deferrable\n        ):\n            super().add_constraint(model, constraint)\n        else:\n            self._remake_table(model)\n\n    def remove_constraint(self, model, constraint):\n        if isinstance(constraint, UniqueConstraint) and (\n            constraint.condition or\n            constraint.contains_expressions or\n            constraint.include or\n            constraint.deferrable\n        ):\n            super().remove_constraint(model, constraint)\n        else:\n            self._remake_table(model)\n\n    def _create_unique_sql(self, model, columns, name=None, condition=None,\n                          deferrable=None, include=None, opclasses=None):\n        \"\"\"\n        Override to handle expressions without table qualification for SQLite.\n        \"\"\"\n        from django.db.backends.ddl_references import Expressions\n        \n        class SQLiteExpressions(Expressions):\n            def __str__(self):\n                # Get the base column references\n                cols = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n                # Return only column names without table qualification for SQLite\n                return ', '.join(self.compiler.quote_name_unless_alias(col) for col in cols)\n        \n        if any(hasattr(col, 'target') for col in columns):\n            # Use SQLite-specific expressions handling for expression columns\n            compiler = self.connection.ops.compiler('SQLCompiler')(\n                query=self.connection.ops.select_compiler('SQLCompiler').query_class(model),\n                connection=self.connection,\n                using=None\n            )\n            expressions = SQLiteExpressions(None, columns, compiler, self.quote_value)\n            columns_sql = str(expressions)\n        else:\n            # Regular column names\n            columns_sql = ', '.join(self.quote_name(column) for column in columns)\n        \n        sql = self.sql_create_unique % {\n            'table': self.quote_name(model._meta.db_table),\n            'name': self.quote_name(name),\n            'columns': columns_sql,\n        }\n        \n        if condition:\n            sql += ' WHERE ' + condition\n            \n        return Statement(sql, [], [])\n",
      "\n    def add_constraint(self, model, constraint):\n        if isinstance(constraint, UniqueConstraint) and (\n            constraint.condition or\n            constraint.contains_expressions or\n            constraint.include or\n            constraint.deferrable\n        ):\n            super().add_constraint(model, constraint)\n        else:\n            self._remake_table(model)\n\n    def remove_constraint(self, model, constraint):\n        if isinstance(constraint, UniqueConstraint) and (\n            constraint.condition or\n            constraint.contains_expressions or\n            constraint.include or\n            constraint.deferrable\n        ):\n            super().remove_constraint(model, constraint)\n        else:\n            self._remake_table(model)\n\n    def _create_unique_sql(self, model, columns, name=None, condition=None,\n                          deferrable=None, include=None, opclasses=None):\n        if condition or include or opclasses:\n            # Use SQLite-specific expressions handling for complex constraints\n            from django.db.backends.ddl_references import Expressions\n            \n            class SQLiteExpressions(Expressions):\n                def __str__(self):\n                    # Get the base column references without table qualification\n                    cols = []\n                    for col in self.compiler.query._gen_cols([self.expressions]):\n                        # Strip table name from column reference for SQLite\n                        if hasattr(col.target, 'column'):\n                            cols.append(col.target.column)\n                        else:\n                            cols.append(str(col))\n                    return ', '.join(self.compiler.quote_name_unless_alias(col) for col in cols)\n            \n            # Replace the expressions class temporarily\n            original_expressions_class = self.connection.ops.__class__.sql_create_unique_index\n            try:\n                return super()._create_unique_sql(model, columns, name, condition, deferrable, include, opclasses)\n            finally:\n                pass\n        else:\n            return super()._create_unique_sql(model, columns, name, condition, deferrable, include, opclasses)\n"
    ],
    "Location 5 (/root/hy/projects_2/django/django/db/backends/sqlite3/schema.py lines 444-444)": [
      "\n    def _collate_sql(self, collation):\n        return 'COLLATE ' + collation\n\n    def _create_unique_sql(self, model, columns, name, condition=None,\n                          deferrable=None, include=None, expressions=None):\n        \"\"\"\n        Override to handle expressions without table qualification for SQLite.\n        SQLite doesn't allow table-qualified column names in unique constraint expressions.\n        \"\"\"\n        if expressions:\n            # Use SQLite-specific Expressions class that strips table qualifiers\n            expressions_sql = SQLiteExpressions(\n                model._meta.db_table, expressions, self.connection.ops.quote_name, self.quote_value\n            )\n            sql = self._create_unique_constraint_sql(\n                model, columns, name, condition, deferrable, include, expressions_sql\n            )\n        else:\n            # Use parent implementation for non-expression constraints\n            sql = super()._create_unique_sql(\n                model, columns, name, condition, deferrable, include, expressions\n            )\n        return sql\n\n\nclass SQLiteExpressions(Statement):\n    \"\"\"\n    SQLite-specific Expressions class that generates column references \n    without table qualification to avoid SQLite syntax errors.\n    \"\"\"\n    def __init__(self, table, expressions, compiler, quote_value):\n        self.table = table\n        self.expressions = expressions\n        self.compiler = compiler\n        self.quote_value = quote_value\n\n    def __str__(self):\n        # Generate expressions without table qualification for SQLite\n        expressions_sql = []\n        for expression in self.expressions:\n            if hasattr(expression, 'target') and hasattr(expression.target, 'column'):\n                # Direct column reference - use only column name\n                expressions_sql.append(self.compiler(expression.target.column))\n            else:\n                # Complex expression - let SQLite handle it\n                expressions_sql.append(str(expression))\n        return ', '.join(expressions_sql)\n",
      "\n    def _collate_sql(self, collation):\n        return 'COLLATE ' + collation\n\n    def _create_unique_sql(self, model, columns, name, condition, deferrable, include, opclasses):\n        \"\"\"\n        Override to handle expressions in unique constraints for SQLite.\n        SQLite doesn't allow table-qualified column names in constraint expressions.\n        \"\"\"\n        if not any(hasattr(col, 'target') for col in columns):\n            # No expressions, use parent implementation\n            return super()._create_unique_sql(model, columns, name, condition, deferrable, include, opclasses)\n        \n        # Handle expressions by creating SQLite-compatible SQL\n        compiler = self.connection.ops.compiler('SQLCompiler')(\n            self.connection.ops.compiler('SQLCompiler').query_class(model), self.connection, 'default'\n        )\n        \n        # Use SQLite-specific Expressions class that strips table qualifiers\n        expressions = SQLiteExpressions(model._meta.db_table, columns, compiler, self.quote_value)\n        return Statement(\n            self.sql_create_unique,\n            table=Table(model._meta.db_table, self.quote_name),\n            name=self.quote_name(name),\n            columns=expressions,\n        )\n\n\nclass SQLiteExpressions:\n    \"\"\"\n    SQLite-specific expressions handler that strips table qualifiers from column names.\n    This prevents SQLite errors when using table-qualified column names in constraints.\n    \"\"\"\n    def __init__(self, table, expressions, compiler, quote_value):\n        self.table = table\n        self.expressions = expressions\n        self.compiler = compiler\n        self.quote_value = quote_value\n\n    def __str__(self):\n        # Generate column list without table qualifiers for SQLite compatibility\n        cols = []\n        for col in self.expressions:\n            if hasattr(col, 'target'):\n                # This is an expression-based column, get just the column name\n                cols.append(col.target.column)\n            else:\n                # Regular column name\n                cols.append(col)\n        return ', '.join(self.quote_value(col) for col in cols)\n",
      "\n    def _collate_sql(self, collation):\n        return 'COLLATE ' + collation\n\n    def _create_unique_sql(self, model, columns, name=None, condition=None,\n                          deferrable=None, include=None, expressions=None):\n        if expressions:\n            # SQLite doesn't support table-qualified column names in expressions\n            # Create a custom Expressions class that strips table qualifiers\n            class SQLiteExpressions(Expressions):\n                def __str__(self):\n                    # Get the base expression string\n                    base_str = super().__str__()\n                    # Remove table qualifiers (table_name.column_name -> column_name)\n                    table_name = self.table._meta.db_table\n                    qualified_prefix = f'\"{table_name}\".'\n                    return base_str.replace(qualified_prefix, '')\n            \n            # Use our custom Expressions class\n            compiler = self.connection.ops.compiler('SQLCompiler')(\n                self.connection.ops.query_class(model), self.connection, 'default'\n            )\n            expressions_sql = SQLiteExpressions(model._meta.db_table, expressions, compiler, self.quote_value)\n            \n            # Build the constraint SQL manually for SQLite\n            sql = self.sql_create_unique_index if name else self.sql_create_unique\n            table_sql = Table(model._meta.db_table, self.quote_name)\n            name_sql = self.quote_name(name) if name else None\n            \n            return Statement(\n                sql,\n                table=table_sql,\n                name=name_sql,\n                columns=expressions_sql,\n                condition=' WHERE ' + condition if condition else '',\n            )\n        else:\n            # For non-expression constraints, use the parent implementation\n            return super()._create_unique_sql(\n                model, columns, name, condition, deferrable, include, expressions\n            )\n",
      "\n    def _collate_sql(self, collation):\n        return 'COLLATE ' + collation\n\n    def _create_unique_sql(self, model, columns, name=None, condition=None,\n                          deferrable=None, include=None, opclasses=None, expressions=None):\n        \"\"\"\n        Override to handle SQLite's restriction on table-qualified column names\n        in unique constraint expressions.\n        \"\"\"\n        if expressions:\n            # Use SQLite-specific Expressions class that strips table qualifiers\n            compiler = self.connection.ops.compiler('SQLCompiler')(\n                query=None, connection=self.connection, using=None\n            )\n            expressions_sql = SQLiteExpressions(\n                model._meta.db_table, expressions, compiler, self.quote_value\n            )\n            sql = self._create_unique_constraint_sql(\n                model, None, name, condition, deferrable, include, opclasses, expressions_sql\n            )\n        else:\n            sql = super()._create_unique_sql(\n                model, columns, name, condition, deferrable, include, opclasses, expressions\n            )\n        return sql\n\n\nclass SQLiteExpressions:\n    \"\"\"\n    SQLite-specific version of Expressions that strips table qualifiers\n    from column references to avoid SQLite's restriction on qualified names\n    in constraint expressions.\n    \"\"\"\n    def __init__(self, table, expressions, compiler, quote_value):\n        self.table = table\n        self.expressions = expressions\n        self.compiler = compiler\n        self.quote_value = quote_value\n\n    def __str__(self):\n        # Generate expression SQL without table qualifiers\n        sql_parts = []\n        for expression in self.expressions:\n            if hasattr(expression, 'resolve_expression'):\n                # Handle F expressions and other complex expressions\n                resolved = expression.resolve_expression()\n                if hasattr(resolved, 'target') and hasattr(resolved.target, 'column'):\n                    # Simple column reference - use just the column name\n                    sql_parts.append(self.quote_value(resolved.target.column))\n                else:\n                    # Complex expression - convert to SQL and strip table qualifiers\n                    expr_sql = str(resolved)\n                    # Remove table qualifications like \"table\".\"column\" -> \"column\"\n                    import re\n                    expr_sql = re.sub(r'\"[^\"]+\"\\.\"([^\"]+)\"', r'\"\\1\"', expr_sql)\n                    sql_parts.append(expr_sql)\n            else:\n                # Handle string expressions or other types\n                sql_parts.append(str(expression))\n        \n        return '(%s)' % ', '.join(sql_parts)\n",
      "\n    def _collate_sql(self, collation):\n        return 'COLLATE ' + collation\n\n    def _create_unique_sql(self, model, columns, name=None, condition=None,\n                          deferrable=None, include=None, opclasses=None, expressions=None):\n        if expressions:\n            # Use SQLite-specific Expressions class that strips table qualifiers\n            from django.db.backends.ddl_references import Expressions\n            \n            class SQLiteExpressions(Expressions):\n                def __str__(self):\n                    # Generate expressions without table qualification for SQLite\n                    expressions_sql = []\n                    for expression in self.expressions:\n                        if hasattr(expression, 'target') and hasattr(expression.target, 'column'):\n                            # Simple column reference - use column name only\n                            expressions_sql.append(self.compiler.quote_name_unless_alias(expression.target.column))\n                        else:\n                            # Complex expression - compile normally but may need table stripping\n                            sql, params = expression.as_sql(self.compiler, self.compiler.connection)\n                            # Strip table qualifiers from the SQL\n                            table_name = self.compiler.quote_name_unless_alias(self.table.table_name)\n                            sql = sql.replace(f'{table_name}.', '')\n                            expressions_sql.append(sql % tuple(self.quote_value(p) for p in params))\n                    return ', '.join(expressions_sql)\n            \n            # Create table reference for expressions\n            table = self._get_table_reference(model)\n            expressions_obj = SQLiteExpressions(table, expressions, self.sql_create_unique.compiler(self.connection), self.quote_value)\n            \n            # Build the unique constraint SQL\n            sql = self.sql_create_unique_index.format(\n                name=self.quote_name(name or self._create_index_name(model._meta.db_table, [col.name for col in columns] if columns else [], '_uniq')),\n                table=self.quote_name(model._meta.db_table),\n                columns=expressions_obj,\n                condition=' WHERE ' + condition if condition else '',\n            )\n            return Statement(sql, table=table)\n        else:\n            # Use parent implementation for non-expression constraints\n            return super()._create_unique_sql(model, columns, name, condition, deferrable, include, opclasses, expressions)\n",
      "\n    def _collate_sql(self, collation):\n        return 'COLLATE ' + collation\n\n    def _create_unique_sql(self, model, columns, name=None, condition=None,\n                          deferrable=None, include=None, opclasses=None, expressions=None):\n        \"\"\"\n        Override to handle expressions without table qualification for SQLite.\n        SQLite doesn't support table-qualified column names in constraint expressions.\n        \"\"\"\n        if expressions:\n            # Use SQLite-specific Expressions class that strips table qualifiers\n            compiler = self.connection.ops.compiler('SQLCompiler')(\n                self.connection.ops.query_class(model), self.connection, 'default'\n            )\n            expressions_sql = SQLiteExpressions(\n                model._meta.db_table, expressions, compiler, self.quote_value\n            )\n            sql = self._unique_sql(\n                model, None, name, expressions=expressions_sql,\n                condition=condition, deferrable=deferrable, include=include\n            )\n        else:\n            sql = super()._create_unique_sql(\n                model, columns, name, condition, deferrable, include, opclasses, expressions\n            )\n        return sql\n\n\nclass SQLiteExpressions:\n    \"\"\"\n    SQLite-specific version of Expressions that strips table qualifiers\n    from column references to avoid SQLite syntax errors.\n    \"\"\"\n    def __init__(self, table, expressions, compiler, quote_value):\n        self.table = table\n        self.expressions = expressions\n        self.compiler = compiler\n        self.quote_value = quote_value\n\n    def __str__(self):\n        # Generate expressions without table qualification\n        sql_parts = []\n        for expression in self.expressions:\n            # Use the compiler to generate SQL but strip table qualifiers\n            sql, params = expression.as_sql(self.compiler, self.compiler.connection)\n            # Remove table qualifiers (e.g., \"table\".\"column\" -> \"column\")\n            sql = sql.replace(f'\"{self.table}\".', '').replace(f'{self.table}.', '')\n            sql_parts.append(sql % tuple(self.quote_value(p) for p in params))\n        return '(%s)' % ', '.join(sql_parts)\n",
      "\n    def _collate_sql(self, collation):\n        return 'COLLATE ' + collation\n\n    def _create_unique_sql(self, model, columns, name=None, condition=None,\n                          deferrable=None, include=None, opclasses=None,\n                          expressions=None):\n        if expressions:\n            # SQLite doesn't support table-qualified column names in constraint expressions\n            # Use a custom Expressions class that strips table qualifiers\n            compiler = self.connection.ops.compiler('SQLCompiler')(\n                self.connection.ops.quote_name, self.connection\n            )\n            expressions_sql = SQLiteExpressions(\n                model._meta.db_table, expressions, compiler, self.quote_value\n            )\n            sql = self._create_unique_name(model, columns, name)\n            return Statement(\n                \"CREATE UNIQUE INDEX %(name)s ON %(table)s (%(expressions)s)%(condition)s\",\n                name=sql,\n                table=Table(model._meta.db_table, self.quote_name),\n                expressions=expressions_sql,\n                condition=' WHERE ' + condition if condition else '',\n            )\n        return super()._create_unique_sql(\n            model, columns, name, condition, deferrable, include, opclasses, expressions\n        )\n\n\nclass SQLiteExpressions(Statement):\n    def __init__(self, table, expressions, compiler, quote_value):\n        self.table = table\n        self.expressions = expressions\n        self.compiler = compiler\n        self.quote_value = quote_value\n\n    def __str__(self):\n        # Generate column references without table qualification for SQLite\n        cols = []\n        for expression in self.expressions:\n            if hasattr(expression, 'target') and hasattr(expression.target, 'column'):\n                # Simple column reference - use just the column name\n                cols.append(self.compiler.quote_name_unless_alias(expression.target.column))\n            else:\n                # Complex expression - compile it normally but strip table qualifiers\n                sql, params = expression.as_sql(self.compiler, self.compiler.connection)\n                # Remove table qualifications like \"table\".\"column\" -> \"column\"\n                import re\n                sql = re.sub(r'\"[^\"]+\"\\.\"([^\"]+)\"', r'\"\\1\"', sql)\n                cols.append(sql)\n        return ', '.join(cols)\n",
      "\n    def _collate_sql(self, collation):\n        return 'COLLATE ' + collation\n\n    def _create_unique_sql(self, model, columns, name, condition=None,\n                          deferrable=None, include=None, expressions=None):\n        if expressions:\n            # SQLite doesn't support table-qualified column names in constraints\n            # Use custom SQLiteExpressions to strip table qualifiers\n            compiler = self._get_index_tablespace_sql(model, None, inline=True)\n            table = Table(model._meta.db_table, self.quote_name)\n            expressions_sql = SQLiteExpressions(table, expressions, compiler, self.quote_value)\n            sql = self._create_index_sql(\n                model, fields=None, name=name, suffix=\"\",\n                using=None, db_tablespace=None, col_suffixes=(),\n                sql=self.sql_create_unique_index, opclasses=(),\n                condition=condition, include=include, expressions=expressions_sql,\n            )\n            return sql\n        return super()._create_unique_sql(\n            model, columns, name, condition, deferrable, include, expressions\n        )\n\n\nclass SQLiteExpressions(Expressions):\n    \"\"\"SQLite-specific expressions that strip table qualifiers from column names.\"\"\"\n    \n    def __str__(self):\n        expressions = []\n        for expression in self.expressions:\n            expressions.append(\n                expression.resolve_expression(\n                    self.compiler.query, allow_joins=False, reuse=None\n                ).as_sql(self.compiler, self.compiler.connection)[0]\n            )\n        # Strip table qualifiers - remove \"table_name.\" prefixes\n        cleaned_expressions = []\n        for expr in expressions:\n            # Remove table qualifiers like \"myapp_mymodel.\" from column references\n            if '.' in expr and not expr.startswith('\"'):\n                # Simple case: table.column -> column\n                parts = expr.split('.')\n                if len(parts) == 2:\n                    cleaned_expressions.append(parts[1])\n                else:\n                    cleaned_expressions.append(expr)\n            else:\n                cleaned_expressions.append(expr)\n        return ', '.join(cleaned_expressions)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 412fb46f16..daeef91ae4 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -1243,6 +1243,7 @@ class BaseDatabaseSchemaEditor:\n             'constraint': constraint,\n         }\n \n+\n     def _create_unique_sql(\n         self, model, fields, name=None, condition=None, deferrable=None,\n         include=None, opclasses=None, expressions=None,\ndiff --git a/django/db/backends/ddl_references.py b/django/db/backends/ddl_references.py\nindex c06386a2fa..ae3e2e3e32 100644\n--- a/django/db/backends/ddl_references.py\n+++ b/django/db/backends/ddl_references.py\n@@ -201,6 +201,7 @@ class Statement(Reference):\n         return self.template % self.parts\n \n \n+\n class Expressions(TableColumns):\n     def __init__(self, table, expressions, compiler, quote_value):\n         self.compiler = compiler\ndiff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py\nindex f0c81c123b..b724f9c5d7 100644\n--- a/django/db/backends/sqlite3/schema.py\n+++ b/django/db/backends/sqlite3/schema.py\n@@ -298,6 +298,7 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n             disable_constraints=False,\n         )\n \n+\n         # Run deferred SQL on correct table\n         for sql in self.deferred_sql:\n             self.execute(sql)\n@@ -418,6 +419,7 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         # Delete the old through table\n         self.delete_model(old_field.remote_field.through)\n \n+\n     def add_constraint(self, model, constraint):\n         if isinstance(constraint, UniqueConstraint) and (\n             constraint.condition or\n@@ -441,4 +443,62 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n             self._remake_table(model)\n \n     def _collate_sql(self, collation):\n+\n         return 'COLLATE ' + collation\n+\n+    class SQLiteExpressions(Expressions):\n+        def __str__(self):\n+            sql, params = self.compiler.compile(self.expressions)\n+            # Remove table qualifiers from the SQL to avoid \".\" operator in SQLite index expressions\n+            # Replace \"table\".\"column\" with just \"column\"\n+            import re\n+            sql = re.sub(r'\"[^\"]+\"\\.\"([^\"]+)\"', r'\"\\1\"', sql)\n+            params = map(self.quote_value, params)\n+            return sql % tuple(params)\n+\n+    def _create_unique_sql(\n+        self, model, fields, name=None, condition=None, deferrable=None,\n+        include=None, opclasses=None, expressions=None,\n+    ):\n+        if (\n+            (\n+                deferrable and\n+                not self.connection.features.supports_deferrable_unique_constraints\n+            ) or\n+            (condition and not self.connection.features.supports_partial_indexes) or\n+            (include and not self.connection.features.supports_covering_indexes) or\n+            (expressions and not self.connection.features.supports_expression_indexes)\n+        ):\n+            return None\n+\n+        def create_unique_name(*args, **kwargs):\n+            return self.quote_name(self._create_index_name(*args, **kwargs))\n+\n+        from django.db.models.sql import Query\n+        from django.db.backends.ddl_references import IndexName, Table\n+\n+        compiler = Query(model, alias_cols=False).get_compiler(connection=self.connection)\n+        table = model._meta.db_table\n+        columns = [field.column for field in fields]\n+        if name is None:\n+            name = IndexName(table, columns, '_uniq', create_unique_name)\n+        else:\n+            name = self.quote_name(name)\n+        if condition or include or opclasses or expressions:\n+            sql = self.sql_create_unique_index\n+        else:\n+            sql = self.sql_create_unique\n+        if columns:\n+            columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n+        else:\n+            # Use SQLite-specific Expressions class that strips table qualifiers\n+            columns = self.SQLiteExpressions(table, expressions, compiler, self.quote_value)\n+        return Statement(\n+            sql,\n+            table=Table(table, self.quote_name),\n+            name=name,\n+            columns=columns,\n+            condition=self._index_condition_sql(condition),\n+            deferrable=self._deferrable_constraint_sql(deferrable),\n+            include=self._index_include_sql(model, include),\n+        )\n",
    "variant_0": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 412fb46f16..764b20d936 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -1243,6 +1243,7 @@ class BaseDatabaseSchemaEditor:\n             'constraint': constraint,\n         }\n \n+\n     def _create_unique_sql(\n         self, model, fields, name=None, condition=None, deferrable=None,\n         include=None, opclasses=None, expressions=None,\n@@ -1275,7 +1276,8 @@ class BaseDatabaseSchemaEditor:\n         if columns:\n             columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n         else:\n-            columns = Expressions(table, expressions, compiler, self.quote_value)\n+            # Use SQLite-specific Expressions class that strips table qualifiers\n+            columns = SQLiteExpressions(table, expressions, compiler, self.quote_value)\n         return Statement(\n             sql,\n             table=Table(table, self.quote_name),\n@@ -1286,6 +1288,19 @@ class BaseDatabaseSchemaEditor:\n             include=self._index_include_sql(model, include),\n         )\n \n+\n+class SQLiteExpressions(Expressions):\n+    \"\"\"SQLite-specific Expressions class that strips table qualifiers from column references.\"\"\"\n+    \n+    def __str__(self):\n+        expressions_sql = []\n+        for expression in self.expressions:\n+            expression_sql = str(expression.resolve_expression(\n+                Query(self.table, alias_cols=False), allow_joins=False, reuse=None, summarize=False\n+            ).as_sql(self.compiler, self.connection)[0])\n+            expressions_sql.append(expression_sql)\n+        return ', '.join(expressions_sql)\n+\n     def _delete_unique_sql(\n         self, model, name, condition=None, deferrable=None, include=None,\n         opclasses=None, expressions=None,\ndiff --git a/django/db/backends/ddl_references.py b/django/db/backends/ddl_references.py\nindex c06386a2fa..cc36966b79 100644\n--- a/django/db/backends/ddl_references.py\n+++ b/django/db/backends/ddl_references.py\n@@ -201,33 +201,39 @@ class Statement(Reference):\n         return self.template % self.parts\n \n \n-class Expressions(TableColumns):\n-    def __init__(self, table, expressions, compiler, quote_value):\n-        self.compiler = compiler\n-        self.expressions = expressions\n-        self.quote_value = quote_value\n-        columns = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n-        super().__init__(table, columns)\n-\n-    def rename_table_references(self, old_table, new_table):\n-        if self.table != old_table:\n-            return\n-        expressions = deepcopy(self.expressions)\n-        self.columns = []\n-        for col in self.compiler.query._gen_cols([expressions]):\n-            col.alias = new_table\n-        self.expressions = expressions\n-        super().rename_table_references(old_table, new_table)\n \n-    def rename_column_references(self, table, old_column, new_column):\n-        if self.table != table:\n-            return\n-        expressions = deepcopy(self.expressions)\n-        self.columns = []\n-        for col in self.compiler.query._gen_cols([expressions]):\n-            if col.target.column == old_column:\n-                col.target.column = new_column\n-            self.columns.append(col.target.column)\n+class SQLiteExpressions(Expressions):\n+    def __init__(self, table, expressions, compiler, quote_value):\n+        super().__init__(table, expressions, compiler, quote_value)\n+        # Strip table qualifiers from column names for SQLite compatibility\n+        self.columns = [col.split('.')[-1] if '.' in col else col for col in self.columns]\n+\n+def _create_unique_sql(self, model, columns, name=None, condition=None,\n+                      deferrable=None, include=None, opclasses=None,\n+                      expressions=None):\n+    if expressions:\n+        # Use SQLite-specific Expressions class to avoid table qualifiers\n+        compiler = Query(model, alias_cols=False).get_compiler(connection=self.connection)\n+        expressions_part = SQLiteExpressions(\n+            Table(model._meta.db_table, self.quote_name),\n+            expressions,\n+            compiler,\n+            self.quote_value\n+        )\n+        template = 'CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)%(condition)s'\n+        sql = Statement(\n+            template,\n+            name=self._create_index_name(model._meta.db_table, [None], suffix=''),\n+            table=Table(model._meta.db_table, self.quote_name),\n+            columns=expressions_part,\n+            condition=' WHERE %s' % condition if condition else '',\n+        )\n+        return sql\n+    else:\n+        # Use parent implementation for non-expression constraints\n+        return super()._create_unique_sql(\n+            model, columns, name, condition, deferrable, include, opclasses, expressions\n+        )\n         self.expressions = expressions\n \n     def __str__(self):\ndiff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py\nindex f0c81c123b..946ad2fa8c 100644\n--- a/django/db/backends/sqlite3/schema.py\n+++ b/django/db/backends/sqlite3/schema.py\n@@ -298,10 +298,51 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n             disable_constraints=False,\n         )\n \n-        # Run deferred SQL on correct table\n-        for sql in self.deferred_sql:\n-            self.execute(sql)\n-        self.deferred_sql = []\n+\n+    def _create_unique_sql(self, model, columns, name=None, condition=None, deferrable=None, include=None, opclasses=None):\n+        \"\"\"\n+        Override to handle expressions in unique constraints for SQLite.\n+        SQLite doesn't allow table-qualified column names in constraint expressions.\n+        \"\"\"\n+        if not any(hasattr(col, 'target') for col in columns):\n+            # No expressions, use the standard implementation\n+            return super()._create_unique_sql(model, columns, name, condition, deferrable, include, opclasses)\n+        \n+        # Handle expressions by using unqualified column names\n+        compiler = self.connection.ops.compiler('SQLCompiler')(\n+            self.connection.ops.compiler('SQLCompiler').query_class(model), self.connection, None\n+        )\n+        \n+        # Create SQLite-specific expressions handler\n+        expressions = SQLiteExpressions(model._meta.db_table, columns, compiler, self.quote_value)\n+        \n+        return self._create_unique_sql_for_field(\n+            model, columns, name, condition, deferrable, include, opclasses, expressions\n+        )\n+\n+\n+class SQLiteExpressions:\n+    \"\"\"\n+    SQLite-specific expressions handler that avoids table-qualified column names\n+    in constraint definitions.\n+    \"\"\"\n+    def __init__(self, table, expressions, compiler, quote_value):\n+        self.table = table\n+        self.expressions = expressions\n+        self.compiler = compiler\n+        self.quote_value = quote_value\n+\n+    def __str__(self):\n+        sql = []\n+        for col in self.compiler.query._gen_cols([self.expressions]):\n+            # Strip table qualification for SQLite\n+            column_name = col.target.column\n+            if hasattr(col, 'output_field') and hasattr(col.output_field, 'get_col'):\n+                # Handle expression columns by getting just the column name\n+                sql.append(self.quote_value(column_name))\n+            else:\n+                sql.append(self.quote_value(column_name))\n+        return ', '.join(sql)\n         # Fix any PK-removed field\n         if restore_pk_field:\n             restore_pk_field.primary_key = True\n@@ -418,6 +459,7 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         # Delete the old through table\n         self.delete_model(old_field.remote_field.through)\n \n+\n     def add_constraint(self, model, constraint):\n         if isinstance(constraint, UniqueConstraint) and (\n             constraint.condition or\n@@ -440,5 +482,94 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         else:\n             self._remake_table(model)\n \n+    def _create_unique_sql(self, model, columns, name=None, condition=None,\n+                          deferrable=None, include=None, opclasses=None,\n+                          expressions=None):\n+        \"\"\"\n+        Override to handle expression-based unique constraints for SQLite.\n+        SQLite doesn't support table-qualified column names in constraint expressions.\n+        \"\"\"\n+        from django.db.backends.ddl_references import Expressions\n+        \n+        class SQLiteExpressions(Expressions):\n+            def __str__(self):\n+                # Get the original expression string\n+                original = super().__str__()\n+                # Remove table qualifiers (table_name.column_name -> column_name)\n+                # This handles the case where expressions contain table-qualified column names\n+                table_name = self.quote_name(self.table)\n+                qualified_prefix = f\"{table_name}.\"\n+                return original.replace(qualified_prefix, \"\")\n+        \n+        if expressions:\n+            # Use our custom Expressions class for SQLite\n+            compiler = self.connection.ops.compiler('SQLCompiler')(\n+                self.connection.ops.quote_name, self.connection\n+            )\n+            expressions_obj = SQLiteExpressions(\n+                model._meta.db_table, expressions, compiler, self.quote_value\n+            )\n+            return Statement(\n+                self.sql_create_unique_index,\n+                table=model._meta.db_table,\n+                name=name,\n+                columns=expressions_obj,\n+                condition=condition and ' WHERE %s' % condition,\n+                deferrable=deferrable,\n+                include=include and ' INCLUDE (%s)' % ', '.join(include),\n+                opclasses=opclasses,\n+            )\n+        else:\n+            # For non-expression constraints, use the base implementation\n+            return super()._create_unique_sql(\n+                model, columns, name, condition, deferrable, include, opclasses, expressions\n+            )\n+\n+    def _collate_sql(self, collation):\n+\n     def _collate_sql(self, collation):\n         return 'COLLATE ' + collation\n+\n+    def _create_unique_sql(self, model, columns, name=None, condition=None,\n+                          deferrable=None, include=None, opclasses=None,\n+                          expressions=None):\n+        if expressions:\n+            # SQLite doesn't support table-qualified column names in unique constraints\n+            # Use a custom Expressions class that strips table qualifiers\n+            compiler = self.connection.ops.compiler('SQLCompiler')(\n+                self.connection.ops.compiler('SQLCompiler').query_class(model), self.connection, None\n+            )\n+            expressions_sql = SQLiteExpressions(\n+                model._meta.db_table, expressions, compiler, self.quote_value\n+            )\n+            columns = [expressions_sql]\n+        \n+        return super()._create_unique_sql(\n+            model, columns, name, condition, deferrable, include, opclasses\n+        )\n+\n+\n+class SQLiteExpressions:\n+    \"\"\"\n+    SQLite-specific expressions class that generates column references\n+    without table qualifiers for use in unique constraints.\n+    \"\"\"\n+    def __init__(self, table, expressions, compiler, quote_value):\n+        self.table = table\n+        self.expressions = expressions\n+        self.compiler = compiler\n+        self.quote_value = quote_value\n+\n+    def __str__(self):\n+        # Generate column names without table qualifiers for SQLite\n+        columns = []\n+        for expression in self.expressions:\n+            if hasattr(expression, 'target') and hasattr(expression.target, 'column'):\n+                # This is a column reference, use only the column name\n+                columns.append(self.quote_value(expression.target.column))\n+            else:\n+                # For other expressions, compile them normally\n+                # This handles cases like functions, literals, etc.\n+                sql, params = expression.as_sql(self.compiler, self.compiler.connection)\n+                columns.append(sql % params if params else sql)\n+        return ', '.join(columns)\n",
    "variant_1": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 412fb46f16..2635d273d3 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -1243,6 +1243,7 @@ class BaseDatabaseSchemaEditor:\n             'constraint': constraint,\n         }\n \n+\n     def _create_unique_sql(\n         self, model, fields, name=None, condition=None, deferrable=None,\n         include=None, opclasses=None, expressions=None,\n@@ -1275,7 +1276,9 @@ class BaseDatabaseSchemaEditor:\n         if columns:\n             columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n         else:\n-            columns = Expressions(table, expressions, compiler, self.quote_value)\n+            # For SQLite, use custom Expressions class to avoid table qualifiers\n+            from django.db.backends.sqlite3.schema import SQLiteExpressions\n+            columns = SQLiteExpressions(table, expressions, compiler, self.quote_value)\n         return Statement(\n             sql,\n             table=Table(table, self.quote_name),\ndiff --git a/django/db/backends/ddl_references.py b/django/db/backends/ddl_references.py\nindex c06386a2fa..107064855c 100644\n--- a/django/db/backends/ddl_references.py\n+++ b/django/db/backends/ddl_references.py\n@@ -201,6 +201,7 @@ class Statement(Reference):\n         return self.template % self.parts\n \n \n+\n class Expressions(TableColumns):\n     def __init__(self, table, expressions, compiler, quote_value):\n         self.compiler = compiler\n@@ -216,6 +217,7 @@ class Expressions(TableColumns):\n         self.columns = []\n         for col in self.compiler.query._gen_cols([expressions]):\n             col.alias = new_table\n+            self.columns.append(col.target.column)\n         self.expressions = expressions\n         super().rename_table_references(old_table, new_table)\n \n@@ -229,6 +231,7 @@ class Expressions(TableColumns):\n                 col.target.column = new_column\n             self.columns.append(col.target.column)\n         self.expressions = expressions\n+        self.expressions = expressions\n \n     def __str__(self):\n         sql, params = self.compiler.compile(self.expressions)\ndiff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py\nindex f0c81c123b..531ed92970 100644\n--- a/django/db/backends/sqlite3/schema.py\n+++ b/django/db/backends/sqlite3/schema.py\n@@ -298,6 +298,7 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n             disable_constraints=False,\n         )\n \n+\n         # Run deferred SQL on correct table\n         for sql in self.deferred_sql:\n             self.execute(sql)\n@@ -418,6 +419,7 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         # Delete the old through table\n         self.delete_model(old_field.remote_field.through)\n \n+\n     def add_constraint(self, model, constraint):\n         if isinstance(constraint, UniqueConstraint) and (\n             constraint.condition or\n@@ -440,5 +442,115 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         else:\n             self._remake_table(model)\n \n+    def _create_unique_sql(self, model, columns, name=None, condition=None, \n+                          deferrable=None, include=None, opclasses=None, expressions=None):\n+        if expressions:\n+            # For SQLite, create a custom Expressions handler that doesn't include table qualifiers\n+            compiler = self.connection.ops.compiler('SQLCompiler')(\n+                query=None, connection=self.connection, using=None\n+            )\n+            table = model._meta.db_table\n+            \n+            # Create SQLite-specific expressions without table qualification\n+            sqlite_expressions = SQLiteExpressions(table, expressions, compiler, self.quote_value)\n+            \n+            return Statement(\n+                'CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)%(condition)s%(deferrable)s',\n+                table=table,\n+                name=name,\n+                columns=sqlite_expressions,\n+                condition=' WHERE %s' % condition if condition else '',\n+                deferrable=' DEFERRABLE INITIALLY DEFERRED' if deferrable else '',\n+            )\n+        else:\n+            return super()._create_unique_sql(\n+                model, columns, name=name, condition=condition,\n+                deferrable=deferrable, include=include, opclasses=opclasses,\n+                expressions=expressions\n+            )\n+\n     def _collate_sql(self, collation):\n         return 'COLLATE ' + collation\n+\n+\n+class SQLiteExpressions:\n+    def __init__(self, table, expressions, compiler, quote_value):\n+        self.table = table\n+        self.expressions = expressions\n+        self.compiler = compiler\n+        self.quote_value = quote_value\n+\n+    def __str__(self):\n+        # Generate column references without table qualification for SQLite\n+        from django.db.backends.ddl_references import Expressions\n+        \n+        # Use the original Expressions to get the columns, then strip table qualifiers\n+        original_expressions = Expressions(self.table, self.expressions, self.compiler, self.quote_value)\n+        columns_sql = str(original_expressions)\n+        \n+        # Remove table qualifications (table_name.column_name -> column_name)\n+        # This handles cases where the table name is quoted or unquoted\n+        import re\n+        table_name = self.table\n+        quoted_table = self.quote_value(table_name)\n+        \n+        # Pattern to match both quoted and unquoted table references\n+        patterns = [\n+            rf'{re.escape(quoted_table)}\\.',  # \"table_name\".\n+            rf'{re.escape(table_name)}\\.',    # table_name.\n+        ]\n+        \n+        for pattern in patterns:\n+            columns_sql = re.sub(pattern, '', columns_sql)\n+        \n+        return columns_sql\n+\n+    def _collate_sql(self, collation):\n+\n+    def _collate_sql(self, collation):\n+        return 'COLLATE ' + collation\n+\n+    def _create_unique_sql(self, model, columns, name, condition=None,\n+                          deferrable=None, include=None, expressions=None):\n+        \"\"\"\n+        Override to handle expressions without table qualification for SQLite.\n+        SQLite doesn't allow table-qualified column names in unique constraint expressions.\n+        \"\"\"\n+        if expressions:\n+            # Use SQLite-specific Expressions class that strips table qualifiers\n+            expressions_sql = SQLiteExpressions(\n+                model._meta.db_table, expressions, self.connection.ops.quote_name, self.quote_value\n+            )\n+            sql = self._create_unique_constraint_sql(\n+                model, columns, name, condition, deferrable, include, expressions_sql\n+            )\n+        else:\n+            # Use parent implementation for non-expression constraints\n+            sql = super()._create_unique_sql(\n+                model, columns, name, condition, deferrable, include, expressions\n+            )\n+        return sql\n+\n+\n+class SQLiteExpressions(Statement):\n+    \"\"\"\n+    SQLite-specific Expressions class that generates column references \n+    without table qualification to avoid SQLite syntax errors.\n+    \"\"\"\n+    def __init__(self, table, expressions, compiler, quote_value):\n+        self.table = table\n+        self.expressions = expressions\n+        self.compiler = compiler\n+        self.quote_value = quote_value\n+\n+    def __str__(self):\n+        # Generate expressions without table qualification for SQLite\n+        expressions_sql = []\n+        for expression in self.expressions:\n+            if hasattr(expression, 'target') and hasattr(expression.target, 'column'):\n+                # Direct column reference - use only column name\n+                expressions_sql.append(self.compiler(expression.target.column))\n+            else:\n+                # Complex expression - let SQLite handle it\n+                expressions_sql.append(str(expression))\n+        return ', '.join(expressions_sql)\n",
    "variant_2": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 412fb46f16..e68c5cf0fb 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -1243,6 +1243,7 @@ class BaseDatabaseSchemaEditor:\n             'constraint': constraint,\n         }\n \n+\n     def _create_unique_sql(\n         self, model, fields, name=None, condition=None, deferrable=None,\n         include=None, opclasses=None, expressions=None,\n@@ -1275,7 +1276,9 @@ class BaseDatabaseSchemaEditor:\n         if columns:\n             columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n         else:\n-            columns = Expressions(table, expressions, compiler, self.quote_value)\n+            # SQLite-specific: Use custom Expressions class to avoid table qualifiers\n+            from django.db.backends.sqlite3.schema import SQLiteExpressions\n+            columns = SQLiteExpressions(table, expressions, compiler, self.quote_value)\n         return Statement(\n             sql,\n             table=Table(table, self.quote_name),\ndiff --git a/django/db/backends/ddl_references.py b/django/db/backends/ddl_references.py\nindex c06386a2fa..107064855c 100644\n--- a/django/db/backends/ddl_references.py\n+++ b/django/db/backends/ddl_references.py\n@@ -201,6 +201,7 @@ class Statement(Reference):\n         return self.template % self.parts\n \n \n+\n class Expressions(TableColumns):\n     def __init__(self, table, expressions, compiler, quote_value):\n         self.compiler = compiler\n@@ -216,6 +217,7 @@ class Expressions(TableColumns):\n         self.columns = []\n         for col in self.compiler.query._gen_cols([expressions]):\n             col.alias = new_table\n+            self.columns.append(col.target.column)\n         self.expressions = expressions\n         super().rename_table_references(old_table, new_table)\n \n@@ -229,6 +231,7 @@ class Expressions(TableColumns):\n                 col.target.column = new_column\n             self.columns.append(col.target.column)\n         self.expressions = expressions\n+        self.expressions = expressions\n \n     def __str__(self):\n         sql, params = self.compiler.compile(self.expressions)\ndiff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py\nindex f0c81c123b..12e80b56f6 100644\n--- a/django/db/backends/sqlite3/schema.py\n+++ b/django/db/backends/sqlite3/schema.py\n@@ -298,10 +298,58 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n             disable_constraints=False,\n         )\n \n-        # Run deferred SQL on correct table\n-        for sql in self.deferred_sql:\n-            self.execute(sql)\n-        self.deferred_sql = []\n+\n+    def _create_unique_sql(self, model, columns, name=None, condition=None,\n+                          deferrable=None, include=None, opclasses=None, expressions=None):\n+        \"\"\"\n+        Override to handle expressions without table qualification for SQLite.\n+        SQLite doesn't support table-qualified column names in unique constraint expressions.\n+        \"\"\"\n+        if expressions:\n+            # Use SQLite-specific Expressions class that strips table qualifiers\n+            compiler = self.connection.ops.compiler('SQLCompiler')(\n+                self.connection.ops.compiler('SQLCompiler').query_class(model), \n+                self.connection, 'default'\n+            )\n+            expressions_sql = SQLiteExpressions(\n+                Table(model._meta.db_table, self.quote_name), \n+                expressions, \n+                compiler, \n+                self.quote_value\n+            )\n+            columns = [expressions_sql]\n+        \n+        return super()._create_unique_sql(\n+            model, columns, name, condition, deferrable, include, opclasses, expressions\n+        )\n+\n+\n+class SQLiteExpressions:\n+    \"\"\"\n+    SQLite-specific Expressions class that generates column references without table qualification.\n+    SQLite prohibits table-qualified column names in unique constraint expressions.\n+    \"\"\"\n+    def __init__(self, table, expressions, compiler, quote_value):\n+        self.table = table\n+        self.expressions = expressions  \n+        self.compiler = compiler\n+        self.quote_value = quote_value\n+\n+    def __str__(self):\n+        # Generate expression SQL without table qualifiers\n+        sql_parts = []\n+        for expression in self.expressions:\n+            if hasattr(expression, 'as_sql'):\n+                sql, params = expression.as_sql(self.compiler, self.compiler.connection)\n+                # Strip table qualifiers from column references\n+                # Replace \"table\".\"column\" with just \"column\" \n+                import re\n+                sql = re.sub(r'\"[^\"]+\"\\.\"([^\"]+)\"', r'\"\\1\"', sql)\n+                sql_parts.append(sql % tuple(self.quote_value(p) for p in params))\n+            else:\n+                # Handle simple column names\n+                sql_parts.append(str(expression))\n+        return ', '.join(sql_parts)\n         # Fix any PK-removed field\n         if restore_pk_field:\n             restore_pk_field.primary_key = True\n@@ -418,6 +466,7 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         # Delete the old through table\n         self.delete_model(old_field.remote_field.through)\n \n+\n     def add_constraint(self, model, constraint):\n         if isinstance(constraint, UniqueConstraint) and (\n             constraint.condition or\n@@ -440,5 +489,97 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         else:\n             self._remake_table(model)\n \n+    def _create_unique_sql(self, model, columns, name=None, condition=None,\n+                          deferrable=None, include=None, opclasses=None,\n+                          expressions=None):\n+        if expressions:\n+            # Use SQLite-specific expression handling to avoid table qualifiers\n+            compiler = self.connection.ops.compiler('SQLCompiler')(\n+                self.connection.ops.quote_name, self.connection\n+            )\n+            expressions_sql = SQLiteExpressions(\n+                None, expressions, compiler, self.quote_value\n+            ).references_column\n+        else:\n+            expressions_sql = None\n+        \n+        return super()._create_unique_sql(\n+            model, columns, name, condition, deferrable, include, \n+            opclasses, expressions_sql\n+        )\n+\n+\n+class SQLiteExpressions:\n+    \"\"\"SQLite-specific expressions handler that strips table qualifiers.\"\"\"\n+    \n+    def __init__(self, table, expressions, compiler, quote_value):\n+        self.table = table\n+        self.expressions = expressions\n+        self.compiler = compiler\n+        self.quote_value = quote_value\n+\n+    @property\n+    def references_column(self):\n+        if not self.expressions:\n+            return []\n+        # Generate column references without table qualifiers for SQLite\n+        cols = []\n+        for col in self.compiler.query._gen_cols([self.expressions]):\n+            # Strip table qualifier if present\n+            column_name = col.target.column\n+            if '.' in column_name:\n+                column_name = column_name.split('.', 1)[1]\n+            cols.append(column_name)\n+        return cols\n+\n+    def _collate_sql(self, collation):\n+\n     def _collate_sql(self, collation):\n         return 'COLLATE ' + collation\n+\n+    def _create_unique_sql(self, model, columns, name, condition, deferrable, include, opclasses):\n+        \"\"\"\n+        Override to handle expressions in unique constraints for SQLite.\n+        SQLite doesn't allow table-qualified column names in constraint expressions.\n+        \"\"\"\n+        if not any(hasattr(col, 'target') for col in columns):\n+            # No expressions, use parent implementation\n+            return super()._create_unique_sql(model, columns, name, condition, deferrable, include, opclasses)\n+        \n+        # Handle expressions by creating SQLite-compatible SQL\n+        compiler = self.connection.ops.compiler('SQLCompiler')(\n+            self.connection.ops.compiler('SQLCompiler').query_class(model), self.connection, 'default'\n+        )\n+        \n+        # Use SQLite-specific Expressions class that strips table qualifiers\n+        expressions = SQLiteExpressions(model._meta.db_table, columns, compiler, self.quote_value)\n+        return Statement(\n+            self.sql_create_unique,\n+            table=Table(model._meta.db_table, self.quote_name),\n+            name=self.quote_name(name),\n+            columns=expressions,\n+        )\n+\n+\n+class SQLiteExpressions:\n+    \"\"\"\n+    SQLite-specific expressions handler that strips table qualifiers from column names.\n+    This prevents SQLite errors when using table-qualified column names in constraints.\n+    \"\"\"\n+    def __init__(self, table, expressions, compiler, quote_value):\n+        self.table = table\n+        self.expressions = expressions\n+        self.compiler = compiler\n+        self.quote_value = quote_value\n+\n+    def __str__(self):\n+        # Generate column list without table qualifiers for SQLite compatibility\n+        cols = []\n+        for col in self.expressions:\n+            if hasattr(col, 'target'):\n+                # This is an expression-based column, get just the column name\n+                cols.append(col.target.column)\n+            else:\n+                # Regular column name\n+                cols.append(col)\n+        return ', '.join(self.quote_value(col) for col in cols)\n",
    "variant_3": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 412fb46f16..c7f82e92a8 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -1243,6 +1243,7 @@ class BaseDatabaseSchemaEditor:\n             'constraint': constraint,\n         }\n \n+\n     def _create_unique_sql(\n         self, model, fields, name=None, condition=None, deferrable=None,\n         include=None, opclasses=None, expressions=None,\n@@ -1275,7 +1276,8 @@ class BaseDatabaseSchemaEditor:\n         if columns:\n             columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n         else:\n-            columns = Expressions(table, expressions, compiler, self.quote_value)\n+            # Use SQLite-specific Expressions class that doesn't include table qualifiers\n+            columns = SQLiteExpressions(table, expressions, compiler, self.quote_value)\n         return Statement(\n             sql,\n             table=Table(table, self.quote_name),\n@@ -1286,6 +1288,22 @@ class BaseDatabaseSchemaEditor:\n             include=self._index_include_sql(model, include),\n         )\n \n+\n+class SQLiteExpressions(Expressions):\n+    def __str__(self):\n+        expressions = []\n+        for expression in self.expressions:\n+            expression = expression.resolve_expression(\n+                Query(self.table, alias_cols=False), allow_joins=False, reuse=None, summarize=False,\n+            )\n+            expression_sql, params = self.compiler.compile(expression)\n+            # Remove table qualifiers from column references for SQLite\n+            # Replace \"table_name\".\"column_name\" with just \"column_name\"\n+            import re\n+            expression_sql = re.sub(r'\"[^\"]+\"\\.\"([^\"]+)\"', r'\"\\1\"', expression_sql)\n+            expressions.append(expression_sql % tuple(self.quote_value(p) for p in params))\n+        return ', '.join(expressions)\n+\n     def _delete_unique_sql(\n         self, model, name, condition=None, deferrable=None, include=None,\n         opclasses=None, expressions=None,\ndiff --git a/django/db/backends/ddl_references.py b/django/db/backends/ddl_references.py\nindex c06386a2fa..2d1ab393a8 100644\n--- a/django/db/backends/ddl_references.py\n+++ b/django/db/backends/ddl_references.py\n@@ -201,33 +201,46 @@ class Statement(Reference):\n         return self.template % self.parts\n \n \n-class Expressions(TableColumns):\n-    def __init__(self, table, expressions, compiler, quote_value):\n-        self.compiler = compiler\n-        self.expressions = expressions\n-        self.quote_value = quote_value\n-        columns = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n-        super().__init__(table, columns)\n \n-    def rename_table_references(self, old_table, new_table):\n-        if self.table != old_table:\n-            return\n-        expressions = deepcopy(self.expressions)\n-        self.columns = []\n-        for col in self.compiler.query._gen_cols([expressions]):\n-            col.alias = new_table\n-        self.expressions = expressions\n-        super().rename_table_references(old_table, new_table)\n+class SQLiteExpressions(Expressions):\n+    \"\"\"\n+    SQLite-specific Expressions class that generates column references \n+    without table qualifiers, which SQLite doesn't allow in unique constraints.\n+    \"\"\"\n+    def __str__(self):\n+        sql, params = self.compiler.compile(self.expressions)\n+        # Remove table qualifiers from column references for SQLite\n+        # This handles cases like \"table\".\"column\" -> \"column\"\n+        import re\n+        sql = re.sub(r'\"[^\"]+\"\\.\"([^\"]+)\"', r'\"\\1\"', sql)\n+        params = map(self.quote_value, params)\n+        return sql % tuple(params)\n \n-    def rename_column_references(self, table, old_column, new_column):\n-        if self.table != table:\n-            return\n-        expressions = deepcopy(self.expressions)\n-        self.columns = []\n-        for col in self.compiler.query._gen_cols([expressions]):\n-            if col.target.column == old_column:\n-                col.target.column = new_column\n-            self.columns.append(col.target.column)\n+def _create_unique_sql(self, model, columns, name=None, condition=None,\n+                      deferrable=None, include=None, opclasses=None, expressions=None):\n+    if expressions:\n+        # Use SQLite-specific Expressions class to avoid table qualifiers\n+        compiler = Query(model, alias_cols=False).get_compiler(connection=self.connection)\n+        expressions_instance = SQLiteExpressions(\n+            Table(model._meta.db_table, self.quote_name), \n+            expressions, \n+            compiler, \n+            self.quote_value\n+        )\n+        template = 'CONSTRAINT %(name)s UNIQUE (%(columns)s)%(condition)s%(deferrable)s'\n+        sql = Statement(\n+            template,\n+            name=self.quote_name(name),\n+            columns=expressions_instance,\n+            condition=(' WHERE (%s)' % condition) if condition else '',\n+            deferrable=self._deferrable_constraint_sql(deferrable),\n+        )\n+        return sql\n+    else:\n+        # Use parent implementation for non-expression constraints\n+        return super()._create_unique_sql(\n+            model, columns, name, condition, deferrable, include, opclasses, expressions\n+        )\n         self.expressions = expressions\n \n     def __str__(self):\ndiff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py\nindex f0c81c123b..19896a057c 100644\n--- a/django/db/backends/sqlite3/schema.py\n+++ b/django/db/backends/sqlite3/schema.py\n@@ -298,10 +298,60 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n             disable_constraints=False,\n         )\n \n+\n         # Run deferred SQL on correct table\n         for sql in self.deferred_sql:\n             self.execute(sql)\n         self.deferred_sql = []\n+        \n+    def _create_unique_sql(self, model, columns, name, condition=None, deferrable=None, include=None, opclasses=None, expressions=None):\n+        \"\"\"\n+        Override to handle SQLite's restriction on table-qualified column names in unique constraints.\n+        \"\"\"\n+        if expressions:\n+            # For expressions, use SQLite-specific handling to avoid table qualification\n+            compiler = self.connection.ops.compiler('SQLCompiler')(\n+                self.connection.ops.quote_name, self.connection\n+            )\n+            \n+            # Create a custom expressions handler that doesn't include table names\n+            class SQLiteExpressions:\n+                def __init__(self, table, expressions, compiler, quote_value):\n+                    self.expressions = expressions\n+                    self.compiler = compiler\n+                    \n+                def __str__(self):\n+                    # Generate expression SQL without table qualification\n+                    sql_parts = []\n+                    for expression in self.expressions:\n+                        # Clone and compile the expression without table references\n+                        expr_clone = expression.copy()\n+                        expr_clone.set_source_expressions([\n+                            expr.copy() for expr in expr_clone.get_source_expressions()\n+                        ])\n+                        sql, params = expr_clone.as_sql(self.compiler, self.compiler.connection)\n+                        # Remove table qualifications from the SQL\n+                        sql = sql.replace(f'\"{model._meta.db_table}\".', '')\n+                        sql_parts.append(sql)\n+                    return ', '.join(sql_parts)\n+            \n+            expressions_obj = SQLiteExpressions(model._meta.db_table, expressions, compiler, self.quote_value)\n+            \n+            sql = self.sql_create_unique % {\n+                'table': self.quote_name(model._meta.db_table),\n+                'name': self.quote_name(name),\n+                'columns': expressions_obj,\n+            }\n+            \n+            if condition:\n+                sql += ' WHERE ' + condition\n+                \n+            return Statement(sql, table=model._meta.db_table, name=name)\n+        else:\n+            # For regular columns, use the parent implementation\n+            return super()._create_unique_sql(\n+                model, columns, name, condition, deferrable, include, opclasses, expressions\n+            )\n         # Fix any PK-removed field\n         if restore_pk_field:\n             restore_pk_field.primary_key = True\n@@ -418,6 +468,7 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         # Delete the old through table\n         self.delete_model(old_field.remote_field.through)\n \n+\n     def add_constraint(self, model, constraint):\n         if isinstance(constraint, UniqueConstraint) and (\n             constraint.condition or\n@@ -440,5 +491,98 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         else:\n             self._remake_table(model)\n \n+    def _create_unique_sql(self, model, columns, name=None, condition=None,\n+                          deferrable=None, include=None, opclasses=None,\n+                          expressions=None):\n+        if expressions:\n+            # Use SQLite-specific expressions handling to avoid table qualifiers\n+            from django.db.backends.ddl_references import Columns\n+            \n+            class SQLiteExpressions:\n+                def __init__(self, table, expressions, compiler, quote_value):\n+                    self.expressions = expressions\n+                    self.compiler = compiler\n+                    self.quote_value = quote_value\n+\n+                def __str__(self):\n+                    # Generate expression SQL without table qualifiers for SQLite\n+                    sql_parts = []\n+                    for expression in self.expressions:\n+                        # Get the SQL for the expression\n+                        sql, params = self.compiler.compile(expression)\n+                        # Remove table qualifiers (anything before the last dot)\n+                        # This handles cases like \"table\".\"column\" -> \"column\"\n+                        import re\n+                        sql = re.sub(r'\"[^\"]*\"\\.\"([^\"]*)\"', r'\"\\1\"', sql)\n+                        sql_parts.append(sql % tuple(self.quote_value(p) for p in params))\n+                    return ', '.join(sql_parts)\n+\n+            # Create a modified version of the base method's logic\n+            compiler = model._meta.default_manager.db.ops.compiler('SQLCompiler')(\n+                model._meta.default_manager.db.ops.compiler('SQLCompiler').query_class(model), \n+                model._meta.default_manager.db, \n+                None\n+            )\n+            \n+            expressions_sql = SQLiteExpressions(\n+                model._meta.db_table, expressions, compiler, self.quote_value\n+            )\n+            \n+            sql = self.sql_create_unique_index if name else self.sql_create_unique\n+            return Statement(\n+                sql,\n+                table=model._meta.db_table,\n+                name=name,\n+                columns=expressions_sql,\n+                condition=condition,\n+                deferrable=deferrable,\n+                include=include,\n+            )\n+        else:\n+            # Use parent implementation for non-expression constraints\n+            return super()._create_unique_sql(\n+                model, columns, name, condition, deferrable, include, opclasses\n+            )\n+\n+    def _collate_sql(self, collation):\n+\n     def _collate_sql(self, collation):\n         return 'COLLATE ' + collation\n+\n+    def _create_unique_sql(self, model, columns, name=None, condition=None,\n+                          deferrable=None, include=None, expressions=None):\n+        if expressions:\n+            # SQLite doesn't support table-qualified column names in expressions\n+            # Create a custom Expressions class that strips table qualifiers\n+            class SQLiteExpressions(Expressions):\n+                def __str__(self):\n+                    # Get the base expression string\n+                    base_str = super().__str__()\n+                    # Remove table qualifiers (table_name.column_name -> column_name)\n+                    table_name = self.table._meta.db_table\n+                    qualified_prefix = f'\"{table_name}\".'\n+                    return base_str.replace(qualified_prefix, '')\n+            \n+            # Use our custom Expressions class\n+            compiler = self.connection.ops.compiler('SQLCompiler')(\n+                self.connection.ops.query_class(model), self.connection, 'default'\n+            )\n+            expressions_sql = SQLiteExpressions(model._meta.db_table, expressions, compiler, self.quote_value)\n+            \n+            # Build the constraint SQL manually for SQLite\n+            sql = self.sql_create_unique_index if name else self.sql_create_unique\n+            table_sql = Table(model._meta.db_table, self.quote_name)\n+            name_sql = self.quote_name(name) if name else None\n+            \n+            return Statement(\n+                sql,\n+                table=table_sql,\n+                name=name_sql,\n+                columns=expressions_sql,\n+                condition=' WHERE ' + condition if condition else '',\n+            )\n+        else:\n+            # For non-expression constraints, use the parent implementation\n+            return super()._create_unique_sql(\n+                model, columns, name, condition, deferrable, include, expressions\n+            )\n",
    "variant_4": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 412fb46f16..e7eaabe680 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -1243,6 +1243,7 @@ class BaseDatabaseSchemaEditor:\n             'constraint': constraint,\n         }\n \n+\n     def _create_unique_sql(\n         self, model, fields, name=None, condition=None, deferrable=None,\n         include=None, opclasses=None, expressions=None,\n@@ -1275,7 +1276,9 @@ class BaseDatabaseSchemaEditor:\n         if columns:\n             columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n         else:\n-            columns = Expressions(table, expressions, compiler, self.quote_value)\n+            # Use SQLite-specific Expressions class to avoid table qualification\n+            from django.db.backends.sqlite3.schema import SQLiteExpressions\n+            columns = SQLiteExpressions(table, expressions, compiler, self.quote_value)\n         return Statement(\n             sql,\n             table=Table(table, self.quote_name),\ndiff --git a/django/db/backends/ddl_references.py b/django/db/backends/ddl_references.py\nindex c06386a2fa..be6b66b04c 100644\n--- a/django/db/backends/ddl_references.py\n+++ b/django/db/backends/ddl_references.py\n@@ -201,33 +201,66 @@ class Statement(Reference):\n         return self.template % self.parts\n \n \n-class Expressions(TableColumns):\n+\n+class SQLiteExpressions(Expressions):\n+    \"\"\"SQLite-specific Expressions that strips table qualifiers from column names.\"\"\"\n+    \n     def __init__(self, table, expressions, compiler, quote_value):\n         self.compiler = compiler\n         self.expressions = expressions\n         self.quote_value = quote_value\n-        columns = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n-        super().__init__(table, columns)\n+        # Generate columns without table qualification for SQLite\n+        columns = []\n+        for col in self.compiler.query._gen_cols([self.expressions]):\n+            # Strip table qualifier - only use the column name\n+            column_name = col.target.column\n+            if '.' in column_name:\n+                column_name = column_name.split('.')[-1]\n+            columns.append(column_name)\n+        # Initialize TableColumns directly, bypassing Expressions.__init__\n+        TableColumns.__init__(self, table, columns)\n \n-    def rename_table_references(self, old_table, new_table):\n-        if self.table != old_table:\n-            return\n-        expressions = deepcopy(self.expressions)\n-        self.columns = []\n-        for col in self.compiler.query._gen_cols([expressions]):\n-            col.alias = new_table\n-        self.expressions = expressions\n-        super().rename_table_references(old_table, new_table)\n+    def __str__(self):\n+        # Generate SQL without table qualifiers\n+        sql, params = self.compiler.compile(self.expressions)\n+        # Remove table qualifiers from the SQL string\n+        # This handles cases where table names appear in the compiled SQL\n+        if self.table and f'\"{self.table}\".' in sql:\n+            sql = sql.replace(f'\"{self.table}\".', '')\n+        elif self.table and f'{self.table}.' in sql:\n+            sql = sql.replace(f'{self.table}.', '')\n+        params = map(self.quote_value, params)\n+        return sql % tuple(params)\n \n-    def rename_column_references(self, table, old_column, new_column):\n-        if self.table != table:\n-            return\n-        expressions = deepcopy(self.expressions)\n-        self.columns = []\n-        for col in self.compiler.query._gen_cols([expressions]):\n-            if col.target.column == old_column:\n-                col.target.column = new_column\n-            self.columns.append(col.target.column)\n+\n+def _create_unique_sql(self, model, columns, name=None, condition=None, deferrable=None, include=None, opclasses=None, expressions=None):\n+    \"\"\"Override to handle expressions without table qualification for SQLite.\"\"\"\n+    if expressions:\n+        # Use SQLite-specific Expressions class to avoid table qualification\n+        compiler = Query(model, alias_cols=False).get_compiler(connection=self.connection)\n+        expressions_instance = SQLiteExpressions(\n+            Table(model._meta.db_table, self.quote_name),\n+            expressions,\n+            compiler,\n+            self.quote_value,\n+        )\n+        template = self.sql_create_unique_index if condition or include or opclasses else self.sql_create_unique\n+        sql = Statement(\n+            template,\n+            table=Table(model._meta.db_table, self.quote_name),\n+            name=self.quote_name(name or self._create_index_name(model._meta.db_table, [expressions_instance], suffix=\"_uniq\")),\n+            columns=expressions_instance,\n+            condition=(\" WHERE \" + condition) if condition else \"\",\n+            deferrable=self._deferrable_constraint_sql(deferrable),\n+            include=self._index_include_sql(model, include),\n+            opclasses=self._index_opclasses_sql(opclasses),\n+        )\n+        return sql\n+    else:\n+        # For non-expression constraints, use the parent implementation\n+        return super()._create_unique_sql(\n+            model, columns, name, condition, deferrable, include, opclasses, expressions\n+        )\n         self.expressions = expressions\n \n     def __str__(self):\ndiff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py\nindex f0c81c123b..e8ccd76734 100644\n--- a/django/db/backends/sqlite3/schema.py\n+++ b/django/db/backends/sqlite3/schema.py\n@@ -298,10 +298,90 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n             disable_constraints=False,\n         )\n \n-        # Run deferred SQL on correct table\n-        for sql in self.deferred_sql:\n-            self.execute(sql)\n-        self.deferred_sql = []\n+\n+    def _create_unique_sql(self, model, columns, name=None, condition=None,\n+                          deferrable=None, include=None, opclasses=None):\n+        \"\"\"\n+        Override to handle expressions in unique constraints for SQLite.\n+        SQLite doesn't support table-qualified column names in constraint expressions.\n+        \"\"\"\n+        if not name:\n+            name = self._create_index_name(model._meta.db_table, columns, suffix=\"_uniq\")\n+        \n+        def _get_index_columns(columns):\n+            # Handle expressions by removing table qualifiers for SQLite\n+            index_columns = []\n+            for column in columns:\n+                if hasattr(column, 'resolve_expression'):\n+                    # This is an expression, use SQLite-specific handling\n+                    compiler = self.connection.ops.compiler('SQLCompiler')(\n+                        query=None, connection=self.connection, using=None\n+                    )\n+                    # Create a mock query for the compiler\n+                    from django.db.models.sql import Query\n+                    query = Query(model)\n+                    compiler.query = query\n+                    \n+                    # Use our custom SQLiteExpressions class\n+                    expr_sql = SQLiteExpressions(\n+                        model._meta.db_table, [column], compiler, self.quote_value\n+                    )\n+                    index_columns.append(str(expr_sql))\n+                else:\n+                    # Regular column name\n+                    index_columns.append(self.quote_name(column))\n+            return index_columns\n+        \n+        index_columns = _get_index_columns(columns)\n+        \n+        sql = self.sql_create_unique % {\n+            \"table\": self.quote_name(model._meta.db_table),\n+            \"name\": self.quote_name(name),\n+            \"columns\": \", \".join(index_columns),\n+        }\n+        \n+        if condition:\n+            sql += \" WHERE \" + condition\n+            \n+        return Statement(sql, [], [])\n+\n+\n+class SQLiteExpressions:\n+    \"\"\"\n+    SQLite-specific expressions handler that removes table qualifiers\n+    from column references in constraint expressions.\n+    \"\"\"\n+    def __init__(self, table, expressions, compiler, quote_value):\n+        self.table = table\n+        self.expressions = expressions  \n+        self.compiler = compiler\n+        self.quote_value = quote_value\n+\n+    def __str__(self):\n+        # Generate column references without table qualifiers for SQLite\n+        if not self.compiler.query:\n+            from django.db.models.sql import Query\n+            # Create a minimal query context if needed\n+            self.compiler.query = Query(None)\n+            \n+        sql_parts = []\n+        for expr in self.expressions:\n+            if hasattr(expr, 'resolve_expression'):\n+                # For expressions, compile them and strip table qualifiers\n+                resolved_expr = expr.resolve_expression(self.compiler.query)\n+                expr_sql, params = resolved_expr.as_sql(self.compiler, self.compiler.connection)\n+                # Remove table qualifiers (everything before the last dot)\n+                if '.' in expr_sql and not expr_sql.startswith('\"'):\n+                    # Handle case like \"table\".\"column\" -> \"column\"  \n+                    parts = expr_sql.split('.')\n+                    if len(parts) > 1:\n+                        expr_sql = parts[-1]  # Take only the column part\n+                sql_parts.append(expr_sql)\n+            else:\n+                # Simple column name\n+                sql_parts.append(str(expr))\n+        \n+        return \", \".join(sql_parts)\n         # Fix any PK-removed field\n         if restore_pk_field:\n             restore_pk_field.primary_key = True\n@@ -418,6 +498,7 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         # Delete the old through table\n         self.delete_model(old_field.remote_field.through)\n \n+\n     def add_constraint(self, model, constraint):\n         if isinstance(constraint, UniqueConstraint) and (\n             constraint.condition or\n@@ -440,5 +521,118 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         else:\n             self._remake_table(model)\n \n+    def _create_unique_sql(self, model, columns, name=None, condition=None,\n+                          deferrable=None, include=None, expressions=None):\n+        \"\"\"\n+        Override to handle expressions without table qualification for SQLite.\n+        \"\"\"\n+        if expressions:\n+            # Use SQLite-specific Expressions that strips table qualifiers\n+            compiler = self.connection.ops.compiler('SQLCompiler')(\n+                self.connection.ops.compiler('SQLCompiler').query_class(model), \n+                self.connection, \n+                'default'\n+            )\n+            expressions_sql = SQLiteExpressions(\n+                model._meta.db_table, expressions, compiler, self.quote_value\n+            )\n+            return Statement(\n+                'CREATE UNIQUE INDEX %(name)s ON %(table)s (%(expressions)s)%(condition)s',\n+                name=name or self._create_index_name(model._meta.db_table, expressions, suffix='_uniq'),\n+                table=Table(model._meta.db_table, self.quote_name),\n+                expressions=expressions_sql,\n+                condition=' WHERE ' + condition if condition else '',\n+            )\n+        else:\n+            return super()._create_unique_sql(\n+                model, columns, name, condition, deferrable, include, expressions\n+            )\n+\n+\n+class SQLiteExpressions:\n+    \"\"\"\n+    SQLite-specific expressions handler that strips table qualifiers.\n+    \"\"\"\n+    def __init__(self, table, expressions, compiler, quote_value):\n+        self.table = table\n+        self.expressions = expressions\n+        self.compiler = compiler\n+        self.quote_value = quote_value\n+\n+    def __str__(self):\n+        expressions_sql = []\n+        for expression in self.expressions:\n+            expression_sql = str(expression.resolve_expression(\n+                self.compiler.query, allow_joins=False, for_save=False\n+            ))\n+            # Strip table qualifiers - remove 'table_name.' prefixes\n+            if '.' in expression_sql and not expression_sql.startswith('\"'):\n+                parts = expression_sql.split('.')\n+                if len(parts) == 2:\n+                    expression_sql = parts[1]  # Keep only column name\n+            expressions_sql.append(expression_sql)\n+        return ', '.join(expressions_sql)\n+\n+    def _collate_sql(self, collation):\n+\n     def _collate_sql(self, collation):\n         return 'COLLATE ' + collation\n+\n+    def _create_unique_sql(self, model, columns, name=None, condition=None,\n+                          deferrable=None, include=None, opclasses=None, expressions=None):\n+        \"\"\"\n+        Override to handle SQLite's restriction on table-qualified column names\n+        in unique constraint expressions.\n+        \"\"\"\n+        if expressions:\n+            # Use SQLite-specific Expressions class that strips table qualifiers\n+            compiler = self.connection.ops.compiler('SQLCompiler')(\n+                query=None, connection=self.connection, using=None\n+            )\n+            expressions_sql = SQLiteExpressions(\n+                model._meta.db_table, expressions, compiler, self.quote_value\n+            )\n+            sql = self._create_unique_constraint_sql(\n+                model, None, name, condition, deferrable, include, opclasses, expressions_sql\n+            )\n+        else:\n+            sql = super()._create_unique_sql(\n+                model, columns, name, condition, deferrable, include, opclasses, expressions\n+            )\n+        return sql\n+\n+\n+class SQLiteExpressions:\n+    \"\"\"\n+    SQLite-specific version of Expressions that strips table qualifiers\n+    from column references to avoid SQLite's restriction on qualified names\n+    in constraint expressions.\n+    \"\"\"\n+    def __init__(self, table, expressions, compiler, quote_value):\n+        self.table = table\n+        self.expressions = expressions\n+        self.compiler = compiler\n+        self.quote_value = quote_value\n+\n+    def __str__(self):\n+        # Generate expression SQL without table qualifiers\n+        sql_parts = []\n+        for expression in self.expressions:\n+            if hasattr(expression, 'resolve_expression'):\n+                # Handle F expressions and other complex expressions\n+                resolved = expression.resolve_expression()\n+                if hasattr(resolved, 'target') and hasattr(resolved.target, 'column'):\n+                    # Simple column reference - use just the column name\n+                    sql_parts.append(self.quote_value(resolved.target.column))\n+                else:\n+                    # Complex expression - convert to SQL and strip table qualifiers\n+                    expr_sql = str(resolved)\n+                    # Remove table qualifications like \"table\".\"column\" -> \"column\"\n+                    import re\n+                    expr_sql = re.sub(r'\"[^\"]+\"\\.\"([^\"]+)\"', r'\"\\1\"', expr_sql)\n+                    sql_parts.append(expr_sql)\n+            else:\n+                # Handle string expressions or other types\n+                sql_parts.append(str(expression))\n+        \n+        return '(%s)' % ', '.join(sql_parts)\n",
    "variant_5": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 412fb46f16..0aa85f3f10 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -1243,6 +1243,7 @@ class BaseDatabaseSchemaEditor:\n             'constraint': constraint,\n         }\n \n+\n     def _create_unique_sql(\n         self, model, fields, name=None, condition=None, deferrable=None,\n         include=None, opclasses=None, expressions=None,\n@@ -1275,7 +1276,17 @@ class BaseDatabaseSchemaEditor:\n         if columns:\n             columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n         else:\n-            columns = Expressions(table, expressions, compiler, self.quote_value)\n+            # Use SQLite-specific Expressions that strips table qualifiers\n+            from django.db.backends.ddl_references import Expressions\n+            \n+            class SQLiteExpressions(Expressions):\n+                def __str__(self):\n+                    # Get the original column references\n+                    cols = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n+                    # Strip table qualifiers for SQLite\n+                    return ', '.join([col.split('.')[-1] if '.' in col else col for col in cols])\n+            \n+            columns = SQLiteExpressions(table, expressions, compiler, self.quote_value)\n         return Statement(\n             sql,\n             table=Table(table, self.quote_name),\ndiff --git a/django/db/backends/ddl_references.py b/django/db/backends/ddl_references.py\nindex c06386a2fa..107064855c 100644\n--- a/django/db/backends/ddl_references.py\n+++ b/django/db/backends/ddl_references.py\n@@ -201,6 +201,7 @@ class Statement(Reference):\n         return self.template % self.parts\n \n \n+\n class Expressions(TableColumns):\n     def __init__(self, table, expressions, compiler, quote_value):\n         self.compiler = compiler\n@@ -216,6 +217,7 @@ class Expressions(TableColumns):\n         self.columns = []\n         for col in self.compiler.query._gen_cols([expressions]):\n             col.alias = new_table\n+            self.columns.append(col.target.column)\n         self.expressions = expressions\n         super().rename_table_references(old_table, new_table)\n \n@@ -229,6 +231,7 @@ class Expressions(TableColumns):\n                 col.target.column = new_column\n             self.columns.append(col.target.column)\n         self.expressions = expressions\n+        self.expressions = expressions\n \n     def __str__(self):\n         sql, params = self.compiler.compile(self.expressions)\ndiff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py\nindex f0c81c123b..719091256c 100644\n--- a/django/db/backends/sqlite3/schema.py\n+++ b/django/db/backends/sqlite3/schema.py\n@@ -298,10 +298,36 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n             disable_constraints=False,\n         )\n \n-        # Run deferred SQL on correct table\n-        for sql in self.deferred_sql:\n-            self.execute(sql)\n-        self.deferred_sql = []\n+    def _create_unique_sql(self, model, columns, name=None, condition=None,\n+                          deferrable=None, include=None, opclasses=None, expressions=None):\n+        \"\"\"\n+        Return the SQL to create a unique constraint for the given columns.\n+        For SQLite, we need to handle expressions specially to avoid table-qualified column names.\n+        \"\"\"\n+        if expressions:\n+            # Use SQLite-specific Expressions class that strips table qualifiers\n+            compiler = Query(model, alias_cols=False).get_compiler(connection=self.connection)\n+            expressions_sql = SQLiteExpressions(\n+                model._meta.db_table, expressions, compiler, self.quote_value\n+            )\n+        else:\n+            expressions_sql = None\n+            \n+        return super()._create_unique_sql(\n+            model, columns, name, condition, deferrable, include, opclasses, expressions_sql\n+        )\n+\n+\n+class SQLiteExpressions(Expressions):\n+    \"\"\"\n+    SQLite-specific Expressions class that strips table qualifiers from column names\n+    to avoid \"table name prefix not allowed\" errors in constraint expressions.\n+    \"\"\"\n+    def __str__(self):\n+        # Get the base column references\n+        cols = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n+        # Strip table qualifiers - only use column names for SQLite\n+        return ', '.join(self.quote_value(col.split('.')[-1]) if '.' in col else self.quote_value(col) for col in cols)\n         # Fix any PK-removed field\n         if restore_pk_field:\n             restore_pk_field.primary_key = True\n@@ -418,6 +444,7 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         # Delete the old through table\n         self.delete_model(old_field.remote_field.through)\n \n+\n     def add_constraint(self, model, constraint):\n         if isinstance(constraint, UniqueConstraint) and (\n             constraint.condition or\n@@ -440,5 +467,83 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         else:\n             self._remake_table(model)\n \n+    def _create_unique_sql(self, model, columns, name, condition=None,\n+                          deferrable=None, include=None, expressions=None):\n+        if expressions:\n+            # SQLite doesn't support table-qualified expressions in constraints\n+            from django.db.backends.ddl_references import Expressions\n+            \n+            class SQLiteExpressions(Expressions):\n+                def __str__(self):\n+                    # Generate column references without table qualification\n+                    compiler = self.compiler\n+                    columns = []\n+                    for expr in self.expressions:\n+                        # Use the compiler to render the expression without table prefix\n+                        sql, params = compiler.compile(expr)\n+                        # Remove table qualifiers (anything before a dot)\n+                        if '.' in sql:\n+                            sql = sql.split('.')[-1]\n+                        columns.append(sql)\n+                    return ', '.join(columns)\n+            \n+            # Use our custom expressions class\n+            expressions_ref = SQLiteExpressions(\n+                model._meta.db_table, expressions, self.connection.ops.quote_name, self.quote_value\n+            )\n+            \n+            return Statement(\n+                'CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)%(condition)s',\n+                name=name,\n+                table=self.quote_name(model._meta.db_table),\n+                columns=expressions_ref,\n+                condition=' WHERE %s' % condition if condition else '',\n+            )\n+        else:\n+            return super()._create_unique_sql(\n+                model, columns, name, condition, deferrable, include, expressions\n+            )\n+\n+    def _collate_sql(self, collation):\n+\n     def _collate_sql(self, collation):\n         return 'COLLATE ' + collation\n+\n+    def _create_unique_sql(self, model, columns, name=None, condition=None,\n+                          deferrable=None, include=None, opclasses=None, expressions=None):\n+        if expressions:\n+            # Use SQLite-specific Expressions class that strips table qualifiers\n+            from django.db.backends.ddl_references import Expressions\n+            \n+            class SQLiteExpressions(Expressions):\n+                def __str__(self):\n+                    # Generate expressions without table qualification for SQLite\n+                    expressions_sql = []\n+                    for expression in self.expressions:\n+                        if hasattr(expression, 'target') and hasattr(expression.target, 'column'):\n+                            # Simple column reference - use column name only\n+                            expressions_sql.append(self.compiler.quote_name_unless_alias(expression.target.column))\n+                        else:\n+                            # Complex expression - compile normally but may need table stripping\n+                            sql, params = expression.as_sql(self.compiler, self.compiler.connection)\n+                            # Strip table qualifiers from the SQL\n+                            table_name = self.compiler.quote_name_unless_alias(self.table.table_name)\n+                            sql = sql.replace(f'{table_name}.', '')\n+                            expressions_sql.append(sql % tuple(self.quote_value(p) for p in params))\n+                    return ', '.join(expressions_sql)\n+            \n+            # Create table reference for expressions\n+            table = self._get_table_reference(model)\n+            expressions_obj = SQLiteExpressions(table, expressions, self.sql_create_unique.compiler(self.connection), self.quote_value)\n+            \n+            # Build the unique constraint SQL\n+            sql = self.sql_create_unique_index.format(\n+                name=self.quote_name(name or self._create_index_name(model._meta.db_table, [col.name for col in columns] if columns else [], '_uniq')),\n+                table=self.quote_name(model._meta.db_table),\n+                columns=expressions_obj,\n+                condition=' WHERE ' + condition if condition else '',\n+            )\n+            return Statement(sql, table=table)\n+        else:\n+            # Use parent implementation for non-expression constraints\n+            return super()._create_unique_sql(model, columns, name, condition, deferrable, include, opclasses, expressions)\n",
    "variant_6": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 412fb46f16..bcdb4ab827 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -1243,6 +1243,7 @@ class BaseDatabaseSchemaEditor:\n             'constraint': constraint,\n         }\n \n+\n     def _create_unique_sql(\n         self, model, fields, name=None, condition=None, deferrable=None,\n         include=None, opclasses=None, expressions=None,\n@@ -1275,7 +1276,9 @@ class BaseDatabaseSchemaEditor:\n         if columns:\n             columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n         else:\n-            columns = Expressions(table, expressions, compiler, self.quote_value)\n+            # Use SQLite-specific Expressions class to avoid table-qualified column names\n+            from django.db.backends.sqlite3.schema import SQLiteExpressions\n+            columns = SQLiteExpressions(table, expressions, compiler, self.quote_value)\n         return Statement(\n             sql,\n             table=Table(table, self.quote_name),\ndiff --git a/django/db/backends/ddl_references.py b/django/db/backends/ddl_references.py\nindex c06386a2fa..3c0e6c1eff 100644\n--- a/django/db/backends/ddl_references.py\n+++ b/django/db/backends/ddl_references.py\n@@ -201,33 +201,48 @@ class Statement(Reference):\n         return self.template % self.parts\n \n \n-class Expressions(TableColumns):\n-    def __init__(self, table, expressions, compiler, quote_value):\n-        self.compiler = compiler\n-        self.expressions = expressions\n-        self.quote_value = quote_value\n-        columns = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n-        super().__init__(table, columns)\n \n-    def rename_table_references(self, old_table, new_table):\n-        if self.table != old_table:\n-            return\n-        expressions = deepcopy(self.expressions)\n-        self.columns = []\n-        for col in self.compiler.query._gen_cols([expressions]):\n-            col.alias = new_table\n-        self.expressions = expressions\n-        super().rename_table_references(old_table, new_table)\n+class SQLiteExpressions(Expressions):\n+    \"\"\"\n+    SQLite-specific Expressions class that generates column references without table qualifiers.\n+    SQLite doesn't allow table-qualified column names in unique constraint expressions.\n+    \"\"\"\n+    def __str__(self):\n+        sql, params = self.compiler.compile(self.expressions)\n+        params = map(self.quote_value, params)\n+        # Remove table qualifiers from the SQL to make it SQLite-compatible\n+        # This handles cases like \"table\".\"column\" -> \"column\"\n+        import re\n+        sql = re.sub(r'\"[^\"]+\"\\.\"([^\"]+)\"', r'\"\\1\"', sql)\n+        return sql % tuple(params)\n \n-    def rename_column_references(self, table, old_column, new_column):\n-        if self.table != table:\n-            return\n-        expressions = deepcopy(self.expressions)\n-        self.columns = []\n-        for col in self.compiler.query._gen_cols([expressions]):\n-            if col.target.column == old_column:\n-                col.target.column = new_column\n-            self.columns.append(col.target.column)\n+\n+def _create_unique_sql(self, model, columns, name=None, condition=None,\n+                      deferrable=None, include=None, opclasses=None,\n+                      expressions=None):\n+    \"\"\"\n+    Override to handle expressions without table qualifiers for SQLite.\n+    \"\"\"\n+    if expressions:\n+        # Use SQLite-specific Expressions class to avoid table qualifiers\n+        compiler = Query(model).get_compiler(self.connection.alias)\n+        expressions_instance = SQLiteExpressions(\n+            Table(model._meta.db_table, self.quote_name),\n+            expressions,\n+            compiler,\n+            self.quote_value\n+        )\n+        return Statement(\n+            self.sql_create_unique,\n+            table=Table(model._meta.db_table, self.quote_name),\n+            name=self.quote_name(name) if name else None,\n+            columns=expressions_instance,\n+        )\n+    else:\n+        # For non-expression constraints, use the base implementation\n+        return super()._create_unique_sql(\n+            model, columns, name, condition, deferrable, include, opclasses\n+        )\n         self.expressions = expressions\n \n     def __str__(self):\ndiff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py\nindex f0c81c123b..96144583c3 100644\n--- a/django/db/backends/sqlite3/schema.py\n+++ b/django/db/backends/sqlite3/schema.py\n@@ -298,10 +298,44 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n             disable_constraints=False,\n         )\n \n-        # Run deferred SQL on correct table\n-        for sql in self.deferred_sql:\n-            self.execute(sql)\n-        self.deferred_sql = []\n+    def _create_unique_sql(self, model, columns, name=None, condition=None,\n+                          deferrable=None, include=None, opclasses=None, expressions=None):\n+        \"\"\"\n+        Generate SQL to create a unique constraint, handling SQLite's restriction\n+        on table-qualified column names in expressions.\n+        \"\"\"\n+        if expressions:\n+            # SQLite doesn't allow table-qualified column names in constraint expressions\n+            # Use a custom Expressions class that strips table qualifiers\n+            compiler = Query(model, alias_cols=False).get_compiler(connection=self.connection)\n+            expressions_sql = SQLiteExpressions(model._meta.db_table, expressions, compiler, self.quote_value)\n+            sql = self._create_unique_constraint_sql(model, name, expressions_sql, condition, deferrable, include, opclasses)\n+        else:\n+            # For non-expression constraints, use the standard approach\n+            sql = super()._create_unique_sql(model, columns, name, condition, deferrable, include, opclasses)\n+        return sql\n+\n+\n+class SQLiteExpressions(Expressions):\n+    \"\"\"\n+    SQLite-specific Expressions class that generates column references\n+    without table qualifiers to comply with SQLite's constraint syntax.\n+    \"\"\"\n+    def __str__(self):\n+        # Generate expressions without table qualification\n+        expressions = []\n+        for expr in self.expressions:\n+            if hasattr(expr, 'resolve_expression'):\n+                resolved = expr.resolve_expression(self.compiler.query)\n+                if hasattr(resolved, 'target') and hasattr(resolved.target, 'column'):\n+                    # Simple column reference - use just the column name\n+                    expressions.append(self.quote_value(resolved.target.column))\n+                else:\n+                    # Complex expression - let SQLite handle it\n+                    expressions.append(str(resolved))\n+            else:\n+                expressions.append(str(expr))\n+        return ', '.join(expressions)\n         # Fix any PK-removed field\n         if restore_pk_field:\n             restore_pk_field.primary_key = True\n@@ -418,6 +452,7 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         # Delete the old through table\n         self.delete_model(old_field.remote_field.through)\n \n+\n     def add_constraint(self, model, constraint):\n         if isinstance(constraint, UniqueConstraint) and (\n             constraint.condition or\n@@ -440,5 +475,108 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         else:\n             self._remake_table(model)\n \n+    def _create_unique_sql(self, model, columns, name, condition=None,\n+                          deferrable=None, include=None, expressions=None):\n+        \"\"\"\n+        Override to handle expressions without table qualification for SQLite.\n+        \"\"\"\n+        if expressions:\n+            # Use SQLite-specific Expressions class that strips table qualifiers\n+            compiler = model._meta.apps.get_app_config('contenttypes').models_module.ContentType._meta.apps._apps['django.db.models.sql.compiler'].SQLCompiler\n+            from django.db import connection\n+            from django.db.models.sql.query import Query\n+            \n+            query = Query(model)\n+            compiler = connection.ops.compiler('SQLCompiler')(query, connection, 'default')\n+            \n+            sqlite_expressions = SQLiteExpressions(model._meta.db_table, expressions, compiler, self.quote_value)\n+            \n+            return Statement(\n+                \"CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)%(condition)s\",\n+                name=self.quote_name(name),\n+                table=self.quote_name(model._meta.db_table),\n+                columns=sqlite_expressions,\n+                condition=' WHERE ' + condition if condition else '',\n+            )\n+        else:\n+            return super()._create_unique_sql(model, columns, name, condition, deferrable, include, expressions)\n+\n+\n+class SQLiteExpressions:\n+    \"\"\"\n+    SQLite-specific expressions handler that strips table qualifiers.\n+    \"\"\"\n+    def __init__(self, table, expressions, compiler, quote_value):\n+        self.table = table\n+        self.expressions = expressions\n+        self.compiler = compiler\n+        self.quote_value = quote_value\n+\n+    def __str__(self):\n+        expressions = []\n+        for expr in self.expressions:\n+            if hasattr(expr, 'target') and hasattr(expr.target, 'column'):\n+                # Strip table qualifier for SQLite compatibility\n+                expressions.append(self.compiler.quote_name_unless_alias(expr.target.column))\n+            else:\n+                # For complex expressions, compile without table prefix\n+                sql, params = expr.as_sql(self.compiler, self.compiler.connection)\n+                # Remove table prefix if present (format: \"table\".\"column\")\n+                if '.' in sql and sql.count('\"') >= 2:\n+                    parts = sql.split('.')\n+                    if len(parts) == 2:\n+                        sql = parts[1]  # Take only the column part\n+                expressions.append(sql)\n+        return ', '.join(expressions)\n+\n+    def _collate_sql(self, collation):\n+\n     def _collate_sql(self, collation):\n         return 'COLLATE ' + collation\n+\n+    def _create_unique_sql(self, model, columns, name=None, condition=None,\n+                          deferrable=None, include=None, opclasses=None, expressions=None):\n+        \"\"\"\n+        Override to handle expressions without table qualification for SQLite.\n+        SQLite doesn't support table-qualified column names in constraint expressions.\n+        \"\"\"\n+        if expressions:\n+            # Use SQLite-specific Expressions class that strips table qualifiers\n+            compiler = self.connection.ops.compiler('SQLCompiler')(\n+                self.connection.ops.query_class(model), self.connection, 'default'\n+            )\n+            expressions_sql = SQLiteExpressions(\n+                model._meta.db_table, expressions, compiler, self.quote_value\n+            )\n+            sql = self._unique_sql(\n+                model, None, name, expressions=expressions_sql,\n+                condition=condition, deferrable=deferrable, include=include\n+            )\n+        else:\n+            sql = super()._create_unique_sql(\n+                model, columns, name, condition, deferrable, include, opclasses, expressions\n+            )\n+        return sql\n+\n+\n+class SQLiteExpressions:\n+    \"\"\"\n+    SQLite-specific version of Expressions that strips table qualifiers\n+    from column references to avoid SQLite syntax errors.\n+    \"\"\"\n+    def __init__(self, table, expressions, compiler, quote_value):\n+        self.table = table\n+        self.expressions = expressions\n+        self.compiler = compiler\n+        self.quote_value = quote_value\n+\n+    def __str__(self):\n+        # Generate expressions without table qualification\n+        sql_parts = []\n+        for expression in self.expressions:\n+            # Use the compiler to generate SQL but strip table qualifiers\n+            sql, params = expression.as_sql(self.compiler, self.compiler.connection)\n+            # Remove table qualifiers (e.g., \"table\".\"column\" -> \"column\")\n+            sql = sql.replace(f'\"{self.table}\".', '').replace(f'{self.table}.', '')\n+            sql_parts.append(sql % tuple(self.quote_value(p) for p in params))\n+        return '(%s)' % ', '.join(sql_parts)\n",
    "variant_7": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 412fb46f16..f58d8d274d 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -1243,6 +1243,7 @@ class BaseDatabaseSchemaEditor:\n             'constraint': constraint,\n         }\n \n+\n     def _create_unique_sql(\n         self, model, fields, name=None, condition=None, deferrable=None,\n         include=None, opclasses=None, expressions=None,\n@@ -1275,7 +1276,8 @@ class BaseDatabaseSchemaEditor:\n         if columns:\n             columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n         else:\n-            columns = Expressions(table, expressions, compiler, self.quote_value)\n+            # Use SQLite-specific expressions that don't include table qualifiers\n+            columns = SQLiteExpressions(table, expressions, compiler, self.quote_value)\n         return Statement(\n             sql,\n             table=Table(table, self.quote_name),\n@@ -1286,6 +1288,13 @@ class BaseDatabaseSchemaEditor:\n             include=self._index_include_sql(model, include),\n         )\n \n+\n+class SQLiteExpressions(Expressions):\n+    def __str__(self):\n+        # Generate column references without table qualifiers for SQLite\n+        cols = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n+        return ', '.join([self.quote_value(col) for col in cols])\n+\n     def _delete_unique_sql(\n         self, model, name, condition=None, deferrable=None, include=None,\n         opclasses=None, expressions=None,\ndiff --git a/django/db/backends/ddl_references.py b/django/db/backends/ddl_references.py\nindex c06386a2fa..5d49868e8d 100644\n--- a/django/db/backends/ddl_references.py\n+++ b/django/db/backends/ddl_references.py\n@@ -201,14 +201,15 @@ class Statement(Reference):\n         return self.template % self.parts\n \n \n-class Expressions(TableColumns):\n-    def __init__(self, table, expressions, compiler, quote_value):\n-        self.compiler = compiler\n-        self.expressions = expressions\n-        self.quote_value = quote_value\n-        columns = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n-        super().__init__(table, columns)\n \n+class SQLiteExpressions(Expressions):\n+    \"\"\"SQLite-specific Expressions that strips table qualifiers from column names.\"\"\"\n+    \n+    def __init__(self, table, expressions, compiler, quote_value):\n+        super().__init__(table, expressions, compiler, quote_value)\n+        # Strip table qualifiers from column names for SQLite compatibility\n+        self.columns = [col.split('.')[-1] if '.' in col else col for col in self.columns]\n+    \n     def rename_table_references(self, old_table, new_table):\n         if self.table != old_table:\n             return\n@@ -216,18 +217,38 @@ class Expressions(TableColumns):\n         self.columns = []\n         for col in self.compiler.query._gen_cols([expressions]):\n             col.alias = new_table\n+            # Strip table qualifier for SQLite\n+            column_name = col.target.column.split('.')[-1] if '.' in col.target.column else col.target.column\n+            self.columns.append(column_name)\n         self.expressions = expressions\n-        super().rename_table_references(old_table, new_table)\n-\n+        super(Expressions, self).rename_table_references(old_table, new_table)\n+    \n     def rename_column_references(self, table, old_column, new_column):\n         if self.table != table:\n             return\n         expressions = deepcopy(self.expressions)\n         self.columns = []\n         for col in self.compiler.query._gen_cols([expressions]):\n-            if col.target.column == old_column:\n+            column_name = col.target.column.split('.')[-1] if '.' in col.target.column else col.target.column\n+            if column_name == old_column:\n                 col.target.column = new_column\n-            self.columns.append(col.target.column)\n+                self.columns.append(new_column)\n+            else:\n+                self.columns.append(column_name)\n+        self.expressions = expressions\n+\n+def _create_unique_sql(self, model, columns, name=None, condition=None, deferrable=None, include=None, opclasses=None, expressions=None):\n+    \"\"\"Override to use SQLite-compatible Expressions that strips table qualifiers.\"\"\"\n+    if expressions:\n+        compiler = Query(model, alias_cols=False).get_compiler(\n+            connection=self.connection,\n+        )\n+        # Use SQLite-specific Expressions class\n+        expressions = SQLiteExpressions(Table(model._meta.db_table, self.quote_name), expressions, compiler, self.quote_value)\n+    return super()._create_unique_sql(\n+        model, columns, name=name, condition=condition, deferrable=deferrable,\n+        include=include, opclasses=opclasses, expressions=expressions\n+    )\n         self.expressions = expressions\n \n     def __str__(self):\ndiff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py\nindex f0c81c123b..c6b1ee4941 100644\n--- a/django/db/backends/sqlite3/schema.py\n+++ b/django/db/backends/sqlite3/schema.py\n@@ -298,10 +298,40 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n             disable_constraints=False,\n         )\n \n-        # Run deferred SQL on correct table\n-        for sql in self.deferred_sql:\n-            self.execute(sql)\n-        self.deferred_sql = []\n+\n+    def _create_unique_sql(self, model, columns, name=None, condition=None,\n+                          deferrable=None, include=None, opclasses=None, expressions=None):\n+        if expressions:\n+            # SQLite doesn't support table-qualified column names in constraint expressions\n+            # Create a custom Expressions handler that strips table qualifiers\n+            class SQLiteExpressions(Expressions):\n+                def __str__(self):\n+                    # Get the base column references without table qualification\n+                    cols = []\n+                    for col in self.compiler.query._gen_cols([self.expressions]):\n+                        # Strip table qualifier if present, keep only column name\n+                        col_name = col.target.column\n+                        cols.append(self.compiler.quote_name_unless_alias(col_name))\n+                    return ', '.join(cols)\n+            \n+            # Use our custom expressions handler\n+            compiler = self.connection.ops.compiler('SQLCompiler')(\n+                self.connection.ops.compiler('SQLCompiler').query_class(model), self.connection, 'default'\n+            )\n+            expressions_sql = SQLiteExpressions(None, expressions, compiler, self.quote_value)\n+            \n+            # Build the constraint SQL manually for SQLite\n+            sql = self.sql_create_unique_index if condition else self.sql_create_unique\n+            return Statement(\n+                sql,\n+                table=Table(model._meta.db_table, self.quote_name),\n+                name=self.quote_name(name) if name else self._create_index_name(model._meta.db_table, [str(expressions_sql)], suffix='_uniq'),\n+                columns=expressions_sql,\n+                condition=' WHERE ' + condition if condition else '',\n+            )\n+        else:\n+            # Use the base implementation for non-expression constraints\n+            return super()._create_unique_sql(model, columns, name, condition, deferrable, include, opclasses, expressions)\n         # Fix any PK-removed field\n         if restore_pk_field:\n             restore_pk_field.primary_key = True\n@@ -418,6 +448,7 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         # Delete the old through table\n         self.delete_model(old_field.remote_field.through)\n \n+\n     def add_constraint(self, model, constraint):\n         if isinstance(constraint, UniqueConstraint) and (\n             constraint.condition or\n@@ -440,5 +471,93 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         else:\n             self._remake_table(model)\n \n+    def _create_unique_sql(self, model, columns, name=None, condition=None,\n+                          deferrable=None, include=None, opclasses=None):\n+        \"\"\"\n+        Override to handle expressions without table qualification for SQLite.\n+        \"\"\"\n+        from django.db.backends.ddl_references import Expressions\n+        \n+        class SQLiteExpressions(Expressions):\n+            def __str__(self):\n+                # Get the base column references\n+                cols = [col.target.column for col in self.compiler.query._gen_cols([self.expressions])]\n+                # Return only column names without table qualification for SQLite\n+                return ', '.join(self.compiler.quote_name_unless_alias(col) for col in cols)\n+        \n+        if any(hasattr(col, 'target') for col in columns):\n+            # Use SQLite-specific expressions handling for expression columns\n+            compiler = self.connection.ops.compiler('SQLCompiler')(\n+                query=self.connection.ops.select_compiler('SQLCompiler').query_class(model),\n+                connection=self.connection,\n+                using=None\n+            )\n+            expressions = SQLiteExpressions(None, columns, compiler, self.quote_value)\n+            columns_sql = str(expressions)\n+        else:\n+            # Regular column names\n+            columns_sql = ', '.join(self.quote_name(column) for column in columns)\n+        \n+        sql = self.sql_create_unique % {\n+            'table': self.quote_name(model._meta.db_table),\n+            'name': self.quote_name(name),\n+            'columns': columns_sql,\n+        }\n+        \n+        if condition:\n+            sql += ' WHERE ' + condition\n+            \n+        return Statement(sql, [], [])\n+\n+    def _collate_sql(self, collation):\n+\n     def _collate_sql(self, collation):\n         return 'COLLATE ' + collation\n+\n+    def _create_unique_sql(self, model, columns, name=None, condition=None,\n+                          deferrable=None, include=None, opclasses=None,\n+                          expressions=None):\n+        if expressions:\n+            # SQLite doesn't support table-qualified column names in constraint expressions\n+            # Use a custom Expressions class that strips table qualifiers\n+            compiler = self.connection.ops.compiler('SQLCompiler')(\n+                self.connection.ops.quote_name, self.connection\n+            )\n+            expressions_sql = SQLiteExpressions(\n+                model._meta.db_table, expressions, compiler, self.quote_value\n+            )\n+            sql = self._create_unique_name(model, columns, name)\n+            return Statement(\n+                \"CREATE UNIQUE INDEX %(name)s ON %(table)s (%(expressions)s)%(condition)s\",\n+                name=sql,\n+                table=Table(model._meta.db_table, self.quote_name),\n+                expressions=expressions_sql,\n+                condition=' WHERE ' + condition if condition else '',\n+            )\n+        return super()._create_unique_sql(\n+            model, columns, name, condition, deferrable, include, opclasses, expressions\n+        )\n+\n+\n+class SQLiteExpressions(Statement):\n+    def __init__(self, table, expressions, compiler, quote_value):\n+        self.table = table\n+        self.expressions = expressions\n+        self.compiler = compiler\n+        self.quote_value = quote_value\n+\n+    def __str__(self):\n+        # Generate column references without table qualification for SQLite\n+        cols = []\n+        for expression in self.expressions:\n+            if hasattr(expression, 'target') and hasattr(expression.target, 'column'):\n+                # Simple column reference - use just the column name\n+                cols.append(self.compiler.quote_name_unless_alias(expression.target.column))\n+            else:\n+                # Complex expression - compile it normally but strip table qualifiers\n+                sql, params = expression.as_sql(self.compiler, self.compiler.connection)\n+                # Remove table qualifications like \"table\".\"column\" -> \"column\"\n+                import re\n+                sql = re.sub(r'\"[^\"]+\"\\.\"([^\"]+)\"', r'\"\\1\"', sql)\n+                cols.append(sql)\n+        return ', '.join(cols)\n",
    "variant_8": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 412fb46f16..bcdb4ab827 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -1243,6 +1243,7 @@ class BaseDatabaseSchemaEditor:\n             'constraint': constraint,\n         }\n \n+\n     def _create_unique_sql(\n         self, model, fields, name=None, condition=None, deferrable=None,\n         include=None, opclasses=None, expressions=None,\n@@ -1275,7 +1276,9 @@ class BaseDatabaseSchemaEditor:\n         if columns:\n             columns = self._index_columns(table, columns, col_suffixes=(), opclasses=opclasses)\n         else:\n-            columns = Expressions(table, expressions, compiler, self.quote_value)\n+            # Use SQLite-specific Expressions class to avoid table-qualified column names\n+            from django.db.backends.sqlite3.schema import SQLiteExpressions\n+            columns = SQLiteExpressions(table, expressions, compiler, self.quote_value)\n         return Statement(\n             sql,\n             table=Table(table, self.quote_name),\ndiff --git a/django/db/backends/ddl_references.py b/django/db/backends/ddl_references.py\nindex c06386a2fa..107064855c 100644\n--- a/django/db/backends/ddl_references.py\n+++ b/django/db/backends/ddl_references.py\n@@ -201,6 +201,7 @@ class Statement(Reference):\n         return self.template % self.parts\n \n \n+\n class Expressions(TableColumns):\n     def __init__(self, table, expressions, compiler, quote_value):\n         self.compiler = compiler\n@@ -216,6 +217,7 @@ class Expressions(TableColumns):\n         self.columns = []\n         for col in self.compiler.query._gen_cols([expressions]):\n             col.alias = new_table\n+            self.columns.append(col.target.column)\n         self.expressions = expressions\n         super().rename_table_references(old_table, new_table)\n \n@@ -229,6 +231,7 @@ class Expressions(TableColumns):\n                 col.target.column = new_column\n             self.columns.append(col.target.column)\n         self.expressions = expressions\n+        self.expressions = expressions\n \n     def __str__(self):\n         sql, params = self.compiler.compile(self.expressions)\ndiff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py\nindex f0c81c123b..3bdc5a02d0 100644\n--- a/django/db/backends/sqlite3/schema.py\n+++ b/django/db/backends/sqlite3/schema.py\n@@ -298,10 +298,47 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n             disable_constraints=False,\n         )\n \n-        # Run deferred SQL on correct table\n-        for sql in self.deferred_sql:\n-            self.execute(sql)\n-        self.deferred_sql = []\n+    def _create_unique_sql(self, model, columns, name=None, condition=None,\n+                          deferrable=None, include=None, expressions=None):\n+        \"\"\"\n+        Return the SQL for creating a unique constraint. Override to handle\n+        expressions without table qualification for SQLite compatibility.\n+        \"\"\"\n+        if expressions:\n+            # Use SQLite-specific Expressions class that strips table qualifiers\n+            expressions_sql = SQLiteExpressions(\n+                model._meta.db_table, expressions, self.connection.ops.compiler(\"SQLCompiler\")(\n+                    self.connection.ops.query_class(model), self.connection, \"default\"\n+                ), self.quote_value\n+            )\n+        else:\n+            expressions_sql = None\n+        \n+        return super()._create_unique_sql(\n+            model, columns, name, condition, deferrable, include, expressions_sql\n+        )\n+\n+\n+class SQLiteExpressions:\n+    \"\"\"\n+    SQLite-specific expressions class that strips table qualifiers from column references.\n+    \"\"\"\n+    def __init__(self, table, expressions, compiler, quote_value):\n+        self.table = table\n+        self.expressions = expressions\n+        self.compiler = compiler\n+        self.quote_value = quote_value\n+\n+    def __str__(self):\n+        # Generate column references without table qualification\n+        cols = []\n+        for col in self.compiler.query._gen_cols([self.expressions]):\n+            # Strip table qualifier from column name\n+            column_name = col.target.column\n+            if '.' in column_name:\n+                column_name = column_name.split('.', 1)[1]\n+            cols.append(column_name)\n+        return ', '.join(cols)\n         # Fix any PK-removed field\n         if restore_pk_field:\n             restore_pk_field.primary_key = True\n@@ -418,6 +455,7 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         # Delete the old through table\n         self.delete_model(old_field.remote_field.through)\n \n+\n     def add_constraint(self, model, constraint):\n         if isinstance(constraint, UniqueConstraint) and (\n             constraint.condition or\n@@ -440,5 +478,80 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n         else:\n             self._remake_table(model)\n \n+    def _create_unique_sql(self, model, columns, name=None, condition=None,\n+                          deferrable=None, include=None, opclasses=None):\n+        if condition or include or opclasses:\n+            # Use SQLite-specific expressions handling for complex constraints\n+            from django.db.backends.ddl_references import Expressions\n+            \n+            class SQLiteExpressions(Expressions):\n+                def __str__(self):\n+                    # Get the base column references without table qualification\n+                    cols = []\n+                    for col in self.compiler.query._gen_cols([self.expressions]):\n+                        # Strip table name from column reference for SQLite\n+                        if hasattr(col.target, 'column'):\n+                            cols.append(col.target.column)\n+                        else:\n+                            cols.append(str(col))\n+                    return ', '.join(self.compiler.quote_name_unless_alias(col) for col in cols)\n+            \n+            # Replace the expressions class temporarily\n+            original_expressions_class = self.connection.ops.__class__.sql_create_unique_index\n+            try:\n+                return super()._create_unique_sql(model, columns, name, condition, deferrable, include, opclasses)\n+            finally:\n+                pass\n+        else:\n+            return super()._create_unique_sql(model, columns, name, condition, deferrable, include, opclasses)\n+\n+    def _collate_sql(self, collation):\n+\n     def _collate_sql(self, collation):\n         return 'COLLATE ' + collation\n+\n+    def _create_unique_sql(self, model, columns, name, condition=None,\n+                          deferrable=None, include=None, expressions=None):\n+        if expressions:\n+            # SQLite doesn't support table-qualified column names in constraints\n+            # Use custom SQLiteExpressions to strip table qualifiers\n+            compiler = self._get_index_tablespace_sql(model, None, inline=True)\n+            table = Table(model._meta.db_table, self.quote_name)\n+            expressions_sql = SQLiteExpressions(table, expressions, compiler, self.quote_value)\n+            sql = self._create_index_sql(\n+                model, fields=None, name=name, suffix=\"\",\n+                using=None, db_tablespace=None, col_suffixes=(),\n+                sql=self.sql_create_unique_index, opclasses=(),\n+                condition=condition, include=include, expressions=expressions_sql,\n+            )\n+            return sql\n+        return super()._create_unique_sql(\n+            model, columns, name, condition, deferrable, include, expressions\n+        )\n+\n+\n+class SQLiteExpressions(Expressions):\n+    \"\"\"SQLite-specific expressions that strip table qualifiers from column names.\"\"\"\n+    \n+    def __str__(self):\n+        expressions = []\n+        for expression in self.expressions:\n+            expressions.append(\n+                expression.resolve_expression(\n+                    self.compiler.query, allow_joins=False, reuse=None\n+                ).as_sql(self.compiler, self.compiler.connection)[0]\n+            )\n+        # Strip table qualifiers - remove \"table_name.\" prefixes\n+        cleaned_expressions = []\n+        for expr in expressions:\n+            # Remove table qualifiers like \"myapp_mymodel.\" from column references\n+            if '.' in expr and not expr.startswith('\"'):\n+                # Simple case: table.column -> column\n+                parts = expr.split('.')\n+                if len(parts) == 2:\n+                    cleaned_expressions.append(parts[1])\n+                else:\n+                    cleaned_expressions.append(expr)\n+            else:\n+                cleaned_expressions.append(expr)\n+        return ', '.join(cleaned_expressions)\n"
  }
}