{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/sympy/sympy/integrals/intpoly.py lines 595-597)": "\n    if separate:\n        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n    return poly_dict\n",
    "Location 2 (/root/hy/projects_2/sympy/sympy/integrals/intpoly.py lines 571-572)": "\n            if separate:\n                return [monom[1] for monom in degrees]\n",
    "Location 3 (/root/hy/projects_2/sympy/sympy/integrals/intpoly.py lines 567-580)": "\ndef decompose(expr, separate=False):\n    \"\"\"\n    Decomposes an input polynomial into homogeneous ones of\n    smaller or equal degree.\n    Returns a dictionary with keys as the degree of the\n    homogeneous polynomials. Values are the homogeneous\n    polynomials.\n\n    Parameters\n    ==========\n    expr : Polynomial(SymPy expression)\n\n    Optional Parameters :\n\n    separate : If True then simply return a list of the\n    constituent homogeneous polynomials along with the\n    monomial constituting them.\n    By default uses the timeit module to test out the\n    different algorithms. Only works with 2D inputs.\n\n    Examples\n    ========\n    >>> from sympy.abc import x, y\n    >>> from sympy.integrals.intpoly import decompose\n    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5)\n    {1: x + y, 2: x**2 + x*y, 5: x**3*y**2 + y**5}\n    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5, True)\n    [x, y, x**2, y**5, x*y, x**3*y**2]\n    \"\"\"\n    expr = S(expr)\n    poly_dict = {}\n\n    if isinstance(expr, Expr) and not expr.is_number:\n        if expr.is_Symbol:\n            poly_dict[1] = expr\n        elif expr.is_Add:\n            symbols = expr.atoms(Symbol)\n            degrees = [(sum(degree_list(monom, *symbols)), monom)\n                       for monom in expr.args]\n            if separate:\n                return [monom[1] for monom in degrees]\n            else:\n                for monom in degrees:\n                    degree, term = monom\n                    if poly_dict.get(degree):\n                        poly_dict[degree] += term\n                    else:\n                        poly_dict[degree] = term\n        elif expr.is_Pow:\n            _, degree = expr.args\n            poly_dict[degree] = expr\n        else:  # Now expr can only be of `Mul` type\n            degree = 0\n            for term in expr.args:\n                term_type = len(term.args)\n                if term_type == 0 and term.is_Symbol:\n                    degree += 1\n                elif term_type == 2:\n                    degree += term.args[1]\n            poly_dict[degree] = expr\n    else:\n        poly_dict[0] = expr\n\n    if separate:\n        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n    else:\n        return poly_dict\n",
    "Location 4 (/root/hy/projects_2/sympy/sympy/integrals/intpoly.py lines 562-597)": "\ndef decompose(expr, separate=False):\n    \"\"\"Decomposes an input polynomial into homogeneous ones of\n    smaller or equal degree.\n    Returns a dictionary with keys as the degree of the smaller\n    constituting polynomials. Values are the constituting polynomials.\n    Parameters\n    ==========\n    expr : Polynomial(SymPy expression)\n\n    Optional Parameters :\n\n    separate : If True then simply return a list of the constituent monomials\n               If not then break up the polynomial into constituent homogeneous\n               polynomials.\n    Examples\n    ========\n    >>> from sympy.abc import x, y\n    >>> from sympy.integrals.intpoly import decompose\n    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5)\n    {1: x + y, 2: x**2 + x*y, 5: x**3*y**2 + y**5}\n    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5, True)\n    [x, y, x**2, y**5, x*y, x**3*y**2]\n    \"\"\"\n    expr = S(expr)\n    poly_dict = {}\n\n    if isinstance(expr, Expr) and not expr.is_number:\n        if expr.is_Symbol:\n            poly_dict[1] = expr\n        elif expr.is_Add:\n            symbols = expr.atoms(Symbol)\n            degrees = [(sum(degree_list(monom, *symbols)), monom)\n                       for monom in expr.args]\n            if separate:\n                return [monom[1] for monom in degrees]\n            else:\n                for monom in degrees:\n                    degree, term = monom\n                    if poly_dict.get(degree):\n                        poly_dict[degree] += term\n                    else:\n                        poly_dict[degree] = term\n        elif expr.is_Pow:\n            _, degree = expr.args\n            poly_dict[degree] = expr\n        else:  # Now expr can only be of `Mul` type\n            degree = 0\n            for term in expr.args:\n                term_type = len(term.args)\n                if term_type == 0 and term.is_Symbol:\n                    degree += 1\n                elif term_type == 2:\n                    degree += term.args[1]\n            poly_dict[degree] = expr\n    else:\n        poly_dict[0] = expr\n\n    if separate:\n        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n    return poly_dict\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/sympy/sympy/integrals/intpoly.py lines 595-597)": [
      "\n    if separate:\n        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n    return poly_dict\n",
      "\n    if separate:\n        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n    return poly_dict\n",
      "\n    if separate:\n        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n    return poly_dict\n",
      "\n    if separate:\n        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n    return poly_dict\n",
      "\n    if separate:\n        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n    return poly_dict\n",
      "\n    if separate:\n        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n    return poly_dict\n",
      "\n    if separate:\n        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n    return poly_dict\n",
      "\n    if separate:\n        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n    return poly_dict\n"
    ],
    "Location 2 (/root/hy/projects_2/sympy/sympy/integrals/intpoly.py lines 571-572)": [
      "\n            if separate:\n                return [monom[1] for monom in degrees]\n",
      "\n            if separate:\n                return [monom[1] for monom in degrees]\n",
      "\n            if separate:\n                return [monom[1] for monom in degrees]\n",
      "\n            if separate:\n                return [monom[1] for monom in degrees]\n",
      "\n            if separate:\n                return [monom[1] for monom in degrees]\n",
      "\n            if separate:\n                return [monom[1] for monom in degrees]\n",
      "\n            if separate:\n                return [monom[1] for monom in degrees]\n",
      "\n            if separate:\n                return [monom[1] for monom in sorted(degrees, key=lambda x: x[0])]\n"
    ],
    "Location 3 (/root/hy/projects_2/sympy/sympy/integrals/intpoly.py lines 567-580)": [
      "\ndef decompose(expr, separate=False):\n    \"\"\"\n    Decomposes an input polynomial into homogeneous ones of\n    smaller or equal degree.\n    Returns a dictionary with keys as the degree of the smaller\n    constituting polynomials. Values are the constituting polynomials.\n    Parameters\n    ==========\n    expr : Polynomial(SymPy expression)\n\n    Optional Parameters :\n\n    separate : If True then simply return a list of the constituent monomials\n               If not then break up the polynomial into constituent homogeneous\n               polynomials.\n    Examples\n    ========\n    >>> from sympy.abc import x, y\n    >>> from sympy.integrals.intpoly import decompose\n    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5)\n    {1: x + y, 2: x**2 + x*y, 5: x**3*y**2 + y**5}\n    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5, True)\n    [x, y, x**2, y**5, x*y, x**3*y**2]\n    \"\"\"\n    expr = S(expr)\n    poly_dict = {}\n\n    if isinstance(expr, Expr) and not expr.is_number:\n        if expr.is_Symbol:\n            poly_dict[1] = expr\n        elif expr.is_Add:\n            symbols = expr.atoms(Symbol)\n            degrees = [(sum(degree_list(monom, *symbols)), monom)\n                       for monom in expr.args]\n            if separate:\n                return [monom[1] for monom in degrees]\n            else:\n                for monom in degrees:\n                    degree, term = monom\n                    if poly_dict.get(degree):\n                        poly_dict[degree] += term\n                    else:\n                        poly_dict[degree] = term\n        elif expr.is_Pow:\n            _, degree = expr.args\n            poly_dict[degree] = expr\n        else:  # Now expr can only be of `Mul` type\n            degree = 0\n            for term in expr.args:\n                term_type = len(term.args)\n                if term_type == 0 and term.is_Symbol:\n                    degree += 1\n                elif term_type == 2:\n                    degree += term.args[1]\n            poly_dict[degree] = expr\n    else:\n        poly_dict[0] = expr\n\n    if separate:\n        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n    else:\n        return poly_dict\n",
      "\ndef decompose(expr, separate=False):\n    \"\"\"\n    Decomposes an input polynomial into homogeneous ones of\n    smaller or equal degree.\n    Returns a dictionary with keys as the degree of the smaller\n    constituting polynomials. Values are the constituting polynomials.\n    Parameters\n    ==========\n    expr : Polynomial(SymPy expression)\n\n    Optional Parameters :\n\n    separate : If True then simply return a list of the constituent monomials\n               If not then break up the polynomial into constituent homogeneous\n               polynomials.\n    Examples\n    ========\n    >>> from sympy.abc import x, y\n    >>> from sympy.integrals.intpoly import decompose\n    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5)\n    {1: x + y, 2: x**2 + x*y, 5: x**3*y**2 + y**5}\n    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5, True)\n    [x, y, x**2, y**5, x*y, x**3*y**2]\n    \"\"\"\n    expr = S(expr)\n    poly_dict = {}\n\n    if isinstance(expr, Expr) and not expr.is_number:\n        if expr.is_Symbol:\n            poly_dict[1] = expr\n        elif expr.is_Add:\n            symbols = expr.atoms(Symbol)\n            degrees = [(sum(degree_list(monom, *symbols)), monom)\n                       for monom in expr.args]\n            if separate:\n                return [monom[1] for monom in degrees]\n            else:\n                for monom in degrees:\n                    degree, term = monom\n                    if poly_dict.get(degree):\n                        poly_dict[degree] += term\n                    else:\n                        poly_dict[degree] = term\n        elif expr.is_Pow:\n            _, degree = expr.args\n            poly_dict[degree] = expr\n        else:  # Now expr can only be of `Mul` type\n            degree = 0\n            for term in expr.args:\n                term_type = len(term.args)\n                if term_type == 0 and term.is_Symbol:\n                    degree += 1\n                elif term_type == 2:\n                    degree += term.args[1]\n            poly_dict[degree] = expr\n    else:\n        poly_dict[0] = expr\n\n    if separate:\n        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n    else:\n        return poly_dict\n",
      "\n    elif expr.is_Add:\n        symbols = expr.atoms(Symbol)\n        degrees = [(sum(degree_list(monom, *symbols)), monom)\n                   for monom in expr.args]\n        if separate:\n            return [monom[1] for monom in degrees]\n        else:\n            for monom in degrees:\n                degree, term = monom\n                if poly_dict.get(degree):\n                    poly_dict[degree] += term\n                else:\n                    poly_dict[degree] = term\n",
      "\n    elif expr.is_Add:\n        symbols = expr.atoms(Symbol)\n        degrees = [(sum(degree_list(monom, *symbols)), monom)\n                   for monom in expr.args]\n        if separate:\n            return [monom[1] for monom in degrees]\n        else:\n            for monom in degrees:\n                degree, term = monom\n                if poly_dict.get(degree):\n                    poly_dict[degree] += term\n                else:\n                    poly_dict[degree] = term\n",
      "\n    elif expr.is_Add:\n        symbols = expr.atoms(Symbol)\n        degrees = [(sum(degree_list(monom, *symbols)), monom)\n                   for monom in expr.args]\n        if separate:\n            return [monom[1] for monom in degrees]\n        else:\n            for monom in degrees:\n                degree, term = monom\n                if poly_dict.get(degree):\n                    poly_dict[degree] += term\n                else:\n                    poly_dict[degree] = term\n",
      "\n    elif expr.is_Add:\n        symbols = expr.atoms(Symbol)\n        degrees = [(sum(degree_list(monom, *symbols)), monom)\n                   for monom in expr.args]\n        if separate:\n            return [monom[1] for monom in degrees]\n        else:\n            for monom in degrees:\n                degree, term = monom\n                if poly_dict.get(degree):\n                    poly_dict[degree] += term\n                else:\n                    poly_dict[degree] = term\n",
      "\n    elif expr.is_Add:\n        symbols = expr.atoms(Symbol)\n        degrees = [(sum(degree_list(monom, *symbols)), monom)\n                   for monom in expr.args]\n        if separate:\n            return [monom[1] for monom in degrees]\n        else:\n            for monom in degrees:\n                degree, term = monom\n                if poly_dict.get(degree):\n                    poly_dict[degree] += term\n                else:\n                    poly_dict[degree] = term\n",
      "\n    elif expr.is_Add:\n        symbols = expr.atoms(Symbol)\n        degrees = [(sum(degree_list(monom, *symbols)), monom)\n                   for monom in expr.args]\n        if separate:\n            return [monom[1] for monom in degrees]\n        else:\n            for monom in degrees:\n                degree, term = monom\n                if poly_dict.get(degree):\n                    poly_dict[degree] += term\n                else:\n                    poly_dict[degree] = term\n"
    ],
    "Location 4 (/root/hy/projects_2/sympy/sympy/integrals/intpoly.py lines 562-597)": [
      "\ndef decompose(expr, separate=False):\n    \"\"\"Decomposes an input polynomial into homogeneous ones of\n    smaller or equal degree.\n    Returns a dictionary with keys as the degree of the smaller\n    constituting polynomials. Values are the constituting polynomials.\n    Parameters\n    ==========\n    expr : Polynomial(SymPy expression)\n\n    Optional Parameters :\n\n    separate : If True then simply return a list of the constituent monomials\n               If not then break up the polynomial into constituent homogeneous\n               polynomials.\n    Examples\n    ========\n    >>> from sympy.abc import x, y\n    >>> from sympy.integrals.intpoly import decompose\n    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5)\n    {1: x + y, 2: x**2 + x*y, 5: x**3*y**2 + y**5}\n    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5, True)\n    [x, y, x**2, y**5, x*y, x**3*y**2]\n    \"\"\"\n    expr = S(expr)\n    poly_dict = {}\n\n    if isinstance(expr, Expr) and not expr.is_number:\n        if expr.is_Symbol:\n            poly_dict[1] = expr\n        elif expr.is_Add:\n            symbols = expr.atoms(Symbol)\n            degrees = [(sum(degree_list(monom, *symbols)), monom)\n                       for monom in expr.args]\n            if separate:\n                return [monom[1] for monom in degrees]\n            else:\n                for monom in degrees:\n                    degree, term = monom\n                    if poly_dict.get(degree):\n                        poly_dict[degree] += term\n                    else:\n                        poly_dict[degree] = term\n        elif expr.is_Pow:\n            _, degree = expr.args\n            poly_dict[degree] = expr\n        else:  # Now expr can only be of `Mul` type\n            degree = 0\n            for term in expr.args:\n                term_type = len(term.args)\n                if term_type == 0 and term.is_Symbol:\n                    degree += 1\n                elif term_type == 2:\n                    degree += term.args[1]\n            poly_dict[degree] = expr\n    else:\n        poly_dict[0] = expr\n\n    if separate:\n        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n    return poly_dict\n",
      "\ndef decompose(expr, separate=False):\n    \"\"\"Decomposes an input polynomial into homogeneous ones of\n    smaller or equal degree.\n    Returns a dictionary with keys as the degree of the smaller\n    constituting polynomials. Values are the constituting polynomials.\n    Parameters\n    ==========\n    expr : Polynomial(SymPy expression)\n\n    Optional Parameters :\n\n    separate : If True then simply return a list of the constituent monomials\n               If not then break up the polynomial into constituent homogeneous\n               polynomials.\n    Examples\n    ========\n    >>> from sympy.abc import x, y\n    >>> from sympy.integrals.intpoly import decompose\n    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5)\n    {1: x + y, 2: x**2 + x*y, 5: x**3*y**2 + y**5}\n    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5, True)\n    [x, y, x**2, y**5, x*y, x**3*y**2]\n    \"\"\"\n    expr = S(expr)\n    poly_dict = {}\n\n    if isinstance(expr, Expr) and not expr.is_number:\n        if expr.is_Symbol:\n            poly_dict[1] = expr\n        elif expr.is_Add:\n            symbols = expr.atoms(Symbol)\n            degrees = [(sum(degree_list(monom, *symbols)), monom)\n                       for monom in expr.args]\n            if separate:\n                return [monom[1] for monom in degrees]\n            else:\n                for monom in degrees:\n                    degree, term = monom\n                    if poly_dict.get(degree):\n                        poly_dict[degree] += term\n                    else:\n                        poly_dict[degree] = term\n        elif expr.is_Pow:\n            _, degree = expr.args\n            poly_dict[degree] = expr\n        else:  # Now expr can only be of `Mul` type\n            degree = 0\n            for term in expr.args:\n                term_type = len(term.args)\n                if term_type == 0 and term.is_Symbol:\n                    degree += 1\n                elif term_type == 2:\n                    degree += term.args[1]\n            poly_dict[degree] = expr\n    else:\n        poly_dict[0] = expr\n\n    if separate:\n        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n    return poly_dict\n",
      "\ndef decompose(expr, separate=False):\n    \"\"\"Decomposes an input polynomial into homogeneous ones of\n    smaller or equal degree.\n    Returns a dictionary with keys as the degree of the smaller\n    constituting polynomials. Values are the constituting polynomials.\n    Parameters\n    ==========\n    expr : Polynomial(SymPy expression)\n    separate : If True then simply return a list of the constituent\n               monomials of expr\n    Examples\n    ========\n    >>> from sympy.abc import x, y\n    >>> from sympy.integrals.intpoly import decompose\n    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5)\n    {1: x + y, 2: x**2 + x*y, 5: x**3*y**2 + y**5}\n    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5, True)\n    [x, y, x**2, y**5, x*y, x**3*y**2]\n    \"\"\"\n    expr = S(expr)\n    poly_dict = {}\n\n    if isinstance(expr, Expr) and not expr.is_number:\n        if expr.is_Symbol:\n            poly_dict[1] = expr\n        elif expr.is_Add:\n            symbols = expr.atoms(Symbol)\n            degrees = [(sum(degree_list(monom, *symbols)), monom)\n                       for monom in expr.args]\n            if separate:\n                return [monom[1] for monom in degrees]\n            else:\n                for monom in degrees:\n                    degree, term = monom\n                    if poly_dict.get(degree):\n                        poly_dict[degree] += term\n                    else:\n                        poly_dict[degree] = term\n        elif expr.is_Pow:\n            _, degree = expr.args\n            poly_dict[degree] = expr\n        else:  # Now expr can only be of `Mul` type\n            degree = 0\n            for term in expr.args:\n                term_type = len(term.args)\n                if term_type == 0 and term.is_Symbol:\n                    degree += 1\n                elif term_type == 2:\n                    degree += term.args[1]\n            poly_dict[degree] = expr\n    else:\n        poly_dict[0] = expr\n\n    if separate:\n        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n    return poly_dict\n",
      "\ndef decompose(expr, separate=False):\n    \"\"\"Decomposes an input polynomial into homogeneous ones of\n    smaller or equal degree.\n    Returns a dictionary with keys as the degree of the smaller\n    constituting polynomials. Values are the constituting polynomials.\n    Parameters\n    ==========\n    expr : Polynomial(SymPy expression)\n\n    Optional Parameters :\n\n    separate : If True then simply return a list of the constituent monomials\n               If not then break up the polynomial into constituent homogeneous\n               polynomials.\n    Examples\n    ========\n    >>> from sympy.abc import x, y\n    >>> from sympy.integrals.intpoly import decompose\n    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5)\n    {1: x + y, 2: x**2 + x*y, 5: x**3*y**2 + y**5}\n    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5, True)\n    [x, y, x**2, y**5, x*y, x**3*y**2]\n    \"\"\"\n    expr = S(expr)\n    poly_dict = {}\n\n    if isinstance(expr, Expr) and not expr.is_number:\n        if expr.is_Symbol:\n            poly_dict[1] = expr\n        elif expr.is_Add:\n            symbols = expr.atoms(Symbol)\n            degrees = [(sum(degree_list(monom, *symbols)), monom)\n                       for monom in expr.args]\n            if separate:\n                return [monom[1] for monom in degrees]\n            else:\n                for monom in degrees:\n                    degree, term = monom\n                    if poly_dict.get(degree):\n                        poly_dict[degree] += term\n                    else:\n                        poly_dict[degree] = term\n        elif expr.is_Pow:\n            _, degree = expr.args\n            poly_dict[degree] = expr\n        else:  # Now expr can only be of `Mul` type\n            degree = 0\n            for term in expr.args:\n                term_type = len(term.args)\n                if term_type == 0 and term.is_Symbol:\n                    degree += 1\n                elif term_type == 2:\n                    degree += term.args[1]\n            poly_dict[degree] = expr\n    else:\n        poly_dict[0] = expr\n\n    if separate:\n        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n    return poly_dict\n",
      "\ndef decompose(expr, separate=False):\n    \"\"\"Decomposes an input polynomial into homogeneous ones of\n    smaller or equal degree.\n    Returns a dictionary with keys as the degree of the smaller\n    constituting polynomials. Values are the constituting polynomials.\n    Parameters\n    ==========\n    expr : Polynomial(SymPy expression)\n\n    Optional Parameters :\n\n    separate : If True then simply return a list of the constituent monomials\n               If not then break up the polynomial into constituent homogeneous\n               polynomials.\n    Examples\n    ========\n    >>> from sympy.abc import x, y\n    >>> from sympy.integrals.intpoly import decompose\n    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5)\n    {1: x + y, 2: x**2 + x*y, 5: x**3*y**2 + y**5}\n    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5, True)\n    [x, y, x**2, y**5, x*y, x**3*y**2]\n    \"\"\"\n    expr = S(expr)\n    poly_dict = {}\n\n    if isinstance(expr, Expr) and not expr.is_number:\n        if expr.is_Symbol:\n            poly_dict[1] = expr\n        elif expr.is_Add:\n            symbols = expr.atoms(Symbol)\n            degrees = [(sum(degree_list(monom, *symbols)), monom)\n                       for monom in expr.args]\n            if separate:\n                return [monom[1] for monom in degrees]\n            else:\n                for monom in degrees:\n                    degree, term = monom\n                    if poly_dict.get(degree):\n                        poly_dict[degree] += term\n                    else:\n                        poly_dict[degree] = term\n        elif expr.is_Pow:\n            _, degree = expr.args\n            poly_dict[degree] = expr\n        else:  # Now expr can only be of `Mul` type\n            degree = 0\n            for term in expr.args:\n                term_type = len(term.args)\n                if term_type == 0 and term.is_Symbol:\n                    degree += 1\n                elif term_type == 2:\n                    degree += term.args[1]\n            poly_dict[degree] = expr\n    else:\n        poly_dict[0] = expr\n\n    if separate:\n        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n    return poly_dict\n",
      "\ndef decompose(expr, separate=False):\n    \"\"\"Decomposes an input polynomial into homogeneous ones of\n    smaller or equal degree.\n    Returns a dictionary with keys as the degree of the smaller\n    constituting polynomials. Values are the constituting polynomials.\n    Parameters\n    ==========\n    expr : Polynomial(SymPy expression)\n\n    Optional Parameters :\n\n    separate : If True then simply return a list of the constituent monomials\n               If not then break up the polynomial into constituent homogeneous\n               polynomials.\n    Examples\n    ========\n    >>> from sympy.abc import x, y\n    >>> from sympy.integrals.intpoly import decompose\n    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5)\n    {1: x + y, 2: x**2 + x*y, 5: x**3*y**2 + y**5}\n    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5, True)\n    [x, y, x**2, y**5, x*y, x**3*y**2]\n    \"\"\"\n    expr = S(expr)\n    poly_dict = {}\n\n    if isinstance(expr, Expr) and not expr.is_number:\n        if expr.is_Symbol:\n            poly_dict[1] = expr\n        elif expr.is_Add:\n            symbols = expr.atoms(Symbol)\n            degrees = [(sum(degree_list(monom, *symbols)), monom)\n                       for monom in expr.args]\n            if separate:\n                return [monom[1] for monom in degrees]\n            else:\n                for monom in degrees:\n                    degree, term = monom\n                    if poly_dict.get(degree):\n                        poly_dict[degree] += term\n                    else:\n                        poly_dict[degree] = term\n        elif expr.is_Pow:\n            _, degree = expr.args\n            poly_dict[degree] = expr\n        else:  # Now expr can only be of `Mul` type\n            degree = 0\n            for term in expr.args:\n                term_type = len(term.args)\n                if term_type == 0 and term.is_Symbol:\n                    degree += 1\n                elif term_type == 2:\n                    degree += term.args[1]\n            poly_dict[degree] = expr\n    else:\n        poly_dict[0] = expr\n\n    if separate:\n        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n    return poly_dict\n",
      "\ndef decompose(expr, separate=False):\n    \"\"\"Decomposes an input polynomial into homogeneous ones of\n    smaller or equal degree.\n    Returns a dictionary with keys as the degree of the smaller\n    constituting polynomials. Values are the constituting polynomials.\n    Parameters\n    ==========\n    expr : Polynomial(SymPy expression)\n\n    Optional Parameters :\n\n    separate : If True then simply return a list of the constituent monomials\n               If not then break up the polynomial into constituent homogeneous\n               polynomials.\n    Examples\n    ========\n    >>> from sympy.abc import x, y\n    >>> from sympy.integrals.intpoly import decompose\n    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5)\n    {1: x + y, 2: x**2 + x*y, 5: x**3*y**2 + y**5}\n    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5, True)\n    [x, y, x**2, y**5, x*y, x**3*y**2]\n    \"\"\"\n    expr = S(expr)\n    poly_dict = {}\n\n    if isinstance(expr, Expr) and not expr.is_number:\n        if expr.is_Symbol:\n            poly_dict[1] = expr\n        elif expr.is_Add:\n            symbols = expr.atoms(Symbol)\n            degrees = [(sum(degree_list(monom, *symbols)), monom)\n                       for monom in expr.args]\n            if separate:\n                return [monom[1] for monom in degrees]\n            else:\n                for monom in degrees:\n                    degree, term = monom\n                    if poly_dict.get(degree):\n                        poly_dict[degree] += term\n                    else:\n                        poly_dict[degree] = term\n        elif expr.is_Pow:\n            _, degree = expr.args\n            poly_dict[degree] = expr\n        else:  # Now expr can only be of `Mul` type\n            degree = 0\n            for term in expr.args:\n                term_type = len(term.args)\n                if term_type == 0 and term.is_Symbol:\n                    degree += 1\n                elif term_type == 2:\n                    degree += term.args[1]\n            poly_dict[degree] = expr\n    else:\n        poly_dict[0] = expr\n\n    if separate:\n        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n    return poly_dict\n",
      "\ndef decompose(expr, separate=False):\n    \"\"\"Decomposes an input polynomial into homogeneous ones of\n    smaller or equal degree.\n    Returns a dictionary with keys as the degree of the smaller\n    constituting polynomials. Values are the constituting polynomials.\n    Parameters\n    ==========\n    expr : Polynomial(SymPy expression)\n\n    Optional Parameters :\n\n    separate : If True then simply return a list of the constituent monomials\n               If not then break up the polynomial into constituent homogeneous\n               polynomials.\n    Examples\n    ========\n    >>> from sympy.abc import x, y\n    >>> from sympy.integrals.intpoly import decompose\n    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5)\n    {1: x + y, 2: x**2 + x*y, 5: x**3*y**2 + y**5}\n    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5, True)\n    [x, y, x**2, y**5, x*y, x**3*y**2]\n    \"\"\"\n    expr = S(expr)\n    poly_dict = {}\n\n    if isinstance(expr, Expr) and not expr.is_number:\n        if expr.is_Symbol:\n            poly_dict[1] = expr\n        elif expr.is_Add:\n            symbols = expr.atoms(Symbol)\n            degrees = [(sum(degree_list(monom, *symbols)), monom)\n                       for monom in expr.args]\n            if separate:\n                return [monom[1] for monom in degrees]\n            else:\n                for monom in degrees:\n                    degree, term = monom\n                    if poly_dict.get(degree):\n                        poly_dict[degree] += term\n                    else:\n                        poly_dict[degree] = term\n        elif expr.is_Pow:\n            _, degree = expr.args\n            poly_dict[degree] = expr\n        else:  # Now expr can only be of `Mul` type\n            degree = 0\n            for term in expr.args:\n                term_type = len(term.args)\n                if term_type == 0 and term.is_Symbol:\n                    degree += 1\n                elif term_type == 2:\n                    degree += term.args[1]\n            poly_dict[degree] = expr\n    else:\n        poly_dict[0] = expr\n\n    if separate:\n        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n    return poly_dict\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sympy/integrals/intpoly.py b/sympy/integrals/intpoly.py\nindex fc72bd206f..09959ab894 100644\n--- a/sympy/integrals/intpoly.py\n+++ b/sympy/integrals/intpoly.py\n@@ -559,6 +559,7 @@ def decompose(expr, separate=False):\n     [x, y, x**2, y**5, x*y, x**3*y**2]\n     \"\"\"\n     expr = S(expr)\n+\n     poly_dict = {}\n \n     if isinstance(expr, Expr) and not expr.is_number:\n@@ -593,7 +594,10 @@ def decompose(expr, separate=False):\n         poly_dict[0] = expr\n \n     if separate:\n-        return list(poly_dict.values())\n+        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n+    return poly_dict\n+    if separate:\n+        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n     return poly_dict\n \n \n",
    "variant_0": "diff --git a/sympy/integrals/intpoly.py b/sympy/integrals/intpoly.py\nindex fc72bd206f..ffdd731b27 100644\n--- a/sympy/integrals/intpoly.py\n+++ b/sympy/integrals/intpoly.py\n@@ -559,6 +559,67 @@ def decompose(expr, separate=False):\n     [x, y, x**2, y**5, x*y, x**3*y**2]\n     \"\"\"\n     expr = S(expr)\n+\n+def decompose(expr, separate=False):\n+    \"\"\"Decomposes an input polynomial into homogeneous ones of\n+    smaller or equal degree.\n+    Returns a dictionary with keys as the degree of the smaller\n+    constituting polynomials. Values are the constituting polynomials.\n+    Parameters\n+    ==========\n+    expr : Polynomial(SymPy expression)\n+\n+    Optional Parameters :\n+\n+    separate : If True then simply return a list of the constituent monomials\n+               If not then break up the polynomial into constituent homogeneous\n+               polynomials.\n+    Examples\n+    ========\n+    >>> from sympy.abc import x, y\n+    >>> from sympy.integrals.intpoly import decompose\n+    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5)\n+    {1: x + y, 2: x**2 + x*y, 5: x**3*y**2 + y**5}\n+    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5, True)\n+    [x, y, x**2, y**5, x*y, x**3*y**2]\n+    \"\"\"\n+    expr = S(expr)\n+    poly_dict = {}\n+\n+    if isinstance(expr, Expr) and not expr.is_number:\n+        if expr.is_Symbol:\n+            poly_dict[1] = expr\n+        elif expr.is_Add:\n+            symbols = expr.atoms(Symbol)\n+            degrees = [(sum(degree_list(monom, *symbols)), monom)\n+                       for monom in expr.args]\n+            if separate:\n+                return [monom[1] for monom in degrees]\n+            else:\n+                for monom in degrees:\n+                    degree, term = monom\n+                    if poly_dict.get(degree):\n+                        poly_dict[degree] += term\n+                    else:\n+                        poly_dict[degree] = term\n+        elif expr.is_Pow:\n+            _, degree = expr.args\n+            poly_dict[degree] = expr\n+        else:  # Now expr can only be of `Mul` type\n+            degree = 0\n+            for term in expr.args:\n+                term_type = len(term.args)\n+                if term_type == 0 and term.is_Symbol:\n+                    degree += 1\n+                elif term_type == 2:\n+                    degree += term.args[1]\n+            poly_dict[degree] = expr\n+    else:\n+        poly_dict[0] = expr\n+\n+    if separate:\n+        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n+    return poly_dict\n     poly_dict = {}\n \n     if isinstance(expr, Expr) and not expr.is_number:\n@@ -593,7 +654,27 @@ def decompose(expr, separate=False):\n         poly_dict[0] = expr\n \n     if separate:\n-        return list(poly_dict.values())\n+        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n+    else:\n+        return poly_dict\n+        elif expr.is_Pow:\n+            _, degree = expr.args\n+            poly_dict[degree] = expr\n+        else:  # Now expr can only be of `Mul` type\n+            degree = 0\n+            for term in expr.args:\n+                term_type = len(term.args)\n+                if term_type == 0 and term.is_Symbol:\n+                    degree += 1\n+                elif term_type == 2:\n+                    degree += term.args[1]\n+            poly_dict[degree] = expr\n+    else:\n+        poly_dict[0] = expr\n+\n+\n+    if separate:\n+        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n     return poly_dict\n \n \n",
    "variant_1": "diff --git a/sympy/integrals/intpoly.py b/sympy/integrals/intpoly.py\nindex fc72bd206f..7f1e2b6810 100644\n--- a/sympy/integrals/intpoly.py\n+++ b/sympy/integrals/intpoly.py\n@@ -535,6 +535,31 @@ def y_axis_cut(ls):\n     return x0\n \n \n+def decompose(expr, separate=False):\n+    \"\"\"Decomposes an input polynomial into homogeneous ones of\n+    smaller or equal degree.\n+    Returns a dictionary with keys as the degree of the smaller\n+    constituting polynomials. Values are the constituting polynomials.\n+    Parameters\n+    ==========\n+    expr : Polynomial(SymPy expression)\n+\n+    Optional Parameters :\n+\n+    separate : If True then simply return a list of the constituent monomials\n+               If not then break up the polynomial into constituent homogeneous\n+               polynomials.\n+    Examples\n+    ========\n+    >>> from sympy.abc import x, y\n+    >>> from sympy.integrals.intpoly import decompose\n+    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5)\n+    {1: x + y, 2: x**2 + x*y, 5: x**3*y**2 + y**5}\n+    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5, True)\n+    [x, y, x**2, y**5, x*y, x**3*y**2]\n+    \"\"\"\n+    expr = S(expr)\n+\n def decompose(expr, separate=False):\n     \"\"\"Decomposes an input polynomial into homogeneous ones of\n     smaller or equal degree.\n@@ -593,7 +618,58 @@ def decompose(expr, separate=False):\n         poly_dict[0] = expr\n \n     if separate:\n-        return list(poly_dict.values())\n+        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n+    return poly_dict\n+        elif expr.is_Add:\n+            symbols = expr.atoms(Symbol)\n+            degrees = [(sum(degree_list(monom, *symbols)), monom)\n+                       for monom in expr.args]\n+            if separate:\n+                return [monom[1] for monom in degrees]\n+            else:\n+                for monom in degrees:\n+                    degree, term = monom\n+                    if poly_dict.get(degree):\n+                        poly_dict[degree] += term\n+                    else:\n+                        poly_dict[degree] = term\n+        elif expr.is_Pow:\n+            _, degree = expr.args\n+            poly_dict[degree] = expr\n+        else:  # Now expr can only be of `Mul` type\n+            degree = 0\n+            for term in expr.args:\n+                term_type = len(term.args)\n+                if term_type == 0 and term.is_Symbol:\n+                    degree += 1\n+                elif term_type == 2:\n+                    degree += term.args[1]\n+            poly_dict[degree] = expr\n+    else:\n+        poly_dict[0] = expr\n+\n+    if separate:\n+        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n+    else:\n+        return poly_dict\n+        elif expr.is_Pow:\n+            _, degree = expr.args\n+            poly_dict[degree] = expr\n+        else:  # Now expr can only be of `Mul` type\n+            degree = 0\n+            for term in expr.args:\n+                term_type = len(term.args)\n+                if term_type == 0 and term.is_Symbol:\n+                    degree += 1\n+                elif term_type == 2:\n+                    degree += term.args[1]\n+            poly_dict[degree] = expr\n+    else:\n+        poly_dict[0] = expr\n+\n+\n+    if separate:\n+        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n     return poly_dict\n \n \n",
    "variant_2": "diff --git a/sympy/integrals/intpoly.py b/sympy/integrals/intpoly.py\nindex fc72bd206f..7f1e2b6810 100644\n--- a/sympy/integrals/intpoly.py\n+++ b/sympy/integrals/intpoly.py\n@@ -535,6 +535,31 @@ def y_axis_cut(ls):\n     return x0\n \n \n+def decompose(expr, separate=False):\n+    \"\"\"Decomposes an input polynomial into homogeneous ones of\n+    smaller or equal degree.\n+    Returns a dictionary with keys as the degree of the smaller\n+    constituting polynomials. Values are the constituting polynomials.\n+    Parameters\n+    ==========\n+    expr : Polynomial(SymPy expression)\n+\n+    Optional Parameters :\n+\n+    separate : If True then simply return a list of the constituent monomials\n+               If not then break up the polynomial into constituent homogeneous\n+               polynomials.\n+    Examples\n+    ========\n+    >>> from sympy.abc import x, y\n+    >>> from sympy.integrals.intpoly import decompose\n+    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5)\n+    {1: x + y, 2: x**2 + x*y, 5: x**3*y**2 + y**5}\n+    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5, True)\n+    [x, y, x**2, y**5, x*y, x**3*y**2]\n+    \"\"\"\n+    expr = S(expr)\n+\n def decompose(expr, separate=False):\n     \"\"\"Decomposes an input polynomial into homogeneous ones of\n     smaller or equal degree.\n@@ -593,7 +618,58 @@ def decompose(expr, separate=False):\n         poly_dict[0] = expr\n \n     if separate:\n-        return list(poly_dict.values())\n+        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n+    return poly_dict\n+        elif expr.is_Add:\n+            symbols = expr.atoms(Symbol)\n+            degrees = [(sum(degree_list(monom, *symbols)), monom)\n+                       for monom in expr.args]\n+            if separate:\n+                return [monom[1] for monom in degrees]\n+            else:\n+                for monom in degrees:\n+                    degree, term = monom\n+                    if poly_dict.get(degree):\n+                        poly_dict[degree] += term\n+                    else:\n+                        poly_dict[degree] = term\n+        elif expr.is_Pow:\n+            _, degree = expr.args\n+            poly_dict[degree] = expr\n+        else:  # Now expr can only be of `Mul` type\n+            degree = 0\n+            for term in expr.args:\n+                term_type = len(term.args)\n+                if term_type == 0 and term.is_Symbol:\n+                    degree += 1\n+                elif term_type == 2:\n+                    degree += term.args[1]\n+            poly_dict[degree] = expr\n+    else:\n+        poly_dict[0] = expr\n+\n+    if separate:\n+        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n+    else:\n+        return poly_dict\n+        elif expr.is_Pow:\n+            _, degree = expr.args\n+            poly_dict[degree] = expr\n+        else:  # Now expr can only be of `Mul` type\n+            degree = 0\n+            for term in expr.args:\n+                term_type = len(term.args)\n+                if term_type == 0 and term.is_Symbol:\n+                    degree += 1\n+                elif term_type == 2:\n+                    degree += term.args[1]\n+            poly_dict[degree] = expr\n+    else:\n+        poly_dict[0] = expr\n+\n+\n+    if separate:\n+        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n     return poly_dict\n \n \n",
    "variant_3": "diff --git a/sympy/integrals/intpoly.py b/sympy/integrals/intpoly.py\nindex fc72bd206f..2b90b4dfa7 100644\n--- a/sympy/integrals/intpoly.py\n+++ b/sympy/integrals/intpoly.py\n@@ -559,6 +559,27 @@ def decompose(expr, separate=False):\n     [x, y, x**2, y**5, x*y, x**3*y**2]\n     \"\"\"\n     expr = S(expr)\n+\n+def decompose(expr, separate=False):\n+    \"\"\"Decomposes an input polynomial into homogeneous ones of\n+    smaller or equal degree.\n+    Returns a dictionary with keys as the degree of the smaller\n+    constituting polynomials. Values are the constituting polynomials.\n+    Parameters\n+    ==========\n+    expr : Polynomial(SymPy expression)\n+    separate : If True then simply return a list of the constituent\n+               monomials of expr\n+    Examples\n+    ========\n+    >>> from sympy.abc import x, y\n+    >>> from sympy.integrals.intpoly import decompose\n+    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5)\n+    {1: x + y, 2: x**2 + x*y, 5: x**3*y**2 + y**5}\n+    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5, True)\n+    [x, y, x**2, y**5, x*y, x**3*y**2]\n+    \"\"\"\n+    expr = S(expr)\n     poly_dict = {}\n \n     if isinstance(expr, Expr) and not expr.is_number:\n@@ -593,7 +614,9 @@ def decompose(expr, separate=False):\n         poly_dict[0] = expr\n \n     if separate:\n-        return list(poly_dict.values())\n+        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n+    return poly_dict\n+        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n     return poly_dict\n \n \n",
    "variant_4": "diff --git a/sympy/integrals/intpoly.py b/sympy/integrals/intpoly.py\nindex fc72bd206f..2580506005 100644\n--- a/sympy/integrals/intpoly.py\n+++ b/sympy/integrals/intpoly.py\n@@ -535,6 +535,31 @@ def y_axis_cut(ls):\n     return x0\n \n \n+def decompose(expr, separate=False):\n+    \"\"\"Decomposes an input polynomial into homogeneous ones of\n+    smaller or equal degree.\n+    Returns a dictionary with keys as the degree of the smaller\n+    constituting polynomials. Values are the constituting polynomials.\n+    Parameters\n+    ==========\n+    expr : Polynomial(SymPy expression)\n+\n+    Optional Parameters :\n+\n+    separate : If True then simply return a list of the constituent monomials\n+               If not then break up the polynomial into constituent homogeneous\n+               polynomials.\n+    Examples\n+    ========\n+    >>> from sympy.abc import x, y\n+    >>> from sympy.integrals.intpoly import decompose\n+    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5)\n+    {1: x + y, 2: x**2 + x*y, 5: x**3*y**2 + y**5}\n+    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5, True)\n+    [x, y, x**2, y**5, x*y, x**3*y**2]\n+    \"\"\"\n+    expr = S(expr)\n+\n def decompose(expr, separate=False):\n     \"\"\"Decomposes an input polynomial into homogeneous ones of\n     smaller or equal degree.\n@@ -593,7 +618,9 @@ def decompose(expr, separate=False):\n         poly_dict[0] = expr\n \n     if separate:\n-        return list(poly_dict.values())\n+        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n+    return poly_dict\n+        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n     return poly_dict\n \n \n",
    "variant_5": "diff --git a/sympy/integrals/intpoly.py b/sympy/integrals/intpoly.py\nindex fc72bd206f..2580506005 100644\n--- a/sympy/integrals/intpoly.py\n+++ b/sympy/integrals/intpoly.py\n@@ -535,6 +535,31 @@ def y_axis_cut(ls):\n     return x0\n \n \n+def decompose(expr, separate=False):\n+    \"\"\"Decomposes an input polynomial into homogeneous ones of\n+    smaller or equal degree.\n+    Returns a dictionary with keys as the degree of the smaller\n+    constituting polynomials. Values are the constituting polynomials.\n+    Parameters\n+    ==========\n+    expr : Polynomial(SymPy expression)\n+\n+    Optional Parameters :\n+\n+    separate : If True then simply return a list of the constituent monomials\n+               If not then break up the polynomial into constituent homogeneous\n+               polynomials.\n+    Examples\n+    ========\n+    >>> from sympy.abc import x, y\n+    >>> from sympy.integrals.intpoly import decompose\n+    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5)\n+    {1: x + y, 2: x**2 + x*y, 5: x**3*y**2 + y**5}\n+    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5, True)\n+    [x, y, x**2, y**5, x*y, x**3*y**2]\n+    \"\"\"\n+    expr = S(expr)\n+\n def decompose(expr, separate=False):\n     \"\"\"Decomposes an input polynomial into homogeneous ones of\n     smaller or equal degree.\n@@ -593,7 +618,9 @@ def decompose(expr, separate=False):\n         poly_dict[0] = expr\n \n     if separate:\n-        return list(poly_dict.values())\n+        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n+    return poly_dict\n+        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n     return poly_dict\n \n \n",
    "variant_6": "diff --git a/sympy/integrals/intpoly.py b/sympy/integrals/intpoly.py\nindex fc72bd206f..2580506005 100644\n--- a/sympy/integrals/intpoly.py\n+++ b/sympy/integrals/intpoly.py\n@@ -535,6 +535,31 @@ def y_axis_cut(ls):\n     return x0\n \n \n+def decompose(expr, separate=False):\n+    \"\"\"Decomposes an input polynomial into homogeneous ones of\n+    smaller or equal degree.\n+    Returns a dictionary with keys as the degree of the smaller\n+    constituting polynomials. Values are the constituting polynomials.\n+    Parameters\n+    ==========\n+    expr : Polynomial(SymPy expression)\n+\n+    Optional Parameters :\n+\n+    separate : If True then simply return a list of the constituent monomials\n+               If not then break up the polynomial into constituent homogeneous\n+               polynomials.\n+    Examples\n+    ========\n+    >>> from sympy.abc import x, y\n+    >>> from sympy.integrals.intpoly import decompose\n+    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5)\n+    {1: x + y, 2: x**2 + x*y, 5: x**3*y**2 + y**5}\n+    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5, True)\n+    [x, y, x**2, y**5, x*y, x**3*y**2]\n+    \"\"\"\n+    expr = S(expr)\n+\n def decompose(expr, separate=False):\n     \"\"\"Decomposes an input polynomial into homogeneous ones of\n     smaller or equal degree.\n@@ -593,7 +618,9 @@ def decompose(expr, separate=False):\n         poly_dict[0] = expr\n \n     if separate:\n-        return list(poly_dict.values())\n+        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n+    return poly_dict\n+        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n     return poly_dict\n \n \n",
    "variant_7": "diff --git a/sympy/integrals/intpoly.py b/sympy/integrals/intpoly.py\nindex fc72bd206f..2580506005 100644\n--- a/sympy/integrals/intpoly.py\n+++ b/sympy/integrals/intpoly.py\n@@ -535,6 +535,31 @@ def y_axis_cut(ls):\n     return x0\n \n \n+def decompose(expr, separate=False):\n+    \"\"\"Decomposes an input polynomial into homogeneous ones of\n+    smaller or equal degree.\n+    Returns a dictionary with keys as the degree of the smaller\n+    constituting polynomials. Values are the constituting polynomials.\n+    Parameters\n+    ==========\n+    expr : Polynomial(SymPy expression)\n+\n+    Optional Parameters :\n+\n+    separate : If True then simply return a list of the constituent monomials\n+               If not then break up the polynomial into constituent homogeneous\n+               polynomials.\n+    Examples\n+    ========\n+    >>> from sympy.abc import x, y\n+    >>> from sympy.integrals.intpoly import decompose\n+    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5)\n+    {1: x + y, 2: x**2 + x*y, 5: x**3*y**2 + y**5}\n+    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5, True)\n+    [x, y, x**2, y**5, x*y, x**3*y**2]\n+    \"\"\"\n+    expr = S(expr)\n+\n def decompose(expr, separate=False):\n     \"\"\"Decomposes an input polynomial into homogeneous ones of\n     smaller or equal degree.\n@@ -593,7 +618,9 @@ def decompose(expr, separate=False):\n         poly_dict[0] = expr\n \n     if separate:\n-        return list(poly_dict.values())\n+        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n+    return poly_dict\n+        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n     return poly_dict\n \n \n",
    "variant_8": "diff --git a/sympy/integrals/intpoly.py b/sympy/integrals/intpoly.py\nindex fc72bd206f..2580506005 100644\n--- a/sympy/integrals/intpoly.py\n+++ b/sympy/integrals/intpoly.py\n@@ -535,6 +535,31 @@ def y_axis_cut(ls):\n     return x0\n \n \n+def decompose(expr, separate=False):\n+    \"\"\"Decomposes an input polynomial into homogeneous ones of\n+    smaller or equal degree.\n+    Returns a dictionary with keys as the degree of the smaller\n+    constituting polynomials. Values are the constituting polynomials.\n+    Parameters\n+    ==========\n+    expr : Polynomial(SymPy expression)\n+\n+    Optional Parameters :\n+\n+    separate : If True then simply return a list of the constituent monomials\n+               If not then break up the polynomial into constituent homogeneous\n+               polynomials.\n+    Examples\n+    ========\n+    >>> from sympy.abc import x, y\n+    >>> from sympy.integrals.intpoly import decompose\n+    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5)\n+    {1: x + y, 2: x**2 + x*y, 5: x**3*y**2 + y**5}\n+    >>> decompose(x**2 + x*y + x + y + x**3*y**2 + y**5, True)\n+    [x, y, x**2, y**5, x*y, x**3*y**2]\n+    \"\"\"\n+    expr = S(expr)\n+\n def decompose(expr, separate=False):\n     \"\"\"Decomposes an input polynomial into homogeneous ones of\n     smaller or equal degree.\n@@ -593,7 +618,9 @@ def decompose(expr, separate=False):\n         poly_dict[0] = expr\n \n     if separate:\n-        return list(poly_dict.values())\n+        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n+    return poly_dict\n+        return [poly_dict[degree] for degree in sorted(poly_dict.keys())]\n     return poly_dict\n \n \n"
  }
}