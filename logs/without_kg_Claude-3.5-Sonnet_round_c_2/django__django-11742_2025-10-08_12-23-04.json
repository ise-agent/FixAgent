{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/django/django/db/models/fields/__init__.py lines 244-292)": "\n    def _check_choices(self):\n        if not self.choices:\n            return []\n\n        def is_value(value, accept_promise=True):\n            return isinstance(value, (str, Promise) if accept_promise else str) or not is_iterable(value)\n\n        if is_value(self.choices, accept_promise=False):\n            return [\n                checks.Error(\n                    \"'choices' must be an iterable (e.g., a list or tuple).\",\n                    obj=self,\n                    id='fields.E004',\n                )\n            ]\n\n        # Expect [group_name, [value, display]]\n        for choices_group in self.choices:\n            try:\n                group_name, group_choices = choices_group\n            except (TypeError, ValueError):\n                # Containing non-pairs\n                break\n            try:\n                if not all(\n                    is_value(value) and is_value(human_name)\n                    for value, human_name in group_choices\n                ):\n                    break\n            except (TypeError, ValueError):\n                # No groups, choices in the form [value, display]\n                value, human_name = group_name, group_choices\n                if not is_value(value) or not is_value(human_name):\n                    break\n\n            # Special case: choices=['ab']\n            if isinstance(choices_group, str):\n                break\n        else:\n            # Check max_length compatibility with choices\n            if hasattr(self, 'max_length') and self.max_length is not None:\n                choice_values = []\n                for choices_group in self.choices:\n                    try:\n                        group_name, group_choices = choices_group\n                        # Grouped choices\n                        for value, human_name in group_choices:\n                            choice_values.append(value)\n                    except (TypeError, ValueError):\n                        # Flat choices\n                        value, human_name = choices_group\n                        choice_values.append(value)\n                \n                if choice_values:\n                    max_choice_length = max(len(str(value)) for value in choice_values)\n                    if self.max_length < max_choice_length:\n                        return [\n                            checks.Error(\n                                \"'max_length' is too small to fit the longest value \"\n                                \"in 'choices' (%d characters).\" % max_choice_length,\n                                obj=self,\n                                id='fields.E009',\n                            )\n                        ]\n            return []\n\n        return [\n            checks.Error(\n                \"'choices' must be an iterable containing \"\n                \"(actual value, human readable name) tuples.\",\n                obj=self,\n                id='fields.E005',\n            )\n        ]\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/django/django/db/models/fields/__init__.py lines 244-292)": [
      "\n    def _check_choices(self):\n        if not self.choices:\n            return []\n\n        def is_value(value, accept_promise=True):\n            return isinstance(value, (str, Promise) if accept_promise else str) or not is_iterable(value)\n\n        if is_value(self.choices, accept_promise=False):\n            return [\n                checks.Error(\n                    \"'choices' must be an iterable (e.g., a list or tuple).\",\n                    obj=self,\n                    id='fields.E004',\n                )\n            ]\n\n        # Expect [group_name, [value, display]]\n        for choices_group in self.choices:\n            try:\n                group_name, group_choices = choices_group\n            except (TypeError, ValueError):\n                # Containing non-pairs\n                break\n            try:\n                if not all(\n                    is_value(value) and is_value(human_name)\n                    for value, human_name in group_choices\n                ):\n                    break\n            except (TypeError, ValueError):\n                # No groups, choices in the form [value, display]\n                value, human_name = group_name, group_choices\n                if not is_value(value) or not is_value(human_name):\n                    break\n\n            # Special case: choices=['ab']\n            if isinstance(choices_group, str):\n                break\n        else:\n            # Check max_length compatibility with choices\n            if hasattr(self, 'max_length') and self.max_length is not None:\n                choice_max_length = 0\n                for choices_group in self.choices:\n                    try:\n                        group_name, group_choices = choices_group\n                        # Grouped choices\n                        for value, human_name in group_choices:\n                            choice_max_length = max(choice_max_length, len(str(value)))\n                    except (TypeError, ValueError):\n                        # Flat choices\n                        value, human_name = choices_group\n                        choice_max_length = max(choice_max_length, len(str(value)))\n                \n                if choice_max_length > self.max_length:\n                    return [\n                        checks.Error(\n                            \"'max_length' is too small to fit the longest value \"\n                            \"in 'choices' (%d characters).\" % choice_max_length,\n                            obj=self,\n                            id='fields.E009',\n                        )\n                    ]\n            return []\n\n        return [\n            checks.Error(\n                \"'choices' must be an iterable containing \"\n                \"(actual value, human readable name) tuples.\",\n                obj=self,\n                id='fields.E005',\n            )\n        ]\n",
      "\n    def _check_choices(self):\n        if not self.choices:\n            return []\n\n        def is_value(value, accept_promise=True):\n            return isinstance(value, (str, Promise) if accept_promise else str) or not is_iterable(value)\n\n        if is_value(self.choices, accept_promise=False):\n            return [\n                checks.Error(\n                    \"'choices' must be an iterable (e.g., a list or tuple).\",\n                    obj=self,\n                    id='fields.E004',\n                )\n            ]\n\n        # Expect [group_name, [value, display]]\n        for choices_group in self.choices:\n            try:\n                group_name, group_choices = choices_group\n            except (TypeError, ValueError):\n                # Containing non-pairs\n                break\n            try:\n                if not all(\n                    is_value(value) and is_value(human_name)\n                    for value, human_name in group_choices\n                ):\n                    break\n            except (TypeError, ValueError):\n                # No groups, choices in the form [value, display]\n                value, human_name = group_name, group_choices\n                if not is_value(value) or not is_value(human_name):\n                    break\n\n            # Special case: choices=['ab']\n            if isinstance(choices_group, str):\n                break\n        else:\n            # Check max_length compatibility with choices\n            if hasattr(self, 'max_length') and self.max_length is not None:\n                choice_values = []\n                for choices_group in self.choices:\n                    try:\n                        group_name, group_choices = choices_group\n                        # Grouped choices format\n                        for value, human_name in group_choices:\n                            choice_values.append(value)\n                    except (TypeError, ValueError):\n                        # Flat choices format\n                        value, human_name = choices_group\n                        choice_values.append(value)\n                \n                if choice_values:\n                    max_choice_length = max(len(str(value)) for value in choice_values)\n                    if self.max_length < max_choice_length:\n                        return [\n                            checks.Error(\n                                \"'max_length' is too small to fit the longest value \"\n                                \"in 'choices' (%d characters).\" % max_choice_length,\n                                obj=self,\n                                id='fields.E009',\n                            )\n                        ]\n            return []\n\n        return [\n            checks.Error(\n                \"'choices' must be an iterable containing \"\n                \"(actual value, human readable name) tuples.\",\n                obj=self,\n                id='fields.E005',\n            )\n        ]\n",
      "\n    def _check_choices(self):\n        if not self.choices:\n            return []\n\n        def is_value(value, accept_promise=True):\n            return isinstance(value, (str, Promise) if accept_promise else str) or not is_iterable(value)\n\n        if is_value(self.choices, accept_promise=False):\n            return [\n                checks.Error(\n                    \"'choices' must be an iterable (e.g., a list or tuple).\",\n                    obj=self,\n                    id='fields.E004',\n                )\n            ]\n\n        # Expect [group_name, [value, display]]\n        for choices_group in self.choices:\n            try:\n                group_name, group_choices = choices_group\n            except (TypeError, ValueError):\n                # Containing non-pairs\n                break\n            try:\n                if not all(\n                    is_value(value) and is_value(human_name)\n                    for value, human_name in group_choices\n                ):\n                    break\n            except (TypeError, ValueError):\n                # No groups, choices in the form [value, display]\n                value, human_name = group_name, group_choices\n                if not is_value(value) or not is_value(human_name):\n                    break\n\n            # Special case: choices=['ab']\n            if isinstance(choices_group, str):\n                break\n        else:\n            # Check max_length compatibility with choices\n            if hasattr(self, 'max_length') and self.max_length is not None:\n                all_choice_values = []\n                \n                for choices_group in self.choices:\n                    try:\n                        group_name, group_choices = choices_group\n                        # Grouped choices format\n                        for value, human_name in group_choices:\n                            all_choice_values.append(value)\n                    except (TypeError, ValueError):\n                        # Flat choices format [value, display]\n                        value, human_name = choices_group\n                        all_choice_values.append(value)\n                \n                if all_choice_values:\n                    max_choice_length = max(len(str(value)) for value in all_choice_values)\n                    if max_choice_length > self.max_length:\n                        return [\n                            checks.Error(\n                                \"'max_length' is too small to fit the longest value in 'choices' (%d characters).\" % max_choice_length,\n                                obj=self,\n                                id='fields.E009',\n                            )\n                        ]\n            return []\n\n        return [\n            checks.Error(\n                \"'choices' must be an iterable containing \"\n                \"(actual value, human readable name) tuples.\",\n                obj=self,\n                id='fields.E005',\n            )\n        ]\n",
      "\n    def _check_choices(self):\n        if not self.choices:\n            return []\n\n        def is_value(value, accept_promise=True):\n            return isinstance(value, (str, Promise) if accept_promise else str) or not is_iterable(value)\n\n        if is_value(self.choices, accept_promise=False):\n            return [\n                checks.Error(\n                    \"'choices' must be an iterable (e.g., a list or tuple).\",\n                    obj=self,\n                    id='fields.E004',\n                )\n            ]\n\n        # Expect [group_name, [value, display]]\n        for choices_group in self.choices:\n            try:\n                group_name, group_choices = choices_group\n            except (TypeError, ValueError):\n                # Containing non-pairs\n                break\n            try:\n                if not all(\n                    is_value(value) and is_value(human_name)\n                    for value, human_name in group_choices\n                ):\n                    break\n            except (TypeError, ValueError):\n                # No groups, choices in the form [value, display]\n                value, human_name = group_name, group_choices\n                if not is_value(value) or not is_value(human_name):\n                    break\n\n            # Special case: choices=['ab']\n            if isinstance(choices_group, str):\n                break\n        else:\n            # Check max_length compatibility with choices\n            if hasattr(self, 'max_length') and self.max_length is not None:\n                choice_values = []\n                for choices_group in self.choices:\n                    try:\n                        group_name, group_choices = choices_group\n                        # Grouped choices\n                        choice_values.extend(value for value, _ in group_choices)\n                    except (TypeError, ValueError):\n                        # Flat choices\n                        choice_values.append(choices_group[0])\n                \n                if choice_values:\n                    max_choice_length = max(len(str(value)) for value in choice_values)\n                    if max_choice_length > self.max_length:\n                        return [\n                            checks.Error(\n                                \"'max_length' is too small to fit the longest value \"\n                                \"in 'choices' (%d characters).\" % max_choice_length,\n                                obj=self,\n                                id='fields.E009',\n                            )\n                        ]\n            return []\n\n        return [\n            checks.Error(\n                \"'choices' must be an iterable containing \"\n                \"(actual value, human readable name) tuples.\",\n                obj=self,\n                id='fields.E005',\n            )\n        ]\n",
      "\n    def _check_choices(self):\n        if not self.choices:\n            return []\n\n        def is_value(value, accept_promise=True):\n            return isinstance(value, (str, Promise) if accept_promise else str) or not is_iterable(value)\n\n        if is_value(self.choices, accept_promise=False):\n            return [\n                checks.Error(\n                    \"'choices' must be an iterable (e.g., a list or tuple).\",\n                    obj=self,\n                    id='fields.E004',\n                )\n            ]\n\n        # Expect [group_name, [value, display]]\n        for choices_group in self.choices:\n            try:\n                group_name, group_choices = choices_group\n            except (TypeError, ValueError):\n                # Containing non-pairs\n                break\n            try:\n                if not all(\n                    is_value(value) and is_value(human_name)\n                    for value, human_name in group_choices\n                ):\n                    break\n            except (TypeError, ValueError):\n                # No groups, choices in the form [value, display]\n                value, human_name = group_name, group_choices\n                if not is_value(value) or not is_value(human_name):\n                    break\n\n            # Special case: choices=['ab']\n            if isinstance(choices_group, str):\n                break\n        else:\n            # Check max_length compatibility with choices\n            if hasattr(self, 'max_length') and self.max_length is not None:\n                all_choice_values = []\n                \n                for choices_group in self.choices:\n                    try:\n                        group_name, group_choices = choices_group\n                        # Grouped choices\n                        for value, human_name in group_choices:\n                            all_choice_values.append(value)\n                    except (TypeError, ValueError):\n                        # Flat choices\n                        value, human_name = choices_group\n                        all_choice_values.append(value)\n                \n                if all_choice_values:\n                    max_choice_length = max(len(str(value)) for value in all_choice_values)\n                    if max_choice_length > self.max_length:\n                        return [\n                            checks.Error(\n                                \"'max_length' is too small to fit the longest value \"\n                                \"in 'choices' (%d characters).\" % max_choice_length,\n                                obj=self,\n                                id='fields.E009',\n                            )\n                        ]\n            \n            return []\n\n        return [\n            checks.Error(\n                \"'choices' must be an iterable containing \"\n                \"(actual value, human readable name) tuples.\",\n                obj=self,\n                id='fields.E005',\n            )\n        ]\n",
      "\n    def _check_choices(self):\n        if not self.choices:\n            return []\n\n        def is_value(value, accept_promise=True):\n            return isinstance(value, (str, Promise) if accept_promise else str) or not is_iterable(value)\n\n        if is_value(self.choices, accept_promise=False):\n            return [\n                checks.Error(\n                    \"'choices' must be an iterable (e.g., a list or tuple).\",\n                    obj=self,\n                    id='fields.E004',\n                )\n            ]\n\n        # Expect [group_name, [value, display]]\n        for choices_group in self.choices:\n            try:\n                group_name, group_choices = choices_group\n            except (TypeError, ValueError):\n                # Containing non-pairs\n                break\n            try:\n                if not all(\n                    is_value(value) and is_value(human_name)\n                    for value, human_name in group_choices\n                ):\n                    break\n            except (TypeError, ValueError):\n                # No groups, choices in the form [value, display]\n                value, human_name = group_name, group_choices\n                if not is_value(value) or not is_value(human_name):\n                    break\n\n            # Special case: choices=['ab']\n            if isinstance(choices_group, str):\n                break\n        else:\n            # Check max_length compatibility with choices\n            if hasattr(self, 'max_length') and self.max_length is not None:\n                choice_values = []\n                \n                # Extract all choice values\n                for choices_group in self.choices:\n                    try:\n                        group_name, group_choices = choices_group\n                        # This is a grouped choice\n                        for value, human_name in group_choices:\n                            choice_values.append(value)\n                    except (TypeError, ValueError):\n                        # This is a flat choice (value, display)\n                        value, human_name = choices_group\n                        choice_values.append(value)\n                \n                if choice_values:\n                    max_choice_length = max(len(str(value)) for value in choice_values)\n                    if self.max_length < max_choice_length:\n                        return [\n                            checks.Error(\n                                \"'max_length' is too small to fit the longest value \"\n                                \"in 'choices' (%d characters).\" % max_choice_length,\n                                obj=self,\n                                id='fields.E009',\n                            )\n                        ]\n            \n            return []\n\n        return [\n            checks.Error(\n                \"'choices' must be an iterable containing \"\n                \"(actual value, human readable name) tuples.\",\n                obj=self,\n                id='fields.E005',\n            )\n        ]\n",
      "\n    def _check_choices(self):\n        if not self.choices:\n            return []\n\n        def is_value(value, accept_promise=True):\n            return isinstance(value, (str, Promise) if accept_promise else str) or not is_iterable(value)\n\n        if is_value(self.choices, accept_promise=False):\n            return [\n                checks.Error(\n                    \"'choices' must be an iterable (e.g., a list or tuple).\",\n                    obj=self,\n                    id='fields.E004',\n                )\n            ]\n\n        # Expect [group_name, [value, display]]\n        for choices_group in self.choices:\n            try:\n                group_name, group_choices = choices_group\n            except (TypeError, ValueError):\n                # Containing non-pairs\n                break\n            try:\n                if not all(\n                    is_value(value) and is_value(human_name)\n                    for value, human_name in group_choices\n                ):\n                    break\n            except (TypeError, ValueError):\n                # No groups, choices in the form [value, display]\n                value, human_name = group_name, group_choices\n                if not is_value(value) or not is_value(human_name):\n                    break\n\n            # Special case: choices=['ab']\n            if isinstance(choices_group, str):\n                break\n        else:\n            # Check max_length compatibility with choices\n            if hasattr(self, 'max_length') and self.max_length:\n                all_choice_values = []\n                for choices_group in self.choices:\n                    try:\n                        group_name, group_choices = choices_group\n                        # Grouped choices\n                        for value, human_name in group_choices:\n                            all_choice_values.append(value)\n                    except (TypeError, ValueError):\n                        # Flat choices\n                        value, human_name = choices_group\n                        all_choice_values.append(value)\n                \n                if all_choice_values:\n                    max_choice_length = max(len(str(value)) for value in all_choice_values)\n                    if max_choice_length > self.max_length:\n                        return [\n                            checks.Error(\n                                \"'max_length' is too small to fit the longest value \"\n                                \"in 'choices' (%d characters).\" % max_choice_length,\n                                obj=self,\n                                id='fields.E009',\n                            )\n                        ]\n            return []\n\n        return [\n            checks.Error(\n                \"'choices' must be an iterable containing \"\n                \"(actual value, human readable name) tuples.\",\n                obj=self,\n                id='fields.E005',\n            )\n        ]\n",
      "\n    def _check_choices(self):\n        if not self.choices:\n            return []\n\n        def is_value(value, accept_promise=True):\n            return isinstance(value, (str, Promise) if accept_promise else str) or not is_iterable(value)\n\n        if is_value(self.choices, accept_promise=False):\n            return [\n                checks.Error(\n                    \"'choices' must be an iterable (e.g., a list or tuple).\",\n                    obj=self,\n                    id='fields.E004',\n                )\n            ]\n\n        # Expect [group_name, [value, display]]\n        for choices_group in self.choices:\n            try:\n                group_name, group_choices = choices_group\n            except (TypeError, ValueError):\n                # Containing non-pairs\n                break\n            try:\n                if not all(\n                    is_value(value) and is_value(human_name)\n                    for value, human_name in group_choices\n                ):\n                    break\n            except (TypeError, ValueError):\n                # No groups, choices in the form [value, display]\n                value, human_name = group_name, group_choices\n                if not is_value(value) or not is_value(human_name):\n                    break\n\n            # Special case: choices=['ab']\n            if isinstance(choices_group, str):\n                break\n        else:\n            # Check max_length compatibility with choices\n            if hasattr(self, 'max_length') and self.max_length is not None:\n                choice_values = []\n                for choices_group in self.choices:\n                    try:\n                        group_name, group_choices = choices_group\n                        # Grouped choices\n                        for value, human_name in group_choices:\n                            choice_values.append(value)\n                    except (TypeError, ValueError):\n                        # Flat choices\n                        value, human_name = choices_group\n                        choice_values.append(value)\n                \n                if choice_values:\n                    max_choice_length = max(len(str(value)) for value in choice_values)\n                    if max_choice_length > self.max_length:\n                        return [\n                            checks.Error(\n                                \"'max_length' is too small to fit the longest value \"\n                                \"in 'choices' (%d characters).\" % max_choice_length,\n                                obj=self,\n                                id='fields.E009',\n                            )\n                        ]\n            return []\n\n        return [\n            checks.Error(\n                \"'choices' must be an iterable containing \"\n                \"(actual value, human readable name) tuples.\",\n                obj=self,\n                id='fields.E005',\n            )\n        ]\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 9ce46e3f73..8765cc1926 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -241,6 +241,7 @@ class Field(RegisterLookupMixin):\n         else:\n             return []\n \n+\n     def _check_choices(self):\n         if not self.choices:\n             return []\n@@ -280,6 +281,28 @@ class Field(RegisterLookupMixin):\n             if isinstance(choices_group, str):\n                 break\n         else:\n+            # Check max_length is sufficient for the longest choice value\n+            if self.max_length is not None:\n+                choice_max_length = 0\n+                for choices_group in self.choices:\n+                    try:\n+                        group_name, group_choices = choices_group\n+                        # Grouped choices: extract values from the group\n+                        for value, human_name in group_choices:\n+                            choice_max_length = max(choice_max_length, len(str(value)))\n+                    except (TypeError, ValueError):\n+                        # Flat choices: group_name is the value, group_choices is the display\n+                        value, human_name = group_name, group_choices\n+                        choice_max_length = max(choice_max_length, len(str(value)))\n+                \n+                if choice_max_length > self.max_length:\n+                    return [\n+                        checks.Error(\n+                            \"'max_length' is too small to fit the longest value in 'choices' (%d characters).\" % choice_max_length,\n+                            obj=self,\n+                            id='fields.E007',\n+                        )\n+                    ]\n             return []\n \n         return [\n",
    "variant_0": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 9ce46e3f73..1cac0efaf0 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -241,6 +241,7 @@ class Field(RegisterLookupMixin):\n         else:\n             return []\n \n+\n     def _check_choices(self):\n         if not self.choices:\n             return []\n@@ -280,6 +281,31 @@ class Field(RegisterLookupMixin):\n             if isinstance(choices_group, str):\n                 break\n         else:\n+            # Check max_length compatibility with choices\n+            if hasattr(self, 'max_length') and self.max_length is not None:\n+                choice_values = []\n+                for choices_group in self.choices:\n+                    try:\n+                        group_name, group_choices = choices_group\n+                        # Grouped choices\n+                        for value, human_name in group_choices:\n+                            choice_values.append(value)\n+                    except (TypeError, ValueError):\n+                        # Flat choices\n+                        value, human_name = choices_group\n+                        choice_values.append(value)\n+                \n+                if choice_values:\n+                    max_choice_length = max(len(str(value)) for value in choice_values)\n+                    if self.max_length < max_choice_length:\n+                        return [\n+                            checks.Error(\n+                                \"'max_length' is too small to fit the longest value \"\n+                                \"in 'choices' (%d characters).\" % max_choice_length,\n+                                obj=self,\n+                                id='fields.E009',\n+                            )\n+                        ]\n             return []\n \n         return [\n",
    "variant_1": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 9ce46e3f73..a152c183d5 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -241,6 +241,7 @@ class Field(RegisterLookupMixin):\n         else:\n             return []\n \n+\n     def _check_choices(self):\n         if not self.choices:\n             return []\n@@ -280,6 +281,29 @@ class Field(RegisterLookupMixin):\n             if isinstance(choices_group, str):\n                 break\n         else:\n+            # Check max_length compatibility with choices\n+            if hasattr(self, 'max_length') and self.max_length is not None:\n+                choice_max_length = 0\n+                for choices_group in self.choices:\n+                    try:\n+                        group_name, group_choices = choices_group\n+                        # Grouped choices\n+                        for value, human_name in group_choices:\n+                            choice_max_length = max(choice_max_length, len(str(value)))\n+                    except (TypeError, ValueError):\n+                        # Flat choices\n+                        value, human_name = choices_group\n+                        choice_max_length = max(choice_max_length, len(str(value)))\n+                \n+                if choice_max_length > self.max_length:\n+                    return [\n+                        checks.Error(\n+                            \"'max_length' is too small to fit the longest value \"\n+                            \"in 'choices' (%d characters).\" % choice_max_length,\n+                            obj=self,\n+                            id='fields.E009',\n+                        )\n+                    ]\n             return []\n \n         return [\n",
    "variant_2": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 9ce46e3f73..664072da36 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -241,6 +241,7 @@ class Field(RegisterLookupMixin):\n         else:\n             return []\n \n+\n     def _check_choices(self):\n         if not self.choices:\n             return []\n@@ -280,6 +281,31 @@ class Field(RegisterLookupMixin):\n             if isinstance(choices_group, str):\n                 break\n         else:\n+            # Check max_length compatibility with choices\n+            if hasattr(self, 'max_length') and self.max_length is not None:\n+                choice_values = []\n+                for choices_group in self.choices:\n+                    try:\n+                        group_name, group_choices = choices_group\n+                        # Grouped choices format\n+                        for value, human_name in group_choices:\n+                            choice_values.append(value)\n+                    except (TypeError, ValueError):\n+                        # Flat choices format\n+                        value, human_name = choices_group\n+                        choice_values.append(value)\n+                \n+                if choice_values:\n+                    max_choice_length = max(len(str(value)) for value in choice_values)\n+                    if self.max_length < max_choice_length:\n+                        return [\n+                            checks.Error(\n+                                \"'max_length' is too small to fit the longest value \"\n+                                \"in 'choices' (%d characters).\" % max_choice_length,\n+                                obj=self,\n+                                id='fields.E009',\n+                            )\n+                        ]\n             return []\n \n         return [\n",
    "variant_3": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 9ce46e3f73..71aaa4bb92 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -241,6 +241,7 @@ class Field(RegisterLookupMixin):\n         else:\n             return []\n \n+\n     def _check_choices(self):\n         if not self.choices:\n             return []\n@@ -280,6 +281,31 @@ class Field(RegisterLookupMixin):\n             if isinstance(choices_group, str):\n                 break\n         else:\n+            # Check max_length compatibility with choices\n+            if hasattr(self, 'max_length') and self.max_length is not None:\n+                all_choice_values = []\n+                \n+                for choices_group in self.choices:\n+                    try:\n+                        group_name, group_choices = choices_group\n+                        # Grouped choices format\n+                        for value, human_name in group_choices:\n+                            all_choice_values.append(value)\n+                    except (TypeError, ValueError):\n+                        # Flat choices format [value, display]\n+                        value, human_name = choices_group\n+                        all_choice_values.append(value)\n+                \n+                if all_choice_values:\n+                    max_choice_length = max(len(str(value)) for value in all_choice_values)\n+                    if max_choice_length > self.max_length:\n+                        return [\n+                            checks.Error(\n+                                \"'max_length' is too small to fit the longest value in 'choices' (%d characters).\" % max_choice_length,\n+                                obj=self,\n+                                id='fields.E009',\n+                            )\n+                        ]\n             return []\n \n         return [\n",
    "variant_4": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 9ce46e3f73..0287e9b09d 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -241,6 +241,7 @@ class Field(RegisterLookupMixin):\n         else:\n             return []\n \n+\n     def _check_choices(self):\n         if not self.choices:\n             return []\n@@ -280,6 +281,29 @@ class Field(RegisterLookupMixin):\n             if isinstance(choices_group, str):\n                 break\n         else:\n+            # Check max_length compatibility with choices\n+            if hasattr(self, 'max_length') and self.max_length is not None:\n+                choice_values = []\n+                for choices_group in self.choices:\n+                    try:\n+                        group_name, group_choices = choices_group\n+                        # Grouped choices\n+                        choice_values.extend(value for value, _ in group_choices)\n+                    except (TypeError, ValueError):\n+                        # Flat choices\n+                        choice_values.append(choices_group[0])\n+                \n+                if choice_values:\n+                    max_choice_length = max(len(str(value)) for value in choice_values)\n+                    if max_choice_length > self.max_length:\n+                        return [\n+                            checks.Error(\n+                                \"'max_length' is too small to fit the longest value \"\n+                                \"in 'choices' (%d characters).\" % max_choice_length,\n+                                obj=self,\n+                                id='fields.E009',\n+                            )\n+                        ]\n             return []\n \n         return [\n",
    "variant_5": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 9ce46e3f73..5bb9395d73 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -241,6 +241,7 @@ class Field(RegisterLookupMixin):\n         else:\n             return []\n \n+\n     def _check_choices(self):\n         if not self.choices:\n             return []\n@@ -280,6 +281,33 @@ class Field(RegisterLookupMixin):\n             if isinstance(choices_group, str):\n                 break\n         else:\n+            # Check max_length compatibility with choices\n+            if hasattr(self, 'max_length') and self.max_length is not None:\n+                all_choice_values = []\n+                \n+                for choices_group in self.choices:\n+                    try:\n+                        group_name, group_choices = choices_group\n+                        # Grouped choices\n+                        for value, human_name in group_choices:\n+                            all_choice_values.append(value)\n+                    except (TypeError, ValueError):\n+                        # Flat choices\n+                        value, human_name = choices_group\n+                        all_choice_values.append(value)\n+                \n+                if all_choice_values:\n+                    max_choice_length = max(len(str(value)) for value in all_choice_values)\n+                    if max_choice_length > self.max_length:\n+                        return [\n+                            checks.Error(\n+                                \"'max_length' is too small to fit the longest value \"\n+                                \"in 'choices' (%d characters).\" % max_choice_length,\n+                                obj=self,\n+                                id='fields.E009',\n+                            )\n+                        ]\n+            \n             return []\n \n         return [\n",
    "variant_6": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 9ce46e3f73..c93d3fa4fc 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -241,6 +241,7 @@ class Field(RegisterLookupMixin):\n         else:\n             return []\n \n+\n     def _check_choices(self):\n         if not self.choices:\n             return []\n@@ -280,6 +281,34 @@ class Field(RegisterLookupMixin):\n             if isinstance(choices_group, str):\n                 break\n         else:\n+            # Check max_length compatibility with choices\n+            if hasattr(self, 'max_length') and self.max_length is not None:\n+                choice_values = []\n+                \n+                # Extract all choice values\n+                for choices_group in self.choices:\n+                    try:\n+                        group_name, group_choices = choices_group\n+                        # This is a grouped choice\n+                        for value, human_name in group_choices:\n+                            choice_values.append(value)\n+                    except (TypeError, ValueError):\n+                        # This is a flat choice (value, display)\n+                        value, human_name = choices_group\n+                        choice_values.append(value)\n+                \n+                if choice_values:\n+                    max_choice_length = max(len(str(value)) for value in choice_values)\n+                    if self.max_length < max_choice_length:\n+                        return [\n+                            checks.Error(\n+                                \"'max_length' is too small to fit the longest value \"\n+                                \"in 'choices' (%d characters).\" % max_choice_length,\n+                                obj=self,\n+                                id='fields.E009',\n+                            )\n+                        ]\n+            \n             return []\n \n         return [\n",
    "variant_7": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 9ce46e3f73..0bf049881e 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -241,6 +241,7 @@ class Field(RegisterLookupMixin):\n         else:\n             return []\n \n+\n     def _check_choices(self):\n         if not self.choices:\n             return []\n@@ -280,6 +281,31 @@ class Field(RegisterLookupMixin):\n             if isinstance(choices_group, str):\n                 break\n         else:\n+            # Check max_length compatibility with choices\n+            if hasattr(self, 'max_length') and self.max_length:\n+                all_choice_values = []\n+                for choices_group in self.choices:\n+                    try:\n+                        group_name, group_choices = choices_group\n+                        # Grouped choices\n+                        for value, human_name in group_choices:\n+                            all_choice_values.append(value)\n+                    except (TypeError, ValueError):\n+                        # Flat choices\n+                        value, human_name = choices_group\n+                        all_choice_values.append(value)\n+                \n+                if all_choice_values:\n+                    max_choice_length = max(len(str(value)) for value in all_choice_values)\n+                    if max_choice_length > self.max_length:\n+                        return [\n+                            checks.Error(\n+                                \"'max_length' is too small to fit the longest value \"\n+                                \"in 'choices' (%d characters).\" % max_choice_length,\n+                                obj=self,\n+                                id='fields.E009',\n+                            )\n+                        ]\n             return []\n \n         return [\n",
    "variant_8": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 9ce46e3f73..8e92b101c8 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -241,6 +241,7 @@ class Field(RegisterLookupMixin):\n         else:\n             return []\n \n+\n     def _check_choices(self):\n         if not self.choices:\n             return []\n@@ -280,6 +281,31 @@ class Field(RegisterLookupMixin):\n             if isinstance(choices_group, str):\n                 break\n         else:\n+            # Check max_length compatibility with choices\n+            if hasattr(self, 'max_length') and self.max_length is not None:\n+                choice_values = []\n+                for choices_group in self.choices:\n+                    try:\n+                        group_name, group_choices = choices_group\n+                        # Grouped choices\n+                        for value, human_name in group_choices:\n+                            choice_values.append(value)\n+                    except (TypeError, ValueError):\n+                        # Flat choices\n+                        value, human_name = choices_group\n+                        choice_values.append(value)\n+                \n+                if choice_values:\n+                    max_choice_length = max(len(str(value)) for value in choice_values)\n+                    if max_choice_length > self.max_length:\n+                        return [\n+                            checks.Error(\n+                                \"'max_length' is too small to fit the longest value \"\n+                                \"in 'choices' (%d characters).\" % max_choice_length,\n+                                obj=self,\n+                                id='fields.E009',\n+                            )\n+                        ]\n             return []\n \n         return [\n"
  }
}