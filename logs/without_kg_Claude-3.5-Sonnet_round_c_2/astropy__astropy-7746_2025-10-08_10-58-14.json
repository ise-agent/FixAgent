{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/astropy/astropy/wcs/wcs.py lines 1221-1225)": "\n        def _return_list_of_arrays(axes, origin):\n            try:\n                axes = np.broadcast_arrays(*axes)\n            except ValueError:\n                raise ValueError(\n                    \"Coordinate arrays are not broadcastable to each other\")\n\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            # Handle empty array case to avoid C library error\n            if xy.size == 0:\n                # Create empty output array with correct shape (0, naxis)\n                output = np.empty((0, self.naxis), dtype=float)\n            else:\n                if ra_dec_order and sky == 'input':\n                    xy = self._denormalize_sky(xy)\n                output = func(xy, origin)\n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
    "Location 2 (/root/hy/projects_2/astropy/astropy/wcs/wcs.py lines 1226-1231)": "\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            # Handle empty array case to avoid C library error\n            if xy.size == 0:\n                # Create empty output array with correct shape (0, naxis)\n                output = np.empty((0, self.naxis), dtype=float)\n            else:\n                if ra_dec_order and sky == 'input':\n                    xy = self._denormalize_sky(xy)\n                output = func(xy, origin)\n            \n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/astropy/astropy/wcs/wcs.py lines 1221-1225)": [
      "\n        def _return_list_of_arrays(axes, origin):\n            try:\n                axes = np.broadcast_arrays(*axes)\n            except ValueError:\n                raise ValueError(\n                    \"Coordinate arrays are not broadcastable to each other\")\n\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            # Handle empty array case to avoid C library error\n            if xy.size == 0:\n                # Create empty output array with correct shape (0, naxis)\n                output = np.empty((0, self.naxis), dtype=float)\n            else:\n                if ra_dec_order and sky == 'input':\n                    xy = self._denormalize_sky(xy)\n                output = func(xy, origin)\n            \n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n        def _return_list_of_arrays(axes, origin):\n            try:\n                axes = np.broadcast_arrays(*axes)\n            except ValueError:\n                raise ValueError(\n                    \"Coordinate arrays are not broadcastable to each other\")\n\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            # Handle empty array case to avoid C library error\n            if xy.size == 0:\n                # Create empty output array with correct shape (0, naxis)\n                output = np.empty((0, self.naxis), dtype=float)\n            else:\n                if ra_dec_order and sky == 'input':\n                    xy = self._denormalize_sky(xy)\n                output = func(xy, origin)\n            \n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n        def _return_list_of_arrays(axes, origin):\n            try:\n                axes = np.broadcast_arrays(*axes)\n            except ValueError:\n                raise ValueError(\n                    \"Coordinate arrays are not broadcastable to each other\")\n\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            # Handle empty array case to avoid C library error\n            if xy.size == 0:\n                # Create empty output array with correct shape (0, naxis)\n                output = np.empty((0, self.naxis), dtype=float)\n            else:\n                if ra_dec_order and sky == 'input':\n                    xy = self._denormalize_sky(xy)\n                output = func(xy, origin)\n            \n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n        def _return_list_of_arrays(axes, origin):\n            try:\n                axes = np.broadcast_arrays(*axes)\n            except ValueError:\n                raise ValueError(\n                    \"Coordinate arrays are not broadcastable to each other\")\n\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            # Handle empty array case to avoid C library error\n            if xy.size == 0:\n                # Create empty output array with correct shape (0, naxis)\n                output = np.empty((0, self.naxis), dtype=float)\n            else:\n                if ra_dec_order and sky == 'input':\n                    xy = self._denormalize_sky(xy)\n                output = func(xy, origin)\n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n        def _return_list_of_arrays(axes, origin):\n            try:\n                axes = np.broadcast_arrays(*axes)\n            except ValueError:\n                raise ValueError(\n                    \"Coordinate arrays are not broadcastable to each other\")\n\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            # Handle empty array case to avoid C library error\n            if xy.size == 0:\n                # Create empty output array with correct shape (0, naxis)\n                output = np.empty((0, self.naxis), dtype=float)\n            else:\n                if ra_dec_order and sky == 'input':\n                    xy = self._denormalize_sky(xy)\n                output = func(xy, origin)\n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n        def _return_list_of_arrays(axes, origin):\n            try:\n                axes = np.broadcast_arrays(*axes)\n            except ValueError:\n                raise ValueError(\n                    \"Coordinate arrays are not broadcastable to each other\")\n\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            # Handle empty array case to avoid C library error\n            if xy.size == 0:\n                # Create empty output array with correct shape (0, naxis)\n                output = np.empty((0, self.naxis), dtype=float)\n            else:\n                if ra_dec_order and sky == 'input':\n                    xy = self._denormalize_sky(xy)\n                output = func(xy, origin)\n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n        def _return_list_of_arrays(axes, origin):\n            try:\n                axes = np.broadcast_arrays(*axes)\n            except ValueError:\n                raise ValueError(\n                    \"Coordinate arrays are not broadcastable to each other\")\n\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            # Handle empty array case to avoid C library error\n            if xy.size == 0:\n                # Create empty output array with correct shape (0, naxis)\n                output = np.empty((0, self.naxis), dtype=float)\n            else:\n                if ra_dec_order and sky == 'input':\n                    xy = self._denormalize_sky(xy)\n                output = func(xy, origin)\n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n        def _return_list_of_arrays(axes, origin):\n            try:\n                axes = np.broadcast_arrays(*axes)\n            except ValueError:\n                raise ValueError(\n                    \"Coordinate arrays are not broadcastable to each other\")\n\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            # Handle empty array case to avoid C library error\n            if xy.size == 0:\n                # Create empty output array with correct shape (0, naxis)\n                output = np.empty((0, self.naxis), dtype=float)\n            else:\n                if ra_dec_order and sky == 'input':\n                    xy = self._denormalize_sky(xy)\n                output = func(xy, origin)\n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n"
    ],
    "Location 2 (/root/hy/projects_2/astropy/astropy/wcs/wcs.py lines 1226-1231)": [
      "\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            # Handle empty array case to avoid C library error\n            if xy.size == 0:\n                # Create empty output array with correct shape (0, naxis)\n                output = np.empty((0, self.naxis), dtype=float)\n            else:\n                if ra_dec_order and sky == 'input':\n                    xy = self._denormalize_sky(xy)\n                output = func(xy, origin)\n            \n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            # Handle empty array case to avoid C library error\n            if xy.size == 0:\n                # Create empty output array with correct shape (0, naxis)\n                output = np.empty((0, self.naxis), dtype=float)\n            else:\n                if ra_dec_order and sky == 'input':\n                    xy = self._denormalize_sky(xy)\n                output = func(xy, origin)\n            \n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            # Handle empty array case to avoid C library error\n            if xy.size == 0:\n                # Create empty output array with correct shape (0, naxis)\n                output = np.empty((0, self.naxis), dtype=float)\n            else:\n                if ra_dec_order and sky == 'input':\n                    xy = self._denormalize_sky(xy)\n                output = func(xy, origin)\n            \n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n            try:\n                axes = np.broadcast_arrays(*axes)\n            except ValueError:\n                raise ValueError(\n                    \"Coordinate arrays are not broadcastable to each other\")\n\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            # Handle empty array case to avoid C library error\n            if xy.size == 0:\n                # Create empty output array with correct shape (0, naxis)\n                output = np.empty((0, self.naxis), dtype=float)\n            else:\n                if ra_dec_order and sky == 'input':\n                    xy = self._denormalize_sky(xy)\n                output = func(xy, origin)\n            \n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            # Handle empty array case to avoid C library error\n            if xy.size == 0:\n                # Create empty output array with correct shape (0, naxis)\n                output = np.empty((0, self.naxis), dtype=float)\n            else:\n                if ra_dec_order and sky == 'input':\n                    xy = self._denormalize_sky(xy)\n                output = func(xy, origin)\n            \n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            # Handle empty array case to avoid C library error\n            if xy.size == 0:\n                # Create empty output array with correct shape (0, naxis)\n                output = np.empty((0, self.naxis), dtype=float)\n            else:\n                if ra_dec_order and sky == 'input':\n                    xy = self._denormalize_sky(xy)\n                output = func(xy, origin)\n            \n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            # Handle empty array case to avoid C library error\n            if xy.size == 0:\n                # Create empty output array with correct shape (0, naxis)\n                output = np.empty((0, self.naxis), dtype=float)\n            else:\n                if ra_dec_order and sky == 'input':\n                    xy = self._denormalize_sky(xy)\n                output = func(xy, origin)\n            \n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            # Handle empty array case to avoid C library error\n            if xy.size == 0:\n                # Create empty output array with correct shape (0, naxis)\n                output = np.empty((0, self.naxis), dtype=float)\n            else:\n                if ra_dec_order and sky == 'input':\n                    xy = self._denormalize_sky(xy)\n                output = func(xy, origin)\n            \n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..5e9d0415da 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1218,11 +1218,18 @@ reduce these to 2 dimensions using the naxis kwarg.\n                 raise ValueError(\n                     \"Coordinate arrays are not broadcastable to each other\")\n \n+\n             xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n-            if ra_dec_order and sky == 'input':\n-                xy = self._denormalize_sky(xy)\n-            output = func(xy, origin)\n+            # Handle empty array case to avoid C library error\n+            if xy.size == 0:\n+                # Create empty output array with correct shape (0, naxis)\n+                output = np.empty((0, self.naxis), dtype=float)\n+            else:\n+                if ra_dec_order and sky == 'input':\n+                    xy = self._denormalize_sky(xy)\n+                output = func(xy, origin)\n+\n             if ra_dec_order and sky == 'output':\n                 output = self._normalize_sky(output)\n                 return (output[:, 0].reshape(axes[0].shape),\n",
    "variant_0": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..783953e77c 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1211,6 +1211,14 @@ reduce these to 2 dimensions using the naxis kwarg.\n         or a single Nx2 array.\n         \"\"\"\n \n+        def _return_list_of_arrays(axes, origin):\n+            try:\n+                axes = np.broadcast_arrays(*axes)\n+            except ValueError:\n+                raise ValueError(\n+                    \"Coordinate arrays are not broadcastable to each other\")\n+\n+\n         def _return_list_of_arrays(axes, origin):\n             try:\n                 axes = np.broadcast_arrays(*axes)\n@@ -1220,9 +1228,32 @@ reduce these to 2 dimensions using the naxis kwarg.\n \n             xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n-            if ra_dec_order and sky == 'input':\n-                xy = self._denormalize_sky(xy)\n-            output = func(xy, origin)\n+            # Handle empty array case to avoid C library error\n+            if xy.size == 0:\n+                # Create empty output array with correct shape (0, naxis)\n+                output = np.empty((0, self.naxis), dtype=float)\n+            else:\n+                if ra_dec_order and sky == 'input':\n+                    xy = self._denormalize_sky(xy)\n+                output = func(xy, origin)\n+            if ra_dec_order and sky == 'output':\n+                output = self._normalize_sky(output)\n+                return (output[:, 0].reshape(axes[0].shape),\n+                        output[:, 1].reshape(axes[0].shape))\n+            return [output[:, i].reshape(axes[0].shape)\n+                    for i in range(output.shape[1])]\n+\n+            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n+\n+            # Handle empty array case to avoid C library error\n+            if xy.size == 0:\n+                # Create empty output array with correct shape (0, naxis)\n+                output = np.empty((0, self.naxis), dtype=float)\n+            else:\n+                if ra_dec_order and sky == 'input':\n+                    xy = self._denormalize_sky(xy)\n+                output = func(xy, origin)\n+            \n             if ra_dec_order and sky == 'output':\n                 output = self._normalize_sky(output)\n                 return (output[:, 0].reshape(axes[0].shape),\n",
    "variant_1": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..86f9078262 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1211,6 +1211,14 @@ reduce these to 2 dimensions using the naxis kwarg.\n         or a single Nx2 array.\n         \"\"\"\n \n+        def _return_list_of_arrays(axes, origin):\n+            try:\n+                axes = np.broadcast_arrays(*axes)\n+            except ValueError:\n+                raise ValueError(\n+                    \"Coordinate arrays are not broadcastable to each other\")\n+\n+\n         def _return_list_of_arrays(axes, origin):\n             try:\n                 axes = np.broadcast_arrays(*axes)\n@@ -1220,9 +1228,33 @@ reduce these to 2 dimensions using the naxis kwarg.\n \n             xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n-            if ra_dec_order and sky == 'input':\n-                xy = self._denormalize_sky(xy)\n-            output = func(xy, origin)\n+            # Handle empty array case to avoid C library error\n+            if xy.size == 0:\n+                # Create empty output array with correct shape (0, naxis)\n+                output = np.empty((0, self.naxis), dtype=float)\n+            else:\n+                if ra_dec_order and sky == 'input':\n+                    xy = self._denormalize_sky(xy)\n+                output = func(xy, origin)\n+            \n+            if ra_dec_order and sky == 'output':\n+                output = self._normalize_sky(output)\n+                return (output[:, 0].reshape(axes[0].shape),\n+                        output[:, 1].reshape(axes[0].shape))\n+            return [output[:, i].reshape(axes[0].shape)\n+                    for i in range(output.shape[1])]\n+\n+            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n+\n+            # Handle empty array case to avoid C library error\n+            if xy.size == 0:\n+                # Create empty output array with correct shape (0, naxis)\n+                output = np.empty((0, self.naxis), dtype=float)\n+            else:\n+                if ra_dec_order and sky == 'input':\n+                    xy = self._denormalize_sky(xy)\n+                output = func(xy, origin)\n+            \n             if ra_dec_order and sky == 'output':\n                 output = self._normalize_sky(output)\n                 return (output[:, 0].reshape(axes[0].shape),\n",
    "variant_2": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..86f9078262 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1211,6 +1211,14 @@ reduce these to 2 dimensions using the naxis kwarg.\n         or a single Nx2 array.\n         \"\"\"\n \n+        def _return_list_of_arrays(axes, origin):\n+            try:\n+                axes = np.broadcast_arrays(*axes)\n+            except ValueError:\n+                raise ValueError(\n+                    \"Coordinate arrays are not broadcastable to each other\")\n+\n+\n         def _return_list_of_arrays(axes, origin):\n             try:\n                 axes = np.broadcast_arrays(*axes)\n@@ -1220,9 +1228,33 @@ reduce these to 2 dimensions using the naxis kwarg.\n \n             xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n-            if ra_dec_order and sky == 'input':\n-                xy = self._denormalize_sky(xy)\n-            output = func(xy, origin)\n+            # Handle empty array case to avoid C library error\n+            if xy.size == 0:\n+                # Create empty output array with correct shape (0, naxis)\n+                output = np.empty((0, self.naxis), dtype=float)\n+            else:\n+                if ra_dec_order and sky == 'input':\n+                    xy = self._denormalize_sky(xy)\n+                output = func(xy, origin)\n+            \n+            if ra_dec_order and sky == 'output':\n+                output = self._normalize_sky(output)\n+                return (output[:, 0].reshape(axes[0].shape),\n+                        output[:, 1].reshape(axes[0].shape))\n+            return [output[:, i].reshape(axes[0].shape)\n+                    for i in range(output.shape[1])]\n+\n+            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n+\n+            # Handle empty array case to avoid C library error\n+            if xy.size == 0:\n+                # Create empty output array with correct shape (0, naxis)\n+                output = np.empty((0, self.naxis), dtype=float)\n+            else:\n+                if ra_dec_order and sky == 'input':\n+                    xy = self._denormalize_sky(xy)\n+                output = func(xy, origin)\n+            \n             if ra_dec_order and sky == 'output':\n                 output = self._normalize_sky(output)\n                 return (output[:, 0].reshape(axes[0].shape),\n",
    "variant_3": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..86f9078262 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1211,6 +1211,14 @@ reduce these to 2 dimensions using the naxis kwarg.\n         or a single Nx2 array.\n         \"\"\"\n \n+        def _return_list_of_arrays(axes, origin):\n+            try:\n+                axes = np.broadcast_arrays(*axes)\n+            except ValueError:\n+                raise ValueError(\n+                    \"Coordinate arrays are not broadcastable to each other\")\n+\n+\n         def _return_list_of_arrays(axes, origin):\n             try:\n                 axes = np.broadcast_arrays(*axes)\n@@ -1220,9 +1228,33 @@ reduce these to 2 dimensions using the naxis kwarg.\n \n             xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n-            if ra_dec_order and sky == 'input':\n-                xy = self._denormalize_sky(xy)\n-            output = func(xy, origin)\n+            # Handle empty array case to avoid C library error\n+            if xy.size == 0:\n+                # Create empty output array with correct shape (0, naxis)\n+                output = np.empty((0, self.naxis), dtype=float)\n+            else:\n+                if ra_dec_order and sky == 'input':\n+                    xy = self._denormalize_sky(xy)\n+                output = func(xy, origin)\n+            \n+            if ra_dec_order and sky == 'output':\n+                output = self._normalize_sky(output)\n+                return (output[:, 0].reshape(axes[0].shape),\n+                        output[:, 1].reshape(axes[0].shape))\n+            return [output[:, i].reshape(axes[0].shape)\n+                    for i in range(output.shape[1])]\n+\n+            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n+\n+            # Handle empty array case to avoid C library error\n+            if xy.size == 0:\n+                # Create empty output array with correct shape (0, naxis)\n+                output = np.empty((0, self.naxis), dtype=float)\n+            else:\n+                if ra_dec_order and sky == 'input':\n+                    xy = self._denormalize_sky(xy)\n+                output = func(xy, origin)\n+            \n             if ra_dec_order and sky == 'output':\n                 output = self._normalize_sky(output)\n                 return (output[:, 0].reshape(axes[0].shape),\n",
    "variant_4": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..c91440e31e 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1211,6 +1211,14 @@ reduce these to 2 dimensions using the naxis kwarg.\n         or a single Nx2 array.\n         \"\"\"\n \n+        def _return_list_of_arrays(axes, origin):\n+            try:\n+                axes = np.broadcast_arrays(*axes)\n+            except ValueError:\n+                raise ValueError(\n+                    \"Coordinate arrays are not broadcastable to each other\")\n+\n+\n         def _return_list_of_arrays(axes, origin):\n             try:\n                 axes = np.broadcast_arrays(*axes)\n@@ -1220,9 +1228,38 @@ reduce these to 2 dimensions using the naxis kwarg.\n \n             xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n-            if ra_dec_order and sky == 'input':\n-                xy = self._denormalize_sky(xy)\n-            output = func(xy, origin)\n+            # Handle empty array case to avoid C library error\n+            if xy.size == 0:\n+                # Create empty output array with correct shape (0, naxis)\n+                output = np.empty((0, self.naxis), dtype=float)\n+            else:\n+                if ra_dec_order and sky == 'input':\n+                    xy = self._denormalize_sky(xy)\n+                output = func(xy, origin)\n+            if ra_dec_order and sky == 'output':\n+                output = self._normalize_sky(output)\n+                return (output[:, 0].reshape(axes[0].shape),\n+                        output[:, 1].reshape(axes[0].shape))\n+            return [output[:, i].reshape(axes[0].shape)\n+                    for i in range(output.shape[1])]\n+\n+            try:\n+                axes = np.broadcast_arrays(*axes)\n+            except ValueError:\n+                raise ValueError(\n+                    \"Coordinate arrays are not broadcastable to each other\")\n+\n+            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n+\n+            # Handle empty array case to avoid C library error\n+            if xy.size == 0:\n+                # Create empty output array with correct shape (0, naxis)\n+                output = np.empty((0, self.naxis), dtype=float)\n+            else:\n+                if ra_dec_order and sky == 'input':\n+                    xy = self._denormalize_sky(xy)\n+                output = func(xy, origin)\n+            \n             if ra_dec_order and sky == 'output':\n                 output = self._normalize_sky(output)\n                 return (output[:, 0].reshape(axes[0].shape),\n",
    "variant_5": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..783953e77c 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1211,6 +1211,14 @@ reduce these to 2 dimensions using the naxis kwarg.\n         or a single Nx2 array.\n         \"\"\"\n \n+        def _return_list_of_arrays(axes, origin):\n+            try:\n+                axes = np.broadcast_arrays(*axes)\n+            except ValueError:\n+                raise ValueError(\n+                    \"Coordinate arrays are not broadcastable to each other\")\n+\n+\n         def _return_list_of_arrays(axes, origin):\n             try:\n                 axes = np.broadcast_arrays(*axes)\n@@ -1220,9 +1228,32 @@ reduce these to 2 dimensions using the naxis kwarg.\n \n             xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n-            if ra_dec_order and sky == 'input':\n-                xy = self._denormalize_sky(xy)\n-            output = func(xy, origin)\n+            # Handle empty array case to avoid C library error\n+            if xy.size == 0:\n+                # Create empty output array with correct shape (0, naxis)\n+                output = np.empty((0, self.naxis), dtype=float)\n+            else:\n+                if ra_dec_order and sky == 'input':\n+                    xy = self._denormalize_sky(xy)\n+                output = func(xy, origin)\n+            if ra_dec_order and sky == 'output':\n+                output = self._normalize_sky(output)\n+                return (output[:, 0].reshape(axes[0].shape),\n+                        output[:, 1].reshape(axes[0].shape))\n+            return [output[:, i].reshape(axes[0].shape)\n+                    for i in range(output.shape[1])]\n+\n+            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n+\n+            # Handle empty array case to avoid C library error\n+            if xy.size == 0:\n+                # Create empty output array with correct shape (0, naxis)\n+                output = np.empty((0, self.naxis), dtype=float)\n+            else:\n+                if ra_dec_order and sky == 'input':\n+                    xy = self._denormalize_sky(xy)\n+                output = func(xy, origin)\n+            \n             if ra_dec_order and sky == 'output':\n                 output = self._normalize_sky(output)\n                 return (output[:, 0].reshape(axes[0].shape),\n",
    "variant_6": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..783953e77c 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1211,6 +1211,14 @@ reduce these to 2 dimensions using the naxis kwarg.\n         or a single Nx2 array.\n         \"\"\"\n \n+        def _return_list_of_arrays(axes, origin):\n+            try:\n+                axes = np.broadcast_arrays(*axes)\n+            except ValueError:\n+                raise ValueError(\n+                    \"Coordinate arrays are not broadcastable to each other\")\n+\n+\n         def _return_list_of_arrays(axes, origin):\n             try:\n                 axes = np.broadcast_arrays(*axes)\n@@ -1220,9 +1228,32 @@ reduce these to 2 dimensions using the naxis kwarg.\n \n             xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n-            if ra_dec_order and sky == 'input':\n-                xy = self._denormalize_sky(xy)\n-            output = func(xy, origin)\n+            # Handle empty array case to avoid C library error\n+            if xy.size == 0:\n+                # Create empty output array with correct shape (0, naxis)\n+                output = np.empty((0, self.naxis), dtype=float)\n+            else:\n+                if ra_dec_order and sky == 'input':\n+                    xy = self._denormalize_sky(xy)\n+                output = func(xy, origin)\n+            if ra_dec_order and sky == 'output':\n+                output = self._normalize_sky(output)\n+                return (output[:, 0].reshape(axes[0].shape),\n+                        output[:, 1].reshape(axes[0].shape))\n+            return [output[:, i].reshape(axes[0].shape)\n+                    for i in range(output.shape[1])]\n+\n+            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n+\n+            # Handle empty array case to avoid C library error\n+            if xy.size == 0:\n+                # Create empty output array with correct shape (0, naxis)\n+                output = np.empty((0, self.naxis), dtype=float)\n+            else:\n+                if ra_dec_order and sky == 'input':\n+                    xy = self._denormalize_sky(xy)\n+                output = func(xy, origin)\n+            \n             if ra_dec_order and sky == 'output':\n                 output = self._normalize_sky(output)\n                 return (output[:, 0].reshape(axes[0].shape),\n",
    "variant_7": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..783953e77c 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1211,6 +1211,14 @@ reduce these to 2 dimensions using the naxis kwarg.\n         or a single Nx2 array.\n         \"\"\"\n \n+        def _return_list_of_arrays(axes, origin):\n+            try:\n+                axes = np.broadcast_arrays(*axes)\n+            except ValueError:\n+                raise ValueError(\n+                    \"Coordinate arrays are not broadcastable to each other\")\n+\n+\n         def _return_list_of_arrays(axes, origin):\n             try:\n                 axes = np.broadcast_arrays(*axes)\n@@ -1220,9 +1228,32 @@ reduce these to 2 dimensions using the naxis kwarg.\n \n             xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n-            if ra_dec_order and sky == 'input':\n-                xy = self._denormalize_sky(xy)\n-            output = func(xy, origin)\n+            # Handle empty array case to avoid C library error\n+            if xy.size == 0:\n+                # Create empty output array with correct shape (0, naxis)\n+                output = np.empty((0, self.naxis), dtype=float)\n+            else:\n+                if ra_dec_order and sky == 'input':\n+                    xy = self._denormalize_sky(xy)\n+                output = func(xy, origin)\n+            if ra_dec_order and sky == 'output':\n+                output = self._normalize_sky(output)\n+                return (output[:, 0].reshape(axes[0].shape),\n+                        output[:, 1].reshape(axes[0].shape))\n+            return [output[:, i].reshape(axes[0].shape)\n+                    for i in range(output.shape[1])]\n+\n+            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n+\n+            # Handle empty array case to avoid C library error\n+            if xy.size == 0:\n+                # Create empty output array with correct shape (0, naxis)\n+                output = np.empty((0, self.naxis), dtype=float)\n+            else:\n+                if ra_dec_order and sky == 'input':\n+                    xy = self._denormalize_sky(xy)\n+                output = func(xy, origin)\n+            \n             if ra_dec_order and sky == 'output':\n                 output = self._normalize_sky(output)\n                 return (output[:, 0].reshape(axes[0].shape),\n",
    "variant_8": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..783953e77c 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1211,6 +1211,14 @@ reduce these to 2 dimensions using the naxis kwarg.\n         or a single Nx2 array.\n         \"\"\"\n \n+        def _return_list_of_arrays(axes, origin):\n+            try:\n+                axes = np.broadcast_arrays(*axes)\n+            except ValueError:\n+                raise ValueError(\n+                    \"Coordinate arrays are not broadcastable to each other\")\n+\n+\n         def _return_list_of_arrays(axes, origin):\n             try:\n                 axes = np.broadcast_arrays(*axes)\n@@ -1220,9 +1228,32 @@ reduce these to 2 dimensions using the naxis kwarg.\n \n             xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n-            if ra_dec_order and sky == 'input':\n-                xy = self._denormalize_sky(xy)\n-            output = func(xy, origin)\n+            # Handle empty array case to avoid C library error\n+            if xy.size == 0:\n+                # Create empty output array with correct shape (0, naxis)\n+                output = np.empty((0, self.naxis), dtype=float)\n+            else:\n+                if ra_dec_order and sky == 'input':\n+                    xy = self._denormalize_sky(xy)\n+                output = func(xy, origin)\n+            if ra_dec_order and sky == 'output':\n+                output = self._normalize_sky(output)\n+                return (output[:, 0].reshape(axes[0].shape),\n+                        output[:, 1].reshape(axes[0].shape))\n+            return [output[:, i].reshape(axes[0].shape)\n+                    for i in range(output.shape[1])]\n+\n+            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n+\n+            # Handle empty array case to avoid C library error\n+            if xy.size == 0:\n+                # Create empty output array with correct shape (0, naxis)\n+                output = np.empty((0, self.naxis), dtype=float)\n+            else:\n+                if ra_dec_order and sky == 'input':\n+                    xy = self._denormalize_sky(xy)\n+                output = func(xy, origin)\n+            \n             if ra_dec_order and sky == 'output':\n                 output = self._normalize_sky(output)\n                 return (output[:, 0].reshape(axes[0].shape),\n"
  }
}