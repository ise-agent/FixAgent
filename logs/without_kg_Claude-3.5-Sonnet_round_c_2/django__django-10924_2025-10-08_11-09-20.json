{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/django/django/forms/fields.py lines 1079-1092)": "\n    def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n                 allow_folders=False, **kwargs):\n        self.path, self.match, self.recursive = path, match, recursive\n        self.allow_files, self.allow_folders = allow_files, allow_folders\n        super().__init__(choices=(), **kwargs)\n\n        if self.required:\n            self.choices = []\n        else:\n            self.choices = [(\"\", \"---------\")]\n\n        if self.match is not None:\n            self.match_re = re.compile(self.match)\n\n        # Build choices with resolved path\n        resolved_path = self._get_resolved_path()\n        \n        if recursive:\n            for root, dirs, files in sorted(os.walk(resolved_path)):\n                if self.allow_files:\n                    for f in sorted(files):\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n                if self.allow_folders:\n                    for f in sorted(dirs):\n                        if f == '__pycache__':\n                            continue\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n        else:\n            try:\n                with os.scandir(resolved_path) as entries:\n                    for f in sorted(entries, key=operator.attrgetter('name')):\n                        if f.name == '__pycache__':\n                            continue\n                        if (((self.allow_files and f.is_file()) or\n                                (self.allow_folders and f.is_dir())) and\n                                (self.match is None or self.match_re.search(f.name))):\n                            self.choices.append((f.path, f.name))\n            except OSError:\n                pass\n\n    def _get_resolved_path(self):\n        \"\"\"Resolve path if it's callable, otherwise return as-is.\"\"\"\n        if callable(self.path):\n            return self.path()\n        return self.path\n",
    "Location 2 (/root/hy/projects_2/django/django/forms/fields.py lines 1093-1107)": "\n        super().__init__(choices=(), **kwargs)\n\n        if self.required:\n            self.choices = []\n        else:\n            self.choices = [(\"\", \"---------\")]\n\n        if self.match is not None:\n            self.match_re = re.compile(self.match)\n\n        # Resolve callable path at runtime\n        resolved_path = self.path() if callable(self.path) else self.path\n\n        if recursive:\n            for root, dirs, files in sorted(os.walk(resolved_path)):\n                if self.allow_files:\n                    for f in sorted(files):\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n                if self.allow_folders:\n                    for f in sorted(dirs):\n                        if f == '__pycache__':\n                            continue\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n",
    "Location 3 (/root/hy/projects_2/django/django/forms/fields.py lines 1108-1118)": "\n        else:\n            choices = []\n            # Resolve callable path at runtime\n            resolved_path = self._resolve_path()\n            for f in os.scandir(resolved_path):\n                if f.name == '__pycache__':\n                    continue\n                if (((self.allow_files and f.is_file()) or\n                        (self.allow_folders and f.is_dir())) and\n                        (self.match is None or self.match_re.search(f.name))):\n                    choices.append((f.path, f.name))\n            choices.sort(key=operator.itemgetter(1))\n            self.choices.extend(choices)\n",
    "Location 4 (/root/hy/projects_2/django/django/db/models/fields/__init__.py lines 1710-1719)": "\n    def formfield(self, **kwargs):\n        return super().formfield(**{\n            'path': self.path,\n            'match': self.match,\n            'recursive': self.recursive,\n            'form_class': forms.FilePathField,\n            'allow_files': self.allow_files,\n            'allow_folders': self.allow_folders,\n            **kwargs,\n        })\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/django/django/forms/fields.py lines 1079-1092)": [
      "\n    def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n                 allow_folders=False, **kwargs):\n        self.path, self.match, self.recursive = path, match, recursive\n        self.allow_files, self.allow_folders = allow_files, allow_folders\n        super().__init__(choices=(), **kwargs)\n\n        if self.required:\n            self.choices = []\n        else:\n            self.choices = [(\"\", \"---------\")]\n\n        if self.match is not None:\n            self.match_re = re.compile(self.match)\n\n        # Build choices using resolved path\n        resolved_path = self._resolve_path()\n        self._build_choices(resolved_path)\n\n    def _resolve_path(self):\n        \"\"\"Resolve the path, handling both string and callable forms.\"\"\"\n        if callable(self.path):\n            return self.path()\n        return self.path\n\n    def _build_choices(self, resolved_path):\n        \"\"\"Build the choices list using the resolved path.\"\"\"\n",
      "\n    def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n                 allow_folders=False, **kwargs):\n        self.path, self.match, self.recursive = path, match, recursive\n        self.allow_files, self.allow_folders = allow_files, allow_folders\n        super().__init__(choices=(), **kwargs)\n\n        if self.required:\n            self.choices = []\n        else:\n            self.choices = [(\"\", \"---------\")]\n\n        if self.match is not None:\n            self.match_re = re.compile(self.match)\n\n        # Build choices using resolved path\n        resolved_path = self._resolve_path()\n        self._build_choices(resolved_path)\n\n    def _resolve_path(self):\n        \"\"\"Resolve path if it's a callable, otherwise return as-is.\"\"\"\n        if callable(self.path):\n            return self.path()\n        return self.path\n\n    def _build_choices(self, resolved_path):\n        \"\"\"Build the choices list using the resolved path.\"\"\"\n",
      "\n    def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n                 allow_folders=False, **kwargs):\n        self.path, self.match, self.recursive = path, match, recursive\n        self.allow_files, self.allow_folders = allow_files, allow_folders\n        super().__init__(choices=(), **kwargs)\n\n        if self.required:\n            self.choices = []\n        else:\n            self.choices = [(\"\", \"---------\")]\n\n        if self.match is not None:\n            self.match_re = re.compile(self.match)\n\n        # Build choices using resolved path\n        resolved_path = self._resolve_path()\n        \n        if recursive:\n            for root, dirs, files in sorted(os.walk(resolved_path)):\n                if self.allow_files:\n                    for f in sorted(files):\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n                if self.allow_folders:\n                    for f in sorted(dirs):\n                        if f == '__pycache__':\n                            continue\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n        else:\n            with os.scandir(resolved_path) as entries:\n                for f in sorted(entries, key=operator.attrgetter('name')):\n                    if f.name == '__pycache__':\n                        continue\n                    if (((self.allow_files and f.is_file()) or\n                         (self.allow_folders and f.is_dir())) and\n                        (self.match is None or self.match_re.search(f.name))):\n                        self.choices.append((f.path, f.name))\n\n    def _resolve_path(self):\n        \"\"\"Resolve the path, handling both strings and callables.\"\"\"\n        if callable(self.path):\n            return self.path()\n        return self.path\n",
      "\ndef __init__(self, path, *, match=None, recursive=False, allow_files=True,\n             allow_folders=False, **kwargs):\n    self.path, self.match, self.recursive = path, match, recursive\n    self.allow_files, self.allow_folders = allow_files, allow_folders\n    super().__init__(choices=(), **kwargs)\n\n    # Defer choice building to allow callable path resolution\n    self._choices_built = False\n\ndef _get_path(self):\n    \"\"\"Resolve path if it's a callable, otherwise return as-is.\"\"\"\n    if callable(self.path):\n        return self.path()\n    return self.path\n\ndef _build_choices(self):\n    \"\"\"Build choices from the resolved path.\"\"\"\n    if self._choices_built:\n        return\n    \n    resolved_path = self._get_path()\n    \n    if self.required:\n        self.choices = []\n    else:\n        self.choices = [(\"\", \"---------\")]\n\n    if self.match is not None:\n        self.match_re = re.compile(self.match)\n",
      "\n    def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n                 allow_folders=False, **kwargs):\n        self.path, self.match, self.recursive = path, match, recursive\n        self.allow_files, self.allow_folders = allow_files, allow_folders\n        super().__init__(choices=(), **kwargs)\n\n        if self.required:\n            self.choices = []\n        else:\n            self.choices = [(\"\", \"---------\")]\n\n        if self.match is not None:\n            self.match_re = re.compile(self.match)\n\n        # Build choices using resolved path\n        resolved_path = self._resolve_path()\n        self._build_choices(resolved_path)\n\n    def _resolve_path(self):\n        \"\"\"Resolve the path, handling both strings and callables.\"\"\"\n        if callable(self.path):\n            return self.path()\n        return self.path\n\n    def _build_choices(self, resolved_path):\n        \"\"\"Build choices using the resolved path.\"\"\"\n",
      "\ndef __init__(self, path, *, match=None, recursive=False, allow_files=True,\n             allow_folders=False, **kwargs):\n    self.path, self.match, self.recursive = path, match, recursive\n    self.allow_files, self.allow_folders = allow_files, allow_folders\n    super().__init__(choices=(), **kwargs)\n\n    if self.required:\n        self.choices = []\n    else:\n        self.choices = [(\"\", \"---------\")]\n\n    if self.match is not None:\n        self.match_re = re.compile(self.match)\n\n    # Defer path resolution and choice building\n    self._build_choices()\n\ndef _resolve_path(self):\n    \"\"\"Resolve the path, handling both string paths and callables.\"\"\"\n    if callable(self.path):\n        return self.path()\n    return self.path\n\ndef _build_choices(self):\n    \"\"\"Build the choices list using the resolved path.\"\"\"\n    resolved_path = self._resolve_path()\n",
      "\ndef __init__(self, path, *, match=None, recursive=False, allow_files=True,\n             allow_folders=False, **kwargs):\n    self.path, self.match, self.recursive = path, match, recursive\n    self.allow_files, self.allow_folders = allow_files, allow_folders\n    super().__init__(choices=(), **kwargs)\n\n    if self.required:\n        self.choices = []\n    else:\n        self.choices = [(\"\", \"---------\")]\n\n    if self.match is not None:\n        self.match_re = re.compile(self.match)\n\n    # Defer choice building to allow callable path resolution\n    self._build_choices()\n\ndef _resolve_path(self):\n    \"\"\"Resolve the path, handling both string paths and callables.\"\"\"\n    if callable(self.path):\n        return self.path()\n    return self.path\n\ndef _build_choices(self):\n    \"\"\"Build the choices list using the resolved path.\"\"\"\n    resolved_path = self._resolve_path()\n",
      "\n    def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n                 allow_folders=False, **kwargs):\n        self.path, self.match, self.recursive = path, match, recursive\n        self.allow_files, self.allow_folders = allow_files, allow_folders\n        super().__init__(choices=(), **kwargs)\n\n        if self.required:\n            self.choices = []\n        else:\n            self.choices = [(\"\", \"---------\")]\n\n        if self.match is not None:\n            self.match_re = re.compile(self.match)\n\n        # Build choices using resolved path\n        resolved_path = self._resolve_path()\n        \n        if recursive:\n            for root, dirs, files in sorted(os.walk(resolved_path)):\n                if self.allow_files:\n                    for f in sorted(files):\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n                if self.allow_folders:\n                    for f in sorted(dirs):\n                        if f == '__pycache__':\n                            continue\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n        else:\n            with os.scandir(resolved_path) as entries:\n                for f in sorted(entries, key=operator.attrgetter('name')):\n                    if f.name == '__pycache__':\n                        continue\n                    if (((self.allow_files and f.is_file()) or\n                         (self.allow_folders and f.is_dir())) and\n                        (self.match is None or self.match_re.search(f.name))):\n                        self.choices.append((f.path, f.name))\n\n    def _resolve_path(self):\n        \"\"\"Resolve the path, calling it if it's a callable.\"\"\"\n        if callable(self.path):\n            return self.path()\n        return self.path\n"
    ],
    "Location 2 (/root/hy/projects_2/django/django/forms/fields.py lines 1093-1107)": [
      "\n    def __init__(self, path, match=None, recursive=False, allow_files=True,\n                 allow_folders=False, **kwargs):\n        self.path = path\n        self.match, self.recursive = match, recursive\n        self.allow_files, self.allow_folders = allow_files, allow_folders\n        super().__init__(choices=(), **kwargs)\n\n        if self.required:\n            self.choices = []\n        else:\n            self.choices = [(\"\", \"---------\")]\n\n        if self.match is not None:\n            self.match_re = re.compile(self.match)\n\n        # Resolve path if it's callable\n        resolved_path = self.path() if callable(self.path) else self.path\n        \n        if recursive:\n            for root, dirs, files in sorted(os.walk(resolved_path)):\n                if self.allow_files:\n                    for f in sorted(files):\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n                if self.allow_folders:\n                    for f in sorted(dirs):\n                        if f == '__pycache__':\n                            continue\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n",
      "\n    def __init__(self, path, match=None, recursive=False, allow_files=True,\n                 allow_folders=False, **kwargs):\n        self.path = path\n        self.match = match\n        self.recursive = recursive\n        self.allow_files = allow_files\n        self.allow_folders = allow_folders\n        super().__init__(choices=(), **kwargs)\n\n        if self.required:\n            self.choices = []\n        else:\n            self.choices = [(\"\", \"---------\")]\n\n        if self.match is not None:\n            self.match_re = re.compile(self.match)\n\n        # Resolve path if it's callable\n        resolved_path = self.path() if callable(self.path) else self.path\n\n        if recursive:\n            for root, dirs, files in sorted(os.walk(resolved_path)):\n                if self.allow_files:\n                    for f in sorted(files):\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n                if self.allow_folders:\n                    for f in sorted(dirs):\n                        if f == '__pycache__':\n                            continue\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n        else:\n            choices = []\n            for f in os.scandir(resolved_path):\n                if f.name == '__pycache__':\n                    continue\n                if (((self.allow_files and f.is_file()) or\n                        (self.allow_folders and f.is_dir())) and\n                        (self.match is None or self.match_re.search(f.name))):\n                    choices.append((f.path, f.name))\n            choices.sort(key=operator.itemgetter(1))\n            self.choices.extend(choices)\n",
      "\n        super().__init__(choices=(), **kwargs)\n\n        if self.required:\n            self.choices = []\n        else:\n            self.choices = [(\"\", \"---------\")]\n\n        if self.match is not None:\n            self.match_re = re.compile(self.match)\n\n        # Resolve path if it's callable\n        resolved_path = self.path() if callable(self.path) else self.path\n\n        if recursive:\n            for root, dirs, files in sorted(os.walk(resolved_path)):\n                if self.allow_files:\n                    for f in sorted(files):\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n                if self.allow_folders:\n                    for f in sorted(dirs):\n                        if f == '__pycache__':\n                            continue\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n",
      "\n    def __init__(self, path, match=None, recursive=False, allow_files=True,\n                 allow_folders=False, **kwargs):\n        self.path = path\n        self.match, self.recursive = match, recursive\n        self.allow_files, self.allow_folders = allow_files, allow_folders\n        super().__init__(choices=(), **kwargs)\n\n        if self.required:\n            self.choices = []\n        else:\n            self.choices = [(\"\", \"---------\")]\n\n        if self.match is not None:\n            self.match_re = re.compile(self.match)\n\n        # Resolve path if it's a callable\n        resolved_path = self.path() if callable(self.path) else self.path\n\n        if recursive:\n            for root, dirs, files in sorted(os.walk(resolved_path)):\n                if self.allow_files:\n                    for f in sorted(files):\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n                if self.allow_folders:\n                    for f in sorted(dirs):\n                        if f == '__pycache__':\n                            continue\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n",
      "\n        super().__init__(choices=(), **kwargs)\n\n        if self.required:\n            self.choices = []\n        else:\n            self.choices = [(\"\", \"---------\")]\n\n        if self.match is not None:\n            self.match_re = re.compile(self.match)\n\n        # Resolve the path if it's callable\n        resolved_path = self.path() if callable(self.path) else self.path\n\n        if recursive:\n            for root, dirs, files in sorted(os.walk(resolved_path)):\n                if self.allow_files:\n                    for f in sorted(files):\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n                if self.allow_folders:\n                    for f in sorted(dirs):\n                        if f == '__pycache__':\n                            continue\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n",
      "\n        super().__init__(choices=(), **kwargs)\n\n        if self.required:\n            self.choices = []\n        else:\n            self.choices = [(\"\", \"---------\")]\n\n        if self.match is not None:\n            self.match_re = re.compile(self.match)\n\n        # Resolve path if it's callable\n        resolved_path = self.path() if callable(self.path) else self.path\n\n        if recursive:\n            for root, dirs, files in sorted(os.walk(resolved_path)):\n                if self.allow_files:\n                    for f in sorted(files):\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n                if self.allow_folders:\n                    for f in sorted(dirs):\n                        if f == '__pycache__':\n                            continue\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n",
      "\n        super().__init__(choices=(), **kwargs)\n\n        if self.required:\n            self.choices = []\n        else:\n            self.choices = [(\"\", \"---------\")]\n\n        if self.match is not None:\n            self.match_re = re.compile(self.match)\n\n        # Resolve path if it's callable\n        resolved_path = self.path() if callable(self.path) else self.path\n\n        if recursive:\n            for root, dirs, files in sorted(os.walk(resolved_path)):\n                if self.allow_files:\n                    for f in sorted(files):\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n                if self.allow_folders:\n                    for f in sorted(dirs):\n                        if f == '__pycache__':\n                            continue\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n",
      "\n    def __init__(self, path, match=None, recursive=False, allow_files=True,\n                 allow_folders=False, **kwargs):\n        self.path = path\n        self.match = match\n        self.recursive = recursive\n        self.allow_files = allow_files\n        self.allow_folders = allow_folders\n        super().__init__(choices=(), **kwargs)\n\n        if self.required:\n            self.choices = []\n        else:\n            self.choices = [(\"\", \"---------\")]\n\n        if self.match is not None:\n            self.match_re = re.compile(self.match)\n\n        # Resolve path if it's callable\n        resolved_path = self.path() if callable(self.path) else self.path\n\n        if recursive:\n            for root, dirs, files in sorted(os.walk(resolved_path)):\n                if self.allow_files:\n                    for f in sorted(files):\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n                if self.allow_folders:\n                    for f in sorted(dirs):\n                        if f == '__pycache__':\n                            continue\n                        if self.match is None or self.match_re.search(f):\n                            f = os.path.join(root, f)\n                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n        else:\n            choices = []\n            for f in os.scandir(resolved_path):\n                if f.name == '__pycache__':\n                    continue\n                if (((self.allow_files and f.is_file()) or\n                        (self.allow_folders and f.is_dir())) and\n                        (self.match is None or self.match_re.search(f.name))):\n                    choices.append((f.path, f.name))\n            choices.sort(key=operator.itemgetter(1))\n            self.choices.extend(choices)\n"
    ],
    "Location 3 (/root/hy/projects_2/django/django/forms/fields.py lines 1108-1118)": [
      "\n        else:\n            # Resolve path if it's a callable\n            resolved_path = self.path() if callable(self.path) else self.path\n            choices = []\n            for f in os.scandir(resolved_path):\n                if f.name == '__pycache__':\n                    continue\n                if (((self.allow_files and f.is_file()) or\n                        (self.allow_folders and f.is_dir())) and\n                        (self.match is None or self.match_re.search(f.name))):\n                    choices.append((f.path, f.name))\n            choices.sort(key=operator.itemgetter(1))\n            self.choices.extend(choices)\n",
      "\n        else:\n            # Resolve path if it's callable\n            resolved_path = self._resolve_path()\n            choices = []\n            for f in os.scandir(resolved_path):\n                if f.name == '__pycache__':\n                    continue\n                if (((self.allow_files and f.is_file()) or\n                        (self.allow_folders and f.is_dir())) and\n                        (self.match is None or self.match_re.search(f.name))):\n                    choices.append((f.path, f.name))\n            choices.sort(key=operator.itemgetter(1))\n            self.choices.extend(choices)\n",
      "\n        else:\n            # Resolve path if it's a callable\n            resolved_path = self._resolve_path()\n            choices = []\n            for f in os.scandir(resolved_path):\n                if f.name == '__pycache__':\n                    continue\n                if (((self.allow_files and f.is_file()) or\n                        (self.allow_folders and f.is_dir())) and\n                        (self.match is None or self.match_re.search(f.name))):\n                    choices.append((f.path, f.name))\n            choices.sort(key=operator.itemgetter(1))\n            self.choices.extend(choices)\n",
      "\n        else:\n            # Resolve path if it's callable\n            resolved_path = self._resolve_path()\n            choices = []\n            for f in os.scandir(resolved_path):\n                if f.name == '__pycache__':\n                    continue\n                if (((self.allow_files and f.is_file()) or\n                        (self.allow_folders and f.is_dir())) and\n                        (self.match is None or self.match_re.search(f.name))):\n                    choices.append((f.path, f.name))\n            choices.sort(key=operator.itemgetter(1))\n            self.choices.extend(choices)\n",
      "\n        else:\n            # Resolve path if it's a callable\n            resolved_path = self._get_resolved_path()\n            choices = []\n            for f in os.scandir(resolved_path):\n                if f.name == '__pycache__':\n                    continue\n                if (((self.allow_files and f.is_file()) or\n                        (self.allow_folders and f.is_dir())) and\n                        (self.match is None or self.match_re.search(f.name))):\n                    choices.append((f.path, f.name))\n            choices.sort(key=operator.itemgetter(1))\n            self.choices.extend(choices)\n",
      "\n        else:\n            # Resolve callable path at runtime\n            resolved_path = self._resolve_path()\n            choices = []\n            for f in os.scandir(resolved_path):\n                if f.name == '__pycache__':\n                    continue\n                if (((self.allow_files and f.is_file()) or\n                        (self.allow_folders and f.is_dir())) and\n                        (self.match is None or self.match_re.search(f.name))):\n                    choices.append((f.path, f.name))\n            choices.sort(key=operator.itemgetter(1))\n            self.choices.extend(choices)\n",
      "\n        else:\n            # Resolve path if it's a callable\n            resolved_path = self.path() if callable(self.path) else self.path\n            choices = []\n            for f in os.scandir(resolved_path):\n                if f.name == '__pycache__':\n                    continue\n                if (((self.allow_files and f.is_file()) or\n                        (self.allow_folders and f.is_dir())) and\n                        (self.match is None or self.match_re.search(f.name))):\n                    choices.append((f.path, f.name))\n            choices.sort(key=operator.itemgetter(1))\n            self.choices.extend(choices)\n",
      "\n        else:\n            # Resolve path if it's a callable\n            resolved_path = self._resolve_path()\n            choices = []\n            for f in os.scandir(resolved_path):\n                if f.name == '__pycache__':\n                    continue\n                if (((self.allow_files and f.is_file()) or\n                        (self.allow_folders and f.is_dir())) and\n                        (self.match is None or self.match_re.search(f.name))):\n                    choices.append((f.path, f.name))\n            choices.sort(key=operator.itemgetter(1))\n            self.choices.extend(choices)\n"
    ],
    "Location 4 (/root/hy/projects_2/django/django/db/models/fields/__init__.py lines 1710-1719)": [
      "\n    def formfield(self, **kwargs):\n        return super().formfield(**{\n            'path': self.path,\n            'match': self.match,\n            'recursive': self.recursive,\n            'form_class': forms.FilePathField,\n            'allow_files': self.allow_files,\n            'allow_folders': self.allow_folders,\n            **kwargs,\n        })\n",
      "\ndef formfield(self, **kwargs):\n    return super().formfield(**{\n        'path': self.path,\n        'match': self.match,\n        'recursive': self.recursive,\n        'form_class': forms.FilePathField,\n        'allow_files': self.allow_files,\n        'allow_folders': self.allow_folders,\n        **kwargs,\n    })\n",
      "\n    def formfield(self, **kwargs):\n        return super().formfield(**{\n            'path': self.path,\n            'match': self.match,\n            'recursive': self.recursive,\n            'form_class': forms.FilePathField,\n            'allow_files': self.allow_files,\n            'allow_folders': self.allow_folders,\n            **kwargs,\n        })\n",
      "\n    def formfield(self, **kwargs):\n        return super().formfield(**{\n            'path': self.path,\n            'match': self.match,\n            'recursive': self.recursive,\n            'form_class': forms.FilePathField,\n            'allow_files': self.allow_files,\n            'allow_folders': self.allow_folders,\n            **kwargs,\n        })\n",
      "\n    def formfield(self, **kwargs):\n        return super().formfield(**{\n            'path': self.path,\n            'match': self.match,\n            'recursive': self.recursive,\n            'form_class': forms.FilePathField,\n            'allow_files': self.allow_files,\n            'allow_folders': self.allow_folders,\n            **kwargs,\n        })\n",
      "\n    def formfield(self, **kwargs):\n        return super().formfield(**{\n            'path': self.path,\n            'match': self.match,\n            'recursive': self.recursive,\n            'form_class': forms.FilePathField,\n            'allow_files': self.allow_files,\n            'allow_folders': self.allow_folders,\n            **kwargs,\n        })\n",
      "\n    def formfield(self, **kwargs):\n        return super().formfield(**{\n            'path': self.path,\n            'match': self.match,\n            'recursive': self.recursive,\n            'form_class': forms.FilePathField,\n            'allow_files': self.allow_files,\n            'allow_folders': self.allow_folders,\n            **kwargs,\n        })\n",
      "\n    def formfield(self, **kwargs):\n        return super().formfield(**{\n            'path': self.path,\n            'match': self.match,\n            'recursive': self.recursive,\n            'form_class': forms.FilePathField,\n            'allow_files': self.allow_files,\n            'allow_folders': self.allow_folders,\n            **kwargs,\n        })\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0c64748ccd..5dc089ad3b 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1707,6 +1707,7 @@ class FilePathField(Field):\n             return None\n         return str(value)\n \n+\n     def formfield(self, **kwargs):\n         return super().formfield(**{\n             'path': self.path,\ndiff --git a/django/forms/fields.py b/django/forms/fields.py\nindex a977256525..671c678167 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -1076,6 +1076,7 @@ class MultiValueField(Field):\n \n \n class FilePathField(ChoiceField):\n+\n     def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n                  allow_folders=False, **kwargs):\n         self.path, self.match, self.recursive = path, match, recursive\n@@ -1090,23 +1091,27 @@ class FilePathField(ChoiceField):\n         if self.match is not None:\n             self.match_re = re.compile(self.match)\n \n+        # Resolve the path if it's a callable\n+        resolved_path = self._resolve_path()\n+\n         if recursive:\n-            for root, dirs, files in sorted(os.walk(self.path)):\n+            for root, dirs, files in sorted(os.walk(resolved_path)):\n                 if self.allow_files:\n                     for f in sorted(files):\n                         if self.match is None or self.match_re.search(f):\n                             f = os.path.join(root, f)\n-                            self.choices.append((f, f.replace(path, \"\", 1)))\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n                 if self.allow_folders:\n                     for f in sorted(dirs):\n                         if f == '__pycache__':\n                             continue\n                         if self.match is None or self.match_re.search(f):\n                             f = os.path.join(root, f)\n-                            self.choices.append((f, f.replace(path, \"\", 1)))\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n         else:\n+\n             choices = []\n-            for f in os.scandir(self.path):\n+            for f in os.scandir(resolved_path):\n                 if f.name == '__pycache__':\n                     continue\n                 if (((self.allow_files and f.is_file()) or\n@@ -1116,6 +1121,11 @@ class FilePathField(ChoiceField):\n             choices.sort(key=operator.itemgetter(1))\n             self.choices.extend(choices)\n \n+    def _resolve_path(self):\n+        \"\"\"Resolve the path if it's a callable, otherwise return as-is.\"\"\"\n+        if callable(self.path):\n+            return self.path()\n+        return self.path\n         self.widget.choices = self.choices\n \n \n",
    "variant_0": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0c64748ccd..5dc089ad3b 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1707,6 +1707,7 @@ class FilePathField(Field):\n             return None\n         return str(value)\n \n+\n     def formfield(self, **kwargs):\n         return super().formfield(**{\n             'path': self.path,\ndiff --git a/django/forms/fields.py b/django/forms/fields.py\nindex a977256525..8f4b3c7f30 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -1076,6 +1076,7 @@ class MultiValueField(Field):\n \n \n class FilePathField(ChoiceField):\n+\n     def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n                  allow_folders=False, **kwargs):\n         self.path, self.match, self.recursive = path, match, recursive\n@@ -1090,23 +1091,75 @@ class FilePathField(ChoiceField):\n         if self.match is not None:\n             self.match_re = re.compile(self.match)\n \n+        # Build choices with resolved path\n+        resolved_path = self._get_resolved_path()\n+        \n         if recursive:\n-            for root, dirs, files in sorted(os.walk(self.path)):\n+            for root, dirs, files in sorted(os.walk(resolved_path)):\n                 if self.allow_files:\n                     for f in sorted(files):\n                         if self.match is None or self.match_re.search(f):\n                             f = os.path.join(root, f)\n-                            self.choices.append((f, f.replace(path, \"\", 1)))\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n                 if self.allow_folders:\n                     for f in sorted(dirs):\n                         if f == '__pycache__':\n                             continue\n                         if self.match is None or self.match_re.search(f):\n                             f = os.path.join(root, f)\n-                            self.choices.append((f, f.replace(path, \"\", 1)))\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n+        else:\n+            try:\n+                with os.scandir(resolved_path) as entries:\n+                    for f in sorted(entries, key=operator.attrgetter('name')):\n+                        if f.name == '__pycache__':\n+                            continue\n+                        if (((self.allow_files and f.is_file()) or\n+                                (self.allow_folders and f.is_dir())) and\n+                                (self.match is None or self.match_re.search(f.name))):\n+                            self.choices.append((f.path, f.name))\n+            except OSError:\n+                pass\n+\n+    def _get_resolved_path(self):\n+        \"\"\"Resolve path if it's callable, otherwise return as-is.\"\"\"\n+        if callable(self.path):\n+            return self.path()\n+        return self.path\n+\n+        super().__init__(choices=(), **kwargs)\n+\n+        if self.required:\n+            self.choices = []\n+        else:\n+            self.choices = [(\"\", \"---------\")]\n+\n+        if self.match is not None:\n+            self.match_re = re.compile(self.match)\n+\n+        # Resolve callable path at runtime\n+        resolved_path = self.path() if callable(self.path) else self.path\n+\n+        if recursive:\n+            for root, dirs, files in sorted(os.walk(resolved_path)):\n+                if self.allow_files:\n+                    for f in sorted(files):\n+                        if self.match is None or self.match_re.search(f):\n+                            f = os.path.join(root, f)\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n+                if self.allow_folders:\n+                    for f in sorted(dirs):\n+                        if f == '__pycache__':\n+                            continue\n+                        if self.match is None or self.match_re.search(f):\n+                            f = os.path.join(root, f)\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n+\n         else:\n             choices = []\n-            for f in os.scandir(self.path):\n+            # Resolve callable path at runtime\n+            resolved_path = self._resolve_path()\n+            for f in os.scandir(resolved_path):\n                 if f.name == '__pycache__':\n                     continue\n                 if (((self.allow_files and f.is_file()) or\n@@ -1115,7 +1168,6 @@ class FilePathField(ChoiceField):\n                     choices.append((f.path, f.name))\n             choices.sort(key=operator.itemgetter(1))\n             self.choices.extend(choices)\n-\n         self.widget.choices = self.choices\n \n \n",
    "variant_1": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0c64748ccd..5dc089ad3b 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1707,6 +1707,7 @@ class FilePathField(Field):\n             return None\n         return str(value)\n \n+\n     def formfield(self, **kwargs):\n         return super().formfield(**{\n             'path': self.path,\ndiff --git a/django/forms/fields.py b/django/forms/fields.py\nindex a977256525..bab16ba5aa 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -1076,6 +1076,7 @@ class MultiValueField(Field):\n \n \n class FilePathField(ChoiceField):\n+\n     def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n                  allow_folders=False, **kwargs):\n         self.path, self.match, self.recursive = path, match, recursive\n@@ -1090,23 +1091,57 @@ class FilePathField(ChoiceField):\n         if self.match is not None:\n             self.match_re = re.compile(self.match)\n \n+        # Build choices using resolved path\n+        resolved_path = self._resolve_path()\n+        self._build_choices(resolved_path)\n+\n+    def _resolve_path(self):\n+        \"\"\"Resolve the path, handling both string and callable forms.\"\"\"\n+        if callable(self.path):\n+            return self.path()\n+        return self.path\n+\n+    def _build_choices(self, resolved_path):\n+        \"\"\"Build the choices list using the resolved path.\"\"\"\n+\n+    def __init__(self, path, match=None, recursive=False, allow_files=True,\n+                 allow_folders=False, **kwargs):\n+        self.path = path\n+        self.match, self.recursive = match, recursive\n+        self.allow_files, self.allow_folders = allow_files, allow_folders\n+        super().__init__(choices=(), **kwargs)\n+\n+        if self.required:\n+            self.choices = []\n+        else:\n+            self.choices = [(\"\", \"---------\")]\n+\n+        if self.match is not None:\n+            self.match_re = re.compile(self.match)\n+\n+        # Resolve path if it's callable\n+        resolved_path = self.path() if callable(self.path) else self.path\n+        \n         if recursive:\n-            for root, dirs, files in sorted(os.walk(self.path)):\n+            for root, dirs, files in sorted(os.walk(resolved_path)):\n                 if self.allow_files:\n                     for f in sorted(files):\n                         if self.match is None or self.match_re.search(f):\n                             f = os.path.join(root, f)\n-                            self.choices.append((f, f.replace(path, \"\", 1)))\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n                 if self.allow_folders:\n                     for f in sorted(dirs):\n                         if f == '__pycache__':\n                             continue\n                         if self.match is None or self.match_re.search(f):\n                             f = os.path.join(root, f)\n-                            self.choices.append((f, f.replace(path, \"\", 1)))\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n+\n         else:\n+            # Resolve path if it's a callable\n+            resolved_path = self.path() if callable(self.path) else self.path\n             choices = []\n-            for f in os.scandir(self.path):\n+            for f in os.scandir(resolved_path):\n                 if f.name == '__pycache__':\n                     continue\n                 if (((self.allow_files and f.is_file()) or\n@@ -1115,7 +1150,6 @@ class FilePathField(ChoiceField):\n                     choices.append((f.path, f.name))\n             choices.sort(key=operator.itemgetter(1))\n             self.choices.extend(choices)\n-\n         self.widget.choices = self.choices\n \n \n",
    "variant_2": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0c64748ccd..73f5a5be67 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1707,16 +1707,17 @@ class FilePathField(Field):\n             return None\n         return str(value)\n \n-    def formfield(self, **kwargs):\n-        return super().formfield(**{\n-            'path': self.path,\n-            'match': self.match,\n-            'recursive': self.recursive,\n-            'form_class': forms.FilePathField,\n-            'allow_files': self.allow_files,\n-            'allow_folders': self.allow_folders,\n-            **kwargs,\n-        })\n+\n+def formfield(self, **kwargs):\n+    return super().formfield(**{\n+        'path': self.path,\n+        'match': self.match,\n+        'recursive': self.recursive,\n+        'form_class': forms.FilePathField,\n+        'allow_files': self.allow_files,\n+        'allow_folders': self.allow_folders,\n+        **kwargs,\n+    })\n \n     def get_internal_type(self):\n         return \"FilePathField\"\ndiff --git a/django/forms/fields.py b/django/forms/fields.py\nindex a977256525..dad7fc3adf 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -1076,6 +1076,7 @@ class MultiValueField(Field):\n \n \n class FilePathField(ChoiceField):\n+\n     def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n                  allow_folders=False, **kwargs):\n         self.path, self.match, self.recursive = path, match, recursive\n@@ -1090,23 +1091,56 @@ class FilePathField(ChoiceField):\n         if self.match is not None:\n             self.match_re = re.compile(self.match)\n \n+        # Build choices using resolved path\n+        resolved_path = self._resolve_path()\n+        self._build_choices(resolved_path)\n+\n+    def _resolve_path(self):\n+        \"\"\"Resolve path if it's a callable, otherwise return as-is.\"\"\"\n+        if callable(self.path):\n+            return self.path()\n+        return self.path\n+\n+    def _build_choices(self, resolved_path):\n+        \"\"\"Build the choices list using the resolved path.\"\"\"\n+\n+    def __init__(self, path, match=None, recursive=False, allow_files=True,\n+                 allow_folders=False, **kwargs):\n+        self.path = path\n+        self.match = match\n+        self.recursive = recursive\n+        self.allow_files = allow_files\n+        self.allow_folders = allow_folders\n+        super().__init__(choices=(), **kwargs)\n+\n+        if self.required:\n+            self.choices = []\n+        else:\n+            self.choices = [(\"\", \"---------\")]\n+\n+        if self.match is not None:\n+            self.match_re = re.compile(self.match)\n+\n+        # Resolve path if it's callable\n+        resolved_path = self.path() if callable(self.path) else self.path\n+\n         if recursive:\n-            for root, dirs, files in sorted(os.walk(self.path)):\n+            for root, dirs, files in sorted(os.walk(resolved_path)):\n                 if self.allow_files:\n                     for f in sorted(files):\n                         if self.match is None or self.match_re.search(f):\n                             f = os.path.join(root, f)\n-                            self.choices.append((f, f.replace(path, \"\", 1)))\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n                 if self.allow_folders:\n                     for f in sorted(dirs):\n                         if f == '__pycache__':\n                             continue\n                         if self.match is None or self.match_re.search(f):\n                             f = os.path.join(root, f)\n-                            self.choices.append((f, f.replace(path, \"\", 1)))\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n         else:\n             choices = []\n-            for f in os.scandir(self.path):\n+            for f in os.scandir(resolved_path):\n                 if f.name == '__pycache__':\n                     continue\n                 if (((self.allow_files and f.is_file()) or\n@@ -1116,6 +1150,19 @@ class FilePathField(ChoiceField):\n             choices.sort(key=operator.itemgetter(1))\n             self.choices.extend(choices)\n \n+        else:\n+            # Resolve path if it's callable\n+            resolved_path = self._resolve_path()\n+            choices = []\n+            for f in os.scandir(resolved_path):\n+                if f.name == '__pycache__':\n+                    continue\n+                if (((self.allow_files and f.is_file()) or\n+                        (self.allow_folders and f.is_dir())) and\n+                        (self.match is None or self.match_re.search(f.name))):\n+                    choices.append((f.path, f.name))\n+            choices.sort(key=operator.itemgetter(1))\n+            self.choices.extend(choices)\n         self.widget.choices = self.choices\n \n \n",
    "variant_3": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0c64748ccd..5dc089ad3b 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1707,6 +1707,7 @@ class FilePathField(Field):\n             return None\n         return str(value)\n \n+\n     def formfield(self, **kwargs):\n         return super().formfield(**{\n             'path': self.path,\ndiff --git a/django/forms/fields.py b/django/forms/fields.py\nindex a977256525..9b3bea7902 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -1076,6 +1076,7 @@ class MultiValueField(Field):\n \n \n class FilePathField(ChoiceField):\n+\n     def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n                  allow_folders=False, **kwargs):\n         self.path, self.match, self.recursive = path, match, recursive\n@@ -1090,23 +1091,72 @@ class FilePathField(ChoiceField):\n         if self.match is not None:\n             self.match_re = re.compile(self.match)\n \n+        # Build choices using resolved path\n+        resolved_path = self._resolve_path()\n+        \n         if recursive:\n-            for root, dirs, files in sorted(os.walk(self.path)):\n+            for root, dirs, files in sorted(os.walk(resolved_path)):\n                 if self.allow_files:\n                     for f in sorted(files):\n                         if self.match is None or self.match_re.search(f):\n                             f = os.path.join(root, f)\n-                            self.choices.append((f, f.replace(path, \"\", 1)))\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n                 if self.allow_folders:\n                     for f in sorted(dirs):\n                         if f == '__pycache__':\n                             continue\n                         if self.match is None or self.match_re.search(f):\n                             f = os.path.join(root, f)\n-                            self.choices.append((f, f.replace(path, \"\", 1)))\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n         else:\n+            with os.scandir(resolved_path) as entries:\n+                for f in sorted(entries, key=operator.attrgetter('name')):\n+                    if f.name == '__pycache__':\n+                        continue\n+                    if (((self.allow_files and f.is_file()) or\n+                         (self.allow_folders and f.is_dir())) and\n+                        (self.match is None or self.match_re.search(f.name))):\n+                        self.choices.append((f.path, f.name))\n+\n+    def _resolve_path(self):\n+        \"\"\"Resolve the path, handling both strings and callables.\"\"\"\n+        if callable(self.path):\n+            return self.path()\n+        return self.path\n+\n+        super().__init__(choices=(), **kwargs)\n+\n+        if self.required:\n+            self.choices = []\n+        else:\n+            self.choices = [(\"\", \"---------\")]\n+\n+        if self.match is not None:\n+            self.match_re = re.compile(self.match)\n+\n+        # Resolve path if it's callable\n+        resolved_path = self.path() if callable(self.path) else self.path\n+\n+        if recursive:\n+            for root, dirs, files in sorted(os.walk(resolved_path)):\n+                if self.allow_files:\n+                    for f in sorted(files):\n+                        if self.match is None or self.match_re.search(f):\n+                            f = os.path.join(root, f)\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n+                if self.allow_folders:\n+                    for f in sorted(dirs):\n+                        if f == '__pycache__':\n+                            continue\n+                        if self.match is None or self.match_re.search(f):\n+                            f = os.path.join(root, f)\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n+\n+        else:\n+            # Resolve path if it's a callable\n+            resolved_path = self._resolve_path()\n             choices = []\n-            for f in os.scandir(self.path):\n+            for f in os.scandir(resolved_path):\n                 if f.name == '__pycache__':\n                     continue\n                 if (((self.allow_files and f.is_file()) or\n@@ -1115,7 +1165,6 @@ class FilePathField(ChoiceField):\n                     choices.append((f.path, f.name))\n             choices.sort(key=operator.itemgetter(1))\n             self.choices.extend(choices)\n-\n         self.widget.choices = self.choices\n \n \n",
    "variant_4": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0c64748ccd..5dc089ad3b 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1707,6 +1707,7 @@ class FilePathField(Field):\n             return None\n         return str(value)\n \n+\n     def formfield(self, **kwargs):\n         return super().formfield(**{\n             'path': self.path,\ndiff --git a/django/forms/fields.py b/django/forms/fields.py\nindex a977256525..fb12f83b87 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -1076,9 +1076,41 @@ class MultiValueField(Field):\n \n \n class FilePathField(ChoiceField):\n-    def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n+\n+def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n+             allow_folders=False, **kwargs):\n+    self.path, self.match, self.recursive = path, match, recursive\n+    self.allow_files, self.allow_folders = allow_files, allow_folders\n+    super().__init__(choices=(), **kwargs)\n+\n+    # Defer choice building to allow callable path resolution\n+    self._choices_built = False\n+\n+def _get_path(self):\n+    \"\"\"Resolve path if it's a callable, otherwise return as-is.\"\"\"\n+    if callable(self.path):\n+        return self.path()\n+    return self.path\n+\n+def _build_choices(self):\n+    \"\"\"Build choices from the resolved path.\"\"\"\n+    if self._choices_built:\n+        return\n+    \n+    resolved_path = self._get_path()\n+    \n+    if self.required:\n+        self.choices = []\n+    else:\n+        self.choices = [(\"\", \"---------\")]\n+\n+    if self.match is not None:\n+        self.match_re = re.compile(self.match)\n+\n+    def __init__(self, path, match=None, recursive=False, allow_files=True,\n                  allow_folders=False, **kwargs):\n-        self.path, self.match, self.recursive = path, match, recursive\n+        self.path = path\n+        self.match, self.recursive = match, recursive\n         self.allow_files, self.allow_folders = allow_files, allow_folders\n         super().__init__(choices=(), **kwargs)\n \n@@ -1090,23 +1122,29 @@ class FilePathField(ChoiceField):\n         if self.match is not None:\n             self.match_re = re.compile(self.match)\n \n+        # Resolve path if it's a callable\n+        resolved_path = self.path() if callable(self.path) else self.path\n+\n         if recursive:\n-            for root, dirs, files in sorted(os.walk(self.path)):\n+            for root, dirs, files in sorted(os.walk(resolved_path)):\n                 if self.allow_files:\n                     for f in sorted(files):\n                         if self.match is None or self.match_re.search(f):\n                             f = os.path.join(root, f)\n-                            self.choices.append((f, f.replace(path, \"\", 1)))\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n                 if self.allow_folders:\n                     for f in sorted(dirs):\n                         if f == '__pycache__':\n                             continue\n                         if self.match is None or self.match_re.search(f):\n                             f = os.path.join(root, f)\n-                            self.choices.append((f, f.replace(path, \"\", 1)))\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n+\n         else:\n+            # Resolve path if it's callable\n+            resolved_path = self._resolve_path()\n             choices = []\n-            for f in os.scandir(self.path):\n+            for f in os.scandir(resolved_path):\n                 if f.name == '__pycache__':\n                     continue\n                 if (((self.allow_files and f.is_file()) or\n@@ -1115,7 +1153,6 @@ class FilePathField(ChoiceField):\n                     choices.append((f.path, f.name))\n             choices.sort(key=operator.itemgetter(1))\n             self.choices.extend(choices)\n-\n         self.widget.choices = self.choices\n \n \n",
    "variant_5": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0c64748ccd..5dc089ad3b 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1707,6 +1707,7 @@ class FilePathField(Field):\n             return None\n         return str(value)\n \n+\n     def formfield(self, **kwargs):\n         return super().formfield(**{\n             'path': self.path,\ndiff --git a/django/forms/fields.py b/django/forms/fields.py\nindex a977256525..2c15ed9388 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -1076,6 +1076,7 @@ class MultiValueField(Field):\n \n \n class FilePathField(ChoiceField):\n+\n     def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n                  allow_folders=False, **kwargs):\n         self.path, self.match, self.recursive = path, match, recursive\n@@ -1090,23 +1091,52 @@ class FilePathField(ChoiceField):\n         if self.match is not None:\n             self.match_re = re.compile(self.match)\n \n+        # Build choices using resolved path\n+        resolved_path = self._resolve_path()\n+        self._build_choices(resolved_path)\n+\n+    def _resolve_path(self):\n+        \"\"\"Resolve the path, handling both strings and callables.\"\"\"\n+        if callable(self.path):\n+            return self.path()\n+        return self.path\n+\n+    def _build_choices(self, resolved_path):\n+        \"\"\"Build choices using the resolved path.\"\"\"\n+\n+        super().__init__(choices=(), **kwargs)\n+\n+        if self.required:\n+            self.choices = []\n+        else:\n+            self.choices = [(\"\", \"---------\")]\n+\n+        if self.match is not None:\n+            self.match_re = re.compile(self.match)\n+\n+        # Resolve the path if it's callable\n+        resolved_path = self.path() if callable(self.path) else self.path\n+\n         if recursive:\n-            for root, dirs, files in sorted(os.walk(self.path)):\n+            for root, dirs, files in sorted(os.walk(resolved_path)):\n                 if self.allow_files:\n                     for f in sorted(files):\n                         if self.match is None or self.match_re.search(f):\n                             f = os.path.join(root, f)\n-                            self.choices.append((f, f.replace(path, \"\", 1)))\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n                 if self.allow_folders:\n                     for f in sorted(dirs):\n                         if f == '__pycache__':\n                             continue\n                         if self.match is None or self.match_re.search(f):\n                             f = os.path.join(root, f)\n-                            self.choices.append((f, f.replace(path, \"\", 1)))\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n+\n         else:\n+            # Resolve path if it's a callable\n+            resolved_path = self._get_resolved_path()\n             choices = []\n-            for f in os.scandir(self.path):\n+            for f in os.scandir(resolved_path):\n                 if f.name == '__pycache__':\n                     continue\n                 if (((self.allow_files and f.is_file()) or\n@@ -1115,7 +1145,6 @@ class FilePathField(ChoiceField):\n                     choices.append((f.path, f.name))\n             choices.sort(key=operator.itemgetter(1))\n             self.choices.extend(choices)\n-\n         self.widget.choices = self.choices\n \n \n",
    "variant_6": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0c64748ccd..5dc089ad3b 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1707,6 +1707,7 @@ class FilePathField(Field):\n             return None\n         return str(value)\n \n+\n     def formfield(self, **kwargs):\n         return super().formfield(**{\n             'path': self.path,\ndiff --git a/django/forms/fields.py b/django/forms/fields.py\nindex a977256525..bc40137e36 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -1076,10 +1076,34 @@ class MultiValueField(Field):\n \n \n class FilePathField(ChoiceField):\n-    def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n-                 allow_folders=False, **kwargs):\n-        self.path, self.match, self.recursive = path, match, recursive\n-        self.allow_files, self.allow_folders = allow_files, allow_folders\n+\n+def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n+             allow_folders=False, **kwargs):\n+    self.path, self.match, self.recursive = path, match, recursive\n+    self.allow_files, self.allow_folders = allow_files, allow_folders\n+    super().__init__(choices=(), **kwargs)\n+\n+    if self.required:\n+        self.choices = []\n+    else:\n+        self.choices = [(\"\", \"---------\")]\n+\n+    if self.match is not None:\n+        self.match_re = re.compile(self.match)\n+\n+    # Defer path resolution and choice building\n+    self._build_choices()\n+\n+def _resolve_path(self):\n+    \"\"\"Resolve the path, handling both string paths and callables.\"\"\"\n+    if callable(self.path):\n+        return self.path()\n+    return self.path\n+\n+def _build_choices(self):\n+    \"\"\"Build the choices list using the resolved path.\"\"\"\n+    resolved_path = self._resolve_path()\n+\n         super().__init__(choices=(), **kwargs)\n \n         if self.required:\n@@ -1090,23 +1114,29 @@ class FilePathField(ChoiceField):\n         if self.match is not None:\n             self.match_re = re.compile(self.match)\n \n+        # Resolve path if it's callable\n+        resolved_path = self.path() if callable(self.path) else self.path\n+\n         if recursive:\n-            for root, dirs, files in sorted(os.walk(self.path)):\n+            for root, dirs, files in sorted(os.walk(resolved_path)):\n                 if self.allow_files:\n                     for f in sorted(files):\n                         if self.match is None or self.match_re.search(f):\n                             f = os.path.join(root, f)\n-                            self.choices.append((f, f.replace(path, \"\", 1)))\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n                 if self.allow_folders:\n                     for f in sorted(dirs):\n                         if f == '__pycache__':\n                             continue\n                         if self.match is None or self.match_re.search(f):\n                             f = os.path.join(root, f)\n-                            self.choices.append((f, f.replace(path, \"\", 1)))\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n+\n         else:\n+            # Resolve callable path at runtime\n+            resolved_path = self._resolve_path()\n             choices = []\n-            for f in os.scandir(self.path):\n+            for f in os.scandir(resolved_path):\n                 if f.name == '__pycache__':\n                     continue\n                 if (((self.allow_files and f.is_file()) or\n@@ -1115,7 +1145,6 @@ class FilePathField(ChoiceField):\n                     choices.append((f.path, f.name))\n             choices.sort(key=operator.itemgetter(1))\n             self.choices.extend(choices)\n-\n         self.widget.choices = self.choices\n \n \n",
    "variant_7": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0c64748ccd..5dc089ad3b 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1707,6 +1707,7 @@ class FilePathField(Field):\n             return None\n         return str(value)\n \n+\n     def formfield(self, **kwargs):\n         return super().formfield(**{\n             'path': self.path,\ndiff --git a/django/forms/fields.py b/django/forms/fields.py\nindex a977256525..1eccf127de 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -1076,10 +1076,34 @@ class MultiValueField(Field):\n \n \n class FilePathField(ChoiceField):\n-    def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n-                 allow_folders=False, **kwargs):\n-        self.path, self.match, self.recursive = path, match, recursive\n-        self.allow_files, self.allow_folders = allow_files, allow_folders\n+\n+def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n+             allow_folders=False, **kwargs):\n+    self.path, self.match, self.recursive = path, match, recursive\n+    self.allow_files, self.allow_folders = allow_files, allow_folders\n+    super().__init__(choices=(), **kwargs)\n+\n+    if self.required:\n+        self.choices = []\n+    else:\n+        self.choices = [(\"\", \"---------\")]\n+\n+    if self.match is not None:\n+        self.match_re = re.compile(self.match)\n+\n+    # Defer choice building to allow callable path resolution\n+    self._build_choices()\n+\n+def _resolve_path(self):\n+    \"\"\"Resolve the path, handling both string paths and callables.\"\"\"\n+    if callable(self.path):\n+        return self.path()\n+    return self.path\n+\n+def _build_choices(self):\n+    \"\"\"Build the choices list using the resolved path.\"\"\"\n+    resolved_path = self._resolve_path()\n+\n         super().__init__(choices=(), **kwargs)\n \n         if self.required:\n@@ -1090,23 +1114,29 @@ class FilePathField(ChoiceField):\n         if self.match is not None:\n             self.match_re = re.compile(self.match)\n \n+        # Resolve path if it's callable\n+        resolved_path = self.path() if callable(self.path) else self.path\n+\n         if recursive:\n-            for root, dirs, files in sorted(os.walk(self.path)):\n+            for root, dirs, files in sorted(os.walk(resolved_path)):\n                 if self.allow_files:\n                     for f in sorted(files):\n                         if self.match is None or self.match_re.search(f):\n                             f = os.path.join(root, f)\n-                            self.choices.append((f, f.replace(path, \"\", 1)))\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n                 if self.allow_folders:\n                     for f in sorted(dirs):\n                         if f == '__pycache__':\n                             continue\n                         if self.match is None or self.match_re.search(f):\n                             f = os.path.join(root, f)\n-                            self.choices.append((f, f.replace(path, \"\", 1)))\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n+\n         else:\n+            # Resolve path if it's a callable\n+            resolved_path = self.path() if callable(self.path) else self.path\n             choices = []\n-            for f in os.scandir(self.path):\n+            for f in os.scandir(resolved_path):\n                 if f.name == '__pycache__':\n                     continue\n                 if (((self.allow_files and f.is_file()) or\n@@ -1115,7 +1145,6 @@ class FilePathField(ChoiceField):\n                     choices.append((f.path, f.name))\n             choices.sort(key=operator.itemgetter(1))\n             self.choices.extend(choices)\n-\n         self.widget.choices = self.choices\n \n \n",
    "variant_8": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0c64748ccd..5dc089ad3b 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1707,6 +1707,7 @@ class FilePathField(Field):\n             return None\n         return str(value)\n \n+\n     def formfield(self, **kwargs):\n         return super().formfield(**{\n             'path': self.path,\ndiff --git a/django/forms/fields.py b/django/forms/fields.py\nindex a977256525..43ad1c7b5e 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -1076,6 +1076,7 @@ class MultiValueField(Field):\n \n \n class FilePathField(ChoiceField):\n+\n     def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n                  allow_folders=False, **kwargs):\n         self.path, self.match, self.recursive = path, match, recursive\n@@ -1090,23 +1091,76 @@ class FilePathField(ChoiceField):\n         if self.match is not None:\n             self.match_re = re.compile(self.match)\n \n+        # Build choices using resolved path\n+        resolved_path = self._resolve_path()\n+        \n+        if recursive:\n+            for root, dirs, files in sorted(os.walk(resolved_path)):\n+                if self.allow_files:\n+                    for f in sorted(files):\n+                        if self.match is None or self.match_re.search(f):\n+                            f = os.path.join(root, f)\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n+                if self.allow_folders:\n+                    for f in sorted(dirs):\n+                        if f == '__pycache__':\n+                            continue\n+                        if self.match is None or self.match_re.search(f):\n+                            f = os.path.join(root, f)\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n+        else:\n+            with os.scandir(resolved_path) as entries:\n+                for f in sorted(entries, key=operator.attrgetter('name')):\n+                    if f.name == '__pycache__':\n+                        continue\n+                    if (((self.allow_files and f.is_file()) or\n+                         (self.allow_folders and f.is_dir())) and\n+                        (self.match is None or self.match_re.search(f.name))):\n+                        self.choices.append((f.path, f.name))\n+\n+    def _resolve_path(self):\n+        \"\"\"Resolve the path, calling it if it's a callable.\"\"\"\n+        if callable(self.path):\n+            return self.path()\n+        return self.path\n+\n+    def __init__(self, path, match=None, recursive=False, allow_files=True,\n+                 allow_folders=False, **kwargs):\n+        self.path = path\n+        self.match = match\n+        self.recursive = recursive\n+        self.allow_files = allow_files\n+        self.allow_folders = allow_folders\n+        super().__init__(choices=(), **kwargs)\n+\n+        if self.required:\n+            self.choices = []\n+        else:\n+            self.choices = [(\"\", \"---------\")]\n+\n+        if self.match is not None:\n+            self.match_re = re.compile(self.match)\n+\n+        # Resolve path if it's callable\n+        resolved_path = self.path() if callable(self.path) else self.path\n+\n         if recursive:\n-            for root, dirs, files in sorted(os.walk(self.path)):\n+            for root, dirs, files in sorted(os.walk(resolved_path)):\n                 if self.allow_files:\n                     for f in sorted(files):\n                         if self.match is None or self.match_re.search(f):\n                             f = os.path.join(root, f)\n-                            self.choices.append((f, f.replace(path, \"\", 1)))\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n                 if self.allow_folders:\n                     for f in sorted(dirs):\n                         if f == '__pycache__':\n                             continue\n                         if self.match is None or self.match_re.search(f):\n                             f = os.path.join(root, f)\n-                            self.choices.append((f, f.replace(path, \"\", 1)))\n+                            self.choices.append((f, f.replace(resolved_path, \"\", 1)))\n         else:\n             choices = []\n-            for f in os.scandir(self.path):\n+            for f in os.scandir(resolved_path):\n                 if f.name == '__pycache__':\n                     continue\n                 if (((self.allow_files and f.is_file()) or\n@@ -1116,6 +1170,19 @@ class FilePathField(ChoiceField):\n             choices.sort(key=operator.itemgetter(1))\n             self.choices.extend(choices)\n \n+        else:\n+            # Resolve path if it's a callable\n+            resolved_path = self._resolve_path()\n+            choices = []\n+            for f in os.scandir(resolved_path):\n+                if f.name == '__pycache__':\n+                    continue\n+                if (((self.allow_files and f.is_file()) or\n+                        (self.allow_folders and f.is_dir())) and\n+                        (self.match is None or self.match_re.search(f.name))):\n+                    choices.append((f.path, f.name))\n+            choices.sort(key=operator.itemgetter(1))\n+            self.choices.extend(choices)\n         self.widget.choices = self.choices\n \n \n"
  }
}