{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/django/django/db/models/fields/json.py lines 368-371)": "\nclass KeyTransformIsNull(lookups.IsNull):\n    # key__isnull=False is the same as has_key='key'\n    def as_oracle(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n        # For isnull=True, check that the key doesn't exist\n        lhs, lhs_params = self.lhs.lhs.as_sql(compiler, connection)\n        key_name = self.lhs.key_name\n        return 'NOT JSON_EXISTS(%s, %%s)' % lhs, tuple(lhs_params) + (key_name,)\n\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        # For isnull=True, check that the key doesn't exist\n        lhs, lhs_params = self.lhs.lhs.as_sql(compiler, connection)\n        key_name = self.lhs.key_name\n        return 'JSON_TYPE(%s, %%s) IS NULL' % lhs, tuple(lhs_params) + (key_name,)\n",
    "Location 2 (/root/hy/projects_2/django/django/db/models/fields/json.py lines 373-376)": "\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        # For isnull=True, check that the key doesn't exist (JSON_TYPE returns NULL)\n        lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n        json_path = compile_json_path([key_name], include_root=False)\n        return 'JSON_TYPE(%s, %s) IS NULL' % (lhs, json_path), lhs_params\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/django/django/db/models/fields/json.py lines 368-371)": [
      "\nclass KeyTransformIsNull(lookups.IsNull):\n    # key__isnull=False is the same as has_key='key'\n    def as_oracle(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n        # For isnull=True, check that the key doesn't exist\n        lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n        json_path = compile_json_path([key_name], include_root=False)\n        return 'NOT JSON_EXISTS(%s, %%s)' % lhs, tuple(lhs_params) + (json_path,)\n\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        # For isnull=True, check that the key doesn't exist\n        lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n        json_path = compile_json_path([key_name])\n        return 'JSON_TYPE(%s, %%s) IS NULL' % lhs, tuple(lhs_params) + (json_path,)\n",
      "\nclass KeyTransformIsNull(lookups.IsNull):\n    # key__isnull=False is the same as has_key='key'\n    def as_oracle(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n        # For isnull=True, check that the key doesn't exist\n        lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n        json_path = compile_json_path([key_name], include_root=False)\n        return 'NOT JSON_EXISTS(%s, %%s)' % lhs, lhs_params + [json_path]\n\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        # For isnull=True, check that the key doesn't exist\n        lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n        json_path = compile_json_path([key_name])\n        return 'JSON_TYPE(%s, %%s) IS NULL' % lhs, lhs_params + [json_path]\n",
      "\nclass KeyTransformIsNull(lookups.IsNull):\n    # key__isnull=False is the same as has_key='key'\n    def as_oracle(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n        # For isnull=True, check that the key doesn't exist\n        lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n        json_path = compile_json_path([key_name], include_root=False)\n        return 'NOT JSON_EXISTS(%s, %%s)' % lhs, lhs_params + [json_path]\n",
      "\nclass KeyTransformIsNull(lookups.IsNull):\n    # key__isnull=False is the same as has_key='key'\n    def as_oracle(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n        # For isnull=True, check that the key doesn't exist\n        lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n        json_path = compile_json_path([key_name], include_root=False)\n        return 'NOT JSON_EXISTS(%s, %%s)' % lhs, tuple(lhs_params) + (json_path,)\n\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        # For isnull=True, check that the key doesn't exist\n        lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n        json_path = compile_json_path([key_name])\n        return 'JSON_TYPE(%s, %%s) IS NULL' % lhs, tuple(lhs_params) + (json_path,)\n",
      "\nclass KeyTransformIsNull(lookups.IsNull):\n    # key__isnull=False is the same as has_key='key'\n    def as_oracle(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n        # When isnull=True, check for key non-existence\n        sql, params = self.lhs.lhs.as_sql(compiler, connection)\n        key_name = self.lhs.key_name\n        return f'NOT JSON_EXISTS({sql}, %s)', params + [key_name]\n\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        # When isnull=True, check for key non-existence\n        sql, params = self.lhs.lhs.as_sql(compiler, connection)\n        key_name = self.lhs.key_name\n        return f'JSON_TYPE({sql}, %s) IS NULL', params + [key_name]\n",
      "\nclass KeyTransformIsNull(lookups.IsNull):\n    # key__isnull=False is the same as has_key='key'\n    def as_oracle(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n        # For isnull=True, check that the key doesn't exist\n        lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n        json_path = compile_json_path([key_name])\n        return 'NOT JSON_EXISTS(%s, %%s)' % lhs, tuple(lhs_params) + (json_path,)\n\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        # For isnull=True, check that the key doesn't exist\n        lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n        json_path = compile_json_path([key_name], include_root=False)\n        return 'JSON_TYPE(%s, %%s) IS NULL' % lhs, tuple(lhs_params) + (json_path,)\n",
      "\nclass KeyTransformIsNull(lookups.IsNull):\n    # key__isnull=False is the same as has_key='key'\n    def as_oracle(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n        # For isnull=True, check that the key doesn't exist\n        lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n        json_path = compile_json_path([key_name], include_root=False)\n        return 'NOT JSON_EXISTS(%s, %%s)' % lhs, lhs_params + [json_path]\n\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        # For isnull=True, check that the key doesn't exist\n        lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n        json_path = compile_json_path([key_name])\n        return 'JSON_TYPE(%s, %%s) IS NULL' % lhs, lhs_params + [json_path]\n",
      "\nclass KeyTransformIsNull(lookups.IsNull):\n    # key__isnull=False is the same as has_key='key'\n    def as_oracle(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n        # For isnull=True, check that the key doesn't exist\n        lhs, lhs_params = self.process_lhs(compiler, connection)\n        rhs, rhs_params = self.process_rhs(compiler, connection)\n        return \"NOT JSON_EXISTS(%s, '%s')\" % (lhs, rhs), lhs_params + rhs_params\n\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        # For isnull=True, check that the key doesn't exist\n        lhs, lhs_params = self.process_lhs(compiler, connection)\n        rhs, rhs_params = self.process_rhs(compiler, connection)\n        return \"JSON_TYPE(%s, %s) IS NULL\" % (lhs, rhs), lhs_params + rhs_params\n"
    ],
    "Location 2 (/root/hy/projects_2/django/django/db/models/fields/json.py lines 373-376)": [
      "\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        # For isnull=True, check that the key doesn't exist (JSON_TYPE returns NULL for non-existent keys)\n        lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n        json_path = compile_json_path([key_name], include_root=False)\n        return 'JSON_TYPE(%s, %%s) IS NULL' % lhs, lhs_params + [json_path]\n",
      "\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        # For isnull=True, check that the key doesn't exist (JSON_TYPE returns NULL)\n        lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n        json_path = compile_json_path([key_name], include_root=False)\n        return 'JSON_TYPE(%s, %%s) IS NULL' % lhs, lhs_params + [json_path]\n",
      "\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        # For isnull=True, check if key doesn't exist (JSON_TYPE returns NULL for non-existent keys)\n        lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n        json_path = compile_json_path([key_name], include_root=False)\n        return 'JSON_TYPE(%s, %%s) IS NULL' % lhs, lhs_params + [json_path]\n",
      "\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        # For isnull=True, check for key non-existence using JSON_TYPE IS NULL\n        lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n        json_path = compile_json_path([key_name], include_root=False)\n        return 'JSON_TYPE(%s, %%s) IS NULL' % lhs, lhs_params + [json_path]\n",
      "\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        # For isnull=True, check that the key doesn't exist (JSON_TYPE returns NULL)\n        lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n        json_path = compile_json_path([key_name])\n        return 'JSON_TYPE(%s, %%s) IS NULL' % lhs, lhs_params + [json_path]\n",
      "\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        # For isnull=True, check that the key doesn't exist (JSON_TYPE IS NULL)\n        lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n        json_path = compile_json_path([key_name])\n        return 'JSON_TYPE(%s, %%s) IS NULL' % lhs, lhs_params + [json_path]\n",
      "\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        # For isnull=True, check that the key doesn't exist (JSON_TYPE returns NULL for non-existent keys)\n        lhs, lhs_params = self.process_lhs(compiler, connection)\n        key_name = self.lhs.key_name\n        path = compile_json_path([key_name])\n        return 'JSON_TYPE(%s, %%s) IS NULL' % lhs, lhs_params + [path]\n",
      "\n    def as_sqlite(self, compiler, connection):\n        if not self.rhs:\n            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n        # For isnull=True, check that the key doesn't exist (JSON_TYPE returns NULL)\n        lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n        json_path = compile_json_path([key_name], include_root=False)\n        return 'JSON_TYPE(%s, %s) IS NULL' % (lhs, '%s'), lhs_params + [json_path]\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex 29c6ff0926..2ec089a5d7 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -365,15 +365,23 @@ class CaseInsensitiveMixin:\n \n class KeyTransformIsNull(lookups.IsNull):\n     # key__isnull=False is the same as has_key='key'\n+\n     def as_oracle(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        # For isnull=True, check that the key does not exist\n+        has_key_lookup = HasKey(self.lhs.lhs, self.lhs.key_name)\n+        sql, params = has_key_lookup.as_sql(compiler, connection, template=\"JSON_EXISTS(%s, '%%s')\")\n+        # Negate the existence check and add paths directly into SQL\n+        return 'NOT (%s)' % (sql % tuple(params)), []\n+\n \n     def as_sqlite(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        # For isnull=True, check that the key does not exist\n+        has_key_lookup = HasKey(self.lhs.lhs, self.lhs.key_name)\n+        return has_key_lookup.as_sql(compiler, connection, template='JSON_TYPE(%s, %%s) IS NULL')\n \n \n class KeyTransformIn(lookups.In):\n",
    "variant_0": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex 29c6ff0926..826b4a4bf6 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -363,17 +363,35 @@ class CaseInsensitiveMixin:\n         return rhs, rhs_params\n \n \n+class KeyTransformIsNull(lookups.IsNull):\n+    # key__isnull=False is the same as has_key='key'\n+\n class KeyTransformIsNull(lookups.IsNull):\n     # key__isnull=False is the same as has_key='key'\n     def as_oracle(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        # For isnull=True, check that the key doesn't exist\n+        lhs, lhs_params = self.lhs.lhs.as_sql(compiler, connection)\n+        key_name = self.lhs.key_name\n+        return 'NOT JSON_EXISTS(%s, %%s)' % lhs, tuple(lhs_params) + (key_name,)\n \n     def as_sqlite(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        # For isnull=True, check that the key doesn't exist\n+        lhs, lhs_params = self.lhs.lhs.as_sql(compiler, connection)\n+        key_name = self.lhs.key_name\n+        return 'JSON_TYPE(%s, %%s) IS NULL' % lhs, tuple(lhs_params) + (key_name,)\n+\n+\n+    def as_sqlite(self, compiler, connection):\n+        if not self.rhs:\n+            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n+        # For isnull=True, check that the key doesn't exist (JSON_TYPE returns NULL)\n+        lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n+        json_path = compile_json_path([key_name], include_root=False)\n+        return 'JSON_TYPE(%s, %s) IS NULL' % (lhs, json_path), lhs_params\n \n \n class KeyTransformIn(lookups.In):\n",
    "variant_1": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex 29c6ff0926..70b3808492 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -363,17 +363,35 @@ class CaseInsensitiveMixin:\n         return rhs, rhs_params\n \n \n+class KeyTransformIsNull(lookups.IsNull):\n+    # key__isnull=False is the same as has_key='key'\n+\n class KeyTransformIsNull(lookups.IsNull):\n     # key__isnull=False is the same as has_key='key'\n     def as_oracle(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        # For isnull=True, check that the key doesn't exist\n+        lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n+        json_path = compile_json_path([key_name], include_root=False)\n+        return 'NOT JSON_EXISTS(%s, %%s)' % lhs, tuple(lhs_params) + (json_path,)\n \n     def as_sqlite(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        # For isnull=True, check that the key doesn't exist\n+        lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n+        json_path = compile_json_path([key_name])\n+        return 'JSON_TYPE(%s, %%s) IS NULL' % lhs, tuple(lhs_params) + (json_path,)\n+\n+\n+    def as_sqlite(self, compiler, connection):\n+        if not self.rhs:\n+            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n+        # For isnull=True, check that the key doesn't exist (JSON_TYPE returns NULL for non-existent keys)\n+        lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n+        json_path = compile_json_path([key_name], include_root=False)\n+        return 'JSON_TYPE(%s, %%s) IS NULL' % lhs, lhs_params + [json_path]\n \n \n class KeyTransformIn(lookups.In):\n",
    "variant_2": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex 29c6ff0926..0c47fae6d7 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -363,17 +363,35 @@ class CaseInsensitiveMixin:\n         return rhs, rhs_params\n \n \n+class KeyTransformIsNull(lookups.IsNull):\n+    # key__isnull=False is the same as has_key='key'\n+\n class KeyTransformIsNull(lookups.IsNull):\n     # key__isnull=False is the same as has_key='key'\n     def as_oracle(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        # For isnull=True, check that the key doesn't exist\n+        lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n+        json_path = compile_json_path([key_name], include_root=False)\n+        return 'NOT JSON_EXISTS(%s, %%s)' % lhs, lhs_params + [json_path]\n \n     def as_sqlite(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        # For isnull=True, check that the key doesn't exist\n+        lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n+        json_path = compile_json_path([key_name])\n+        return 'JSON_TYPE(%s, %%s) IS NULL' % lhs, lhs_params + [json_path]\n+\n+\n+    def as_sqlite(self, compiler, connection):\n+        if not self.rhs:\n+            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n+        # For isnull=True, check that the key doesn't exist (JSON_TYPE returns NULL)\n+        lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n+        json_path = compile_json_path([key_name], include_root=False)\n+        return 'JSON_TYPE(%s, %%s) IS NULL' % lhs, lhs_params + [json_path]\n \n \n class KeyTransformIn(lookups.In):\n",
    "variant_3": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex 29c6ff0926..dc548d5ff8 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -363,17 +363,27 @@ class CaseInsensitiveMixin:\n         return rhs, rhs_params\n \n \n+class KeyTransformIsNull(lookups.IsNull):\n+    # key__isnull=False is the same as has_key='key'\n+\n class KeyTransformIsNull(lookups.IsNull):\n     # key__isnull=False is the same as has_key='key'\n     def as_oracle(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        # For isnull=True, check that the key doesn't exist\n+        lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n+        json_path = compile_json_path([key_name], include_root=False)\n+        return 'NOT JSON_EXISTS(%s, %%s)' % lhs, lhs_params + [json_path]\n+\n \n     def as_sqlite(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        # For isnull=True, check if key doesn't exist (JSON_TYPE returns NULL for non-existent keys)\n+        lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n+        json_path = compile_json_path([key_name], include_root=False)\n+        return 'JSON_TYPE(%s, %%s) IS NULL' % lhs, lhs_params + [json_path]\n \n \n class KeyTransformIn(lookups.In):\n",
    "variant_4": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex 29c6ff0926..e02a38eb53 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -363,17 +363,35 @@ class CaseInsensitiveMixin:\n         return rhs, rhs_params\n \n \n+class KeyTransformIsNull(lookups.IsNull):\n+    # key__isnull=False is the same as has_key='key'\n+\n class KeyTransformIsNull(lookups.IsNull):\n     # key__isnull=False is the same as has_key='key'\n     def as_oracle(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        # For isnull=True, check that the key doesn't exist\n+        lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n+        json_path = compile_json_path([key_name], include_root=False)\n+        return 'NOT JSON_EXISTS(%s, %%s)' % lhs, tuple(lhs_params) + (json_path,)\n \n     def as_sqlite(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        # For isnull=True, check that the key doesn't exist\n+        lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n+        json_path = compile_json_path([key_name])\n+        return 'JSON_TYPE(%s, %%s) IS NULL' % lhs, tuple(lhs_params) + (json_path,)\n+\n+\n+    def as_sqlite(self, compiler, connection):\n+        if not self.rhs:\n+            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n+        # For isnull=True, check for key non-existence using JSON_TYPE IS NULL\n+        lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n+        json_path = compile_json_path([key_name], include_root=False)\n+        return 'JSON_TYPE(%s, %%s) IS NULL' % lhs, lhs_params + [json_path]\n \n \n class KeyTransformIn(lookups.In):\n",
    "variant_5": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex 29c6ff0926..270b65b535 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -363,17 +363,35 @@ class CaseInsensitiveMixin:\n         return rhs, rhs_params\n \n \n+class KeyTransformIsNull(lookups.IsNull):\n+    # key__isnull=False is the same as has_key='key'\n+\n class KeyTransformIsNull(lookups.IsNull):\n     # key__isnull=False is the same as has_key='key'\n     def as_oracle(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        # When isnull=True, check for key non-existence\n+        sql, params = self.lhs.lhs.as_sql(compiler, connection)\n+        key_name = self.lhs.key_name\n+        return f'NOT JSON_EXISTS({sql}, %s)', params + [key_name]\n \n     def as_sqlite(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        # When isnull=True, check for key non-existence\n+        sql, params = self.lhs.lhs.as_sql(compiler, connection)\n+        key_name = self.lhs.key_name\n+        return f'JSON_TYPE({sql}, %s) IS NULL', params + [key_name]\n+\n+\n+    def as_sqlite(self, compiler, connection):\n+        if not self.rhs:\n+            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n+        # For isnull=True, check that the key doesn't exist (JSON_TYPE returns NULL)\n+        lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n+        json_path = compile_json_path([key_name])\n+        return 'JSON_TYPE(%s, %%s) IS NULL' % lhs, lhs_params + [json_path]\n \n \n class KeyTransformIn(lookups.In):\n",
    "variant_6": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex 29c6ff0926..b45e0b7c21 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -363,17 +363,35 @@ class CaseInsensitiveMixin:\n         return rhs, rhs_params\n \n \n+class KeyTransformIsNull(lookups.IsNull):\n+    # key__isnull=False is the same as has_key='key'\n+\n class KeyTransformIsNull(lookups.IsNull):\n     # key__isnull=False is the same as has_key='key'\n     def as_oracle(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        # For isnull=True, check that the key doesn't exist\n+        lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n+        json_path = compile_json_path([key_name])\n+        return 'NOT JSON_EXISTS(%s, %%s)' % lhs, tuple(lhs_params) + (json_path,)\n \n     def as_sqlite(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        # For isnull=True, check that the key doesn't exist\n+        lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n+        json_path = compile_json_path([key_name], include_root=False)\n+        return 'JSON_TYPE(%s, %%s) IS NULL' % lhs, tuple(lhs_params) + (json_path,)\n+\n+\n+    def as_sqlite(self, compiler, connection):\n+        if not self.rhs:\n+            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n+        # For isnull=True, check that the key doesn't exist (JSON_TYPE IS NULL)\n+        lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n+        json_path = compile_json_path([key_name])\n+        return 'JSON_TYPE(%s, %%s) IS NULL' % lhs, lhs_params + [json_path]\n \n \n class KeyTransformIn(lookups.In):\n",
    "variant_7": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex 29c6ff0926..1de5abb410 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -363,17 +363,36 @@ class CaseInsensitiveMixin:\n         return rhs, rhs_params\n \n \n+class KeyTransformIsNull(lookups.IsNull):\n+    # key__isnull=False is the same as has_key='key'\n+\n class KeyTransformIsNull(lookups.IsNull):\n     # key__isnull=False is the same as has_key='key'\n     def as_oracle(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        # For isnull=True, check that the key doesn't exist\n+        lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n+        json_path = compile_json_path([key_name], include_root=False)\n+        return 'NOT JSON_EXISTS(%s, %%s)' % lhs, lhs_params + [json_path]\n \n     def as_sqlite(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        # For isnull=True, check that the key doesn't exist\n+        lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n+        json_path = compile_json_path([key_name])\n+        return 'JSON_TYPE(%s, %%s) IS NULL' % lhs, lhs_params + [json_path]\n+\n+\n+    def as_sqlite(self, compiler, connection):\n+        if not self.rhs:\n+            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n+        # For isnull=True, check that the key doesn't exist (JSON_TYPE returns NULL for non-existent keys)\n+        lhs, lhs_params = self.process_lhs(compiler, connection)\n+        key_name = self.lhs.key_name\n+        path = compile_json_path([key_name])\n+        return 'JSON_TYPE(%s, %%s) IS NULL' % lhs, lhs_params + [path]\n \n \n class KeyTransformIn(lookups.In):\n",
    "variant_8": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex 29c6ff0926..f5aed9d1b7 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -363,17 +363,35 @@ class CaseInsensitiveMixin:\n         return rhs, rhs_params\n \n \n+class KeyTransformIsNull(lookups.IsNull):\n+    # key__isnull=False is the same as has_key='key'\n+\n class KeyTransformIsNull(lookups.IsNull):\n     # key__isnull=False is the same as has_key='key'\n     def as_oracle(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        # For isnull=True, check that the key doesn't exist\n+        lhs, lhs_params = self.process_lhs(compiler, connection)\n+        rhs, rhs_params = self.process_rhs(compiler, connection)\n+        return \"NOT JSON_EXISTS(%s, '%s')\" % (lhs, rhs), lhs_params + rhs_params\n \n     def as_sqlite(self, compiler, connection):\n         if not self.rhs:\n             return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n-        return super().as_sql(compiler, connection)\n+        # For isnull=True, check that the key doesn't exist\n+        lhs, lhs_params = self.process_lhs(compiler, connection)\n+        rhs, rhs_params = self.process_rhs(compiler, connection)\n+        return \"JSON_TYPE(%s, %s) IS NULL\" % (lhs, rhs), lhs_params + rhs_params\n+\n+\n+    def as_sqlite(self, compiler, connection):\n+        if not self.rhs:\n+            return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n+        # For isnull=True, check that the key doesn't exist (JSON_TYPE returns NULL)\n+        lhs, lhs_params, key_name = self.lhs.preprocess_lhs(compiler, connection)\n+        json_path = compile_json_path([key_name], include_root=False)\n+        return 'JSON_TYPE(%s, %s) IS NULL' % (lhs, '%s'), lhs_params + [json_path]\n \n \n class KeyTransformIn(lookups.In):\n"
  }
}