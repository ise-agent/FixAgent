{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/sympy/sympy/polys/partfrac.py lines 120-126)": "\n    if P.is_multivariate:\n        # Check if the expression is univariate in the target variable x\n        # even though it contains other symbolic parameters\n        if x is not None and x in P.free_symbols:\n            # Expression has symbolic parameters but may still be decomposable in x\n            # Check if P and Q are polynomials in x with symbolic coefficients\n            try:\n                # Try to treat as univariate in x with symbolic coefficients\n                P_univar = P.as_poly(x)\n                Q_univar = Q.as_poly(x)\n                if P_univar is not None and Q_univar is not None:\n                    # Continue with univariate decomposition\n                    P, Q = P_univar, Q_univar\n                else:\n                    raise PolynomialError(\"Cannot convert to univariate\")\n            except (PolynomialError, AttributeError):\n                fc = f.cancel()\n                if fc != f:\n                    return apart(fc, x=x, full=full, **_options)\n                raise NotImplementedError(\n                    \"multivariate partial fraction decomposition\")\n        else:\n            fc = f.cancel()\n            if fc != f:\n                return apart(fc, x=x, full=full, **_options)\n            raise NotImplementedError(\n                \"multivariate partial fraction decomposition\")\n",
    "Location 2 (/root/hy/projects_2/sympy/sympy/polys/partfrac.py lines 78-79)": "\n        P, Q = f.as_numer_denom()\n",
    "Location 3 (/root/hy/projects_2/sympy/sympy/polys/partfrac.py lines 128-131)": "\n    if P.is_multivariate:\n        # Check if the expression is univariate in the target variable x\n        # even though it contains other symbolic parameters\n        if x is not None and x in P.free_symbols:\n            # Check if P and Q are actually univariate polynomials in x\n            # (they may contain symbolic parameters but still be decomposable)\n            try:\n                # Try to treat as univariate in x, allowing symbolic parameters\n                P_vars = P.free_symbols\n                Q_vars = Q.free_symbols\n                if len(P_vars & {x}) == 1 and len(Q_vars & {x}) == 1:\n                    # Both P and Q contain x and can be treated as univariate in x\n                    pass  # Continue to univariate decomposition\n                else:\n                    raise PolynomialError(\"Not univariate in target variable\")\n            except:\n                fc = f.cancel()\n                if fc != f:\n                    return apart(fc, x=x, full=full, **_options)\n                raise NotImplementedError(\n                    \"multivariate partial fraction decomposition\")\n        else:\n            fc = f.cancel()\n            if fc != f:\n                return apart(fc, x=x, full=full, **_options)\n            raise NotImplementedError(\n                \"multivariate partial fraction decomposition\")\n",
    "Location 4 (/root/hy/projects_2/sympy/sympy/polys/partfrac.py lines 133-149)": "\nif P.is_multivariate:\n    # Check if the expression is univariate in the target variable x\n    # even though it contains other symbolic parameters\n    if x is not None:\n        # Get the variables involved in P and Q\n        P_vars = P.free_symbols\n        Q_vars = Q.free_symbols\n        \n        # If x is the only polynomial variable and others are just parameters\n        if x in P_vars and x in Q_vars:\n            # Check if P and Q are actually polynomials in x\n            try:\n                # Try to treat as univariate in x with symbolic coefficients\n                P_uni = P.as_poly(x)\n                Q_uni = Q.as_poly(x)\n                if P_uni is not None and Q_uni is not None:\n                    # Update P and Q to be univariate polynomials in x\n                    P, Q = P_uni, Q_uni\n                else:\n                    # Fall back to cancellation approach\n                    fc = f.cancel()\n                    if fc != f:\n                        return apart(fc, x=x, full=full, **_options)\n                    raise NotImplementedError(\n                        \"multivariate partial fraction decomposition\")\n            except:\n                # Fall back to cancellation approach\n                fc = f.cancel()\n                if fc != f:\n                    return apart(fc, x=x, full=full, **_options)\n                raise NotImplementedError(\n                    \"multivariate partial fraction decomposition\")\n        else:\n            fc = f.cancel()\n            if fc != f:\n                return apart(fc, x=x, full=full, **_options)\n            raise NotImplementedError(\n                \"multivariate partial fraction decomposition\")\n    else:\n        fc = f.cancel()\n        if fc != f:\n            return apart(fc, x=x, full=full, **_options)\n        raise NotImplementedError(\n            \"multivariate partial fraction decomposition\")\n",
    "Location 5 (/root/hy/projects_2/sympy/sympy/polys/partfrac.py lines 152-188)": "\ndef apart_undetermined_coeffs(P, Q):\n    \"\"\"Partial fractions via method of undetermined coefficients. \"\"\"\n    X = numbered_symbols(cls=Dummy)\n    partial, symbols = [], []\n\n    _, factors = Q.factor_list()\n\n    for f, k in factors:\n        n, q = f.degree(), Q\n\n        for i in range(1, k + 1):\n            coeffs, q = take(X, n), q.quo(f)\n            partial.append((coeffs, q, f, i))\n            symbols.extend(coeffs)\n\n    # Handle symbolic parameters in domain\n    extra_symbols = Q.free_symbols - {Q.gen}\n    if P.free_symbols:\n        extra_symbols.update(P.free_symbols - {Q.gen})\n    \n    dom = Q.get_domain()\n    if symbols:\n        dom = dom.inject(*symbols)\n    if extra_symbols:\n        dom = dom.inject(*extra_symbols)\n    \n    F = Poly(0, Q.gen, domain=dom)\n\n    for i, (coeffs, q, f, k) in enumerate(partial):\n        h = Poly(coeffs, Q.gen, domain=dom)\n        partial[i] = (h, f, k)\n        q = q.set_domain(dom)\n        F += h*q\n\n    system, result = [], S(0)\n\n    for (k,), coeff in F.terms():\n        system.append(coeff - P.nth(k))\n\n    from sympy.solvers import solve\n    solution = solve(system, symbols)\n\n    for h, f, k in partial:\n        h = h.as_expr().subs(solution)\n        result += h/f.as_expr()**k\n\n    return result\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/sympy/sympy/polys/partfrac.py lines 120-126)": [
      "\nif P.is_multivariate:\n    # Check if the expression is univariate in the target variable x\n    # even though it contains other symbolic parameters\n    if x is not None and x in P.free_symbols:\n        # Get the polynomial in terms of x only\n        try:\n            # Try to treat as univariate in x with symbolic coefficients\n            P_uni = Poly(P.as_expr(), x, domain='ZZ[%s]' % ','.join(str(s) for s in P.free_symbols - {x}))\n            Q_uni = Poly(Q.as_expr(), x, domain='ZZ[%s]' % ','.join(str(s) for s in Q.free_symbols - {x}))\n            # Replace P and Q with univariate versions and continue\n            P, Q = P_uni, Q_uni\n        except PolynomialError:\n            # Fall back to original multivariate handling\n            fc = f.cancel()\n            if fc != f:\n                return apart(fc, x=x, full=full, **_options)\n            raise NotImplementedError(\n                \"multivariate partial fraction decomposition\")\n    else:\n        fc = f.cancel()\n        if fc != f:\n            return apart(fc, x=x, full=full, **_options)\n        raise NotImplementedError(\n            \"multivariate partial fraction decomposition\")\n",
      "\n    if P.is_multivariate:\n        # Check if the expression is univariate in the target variable x\n        # even though it contains other symbolic parameters\n        if x is not None and x in P.free_symbols:\n            # Expression has symbolic parameters but may still be decomposable in x\n            # Try to proceed with univariate decomposition logic\n            pass  # Continue to univariate partial fraction decomposition\n        else:\n            fc = f.cancel()\n            if fc != f:\n                return apart(fc, x=x, full=full, **_options)\n            raise NotImplementedError(\n                \"multivariate partial fraction decomposition\")\n",
      "\n    if P.is_multivariate:\n        # Check if the expression is univariate in the target variable x\n        # even though it contains other symbolic parameters\n        if x is not None and x in P.free_symbols and P.degree(x) > 0:\n            # Expression has symbolic parameters but is still univariate in x\n            # Continue with univariate partial fraction decomposition\n            pass\n        else:\n            fc = f.cancel()\n            if fc != f:\n                return apart(fc, x=x, full=full, **_options)\n            raise NotImplementedError(\n                \"multivariate partial fraction decomposition\")\n",
      "\n    if P.is_multivariate:\n        # Check if the expression is univariate in the target variable x\n        # even though it contains other symbolic parameters\n        if x is not None and x in P.free_symbols:\n            # Expression has symbolic parameters but may still be decomposable in x\n            # Check if P and Q are rational in x (univariate polynomials in x with symbolic coeffs)\n            try:\n                # Try to treat as univariate in x with symbolic coefficients\n                P_univar = P.as_poly(x)\n                Q_univar = Q.as_poly(x)\n                if P_univar is not None and Q_univar is not None:\n                    # Proceed with univariate partial fraction decomposition\n                    pass\n                else:\n                    raise PolynomialError(\"Not univariate in target variable\")\n            except (PolynomialError, TypeError):\n                fc = f.cancel()\n                if fc != f:\n                    return apart(fc, x=x, full=full, **_options)\n                raise NotImplementedError(\n                    \"multivariate partial fraction decomposition\")\n        else:\n            fc = f.cancel()\n            if fc != f:\n                return apart(fc, x=x, full=full, **_options)\n            raise NotImplementedError(\n                \"multivariate partial fraction decomposition\")\n",
      "\nif P.is_multivariate:\n    # Check if the expression is univariate in the target variable x\n    # even though it contains other symbolic parameters\n    if x is not None and x in P.free_symbols:\n        # Get all variables except the target variable x\n        other_vars = P.free_symbols - {x}\n        # If P only depends on x and symbolic parameters (not other polynomial variables),\n        # we can still perform partial fraction decomposition\n        if other_vars and all(not P.has(var) or var.is_symbol for var in other_vars):\n            # Continue with univariate decomposition logic\n            pass\n        else:\n            fc = f.cancel()\n            if fc != f:\n                return apart(fc, x=x, full=full, **_options)\n            raise NotImplementedError(\n                \"multivariate partial fraction decomposition\")\n    else:\n        fc = f.cancel()\n        if fc != f:\n            return apart(fc, x=x, full=full, **_options)\n        raise NotImplementedError(\n            \"multivariate partial fraction decomposition\")\n",
      "\nif P.is_multivariate:\n    # Check if the expression is univariate in the target variable x\n    # even though it contains other symbolic parameters\n    if x is not None and x in P.free_symbols:\n        # Get the polynomial in terms of x only\n        try:\n            # Try to treat as univariate in x with symbolic coefficients\n            P_univar = P.as_poly(x)\n            Q_univar = Q.as_poly(x)\n            if P_univar is not None and Q_univar is not None:\n                # Continue with univariate partial fraction decomposition\n                pass\n            else:\n                raise PolynomialError(\"Cannot convert to univariate polynomial\")\n        except (PolynomialError, AttributeError):\n            fc = f.cancel()\n            if fc != f:\n                return apart(fc, x=x, full=full, **_options)\n            raise NotImplementedError(\n                \"multivariate partial fraction decomposition\")\n    else:\n        fc = f.cancel()\n        if fc != f:\n            return apart(fc, x=x, full=full, **_options)\n        raise NotImplementedError(\n            \"multivariate partial fraction decomposition\")\n",
      "\nif P.is_multivariate:\n    # Check if the expression is univariate in the target variable x\n    # even though it contains other symbolic parameters\n    if x is not None and x in P.free_symbols:\n        # Get variables other than x\n        other_vars = P.free_symbols - {x}\n        # If P is polynomial in x with symbolic coefficients, proceed with decomposition\n        try:\n            # Test if we can treat this as univariate in x\n            P_in_x = P.as_poly(x)\n            Q_in_x = Q.as_poly(x)\n            # If successful, continue with univariate logic\n        except (PolynomialError, TypeError):\n            # Fall back to cancellation approach\n            fc = f.cancel()\n            if fc != f:\n                return apart(fc, x=x, full=full, **_options)\n            raise NotImplementedError(\n                \"multivariate partial fraction decomposition\")\n    else:\n        fc = f.cancel()\n        if fc != f:\n            return apart(fc, x=x, full=full, **_options)\n        raise NotImplementedError(\n            \"multivariate partial fraction decomposition\")\n",
      "\n    if P.is_multivariate:\n        # Check if the expression is univariate in the target variable x\n        # even though it contains other symbolic parameters\n        if x is not None and x in P.free_symbols:\n            # Expression has symbolic parameters but may still be decomposable in x\n            # Check if P and Q are polynomial in x when other symbols are treated as parameters\n            try:\n                # Try to treat other symbols as parameters and proceed with decomposition\n                pass  # Continue to univariate decomposition logic\n            except:\n                fc = f.cancel()\n                if fc != f:\n                    return apart(fc, x=x, full=full, **_options)\n                raise NotImplementedError(\n                    \"multivariate partial fraction decomposition\")\n        else:\n            fc = f.cancel()\n            if fc != f:\n                return apart(fc, x=x, full=full, **_options)\n            raise NotImplementedError(\n                \"multivariate partial fraction decomposition\")\n"
    ],
    "Location 2 (/root/hy/projects_2/sympy/sympy/polys/partfrac.py lines 78-79)": [
      "\n        P, Q = f.as_numer_denom()\n",
      "\n        P, Q = f.as_numer_denom()\n",
      "\n    if f.is_Atom:\n        return f\n    else:\n        P, Q = f.as_numer_denom()\n        \n        # Check if expression is truly multivariate or just has symbolic parameters\n        if x is not None and P.is_polynomial() and Q.is_polynomial():\n            # Get variables that appear with non-zero degree\n            P_vars = getattr(P, 'free_symbols', set())\n            Q_vars = getattr(Q, 'free_symbols', set())\n            poly_vars = P_vars | Q_vars\n            \n            # If x is the only variable with polynomial degree > 0, treat as univariate\n            if x in poly_vars:\n                try:\n                    from sympy import degree\n                    # Check if other variables appear only as coefficients\n                    other_vars = poly_vars - {x}\n                    is_univariate_in_x = True\n                    \n                    # Simple heuristic: if we can extract x-dependent terms, proceed\n                    if other_vars and hasattr(P, 'as_poly') and hasattr(Q, 'as_poly'):\n                        try:\n                            P.as_poly(x)\n                            Q.as_poly(x)\n                            # If successful, treat as univariate in x with symbolic coefficients\n                        except:\n                            is_univariate_in_x = False\n                    \n                    if not is_univariate_in_x and len(poly_vars) > 1:\n                        # Truly multivariate case\n                        fc = f.cancel()\n                        if fc != f:\n                            return apart(fc, x=x, full=full, **_options)\n                        raise NotImplementedError(\n                            \"multivariate partial fraction decomposition\")\n                except:\n                    # Fall back to original logic if analysis fails\n                    pass\n",
      "\n        P, Q = f.as_numer_denom()\n",
      "\n        P, Q = f.as_numer_denom()\n\n        # Check if the expression is univariate in the target variable x\n        # even though it may contain symbolic parameters\n        if P.is_multivariate and x is not None:\n            # If P has variables other than x, check if it's still decomposable in x\n            p_vars = P.free_symbols if hasattr(P, 'free_symbols') else set()\n            q_vars = Q.free_symbols if hasattr(Q, 'free_symbols') else set()\n            all_vars = p_vars | q_vars\n            \n            # If the only \"extra\" variables are symbolic parameters (not the target variable),\n            # we can still proceed with partial fraction decomposition\n            if x in all_vars and len(all_vars - {x}) > 0:\n                # Continue with decomposition - this is univariate in x with parameters\n                pass\n            else:\n                # Truly multivariate case\n                fc = f.cancel()\n                if fc != f:\n                    return apart(fc, x=x, full=full, **_options)\n                raise NotImplementedError(\n                    \"multivariate partial fraction decomposition\")\n        elif P.is_multivariate:\n            fc = f.cancel()\n            if fc != f:\n                return apart(fc, x=x, full=full, **_options)\n            raise NotImplementedError(\n                \"multivariate partial fraction decomposition\")\n",
      "\n    if P.is_multivariate:\n        # Check if the expression is univariate in the target variable x\n        # even though it contains other symbolic parameters\n        if x is not None and x in P.free_symbols:\n            # Expression has symbolic parameters but may still be decomposable in x\n            # Check if P and Q are actually univariate polynomials in x\n            try:\n                P_univar = P.as_poly(x)\n                Q_univar = Q.as_poly(x)\n                if P_univar is not None and Q_univar is not None:\n                    # Proceed with univariate partial fraction decomposition\n                    pass\n                else:\n                    raise NotImplementedError\n            except:\n                fc = f.cancel()\n                if fc != f:\n                    return apart(fc, x=x, full=full, **_options)\n                raise NotImplementedError(\n                    \"multivariate partial fraction decomposition\")\n        else:\n            fc = f.cancel()\n            if fc != f:\n                return apart(fc, x=x, full=full, **_options)\n            raise NotImplementedError(\n                \"multivariate partial fraction decomposition\")\n",
      "\n        P, Q = f.as_numer_denom()\n",
      "\n    if P.is_multivariate:\n        # Check if the expression is univariate in the target variable x\n        # even though it contains other symbolic parameters\n        if x is not None and len(P.gens) == 1 and P.gen == x:\n            # Expression is univariate in x, proceed with decomposition\n            pass\n        else:\n            fc = f.cancel()\n            if fc != f:\n                return apart(fc, x=x, full=full, **_options)\n\n            raise NotImplementedError(\n                \"multivariate partial fraction decomposition\")\n"
    ],
    "Location 3 (/root/hy/projects_2/sympy/sympy/polys/partfrac.py lines 128-131)": [
      "\n    if P.is_multivariate:\n        # Check if the expression is univariate in the target variable x\n        # even though it contains other symbolic parameters\n        if x is not None and x in P.free_symbols:\n            # Get all variables except the target variable x\n            other_vars = P.free_symbols - {x}\n            # If P and Q are polynomials in x with symbolic coefficients,\n            # we can still do partial fraction decomposition\n            try:\n                # Check if P and Q can be treated as univariate in x\n                P_uni = P.as_poly(x)\n                Q_uni = Q.as_poly(x)\n                if P_uni is not None and Q_uni is not None:\n                    # Continue with univariate partial fraction decomposition\n                    pass\n                else:\n                    raise PolynomialError(\"Cannot convert to univariate\")\n            except PolynomialError:\n                fc = f.cancel()\n                if fc != f:\n                    return apart(fc, x=x, full=full, **_options)\n                raise NotImplementedError(\n                    \"multivariate partial fraction decomposition\")\n        else:\n            fc = f.cancel()\n            if fc != f:\n                return apart(fc, x=x, full=full, **_options)\n            raise NotImplementedError(\n                \"multivariate partial fraction decomposition\")\n",
      "\n    if P.is_multivariate:\n        # Check if the expression is univariate in the target variable x\n        # even though it contains other symbolic parameters\n        if x is not None and x in P.free_symbols:\n            # Expression may be univariate in x despite having symbolic parameters\n            # Check if we can treat it as a univariate rational function in x\n            try:\n                # Try to get the degree in x to verify it's a polynomial in x\n                P.degree(x)\n                Q.degree(x)\n                # If we get here, P and Q are polynomials in x, proceed with decomposition\n            except (PolynomialError, TypeError):\n                # Fall back to cancellation approach\n                fc = f.cancel()\n                if fc != f:\n                    return apart(fc, x=x, full=full, **_options)\n                raise NotImplementedError(\n                    \"multivariate partial fraction decomposition\")\n        else:\n            fc = f.cancel()\n            if fc != f:\n                return apart(fc, x=x, full=full, **_options)\n            raise NotImplementedError(\n                \"multivariate partial fraction decomposition\")\n",
      "\n    if P.is_multivariate:\n        # Check if the expression is univariate in the target variable x\n        # even though it contains other symbolic parameters\n        if x is not None and x in P.free_symbols:\n            # Extract variables other than x\n            other_vars = P.free_symbols - {x}\n            # If P is polynomial in x but has symbolic parameters, proceed with decomposition\n            if other_vars and all(P.degree(var) == 0 for var in other_vars if var != x):\n                pass  # Continue to univariate decomposition logic\n            else:\n                fc = f.cancel()\n                if fc != f:\n                    return apart(fc, x=x, full=full, **_options)\n                raise NotImplementedError(\n                    \"multivariate partial fraction decomposition\")\n        else:\n            fc = f.cancel()\n            if fc != f:\n                return apart(fc, x=x, full=full, **_options)\n            raise NotImplementedError(\n                \"multivariate partial fraction decomposition\")\n",
      "\n    if P.is_multivariate:\n        # Check if the expression is univariate in the target variable x\n        # even though it contains other symbolic parameters\n        if x is not None and x in P.free_symbols:\n            # Get variables other than x\n            other_vars = P.free_symbols - {x}\n            # If P and Q are polynomials in x with symbolic coefficients,\n            # we can still perform partial fraction decomposition\n            try:\n                # Try to treat as univariate in x with symbolic coefficients\n                pass  # Continue to cancellation logic below\n            except:\n                fc = f.cancel()\n                if fc != f:\n                    return apart(fc, x=x, full=full, **_options)\n                raise NotImplementedError(\n                    \"multivariate partial fraction decomposition\")\n        else:\n            fc = f.cancel()\n            if fc != f:\n                return apart(fc, x=x, full=full, **_options)\n            raise NotImplementedError(\n                \"multivariate partial fraction decomposition\")\n\n    common, P, Q = P.cancel(Q)\n\n    poly, P = P.div(Q, auto=True)\n    P, Q = P.rat_clear_denoms(Q)\n",
      "\n    if P.is_multivariate:\n        # Check if the expression is univariate in the target variable x\n        # even though it contains other symbolic parameters\n        if x is not None and x in P.free_symbols:\n            # Check if P and Q are polynomials in x with symbolic coefficients\n            try:\n                # Try to treat as univariate in x with symbolic coefficients\n                P_x = P.as_poly(x)\n                Q_x = Q.as_poly(x)\n                if P_x is not None and Q_x is not None:\n                    # Continue with univariate decomposition\n                    pass\n                else:\n                    raise PolynomialError(\"Not polynomial in target variable\")\n            except PolynomialError:\n                fc = f.cancel()\n                if fc != f:\n                    return apart(fc, x=x, full=full, **_options)\n                raise NotImplementedError(\n                    \"multivariate partial fraction decomposition\")\n        else:\n            fc = f.cancel()\n            if fc != f:\n                return apart(fc, x=x, full=full, **_options)\n            raise NotImplementedError(\n                \"multivariate partial fraction decomposition\")\n",
      "\n    if P.is_multivariate:\n        # Check if the expression is univariate in the target variable x\n        # even though it contains other symbolic parameters\n        if x is not None and x in P.free_symbols:\n            # Get all variables except the target variable x\n            other_vars = P.free_symbols - {x}\n            # If other variables are just symbolic parameters (not in denominator degree),\n            # we can still do partial fraction decomposition in x\n            if other_vars and all(Q.degree(var) == 0 for var in other_vars if var != x):\n                # Continue with univariate decomposition logic\n                pass\n            else:\n                fc = f.cancel()\n                if fc != f:\n                    return apart(fc, x=x, full=full, **_options)\n                raise NotImplementedError(\n                    \"multivariate partial fraction decomposition\")\n        else:\n            fc = f.cancel()\n            if fc != f:\n                return apart(fc, x=x, full=full, **_options)\n            raise NotImplementedError(\n                \"multivariate partial fraction decomposition\")\n",
      "\n    if P.is_multivariate:\n        # Check if the expression is univariate in the target variable x\n        # even though it contains other symbolic parameters\n        if x is not None and x in P.free_symbols and Q.free_symbols - {x}:\n            # Expression has symbolic parameters but is still univariate in x\n            # Continue with univariate decomposition logic\n            pass\n        else:\n            fc = f.cancel()\n            if fc != f:\n                return apart(fc, x=x, full=full, **_options)\n            raise NotImplementedError(\n                \"multivariate partial fraction decomposition\")\n",
      "\n    if P.is_multivariate:\n        # Check if the expression is univariate in the target variable x\n        # even though it contains other symbolic parameters\n        if x is not None and x in P.free_symbols:\n            # Check if P and Q are actually polynomials in x with symbolic coefficients\n            try:\n                # Try to treat as univariate in x with symbolic parameters\n                P_vars = P.free_symbols\n                Q_vars = Q.free_symbols\n                if P_vars <= Q_vars.union({x}) and x in Q_vars:\n                    # P and Q only contain x and possibly symbolic parameters\n                    # Continue with univariate partial fraction decomposition\n                    pass\n                else:\n                    raise PolynomialError(\"truly multivariate\")\n            except:\n                fc = f.cancel()\n                if fc != f:\n                    return apart(fc, x=x, full=full, **_options)\n                raise NotImplementedError(\n                    \"multivariate partial fraction decomposition\")\n        else:\n            fc = f.cancel()\n            if fc != f:\n                return apart(fc, x=x, full=full, **_options)\n            raise NotImplementedError(\n                \"multivariate partial fraction decomposition\")\n"
    ],
    "Location 4 (/root/hy/projects_2/sympy/sympy/polys/partfrac.py lines 133-149)": [
      "\nif P.is_multivariate:\n    # Check if the expression is univariate in the target variable x\n    # even though it contains other symbolic parameters\n    if x is not None:\n        # Get all variables except the target variable x\n        other_vars = P.free_symbols - {x}\n        # If P and Q only involve x and symbolic parameters (not other variables),\n        # we can still perform partial fraction decomposition in x\n        if other_vars and all(not var.is_symbol or var in f.free_symbols for var in other_vars):\n            # Continue with univariate decomposition logic\n            pass\n        else:\n            fc = f.cancel()\n            if fc != f:\n                return apart(fc, x=x, full=full, **_options)\n            raise NotImplementedError(\n                \"multivariate partial fraction decomposition\")\n    else:\n        fc = f.cancel()\n        if fc != f:\n            return apart(fc, x=x, full=full, **_options)\n        raise NotImplementedError(\n            \"multivariate partial fraction decomposition\")\n",
      "\n    if P.is_multivariate:\n        # Check if the expression is univariate in the target variable x\n        # even though it contains other symbolic parameters\n        if x is not None:\n            # Get variables other than x\n            other_vars = P.free_symbols - {x}\n            # If there are symbolic parameters but the expression is still\n            # a rational function in x, we can proceed with decomposition\n            if other_vars and all(var not in Q.free_symbols or \n                                Q.degree(var) == 0 for var in other_vars):\n                # Expression has symbolic parameters but is univariate in x\n                pass  # Continue to line 128\n            else:\n                fc = f.cancel()\n                if fc != f:\n                    return apart(fc, x=x, full=full, **_options)\n                raise NotImplementedError(\n                    \"multivariate partial fraction decomposition\")\n        else:\n            fc = f.cancel()\n            if fc != f:\n                return apart(fc, x=x, full=full, **_options)\n            raise NotImplementedError(\n                \"multivariate partial fraction decomposition\")\n",
      "\n    if P.is_multivariate:\n        # Check if the expression is univariate in the target variable x\n        # even though it contains other symbolic parameters\n        if x is not None:\n            # Get all variables except the target variable x\n            other_vars = P.free_symbols - {x}\n            # If there are symbolic parameters but the expression is still\n            # a rational function in x, we can proceed with decomposition\n            if other_vars and all(not P.has_free(var) for var in other_vars if P.degree(var) > 0):\n                # Expression has symbolic parameters but is polynomial in x\n                pass  # Continue to univariate decomposition\n            else:\n                fc = f.cancel()\n                if fc != f:\n                    return apart(fc, x=x, full=full, **_options)\n                raise NotImplementedError(\n                    \"multivariate partial fraction decomposition\")\n        else:\n            fc = f.cancel()\n            if fc != f:\n                return apart(fc, x=x, full=full, **_options)\n            raise NotImplementedError(\n                \"multivariate partial fraction decomposition\")\n",
      "\n    if P.is_multivariate:\n        # Check if the expression is univariate in the target variable x\n        # even though it contains other symbolic parameters\n        if x is not None:\n            # Get all variables in P except the target variable x\n            other_vars = P.free_symbols - {x}\n            # If P is rational in x (even with symbolic parameters), proceed\n            if other_vars and all(var not in P.gens for var in other_vars):\n                # Expression has symbolic parameters but is still rational in x\n                pass  # Continue with univariate decomposition\n            else:\n                fc = f.cancel()\n                if fc != f:\n                    return apart(fc, x=x, full=full, **_options)\n                raise NotImplementedError(\n                    \"multivariate partial fraction decomposition\")\n        else:\n            fc = f.cancel()\n            if fc != f:\n                return apart(fc, x=x, full=full, **_options)\n            raise NotImplementedError(\n                \"multivariate partial fraction decomposition\")\n",
      "\nif P.is_multivariate:\n    # Check if the expression is univariate in the target variable x\n    # even though it contains other symbolic parameters\n    if x is not None:\n        # Get the variables that are not the target variable\n        other_vars = P.free_symbols - {x}\n        # If there are other variables, check if they are just parameters\n        # (i.e., the expression is still a rational function in x)\n        if other_vars:\n            # Try to treat other variables as parameters and proceed\n            # with univariate partial fraction decomposition in x\n            pass  # Continue to the univariate logic below\n        else:\n            fc = f.cancel()\n            if fc != f:\n                return apart(fc, x=x, full=full, **_options)\n            raise NotImplementedError(\n                \"multivariate partial fraction decomposition\")\n    else:\n        fc = f.cancel()\n        if fc != f:\n            return apart(fc, x=x, full=full, **_options)\n        raise NotImplementedError(\n            \"multivariate partial fraction decomposition\")\n",
      "\n    if P.is_multivariate:\n        # Check if the expression is univariate in the target variable x\n        # even though it contains other symbolic parameters\n        if x is not None:\n            # Get all variables in the polynomials\n            P_vars = P.free_symbols\n            Q_vars = Q.free_symbols\n            all_vars = P_vars | Q_vars\n            \n            # If x is the only polynomial variable (others are just parameters)\n            if all_vars - {x}:  # Has symbolic parameters\n                # Check if P and Q are actually univariate polynomials in x\n                try:\n                    # Try to treat as univariate in x with symbolic coefficients\n                    P_uni = P.as_poly(x)\n                    Q_uni = Q.as_poly(x)\n                    if P_uni is not None and Q_uni is not None:\n                        # Update P and Q to be univariate polynomials in x\n                        P, Q = P_uni, Q_uni\n                    else:\n                        # Fall back to cancellation approach\n                        fc = f.cancel()\n                        if fc != f:\n                            return apart(fc, x=x, full=full, **_options)\n                        raise NotImplementedError(\n                            \"multivariate partial fraction decomposition\")\n                except PolynomialError:\n                    # Fall back to cancellation approach\n                    fc = f.cancel()\n                    if fc != f:\n                        return apart(fc, x=x, full=full, **_options)\n                    raise NotImplementedError(\n                        \"multivariate partial fraction decomposition\")\n            else:\n                fc = f.cancel()\n                if fc != f:\n                    return apart(fc, x=x, full=full, **_options)\n                raise NotImplementedError(\n                    \"multivariate partial fraction decomposition\")\n        else:\n            fc = f.cancel()\n            if fc != f:\n                return apart(fc, x=x, full=full, **_options)\n            raise NotImplementedError(\n                \"multivariate partial fraction decomposition\")\n",
      "\nif P.is_multivariate:\n    # Check if the expression is univariate in the target variable x\n    # even though it contains other symbolic parameters\n    if x is not None:\n        # Get variables other than x\n        other_vars = P.free_symbols - {x}\n        # If P is polynomial in x but has symbolic parameters, proceed\n        if other_vars and all(P.degree(var) == 0 for var in other_vars if var in P.gens):\n            pass  # Continue to univariate decomposition\n        else:\n            fc = f.cancel()\n            if fc != f:\n                return apart(fc, x=x, full=full, **_options)\n            raise NotImplementedError(\n                \"multivariate partial fraction decomposition\")\n    else:\n        fc = f.cancel()\n        if fc != f:\n            return apart(fc, x=x, full=full, **_options)\n        raise NotImplementedError(\n            \"multivariate partial fraction decomposition\")\n",
      "\n    if P.is_multivariate:\n        # Check if the expression is univariate in the target variable x\n        # even though it contains other symbolic parameters\n        if x is not None:\n            # Get all variables except the target variable x\n            other_vars = P.free_symbols - {x}\n            # If there are symbolic parameters but the expression is still\n            # a rational function in x, we can proceed with decomposition\n            if other_vars and all(not P.has_free(var) or var in P.coeffs() for var in other_vars):\n                # Expression has symbolic parameters but is univariate in x\n                pass  # Continue to univariate decomposition logic\n            else:\n                fc = f.cancel()\n                if fc != f:\n                    return apart(fc, x=x, full=full, **_options)\n                raise NotImplementedError(\n                    \"multivariate partial fraction decomposition\")\n        else:\n            fc = f.cancel()\n            if fc != f:\n                return apart(fc, x=x, full=full, **_options)\n            raise NotImplementedError(\n                \"multivariate partial fraction decomposition\")\n"
    ],
    "Location 5 (/root/hy/projects_2/sympy/sympy/polys/partfrac.py lines 152-188)": [
      "\ndef apart_undetermined_coeffs(P, Q):\n    \"\"\"Partial fractions via method of undetermined coefficients. \"\"\"\n    X = numbered_symbols(cls=Dummy)\n    partial, symbols = [], []\n\n    _, factors = Q.factor_list()\n\n    for f, k in factors:\n        n, q = f.degree(), Q\n\n        for i in range(1, k + 1):\n            coeffs, q = take(X, n), q.quo(f)\n            partial.append((coeffs, q, f, i))\n            symbols.extend(coeffs)\n\n    # Handle symbolic parameters in the domain\n    extra_symbols = Q.free_symbols - {Q.gen}\n    if P.free_symbols:\n        extra_symbols = extra_symbols.union(P.free_symbols - {Q.gen})\n    \n    dom = Q.get_domain()\n    if symbols:\n        dom = dom.inject(*symbols)\n    if extra_symbols:\n        dom = dom.inject(*extra_symbols)\n    \n    F = Poly(0, Q.gen, domain=dom)\n\n    for i, (coeffs, q, f, k) in enumerate(partial):\n        h = Poly(coeffs, Q.gen, domain=dom)\n        partial[i] = (h, f, k)\n        q = q.set_domain(dom)\n        F += h*q\n\n    system, result = [], S(0)\n\n    for (k,), coeff in F.terms():\n        system.append(coeff - P.nth(k))\n\n    from sympy.solvers import solve\n    solution = solve(system, symbols)\n\n    for h, f, k in partial:\n        h = h.as_expr().subs(solution)\n        result += h/f.as_expr()**k\n\n    return result\n",
      "\ndef apart_undetermined_coeffs(P, Q):\n    \"\"\"Partial fractions via method of undetermined coefficients. \"\"\"\n    X = numbered_symbols(cls=Dummy)\n    partial, symbols = [], []\n\n    _, factors = Q.factor_list()\n\n    for f, k in factors:\n        n, q = f.degree(), Q\n\n        for i in range(1, k + 1):\n            coeffs, q = take(X, n), q.quo(f)\n            partial.append((coeffs, q, f, i))\n            symbols.extend(coeffs)\n\n    # Handle symbolic parameters by extending domain\n    extra_symbols = Q.free_symbols - {Q.gen}\n    if P.free_symbols:\n        extra_symbols.update(P.free_symbols - {Q.gen})\n    \n    dom = Q.get_domain()\n    if extra_symbols:\n        dom = dom.inject(*extra_symbols)\n    if symbols:\n        dom = dom.inject(*symbols)\n    \n    F = Poly(0, Q.gen, domain=dom)\n\n    for i, (coeffs, q, f, k) in enumerate(partial):\n        h = Poly(coeffs, Q.gen, domain=dom)\n        partial[i] = (h, f, k)\n        q = q.set_domain(dom)\n        F += h*q\n\n    system, result = [], S(0)\n\n    for (k,), coeff in F.terms():\n        system.append(coeff - P.nth(k))\n\n    from sympy.solvers import solve\n    solution = solve(system, symbols)\n\n    for h, f, k in partial:\n        h = h.as_expr().subs(solution)\n        result += h/f.as_expr()**k\n\n    return result\n",
      "\ndef apart_undetermined_coeffs(P, Q):\n    \"\"\"Partial fractions via method of undetermined coefficients. \"\"\"\n    X = numbered_symbols(cls=Dummy)\n    partial, symbols = [], []\n\n    _, factors = Q.factor_list()\n\n    for f, k in factors:\n        n, q = f.degree(), Q\n\n        for i in range(1, k + 1):\n            coeffs, q = take(X, n), q.quo(f)\n            partial.append((coeffs, q, f, i))\n            symbols.extend(coeffs)\n\n    # Handle symbolic parameters in the domain\n    extra_symbols = Q.free_symbols - {Q.gen}\n    if P.free_symbols:\n        extra_symbols = extra_symbols.union(P.free_symbols - {Q.gen})\n    \n    dom = Q.get_domain()\n    if symbols:\n        dom = dom.inject(*symbols)\n    if extra_symbols:\n        dom = dom.inject(*extra_symbols)\n    \n    F = Poly(0, Q.gen, domain=dom)\n\n    for i, (coeffs, q, f, k) in enumerate(partial):\n        h = Poly(coeffs, Q.gen, domain=dom)\n        partial[i] = (h, f, k)\n        q = q.set_domain(dom)\n        F += h*q\n\n    system, result = [], S(0)\n\n    for (k,), coeff in F.terms():\n        system.append(coeff - P.nth(k))\n\n    from sympy.solvers import solve\n    solution = solve(system, symbols)\n\n    for h, f, k in partial:\n        h = h.as_expr().subs(solution)\n        result += h/f.as_expr()**k\n\n    return result\n",
      "\ndef apart_undetermined_coeffs(P, Q):\n    \"\"\"Partial fractions via method of undetermined coefficients. \"\"\"\n    X = numbered_symbols(cls=Dummy)\n    partial, symbols = [], []\n\n    _, factors = Q.factor_list()\n\n    for f, k in factors:\n        n, q = f.degree(), Q\n\n        for i in range(1, k + 1):\n            coeffs, q = take(X, n), q.quo(f)\n            partial.append((coeffs, q, f, i))\n            symbols.extend(coeffs)\n\n    # Handle symbolic parameters in the domain\n    extra_symbols = set()\n    if hasattr(P, 'free_symbols'):\n        extra_symbols.update(P.free_symbols - {Q.gen})\n    if hasattr(Q, 'free_symbols'):\n        extra_symbols.update(Q.free_symbols - {Q.gen})\n    \n    dom = Q.get_domain().inject(*symbols)\n    if extra_symbols:\n        dom = dom.inject(*extra_symbols)\n    \n    F = Poly(0, Q.gen, domain=dom)\n\n    for i, (coeffs, q, f, k) in enumerate(partial):\n        h = Poly(coeffs, Q.gen, domain=dom)\n        partial[i] = (h, f, k)\n        q = q.set_domain(dom)\n        F += h*q\n\n    system, result = [], S(0)\n\n    for (k,), coeff in F.terms():\n        system.append(coeff - P.nth(k))\n\n    from sympy.solvers import solve\n    solution = solve(system, symbols)\n\n    for h, f, k in partial:\n        h = h.as_expr().subs(solution)\n        result += h/f.as_expr()**k\n\n    return result\n",
      "\ndef apart_undetermined_coeffs(P, Q):\n    \"\"\"Partial fractions via method of undetermined coefficients. \"\"\"\n    X = numbered_symbols(cls=Dummy)\n    partial, symbols = [], []\n\n    _, factors = Q.factor_list()\n\n    for f, k in factors:\n        n, q = f.degree(), Q\n\n        for i in range(1, k + 1):\n            coeffs, q = take(X, n), q.quo(f)\n            partial.append((coeffs, q, f, i))\n            symbols.extend(coeffs)\n\n    # Handle symbolic parameters in domain\n    extra_symbols = Q.free_symbols - {Q.gen}\n    if P.free_symbols:\n        extra_symbols = extra_symbols.union(P.free_symbols - {Q.gen})\n    \n    dom = Q.get_domain()\n    if symbols:\n        dom = dom.inject(*symbols)\n    if extra_symbols:\n        dom = dom.inject(*extra_symbols)\n    \n    F = Poly(0, Q.gen, domain=dom)\n\n    for i, (coeffs, q, f, k) in enumerate(partial):\n        h = Poly(coeffs, Q.gen, domain=dom)\n        partial[i] = (h, f, k)\n        q = q.set_domain(dom)\n        F += h*q\n\n    system, result = [], S(0)\n\n    for (k,), coeff in F.terms():\n        system.append(coeff - P.nth(k))\n\n    from sympy.solvers import solve\n    solution = solve(system, symbols)\n\n    for h, f, k in partial:\n        h = h.as_expr().subs(solution)\n        result += h/f.as_expr()**k\n\n    return result\n",
      "\ndef apart_undetermined_coeffs(P, Q):\n    \"\"\"Partial fractions via method of undetermined coefficients. \"\"\"\n    X = numbered_symbols(cls=Dummy)\n    partial, symbols = [], []\n\n    _, factors = Q.factor_list()\n\n    for f, k in factors:\n        n, q = f.degree(), Q\n\n        for i in range(1, k + 1):\n            coeffs, q = take(X, n), q.quo(f)\n            partial.append((coeffs, q, f, i))\n            symbols.extend(coeffs)\n\n    # Include symbolic parameters in domain\n    extra_symbols = Q.free_symbols - {Q.gen}\n    if P.free_symbols:\n        extra_symbols.update(P.free_symbols - {Q.gen})\n    \n    dom = Q.get_domain().inject(*symbols)\n    if extra_symbols:\n        dom = dom.inject(*extra_symbols)\n    \n    F = Poly(0, Q.gen, domain=dom)\n\n    for i, (coeffs, q, f, k) in enumerate(partial):\n        h = Poly(coeffs, Q.gen, domain=dom)\n        partial[i] = (h, f, k)\n        q = q.set_domain(dom)\n        F += h*q\n\n    system, result = [], S(0)\n\n    for (k,), coeff in F.terms():\n        system.append(coeff - P.nth(k))\n\n    from sympy.solvers import solve\n    solution = solve(system, symbols)\n\n    for h, f, k in partial:\n        h = h.as_expr().subs(solution)\n        result += h/f.as_expr()**k\n\n    return result\n",
      "\ndef apart_undetermined_coeffs(P, Q):\n    \"\"\"Partial fractions via method of undetermined coefficients. \"\"\"\n    X = numbered_symbols(cls=Dummy)\n    partial, symbols = [], []\n\n    _, factors = Q.factor_list()\n\n    for f, k in factors:\n        n, q = f.degree(), Q\n\n        for i in range(1, k + 1):\n            coeffs, q = take(X, n), q.quo(f)\n            partial.append((coeffs, q, f, i))\n            symbols.extend(coeffs)\n\n    # Handle symbolic parameters in domain\n    extra_symbols = Q.free_symbols - {Q.gen}\n    if P.free_symbols:\n        extra_symbols = extra_symbols.union(P.free_symbols - {Q.gen})\n    \n    dom = Q.get_domain()\n    if symbols:\n        dom = dom.inject(*symbols)\n    if extra_symbols:\n        dom = dom.inject(*extra_symbols)\n    \n    F = Poly(0, Q.gen, domain=dom)\n\n    for i, (coeffs, q, f, k) in enumerate(partial):\n        h = Poly(coeffs, Q.gen, domain=dom)\n        partial[i] = (h, f, k)\n        q = q.set_domain(dom)\n        F += h*q\n\n    system, result = [], S(0)\n\n    for (k,), coeff in F.terms():\n        system.append(coeff - P.nth(k))\n\n    from sympy.solvers import solve\n    solution = solve(system, symbols)\n\n    for h, f, k in partial:\n        h = h.as_expr().subs(solution)\n        result += h/f.as_expr()**k\n\n    return result\n",
      "\ndef apart_undetermined_coeffs(P, Q):\n    \"\"\"Partial fractions via method of undetermined coefficients. \"\"\"\n    X = numbered_symbols(cls=Dummy)\n    partial, symbols = [], []\n\n    _, factors = Q.factor_list()\n\n    for f, k in factors:\n        n, q = f.degree(), Q\n\n        for i in range(1, k + 1):\n            coeffs, q = take(X, n), q.quo(f)\n            partial.append((coeffs, q, f, i))\n            symbols.extend(coeffs)\n\n    # Handle symbolic parameters in the domain\n    extra_symbols = (P.free_symbols | Q.free_symbols) - {Q.gen}\n    dom = Q.get_domain()\n    if extra_symbols:\n        dom = dom.inject(*extra_symbols)\n    dom = dom.inject(*symbols)\n    \n    F = Poly(0, Q.gen, domain=dom)\n\n    for i, (coeffs, q, f, k) in enumerate(partial):\n        h = Poly(coeffs, Q.gen, domain=dom)\n        partial[i] = (h, f, k)\n        q = q.set_domain(dom)\n        F += h*q\n\n    system, result = [], S(0)\n\n    for (k,), coeff in F.terms():\n        system.append(coeff - P.nth(k))\n\n    from sympy.solvers import solve\n    solution = solve(system, symbols)\n\n    for h, f, k in partial:\n        h = h.as_expr().subs(solution)\n        result += h/f.as_expr()**k\n\n    return result\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sympy/polys/partfrac.py b/sympy/polys/partfrac.py\nindex 612b8f4607..d265a414ea 100644\n--- a/sympy/polys/partfrac.py\n+++ b/sympy/polys/partfrac.py\n@@ -75,8 +75,8 @@ def apart(f, x=None, full=False, **options):\n     if f.is_Atom:\n         return f\n     else:\n-        P, Q = f.as_numer_denom()\n \n+        P, Q = f.as_numer_denom()\n     _options = options.copy()\n     options = set_defaults(options, extension=True)\n     try:\n@@ -117,19 +117,42 @@ def apart(f, x=None, full=False, **options):\n                     pass\n             return f.xreplace(dict(reps))\n \n+\n     if P.is_multivariate:\n-        fc = f.cancel()\n-        if fc != f:\n-            return apart(fc, x=x, full=full, **_options)\n+        # Check if the expression is univariate in the target variable x\n+        # even though it contains other symbolic parameters\n+        if x is not None and x in P.free_symbols:\n+            # Check if P is actually a polynomial in x with symbolic coefficients\n+            # If so, we can still proceed with univariate decomposition\n+            try:\n+                # Try to treat as univariate in x\n+                P_test = P.as_poly(x)\n+                if P_test is not None:\n+                    # Expression is polynomial in x, proceed with univariate logic\n+                    pass\n+                else:\n+                    raise PolynomialError(\"Not univariate in target variable\")\n+            except (PolynomialError, AttributeError):\n+                # Fall back to original multivariate handling\n+                fc = f.cancel()\n+                if fc != f:\n+                    return apart(fc, x=x, full=full, **_options)\n+                raise NotImplementedError(\n+                    \"multivariate partial fraction decomposition\")\n+        else:\n+            fc = f.cancel()\n+            if fc != f:\n+                return apart(fc, x=x, full=full, **_options)\n+            raise NotImplementedError(\n+                \"multivariate partial fraction decomposition\")\n \n-        raise NotImplementedError(\n-            \"multivariate partial fraction decomposition\")\n \n     common, P, Q = P.cancel(Q)\n \n     poly, P = P.div(Q, auto=True)\n     P, Q = P.rat_clear_denoms(Q)\n \n+\n     if Q.degree() <= 1:\n         partial = P/Q\n     else:\n@@ -149,6 +172,7 @@ def apart(f, x=None, full=False, **options):\n     return common*(poly.as_expr() + terms)\n \n \n+\n def apart_undetermined_coeffs(P, Q):\n     \"\"\"Partial fractions via method of undetermined coefficients. \"\"\"\n     X = numbered_symbols(cls=Dummy)\n@@ -165,6 +189,17 @@ def apart_undetermined_coeffs(P, Q):\n             symbols.extend(coeffs)\n \n     dom = Q.get_domain().inject(*symbols)\n+    \n+    # Ensure symbolic parameters are properly handled in domain\n+    if hasattr(P, 'free_symbols') and hasattr(Q, 'gen'):\n+        extra_symbols = P.free_symbols - {Q.gen}\n+        if extra_symbols:\n+            try:\n+                dom = dom.inject(*extra_symbols)\n+            except (AttributeError, TypeError):\n+                # If injection fails, continue with original domain\n+                pass\n+    \n     F = Poly(0, Q.gen, domain=dom)\n \n     for i, (coeffs, q, f, k) in enumerate(partial):\n",
    "variant_0": "diff --git a/sympy/polys/partfrac.py b/sympy/polys/partfrac.py\nindex 612b8f4607..717c9008e0 100644\n--- a/sympy/polys/partfrac.py\n+++ b/sympy/polys/partfrac.py\n@@ -75,8 +75,8 @@ def apart(f, x=None, full=False, **options):\n     if f.is_Atom:\n         return f\n     else:\n-        P, Q = f.as_numer_denom()\n \n+        P, Q = f.as_numer_denom()\n     _options = options.copy()\n     options = set_defaults(options, extension=True)\n     try:\n@@ -117,36 +117,110 @@ def apart(f, x=None, full=False, **options):\n                     pass\n             return f.xreplace(dict(reps))\n \n+\n     if P.is_multivariate:\n+        # Check if the expression is univariate in the target variable x\n+        # even though it contains other symbolic parameters\n+        if x is not None and x in P.free_symbols:\n+            # Expression has symbolic parameters but may still be decomposable in x\n+            # Check if P and Q are polynomials in x with symbolic coefficients\n+            try:\n+                # Try to treat as univariate in x with symbolic coefficients\n+                P_univar = P.as_poly(x)\n+                Q_univar = Q.as_poly(x)\n+                if P_univar is not None and Q_univar is not None:\n+                    # Continue with univariate decomposition\n+                    P, Q = P_univar, Q_univar\n+                else:\n+                    raise PolynomialError(\"Cannot convert to univariate\")\n+            except (PolynomialError, AttributeError):\n+                fc = f.cancel()\n+                if fc != f:\n+                    return apart(fc, x=x, full=full, **_options)\n+                raise NotImplementedError(\n+                    \"multivariate partial fraction decomposition\")\n+        else:\n+            fc = f.cancel()\n+            if fc != f:\n+                return apart(fc, x=x, full=full, **_options)\n+            raise NotImplementedError(\n+                \"multivariate partial fraction decomposition\")\n+\n+\n+    if P.is_multivariate:\n+        # Check if the expression is univariate in the target variable x\n+        # even though it contains other symbolic parameters\n+        if x is not None and x in P.free_symbols:\n+            # Check if P and Q are actually univariate polynomials in x\n+            # (they may contain symbolic parameters but still be decomposable)\n+            try:\n+                # Try to treat as univariate in x, allowing symbolic parameters\n+                P_vars = P.free_symbols\n+                Q_vars = Q.free_symbols\n+                if len(P_vars & {x}) == 1 and len(Q_vars & {x}) == 1:\n+                    # Both P and Q contain x and can be treated as univariate in x\n+                    pass  # Continue to univariate decomposition\n+                else:\n+                    raise PolynomialError(\"Not univariate in target variable\")\n+            except:\n+                fc = f.cancel()\n+                if fc != f:\n+                    return apart(fc, x=x, full=full, **_options)\n+                raise NotImplementedError(\n+                    \"multivariate partial fraction decomposition\")\n+        else:\n+            fc = f.cancel()\n+            if fc != f:\n+                return apart(fc, x=x, full=full, **_options)\n+            raise NotImplementedError(\n+                \"multivariate partial fraction decomposition\")\n+\n+\n+if P.is_multivariate:\n+    # Check if the expression is univariate in the target variable x\n+    # even though it contains other symbolic parameters\n+    if x is not None:\n+        # Get the variables involved in P and Q\n+        P_vars = P.free_symbols\n+        Q_vars = Q.free_symbols\n+        \n+        # If x is the only polynomial variable and others are just parameters\n+        if x in P_vars and x in Q_vars:\n+            # Check if P and Q are actually polynomials in x\n+            try:\n+                # Try to treat as univariate in x with symbolic coefficients\n+                P_uni = P.as_poly(x)\n+                Q_uni = Q.as_poly(x)\n+                if P_uni is not None and Q_uni is not None:\n+                    # Update P and Q to be univariate polynomials in x\n+                    P, Q = P_uni, Q_uni\n+                else:\n+                    # Fall back to cancellation approach\n+                    fc = f.cancel()\n+                    if fc != f:\n+                        return apart(fc, x=x, full=full, **_options)\n+                    raise NotImplementedError(\n+                        \"multivariate partial fraction decomposition\")\n+            except:\n+                # Fall back to cancellation approach\n+                fc = f.cancel()\n+                if fc != f:\n+                    return apart(fc, x=x, full=full, **_options)\n+                raise NotImplementedError(\n+                    \"multivariate partial fraction decomposition\")\n+        else:\n+            fc = f.cancel()\n+            if fc != f:\n+                return apart(fc, x=x, full=full, **_options)\n+            raise NotImplementedError(\n+                \"multivariate partial fraction decomposition\")\n+    else:\n         fc = f.cancel()\n         if fc != f:\n             return apart(fc, x=x, full=full, **_options)\n-\n         raise NotImplementedError(\n             \"multivariate partial fraction decomposition\")\n \n-    common, P, Q = P.cancel(Q)\n-\n-    poly, P = P.div(Q, auto=True)\n-    P, Q = P.rat_clear_denoms(Q)\n-\n-    if Q.degree() <= 1:\n-        partial = P/Q\n-    else:\n-        if not full:\n-            partial = apart_undetermined_coeffs(P, Q)\n-        else:\n-            partial = apart_full_decomposition(P, Q)\n-\n-    terms = S.Zero\n-\n-    for term in Add.make_args(partial):\n-        if term.has(RootSum):\n-            terms += term\n-        else:\n-            terms += factor(term)\n-\n-    return common*(poly.as_expr() + terms)\n \n \n def apart_undetermined_coeffs(P, Q):\n@@ -164,7 +238,17 @@ def apart_undetermined_coeffs(P, Q):\n             partial.append((coeffs, q, f, i))\n             symbols.extend(coeffs)\n \n-    dom = Q.get_domain().inject(*symbols)\n+    # Handle symbolic parameters in domain\n+    extra_symbols = Q.free_symbols - {Q.gen}\n+    if P.free_symbols:\n+        extra_symbols.update(P.free_symbols - {Q.gen})\n+    \n+    dom = Q.get_domain()\n+    if symbols:\n+        dom = dom.inject(*symbols)\n+    if extra_symbols:\n+        dom = dom.inject(*extra_symbols)\n+    \n     F = Poly(0, Q.gen, domain=dom)\n \n     for i, (coeffs, q, f, k) in enumerate(partial):\n",
    "variant_1": "diff --git a/sympy/polys/partfrac.py b/sympy/polys/partfrac.py\nindex 612b8f4607..6ff3c29ed1 100644\n--- a/sympy/polys/partfrac.py\n+++ b/sympy/polys/partfrac.py\n@@ -75,8 +75,8 @@ def apart(f, x=None, full=False, **options):\n     if f.is_Atom:\n         return f\n     else:\n-        P, Q = f.as_numer_denom()\n \n+        P, Q = f.as_numer_denom()\n     _options = options.copy()\n     options = set_defaults(options, extension=True)\n     try:\n@@ -117,36 +117,88 @@ def apart(f, x=None, full=False, **options):\n                     pass\n             return f.xreplace(dict(reps))\n \n-    if P.is_multivariate:\n+\n+if P.is_multivariate:\n+    # Check if the expression is univariate in the target variable x\n+    # even though it contains other symbolic parameters\n+    if x is not None and x in P.free_symbols:\n+        # Get the polynomial in terms of x only\n+        try:\n+            # Try to treat as univariate in x with symbolic coefficients\n+            P_uni = Poly(P.as_expr(), x, domain='ZZ[%s]' % ','.join(str(s) for s in P.free_symbols - {x}))\n+            Q_uni = Poly(Q.as_expr(), x, domain='ZZ[%s]' % ','.join(str(s) for s in Q.free_symbols - {x}))\n+            # Replace P and Q with univariate versions and continue\n+            P, Q = P_uni, Q_uni\n+        except PolynomialError:\n+            # Fall back to original multivariate handling\n+            fc = f.cancel()\n+            if fc != f:\n+                return apart(fc, x=x, full=full, **_options)\n+            raise NotImplementedError(\n+                \"multivariate partial fraction decomposition\")\n+    else:\n         fc = f.cancel()\n         if fc != f:\n             return apart(fc, x=x, full=full, **_options)\n-\n         raise NotImplementedError(\n             \"multivariate partial fraction decomposition\")\n \n-    common, P, Q = P.cancel(Q)\n \n-    poly, P = P.div(Q, auto=True)\n-    P, Q = P.rat_clear_denoms(Q)\n-\n-    if Q.degree() <= 1:\n-        partial = P/Q\n-    else:\n-        if not full:\n-            partial = apart_undetermined_coeffs(P, Q)\n+    if P.is_multivariate:\n+        # Check if the expression is univariate in the target variable x\n+        # even though it contains other symbolic parameters\n+        if x is not None and x in P.free_symbols:\n+            # Get all variables except the target variable x\n+            other_vars = P.free_symbols - {x}\n+            # If P and Q are polynomials in x with symbolic coefficients,\n+            # we can still do partial fraction decomposition\n+            try:\n+                # Check if P and Q can be treated as univariate in x\n+                P_uni = P.as_poly(x)\n+                Q_uni = Q.as_poly(x)\n+                if P_uni is not None and Q_uni is not None:\n+                    # Continue with univariate partial fraction decomposition\n+                    pass\n+                else:\n+                    raise PolynomialError(\"Cannot convert to univariate\")\n+            except PolynomialError:\n+                fc = f.cancel()\n+                if fc != f:\n+                    return apart(fc, x=x, full=full, **_options)\n+                raise NotImplementedError(\n+                    \"multivariate partial fraction decomposition\")\n         else:\n-            partial = apart_full_decomposition(P, Q)\n-\n-    terms = S.Zero\n-\n-    for term in Add.make_args(partial):\n-        if term.has(RootSum):\n-            terms += term\n+            fc = f.cancel()\n+            if fc != f:\n+                return apart(fc, x=x, full=full, **_options)\n+            raise NotImplementedError(\n+                \"multivariate partial fraction decomposition\")\n+\n+\n+if P.is_multivariate:\n+    # Check if the expression is univariate in the target variable x\n+    # even though it contains other symbolic parameters\n+    if x is not None:\n+        # Get all variables except the target variable x\n+        other_vars = P.free_symbols - {x}\n+        # If P and Q only involve x and symbolic parameters (not other variables),\n+        # we can still perform partial fraction decomposition in x\n+        if other_vars and all(not var.is_symbol or var in f.free_symbols for var in other_vars):\n+            # Continue with univariate decomposition logic\n+            pass\n         else:\n-            terms += factor(term)\n+            fc = f.cancel()\n+            if fc != f:\n+                return apart(fc, x=x, full=full, **_options)\n+            raise NotImplementedError(\n+                \"multivariate partial fraction decomposition\")\n+    else:\n+        fc = f.cancel()\n+        if fc != f:\n+            return apart(fc, x=x, full=full, **_options)\n+        raise NotImplementedError(\n+            \"multivariate partial fraction decomposition\")\n \n-    return common*(poly.as_expr() + terms)\n \n \n def apart_undetermined_coeffs(P, Q):\n@@ -164,7 +216,17 @@ def apart_undetermined_coeffs(P, Q):\n             partial.append((coeffs, q, f, i))\n             symbols.extend(coeffs)\n \n-    dom = Q.get_domain().inject(*symbols)\n+    # Handle symbolic parameters in the domain\n+    extra_symbols = Q.free_symbols - {Q.gen}\n+    if P.free_symbols:\n+        extra_symbols = extra_symbols.union(P.free_symbols - {Q.gen})\n+    \n+    dom = Q.get_domain()\n+    if symbols:\n+        dom = dom.inject(*symbols)\n+    if extra_symbols:\n+        dom = dom.inject(*extra_symbols)\n+    \n     F = Poly(0, Q.gen, domain=dom)\n \n     for i, (coeffs, q, f, k) in enumerate(partial):\n",
    "variant_2": "diff --git a/sympy/polys/partfrac.py b/sympy/polys/partfrac.py\nindex 612b8f4607..23dc4ba379 100644\n--- a/sympy/polys/partfrac.py\n+++ b/sympy/polys/partfrac.py\n@@ -75,8 +75,8 @@ def apart(f, x=None, full=False, **options):\n     if f.is_Atom:\n         return f\n     else:\n-        P, Q = f.as_numer_denom()\n \n+        P, Q = f.as_numer_denom()\n     _options = options.copy()\n     options = set_defaults(options, extension=True)\n     try:\n@@ -117,36 +117,73 @@ def apart(f, x=None, full=False, **options):\n                     pass\n             return f.xreplace(dict(reps))\n \n-    if P.is_multivariate:\n-        fc = f.cancel()\n-        if fc != f:\n-            return apart(fc, x=x, full=full, **_options)\n-\n-        raise NotImplementedError(\n-            \"multivariate partial fraction decomposition\")\n \n-    common, P, Q = P.cancel(Q)\n+    if P.is_multivariate:\n+        # Check if the expression is univariate in the target variable x\n+        # even though it contains other symbolic parameters\n+        if x is not None and x in P.free_symbols:\n+            # Expression has symbolic parameters but may still be decomposable in x\n+            # Try to proceed with univariate decomposition logic\n+            pass  # Continue to univariate partial fraction decomposition\n+        else:\n+            fc = f.cancel()\n+            if fc != f:\n+                return apart(fc, x=x, full=full, **_options)\n+            raise NotImplementedError(\n+                \"multivariate partial fraction decomposition\")\n \n-    poly, P = P.div(Q, auto=True)\n-    P, Q = P.rat_clear_denoms(Q)\n \n-    if Q.degree() <= 1:\n-        partial = P/Q\n-    else:\n-        if not full:\n-            partial = apart_undetermined_coeffs(P, Q)\n+    if P.is_multivariate:\n+        # Check if the expression is univariate in the target variable x\n+        # even though it contains other symbolic parameters\n+        if x is not None and x in P.free_symbols:\n+            # Expression may be univariate in x despite having symbolic parameters\n+            # Check if we can treat it as a univariate rational function in x\n+            try:\n+                # Try to get the degree in x to verify it's a polynomial in x\n+                P.degree(x)\n+                Q.degree(x)\n+                # If we get here, P and Q are polynomials in x, proceed with decomposition\n+            except (PolynomialError, TypeError):\n+                # Fall back to cancellation approach\n+                fc = f.cancel()\n+                if fc != f:\n+                    return apart(fc, x=x, full=full, **_options)\n+                raise NotImplementedError(\n+                    \"multivariate partial fraction decomposition\")\n         else:\n-            partial = apart_full_decomposition(P, Q)\n+            fc = f.cancel()\n+            if fc != f:\n+                return apart(fc, x=x, full=full, **_options)\n+            raise NotImplementedError(\n+                \"multivariate partial fraction decomposition\")\n \n-    terms = S.Zero\n \n-    for term in Add.make_args(partial):\n-        if term.has(RootSum):\n-            terms += term\n+    if P.is_multivariate:\n+        # Check if the expression is univariate in the target variable x\n+        # even though it contains other symbolic parameters\n+        if x is not None:\n+            # Get variables other than x\n+            other_vars = P.free_symbols - {x}\n+            # If there are symbolic parameters but the expression is still\n+            # a rational function in x, we can proceed with decomposition\n+            if other_vars and all(var not in Q.free_symbols or \n+                                Q.degree(var) == 0 for var in other_vars):\n+                # Expression has symbolic parameters but is univariate in x\n+                pass  # Continue to line 128\n+            else:\n+                fc = f.cancel()\n+                if fc != f:\n+                    return apart(fc, x=x, full=full, **_options)\n+                raise NotImplementedError(\n+                    \"multivariate partial fraction decomposition\")\n         else:\n-            terms += factor(term)\n+            fc = f.cancel()\n+            if fc != f:\n+                return apart(fc, x=x, full=full, **_options)\n+            raise NotImplementedError(\n+                \"multivariate partial fraction decomposition\")\n \n-    return common*(poly.as_expr() + terms)\n \n \n def apart_undetermined_coeffs(P, Q):\n@@ -164,7 +201,17 @@ def apart_undetermined_coeffs(P, Q):\n             partial.append((coeffs, q, f, i))\n             symbols.extend(coeffs)\n \n-    dom = Q.get_domain().inject(*symbols)\n+    # Handle symbolic parameters by extending domain\n+    extra_symbols = Q.free_symbols - {Q.gen}\n+    if P.free_symbols:\n+        extra_symbols.update(P.free_symbols - {Q.gen})\n+    \n+    dom = Q.get_domain()\n+    if extra_symbols:\n+        dom = dom.inject(*extra_symbols)\n+    if symbols:\n+        dom = dom.inject(*symbols)\n+    \n     F = Poly(0, Q.gen, domain=dom)\n \n     for i, (coeffs, q, f, k) in enumerate(partial):\n",
    "variant_3": "diff --git a/sympy/polys/partfrac.py b/sympy/polys/partfrac.py\nindex 612b8f4607..856cebe16c 100644\n--- a/sympy/polys/partfrac.py\n+++ b/sympy/polys/partfrac.py\n@@ -75,8 +75,46 @@ def apart(f, x=None, full=False, **options):\n     if f.is_Atom:\n         return f\n     else:\n-        P, Q = f.as_numer_denom()\n \n+    if f.is_Atom:\n+        return f\n+    else:\n+        P, Q = f.as_numer_denom()\n+        \n+        # Check if expression is truly multivariate or just has symbolic parameters\n+        if x is not None and P.is_polynomial() and Q.is_polynomial():\n+            # Get variables that appear with non-zero degree\n+            P_vars = getattr(P, 'free_symbols', set())\n+            Q_vars = getattr(Q, 'free_symbols', set())\n+            poly_vars = P_vars | Q_vars\n+            \n+            # If x is the only variable with polynomial degree > 0, treat as univariate\n+            if x in poly_vars:\n+                try:\n+                    from sympy import degree\n+                    # Check if other variables appear only as coefficients\n+                    other_vars = poly_vars - {x}\n+                    is_univariate_in_x = True\n+                    \n+                    # Simple heuristic: if we can extract x-dependent terms, proceed\n+                    if other_vars and hasattr(P, 'as_poly') and hasattr(Q, 'as_poly'):\n+                        try:\n+                            P.as_poly(x)\n+                            Q.as_poly(x)\n+                            # If successful, treat as univariate in x with symbolic coefficients\n+                        except:\n+                            is_univariate_in_x = False\n+                    \n+                    if not is_univariate_in_x and len(poly_vars) > 1:\n+                        # Truly multivariate case\n+                        fc = f.cancel()\n+                        if fc != f:\n+                            return apart(fc, x=x, full=full, **_options)\n+                        raise NotImplementedError(\n+                            \"multivariate partial fraction decomposition\")\n+                except:\n+                    # Fall back to original logic if analysis fails\n+                    pass\n     _options = options.copy()\n     options = set_defaults(options, extension=True)\n     try:\n@@ -117,36 +155,69 @@ def apart(f, x=None, full=False, **options):\n                     pass\n             return f.xreplace(dict(reps))\n \n-    if P.is_multivariate:\n-        fc = f.cancel()\n-        if fc != f:\n-            return apart(fc, x=x, full=full, **_options)\n-\n-        raise NotImplementedError(\n-            \"multivariate partial fraction decomposition\")\n \n-    common, P, Q = P.cancel(Q)\n+    if P.is_multivariate:\n+        # Check if the expression is univariate in the target variable x\n+        # even though it contains other symbolic parameters\n+        if x is not None and x in P.free_symbols and P.degree(x) > 0:\n+            # Expression has symbolic parameters but is still univariate in x\n+            # Continue with univariate partial fraction decomposition\n+            pass\n+        else:\n+            fc = f.cancel()\n+            if fc != f:\n+                return apart(fc, x=x, full=full, **_options)\n+            raise NotImplementedError(\n+                \"multivariate partial fraction decomposition\")\n \n-    poly, P = P.div(Q, auto=True)\n-    P, Q = P.rat_clear_denoms(Q)\n \n-    if Q.degree() <= 1:\n-        partial = P/Q\n-    else:\n-        if not full:\n-            partial = apart_undetermined_coeffs(P, Q)\n+    if P.is_multivariate:\n+        # Check if the expression is univariate in the target variable x\n+        # even though it contains other symbolic parameters\n+        if x is not None and x in P.free_symbols:\n+            # Extract variables other than x\n+            other_vars = P.free_symbols - {x}\n+            # If P is polynomial in x but has symbolic parameters, proceed with decomposition\n+            if other_vars and all(P.degree(var) == 0 for var in other_vars if var != x):\n+                pass  # Continue to univariate decomposition logic\n+            else:\n+                fc = f.cancel()\n+                if fc != f:\n+                    return apart(fc, x=x, full=full, **_options)\n+                raise NotImplementedError(\n+                    \"multivariate partial fraction decomposition\")\n         else:\n-            partial = apart_full_decomposition(P, Q)\n+            fc = f.cancel()\n+            if fc != f:\n+                return apart(fc, x=x, full=full, **_options)\n+            raise NotImplementedError(\n+                \"multivariate partial fraction decomposition\")\n \n-    terms = S.Zero\n \n-    for term in Add.make_args(partial):\n-        if term.has(RootSum):\n-            terms += term\n+    if P.is_multivariate:\n+        # Check if the expression is univariate in the target variable x\n+        # even though it contains other symbolic parameters\n+        if x is not None:\n+            # Get all variables except the target variable x\n+            other_vars = P.free_symbols - {x}\n+            # If there are symbolic parameters but the expression is still\n+            # a rational function in x, we can proceed with decomposition\n+            if other_vars and all(not P.has_free(var) for var in other_vars if P.degree(var) > 0):\n+                # Expression has symbolic parameters but is polynomial in x\n+                pass  # Continue to univariate decomposition\n+            else:\n+                fc = f.cancel()\n+                if fc != f:\n+                    return apart(fc, x=x, full=full, **_options)\n+                raise NotImplementedError(\n+                    \"multivariate partial fraction decomposition\")\n         else:\n-            terms += factor(term)\n+            fc = f.cancel()\n+            if fc != f:\n+                return apart(fc, x=x, full=full, **_options)\n+            raise NotImplementedError(\n+                \"multivariate partial fraction decomposition\")\n \n-    return common*(poly.as_expr() + terms)\n \n \n def apart_undetermined_coeffs(P, Q):\n@@ -164,7 +235,17 @@ def apart_undetermined_coeffs(P, Q):\n             partial.append((coeffs, q, f, i))\n             symbols.extend(coeffs)\n \n-    dom = Q.get_domain().inject(*symbols)\n+    # Handle symbolic parameters in the domain\n+    extra_symbols = Q.free_symbols - {Q.gen}\n+    if P.free_symbols:\n+        extra_symbols = extra_symbols.union(P.free_symbols - {Q.gen})\n+    \n+    dom = Q.get_domain()\n+    if symbols:\n+        dom = dom.inject(*symbols)\n+    if extra_symbols:\n+        dom = dom.inject(*extra_symbols)\n+    \n     F = Poly(0, Q.gen, domain=dom)\n \n     for i, (coeffs, q, f, k) in enumerate(partial):\n",
    "variant_4": "diff --git a/sympy/polys/partfrac.py b/sympy/polys/partfrac.py\nindex 612b8f4607..b9aae888b5 100644\n--- a/sympy/polys/partfrac.py\n+++ b/sympy/polys/partfrac.py\n@@ -75,8 +75,8 @@ def apart(f, x=None, full=False, **options):\n     if f.is_Atom:\n         return f\n     else:\n-        P, Q = f.as_numer_denom()\n \n+        P, Q = f.as_numer_denom()\n     _options = options.copy()\n     options = set_defaults(options, extension=True)\n     try:\n@@ -117,36 +117,89 @@ def apart(f, x=None, full=False, **options):\n                     pass\n             return f.xreplace(dict(reps))\n \n+\n     if P.is_multivariate:\n-        fc = f.cancel()\n-        if fc != f:\n-            return apart(fc, x=x, full=full, **_options)\n+        # Check if the expression is univariate in the target variable x\n+        # even though it contains other symbolic parameters\n+        if x is not None and x in P.free_symbols:\n+            # Expression has symbolic parameters but may still be decomposable in x\n+            # Check if P and Q are rational in x (univariate polynomials in x with symbolic coeffs)\n+            try:\n+                # Try to treat as univariate in x with symbolic coefficients\n+                P_univar = P.as_poly(x)\n+                Q_univar = Q.as_poly(x)\n+                if P_univar is not None and Q_univar is not None:\n+                    # Proceed with univariate partial fraction decomposition\n+                    pass\n+                else:\n+                    raise PolynomialError(\"Not univariate in target variable\")\n+            except (PolynomialError, TypeError):\n+                fc = f.cancel()\n+                if fc != f:\n+                    return apart(fc, x=x, full=full, **_options)\n+                raise NotImplementedError(\n+                    \"multivariate partial fraction decomposition\")\n+        else:\n+            fc = f.cancel()\n+            if fc != f:\n+                return apart(fc, x=x, full=full, **_options)\n+            raise NotImplementedError(\n+                \"multivariate partial fraction decomposition\")\n \n-        raise NotImplementedError(\n-            \"multivariate partial fraction decomposition\")\n+\n+    if P.is_multivariate:\n+        # Check if the expression is univariate in the target variable x\n+        # even though it contains other symbolic parameters\n+        if x is not None and x in P.free_symbols:\n+            # Get variables other than x\n+            other_vars = P.free_symbols - {x}\n+            # If P and Q are polynomials in x with symbolic coefficients,\n+            # we can still perform partial fraction decomposition\n+            try:\n+                # Try to treat as univariate in x with symbolic coefficients\n+                pass  # Continue to cancellation logic below\n+            except:\n+                fc = f.cancel()\n+                if fc != f:\n+                    return apart(fc, x=x, full=full, **_options)\n+                raise NotImplementedError(\n+                    \"multivariate partial fraction decomposition\")\n+        else:\n+            fc = f.cancel()\n+            if fc != f:\n+                return apart(fc, x=x, full=full, **_options)\n+            raise NotImplementedError(\n+                \"multivariate partial fraction decomposition\")\n \n     common, P, Q = P.cancel(Q)\n \n     poly, P = P.div(Q, auto=True)\n     P, Q = P.rat_clear_denoms(Q)\n \n-    if Q.degree() <= 1:\n-        partial = P/Q\n-    else:\n-        if not full:\n-            partial = apart_undetermined_coeffs(P, Q)\n-        else:\n-            partial = apart_full_decomposition(P, Q)\n-\n-    terms = S.Zero\n \n-    for term in Add.make_args(partial):\n-        if term.has(RootSum):\n-            terms += term\n+    if P.is_multivariate:\n+        # Check if the expression is univariate in the target variable x\n+        # even though it contains other symbolic parameters\n+        if x is not None:\n+            # Get all variables in P except the target variable x\n+            other_vars = P.free_symbols - {x}\n+            # If P is rational in x (even with symbolic parameters), proceed\n+            if other_vars and all(var not in P.gens for var in other_vars):\n+                # Expression has symbolic parameters but is still rational in x\n+                pass  # Continue with univariate decomposition\n+            else:\n+                fc = f.cancel()\n+                if fc != f:\n+                    return apart(fc, x=x, full=full, **_options)\n+                raise NotImplementedError(\n+                    \"multivariate partial fraction decomposition\")\n         else:\n-            terms += factor(term)\n+            fc = f.cancel()\n+            if fc != f:\n+                return apart(fc, x=x, full=full, **_options)\n+            raise NotImplementedError(\n+                \"multivariate partial fraction decomposition\")\n \n-    return common*(poly.as_expr() + terms)\n \n \n def apart_undetermined_coeffs(P, Q):\n@@ -164,7 +217,17 @@ def apart_undetermined_coeffs(P, Q):\n             partial.append((coeffs, q, f, i))\n             symbols.extend(coeffs)\n \n+    # Handle symbolic parameters in the domain\n+    extra_symbols = set()\n+    if hasattr(P, 'free_symbols'):\n+        extra_symbols.update(P.free_symbols - {Q.gen})\n+    if hasattr(Q, 'free_symbols'):\n+        extra_symbols.update(Q.free_symbols - {Q.gen})\n+    \n     dom = Q.get_domain().inject(*symbols)\n+    if extra_symbols:\n+        dom = dom.inject(*extra_symbols)\n+    \n     F = Poly(0, Q.gen, domain=dom)\n \n     for i, (coeffs, q, f, k) in enumerate(partial):\n",
    "variant_5": "diff --git a/sympy/polys/partfrac.py b/sympy/polys/partfrac.py\nindex 612b8f4607..e1b34b902b 100644\n--- a/sympy/polys/partfrac.py\n+++ b/sympy/polys/partfrac.py\n@@ -75,8 +75,35 @@ def apart(f, x=None, full=False, **options):\n     if f.is_Atom:\n         return f\n     else:\n+\n         P, Q = f.as_numer_denom()\n \n+        # Check if the expression is univariate in the target variable x\n+        # even though it may contain symbolic parameters\n+        if P.is_multivariate and x is not None:\n+            # If P has variables other than x, check if it's still decomposable in x\n+            p_vars = P.free_symbols if hasattr(P, 'free_symbols') else set()\n+            q_vars = Q.free_symbols if hasattr(Q, 'free_symbols') else set()\n+            all_vars = p_vars | q_vars\n+            \n+            # If the only \"extra\" variables are symbolic parameters (not the target variable),\n+            # we can still proceed with partial fraction decomposition\n+            if x in all_vars and len(all_vars - {x}) > 0:\n+                # Continue with decomposition - this is univariate in x with parameters\n+                pass\n+            else:\n+                # Truly multivariate case\n+                fc = f.cancel()\n+                if fc != f:\n+                    return apart(fc, x=x, full=full, **_options)\n+                raise NotImplementedError(\n+                    \"multivariate partial fraction decomposition\")\n+        elif P.is_multivariate:\n+            fc = f.cancel()\n+            if fc != f:\n+                return apart(fc, x=x, full=full, **_options)\n+            raise NotImplementedError(\n+                \"multivariate partial fraction decomposition\")\n     _options = options.copy()\n     options = set_defaults(options, extension=True)\n     try:\n@@ -117,36 +144,85 @@ def apart(f, x=None, full=False, **options):\n                     pass\n             return f.xreplace(dict(reps))\n \n-    if P.is_multivariate:\n+\n+if P.is_multivariate:\n+    # Check if the expression is univariate in the target variable x\n+    # even though it contains other symbolic parameters\n+    if x is not None and x in P.free_symbols:\n+        # Get all variables except the target variable x\n+        other_vars = P.free_symbols - {x}\n+        # If P only depends on x and symbolic parameters (not other polynomial variables),\n+        # we can still perform partial fraction decomposition\n+        if other_vars and all(not P.has(var) or var.is_symbol for var in other_vars):\n+            # Continue with univariate decomposition logic\n+            pass\n+        else:\n+            fc = f.cancel()\n+            if fc != f:\n+                return apart(fc, x=x, full=full, **_options)\n+            raise NotImplementedError(\n+                \"multivariate partial fraction decomposition\")\n+    else:\n         fc = f.cancel()\n         if fc != f:\n             return apart(fc, x=x, full=full, **_options)\n-\n         raise NotImplementedError(\n             \"multivariate partial fraction decomposition\")\n \n-    common, P, Q = P.cancel(Q)\n-\n-    poly, P = P.div(Q, auto=True)\n-    P, Q = P.rat_clear_denoms(Q)\n \n-    if Q.degree() <= 1:\n-        partial = P/Q\n-    else:\n-        if not full:\n-            partial = apart_undetermined_coeffs(P, Q)\n+    if P.is_multivariate:\n+        # Check if the expression is univariate in the target variable x\n+        # even though it contains other symbolic parameters\n+        if x is not None and x in P.free_symbols:\n+            # Check if P and Q are polynomials in x with symbolic coefficients\n+            try:\n+                # Try to treat as univariate in x with symbolic coefficients\n+                P_x = P.as_poly(x)\n+                Q_x = Q.as_poly(x)\n+                if P_x is not None and Q_x is not None:\n+                    # Continue with univariate decomposition\n+                    pass\n+                else:\n+                    raise PolynomialError(\"Not polynomial in target variable\")\n+            except PolynomialError:\n+                fc = f.cancel()\n+                if fc != f:\n+                    return apart(fc, x=x, full=full, **_options)\n+                raise NotImplementedError(\n+                    \"multivariate partial fraction decomposition\")\n         else:\n-            partial = apart_full_decomposition(P, Q)\n-\n-    terms = S.Zero\n-\n-    for term in Add.make_args(partial):\n-        if term.has(RootSum):\n-            terms += term\n+            fc = f.cancel()\n+            if fc != f:\n+                return apart(fc, x=x, full=full, **_options)\n+            raise NotImplementedError(\n+                \"multivariate partial fraction decomposition\")\n+\n+\n+if P.is_multivariate:\n+    # Check if the expression is univariate in the target variable x\n+    # even though it contains other symbolic parameters\n+    if x is not None:\n+        # Get the variables that are not the target variable\n+        other_vars = P.free_symbols - {x}\n+        # If there are other variables, check if they are just parameters\n+        # (i.e., the expression is still a rational function in x)\n+        if other_vars:\n+            # Try to treat other variables as parameters and proceed\n+            # with univariate partial fraction decomposition in x\n+            pass  # Continue to the univariate logic below\n         else:\n-            terms += factor(term)\n+            fc = f.cancel()\n+            if fc != f:\n+                return apart(fc, x=x, full=full, **_options)\n+            raise NotImplementedError(\n+                \"multivariate partial fraction decomposition\")\n+    else:\n+        fc = f.cancel()\n+        if fc != f:\n+            return apart(fc, x=x, full=full, **_options)\n+        raise NotImplementedError(\n+            \"multivariate partial fraction decomposition\")\n \n-    return common*(poly.as_expr() + terms)\n \n \n def apart_undetermined_coeffs(P, Q):\n@@ -164,7 +240,17 @@ def apart_undetermined_coeffs(P, Q):\n             partial.append((coeffs, q, f, i))\n             symbols.extend(coeffs)\n \n-    dom = Q.get_domain().inject(*symbols)\n+    # Handle symbolic parameters in domain\n+    extra_symbols = Q.free_symbols - {Q.gen}\n+    if P.free_symbols:\n+        extra_symbols = extra_symbols.union(P.free_symbols - {Q.gen})\n+    \n+    dom = Q.get_domain()\n+    if symbols:\n+        dom = dom.inject(*symbols)\n+    if extra_symbols:\n+        dom = dom.inject(*extra_symbols)\n+    \n     F = Poly(0, Q.gen, domain=dom)\n \n     for i, (coeffs, q, f, k) in enumerate(partial):\n",
    "variant_6": "diff --git a/sympy/polys/partfrac.py b/sympy/polys/partfrac.py\nindex 612b8f4607..aefae5221c 100644\n--- a/sympy/polys/partfrac.py\n+++ b/sympy/polys/partfrac.py\n@@ -75,8 +75,33 @@ def apart(f, x=None, full=False, **options):\n     if f.is_Atom:\n         return f\n     else:\n-        P, Q = f.as_numer_denom()\n \n+    if P.is_multivariate:\n+        # Check if the expression is univariate in the target variable x\n+        # even though it contains other symbolic parameters\n+        if x is not None and x in P.free_symbols:\n+            # Expression has symbolic parameters but may still be decomposable in x\n+            # Check if P and Q are actually univariate polynomials in x\n+            try:\n+                P_univar = P.as_poly(x)\n+                Q_univar = Q.as_poly(x)\n+                if P_univar is not None and Q_univar is not None:\n+                    # Proceed with univariate partial fraction decomposition\n+                    pass\n+                else:\n+                    raise NotImplementedError\n+            except:\n+                fc = f.cancel()\n+                if fc != f:\n+                    return apart(fc, x=x, full=full, **_options)\n+                raise NotImplementedError(\n+                    \"multivariate partial fraction decomposition\")\n+        else:\n+            fc = f.cancel()\n+            if fc != f:\n+                return apart(fc, x=x, full=full, **_options)\n+            raise NotImplementedError(\n+                \"multivariate partial fraction decomposition\")\n     _options = options.copy()\n     options = set_defaults(options, extension=True)\n     try:\n@@ -117,36 +142,106 @@ def apart(f, x=None, full=False, **options):\n                     pass\n             return f.xreplace(dict(reps))\n \n-    if P.is_multivariate:\n+\n+if P.is_multivariate:\n+    # Check if the expression is univariate in the target variable x\n+    # even though it contains other symbolic parameters\n+    if x is not None and x in P.free_symbols:\n+        # Get the polynomial in terms of x only\n+        try:\n+            # Try to treat as univariate in x with symbolic coefficients\n+            P_univar = P.as_poly(x)\n+            Q_univar = Q.as_poly(x)\n+            if P_univar is not None and Q_univar is not None:\n+                # Continue with univariate partial fraction decomposition\n+                pass\n+            else:\n+                raise PolynomialError(\"Cannot convert to univariate polynomial\")\n+        except (PolynomialError, AttributeError):\n+            fc = f.cancel()\n+            if fc != f:\n+                return apart(fc, x=x, full=full, **_options)\n+            raise NotImplementedError(\n+                \"multivariate partial fraction decomposition\")\n+    else:\n         fc = f.cancel()\n         if fc != f:\n             return apart(fc, x=x, full=full, **_options)\n-\n         raise NotImplementedError(\n             \"multivariate partial fraction decomposition\")\n \n-    common, P, Q = P.cancel(Q)\n \n-    poly, P = P.div(Q, auto=True)\n-    P, Q = P.rat_clear_denoms(Q)\n-\n-    if Q.degree() <= 1:\n-        partial = P/Q\n-    else:\n-        if not full:\n-            partial = apart_undetermined_coeffs(P, Q)\n+    if P.is_multivariate:\n+        # Check if the expression is univariate in the target variable x\n+        # even though it contains other symbolic parameters\n+        if x is not None and x in P.free_symbols:\n+            # Get all variables except the target variable x\n+            other_vars = P.free_symbols - {x}\n+            # If other variables are just symbolic parameters (not in denominator degree),\n+            # we can still do partial fraction decomposition in x\n+            if other_vars and all(Q.degree(var) == 0 for var in other_vars if var != x):\n+                # Continue with univariate decomposition logic\n+                pass\n+            else:\n+                fc = f.cancel()\n+                if fc != f:\n+                    return apart(fc, x=x, full=full, **_options)\n+                raise NotImplementedError(\n+                    \"multivariate partial fraction decomposition\")\n         else:\n-            partial = apart_full_decomposition(P, Q)\n+            fc = f.cancel()\n+            if fc != f:\n+                return apart(fc, x=x, full=full, **_options)\n+            raise NotImplementedError(\n+                \"multivariate partial fraction decomposition\")\n \n-    terms = S.Zero\n \n-    for term in Add.make_args(partial):\n-        if term.has(RootSum):\n-            terms += term\n+    if P.is_multivariate:\n+        # Check if the expression is univariate in the target variable x\n+        # even though it contains other symbolic parameters\n+        if x is not None:\n+            # Get all variables in the polynomials\n+            P_vars = P.free_symbols\n+            Q_vars = Q.free_symbols\n+            all_vars = P_vars | Q_vars\n+            \n+            # If x is the only polynomial variable (others are just parameters)\n+            if all_vars - {x}:  # Has symbolic parameters\n+                # Check if P and Q are actually univariate polynomials in x\n+                try:\n+                    # Try to treat as univariate in x with symbolic coefficients\n+                    P_uni = P.as_poly(x)\n+                    Q_uni = Q.as_poly(x)\n+                    if P_uni is not None and Q_uni is not None:\n+                        # Update P and Q to be univariate polynomials in x\n+                        P, Q = P_uni, Q_uni\n+                    else:\n+                        # Fall back to cancellation approach\n+                        fc = f.cancel()\n+                        if fc != f:\n+                            return apart(fc, x=x, full=full, **_options)\n+                        raise NotImplementedError(\n+                            \"multivariate partial fraction decomposition\")\n+                except PolynomialError:\n+                    # Fall back to cancellation approach\n+                    fc = f.cancel()\n+                    if fc != f:\n+                        return apart(fc, x=x, full=full, **_options)\n+                    raise NotImplementedError(\n+                        \"multivariate partial fraction decomposition\")\n+            else:\n+                fc = f.cancel()\n+                if fc != f:\n+                    return apart(fc, x=x, full=full, **_options)\n+                raise NotImplementedError(\n+                    \"multivariate partial fraction decomposition\")\n         else:\n-            terms += factor(term)\n+            fc = f.cancel()\n+            if fc != f:\n+                return apart(fc, x=x, full=full, **_options)\n+            raise NotImplementedError(\n+                \"multivariate partial fraction decomposition\")\n \n-    return common*(poly.as_expr() + terms)\n \n \n def apart_undetermined_coeffs(P, Q):\n@@ -164,7 +259,15 @@ def apart_undetermined_coeffs(P, Q):\n             partial.append((coeffs, q, f, i))\n             symbols.extend(coeffs)\n \n+    # Include symbolic parameters in domain\n+    extra_symbols = Q.free_symbols - {Q.gen}\n+    if P.free_symbols:\n+        extra_symbols.update(P.free_symbols - {Q.gen})\n+    \n     dom = Q.get_domain().inject(*symbols)\n+    if extra_symbols:\n+        dom = dom.inject(*extra_symbols)\n+    \n     F = Poly(0, Q.gen, domain=dom)\n \n     for i, (coeffs, q, f, k) in enumerate(partial):\n",
    "variant_7": "diff --git a/sympy/polys/partfrac.py b/sympy/polys/partfrac.py\nindex 612b8f4607..7f5aa3982f 100644\n--- a/sympy/polys/partfrac.py\n+++ b/sympy/polys/partfrac.py\n@@ -75,8 +75,8 @@ def apart(f, x=None, full=False, **options):\n     if f.is_Atom:\n         return f\n     else:\n-        P, Q = f.as_numer_denom()\n \n+        P, Q = f.as_numer_denom()\n     _options = options.copy()\n     options = set_defaults(options, extension=True)\n     try:\n@@ -117,36 +117,71 @@ def apart(f, x=None, full=False, **options):\n                     pass\n             return f.xreplace(dict(reps))\n \n-    if P.is_multivariate:\n+\n+if P.is_multivariate:\n+    # Check if the expression is univariate in the target variable x\n+    # even though it contains other symbolic parameters\n+    if x is not None and x in P.free_symbols:\n+        # Get variables other than x\n+        other_vars = P.free_symbols - {x}\n+        # If P is polynomial in x with symbolic coefficients, proceed with decomposition\n+        try:\n+            # Test if we can treat this as univariate in x\n+            P_in_x = P.as_poly(x)\n+            Q_in_x = Q.as_poly(x)\n+            # If successful, continue with univariate logic\n+        except (PolynomialError, TypeError):\n+            # Fall back to cancellation approach\n+            fc = f.cancel()\n+            if fc != f:\n+                return apart(fc, x=x, full=full, **_options)\n+            raise NotImplementedError(\n+                \"multivariate partial fraction decomposition\")\n+    else:\n         fc = f.cancel()\n         if fc != f:\n             return apart(fc, x=x, full=full, **_options)\n-\n         raise NotImplementedError(\n             \"multivariate partial fraction decomposition\")\n \n-    common, P, Q = P.cancel(Q)\n-\n-    poly, P = P.div(Q, auto=True)\n-    P, Q = P.rat_clear_denoms(Q)\n \n-    if Q.degree() <= 1:\n-        partial = P/Q\n-    else:\n-        if not full:\n-            partial = apart_undetermined_coeffs(P, Q)\n+    if P.is_multivariate:\n+        # Check if the expression is univariate in the target variable x\n+        # even though it contains other symbolic parameters\n+        if x is not None and x in P.free_symbols and Q.free_symbols - {x}:\n+            # Expression has symbolic parameters but is still univariate in x\n+            # Continue with univariate decomposition logic\n+            pass\n         else:\n-            partial = apart_full_decomposition(P, Q)\n-\n-    terms = S.Zero\n-\n-    for term in Add.make_args(partial):\n-        if term.has(RootSum):\n-            terms += term\n+            fc = f.cancel()\n+            if fc != f:\n+                return apart(fc, x=x, full=full, **_options)\n+            raise NotImplementedError(\n+                \"multivariate partial fraction decomposition\")\n+\n+\n+if P.is_multivariate:\n+    # Check if the expression is univariate in the target variable x\n+    # even though it contains other symbolic parameters\n+    if x is not None:\n+        # Get variables other than x\n+        other_vars = P.free_symbols - {x}\n+        # If P is polynomial in x but has symbolic parameters, proceed\n+        if other_vars and all(P.degree(var) == 0 for var in other_vars if var in P.gens):\n+            pass  # Continue to univariate decomposition\n         else:\n-            terms += factor(term)\n+            fc = f.cancel()\n+            if fc != f:\n+                return apart(fc, x=x, full=full, **_options)\n+            raise NotImplementedError(\n+                \"multivariate partial fraction decomposition\")\n+    else:\n+        fc = f.cancel()\n+        if fc != f:\n+            return apart(fc, x=x, full=full, **_options)\n+        raise NotImplementedError(\n+            \"multivariate partial fraction decomposition\")\n \n-    return common*(poly.as_expr() + terms)\n \n \n def apart_undetermined_coeffs(P, Q):\n@@ -164,7 +199,17 @@ def apart_undetermined_coeffs(P, Q):\n             partial.append((coeffs, q, f, i))\n             symbols.extend(coeffs)\n \n-    dom = Q.get_domain().inject(*symbols)\n+    # Handle symbolic parameters in domain\n+    extra_symbols = Q.free_symbols - {Q.gen}\n+    if P.free_symbols:\n+        extra_symbols = extra_symbols.union(P.free_symbols - {Q.gen})\n+    \n+    dom = Q.get_domain()\n+    if symbols:\n+        dom = dom.inject(*symbols)\n+    if extra_symbols:\n+        dom = dom.inject(*extra_symbols)\n+    \n     F = Poly(0, Q.gen, domain=dom)\n \n     for i, (coeffs, q, f, k) in enumerate(partial):\n",
    "variant_8": "diff --git a/sympy/polys/partfrac.py b/sympy/polys/partfrac.py\nindex 612b8f4607..d0d5959e1d 100644\n--- a/sympy/polys/partfrac.py\n+++ b/sympy/polys/partfrac.py\n@@ -75,8 +75,20 @@ def apart(f, x=None, full=False, **options):\n     if f.is_Atom:\n         return f\n     else:\n-        P, Q = f.as_numer_denom()\n \n+    if P.is_multivariate:\n+        # Check if the expression is univariate in the target variable x\n+        # even though it contains other symbolic parameters\n+        if x is not None and len(P.gens) == 1 and P.gen == x:\n+            # Expression is univariate in x, proceed with decomposition\n+            pass\n+        else:\n+            fc = f.cancel()\n+            if fc != f:\n+                return apart(fc, x=x, full=full, **_options)\n+\n+            raise NotImplementedError(\n+                \"multivariate partial fraction decomposition\")\n     _options = options.copy()\n     options = set_defaults(options, extension=True)\n     try:\n@@ -117,36 +129,83 @@ def apart(f, x=None, full=False, **options):\n                     pass\n             return f.xreplace(dict(reps))\n \n-    if P.is_multivariate:\n-        fc = f.cancel()\n-        if fc != f:\n-            return apart(fc, x=x, full=full, **_options)\n-\n-        raise NotImplementedError(\n-            \"multivariate partial fraction decomposition\")\n \n-    common, P, Q = P.cancel(Q)\n+    if P.is_multivariate:\n+        # Check if the expression is univariate in the target variable x\n+        # even though it contains other symbolic parameters\n+        if x is not None and x in P.free_symbols:\n+            # Expression has symbolic parameters but may still be decomposable in x\n+            # Check if P and Q are polynomial in x when other symbols are treated as parameters\n+            try:\n+                # Try to treat other symbols as parameters and proceed with decomposition\n+                pass  # Continue to univariate decomposition logic\n+            except:\n+                fc = f.cancel()\n+                if fc != f:\n+                    return apart(fc, x=x, full=full, **_options)\n+                raise NotImplementedError(\n+                    \"multivariate partial fraction decomposition\")\n+        else:\n+            fc = f.cancel()\n+            if fc != f:\n+                return apart(fc, x=x, full=full, **_options)\n+            raise NotImplementedError(\n+                \"multivariate partial fraction decomposition\")\n \n-    poly, P = P.div(Q, auto=True)\n-    P, Q = P.rat_clear_denoms(Q)\n \n-    if Q.degree() <= 1:\n-        partial = P/Q\n-    else:\n-        if not full:\n-            partial = apart_undetermined_coeffs(P, Q)\n+    if P.is_multivariate:\n+        # Check if the expression is univariate in the target variable x\n+        # even though it contains other symbolic parameters\n+        if x is not None and x in P.free_symbols:\n+            # Check if P and Q are actually polynomials in x with symbolic coefficients\n+            try:\n+                # Try to treat as univariate in x with symbolic parameters\n+                P_vars = P.free_symbols\n+                Q_vars = Q.free_symbols\n+                if P_vars <= Q_vars.union({x}) and x in Q_vars:\n+                    # P and Q only contain x and possibly symbolic parameters\n+                    # Continue with univariate partial fraction decomposition\n+                    pass\n+                else:\n+                    raise PolynomialError(\"truly multivariate\")\n+            except:\n+                fc = f.cancel()\n+                if fc != f:\n+                    return apart(fc, x=x, full=full, **_options)\n+                raise NotImplementedError(\n+                    \"multivariate partial fraction decomposition\")\n         else:\n-            partial = apart_full_decomposition(P, Q)\n+            fc = f.cancel()\n+            if fc != f:\n+                return apart(fc, x=x, full=full, **_options)\n+            raise NotImplementedError(\n+                \"multivariate partial fraction decomposition\")\n \n-    terms = S.Zero\n \n-    for term in Add.make_args(partial):\n-        if term.has(RootSum):\n-            terms += term\n+    if P.is_multivariate:\n+        # Check if the expression is univariate in the target variable x\n+        # even though it contains other symbolic parameters\n+        if x is not None:\n+            # Get all variables except the target variable x\n+            other_vars = P.free_symbols - {x}\n+            # If there are symbolic parameters but the expression is still\n+            # a rational function in x, we can proceed with decomposition\n+            if other_vars and all(not P.has_free(var) or var in P.coeffs() for var in other_vars):\n+                # Expression has symbolic parameters but is univariate in x\n+                pass  # Continue to univariate decomposition logic\n+            else:\n+                fc = f.cancel()\n+                if fc != f:\n+                    return apart(fc, x=x, full=full, **_options)\n+                raise NotImplementedError(\n+                    \"multivariate partial fraction decomposition\")\n         else:\n-            terms += factor(term)\n+            fc = f.cancel()\n+            if fc != f:\n+                return apart(fc, x=x, full=full, **_options)\n+            raise NotImplementedError(\n+                \"multivariate partial fraction decomposition\")\n \n-    return common*(poly.as_expr() + terms)\n \n \n def apart_undetermined_coeffs(P, Q):\n@@ -164,7 +223,13 @@ def apart_undetermined_coeffs(P, Q):\n             partial.append((coeffs, q, f, i))\n             symbols.extend(coeffs)\n \n-    dom = Q.get_domain().inject(*symbols)\n+    # Handle symbolic parameters in the domain\n+    extra_symbols = (P.free_symbols | Q.free_symbols) - {Q.gen}\n+    dom = Q.get_domain()\n+    if extra_symbols:\n+        dom = dom.inject(*extra_symbols)\n+    dom = dom.inject(*symbols)\n+    \n     F = Poly(0, Q.gen, domain=dom)\n \n     for i, (coeffs, q, f, k) in enumerate(partial):\n"
  }
}