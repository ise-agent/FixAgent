{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/scikit-learn/sklearn/preprocessing/_encoders.py lines 108-115)": "\n                else:\n                    # Set the problematic rows to an acceptable value and\n                    # continue `The rows are marked `X_mask` and will be\n                    # removed later.\n                    X_mask[:, i] = valid_mask\n                    Xi = Xi.copy()\n                    \n                    # Check if we have a string dtype and if replacement string fits\n                    if (np.issubdtype(Xi.dtype, np.str_) or np.issubdtype(Xi.dtype, np.unicode_)):\n                        replacement_str = self.categories_[i][0]\n                        # Check if replacement string is too long for current dtype\n                        if hasattr(Xi.dtype, 'itemsize') and len(str(replacement_str)) * Xi.dtype.itemsize // Xi.dtype.itemsize > Xi.dtype.itemsize:\n                            # Convert to object dtype to avoid truncation\n                            Xi = Xi.astype(object)\n                    \n                    Xi[~valid_mask] = self.categories_[i][0]\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/scikit-learn/sklearn/preprocessing/_encoders.py lines 108-115)": [
      "\n            else:\n                # Set the problematic rows to an acceptable value and\n                # continue `The rows are marked `X_mask` and will be\n                # removed later.\n                X_mask[:, i] = valid_mask\n                Xi = Xi.copy()\n                \n                # Check if we have a string dtype and if replacement string fits\n                if (np.issubdtype(Xi.dtype, np.str_) or np.issubdtype(Xi.dtype, np.unicode_)):\n                    replacement_str = self.categories_[i][0]\n                    # Check if replacement string fits in current dtype\n                    if hasattr(Xi.dtype, 'itemsize') and Xi.dtype.itemsize > 0:\n                        max_len = Xi.dtype.itemsize // 4 if Xi.dtype.kind == 'U' else Xi.dtype.itemsize\n                        if len(str(replacement_str)) > max_len:\n                            # Convert to object dtype to avoid truncation\n                            Xi = Xi.astype(object)\n                \n                Xi[~valid_mask] = self.categories_[i][0]\n",
      "\n        else:\n            # Set the problematic rows to an acceptable value and\n            # continue `The rows are marked `X_mask` and will be\n            # removed later.\n            X_mask[:, i] = valid_mask\n            Xi = Xi.copy()\n            \n            # Check if we have a string dtype and if replacement string fits\n            if (np.issubdtype(Xi.dtype, np.str_) or np.issubdtype(Xi.dtype, np.unicode_)):\n                replacement_str = self.categories_[i][0]\n                # Check if replacement string fits in current dtype\n                if hasattr(Xi.dtype, 'itemsize') and Xi.dtype.itemsize > 0:\n                    max_len = Xi.dtype.itemsize // 4 if Xi.dtype.kind == 'U' else Xi.dtype.itemsize\n                    if len(str(replacement_str)) > max_len:\n                        # Convert to object dtype to avoid truncation\n                        Xi = Xi.astype(object)\n            \n            Xi[~valid_mask] = self.categories_[i][0]\n",
      "\n        else:\n            # Set the problematic rows to an acceptable value and\n            # continue `The rows are marked `X_mask` and will be\n            # removed later.\n            X_mask[:, i] = valid_mask\n            Xi = Xi.copy()\n            \n            # Check if we have a string dtype and if replacement string fits\n            if (np.issubdtype(Xi.dtype, np.str_) or np.issubdtype(Xi.dtype, np.unicode_)):\n                replacement_str = self.categories_[i][0]\n                # Get the maximum string length that fits in current dtype\n                if hasattr(Xi.dtype, 'itemsize'):\n                    max_len = Xi.dtype.itemsize // 4 if Xi.dtype.kind == 'U' else Xi.dtype.itemsize\n                    if len(str(replacement_str)) > max_len:\n                        # Convert to object dtype to avoid truncation\n                        Xi = Xi.astype(object)\n            \n            Xi[~valid_mask] = self.categories_[i][0]\n",
      "\n                else:\n                    # Set the problematic rows to an acceptable value and\n                    # continue `The rows are marked `X_mask` and will be\n                    # removed later.\n                    X_mask[:, i] = valid_mask\n                    Xi = Xi.copy()\n                    \n                    # Check if we have a string dtype and if replacement string fits\n                    if (np.issubdtype(Xi.dtype, np.str_) or np.issubdtype(Xi.dtype, np.unicode_)):\n                        replacement_str = self.categories_[i][0]\n                        # Check if replacement string fits in current dtype\n                        max_len = Xi.dtype.itemsize // 4 if np.issubdtype(Xi.dtype, np.unicode_) else Xi.dtype.itemsize\n                        if len(str(replacement_str)) > max_len:\n                            # Convert to object dtype to avoid truncation\n                            Xi = Xi.astype(object)\n                    \n                    Xi[~valid_mask] = self.categories_[i][0]\n",
      "\n            else:\n                # Set the problematic rows to an acceptable value and\n                # continue `The rows are marked `X_mask` and will be\n                # removed later.\n                X_mask[:, i] = valid_mask\n                Xi = Xi.copy()\n                \n                # Check if we have a string dtype and if replacement string fits\n                if (np.issubdtype(Xi.dtype, np.str_) or np.issubdtype(Xi.dtype, np.unicode_)):\n                    replacement_str = self.categories_[i][0]\n                    # Check if replacement string fits in current dtype\n                    if len(str(replacement_str)) * Xi.dtype.itemsize // Xi.dtype.itemsize > Xi.dtype.itemsize // 4:\n                        # Convert to object dtype to avoid truncation\n                        Xi = Xi.astype(object)\n                \n                Xi[~valid_mask] = self.categories_[i][0]\n",
      "\n                else:\n                    # Set the problematic rows to an acceptable value and\n                    # continue `The rows are marked `X_mask` and will be\n                    # removed later.\n                    X_mask[:, i] = valid_mask\n                    Xi = Xi.copy()\n                    \n                    # Check if we have a string dtype and if replacement string fits\n                    if (np.issubdtype(Xi.dtype, np.str_) or np.issubdtype(Xi.dtype, np.unicode_)):\n                        replacement_str = self.categories_[i][0]\n                        # Check if replacement string fits in current dtype\n                        if hasattr(Xi.dtype, 'itemsize') and len(str(replacement_str)) * Xi.dtype.itemsize // Xi.dtype.itemsize > Xi.dtype.itemsize // Xi.dtype.itemsize:\n                            # Convert to object dtype to avoid truncation\n                            Xi = Xi.astype(object)\n                    \n                    Xi[~valid_mask] = self.categories_[i][0]\n",
      "\n                else:\n                    # Set the problematic rows to an acceptable value and\n                    # continue `The rows are marked `X_mask` and will be\n                    # removed later.\n                    X_mask[:, i] = valid_mask\n                    Xi = Xi.copy()\n                    \n                    # Check if we have a string dtype and if replacement string fits\n                    if (np.issubdtype(Xi.dtype, np.str_) or np.issubdtype(Xi.dtype, np.unicode_)):\n                        replacement_str = self.categories_[i][0]\n                        # Check if replacement string fits in current dtype\n                        if hasattr(Xi.dtype, 'itemsize') and len(str(replacement_str)) * Xi.dtype.itemsize // Xi.dtype.itemsize > Xi.dtype.itemsize // 4:\n                            # Convert to object dtype to avoid truncation\n                            Xi = Xi.astype(object)\n                    \n                    Xi[~valid_mask] = self.categories_[i][0]\n",
      "\n            else:\n                # Set the problematic rows to an acceptable value and\n                # continue `The rows are marked `X_mask` and will be\n                # removed later.\n                X_mask[:, i] = valid_mask\n                Xi = Xi.copy()\n                \n                # Check if we have a string dtype and if replacement string fits\n                if (np.issubdtype(Xi.dtype, np.str_) or np.issubdtype(Xi.dtype, np.unicode_)):\n                    replacement_str = self.categories_[i][0]\n                    # Check if replacement string fits in current dtype\n                    if len(str(replacement_str)) * Xi.dtype.itemsize // Xi.itemsize > Xi.dtype.itemsize:\n                        # Convert to object dtype to avoid truncation\n                        Xi = Xi.astype(object)\n                \n                Xi[~valid_mask] = self.categories_[i][0]\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sklearn/preprocessing/_encoders.py b/sklearn/preprocessing/_encoders.py\nindex 1e05aba59..111afcd89 100644\n--- a/sklearn/preprocessing/_encoders.py\n+++ b/sklearn/preprocessing/_encoders.py\n@@ -105,12 +105,27 @@ class _BaseEncoder(BaseEstimator, TransformerMixin):\n                     msg = (\"Found unknown categories {0} in column {1}\"\n                            \" during transform\".format(diff, i))\n                     raise ValueError(msg)\n+\n                 else:\n                     # Set the problematic rows to an acceptable value and\n                     # continue `The rows are marked `X_mask` and will be\n                     # removed later.\n                     X_mask[:, i] = valid_mask\n                     Xi = Xi.copy()\n+                    \n+                    # Check if we have a string dtype and if replacement string fits\n+                    if (np.issubdtype(Xi.dtype, np.str_) or np.issubdtype(Xi.dtype, np.unicode_)):\n+                        replacement_str = str(self.categories_[i][0])\n+                        # Get the maximum string length the current dtype can hold\n+                        if hasattr(Xi.dtype, 'itemsize'):\n+                            max_str_len = Xi.dtype.itemsize // 4  # For unicode strings\n+                            if Xi.dtype.char == 'S':  # For byte strings\n+                                max_str_len = Xi.dtype.itemsize\n+                            # Check if replacement string fits in current dtype\n+                            if len(replacement_str) > max_str_len:\n+                                # Convert to object dtype to avoid truncation\n+                                Xi = Xi.astype(object)\n+                    \n                     Xi[~valid_mask] = self.categories_[i][0]\n             _, encoded = _encode(Xi, self.categories_[i], encode=True)\n             X_int[:, i] = encoded\n",
    "variant_0": "diff --git a/sklearn/preprocessing/_encoders.py b/sklearn/preprocessing/_encoders.py\nindex 1e05aba59..99cef2735 100644\n--- a/sklearn/preprocessing/_encoders.py\n+++ b/sklearn/preprocessing/_encoders.py\n@@ -105,14 +105,23 @@ class _BaseEncoder(BaseEstimator, TransformerMixin):\n                     msg = (\"Found unknown categories {0} in column {1}\"\n                            \" during transform\".format(diff, i))\n                     raise ValueError(msg)\n+\n                 else:\n                     # Set the problematic rows to an acceptable value and\n                     # continue `The rows are marked `X_mask` and will be\n                     # removed later.\n                     X_mask[:, i] = valid_mask\n                     Xi = Xi.copy()\n+                    \n+                    # Check if we have a string dtype and if replacement string fits\n+                    if (np.issubdtype(Xi.dtype, np.str_) or np.issubdtype(Xi.dtype, np.unicode_)):\n+                        replacement_str = self.categories_[i][0]\n+                        # Check if replacement string is too long for current dtype\n+                        if hasattr(Xi.dtype, 'itemsize') and len(str(replacement_str)) * Xi.dtype.itemsize // Xi.dtype.itemsize > Xi.dtype.itemsize:\n+                            # Convert to object dtype to avoid truncation\n+                            Xi = Xi.astype(object)\n+                    \n                     Xi[~valid_mask] = self.categories_[i][0]\n-            _, encoded = _encode(Xi, self.categories_[i], encode=True)\n             X_int[:, i] = encoded\n \n         return X_int, X_mask\n",
    "variant_1": "diff --git a/sklearn/preprocessing/_encoders.py b/sklearn/preprocessing/_encoders.py\nindex 1e05aba59..b76f843d6 100644\n--- a/sklearn/preprocessing/_encoders.py\n+++ b/sklearn/preprocessing/_encoders.py\n@@ -105,14 +105,25 @@ class _BaseEncoder(BaseEstimator, TransformerMixin):\n                     msg = (\"Found unknown categories {0} in column {1}\"\n                            \" during transform\".format(diff, i))\n                     raise ValueError(msg)\n-                else:\n-                    # Set the problematic rows to an acceptable value and\n-                    # continue `The rows are marked `X_mask` and will be\n-                    # removed later.\n-                    X_mask[:, i] = valid_mask\n-                    Xi = Xi.copy()\n-                    Xi[~valid_mask] = self.categories_[i][0]\n-            _, encoded = _encode(Xi, self.categories_[i], encode=True)\n+\n+            else:\n+                # Set the problematic rows to an acceptable value and\n+                # continue `The rows are marked `X_mask` and will be\n+                # removed later.\n+                X_mask[:, i] = valid_mask\n+                Xi = Xi.copy()\n+                \n+                # Check if we have a string dtype and if replacement string fits\n+                if (np.issubdtype(Xi.dtype, np.str_) or np.issubdtype(Xi.dtype, np.unicode_)):\n+                    replacement_str = self.categories_[i][0]\n+                    # Check if replacement string fits in current dtype\n+                    if hasattr(Xi.dtype, 'itemsize') and Xi.dtype.itemsize > 0:\n+                        max_len = Xi.dtype.itemsize // 4 if Xi.dtype.kind == 'U' else Xi.dtype.itemsize\n+                        if len(str(replacement_str)) > max_len:\n+                            # Convert to object dtype to avoid truncation\n+                            Xi = Xi.astype(object)\n+                \n+                Xi[~valid_mask] = self.categories_[i][0]\n             X_int[:, i] = encoded\n \n         return X_int, X_mask\n",
    "variant_2": "diff --git a/sklearn/preprocessing/_encoders.py b/sklearn/preprocessing/_encoders.py\nindex 1e05aba59..9c15081c0 100644\n--- a/sklearn/preprocessing/_encoders.py\n+++ b/sklearn/preprocessing/_encoders.py\n@@ -105,14 +105,25 @@ class _BaseEncoder(BaseEstimator, TransformerMixin):\n                     msg = (\"Found unknown categories {0} in column {1}\"\n                            \" during transform\".format(diff, i))\n                     raise ValueError(msg)\n-                else:\n-                    # Set the problematic rows to an acceptable value and\n-                    # continue `The rows are marked `X_mask` and will be\n-                    # removed later.\n-                    X_mask[:, i] = valid_mask\n-                    Xi = Xi.copy()\n-                    Xi[~valid_mask] = self.categories_[i][0]\n-            _, encoded = _encode(Xi, self.categories_[i], encode=True)\n+\n+        else:\n+            # Set the problematic rows to an acceptable value and\n+            # continue `The rows are marked `X_mask` and will be\n+            # removed later.\n+            X_mask[:, i] = valid_mask\n+            Xi = Xi.copy()\n+            \n+            # Check if we have a string dtype and if replacement string fits\n+            if (np.issubdtype(Xi.dtype, np.str_) or np.issubdtype(Xi.dtype, np.unicode_)):\n+                replacement_str = self.categories_[i][0]\n+                # Check if replacement string fits in current dtype\n+                if hasattr(Xi.dtype, 'itemsize') and Xi.dtype.itemsize > 0:\n+                    max_len = Xi.dtype.itemsize // 4 if Xi.dtype.kind == 'U' else Xi.dtype.itemsize\n+                    if len(str(replacement_str)) > max_len:\n+                        # Convert to object dtype to avoid truncation\n+                        Xi = Xi.astype(object)\n+            \n+            Xi[~valid_mask] = self.categories_[i][0]\n             X_int[:, i] = encoded\n \n         return X_int, X_mask\n",
    "variant_3": "diff --git a/sklearn/preprocessing/_encoders.py b/sklearn/preprocessing/_encoders.py\nindex 1e05aba59..d9244000d 100644\n--- a/sklearn/preprocessing/_encoders.py\n+++ b/sklearn/preprocessing/_encoders.py\n@@ -105,14 +105,25 @@ class _BaseEncoder(BaseEstimator, TransformerMixin):\n                     msg = (\"Found unknown categories {0} in column {1}\"\n                            \" during transform\".format(diff, i))\n                     raise ValueError(msg)\n-                else:\n-                    # Set the problematic rows to an acceptable value and\n-                    # continue `The rows are marked `X_mask` and will be\n-                    # removed later.\n-                    X_mask[:, i] = valid_mask\n-                    Xi = Xi.copy()\n-                    Xi[~valid_mask] = self.categories_[i][0]\n-            _, encoded = _encode(Xi, self.categories_[i], encode=True)\n+\n+        else:\n+            # Set the problematic rows to an acceptable value and\n+            # continue `The rows are marked `X_mask` and will be\n+            # removed later.\n+            X_mask[:, i] = valid_mask\n+            Xi = Xi.copy()\n+            \n+            # Check if we have a string dtype and if replacement string fits\n+            if (np.issubdtype(Xi.dtype, np.str_) or np.issubdtype(Xi.dtype, np.unicode_)):\n+                replacement_str = self.categories_[i][0]\n+                # Get the maximum string length that fits in current dtype\n+                if hasattr(Xi.dtype, 'itemsize'):\n+                    max_len = Xi.dtype.itemsize // 4 if Xi.dtype.kind == 'U' else Xi.dtype.itemsize\n+                    if len(str(replacement_str)) > max_len:\n+                        # Convert to object dtype to avoid truncation\n+                        Xi = Xi.astype(object)\n+            \n+            Xi[~valid_mask] = self.categories_[i][0]\n             X_int[:, i] = encoded\n \n         return X_int, X_mask\n",
    "variant_4": "diff --git a/sklearn/preprocessing/_encoders.py b/sklearn/preprocessing/_encoders.py\nindex 1e05aba59..1a3b75c18 100644\n--- a/sklearn/preprocessing/_encoders.py\n+++ b/sklearn/preprocessing/_encoders.py\n@@ -105,14 +105,24 @@ class _BaseEncoder(BaseEstimator, TransformerMixin):\n                     msg = (\"Found unknown categories {0} in column {1}\"\n                            \" during transform\".format(diff, i))\n                     raise ValueError(msg)\n+\n                 else:\n                     # Set the problematic rows to an acceptable value and\n                     # continue `The rows are marked `X_mask` and will be\n                     # removed later.\n                     X_mask[:, i] = valid_mask\n                     Xi = Xi.copy()\n+                    \n+                    # Check if we have a string dtype and if replacement string fits\n+                    if (np.issubdtype(Xi.dtype, np.str_) or np.issubdtype(Xi.dtype, np.unicode_)):\n+                        replacement_str = self.categories_[i][0]\n+                        # Check if replacement string fits in current dtype\n+                        max_len = Xi.dtype.itemsize // 4 if np.issubdtype(Xi.dtype, np.unicode_) else Xi.dtype.itemsize\n+                        if len(str(replacement_str)) > max_len:\n+                            # Convert to object dtype to avoid truncation\n+                            Xi = Xi.astype(object)\n+                    \n                     Xi[~valid_mask] = self.categories_[i][0]\n-            _, encoded = _encode(Xi, self.categories_[i], encode=True)\n             X_int[:, i] = encoded\n \n         return X_int, X_mask\n",
    "variant_5": "diff --git a/sklearn/preprocessing/_encoders.py b/sklearn/preprocessing/_encoders.py\nindex 1e05aba59..069d9e27e 100644\n--- a/sklearn/preprocessing/_encoders.py\n+++ b/sklearn/preprocessing/_encoders.py\n@@ -105,14 +105,23 @@ class _BaseEncoder(BaseEstimator, TransformerMixin):\n                     msg = (\"Found unknown categories {0} in column {1}\"\n                            \" during transform\".format(diff, i))\n                     raise ValueError(msg)\n-                else:\n-                    # Set the problematic rows to an acceptable value and\n-                    # continue `The rows are marked `X_mask` and will be\n-                    # removed later.\n-                    X_mask[:, i] = valid_mask\n-                    Xi = Xi.copy()\n-                    Xi[~valid_mask] = self.categories_[i][0]\n-            _, encoded = _encode(Xi, self.categories_[i], encode=True)\n+\n+            else:\n+                # Set the problematic rows to an acceptable value and\n+                # continue `The rows are marked `X_mask` and will be\n+                # removed later.\n+                X_mask[:, i] = valid_mask\n+                Xi = Xi.copy()\n+                \n+                # Check if we have a string dtype and if replacement string fits\n+                if (np.issubdtype(Xi.dtype, np.str_) or np.issubdtype(Xi.dtype, np.unicode_)):\n+                    replacement_str = self.categories_[i][0]\n+                    # Check if replacement string fits in current dtype\n+                    if len(str(replacement_str)) * Xi.dtype.itemsize // Xi.dtype.itemsize > Xi.dtype.itemsize // 4:\n+                        # Convert to object dtype to avoid truncation\n+                        Xi = Xi.astype(object)\n+                \n+                Xi[~valid_mask] = self.categories_[i][0]\n             X_int[:, i] = encoded\n \n         return X_int, X_mask\n",
    "variant_6": "diff --git a/sklearn/preprocessing/_encoders.py b/sklearn/preprocessing/_encoders.py\nindex 1e05aba59..1422af026 100644\n--- a/sklearn/preprocessing/_encoders.py\n+++ b/sklearn/preprocessing/_encoders.py\n@@ -105,14 +105,23 @@ class _BaseEncoder(BaseEstimator, TransformerMixin):\n                     msg = (\"Found unknown categories {0} in column {1}\"\n                            \" during transform\".format(diff, i))\n                     raise ValueError(msg)\n+\n                 else:\n                     # Set the problematic rows to an acceptable value and\n                     # continue `The rows are marked `X_mask` and will be\n                     # removed later.\n                     X_mask[:, i] = valid_mask\n                     Xi = Xi.copy()\n+                    \n+                    # Check if we have a string dtype and if replacement string fits\n+                    if (np.issubdtype(Xi.dtype, np.str_) or np.issubdtype(Xi.dtype, np.unicode_)):\n+                        replacement_str = self.categories_[i][0]\n+                        # Check if replacement string fits in current dtype\n+                        if hasattr(Xi.dtype, 'itemsize') and len(str(replacement_str)) * Xi.dtype.itemsize // Xi.dtype.itemsize > Xi.dtype.itemsize // Xi.dtype.itemsize:\n+                            # Convert to object dtype to avoid truncation\n+                            Xi = Xi.astype(object)\n+                    \n                     Xi[~valid_mask] = self.categories_[i][0]\n-            _, encoded = _encode(Xi, self.categories_[i], encode=True)\n             X_int[:, i] = encoded\n \n         return X_int, X_mask\n",
    "variant_7": "diff --git a/sklearn/preprocessing/_encoders.py b/sklearn/preprocessing/_encoders.py\nindex 1e05aba59..b91d31646 100644\n--- a/sklearn/preprocessing/_encoders.py\n+++ b/sklearn/preprocessing/_encoders.py\n@@ -105,14 +105,23 @@ class _BaseEncoder(BaseEstimator, TransformerMixin):\n                     msg = (\"Found unknown categories {0} in column {1}\"\n                            \" during transform\".format(diff, i))\n                     raise ValueError(msg)\n+\n                 else:\n                     # Set the problematic rows to an acceptable value and\n                     # continue `The rows are marked `X_mask` and will be\n                     # removed later.\n                     X_mask[:, i] = valid_mask\n                     Xi = Xi.copy()\n+                    \n+                    # Check if we have a string dtype and if replacement string fits\n+                    if (np.issubdtype(Xi.dtype, np.str_) or np.issubdtype(Xi.dtype, np.unicode_)):\n+                        replacement_str = self.categories_[i][0]\n+                        # Check if replacement string fits in current dtype\n+                        if hasattr(Xi.dtype, 'itemsize') and len(str(replacement_str)) * Xi.dtype.itemsize // Xi.dtype.itemsize > Xi.dtype.itemsize // 4:\n+                            # Convert to object dtype to avoid truncation\n+                            Xi = Xi.astype(object)\n+                    \n                     Xi[~valid_mask] = self.categories_[i][0]\n-            _, encoded = _encode(Xi, self.categories_[i], encode=True)\n             X_int[:, i] = encoded\n \n         return X_int, X_mask\n",
    "variant_8": "diff --git a/sklearn/preprocessing/_encoders.py b/sklearn/preprocessing/_encoders.py\nindex 1e05aba59..8979f078c 100644\n--- a/sklearn/preprocessing/_encoders.py\n+++ b/sklearn/preprocessing/_encoders.py\n@@ -105,14 +105,23 @@ class _BaseEncoder(BaseEstimator, TransformerMixin):\n                     msg = (\"Found unknown categories {0} in column {1}\"\n                            \" during transform\".format(diff, i))\n                     raise ValueError(msg)\n-                else:\n-                    # Set the problematic rows to an acceptable value and\n-                    # continue `The rows are marked `X_mask` and will be\n-                    # removed later.\n-                    X_mask[:, i] = valid_mask\n-                    Xi = Xi.copy()\n-                    Xi[~valid_mask] = self.categories_[i][0]\n-            _, encoded = _encode(Xi, self.categories_[i], encode=True)\n+\n+            else:\n+                # Set the problematic rows to an acceptable value and\n+                # continue `The rows are marked `X_mask` and will be\n+                # removed later.\n+                X_mask[:, i] = valid_mask\n+                Xi = Xi.copy()\n+                \n+                # Check if we have a string dtype and if replacement string fits\n+                if (np.issubdtype(Xi.dtype, np.str_) or np.issubdtype(Xi.dtype, np.unicode_)):\n+                    replacement_str = self.categories_[i][0]\n+                    # Check if replacement string fits in current dtype\n+                    if len(str(replacement_str)) * Xi.dtype.itemsize // Xi.itemsize > Xi.dtype.itemsize:\n+                        # Convert to object dtype to avoid truncation\n+                        Xi = Xi.astype(object)\n+                \n+                Xi[~valid_mask] = self.categories_[i][0]\n             X_int[:, i] = encoded\n \n         return X_int, X_mask\n"
  }
}