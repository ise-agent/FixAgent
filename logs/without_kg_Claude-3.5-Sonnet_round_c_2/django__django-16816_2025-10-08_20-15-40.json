{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/django/django/contrib/admin/checks.py lines 896-897)": "\ndef _check_list_display_item(self, obj, item, label):\n    if callable(item):\n        return []\n    elif hasattr(obj, item):\n        # Verify the attribute will be accessible at runtime\n        try:\n            getattr(obj, item)\n            return []\n        except AttributeError:\n            # If we can't get the attribute, continue to the error case\n            pass\n    try:\n        field = obj.model._meta.get_field(item)\n    except FieldDoesNotExist:\n        try:\n            field = getattr(obj.model, item)\n        except AttributeError:\n            return [\n                checks.Error(\n                    \"The value of '%s' refers to '%s', which is not a \"\n                    \"callable, an attribute of '%s', or an attribute or \"\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/django/django/contrib/admin/checks.py lines 896-897)": [
      "\ndef _check_list_display_item(self, obj, item, label):\n    if callable(item):\n        return []\n    elif hasattr(obj, item):\n        # Verify the attribute is actually accessible to match runtime behavior\n        try:\n            getattr(obj, item)\n            return []\n        except AttributeError:\n            # If we can't access it, fall through to the field/model checks\n            pass\n    try:\n        field = obj.model._meta.get_field(item)\n    except FieldDoesNotExist:\n        try:\n            field = getattr(obj.model, item)\n        except AttributeError:\n            return [\n                checks.Error(\n                    \"The value of '%s' refers to '%s', which is not a \"\n                    \"callable, an attribute of '%s', or an attribute or \"\n",
      "\ndef _check_list_display_item(self, obj, item, label):\n    if callable(item):\n        return []\n    elif hasattr(obj, item):\n        # Verify the attribute is actually accessible to match runtime behavior\n        try:\n            getattr(obj, item)\n            return []\n        except AttributeError:\n            # If we can't access the attribute, fall through to field checks\n            pass\n    try:\n        field = obj.model._meta.get_field(item)\n    except FieldDoesNotExist:\n        try:\n            field = getattr(obj.model, item)\n        except AttributeError:\n            return [\n                checks.Error(\n                    \"The value of '%s' refers to '%s', which is not a \"\n                    \"callable, an attribute of '%s', or an attribute or \"\n                    \"method on '%s.%s'.\" % (\n                        label, item, obj.__class__.__name__,\n                        obj.model._meta.app_label, obj.model._meta.object_name,\n                    ),\n                    obj=obj.__class__,\n                    id='admin.E108',\n                )\n            ]\n    if isinstance(field, models.ManyToManyField):\n        return [\n            checks.Error(\n                \"The value of '%s' must not be a ManyToManyField.\" % label,\n                obj=obj.__class__,\n                id='admin.E109',\n            )\n        ]\n    return []\n",
      "\ndef _check_list_display_item(self, obj, item, label):\n    if callable(item):\n        return []\n    elif hasattr(obj, item):\n        # Verify the attribute is actually accessible to match runtime behavior\n        try:\n            getattr(obj, item)\n            return []\n        except AttributeError:\n            # If we can't access the attribute, fall through to field checking\n            pass\n    try:\n        field = obj.model._meta.get_field(item)\n    except FieldDoesNotExist:\n        try:\n            field = getattr(obj.model, item)\n        except AttributeError:\n            return [\n                checks.Error(\n                    \"The value of '%s' refers to '%s', which is not a \"\n                    \"callable, an attribute of '%s', or an attribute or \"\n",
      "\ndef _check_list_display_item(self, obj, item, label):\n    if callable(item):\n        return []\n    elif hasattr(obj, item):\n        # Verify the attribute is actually accessible to match runtime behavior\n        try:\n            getattr(obj, item)\n            return []\n        except AttributeError:\n            # If we can't access the attribute, continue to model field checks\n            pass\n    try:\n        field = obj.model._meta.get_field(item)\n    except FieldDoesNotExist:\n        try:\n            field = getattr(obj.model, item)\n        except AttributeError:\n            return [\n                checks.Error(\n                    \"The value of '%s' refers to '%s', which is not a \"\n                    \"callable, an attribute of '%s', or an attribute or \"\n",
      "\ndef _check_list_display_item(self, obj, item, label):\n    if callable(item):\n        return []\n    elif hasattr(obj, item):\n        # Verify the attribute is actually accessible to match runtime behavior\n        try:\n            getattr(obj, item)\n            return []\n        except AttributeError:\n            # Continue to field/model attribute checks below\n            pass\n    try:\n        field = obj.model._meta.get_field(item)\n    except FieldDoesNotExist:\n        try:\n            field = getattr(obj.model, item)\n        except AttributeError:\n            return [\n                checks.Error(\n                    \"The value of '%s' refers to '%s', which is not a \"\n                    \"callable, an attribute of '%s', or an attribute or \"\n",
      "\ndef _check_list_display_item(self, obj, item, label):\n    if callable(item):\n        return []\n    elif hasattr(obj, item):\n        # Verify the attribute is actually accessible to match runtime behavior\n        try:\n            getattr(obj, item)\n            return []\n        except AttributeError:\n            # Continue to field/model attribute checks if admin attribute is not accessible\n            pass\n    try:\n        field = obj.model._meta.get_field(item)\n    except FieldDoesNotExist:\n        try:\n            field = getattr(obj.model, item)\n        except AttributeError:\n            return [\n                checks.Error(\n                    \"The value of '%s' refers to '%s', which is not a \"\n                    \"callable, an attribute of '%s', or an attribute or \"\n",
      "\ndef _check_list_display_item(self, obj, item, label):\n    if callable(item):\n        return []\n    elif hasattr(obj, item):\n        # Verify the attribute is actually accessible to match runtime behavior\n        try:\n            getattr(obj, item)\n            return []\n        except AttributeError:\n            # If we can't access the attribute, fall through to field checks\n            pass\n    try:\n        field = obj.model._meta.get_field(item)\n    except FieldDoesNotExist:\n        try:\n            field = getattr(obj.model, item)\n        except AttributeError:\n            return [\n                checks.Error(\n                    \"The value of '%s' refers to '%s', which is not a \"\n                    \"callable, an attribute of '%s', or an attribute or \"\n",
      "\ndef _check_list_display_item(self, obj, item, label):\n    if callable(item):\n        return []\n    elif hasattr(obj, item):\n        # Verify the attribute is actually accessible to match runtime behavior\n        try:\n            getattr(obj, item)\n            return []\n        except AttributeError:\n            # If we can't access the attribute, fall through to field checks\n            pass\n    try:\n        field = obj.model._meta.get_field(item)\n    except FieldDoesNotExist:\n        try:\n            field = getattr(obj.model, item)\n        except AttributeError:\n            return [\n                checks.Error(\n                    \"The value of '%s' refers to '%s', which is not a \"\n                    \"callable, an attribute of '%s', or an attribute or \"\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/contrib/admin/checks.py b/django/contrib/admin/checks.py\nindex 0fefe65e48..6dea3fc8be 100644\n--- a/django/contrib/admin/checks.py\n+++ b/django/contrib/admin/checks.py\n@@ -893,8 +893,20 @@ class ModelAdminChecks(BaseModelAdminChecks):\n     def _check_list_display_item(self, obj, item, label):\n         if callable(item):\n             return []\n+\n         elif hasattr(obj, item):\n-            return []\n+            # Verify the attribute will be accessible and usable at runtime\n+            try:\n+                attr = getattr(obj, item)\n+                # Check if the attribute is actually valid for list_display\n+                # This matches the runtime logic in label_for_field()\n+                if callable(attr) or hasattr(attr, 'short_description') or isinstance(attr, property):\n+                    return []\n+                # If admin has the attribute but it's not usable for display,\n+                # continue to the error case below\n+            except AttributeError:\n+                # If we can't get the attribute, continue to the error case\n+                pass\n         try:\n             field = obj.model._meta.get_field(item)\n         except FieldDoesNotExist:\n",
    "variant_0": "diff --git a/django/contrib/admin/checks.py b/django/contrib/admin/checks.py\nindex 0fefe65e48..735619c20e 100644\n--- a/django/contrib/admin/checks.py\n+++ b/django/contrib/admin/checks.py\n@@ -893,8 +893,28 @@ class ModelAdminChecks(BaseModelAdminChecks):\n     def _check_list_display_item(self, obj, item, label):\n         if callable(item):\n             return []\n-        elif hasattr(obj, item):\n+\n+def _check_list_display_item(self, obj, item, label):\n+    if callable(item):\n+        return []\n+    elif hasattr(obj, item):\n+        # Verify the attribute will be accessible at runtime\n+        try:\n+            getattr(obj, item)\n             return []\n+        except AttributeError:\n+            # If we can't get the attribute, continue to the error case\n+            pass\n+    try:\n+        field = obj.model._meta.get_field(item)\n+    except FieldDoesNotExist:\n+        try:\n+            field = getattr(obj.model, item)\n+        except AttributeError:\n+            return [\n+                checks.Error(\n+                    \"The value of '%s' refers to '%s', which is not a \"\n+                    \"callable, an attribute of '%s', or an attribute or \"\n         try:\n             field = obj.model._meta.get_field(item)\n         except FieldDoesNotExist:\n",
    "variant_1": "diff --git a/django/contrib/admin/checks.py b/django/contrib/admin/checks.py\nindex 0fefe65e48..6ee8a5b912 100644\n--- a/django/contrib/admin/checks.py\n+++ b/django/contrib/admin/checks.py\n@@ -893,8 +893,28 @@ class ModelAdminChecks(BaseModelAdminChecks):\n     def _check_list_display_item(self, obj, item, label):\n         if callable(item):\n             return []\n-        elif hasattr(obj, item):\n+\n+def _check_list_display_item(self, obj, item, label):\n+    if callable(item):\n+        return []\n+    elif hasattr(obj, item):\n+        # Verify the attribute is actually accessible to match runtime behavior\n+        try:\n+            getattr(obj, item)\n             return []\n+        except AttributeError:\n+            # If we can't access it, fall through to the field/model checks\n+            pass\n+    try:\n+        field = obj.model._meta.get_field(item)\n+    except FieldDoesNotExist:\n+        try:\n+            field = getattr(obj.model, item)\n+        except AttributeError:\n+            return [\n+                checks.Error(\n+                    \"The value of '%s' refers to '%s', which is not a \"\n+                    \"callable, an attribute of '%s', or an attribute or \"\n         try:\n             field = obj.model._meta.get_field(item)\n         except FieldDoesNotExist:\n",
    "variant_2": "diff --git a/django/contrib/admin/checks.py b/django/contrib/admin/checks.py\nindex 0fefe65e48..78b3abd352 100644\n--- a/django/contrib/admin/checks.py\n+++ b/django/contrib/admin/checks.py\n@@ -893,8 +893,45 @@ class ModelAdminChecks(BaseModelAdminChecks):\n     def _check_list_display_item(self, obj, item, label):\n         if callable(item):\n             return []\n-        elif hasattr(obj, item):\n+\n+def _check_list_display_item(self, obj, item, label):\n+    if callable(item):\n+        return []\n+    elif hasattr(obj, item):\n+        # Verify the attribute is actually accessible to match runtime behavior\n+        try:\n+            getattr(obj, item)\n             return []\n+        except AttributeError:\n+            # If we can't access the attribute, fall through to field checks\n+            pass\n+    try:\n+        field = obj.model._meta.get_field(item)\n+    except FieldDoesNotExist:\n+        try:\n+            field = getattr(obj.model, item)\n+        except AttributeError:\n+            return [\n+                checks.Error(\n+                    \"The value of '%s' refers to '%s', which is not a \"\n+                    \"callable, an attribute of '%s', or an attribute or \"\n+                    \"method on '%s.%s'.\" % (\n+                        label, item, obj.__class__.__name__,\n+                        obj.model._meta.app_label, obj.model._meta.object_name,\n+                    ),\n+                    obj=obj.__class__,\n+                    id='admin.E108',\n+                )\n+            ]\n+    if isinstance(field, models.ManyToManyField):\n+        return [\n+            checks.Error(\n+                \"The value of '%s' must not be a ManyToManyField.\" % label,\n+                obj=obj.__class__,\n+                id='admin.E109',\n+            )\n+        ]\n+    return []\n         try:\n             field = obj.model._meta.get_field(item)\n         except FieldDoesNotExist:\n",
    "variant_3": "diff --git a/django/contrib/admin/checks.py b/django/contrib/admin/checks.py\nindex 0fefe65e48..2650e8d6a3 100644\n--- a/django/contrib/admin/checks.py\n+++ b/django/contrib/admin/checks.py\n@@ -893,8 +893,28 @@ class ModelAdminChecks(BaseModelAdminChecks):\n     def _check_list_display_item(self, obj, item, label):\n         if callable(item):\n             return []\n-        elif hasattr(obj, item):\n+\n+def _check_list_display_item(self, obj, item, label):\n+    if callable(item):\n+        return []\n+    elif hasattr(obj, item):\n+        # Verify the attribute is actually accessible to match runtime behavior\n+        try:\n+            getattr(obj, item)\n             return []\n+        except AttributeError:\n+            # If we can't access the attribute, fall through to field checking\n+            pass\n+    try:\n+        field = obj.model._meta.get_field(item)\n+    except FieldDoesNotExist:\n+        try:\n+            field = getattr(obj.model, item)\n+        except AttributeError:\n+            return [\n+                checks.Error(\n+                    \"The value of '%s' refers to '%s', which is not a \"\n+                    \"callable, an attribute of '%s', or an attribute or \"\n         try:\n             field = obj.model._meta.get_field(item)\n         except FieldDoesNotExist:\n",
    "variant_4": "diff --git a/django/contrib/admin/checks.py b/django/contrib/admin/checks.py\nindex 0fefe65e48..5560d64753 100644\n--- a/django/contrib/admin/checks.py\n+++ b/django/contrib/admin/checks.py\n@@ -893,8 +893,28 @@ class ModelAdminChecks(BaseModelAdminChecks):\n     def _check_list_display_item(self, obj, item, label):\n         if callable(item):\n             return []\n-        elif hasattr(obj, item):\n+\n+def _check_list_display_item(self, obj, item, label):\n+    if callable(item):\n+        return []\n+    elif hasattr(obj, item):\n+        # Verify the attribute is actually accessible to match runtime behavior\n+        try:\n+            getattr(obj, item)\n             return []\n+        except AttributeError:\n+            # If we can't access the attribute, continue to model field checks\n+            pass\n+    try:\n+        field = obj.model._meta.get_field(item)\n+    except FieldDoesNotExist:\n+        try:\n+            field = getattr(obj.model, item)\n+        except AttributeError:\n+            return [\n+                checks.Error(\n+                    \"The value of '%s' refers to '%s', which is not a \"\n+                    \"callable, an attribute of '%s', or an attribute or \"\n         try:\n             field = obj.model._meta.get_field(item)\n         except FieldDoesNotExist:\n",
    "variant_5": "diff --git a/django/contrib/admin/checks.py b/django/contrib/admin/checks.py\nindex 0fefe65e48..62b113beb0 100644\n--- a/django/contrib/admin/checks.py\n+++ b/django/contrib/admin/checks.py\n@@ -893,8 +893,28 @@ class ModelAdminChecks(BaseModelAdminChecks):\n     def _check_list_display_item(self, obj, item, label):\n         if callable(item):\n             return []\n-        elif hasattr(obj, item):\n+\n+def _check_list_display_item(self, obj, item, label):\n+    if callable(item):\n+        return []\n+    elif hasattr(obj, item):\n+        # Verify the attribute is actually accessible to match runtime behavior\n+        try:\n+            getattr(obj, item)\n             return []\n+        except AttributeError:\n+            # Continue to field/model attribute checks below\n+            pass\n+    try:\n+        field = obj.model._meta.get_field(item)\n+    except FieldDoesNotExist:\n+        try:\n+            field = getattr(obj.model, item)\n+        except AttributeError:\n+            return [\n+                checks.Error(\n+                    \"The value of '%s' refers to '%s', which is not a \"\n+                    \"callable, an attribute of '%s', or an attribute or \"\n         try:\n             field = obj.model._meta.get_field(item)\n         except FieldDoesNotExist:\n",
    "variant_6": "diff --git a/django/contrib/admin/checks.py b/django/contrib/admin/checks.py\nindex 0fefe65e48..bd000b6c67 100644\n--- a/django/contrib/admin/checks.py\n+++ b/django/contrib/admin/checks.py\n@@ -893,8 +893,28 @@ class ModelAdminChecks(BaseModelAdminChecks):\n     def _check_list_display_item(self, obj, item, label):\n         if callable(item):\n             return []\n-        elif hasattr(obj, item):\n+\n+def _check_list_display_item(self, obj, item, label):\n+    if callable(item):\n+        return []\n+    elif hasattr(obj, item):\n+        # Verify the attribute is actually accessible to match runtime behavior\n+        try:\n+            getattr(obj, item)\n             return []\n+        except AttributeError:\n+            # Continue to field/model attribute checks if admin attribute is not accessible\n+            pass\n+    try:\n+        field = obj.model._meta.get_field(item)\n+    except FieldDoesNotExist:\n+        try:\n+            field = getattr(obj.model, item)\n+        except AttributeError:\n+            return [\n+                checks.Error(\n+                    \"The value of '%s' refers to '%s', which is not a \"\n+                    \"callable, an attribute of '%s', or an attribute or \"\n         try:\n             field = obj.model._meta.get_field(item)\n         except FieldDoesNotExist:\n",
    "variant_7": "diff --git a/django/contrib/admin/checks.py b/django/contrib/admin/checks.py\nindex 0fefe65e48..9d544b1567 100644\n--- a/django/contrib/admin/checks.py\n+++ b/django/contrib/admin/checks.py\n@@ -893,8 +893,28 @@ class ModelAdminChecks(BaseModelAdminChecks):\n     def _check_list_display_item(self, obj, item, label):\n         if callable(item):\n             return []\n-        elif hasattr(obj, item):\n+\n+def _check_list_display_item(self, obj, item, label):\n+    if callable(item):\n+        return []\n+    elif hasattr(obj, item):\n+        # Verify the attribute is actually accessible to match runtime behavior\n+        try:\n+            getattr(obj, item)\n             return []\n+        except AttributeError:\n+            # If we can't access the attribute, fall through to field checks\n+            pass\n+    try:\n+        field = obj.model._meta.get_field(item)\n+    except FieldDoesNotExist:\n+        try:\n+            field = getattr(obj.model, item)\n+        except AttributeError:\n+            return [\n+                checks.Error(\n+                    \"The value of '%s' refers to '%s', which is not a \"\n+                    \"callable, an attribute of '%s', or an attribute or \"\n         try:\n             field = obj.model._meta.get_field(item)\n         except FieldDoesNotExist:\n",
    "variant_8": "diff --git a/django/contrib/admin/checks.py b/django/contrib/admin/checks.py\nindex 0fefe65e48..9d544b1567 100644\n--- a/django/contrib/admin/checks.py\n+++ b/django/contrib/admin/checks.py\n@@ -893,8 +893,28 @@ class ModelAdminChecks(BaseModelAdminChecks):\n     def _check_list_display_item(self, obj, item, label):\n         if callable(item):\n             return []\n-        elif hasattr(obj, item):\n+\n+def _check_list_display_item(self, obj, item, label):\n+    if callable(item):\n+        return []\n+    elif hasattr(obj, item):\n+        # Verify the attribute is actually accessible to match runtime behavior\n+        try:\n+            getattr(obj, item)\n             return []\n+        except AttributeError:\n+            # If we can't access the attribute, fall through to field checks\n+            pass\n+    try:\n+        field = obj.model._meta.get_field(item)\n+    except FieldDoesNotExist:\n+        try:\n+            field = getattr(obj.model, item)\n+        except AttributeError:\n+            return [\n+                checks.Error(\n+                    \"The value of '%s' refers to '%s', which is not a \"\n+                    \"callable, an attribute of '%s', or an attribute or \"\n         try:\n             field = obj.model._meta.get_field(item)\n         except FieldDoesNotExist:\n"
  }
}