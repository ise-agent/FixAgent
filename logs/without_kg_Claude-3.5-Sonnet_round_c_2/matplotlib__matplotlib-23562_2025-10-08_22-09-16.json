{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/matplotlib/lib/mpl_toolkits/mplot3d/art3d.py lines 710-711)": "\n        self.set_zsort(zsort)\n        self._codes3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n",
    "Location 2 (/root/hy/projects_2/matplotlib/lib/mpl_toolkits/mplot3d/art3d.py lines 869-870)": "\n    def __init__(self, verts, *args, zsort='average', **kwargs):\n        \"\"\"\n        Create a Poly3DCollection.\n\n        *verts* is a list of 3D polygons; each polygon is a list of 3D points.\n\n        Note that the zs can be scalars or arrays; if scalars, they will be\n        broadcast to match the first dimension of the *verts* array.\n\n        *zsort* can be 'average', 'min', or 'max'.  When multiple polygons\n        overlap, *zsort* determines which polygon(s) to place in front.\n        \"\"\"\n        super().__init__([])\n        self.set_zsort(zsort)\n        self._codes3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n\n        if isinstance(verts, np.ndarray):\n            if verts.ndim != 3:\n                raise ValueError('verts must be a list of (N, 3) arrays')\n            verts = [verts[j] for j in range(verts.shape[0])]\n\n        self.set_3d_properties()\n        self.set_verts(verts, closed=kwargs.get('closed', True))\n        self._closed = kwargs.get('closed', True)\n\n        PolyCollection.__init__(self, [], *args, **kwargs)\n",
    "Location 3 (/root/hy/projects_2/matplotlib/lib/mpl_toolkits/mplot3d/art3d.py lines 818-819)": "\n        # Initialize 2D color arrays to prevent AttributeError in get_facecolors()\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n",
    "Location 4 (/root/hy/projects_2/matplotlib/lib/mpl_toolkits/mplot3d/art3d.py lines 814-815)": "\n    def __init__(self, verts, *args, zsort='average', **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        verts : list of (N, 3) array-like\n            Each element describes a polygon as a sequence of ``N_i`` points\n            ``(x, y, z)``.\n        zsort : {'average', 'min', 'max'}, default: 'average'\n            The calculation method for the z-order.\n            See `~mpl_toolkits.mplot3d.art3d.zalpha` for details.\n        *args, **kwargs\n            All other parameters are passed on to\n            :class:`~matplotlib.collections.PolyCollection`.\n\n        Note that this class does a bit of magic with the _facecolors\n        and _edgecolors properties.\n        \"\"\"\n        if isinstance(verts, np.ndarray):\n            if verts.ndim != 3:\n                raise ValueError('verts must be a list of (N, 3) array-like')\n        else:\n            verts = [np.asarray(v) for v in verts]\n            if any(len(v.shape) != 2 or v.shape[-1] < 3 for v in verts):\n                raise ValueError('verts must be a list of (N, 3) array-like')\n        self.set_zsort(zsort)\n        self._codes3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n\n        super().__init__([], *args, **kwargs)\n        self.set_3d_properties(verts, 'z')\n",
    "Location 5 (/root/hy/projects_2/matplotlib/lib/mpl_toolkits/mplot3d/art3d.py lines 684-702)": "\n    def __init__(self, verts, *args, zsort='average', **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        verts : list of (N, 3) array-like\n            Each element describes a polygon as a sequence of ``N_i`` points\n            ``(x, y, z)``.\n        zsort : {'average', 'min', 'max'}, default: 'average'\n            The calculation method for the z-order.\n            See `~.Poly3DCollection.set_zsort` for details.\n        *args, **kwargs\n            All other parameters are forwarded to `.PolyCollection`.\n\n        Notes\n        -----\n        Note that this class does a bit of magic with the _facecolors\n        and _edgecolors properties.\n        \"\"\"\n        super().__init__(verts, *args, **kwargs)\n        if isinstance(verts, np.ndarray):\n            if verts.ndim != 3:\n                raise ValueError('verts must be a list of (N, 3) array-like')\n        else:\n            if any(len(np.shape(vert)) != 2 for vert in verts):\n                raise ValueError('verts must be a list of (N, 3) array-like')\n        self.set_zsort(zsort)\n        self._codes3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/matplotlib/lib/mpl_toolkits/mplot3d/art3d.py lines 710-711)": [
      "\n        self.set_zsort(zsort)\n        self._codes3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n",
      "\n        self.set_zsort(zsort)\n        self._codes3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n",
      "\n        self.set_zsort(zsort)\n        self._codes3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n",
      "\n        self.set_zsort(zsort)\n        self._codes3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n",
      "\n        self.set_zsort(zsort)\n        self._codes3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n",
      "\n        self._codes3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n",
      "\n        self.set_zsort(zsort)\n        self._codes3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n",
      "\n        self._codes3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n"
    ],
    "Location 2 (/root/hy/projects_2/matplotlib/lib/mpl_toolkits/mplot3d/art3d.py lines 869-870)": [
      "\n    def __init__(self, verts, *args, zsort='average', **kwargs):\n        \"\"\"\n        Create a Poly3DCollection.\n\n        *verts* should be a sequence of polygons and each polygon should be a\n        sequence of points. Each point is a length-3 sequence giving the\n        x, y, z coordinates.\n\n        Note that if *verts* contains 2D arrays, these are converted to 3D by\n        assuming z=0.\n\n        The *zsort* parameter determines how the face colors are rendered:\n\n        * 'average': The default. Averages the z-coordinates of each face and\n          renders faces in that order.\n        * 'min': Uses the minimum z-coordinate of each face and renders faces\n          in that order.\n        * 'max': Uses the maximum z-coordinate of each face and renders faces\n          in that order.\n        * True: Equivalent to 'average'.\n        * False: The faces are rendered in the order they appear in *verts*,\n          with no attempt at z-sorting.\n\n        Keyword arguments are passed on to\n        :class:`~matplotlib.collections.PolyCollection`.\n        \"\"\"\n        if isinstance(verts, np.ndarray):\n            if verts.ndim != 3:\n                raise ValueError('verts must be a list of (N, 3) array-like')\n        else:\n            if any(len(np.shape(vert)) != 2 for vert in verts):\n                raise ValueError('verts must be a list of (N, 3) array-like')\n        self._zsort = zsort\n        self._sort_zpos = None\n        self._facecolor3d = None\n        self._edgecolor3d = None\n        self._alpha3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n        super().__init__([], *args, **kwargs)\n        self.set_3d_properties(verts)\n",
      "\n    def __init__(self, verts, *args, zsort='average', **kwargs):\n        \"\"\"\n        Create a Poly3DCollection.\n\n        *verts* is a list of 3D polygons. Each polygon is a list of\n        3-tuples or a (N, 3) array.\n\n        Note that if *verts* contains 2D polygons, these are converted to 3D\n        by setting all z-coordinates to 0.\n\n        Keyword arguments are passed on to\n        :class:`~matplotlib.collections.PolyCollection`.\n\n        zsort : {'average', 'min', 'max'}, default 'average'\n            The calculation method for the z-order.\n            See :meth:`set_zsort` for details.\n        \"\"\"\n        super().__init__([], *args, **kwargs)\n        self.set_zsort(zsort)\n        self.set_3d_properties(verts, 'z')\n        self._codes3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n",
      "\n    def __init__(self, verts, *args, zsort='average', **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        verts : list of array-like\n            Each element describes a polygon as a 2D array of (x, y) coordinates.\n        zsort : {'average', 'min', 'max'}, default: 'average'\n            The calculation method for the z-order.\n            See `~mpl_toolkits.mplot3d.art3d.zalpha` for details.\n        *args, **kwargs\n            All other parameters are passed on to `~matplotlib.collections.PolyCollection`.\n\n        Notes\n        -----\n        Note that this class does a bit of magic with the _facecolors\n        and _edgecolors properties.\n        \"\"\"\n        super().__init__(verts, *args, **kwargs)\n        if isinstance(verts, np.ndarray):\n            if verts.ndim != 3:\n                raise ValueError('verts must be a list of (N, 2) arrays')\n            verts = [verts[i] for i in range(verts.shape[0])]\n        self._segment3d = np.asarray(verts)\n        self._zsort = zsort\n        self._codes3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n",
      "\n    def get_facecolor(self):\n        # Return _facecolors2d if it exists and has data, otherwise fall back to _facecolors\n        if hasattr(self, '_facecolors2d') and len(self._facecolors2d) > 0:\n            return self._facecolors2d\n        elif hasattr(self, '_facecolors'):\n            return self._facecolors\n        else:\n            return np.empty((0, 4))\n",
      "\n    def get_facecolor(self):\n        # Return _facecolors2d if it exists and has data, otherwise fall back to _facecolors\n        if hasattr(self, '_facecolors2d') and len(self._facecolors2d) > 0:\n            return self._facecolors2d\n        elif hasattr(self, '_facecolors'):\n            return self._facecolors\n        else:\n            return np.empty((0, 4))\n",
      "\n    def __init__(self, verts, *args, zsort='average', **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        verts : list of array-like\n            Each element describes a polygon as a 2D array of (x, y) coordinates.\n        zsort : {'average', 'min', 'max'}, default: 'average'\n            The calculation method for the z-order.\n            See `~mpl_toolkits.mplot3d.art3d.sort_z_by_artist_3d`.\n        *args, **kwargs\n            All other parameters are passed on to `~matplotlib.collections.PolyCollection`.\n\n        Note that this class does a bit of magic with the _facecolors\n        and _edgecolors properties.\n        \"\"\"\n        super().__init__(verts, *args, **kwargs)\n        if isinstance(verts, np.ndarray):\n            if verts.ndim != 3:\n                raise ValueError('verts must be a list of (N, 2) arrays')\n            verts = [verts[j] for j in range(verts.shape[0])]\n        self.set_zsort(zsort)\n        self._codes3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n",
      "\n    def __init__(self, verts, *args, zsort='average', **kwargs):\n        \"\"\"\n        Create a Poly3DCollection.\n\n        *verts* is a list of 3D polygons. Each polygon is a list of 3-tuples.\n\n        Note that the class dynamically adds and removes *_facecolors3d* and\n        *_edgecolors3d* attributes when needed for internal use. These should\n        not be read from or written to by the user.\n\n        Keyword arguments:\n        zsort : {'average', 'min', 'max'}, default 'average'\n            The calculation method for the z-order.\n            See `~mpl_toolkits.mplot3d.art3d.Poly3DCollection.set_zsort` for\n            details.\n\n        *args*, *kwargs* are passed on to\n        `~matplotlib.collections.PolyCollection`.\n        \"\"\"\n        super().__init__([], *args, **kwargs)\n        self.set_3d_properties(verts, 'z')\n        self.set_zsort(zsort)\n        self._codes3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n",
      "\n    def __init__(self, verts, *args, zsort='average', **kwargs):\n        \"\"\"\n        Create a Poly3DCollection.\n\n        *verts* is a list of polygons where each polygon is a list of points.\n        Each point is a tuple of coordinates (x, y, z).\n\n        Note that the class PolyCollection is used as a base class and\n        PolyCollection.__init__ is called with an empty list as the\n        verts parameter. This is because PolyCollection.__init__ calls\n        self.set_verts(verts) which is overridden in this class. The\n        overridden method processes the 3D verts and sets the 2D verts\n        appropriately.\n\n        *zsort* can be one of {'average', 'min', 'max'}, or a callable\n        that takes a list of coordinates for each face and returns a key\n        to sort by.\n\n        Note that this class does a bit of magic with the _facecolors\n        and _edgecolors properties.\n        \"\"\"\n        if isinstance(verts, np.ndarray):\n            if verts.ndim != 3:\n                raise ValueError('verts must be a list of (N, 3) array-like')\n        else:\n            if any(len(np.shape(vert)) != 2 for vert in verts):\n                raise ValueError('verts must be a list of (N, 3) array-like')\n        self._zsort = zsort\n        PolyCollection.__init__(self, [], *args, **kwargs)\n        self._codes3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n        self.set_verts(verts, closed)\n"
    ],
    "Location 3 (/root/hy/projects_2/matplotlib/lib/mpl_toolkits/mplot3d/art3d.py lines 818-819)": [
      "\n    def __init__(self, verts, *args, zsort='average', **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        verts : list of array-like\n            Each element describes a polygon as a 2D array of shape (N, 3).\n        zsort : {'average', 'min', 'max'}, default: 'average'\n            The calculation method for the z-order.\n            See `~mpl_toolkits.mplot3d.art3d.zalpha` for details.\n        *args, **kwargs\n            All other arguments are passed on to `~matplotlib.collections.PolyCollection`.\n\n        Note that this class does a bit of magic with the _facecolors\n        and _edgecolors properties.\n        \"\"\"\n        super().__init__(verts, *args, **kwargs)\n        if isinstance(verts, np.ndarray):\n            if verts.ndim != 3:\n                raise ValueError('verts must be a list of (N, 3) arrays')\n            verts = [verts[j] for j in range(verts.shape[0])]\n        self._verts3d = verts\n        self._zsortfunc = self._zsort_functions[zsort]\n        self._sort_zpos = None\n        self._codes3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n",
      "\n        self._codes3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n",
      "\n        self._codes3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n",
      "\n        self._codes3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n",
      "\n    def __init__(self, verts, *args, zsort='average', **kwargs):\n        \"\"\"\n        Create a Poly3DCollection.\n\n        *verts* should be a sequence of N polygons, where each polygon is an\n        (M, 3) array-like of (x, y, z) vertices.\n\n        Note that this class does a bit of magic with the _facecolors\n        and _edgecolors properties.\n        \"\"\"\n        if isinstance(verts, np.ndarray):\n            if verts.ndim != 3:\n                raise ValueError('verts must be a list of (N, 3) array-like')\n        else:\n            if any(len(np.shape(vert)) != 2 for vert in verts):\n                raise ValueError('verts must be a list of (N, 3) array-like')\n        self._zsortfunc = self._zsort_functions[zsort]\n        self._sort_zpos = None\n        self._codes3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n\n        super().__init__([], *args, **kwargs)\n        self.set_3d_properties(verts, 'z')\n",
      "\n    def __init__(self, verts, *args, zsort='average', **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        verts : list of array-like\n            Each element of the collection is a list of polygons in 3D space.\n            In case of ``facecolors=None``, the polygons are assumed to be\n            closed and a ``Polygon`` patch is created for each polygon.\n            Otherwise, a ``PolyCollection`` is used.\n        zsort : {'average', 'min', 'max'}, default: 'average'\n            The calculation method for the z-order.\n            See `~mpl_toolkits.mplot3d.art3d.poly_collection_2d_to_3d`.\n        *args, **kwargs\n            All other parameters are forwarded to `.PolyCollection`.\n\n        Note that this class does a bit of magic with the _facecolors\n        and _edgecolors properties.\n        \"\"\"\n        if isinstance(verts, np.ndarray):\n            if verts.ndim != 3:\n                raise ValueError('verts must be a list of (N, 3) array-like')\n        else:\n            if any(len(np.shape(vert)) != 2 for vert in verts):\n                raise ValueError('verts must be a list of (N, 3) array-like')\n        self._zsortfunc = self._zsort_functions[zsort]\n        self._sort_zpos = None\n        self._facecolor3d = PolyCollection.get_facecolor(self)\n        self._edgecolor3d = PolyCollection.get_edgecolor(self)\n        self._alpha3d = PolyCollection.get_alpha(self)\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n        super().__init__([], *args, **kwargs)\n        if isinstance(verts, np.ndarray):\n            verts = [verts[i] for i in range(verts.shape[0])]\n        self.set_3d_properties(verts)\n        self._codes3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n",
      "\n    def __init__(self, verts, *args, zsort='average', **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        verts : list of array-like\n            Each element describes a polygon as a 2D array of shape (N, 3).\n        zsort : {'average', 'min', 'max'}, default: 'average'\n            The calculation method for the z-order.\n            See `~mpl_toolkits.mplot3d.art3d.zalpha` for details.\n        *args, **kwargs\n            All other parameters are forwarded to `.PolyCollection`.\n\n        Note that this class does a bit of magic with the _facecolors\n        and _edgecolors properties.\n        \"\"\"\n        super().__init__([], *args, **kwargs)\n        self.set_zsort(zsort)\n        self._codes3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n\n        if verts is not None:\n            self.set_verts(verts)\n",
      "\n    def __init__(self, verts, zsort='average', *args, **kwargs):\n        \"\"\"\n        Create a Poly3DCollection.\n\n        *verts* is a list of 3D polygons. Each polygon is a list of\n        3-tuples or an array of shape (N, 3).\n\n        Note that the Poly3DCollection is faster to use than Line3DCollection\n        for a large number of polygons.\n\n        Keywords:\n        zsort : {'average', 'min', 'max'}, default: 'average'\n            The calculation method for the z-order.\n            See `~mpl_toolkits.mplot3d.art3d.zalpha` for details.\n        \"\"\"\n        super().__init__([], *args, **kwargs)\n        self.set_zsort(zsort)\n        self.set_verts(verts)\n        self._codes3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n"
    ],
    "Location 4 (/root/hy/projects_2/matplotlib/lib/mpl_toolkits/mplot3d/art3d.py lines 814-815)": [
      "\n        self._codes3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n",
      "\n    def __init__(self, verts, *args, zsort='average', **kwargs):\n        \"\"\"\n        Create a Poly3DCollection.\n\n        *verts* should be a sequence of polygons and each polygon\n        should be a sequence of x-y-z 3-tuples.\n\n        Note that this class does a bit of magic with the _facecolors\n        and _edgecolors properties.\n        \"\"\"\n        super().__init__(verts, *args, **kwargs)\n        self.set_zsort(zsort)\n        self._codes3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n",
      "\n    def __init__(self, verts, *args, zsort='average', **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        verts : list of array-like\n            Each element describes a polygon as a 2D array of shape (N, 3).\n        zsort : {'average', 'min', 'max'}, default: 'average'\n            The calculation method for the z-order.\n            See `~mpl_toolkits.mplot3d.art3d.zalpha` for details.\n        *args, **kwargs\n            All other parameters are forwarded to `.PolyCollection`.\n\n        Note that this class does a bit of magic with the _facecolors\n        and _edgecolors properties.\n        \"\"\"\n        super().__init__([], *args, **kwargs)\n        self.set_3d_properties(verts, zsort)\n        self._codes3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n",
      "\n    def __init__(self, verts, *args, zsort='average', **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        verts : list of array-like\n            Each element describes a polygon as a 2D array of shape (N, 3).\n        zsort : {'average', 'min', 'max'}, default: 'average'\n            The calculation method for the z-order.\n            See `~mpl_toolkits.mplot3d.art3d.zalpha` for details.\n        *args, **kwargs\n            All other parameters are passed on to `~matplotlib.collections.PolyCollection`.\n\n        Note that this class does a bit of magic with the _facecolors\n        and _edgecolors properties.\n        \"\"\"\n        if isinstance(verts, np.ndarray):\n            if verts.ndim != 3:\n                raise ValueError('verts must be a list of (N, 3) array-like')\n        else:\n            if any(len(np.shape(vert)) != 2 for vert in verts):\n                raise ValueError('verts must be a list of (N, 3) array-like')\n        super().__init__([], *args, **kwargs)\n        self.set_3d_properties(verts, zsort)\n        self._codes3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n",
      "\n    def __init__(self, verts, *args, zsort='average', **kwargs):\n        \"\"\"\n        Create a Poly3DCollection.\n\n        *verts* is a list of 3D polygons, where each polygon is a list of\n        3-tuples (or array of shape (N, 3)) of (x, y, z) coordinates.\n\n        Note that the returned object does not contain the original 3D\n        vertices but the projections of them.\n        \"\"\"\n        super().__init__([], *args, **kwargs)\n        self.set_zsort(zsort)\n        self.set_verts(verts, closed=kwargs.get('closed', True))\n        self._codes3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n",
      "\n        self._codes3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n",
      "\n    def __init__(self, verts, *args, zsort='average', **kwargs):\n        \"\"\"\n        Create a Poly3DCollection.\n\n        *verts* should be a sequence of N x 3 arrays (if *closed* is\n        *True*) or N x 2 arrays (if *closed* is *False*).\n\n        Note that this class does a bit of magic with the _facecolors\n        and _edgecolors properties.\n        \"\"\"\n        if isinstance(verts, np.ndarray):\n            if verts.ndim != 3:\n                raise ValueError('verts must be a list of (N, 3) arrays')\n            verts = [verts[j] for j in range(len(verts))]\n        elif np.ma.isMaskedArray(verts):\n            # When verts is a masked array with shape (npolys, npoints, 3)\n            # we need to split up the verts into separate arrays for each poly\n            verts = [verts[j] for j in range(len(verts))]\n\n        super().__init__([], *args, **kwargs)\n        self.set_3d_properties(verts, zsort)\n        self._codes3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n",
      "\n    def __init__(self, verts, *args, zsort='average', **kwargs):\n        \"\"\"\n        Create a Poly3DCollection.\n\n        *verts* should be a sequence of N x 3 arrays (if *facecolors* is not\n        specified, N x 6 arrays, with the first 3 columns being x, y, z, and\n        the next 3 columns being r, g, b).\n\n        Note that this class does a bit of magic with the _facecolors\n        and _edgecolors properties.\n        \"\"\"\n        if isinstance(verts, np.ndarray):\n            if verts.ndim != 3:\n                raise ValueError('verts must be a list of (N, 3) arrays')\n            verts = [verts[j] for j in range(verts.shape[0])]\n\n        self.set_zsort(zsort)\n        self._codes3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n\n        super().__init__([], *args, **kwargs)\n        self.set_3d_properties(verts)\n"
    ],
    "Location 5 (/root/hy/projects_2/matplotlib/lib/mpl_toolkits/mplot3d/art3d.py lines 684-702)": [
      "\n    def __init__(self, verts, *args, zsort='average', **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        verts : list of (N, 3) array-like\n            Each element describes a polygon as a sequence of ``N_i`` points\n            ``(x, y, z)``.\n        zsort : {'average', 'min', 'max'}, default: 'average'\n            The calculation method for the z-order.\n            See `~.Poly3DCollection.set_zsort` for details.\n        *args, **kwargs\n            All other parameters are forwarded to `.PolyCollection`.\n\n        Notes\n        -----\n        Note that this class does a bit of magic with the _facecolors\n        and _edgecolors properties.\n        \"\"\"\n        super().__init__(verts, *args, **kwargs)\n        if isinstance(verts, np.ndarray):\n            if verts.ndim != 3:\n                raise ValueError('verts must be a list of (N, 3) array-like')\n        else:\n            if any(len(np.shape(vert)) != 2 for vert in verts):\n                raise ValueError('verts must be a list of (N, 3) array-like')\n        self.set_zsort(zsort)\n        self._codes3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n",
      "\n    def __init__(self, verts, *args, zsort='average', **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        verts : list of (N, 3) array-like\n            Each element describes a polygon as a sequence of ``N_i`` points\n            ``(x, y, z)``.\n        zsort : {'average', 'min', 'max'}, default: 'average'\n            The calculation method for the z-order.\n            See `~.Poly3DCollection.set_zsort` for details.\n        *args, **kwargs\n            All other parameters are forwarded to `.PolyCollection`.\n\n        Notes\n        -----\n        Note that this class does a bit of magic with the _facecolors\n        and _edgecolors properties.\n        \"\"\"\n        super().__init__(verts, *args, **kwargs)\n        if isinstance(verts, np.ndarray):\n            if verts.ndim != 3:\n                raise ValueError('verts must be a list of (N, 3) array-like')\n        else:\n            if any(len(np.shape(vert)) != 2 for vert in verts):\n                raise ValueError('verts must be a list of (N, 3) array-like')\n        self.set_zsort(zsort)\n        self._codes3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n",
      "\n    def __init__(self, verts, *args, zsort='average', **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        verts : list of (N, 3) array-like\n            Each element describes a polygon as a sequence of ``N_i`` points\n            ``(x, y, z)``.\n        zsort : {'average', 'min', 'max'}, default: 'average'\n            The calculation method for the z-order.\n            See `~.Poly3DCollection.set_zsort` for details.\n        *args, **kwargs\n            All other parameters are forwarded to `.PolyCollection`.\n\n        Notes\n        -----\n        Note that this class does a bit of magic with the _facecolors\n        and _edgecolors properties.\n        \"\"\"\n        super().__init__(verts, *args, **kwargs)\n        if isinstance(verts, np.ndarray):\n            if verts.ndim != 3:\n                raise ValueError('verts must be a list of (N, 3) array-like')\n        else:\n            if any(len(np.shape(vert)) != 2 for vert in verts):\n                raise ValueError('verts must be a list of (N, 3) array-like')\n        self.set_zsort(zsort)\n        self._codes3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n",
      "\n    def __init__(self, verts, *args, zsort='average', **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        verts : list of (N, 3) array-like\n            Each element describes a polygon as a sequence of ``N_i`` points\n            ``(x, y, z)``.\n        zsort : {'average', 'min', 'max'}, default: 'average'\n            The calculation method for the z-order.\n            See `~.Poly3DCollection.set_zsort` for details.\n        *args, **kwargs\n            All other parameters are forwarded to `.PolyCollection`.\n\n        Notes\n        -----\n        Note that this class does a bit of magic with the _facecolors\n        and _edgecolors properties.\n        \"\"\"\n        super().__init__(verts, *args, **kwargs)\n        if isinstance(verts, np.ndarray):\n            if verts.ndim != 3:\n                raise ValueError('verts must be a list of (N, 3) array-like')\n        else:\n            if any(len(np.shape(vert)) != 2 for vert in verts):\n                raise ValueError('verts must be a list of (N, 3) array-like')\n        self.set_zsort(zsort)\n        self._codes3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n",
      "\n    def __init__(self, verts, *args, zsort='average', **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        verts : list of (N, 3) array-like\n            Each element describes a polygon as a sequence of ``N_i`` points\n            ``(x, y, z)``.\n        zsort : {'average', 'min', 'max'}, default: 'average'\n            The calculation method for the z-order.\n            See `~.Poly3DCollection.set_zsort` for details.\n        *args, **kwargs\n            All other parameters are forwarded to `.PolyCollection`.\n\n        Notes\n        -----\n        Note that this class does a bit of magic with the _facecolors\n        and _edgecolors properties.\n        \"\"\"\n        super().__init__(verts, *args, **kwargs)\n        if isinstance(verts, np.ndarray):\n            if verts.ndim != 3:\n                raise ValueError('verts must be a list of (N, 3) array-like')\n        else:\n            if any(len(np.shape(vert)) != 2 for vert in verts):\n                raise ValueError('verts must be a list of (N, 3) array-like')\n        self.set_zsort(zsort)\n        self._codes3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n",
      "\n    def __init__(self, verts, *args, zsort='average', **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        verts : list of (N, 3) array-like\n            Each element describes a polygon as a sequence of ``N_i`` points\n            ``(x, y, z)``.\n        zsort : {'average', 'min', 'max'}, default: 'average'\n            The calculation method for the z-order.\n            See `~.Poly3DCollection.set_zsort` for details.\n        *args, **kwargs\n            All other parameters are forwarded to `.PolyCollection`.\n\n        Notes\n        -----\n        Note that this class does a bit of magic with the _facecolors\n        and _edgecolors properties.\n        \"\"\"\n        super().__init__(verts, *args, **kwargs)\n        if isinstance(verts, np.ndarray):\n            if verts.ndim != 3:\n                raise ValueError('verts must be a list of (N, 3) array-like')\n        else:\n            if any(len(np.shape(vert)) != 2 for vert in verts):\n                raise ValueError('verts must be a list of (N, 3) array-like')\n        self.set_zsort(zsort)\n        self._codes3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n",
      "\n    def __init__(self, verts, *args, zsort='average', **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        verts : list of (N, 3) array-like\n            Each element describes a polygon as a sequence of ``N_i`` points\n            ``(x, y, z)``.\n        zsort : {'average', 'min', 'max'}, default: 'average'\n            The calculation method for the z-order.\n            See `~.Poly3DCollection.set_zsort` for details.\n        *args, **kwargs\n            All other parameters are forwarded to `.PolyCollection`.\n\n        Notes\n        -----\n        Note that this class does a bit of magic with the _facecolors\n        and _edgecolors properties.\n        \"\"\"\n        super().__init__(verts, *args, **kwargs)\n        if isinstance(verts, np.ndarray):\n            if verts.ndim != 3:\n                raise ValueError('verts must be a list of (N, 3) array-like')\n        else:\n            if any(len(np.shape(vert)) != 2 for vert in verts):\n                raise ValueError('verts must be a list of (N, 3) array-like')\n        self.set_zsort(zsort)\n        self._codes3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n",
      "\n    def __init__(self, verts, *args, zsort='average', **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        verts : list of (N, 3) array-like\n            Each element describes a polygon as a sequence of ``N_i`` points\n            ``(x, y, z)``.\n        zsort : {'average', 'min', 'max'}, default: 'average'\n            The calculation method for the z-order.\n            See `~.Poly3DCollection.set_zsort` for details.\n        *args, **kwargs\n            All other parameters are forwarded to `.PolyCollection`.\n\n        Notes\n        -----\n        Note that this class does a bit of magic with the _facecolors\n        and _edgecolors properties.\n        \"\"\"\n        super().__init__(verts, *args, **kwargs)\n        if isinstance(verts, np.ndarray):\n            if verts.ndim != 3:\n                raise ValueError('verts must be a list of (N, 3) array-like')\n        else:\n            if any(len(np.shape(vert)) != 2 for vert in verts):\n                raise ValueError('verts must be a list of (N, 3) array-like')\n        self.set_zsort(zsort)\n        self._codes3d = None\n        self._facecolors2d = np.empty((0, 4))\n        self._edgecolors2d = np.empty((0, 4))\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/lib/mpl_toolkits/mplot3d/art3d.py b/lib/mpl_toolkits/mplot3d/art3d.py\nindex 8fe6e7a9c1..6f481643a1 100644\n--- a/lib/mpl_toolkits/mplot3d/art3d.py\n+++ b/lib/mpl_toolkits/mplot3d/art3d.py\n@@ -681,6 +681,7 @@ class Poly3DCollection(PolyCollection):\n         triangulation and thus generates consistent surfaces.\n     \"\"\"\n \n+\n     def __init__(self, verts, *args, zsort='average', **kwargs):\n         \"\"\"\n         Parameters\n@@ -707,8 +708,10 @@ class Poly3DCollection(PolyCollection):\n             if any(len(np.shape(vert)) != 2 for vert in verts):\n                 raise ValueError('verts must be a list of (N, 3) array-like')\n         self.set_zsort(zsort)\n-        self._codes3d = None\n \n+        self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n     _zsort_functions = {\n         'average': np.average,\n         'min': np.min,\n@@ -811,10 +814,12 @@ class Poly3DCollection(PolyCollection):\n                  in enumerate(zip(xyzlist, cface, cedge))),\n                 key=lambda x: x[0], reverse=True)\n \n+\n             _, segments_2d, self._facecolors2d, self._edgecolors2d, idxs = \\\n                 zip(*z_segments_2d)\n         else:\n             segments_2d = []\n+\n             self._facecolors2d = np.empty((0, 4))\n             self._edgecolors2d = np.empty((0, 4))\n             idxs = []\n@@ -866,6 +871,7 @@ class Poly3DCollection(PolyCollection):\n             pass\n         self.stale = True\n \n+\n     def get_facecolor(self):\n         return self._facecolors2d\n \n",
    "variant_0": "diff --git a/lib/mpl_toolkits/mplot3d/art3d.py b/lib/mpl_toolkits/mplot3d/art3d.py\nindex 8fe6e7a9c1..e236789a34 100644\n--- a/lib/mpl_toolkits/mplot3d/art3d.py\n+++ b/lib/mpl_toolkits/mplot3d/art3d.py\n@@ -681,6 +681,7 @@ class Poly3DCollection(PolyCollection):\n         triangulation and thus generates consistent surfaces.\n     \"\"\"\n \n+\n     def __init__(self, verts, *args, zsort='average', **kwargs):\n         \"\"\"\n         Parameters\n@@ -708,7 +709,20 @@ class Poly3DCollection(PolyCollection):\n                 raise ValueError('verts must be a list of (N, 3) array-like')\n         self.set_zsort(zsort)\n         self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n+        if isinstance(verts, np.ndarray):\n+            if verts.ndim != 3:\n+                raise ValueError('verts must be a list of (N, 3) array-like')\n+        else:\n+            if any(len(np.shape(vert)) != 2 for vert in verts):\n+                raise ValueError('verts must be a list of (N, 3) array-like')\n+        self.set_zsort(zsort)\n \n+        self.set_zsort(zsort)\n+        self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n     _zsort_functions = {\n         'average': np.average,\n         'min': np.min,\n@@ -811,12 +825,44 @@ class Poly3DCollection(PolyCollection):\n                  in enumerate(zip(xyzlist, cface, cedge))),\n                 key=lambda x: x[0], reverse=True)\n \n-            _, segments_2d, self._facecolors2d, self._edgecolors2d, idxs = \\\n-                zip(*z_segments_2d)\n+\n+    def __init__(self, verts, *args, zsort='average', **kwargs):\n+        \"\"\"\n+        Parameters\n+        ----------\n+        verts : list of (N, 3) array-like\n+            Each element describes a polygon as a sequence of ``N_i`` points\n+            ``(x, y, z)``.\n+        zsort : {'average', 'min', 'max'}, default: 'average'\n+            The calculation method for the z-order.\n+            See `~mpl_toolkits.mplot3d.art3d.zalpha` for details.\n+        *args, **kwargs\n+            All other parameters are passed on to\n+            :class:`~matplotlib.collections.PolyCollection`.\n+\n+        Note that this class does a bit of magic with the _facecolors\n+        and _edgecolors properties.\n+        \"\"\"\n+        if isinstance(verts, np.ndarray):\n+            if verts.ndim != 3:\n+                raise ValueError('verts must be a list of (N, 3) array-like')\n+        else:\n+            verts = [np.asarray(v) for v in verts]\n+            if any(len(v.shape) != 2 or v.shape[-1] < 3 for v in verts):\n+                raise ValueError('verts must be a list of (N, 3) array-like')\n+        self.set_zsort(zsort)\n+        self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n+\n+        super().__init__([], *args, **kwargs)\n+        self.set_3d_properties(verts, 'z')\n         else:\n             segments_2d = []\n-            self._facecolors2d = np.empty((0, 4))\n-            self._edgecolors2d = np.empty((0, 4))\n+\n+        # Initialize 2D color arrays to prevent AttributeError in get_facecolors()\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n             idxs = []\n \n         if self._codes3d is not None:\n@@ -866,8 +912,35 @@ class Poly3DCollection(PolyCollection):\n             pass\n         self.stale = True\n \n-    def get_facecolor(self):\n-        return self._facecolors2d\n+\n+    def __init__(self, verts, *args, zsort='average', **kwargs):\n+        \"\"\"\n+        Create a Poly3DCollection.\n+\n+        *verts* is a list of 3D polygons; each polygon is a list of 3D points.\n+\n+        Note that the zs can be scalars or arrays; if scalars, they will be\n+        broadcast to match the first dimension of the *verts* array.\n+\n+        *zsort* can be 'average', 'min', or 'max'.  When multiple polygons\n+        overlap, *zsort* determines which polygon(s) to place in front.\n+        \"\"\"\n+        super().__init__([])\n+        self.set_zsort(zsort)\n+        self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n+\n+        if isinstance(verts, np.ndarray):\n+            if verts.ndim != 3:\n+                raise ValueError('verts must be a list of (N, 3) arrays')\n+            verts = [verts[j] for j in range(verts.shape[0])]\n+\n+        self.set_3d_properties()\n+        self.set_verts(verts, closed=kwargs.get('closed', True))\n+        self._closed = kwargs.get('closed', True)\n+\n+        PolyCollection.__init__(self, [], *args, **kwargs)\n \n     def get_edgecolor(self):\n         return self._edgecolors2d\n",
    "variant_1": "diff --git a/lib/mpl_toolkits/mplot3d/art3d.py b/lib/mpl_toolkits/mplot3d/art3d.py\nindex 8fe6e7a9c1..3bad4da428 100644\n--- a/lib/mpl_toolkits/mplot3d/art3d.py\n+++ b/lib/mpl_toolkits/mplot3d/art3d.py\n@@ -681,6 +681,7 @@ class Poly3DCollection(PolyCollection):\n         triangulation and thus generates consistent surfaces.\n     \"\"\"\n \n+\n     def __init__(self, verts, *args, zsort='average', **kwargs):\n         \"\"\"\n         Parameters\n@@ -708,7 +709,20 @@ class Poly3DCollection(PolyCollection):\n                 raise ValueError('verts must be a list of (N, 3) array-like')\n         self.set_zsort(zsort)\n         self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n+        if isinstance(verts, np.ndarray):\n+            if verts.ndim != 3:\n+                raise ValueError('verts must be a list of (N, 3) array-like')\n+        else:\n+            if any(len(np.shape(vert)) != 2 for vert in verts):\n+                raise ValueError('verts must be a list of (N, 3) array-like')\n+        self.set_zsort(zsort)\n \n+        self.set_zsort(zsort)\n+        self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n     _zsort_functions = {\n         'average': np.average,\n         'min': np.min,\n@@ -811,12 +825,39 @@ class Poly3DCollection(PolyCollection):\n                  in enumerate(zip(xyzlist, cface, cedge))),\n                 key=lambda x: x[0], reverse=True)\n \n-            _, segments_2d, self._facecolors2d, self._edgecolors2d, idxs = \\\n-                zip(*z_segments_2d)\n+\n+        self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n         else:\n             segments_2d = []\n-            self._facecolors2d = np.empty((0, 4))\n-            self._edgecolors2d = np.empty((0, 4))\n+\n+    def __init__(self, verts, *args, zsort='average', **kwargs):\n+        \"\"\"\n+        Parameters\n+        ----------\n+        verts : list of array-like\n+            Each element describes a polygon as a 2D array of shape (N, 3).\n+        zsort : {'average', 'min', 'max'}, default: 'average'\n+            The calculation method for the z-order.\n+            See `~mpl_toolkits.mplot3d.art3d.zalpha` for details.\n+        *args, **kwargs\n+            All other arguments are passed on to `~matplotlib.collections.PolyCollection`.\n+\n+        Note that this class does a bit of magic with the _facecolors\n+        and _edgecolors properties.\n+        \"\"\"\n+        super().__init__(verts, *args, **kwargs)\n+        if isinstance(verts, np.ndarray):\n+            if verts.ndim != 3:\n+                raise ValueError('verts must be a list of (N, 3) arrays')\n+            verts = [verts[j] for j in range(verts.shape[0])]\n+        self._verts3d = verts\n+        self._zsortfunc = self._zsort_functions[zsort]\n+        self._sort_zpos = None\n+        self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n             idxs = []\n \n         if self._codes3d is not None:\n@@ -866,8 +907,48 @@ class Poly3DCollection(PolyCollection):\n             pass\n         self.stale = True\n \n-    def get_facecolor(self):\n-        return self._facecolors2d\n+\n+    def __init__(self, verts, *args, zsort='average', **kwargs):\n+        \"\"\"\n+        Create a Poly3DCollection.\n+\n+        *verts* should be a sequence of polygons and each polygon should be a\n+        sequence of points. Each point is a length-3 sequence giving the\n+        x, y, z coordinates.\n+\n+        Note that if *verts* contains 2D arrays, these are converted to 3D by\n+        assuming z=0.\n+\n+        The *zsort* parameter determines how the face colors are rendered:\n+\n+        * 'average': The default. Averages the z-coordinates of each face and\n+          renders faces in that order.\n+        * 'min': Uses the minimum z-coordinate of each face and renders faces\n+          in that order.\n+        * 'max': Uses the maximum z-coordinate of each face and renders faces\n+          in that order.\n+        * True: Equivalent to 'average'.\n+        * False: The faces are rendered in the order they appear in *verts*,\n+          with no attempt at z-sorting.\n+\n+        Keyword arguments are passed on to\n+        :class:`~matplotlib.collections.PolyCollection`.\n+        \"\"\"\n+        if isinstance(verts, np.ndarray):\n+            if verts.ndim != 3:\n+                raise ValueError('verts must be a list of (N, 3) array-like')\n+        else:\n+            if any(len(np.shape(vert)) != 2 for vert in verts):\n+                raise ValueError('verts must be a list of (N, 3) array-like')\n+        self._zsort = zsort\n+        self._sort_zpos = None\n+        self._facecolor3d = None\n+        self._edgecolor3d = None\n+        self._alpha3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n+        super().__init__([], *args, **kwargs)\n+        self.set_3d_properties(verts)\n \n     def get_edgecolor(self):\n         return self._edgecolors2d\n",
    "variant_2": "diff --git a/lib/mpl_toolkits/mplot3d/art3d.py b/lib/mpl_toolkits/mplot3d/art3d.py\nindex 8fe6e7a9c1..ab4ef23a2a 100644\n--- a/lib/mpl_toolkits/mplot3d/art3d.py\n+++ b/lib/mpl_toolkits/mplot3d/art3d.py\n@@ -681,6 +681,7 @@ class Poly3DCollection(PolyCollection):\n         triangulation and thus generates consistent surfaces.\n     \"\"\"\n \n+\n     def __init__(self, verts, *args, zsort='average', **kwargs):\n         \"\"\"\n         Parameters\n@@ -708,7 +709,20 @@ class Poly3DCollection(PolyCollection):\n                 raise ValueError('verts must be a list of (N, 3) array-like')\n         self.set_zsort(zsort)\n         self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n+        if isinstance(verts, np.ndarray):\n+            if verts.ndim != 3:\n+                raise ValueError('verts must be a list of (N, 3) array-like')\n+        else:\n+            if any(len(np.shape(vert)) != 2 for vert in verts):\n+                raise ValueError('verts must be a list of (N, 3) array-like')\n+        self.set_zsort(zsort)\n \n+        self.set_zsort(zsort)\n+        self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n     _zsort_functions = {\n         'average': np.average,\n         'min': np.min,\n@@ -811,12 +825,28 @@ class Poly3DCollection(PolyCollection):\n                  in enumerate(zip(xyzlist, cface, cedge))),\n                 key=lambda x: x[0], reverse=True)\n \n-            _, segments_2d, self._facecolors2d, self._edgecolors2d, idxs = \\\n-                zip(*z_segments_2d)\n+\n+    def __init__(self, verts, *args, zsort='average', **kwargs):\n+        \"\"\"\n+        Create a Poly3DCollection.\n+\n+        *verts* should be a sequence of polygons and each polygon\n+        should be a sequence of x-y-z 3-tuples.\n+\n+        Note that this class does a bit of magic with the _facecolors\n+        and _edgecolors properties.\n+        \"\"\"\n+        super().__init__(verts, *args, **kwargs)\n+        self.set_zsort(zsort)\n+        self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n         else:\n             segments_2d = []\n-            self._facecolors2d = np.empty((0, 4))\n-            self._edgecolors2d = np.empty((0, 4))\n+\n+        self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n             idxs = []\n \n         if self._codes3d is not None:\n@@ -866,8 +896,30 @@ class Poly3DCollection(PolyCollection):\n             pass\n         self.stale = True\n \n-    def get_facecolor(self):\n-        return self._facecolors2d\n+\n+    def __init__(self, verts, *args, zsort='average', **kwargs):\n+        \"\"\"\n+        Create a Poly3DCollection.\n+\n+        *verts* is a list of 3D polygons. Each polygon is a list of\n+        3-tuples or a (N, 3) array.\n+\n+        Note that if *verts* contains 2D polygons, these are converted to 3D\n+        by setting all z-coordinates to 0.\n+\n+        Keyword arguments are passed on to\n+        :class:`~matplotlib.collections.PolyCollection`.\n+\n+        zsort : {'average', 'min', 'max'}, default 'average'\n+            The calculation method for the z-order.\n+            See :meth:`set_zsort` for details.\n+        \"\"\"\n+        super().__init__([], *args, **kwargs)\n+        self.set_zsort(zsort)\n+        self.set_3d_properties(verts, 'z')\n+        self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n \n     def get_edgecolor(self):\n         return self._edgecolors2d\n",
    "variant_3": "diff --git a/lib/mpl_toolkits/mplot3d/art3d.py b/lib/mpl_toolkits/mplot3d/art3d.py\nindex 8fe6e7a9c1..570795c56d 100644\n--- a/lib/mpl_toolkits/mplot3d/art3d.py\n+++ b/lib/mpl_toolkits/mplot3d/art3d.py\n@@ -681,6 +681,7 @@ class Poly3DCollection(PolyCollection):\n         triangulation and thus generates consistent surfaces.\n     \"\"\"\n \n+\n     def __init__(self, verts, *args, zsort='average', **kwargs):\n         \"\"\"\n         Parameters\n@@ -708,7 +709,20 @@ class Poly3DCollection(PolyCollection):\n                 raise ValueError('verts must be a list of (N, 3) array-like')\n         self.set_zsort(zsort)\n         self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n+        if isinstance(verts, np.ndarray):\n+            if verts.ndim != 3:\n+                raise ValueError('verts must be a list of (N, 3) array-like')\n+        else:\n+            if any(len(np.shape(vert)) != 2 for vert in verts):\n+                raise ValueError('verts must be a list of (N, 3) array-like')\n+        self.set_zsort(zsort)\n \n+        self.set_zsort(zsort)\n+        self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n     _zsort_functions = {\n         'average': np.average,\n         'min': np.min,\n@@ -811,12 +825,33 @@ class Poly3DCollection(PolyCollection):\n                  in enumerate(zip(xyzlist, cface, cedge))),\n                 key=lambda x: x[0], reverse=True)\n \n-            _, segments_2d, self._facecolors2d, self._edgecolors2d, idxs = \\\n-                zip(*z_segments_2d)\n+\n+    def __init__(self, verts, *args, zsort='average', **kwargs):\n+        \"\"\"\n+        Parameters\n+        ----------\n+        verts : list of array-like\n+            Each element describes a polygon as a 2D array of shape (N, 3).\n+        zsort : {'average', 'min', 'max'}, default: 'average'\n+            The calculation method for the z-order.\n+            See `~mpl_toolkits.mplot3d.art3d.zalpha` for details.\n+        *args, **kwargs\n+            All other parameters are forwarded to `.PolyCollection`.\n+\n+        Note that this class does a bit of magic with the _facecolors\n+        and _edgecolors properties.\n+        \"\"\"\n+        super().__init__([], *args, **kwargs)\n+        self.set_3d_properties(verts, zsort)\n+        self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n         else:\n             segments_2d = []\n-            self._facecolors2d = np.empty((0, 4))\n-            self._edgecolors2d = np.empty((0, 4))\n+\n+        self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n             idxs = []\n \n         if self._codes3d is not None:\n@@ -866,8 +901,34 @@ class Poly3DCollection(PolyCollection):\n             pass\n         self.stale = True\n \n-    def get_facecolor(self):\n-        return self._facecolors2d\n+\n+    def __init__(self, verts, *args, zsort='average', **kwargs):\n+        \"\"\"\n+        Parameters\n+        ----------\n+        verts : list of array-like\n+            Each element describes a polygon as a 2D array of (x, y) coordinates.\n+        zsort : {'average', 'min', 'max'}, default: 'average'\n+            The calculation method for the z-order.\n+            See `~mpl_toolkits.mplot3d.art3d.zalpha` for details.\n+        *args, **kwargs\n+            All other parameters are passed on to `~matplotlib.collections.PolyCollection`.\n+\n+        Notes\n+        -----\n+        Note that this class does a bit of magic with the _facecolors\n+        and _edgecolors properties.\n+        \"\"\"\n+        super().__init__(verts, *args, **kwargs)\n+        if isinstance(verts, np.ndarray):\n+            if verts.ndim != 3:\n+                raise ValueError('verts must be a list of (N, 2) arrays')\n+            verts = [verts[i] for i in range(verts.shape[0])]\n+        self._segment3d = np.asarray(verts)\n+        self._zsort = zsort\n+        self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n \n     def get_edgecolor(self):\n         return self._edgecolors2d\n",
    "variant_4": "diff --git a/lib/mpl_toolkits/mplot3d/art3d.py b/lib/mpl_toolkits/mplot3d/art3d.py\nindex 8fe6e7a9c1..2cd22678f4 100644\n--- a/lib/mpl_toolkits/mplot3d/art3d.py\n+++ b/lib/mpl_toolkits/mplot3d/art3d.py\n@@ -681,6 +681,7 @@ class Poly3DCollection(PolyCollection):\n         triangulation and thus generates consistent surfaces.\n     \"\"\"\n \n+\n     def __init__(self, verts, *args, zsort='average', **kwargs):\n         \"\"\"\n         Parameters\n@@ -708,7 +709,20 @@ class Poly3DCollection(PolyCollection):\n                 raise ValueError('verts must be a list of (N, 3) array-like')\n         self.set_zsort(zsort)\n         self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n+        if isinstance(verts, np.ndarray):\n+            if verts.ndim != 3:\n+                raise ValueError('verts must be a list of (N, 3) array-like')\n+        else:\n+            if any(len(np.shape(vert)) != 2 for vert in verts):\n+                raise ValueError('verts must be a list of (N, 3) array-like')\n+        self.set_zsort(zsort)\n \n+        self.set_zsort(zsort)\n+        self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n     _zsort_functions = {\n         'average': np.average,\n         'min': np.min,\n@@ -811,12 +825,39 @@ class Poly3DCollection(PolyCollection):\n                  in enumerate(zip(xyzlist, cface, cedge))),\n                 key=lambda x: x[0], reverse=True)\n \n-            _, segments_2d, self._facecolors2d, self._edgecolors2d, idxs = \\\n-                zip(*z_segments_2d)\n+\n+    def __init__(self, verts, *args, zsort='average', **kwargs):\n+        \"\"\"\n+        Parameters\n+        ----------\n+        verts : list of array-like\n+            Each element describes a polygon as a 2D array of shape (N, 3).\n+        zsort : {'average', 'min', 'max'}, default: 'average'\n+            The calculation method for the z-order.\n+            See `~mpl_toolkits.mplot3d.art3d.zalpha` for details.\n+        *args, **kwargs\n+            All other parameters are passed on to `~matplotlib.collections.PolyCollection`.\n+\n+        Note that this class does a bit of magic with the _facecolors\n+        and _edgecolors properties.\n+        \"\"\"\n+        if isinstance(verts, np.ndarray):\n+            if verts.ndim != 3:\n+                raise ValueError('verts must be a list of (N, 3) array-like')\n+        else:\n+            if any(len(np.shape(vert)) != 2 for vert in verts):\n+                raise ValueError('verts must be a list of (N, 3) array-like')\n+        super().__init__([], *args, **kwargs)\n+        self.set_3d_properties(verts, zsort)\n+        self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n         else:\n             segments_2d = []\n-            self._facecolors2d = np.empty((0, 4))\n-            self._edgecolors2d = np.empty((0, 4))\n+\n+        self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n             idxs = []\n \n         if self._codes3d is not None:\n@@ -866,8 +907,15 @@ class Poly3DCollection(PolyCollection):\n             pass\n         self.stale = True\n \n+\n     def get_facecolor(self):\n-        return self._facecolors2d\n+        # Return _facecolors2d if it exists and has data, otherwise fall back to _facecolors\n+        if hasattr(self, '_facecolors2d') and len(self._facecolors2d) > 0:\n+            return self._facecolors2d\n+        elif hasattr(self, '_facecolors'):\n+            return self._facecolors\n+        else:\n+            return np.empty((0, 4))\n \n     def get_edgecolor(self):\n         return self._edgecolors2d\n",
    "variant_5": "diff --git a/lib/mpl_toolkits/mplot3d/art3d.py b/lib/mpl_toolkits/mplot3d/art3d.py\nindex 8fe6e7a9c1..07b33bf5e1 100644\n--- a/lib/mpl_toolkits/mplot3d/art3d.py\n+++ b/lib/mpl_toolkits/mplot3d/art3d.py\n@@ -681,6 +681,7 @@ class Poly3DCollection(PolyCollection):\n         triangulation and thus generates consistent surfaces.\n     \"\"\"\n \n+\n     def __init__(self, verts, *args, zsort='average', **kwargs):\n         \"\"\"\n         Parameters\n@@ -708,7 +709,20 @@ class Poly3DCollection(PolyCollection):\n                 raise ValueError('verts must be a list of (N, 3) array-like')\n         self.set_zsort(zsort)\n         self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n+        if isinstance(verts, np.ndarray):\n+            if verts.ndim != 3:\n+                raise ValueError('verts must be a list of (N, 3) array-like')\n+        else:\n+            if any(len(np.shape(vert)) != 2 for vert in verts):\n+                raise ValueError('verts must be a list of (N, 3) array-like')\n+        self.set_zsort(zsort)\n \n+        self.set_zsort(zsort)\n+        self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n     _zsort_functions = {\n         'average': np.average,\n         'min': np.min,\n@@ -811,12 +825,50 @@ class Poly3DCollection(PolyCollection):\n                  in enumerate(zip(xyzlist, cface, cedge))),\n                 key=lambda x: x[0], reverse=True)\n \n-            _, segments_2d, self._facecolors2d, self._edgecolors2d, idxs = \\\n-                zip(*z_segments_2d)\n+\n+    def __init__(self, verts, *args, zsort='average', **kwargs):\n+        \"\"\"\n+        Create a Poly3DCollection.\n+\n+        *verts* is a list of 3D polygons, where each polygon is a list of\n+        3-tuples (or array of shape (N, 3)) of (x, y, z) coordinates.\n+\n+        Note that the returned object does not contain the original 3D\n+        vertices but the projections of them.\n+        \"\"\"\n+        super().__init__([], *args, **kwargs)\n+        self.set_zsort(zsort)\n+        self.set_verts(verts, closed=kwargs.get('closed', True))\n+        self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n         else:\n             segments_2d = []\n-            self._facecolors2d = np.empty((0, 4))\n-            self._edgecolors2d = np.empty((0, 4))\n+\n+    def __init__(self, verts, *args, zsort='average', **kwargs):\n+        \"\"\"\n+        Create a Poly3DCollection.\n+\n+        *verts* should be a sequence of N polygons, where each polygon is an\n+        (M, 3) array-like of (x, y, z) vertices.\n+\n+        Note that this class does a bit of magic with the _facecolors\n+        and _edgecolors properties.\n+        \"\"\"\n+        if isinstance(verts, np.ndarray):\n+            if verts.ndim != 3:\n+                raise ValueError('verts must be a list of (N, 3) array-like')\n+        else:\n+            if any(len(np.shape(vert)) != 2 for vert in verts):\n+                raise ValueError('verts must be a list of (N, 3) array-like')\n+        self._zsortfunc = self._zsort_functions[zsort]\n+        self._sort_zpos = None\n+        self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n+\n+        super().__init__([], *args, **kwargs)\n+        self.set_3d_properties(verts, 'z')\n             idxs = []\n \n         if self._codes3d is not None:\n@@ -866,8 +918,15 @@ class Poly3DCollection(PolyCollection):\n             pass\n         self.stale = True\n \n+\n     def get_facecolor(self):\n-        return self._facecolors2d\n+        # Return _facecolors2d if it exists and has data, otherwise fall back to _facecolors\n+        if hasattr(self, '_facecolors2d') and len(self._facecolors2d) > 0:\n+            return self._facecolors2d\n+        elif hasattr(self, '_facecolors'):\n+            return self._facecolors\n+        else:\n+            return np.empty((0, 4))\n \n     def get_edgecolor(self):\n         return self._edgecolors2d\n",
    "variant_6": "diff --git a/lib/mpl_toolkits/mplot3d/art3d.py b/lib/mpl_toolkits/mplot3d/art3d.py\nindex 8fe6e7a9c1..7fa94c4638 100644\n--- a/lib/mpl_toolkits/mplot3d/art3d.py\n+++ b/lib/mpl_toolkits/mplot3d/art3d.py\n@@ -681,6 +681,7 @@ class Poly3DCollection(PolyCollection):\n         triangulation and thus generates consistent surfaces.\n     \"\"\"\n \n+\n     def __init__(self, verts, *args, zsort='average', **kwargs):\n         \"\"\"\n         Parameters\n@@ -708,7 +709,19 @@ class Poly3DCollection(PolyCollection):\n                 raise ValueError('verts must be a list of (N, 3) array-like')\n         self.set_zsort(zsort)\n         self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n+        if isinstance(verts, np.ndarray):\n+            if verts.ndim != 3:\n+                raise ValueError('verts must be a list of (N, 3) array-like')\n+        else:\n+            if any(len(np.shape(vert)) != 2 for vert in verts):\n+                raise ValueError('verts must be a list of (N, 3) array-like')\n+        self.set_zsort(zsort)\n \n+        self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n     _zsort_functions = {\n         'average': np.average,\n         'min': np.min,\n@@ -811,12 +824,51 @@ class Poly3DCollection(PolyCollection):\n                  in enumerate(zip(xyzlist, cface, cedge))),\n                 key=lambda x: x[0], reverse=True)\n \n-            _, segments_2d, self._facecolors2d, self._edgecolors2d, idxs = \\\n-                zip(*z_segments_2d)\n+\n+        self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n         else:\n             segments_2d = []\n-            self._facecolors2d = np.empty((0, 4))\n-            self._edgecolors2d = np.empty((0, 4))\n+\n+    def __init__(self, verts, *args, zsort='average', **kwargs):\n+        \"\"\"\n+        Parameters\n+        ----------\n+        verts : list of array-like\n+            Each element of the collection is a list of polygons in 3D space.\n+            In case of ``facecolors=None``, the polygons are assumed to be\n+            closed and a ``Polygon`` patch is created for each polygon.\n+            Otherwise, a ``PolyCollection`` is used.\n+        zsort : {'average', 'min', 'max'}, default: 'average'\n+            The calculation method for the z-order.\n+            See `~mpl_toolkits.mplot3d.art3d.poly_collection_2d_to_3d`.\n+        *args, **kwargs\n+            All other parameters are forwarded to `.PolyCollection`.\n+\n+        Note that this class does a bit of magic with the _facecolors\n+        and _edgecolors properties.\n+        \"\"\"\n+        if isinstance(verts, np.ndarray):\n+            if verts.ndim != 3:\n+                raise ValueError('verts must be a list of (N, 3) array-like')\n+        else:\n+            if any(len(np.shape(vert)) != 2 for vert in verts):\n+                raise ValueError('verts must be a list of (N, 3) array-like')\n+        self._zsortfunc = self._zsort_functions[zsort]\n+        self._sort_zpos = None\n+        self._facecolor3d = PolyCollection.get_facecolor(self)\n+        self._edgecolor3d = PolyCollection.get_edgecolor(self)\n+        self._alpha3d = PolyCollection.get_alpha(self)\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n+        super().__init__([], *args, **kwargs)\n+        if isinstance(verts, np.ndarray):\n+            verts = [verts[i] for i in range(verts.shape[0])]\n+        self.set_3d_properties(verts)\n+        self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n             idxs = []\n \n         if self._codes3d is not None:\n@@ -866,8 +918,31 @@ class Poly3DCollection(PolyCollection):\n             pass\n         self.stale = True\n \n-    def get_facecolor(self):\n-        return self._facecolors2d\n+\n+    def __init__(self, verts, *args, zsort='average', **kwargs):\n+        \"\"\"\n+        Parameters\n+        ----------\n+        verts : list of array-like\n+            Each element describes a polygon as a 2D array of (x, y) coordinates.\n+        zsort : {'average', 'min', 'max'}, default: 'average'\n+            The calculation method for the z-order.\n+            See `~mpl_toolkits.mplot3d.art3d.sort_z_by_artist_3d`.\n+        *args, **kwargs\n+            All other parameters are passed on to `~matplotlib.collections.PolyCollection`.\n+\n+        Note that this class does a bit of magic with the _facecolors\n+        and _edgecolors properties.\n+        \"\"\"\n+        super().__init__(verts, *args, **kwargs)\n+        if isinstance(verts, np.ndarray):\n+            if verts.ndim != 3:\n+                raise ValueError('verts must be a list of (N, 2) arrays')\n+            verts = [verts[j] for j in range(verts.shape[0])]\n+        self.set_zsort(zsort)\n+        self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n \n     def get_edgecolor(self):\n         return self._edgecolors2d\n",
    "variant_7": "diff --git a/lib/mpl_toolkits/mplot3d/art3d.py b/lib/mpl_toolkits/mplot3d/art3d.py\nindex 8fe6e7a9c1..787475dd40 100644\n--- a/lib/mpl_toolkits/mplot3d/art3d.py\n+++ b/lib/mpl_toolkits/mplot3d/art3d.py\n@@ -681,6 +681,7 @@ class Poly3DCollection(PolyCollection):\n         triangulation and thus generates consistent surfaces.\n     \"\"\"\n \n+\n     def __init__(self, verts, *args, zsort='average', **kwargs):\n         \"\"\"\n         Parameters\n@@ -708,7 +709,20 @@ class Poly3DCollection(PolyCollection):\n                 raise ValueError('verts must be a list of (N, 3) array-like')\n         self.set_zsort(zsort)\n         self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n+        if isinstance(verts, np.ndarray):\n+            if verts.ndim != 3:\n+                raise ValueError('verts must be a list of (N, 3) array-like')\n+        else:\n+            if any(len(np.shape(vert)) != 2 for vert in verts):\n+                raise ValueError('verts must be a list of (N, 3) array-like')\n+        self.set_zsort(zsort)\n \n+        self.set_zsort(zsort)\n+        self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n     _zsort_functions = {\n         'average': np.average,\n         'min': np.min,\n@@ -811,12 +825,57 @@ class Poly3DCollection(PolyCollection):\n                  in enumerate(zip(xyzlist, cface, cedge))),\n                 key=lambda x: x[0], reverse=True)\n \n-            _, segments_2d, self._facecolors2d, self._edgecolors2d, idxs = \\\n-                zip(*z_segments_2d)\n+\n+    def __init__(self, verts, *args, zsort='average', **kwargs):\n+        \"\"\"\n+        Create a Poly3DCollection.\n+\n+        *verts* should be a sequence of N x 3 arrays (if *closed* is\n+        *True*) or N x 2 arrays (if *closed* is *False*).\n+\n+        Note that this class does a bit of magic with the _facecolors\n+        and _edgecolors properties.\n+        \"\"\"\n+        if isinstance(verts, np.ndarray):\n+            if verts.ndim != 3:\n+                raise ValueError('verts must be a list of (N, 3) arrays')\n+            verts = [verts[j] for j in range(len(verts))]\n+        elif np.ma.isMaskedArray(verts):\n+            # When verts is a masked array with shape (npolys, npoints, 3)\n+            # we need to split up the verts into separate arrays for each poly\n+            verts = [verts[j] for j in range(len(verts))]\n+\n+        super().__init__([], *args, **kwargs)\n+        self.set_3d_properties(verts, zsort)\n+        self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n         else:\n             segments_2d = []\n-            self._facecolors2d = np.empty((0, 4))\n-            self._edgecolors2d = np.empty((0, 4))\n+\n+    def __init__(self, verts, *args, zsort='average', **kwargs):\n+        \"\"\"\n+        Parameters\n+        ----------\n+        verts : list of array-like\n+            Each element describes a polygon as a 2D array of shape (N, 3).\n+        zsort : {'average', 'min', 'max'}, default: 'average'\n+            The calculation method for the z-order.\n+            See `~mpl_toolkits.mplot3d.art3d.zalpha` for details.\n+        *args, **kwargs\n+            All other parameters are forwarded to `.PolyCollection`.\n+\n+        Note that this class does a bit of magic with the _facecolors\n+        and _edgecolors properties.\n+        \"\"\"\n+        super().__init__([], *args, **kwargs)\n+        self.set_zsort(zsort)\n+        self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n+\n+        if verts is not None:\n+            self.set_verts(verts)\n             idxs = []\n \n         if self._codes3d is not None:\n@@ -866,8 +925,32 @@ class Poly3DCollection(PolyCollection):\n             pass\n         self.stale = True\n \n-    def get_facecolor(self):\n-        return self._facecolors2d\n+\n+    def __init__(self, verts, *args, zsort='average', **kwargs):\n+        \"\"\"\n+        Create a Poly3DCollection.\n+\n+        *verts* is a list of 3D polygons. Each polygon is a list of 3-tuples.\n+\n+        Note that the class dynamically adds and removes *_facecolors3d* and\n+        *_edgecolors3d* attributes when needed for internal use. These should\n+        not be read from or written to by the user.\n+\n+        Keyword arguments:\n+        zsort : {'average', 'min', 'max'}, default 'average'\n+            The calculation method for the z-order.\n+            See `~mpl_toolkits.mplot3d.art3d.Poly3DCollection.set_zsort` for\n+            details.\n+\n+        *args*, *kwargs* are passed on to\n+        `~matplotlib.collections.PolyCollection`.\n+        \"\"\"\n+        super().__init__([], *args, **kwargs)\n+        self.set_3d_properties(verts, 'z')\n+        self.set_zsort(zsort)\n+        self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n \n     def get_edgecolor(self):\n         return self._edgecolors2d\n",
    "variant_8": "diff --git a/lib/mpl_toolkits/mplot3d/art3d.py b/lib/mpl_toolkits/mplot3d/art3d.py\nindex 8fe6e7a9c1..6fb71f2668 100644\n--- a/lib/mpl_toolkits/mplot3d/art3d.py\n+++ b/lib/mpl_toolkits/mplot3d/art3d.py\n@@ -681,6 +681,7 @@ class Poly3DCollection(PolyCollection):\n         triangulation and thus generates consistent surfaces.\n     \"\"\"\n \n+\n     def __init__(self, verts, *args, zsort='average', **kwargs):\n         \"\"\"\n         Parameters\n@@ -708,7 +709,19 @@ class Poly3DCollection(PolyCollection):\n                 raise ValueError('verts must be a list of (N, 3) array-like')\n         self.set_zsort(zsort)\n         self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n+        if isinstance(verts, np.ndarray):\n+            if verts.ndim != 3:\n+                raise ValueError('verts must be a list of (N, 3) array-like')\n+        else:\n+            if any(len(np.shape(vert)) != 2 for vert in verts):\n+                raise ValueError('verts must be a list of (N, 3) array-like')\n+        self.set_zsort(zsort)\n \n+        self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n     _zsort_functions = {\n         'average': np.average,\n         'min': np.min,\n@@ -811,12 +824,54 @@ class Poly3DCollection(PolyCollection):\n                  in enumerate(zip(xyzlist, cface, cedge))),\n                 key=lambda x: x[0], reverse=True)\n \n-            _, segments_2d, self._facecolors2d, self._edgecolors2d, idxs = \\\n-                zip(*z_segments_2d)\n+\n+    def __init__(self, verts, *args, zsort='average', **kwargs):\n+        \"\"\"\n+        Create a Poly3DCollection.\n+\n+        *verts* should be a sequence of N x 3 arrays (if *facecolors* is not\n+        specified, N x 6 arrays, with the first 3 columns being x, y, z, and\n+        the next 3 columns being r, g, b).\n+\n+        Note that this class does a bit of magic with the _facecolors\n+        and _edgecolors properties.\n+        \"\"\"\n+        if isinstance(verts, np.ndarray):\n+            if verts.ndim != 3:\n+                raise ValueError('verts must be a list of (N, 3) arrays')\n+            verts = [verts[j] for j in range(verts.shape[0])]\n+\n+        self.set_zsort(zsort)\n+        self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n+\n+        super().__init__([], *args, **kwargs)\n+        self.set_3d_properties(verts)\n         else:\n             segments_2d = []\n-            self._facecolors2d = np.empty((0, 4))\n-            self._edgecolors2d = np.empty((0, 4))\n+\n+    def __init__(self, verts, zsort='average', *args, **kwargs):\n+        \"\"\"\n+        Create a Poly3DCollection.\n+\n+        *verts* is a list of 3D polygons. Each polygon is a list of\n+        3-tuples or an array of shape (N, 3).\n+\n+        Note that the Poly3DCollection is faster to use than Line3DCollection\n+        for a large number of polygons.\n+\n+        Keywords:\n+        zsort : {'average', 'min', 'max'}, default: 'average'\n+            The calculation method for the z-order.\n+            See `~mpl_toolkits.mplot3d.art3d.zalpha` for details.\n+        \"\"\"\n+        super().__init__([], *args, **kwargs)\n+        self.set_zsort(zsort)\n+        self.set_verts(verts)\n+        self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n             idxs = []\n \n         if self._codes3d is not None:\n@@ -866,8 +921,40 @@ class Poly3DCollection(PolyCollection):\n             pass\n         self.stale = True\n \n-    def get_facecolor(self):\n-        return self._facecolors2d\n+\n+    def __init__(self, verts, *args, zsort='average', **kwargs):\n+        \"\"\"\n+        Create a Poly3DCollection.\n+\n+        *verts* is a list of polygons where each polygon is a list of points.\n+        Each point is a tuple of coordinates (x, y, z).\n+\n+        Note that the class PolyCollection is used as a base class and\n+        PolyCollection.__init__ is called with an empty list as the\n+        verts parameter. This is because PolyCollection.__init__ calls\n+        self.set_verts(verts) which is overridden in this class. The\n+        overridden method processes the 3D verts and sets the 2D verts\n+        appropriately.\n+\n+        *zsort* can be one of {'average', 'min', 'max'}, or a callable\n+        that takes a list of coordinates for each face and returns a key\n+        to sort by.\n+\n+        Note that this class does a bit of magic with the _facecolors\n+        and _edgecolors properties.\n+        \"\"\"\n+        if isinstance(verts, np.ndarray):\n+            if verts.ndim != 3:\n+                raise ValueError('verts must be a list of (N, 3) array-like')\n+        else:\n+            if any(len(np.shape(vert)) != 2 for vert in verts):\n+                raise ValueError('verts must be a list of (N, 3) array-like')\n+        self._zsort = zsort\n+        PolyCollection.__init__(self, [], *args, **kwargs)\n+        self._codes3d = None\n+        self._facecolors2d = np.empty((0, 4))\n+        self._edgecolors2d = np.empty((0, 4))\n+        self.set_verts(verts, closed)\n \n     def get_edgecolor(self):\n         return self._edgecolors2d\n"
  }
}