{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/django/django/core/management/base.py lines 105-133)": "\nclass DjangoHelpFormatter(HelpFormatter):\n    \"\"\"\n    Customized formatter so that command-specific arguments appear in the\n    --help output before arguments common to all commands.\n    \"\"\"\n\n    show_last = {\n        \"--version\",\n        \"--verbosity\",\n        \"--traceback\",\n        \"--settings\",\n        \"--pythonpath\",\n        \"--no-color\",\n        \"--force-color\",\n        \"--skip-checks\",\n    }\n\n    def _reordered_actions(self, actions):\n        return sorted(\n            actions, key=lambda a: set(a.option_strings) & self.show_last != set()\n        )\n\n    def add_usage(self, usage, actions, *args, **kwargs):\n        super().add_usage(usage, self._reordered_actions(actions), *args, **kwargs)\n\n    def add_arguments(self, actions):\n        super().add_arguments(self._reordered_actions(actions))\n\n    def _fill_text(self, text, width, indent):\n        \"\"\"\n        Override to preserve multi-line formatting in help text.\n        If text contains line breaks, return it as-is with proper indentation.\n        Otherwise, use the default text wrapping behavior.\n        \"\"\"\n        if '\\n' in text:\n            # Preserve multi-line formatting\n            lines = text.splitlines()\n            return '\\n'.join(indent + line for line in lines)\n        else:\n            # Use default wrapping for single-line text\n            return super()._fill_text(text, width, indent)\n",
    "Location 2 (/root/hy/projects_2/django/django/core/management/base.py lines 284-296)": "\n    def create_parser(self, prog_name, subcommand, **kwargs):\n        \"\"\"\n        Create and return the ``ArgumentParser`` which will be used to\n        parse the arguments to this command.\n        \"\"\"\n        parser = CommandParser(\n            prog=\"%s %s\" % (os.path.basename(prog_name), subcommand),\n            description=self.help or None,\n            formatter_class=DjangoHelpFormatter,\n            missing_args_message=getattr(self, \"missing_args_message\", None),\n            called_from_command_line=getattr(self, \"_called_from_command_line\", None),\n            **kwargs,\n        )\n",
    "Location 3 (/root/hy/projects_2/django/django/core/management/base.py lines 190-191)": "\nclass DjangoHelpFormatter(HelpFormatter):\n    \"\"\"\n    Customized formatter so that command-specific arguments appear in the\n    --help output before arguments common to all commands.\n    \"\"\"\n\n    show_last = {\n        '--version', '--verbosity', '--settings', '--pythonpath',\n        '--traceback', '--no-color', '--force-color', '--skip-checks',\n    }\n\n    def _get_formatter(self, name):\n        return self._prog\n\n    def add_usage(self, usage, actions, groups, prefix=None):\n        if prefix is None:\n            prefix = 'usage: '\n        return super().add_usage(\n            usage, actions, groups, prefix)\n\n    def add_arguments(self, actions):\n        mugroup = self._mutually_exclusive_groups\n        for action in actions:\n            if action.option_strings == ['--help']:\n                # optparse has a special-case for --help, but argparse honors\n                # our special purpose and doesn't add --help if we do this.\n                continue\n            if action.option_strings and action.option_strings[0] in self.show_last:\n                self._actions_last.append((action, mugroup.get(action)))\n            else:\n                super().add_argument(action)\n\n    def _fill_text(self, text, width, indent):\n        \"\"\"\n        Preserve formatting for multi-line text by not rewrapping lines\n        that contain explicit line breaks.\n        \"\"\"\n        if '\\n' in text:\n            return text\n        return super()._fill_text(text, width, indent)\n",
    "Location 4 (/root/hy/projects_2/django/django/core/management/base.py lines 380-385)": "\n    def print_help(self, prog_name, subcommand):\n        \"\"\"\n        Print the help message for this command, derived from\n        ``self.usage()``.\n        \"\"\"\n        parser = self.create_parser(prog_name, subcommand)\n        parser.print_help()\n\n    def run_from_argv(self, argv):\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/django/django/core/management/base.py lines 105-133)": [
      "\nclass DjangoHelpFormatter(HelpFormatter):\n    \"\"\"\n    Customized formatter so that command-specific arguments appear in the\n    --help output before arguments common to all commands.\n    \"\"\"\n\n    show_last = {\n        \"--version\",\n        \"--verbosity\",\n        \"--traceback\",\n        \"--settings\",\n        \"--pythonpath\",\n        \"--no-color\",\n        \"--force-color\",\n        \"--skip-checks\",\n    }\n\n    def _reordered_actions(self, actions):\n        return sorted(\n            actions, key=lambda a: set(a.option_strings) & self.show_last != set()\n        )\n\n    def add_usage(self, usage, actions, *args, **kwargs):\n        super().add_usage(usage, self._reordered_actions(actions), *args, **kwargs)\n\n    def add_arguments(self, actions):\n        super().add_arguments(self._reordered_actions(actions))\n\n    def _fill_text(self, text, width, indent):\n        \"\"\"\n        Override _fill_text to preserve multi-line formatting in help text.\n        If the text contains line breaks, return it as-is with proper indentation.\n        Otherwise, use the default text wrapping behavior.\n        \"\"\"\n        if '\\n' in text:\n            lines = text.splitlines()\n            return '\\n'.join(indent + line for line in lines)\n        return super()._fill_text(text, width, indent)\n",
      "\nclass DjangoHelpFormatter(HelpFormatter):\n    \"\"\"\n    Customized formatter so that command-specific arguments appear in the\n    --help output before arguments common to all commands.\n    \"\"\"\n\n    show_last = {\n        \"--version\",\n        \"--verbosity\",\n        \"--traceback\",\n        \"--settings\",\n        \"--pythonpath\",\n        \"--no-color\",\n        \"--force-color\",\n        \"--skip-checks\",\n    }\n\n    def _reordered_actions(self, actions):\n        return sorted(\n            actions, key=lambda a: set(a.option_strings) & self.show_last != set()\n        )\n\n    def add_usage(self, usage, actions, *args, **kwargs):\n        super().add_usage(usage, self._reordered_actions(actions), *args, **kwargs)\n\n    def add_arguments(self, actions):\n        super().add_arguments(self._reordered_actions(actions))\n\n    def _fill_text(self, text, width, indent):\n        \"\"\"\n        Override to preserve multi-line formatting in help text.\n        \"\"\"\n        if '\\n' in text:\n            return text\n        return super()._fill_text(text, width, indent)\n",
      "\nclass DjangoHelpFormatter(HelpFormatter):\n    \"\"\"\n    Customized formatter so that command-specific arguments appear in the\n    --help output before arguments common to all commands.\n    \"\"\"\n\n    show_last = {\n        \"--version\",\n        \"--verbosity\",\n        \"--traceback\",\n        \"--settings\",\n        \"--pythonpath\",\n        \"--no-color\",\n        \"--force-color\",\n        \"--skip-checks\",\n    }\n\n    def _reordered_actions(self, actions):\n        return sorted(\n            actions, key=lambda a: set(a.option_strings) & self.show_last != set()\n        )\n\n    def add_usage(self, usage, actions, *args, **kwargs):\n        super().add_usage(usage, self._reordered_actions(actions), *args, **kwargs)\n\n    def add_arguments(self, actions):\n        super().add_arguments(self._reordered_actions(actions))\n\n    def _fill_text(self, text, width, indent):\n        \"\"\"\n        Override to preserve multi-line formatting in help text.\n        If the text contains newlines, preserve the original formatting\n        instead of reflowing it.\n        \"\"\"\n        if '\\n' in text:\n            return text\n        return super()._fill_text(text, width, indent)\n",
      "\nclass DjangoHelpFormatter(HelpFormatter):\n    \"\"\"\n    Customized formatter so that command-specific arguments appear in the\n    --help output before arguments common to all commands.\n    \"\"\"\n\n    show_last = {\n        \"--version\",\n        \"--verbosity\",\n        \"--traceback\",\n        \"--settings\",\n        \"--pythonpath\",\n        \"--no-color\",\n        \"--force-color\",\n        \"--skip-checks\",\n    }\n\n    def _reordered_actions(self, actions):\n        return sorted(\n            actions, key=lambda a: set(a.option_strings) & self.show_last != set()\n        )\n\n    def add_usage(self, usage, actions, *args, **kwargs):\n        super().add_usage(usage, self._reordered_actions(actions), *args, **kwargs)\n\n    def add_arguments(self, actions):\n        super().add_arguments(self._reordered_actions(actions))\n\n    def _fill_text(self, text, width, indent):\n        \"\"\"\n        Override to preserve multi-line formatting in help text.\n        If text contains newlines, preserve them instead of reflowing.\n        \"\"\"\n        if '\\n' in text:\n            return text\n        return super()._fill_text(text, width, indent)\n",
      "\nclass DjangoHelpFormatter(HelpFormatter):\n    \"\"\"\n    Customized formatter so that command-specific arguments appear in the\n    --help output before arguments common to all commands.\n    \"\"\"\n\n    show_last = {\n        \"--version\",\n        \"--verbosity\",\n        \"--traceback\",\n        \"--settings\",\n        \"--pythonpath\",\n        \"--no-color\",\n        \"--force-color\",\n        \"--skip-checks\",\n    }\n\n    def _reordered_actions(self, actions):\n        return sorted(\n            actions, key=lambda a: set(a.option_strings) & self.show_last != set()\n        )\n\n    def add_usage(self, usage, actions, *args, **kwargs):\n        super().add_usage(usage, self._reordered_actions(actions), *args, **kwargs)\n\n    def add_arguments(self, actions):\n        super().add_arguments(self._reordered_actions(actions))\n\n    def _fill_text(self, text, width, indent):\n        \"\"\"\n        Override _fill_text to preserve multi-line formatting in help text.\n        If the text contains line breaks, return it as-is with proper indentation.\n        Otherwise, use the standard text wrapping behavior.\n        \"\"\"\n        if '\\n' in text:\n            # Preserve multi-line formatting\n            lines = text.splitlines()\n            return '\\n'.join(indent + line for line in lines)\n        else:\n            # Use standard text wrapping for single-line text\n            return super()._fill_text(text, width, indent)\n",
      "\nclass DjangoHelpFormatter(HelpFormatter):\n    \"\"\"\n    Customized formatter so that command-specific arguments appear in the\n    --help output before arguments common to all commands.\n    \"\"\"\n\n    show_last = {\n        \"--version\",\n        \"--verbosity\",\n        \"--traceback\",\n        \"--settings\",\n        \"--pythonpath\",\n        \"--no-color\",\n        \"--force-color\",\n        \"--skip-checks\",\n    }\n\n    def _reordered_actions(self, actions):\n        return sorted(\n            actions, key=lambda a: set(a.option_strings) & self.show_last != set()\n        )\n\n    def add_usage(self, usage, actions, *args, **kwargs):\n        super().add_usage(usage, self._reordered_actions(actions), *args, **kwargs)\n\n    def add_arguments(self, actions):\n        super().add_arguments(self._reordered_actions(actions))\n\n    def _fill_text(self, text, width, indent):\n        \"\"\"\n        Override to preserve multi-line formatting in help text.\n        If text contains newlines, preserve the original formatting.\n        \"\"\"\n        if '\\n' in text:\n            return text\n        return super()._fill_text(text, width, indent)\n",
      "\nclass DjangoHelpFormatter(HelpFormatter):\n    \"\"\"\n    Customized formatter so that command-specific arguments appear in the\n    --help output before arguments common to all commands.\n    \"\"\"\n\n    show_last = {\n        \"--version\",\n        \"--verbosity\",\n        \"--traceback\",\n        \"--settings\",\n        \"--pythonpath\",\n        \"--no-color\",\n        \"--force-color\",\n        \"--skip-checks\",\n    }\n\n    def _reordered_actions(self, actions):\n        return sorted(\n            actions, key=lambda a: set(a.option_strings) & self.show_last != set()\n        )\n\n    def add_usage(self, usage, actions, *args, **kwargs):\n        super().add_usage(usage, self._reordered_actions(actions), *args, **kwargs)\n\n    def add_arguments(self, actions):\n        super().add_arguments(self._reordered_actions(actions))\n\n    def _fill_text(self, text, width, indent):\n        \"\"\"\n        Preserve multi-line formatting in help text by not wrapping text\n        that contains line breaks.\n        \"\"\"\n        if '\\n' in text:\n            return text\n        return super()._fill_text(text, width, indent)\n",
      "\nclass DjangoHelpFormatter(HelpFormatter):\n    \"\"\"\n    Customized formatter so that command-specific arguments appear in the\n    --help output before arguments common to all commands.\n    \"\"\"\n\n    show_last = {\n        \"--version\",\n        \"--verbosity\",\n        \"--traceback\",\n        \"--settings\",\n        \"--pythonpath\",\n        \"--no-color\",\n        \"--force-color\",\n        \"--skip-checks\",\n    }\n\n    def _reordered_actions(self, actions):\n        return sorted(\n            actions, key=lambda a: set(a.option_strings) & self.show_last != set()\n        )\n\n    def add_usage(self, usage, actions, *args, **kwargs):\n        super().add_usage(usage, self._reordered_actions(actions), *args, **kwargs)\n\n    def add_arguments(self, actions):\n        super().add_arguments(self._reordered_actions(actions))\n\n    def _fill_text(self, text, width, indent):\n        \"\"\"\n        Override to preserve multi-line formatting in help text.\n        If text contains newlines, preserve the original formatting\n        instead of rewrapping it.\n        \"\"\"\n        if '\\n' in text:\n            return text\n        return super()._fill_text(text, width, indent)\n"
    ],
    "Location 2 (/root/hy/projects_2/django/django/core/management/base.py lines 284-296)": [
      "\n    def create_parser(self, prog_name, subcommand, **kwargs):\n        \"\"\"\n        Create and return the ``ArgumentParser`` which will be used to\n        parse the arguments to this command.\n        \"\"\"\n        parser = CommandParser(\n            prog=\"%s %s\" % (os.path.basename(prog_name), subcommand),\n            description=self.help or None,\n            formatter_class=DjangoHelpFormatter,\n            missing_args_message=getattr(self, \"missing_args_message\", None),\n            called_from_command_line=getattr(self, \"_called_from_command_line\", None),\n            **kwargs,\n        )\n",
      "\n    def create_parser(self, prog_name, subcommand, **kwargs):\n        \"\"\"\n        Create and return the ``ArgumentParser`` which will be used to\n        parse the arguments to this command.\n        \"\"\"\n        parser = CommandParser(\n            prog=\"%s %s\" % (os.path.basename(prog_name), subcommand),\n            description=self.help or None,\n            formatter_class=DjangoHelpFormatter,\n            missing_args_message=getattr(self, \"missing_args_message\", None),\n            called_from_command_line=getattr(self, \"_called_from_command_line\", None),\n            **kwargs,\n        )\n",
      "\n    def create_parser(self, prog_name, subcommand, **kwargs):\n        \"\"\"\n        Create and return the ``ArgumentParser`` which will be used to\n        parse the arguments to this command.\n        \"\"\"\n        parser = CommandParser(\n            prog=\"%s %s\" % (os.path.basename(prog_name), subcommand),\n            description=self.help or None,\n            formatter_class=DjangoHelpFormatter,\n            missing_args_message=getattr(self, \"missing_args_message\", None),\n            called_from_command_line=getattr(self, \"_called_from_command_line\", None),\n            **kwargs,\n        )\n",
      "\n    def create_parser(self, prog_name, subcommand, **kwargs):\n        \"\"\"\n        Create and return the ``ArgumentParser`` which will be used to\n        parse the arguments to this command.\n        \"\"\"\n        parser = CommandParser(\n            prog=\"%s %s\" % (os.path.basename(prog_name), subcommand),\n            description=self.help or None,\n            formatter_class=DjangoHelpFormatter,\n            missing_args_message=getattr(self, \"missing_args_message\", None),\n            called_from_command_line=getattr(self, \"_called_from_command_line\", None),\n            **kwargs,\n        )\n",
      "\n    def create_parser(self, prog_name, subcommand, **kwargs):\n        \"\"\"\n        Create and return the ``ArgumentParser`` which will be used to\n        parse the arguments to this command.\n        \"\"\"\n        parser = CommandParser(\n            prog=\"%s %s\" % (os.path.basename(prog_name), subcommand),\n            description=self.help or None,\n            formatter_class=DjangoHelpFormatter,\n            missing_args_message=getattr(self, \"missing_args_message\", None),\n            called_from_command_line=getattr(self, \"_called_from_command_line\", None),\n            **kwargs,\n        )\n",
      "\n    def create_parser(self, prog_name, subcommand, **kwargs):\n        \"\"\"\n        Create and return the ``ArgumentParser`` which will be used to\n        parse the arguments to this command.\n        \"\"\"\n        parser = CommandParser(\n            prog=\"%s %s\" % (os.path.basename(prog_name), subcommand),\n            description=self.help or None,\n            formatter_class=DjangoHelpFormatter,\n            missing_args_message=getattr(self, \"missing_args_message\", None),\n            called_from_command_line=getattr(self, \"_called_from_command_line\", None),\n            **kwargs,\n        )\n",
      "\n    def create_parser(self, prog_name, subcommand, **kwargs):\n        \"\"\"\n        Create and return the ``ArgumentParser`` which will be used to\n        parse the arguments to this command.\n        \"\"\"\n        parser = CommandParser(\n            prog=\"%s %s\" % (os.path.basename(prog_name), subcommand),\n            description=self.help or None,\n            formatter_class=DjangoHelpFormatter,\n            missing_args_message=getattr(self, \"missing_args_message\", None),\n            called_from_command_line=getattr(self, \"_called_from_command_line\", None),\n            **kwargs,\n        )\n",
      "\n    def create_parser(self, prog_name, subcommand, **kwargs):\n        \"\"\"\n        Create and return the ``ArgumentParser`` which will be used to\n        parse the arguments to this command.\n        \"\"\"\n        parser = CommandParser(\n            prog=\"%s %s\" % (os.path.basename(prog_name), subcommand),\n            description=self.help or None,\n            formatter_class=DjangoHelpFormatter,\n            missing_args_message=getattr(self, \"missing_args_message\", None),\n            called_from_command_line=getattr(self, \"_called_from_command_line\", None),\n            **kwargs,\n        )\n"
    ],
    "Location 3 (/root/hy/projects_2/django/django/core/management/base.py lines 190-191)": [
      "\nclass DjangoHelpFormatter(HelpFormatter):\n    \"\"\"\n    Customized formatter so that command-specific arguments appear in the\n    --help output before arguments common to all commands.\n    \"\"\"\n\n    show_last = {\n        '--version', '--verbosity', '--settings', '--pythonpath',\n        '--traceback', '--no-color', '--force-color', '--skip-checks',\n    }\n\n    def _fill_text(self, text, width, indent):\n        \"\"\"\n        Override to preserve multi-line formatting in help text.\n        If the text contains newlines, preserve them instead of rewrapping.\n        \"\"\"\n        if '\\n' in text:\n            return text\n        return super()._fill_text(text, width, indent)\n\n    def _get_formatter(self, name):\n        return self._prog\n\n    def add_usage(self, usage, actions, *args, **kwargs):\n        super().add_usage(usage, actions, *args, **kwargs)\n\n    def add_arguments(self, actions):\n        first = set()\n        for action in actions:\n            option_strings = action.option_strings\n            if option_strings:\n                option_strings = ', '.join(option_strings)\n                if option_strings in self.show_last:\n                    first.add(action)\n        super().add_arguments([\n            action for action in actions if action not in first\n        ] + sorted(first, key=lambda x: x.option_strings))\n",
      "\nclass DjangoHelpFormatter(HelpFormatter):\n    \"\"\"\n    Customized formatter so that command-specific arguments appear in the\n    --help output before arguments common to all commands.\n    \"\"\"\n\n    show_last = {\n        '--version', '--verbosity', '--settings', '--pythonpath',\n        '--traceback', '--no-color', '--force-color', '--skip-checks',\n    }\n\n    def _check_value(self, action, value):\n        # converted value must be one of the choices (if specified)\n        if action.choices is not None and value not in action.choices:\n            args = {'value': value,\n                    'choices': ', '.join(map(repr, action.choices))}\n            msg = argparse._('invalid choice: %(value)r (choose from %(choices)s)')\n            raise argparse.ArgumentError(action, msg % args)\n\n    def add_usage(self, usage, actions, *args, **kwargs):\n        super().add_usage(usage, self._reordered_actions(actions), *args, **kwargs)\n\n    def add_arguments(self, actions):\n        super().add_arguments(self._reordered_actions(actions))\n\n    def _reordered_actions(self, actions):\n        return sorted(\n            actions,\n            key=lambda a: set(a.option_strings) & self.show_last != set()\n        )\n\n    def _fill_text(self, text, width, indent):\n        \"\"\"\n        Preserve multi-line formatting in help text by avoiding rewrapping\n        text that contains explicit line breaks.\n        \"\"\"\n        if '\\n' in text:\n            return text\n        return super()._fill_text(text, width, indent)\n",
      "\nclass DjangoHelpFormatter(HelpFormatter):\n    \"\"\"\n    Customized formatter so that command-specific arguments appear in the\n    --help output before arguments common to all commands.\n    \"\"\"\n\n    show_last = {\n        '--version', '--verbosity', '--settings', '--pythonpath',\n        '--traceback', '--no-color', '--force-color', '--skip-checks',\n    }\n\n    def _fill_text(self, text, width, indent):\n        \"\"\"\n        Override _fill_text to preserve multi-line formatting in help text.\n        If the text contains line breaks, preserve them instead of wrapping.\n        \"\"\"\n        if '\\n' in text:\n            # Preserve existing line breaks and only indent\n            lines = text.splitlines()\n            return '\\n'.join(indent + line for line in lines)\n        # For single-line text, use default wrapping behavior\n        return super()._fill_text(text, width, indent)\n\n    def _get_formatter(self, action):\n        return self._format_action_invocation(action)\n\n    def add_usage(self, usage, actions, *args, **kwargs):\n        super().add_usage(usage, actions, *args, **kwargs)\n\n    def add_arguments(self, actions):\n        actions = sorted(\n            actions, key=lambda x: x.option_strings[0] in self.show_last\n        )\n        super().add_arguments(actions)\n",
      "\nclass DjangoHelpFormatter(HelpFormatter):\n    \"\"\"\n    Customized formatter so that command-specific arguments appear in the\n    --help output before arguments common to all commands.\n    \"\"\"\n\n    show_last = {\n        '--version', '--verbosity', '--settings', '--pythonpath',\n        '--traceback', '--no-color', '--force-color', '--skip-checks',\n    }\n\n    def _get_formatter(self, prog):\n        return self._format_action_invocation\n\n    def add_usage(self, usage, actions, *args, **kwargs):\n        super().add_usage(usage, actions, *args, **kwargs)\n\n    def add_arguments(self, actions):\n        actions = sorted(\n            actions,\n            key=lambda x: set(x.option_strings) & self.show_last != set()\n        )\n        super().add_arguments(actions)\n\n    def _fill_text(self, text, width, indent):\n        \"\"\"\n        Override the default text filling behavior to preserve multi-line formatting.\n        If the text contains line breaks, return it as-is with proper indentation.\n        Otherwise, use the default text wrapping behavior.\n        \"\"\"\n        if '\\n' in text:\n            # Preserve multi-line formatting by adding indent to each line\n            lines = text.split('\\n')\n            return '\\n'.join(indent + line for line in lines)\n        else:\n            # Use default behavior for single-line text\n            return super()._fill_text(text, width, indent)\n",
      "\nclass DjangoHelpFormatter(HelpFormatter):\n    \"\"\"\n    Customized formatter so that command-specific arguments appear in the\n    --help output before arguments common to all commands.\n    \"\"\"\n\n    show_last = {\n        '--version', '--verbosity', '--settings', '--pythonpath',\n        '--traceback', '--no-color', '--force-color', '--skip-checks',\n    }\n\n    def _check_value(self, action, value):\n        # converted value must be one of the choices (if specified)\n        if action.choices is not None and value not in action.choices:\n            args = {'value': value,\n                    'choices': ', '.join(map(repr, action.choices))}\n            msg = argparse._('invalid choice: %(value)r (choose from %(choices)s)')\n            raise argparse.ArgumentError(action, msg % args)\n\n    def add_usage(self, usage, actions, groups, prefix=None):\n        if prefix is None:\n            prefix = argparse._('usage: ')\n        return super().add_usage(\n            usage, actions, groups, prefix)\n\n    def add_arguments(self, actions):\n        last = []\n        for action in actions:\n            if action.option_strings:\n                if any(option in self.show_last for option in action.option_strings):\n                    last.append(action)\n                    continue\n            self.add_argument(action)\n        self.add_arguments(last)\n\n    def _fill_text(self, text, width, indent):\n        \"\"\"\n        Override to preserve multi-line formatting in help text.\n        If the text contains line breaks, return it as-is to preserve\n        the original formatting. Otherwise, use the default behavior.\n        \"\"\"\n        if '\\n' in text:\n            return text\n        return super()._fill_text(text, width, indent)\n",
      "\nclass DjangoHelpFormatter(HelpFormatter):\n    \"\"\"\n    Customized formatter so that command-specific arguments appear in the\n    --help output before arguments common to all commands.\n    \"\"\"\n\n    show_last = {\n        '--version', '--verbosity', '--settings', '--pythonpath',\n        '--traceback', '--no-color', '--force-color', '--skip-checks',\n    }\n\n    def _check_value(self, action, value):\n        # converted value must be one of the choices (if specified)\n        if action.choices is not None and value not in action.choices:\n            args = {'value': value,\n                    'choices': ', '.join(map(repr, action.choices))}\n            msg = 'invalid choice: %(value)r (choose from %(choices)s)'\n            raise argparse.ArgumentTypeError(msg % args)\n\n    def add_usage(self, usage, actions, groups, prefix=None):\n        if prefix is None:\n            prefix = 'usage: '\n        return super().add_usage(\n            usage, [a for a in actions if a.option_strings != ['--help']],\n            groups, prefix)\n\n    def add_arguments(self, actions):\n        super().add_arguments(\n            [a for a in actions if a.option_strings and\n             set(a.option_strings).isdisjoint(self.show_last)])\n        super().add_arguments(\n            [a for a in actions if a.option_strings and\n             not set(a.option_strings).isdisjoint(self.show_last)])\n\n    def _fill_text(self, text, width, indent):\n        \"\"\"\n        Override to preserve multi-line formatting in help text.\n        \"\"\"\n        if '\\n' in text:\n            return text\n        return super()._fill_text(text, width, indent)\n",
      "\nclass DjangoHelpFormatter(HelpFormatter):\n    \"\"\"\n    Customized formatter so that command-specific arguments appear in the\n    --help output before arguments common to all commands.\n    \"\"\"\n\n    show_last = {\n        '--version', '--verbosity', '--settings', '--pythonpath',\n        '--traceback', '--no-color', '--force-color', '--skip-checks',\n    }\n\n    def _check_value(self, action, value):\n        # converted value must be one of the choices (if specified)\n        if action.choices is not None and value not in action.choices:\n            args = {'value': value,\n                    'choices': ', '.join(map(repr, action.choices))}\n            msg = 'invalid choice: %(value)r (choose from %(choices)s)'\n            raise argparse.ArgumentTypeError(msg % args)\n\n    def add_usage(self, usage, actions, groups, prefix=None):\n        if prefix is None:\n            prefix = 'usage: '\n        return super().add_usage(\n            usage, actions, groups, prefix)\n\n    def add_arguments(self, actions):\n        actions = sorted(\n            actions,\n            key=lambda a: set(a.option_strings) & self.show_last != set()\n        )\n        super().add_arguments(actions)\n\n    def _fill_text(self, text, width, indent):\n        \"\"\"\n        Override to preserve multi-line formatting in help text.\n        If the text contains newlines, preserve the formatting as-is.\n        Otherwise, use the default text wrapping behavior.\n        \"\"\"\n        if '\\n' in text:\n            return text\n        return super()._fill_text(text, width, indent)\n",
      "\nclass DjangoHelpFormatter(HelpFormatter):\n    \"\"\"\n    Customized formatter so that command-specific arguments appear in the\n    --help output before arguments common to all commands.\n    \"\"\"\n\n    show_last = {\n        '--version', '--verbosity', '--settings', '--pythonpath',\n        '--traceback', '--no-color', '--force-color', '--skip-checks',\n    }\n\n    def _get_formatter(self, name):\n        return self._prog\n\n    def add_usage(self, usage, actions, *args, **kwargs):\n        super().add_usage(usage, actions, *args, **kwargs)\n\n    def add_arguments(self, actions):\n        actions = [a for a in actions if a.help is not argparse.SUPPRESS]\n        actions = sorted(\n            actions,\n            key=lambda x: set(x.option_strings) & self.show_last != set()\n        )\n        super().add_arguments(actions)\n\n    def _fill_text(self, text, width, indent):\n        \"\"\"\n        Override _fill_text to preserve multi-line formatting in help text.\n        If the text contains line breaks, return it as-is with proper indentation.\n        Otherwise, use the default text wrapping behavior.\n        \"\"\"\n        if '\\n' in text:\n            # Preserve multi-line formatting by adding indent to each line\n            lines = text.split('\\n')\n            return '\\n'.join(indent + line for line in lines)\n        return super()._fill_text(text, width, indent)\n"
    ],
    "Location 4 (/root/hy/projects_2/django/django/core/management/base.py lines 380-385)": [
      "\n    def print_help(self, prog_name, subcommand):\n        \"\"\"\n        Print the help message for this command, derived from\n        ``self.usage()``.\n        \"\"\"\n        parser = self.create_parser(prog_name, subcommand)\n        parser.print_help()\n\n    def run_from_argv(self, argv):\n",
      "\n    def print_help(self, prog_name, subcommand):\n        \"\"\"\n        Print the help message for this command, derived from\n        ``self.usage()``.\n        \"\"\"\n        parser = self.create_parser(prog_name, subcommand)\n        parser.print_help()\n\n    def run_from_argv(self, argv):\n",
      "\n    def print_help(self, prog_name, subcommand):\n        \"\"\"\n        Print the help message for this command, derived from\n        ``self.usage()``.\n        \"\"\"\n        parser = self.create_parser(prog_name, subcommand)\n        parser.print_help()\n\n    def run_from_argv(self, argv):\n",
      "\n    def print_help(self, prog_name, subcommand):\n        \"\"\"\n        Print the help message for this command, derived from\n        ``self.usage()``.\n        \"\"\"\n        parser = self.create_parser(prog_name, subcommand)\n        parser.print_help()\n\n    def run_from_argv(self, argv):\n",
      "\n    def print_help(self, prog_name, subcommand):\n        \"\"\"\n        Print the help message for this command, derived from\n        ``self.usage()``.\n        \"\"\"\n        parser = self.create_parser(prog_name, subcommand)\n        parser.print_help()\n\n    def run_from_argv(self, argv):\n",
      "\n    def print_help(self, prog_name, subcommand):\n        \"\"\"\n        Print the help message for this command, derived from\n        ``self.usage()``.\n        \"\"\"\n        parser = self.create_parser(prog_name, subcommand)\n        parser.print_help()\n\n    def run_from_argv(self, argv):\n",
      "\n    def print_help(self, prog_name, subcommand):\n        \"\"\"\n        Print the help message for this command, derived from\n        ``self.usage()``.\n        \"\"\"\n        parser = self.create_parser(prog_name, subcommand)\n        parser.print_help()\n\n    def run_from_argv(self, argv):\n",
      "\n    def print_help(self, prog_name, subcommand):\n        \"\"\"\n        Print the help message for this command, derived from\n        ``self.usage()``.\n        \"\"\"\n        parser = self.create_parser(prog_name, subcommand)\n        parser.print_help()\n\n    def run_from_argv(self, argv):\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/core/management/base.py b/django/core/management/base.py\nindex d37d43d5c5..3aaaf16a64 100644\n--- a/django/core/management/base.py\n+++ b/django/core/management/base.py\n@@ -102,6 +102,7 @@ def no_translations(handle_func):\n     return wrapper\n \n \n+\n class DjangoHelpFormatter(HelpFormatter):\n     \"\"\"\n     Customized formatter so that command-specific arguments appear in the\n@@ -130,6 +131,19 @@ class DjangoHelpFormatter(HelpFormatter):\n     def add_arguments(self, actions):\n         super().add_arguments(self._reordered_actions(actions))\n \n+    def _fill_text(self, text, width, indent):\n+        \"\"\"\n+        Override to preserve multi-line formatting in help text.\n+        If the text contains line breaks, preserve the original formatting\n+        instead of using the standard text wrapping behavior.\n+        \"\"\"\n+        if '\\n' in text:\n+            # Preserve original formatting for multi-line text\n+            return text\n+        else:\n+            # Use standard behavior for single-line text\n+            return super()._fill_text(text, width, indent)\n+\n \n class OutputWrapper(TextIOBase):\n     \"\"\"\n@@ -187,6 +201,7 @@ class BaseCommand:\n     1. ``django-admin`` or ``manage.py`` loads the command class\n        and calls its ``run_from_argv()`` method.\n \n+\n     2. The ``run_from_argv()`` method calls ``create_parser()`` to get\n        an ``ArgumentParser`` for the arguments, parses them, performs\n        any environment changes requested by options like\n@@ -281,6 +296,7 @@ class BaseCommand:\n         \"\"\"\n         return django.get_version()\n \n+\n     def create_parser(self, prog_name, subcommand, **kwargs):\n         \"\"\"\n         Create and return the ``ArgumentParser`` which will be used to\n@@ -377,6 +393,7 @@ class BaseCommand:\n     def print_help(self, prog_name, subcommand):\n         \"\"\"\n         Print the help message for this command, derived from\n+\n         ``self.usage()``.\n         \"\"\"\n         parser = self.create_parser(prog_name, subcommand)\n",
    "variant_0": "diff --git a/django/core/management/base.py b/django/core/management/base.py\nindex d37d43d5c5..f2f078cf3c 100644\n--- a/django/core/management/base.py\n+++ b/django/core/management/base.py\n@@ -102,6 +102,7 @@ def no_translations(handle_func):\n     return wrapper\n \n \n+\n class DjangoHelpFormatter(HelpFormatter):\n     \"\"\"\n     Customized formatter so that command-specific arguments appear in the\n@@ -130,7 +131,19 @@ class DjangoHelpFormatter(HelpFormatter):\n     def add_arguments(self, actions):\n         super().add_arguments(self._reordered_actions(actions))\n \n-\n+    def _fill_text(self, text, width, indent):\n+        \"\"\"\n+        Override to preserve multi-line formatting in help text.\n+        If text contains line breaks, return it as-is with proper indentation.\n+        Otherwise, use the default text wrapping behavior.\n+        \"\"\"\n+        if '\\n' in text:\n+            # Preserve multi-line formatting\n+            lines = text.splitlines()\n+            return '\\n'.join(indent + line for line in lines)\n+        else:\n+            # Use default wrapping for single-line text\n+            return super()._fill_text(text, width, indent)\n class OutputWrapper(TextIOBase):\n     \"\"\"\n     Wrapper around stdout/stderr\n@@ -187,8 +200,47 @@ class BaseCommand:\n     1. ``django-admin`` or ``manage.py`` loads the command class\n        and calls its ``run_from_argv()`` method.\n \n-    2. The ``run_from_argv()`` method calls ``create_parser()`` to get\n-       an ``ArgumentParser`` for the arguments, parses them, performs\n+\n+class DjangoHelpFormatter(HelpFormatter):\n+    \"\"\"\n+    Customized formatter so that command-specific arguments appear in the\n+    --help output before arguments common to all commands.\n+    \"\"\"\n+\n+    show_last = {\n+        '--version', '--verbosity', '--settings', '--pythonpath',\n+        '--traceback', '--no-color', '--force-color', '--skip-checks',\n+    }\n+\n+    def _get_formatter(self, name):\n+        return self._prog\n+\n+    def add_usage(self, usage, actions, groups, prefix=None):\n+        if prefix is None:\n+            prefix = 'usage: '\n+        return super().add_usage(\n+            usage, actions, groups, prefix)\n+\n+    def add_arguments(self, actions):\n+        mugroup = self._mutually_exclusive_groups\n+        for action in actions:\n+            if action.option_strings == ['--help']:\n+                # optparse has a special-case for --help, but argparse honors\n+                # our special purpose and doesn't add --help if we do this.\n+                continue\n+            if action.option_strings and action.option_strings[0] in self.show_last:\n+                self._actions_last.append((action, mugroup.get(action)))\n+            else:\n+                super().add_argument(action)\n+\n+    def _fill_text(self, text, width, indent):\n+        \"\"\"\n+        Preserve formatting for multi-line text by not rewrapping lines\n+        that contain explicit line breaks.\n+        \"\"\"\n+        if '\\n' in text:\n+            return text\n+        return super()._fill_text(text, width, indent)\n        any environment changes requested by options like\n        ``pythonpath``, and then calls the ``execute()`` method,\n        passing the parsed arguments.\n@@ -281,6 +333,7 @@ class BaseCommand:\n         \"\"\"\n         return django.get_version()\n \n+\n     def create_parser(self, prog_name, subcommand, **kwargs):\n         \"\"\"\n         Create and return the ``ArgumentParser`` which will be used to\n@@ -374,6 +427,10 @@ class BaseCommand:\n                 break\n         parser.add_argument(*args, **kwargs)\n \n+    def print_help(self, prog_name, subcommand):\n+        \"\"\"\n+        Print the help message for this command, derived from\n+\n     def print_help(self, prog_name, subcommand):\n         \"\"\"\n         Print the help message for this command, derived from\n",
    "variant_1": "diff --git a/django/core/management/base.py b/django/core/management/base.py\nindex d37d43d5c5..fa7a216f89 100644\n--- a/django/core/management/base.py\n+++ b/django/core/management/base.py\n@@ -102,6 +102,7 @@ def no_translations(handle_func):\n     return wrapper\n \n \n+\n class DjangoHelpFormatter(HelpFormatter):\n     \"\"\"\n     Customized formatter so that command-specific arguments appear in the\n@@ -130,7 +131,16 @@ class DjangoHelpFormatter(HelpFormatter):\n     def add_arguments(self, actions):\n         super().add_arguments(self._reordered_actions(actions))\n \n-\n+    def _fill_text(self, text, width, indent):\n+        \"\"\"\n+        Override _fill_text to preserve multi-line formatting in help text.\n+        If the text contains line breaks, return it as-is with proper indentation.\n+        Otherwise, use the default text wrapping behavior.\n+        \"\"\"\n+        if '\\n' in text:\n+            lines = text.splitlines()\n+            return '\\n'.join(indent + line for line in lines)\n+        return super()._fill_text(text, width, indent)\n class OutputWrapper(TextIOBase):\n     \"\"\"\n     Wrapper around stdout/stderr\n@@ -187,8 +197,44 @@ class BaseCommand:\n     1. ``django-admin`` or ``manage.py`` loads the command class\n        and calls its ``run_from_argv()`` method.\n \n-    2. The ``run_from_argv()`` method calls ``create_parser()`` to get\n-       an ``ArgumentParser`` for the arguments, parses them, performs\n+\n+class DjangoHelpFormatter(HelpFormatter):\n+    \"\"\"\n+    Customized formatter so that command-specific arguments appear in the\n+    --help output before arguments common to all commands.\n+    \"\"\"\n+\n+    show_last = {\n+        '--version', '--verbosity', '--settings', '--pythonpath',\n+        '--traceback', '--no-color', '--force-color', '--skip-checks',\n+    }\n+\n+    def _fill_text(self, text, width, indent):\n+        \"\"\"\n+        Override to preserve multi-line formatting in help text.\n+        If the text contains newlines, preserve them instead of rewrapping.\n+        \"\"\"\n+        if '\\n' in text:\n+            return text\n+        return super()._fill_text(text, width, indent)\n+\n+    def _get_formatter(self, name):\n+        return self._prog\n+\n+    def add_usage(self, usage, actions, *args, **kwargs):\n+        super().add_usage(usage, actions, *args, **kwargs)\n+\n+    def add_arguments(self, actions):\n+        first = set()\n+        for action in actions:\n+            option_strings = action.option_strings\n+            if option_strings:\n+                option_strings = ', '.join(option_strings)\n+                if option_strings in self.show_last:\n+                    first.add(action)\n+        super().add_arguments([\n+            action for action in actions if action not in first\n+        ] + sorted(first, key=lambda x: x.option_strings))\n        any environment changes requested by options like\n        ``pythonpath``, and then calls the ``execute()`` method,\n        passing the parsed arguments.\n@@ -281,6 +327,7 @@ class BaseCommand:\n         \"\"\"\n         return django.get_version()\n \n+\n     def create_parser(self, prog_name, subcommand, **kwargs):\n         \"\"\"\n         Create and return the ``ArgumentParser`` which will be used to\n@@ -374,6 +421,10 @@ class BaseCommand:\n                 break\n         parser.add_argument(*args, **kwargs)\n \n+    def print_help(self, prog_name, subcommand):\n+        \"\"\"\n+        Print the help message for this command, derived from\n+\n     def print_help(self, prog_name, subcommand):\n         \"\"\"\n         Print the help message for this command, derived from\n",
    "variant_2": "diff --git a/django/core/management/base.py b/django/core/management/base.py\nindex d37d43d5c5..b5b4824a1c 100644\n--- a/django/core/management/base.py\n+++ b/django/core/management/base.py\n@@ -102,6 +102,7 @@ def no_translations(handle_func):\n     return wrapper\n \n \n+\n class DjangoHelpFormatter(HelpFormatter):\n     \"\"\"\n     Customized formatter so that command-specific arguments appear in the\n@@ -130,7 +131,13 @@ class DjangoHelpFormatter(HelpFormatter):\n     def add_arguments(self, actions):\n         super().add_arguments(self._reordered_actions(actions))\n \n-\n+    def _fill_text(self, text, width, indent):\n+        \"\"\"\n+        Override to preserve multi-line formatting in help text.\n+        \"\"\"\n+        if '\\n' in text:\n+            return text\n+        return super()._fill_text(text, width, indent)\n class OutputWrapper(TextIOBase):\n     \"\"\"\n     Wrapper around stdout/stderr\n@@ -187,8 +194,46 @@ class BaseCommand:\n     1. ``django-admin`` or ``manage.py`` loads the command class\n        and calls its ``run_from_argv()`` method.\n \n-    2. The ``run_from_argv()`` method calls ``create_parser()`` to get\n-       an ``ArgumentParser`` for the arguments, parses them, performs\n+\n+class DjangoHelpFormatter(HelpFormatter):\n+    \"\"\"\n+    Customized formatter so that command-specific arguments appear in the\n+    --help output before arguments common to all commands.\n+    \"\"\"\n+\n+    show_last = {\n+        '--version', '--verbosity', '--settings', '--pythonpath',\n+        '--traceback', '--no-color', '--force-color', '--skip-checks',\n+    }\n+\n+    def _check_value(self, action, value):\n+        # converted value must be one of the choices (if specified)\n+        if action.choices is not None and value not in action.choices:\n+            args = {'value': value,\n+                    'choices': ', '.join(map(repr, action.choices))}\n+            msg = argparse._('invalid choice: %(value)r (choose from %(choices)s)')\n+            raise argparse.ArgumentError(action, msg % args)\n+\n+    def add_usage(self, usage, actions, *args, **kwargs):\n+        super().add_usage(usage, self._reordered_actions(actions), *args, **kwargs)\n+\n+    def add_arguments(self, actions):\n+        super().add_arguments(self._reordered_actions(actions))\n+\n+    def _reordered_actions(self, actions):\n+        return sorted(\n+            actions,\n+            key=lambda a: set(a.option_strings) & self.show_last != set()\n+        )\n+\n+    def _fill_text(self, text, width, indent):\n+        \"\"\"\n+        Preserve multi-line formatting in help text by avoiding rewrapping\n+        text that contains explicit line breaks.\n+        \"\"\"\n+        if '\\n' in text:\n+            return text\n+        return super()._fill_text(text, width, indent)\n        any environment changes requested by options like\n        ``pythonpath``, and then calls the ``execute()`` method,\n        passing the parsed arguments.\n@@ -281,6 +326,7 @@ class BaseCommand:\n         \"\"\"\n         return django.get_version()\n \n+\n     def create_parser(self, prog_name, subcommand, **kwargs):\n         \"\"\"\n         Create and return the ``ArgumentParser`` which will be used to\n@@ -374,6 +420,10 @@ class BaseCommand:\n                 break\n         parser.add_argument(*args, **kwargs)\n \n+    def print_help(self, prog_name, subcommand):\n+        \"\"\"\n+        Print the help message for this command, derived from\n+\n     def print_help(self, prog_name, subcommand):\n         \"\"\"\n         Print the help message for this command, derived from\n",
    "variant_3": "diff --git a/django/core/management/base.py b/django/core/management/base.py\nindex d37d43d5c5..786ca4ee8e 100644\n--- a/django/core/management/base.py\n+++ b/django/core/management/base.py\n@@ -102,6 +102,7 @@ def no_translations(handle_func):\n     return wrapper\n \n \n+\n class DjangoHelpFormatter(HelpFormatter):\n     \"\"\"\n     Customized formatter so that command-specific arguments appear in the\n@@ -130,7 +131,15 @@ class DjangoHelpFormatter(HelpFormatter):\n     def add_arguments(self, actions):\n         super().add_arguments(self._reordered_actions(actions))\n \n-\n+    def _fill_text(self, text, width, indent):\n+        \"\"\"\n+        Override to preserve multi-line formatting in help text.\n+        If the text contains newlines, preserve the original formatting\n+        instead of reflowing it.\n+        \"\"\"\n+        if '\\n' in text:\n+            return text\n+        return super()._fill_text(text, width, indent)\n class OutputWrapper(TextIOBase):\n     \"\"\"\n     Wrapper around stdout/stderr\n@@ -187,8 +196,41 @@ class BaseCommand:\n     1. ``django-admin`` or ``manage.py`` loads the command class\n        and calls its ``run_from_argv()`` method.\n \n-    2. The ``run_from_argv()`` method calls ``create_parser()`` to get\n-       an ``ArgumentParser`` for the arguments, parses them, performs\n+\n+class DjangoHelpFormatter(HelpFormatter):\n+    \"\"\"\n+    Customized formatter so that command-specific arguments appear in the\n+    --help output before arguments common to all commands.\n+    \"\"\"\n+\n+    show_last = {\n+        '--version', '--verbosity', '--settings', '--pythonpath',\n+        '--traceback', '--no-color', '--force-color', '--skip-checks',\n+    }\n+\n+    def _fill_text(self, text, width, indent):\n+        \"\"\"\n+        Override _fill_text to preserve multi-line formatting in help text.\n+        If the text contains line breaks, preserve them instead of wrapping.\n+        \"\"\"\n+        if '\\n' in text:\n+            # Preserve existing line breaks and only indent\n+            lines = text.splitlines()\n+            return '\\n'.join(indent + line for line in lines)\n+        # For single-line text, use default wrapping behavior\n+        return super()._fill_text(text, width, indent)\n+\n+    def _get_formatter(self, action):\n+        return self._format_action_invocation(action)\n+\n+    def add_usage(self, usage, actions, *args, **kwargs):\n+        super().add_usage(usage, actions, *args, **kwargs)\n+\n+    def add_arguments(self, actions):\n+        actions = sorted(\n+            actions, key=lambda x: x.option_strings[0] in self.show_last\n+        )\n+        super().add_arguments(actions)\n        any environment changes requested by options like\n        ``pythonpath``, and then calls the ``execute()`` method,\n        passing the parsed arguments.\n@@ -281,6 +323,7 @@ class BaseCommand:\n         \"\"\"\n         return django.get_version()\n \n+\n     def create_parser(self, prog_name, subcommand, **kwargs):\n         \"\"\"\n         Create and return the ``ArgumentParser`` which will be used to\n@@ -374,6 +417,10 @@ class BaseCommand:\n                 break\n         parser.add_argument(*args, **kwargs)\n \n+    def print_help(self, prog_name, subcommand):\n+        \"\"\"\n+        Print the help message for this command, derived from\n+\n     def print_help(self, prog_name, subcommand):\n         \"\"\"\n         Print the help message for this command, derived from\n",
    "variant_4": "diff --git a/django/core/management/base.py b/django/core/management/base.py\nindex d37d43d5c5..be47696fee 100644\n--- a/django/core/management/base.py\n+++ b/django/core/management/base.py\n@@ -102,6 +102,7 @@ def no_translations(handle_func):\n     return wrapper\n \n \n+\n class DjangoHelpFormatter(HelpFormatter):\n     \"\"\"\n     Customized formatter so that command-specific arguments appear in the\n@@ -130,7 +131,14 @@ class DjangoHelpFormatter(HelpFormatter):\n     def add_arguments(self, actions):\n         super().add_arguments(self._reordered_actions(actions))\n \n-\n+    def _fill_text(self, text, width, indent):\n+        \"\"\"\n+        Override to preserve multi-line formatting in help text.\n+        If text contains newlines, preserve them instead of reflowing.\n+        \"\"\"\n+        if '\\n' in text:\n+            return text\n+        return super()._fill_text(text, width, indent)\n class OutputWrapper(TextIOBase):\n     \"\"\"\n     Wrapper around stdout/stderr\n@@ -187,8 +195,44 @@ class BaseCommand:\n     1. ``django-admin`` or ``manage.py`` loads the command class\n        and calls its ``run_from_argv()`` method.\n \n-    2. The ``run_from_argv()`` method calls ``create_parser()`` to get\n-       an ``ArgumentParser`` for the arguments, parses them, performs\n+\n+class DjangoHelpFormatter(HelpFormatter):\n+    \"\"\"\n+    Customized formatter so that command-specific arguments appear in the\n+    --help output before arguments common to all commands.\n+    \"\"\"\n+\n+    show_last = {\n+        '--version', '--verbosity', '--settings', '--pythonpath',\n+        '--traceback', '--no-color', '--force-color', '--skip-checks',\n+    }\n+\n+    def _get_formatter(self, prog):\n+        return self._format_action_invocation\n+\n+    def add_usage(self, usage, actions, *args, **kwargs):\n+        super().add_usage(usage, actions, *args, **kwargs)\n+\n+    def add_arguments(self, actions):\n+        actions = sorted(\n+            actions,\n+            key=lambda x: set(x.option_strings) & self.show_last != set()\n+        )\n+        super().add_arguments(actions)\n+\n+    def _fill_text(self, text, width, indent):\n+        \"\"\"\n+        Override the default text filling behavior to preserve multi-line formatting.\n+        If the text contains line breaks, return it as-is with proper indentation.\n+        Otherwise, use the default text wrapping behavior.\n+        \"\"\"\n+        if '\\n' in text:\n+            # Preserve multi-line formatting by adding indent to each line\n+            lines = text.split('\\n')\n+            return '\\n'.join(indent + line for line in lines)\n+        else:\n+            # Use default behavior for single-line text\n+            return super()._fill_text(text, width, indent)\n        any environment changes requested by options like\n        ``pythonpath``, and then calls the ``execute()`` method,\n        passing the parsed arguments.\n@@ -281,6 +325,7 @@ class BaseCommand:\n         \"\"\"\n         return django.get_version()\n \n+\n     def create_parser(self, prog_name, subcommand, **kwargs):\n         \"\"\"\n         Create and return the ``ArgumentParser`` which will be used to\n@@ -374,6 +419,10 @@ class BaseCommand:\n                 break\n         parser.add_argument(*args, **kwargs)\n \n+    def print_help(self, prog_name, subcommand):\n+        \"\"\"\n+        Print the help message for this command, derived from\n+\n     def print_help(self, prog_name, subcommand):\n         \"\"\"\n         Print the help message for this command, derived from\n",
    "variant_5": "diff --git a/django/core/management/base.py b/django/core/management/base.py\nindex d37d43d5c5..5c7aa0c853 100644\n--- a/django/core/management/base.py\n+++ b/django/core/management/base.py\n@@ -102,6 +102,7 @@ def no_translations(handle_func):\n     return wrapper\n \n \n+\n class DjangoHelpFormatter(HelpFormatter):\n     \"\"\"\n     Customized formatter so that command-specific arguments appear in the\n@@ -130,7 +131,19 @@ class DjangoHelpFormatter(HelpFormatter):\n     def add_arguments(self, actions):\n         super().add_arguments(self._reordered_actions(actions))\n \n-\n+    def _fill_text(self, text, width, indent):\n+        \"\"\"\n+        Override _fill_text to preserve multi-line formatting in help text.\n+        If the text contains line breaks, return it as-is with proper indentation.\n+        Otherwise, use the standard text wrapping behavior.\n+        \"\"\"\n+        if '\\n' in text:\n+            # Preserve multi-line formatting\n+            lines = text.splitlines()\n+            return '\\n'.join(indent + line for line in lines)\n+        else:\n+            # Use standard text wrapping for single-line text\n+            return super()._fill_text(text, width, indent)\n class OutputWrapper(TextIOBase):\n     \"\"\"\n     Wrapper around stdout/stderr\n@@ -187,8 +200,51 @@ class BaseCommand:\n     1. ``django-admin`` or ``manage.py`` loads the command class\n        and calls its ``run_from_argv()`` method.\n \n-    2. The ``run_from_argv()`` method calls ``create_parser()`` to get\n-       an ``ArgumentParser`` for the arguments, parses them, performs\n+\n+class DjangoHelpFormatter(HelpFormatter):\n+    \"\"\"\n+    Customized formatter so that command-specific arguments appear in the\n+    --help output before arguments common to all commands.\n+    \"\"\"\n+\n+    show_last = {\n+        '--version', '--verbosity', '--settings', '--pythonpath',\n+        '--traceback', '--no-color', '--force-color', '--skip-checks',\n+    }\n+\n+    def _check_value(self, action, value):\n+        # converted value must be one of the choices (if specified)\n+        if action.choices is not None and value not in action.choices:\n+            args = {'value': value,\n+                    'choices': ', '.join(map(repr, action.choices))}\n+            msg = argparse._('invalid choice: %(value)r (choose from %(choices)s)')\n+            raise argparse.ArgumentError(action, msg % args)\n+\n+    def add_usage(self, usage, actions, groups, prefix=None):\n+        if prefix is None:\n+            prefix = argparse._('usage: ')\n+        return super().add_usage(\n+            usage, actions, groups, prefix)\n+\n+    def add_arguments(self, actions):\n+        last = []\n+        for action in actions:\n+            if action.option_strings:\n+                if any(option in self.show_last for option in action.option_strings):\n+                    last.append(action)\n+                    continue\n+            self.add_argument(action)\n+        self.add_arguments(last)\n+\n+    def _fill_text(self, text, width, indent):\n+        \"\"\"\n+        Override to preserve multi-line formatting in help text.\n+        If the text contains line breaks, return it as-is to preserve\n+        the original formatting. Otherwise, use the default behavior.\n+        \"\"\"\n+        if '\\n' in text:\n+            return text\n+        return super()._fill_text(text, width, indent)\n        any environment changes requested by options like\n        ``pythonpath``, and then calls the ``execute()`` method,\n        passing the parsed arguments.\n@@ -281,6 +337,7 @@ class BaseCommand:\n         \"\"\"\n         return django.get_version()\n \n+\n     def create_parser(self, prog_name, subcommand, **kwargs):\n         \"\"\"\n         Create and return the ``ArgumentParser`` which will be used to\n@@ -374,6 +431,10 @@ class BaseCommand:\n                 break\n         parser.add_argument(*args, **kwargs)\n \n+    def print_help(self, prog_name, subcommand):\n+        \"\"\"\n+        Print the help message for this command, derived from\n+\n     def print_help(self, prog_name, subcommand):\n         \"\"\"\n         Print the help message for this command, derived from\n",
    "variant_6": "diff --git a/django/core/management/base.py b/django/core/management/base.py\nindex d37d43d5c5..518e6b2c24 100644\n--- a/django/core/management/base.py\n+++ b/django/core/management/base.py\n@@ -102,6 +102,7 @@ def no_translations(handle_func):\n     return wrapper\n \n \n+\n class DjangoHelpFormatter(HelpFormatter):\n     \"\"\"\n     Customized formatter so that command-specific arguments appear in the\n@@ -130,7 +131,14 @@ class DjangoHelpFormatter(HelpFormatter):\n     def add_arguments(self, actions):\n         super().add_arguments(self._reordered_actions(actions))\n \n-\n+    def _fill_text(self, text, width, indent):\n+        \"\"\"\n+        Override to preserve multi-line formatting in help text.\n+        If text contains newlines, preserve the original formatting.\n+        \"\"\"\n+        if '\\n' in text:\n+            return text\n+        return super()._fill_text(text, width, indent)\n class OutputWrapper(TextIOBase):\n     \"\"\"\n     Wrapper around stdout/stderr\n@@ -187,8 +195,48 @@ class BaseCommand:\n     1. ``django-admin`` or ``manage.py`` loads the command class\n        and calls its ``run_from_argv()`` method.\n \n-    2. The ``run_from_argv()`` method calls ``create_parser()`` to get\n-       an ``ArgumentParser`` for the arguments, parses them, performs\n+\n+class DjangoHelpFormatter(HelpFormatter):\n+    \"\"\"\n+    Customized formatter so that command-specific arguments appear in the\n+    --help output before arguments common to all commands.\n+    \"\"\"\n+\n+    show_last = {\n+        '--version', '--verbosity', '--settings', '--pythonpath',\n+        '--traceback', '--no-color', '--force-color', '--skip-checks',\n+    }\n+\n+    def _check_value(self, action, value):\n+        # converted value must be one of the choices (if specified)\n+        if action.choices is not None and value not in action.choices:\n+            args = {'value': value,\n+                    'choices': ', '.join(map(repr, action.choices))}\n+            msg = 'invalid choice: %(value)r (choose from %(choices)s)'\n+            raise argparse.ArgumentTypeError(msg % args)\n+\n+    def add_usage(self, usage, actions, groups, prefix=None):\n+        if prefix is None:\n+            prefix = 'usage: '\n+        return super().add_usage(\n+            usage, [a for a in actions if a.option_strings != ['--help']],\n+            groups, prefix)\n+\n+    def add_arguments(self, actions):\n+        super().add_arguments(\n+            [a for a in actions if a.option_strings and\n+             set(a.option_strings).isdisjoint(self.show_last)])\n+        super().add_arguments(\n+            [a for a in actions if a.option_strings and\n+             not set(a.option_strings).isdisjoint(self.show_last)])\n+\n+    def _fill_text(self, text, width, indent):\n+        \"\"\"\n+        Override to preserve multi-line formatting in help text.\n+        \"\"\"\n+        if '\\n' in text:\n+            return text\n+        return super()._fill_text(text, width, indent)\n        any environment changes requested by options like\n        ``pythonpath``, and then calls the ``execute()`` method,\n        passing the parsed arguments.\n@@ -281,6 +329,7 @@ class BaseCommand:\n         \"\"\"\n         return django.get_version()\n \n+\n     def create_parser(self, prog_name, subcommand, **kwargs):\n         \"\"\"\n         Create and return the ``ArgumentParser`` which will be used to\n@@ -374,6 +423,10 @@ class BaseCommand:\n                 break\n         parser.add_argument(*args, **kwargs)\n \n+    def print_help(self, prog_name, subcommand):\n+        \"\"\"\n+        Print the help message for this command, derived from\n+\n     def print_help(self, prog_name, subcommand):\n         \"\"\"\n         Print the help message for this command, derived from\n",
    "variant_7": "diff --git a/django/core/management/base.py b/django/core/management/base.py\nindex d37d43d5c5..69a047bba6 100644\n--- a/django/core/management/base.py\n+++ b/django/core/management/base.py\n@@ -102,6 +102,7 @@ def no_translations(handle_func):\n     return wrapper\n \n \n+\n class DjangoHelpFormatter(HelpFormatter):\n     \"\"\"\n     Customized formatter so that command-specific arguments appear in the\n@@ -130,7 +131,14 @@ class DjangoHelpFormatter(HelpFormatter):\n     def add_arguments(self, actions):\n         super().add_arguments(self._reordered_actions(actions))\n \n-\n+    def _fill_text(self, text, width, indent):\n+        \"\"\"\n+        Preserve multi-line formatting in help text by not wrapping text\n+        that contains line breaks.\n+        \"\"\"\n+        if '\\n' in text:\n+            return text\n+        return super()._fill_text(text, width, indent)\n class OutputWrapper(TextIOBase):\n     \"\"\"\n     Wrapper around stdout/stderr\n@@ -187,8 +195,48 @@ class BaseCommand:\n     1. ``django-admin`` or ``manage.py`` loads the command class\n        and calls its ``run_from_argv()`` method.\n \n-    2. The ``run_from_argv()`` method calls ``create_parser()`` to get\n-       an ``ArgumentParser`` for the arguments, parses them, performs\n+\n+class DjangoHelpFormatter(HelpFormatter):\n+    \"\"\"\n+    Customized formatter so that command-specific arguments appear in the\n+    --help output before arguments common to all commands.\n+    \"\"\"\n+\n+    show_last = {\n+        '--version', '--verbosity', '--settings', '--pythonpath',\n+        '--traceback', '--no-color', '--force-color', '--skip-checks',\n+    }\n+\n+    def _check_value(self, action, value):\n+        # converted value must be one of the choices (if specified)\n+        if action.choices is not None and value not in action.choices:\n+            args = {'value': value,\n+                    'choices': ', '.join(map(repr, action.choices))}\n+            msg = 'invalid choice: %(value)r (choose from %(choices)s)'\n+            raise argparse.ArgumentTypeError(msg % args)\n+\n+    def add_usage(self, usage, actions, groups, prefix=None):\n+        if prefix is None:\n+            prefix = 'usage: '\n+        return super().add_usage(\n+            usage, actions, groups, prefix)\n+\n+    def add_arguments(self, actions):\n+        actions = sorted(\n+            actions,\n+            key=lambda a: set(a.option_strings) & self.show_last != set()\n+        )\n+        super().add_arguments(actions)\n+\n+    def _fill_text(self, text, width, indent):\n+        \"\"\"\n+        Override to preserve multi-line formatting in help text.\n+        If the text contains newlines, preserve the formatting as-is.\n+        Otherwise, use the default text wrapping behavior.\n+        \"\"\"\n+        if '\\n' in text:\n+            return text\n+        return super()._fill_text(text, width, indent)\n        any environment changes requested by options like\n        ``pythonpath``, and then calls the ``execute()`` method,\n        passing the parsed arguments.\n@@ -281,6 +329,7 @@ class BaseCommand:\n         \"\"\"\n         return django.get_version()\n \n+\n     def create_parser(self, prog_name, subcommand, **kwargs):\n         \"\"\"\n         Create and return the ``ArgumentParser`` which will be used to\n@@ -374,6 +423,10 @@ class BaseCommand:\n                 break\n         parser.add_argument(*args, **kwargs)\n \n+    def print_help(self, prog_name, subcommand):\n+        \"\"\"\n+        Print the help message for this command, derived from\n+\n     def print_help(self, prog_name, subcommand):\n         \"\"\"\n         Print the help message for this command, derived from\n",
    "variant_8": "diff --git a/django/core/management/base.py b/django/core/management/base.py\nindex d37d43d5c5..450447c962 100644\n--- a/django/core/management/base.py\n+++ b/django/core/management/base.py\n@@ -102,6 +102,7 @@ def no_translations(handle_func):\n     return wrapper\n \n \n+\n class DjangoHelpFormatter(HelpFormatter):\n     \"\"\"\n     Customized formatter so that command-specific arguments appear in the\n@@ -130,7 +131,15 @@ class DjangoHelpFormatter(HelpFormatter):\n     def add_arguments(self, actions):\n         super().add_arguments(self._reordered_actions(actions))\n \n-\n+    def _fill_text(self, text, width, indent):\n+        \"\"\"\n+        Override to preserve multi-line formatting in help text.\n+        If text contains newlines, preserve the original formatting\n+        instead of rewrapping it.\n+        \"\"\"\n+        if '\\n' in text:\n+            return text\n+        return super()._fill_text(text, width, indent)\n class OutputWrapper(TextIOBase):\n     \"\"\"\n     Wrapper around stdout/stderr\n@@ -187,8 +196,43 @@ class BaseCommand:\n     1. ``django-admin`` or ``manage.py`` loads the command class\n        and calls its ``run_from_argv()`` method.\n \n-    2. The ``run_from_argv()`` method calls ``create_parser()`` to get\n-       an ``ArgumentParser`` for the arguments, parses them, performs\n+\n+class DjangoHelpFormatter(HelpFormatter):\n+    \"\"\"\n+    Customized formatter so that command-specific arguments appear in the\n+    --help output before arguments common to all commands.\n+    \"\"\"\n+\n+    show_last = {\n+        '--version', '--verbosity', '--settings', '--pythonpath',\n+        '--traceback', '--no-color', '--force-color', '--skip-checks',\n+    }\n+\n+    def _get_formatter(self, name):\n+        return self._prog\n+\n+    def add_usage(self, usage, actions, *args, **kwargs):\n+        super().add_usage(usage, actions, *args, **kwargs)\n+\n+    def add_arguments(self, actions):\n+        actions = [a for a in actions if a.help is not argparse.SUPPRESS]\n+        actions = sorted(\n+            actions,\n+            key=lambda x: set(x.option_strings) & self.show_last != set()\n+        )\n+        super().add_arguments(actions)\n+\n+    def _fill_text(self, text, width, indent):\n+        \"\"\"\n+        Override _fill_text to preserve multi-line formatting in help text.\n+        If the text contains line breaks, return it as-is with proper indentation.\n+        Otherwise, use the default text wrapping behavior.\n+        \"\"\"\n+        if '\\n' in text:\n+            # Preserve multi-line formatting by adding indent to each line\n+            lines = text.split('\\n')\n+            return '\\n'.join(indent + line for line in lines)\n+        return super()._fill_text(text, width, indent)\n        any environment changes requested by options like\n        ``pythonpath``, and then calls the ``execute()`` method,\n        passing the parsed arguments.\n@@ -281,6 +325,7 @@ class BaseCommand:\n         \"\"\"\n         return django.get_version()\n \n+\n     def create_parser(self, prog_name, subcommand, **kwargs):\n         \"\"\"\n         Create and return the ``ArgumentParser`` which will be used to\n@@ -374,6 +419,10 @@ class BaseCommand:\n                 break\n         parser.add_argument(*args, **kwargs)\n \n+    def print_help(self, prog_name, subcommand):\n+        \"\"\"\n+        Print the help message for this command, derived from\n+\n     def print_help(self, prog_name, subcommand):\n         \"\"\"\n         Print the help message for this command, derived from\n"
  }
}