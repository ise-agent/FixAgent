{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/scikit-learn/sklearn/neighbors/base.py lines 106-118)": "\n    @abstractmethod\n    def __init__(self, n_neighbors=None, radius=None,\n                 algorithm='auto', leaf_size=30, metric='minkowski',\n                 p=2, metric_params=None, n_jobs=1):\n\n        self.n_neighbors = n_neighbors\n        if n_neighbors is not None and not isinstance(n_neighbors, numbers.Integral):\n            raise TypeError(\"n_neighbors must be an integer, got %s\" % type(n_neighbors).__name__)\n        self.radius = radius\n        self.algorithm = algorithm\n        self.leaf_size = leaf_size\n        self.metric = metric\n        self.metric_params = metric_params\n        self.p = p\n        self.n_jobs = n_jobs\n        self._check_algorithm_metric()\n",
    "Location 2 (/root/hy/projects_2/scikit-learn/sklearn/neighbors/base.py lines 326-347)": "\n        check_is_fitted(self, \"_fit_method\")\n\n        if n_neighbors is None:\n            n_neighbors = self.n_neighbors\n\n        # Validate n_neighbors is an integer\n        if not isinstance(n_neighbors, numbers.Integral):\n            raise TypeError(\"n_neighbors must be an integer, got %s\" % type(n_neighbors).__name__)\n\n        if X is not None:\n            query_is_train = False\n            X = check_array(X, accept_sparse='csr')\n        else:\n            query_is_train = True\n            X = self._fit_X\n            # Include an extra neighbor to account for the sample itself being\n            # returned, which is removed later\n            n_neighbors += 1\n\n        train_size = self._fit_X.shape[0]\n        if n_neighbors > train_size:\n            raise ValueError(\n                \"Expected n_neighbors <= n_samples, \"\n                \" but n_samples = %d, n_neighbors = %d\" %\n                (train_size, n_neighbors)\n            )\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/scikit-learn/sklearn/neighbors/base.py lines 106-118)": [
      "\n    @abstractmethod\n    def __init__(self, n_neighbors=None, radius=None,\n                 algorithm='auto', leaf_size=30, metric='minkowski',\n                 p=2, metric_params=None, n_jobs=1):\n\n        self.n_neighbors = n_neighbors\n        if n_neighbors is not None and not isinstance(n_neighbors, numbers.Integral):\n            raise TypeError(\"n_neighbors must be an integer, got %s\" % type(n_neighbors).__name__)\n        self.radius = radius\n        self.algorithm = algorithm\n        self.leaf_size = leaf_size\n        self.metric = metric\n        self.metric_params = metric_params\n        self.p = p\n        self.n_jobs = n_jobs\n        self._check_algorithm_metric()\n",
      "\n    @abstractmethod\n    def __init__(self, n_neighbors=None, radius=None,\n                 algorithm='auto', leaf_size=30, metric='minkowski',\n                 p=2, metric_params=None, n_jobs=1):\n\n        self.n_neighbors = n_neighbors\n        if n_neighbors is not None and not isinstance(n_neighbors, numbers.Integral):\n            raise TypeError(\"n_neighbors must be an integer, got %s\" % type(n_neighbors).__name__)\n        self.radius = radius\n        self.algorithm = algorithm\n        self.leaf_size = leaf_size\n        self.metric = metric\n        self.metric_params = metric_params\n        self.p = p\n        self.n_jobs = n_jobs\n        self._check_algorithm_metric()\n",
      "\n    @abstractmethod\n    def __init__(self, n_neighbors=None, radius=None,\n                 algorithm='auto', leaf_size=30, metric='minkowski',\n                 p=2, metric_params=None, n_jobs=1):\n\n        self.n_neighbors = n_neighbors\n        if n_neighbors is not None and not isinstance(n_neighbors, numbers.Integral):\n            raise TypeError(\"n_neighbors must be an integer, got %s\" % type(n_neighbors).__name__)\n        self.radius = radius\n        self.algorithm = algorithm\n        self.leaf_size = leaf_size\n        self.metric = metric\n        self.metric_params = metric_params\n        self.p = p\n        self.n_jobs = n_jobs\n        self._check_algorithm_metric()\n",
      "\n    @abstractmethod\n    def __init__(self, n_neighbors=None, radius=None,\n                 algorithm='auto', leaf_size=30, metric='minkowski',\n                 p=2, metric_params=None, n_jobs=1):\n\n        self.n_neighbors = n_neighbors\n        # Validate n_neighbors parameter\n        if n_neighbors is not None and not isinstance(n_neighbors, int):\n            raise TypeError(\"n_neighbors must be an integer, got {}\"\n                          .format(type(n_neighbors).__name__))\n        self.radius = radius\n        self.algorithm = algorithm\n        self.leaf_size = leaf_size\n        self.metric = metric\n        self.metric_params = metric_params\n        self.p = p\n        self.n_jobs = n_jobs\n        self._check_algorithm_metric()\n",
      "\n    @abstractmethod\n    def __init__(self, n_neighbors=None, radius=None,\n                 algorithm='auto', leaf_size=30, metric='minkowski',\n                 p=2, metric_params=None, n_jobs=1):\n\n        self.n_neighbors = n_neighbors\n        if n_neighbors is not None and not isinstance(n_neighbors, numbers.Integral):\n            raise TypeError(\"n_neighbors must be an integer, got %s\" % type(n_neighbors).__name__)\n        self.radius = radius\n        self.algorithm = algorithm\n        self.leaf_size = leaf_size\n        self.metric = metric\n        self.metric_params = metric_params\n        self.p = p\n        self.n_jobs = n_jobs\n        self._check_algorithm_metric()\n",
      "\n    @abstractmethod\n    def __init__(self, n_neighbors=None, radius=None,\n                 algorithm='auto', leaf_size=30, metric='minkowski',\n                 p=2, metric_params=None, n_jobs=1):\n\n        self.n_neighbors = n_neighbors\n        if n_neighbors is not None and not isinstance(n_neighbors, numbers.Integral):\n            raise TypeError(\"n_neighbors must be an integer, got %s\" % type(n_neighbors).__name__)\n        self.radius = radius\n        self.algorithm = algorithm\n        self.leaf_size = leaf_size\n        self.metric = metric\n        self.metric_params = metric_params\n        self.p = p\n        self.n_jobs = n_jobs\n        self._check_algorithm_metric()\n",
      "\n    @abstractmethod\n    def __init__(self, n_neighbors=None, radius=None,\n                 algorithm='auto', leaf_size=30, metric='minkowski',\n                 p=2, metric_params=None, n_jobs=1):\n\n        self.n_neighbors = n_neighbors\n        if n_neighbors is not None and not isinstance(n_neighbors, numbers.Integral):\n            raise TypeError(\"n_neighbors must be an integer, got %s\" % type(n_neighbors).__name__)\n        self.radius = radius\n        self.algorithm = algorithm\n        self.leaf_size = leaf_size\n        self.metric = metric\n        self.metric_params = metric_params\n        self.p = p\n        self.n_jobs = n_jobs\n        self._check_algorithm_metric()\n",
      "\n    @abstractmethod\n    def __init__(self, n_neighbors=None, radius=None,\n                 algorithm='auto', leaf_size=30, metric='minkowski',\n                 p=2, metric_params=None, n_jobs=1):\n\n        self.n_neighbors = n_neighbors\n        if n_neighbors is not None and not isinstance(n_neighbors, int):\n            raise TypeError(\"n_neighbors must be an integer, got %s\" % type(n_neighbors).__name__)\n        self.radius = radius\n        self.algorithm = algorithm\n        self.leaf_size = leaf_size\n        self.metric = metric\n        self.metric_params = metric_params\n        self.p = p\n        self.n_jobs = n_jobs\n        self._check_algorithm_metric()\n"
    ],
    "Location 2 (/root/hy/projects_2/scikit-learn/sklearn/neighbors/base.py lines 326-347)": [
      "\n        check_is_fitted(self, \"_fit_method\")\n\n        if n_neighbors is None:\n            n_neighbors = self.n_neighbors\n\n        # Validate n_neighbors is an integer\n        if not isinstance(n_neighbors, numbers.Integral):\n            raise TypeError(\"n_neighbors must be an integer, got %s\" % type(n_neighbors).__name__)\n\n        if X is not None:\n            query_is_train = False\n            X = check_array(X, accept_sparse='csr')\n        else:\n            query_is_train = True\n            X = self._fit_X\n            # Include an extra neighbor to account for the sample itself being\n            # returned, which is removed later\n            n_neighbors += 1\n\n        train_size = self._fit_X.shape[0]\n        if n_neighbors > train_size:\n            raise ValueError(\n                \"Expected n_neighbors <= n_samples, \"\n                \" but n_samples = %d, n_neighbors = %d\" %\n                (train_size, n_neighbors)\n            )\n",
      "\n        check_is_fitted(self, \"_fit_method\")\n\n        if n_neighbors is None:\n            n_neighbors = self.n_neighbors\n\n        # Validate n_neighbors is an integer\n        if not isinstance(n_neighbors, numbers.Integral):\n            raise TypeError(\"n_neighbors must be an integer, got %s\" % type(n_neighbors).__name__)\n\n        if X is not None:\n            query_is_train = False\n            X = check_array(X, accept_sparse='csr')\n        else:\n            query_is_train = True\n            X = self._fit_X\n            # Include an extra neighbor to account for the sample itself being\n            # returned, which is removed later\n            n_neighbors += 1\n\n        train_size = self._fit_X.shape[0]\n        if n_neighbors > train_size:\n            raise ValueError(\n                \"Expected n_neighbors <= n_samples, \"\n                \" but n_samples = %d, n_neighbors = %d\" %\n                (train_size, n_neighbors)\n            )\n",
      "\n        check_is_fitted(self, \"_fit_method\")\n\n        if n_neighbors is None:\n            n_neighbors = self.n_neighbors\n\n        # Validate n_neighbors parameter\n        if not isinstance(n_neighbors, numbers.Integral):\n            raise TypeError(\"n_neighbors must be an integer, got %s\" % type(n_neighbors).__name__)\n\n        if X is not None:\n            query_is_train = False\n            X = check_array(X, accept_sparse='csr')\n        else:\n            query_is_train = True\n            X = self._fit_X\n            # Include an extra neighbor to account for the sample itself being\n            # returned, which is removed later\n            n_neighbors += 1\n\n        train_size = self._fit_X.shape[0]\n        if n_neighbors > train_size:\n            raise ValueError(\n                \"Expected n_neighbors <= n_samples, \"\n                \" but n_samples = %d, n_neighbors = %d\" %\n                (train_size, n_neighbors)\n            )\n",
      "\n        check_is_fitted(self, \"_fit_method\")\n\n        if n_neighbors is None:\n            n_neighbors = self.n_neighbors\n\n        # Validate n_neighbors is an integer\n        if not isinstance(n_neighbors, numbers.Integral):\n            raise TypeError(\"n_neighbors must be an integer, got %s\" % type(n_neighbors).__name__)\n\n        if X is not None:\n            query_is_train = False\n            X = check_array(X, accept_sparse='csr')\n        else:\n            query_is_train = True\n            X = self._fit_X\n            # Include an extra neighbor to account for the sample itself being\n            # returned, which is removed later\n            n_neighbors += 1\n\n        train_size = self._fit_X.shape[0]\n        if n_neighbors > train_size:\n            raise ValueError(\n                \"Expected n_neighbors <= n_samples, \"\n                \" but n_samples = %d, n_neighbors = %d\" %\n                (train_size, n_neighbors)\n            )\n",
      "\n        check_is_fitted(self, \"_fit_method\")\n\n        if n_neighbors is None:\n            n_neighbors = self.n_neighbors\n        \n        # Validate n_neighbors is an integer\n        if not isinstance(n_neighbors, numbers.Integral):\n            raise TypeError(\"n_neighbors must be an integer, got %s\" % type(n_neighbors).__name__)\n\n        if X is not None:\n            query_is_train = False\n            X = check_array(X, accept_sparse='csr')\n        else:\n            query_is_train = True\n            X = self._fit_X\n            # Include an extra neighbor to account for the sample itself being\n            # returned, which is removed later\n            n_neighbors += 1\n\n        train_size = self._fit_X.shape[0]\n        if n_neighbors > train_size:\n            raise ValueError(\n                \"Expected n_neighbors <= n_samples, \"\n                \" but n_samples = %d, n_neighbors = %d\" %\n                (train_size, n_neighbors)\n            )\n",
      "\n        check_is_fitted(self, \"_fit_method\")\n\n        if n_neighbors is None:\n            n_neighbors = self.n_neighbors\n\n        # Validate n_neighbors is an integer\n        if not isinstance(n_neighbors, numbers.Integral):\n            raise TypeError(\"n_neighbors must be an integer, got %s\" % type(n_neighbors).__name__)\n\n        if X is not None:\n            query_is_train = False\n            X = check_array(X, accept_sparse='csr')\n        else:\n            query_is_train = True\n            X = self._fit_X\n            # Include an extra neighbor to account for the sample itself being\n            # returned, which is removed later\n            n_neighbors += 1\n\n        train_size = self._fit_X.shape[0]\n        if n_neighbors > train_size:\n            raise ValueError(\n                \"Expected n_neighbors <= n_samples, \"\n                \" but n_samples = %d, n_neighbors = %d\" %\n                (train_size, n_neighbors)\n            )\n",
      "\n        check_is_fitted(self, \"_fit_method\")\n\n        if n_neighbors is None:\n            n_neighbors = self.n_neighbors\n\n        # Validate n_neighbors is an integer\n        if n_neighbors is not None and not isinstance(n_neighbors, numbers.Integral):\n            raise TypeError(\"n_neighbors must be an integer, got %s\" % type(n_neighbors).__name__)\n\n        if X is not None:\n            query_is_train = False\n            X = check_array(X, accept_sparse='csr')\n        else:\n            query_is_train = True\n            X = self._fit_X\n            # Include an extra neighbor to account for the sample itself being\n            # returned, which is removed later\n            n_neighbors += 1\n\n        train_size = self._fit_X.shape[0]\n        if n_neighbors > train_size:\n            raise ValueError(\n                \"Expected n_neighbors <= n_samples, \"\n                \" but n_samples = %d, n_neighbors = %d\" %\n                (train_size, n_neighbors)\n            )\n",
      "\n        check_is_fitted(self, \"_fit_method\")\n\n        if n_neighbors is None:\n            n_neighbors = self.n_neighbors\n\n        # Validate n_neighbors is an integer\n        if not isinstance(n_neighbors, numbers.Integral):\n            raise TypeError(\"n_neighbors must be an integer, got %s\" % type(n_neighbors).__name__)\n\n        if X is not None:\n            query_is_train = False\n            X = check_array(X, accept_sparse='csr')\n        else:\n            query_is_train = True\n            X = self._fit_X\n            # Include an extra neighbor to account for the sample itself being\n            # returned, which is removed later\n            n_neighbors += 1\n\n        train_size = self._fit_X.shape[0]\n        if n_neighbors > train_size:\n            raise ValueError(\n                \"Expected n_neighbors <= n_samples, \"\n                \" but n_samples = %d, n_neighbors = %d\" %\n                (train_size, n_neighbors)\n            )\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sklearn/neighbors/base.py b/sklearn/neighbors/base.py\nindex 3e5e729c2..694d07558 100644\n--- a/sklearn/neighbors/base.py\n+++ b/sklearn/neighbors/base.py\n@@ -103,6 +103,7 @@ class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n     \"\"\"Base class for nearest neighbors estimators.\"\"\"\n \n     @abstractmethod\n+\n     def __init__(self, n_neighbors=None, radius=None,\n                  algorithm='auto', leaf_size=30, metric='minkowski',\n                  p=2, metric_params=None, n_jobs=1):\n@@ -115,6 +116,13 @@ class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n         self.metric_params = metric_params\n         self.p = p\n         self.n_jobs = n_jobs\n+        \n+        # Validate n_neighbors parameter\n+        if self.n_neighbors is not None:\n+            if not isinstance(self.n_neighbors, (int, np.integer)):\n+                raise TypeError(\"n_neighbors must be an integer, got %s\" \n+                              % type(self.n_neighbors).__name__)\n+        \n         self._check_algorithm_metric()\n \n     def _check_algorithm_metric(self):\n@@ -323,11 +331,18 @@ class KNeighborsMixin(object):\n                [2]]...)\n \n         \"\"\"\n+\n         check_is_fitted(self, \"_fit_method\")\n \n         if n_neighbors is None:\n             n_neighbors = self.n_neighbors\n \n+        # Validate n_neighbors parameter\n+        if n_neighbors is not None:\n+            if not isinstance(n_neighbors, (int, np.integer)):\n+                raise TypeError(\"n_neighbors must be an integer, got %s\" \n+                              % type(n_neighbors).__name__)\n+\n         if X is not None:\n             query_is_train = False\n             X = check_array(X, accept_sparse='csr')\n",
    "variant_0": "diff --git a/sklearn/neighbors/base.py b/sklearn/neighbors/base.py\nindex 3e5e729c2..7ad74b395 100644\n--- a/sklearn/neighbors/base.py\n+++ b/sklearn/neighbors/base.py\n@@ -102,12 +102,16 @@ def _get_weights(dist, weights):\n class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n     \"\"\"Base class for nearest neighbors estimators.\"\"\"\n \n+    @abstractmethod\n+\n     @abstractmethod\n     def __init__(self, n_neighbors=None, radius=None,\n                  algorithm='auto', leaf_size=30, metric='minkowski',\n                  p=2, metric_params=None, n_jobs=1):\n \n         self.n_neighbors = n_neighbors\n+        if n_neighbors is not None and not isinstance(n_neighbors, numbers.Integral):\n+            raise TypeError(\"n_neighbors must be an integer, got %s\" % type(n_neighbors).__name__)\n         self.radius = radius\n         self.algorithm = algorithm\n         self.leaf_size = leaf_size\n@@ -323,11 +327,16 @@ class KNeighborsMixin(object):\n                [2]]...)\n \n         \"\"\"\n+\n         check_is_fitted(self, \"_fit_method\")\n \n         if n_neighbors is None:\n             n_neighbors = self.n_neighbors\n \n+        # Validate n_neighbors is an integer\n+        if not isinstance(n_neighbors, numbers.Integral):\n+            raise TypeError(\"n_neighbors must be an integer, got %s\" % type(n_neighbors).__name__)\n+\n         if X is not None:\n             query_is_train = False\n             X = check_array(X, accept_sparse='csr')\n",
    "variant_1": "diff --git a/sklearn/neighbors/base.py b/sklearn/neighbors/base.py\nindex 3e5e729c2..7ad74b395 100644\n--- a/sklearn/neighbors/base.py\n+++ b/sklearn/neighbors/base.py\n@@ -102,12 +102,16 @@ def _get_weights(dist, weights):\n class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n     \"\"\"Base class for nearest neighbors estimators.\"\"\"\n \n+    @abstractmethod\n+\n     @abstractmethod\n     def __init__(self, n_neighbors=None, radius=None,\n                  algorithm='auto', leaf_size=30, metric='minkowski',\n                  p=2, metric_params=None, n_jobs=1):\n \n         self.n_neighbors = n_neighbors\n+        if n_neighbors is not None and not isinstance(n_neighbors, numbers.Integral):\n+            raise TypeError(\"n_neighbors must be an integer, got %s\" % type(n_neighbors).__name__)\n         self.radius = radius\n         self.algorithm = algorithm\n         self.leaf_size = leaf_size\n@@ -323,11 +327,16 @@ class KNeighborsMixin(object):\n                [2]]...)\n \n         \"\"\"\n+\n         check_is_fitted(self, \"_fit_method\")\n \n         if n_neighbors is None:\n             n_neighbors = self.n_neighbors\n \n+        # Validate n_neighbors is an integer\n+        if not isinstance(n_neighbors, numbers.Integral):\n+            raise TypeError(\"n_neighbors must be an integer, got %s\" % type(n_neighbors).__name__)\n+\n         if X is not None:\n             query_is_train = False\n             X = check_array(X, accept_sparse='csr')\n",
    "variant_2": "diff --git a/sklearn/neighbors/base.py b/sklearn/neighbors/base.py\nindex 3e5e729c2..7ad74b395 100644\n--- a/sklearn/neighbors/base.py\n+++ b/sklearn/neighbors/base.py\n@@ -102,12 +102,16 @@ def _get_weights(dist, weights):\n class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n     \"\"\"Base class for nearest neighbors estimators.\"\"\"\n \n+    @abstractmethod\n+\n     @abstractmethod\n     def __init__(self, n_neighbors=None, radius=None,\n                  algorithm='auto', leaf_size=30, metric='minkowski',\n                  p=2, metric_params=None, n_jobs=1):\n \n         self.n_neighbors = n_neighbors\n+        if n_neighbors is not None and not isinstance(n_neighbors, numbers.Integral):\n+            raise TypeError(\"n_neighbors must be an integer, got %s\" % type(n_neighbors).__name__)\n         self.radius = radius\n         self.algorithm = algorithm\n         self.leaf_size = leaf_size\n@@ -323,11 +327,16 @@ class KNeighborsMixin(object):\n                [2]]...)\n \n         \"\"\"\n+\n         check_is_fitted(self, \"_fit_method\")\n \n         if n_neighbors is None:\n             n_neighbors = self.n_neighbors\n \n+        # Validate n_neighbors is an integer\n+        if not isinstance(n_neighbors, numbers.Integral):\n+            raise TypeError(\"n_neighbors must be an integer, got %s\" % type(n_neighbors).__name__)\n+\n         if X is not None:\n             query_is_train = False\n             X = check_array(X, accept_sparse='csr')\n",
    "variant_3": "diff --git a/sklearn/neighbors/base.py b/sklearn/neighbors/base.py\nindex 3e5e729c2..c328d9dbc 100644\n--- a/sklearn/neighbors/base.py\n+++ b/sklearn/neighbors/base.py\n@@ -102,12 +102,16 @@ def _get_weights(dist, weights):\n class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n     \"\"\"Base class for nearest neighbors estimators.\"\"\"\n \n+    @abstractmethod\n+\n     @abstractmethod\n     def __init__(self, n_neighbors=None, radius=None,\n                  algorithm='auto', leaf_size=30, metric='minkowski',\n                  p=2, metric_params=None, n_jobs=1):\n \n         self.n_neighbors = n_neighbors\n+        if n_neighbors is not None and not isinstance(n_neighbors, numbers.Integral):\n+            raise TypeError(\"n_neighbors must be an integer, got %s\" % type(n_neighbors).__name__)\n         self.radius = radius\n         self.algorithm = algorithm\n         self.leaf_size = leaf_size\n@@ -323,11 +327,16 @@ class KNeighborsMixin(object):\n                [2]]...)\n \n         \"\"\"\n+\n         check_is_fitted(self, \"_fit_method\")\n \n         if n_neighbors is None:\n             n_neighbors = self.n_neighbors\n \n+        # Validate n_neighbors parameter\n+        if not isinstance(n_neighbors, numbers.Integral):\n+            raise TypeError(\"n_neighbors must be an integer, got %s\" % type(n_neighbors).__name__)\n+\n         if X is not None:\n             query_is_train = False\n             X = check_array(X, accept_sparse='csr')\n",
    "variant_4": "diff --git a/sklearn/neighbors/base.py b/sklearn/neighbors/base.py\nindex 3e5e729c2..db45b1e7f 100644\n--- a/sklearn/neighbors/base.py\n+++ b/sklearn/neighbors/base.py\n@@ -102,12 +102,18 @@ def _get_weights(dist, weights):\n class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n     \"\"\"Base class for nearest neighbors estimators.\"\"\"\n \n+    @abstractmethod\n+\n     @abstractmethod\n     def __init__(self, n_neighbors=None, radius=None,\n                  algorithm='auto', leaf_size=30, metric='minkowski',\n                  p=2, metric_params=None, n_jobs=1):\n \n         self.n_neighbors = n_neighbors\n+        # Validate n_neighbors parameter\n+        if n_neighbors is not None and not isinstance(n_neighbors, int):\n+            raise TypeError(\"n_neighbors must be an integer, got {}\"\n+                          .format(type(n_neighbors).__name__))\n         self.radius = radius\n         self.algorithm = algorithm\n         self.leaf_size = leaf_size\n@@ -323,11 +329,16 @@ class KNeighborsMixin(object):\n                [2]]...)\n \n         \"\"\"\n+\n         check_is_fitted(self, \"_fit_method\")\n \n         if n_neighbors is None:\n             n_neighbors = self.n_neighbors\n \n+        # Validate n_neighbors is an integer\n+        if not isinstance(n_neighbors, numbers.Integral):\n+            raise TypeError(\"n_neighbors must be an integer, got %s\" % type(n_neighbors).__name__)\n+\n         if X is not None:\n             query_is_train = False\n             X = check_array(X, accept_sparse='csr')\n",
    "variant_5": "diff --git a/sklearn/neighbors/base.py b/sklearn/neighbors/base.py\nindex 3e5e729c2..74c0bce76 100644\n--- a/sklearn/neighbors/base.py\n+++ b/sklearn/neighbors/base.py\n@@ -102,12 +102,16 @@ def _get_weights(dist, weights):\n class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n     \"\"\"Base class for nearest neighbors estimators.\"\"\"\n \n+    @abstractmethod\n+\n     @abstractmethod\n     def __init__(self, n_neighbors=None, radius=None,\n                  algorithm='auto', leaf_size=30, metric='minkowski',\n                  p=2, metric_params=None, n_jobs=1):\n \n         self.n_neighbors = n_neighbors\n+        if n_neighbors is not None and not isinstance(n_neighbors, numbers.Integral):\n+            raise TypeError(\"n_neighbors must be an integer, got %s\" % type(n_neighbors).__name__)\n         self.radius = radius\n         self.algorithm = algorithm\n         self.leaf_size = leaf_size\n@@ -323,10 +327,15 @@ class KNeighborsMixin(object):\n                [2]]...)\n \n         \"\"\"\n+\n         check_is_fitted(self, \"_fit_method\")\n \n         if n_neighbors is None:\n             n_neighbors = self.n_neighbors\n+        \n+        # Validate n_neighbors is an integer\n+        if not isinstance(n_neighbors, numbers.Integral):\n+            raise TypeError(\"n_neighbors must be an integer, got %s\" % type(n_neighbors).__name__)\n \n         if X is not None:\n             query_is_train = False\n",
    "variant_6": "diff --git a/sklearn/neighbors/base.py b/sklearn/neighbors/base.py\nindex 3e5e729c2..7ad74b395 100644\n--- a/sklearn/neighbors/base.py\n+++ b/sklearn/neighbors/base.py\n@@ -102,12 +102,16 @@ def _get_weights(dist, weights):\n class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n     \"\"\"Base class for nearest neighbors estimators.\"\"\"\n \n+    @abstractmethod\n+\n     @abstractmethod\n     def __init__(self, n_neighbors=None, radius=None,\n                  algorithm='auto', leaf_size=30, metric='minkowski',\n                  p=2, metric_params=None, n_jobs=1):\n \n         self.n_neighbors = n_neighbors\n+        if n_neighbors is not None and not isinstance(n_neighbors, numbers.Integral):\n+            raise TypeError(\"n_neighbors must be an integer, got %s\" % type(n_neighbors).__name__)\n         self.radius = radius\n         self.algorithm = algorithm\n         self.leaf_size = leaf_size\n@@ -323,11 +327,16 @@ class KNeighborsMixin(object):\n                [2]]...)\n \n         \"\"\"\n+\n         check_is_fitted(self, \"_fit_method\")\n \n         if n_neighbors is None:\n             n_neighbors = self.n_neighbors\n \n+        # Validate n_neighbors is an integer\n+        if not isinstance(n_neighbors, numbers.Integral):\n+            raise TypeError(\"n_neighbors must be an integer, got %s\" % type(n_neighbors).__name__)\n+\n         if X is not None:\n             query_is_train = False\n             X = check_array(X, accept_sparse='csr')\n",
    "variant_7": "diff --git a/sklearn/neighbors/base.py b/sklearn/neighbors/base.py\nindex 3e5e729c2..1fe2df949 100644\n--- a/sklearn/neighbors/base.py\n+++ b/sklearn/neighbors/base.py\n@@ -102,12 +102,16 @@ def _get_weights(dist, weights):\n class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n     \"\"\"Base class for nearest neighbors estimators.\"\"\"\n \n+    @abstractmethod\n+\n     @abstractmethod\n     def __init__(self, n_neighbors=None, radius=None,\n                  algorithm='auto', leaf_size=30, metric='minkowski',\n                  p=2, metric_params=None, n_jobs=1):\n \n         self.n_neighbors = n_neighbors\n+        if n_neighbors is not None and not isinstance(n_neighbors, numbers.Integral):\n+            raise TypeError(\"n_neighbors must be an integer, got %s\" % type(n_neighbors).__name__)\n         self.radius = radius\n         self.algorithm = algorithm\n         self.leaf_size = leaf_size\n@@ -323,11 +327,16 @@ class KNeighborsMixin(object):\n                [2]]...)\n \n         \"\"\"\n+\n         check_is_fitted(self, \"_fit_method\")\n \n         if n_neighbors is None:\n             n_neighbors = self.n_neighbors\n \n+        # Validate n_neighbors is an integer\n+        if n_neighbors is not None and not isinstance(n_neighbors, numbers.Integral):\n+            raise TypeError(\"n_neighbors must be an integer, got %s\" % type(n_neighbors).__name__)\n+\n         if X is not None:\n             query_is_train = False\n             X = check_array(X, accept_sparse='csr')\n",
    "variant_8": "diff --git a/sklearn/neighbors/base.py b/sklearn/neighbors/base.py\nindex 3e5e729c2..ec5581a1b 100644\n--- a/sklearn/neighbors/base.py\n+++ b/sklearn/neighbors/base.py\n@@ -102,12 +102,16 @@ def _get_weights(dist, weights):\n class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n     \"\"\"Base class for nearest neighbors estimators.\"\"\"\n \n+    @abstractmethod\n+\n     @abstractmethod\n     def __init__(self, n_neighbors=None, radius=None,\n                  algorithm='auto', leaf_size=30, metric='minkowski',\n                  p=2, metric_params=None, n_jobs=1):\n \n         self.n_neighbors = n_neighbors\n+        if n_neighbors is not None and not isinstance(n_neighbors, int):\n+            raise TypeError(\"n_neighbors must be an integer, got %s\" % type(n_neighbors).__name__)\n         self.radius = radius\n         self.algorithm = algorithm\n         self.leaf_size = leaf_size\n@@ -323,11 +327,16 @@ class KNeighborsMixin(object):\n                [2]]...)\n \n         \"\"\"\n+\n         check_is_fitted(self, \"_fit_method\")\n \n         if n_neighbors is None:\n             n_neighbors = self.n_neighbors\n \n+        # Validate n_neighbors is an integer\n+        if not isinstance(n_neighbors, numbers.Integral):\n+            raise TypeError(\"n_neighbors must be an integer, got %s\" % type(n_neighbors).__name__)\n+\n         if X is not None:\n             query_is_train = False\n             X = check_array(X, accept_sparse='csr')\n"
  }
}