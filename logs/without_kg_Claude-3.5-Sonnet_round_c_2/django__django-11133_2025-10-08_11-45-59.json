{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/django/django/http/response.py lines 236-237)": "\n    def make_bytes(self, value):\n        \"\"\"Turn a value into a bytestring encoded in the output charset.\"\"\"\n        # Per PEP 3333, this response body must be bytes. To avoid the\n        # overhead on Python 2 of calling conditional_escape before\n        # bytes(value), we skip the conditional_escape call on bytes objects.\n        # This should only happen either when HttpResponse is initialized\n        # with bytes, or when the data is retrieved from the cache backend\n        # and is already a bytes instance.\n\n        # Handle string types -- we can't rely on force_bytes here because:\n        # - Python attempts str conversion first\n        # - when self._charset != 'utf-8' it re-encodes the content\n        if isinstance(value, bytes):\n            return bytes(value)\n        if isinstance(value, str):\n            return bytes(value.encode(self.charset))\n        if isinstance(value, memoryview):\n            return bytes(value)\n        # Handle non-string types.\n        return str(value).encode(self.charset)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/django/django/http/response.py lines 236-237)": [
      "\n    def make_bytes(self, value):\n        \"\"\"Turn a value into a bytestring encoded in the output charset.\"\"\"\n        # Per PEP 3333, this response body must be bytes. To avoid the\n        # overhead of conversion when using JsonResponse and friends, we\n        # use __bytes__ when available, and encode strings here.\n        #\n        # Also, we can't use bytes() here because, although the returned\n        # value will be bytes, if the argument is an instance of a subclass\n        # of bytes, this function returns `bytes(value)`.\n        # This doesn't make a copy when `value` already contains bytes.\n\n        # Handle string types -- we can't rely on force_bytes here because:\n        # - Python attempts str conversion first\n        # - when self._charset != 'utf-8' it re-encodes the content\n        if isinstance(value, bytes):\n            return bytes(value)\n        if isinstance(value, str):\n            return bytes(value.encode(self.charset))\n        if isinstance(value, memoryview):\n            return bytes(value)\n        # Handle non-string types.\n        return str(value).encode(self.charset)\n",
      "\n    def make_bytes(self, value):\n        \"\"\"Turn a value into a bytestring encoded in the output charset.\"\"\"\n        # Per PEP 3333, this response body must be bytes. To avoid the\n        # overhead on Python 2 of calling conditional_escape after\n        # closing the iterator, we return `bytes(value)` when the value\n        # is an instance of a subclass, this function returns `bytes(value)`.\n        # This doesn't make a copy when `value` already contains bytes.\n\n        # Handle string types -- we can't rely on force_bytes here because:\n        # - Python attempts str conversion first\n        # - when self._charset != 'utf-8' it re-encodes the content\n        if isinstance(value, bytes):\n            return bytes(value)\n        if isinstance(value, str):\n            return bytes(value.encode(self.charset))\n        if isinstance(value, memoryview):\n            return bytes(value)\n        # Handle non-string types.\n        return str(value).encode(self.charset)\n",
      "\n    def make_bytes(self, value):\n        \"\"\"Turn a value into a bytestring encoded in the output charset.\"\"\"\n        # Per PEP 3333, this response body must be bytes. To avoid the\n        # overhead on Python 2 of calling isinstance(value, six.binary_type)\n        # at runtime, we do different compilations here and in the upload\n        # handling code (flup). This works because bytes_type.__class__ is type\n        # (it's a base type) and bytes_type.__class__.__module__ is builtins.\n        # Also, this code won't be hit on Python 2, since the content-type\n        # checks above will always succeed on that version.\n\n        # Handle string types -- we can't rely on force_bytes here because:\n        # - Python attempts str conversion first\n        # - when self._charset != 'utf-8' it re-encodes the content\n        if isinstance(value, bytes):\n            return bytes(value)\n        if isinstance(value, str):\n            return bytes(value.encode(self.charset))\n        if isinstance(value, memoryview):\n            return bytes(value)\n        # Handle non-string types.\n        return str(value).encode(self.charset)\n",
      "\n    def make_bytes(self, value):\n        \"\"\"Turn a value into a bytestring encoded in the output charset.\"\"\"\n        # Per PEP 3333, this response body must be bytes. To avoid the\n        # overhead on Python 2 of calling conditional_escape before\n        # calling force_bytes, we skip the conditional_escape step on\n        # bytes, SafeBytes, and SafeText since bytes(value) doesn't call\n        # __html__ on SafeBytes and SafeText.\n        if value is None:\n            return b''\n\n        # Handle the common case of a string without calling force_bytes().\n        # This avoids the overhead of the isinstance() calls in force_bytes().\n        if isinstance(value, bytes):\n            return value\n\n        # force_bytes will call force_str on all other types.\n        return force_bytes(value, self.charset)\n\n    def _consume_content(self):\n        # If the response was instantiated with an iterator, we need to\n        # consume the iterator and convert it to bytes.\n        if self._container is None:\n            self._container = b''.join(self.make_bytes(chunk) for chunk in self._container_iter)\n\n    def make_bytes(self, value):\n        \"\"\"Turn a value into a bytestring encoded in the output charset.\"\"\"\n        # Per PEP 3333, this response body must be bytes. To avoid the\n        # overhead on Python 2 of calling conditional_escape before\n        # calling force_bytes, we skip the conditional_escape step on\n        # bytes, SafeBytes, and SafeText since bytes(value) doesn't call\n        # __html__ on SafeBytes and SafeText.\n\n        # Handle the common case first\n        # This avoids the overhead of the isinstance() calls in force_bytes().\n        # This should be the *only* path that matters in most code.\n        # If your HttpResponse is getting non-string, non-bytes data, you are\n        # probably doing something wrong. But, if you do, here's how we\n        # handle it.\n\n        # Note that this is somewhat different from the equivalent function in\n        # django.utils.encoding.force_bytes, because we are guaranteed that\n        # this function will only be called with the output of render(), and\n        # render() always returns a SafeString (unless the template contains\n        # a SafeString, in which case it returns a SafeString as well).\n\n        # Given that we are guaranteed that the input is a string-like object\n        # (either bytes, str, SafeBytes or SafeString), this function should\n        # only be called with bytes or string values.\n\n        # However, when called with a subclass of bytes, such as SafeBytes,\n        # this function returns `bytes(value)`. This is because we don't want\n        # to call SafeBytes.__str__(), but instead want to call bytes().\n\n        # If this function is called with a subclass of str, such as SafeString,\n        # then we want to call SafeString.encode(), not bytes().\n\n        # However, if this function is called with some other value, such as\n        # an instance of a subclass, this function returns `bytes(value)`.\n        # This doesn't make a copy when `value` already contains bytes.\n\n        # Handle string types -- we can't rely on force_bytes here because:\n        # - Python attempts str conversion first\n        # - when self._charset != 'utf-8' it re-encodes the content\n        if isinstance(value, bytes):\n            return bytes(value)\n        if isinstance(value, str):\n            return bytes(value.encode(self.charset))\n        if isinstance(value, memoryview):\n            return bytes(value)\n        # Handle non-string types.\n        return str(value).encode(self.charset)\n",
      "\n    def make_bytes(self, value):\n        \"\"\"Turn a value into a bytestring encoded in the output charset.\"\"\"\n        # Per PEP 3333, this response body must be bytes. To avoid the\n        # overhead on Python 2 of calling conditional_escape before\n        # calling force_bytes, we skip straight to force_bytes, but this\n        # makes the following assumptions:\n        # * all byte strings will be returned unchanged\n        # * strings will be returned unchanged except for encoding\n        # * all other objects will be converted first to a string, then\n        #   to bytes\n        #\n        # When a subclass assignment is made with `bytes(value)` it calls\n        # the subclass method `__bytes__()`. When the response object is\n        # an instance of a subclass, this function returns `bytes(value)`.\n        # This doesn't make a copy when `value` already contains bytes.\n\n        # Handle string types -- we can't rely on force_bytes here because:\n        # - Python attempts str conversion first\n        # - when self._charset != 'utf-8' it re-encodes the content\n        if isinstance(value, bytes):\n            return bytes(value)\n        if isinstance(value, str):\n            return bytes(value.encode(self.charset))\n        if isinstance(value, memoryview):\n            return bytes(value)\n        # Handle non-string types.\n        return str(value).encode(self.charset)\n",
      "\n    def make_bytes(self, value):\n        \"\"\"Turn a value into a bytestring encoded in the output charset.\"\"\"\n        # Per PEP 3333, this response body must be bytes. To avoid the\n        # overhead on Python 2 of calling conditional_escape before\n        # calling force_bytes, we skip the conditional_escape step on\n        # bytes, SafeBytes, and SafeText objects.\n        if isinstance(value, bytes):\n            return bytes(value)\n        if isinstance(value, str):\n            return bytes(value.encode(self.charset))\n        if isinstance(value, memoryview):\n            return bytes(value)\n        # Handle non-string types.\n        return str(value).encode(self.charset)\n",
      "\n    def make_bytes(self, value):\n        \"\"\"Turn a value into a bytestring encoded in the output charset.\"\"\"\n        # Per PEP 3333, this response body must be bytes. To avoid the\n        # overhead of unused chunked encoding, we encode here rather\n        # than in self.write() so that the updated self.content is also\n        # bytes.\n\n        # Handle the common case of a bytes subclass. In Python 2, this\n        # includes str; in Python 3, this separately handles bytes and\n        # bytearray, and a few other types. In Python 2, this may also\n        # include the `buffer` type.\n\n        # Encode strings with the configured charset.\n\n        # Force evaluation if it's a lazy object, e.g. HttpRequest.body.\n        # When value is an instance of a subclass, this function returns `bytes(value)`.\n        # This doesn't make a copy when `value` already contains bytes.\n\n        # Handle string types -- we can't rely on force_bytes here because:\n        # - Python attempts str conversion first\n        # - when self._charset != 'utf-8' it re-encodes the content\n        if isinstance(value, bytes):\n            return bytes(value)\n        if isinstance(value, str):\n            return bytes(value.encode(self.charset))\n        # Handle memoryview objects.\n        if isinstance(value, memoryview):\n            return bytes(value)\n        # Handle non-string types.\n        return str(value).encode(self.charset)\n",
      "\n    def make_bytes(self, value):\n        \"\"\"Turn a value into a bytestring encoded in the output charset.\"\"\"\n        # Per PEP 3333, this response body must be bytes. To avoid the\n        # overhead of doing this conversion on each write when we know we'll\n        # get mostly strings, we do the conversion here, once.\n        #\n        # Note that we do *not* attempt bytes conversion first because it would\n        # double-encode strings.\n        #\n        # Note also that we can't use smart_bytes here because it would\n        # double-encode when self._charset != 'utf-8' (e.g. HttpResponseRedirect\n        # after a POST with non-ASCII data)\n        #\n        # Finally, when dealing with subclasses of bytes that may not be\n        # an instance of a subclass, this function returns `bytes(value)`.\n        # This doesn't make a copy when `value` already contains bytes.\n\n        # Handle string types -- we can't rely on force_bytes here because:\n        # - Python attempts str conversion first\n        # - when self._charset != 'utf-8' it re-encodes the content\n        if isinstance(value, bytes):\n            return bytes(value)\n        if isinstance(value, str):\n            return bytes(value.encode(self.charset))\n        if isinstance(value, memoryview):\n            return bytes(value)\n        # Handle non-string types.\n        return str(value).encode(self.charset)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/http/response.py b/django/http/response.py\nindex 6a84e193ba..1be6cbceaf 100644\n--- a/django/http/response.py\n+++ b/django/http/response.py\n@@ -233,7 +233,10 @@ class HttpResponseBase:\n             return bytes(value)\n         if isinstance(value, str):\n             return bytes(value.encode(self.charset))\n+\n         # Handle non-string types.\n+        if isinstance(value, memoryview):\n+            return bytes(value)\n         return str(value).encode(self.charset)\n \n     # These methods partially implement the file-like object interface.\n",
    "variant_0": "diff --git a/django/http/response.py b/django/http/response.py\nindex 6a84e193ba..9c849ae040 100644\n--- a/django/http/response.py\n+++ b/django/http/response.py\n@@ -233,6 +233,25 @@ class HttpResponseBase:\n             return bytes(value)\n         if isinstance(value, str):\n             return bytes(value.encode(self.charset))\n+\n+    def make_bytes(self, value):\n+        \"\"\"Turn a value into a bytestring encoded in the output charset.\"\"\"\n+        # Per PEP 3333, this response body must be bytes. To avoid the\n+        # overhead on Python 2 of calling conditional_escape before\n+        # bytes(value), we skip the conditional_escape call on bytes objects.\n+        # This should only happen either when HttpResponse is initialized\n+        # with bytes, or when the data is retrieved from the cache backend\n+        # and is already a bytes instance.\n+\n+        # Handle string types -- we can't rely on force_bytes here because:\n+        # - Python attempts str conversion first\n+        # - when self._charset != 'utf-8' it re-encodes the content\n+        if isinstance(value, bytes):\n+            return bytes(value)\n+        if isinstance(value, str):\n+            return bytes(value.encode(self.charset))\n+        if isinstance(value, memoryview):\n+            return bytes(value)\n         # Handle non-string types.\n         return str(value).encode(self.charset)\n \n",
    "variant_1": "diff --git a/django/http/response.py b/django/http/response.py\nindex 6a84e193ba..f79397faeb 100644\n--- a/django/http/response.py\n+++ b/django/http/response.py\n@@ -233,6 +233,27 @@ class HttpResponseBase:\n             return bytes(value)\n         if isinstance(value, str):\n             return bytes(value.encode(self.charset))\n+\n+    def make_bytes(self, value):\n+        \"\"\"Turn a value into a bytestring encoded in the output charset.\"\"\"\n+        # Per PEP 3333, this response body must be bytes. To avoid the\n+        # overhead of conversion when using JsonResponse and friends, we\n+        # use __bytes__ when available, and encode strings here.\n+        #\n+        # Also, we can't use bytes() here because, although the returned\n+        # value will be bytes, if the argument is an instance of a subclass\n+        # of bytes, this function returns `bytes(value)`.\n+        # This doesn't make a copy when `value` already contains bytes.\n+\n+        # Handle string types -- we can't rely on force_bytes here because:\n+        # - Python attempts str conversion first\n+        # - when self._charset != 'utf-8' it re-encodes the content\n+        if isinstance(value, bytes):\n+            return bytes(value)\n+        if isinstance(value, str):\n+            return bytes(value.encode(self.charset))\n+        if isinstance(value, memoryview):\n+            return bytes(value)\n         # Handle non-string types.\n         return str(value).encode(self.charset)\n \n",
    "variant_2": "diff --git a/django/http/response.py b/django/http/response.py\nindex 6a84e193ba..85704c0134 100644\n--- a/django/http/response.py\n+++ b/django/http/response.py\n@@ -233,6 +233,24 @@ class HttpResponseBase:\n             return bytes(value)\n         if isinstance(value, str):\n             return bytes(value.encode(self.charset))\n+\n+    def make_bytes(self, value):\n+        \"\"\"Turn a value into a bytestring encoded in the output charset.\"\"\"\n+        # Per PEP 3333, this response body must be bytes. To avoid the\n+        # overhead on Python 2 of calling conditional_escape after\n+        # closing the iterator, we return `bytes(value)` when the value\n+        # is an instance of a subclass, this function returns `bytes(value)`.\n+        # This doesn't make a copy when `value` already contains bytes.\n+\n+        # Handle string types -- we can't rely on force_bytes here because:\n+        # - Python attempts str conversion first\n+        # - when self._charset != 'utf-8' it re-encodes the content\n+        if isinstance(value, bytes):\n+            return bytes(value)\n+        if isinstance(value, str):\n+            return bytes(value.encode(self.charset))\n+        if isinstance(value, memoryview):\n+            return bytes(value)\n         # Handle non-string types.\n         return str(value).encode(self.charset)\n \n",
    "variant_3": "diff --git a/django/http/response.py b/django/http/response.py\nindex 6a84e193ba..b1098619d0 100644\n--- a/django/http/response.py\n+++ b/django/http/response.py\n@@ -233,6 +233,26 @@ class HttpResponseBase:\n             return bytes(value)\n         if isinstance(value, str):\n             return bytes(value.encode(self.charset))\n+\n+    def make_bytes(self, value):\n+        \"\"\"Turn a value into a bytestring encoded in the output charset.\"\"\"\n+        # Per PEP 3333, this response body must be bytes. To avoid the\n+        # overhead on Python 2 of calling isinstance(value, six.binary_type)\n+        # at runtime, we do different compilations here and in the upload\n+        # handling code (flup). This works because bytes_type.__class__ is type\n+        # (it's a base type) and bytes_type.__class__.__module__ is builtins.\n+        # Also, this code won't be hit on Python 2, since the content-type\n+        # checks above will always succeed on that version.\n+\n+        # Handle string types -- we can't rely on force_bytes here because:\n+        # - Python attempts str conversion first\n+        # - when self._charset != 'utf-8' it re-encodes the content\n+        if isinstance(value, bytes):\n+            return bytes(value)\n+        if isinstance(value, str):\n+            return bytes(value.encode(self.charset))\n+        if isinstance(value, memoryview):\n+            return bytes(value)\n         # Handle non-string types.\n         return str(value).encode(self.charset)\n \n",
    "variant_4": "diff --git a/django/http/response.py b/django/http/response.py\nindex 6a84e193ba..c3e8f8022f 100644\n--- a/django/http/response.py\n+++ b/django/http/response.py\n@@ -233,6 +233,76 @@ class HttpResponseBase:\n             return bytes(value)\n         if isinstance(value, str):\n             return bytes(value.encode(self.charset))\n+\n+    def make_bytes(self, value):\n+        \"\"\"Turn a value into a bytestring encoded in the output charset.\"\"\"\n+        # Per PEP 3333, this response body must be bytes. To avoid the\n+        # overhead on Python 2 of calling conditional_escape before\n+        # calling force_bytes, we skip the conditional_escape step on\n+        # bytes, SafeBytes, and SafeText since bytes(value) doesn't call\n+        # __html__ on SafeBytes and SafeText.\n+        if value is None:\n+            return b''\n+\n+        # Handle the common case of a string without calling force_bytes().\n+        # This avoids the overhead of the isinstance() calls in force_bytes().\n+        if isinstance(value, bytes):\n+            return value\n+\n+        # force_bytes will call force_str on all other types.\n+        return force_bytes(value, self.charset)\n+\n+    def _consume_content(self):\n+        # If the response was instantiated with an iterator, we need to\n+        # consume the iterator and convert it to bytes.\n+        if self._container is None:\n+            self._container = b''.join(self.make_bytes(chunk) for chunk in self._container_iter)\n+\n+    def make_bytes(self, value):\n+        \"\"\"Turn a value into a bytestring encoded in the output charset.\"\"\"\n+        # Per PEP 3333, this response body must be bytes. To avoid the\n+        # overhead on Python 2 of calling conditional_escape before\n+        # calling force_bytes, we skip the conditional_escape step on\n+        # bytes, SafeBytes, and SafeText since bytes(value) doesn't call\n+        # __html__ on SafeBytes and SafeText.\n+\n+        # Handle the common case first\n+        # This avoids the overhead of the isinstance() calls in force_bytes().\n+        # This should be the *only* path that matters in most code.\n+        # If your HttpResponse is getting non-string, non-bytes data, you are\n+        # probably doing something wrong. But, if you do, here's how we\n+        # handle it.\n+\n+        # Note that this is somewhat different from the equivalent function in\n+        # django.utils.encoding.force_bytes, because we are guaranteed that\n+        # this function will only be called with the output of render(), and\n+        # render() always returns a SafeString (unless the template contains\n+        # a SafeString, in which case it returns a SafeString as well).\n+\n+        # Given that we are guaranteed that the input is a string-like object\n+        # (either bytes, str, SafeBytes or SafeString), this function should\n+        # only be called with bytes or string values.\n+\n+        # However, when called with a subclass of bytes, such as SafeBytes,\n+        # this function returns `bytes(value)`. This is because we don't want\n+        # to call SafeBytes.__str__(), but instead want to call bytes().\n+\n+        # If this function is called with a subclass of str, such as SafeString,\n+        # then we want to call SafeString.encode(), not bytes().\n+\n+        # However, if this function is called with some other value, such as\n+        # an instance of a subclass, this function returns `bytes(value)`.\n+        # This doesn't make a copy when `value` already contains bytes.\n+\n+        # Handle string types -- we can't rely on force_bytes here because:\n+        # - Python attempts str conversion first\n+        # - when self._charset != 'utf-8' it re-encodes the content\n+        if isinstance(value, bytes):\n+            return bytes(value)\n+        if isinstance(value, str):\n+            return bytes(value.encode(self.charset))\n+        if isinstance(value, memoryview):\n+            return bytes(value)\n         # Handle non-string types.\n         return str(value).encode(self.charset)\n \n",
    "variant_5": "diff --git a/django/http/response.py b/django/http/response.py\nindex 6a84e193ba..431ccca1ec 100644\n--- a/django/http/response.py\n+++ b/django/http/response.py\n@@ -233,6 +233,32 @@ class HttpResponseBase:\n             return bytes(value)\n         if isinstance(value, str):\n             return bytes(value.encode(self.charset))\n+\n+    def make_bytes(self, value):\n+        \"\"\"Turn a value into a bytestring encoded in the output charset.\"\"\"\n+        # Per PEP 3333, this response body must be bytes. To avoid the\n+        # overhead on Python 2 of calling conditional_escape before\n+        # calling force_bytes, we skip straight to force_bytes, but this\n+        # makes the following assumptions:\n+        # * all byte strings will be returned unchanged\n+        # * strings will be returned unchanged except for encoding\n+        # * all other objects will be converted first to a string, then\n+        #   to bytes\n+        #\n+        # When a subclass assignment is made with `bytes(value)` it calls\n+        # the subclass method `__bytes__()`. When the response object is\n+        # an instance of a subclass, this function returns `bytes(value)`.\n+        # This doesn't make a copy when `value` already contains bytes.\n+\n+        # Handle string types -- we can't rely on force_bytes here because:\n+        # - Python attempts str conversion first\n+        # - when self._charset != 'utf-8' it re-encodes the content\n+        if isinstance(value, bytes):\n+            return bytes(value)\n+        if isinstance(value, str):\n+            return bytes(value.encode(self.charset))\n+        if isinstance(value, memoryview):\n+            return bytes(value)\n         # Handle non-string types.\n         return str(value).encode(self.charset)\n \n",
    "variant_6": "diff --git a/django/http/response.py b/django/http/response.py\nindex 6a84e193ba..10ce7cefe7 100644\n--- a/django/http/response.py\n+++ b/django/http/response.py\n@@ -233,6 +233,19 @@ class HttpResponseBase:\n             return bytes(value)\n         if isinstance(value, str):\n             return bytes(value.encode(self.charset))\n+\n+    def make_bytes(self, value):\n+        \"\"\"Turn a value into a bytestring encoded in the output charset.\"\"\"\n+        # Per PEP 3333, this response body must be bytes. To avoid the\n+        # overhead on Python 2 of calling conditional_escape before\n+        # calling force_bytes, we skip the conditional_escape step on\n+        # bytes, SafeBytes, and SafeText objects.\n+        if isinstance(value, bytes):\n+            return bytes(value)\n+        if isinstance(value, str):\n+            return bytes(value.encode(self.charset))\n+        if isinstance(value, memoryview):\n+            return bytes(value)\n         # Handle non-string types.\n         return str(value).encode(self.charset)\n \n",
    "variant_7": "diff --git a/django/http/response.py b/django/http/response.py\nindex 6a84e193ba..6124e256a8 100644\n--- a/django/http/response.py\n+++ b/django/http/response.py\n@@ -233,6 +233,35 @@ class HttpResponseBase:\n             return bytes(value)\n         if isinstance(value, str):\n             return bytes(value.encode(self.charset))\n+\n+    def make_bytes(self, value):\n+        \"\"\"Turn a value into a bytestring encoded in the output charset.\"\"\"\n+        # Per PEP 3333, this response body must be bytes. To avoid the\n+        # overhead of unused chunked encoding, we encode here rather\n+        # than in self.write() so that the updated self.content is also\n+        # bytes.\n+\n+        # Handle the common case of a bytes subclass. In Python 2, this\n+        # includes str; in Python 3, this separately handles bytes and\n+        # bytearray, and a few other types. In Python 2, this may also\n+        # include the `buffer` type.\n+\n+        # Encode strings with the configured charset.\n+\n+        # Force evaluation if it's a lazy object, e.g. HttpRequest.body.\n+        # When value is an instance of a subclass, this function returns `bytes(value)`.\n+        # This doesn't make a copy when `value` already contains bytes.\n+\n+        # Handle string types -- we can't rely on force_bytes here because:\n+        # - Python attempts str conversion first\n+        # - when self._charset != 'utf-8' it re-encodes the content\n+        if isinstance(value, bytes):\n+            return bytes(value)\n+        if isinstance(value, str):\n+            return bytes(value.encode(self.charset))\n+        # Handle memoryview objects.\n+        if isinstance(value, memoryview):\n+            return bytes(value)\n         # Handle non-string types.\n         return str(value).encode(self.charset)\n \n",
    "variant_8": "diff --git a/django/http/response.py b/django/http/response.py\nindex 6a84e193ba..a1a00bcee3 100644\n--- a/django/http/response.py\n+++ b/django/http/response.py\n@@ -233,6 +233,33 @@ class HttpResponseBase:\n             return bytes(value)\n         if isinstance(value, str):\n             return bytes(value.encode(self.charset))\n+\n+    def make_bytes(self, value):\n+        \"\"\"Turn a value into a bytestring encoded in the output charset.\"\"\"\n+        # Per PEP 3333, this response body must be bytes. To avoid the\n+        # overhead of doing this conversion on each write when we know we'll\n+        # get mostly strings, we do the conversion here, once.\n+        #\n+        # Note that we do *not* attempt bytes conversion first because it would\n+        # double-encode strings.\n+        #\n+        # Note also that we can't use smart_bytes here because it would\n+        # double-encode when self._charset != 'utf-8' (e.g. HttpResponseRedirect\n+        # after a POST with non-ASCII data)\n+        #\n+        # Finally, when dealing with subclasses of bytes that may not be\n+        # an instance of a subclass, this function returns `bytes(value)`.\n+        # This doesn't make a copy when `value` already contains bytes.\n+\n+        # Handle string types -- we can't rely on force_bytes here because:\n+        # - Python attempts str conversion first\n+        # - when self._charset != 'utf-8' it re-encodes the content\n+        if isinstance(value, bytes):\n+            return bytes(value)\n+        if isinstance(value, str):\n+            return bytes(value.encode(self.charset))\n+        if isinstance(value, memoryview):\n+            return bytes(value)\n         # Handle non-string types.\n         return str(value).encode(self.charset)\n \n"
  }
}