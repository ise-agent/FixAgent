{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/pytest/src/_pytest/python_api.py lines 709-728)": "\nclass RaisesContext:\n    def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None\n\n    def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo\n\n    def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception\n\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n",
    "Location 2 (/root/hy/projects_2/pytest/src/_pytest/_code/code.py lines 537-542)": "\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n",
    "Location 3 (/root/hy/projects_2/pytest/src/_pytest/_code/code.py lines 422-424)": "\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n\n    @property\n    def value(self):\n        \"\"\"the exception value\"\"\"\n        return self._excinfo[1]\n",
    "Location 4 (/root/hy/projects_2/pytest/src/_pytest/python_api.py lines 716-718)": "\nclass RaisesContext:\n    def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None\n\n    def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo\n\n    def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception\n\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n",
    "Location 5 (/root/hy/projects_2/pytest/src/_pytest/python_api.py lines 720-728)": "\n    def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception\n\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/pytest/src/_pytest/python_api.py lines 709-728)": [
      "\nclass RaisesContext:\n    def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None\n\n    def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo\n\n    def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception\n\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n",
      "\nclass RaisesContext:\n    def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None\n\n    def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo\n\n    def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception\n\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n",
      "\nclass RaisesContext:\n    def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None\n\n    def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo\n\n    def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception\n\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n",
      "\nclass RaisesContext:\n    def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None\n\n    def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo\n\n    def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception\n\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n",
      "\nclass RaisesContext:\n    def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None\n\n    def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo\n\n    def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception\n\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n",
      "\nclass RaisesContext:\n    def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None\n\n    def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo\n\n    def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception\n\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n",
      "\nclass RaisesContext:\n    def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None\n\n    def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo\n\n    def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception\n\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n",
      "\nclass RaisesContext:\n    def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None\n\n    def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo\n\n    def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception\n\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n"
    ],
    "Location 2 (/root/hy/projects_2/pytest/src/_pytest/_code/code.py lines 537-542)": [
      "\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n",
      "\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n",
      "\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n",
      "\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n",
      "\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n",
      "\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n",
      "\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n",
      "\nclass RaisesContext:\n    def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None\n\n    def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo\n\n    def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if sys.version_info[0] == 2 and suppress_exception:\n            sys.exc_clear()\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception\n\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n"
    ],
    "Location 3 (/root/hy/projects_2/pytest/src/_pytest/_code/code.py lines 422-424)": [
      "\nclass RaisesContext:\n    def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None\n\n    def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo\n\n    def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if sys.version_info[0] == 2 and suppress_exception:\n            sys.exc_clear()\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception\n\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n",
      "\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n\n    @property\n    def value(self):\n        \"\"\"the exception value\"\"\"\n        return self._excinfo[1]\n",
      "\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n\n    @property\n    def value(self):\n        \"\"\"the exception value\"\"\"\n        return self._excinfo[1]\n",
      "\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n\n    @property\n    def value(self):\n        \"\"\"the exception value\"\"\"\n        return self._excinfo[1]\n",
      "\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n\n    @property\n    def value(self):\n        \"\"\"the exception value\"\"\"\n        return self._excinfo[1]\n",
      "\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n\n    @property\n    def value(self):\n        \"\"\"the exception value\"\"\"\n        return self._excinfo[1]\n",
      "\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n\n    @property\n    def value(self):\n        \"\"\"the exception value\"\"\"\n        return self._excinfo[1]\n",
      "\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n\n    @property\n    def value(self):\n        \"\"\"the exception value\"\"\"\n        return self._excinfo[1]\n"
    ],
    "Location 4 (/root/hy/projects_2/pytest/src/_pytest/python_api.py lines 716-718)": [
      "\nclass RaisesContext:\n    def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None\n\n    def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo\n\n    def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception\n\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n",
      "\nclass RaisesContext:\n    def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None\n\n    def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo\n\n    def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception\n\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n",
      "\nclass RaisesContext:\n    def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None\n\n    def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo\n\n    def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception\n\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n",
      "\nclass RaisesContext:\n    def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None\n\n    def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo\n\n    def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception\n\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n",
      "\nclass RaisesContext:\n    def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None\n\n    def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo\n\n    def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception\n\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n",
      "\nclass RaisesContext:\n    def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None\n\n    def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo\n\n    def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception\n\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n",
      "\nclass RaisesContext:\n    def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None\n\n    def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo\n\n    def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception\n\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n",
      "\nclass RaisesContext:\n    def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None\n\n    def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo\n\n    def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception\n\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n"
    ],
    "Location 5 (/root/hy/projects_2/pytest/src/_pytest/python_api.py lines 720-728)": [
      "\n    def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception\n\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n",
      "\n    def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception\n\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n",
      "\n    def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception\n\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n",
      "\n    def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception\n\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n",
      "\n    def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception\n\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n",
      "\n    def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception\n\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n",
      "\n    def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception\n\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n",
      "\n    def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception\n\n    def __str__(self):\n        \"\"\"Return the string representation of the caught exception.\n        \n        This makes str(context_manager) behave the same as str(exception)\n        in normal exception handling, returning the full exception message\n        instead of the file location format.\n        \"\"\"\n        if self.excinfo is None or self.excinfo.value is None:\n            return \"\"\n        return str(self.excinfo.value)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/src/_pytest/_code/code.py b/src/_pytest/_code/code.py\nindex c4ed961ac..216ad4010 100644\n--- a/src/_pytest/_code/code.py\n+++ b/src/_pytest/_code/code.py\n@@ -419,6 +419,7 @@ class ExceptionInfo:\n         return self._excinfo[0]\n \n     @property\n+\n     def value(self):\n         \"\"\"the exception value\"\"\"\n         return self._excinfo[1]\n@@ -534,6 +535,7 @@ class ExceptionInfo:\n         )\n         return fmt.repr_excinfo(self)\n \n+\n     def __str__(self):\n         if self._excinfo is None:\n             return repr(self)\ndiff --git a/src/_pytest/python_api.py b/src/_pytest/python_api.py\nindex 011181a40..835cf9034 100644\n--- a/src/_pytest/python_api.py\n+++ b/src/_pytest/python_api.py\n@@ -706,6 +706,7 @@ def raises(expected_exception, *args, **kwargs):\n raises.Exception = fail.Exception\n \n \n+\n class RaisesContext:\n     def __init__(self, expected_exception, message, match_expr):\n         self.expected_exception = expected_exception\n@@ -726,3 +727,16 @@ class RaisesContext:\n         if self.match_expr is not None and suppress_exception:\n             self.excinfo.match(self.match_expr)\n         return suppress_exception\n+\n+    def __str__(self):\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n+            self.excinfo.match(self.match_expr)\n+        return suppress_exception\n",
    "variant_0": "diff --git a/src/_pytest/_code/code.py b/src/_pytest/_code/code.py\nindex c4ed961ac..98d0c7dc7 100644\n--- a/src/_pytest/_code/code.py\n+++ b/src/_pytest/_code/code.py\n@@ -418,6 +418,19 @@ class ExceptionInfo:\n         \"\"\"the exception class\"\"\"\n         return self._excinfo[0]\n \n+    @property\n+\n+    def __str__(self):\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n+\n     @property\n     def value(self):\n         \"\"\"the exception value\"\"\"\n@@ -534,12 +547,17 @@ class ExceptionInfo:\n         )\n         return fmt.repr_excinfo(self)\n \n+\n     def __str__(self):\n-        if self._excinfo is None:\n-            return repr(self)\n-        entry = self.traceback[-1]\n-        loc = ReprFileLocation(entry.path, entry.lineno + 1, self.exconly())\n-        return str(loc)\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n \n     def match(self, regexp):\n         \"\"\"\ndiff --git a/src/_pytest/python_api.py b/src/_pytest/python_api.py\nindex 011181a40..72ddd40b6 100644\n--- a/src/_pytest/python_api.py\n+++ b/src/_pytest/python_api.py\n@@ -706,6 +706,7 @@ def raises(expected_exception, *args, **kwargs):\n raises.Exception = fail.Exception\n \n \n+\n class RaisesContext:\n     def __init__(self, expected_exception, message, match_expr):\n         self.expected_exception = expected_exception\n@@ -726,3 +727,55 @@ class RaisesContext:\n         if self.match_expr is not None and suppress_exception:\n             self.excinfo.match(self.match_expr)\n         return suppress_exception\n+\n+    def __str__(self):\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n+        __tracebackhide__ = True\n+        if tp[0] is None:\n+            fail(self.message)\n+        self.excinfo.__init__(tp)\n+        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n+        if self.match_expr is not None and suppress_exception:\n+            self.excinfo.match(self.match_expr)\n+        return suppress_exception\n+\n+    def __str__(self):\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n+\n+\n+    def __exit__(self, *tp):\n+        __tracebackhide__ = True\n+        if tp[0] is None:\n+            fail(self.message)\n+        self.excinfo.__init__(tp)\n+        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n+        if self.match_expr is not None and suppress_exception:\n+            self.excinfo.match(self.match_expr)\n+        return suppress_exception\n+\n+    def __str__(self):\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n",
    "variant_1": "diff --git a/src/_pytest/_code/code.py b/src/_pytest/_code/code.py\nindex c4ed961ac..96df88274 100644\n--- a/src/_pytest/_code/code.py\n+++ b/src/_pytest/_code/code.py\n@@ -419,9 +419,40 @@ class ExceptionInfo:\n         return self._excinfo[0]\n \n     @property\n-    def value(self):\n-        \"\"\"the exception value\"\"\"\n-        return self._excinfo[1]\n+\n+class RaisesContext:\n+    def __init__(self, expected_exception, message, match_expr):\n+        self.expected_exception = expected_exception\n+        self.message = message\n+        self.match_expr = match_expr\n+        self.excinfo = None\n+\n+    def __enter__(self):\n+        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n+        return self.excinfo\n+\n+    def __exit__(self, *tp):\n+        __tracebackhide__ = True\n+        if tp[0] is None:\n+            fail(self.message)\n+        self.excinfo.__init__(tp)\n+        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n+        if sys.version_info[0] == 2 and suppress_exception:\n+            sys.exc_clear()\n+        if self.match_expr is not None and suppress_exception:\n+            self.excinfo.match(self.match_expr)\n+        return suppress_exception\n+\n+    def __str__(self):\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n \n     @property\n     def tb(self):\n@@ -534,12 +565,17 @@ class ExceptionInfo:\n         )\n         return fmt.repr_excinfo(self)\n \n+\n     def __str__(self):\n-        if self._excinfo is None:\n-            return repr(self)\n-        entry = self.traceback[-1]\n-        loc = ReprFileLocation(entry.path, entry.lineno + 1, self.exconly())\n-        return str(loc)\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n \n     def match(self, regexp):\n         \"\"\"\ndiff --git a/src/_pytest/python_api.py b/src/_pytest/python_api.py\nindex 011181a40..72ddd40b6 100644\n--- a/src/_pytest/python_api.py\n+++ b/src/_pytest/python_api.py\n@@ -706,6 +706,7 @@ def raises(expected_exception, *args, **kwargs):\n raises.Exception = fail.Exception\n \n \n+\n class RaisesContext:\n     def __init__(self, expected_exception, message, match_expr):\n         self.expected_exception = expected_exception\n@@ -726,3 +727,55 @@ class RaisesContext:\n         if self.match_expr is not None and suppress_exception:\n             self.excinfo.match(self.match_expr)\n         return suppress_exception\n+\n+    def __str__(self):\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n+        __tracebackhide__ = True\n+        if tp[0] is None:\n+            fail(self.message)\n+        self.excinfo.__init__(tp)\n+        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n+        if self.match_expr is not None and suppress_exception:\n+            self.excinfo.match(self.match_expr)\n+        return suppress_exception\n+\n+    def __str__(self):\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n+\n+\n+    def __exit__(self, *tp):\n+        __tracebackhide__ = True\n+        if tp[0] is None:\n+            fail(self.message)\n+        self.excinfo.__init__(tp)\n+        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n+        if self.match_expr is not None and suppress_exception:\n+            self.excinfo.match(self.match_expr)\n+        return suppress_exception\n+\n+    def __str__(self):\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n",
    "variant_2": "diff --git a/src/_pytest/_code/code.py b/src/_pytest/_code/code.py\nindex c4ed961ac..98d0c7dc7 100644\n--- a/src/_pytest/_code/code.py\n+++ b/src/_pytest/_code/code.py\n@@ -418,6 +418,19 @@ class ExceptionInfo:\n         \"\"\"the exception class\"\"\"\n         return self._excinfo[0]\n \n+    @property\n+\n+    def __str__(self):\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n+\n     @property\n     def value(self):\n         \"\"\"the exception value\"\"\"\n@@ -534,12 +547,17 @@ class ExceptionInfo:\n         )\n         return fmt.repr_excinfo(self)\n \n+\n     def __str__(self):\n-        if self._excinfo is None:\n-            return repr(self)\n-        entry = self.traceback[-1]\n-        loc = ReprFileLocation(entry.path, entry.lineno + 1, self.exconly())\n-        return str(loc)\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n \n     def match(self, regexp):\n         \"\"\"\ndiff --git a/src/_pytest/python_api.py b/src/_pytest/python_api.py\nindex 011181a40..72ddd40b6 100644\n--- a/src/_pytest/python_api.py\n+++ b/src/_pytest/python_api.py\n@@ -706,6 +706,7 @@ def raises(expected_exception, *args, **kwargs):\n raises.Exception = fail.Exception\n \n \n+\n class RaisesContext:\n     def __init__(self, expected_exception, message, match_expr):\n         self.expected_exception = expected_exception\n@@ -726,3 +727,55 @@ class RaisesContext:\n         if self.match_expr is not None and suppress_exception:\n             self.excinfo.match(self.match_expr)\n         return suppress_exception\n+\n+    def __str__(self):\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n+        __tracebackhide__ = True\n+        if tp[0] is None:\n+            fail(self.message)\n+        self.excinfo.__init__(tp)\n+        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n+        if self.match_expr is not None and suppress_exception:\n+            self.excinfo.match(self.match_expr)\n+        return suppress_exception\n+\n+    def __str__(self):\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n+\n+\n+    def __exit__(self, *tp):\n+        __tracebackhide__ = True\n+        if tp[0] is None:\n+            fail(self.message)\n+        self.excinfo.__init__(tp)\n+        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n+        if self.match_expr is not None and suppress_exception:\n+            self.excinfo.match(self.match_expr)\n+        return suppress_exception\n+\n+    def __str__(self):\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n",
    "variant_3": "diff --git a/src/_pytest/_code/code.py b/src/_pytest/_code/code.py\nindex c4ed961ac..98d0c7dc7 100644\n--- a/src/_pytest/_code/code.py\n+++ b/src/_pytest/_code/code.py\n@@ -418,6 +418,19 @@ class ExceptionInfo:\n         \"\"\"the exception class\"\"\"\n         return self._excinfo[0]\n \n+    @property\n+\n+    def __str__(self):\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n+\n     @property\n     def value(self):\n         \"\"\"the exception value\"\"\"\n@@ -534,12 +547,17 @@ class ExceptionInfo:\n         )\n         return fmt.repr_excinfo(self)\n \n+\n     def __str__(self):\n-        if self._excinfo is None:\n-            return repr(self)\n-        entry = self.traceback[-1]\n-        loc = ReprFileLocation(entry.path, entry.lineno + 1, self.exconly())\n-        return str(loc)\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n \n     def match(self, regexp):\n         \"\"\"\ndiff --git a/src/_pytest/python_api.py b/src/_pytest/python_api.py\nindex 011181a40..72ddd40b6 100644\n--- a/src/_pytest/python_api.py\n+++ b/src/_pytest/python_api.py\n@@ -706,6 +706,7 @@ def raises(expected_exception, *args, **kwargs):\n raises.Exception = fail.Exception\n \n \n+\n class RaisesContext:\n     def __init__(self, expected_exception, message, match_expr):\n         self.expected_exception = expected_exception\n@@ -726,3 +727,55 @@ class RaisesContext:\n         if self.match_expr is not None and suppress_exception:\n             self.excinfo.match(self.match_expr)\n         return suppress_exception\n+\n+    def __str__(self):\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n+        __tracebackhide__ = True\n+        if tp[0] is None:\n+            fail(self.message)\n+        self.excinfo.__init__(tp)\n+        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n+        if self.match_expr is not None and suppress_exception:\n+            self.excinfo.match(self.match_expr)\n+        return suppress_exception\n+\n+    def __str__(self):\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n+\n+\n+    def __exit__(self, *tp):\n+        __tracebackhide__ = True\n+        if tp[0] is None:\n+            fail(self.message)\n+        self.excinfo.__init__(tp)\n+        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n+        if self.match_expr is not None and suppress_exception:\n+            self.excinfo.match(self.match_expr)\n+        return suppress_exception\n+\n+    def __str__(self):\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n",
    "variant_4": "diff --git a/src/_pytest/_code/code.py b/src/_pytest/_code/code.py\nindex c4ed961ac..98d0c7dc7 100644\n--- a/src/_pytest/_code/code.py\n+++ b/src/_pytest/_code/code.py\n@@ -418,6 +418,19 @@ class ExceptionInfo:\n         \"\"\"the exception class\"\"\"\n         return self._excinfo[0]\n \n+    @property\n+\n+    def __str__(self):\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n+\n     @property\n     def value(self):\n         \"\"\"the exception value\"\"\"\n@@ -534,12 +547,17 @@ class ExceptionInfo:\n         )\n         return fmt.repr_excinfo(self)\n \n+\n     def __str__(self):\n-        if self._excinfo is None:\n-            return repr(self)\n-        entry = self.traceback[-1]\n-        loc = ReprFileLocation(entry.path, entry.lineno + 1, self.exconly())\n-        return str(loc)\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n \n     def match(self, regexp):\n         \"\"\"\ndiff --git a/src/_pytest/python_api.py b/src/_pytest/python_api.py\nindex 011181a40..72ddd40b6 100644\n--- a/src/_pytest/python_api.py\n+++ b/src/_pytest/python_api.py\n@@ -706,6 +706,7 @@ def raises(expected_exception, *args, **kwargs):\n raises.Exception = fail.Exception\n \n \n+\n class RaisesContext:\n     def __init__(self, expected_exception, message, match_expr):\n         self.expected_exception = expected_exception\n@@ -726,3 +727,55 @@ class RaisesContext:\n         if self.match_expr is not None and suppress_exception:\n             self.excinfo.match(self.match_expr)\n         return suppress_exception\n+\n+    def __str__(self):\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n+        __tracebackhide__ = True\n+        if tp[0] is None:\n+            fail(self.message)\n+        self.excinfo.__init__(tp)\n+        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n+        if self.match_expr is not None and suppress_exception:\n+            self.excinfo.match(self.match_expr)\n+        return suppress_exception\n+\n+    def __str__(self):\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n+\n+\n+    def __exit__(self, *tp):\n+        __tracebackhide__ = True\n+        if tp[0] is None:\n+            fail(self.message)\n+        self.excinfo.__init__(tp)\n+        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n+        if self.match_expr is not None and suppress_exception:\n+            self.excinfo.match(self.match_expr)\n+        return suppress_exception\n+\n+    def __str__(self):\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n",
    "variant_5": "diff --git a/src/_pytest/_code/code.py b/src/_pytest/_code/code.py\nindex c4ed961ac..98d0c7dc7 100644\n--- a/src/_pytest/_code/code.py\n+++ b/src/_pytest/_code/code.py\n@@ -418,6 +418,19 @@ class ExceptionInfo:\n         \"\"\"the exception class\"\"\"\n         return self._excinfo[0]\n \n+    @property\n+\n+    def __str__(self):\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n+\n     @property\n     def value(self):\n         \"\"\"the exception value\"\"\"\n@@ -534,12 +547,17 @@ class ExceptionInfo:\n         )\n         return fmt.repr_excinfo(self)\n \n+\n     def __str__(self):\n-        if self._excinfo is None:\n-            return repr(self)\n-        entry = self.traceback[-1]\n-        loc = ReprFileLocation(entry.path, entry.lineno + 1, self.exconly())\n-        return str(loc)\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n \n     def match(self, regexp):\n         \"\"\"\ndiff --git a/src/_pytest/python_api.py b/src/_pytest/python_api.py\nindex 011181a40..72ddd40b6 100644\n--- a/src/_pytest/python_api.py\n+++ b/src/_pytest/python_api.py\n@@ -706,6 +706,7 @@ def raises(expected_exception, *args, **kwargs):\n raises.Exception = fail.Exception\n \n \n+\n class RaisesContext:\n     def __init__(self, expected_exception, message, match_expr):\n         self.expected_exception = expected_exception\n@@ -726,3 +727,55 @@ class RaisesContext:\n         if self.match_expr is not None and suppress_exception:\n             self.excinfo.match(self.match_expr)\n         return suppress_exception\n+\n+    def __str__(self):\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n+        __tracebackhide__ = True\n+        if tp[0] is None:\n+            fail(self.message)\n+        self.excinfo.__init__(tp)\n+        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n+        if self.match_expr is not None and suppress_exception:\n+            self.excinfo.match(self.match_expr)\n+        return suppress_exception\n+\n+    def __str__(self):\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n+\n+\n+    def __exit__(self, *tp):\n+        __tracebackhide__ = True\n+        if tp[0] is None:\n+            fail(self.message)\n+        self.excinfo.__init__(tp)\n+        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n+        if self.match_expr is not None and suppress_exception:\n+            self.excinfo.match(self.match_expr)\n+        return suppress_exception\n+\n+    def __str__(self):\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n",
    "variant_6": "diff --git a/src/_pytest/_code/code.py b/src/_pytest/_code/code.py\nindex c4ed961ac..98d0c7dc7 100644\n--- a/src/_pytest/_code/code.py\n+++ b/src/_pytest/_code/code.py\n@@ -418,6 +418,19 @@ class ExceptionInfo:\n         \"\"\"the exception class\"\"\"\n         return self._excinfo[0]\n \n+    @property\n+\n+    def __str__(self):\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n+\n     @property\n     def value(self):\n         \"\"\"the exception value\"\"\"\n@@ -534,12 +547,17 @@ class ExceptionInfo:\n         )\n         return fmt.repr_excinfo(self)\n \n+\n     def __str__(self):\n-        if self._excinfo is None:\n-            return repr(self)\n-        entry = self.traceback[-1]\n-        loc = ReprFileLocation(entry.path, entry.lineno + 1, self.exconly())\n-        return str(loc)\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n \n     def match(self, regexp):\n         \"\"\"\ndiff --git a/src/_pytest/python_api.py b/src/_pytest/python_api.py\nindex 011181a40..72ddd40b6 100644\n--- a/src/_pytest/python_api.py\n+++ b/src/_pytest/python_api.py\n@@ -706,6 +706,7 @@ def raises(expected_exception, *args, **kwargs):\n raises.Exception = fail.Exception\n \n \n+\n class RaisesContext:\n     def __init__(self, expected_exception, message, match_expr):\n         self.expected_exception = expected_exception\n@@ -726,3 +727,55 @@ class RaisesContext:\n         if self.match_expr is not None and suppress_exception:\n             self.excinfo.match(self.match_expr)\n         return suppress_exception\n+\n+    def __str__(self):\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n+        __tracebackhide__ = True\n+        if tp[0] is None:\n+            fail(self.message)\n+        self.excinfo.__init__(tp)\n+        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n+        if self.match_expr is not None and suppress_exception:\n+            self.excinfo.match(self.match_expr)\n+        return suppress_exception\n+\n+    def __str__(self):\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n+\n+\n+    def __exit__(self, *tp):\n+        __tracebackhide__ = True\n+        if tp[0] is None:\n+            fail(self.message)\n+        self.excinfo.__init__(tp)\n+        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n+        if self.match_expr is not None and suppress_exception:\n+            self.excinfo.match(self.match_expr)\n+        return suppress_exception\n+\n+    def __str__(self):\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n",
    "variant_7": "diff --git a/src/_pytest/_code/code.py b/src/_pytest/_code/code.py\nindex c4ed961ac..98d0c7dc7 100644\n--- a/src/_pytest/_code/code.py\n+++ b/src/_pytest/_code/code.py\n@@ -418,6 +418,19 @@ class ExceptionInfo:\n         \"\"\"the exception class\"\"\"\n         return self._excinfo[0]\n \n+    @property\n+\n+    def __str__(self):\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n+\n     @property\n     def value(self):\n         \"\"\"the exception value\"\"\"\n@@ -534,12 +547,17 @@ class ExceptionInfo:\n         )\n         return fmt.repr_excinfo(self)\n \n+\n     def __str__(self):\n-        if self._excinfo is None:\n-            return repr(self)\n-        entry = self.traceback[-1]\n-        loc = ReprFileLocation(entry.path, entry.lineno + 1, self.exconly())\n-        return str(loc)\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n \n     def match(self, regexp):\n         \"\"\"\ndiff --git a/src/_pytest/python_api.py b/src/_pytest/python_api.py\nindex 011181a40..72ddd40b6 100644\n--- a/src/_pytest/python_api.py\n+++ b/src/_pytest/python_api.py\n@@ -706,6 +706,7 @@ def raises(expected_exception, *args, **kwargs):\n raises.Exception = fail.Exception\n \n \n+\n class RaisesContext:\n     def __init__(self, expected_exception, message, match_expr):\n         self.expected_exception = expected_exception\n@@ -726,3 +727,55 @@ class RaisesContext:\n         if self.match_expr is not None and suppress_exception:\n             self.excinfo.match(self.match_expr)\n         return suppress_exception\n+\n+    def __str__(self):\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n+        __tracebackhide__ = True\n+        if tp[0] is None:\n+            fail(self.message)\n+        self.excinfo.__init__(tp)\n+        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n+        if self.match_expr is not None and suppress_exception:\n+            self.excinfo.match(self.match_expr)\n+        return suppress_exception\n+\n+    def __str__(self):\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n+\n+\n+    def __exit__(self, *tp):\n+        __tracebackhide__ = True\n+        if tp[0] is None:\n+            fail(self.message)\n+        self.excinfo.__init__(tp)\n+        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n+        if self.match_expr is not None and suppress_exception:\n+            self.excinfo.match(self.match_expr)\n+        return suppress_exception\n+\n+    def __str__(self):\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n",
    "variant_8": "diff --git a/src/_pytest/_code/code.py b/src/_pytest/_code/code.py\nindex c4ed961ac..2dcb3b942 100644\n--- a/src/_pytest/_code/code.py\n+++ b/src/_pytest/_code/code.py\n@@ -418,6 +418,19 @@ class ExceptionInfo:\n         \"\"\"the exception class\"\"\"\n         return self._excinfo[0]\n \n+    @property\n+\n+    def __str__(self):\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n+\n     @property\n     def value(self):\n         \"\"\"the exception value\"\"\"\n@@ -534,12 +547,40 @@ class ExceptionInfo:\n         )\n         return fmt.repr_excinfo(self)\n \n+\n+class RaisesContext:\n+    def __init__(self, expected_exception, message, match_expr):\n+        self.expected_exception = expected_exception\n+        self.message = message\n+        self.match_expr = match_expr\n+        self.excinfo = None\n+\n+    def __enter__(self):\n+        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n+        return self.excinfo\n+\n+    def __exit__(self, *tp):\n+        __tracebackhide__ = True\n+        if tp[0] is None:\n+            fail(self.message)\n+        self.excinfo.__init__(tp)\n+        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n+        if sys.version_info[0] == 2 and suppress_exception:\n+            sys.exc_clear()\n+        if self.match_expr is not None and suppress_exception:\n+            self.excinfo.match(self.match_expr)\n+        return suppress_exception\n+\n     def __str__(self):\n-        if self._excinfo is None:\n-            return repr(self)\n-        entry = self.traceback[-1]\n-        loc = ReprFileLocation(entry.path, entry.lineno + 1, self.exconly())\n-        return str(loc)\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n \n     def match(self, regexp):\n         \"\"\"\ndiff --git a/src/_pytest/python_api.py b/src/_pytest/python_api.py\nindex 011181a40..72ddd40b6 100644\n--- a/src/_pytest/python_api.py\n+++ b/src/_pytest/python_api.py\n@@ -706,6 +706,7 @@ def raises(expected_exception, *args, **kwargs):\n raises.Exception = fail.Exception\n \n \n+\n class RaisesContext:\n     def __init__(self, expected_exception, message, match_expr):\n         self.expected_exception = expected_exception\n@@ -726,3 +727,55 @@ class RaisesContext:\n         if self.match_expr is not None and suppress_exception:\n             self.excinfo.match(self.match_expr)\n         return suppress_exception\n+\n+    def __str__(self):\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n+        __tracebackhide__ = True\n+        if tp[0] is None:\n+            fail(self.message)\n+        self.excinfo.__init__(tp)\n+        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n+        if self.match_expr is not None and suppress_exception:\n+            self.excinfo.match(self.match_expr)\n+        return suppress_exception\n+\n+    def __str__(self):\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n+\n+\n+    def __exit__(self, *tp):\n+        __tracebackhide__ = True\n+        if tp[0] is None:\n+            fail(self.message)\n+        self.excinfo.__init__(tp)\n+        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n+        if self.match_expr is not None and suppress_exception:\n+            self.excinfo.match(self.match_expr)\n+        return suppress_exception\n+\n+    def __str__(self):\n+        \"\"\"Return the string representation of the caught exception.\n+        \n+        This makes str(context_manager) behave the same as str(exception)\n+        in normal exception handling, returning the full exception message\n+        instead of the file location format.\n+        \"\"\"\n+        if self.excinfo is None or self.excinfo.value is None:\n+            return \"\"\n+        return str(self.excinfo.value)\n"
  }
}