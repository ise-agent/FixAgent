{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/pylint/pylint/config/option.py lines 23-26)": "\ndef _regexp_validator(_, name, value):\n    if hasattr(value, \"pattern\"):\n        return value\n    try:\n        import regex\n        return regex.compile(value)\n    except ImportError:\n        return re.compile(value)\n    except re.error as exc:\n        raise optparse.OptionValueError(f\"invalid regular expression: {exc}\") from exc\n",
    "Location 2 (/root/hy/projects_2/pylint/pylint/config/option.py lines 106-106)": "\n    \"regexp\": lambda pattern: _compile_regex(pattern or \"\"),\n",
    "Location 3 (/root/hy/projects_2/pylint/pylint/config/option.py lines 10-12)": "\nimport re\nimport warnings\ntry:\n    import regex\n    HAS_REGEX = True\nexcept ImportError:\n    HAS_REGEX = False\nfrom re import Pattern\n",
    "Location 4 (/root/hy/projects_2/pylint/pylint/config/option.py lines 102-120)": "\n# Unicode-aware compilation helper - add after existing imports\ntry:\n    import regex\n    HAS_REGEX = True\nexcept ImportError:\n    HAS_REGEX = False\n\ndef _compile_regex_unicode_aware(pattern):\n    \"\"\"Compile regex pattern with Unicode property escape support when available.\"\"\"\n    if not pattern:\n        pattern = \"\"\n    \n    if HAS_REGEX:\n        try:\n            return regex.compile(pattern)\n        except regex.error:\n            # Fall back to standard re if regex fails\n            pass\n    \n    return re.compile(pattern)\n\nVALIDATORS = {\n    \"string\": utils._unquote,\n    \"int\": int,\n    \"float\": float,\n    \"regexp\": _compile_regex_unicode_aware,\n    \"regexp_csv\": _regexp_csv_validator,\n    \"regexp_paths_csv\": _regexp_paths_csv_validator,\n    \"csv\": _csv_validator,\n    \"yn\": _yn_validator,\n    \"choice\": lambda opt, name, value: _choice_validator(opt[\"choices\"], name, value),\n    \"confidence\": lambda opt, name, value: _multiple_choice_validator(\n        opt[\"choices\"], name, value\n    ),\n    \"multiple_choice\": lambda opt, name, value: _multiple_choice_validator(\n        opt[\"choices\"], name, value\n    ),\n    \"non_empty_string\": _non_empty_string_validator,\n    \"py_version\": _py_version_validator,\n}\n",
    "Location 5 (/root/hy/projects_2/pylint/pylint/config/option.py lines 35-39)": "\ndef _regexp_paths_csv_validator(\n    _, name: str, value: str | list[Pattern[str]]\n) -> list[Pattern[str]]:\n    if isinstance(value, list):\n        return value\n    patterns = []\n    for val in _csv_validator(_, name, value):\n        try:\n            # Try regex module first for Unicode property escape support\n            if 'regex' in globals():\n                pattern = regex.compile(\n                    str(pathlib.PureWindowsPath(val)).replace(\"\\\\\", \"\\\\\\\\\")\n                    + \"|\"\n                    + pathlib.PureWindowsPath(val).as_posix()\n                )\n            else:\n                pattern = re.compile(\n                    str(pathlib.PureWindowsPath(val)).replace(\"\\\\\", \"\\\\\\\\\")\n                    + \"|\"\n                    + pathlib.PureWindowsPath(val).as_posix()\n                )\n            patterns.append(pattern)\n        except (re.error, ValueError) as exc:\n            raise optparse.OptionValueError(f\"Invalid regexp pattern {val!r}: {exc}\")\n    return patterns\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/pylint/pylint/config/option.py lines 23-26)": [
      "\ndef _regexp_validator(_, name, value):\n    if hasattr(value, \"pattern\"):\n        return value\n    try:\n        import regex\n        return regex.compile(value)\n    except ImportError:\n        return re.compile(value)\n    except Exception:\n        # If regex module fails to compile, fallback to re\n        return re.compile(value)\n",
      "\ndef _regexp_validator(_, name, value):\n    if hasattr(value, \"pattern\"):\n        return value\n    try:\n        import regex\n        return regex.compile(value)\n    except ImportError:\n        return re.compile(value)\n    except re.error as exc:\n        raise optparse.OptionValueError(f\"Invalid regular expression: {exc}\")\n",
      "\ndef _regexp_validator(_, name, value):\n    if hasattr(value, \"pattern\"):\n        return value\n    try:\n        import regex\n        return regex.compile(value)\n    except ImportError:\n        return re.compile(value)\n    except Exception:\n        # If regex module fails to compile, fallback to re\n        return re.compile(value)\n",
      "\ndef _regexp_validator(_, name, value):\n    if hasattr(value, \"pattern\"):\n        return value\n    try:\n        import regex\n        return regex.compile(value)\n    except ImportError:\n        return re.compile(value)\n    except re.error as e:\n        try:\n            import regex\n            return regex.compile(value)\n        except ImportError:\n            raise optparse.OptionValueError(f\"Invalid regular expression: {e}\")\n        except regex.error:\n            raise optparse.OptionValueError(f\"Invalid regular expression: {e}\")\n",
      "\ndef _regexp_validator(_, name, value):\n    if hasattr(value, \"pattern\"):\n        return value\n    try:\n        import regex\n        return regex.compile(value)\n    except ImportError:\n        return re.compile(value)\n    except re.error as exc:\n        raise optparse.OptionValueError(f\"invalid regexp {value!r}: {exc}\") from exc\n",
      "\ndef _regexp_validator(_, name, value):\n    if hasattr(value, \"pattern\"):\n        return value\n    try:\n        import regex\n        return regex.compile(value)\n    except ImportError:\n        return re.compile(value)\n    except re.error as e:\n        try:\n            import regex\n            return regex.compile(value)\n        except ImportError:\n            raise e\n",
      "\ndef _regexp_validator(_, name, value):\n    if hasattr(value, \"pattern\"):\n        return value\n    try:\n        import regex\n        return regex.compile(value)\n    except ImportError:\n        return re.compile(value)\n    except re.error as exc:\n        raise optparse.OptionValueError(f\"Invalid regular expression: {exc}\")\n",
      "\ndef _regexp_validator(_, name, value):\n    if hasattr(value, \"pattern\"):\n        return value\n    try:\n        import regex\n        return regex.compile(value)\n    except ImportError:\n        return re.compile(value)\n    except Exception:\n        # If regex module fails to compile, fall back to re\n        return re.compile(value)\n"
    ],
    "Location 2 (/root/hy/projects_2/pylint/pylint/config/option.py lines 106-106)": [
      "\n    \"regexp\": lambda pattern: _compile_regexp(pattern or \"\"),\n",
      "\n    \"regexp\": lambda pattern: utils._compile_regexp_with_unicode_fallback(pattern or \"\"),\n",
      "\n    \"regexp\": lambda pattern: _compile_regexp(pattern or \"\"),\n",
      "\n    \"regexp\": lambda pattern: _compile_regexp(pattern or \"\"),\n",
      "\n    \"regexp\": lambda pattern: _compile_regex(pattern or \"\"),\n",
      "\n    \"regexp\": lambda pattern: _compile_regexp(pattern or \"\"),\n",
      "\n\"regexp\": lambda pattern: _compile_regex(pattern or \"\"),\n",
      "\n    \"regexp\": lambda pattern: utils._compile_regex_pattern(pattern or \"\"),\n"
    ],
    "Location 3 (/root/hy/projects_2/pylint/pylint/config/option.py lines 10-12)": [
      "\nimport re\nimport warnings\ntry:\n    import regex\n    HAS_REGEX = True\nexcept ImportError:\n    HAS_REGEX = False\nfrom re import Pattern\n",
      "\nimport re\nimport warnings\ntry:\n    import regex\n    HAS_REGEX = True\nexcept ImportError:\n    HAS_REGEX = False\n    regex = None\nfrom re import Pattern\n",
      "\nimport re\nimport warnings\ntry:\n    import regex\n    HAS_REGEX = True\nexcept ImportError:\n    HAS_REGEX = False\nfrom re import Pattern\n",
      "\nimport re\nimport warnings\ntry:\n    import regex\n    HAS_REGEX = True\nexcept ImportError:\n    HAS_REGEX = False\nfrom re import Pattern\n",
      "\nimport re\nimport warnings\ntry:\n    import regex\n    HAS_REGEX = True\nexcept ImportError:\n    HAS_REGEX = False\nfrom re import Pattern\n",
      "\nimport re\nimport warnings\ntry:\n    import regex\n    HAS_REGEX = True\nexcept ImportError:\n    HAS_REGEX = False\nfrom re import Pattern\n",
      "\nimport re\nimport warnings\ntry:\n    import regex\n    HAS_REGEX = True\nexcept ImportError:\n    HAS_REGEX = False\nfrom re import Pattern\n",
      "\nimport re\nimport warnings\ntry:\n    import regex\n    HAS_REGEX = True\nexcept ImportError:\n    HAS_REGEX = False\nfrom re import Pattern\n"
    ],
    "Location 4 (/root/hy/projects_2/pylint/pylint/config/option.py lines 102-120)": [
      "\n# Helper function for Unicode-aware regex compilation\ndef _compile_regex_with_unicode_support(pattern):\n    \"\"\"Compile regex pattern with Unicode property escape support if available.\"\"\"\n    if not pattern:\n        pattern = \"\"\n    \n    # Try regex module first for Unicode property escape support\n    try:\n        import regex\n        return regex.compile(pattern)\n    except ImportError:\n        pass\n    except regex.error:\n        # If regex module fails, fall back to re module\n        pass\n    \n    # Fallback to standard re module\n    return re.compile(pattern)\n\nVALIDATORS = {\n    \"string\": utils._unquote,\n    \"int\": int,\n    \"float\": float,\n    \"regexp\": _compile_regex_with_unicode_support,\n    \"regexp_csv\": _regexp_csv_validator,\n    \"regexp_paths_csv\": _regexp_paths_csv_validator,\n    \"csv\": _csv_validator,\n    \"yn\": _yn_validator,\n    \"choice\": lambda opt, name, value: _choice_validator(opt[\"choices\"], name, value),\n    \"confidence\": lambda opt, name, value: _multiple_choice_validator(\n        opt[\"choices\"], name, value\n    ),\n    \"multiple_choice\": lambda opt, name, value: _multiple_choice_validator(\n        opt[\"choices\"], name, value\n    ),\n    \"non_empty_string\": _non_empty_string_validator,\n    \"py_version\": _py_version_validator,\n}\n",
      "\n# Helper function to compile regex patterns with Unicode property support\ndef _compile_regex_with_unicode_support(pattern):\n    \"\"\"Compile regex pattern with Unicode property escape support if available.\"\"\"\n    if not pattern:\n        pattern = \"\"\n    \n    # Try regex module first for Unicode property escape support\n    try:\n        import regex\n        return regex.compile(pattern)\n    except ImportError:\n        # Fall back to standard re module\n        try:\n            return re.compile(pattern)\n        except re.error as e:\n            # If it's a Unicode property escape error, provide helpful message\n            if r'\\p{' in pattern:\n                raise re.error(\n                    f\"Unicode property escapes like \\\\p{{...}} are not supported by the standard re module. \"\n                    f\"Install the 'regex' package for Unicode property escape support.\"\n                ) from e\n            raise\n\nVALIDATORS = {\n    \"string\": utils._unquote,\n    \"int\": int,\n    \"float\": float,\n    \"regexp\": _compile_regex_with_unicode_support,\n    \"regexp_csv\": _regexp_csv_validator,\n    \"regexp_paths_csv\": _regexp_paths_csv_validator,\n    \"csv\": _csv_validator,\n    \"yn\": _yn_validator,\n    \"choice\": lambda opt, name, value: _choice_validator(opt[\"choices\"], name, value),\n    \"confidence\": lambda opt, name, value: _multiple_choice_validator(\n        opt[\"choices\"], name, value\n    ),\n    \"multiple_choice\": lambda opt, name, value: _multiple_choice_validator(\n        opt[\"choices\"], name, value\n    ),\n    \"non_empty_string\": _non_empty_string_validator,\n    \"py_version\": _py_version_validator,\n}\n",
      "\nVALIDATORS = {\n    \"string\": utils._unquote,\n    \"int\": int,\n    \"float\": float,\n    \"regexp\": lambda pattern: _compile_regexp(pattern or \"\"),\n    \"regexp_csv\": _regexp_csv_validator,\n    \"regexp_paths_csv\": _regexp_paths_csv_validator,\n    \"csv\": _csv_validator,\n    \"yn\": _yn_validator,\n    \"choice\": lambda opt, name, value: _choice_validator(opt[\"choices\"], name, value),\n    \"confidence\": lambda opt, name, value: _multiple_choice_validator(\n        opt[\"choices\"], name, value\n    ),\n    \"multiple_choice\": lambda opt, name, value: _multiple_choice_validator(\n        opt[\"choices\"], name, value\n    ),\n    \"non_empty_string\": _non_empty_string_validator,\n    \"py_version\": _py_version_validator,\n}\n",
      "\n# Create a helper function for Unicode-aware regex compilation\ndef _compile_regex_with_unicode_support(pattern):\n    \"\"\"Compile regex pattern with Unicode property escape support if available.\"\"\"\n    if not pattern:\n        pattern = \"\"\n    \n    # Try regex module first for Unicode property escape support\n    try:\n        import regex\n        return regex.compile(pattern)\n    except ImportError:\n        pass\n    except regex.error:\n        # Fall back to re module if regex compilation fails\n        pass\n    \n    # Fall back to standard re module\n    try:\n        return re.compile(pattern)\n    except re.error as exc:\n        # Provide helpful error message for Unicode property escapes\n        if r'\\p{' in pattern:\n            raise re.error(\n                f\"Unicode property escapes like '\\\\p{{...}}' are not supported by the standard re module. \"\n                f\"Install the 'regex' package for Unicode property escape support: pip install regex\"\n            ) from exc\n        raise\n\nVALIDATORS = {\n    \"string\": utils._unquote,\n    \"int\": int,\n    \"float\": float,\n    \"regexp\": _compile_regex_with_unicode_support,\n    \"regexp_csv\": _regexp_csv_validator,\n    \"regexp_paths_csv\": _regexp_paths_csv_validator,\n    \"csv\": _csv_validator,\n    \"yn\": _yn_validator,\n    \"choice\": lambda opt, name, value: _choice_validator(opt[\"choices\"], name, value),\n    \"confidence\": lambda opt, name, value: _multiple_choice_validator(\n        opt[\"choices\"], name, value\n    ),\n    \"multiple_choice\": lambda opt, name, value: _multiple_choice_validator(\n        opt[\"choices\"], name, value\n    ),\n    \"non_empty_string\": _non_empty_string_validator,\n    \"py_version\": _py_version_validator,\n}\n",
      "\n# Create a helper function for Unicode-aware regex compilation\ndef _compile_regex_with_unicode_support(pattern):\n    \"\"\"Compile regex pattern with Unicode property escape support when available.\"\"\"\n    if not pattern:\n        pattern = \"\"\n    \n    # Try regex module first for Unicode property escape support\n    try:\n        import regex\n        return regex.compile(pattern)\n    except ImportError:\n        pass\n    except regex.error:\n        # If regex module fails, fall back to re module\n        pass\n    \n    # Fall back to standard re module\n    try:\n        return re.compile(pattern)\n    except re.error as exc:\n        # Provide helpful error message for Unicode property escapes\n        if r'\\p{' in pattern or r'\\P{' in pattern:\n            raise re.error(\n                f\"Unicode property escapes like \\\\p{{}} are not supported by Python's re module. \"\n                f\"Install the 'regex' module for Unicode property escape support. \"\n                f\"Original error: {exc}\"\n            ) from exc\n        raise\n\nVALIDATORS = {\n    \"string\": utils._unquote,\n    \"int\": int,\n    \"float\": float,\n    \"regexp\": _compile_regex_with_unicode_support,\n    \"regexp_csv\": _regexp_csv_validator,\n    \"regexp_paths_csv\": _regexp_paths_csv_validator,\n    \"csv\": _csv_validator,\n    \"yn\": _yn_validator,\n    \"choice\": lambda opt, name, value: _choice_validator(opt[\"choices\"], name, value),\n    \"confidence\": lambda opt, name, value: _multiple_choice_validator(\n        opt[\"choices\"], name, value\n    ),\n    \"multiple_choice\": lambda opt, name, value: _multiple_choice_validator(\n        opt[\"choices\"], name, value\n    ),\n    \"non_empty_string\": _non_empty_string_validator,\n    \"py_version\": _py_version_validator,\n}\n",
      "\n# Helper function to compile regex patterns with Unicode support\ndef _compile_regex_with_unicode_support(pattern):\n    \"\"\"Compile regex pattern with Unicode property escape support if available.\"\"\"\n    if not pattern:\n        pattern = \"\"\n    \n    # Try to use regex module for Unicode property escape support\n    try:\n        import regex\n        return regex.compile(pattern)\n    except ImportError:\n        # Fall back to standard re module\n        try:\n            return re.compile(pattern)\n        except re.error as exc:\n            # Check if this might be a Unicode property escape issue\n            if '\\\\p{' in pattern or '\\\\P{' in pattern:\n                raise re.error(\n                    f\"Unicode property escapes like \\\\p{{}} are not supported by Python's re module. \"\n                    f\"Install the 'regex' package for Unicode property escape support. \"\n                    f\"Original error: {exc}\"\n                ) from exc\n            raise\n\n\nVALIDATORS = {\n    \"string\": utils._unquote,\n    \"int\": int,\n    \"float\": float,\n    \"regexp\": lambda pattern: _compile_regex_with_unicode_support(pattern),\n    \"regexp_csv\": _regexp_csv_validator,\n    \"regexp_paths_csv\": _regexp_paths_csv_validator,\n    \"csv\": _csv_validator,\n    \"yn\": _yn_validator,\n    \"choice\": lambda opt, name, value: _choice_validator(opt[\"choices\"], name, value),\n    \"confidence\": lambda opt, name, value: _multiple_choice_validator(\n        opt[\"choices\"], name, value\n    ),\n    \"multiple_choice\": lambda opt, name, value: _multiple_choice_validator(\n        opt[\"choices\"], name, value\n    ),\n    \"non_empty_string\": _non_empty_string_validator,\n    \"py_version\": _py_version_validator,\n}\n",
      "\n# Import regex module for Unicode property escape support, fallback to standard re\ntry:\n    import regex\n    HAS_REGEX = True\nexcept ImportError:\n    HAS_REGEX = False\n\n\ndef _compile_regex_with_unicode_support(pattern):\n    \"\"\"Compile regex pattern with Unicode property escape support when available.\"\"\"\n    if not pattern:\n        pattern = \"\"\n    \n    if HAS_REGEX:\n        try:\n            return regex.compile(pattern)\n        except regex.error:\n            # Fall back to standard re module if regex fails\n            pass\n    \n    return re.compile(pattern)\n\n\nVALIDATORS = {\n    \"string\": utils._unquote,\n    \"int\": int,\n    \"float\": float,\n    \"regexp\": _compile_regex_with_unicode_support,\n    \"regexp_csv\": _regexp_csv_validator,\n    \"regexp_paths_csv\": _regexp_paths_csv_validator,\n    \"csv\": _csv_validator,\n    \"yn\": _yn_validator,\n    \"choice\": lambda opt, name, value: _choice_validator(opt[\"choices\"], name, value),\n    \"confidence\": lambda opt, name, value: _multiple_choice_validator(\n        opt[\"choices\"], name, value\n    ),\n    \"multiple_choice\": lambda opt, name, value: _multiple_choice_validator(\n        opt[\"choices\"], name, value\n    ),\n    \"non_empty_string\": _non_empty_string_validator,\n    \"py_version\": _py_version_validator,\n}\n",
      "\n# Add helper function for Unicode-aware regex compilation\ndef _compile_regex_with_unicode_support(pattern):\n    \"\"\"Compile regex pattern with Unicode property escape support if available.\"\"\"\n    if not pattern:\n        pattern = \"\"\n    \n    # Try regex module first for Unicode property escape support\n    try:\n        import regex\n        return regex.compile(pattern)\n    except ImportError:\n        pass\n    except regex.error as e:\n        # If regex module fails, fall back to re module\n        pass\n    \n    # Fall back to standard re module\n    try:\n        return re.compile(pattern)\n    except re.error as e:\n        raise optparse.OptionValueError(f\"Invalid regular expression pattern: {e}\") from None\n\nVALIDATORS = {\n    \"string\": utils._unquote,\n    \"int\": int,\n    \"float\": float,\n    \"regexp\": _compile_regex_with_unicode_support,\n    \"regexp_csv\": _regexp_csv_validator,\n    \"regexp_paths_csv\": _regexp_paths_csv_validator,\n    \"csv\": _csv_validator,\n    \"yn\": _yn_validator,\n    \"choice\": lambda opt, name, value: _choice_validator(opt[\"choices\"], name, value),\n    \"confidence\": lambda opt, name, value: _multiple_choice_validator(\n        opt[\"choices\"], name, value\n    ),\n    \"multiple_choice\": lambda opt, name, value: _multiple_choice_validator(\n        opt[\"choices\"], name, value\n    ),\n    \"non_empty_string\": _non_empty_string_validator,\n    \"py_version\": _py_version_validator,\n}\n"
    ],
    "Location 5 (/root/hy/projects_2/pylint/pylint/config/option.py lines 35-39)": [
      "\ndef _regexp_paths_csv_validator(\n    _, name: str, value: str | list[Pattern[str]]\n) -> list[Pattern[str]]:\n    if isinstance(value, list):\n        return value\n    patterns = []\n    for val in _csv_validator(_, name, value):\n        try:\n            # Try regex module first for Unicode property escape support\n            if 'regex' in globals():\n                pattern = regex.compile(\n                    str(pathlib.PureWindowsPath(val)).replace(\"\\\\\", \"\\\\\\\\\")\n                    + \"|\"\n                    + pathlib.PureWindowsPath(val).as_posix()\n                )\n            else:\n                pattern = re.compile(\n                    str(pathlib.PureWindowsPath(val)).replace(\"\\\\\", \"\\\\\\\\\")\n                    + \"|\"\n                    + pathlib.PureWindowsPath(val).as_posix()\n                )\n            patterns.append(pattern)\n        except re.error as exc:\n            raise optparse.OptionValueError(f\"Error in provided regular expression: {val} beginning at index {exc.pos}: {exc.msg}\")\n    return patterns\n",
      "\ndef _regexp_paths_csv_validator(\n    _, name: str, value: str | list[Pattern[str]]\n) -> list[Pattern[str]]:\n    if isinstance(value, list):\n        return value\n    patterns = []\n    for val in _csv_validator(_, name, value):\n        patterns.append(\n            _compile_regexp(\n                str(pathlib.PureWindowsPath(val)).replace(\"\\\\\", \"\\\\\\\\\")\n                + \"|\"\n                + pathlib.PureWindowsPath(val).as_posix()\n            )\n        )\n    return patterns\n",
      "\ndef _regexp_paths_csv_validator(\n    _, name: str, value: str | list[Pattern[str]]\n) -> list[Pattern[str]]:\n    if isinstance(value, list):\n        return value\n    patterns = []\n    for val in _csv_validator(_, name, value):\n        patterns.append(\n            _compile_regexp(\n                str(pathlib.PureWindowsPath(val)).replace(\"\\\\\", \"\\\\\\\\\")\n                + \"|\"\n                + pathlib.PureWindowsPath(val).as_posix()\n            )\n        )\n    return patterns\n",
      "\ndef _regexp_paths_csv_validator(\n    _, name: str, value: str | list[Pattern[str]]\n) -> list[Pattern[str]]:\n    if isinstance(value, list):\n        return value\n    patterns = []\n    for val in _csv_validator(_, name, value):\n        patterns.append(\n            _compile_regexp(\n                str(pathlib.PureWindowsPath(val)).replace(\"\\\\\", \"\\\\\\\\\")\n                + \"|\"\n                + pathlib.PureWindowsPath(val).as_posix()\n            )\n        )\n    return patterns\n",
      "\ndef _regexp_paths_csv_validator(\n    _, name: str, value: str | list[Pattern[str]]\n) -> list[Pattern[str]]:\n    if isinstance(value, list):\n        return value\n    patterns = []\n    for val in _csv_validator(_, name, value):\n        patterns.append(\n            _compile_regexp(\n                str(pathlib.PureWindowsPath(val)).replace(\"\\\\\", \"\\\\\\\\\")\n                + \"|\"\n                + pathlib.PureWindowsPath(val).as_posix()\n            )\n        )\n    return patterns\n",
      "\ndef _regexp_paths_csv_validator(\n    _, name: str, value: str | list[Pattern[str]]\n) -> list[Pattern[str]]:\n    if isinstance(value, list):\n        return value\n    patterns = []\n    for val in _csv_validator(_, name, value):\n        try:\n            # Try regex module first for Unicode property escape support\n            import regex\n            compiled_pattern = regex.compile(\n                str(pathlib.PureWindowsPath(val)).replace(\"\\\\\", \"\\\\\\\\\")\n                + \"|\"\n                + pathlib.PureWindowsPath(val).as_posix()\n            )\n        except ImportError:\n            # Fall back to standard re module\n            compiled_pattern = re.compile(\n                str(pathlib.PureWindowsPath(val)).replace(\"\\\\\", \"\\\\\\\\\")\n                + \"|\"\n                + pathlib.PureWindowsPath(val).as_posix()\n            )\n        patterns.append(compiled_pattern)\n    return patterns\n",
      "\ndef _regexp_paths_csv_validator(\n    _, name: str, value: str | list[Pattern[str]]\n) -> list[Pattern[str]]:\n    if isinstance(value, list):\n        return value\n    patterns = []\n    for val in _csv_validator(_, name, value):\n        patterns.append(\n            _compile_regexp(\n                str(pathlib.PureWindowsPath(val)).replace(\"\\\\\", \"\\\\\\\\\")\n                + \"|\"\n                + pathlib.PureWindowsPath(val).as_posix()\n            )\n        )\n    return patterns\n",
      "\ndef _regexp_paths_csv_validator(\n    _, name: str, value: str | list[Pattern[str]]\n) -> list[Pattern[str]]:\n    if isinstance(value, list):\n        return value\n    patterns = []\n    for val in _csv_validator(_, name, value):\n        patterns.append(\n            _compile_regexp(\n                str(pathlib.PureWindowsPath(val)).replace(\"\\\\\", \"\\\\\\\\\")\n                + \"|\"\n                + pathlib.PureWindowsPath(val).as_posix()\n            )\n        )\n    return patterns\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/pylint/config/option.py b/pylint/config/option.py\nindex 5043fe765..8d937aa7e 100644\n--- a/pylint/config/option.py\n+++ b/pylint/config/option.py\n@@ -7,9 +7,8 @@ from __future__ import annotations\n import copy\n import optparse  # pylint: disable=deprecated-module\n import pathlib\n-import re\n-import warnings\n-from re import Pattern\n+\n+    \"regexp\": lambda pattern: _compile_regex(pattern or \"\"),\n \n from pylint import utils\n \n@@ -20,10 +19,15 @@ def _csv_validator(_, name, value):\n \n \n # pylint: disable=unused-argument\n-def _regexp_validator(_, name, value):\n-    if hasattr(value, \"pattern\"):\n-        return value\n-    return re.compile(value)\n+\n+import re\n+import warnings\n+try:\n+    import regex\n+    HAS_REGEX = True\n+except ImportError:\n+    HAS_REGEX = False\n+from re import Pattern\n \n \n # pylint: disable=unused-argument\n@@ -32,6 +36,7 @@ def _regexp_csv_validator(_, name, value):\n \n \n def _regexp_paths_csv_validator(\n+\n     _, name: str, value: str | list[Pattern[str]]\n ) -> list[Pattern[str]]:\n     if isinstance(value, list):\n@@ -99,11 +104,23 @@ def _py_version_validator(_, name, value):\n     return value\n \n \n+\n+def _compile_regex(pattern):\n+    \"\"\"Compile a regex pattern with Unicode property support when available.\"\"\"\n+    try:\n+        if HAS_REGEX:\n+            return regex.compile(pattern)\n+        else:\n+            return re.compile(pattern)\n+    except Exception as e:\n+        raise optparse.OptionValueError(f\"Invalid regex pattern: {e}\")\n+\n+\n VALIDATORS = {\n     \"string\": utils._unquote,\n     \"int\": int,\n     \"float\": float,\n-    \"regexp\": lambda pattern: re.compile(pattern or \"\"),\n+    \"regexp\": lambda pattern: _compile_regex(pattern or \"\"),\n     \"regexp_csv\": _regexp_csv_validator,\n     \"regexp_paths_csv\": _regexp_paths_csv_validator,\n     \"csv\": _csv_validator,\n@@ -118,6 +135,10 @@ VALIDATORS = {\n     \"non_empty_string\": _non_empty_string_validator,\n     \"py_version\": _py_version_validator,\n }\n+    ),\n+    \"non_empty_string\": _non_empty_string_validator,\n+    \"py_version\": _py_version_validator,\n+}\n \n \n def _call_validator(opttype, optdict, option, value):\n",
    "variant_0": "diff --git a/pylint/config/option.py b/pylint/config/option.py\nindex 5043fe765..ffa41ee1d 100644\n--- a/pylint/config/option.py\n+++ b/pylint/config/option.py\n@@ -7,8 +7,14 @@ from __future__ import annotations\n import copy\n import optparse  # pylint: disable=deprecated-module\n import pathlib\n+\n import re\n import warnings\n+try:\n+    import regex\n+    HAS_REGEX = True\n+except ImportError:\n+    HAS_REGEX = False\n from re import Pattern\n \n from pylint import utils\n@@ -20,10 +26,17 @@ def _csv_validator(_, name, value):\n \n \n # pylint: disable=unused-argument\n+\n def _regexp_validator(_, name, value):\n     if hasattr(value, \"pattern\"):\n         return value\n-    return re.compile(value)\n+    try:\n+        import regex\n+        return regex.compile(value)\n+    except ImportError:\n+        return re.compile(value)\n+    except re.error as exc:\n+        raise optparse.OptionValueError(f\"invalid regular expression: {exc}\") from exc\n \n \n # pylint: disable=unused-argument\n@@ -31,12 +44,33 @@ def _regexp_csv_validator(_, name, value):\n     return [_regexp_validator(_, name, val) for val in _csv_validator(_, name, value)]\n \n \n+def _regexp_paths_csv_validator(\n+\n def _regexp_paths_csv_validator(\n     _, name: str, value: str | list[Pattern[str]]\n ) -> list[Pattern[str]]:\n     if isinstance(value, list):\n         return value\n     patterns = []\n+    for val in _csv_validator(_, name, value):\n+        try:\n+            # Try regex module first for Unicode property escape support\n+            if 'regex' in globals():\n+                pattern = regex.compile(\n+                    str(pathlib.PureWindowsPath(val)).replace(\"\\\\\", \"\\\\\\\\\")\n+                    + \"|\"\n+                    + pathlib.PureWindowsPath(val).as_posix()\n+                )\n+            else:\n+                pattern = re.compile(\n+                    str(pathlib.PureWindowsPath(val)).replace(\"\\\\\", \"\\\\\\\\\")\n+                    + \"|\"\n+                    + pathlib.PureWindowsPath(val).as_posix()\n+                )\n+            patterns.append(pattern)\n+        except (re.error, ValueError) as exc:\n+            raise optparse.OptionValueError(f\"Invalid regexp pattern {val!r}: {exc}\")\n+    return patterns\n     for val in _csv_validator(_, name, value):\n         patterns.append(\n             re.compile(\n@@ -99,11 +133,33 @@ def _py_version_validator(_, name, value):\n     return value\n \n \n+\n+# Unicode-aware compilation helper - add after existing imports\n+try:\n+    import regex\n+    HAS_REGEX = True\n+except ImportError:\n+    HAS_REGEX = False\n+\n+def _compile_regex_unicode_aware(pattern):\n+    \"\"\"Compile regex pattern with Unicode property escape support when available.\"\"\"\n+    if not pattern:\n+        pattern = \"\"\n+    \n+    if HAS_REGEX:\n+        try:\n+            return regex.compile(pattern)\n+        except regex.error:\n+            # Fall back to standard re if regex fails\n+            pass\n+    \n+    return re.compile(pattern)\n+\n VALIDATORS = {\n     \"string\": utils._unquote,\n     \"int\": int,\n     \"float\": float,\n-    \"regexp\": lambda pattern: re.compile(pattern or \"\"),\n+    \"regexp\": _compile_regex_unicode_aware,\n     \"regexp_csv\": _regexp_csv_validator,\n     \"regexp_paths_csv\": _regexp_paths_csv_validator,\n     \"csv\": _csv_validator,\n@@ -118,6 +174,7 @@ VALIDATORS = {\n     \"non_empty_string\": _non_empty_string_validator,\n     \"py_version\": _py_version_validator,\n }\n+}\n \n \n def _call_validator(opttype, optdict, option, value):\n",
    "variant_1": "diff --git a/pylint/config/option.py b/pylint/config/option.py\nindex 5043fe765..be45d06a8 100644\n--- a/pylint/config/option.py\n+++ b/pylint/config/option.py\n@@ -7,8 +7,14 @@ from __future__ import annotations\n import copy\n import optparse  # pylint: disable=deprecated-module\n import pathlib\n+\n import re\n import warnings\n+try:\n+    import regex\n+    HAS_REGEX = True\n+except ImportError:\n+    HAS_REGEX = False\n from re import Pattern\n \n from pylint import utils\n@@ -20,10 +26,18 @@ def _csv_validator(_, name, value):\n \n \n # pylint: disable=unused-argument\n+\n def _regexp_validator(_, name, value):\n     if hasattr(value, \"pattern\"):\n         return value\n-    return re.compile(value)\n+    try:\n+        import regex\n+        return regex.compile(value)\n+    except ImportError:\n+        return re.compile(value)\n+    except Exception:\n+        # If regex module fails to compile, fallback to re\n+        return re.compile(value)\n \n \n # pylint: disable=unused-argument\n@@ -31,12 +45,33 @@ def _regexp_csv_validator(_, name, value):\n     return [_regexp_validator(_, name, val) for val in _csv_validator(_, name, value)]\n \n \n+def _regexp_paths_csv_validator(\n+\n def _regexp_paths_csv_validator(\n     _, name: str, value: str | list[Pattern[str]]\n ) -> list[Pattern[str]]:\n     if isinstance(value, list):\n         return value\n     patterns = []\n+    for val in _csv_validator(_, name, value):\n+        try:\n+            # Try regex module first for Unicode property escape support\n+            if 'regex' in globals():\n+                pattern = regex.compile(\n+                    str(pathlib.PureWindowsPath(val)).replace(\"\\\\\", \"\\\\\\\\\")\n+                    + \"|\"\n+                    + pathlib.PureWindowsPath(val).as_posix()\n+                )\n+            else:\n+                pattern = re.compile(\n+                    str(pathlib.PureWindowsPath(val)).replace(\"\\\\\", \"\\\\\\\\\")\n+                    + \"|\"\n+                    + pathlib.PureWindowsPath(val).as_posix()\n+                )\n+            patterns.append(pattern)\n+        except re.error as exc:\n+            raise optparse.OptionValueError(f\"Error in provided regular expression: {val} beginning at index {exc.pos}: {exc.msg}\")\n+    return patterns\n     for val in _csv_validator(_, name, value):\n         patterns.append(\n             re.compile(\n@@ -99,11 +134,31 @@ def _py_version_validator(_, name, value):\n     return value\n \n \n+\n+# Helper function for Unicode-aware regex compilation\n+def _compile_regex_with_unicode_support(pattern):\n+    \"\"\"Compile regex pattern with Unicode property escape support if available.\"\"\"\n+    if not pattern:\n+        pattern = \"\"\n+    \n+    # Try regex module first for Unicode property escape support\n+    try:\n+        import regex\n+        return regex.compile(pattern)\n+    except ImportError:\n+        pass\n+    except regex.error:\n+        # If regex module fails, fall back to re module\n+        pass\n+    \n+    # Fallback to standard re module\n+    return re.compile(pattern)\n+\n VALIDATORS = {\n     \"string\": utils._unquote,\n     \"int\": int,\n     \"float\": float,\n-    \"regexp\": lambda pattern: re.compile(pattern or \"\"),\n+    \"regexp\": _compile_regex_with_unicode_support,\n     \"regexp_csv\": _regexp_csv_validator,\n     \"regexp_paths_csv\": _regexp_paths_csv_validator,\n     \"csv\": _csv_validator,\n@@ -118,6 +173,7 @@ VALIDATORS = {\n     \"non_empty_string\": _non_empty_string_validator,\n     \"py_version\": _py_version_validator,\n }\n+}\n \n \n def _call_validator(opttype, optdict, option, value):\n",
    "variant_2": "diff --git a/pylint/config/option.py b/pylint/config/option.py\nindex 5043fe765..c8a845a15 100644\n--- a/pylint/config/option.py\n+++ b/pylint/config/option.py\n@@ -7,8 +7,15 @@ from __future__ import annotations\n import copy\n import optparse  # pylint: disable=deprecated-module\n import pathlib\n+\n import re\n import warnings\n+try:\n+    import regex\n+    HAS_REGEX = True\n+except ImportError:\n+    HAS_REGEX = False\n+    regex = None\n from re import Pattern\n \n from pylint import utils\n@@ -20,10 +27,17 @@ def _csv_validator(_, name, value):\n \n \n # pylint: disable=unused-argument\n+\n def _regexp_validator(_, name, value):\n     if hasattr(value, \"pattern\"):\n         return value\n-    return re.compile(value)\n+    try:\n+        import regex\n+        return regex.compile(value)\n+    except ImportError:\n+        return re.compile(value)\n+    except re.error as exc:\n+        raise optparse.OptionValueError(f\"Invalid regular expression: {exc}\")\n \n \n # pylint: disable=unused-argument\n@@ -31,12 +45,23 @@ def _regexp_csv_validator(_, name, value):\n     return [_regexp_validator(_, name, val) for val in _csv_validator(_, name, value)]\n \n \n+def _regexp_paths_csv_validator(\n+\n def _regexp_paths_csv_validator(\n     _, name: str, value: str | list[Pattern[str]]\n ) -> list[Pattern[str]]:\n     if isinstance(value, list):\n         return value\n     patterns = []\n+    for val in _csv_validator(_, name, value):\n+        patterns.append(\n+            _compile_regexp(\n+                str(pathlib.PureWindowsPath(val)).replace(\"\\\\\", \"\\\\\\\\\")\n+                + \"|\"\n+                + pathlib.PureWindowsPath(val).as_posix()\n+            )\n+        )\n+    return patterns\n     for val in _csv_validator(_, name, value):\n         patterns.append(\n             re.compile(\n@@ -99,11 +124,35 @@ def _py_version_validator(_, name, value):\n     return value\n \n \n+\n+# Helper function to compile regex patterns with Unicode property support\n+def _compile_regex_with_unicode_support(pattern):\n+    \"\"\"Compile regex pattern with Unicode property escape support if available.\"\"\"\n+    if not pattern:\n+        pattern = \"\"\n+    \n+    # Try regex module first for Unicode property escape support\n+    try:\n+        import regex\n+        return regex.compile(pattern)\n+    except ImportError:\n+        # Fall back to standard re module\n+        try:\n+            return re.compile(pattern)\n+        except re.error as e:\n+            # If it's a Unicode property escape error, provide helpful message\n+            if r'\\p{' in pattern:\n+                raise re.error(\n+                    f\"Unicode property escapes like \\\\p{{...}} are not supported by the standard re module. \"\n+                    f\"Install the 'regex' package for Unicode property escape support.\"\n+                ) from e\n+            raise\n+\n VALIDATORS = {\n     \"string\": utils._unquote,\n     \"int\": int,\n     \"float\": float,\n-    \"regexp\": lambda pattern: re.compile(pattern or \"\"),\n+    \"regexp\": _compile_regex_with_unicode_support,\n     \"regexp_csv\": _regexp_csv_validator,\n     \"regexp_paths_csv\": _regexp_paths_csv_validator,\n     \"csv\": _csv_validator,\n@@ -118,6 +167,7 @@ VALIDATORS = {\n     \"non_empty_string\": _non_empty_string_validator,\n     \"py_version\": _py_version_validator,\n }\n+}\n \n \n def _call_validator(opttype, optdict, option, value):\n",
    "variant_3": "diff --git a/pylint/config/option.py b/pylint/config/option.py\nindex 5043fe765..1c190e7ee 100644\n--- a/pylint/config/option.py\n+++ b/pylint/config/option.py\n@@ -7,8 +7,14 @@ from __future__ import annotations\n import copy\n import optparse  # pylint: disable=deprecated-module\n import pathlib\n+\n import re\n import warnings\n+try:\n+    import regex\n+    HAS_REGEX = True\n+except ImportError:\n+    HAS_REGEX = False\n from re import Pattern\n \n from pylint import utils\n@@ -20,10 +26,18 @@ def _csv_validator(_, name, value):\n \n \n # pylint: disable=unused-argument\n+\n def _regexp_validator(_, name, value):\n     if hasattr(value, \"pattern\"):\n         return value\n-    return re.compile(value)\n+    try:\n+        import regex\n+        return regex.compile(value)\n+    except ImportError:\n+        return re.compile(value)\n+    except Exception:\n+        # If regex module fails to compile, fallback to re\n+        return re.compile(value)\n \n \n # pylint: disable=unused-argument\n@@ -31,12 +45,23 @@ def _regexp_csv_validator(_, name, value):\n     return [_regexp_validator(_, name, val) for val in _csv_validator(_, name, value)]\n \n \n+def _regexp_paths_csv_validator(\n+\n def _regexp_paths_csv_validator(\n     _, name: str, value: str | list[Pattern[str]]\n ) -> list[Pattern[str]]:\n     if isinstance(value, list):\n         return value\n     patterns = []\n+    for val in _csv_validator(_, name, value):\n+        patterns.append(\n+            _compile_regexp(\n+                str(pathlib.PureWindowsPath(val)).replace(\"\\\\\", \"\\\\\\\\\")\n+                + \"|\"\n+                + pathlib.PureWindowsPath(val).as_posix()\n+            )\n+        )\n+    return patterns\n     for val in _csv_validator(_, name, value):\n         patterns.append(\n             re.compile(\n@@ -99,11 +124,12 @@ def _py_version_validator(_, name, value):\n     return value\n \n \n+\n VALIDATORS = {\n     \"string\": utils._unquote,\n     \"int\": int,\n     \"float\": float,\n-    \"regexp\": lambda pattern: re.compile(pattern or \"\"),\n+    \"regexp\": lambda pattern: _compile_regexp(pattern or \"\"),\n     \"regexp_csv\": _regexp_csv_validator,\n     \"regexp_paths_csv\": _regexp_paths_csv_validator,\n     \"csv\": _csv_validator,\n@@ -118,6 +144,7 @@ VALIDATORS = {\n     \"non_empty_string\": _non_empty_string_validator,\n     \"py_version\": _py_version_validator,\n }\n+}\n \n \n def _call_validator(opttype, optdict, option, value):\n",
    "variant_4": "diff --git a/pylint/config/option.py b/pylint/config/option.py\nindex 5043fe765..cb1981a67 100644\n--- a/pylint/config/option.py\n+++ b/pylint/config/option.py\n@@ -7,8 +7,14 @@ from __future__ import annotations\n import copy\n import optparse  # pylint: disable=deprecated-module\n import pathlib\n+\n import re\n import warnings\n+try:\n+    import regex\n+    HAS_REGEX = True\n+except ImportError:\n+    HAS_REGEX = False\n from re import Pattern\n \n from pylint import utils\n@@ -20,10 +26,23 @@ def _csv_validator(_, name, value):\n \n \n # pylint: disable=unused-argument\n+\n def _regexp_validator(_, name, value):\n     if hasattr(value, \"pattern\"):\n         return value\n-    return re.compile(value)\n+    try:\n+        import regex\n+        return regex.compile(value)\n+    except ImportError:\n+        return re.compile(value)\n+    except re.error as e:\n+        try:\n+            import regex\n+            return regex.compile(value)\n+        except ImportError:\n+            raise optparse.OptionValueError(f\"Invalid regular expression: {e}\")\n+        except regex.error:\n+            raise optparse.OptionValueError(f\"Invalid regular expression: {e}\")\n \n \n # pylint: disable=unused-argument\n@@ -31,12 +50,23 @@ def _regexp_csv_validator(_, name, value):\n     return [_regexp_validator(_, name, val) for val in _csv_validator(_, name, value)]\n \n \n+def _regexp_paths_csv_validator(\n+\n def _regexp_paths_csv_validator(\n     _, name: str, value: str | list[Pattern[str]]\n ) -> list[Pattern[str]]:\n     if isinstance(value, list):\n         return value\n     patterns = []\n+    for val in _csv_validator(_, name, value):\n+        patterns.append(\n+            _compile_regexp(\n+                str(pathlib.PureWindowsPath(val)).replace(\"\\\\\", \"\\\\\\\\\")\n+                + \"|\"\n+                + pathlib.PureWindowsPath(val).as_posix()\n+            )\n+        )\n+    return patterns\n     for val in _csv_validator(_, name, value):\n         patterns.append(\n             re.compile(\n@@ -99,11 +129,40 @@ def _py_version_validator(_, name, value):\n     return value\n \n \n+\n+# Create a helper function for Unicode-aware regex compilation\n+def _compile_regex_with_unicode_support(pattern):\n+    \"\"\"Compile regex pattern with Unicode property escape support if available.\"\"\"\n+    if not pattern:\n+        pattern = \"\"\n+    \n+    # Try regex module first for Unicode property escape support\n+    try:\n+        import regex\n+        return regex.compile(pattern)\n+    except ImportError:\n+        pass\n+    except regex.error:\n+        # Fall back to re module if regex compilation fails\n+        pass\n+    \n+    # Fall back to standard re module\n+    try:\n+        return re.compile(pattern)\n+    except re.error as exc:\n+        # Provide helpful error message for Unicode property escapes\n+        if r'\\p{' in pattern:\n+            raise re.error(\n+                f\"Unicode property escapes like '\\\\p{{...}}' are not supported by the standard re module. \"\n+                f\"Install the 'regex' package for Unicode property escape support: pip install regex\"\n+            ) from exc\n+        raise\n+\n VALIDATORS = {\n     \"string\": utils._unquote,\n     \"int\": int,\n     \"float\": float,\n-    \"regexp\": lambda pattern: re.compile(pattern or \"\"),\n+    \"regexp\": _compile_regex_with_unicode_support,\n     \"regexp_csv\": _regexp_csv_validator,\n     \"regexp_paths_csv\": _regexp_paths_csv_validator,\n     \"csv\": _csv_validator,\n@@ -118,6 +177,7 @@ VALIDATORS = {\n     \"non_empty_string\": _non_empty_string_validator,\n     \"py_version\": _py_version_validator,\n }\n+}\n \n \n def _call_validator(opttype, optdict, option, value):\n",
    "variant_5": "diff --git a/pylint/config/option.py b/pylint/config/option.py\nindex 5043fe765..820075eeb 100644\n--- a/pylint/config/option.py\n+++ b/pylint/config/option.py\n@@ -7,8 +7,14 @@ from __future__ import annotations\n import copy\n import optparse  # pylint: disable=deprecated-module\n import pathlib\n+\n import re\n import warnings\n+try:\n+    import regex\n+    HAS_REGEX = True\n+except ImportError:\n+    HAS_REGEX = False\n from re import Pattern\n \n from pylint import utils\n@@ -20,10 +26,17 @@ def _csv_validator(_, name, value):\n \n \n # pylint: disable=unused-argument\n+\n def _regexp_validator(_, name, value):\n     if hasattr(value, \"pattern\"):\n         return value\n-    return re.compile(value)\n+    try:\n+        import regex\n+        return regex.compile(value)\n+    except ImportError:\n+        return re.compile(value)\n+    except re.error as exc:\n+        raise optparse.OptionValueError(f\"invalid regexp {value!r}: {exc}\") from exc\n \n \n # pylint: disable=unused-argument\n@@ -31,12 +44,23 @@ def _regexp_csv_validator(_, name, value):\n     return [_regexp_validator(_, name, val) for val in _csv_validator(_, name, value)]\n \n \n+def _regexp_paths_csv_validator(\n+\n def _regexp_paths_csv_validator(\n     _, name: str, value: str | list[Pattern[str]]\n ) -> list[Pattern[str]]:\n     if isinstance(value, list):\n         return value\n     patterns = []\n+    for val in _csv_validator(_, name, value):\n+        patterns.append(\n+            _compile_regexp(\n+                str(pathlib.PureWindowsPath(val)).replace(\"\\\\\", \"\\\\\\\\\")\n+                + \"|\"\n+                + pathlib.PureWindowsPath(val).as_posix()\n+            )\n+        )\n+    return patterns\n     for val in _csv_validator(_, name, value):\n         patterns.append(\n             re.compile(\n@@ -99,11 +123,41 @@ def _py_version_validator(_, name, value):\n     return value\n \n \n+\n+# Create a helper function for Unicode-aware regex compilation\n+def _compile_regex_with_unicode_support(pattern):\n+    \"\"\"Compile regex pattern with Unicode property escape support when available.\"\"\"\n+    if not pattern:\n+        pattern = \"\"\n+    \n+    # Try regex module first for Unicode property escape support\n+    try:\n+        import regex\n+        return regex.compile(pattern)\n+    except ImportError:\n+        pass\n+    except regex.error:\n+        # If regex module fails, fall back to re module\n+        pass\n+    \n+    # Fall back to standard re module\n+    try:\n+        return re.compile(pattern)\n+    except re.error as exc:\n+        # Provide helpful error message for Unicode property escapes\n+        if r'\\p{' in pattern or r'\\P{' in pattern:\n+            raise re.error(\n+                f\"Unicode property escapes like \\\\p{{}} are not supported by Python's re module. \"\n+                f\"Install the 'regex' module for Unicode property escape support. \"\n+                f\"Original error: {exc}\"\n+            ) from exc\n+        raise\n+\n VALIDATORS = {\n     \"string\": utils._unquote,\n     \"int\": int,\n     \"float\": float,\n-    \"regexp\": lambda pattern: re.compile(pattern or \"\"),\n+    \"regexp\": _compile_regex_with_unicode_support,\n     \"regexp_csv\": _regexp_csv_validator,\n     \"regexp_paths_csv\": _regexp_paths_csv_validator,\n     \"csv\": _csv_validator,\n@@ -118,6 +172,7 @@ VALIDATORS = {\n     \"non_empty_string\": _non_empty_string_validator,\n     \"py_version\": _py_version_validator,\n }\n+}\n \n \n def _call_validator(opttype, optdict, option, value):\n",
    "variant_6": "diff --git a/pylint/config/option.py b/pylint/config/option.py\nindex 5043fe765..86446c2e1 100644\n--- a/pylint/config/option.py\n+++ b/pylint/config/option.py\n@@ -7,8 +7,14 @@ from __future__ import annotations\n import copy\n import optparse  # pylint: disable=deprecated-module\n import pathlib\n+\n import re\n import warnings\n+try:\n+    import regex\n+    HAS_REGEX = True\n+except ImportError:\n+    HAS_REGEX = False\n from re import Pattern\n \n from pylint import utils\n@@ -20,10 +26,21 @@ def _csv_validator(_, name, value):\n \n \n # pylint: disable=unused-argument\n+\n def _regexp_validator(_, name, value):\n     if hasattr(value, \"pattern\"):\n         return value\n-    return re.compile(value)\n+    try:\n+        import regex\n+        return regex.compile(value)\n+    except ImportError:\n+        return re.compile(value)\n+    except re.error as e:\n+        try:\n+            import regex\n+            return regex.compile(value)\n+        except ImportError:\n+            raise e\n \n \n # pylint: disable=unused-argument\n@@ -31,12 +48,32 @@ def _regexp_csv_validator(_, name, value):\n     return [_regexp_validator(_, name, val) for val in _csv_validator(_, name, value)]\n \n \n+def _regexp_paths_csv_validator(\n+\n def _regexp_paths_csv_validator(\n     _, name: str, value: str | list[Pattern[str]]\n ) -> list[Pattern[str]]:\n     if isinstance(value, list):\n         return value\n     patterns = []\n+    for val in _csv_validator(_, name, value):\n+        try:\n+            # Try regex module first for Unicode property escape support\n+            import regex\n+            compiled_pattern = regex.compile(\n+                str(pathlib.PureWindowsPath(val)).replace(\"\\\\\", \"\\\\\\\\\")\n+                + \"|\"\n+                + pathlib.PureWindowsPath(val).as_posix()\n+            )\n+        except ImportError:\n+            # Fall back to standard re module\n+            compiled_pattern = re.compile(\n+                str(pathlib.PureWindowsPath(val)).replace(\"\\\\\", \"\\\\\\\\\")\n+                + \"|\"\n+                + pathlib.PureWindowsPath(val).as_posix()\n+            )\n+        patterns.append(compiled_pattern)\n+    return patterns\n     for val in _csv_validator(_, name, value):\n         patterns.append(\n             re.compile(\n@@ -99,11 +136,37 @@ def _py_version_validator(_, name, value):\n     return value\n \n \n+\n+# Helper function to compile regex patterns with Unicode support\n+def _compile_regex_with_unicode_support(pattern):\n+    \"\"\"Compile regex pattern with Unicode property escape support if available.\"\"\"\n+    if not pattern:\n+        pattern = \"\"\n+    \n+    # Try to use regex module for Unicode property escape support\n+    try:\n+        import regex\n+        return regex.compile(pattern)\n+    except ImportError:\n+        # Fall back to standard re module\n+        try:\n+            return re.compile(pattern)\n+        except re.error as exc:\n+            # Check if this might be a Unicode property escape issue\n+            if '\\\\p{' in pattern or '\\\\P{' in pattern:\n+                raise re.error(\n+                    f\"Unicode property escapes like \\\\p{{}} are not supported by Python's re module. \"\n+                    f\"Install the 'regex' package for Unicode property escape support. \"\n+                    f\"Original error: {exc}\"\n+                ) from exc\n+            raise\n+\n+\n VALIDATORS = {\n     \"string\": utils._unquote,\n     \"int\": int,\n     \"float\": float,\n-    \"regexp\": lambda pattern: re.compile(pattern or \"\"),\n+    \"regexp\": lambda pattern: _compile_regex_with_unicode_support(pattern),\n     \"regexp_csv\": _regexp_csv_validator,\n     \"regexp_paths_csv\": _regexp_paths_csv_validator,\n     \"csv\": _csv_validator,\n@@ -118,6 +181,7 @@ VALIDATORS = {\n     \"non_empty_string\": _non_empty_string_validator,\n     \"py_version\": _py_version_validator,\n }\n+}\n \n \n def _call_validator(opttype, optdict, option, value):\n",
    "variant_7": "diff --git a/pylint/config/option.py b/pylint/config/option.py\nindex 5043fe765..8f5e7ace1 100644\n--- a/pylint/config/option.py\n+++ b/pylint/config/option.py\n@@ -7,8 +7,14 @@ from __future__ import annotations\n import copy\n import optparse  # pylint: disable=deprecated-module\n import pathlib\n+\n import re\n import warnings\n+try:\n+    import regex\n+    HAS_REGEX = True\n+except ImportError:\n+    HAS_REGEX = False\n from re import Pattern\n \n from pylint import utils\n@@ -20,10 +26,17 @@ def _csv_validator(_, name, value):\n \n \n # pylint: disable=unused-argument\n+\n def _regexp_validator(_, name, value):\n     if hasattr(value, \"pattern\"):\n         return value\n-    return re.compile(value)\n+    try:\n+        import regex\n+        return regex.compile(value)\n+    except ImportError:\n+        return re.compile(value)\n+    except re.error as exc:\n+        raise optparse.OptionValueError(f\"Invalid regular expression: {exc}\")\n \n \n # pylint: disable=unused-argument\n@@ -31,12 +44,23 @@ def _regexp_csv_validator(_, name, value):\n     return [_regexp_validator(_, name, val) for val in _csv_validator(_, name, value)]\n \n \n+def _regexp_paths_csv_validator(\n+\n def _regexp_paths_csv_validator(\n     _, name: str, value: str | list[Pattern[str]]\n ) -> list[Pattern[str]]:\n     if isinstance(value, list):\n         return value\n     patterns = []\n+    for val in _csv_validator(_, name, value):\n+        patterns.append(\n+            _compile_regexp(\n+                str(pathlib.PureWindowsPath(val)).replace(\"\\\\\", \"\\\\\\\\\")\n+                + \"|\"\n+                + pathlib.PureWindowsPath(val).as_posix()\n+            )\n+        )\n+    return patterns\n     for val in _csv_validator(_, name, value):\n         patterns.append(\n             re.compile(\n@@ -99,11 +123,35 @@ def _py_version_validator(_, name, value):\n     return value\n \n \n+\n+# Import regex module for Unicode property escape support, fallback to standard re\n+try:\n+    import regex\n+    HAS_REGEX = True\n+except ImportError:\n+    HAS_REGEX = False\n+\n+\n+def _compile_regex_with_unicode_support(pattern):\n+    \"\"\"Compile regex pattern with Unicode property escape support when available.\"\"\"\n+    if not pattern:\n+        pattern = \"\"\n+    \n+    if HAS_REGEX:\n+        try:\n+            return regex.compile(pattern)\n+        except regex.error:\n+            # Fall back to standard re module if regex fails\n+            pass\n+    \n+    return re.compile(pattern)\n+\n+\n VALIDATORS = {\n     \"string\": utils._unquote,\n     \"int\": int,\n     \"float\": float,\n-    \"regexp\": lambda pattern: re.compile(pattern or \"\"),\n+    \"regexp\": _compile_regex_with_unicode_support,\n     \"regexp_csv\": _regexp_csv_validator,\n     \"regexp_paths_csv\": _regexp_paths_csv_validator,\n     \"csv\": _csv_validator,\n@@ -118,6 +166,7 @@ VALIDATORS = {\n     \"non_empty_string\": _non_empty_string_validator,\n     \"py_version\": _py_version_validator,\n }\n+}\n \n \n def _call_validator(opttype, optdict, option, value):\n",
    "variant_8": "diff --git a/pylint/config/option.py b/pylint/config/option.py\nindex 5043fe765..d91500874 100644\n--- a/pylint/config/option.py\n+++ b/pylint/config/option.py\n@@ -7,8 +7,14 @@ from __future__ import annotations\n import copy\n import optparse  # pylint: disable=deprecated-module\n import pathlib\n+\n import re\n import warnings\n+try:\n+    import regex\n+    HAS_REGEX = True\n+except ImportError:\n+    HAS_REGEX = False\n from re import Pattern\n \n from pylint import utils\n@@ -20,10 +26,18 @@ def _csv_validator(_, name, value):\n \n \n # pylint: disable=unused-argument\n+\n def _regexp_validator(_, name, value):\n     if hasattr(value, \"pattern\"):\n         return value\n-    return re.compile(value)\n+    try:\n+        import regex\n+        return regex.compile(value)\n+    except ImportError:\n+        return re.compile(value)\n+    except Exception:\n+        # If regex module fails to compile, fall back to re\n+        return re.compile(value)\n \n \n # pylint: disable=unused-argument\n@@ -31,12 +45,23 @@ def _regexp_csv_validator(_, name, value):\n     return [_regexp_validator(_, name, val) for val in _csv_validator(_, name, value)]\n \n \n+def _regexp_paths_csv_validator(\n+\n def _regexp_paths_csv_validator(\n     _, name: str, value: str | list[Pattern[str]]\n ) -> list[Pattern[str]]:\n     if isinstance(value, list):\n         return value\n     patterns = []\n+    for val in _csv_validator(_, name, value):\n+        patterns.append(\n+            _compile_regexp(\n+                str(pathlib.PureWindowsPath(val)).replace(\"\\\\\", \"\\\\\\\\\")\n+                + \"|\"\n+                + pathlib.PureWindowsPath(val).as_posix()\n+            )\n+        )\n+    return patterns\n     for val in _csv_validator(_, name, value):\n         patterns.append(\n             re.compile(\n@@ -99,11 +124,34 @@ def _py_version_validator(_, name, value):\n     return value\n \n \n+\n+# Add helper function for Unicode-aware regex compilation\n+def _compile_regex_with_unicode_support(pattern):\n+    \"\"\"Compile regex pattern with Unicode property escape support if available.\"\"\"\n+    if not pattern:\n+        pattern = \"\"\n+    \n+    # Try regex module first for Unicode property escape support\n+    try:\n+        import regex\n+        return regex.compile(pattern)\n+    except ImportError:\n+        pass\n+    except regex.error as e:\n+        # If regex module fails, fall back to re module\n+        pass\n+    \n+    # Fall back to standard re module\n+    try:\n+        return re.compile(pattern)\n+    except re.error as e:\n+        raise optparse.OptionValueError(f\"Invalid regular expression pattern: {e}\") from None\n+\n VALIDATORS = {\n     \"string\": utils._unquote,\n     \"int\": int,\n     \"float\": float,\n-    \"regexp\": lambda pattern: re.compile(pattern or \"\"),\n+    \"regexp\": _compile_regex_with_unicode_support,\n     \"regexp_csv\": _regexp_csv_validator,\n     \"regexp_paths_csv\": _regexp_paths_csv_validator,\n     \"csv\": _csv_validator,\n@@ -118,6 +166,7 @@ VALIDATORS = {\n     \"non_empty_string\": _non_empty_string_validator,\n     \"py_version\": _py_version_validator,\n }\n+}\n \n \n def _call_validator(opttype, optdict, option, value):\n"
  }
}