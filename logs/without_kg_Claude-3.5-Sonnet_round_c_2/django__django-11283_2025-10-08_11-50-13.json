{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/django/django/contrib/auth/migrations/0011_update_proxy_permissions.py lines 27-30)": "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename, name=name)\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Delete any existing permissions with the new content type to avoid duplicates\n        Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        ).delete()\n        \n        Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        ).update(content_type=new_content_type)\n\n\ndef revert_proxy_model_permissions(apps, schema_editor):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the concrete model.\n    \"\"\"\n    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n",
    "Location 2 (/root/hy/projects_2/django/django/contrib/auth/migrations/0011_update_proxy_permissions.py lines 20-26)": "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename, name=name)\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that need to be updated\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Check for existing permissions with the new content type that would cause duplicates\n        existing_codenames = set(\n            Permission.objects.filter(\n                permissions_query,\n                content_type=new_content_type,\n            ).values_list('codename', flat=True)\n        )\n        \n        # Only update permissions that won't create duplicates\n        for permission in permissions_to_update:\n            if permission.codename not in existing_codenames:\n                permission.content_type = new_content_type\n                permission.save()\n\n\ndef revert_proxy_model_permissions(apps, schema_editor):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the concrete model.\n    \"\"\"\n    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n",
    "Location 3 (/root/hy/projects_2/django/django/contrib/auth/migrations/0011_update_proxy_permissions.py lines 33-38)": "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    style = color_style()\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename, name=name)\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions to update\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Check for existing permissions that would create duplicates\n        for permission in permissions_to_update:\n            existing_permission = Permission.objects.filter(\n                codename=permission.codename,\n                content_type=new_content_type,\n            ).first()\n            \n            if existing_permission:\n                # Delete the old permission to avoid duplicate key violation\n                permission.delete()\n            else:\n                # Safe to update\n                permission.content_type = new_content_type\n                permission.save()\n\n\ndef revert_proxy_model_permissions(apps, schema_editor):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the concrete model.\n    \"\"\"\n    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n",
    "Location 4 (/root/hy/projects_2/django/django/contrib/auth/migrations/0011_update_proxy_permissions.py lines 12-19)": "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename, name=name)\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that need to be updated\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Check for existing permissions with the new content type that would cause duplicates\n        existing_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        ).values_list('codename', flat=True)\n        \n        # Only update permissions that won't create duplicates\n        for permission in permissions_to_update:\n            if permission.codename not in existing_permissions:\n                permission.content_type = new_content_type\n                permission.save()\n\n\ndef revert_proxy_model_permissions(apps, schema_editor):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the concrete model.\n    \"\"\"\n    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n",
    "Location 5 (/root/hy/projects_2/django/django/contrib/auth/migrations/0011_update_proxy_permissions.py lines 5-11)": "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename)\n        concrete_content_type = ContentType.objects.get_for_model(\n            Model, for_concrete_model=True\n        )\n        proxy_content_type = ContentType.objects.get_for_model(\n            Model, for_concrete_model=False\n        )\n        \n        if reverse:\n            # Check for existing permissions with concrete content type before updating\n            existing_concrete_permissions = Permission.objects.filter(\n                permissions_query,\n                content_type=concrete_content_type,\n            )\n            # Delete proxy permissions that would conflict\n            Permission.objects.filter(\n                permissions_query,\n                content_type=proxy_content_type,\n            ).exclude(\n                codename__in=existing_concrete_permissions.values_list('codename', flat=True)\n            ).delete()\n            # Update remaining proxy permissions to concrete\n            Permission.objects.filter(\n                permissions_query,\n                content_type=proxy_content_type,\n            ).update(content_type=concrete_content_type)\n        else:\n            # Check for existing permissions with proxy content type before updating\n            existing_proxy_permissions = Permission.objects.filter(\n                permissions_query,\n                content_type=proxy_content_type,\n            )\n            # Delete concrete permissions that would conflict\n            Permission.objects.filter(\n                permissions_query,\n                content_type=concrete_content_type,\n            ).exclude(\n                codename__in=existing_proxy_permissions.values_list('codename', flat=True)\n            ).delete()\n            # Update remaining concrete permissions to proxy\n            Permission.objects.filter(\n                permissions_query,\n                content_type=concrete_content_type,\n            ).update(content_type=proxy_content_type)\n\n\ndef revert_proxy_model_permissions(apps, schema_editor):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the concrete model.\n    \"\"\"\n    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/django/django/contrib/auth/migrations/0011_update_proxy_permissions.py lines 27-30)": [
      "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename, name=name)\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that would cause duplicates after update\n        existing_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        ).values_list('codename', flat=True)\n        \n        # Only update permissions that won't cause duplicates\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        ).exclude(codename__in=existing_permissions)\n        \n        permissions_to_update.update(content_type=new_content_type)\n",
      "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename, name=name)\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions to update\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Check for existing permissions with new content type to avoid duplicates\n        existing_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        ).values_list('codename', flat=True)\n        \n        # Only update permissions that won't create duplicates\n        for permission in permissions_to_update:\n            if permission.codename not in existing_permissions:\n                permission.content_type = new_content_type\n                permission.save()\n            else:\n                # Delete the old permission since we already have one with the new content type\n                permission.delete()\n\n\ndef revert_proxy_model_permissions(apps, schema_editor):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the concrete model.\n    \"\"\"\n    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n",
      "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    style = color_style()\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename, name=name)\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that need to be updated\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Check for existing permissions with the new content type that would cause duplicates\n        existing_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        ).values_list('codename', flat=True)\n        \n        # Only update permissions that won't create duplicates\n        for permission in permissions_to_update:\n            if permission.codename not in existing_permissions:\n                permission.content_type = new_content_type\n                permission.save()\n",
      "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename, name=name)\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that need to be updated\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Check for existing permissions with the new content_type that would cause conflicts\n        existing_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        ).values_list('codename', flat=True)\n        \n        # Only update permissions that won't create duplicates\n        for permission in permissions_to_update:\n            if permission.codename not in existing_permissions:\n                permission.content_type = new_content_type\n                permission.save()\n",
      "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename, name=name)\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that need to be updated\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Check for existing permissions with the new content_type that would cause duplicates\n        existing_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        ).values_list('codename', flat=True)\n        \n        # Only update permissions that won't create duplicates\n        for permission in permissions_to_update:\n            if permission.codename not in existing_permissions:\n                permission.content_type = new_content_type\n                permission.save()\n",
      "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    style = schema_editor.style\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename, name=name)\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that need to be updated\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Check for existing permissions with the new content type that would cause duplicates\n        existing_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        ).values_list('codename', flat=True)\n        \n        # Filter out permissions that would create duplicates\n        for permission in permissions_to_update:\n            if permission.codename not in existing_permissions:\n                permission.content_type = new_content_type\n                permission.save()\n",
      "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename, name=name)\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that would cause duplicates and delete them first\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Find existing permissions with the same codename and new content type\n        existing_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        ).values_list('codename', flat=True)\n        \n        # Delete existing permissions that would cause duplicates\n        if existing_permissions:\n            Permission.objects.filter(\n                codename__in=existing_permissions,\n                content_type=new_content_type,\n            ).delete()\n        \n        # Now safely update the remaining permissions\n        permissions_to_update.update(content_type=new_content_type)\n\n\ndef revert_proxy_model_permissions(apps, schema_editor):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the concrete model.\n    \"\"\"\n    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n",
      "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename, name=name)\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # First, delete any existing permissions with the target content_type to avoid duplicates\n        Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        ).delete()\n        \n        # Then update the permissions to use the new content_type\n        Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        ).update(content_type=new_content_type)\n\n\ndef revert_proxy_model_permissions(apps, schema_editor):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the concrete model.\n    \"\"\"\n    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n"
    ],
    "Location 2 (/root/hy/projects_2/django/django/contrib/auth/migrations/0011_update_proxy_permissions.py lines 20-26)": [
      "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename, name=name)\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that would be updated\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Check for existing permissions with the new content type that would cause duplicates\n        existing_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        ).values_list('codename', flat=True)\n        \n        # Only update permissions that won't create duplicates\n        for permission in permissions_to_update:\n            if permission.codename not in existing_permissions:\n                permission.content_type = new_content_type\n                permission.save()\n\n\ndef revert_proxy_model_permissions(apps, schema_editor):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the concrete model.\n    \"\"\"\n    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n",
      "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename, name=name)\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that need to be updated\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Check for existing permissions that would cause duplicates\n        existing_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        ).values_list('codename', flat=True)\n        \n        # Only update permissions that won't create duplicates\n        for permission in permissions_to_update:\n            if permission.codename not in existing_permissions:\n                permission.content_type = new_content_type\n                permission.save()\n",
      "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename, name=name)\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions to update\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Check for existing permissions with the new content type\n        existing_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        ).values_list('codename', flat=True)\n        \n        # Filter out permissions that would create duplicates\n        safe_permissions = permissions_to_update.exclude(\n            codename__in=existing_permissions\n        )\n        \n        # Update only the safe permissions\n        safe_permissions.update(content_type=new_content_type)\n        \n        # Delete the remaining old permissions that would cause duplicates\n        permissions_to_update.filter(\n            codename__in=existing_permissions\n        ).delete()\n\n\ndef revert_proxy_model_permissions(apps, schema_editor):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the concrete model.\n    \"\"\"\n    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n",
      "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename, name=name)\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that need to be updated\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Check for existing permissions that would cause conflicts\n        existing_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        ).values_list('codename', flat=True)\n        \n        # Filter out permissions that would create duplicates\n        safe_permissions = permissions_to_update.exclude(\n            codename__in=existing_permissions\n        )\n        \n        # Update only the safe permissions\n        safe_permissions.update(content_type=new_content_type)\n\n\ndef revert_proxy_model_permissions(apps, schema_editor):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the concrete model.\n    \"\"\"\n    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n",
      "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename, name=name)\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions to update\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Check for existing permissions that would cause duplicates\n        existing_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        ).values_list('codename', flat=True)\n        \n        # Update permissions that won't cause duplicates\n        for permission in permissions_to_update:\n            if permission.codename not in existing_permissions:\n                permission.content_type = new_content_type\n                permission.save()\n            else:\n                # Delete the old permission since the new one already exists\n                permission.delete()\n\n\ndef revert_proxy_model_permissions(apps, schema_editor):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the concrete model.\n    \"\"\"\n    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n",
      "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename, name=name)\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that would cause duplicates after update\n        existing_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        ).values_list('codename', flat=True)\n        \n        # Only update permissions that won't create duplicates\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        ).exclude(codename__in=existing_permissions)\n        \n        permissions_to_update.update(content_type=new_content_type)\n\n\ndef revert_proxy_model_permissions(apps, schema_editor):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the concrete model.\n    \"\"\"\n    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n",
      "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename, name=name)\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that need to be updated\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Check for existing permissions with the new content type that would cause duplicates\n        existing_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        ).values_list('codename', flat=True)\n        \n        # Filter out permissions that would create duplicates\n        safe_permissions = permissions_to_update.exclude(codename__in=existing_permissions)\n        \n        # Update only the safe permissions\n        safe_permissions.update(content_type=new_content_type)\n        \n        # Delete the conflicting old permissions to avoid duplicates\n        permissions_to_update.filter(codename__in=existing_permissions).delete()\n\n\ndef revert_proxy_model_permissions(apps, schema_editor):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the concrete model.\n    \"\"\"\n    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n",
      "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename, name=name)\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that would conflict with the update\n        conflicting_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        )\n        conflicting_codenames = set(conflicting_permissions.values_list('codename', flat=True))\n        \n        # Only update permissions that won't create duplicates\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        ).exclude(codename__in=conflicting_codenames)\n        \n        permissions_to_update.update(content_type=new_content_type)\n\n\ndef revert_proxy_model_permissions(apps, schema_editor):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the concrete model.\n    \"\"\"\n    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n"
    ],
    "Location 3 (/root/hy/projects_2/django/django/contrib/auth/migrations/0011_update_proxy_permissions.py lines 33-38)": [
      "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    style = color_style()\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename, name=name)\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that need to be updated\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Check for existing permissions with the target content_type that would cause duplicates\n        existing_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        ).values_list('codename', flat=True)\n        \n        # Only update permissions that won't create duplicates\n        for permission in permissions_to_update:\n            if permission.codename not in existing_permissions:\n                permission.content_type = new_content_type\n                permission.save()\n            else:\n                # Delete the old permission since we already have the new one\n                permission.delete()\n\n\ndef revert_proxy_model_permissions(apps, schema_editor):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the concrete model.\n    \"\"\"\n    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n",
      "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    \n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename, name=name)\n        \n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that need to be updated\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Check for existing permissions that would cause duplicates\n        existing_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        ).values_list('codename', flat=True)\n        \n        # Only update permissions that won't create duplicates\n        safe_permissions = permissions_to_update.exclude(\n            codename__in=existing_permissions\n        )\n        \n        # Delete duplicate permissions from old content type if they exist in new content type\n        if existing_permissions:\n            permissions_to_update.filter(\n                codename__in=existing_permissions\n            ).delete()\n        \n        # Update the remaining permissions\n        safe_permissions.update(content_type=new_content_type)\n\n\ndef revert_proxy_model_permissions(apps, schema_editor):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the concrete model.\n    \"\"\"\n    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n",
      "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    style = color_style()\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename, name=name)\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that need to be updated\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Check for existing permissions with the new content type that would cause duplicates\n        existing_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        ).values_list('codename', flat=True)\n        \n        # Only update permissions that won't create duplicates\n        for permission in permissions_to_update:\n            if permission.codename not in existing_permissions:\n                permission.content_type = new_content_type\n                permission.save()\n\n\ndef revert_proxy_model_permissions(apps, schema_editor):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the concrete model.\n    \"\"\"\n    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n",
      "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    style = color_style()\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename, name=name)\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that need to be updated\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Check for existing permissions with the new content_type that would create duplicates\n        existing_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        ).values_list('codename', flat=True)\n        \n        # Filter out permissions that would create duplicates\n        safe_permissions = permissions_to_update.exclude(codename__in=existing_permissions)\n        \n        # Update only the safe permissions\n        safe_permissions.update(content_type=new_content_type)\n        \n        # Delete conflicting permissions from old content_type if any remain\n        conflicting_permissions = permissions_to_update.filter(codename__in=existing_permissions)\n        conflicting_permissions.delete()\n\n\ndef revert_proxy_model_permissions(apps, schema_editor):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the concrete model.\n    \"\"\"\n    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n",
      "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    style = color_style()\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename, name=name)\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that need to be updated\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Check for existing permissions with the new content_type that would cause duplicates\n        existing_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        ).values_list('codename', flat=True)\n        \n        # Only update permissions that won't create duplicates\n        permissions_to_update = permissions_to_update.exclude(codename__in=existing_permissions)\n        \n        # Update the remaining permissions\n        permissions_to_update.update(content_type=new_content_type)\n\n\ndef revert_proxy_model_permissions(apps, schema_editor):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the concrete model.\n    \"\"\"\n    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n",
      "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    style = color_style()\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename, name=name)\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that need to be updated\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Check for existing permissions with the new content_type that would cause conflicts\n        existing_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        ).values_list('codename', flat=True)\n        \n        # Only update permissions that won't cause duplicate key violations\n        for permission in permissions_to_update:\n            if permission.codename not in existing_permissions:\n                permission.content_type = new_content_type\n                permission.save()\n            else:\n                # Delete the old permission to avoid duplicates\n                permission.delete()\n\n\ndef revert_proxy_model_permissions(apps, schema_editor):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the concrete model.\n    \"\"\"\n    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n",
      "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    Permission = apps.get_model('auth', 'Permission')\n    \n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename, name=name)\n\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that would conflict after update\n        conflicting_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type\n        ).values_list('codename', flat=True)\n        \n        # Only update permissions that won't create duplicates\n        non_conflicting_query = permissions_query & ~Q(codename__in=conflicting_permissions)\n        \n        Permission.objects.filter(\n            non_conflicting_query,\n            content_type=old_content_type,\n        ).update(content_type=new_content_type)\n\n\ndef revert_proxy_model_permissions(apps, schema_editor):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the concrete model.\n    \"\"\"\n    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n",
      "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    style = schema_editor.style\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename, name=name)\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions to update\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Check for existing permissions with the target content_type\n        # that would cause duplicates\n        existing_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        ).values_list('codename', flat=True)\n        \n        # Only update permissions that won't create duplicates\n        for permission in permissions_to_update:\n            if permission.codename not in existing_permissions:\n                permission.content_type = new_content_type\n                permission.save()\n"
    ],
    "Location 4 (/root/hy/projects_2/django/django/contrib/auth/migrations/0011_update_proxy_permissions.py lines 12-19)": [
      "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename, name=name)\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that need to be updated\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Check for existing permissions with the new content type to avoid duplicates\n        existing_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        ).values_list('codename', flat=True)\n        \n        # Only update permissions that won't create duplicates\n        for permission in permissions_to_update:\n            if permission.codename not in existing_permissions:\n                permission.content_type = new_content_type\n                permission.save()\n\n\ndef revert_proxy_model_permissions(apps, schema_editor, **kwargs):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the concrete model.\n    \"\"\"\n    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n",
      "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename, name=name)\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that need to be updated\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Check for existing permissions with the new content type that would cause duplicates\n        existing_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        ).values_list('codename', flat=True)\n        \n        # Filter out permissions that would create duplicates\n        safe_permissions = permissions_to_update.exclude(codename__in=existing_permissions)\n        \n        # Update only the safe permissions\n        safe_permissions.update(content_type=new_content_type)\n\n\ndef revert_proxy_model_permissions(apps, schema_editor):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the concrete model.\n    \"\"\"\n    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n",
      "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename, name=name)\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that need to be updated\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Check for existing permissions with the new content type to avoid duplicates\n        existing_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        ).values_list('codename', flat=True)\n        \n        # Only update permissions that won't create duplicates\n        permissions_to_update = permissions_to_update.exclude(\n            codename__in=existing_permissions\n        )\n        \n        permissions_to_update.update(content_type=new_content_type)\n\n\ndef revert_proxy_model_permissions(apps, schema_editor):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the concrete model.\n    \"\"\"\n    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n",
      "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename, name=name)\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that need to be updated\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Check for existing permissions with the new content type that would cause conflicts\n        existing_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        ).values_list('codename', flat=True)\n        \n        # Filter out permissions that would create duplicates\n        safe_permissions = permissions_to_update.exclude(codename__in=existing_permissions)\n        \n        # Update only the safe permissions\n        safe_permissions.update(content_type=new_content_type)\n\n\ndef revert_proxy_model_permissions(apps, schema_editor):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the concrete model.\n    \"\"\"\n    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n",
      "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename, name=name)\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that need to be updated\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Check for existing permissions with the new content type that would cause conflicts\n        existing_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        ).values_list('codename', flat=True)\n        \n        # Only update permissions that won't create duplicates\n        for permission in permissions_to_update:\n            if permission.codename not in existing_permissions:\n                permission.content_type = new_content_type\n                permission.save()\n\n\ndef revert_proxy_model_permissions(apps, schema_editor):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the concrete model.\n    \"\"\"\n    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n",
      "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename, name=name)\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that need to be updated\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Check for existing permissions with new content type that would cause duplicates\n        existing_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        ).values_list('codename', flat=True)\n        \n        # Only update permissions that won't create duplicates\n        for permission in permissions_to_update:\n            if permission.codename not in existing_permissions:\n                permission.content_type = new_content_type\n                permission.save()\n\n\ndef revert_proxy_model_permissions(apps, schema_editor):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the concrete model.\n    \"\"\"\n    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n",
      "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename, name=name)\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that need to be updated\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Check for existing permissions that would cause duplicates\n        existing_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        ).values_list('codename', flat=True)\n        \n        # Filter out permissions that would create duplicates\n        safe_permissions = permissions_to_update.exclude(\n            codename__in=existing_permissions\n        )\n        \n        # Update only the safe permissions\n        safe_permissions.update(content_type=new_content_type)\n",
      "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename, name=name)\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that need to be updated\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Check for existing permissions with the new content_type that would cause conflicts\n        existing_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        ).values_list('codename', flat=True)\n        \n        # Only update permissions that won't create duplicates\n        for permission in permissions_to_update:\n            if permission.codename not in existing_permissions:\n                permission.content_type = new_content_type\n                permission.save()\n\n\ndef revert_proxy_model_permissions(apps, schema_editor):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the concrete model.\n    \"\"\"\n    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n"
    ],
    "Location 5 (/root/hy/projects_2/django/django/contrib/auth/migrations/0011_update_proxy_permissions.py lines 5-11)": [
      "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename)\n        concrete_content_type = ContentType.objects.get_for_model(\n            Model, for_concrete_model=True\n        )\n        proxy_content_type = ContentType.objects.get_for_model(\n            Model, for_concrete_model=False\n        )\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that need to be updated\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Check for existing permissions with the new content type that would cause conflicts\n        existing_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        ).values_list('codename', flat=True)\n        \n        # Only update permissions that won't create duplicates\n        safe_permissions = permissions_to_update.exclude(\n            codename__in=existing_permissions\n        )\n        \n        safe_permissions.update(content_type=new_content_type)\n",
      "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename)\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that need to be updated\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Check for existing permissions with the new content type that would cause conflicts\n        existing_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        ).values_list('codename', flat=True)\n        \n        # Only update permissions that won't create duplicates\n        safe_permissions = permissions_to_update.exclude(codename__in=existing_permissions)\n        \n        safe_permissions.update(content_type=new_content_type)\n",
      "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename)\n        concrete_content_type = ContentType.objects.get_for_model(\n            Model, for_concrete_model=True\n        )\n        proxy_content_type = ContentType.objects.get_for_model(\n            Model, for_concrete_model=False\n        )\n        old_content_type = concrete_content_type if not reverse else proxy_content_type\n        new_content_type = proxy_content_type if not reverse else concrete_content_type\n        \n        # Get permissions that need to be updated\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Check for existing permissions with target content_type to avoid duplicates\n        existing_permissions = set(\n            Permission.objects.filter(\n                permissions_query,\n                content_type=new_content_type,\n            ).values_list('codename', flat=True)\n        )\n        \n        # Only update permissions that won't create duplicates\n        safe_permissions = permissions_to_update.exclude(\n            codename__in=existing_permissions\n        )\n        \n        safe_permissions.update(content_type=new_content_type)\n",
      "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename)\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type, new_content_type = (\n            (proxy_content_type, concrete_content_type) if reverse else (concrete_content_type, proxy_content_type)\n        )\n        \n        # Get permissions that need to be updated\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Check for existing permissions that would cause conflicts\n        existing_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        ).values_list('codename', flat=True)\n        \n        # Only update permissions that won't cause duplicates\n        safe_permissions = permissions_to_update.exclude(\n            codename__in=existing_permissions\n        )\n        \n        safe_permissions.update(content_type=new_content_type)\n\n\ndef revert_proxy_model_permissions(apps, schema_editor):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the concrete model.\n    \"\"\"\n    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n",
      "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename)\n        concrete_content_type = ContentType.objects.get_for_model(\n            Model, for_concrete_model=True\n        )\n        proxy_content_type = ContentType.objects.get_for_model(\n            Model, for_concrete_model=False\n        )\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that need to be updated\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Check for existing permissions that would cause duplicates\n        existing_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        ).values_list('codename', flat=True)\n        \n        # Only update permissions that won't create duplicates\n        safe_permissions = permissions_to_update.exclude(\n            codename__in=existing_permissions\n        )\n        \n        safe_permissions.update(content_type=new_content_type)\n",
      "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename)\n        concrete_content_type = ContentType.objects.get_for_model(\n            Model, for_concrete_model=True\n        )\n        proxy_content_type = ContentType.objects.get_for_model(\n            Model, for_concrete_model=False\n        )\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that need to be updated\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Check for existing permissions with the target content type that would cause conflicts\n        existing_conflicting_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        ).values_list('codename', flat=True)\n        \n        # Only update permissions that won't create duplicates\n        safe_permissions = permissions_to_update.exclude(\n            codename__in=existing_conflicting_permissions\n        )\n        \n        # Update the safe permissions\n        safe_permissions.update(content_type=new_content_type)\n",
      "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename)\n        concrete_content_type = ContentType.objects.get_for_model(\n            Model, for_concrete_model=True\n        )\n        proxy_content_type = ContentType.objects.get_for_model(\n            Model, for_concrete_model=False\n        )\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that need to be updated\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Check for existing permissions that would cause conflicts\n        existing_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        ).values_list('codename', flat=True)\n        \n        # Only update permissions that won't create duplicates\n        safe_permissions = permissions_to_update.exclude(\n            codename__in=existing_permissions\n        )\n        \n        safe_permissions.update(content_type=new_content_type)\n",
      "\ndef update_proxy_model_permissions(apps, schema_editor, reverse=False):\n    \"\"\"\n    Update the content_type of proxy model permissions to use the ContentType\n    of the proxy model.\n    \"\"\"\n    Permission = apps.get_model('auth', 'Permission')\n    ContentType = apps.get_model('contenttypes', 'ContentType')\n    for Model in apps.get_models():\n        opts = Model._meta\n        if not opts.proxy:\n            continue\n        proxy_default_permissions_codenames = [\n            '%s_%s' % (action, opts.model_name)\n            for action in opts.default_permissions\n        ]\n        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n        for codename, name in opts.permissions:\n            permissions_query = permissions_query | Q(codename=codename)\n        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n        old_content_type = proxy_content_type if reverse else concrete_content_type\n        new_content_type = concrete_content_type if reverse else proxy_content_type\n        \n        # Get permissions that need to be updated\n        permissions_to_update = Permission.objects.filter(\n            permissions_query,\n            content_type=old_content_type,\n        )\n        \n        # Check for existing permissions with the new content type that would cause conflicts\n        existing_permissions = Permission.objects.filter(\n            permissions_query,\n            content_type=new_content_type,\n        ).values_list('codename', flat=True)\n        \n        # Only update permissions that won't create duplicates\n        permissions_to_update = permissions_to_update.exclude(\n            codename__in=existing_permissions\n        )\n        \n        permissions_to_update.update(content_type=new_content_type)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/contrib/auth/migrations/0011_update_proxy_permissions.py b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\nindex 0e66649695..58941d5de3 100644\n--- a/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n+++ b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n@@ -2,6 +2,7 @@ from django.db import migrations\n from django.db.models import Q\n \n \n+\n def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n     \"\"\"\n     Update the content_type of proxy model permissions to use the ContentType\n@@ -9,6 +10,7 @@ def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n     \"\"\"\n     Permission = apps.get_model('auth', 'Permission')\n     ContentType = apps.get_model('contenttypes', 'ContentType')\n+\n     for Model in apps.get_models():\n         opts = Model._meta\n         if not opts.proxy:\n@@ -17,6 +19,7 @@ def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n             '%s_%s' % (action, opts.model_name)\n             for action in opts.default_permissions\n         ]\n+\n         permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n         for codename, name in opts.permissions:\n             permissions_query = permissions_query | Q(codename=codename, name=name)\n@@ -24,10 +27,25 @@ def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n         proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n         old_content_type = proxy_content_type if reverse else concrete_content_type\n         new_content_type = concrete_content_type if reverse else proxy_content_type\n-        Permission.objects.filter(\n+\n+        # Check for existing permissions that would conflict with the update\n+        conflicting_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        )\n+        \n+        # Get the permissions we want to update\n+        permissions_to_update = Permission.objects.filter(\n             permissions_query,\n             content_type=old_content_type,\n-        ).update(content_type=new_content_type)\n+        )\n+        \n+        # Delete conflicting permissions to avoid duplicate key violations\n+        conflicting_permissions.delete()\n+        \n+        # Now safely update the remaining permissions\n+        permissions_to_update.update(content_type=new_content_type)\n+\n \n \n def revert_proxy_model_permissions(apps, schema_editor):\n",
    "variant_0": "diff --git a/django/contrib/auth/migrations/0011_update_proxy_permissions.py b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\nindex 0e66649695..8f51c6ceaa 100644\n--- a/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n+++ b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n@@ -2,6 +2,126 @@ from django.db import migrations\n from django.db.models import Q\n \n \n+\n+def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the proxy model.\n+    \"\"\"\n+    Permission = apps.get_model('auth', 'Permission')\n+    ContentType = apps.get_model('contenttypes', 'ContentType')\n+    for Model in apps.get_models():\n+        opts = Model._meta\n+        if not opts.proxy:\n+            continue\n+        proxy_default_permissions_codenames = [\n+            '%s_%s' % (action, opts.model_name)\n+            for action in opts.default_permissions\n+        ]\n+        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n+        for codename, name in opts.permissions:\n+            permissions_query = permissions_query | Q(codename=codename)\n+        concrete_content_type = ContentType.objects.get_for_model(\n+            Model, for_concrete_model=True\n+        )\n+        proxy_content_type = ContentType.objects.get_for_model(\n+            Model, for_concrete_model=False\n+        )\n+        \n+        if reverse:\n+            # Check for existing permissions with concrete content type before updating\n+            existing_concrete_permissions = Permission.objects.filter(\n+                permissions_query,\n+                content_type=concrete_content_type,\n+            )\n+            # Delete proxy permissions that would conflict\n+            Permission.objects.filter(\n+                permissions_query,\n+                content_type=proxy_content_type,\n+            ).exclude(\n+                codename__in=existing_concrete_permissions.values_list('codename', flat=True)\n+            ).delete()\n+            # Update remaining proxy permissions to concrete\n+            Permission.objects.filter(\n+                permissions_query,\n+                content_type=proxy_content_type,\n+            ).update(content_type=concrete_content_type)\n+        else:\n+            # Check for existing permissions with proxy content type before updating\n+            existing_proxy_permissions = Permission.objects.filter(\n+                permissions_query,\n+                content_type=proxy_content_type,\n+            )\n+            # Delete concrete permissions that would conflict\n+            Permission.objects.filter(\n+                permissions_query,\n+                content_type=concrete_content_type,\n+            ).exclude(\n+                codename__in=existing_proxy_permissions.values_list('codename', flat=True)\n+            ).delete()\n+            # Update remaining concrete permissions to proxy\n+            Permission.objects.filter(\n+                permissions_query,\n+                content_type=concrete_content_type,\n+            ).update(content_type=proxy_content_type)\n+\n+\n+def revert_proxy_model_permissions(apps, schema_editor):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the concrete model.\n+    \"\"\"\n+    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n+\n+def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the proxy model.\n+    \"\"\"\n+    Permission = apps.get_model('auth', 'Permission')\n+    ContentType = apps.get_model('contenttypes', 'ContentType')\n+    for Model in apps.get_models():\n+        opts = Model._meta\n+        if not opts.proxy:\n+            continue\n+        proxy_default_permissions_codenames = [\n+            '%s_%s' % (action, opts.model_name)\n+            for action in opts.default_permissions\n+        ]\n+        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n+        for codename, name in opts.permissions:\n+            permissions_query = permissions_query | Q(codename=codename, name=name)\n+        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n+        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n+        old_content_type = proxy_content_type if reverse else concrete_content_type\n+        new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions that need to be updated\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Check for existing permissions with the new content type that would cause duplicates\n+        existing_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        ).values_list('codename', flat=True)\n+        \n+        # Only update permissions that won't create duplicates\n+        for permission in permissions_to_update:\n+            if permission.codename not in existing_permissions:\n+                permission.content_type = new_content_type\n+                permission.save()\n+\n+\n+def revert_proxy_model_permissions(apps, schema_editor):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the concrete model.\n+    \"\"\"\n+    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n+\n def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n     \"\"\"\n     Update the content_type of proxy model permissions to use the ContentType\n@@ -24,6 +144,64 @@ def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n         proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n         old_content_type = proxy_content_type if reverse else concrete_content_type\n         new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions that need to be updated\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Check for existing permissions with the new content type that would cause duplicates\n+        existing_codenames = set(\n+            Permission.objects.filter(\n+                permissions_query,\n+                content_type=new_content_type,\n+            ).values_list('codename', flat=True)\n+        )\n+        \n+        # Only update permissions that won't create duplicates\n+        for permission in permissions_to_update:\n+            if permission.codename not in existing_codenames:\n+                permission.content_type = new_content_type\n+                permission.save()\n+\n+\n+def revert_proxy_model_permissions(apps, schema_editor):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the concrete model.\n+    \"\"\"\n+    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n+\n+def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the proxy model.\n+    \"\"\"\n+    Permission = apps.get_model('auth', 'Permission')\n+    ContentType = apps.get_model('contenttypes', 'ContentType')\n+    for Model in apps.get_models():\n+        opts = Model._meta\n+        if not opts.proxy:\n+            continue\n+        proxy_default_permissions_codenames = [\n+            '%s_%s' % (action, opts.model_name)\n+            for action in opts.default_permissions\n+        ]\n+        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n+        for codename, name in opts.permissions:\n+            permissions_query = permissions_query | Q(codename=codename, name=name)\n+        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n+        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n+        old_content_type = proxy_content_type if reverse else concrete_content_type\n+        new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Delete any existing permissions with the new content type to avoid duplicates\n+        Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        ).delete()\n+        \n         Permission.objects.filter(\n             permissions_query,\n             content_type=old_content_type,\n@@ -38,6 +216,61 @@ def revert_proxy_model_permissions(apps, schema_editor):\n     update_proxy_model_permissions(apps, schema_editor, reverse=True)\n \n \n+\n+def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the proxy model.\n+    \"\"\"\n+    style = color_style()\n+    Permission = apps.get_model('auth', 'Permission')\n+    ContentType = apps.get_model('contenttypes', 'ContentType')\n+    for Model in apps.get_models():\n+        opts = Model._meta\n+        if not opts.proxy:\n+            continue\n+        proxy_default_permissions_codenames = [\n+            '%s_%s' % (action, opts.model_name)\n+            for action in opts.default_permissions\n+        ]\n+        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n+        for codename, name in opts.permissions:\n+            permissions_query = permissions_query | Q(codename=codename, name=name)\n+        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n+        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n+        old_content_type = proxy_content_type if reverse else concrete_content_type\n+        new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions to update\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Check for existing permissions that would create duplicates\n+        for permission in permissions_to_update:\n+            existing_permission = Permission.objects.filter(\n+                codename=permission.codename,\n+                content_type=new_content_type,\n+            ).first()\n+            \n+            if existing_permission:\n+                # Delete the old permission to avoid duplicate key violation\n+                permission.delete()\n+            else:\n+                # Safe to update\n+                permission.content_type = new_content_type\n+                permission.save()\n+\n+\n+def revert_proxy_model_permissions(apps, schema_editor):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the concrete model.\n+    \"\"\"\n+    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n+\n+\n class Migration(migrations.Migration):\n     dependencies = [\n         ('auth', '0010_alter_group_name_max_length'),\n",
    "variant_1": "diff --git a/django/contrib/auth/migrations/0011_update_proxy_permissions.py b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\nindex 0e66649695..ea7848a688 100644\n--- a/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n+++ b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n@@ -2,11 +2,196 @@ from django.db import migrations\n from django.db.models import Q\n \n \n+\n+def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the proxy model.\n+    \"\"\"\n+    Permission = apps.get_model('auth', 'Permission')\n+    ContentType = apps.get_model('contenttypes', 'ContentType')\n+    for Model in apps.get_models():\n+        opts = Model._meta\n+        if not opts.proxy:\n+            continue\n+        proxy_default_permissions_codenames = [\n+            '%s_%s' % (action, opts.model_name)\n+            for action in opts.default_permissions\n+        ]\n+        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n+        for codename, name in opts.permissions:\n+            permissions_query = permissions_query | Q(codename=codename)\n+        concrete_content_type = ContentType.objects.get_for_model(\n+            Model, for_concrete_model=True\n+        )\n+        proxy_content_type = ContentType.objects.get_for_model(\n+            Model, for_concrete_model=False\n+        )\n+        old_content_type = proxy_content_type if reverse else concrete_content_type\n+        new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions that need to be updated\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Check for existing permissions with the new content type that would cause conflicts\n+        existing_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        ).values_list('codename', flat=True)\n+        \n+        # Only update permissions that won't create duplicates\n+        safe_permissions = permissions_to_update.exclude(\n+            codename__in=existing_permissions\n+        )\n+        \n+        safe_permissions.update(content_type=new_content_type)\n+\n+def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the proxy model.\n+    \"\"\"\n+    Permission = apps.get_model('auth', 'Permission')\n+    ContentType = apps.get_model('contenttypes', 'ContentType')\n+    for Model in apps.get_models():\n+        opts = Model._meta\n+        if not opts.proxy:\n+            continue\n+        proxy_default_permissions_codenames = [\n+            '%s_%s' % (action, opts.model_name)\n+            for action in opts.default_permissions\n+        ]\n+        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n+        for codename, name in opts.permissions:\n+            permissions_query = permissions_query | Q(codename=codename, name=name)\n+        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n+        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n+        old_content_type = proxy_content_type if reverse else concrete_content_type\n+        new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions that need to be updated\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Check for existing permissions with the new content type to avoid duplicates\n+        existing_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        ).values_list('codename', flat=True)\n+        \n+        # Only update permissions that won't create duplicates\n+        for permission in permissions_to_update:\n+            if permission.codename not in existing_permissions:\n+                permission.content_type = new_content_type\n+                permission.save()\n+\n+\n+def revert_proxy_model_permissions(apps, schema_editor, **kwargs):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the concrete model.\n+    \"\"\"\n+    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n+\n+def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the proxy model.\n+    \"\"\"\n+    Permission = apps.get_model('auth', 'Permission')\n+    ContentType = apps.get_model('contenttypes', 'ContentType')\n+    for Model in apps.get_models():\n+        opts = Model._meta\n+        if not opts.proxy:\n+            continue\n+        proxy_default_permissions_codenames = [\n+            '%s_%s' % (action, opts.model_name)\n+            for action in opts.default_permissions\n+        ]\n+        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n+        for codename, name in opts.permissions:\n+            permissions_query = permissions_query | Q(codename=codename, name=name)\n+        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n+        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n+        old_content_type = proxy_content_type if reverse else concrete_content_type\n+        new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions that would be updated\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Check for existing permissions with the new content type that would cause duplicates\n+        existing_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        ).values_list('codename', flat=True)\n+        \n+        # Only update permissions that won't create duplicates\n+        for permission in permissions_to_update:\n+            if permission.codename not in existing_permissions:\n+                permission.content_type = new_content_type\n+                permission.save()\n+\n+\n+def revert_proxy_model_permissions(apps, schema_editor):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the concrete model.\n+    \"\"\"\n+    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n+\n+def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the proxy model.\n+    \"\"\"\n+    Permission = apps.get_model('auth', 'Permission')\n+    ContentType = apps.get_model('contenttypes', 'ContentType')\n+    for Model in apps.get_models():\n+        opts = Model._meta\n+        if not opts.proxy:\n+            continue\n+        proxy_default_permissions_codenames = [\n+            '%s_%s' % (action, opts.model_name)\n+            for action in opts.default_permissions\n+        ]\n+        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n+        for codename, name in opts.permissions:\n+            permissions_query = permissions_query | Q(codename=codename, name=name)\n+        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n+        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n+        old_content_type = proxy_content_type if reverse else concrete_content_type\n+        new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions that would cause duplicates after update\n+        existing_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        ).values_list('codename', flat=True)\n+        \n+        # Only update permissions that won't cause duplicates\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        ).exclude(codename__in=existing_permissions)\n+        \n+        permissions_to_update.update(content_type=new_content_type)\n+\n+\n+\n def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n     \"\"\"\n     Update the content_type of proxy model permissions to use the ContentType\n     of the proxy model.\n     \"\"\"\n+    style = color_style()\n     Permission = apps.get_model('auth', 'Permission')\n     ContentType = apps.get_model('contenttypes', 'ContentType')\n     for Model in apps.get_models():\n@@ -24,10 +209,27 @@ def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n         proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n         old_content_type = proxy_content_type if reverse else concrete_content_type\n         new_content_type = concrete_content_type if reverse else proxy_content_type\n-        Permission.objects.filter(\n+        \n+        # Get permissions that need to be updated\n+        permissions_to_update = Permission.objects.filter(\n             permissions_query,\n             content_type=old_content_type,\n-        ).update(content_type=new_content_type)\n+        )\n+        \n+        # Check for existing permissions with the target content_type that would cause duplicates\n+        existing_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        ).values_list('codename', flat=True)\n+        \n+        # Only update permissions that won't create duplicates\n+        for permission in permissions_to_update:\n+            if permission.codename not in existing_permissions:\n+                permission.content_type = new_content_type\n+                permission.save()\n+            else:\n+                # Delete the old permission since we already have the new one\n+                permission.delete()\n \n \n def revert_proxy_model_permissions(apps, schema_editor):\n",
    "variant_2": "diff --git a/django/contrib/auth/migrations/0011_update_proxy_permissions.py b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\nindex 0e66649695..290830e1c6 100644\n--- a/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n+++ b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n@@ -2,6 +2,96 @@ from django.db import migrations\n from django.db.models import Q\n \n \n+\n+def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the proxy model.\n+    \"\"\"\n+    Permission = apps.get_model('auth', 'Permission')\n+    ContentType = apps.get_model('contenttypes', 'ContentType')\n+    for Model in apps.get_models():\n+        opts = Model._meta\n+        if not opts.proxy:\n+            continue\n+        proxy_default_permissions_codenames = [\n+            '%s_%s' % (action, opts.model_name)\n+            for action in opts.default_permissions\n+        ]\n+        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n+        for codename, name in opts.permissions:\n+            permissions_query = permissions_query | Q(codename=codename)\n+        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n+        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n+        old_content_type = proxy_content_type if reverse else concrete_content_type\n+        new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions that need to be updated\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Check for existing permissions with the new content type that would cause conflicts\n+        existing_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        ).values_list('codename', flat=True)\n+        \n+        # Only update permissions that won't create duplicates\n+        safe_permissions = permissions_to_update.exclude(codename__in=existing_permissions)\n+        \n+        safe_permissions.update(content_type=new_content_type)\n+\n+def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the proxy model.\n+    \"\"\"\n+    Permission = apps.get_model('auth', 'Permission')\n+    ContentType = apps.get_model('contenttypes', 'ContentType')\n+    for Model in apps.get_models():\n+        opts = Model._meta\n+        if not opts.proxy:\n+            continue\n+        proxy_default_permissions_codenames = [\n+            '%s_%s' % (action, opts.model_name)\n+            for action in opts.default_permissions\n+        ]\n+        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n+        for codename, name in opts.permissions:\n+            permissions_query = permissions_query | Q(codename=codename, name=name)\n+        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n+        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n+        old_content_type = proxy_content_type if reverse else concrete_content_type\n+        new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions that need to be updated\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Check for existing permissions with the new content type that would cause duplicates\n+        existing_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        ).values_list('codename', flat=True)\n+        \n+        # Filter out permissions that would create duplicates\n+        safe_permissions = permissions_to_update.exclude(codename__in=existing_permissions)\n+        \n+        # Update only the safe permissions\n+        safe_permissions.update(content_type=new_content_type)\n+\n+\n+def revert_proxy_model_permissions(apps, schema_editor):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the concrete model.\n+    \"\"\"\n+    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n+\n def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n     \"\"\"\n     Update the content_type of proxy model permissions to use the ContentType\n@@ -24,10 +114,129 @@ def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n         proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n         old_content_type = proxy_content_type if reverse else concrete_content_type\n         new_content_type = concrete_content_type if reverse else proxy_content_type\n-        Permission.objects.filter(\n+        \n+        # Get permissions that need to be updated\n+        permissions_to_update = Permission.objects.filter(\n             permissions_query,\n             content_type=old_content_type,\n-        ).update(content_type=new_content_type)\n+        )\n+        \n+        # Check for existing permissions that would cause duplicates\n+        existing_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        ).values_list('codename', flat=True)\n+        \n+        # Only update permissions that won't create duplicates\n+        for permission in permissions_to_update:\n+            if permission.codename not in existing_permissions:\n+                permission.content_type = new_content_type\n+                permission.save()\n+\n+def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the proxy model.\n+    \"\"\"\n+    Permission = apps.get_model('auth', 'Permission')\n+    ContentType = apps.get_model('contenttypes', 'ContentType')\n+    for Model in apps.get_models():\n+        opts = Model._meta\n+        if not opts.proxy:\n+            continue\n+        proxy_default_permissions_codenames = [\n+            '%s_%s' % (action, opts.model_name)\n+            for action in opts.default_permissions\n+        ]\n+        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n+        for codename, name in opts.permissions:\n+            permissions_query = permissions_query | Q(codename=codename, name=name)\n+        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n+        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n+        old_content_type = proxy_content_type if reverse else concrete_content_type\n+        new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions to update\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Check for existing permissions with new content type to avoid duplicates\n+        existing_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        ).values_list('codename', flat=True)\n+        \n+        # Only update permissions that won't create duplicates\n+        for permission in permissions_to_update:\n+            if permission.codename not in existing_permissions:\n+                permission.content_type = new_content_type\n+                permission.save()\n+            else:\n+                # Delete the old permission since we already have one with the new content type\n+                permission.delete()\n+\n+\n+def revert_proxy_model_permissions(apps, schema_editor):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the concrete model.\n+    \"\"\"\n+    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n+\n+\n+\n+def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the proxy model.\n+    \"\"\"\n+    Permission = apps.get_model('auth', 'Permission')\n+    ContentType = apps.get_model('contenttypes', 'ContentType')\n+    \n+    for Model in apps.get_models():\n+        opts = Model._meta\n+        if not opts.proxy:\n+            continue\n+        proxy_default_permissions_codenames = [\n+            '%s_%s' % (action, opts.model_name)\n+            for action in opts.default_permissions\n+        ]\n+        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n+        for codename, name in opts.permissions:\n+            permissions_query = permissions_query | Q(codename=codename, name=name)\n+        \n+        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n+        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n+        old_content_type = proxy_content_type if reverse else concrete_content_type\n+        new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions that need to be updated\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Check for existing permissions that would cause duplicates\n+        existing_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        ).values_list('codename', flat=True)\n+        \n+        # Only update permissions that won't create duplicates\n+        safe_permissions = permissions_to_update.exclude(\n+            codename__in=existing_permissions\n+        )\n+        \n+        # Delete duplicate permissions from old content type if they exist in new content type\n+        if existing_permissions:\n+            permissions_to_update.filter(\n+                codename__in=existing_permissions\n+            ).delete()\n+        \n+        # Update the remaining permissions\n+        safe_permissions.update(content_type=new_content_type)\n \n \n def revert_proxy_model_permissions(apps, schema_editor):\n",
    "variant_3": "diff --git a/django/contrib/auth/migrations/0011_update_proxy_permissions.py b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\nindex 0e66649695..9fc91a277b 100644\n--- a/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n+++ b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n@@ -2,11 +2,167 @@ from django.db import migrations\n from django.db.models import Q\n \n \n+\n+def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the proxy model.\n+    \"\"\"\n+    Permission = apps.get_model('auth', 'Permission')\n+    ContentType = apps.get_model('contenttypes', 'ContentType')\n+    for Model in apps.get_models():\n+        opts = Model._meta\n+        if not opts.proxy:\n+            continue\n+        proxy_default_permissions_codenames = [\n+            '%s_%s' % (action, opts.model_name)\n+            for action in opts.default_permissions\n+        ]\n+        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n+        for codename, name in opts.permissions:\n+            permissions_query = permissions_query | Q(codename=codename)\n+        concrete_content_type = ContentType.objects.get_for_model(\n+            Model, for_concrete_model=True\n+        )\n+        proxy_content_type = ContentType.objects.get_for_model(\n+            Model, for_concrete_model=False\n+        )\n+        old_content_type = concrete_content_type if not reverse else proxy_content_type\n+        new_content_type = proxy_content_type if not reverse else concrete_content_type\n+        \n+        # Get permissions that need to be updated\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Check for existing permissions with target content_type to avoid duplicates\n+        existing_permissions = set(\n+            Permission.objects.filter(\n+                permissions_query,\n+                content_type=new_content_type,\n+            ).values_list('codename', flat=True)\n+        )\n+        \n+        # Only update permissions that won't create duplicates\n+        safe_permissions = permissions_to_update.exclude(\n+            codename__in=existing_permissions\n+        )\n+        \n+        safe_permissions.update(content_type=new_content_type)\n+\n+def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the proxy model.\n+    \"\"\"\n+    Permission = apps.get_model('auth', 'Permission')\n+    ContentType = apps.get_model('contenttypes', 'ContentType')\n+    for Model in apps.get_models():\n+        opts = Model._meta\n+        if not opts.proxy:\n+            continue\n+        proxy_default_permissions_codenames = [\n+            '%s_%s' % (action, opts.model_name)\n+            for action in opts.default_permissions\n+        ]\n+        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n+        for codename, name in opts.permissions:\n+            permissions_query = permissions_query | Q(codename=codename, name=name)\n+        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n+        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n+        old_content_type = proxy_content_type if reverse else concrete_content_type\n+        new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions that need to be updated\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Check for existing permissions with the new content type to avoid duplicates\n+        existing_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        ).values_list('codename', flat=True)\n+        \n+        # Only update permissions that won't create duplicates\n+        permissions_to_update = permissions_to_update.exclude(\n+            codename__in=existing_permissions\n+        )\n+        \n+        permissions_to_update.update(content_type=new_content_type)\n+\n+\n+def revert_proxy_model_permissions(apps, schema_editor):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the concrete model.\n+    \"\"\"\n+    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n+\n+def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the proxy model.\n+    \"\"\"\n+    Permission = apps.get_model('auth', 'Permission')\n+    ContentType = apps.get_model('contenttypes', 'ContentType')\n+    for Model in apps.get_models():\n+        opts = Model._meta\n+        if not opts.proxy:\n+            continue\n+        proxy_default_permissions_codenames = [\n+            '%s_%s' % (action, opts.model_name)\n+            for action in opts.default_permissions\n+        ]\n+        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n+        for codename, name in opts.permissions:\n+            permissions_query = permissions_query | Q(codename=codename, name=name)\n+        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n+        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n+        old_content_type = proxy_content_type if reverse else concrete_content_type\n+        new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions to update\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Check for existing permissions with the new content type\n+        existing_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        ).values_list('codename', flat=True)\n+        \n+        # Filter out permissions that would create duplicates\n+        safe_permissions = permissions_to_update.exclude(\n+            codename__in=existing_permissions\n+        )\n+        \n+        # Update only the safe permissions\n+        safe_permissions.update(content_type=new_content_type)\n+        \n+        # Delete the remaining old permissions that would cause duplicates\n+        permissions_to_update.filter(\n+            codename__in=existing_permissions\n+        ).delete()\n+\n+\n+def revert_proxy_model_permissions(apps, schema_editor):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the concrete model.\n+    \"\"\"\n+    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n+\n def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n     \"\"\"\n     Update the content_type of proxy model permissions to use the ContentType\n     of the proxy model.\n     \"\"\"\n+    style = color_style()\n     Permission = apps.get_model('auth', 'Permission')\n     ContentType = apps.get_model('contenttypes', 'ContentType')\n     for Model in apps.get_models():\n@@ -24,10 +180,68 @@ def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n         proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n         old_content_type = proxy_content_type if reverse else concrete_content_type\n         new_content_type = concrete_content_type if reverse else proxy_content_type\n-        Permission.objects.filter(\n+        \n+        # Get permissions that need to be updated\n+        permissions_to_update = Permission.objects.filter(\n             permissions_query,\n             content_type=old_content_type,\n-        ).update(content_type=new_content_type)\n+        )\n+        \n+        # Check for existing permissions with the new content type that would cause duplicates\n+        existing_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        ).values_list('codename', flat=True)\n+        \n+        # Only update permissions that won't create duplicates\n+        for permission in permissions_to_update:\n+            if permission.codename not in existing_permissions:\n+                permission.content_type = new_content_type\n+                permission.save()\n+\n+\n+\n+def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the proxy model.\n+    \"\"\"\n+    style = color_style()\n+    Permission = apps.get_model('auth', 'Permission')\n+    ContentType = apps.get_model('contenttypes', 'ContentType')\n+    for Model in apps.get_models():\n+        opts = Model._meta\n+        if not opts.proxy:\n+            continue\n+        proxy_default_permissions_codenames = [\n+            '%s_%s' % (action, opts.model_name)\n+            for action in opts.default_permissions\n+        ]\n+        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n+        for codename, name in opts.permissions:\n+            permissions_query = permissions_query | Q(codename=codename, name=name)\n+        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n+        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n+        old_content_type = proxy_content_type if reverse else concrete_content_type\n+        new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions that need to be updated\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Check for existing permissions with the new content type that would cause duplicates\n+        existing_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        ).values_list('codename', flat=True)\n+        \n+        # Only update permissions that won't create duplicates\n+        for permission in permissions_to_update:\n+            if permission.codename not in existing_permissions:\n+                permission.content_type = new_content_type\n+                permission.save()\n \n \n def revert_proxy_model_permissions(apps, schema_editor):\n",
    "variant_4": "diff --git a/django/contrib/auth/migrations/0011_update_proxy_permissions.py b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\nindex 0e66649695..a801d65db3 100644\n--- a/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n+++ b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n@@ -2,6 +2,58 @@ from django.db import migrations\n from django.db.models import Q\n \n \n+\n+def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the proxy model.\n+    \"\"\"\n+    Permission = apps.get_model('auth', 'Permission')\n+    ContentType = apps.get_model('contenttypes', 'ContentType')\n+    for Model in apps.get_models():\n+        opts = Model._meta\n+        if not opts.proxy:\n+            continue\n+        proxy_default_permissions_codenames = [\n+            '%s_%s' % (action, opts.model_name)\n+            for action in opts.default_permissions\n+        ]\n+        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n+        for codename, name in opts.permissions:\n+            permissions_query = permissions_query | Q(codename=codename)\n+        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n+        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n+        old_content_type, new_content_type = (\n+            (proxy_content_type, concrete_content_type) if reverse else (concrete_content_type, proxy_content_type)\n+        )\n+        \n+        # Get permissions that need to be updated\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Check for existing permissions that would cause conflicts\n+        existing_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        ).values_list('codename', flat=True)\n+        \n+        # Only update permissions that won't cause duplicates\n+        safe_permissions = permissions_to_update.exclude(\n+            codename__in=existing_permissions\n+        )\n+        \n+        safe_permissions.update(content_type=new_content_type)\n+\n+\n+def revert_proxy_model_permissions(apps, schema_editor):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the concrete model.\n+    \"\"\"\n+    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n+\n def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n     \"\"\"\n     Update the content_type of proxy model permissions to use the ContentType\n@@ -24,10 +76,172 @@ def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n         proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n         old_content_type = proxy_content_type if reverse else concrete_content_type\n         new_content_type = concrete_content_type if reverse else proxy_content_type\n-        Permission.objects.filter(\n+        \n+        # Get permissions that need to be updated\n+        permissions_to_update = Permission.objects.filter(\n             permissions_query,\n             content_type=old_content_type,\n-        ).update(content_type=new_content_type)\n+        )\n+        \n+        # Check for existing permissions with the new content type that would cause conflicts\n+        existing_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        ).values_list('codename', flat=True)\n+        \n+        # Filter out permissions that would create duplicates\n+        safe_permissions = permissions_to_update.exclude(codename__in=existing_permissions)\n+        \n+        # Update only the safe permissions\n+        safe_permissions.update(content_type=new_content_type)\n+\n+\n+def revert_proxy_model_permissions(apps, schema_editor):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the concrete model.\n+    \"\"\"\n+    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n+\n+def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the proxy model.\n+    \"\"\"\n+    Permission = apps.get_model('auth', 'Permission')\n+    ContentType = apps.get_model('contenttypes', 'ContentType')\n+    for Model in apps.get_models():\n+        opts = Model._meta\n+        if not opts.proxy:\n+            continue\n+        proxy_default_permissions_codenames = [\n+            '%s_%s' % (action, opts.model_name)\n+            for action in opts.default_permissions\n+        ]\n+        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n+        for codename, name in opts.permissions:\n+            permissions_query = permissions_query | Q(codename=codename, name=name)\n+        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n+        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n+        old_content_type = proxy_content_type if reverse else concrete_content_type\n+        new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions that need to be updated\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Check for existing permissions that would cause conflicts\n+        existing_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        ).values_list('codename', flat=True)\n+        \n+        # Filter out permissions that would create duplicates\n+        safe_permissions = permissions_to_update.exclude(\n+            codename__in=existing_permissions\n+        )\n+        \n+        # Update only the safe permissions\n+        safe_permissions.update(content_type=new_content_type)\n+\n+\n+def revert_proxy_model_permissions(apps, schema_editor):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the concrete model.\n+    \"\"\"\n+    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n+\n+def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the proxy model.\n+    \"\"\"\n+    Permission = apps.get_model('auth', 'Permission')\n+    ContentType = apps.get_model('contenttypes', 'ContentType')\n+    for Model in apps.get_models():\n+        opts = Model._meta\n+        if not opts.proxy:\n+            continue\n+        proxy_default_permissions_codenames = [\n+            '%s_%s' % (action, opts.model_name)\n+            for action in opts.default_permissions\n+        ]\n+        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n+        for codename, name in opts.permissions:\n+            permissions_query = permissions_query | Q(codename=codename, name=name)\n+        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n+        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n+        old_content_type = proxy_content_type if reverse else concrete_content_type\n+        new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions that need to be updated\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Check for existing permissions with the new content_type that would cause conflicts\n+        existing_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        ).values_list('codename', flat=True)\n+        \n+        # Only update permissions that won't create duplicates\n+        for permission in permissions_to_update:\n+            if permission.codename not in existing_permissions:\n+                permission.content_type = new_content_type\n+                permission.save()\n+\n+\n+\n+def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the proxy model.\n+    \"\"\"\n+    style = color_style()\n+    Permission = apps.get_model('auth', 'Permission')\n+    ContentType = apps.get_model('contenttypes', 'ContentType')\n+    for Model in apps.get_models():\n+        opts = Model._meta\n+        if not opts.proxy:\n+            continue\n+        proxy_default_permissions_codenames = [\n+            '%s_%s' % (action, opts.model_name)\n+            for action in opts.default_permissions\n+        ]\n+        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n+        for codename, name in opts.permissions:\n+            permissions_query = permissions_query | Q(codename=codename, name=name)\n+        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n+        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n+        old_content_type = proxy_content_type if reverse else concrete_content_type\n+        new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions that need to be updated\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Check for existing permissions with the new content_type that would create duplicates\n+        existing_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        ).values_list('codename', flat=True)\n+        \n+        # Filter out permissions that would create duplicates\n+        safe_permissions = permissions_to_update.exclude(codename__in=existing_permissions)\n+        \n+        # Update only the safe permissions\n+        safe_permissions.update(content_type=new_content_type)\n+        \n+        # Delete conflicting permissions from old content_type if any remain\n+        conflicting_permissions = permissions_to_update.filter(codename__in=existing_permissions)\n+        conflicting_permissions.delete()\n \n \n def revert_proxy_model_permissions(apps, schema_editor):\n",
    "variant_5": "diff --git a/django/contrib/auth/migrations/0011_update_proxy_permissions.py b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\nindex 0e66649695..0011271058 100644\n--- a/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n+++ b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n@@ -2,6 +2,53 @@ from django.db import migrations\n from django.db.models import Q\n \n \n+\n+def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the proxy model.\n+    \"\"\"\n+    Permission = apps.get_model('auth', 'Permission')\n+    ContentType = apps.get_model('contenttypes', 'ContentType')\n+    for Model in apps.get_models():\n+        opts = Model._meta\n+        if not opts.proxy:\n+            continue\n+        proxy_default_permissions_codenames = [\n+            '%s_%s' % (action, opts.model_name)\n+            for action in opts.default_permissions\n+        ]\n+        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n+        for codename, name in opts.permissions:\n+            permissions_query = permissions_query | Q(codename=codename)\n+        concrete_content_type = ContentType.objects.get_for_model(\n+            Model, for_concrete_model=True\n+        )\n+        proxy_content_type = ContentType.objects.get_for_model(\n+            Model, for_concrete_model=False\n+        )\n+        old_content_type = proxy_content_type if reverse else concrete_content_type\n+        new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions that need to be updated\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Check for existing permissions that would cause duplicates\n+        existing_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        ).values_list('codename', flat=True)\n+        \n+        # Only update permissions that won't create duplicates\n+        safe_permissions = permissions_to_update.exclude(\n+            codename__in=existing_permissions\n+        )\n+        \n+        safe_permissions.update(content_type=new_content_type)\n+\n def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n     \"\"\"\n     Update the content_type of proxy model permissions to use the ContentType\n@@ -24,10 +71,169 @@ def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n         proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n         old_content_type = proxy_content_type if reverse else concrete_content_type\n         new_content_type = concrete_content_type if reverse else proxy_content_type\n-        Permission.objects.filter(\n+        \n+        # Get permissions that need to be updated\n+        permissions_to_update = Permission.objects.filter(\n             permissions_query,\n             content_type=old_content_type,\n-        ).update(content_type=new_content_type)\n+        )\n+        \n+        # Check for existing permissions with the new content type that would cause conflicts\n+        existing_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        ).values_list('codename', flat=True)\n+        \n+        # Only update permissions that won't create duplicates\n+        for permission in permissions_to_update:\n+            if permission.codename not in existing_permissions:\n+                permission.content_type = new_content_type\n+                permission.save()\n+\n+\n+def revert_proxy_model_permissions(apps, schema_editor):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the concrete model.\n+    \"\"\"\n+    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n+\n+def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the proxy model.\n+    \"\"\"\n+    Permission = apps.get_model('auth', 'Permission')\n+    ContentType = apps.get_model('contenttypes', 'ContentType')\n+    for Model in apps.get_models():\n+        opts = Model._meta\n+        if not opts.proxy:\n+            continue\n+        proxy_default_permissions_codenames = [\n+            '%s_%s' % (action, opts.model_name)\n+            for action in opts.default_permissions\n+        ]\n+        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n+        for codename, name in opts.permissions:\n+            permissions_query = permissions_query | Q(codename=codename, name=name)\n+        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n+        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n+        old_content_type = proxy_content_type if reverse else concrete_content_type\n+        new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions to update\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Check for existing permissions that would cause duplicates\n+        existing_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        ).values_list('codename', flat=True)\n+        \n+        # Update permissions that won't cause duplicates\n+        for permission in permissions_to_update:\n+            if permission.codename not in existing_permissions:\n+                permission.content_type = new_content_type\n+                permission.save()\n+            else:\n+                # Delete the old permission since the new one already exists\n+                permission.delete()\n+\n+\n+def revert_proxy_model_permissions(apps, schema_editor):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the concrete model.\n+    \"\"\"\n+    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n+\n+def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the proxy model.\n+    \"\"\"\n+    Permission = apps.get_model('auth', 'Permission')\n+    ContentType = apps.get_model('contenttypes', 'ContentType')\n+    for Model in apps.get_models():\n+        opts = Model._meta\n+        if not opts.proxy:\n+            continue\n+        proxy_default_permissions_codenames = [\n+            '%s_%s' % (action, opts.model_name)\n+            for action in opts.default_permissions\n+        ]\n+        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n+        for codename, name in opts.permissions:\n+            permissions_query = permissions_query | Q(codename=codename, name=name)\n+        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n+        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n+        old_content_type = proxy_content_type if reverse else concrete_content_type\n+        new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions that need to be updated\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Check for existing permissions with the new content_type that would cause duplicates\n+        existing_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        ).values_list('codename', flat=True)\n+        \n+        # Only update permissions that won't create duplicates\n+        for permission in permissions_to_update:\n+            if permission.codename not in existing_permissions:\n+                permission.content_type = new_content_type\n+                permission.save()\n+\n+\n+\n+def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the proxy model.\n+    \"\"\"\n+    style = color_style()\n+    Permission = apps.get_model('auth', 'Permission')\n+    ContentType = apps.get_model('contenttypes', 'ContentType')\n+    for Model in apps.get_models():\n+        opts = Model._meta\n+        if not opts.proxy:\n+            continue\n+        proxy_default_permissions_codenames = [\n+            '%s_%s' % (action, opts.model_name)\n+            for action in opts.default_permissions\n+        ]\n+        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n+        for codename, name in opts.permissions:\n+            permissions_query = permissions_query | Q(codename=codename, name=name)\n+        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n+        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n+        old_content_type = proxy_content_type if reverse else concrete_content_type\n+        new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions that need to be updated\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Check for existing permissions with the new content_type that would cause duplicates\n+        existing_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        ).values_list('codename', flat=True)\n+        \n+        # Only update permissions that won't create duplicates\n+        permissions_to_update = permissions_to_update.exclude(codename__in=existing_permissions)\n+        \n+        # Update the remaining permissions\n+        permissions_to_update.update(content_type=new_content_type)\n \n \n def revert_proxy_model_permissions(apps, schema_editor):\n",
    "variant_6": "diff --git a/django/contrib/auth/migrations/0011_update_proxy_permissions.py b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\nindex 0e66649695..ec00f60769 100644\n--- a/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n+++ b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n@@ -2,6 +2,54 @@ from django.db import migrations\n from django.db.models import Q\n \n \n+\n+def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the proxy model.\n+    \"\"\"\n+    Permission = apps.get_model('auth', 'Permission')\n+    ContentType = apps.get_model('contenttypes', 'ContentType')\n+    for Model in apps.get_models():\n+        opts = Model._meta\n+        if not opts.proxy:\n+            continue\n+        proxy_default_permissions_codenames = [\n+            '%s_%s' % (action, opts.model_name)\n+            for action in opts.default_permissions\n+        ]\n+        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n+        for codename, name in opts.permissions:\n+            permissions_query = permissions_query | Q(codename=codename)\n+        concrete_content_type = ContentType.objects.get_for_model(\n+            Model, for_concrete_model=True\n+        )\n+        proxy_content_type = ContentType.objects.get_for_model(\n+            Model, for_concrete_model=False\n+        )\n+        old_content_type = proxy_content_type if reverse else concrete_content_type\n+        new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions that need to be updated\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Check for existing permissions with the target content type that would cause conflicts\n+        existing_conflicting_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        ).values_list('codename', flat=True)\n+        \n+        # Only update permissions that won't create duplicates\n+        safe_permissions = permissions_to_update.exclude(\n+            codename__in=existing_conflicting_permissions\n+        )\n+        \n+        # Update the safe permissions\n+        safe_permissions.update(content_type=new_content_type)\n+\n def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n     \"\"\"\n     Update the content_type of proxy model permissions to use the ContentType\n@@ -24,10 +72,166 @@ def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n         proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n         old_content_type = proxy_content_type if reverse else concrete_content_type\n         new_content_type = concrete_content_type if reverse else proxy_content_type\n-        Permission.objects.filter(\n+        \n+        # Get permissions that need to be updated\n+        permissions_to_update = Permission.objects.filter(\n             permissions_query,\n             content_type=old_content_type,\n-        ).update(content_type=new_content_type)\n+        )\n+        \n+        # Check for existing permissions with new content type that would cause duplicates\n+        existing_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        ).values_list('codename', flat=True)\n+        \n+        # Only update permissions that won't create duplicates\n+        for permission in permissions_to_update:\n+            if permission.codename not in existing_permissions:\n+                permission.content_type = new_content_type\n+                permission.save()\n+\n+\n+def revert_proxy_model_permissions(apps, schema_editor):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the concrete model.\n+    \"\"\"\n+    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n+\n+def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the proxy model.\n+    \"\"\"\n+    Permission = apps.get_model('auth', 'Permission')\n+    ContentType = apps.get_model('contenttypes', 'ContentType')\n+    for Model in apps.get_models():\n+        opts = Model._meta\n+        if not opts.proxy:\n+            continue\n+        proxy_default_permissions_codenames = [\n+            '%s_%s' % (action, opts.model_name)\n+            for action in opts.default_permissions\n+        ]\n+        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n+        for codename, name in opts.permissions:\n+            permissions_query = permissions_query | Q(codename=codename, name=name)\n+        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n+        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n+        old_content_type = proxy_content_type if reverse else concrete_content_type\n+        new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions that would cause duplicates after update\n+        existing_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        ).values_list('codename', flat=True)\n+        \n+        # Only update permissions that won't create duplicates\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        ).exclude(codename__in=existing_permissions)\n+        \n+        permissions_to_update.update(content_type=new_content_type)\n+\n+\n+def revert_proxy_model_permissions(apps, schema_editor):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the concrete model.\n+    \"\"\"\n+    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n+\n+def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the proxy model.\n+    \"\"\"\n+    style = schema_editor.style\n+    Permission = apps.get_model('auth', 'Permission')\n+    ContentType = apps.get_model('contenttypes', 'ContentType')\n+    for Model in apps.get_models():\n+        opts = Model._meta\n+        if not opts.proxy:\n+            continue\n+        proxy_default_permissions_codenames = [\n+            '%s_%s' % (action, opts.model_name)\n+            for action in opts.default_permissions\n+        ]\n+        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n+        for codename, name in opts.permissions:\n+            permissions_query = permissions_query | Q(codename=codename, name=name)\n+        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n+        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n+        old_content_type = proxy_content_type if reverse else concrete_content_type\n+        new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions that need to be updated\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Check for existing permissions with the new content type that would cause duplicates\n+        existing_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        ).values_list('codename', flat=True)\n+        \n+        # Filter out permissions that would create duplicates\n+        for permission in permissions_to_update:\n+            if permission.codename not in existing_permissions:\n+                permission.content_type = new_content_type\n+                permission.save()\n+\n+\n+\n+def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the proxy model.\n+    \"\"\"\n+    style = color_style()\n+    Permission = apps.get_model('auth', 'Permission')\n+    ContentType = apps.get_model('contenttypes', 'ContentType')\n+    for Model in apps.get_models():\n+        opts = Model._meta\n+        if not opts.proxy:\n+            continue\n+        proxy_default_permissions_codenames = [\n+            '%s_%s' % (action, opts.model_name)\n+            for action in opts.default_permissions\n+        ]\n+        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n+        for codename, name in opts.permissions:\n+            permissions_query = permissions_query | Q(codename=codename, name=name)\n+        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n+        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n+        old_content_type = proxy_content_type if reverse else concrete_content_type\n+        new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions that need to be updated\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Check for existing permissions with the new content_type that would cause conflicts\n+        existing_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        ).values_list('codename', flat=True)\n+        \n+        # Only update permissions that won't cause duplicate key violations\n+        for permission in permissions_to_update:\n+            if permission.codename not in existing_permissions:\n+                permission.content_type = new_content_type\n+                permission.save()\n+            else:\n+                # Delete the old permission to avoid duplicates\n+                permission.delete()\n \n \n def revert_proxy_model_permissions(apps, schema_editor):\n",
    "variant_7": "diff --git a/django/contrib/auth/migrations/0011_update_proxy_permissions.py b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\nindex 0e66649695..48921d6142 100644\n--- a/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n+++ b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n@@ -2,6 +2,53 @@ from django.db import migrations\n from django.db.models import Q\n \n \n+\n+def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the proxy model.\n+    \"\"\"\n+    Permission = apps.get_model('auth', 'Permission')\n+    ContentType = apps.get_model('contenttypes', 'ContentType')\n+    for Model in apps.get_models():\n+        opts = Model._meta\n+        if not opts.proxy:\n+            continue\n+        proxy_default_permissions_codenames = [\n+            '%s_%s' % (action, opts.model_name)\n+            for action in opts.default_permissions\n+        ]\n+        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n+        for codename, name in opts.permissions:\n+            permissions_query = permissions_query | Q(codename=codename)\n+        concrete_content_type = ContentType.objects.get_for_model(\n+            Model, for_concrete_model=True\n+        )\n+        proxy_content_type = ContentType.objects.get_for_model(\n+            Model, for_concrete_model=False\n+        )\n+        old_content_type = proxy_content_type if reverse else concrete_content_type\n+        new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions that need to be updated\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Check for existing permissions that would cause conflicts\n+        existing_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        ).values_list('codename', flat=True)\n+        \n+        # Only update permissions that won't create duplicates\n+        safe_permissions = permissions_to_update.exclude(\n+            codename__in=existing_permissions\n+        )\n+        \n+        safe_permissions.update(content_type=new_content_type)\n+\n def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n     \"\"\"\n     Update the content_type of proxy model permissions to use the ContentType\n@@ -24,9 +71,171 @@ def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n         proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n         old_content_type = proxy_content_type if reverse else concrete_content_type\n         new_content_type = concrete_content_type if reverse else proxy_content_type\n-        Permission.objects.filter(\n+        \n+        # Get permissions that need to be updated\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Check for existing permissions that would cause duplicates\n+        existing_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        ).values_list('codename', flat=True)\n+        \n+        # Filter out permissions that would create duplicates\n+        safe_permissions = permissions_to_update.exclude(\n+            codename__in=existing_permissions\n+        )\n+        \n+        # Update only the safe permissions\n+        safe_permissions.update(content_type=new_content_type)\n+\n+def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the proxy model.\n+    \"\"\"\n+    Permission = apps.get_model('auth', 'Permission')\n+    ContentType = apps.get_model('contenttypes', 'ContentType')\n+    for Model in apps.get_models():\n+        opts = Model._meta\n+        if not opts.proxy:\n+            continue\n+        proxy_default_permissions_codenames = [\n+            '%s_%s' % (action, opts.model_name)\n+            for action in opts.default_permissions\n+        ]\n+        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n+        for codename, name in opts.permissions:\n+            permissions_query = permissions_query | Q(codename=codename, name=name)\n+        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n+        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n+        old_content_type = proxy_content_type if reverse else concrete_content_type\n+        new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions that need to be updated\n+        permissions_to_update = Permission.objects.filter(\n             permissions_query,\n             content_type=old_content_type,\n+        )\n+        \n+        # Check for existing permissions with the new content type that would cause duplicates\n+        existing_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        ).values_list('codename', flat=True)\n+        \n+        # Filter out permissions that would create duplicates\n+        safe_permissions = permissions_to_update.exclude(codename__in=existing_permissions)\n+        \n+        # Update only the safe permissions\n+        safe_permissions.update(content_type=new_content_type)\n+        \n+        # Delete the conflicting old permissions to avoid duplicates\n+        permissions_to_update.filter(codename__in=existing_permissions).delete()\n+\n+\n+def revert_proxy_model_permissions(apps, schema_editor):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the concrete model.\n+    \"\"\"\n+    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n+\n+def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the proxy model.\n+    \"\"\"\n+    Permission = apps.get_model('auth', 'Permission')\n+    ContentType = apps.get_model('contenttypes', 'ContentType')\n+    for Model in apps.get_models():\n+        opts = Model._meta\n+        if not opts.proxy:\n+            continue\n+        proxy_default_permissions_codenames = [\n+            '%s_%s' % (action, opts.model_name)\n+            for action in opts.default_permissions\n+        ]\n+        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n+        for codename, name in opts.permissions:\n+            permissions_query = permissions_query | Q(codename=codename, name=name)\n+        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n+        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n+        old_content_type = proxy_content_type if reverse else concrete_content_type\n+        new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions that would cause duplicates and delete them first\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Find existing permissions with the same codename and new content type\n+        existing_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        ).values_list('codename', flat=True)\n+        \n+        # Delete existing permissions that would cause duplicates\n+        if existing_permissions:\n+            Permission.objects.filter(\n+                codename__in=existing_permissions,\n+                content_type=new_content_type,\n+            ).delete()\n+        \n+        # Now safely update the remaining permissions\n+        permissions_to_update.update(content_type=new_content_type)\n+\n+\n+def revert_proxy_model_permissions(apps, schema_editor):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the concrete model.\n+    \"\"\"\n+    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n+\n+\n+\n+def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the proxy model.\n+    \"\"\"\n+    ContentType = apps.get_model('contenttypes', 'ContentType')\n+    Permission = apps.get_model('auth', 'Permission')\n+    \n+    for Model in apps.get_models():\n+        opts = Model._meta\n+        if not opts.proxy:\n+            continue\n+        proxy_default_permissions_codenames = [\n+            '%s_%s' % (action, opts.model_name)\n+            for action in opts.default_permissions\n+        ]\n+        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n+        for codename, name in opts.permissions:\n+            permissions_query = permissions_query | Q(codename=codename, name=name)\n+\n+        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n+        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n+        old_content_type = proxy_content_type if reverse else concrete_content_type\n+        new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions that would conflict after update\n+        conflicting_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type\n+        ).values_list('codename', flat=True)\n+        \n+        # Only update permissions that won't create duplicates\n+        non_conflicting_query = permissions_query & ~Q(codename__in=conflicting_permissions)\n+        \n+        Permission.objects.filter(\n+            non_conflicting_query,\n+            content_type=old_content_type,\n         ).update(content_type=new_content_type)\n \n \n",
    "variant_8": "diff --git a/django/contrib/auth/migrations/0011_update_proxy_permissions.py b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\nindex 0e66649695..7a5d94943c 100644\n--- a/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n+++ b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n@@ -2,6 +2,144 @@ from django.db import migrations\n from django.db.models import Q\n \n \n+\n+def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the proxy model.\n+    \"\"\"\n+    Permission = apps.get_model('auth', 'Permission')\n+    ContentType = apps.get_model('contenttypes', 'ContentType')\n+    for Model in apps.get_models():\n+        opts = Model._meta\n+        if not opts.proxy:\n+            continue\n+        proxy_default_permissions_codenames = [\n+            '%s_%s' % (action, opts.model_name)\n+            for action in opts.default_permissions\n+        ]\n+        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n+        for codename, name in opts.permissions:\n+            permissions_query = permissions_query | Q(codename=codename)\n+        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n+        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n+        old_content_type = proxy_content_type if reverse else concrete_content_type\n+        new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions that need to be updated\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Check for existing permissions with the new content type that would cause conflicts\n+        existing_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        ).values_list('codename', flat=True)\n+        \n+        # Only update permissions that won't create duplicates\n+        permissions_to_update = permissions_to_update.exclude(\n+            codename__in=existing_permissions\n+        )\n+        \n+        permissions_to_update.update(content_type=new_content_type)\n+\n+def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the proxy model.\n+    \"\"\"\n+    Permission = apps.get_model('auth', 'Permission')\n+    ContentType = apps.get_model('contenttypes', 'ContentType')\n+    for Model in apps.get_models():\n+        opts = Model._meta\n+        if not opts.proxy:\n+            continue\n+        proxy_default_permissions_codenames = [\n+            '%s_%s' % (action, opts.model_name)\n+            for action in opts.default_permissions\n+        ]\n+        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n+        for codename, name in opts.permissions:\n+            permissions_query = permissions_query | Q(codename=codename, name=name)\n+        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n+        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n+        old_content_type = proxy_content_type if reverse else concrete_content_type\n+        new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions that need to be updated\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Check for existing permissions with the new content_type that would cause conflicts\n+        existing_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        ).values_list('codename', flat=True)\n+        \n+        # Only update permissions that won't create duplicates\n+        for permission in permissions_to_update:\n+            if permission.codename not in existing_permissions:\n+                permission.content_type = new_content_type\n+                permission.save()\n+\n+\n+def revert_proxy_model_permissions(apps, schema_editor):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the concrete model.\n+    \"\"\"\n+    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n+\n+def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the proxy model.\n+    \"\"\"\n+    Permission = apps.get_model('auth', 'Permission')\n+    ContentType = apps.get_model('contenttypes', 'ContentType')\n+    for Model in apps.get_models():\n+        opts = Model._meta\n+        if not opts.proxy:\n+            continue\n+        proxy_default_permissions_codenames = [\n+            '%s_%s' % (action, opts.model_name)\n+            for action in opts.default_permissions\n+        ]\n+        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n+        for codename, name in opts.permissions:\n+            permissions_query = permissions_query | Q(codename=codename, name=name)\n+        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n+        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n+        old_content_type = proxy_content_type if reverse else concrete_content_type\n+        new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions that would conflict with the update\n+        conflicting_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        )\n+        conflicting_codenames = set(conflicting_permissions.values_list('codename', flat=True))\n+        \n+        # Only update permissions that won't create duplicates\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        ).exclude(codename__in=conflicting_codenames)\n+        \n+        permissions_to_update.update(content_type=new_content_type)\n+\n+\n+def revert_proxy_model_permissions(apps, schema_editor):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the concrete model.\n+    \"\"\"\n+    update_proxy_model_permissions(apps, schema_editor, reverse=True)\n+\n def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n     \"\"\"\n     Update the content_type of proxy model permissions to use the ContentType\n@@ -24,6 +162,14 @@ def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n         proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n         old_content_type = proxy_content_type if reverse else concrete_content_type\n         new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # First, delete any existing permissions with the target content_type to avoid duplicates\n+        Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        ).delete()\n+        \n+        # Then update the permissions to use the new content_type\n         Permission.objects.filter(\n             permissions_query,\n             content_type=old_content_type,\n@@ -38,6 +184,51 @@ def revert_proxy_model_permissions(apps, schema_editor):\n     update_proxy_model_permissions(apps, schema_editor, reverse=True)\n \n \n+\n+def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n+    \"\"\"\n+    Update the content_type of proxy model permissions to use the ContentType\n+    of the proxy model.\n+    \"\"\"\n+    style = schema_editor.style\n+    Permission = apps.get_model('auth', 'Permission')\n+    ContentType = apps.get_model('contenttypes', 'ContentType')\n+    for Model in apps.get_models():\n+        opts = Model._meta\n+        if not opts.proxy:\n+            continue\n+        proxy_default_permissions_codenames = [\n+            '%s_%s' % (action, opts.model_name)\n+            for action in opts.default_permissions\n+        ]\n+        permissions_query = Q(codename__in=proxy_default_permissions_codenames)\n+        for codename, name in opts.permissions:\n+            permissions_query = permissions_query | Q(codename=codename, name=name)\n+        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)\n+        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)\n+        old_content_type = proxy_content_type if reverse else concrete_content_type\n+        new_content_type = concrete_content_type if reverse else proxy_content_type\n+        \n+        # Get permissions to update\n+        permissions_to_update = Permission.objects.filter(\n+            permissions_query,\n+            content_type=old_content_type,\n+        )\n+        \n+        # Check for existing permissions with the target content_type\n+        # that would cause duplicates\n+        existing_permissions = Permission.objects.filter(\n+            permissions_query,\n+            content_type=new_content_type,\n+        ).values_list('codename', flat=True)\n+        \n+        # Only update permissions that won't create duplicates\n+        for permission in permissions_to_update:\n+            if permission.codename not in existing_permissions:\n+                permission.content_type = new_content_type\n+                permission.save()\n+\n+\n class Migration(migrations.Migration):\n     dependencies = [\n         ('auth', '0010_alter_group_name_max_length'),\n"
  }
}