{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/django/django/contrib/auth/management/__init__.py lines 37-44)": "\ndef create_permissions(\n    app_config,\n    verbosity=2,\n    interactive=True,\n    using=DEFAULT_DB_ALIAS,\n    apps=global_apps,\n    **kwargs,\n):\n    if not app_config.models_module:\n        return\n\n    # Ensure that contenttypes are created for this app. Needed if\n    # 'django.contrib.auth' is in INSTALLED_APPS before\n    # 'django.contrib.contenttypes'.\n    create_contenttypes(\n        app_config,\n        verbosity=verbosity,\n        interactive=interactive,\n        using=using,\n        apps=apps,\n        **kwargs,\n    )\n\n    app_label = app_config.label\n    try:\n        app_config = apps.get_app_config(app_label)\n        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n        Permission = apps.get_model(\"auth\", \"Permission\")\n    except LookupError:\n        return\n\n    if not router.allow_migrate_model(using, Permission):\n        return\n\n    # This will hold the permissions we're looking for as\n    # (content_type, (codename, name))\n    searched_perms = []\n    # The codenames and ctypes that should exist.\n    ctypes = set()\n    for klass in app_config.get_models():\n        # Force looking up the content types in the current database\n        # before creating foreign keys to them.\n        ctype = ContentType._base_manager.db_manager(using).get_for_model(\n            klass, for_concrete_model=False\n        )\n\n        ctypes.add(ctype)\n        for perm in _get_all_permissions(klass._meta):\n            searched_perms.append((ctype, perm))\n\n    # Find all the Permissions that have a content_type for a model we're\n    # looking for.  We don't need to check for codenames since we already have\n    # a list of the ones we're going to create.\n    all_perms = set(\n        Permission._base_manager.db_manager(using)\n        .filter(content_type__in=ctypes)\n        .values_list(\"content_type\", \"codename\")\n    )\n\n    perms = [\n        Permission(codename=codename, name=name, content_type=ct)\n        for ct, (codename, name) in searched_perms\n        if (ct.pk, codename) not in all_perms\n    ]\n    Permission._base_manager.db_manager(using).bulk_create(perms)\n    if verbosity >= 2:\n        for perm in perms:\n            print(\"Adding permission '%s'\" % perm)\n",
    "Location 2 (/root/hy/projects_2/django/django/contrib/auth/management/__init__.py lines 79-81)": "\n        # Force looking up the content types in the current database\n        # before creating foreign keys to them.\n        # Bypass router when explicit database is specified during migration\n        if using != DEFAULT_DB_ALIAS:\n            # Use raw connection to bypass router for migration operations\n            ctype = ContentType.objects.using(using).get_for_model(\n                klass, for_concrete_model=False\n            )\n        else:\n            ctype = ContentType.objects.db_manager(using).get_for_model(\n                klass, for_concrete_model=False\n            )\n",
    "Location 3 (/root/hy/projects_2/django/django/contrib/auth/management/__init__.py lines 91-96)": "\n    # Find all the Permissions that have a content_type for a model we're\n    # looking for.  We don't need to check for codenames since we already have\n    # a list of the ones we're going to create.\n    all_perms = set(\n        Permission._default_manager.db_manager(using)\n        .filter(\n            content_type__in=ctypes,\n        )\n        .values_list(\"content_type\", \"codename\")\n    )\n",
    "Location 4 (/root/hy/projects_2/django/django/contrib/auth/management/__init__.py lines 51-58)": "\n    create_contenttypes(\n        app_config,\n        verbosity=verbosity,\n        interactive=interactive,\n        using=using,\n        apps=apps,\n        **kwargs,\n    )\n",
    "Location 5 (/root/hy/projects_2/django/django/contrib/auth/management/__init__.py lines 103-103)": "\n    Permission.objects.using(using).bulk_create(perms, ignore_conflicts=True)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/django/django/contrib/auth/management/__init__.py lines 37-44)": [
      "\ndef create_permissions(\n    app_config,\n    verbosity=2,\n    interactive=True,\n    using=DEFAULT_DB_ALIAS,\n    apps=global_apps,\n    **kwargs,\n):\n    if not app_config.models_module:\n        return\n\n    # Ensure that contenttypes are created for this app. Needed if\n    # 'django.contrib.auth' is in INSTALLED_APPS before\n    # 'django.contrib.contenttypes'.\n    create_contenttypes(\n        app_config,\n        verbosity=verbosity,\n        interactive=interactive,\n        using=using,\n        apps=apps,\n        **kwargs,\n    )\n\n    app_label = app_config.label\n    try:\n        app_config = apps.get_app_config(app_label)\n        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n        Permission = apps.get_model(\"auth\", \"Permission\")\n    except LookupError:\n        return\n\n    if not router.allow_migrate_model(using, Permission):\n        return\n\n    # This will hold the permissions we're looking for as\n    # (content_type, (codename, name))\n    searched_perms = []\n    # The codenames and ctypes that should exist.\n    ctypes = set()\n    for klass in app_config.get_models():\n        # Force looking up the content types in the current database\n        # before creating foreign keys to them.\n        ctype = ContentType.objects.db_manager(using).get_for_model(\n            klass, for_concrete_model=False\n        )\n\n        ctypes.add(ctype)\n        for perm in _get_all_permissions(klass._meta):\n            searched_perms.append((ctype, perm))\n\n    # Find all the Permissions that have a content_type for a model we're\n    # looking for. We don't need to check for codenames since we already have\n    # a list of the ones we're going to create.\n    all_perms = set(\n        Permission.objects.using(using)\n        .filter(\n            content_type__in=ctypes,\n        )\n        .values_list(\"content_type\", \"codename\")\n    )\n\n    perms = [\n        Permission(codename=codename, name=name, content_type=ct)\n        for ct, (codename, name) in searched_perms\n        if (ct.pk, codename) not in all_perms\n    ]\n    Permission.objects.using(using).bulk_create(perms)\n    if verbosity >= 2:\n        for perm in perms:\n            print(\"Adding permission '%s'\" % perm)\n",
      "\ndef create_permissions(\n    app_config,\n    verbosity=2,\n    interactive=True,\n    using=DEFAULT_DB_ALIAS,\n    apps=global_apps,\n    **kwargs,\n):\n    if not app_config.models_module:\n        return\n\n    # Ensure that contenttypes are created for this app. Needed if\n    # 'django.contrib.auth' is in INSTALLED_APPS before\n    # 'django.contrib.contenttypes'.\n    create_contenttypes(\n        app_config,\n        verbosity=verbosity,\n        interactive=interactive,\n        using=using,\n        apps=apps,\n        **kwargs,\n    )\n\n    app_label = app_config.label\n    try:\n        app_config = apps.get_app_config(app_label)\n        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n        Permission = apps.get_model(\"auth\", \"Permission\")\n    except LookupError:\n        return\n\n    if not router.allow_migrate_model(using, Permission):\n        return\n\n    # This will hold the permissions we're looking for as\n    # (content_type, (codename, name))\n    searched_perms = []\n    # The codenames and ctypes that should exist.\n    ctypes = set()\n    for klass in app_config.get_models():\n        # Force looking up the content types in the current database\n        # before creating foreign keys to them.\n        ctype = ContentType._base_manager.db_manager(using).get_for_model(\n            klass, for_concrete_model=False\n        )\n        ctypes.add(ctype)\n        for perm in _get_all_permissions(klass._meta):\n            searched_perms.append((ctype, perm))\n\n    # Find all the Permissions that have a content_type for a model we're\n    # looking for.  We don't need to check for codenames since we already have\n    # a list of the ones we're going to create.\n    all_perms = set(\n        Permission._base_manager.db_manager(using)\n        .filter(\n            content_type__in=ctypes,\n        )\n        .values_list(\"content_type\", \"codename\")\n    )\n\n    perms = [\n        Permission(codename=codename, name=name, content_type=ct)\n        for ct, (codename, name) in searched_perms\n        if (ct.pk, codename) not in all_perms\n    ]\n    Permission._base_manager.db_manager(using).bulk_create(perms)\n    if verbosity >= 2:\n        for perm in perms:\n            print(\"Adding permission '%s'\" % perm)\n",
      "\ndef create_permissions(\n    app_config,\n    verbosity=2,\n    interactive=True,\n    using=DEFAULT_DB_ALIAS,\n    apps=global_apps,\n    **kwargs,\n):\n    if not app_config.models_module:\n        return\n\n    # Ensure that contenttypes are created for this app. Needed if\n    # 'django.contrib.auth' is in INSTALLED_APPS before\n    # 'django.contrib.contenttypes'.\n    create_contenttypes(\n        app_config,\n        verbosity=verbosity,\n        interactive=interactive,\n        using=using,\n        apps=apps,\n    )\n\n    app_label = app_config.label\n    try:\n        app_config = apps.get_app_config(app_label)\n        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n        Permission = apps.get_model(\"auth\", \"Permission\")\n    except LookupError:\n        return\n\n    if not router.allow_migrate_model(using, Permission):\n        return\n\n    # This will hold the permissions we're looking for as\n    # (content_type, (codename, name))\n    searched_perms = []\n    # The codenames and ctypes that should exist.\n    ctypes = set()\n    for klass in app_config.get_models():\n        # Force looking up the content types in the current database\n        # before creating foreign keys to them.\n        ctype = ContentType.objects.db_manager(using).get_for_model(\n            klass, for_concrete_model=False\n        )\n\n        ctypes.add(ctype)\n        for perm in _get_builtin_permissions(klass._meta):\n            searched_perms.append((ctype, perm))\n\n    # Find all the Permissions that have a content_type for a model we're\n    # looking for.  We don't need to check for codenames since we already have\n    # a list of the ones we're going to create.\n    all_perms = set(\n        Permission.objects.using(using)\n        .filter(\n            content_type__in=ctypes,\n        )\n        .values_list(\"content_type\", \"codename\")\n    )\n\n    perms = [\n        Permission(codename=codename, name=name, content_type=ct)\n        for ct, (codename, name) in searched_perms\n        if (ct.pk, codename) not in all_perms\n    ]\n    Permission.objects.using(using).bulk_create(perms)\n    if verbosity >= 2:\n        for perm in perms:\n            print(\"Adding permission '%s'\" % perm)\n",
      "\ndef create_permissions(\n    app_config,\n    verbosity=2,\n    interactive=True,\n    using=DEFAULT_DB_ALIAS,\n    apps=global_apps,\n    **kwargs,\n):\n    if not app_config.models_module:\n        return\n\n    # Ensure that contenttypes are created for this app. Needed if\n    # 'django.contrib.auth' is in INSTALLED_APPS before\n    # 'django.contrib.contenttypes'.\n    create_contenttypes(\n        app_config,\n        verbosity=verbosity,\n        interactive=interactive,\n        using=using,\n        apps=apps,\n        **kwargs,\n    )\n\n    app_label = app_config.label\n    try:\n        app_config = apps.get_app_config(app_label)\n        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n        Permission = apps.get_model(\"auth\", \"Permission\")\n    except LookupError:\n        return\n\n    if not router.allow_migrate_model(using, Permission):\n        return\n\n    # This will hold the permissions we're looking for as\n    # (content_type, (codename, name))\n    searched_perms = []\n    # The codenames and ctypes that should exist.\n    ctypes = set()\n    for klass in app_config.get_models():\n        # Force looking up the content types in the current database\n        # before creating foreign keys to them.\n        ctype = ContentType.objects.db_manager(using).get_for_model(\n            klass, for_concrete_model=False\n        )\n\n        ctypes.add(ctype)\n        for perm in _get_all_permissions(klass._meta):\n            searched_perms.append((ctype, perm))\n\n    # Find all the Permissions that have a content_type for a model we're\n    # looking for.  We don't need to check for codenames since we already have\n    # a list of the ones we're going to create.\n    all_perms = set(\n        Permission.objects.db_manager(using)\n        .filter(\n            content_type__in=ctypes,\n        )\n        .values_list(\"content_type\", \"codename\")\n    )\n\n    perms = [\n        Permission(codename=codename, name=name, content_type=ct)\n        for ct, (codename, name) in searched_perms\n        if (ct.pk, codename) not in all_perms\n    ]\n    Permission.objects.db_manager(using).bulk_create(perms)\n    if verbosity >= 2:\n        for perm in perms:\n            print(\"Adding permission '%s'\" % perm)\n",
      "\ndef create_permissions(\n    app_config,\n    verbosity=2,\n    interactive=True,\n    using=DEFAULT_DB_ALIAS,\n    apps=global_apps,\n    **kwargs,\n):\n    if not app_config.models_module:\n        return\n\n    # Ensure that contenttypes are created for this app. Needed if\n    # 'django.contrib.auth' is in INSTALLED_APPS before\n    # 'django.contrib.contenttypes'.\n    create_contenttypes(\n        app_config,\n        verbosity=verbosity,\n        interactive=interactive,\n        using=using,\n        apps=apps,\n        **kwargs,\n    )\n\n    app_label = app_config.label\n    try:\n        app_config = apps.get_app_config(app_label)\n        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n        Permission = apps.get_model(\"auth\", \"Permission\")\n    except LookupError:\n        return\n\n    if not router.allow_migrate_model(using, Permission):\n        return\n\n    # This will hold the permissions we're looking for as\n    # (content_type, (codename, name))\n    searched_perms = []\n    # The codenames and ctypes that should exist.\n    ctypes = set()\n    for klass in app_config.get_models():\n        # Force looking up the content types in the current database\n        # before creating foreign keys to them.\n        ctype = ContentType._base_manager.db_manager(using).get_for_model(\n            klass, for_concrete_model=False\n        )\n        ctypes.add(ctype)\n        for perm in _get_all_permissions(klass._meta):\n            searched_perms.append((ctype, perm))\n\n    # Find all the Permissions that have a content_type for a model we're\n    # looking for.  We don't need to check for codenames since we already have\n    # a list of the ones we're going to create.\n    all_perms = set(\n        Permission._base_manager.db_manager(using)\n        .filter(\n            content_type__in=ctypes,\n        )\n        .values_list(\"content_type\", \"codename\")\n    )\n\n    perms = [\n        Permission(codename=codename, name=name, content_type=ct)\n        for ct, (codename, name) in searched_perms\n        if (ct.pk, codename) not in all_perms\n    ]\n    Permission._base_manager.db_manager(using).bulk_create(perms)\n    if verbosity >= 2:\n        for perm in perms:\n            print(\"Adding permission '%s'\" % perm)\n",
      "\ndef create_permissions(\n    app_config,\n    verbosity=2,\n    interactive=True,\n    using=DEFAULT_DB_ALIAS,\n    apps=global_apps,\n    **kwargs,\n):\n    if not app_config.models_module:\n        return\n\n    # Ensure that contenttypes are created for this app. Needed if\n    # 'django.contrib.auth' is in INSTALLED_APPS before\n    # 'django.contrib.contenttypes'.\n    create_contenttypes(\n        app_config,\n        verbosity=verbosity,\n        interactive=interactive,\n        using=using,\n        apps=apps,\n        **kwargs,\n    )\n\n    app_label = app_config.label\n    try:\n        app_config = apps.get_app_config(app_label)\n        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n        Permission = apps.get_model(\"auth\", \"Permission\")\n    except LookupError:\n        return\n\n    if not router.allow_migrate_model(using, Permission):\n        return\n\n    # This will hold the permissions we're looking for as\n    # (content_type, (codename, name))\n    searched_perms = []\n    # The codenames and ctypes that should exist.\n    ctypes = set()\n    for klass in app_config.get_models():\n        # Force looking up the content types in the current database\n        # before creating foreign keys to them.\n        ctype = ContentType.objects.db_manager(using).get_for_model(\n            klass, for_concrete_model=False\n        )\n\n        ctypes.add(ctype)\n        for perm in _get_all_permissions(klass._meta):\n            searched_perms.append((ctype, perm))\n\n    # Find all the Permissions that have a content_type for a model we're\n    # looking for.  We don't need to check for codenames since we already have\n    # a list of the ones we're going to create.\n    all_perms = set(\n        Permission.objects.db_manager(using)\n        .filter(\n            content_type__in=ctypes,\n        )\n        .values_list(\"content_type\", \"codename\")\n    )\n\n    perms = [\n        Permission(codename=codename, name=name, content_type=ct)\n        for ct, (codename, name) in searched_perms\n        if (ct.pk, codename) not in all_perms\n    ]\n    Permission.objects.db_manager(using).bulk_create(perms)\n    if verbosity >= 2:\n        for perm in perms:\n            print(\"Adding permission '%s'\" % perm)\n",
      "\ndef create_permissions(\n    app_config,\n    verbosity=2,\n    interactive=True,\n    using=DEFAULT_DB_ALIAS,\n    apps=global_apps,\n    **kwargs,\n):\n    if not app_config.models_module:\n        return\n\n    # Ensure that contenttypes are created for this app. Needed if\n    # 'django.contrib.auth' is in INSTALLED_APPS before\n    # 'django.contrib.contenttypes'.\n    create_contenttypes(\n        app_config,\n        verbosity=verbosity,\n        interactive=interactive,\n        using=using,\n        apps=apps,\n        **kwargs,\n    )\n\n    app_label = app_config.label\n    try:\n        app_config = apps.get_app_config(app_label)\n        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n        Permission = apps.get_model(\"auth\", \"Permission\")\n    except LookupError:\n        return\n\n    if not router.allow_migrate_model(using, Permission):\n        return\n\n    # This will hold the permissions we're looking for as\n    # (content_type, (codename, name))\n    searched_perms = []\n    # The codenames and ctypes that should exist.\n    ctypes = set()\n    for klass in app_config.get_models():\n        # Force looking up the content types in the current database\n        # before creating foreign keys to them.\n        ctype = ContentType.objects.db_manager(using).get_for_model(\n            klass, for_concrete_model=False\n        )\n\n        ctypes.add(ctype)\n        for perm in _get_all_permissions(klass._meta):\n            searched_perms.append((ctype, perm))\n\n    # Find all the Permissions that have a content_type for a model we're\n    # looking for.  We don't need to check for codenames since we already have\n    # a list of the ones we're going to create.\n    all_perms = set(\n        Permission.objects.using(using)\n        .filter(\n            content_type__in=ctypes,\n        )\n        .values_list(\"content_type\", \"codename\")\n    )\n\n    perms = [\n        Permission(codename=codename, name=name, content_type=ct)\n        for ct, (codename, name) in searched_perms\n        if (ct.pk, codename) not in all_perms\n    ]\n    Permission.objects.using(using).bulk_create(perms)\n    if verbosity >= 2:\n        for perm in perms:\n            print(\"Adding permission '%s'\" % perm)\n",
      "\ndef create_permissions(\n    app_config,\n    verbosity=2,\n    interactive=True,\n    using=DEFAULT_DB_ALIAS,\n    apps=global_apps,\n    **kwargs,\n):\n    if not app_config.models_module:\n        return\n\n    # Ensure that contenttypes are created for this app. Needed if\n    # 'django.contrib.auth' is in INSTALLED_APPS before\n    # 'django.contrib.contenttypes'.\n    create_contenttypes(\n        app_config,\n        verbosity=verbosity,\n        interactive=interactive,\n        using=using,\n        apps=apps,\n    )\n\n    try:\n        Permission = apps.get_model(\"auth\", \"Permission\")\n        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n    except LookupError:\n        return\n\n    if not router.allow_migrate_model(using, Permission):\n        return\n\n    # This will hold the permissions we're looking for as\n    # (content_type, (codename, name))\n    searched_perms = []\n    # The codenames and ctypes that should exist.\n    ctypes = set()\n    for klass in app_config.get_models():\n        # Force looking up the content types in the current database\n        # before creating foreign keys to them.\n        ctype = ContentType._base_manager.db_manager(using).get_for_model(\n            klass,\n            for_concrete_model=False,\n        )\n\n        ctypes.add(ctype)\n        for perm in _get_all_permissions(klass._meta):\n            searched_perms.append((ctype, perm))\n\n    # Find all the Permissions that have a content_type for a model we're\n    # looking for.  We don't need to check for codenames since we already have\n    # a list of the ones we're going to create.\n    all_perms = set(\n        Permission._base_manager.db_manager(using).filter(\n            content_type__in=ctypes,\n        ).values_list(\"content_type\", \"codename\")\n    )\n\n    perms = [\n        Permission(codename=codename, name=name, content_type=ct)\n        for ct, (codename, name) in searched_perms\n        if (ct.pk, codename) not in all_perms\n    ]\n    Permission._base_manager.db_manager(using).bulk_create(perms)\n    if verbosity >= 2:\n        for perm in perms:\n            print(\"Adding permission '%s'\" % perm)\n"
    ],
    "Location 2 (/root/hy/projects_2/django/django/contrib/auth/management/__init__.py lines 79-81)": [
      "\n        # Force looking up the content types in the current database\n        # before creating foreign keys to them.\n        # Use direct database connection to bypass router during migrations\n        if using != DEFAULT_DB_ALIAS:\n            # For explicit database specification, bypass router\n            ctype = ContentType.objects.using(using).get_for_model(\n                klass, for_concrete_model=False\n            )\n        else:\n            ctype = ContentType.objects.db_manager(using).get_for_model(\n                klass, for_concrete_model=False\n            )\n",
      "\n        # Force looking up the content types in the current database\n        # before creating foreign keys to them.\n        # Use raw SQL query to bypass router when explicit database is specified\n        from django.db import connections\n        connection = connections[using]\n        with connection.cursor() as cursor:\n            cursor.execute(\n                \"SELECT id FROM django_content_type WHERE app_label = %s AND model = %s\",\n                [klass._meta.app_label, klass._meta.model_name.lower()]\n            )\n            row = cursor.fetchone()\n            if row:\n                ctype = ContentType(\n                    id=row[0],\n                    app_label=klass._meta.app_label,\n                    model=klass._meta.model_name.lower()\n                )\n            else:\n                # Fallback to ORM if not found (shouldn't happen during migrations)\n                ctype = ContentType.objects.db_manager(using).get_for_model(\n                    klass, for_concrete_model=False\n                )\n",
      "\n        # Force looking up the content types in the current database\n        # before creating foreign keys to them.\n        # Bypass router when explicit database is specified during migration\n        if using != DEFAULT_DB_ALIAS:\n            # Use raw connection to bypass router for explicit database operations\n            ctype = ContentType.objects.db_manager(using).get_for_model(\n                klass, for_concrete_model=False\n            )\n        else:\n            ctype = ContentType.objects.get_for_model(\n                klass, for_concrete_model=False\n            )\n",
      "\n        # Force looking up the content types in the current database\n        # before creating foreign keys to them.\n        # Use direct database connection to bypass router during migrations\n        if using != DEFAULT_DB_ALIAS:\n            # Bypass router for explicit database specification during migrations\n            from django.db import connections\n            connection = connections[using]\n            with connection.cursor() as cursor:\n                # Get ContentType directly without router involvement\n                ctype = ContentType.objects.db_manager(using).get_for_model(\n                    klass, for_concrete_model=False\n                )\n        else:\n            ctype = ContentType.objects.db_manager(using).get_for_model(\n                klass, for_concrete_model=False\n            )\n",
      "\n        # Force looking up the content types in the current database\n        # before creating foreign keys to them.\n        # Use raw SQL to bypass router when explicit database is specified\n        if using != DEFAULT_DB_ALIAS:\n            from django.db import connections\n            connection = connections[using]\n            with connection.cursor() as cursor:\n                cursor.execute(\n                    \"SELECT id FROM django_content_type WHERE app_label = %s AND model = %s\",\n                    [klass._meta.app_label, klass._meta.model_name]\n                )\n                row = cursor.fetchone()\n                if row:\n                    ctype = ContentType(\n                        id=row[0],\n                        app_label=klass._meta.app_label,\n                        model=klass._meta.model_name\n                    )\n                else:\n                    # Fallback to regular ORM if content type doesn't exist\n                    ctype = ContentType.objects.db_manager(using).get_for_model(\n                        klass, for_concrete_model=False\n                    )\n        else:\n            ctype = ContentType.objects.db_manager(using).get_for_model(\n                klass, for_concrete_model=False\n            )\n",
      "\n        # Force looking up the content types in the current database\n        # before creating foreign keys to them.\n        # Bypass router when using explicit database during migrations\n        if using != DEFAULT_DB_ALIAS:\n            # Use raw SQL to bypass router for explicit database operations\n            from django.db import connections\n            connection = connections[using]\n            with connection.cursor() as cursor:\n                cursor.execute(\n                    \"SELECT id FROM django_content_type WHERE app_label = %s AND model = %s\",\n                    [klass._meta.app_label, klass._meta.model_name.lower()]\n                )\n                result = cursor.fetchone()\n                if result:\n                    ctype = ContentType(id=result[0], app_label=klass._meta.app_label, model=klass._meta.model_name.lower())\n                else:\n                    # Create content type directly in specified database\n                    ctype = ContentType.objects.db_manager(using).get_or_create(\n                        app_label=klass._meta.app_label,\n                        model=klass._meta.model_name.lower(),\n                        defaults={'model': klass._meta.model_name.lower()}\n                    )[0]\n        else:\n            ctype = ContentType.objects.db_manager(using).get_for_model(\n                klass, for_concrete_model=False\n            )\n",
      "\n        # Force looking up the content types in the current database\n        # before creating foreign keys to them.\n        # Bypass router for explicit database selection during migrations\n        if using != DEFAULT_DB_ALIAS:\n            # Use direct database connection to bypass router\n            ctype = ContentType.objects.using(using).get_for_model(\n                klass, for_concrete_model=False\n            )\n        else:\n            ctype = ContentType.objects.db_manager(using).get_for_model(\n                klass, for_concrete_model=False\n            )\n",
      "\n        # Force looking up the content types in the current database\n        # before creating foreign keys to them.\n        # Use raw SQL to bypass router when explicit database is specified\n        from django.db import connections\n        connection = connections[using]\n        with connection.cursor() as cursor:\n            cursor.execute(\n                \"SELECT id FROM django_content_type WHERE app_label = %s AND model = %s\",\n                [klass._meta.app_label, klass._meta.model_name]\n            )\n            row = cursor.fetchone()\n            if row:\n                ctype = ContentType(id=row[0], app_label=klass._meta.app_label, model=klass._meta.model_name)\n            else:\n                # Fallback to ORM if not found, but this should be rare during migrations\n                ctype = ContentType.objects.db_manager(using).get_for_model(\n                    klass, for_concrete_model=False\n                )\n"
    ],
    "Location 3 (/root/hy/projects_2/django/django/contrib/auth/management/__init__.py lines 91-96)": [
      "\n    # Find all the Permissions that have a content_type for a model we're\n    # looking for.  We don't need to check for codenames since we already have\n    # a list of the ones we're going to create.\n    all_perms = set(\n        Permission._base_manager.using(using)\n        .filter(\n            content_type__in=ctypes,\n        )\n        .values_list(\"content_type\", \"codename\")\n    )\n",
      "\n    # Find all the Permissions that have a content_type for a model we're\n    # looking for.  We don't need to check for codenames since we already have\n    # a list of the ones we're going to create.\n    all_perms = set(\n        Permission._base_manager.using(using)\n        .filter(\n            content_type__in=ctypes,\n        )\n        .values_list(\"content_type\", \"codename\")\n    )\n",
      "\n    # Find all the Permissions that have a content_type for a model we're\n    # looking for.  We don't need to check for codenames since we already have\n    # a list of the ones we're going to create.\n    all_perms = set(\n        Permission.objects.db_manager(using)\n        .filter(\n            content_type__in=ctypes,\n        )\n        .values_list(\"content_type\", \"codename\")\n    )\n",
      "\n    # Find all the Permissions that have a content_type for a model we're\n    # looking for.  We don't need to check for codenames since we already have\n    # a list of the ones we're going to create.\n    all_perms = set(\n        Permission.objects.db_manager(using)\n        .filter(\n            content_type__in=ctypes,\n        )\n        .values_list(\"content_type\", \"codename\")\n    )\n",
      "\n    # Find all the Permissions that have a content_type for a model we're\n    # looking for.  We don't need to check for codenames since we already have\n    # a list of the ones we're going to create.\n    all_perms = set(\n        Permission.objects.db_manager(using)\n        .filter(\n            content_type__in=ctypes,\n        )\n        .values_list(\"content_type\", \"codename\")\n    )\n",
      "\n    # Find all the Permissions that have a content_type for a model we're\n    # looking for.  We don't need to check for codenames since we already have\n    # a list of the ones we're going to create.\n    all_perms = set(\n        Permission.objects.using(using)\n        .filter(\n            content_type__in=ctypes,\n        )\n        .values_list(\"content_type\", \"codename\")\n    )\n",
      "\n    # Find all the Permissions that have a content_type for a model we're\n    # looking for.  We don't need to check for codenames since we already have\n    # a list of the ones we're going to create.\n    all_perms = set(\n        Permission.objects.db_manager(using)\n        .filter(\n            content_type__in=ctypes,\n        )\n        .values_list(\"content_type\", \"codename\")\n    )\n",
      "\n    # Find all the Permissions that have a content_type for a model we're\n    # looking for.  We don't need to check for codenames since we already have\n    # a list of the ones we're going to create.\n    all_perms = set(\n        Permission._default_manager.db_manager(using)\n        .filter(\n            content_type__in=ctypes,\n        )\n        .values_list(\"content_type\", \"codename\")\n    )\n"
    ],
    "Location 4 (/root/hy/projects_2/django/django/contrib/auth/management/__init__.py lines 51-58)": [
      "\n    create_contenttypes(\n        app_config,\n        verbosity=verbosity,\n        interactive=interactive,\n        using=using,\n        apps=apps,\n        **kwargs,\n    )\n",
      "\ndef create_permissions(\n    app_config,\n    verbosity=2,\n    interactive=True,\n    using=DEFAULT_DB_ALIAS,\n    apps=global_apps,\n    **kwargs,\n):\n    if not app_config.models_module:\n        return\n\n    # Ensure that contenttypes are created for this app. Needed if\n    # 'django.contrib.auth' is in INSTALLED_APPS before\n    # 'django.contrib.contenttypes'.\n    create_contenttypes(\n        app_config,\n        verbosity=verbosity,\n        interactive=interactive,\n        using=using,\n        apps=apps,\n        **kwargs,\n    )\n\n    app_label = app_config.label\n    try:\n        app_config = apps.get_app_config(app_label)\n        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n        Permission = apps.get_model(\"auth\", \"Permission\")\n    except LookupError:\n        return\n\n    if not router.allow_migrate_model(using, Permission):\n        return\n\n    # The codenames and ctypes that should exist.\n    ctypes = set()\n    for klass in app_config.get_models():\n        # Force looking up the content types in the current database\n        # before creating foreign keys to them. The\n        # contenttypes.management.create_contenttypes() call above should\n        # have created them.\n        ctype = ContentType.objects.db_manager(using).get_for_model(\n            klass, for_concrete_model=False\n        )\n        ctypes.add(ctype)\n\n    # Find all the Permissions that have a content_type for a model we're\n    # looking for. We don't need to check for codenames since we already have\n    # a list of the ones we're going to create.\n    all_perms = set(\n        Permission.objects.using(using)\n        .filter(content_type__in=ctypes)\n        .values_list(\"content_type\", \"codename\")\n    )\n\n    perms = [\n        Permission(\n            codename=codename,\n            name=name,\n            content_type=ct,\n        )\n        for ct in ctypes\n        for codename, name in _get_all_permissions(ct.model_class())\n        if (ct.pk, codename) not in all_perms\n    ]\n    Permission.objects.using(using).bulk_create(perms)\n    if verbosity >= 2:\n        for perm in perms:\n            print(\"Adding permission '%s'\" % perm)\n",
      "\ndef create_permissions(\n    app_config,\n    verbosity=2,\n    interactive=True,\n    using=DEFAULT_DB_ALIAS,\n    apps=global_apps,\n    **kwargs,\n):\n    if not app_config.models_module:\n        return\n\n    # Ensure that contenttypes are created for this app. Needed if\n    # 'django.contrib.auth' is in INSTALLED_APPS before\n    # 'django.contrib.contenttypes'.\n    create_contenttypes(\n        app_config,\n        verbosity=verbosity,\n        interactive=interactive,\n        using=using,\n        apps=apps,\n        **kwargs,\n    )\n\n    app_label = app_config.label\n    try:\n        app_config = apps.get_app_config(app_label)\n        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n        Permission = apps.get_model(\"auth\", \"Permission\")\n    except LookupError:\n        return\n\n    if not router.allow_migrate_model(using, Permission):\n        return\n\n    # This will hold the permissions we're looking for as\n    # (content_type, (codename, name))\n    searched_perms = []\n    # The codenames and ctypes that should exist.\n    ctypes = set()\n    for klass in app_config.get_models():\n        # Force looking up the content types in the current database\n        # before creating foreign keys to them.\n        ctype = ContentType.objects.db_manager(using).get_for_model(\n            klass, for_concrete_model=False\n        )\n\n        ctypes.add(ctype)\n        for perm in _get_all_permissions(klass._meta):\n            searched_perms.append((ctype, perm))\n\n    # Find all the Permissions that have a content_type for a model we're\n    # looking for.  We don't need to check for codenames since we already have\n    # a list of the ones we're going to create.\n    all_perms = set(\n        Permission.objects.using(using)\n        .filter(\n            content_type__in=ctypes,\n        )\n        .values_list(\"content_type\", \"codename\")\n    )\n\n    perms = [\n        Permission(codename=codename, name=name, content_type=ct)\n        for ct, (codename, name) in searched_perms\n        if (ct.pk, codename) not in all_perms\n    ]\n    Permission.objects.using(using).bulk_create(perms)\n    if verbosity >= 2:\n        for perm in perms:\n            print(\"Adding permission '%s'\" % perm)\n",
      "\ndef create_permissions(\n    app_config,\n    verbosity=2,\n    interactive=True,\n    using=DEFAULT_DB_ALIAS,\n    apps=global_apps,\n    **kwargs,\n):\n    if not app_config.models_module:\n        return\n\n    # Ensure that contenttypes are created for this app. Needed if\n    # 'django.contrib.auth' is in INSTALLED_APPS before\n    # 'django.contrib.contenttypes'.\n    create_contenttypes(\n        app_config,\n        verbosity=verbosity,\n        interactive=interactive,\n        using=using,\n        apps=apps,\n        **kwargs,\n    )\n\n    app_label = app_config.label\n    try:\n        app_config = apps.get_app_config(app_label)\n        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n        Permission = apps.get_model(\"auth\", \"Permission\")\n    except LookupError:\n        return\n\n    if not router.allow_migrate_model(using, Permission):\n        return\n\n    # This will hold the permissions we're looking for as\n    # (content_type, (codename, name))\n    searched_perms = []\n    # The codenames and ctypes that should exist.\n    ctypes = set()\n    for klass in app_config.get_models():\n        # Force looking up the content types in case the ContentType app\n        # isn't already loaded.\n        ctype = ContentType.objects.db_manager(using).get_for_model(\n            klass, for_concrete_model=False\n        )\n        ctypes.add(ctype)\n        for perm in _get_all_permissions(klass._meta):\n            searched_perms.append((ctype, perm))\n\n    # Find all the Permissions that have a content_type for a model we're\n    # looking for.  We don't need to check for codenames since we already have\n    # a list of the ones we're going to create.\n    all_perms = set(\n        Permission.objects.using(using)\n        .filter(content_type__in=ctypes)\n        .values_list(\"content_type\", \"codename\")\n    )\n\n    perms = [\n        Permission(codename=codename, name=name, content_type=ct)\n        for ct, (codename, name) in searched_perms\n        if (ct.pk, codename) not in all_perms\n    ]\n    Permission.objects.using(using).bulk_create(perms)\n    if verbosity >= 2:\n        for perm in perms:\n            print(\"Adding permission '%s'\" % perm)\n",
      "\n    create_contenttypes(\n        app_config,\n        verbosity=verbosity,\n        interactive=interactive,\n        using=using,\n        apps=apps,\n        **kwargs,\n    )\n",
      "\ndef create_permissions(\n    app_config,\n    verbosity=2,\n    interactive=True,\n    using=DEFAULT_DB_ALIAS,\n    apps=global_apps,\n    **kwargs,\n):\n    if not app_config.models_module:\n        return\n\n    # Ensure that contenttypes are created for this app. Needed if\n    # 'django.contrib.auth' is in INSTALLED_APPS before\n    # 'django.contrib.contenttypes'.\n    create_contenttypes(\n        app_config,\n        verbosity=verbosity,\n        interactive=interactive,\n        using=using,\n        apps=apps,\n        **kwargs,\n    )\n\n    app_label = app_config.label\n    try:\n        app_config = apps.get_app_config(app_label)\n        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n        Permission = apps.get_model(\"auth\", \"Permission\")\n    except LookupError:\n        return\n\n    if not router.allow_migrate_model(using, Permission):\n        return\n\n    # The codenames and ctypes that should exist.\n    ctypes = set()\n    for klass in app_config.get_models():\n        # Force looking up the content types in the current database\n        # before creating foreign keys to them. The\n        # default database would only get populated by\n        # django.contrib.contenttypes.management.\n        try:\n            # Bypass router by using raw database connection when using is explicit\n            if using != DEFAULT_DB_ALIAS:\n                # Use raw SQL to avoid router calls for explicit database\n                from django.db import connections\n                connection = connections[using]\n                with connection.cursor() as cursor:\n                    cursor.execute(\n                        \"SELECT id FROM django_content_type WHERE app_label = %s AND model = %s\",\n                        [klass._meta.app_label, klass._meta.model_name.lower()]\n                    )\n                    result = cursor.fetchone()\n                    if result:\n                        ctype = ContentType(\n                            id=result[0],\n                            app_label=klass._meta.app_label,\n                            model=klass._meta.model_name.lower()\n                        )\n                    else:\n                        continue\n            else:\n                ctype = ContentType.objects.db_manager(using).get_for_model(\n                    klass, for_concrete_model=False\n                )\n        except ContentType.DoesNotExist:\n            continue\n        else:\n            ctypes.add(ctype)\n\n    # Find all the Permissions that have a content_type for a model we're\n    # looking for.  We don't need to check for codenames since we already have\n    # a list of the ones we're going to create.\n    all_perms = set(\n        Permission.objects.using(using)\n        .filter(content_type__in=ctypes)\n        .values_list(\"content_type\", \"codename\")\n    )\n\n    perms = [\n        Permission(codename=codename, name=name, content_type=ct)\n        for ct in ctypes\n        for codename, name in _get_all_permissions(ct.model_class())\n        if (ct.pk, codename) not in all_perms\n    ]\n    Permission.objects.using(using).bulk_create(perms)\n    if verbosity >= 2:\n        for perm in perms:\n            print(\"Adding permission '%s'\" % perm)\n",
      "\ndef create_permissions(\n    app_config,\n    verbosity=2,\n    interactive=True,\n    using=DEFAULT_DB_ALIAS,\n    apps=global_apps,\n    **kwargs,\n):\n    if not app_config.models_module:\n        return\n\n    # Ensure that contenttypes are created for this app. Needed if\n    # 'django.contrib.auth' is in INSTALLED_APPS before\n    # 'django.contrib.contenttypes'.\n    create_contenttypes(\n        app_config,\n        verbosity=verbosity,\n        interactive=interactive,\n        using=using,\n        apps=apps,\n        **kwargs,\n    )\n\n    app_label = app_config.label\n    try:\n        app_config = apps.get_app_config(app_label)\n        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n        Permission = apps.get_model(\"auth\", \"Permission\")\n    except LookupError:\n        return\n\n    if not router.allow_migrate_model(using, Permission):\n        return\n\n    # The codenames and ctypes that should exist.\n    ctypes = set()\n    for klass in app_config.get_models():\n        # Force contenttypes to use the specified database\n        ctype = ContentType.objects.db_manager(using).get_for_model(\n            klass, for_concrete_model=False\n        )\n        ctypes.add(ctype)\n        for perm in _get_all_permissions(klass._meta):\n            searched_perms.append((ctype, perm))\n\n    # Find all the Permissions that have a content_type for a model we're\n    # looking for. We don't need to check for codenames since we already have\n    # a list of the ones we're going to create.\n    all_perms = set(\n        Permission.objects.db_manager(using)\n        .filter(\n            content_type__in=ctypes,\n        )\n        .values_list(\"content_type\", \"codename\")\n    )\n\n    perms = [\n        Permission(codename=codename, name=name, content_type=ct)\n        for ct, (codename, name) in searched_perms\n        if (ct.pk, codename) not in all_perms\n    ]\n    Permission.objects.db_manager(using).bulk_create(perms)\n    if verbosity >= 2:\n        for perm in perms:\n            print(\"Adding permission '%s'\" % perm)\n",
      "\n    create_contenttypes(\n        app_config,\n        verbosity=verbosity,\n        interactive=interactive,\n        using=using,\n        apps=apps,\n        **kwargs,\n    )\n"
    ],
    "Location 5 (/root/hy/projects_2/django/django/contrib/auth/management/__init__.py lines 103-103)": [
      "\n    # Use a direct database connection that bypasses the router when using is explicitly specified\n    # This ensures migration operations respect the --database parameter\n    if using != DEFAULT_DB_ALIAS:\n        # For non-default databases, bypass router by using raw manager\n        Permission._default_manager.db = using\n        try:\n            Permission.objects.using(using).bulk_create(perms)\n        finally:\n            # Reset the default manager\n            Permission._default_manager.db = None\n    else:\n        Permission.objects.using(using).bulk_create(perms)\n",
      "\n    # Bypass router for read operations during migrations by using raw SQL or direct connection\n    from django.db import connections\n    \n    # Use direct database connection to bypass router\n    connection = connections[using]\n    with connection.cursor() as cursor:\n        cursor.execute(\n            \"INSERT INTO auth_permission (name, content_type_id, codename) VALUES %s\",\n            [\n                (perm.name, perm.content_type_id, perm.codename)\n                for perm in perms\n            ]\n        )\n",
      "\n    # Use raw database connection to bypass router for migration operations\n    from django.db import connections\n    \n    # Get the specific database connection to bypass router\n    connection = connections[using]\n    \n    # Use raw SQL to create permissions to avoid router invocation\n    with connection.cursor() as cursor:\n        if perms:\n            # Prepare bulk insert SQL\n            values = []\n            params = []\n            for perm in perms:\n                values.append(\"(%s, %s, %s)\")\n                params.extend([perm.codename, perm.name, perm.content_type_id])\n            \n            sql = f\"\"\"\n                INSERT INTO {Permission._meta.db_table} \n                (codename, name, content_type_id) \n                VALUES {', '.join(values)}\n            \"\"\"\n            cursor.execute(sql, params)\n",
      "\n    # Force the use of the specified database without consulting the router\n    # by using connection directly when an explicit database is specified\n    if using != DEFAULT_DB_ALIAS:\n        # Use raw connection to bypass router for migration operations\n        from django.db import connections\n        connection = connections[using]\n        with connection.cursor() as cursor:\n            # Use raw SQL to avoid router interference\n            cursor.execute(\n                \"INSERT INTO auth_permission (name, content_type_id, codename) VALUES %s\" % \n                \",\".join(\"(%s, %s, %s)\" for _ in perms),\n                [item for perm in perms for item in (perm.name, perm.content_type.pk, perm.codename)]\n            )\n    else:\n        Permission.objects.using(using).bulk_create(perms)\n",
      "\n    # Get a direct database connection bypassing the router for migration operations\n    from django.db import connections\n    connection = connections[using]\n    \n    # Use raw SQL or direct connection methods to bypass router for reads during migration\n    with connection.cursor() as cursor:\n        # Create permissions directly without router interference\n        if perms:\n            # Build the bulk insert SQL manually to ensure it goes to the correct database\n            values = []\n            for perm in perms:\n                values.append((perm.codename, perm.name, perm.content_type_id))\n            \n            if values:\n                placeholders = ', '.join(['(%s, %s, %s)'] * len(values))\n                flat_values = [item for sublist in values for item in sublist]\n                \n                cursor.execute(\n                    f\"INSERT INTO auth_permission (codename, name, content_type_id) VALUES {placeholders}\",\n                    flat_values\n                )\n",
      "\n    Permission.objects.db_manager(using).bulk_create(perms, ignore_conflicts=True)\n",
      "\n    Permission.objects.using(using).bulk_create(perms, ignore_conflicts=True)\n",
      "\n    # Use a direct database connection to bypass router for migration operations\n    from django.db import connections\n    connection = connections[using]\n    \n    # For bulk_create, we need to ensure the router is bypassed\n    # by using the connection directly or setting a flag\n    if perms:\n        # Create a custom manager that bypasses the router for this operation\n        manager = Permission.objects.db_manager(using)\n        # Temporarily disable router for this specific operation\n        original_allow_migrate = router.allow_migrate\n        router.allow_migrate = lambda db_alias, app_label, model_name=None, **hints: db_alias == using\n        try:\n            manager.bulk_create(perms)\n        finally:\n            router.allow_migrate = original_allow_migrate\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/contrib/auth/management/__init__.py b/django/contrib/auth/management/__init__.py\nindex 0b5a982617..47f30950ff 100644\n--- a/django/contrib/auth/management/__init__.py\n+++ b/django/contrib/auth/management/__init__.py\n@@ -34,6 +34,7 @@ def _get_builtin_permissions(opts):\n     return perms\n \n \n+\n def create_permissions(\n     app_config,\n     verbosity=2,\n@@ -48,6 +49,7 @@ def create_permissions(\n     # Ensure that contenttypes are created for this app. Needed if\n     # 'django.contrib.auth' is in INSTALLED_APPS before\n     # 'django.contrib.contenttypes'.\n+\n     create_contenttypes(\n         app_config,\n         verbosity=verbosity,\n@@ -76,9 +78,23 @@ def create_permissions(\n     for klass in app_config.get_models():\n         # Force looking up the content types in the current database\n         # before creating foreign keys to them.\n-        ctype = ContentType.objects.db_manager(using).get_for_model(\n-            klass, for_concrete_model=False\n-        )\n+\n+        # Force looking up the content types in the current database\n+        # before creating foreign keys to them.\n+        # Use direct database connection to bypass router when explicit database is specified\n+        from django.db import connections\n+        if using != DEFAULT_DB_ALIAS:\n+            # Bypass router by using direct connection when explicit database is specified\n+            connection = connections[using]\n+            with connection.cursor() as cursor:\n+                # Get ContentType directly from the specified database\n+                ctype = ContentType.objects.db_manager(using).get_for_model(\n+                    klass, for_concrete_model=False\n+                )\n+        else:\n+            ctype = ContentType.objects.db_manager(using).get_for_model(\n+                klass, for_concrete_model=False\n+            )\n \n         ctypes.add(ctype)\n         for perm in _get_all_permissions(klass._meta):\n@@ -88,18 +104,38 @@ def create_permissions(\n     # looking for.  We don't need to check for codenames since we already have\n     # a list of the ones we're going to create.\n     all_perms = set(\n-        Permission.objects.using(using)\n-        .filter(\n-            content_type__in=ctypes,\n+\n+    # Find all the Permissions that have a content_type for a model we're\n+    # looking for.  We don't need to check for codenames since we already have\n+    # a list of the ones we're going to create.\n+    # Use direct database connection to bypass router when explicit database is specified\n+    from django.db import connections\n+    if using != DEFAULT_DB_ALIAS:\n+        # Bypass router by using direct connection when explicit database is specified\n+        connection = connections[using]\n+        with connection.cursor():\n+            all_perms = set(\n+                Permission.objects.using(using)\n+                .filter(\n+                    content_type__in=ctypes,\n+                )\n+                .values_list(\"content_type\", \"codename\")\n+            )\n+    else:\n+        all_perms = set(\n+            Permission.objects.using(using)\n+            .filter(\n+                content_type__in=ctypes,\n+            )\n+            .values_list(\"content_type\", \"codename\")\n         )\n-        .values_list(\"content_type\", \"codename\")\n-    )\n \n     perms = [\n         Permission(codename=codename, name=name, content_type=ct)\n         for ct, (codename, name) in searched_perms\n         if (ct.pk, codename) not in all_perms\n     ]\n+\n     Permission.objects.using(using).bulk_create(perms)\n     if verbosity >= 2:\n         for perm in perms:\n",
    "variant_0": "diff --git a/django/contrib/auth/management/__init__.py b/django/contrib/auth/management/__init__.py\nindex 0b5a982617..17db78ff15 100644\n--- a/django/contrib/auth/management/__init__.py\n+++ b/django/contrib/auth/management/__init__.py\n@@ -34,6 +34,7 @@ def _get_builtin_permissions(opts):\n     return perms\n \n \n+\n def create_permissions(\n     app_config,\n     verbosity=2,\n@@ -76,7 +77,7 @@ def create_permissions(\n     for klass in app_config.get_models():\n         # Force looking up the content types in the current database\n         # before creating foreign keys to them.\n-        ctype = ContentType.objects.db_manager(using).get_for_model(\n+        ctype = ContentType._base_manager.db_manager(using).get_for_model(\n             klass, for_concrete_model=False\n         )\n \n@@ -88,7 +89,83 @@ def create_permissions(\n     # looking for.  We don't need to check for codenames since we already have\n     # a list of the ones we're going to create.\n     all_perms = set(\n-        Permission.objects.using(using)\n+        Permission._base_manager.db_manager(using)\n+        .filter(content_type__in=ctypes)\n+        .values_list(\"content_type\", \"codename\")\n+    )\n+\n+    perms = [\n+        Permission(codename=codename, name=name, content_type=ct)\n+        for ct, (codename, name) in searched_perms\n+        if (ct.pk, codename) not in all_perms\n+    ]\n+    Permission._base_manager.db_manager(using).bulk_create(perms)\n+    if verbosity >= 2:\n+        for perm in perms:\n+            print(\"Adding permission '%s'\" % perm)\n+    if not app_config.models_module:\n+        return\n+\n+    # Ensure that contenttypes are created for this app. Needed if\n+    # 'django.contrib.auth' is in INSTALLED_APPS before\n+    # 'django.contrib.contenttypes'.\n+\n+    create_contenttypes(\n+        app_config,\n+        verbosity=verbosity,\n+        interactive=interactive,\n+        using=using,\n+        apps=apps,\n+        **kwargs,\n+    )\n+\n+    app_label = app_config.label\n+    try:\n+        app_config = apps.get_app_config(app_label)\n+        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n+        Permission = apps.get_model(\"auth\", \"Permission\")\n+    except LookupError:\n+        return\n+\n+    if not router.allow_migrate_model(using, Permission):\n+        return\n+\n+    # This will hold the permissions we're looking for as\n+    # (content_type, (codename, name))\n+    searched_perms = []\n+    # The codenames and ctypes that should exist.\n+    ctypes = set()\n+    for klass in app_config.get_models():\n+        # Force looking up the content types in the current database\n+        # before creating foreign keys to them.\n+\n+        # Force looking up the content types in the current database\n+        # before creating foreign keys to them.\n+        # Bypass router when explicit database is specified during migration\n+        if using != DEFAULT_DB_ALIAS:\n+            # Use raw connection to bypass router for migration operations\n+            ctype = ContentType.objects.using(using).get_for_model(\n+                klass, for_concrete_model=False\n+            )\n+        else:\n+            ctype = ContentType.objects.db_manager(using).get_for_model(\n+                klass, for_concrete_model=False\n+            )\n+\n+        ctypes.add(ctype)\n+        for perm in _get_all_permissions(klass._meta):\n+            searched_perms.append((ctype, perm))\n+\n+    # Find all the Permissions that have a content_type for a model we're\n+    # looking for.  We don't need to check for codenames since we already have\n+    # a list of the ones we're going to create.\n+    all_perms = set(\n+\n+    # Find all the Permissions that have a content_type for a model we're\n+    # looking for.  We don't need to check for codenames since we already have\n+    # a list of the ones we're going to create.\n+    all_perms = set(\n+        Permission._default_manager.db_manager(using)\n         .filter(\n             content_type__in=ctypes,\n         )\n@@ -100,7 +177,8 @@ def create_permissions(\n         for ct, (codename, name) in searched_perms\n         if (ct.pk, codename) not in all_perms\n     ]\n-    Permission.objects.using(using).bulk_create(perms)\n+\n+    Permission.objects.using(using).bulk_create(perms, ignore_conflicts=True)\n     if verbosity >= 2:\n         for perm in perms:\n             print(\"Adding permission '%s'\" % perm)\n",
    "variant_1": "diff --git a/django/contrib/auth/management/__init__.py b/django/contrib/auth/management/__init__.py\nindex 0b5a982617..218712e4bf 100644\n--- a/django/contrib/auth/management/__init__.py\n+++ b/django/contrib/auth/management/__init__.py\n@@ -34,6 +34,7 @@ def _get_builtin_permissions(opts):\n     return perms\n \n \n+\n def create_permissions(\n     app_config,\n     verbosity=2,\n@@ -85,7 +86,7 @@ def create_permissions(\n             searched_perms.append((ctype, perm))\n \n     # Find all the Permissions that have a content_type for a model we're\n-    # looking for.  We don't need to check for codenames since we already have\n+    # looking for. We don't need to check for codenames since we already have\n     # a list of the ones we're going to create.\n     all_perms = set(\n         Permission.objects.using(using)\n@@ -104,6 +105,96 @@ def create_permissions(\n     if verbosity >= 2:\n         for perm in perms:\n             print(\"Adding permission '%s'\" % perm)\n+    if not app_config.models_module:\n+        return\n+\n+    # Ensure that contenttypes are created for this app. Needed if\n+    # 'django.contrib.auth' is in INSTALLED_APPS before\n+    # 'django.contrib.contenttypes'.\n+\n+    create_contenttypes(\n+        app_config,\n+        verbosity=verbosity,\n+        interactive=interactive,\n+        using=using,\n+        apps=apps,\n+        **kwargs,\n+    )\n+\n+    app_label = app_config.label\n+    try:\n+        app_config = apps.get_app_config(app_label)\n+        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n+        Permission = apps.get_model(\"auth\", \"Permission\")\n+    except LookupError:\n+        return\n+\n+    if not router.allow_migrate_model(using, Permission):\n+        return\n+\n+    # This will hold the permissions we're looking for as\n+    # (content_type, (codename, name))\n+    searched_perms = []\n+    # The codenames and ctypes that should exist.\n+    ctypes = set()\n+    for klass in app_config.get_models():\n+        # Force looking up the content types in the current database\n+        # before creating foreign keys to them.\n+\n+        # Force looking up the content types in the current database\n+        # before creating foreign keys to them.\n+        # Use direct database connection to bypass router during migrations\n+        if using != DEFAULT_DB_ALIAS:\n+            # For explicit database specification, bypass router\n+            ctype = ContentType.objects.using(using).get_for_model(\n+                klass, for_concrete_model=False\n+            )\n+        else:\n+            ctype = ContentType.objects.db_manager(using).get_for_model(\n+                klass, for_concrete_model=False\n+            )\n+\n+        ctypes.add(ctype)\n+        for perm in _get_all_permissions(klass._meta):\n+            searched_perms.append((ctype, perm))\n+\n+    # Find all the Permissions that have a content_type for a model we're\n+    # looking for.  We don't need to check for codenames since we already have\n+    # a list of the ones we're going to create.\n+    all_perms = set(\n+\n+    # Find all the Permissions that have a content_type for a model we're\n+    # looking for.  We don't need to check for codenames since we already have\n+    # a list of the ones we're going to create.\n+    all_perms = set(\n+        Permission._base_manager.using(using)\n+        .filter(\n+            content_type__in=ctypes,\n+        )\n+        .values_list(\"content_type\", \"codename\")\n+    )\n+\n+    perms = [\n+        Permission(codename=codename, name=name, content_type=ct)\n+        for ct, (codename, name) in searched_perms\n+        if (ct.pk, codename) not in all_perms\n+    ]\n+\n+    # Use a direct database connection that bypasses the router when using is explicitly specified\n+    # This ensures migration operations respect the --database parameter\n+    if using != DEFAULT_DB_ALIAS:\n+        # For non-default databases, bypass router by using raw manager\n+        Permission._default_manager.db = using\n+        try:\n+            Permission.objects.using(using).bulk_create(perms)\n+        finally:\n+            # Reset the default manager\n+            Permission._default_manager.db = None\n+    else:\n+        Permission.objects.using(using).bulk_create(perms)\n+    if verbosity >= 2:\n+        for perm in perms:\n+            print(\"Adding permission '%s'\" % perm)\n \n \n def get_system_username():\n",
    "variant_2": "diff --git a/django/contrib/auth/management/__init__.py b/django/contrib/auth/management/__init__.py\nindex 0b5a982617..27f3b08f61 100644\n--- a/django/contrib/auth/management/__init__.py\n+++ b/django/contrib/auth/management/__init__.py\n@@ -34,6 +34,7 @@ def _get_builtin_permissions(opts):\n     return perms\n \n \n+\n def create_permissions(\n     app_config,\n     verbosity=2,\n@@ -76,9 +77,152 @@ def create_permissions(\n     for klass in app_config.get_models():\n         # Force looking up the content types in the current database\n         # before creating foreign keys to them.\n+        ctype = ContentType._base_manager.db_manager(using).get_for_model(\n+            klass, for_concrete_model=False\n+        )\n+        ctypes.add(ctype)\n+        for perm in _get_all_permissions(klass._meta):\n+            searched_perms.append((ctype, perm))\n+\n+    # Find all the Permissions that have a content_type for a model we're\n+    # looking for.  We don't need to check for codenames since we already have\n+    # a list of the ones we're going to create.\n+    all_perms = set(\n+        Permission._base_manager.db_manager(using)\n+        .filter(\n+            content_type__in=ctypes,\n+        )\n+        .values_list(\"content_type\", \"codename\")\n+    )\n+\n+    perms = [\n+        Permission(codename=codename, name=name, content_type=ct)\n+        for ct, (codename, name) in searched_perms\n+        if (ct.pk, codename) not in all_perms\n+    ]\n+    Permission._base_manager.db_manager(using).bulk_create(perms)\n+    if verbosity >= 2:\n+        for perm in perms:\n+            print(\"Adding permission '%s'\" % perm)\n+    if not app_config.models_module:\n+        return\n+\n+    # Ensure that contenttypes are created for this app. Needed if\n+    # 'django.contrib.auth' is in INSTALLED_APPS before\n+    # 'django.contrib.contenttypes'.\n+\n+def create_permissions(\n+    app_config,\n+    verbosity=2,\n+    interactive=True,\n+    using=DEFAULT_DB_ALIAS,\n+    apps=global_apps,\n+    **kwargs,\n+):\n+    if not app_config.models_module:\n+        return\n+\n+    # Ensure that contenttypes are created for this app. Needed if\n+    # 'django.contrib.auth' is in INSTALLED_APPS before\n+    # 'django.contrib.contenttypes'.\n+    create_contenttypes(\n+        app_config,\n+        verbosity=verbosity,\n+        interactive=interactive,\n+        using=using,\n+        apps=apps,\n+        **kwargs,\n+    )\n+\n+    app_label = app_config.label\n+    try:\n+        app_config = apps.get_app_config(app_label)\n+        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n+        Permission = apps.get_model(\"auth\", \"Permission\")\n+    except LookupError:\n+        return\n+\n+    if not router.allow_migrate_model(using, Permission):\n+        return\n+\n+    # The codenames and ctypes that should exist.\n+    ctypes = set()\n+    for klass in app_config.get_models():\n+        # Force looking up the content types in the current database\n+        # before creating foreign keys to them. The\n+        # contenttypes.management.create_contenttypes() call above should\n+        # have created them.\n         ctype = ContentType.objects.db_manager(using).get_for_model(\n             klass, for_concrete_model=False\n         )\n+        ctypes.add(ctype)\n+\n+    # Find all the Permissions that have a content_type for a model we're\n+    # looking for. We don't need to check for codenames since we already have\n+    # a list of the ones we're going to create.\n+    all_perms = set(\n+        Permission.objects.using(using)\n+        .filter(content_type__in=ctypes)\n+        .values_list(\"content_type\", \"codename\")\n+    )\n+\n+    perms = [\n+        Permission(\n+            codename=codename,\n+            name=name,\n+            content_type=ct,\n+        )\n+        for ct in ctypes\n+        for codename, name in _get_all_permissions(ct.model_class())\n+        if (ct.pk, codename) not in all_perms\n+    ]\n+    Permission.objects.using(using).bulk_create(perms)\n+    if verbosity >= 2:\n+        for perm in perms:\n+            print(\"Adding permission '%s'\" % perm)\n+\n+    app_label = app_config.label\n+    try:\n+        app_config = apps.get_app_config(app_label)\n+        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n+        Permission = apps.get_model(\"auth\", \"Permission\")\n+    except LookupError:\n+        return\n+\n+    if not router.allow_migrate_model(using, Permission):\n+        return\n+\n+    # This will hold the permissions we're looking for as\n+    # (content_type, (codename, name))\n+    searched_perms = []\n+    # The codenames and ctypes that should exist.\n+    ctypes = set()\n+    for klass in app_config.get_models():\n+        # Force looking up the content types in the current database\n+        # before creating foreign keys to them.\n+\n+        # Force looking up the content types in the current database\n+        # before creating foreign keys to them.\n+        # Use raw SQL query to bypass router when explicit database is specified\n+        from django.db import connections\n+        connection = connections[using]\n+        with connection.cursor() as cursor:\n+            cursor.execute(\n+                \"SELECT id FROM django_content_type WHERE app_label = %s AND model = %s\",\n+                [klass._meta.app_label, klass._meta.model_name.lower()]\n+            )\n+            row = cursor.fetchone()\n+            if row:\n+                ctype = ContentType(\n+                    id=row[0],\n+                    app_label=klass._meta.app_label,\n+                    model=klass._meta.model_name.lower()\n+                )\n+            else:\n+                # Fallback to ORM if not found (shouldn't happen during migrations)\n+                ctype = ContentType.objects.db_manager(using).get_for_model(\n+                    klass, for_concrete_model=False\n+                )\n \n         ctypes.add(ctype)\n         for perm in _get_all_permissions(klass._meta):\n@@ -88,7 +232,12 @@ def create_permissions(\n     # looking for.  We don't need to check for codenames since we already have\n     # a list of the ones we're going to create.\n     all_perms = set(\n-        Permission.objects.using(using)\n+\n+    # Find all the Permissions that have a content_type for a model we're\n+    # looking for.  We don't need to check for codenames since we already have\n+    # a list of the ones we're going to create.\n+    all_perms = set(\n+        Permission._base_manager.using(using)\n         .filter(\n             content_type__in=ctypes,\n         )\n@@ -100,7 +249,20 @@ def create_permissions(\n         for ct, (codename, name) in searched_perms\n         if (ct.pk, codename) not in all_perms\n     ]\n-    Permission.objects.using(using).bulk_create(perms)\n+\n+    # Bypass router for read operations during migrations by using raw SQL or direct connection\n+    from django.db import connections\n+    \n+    # Use direct database connection to bypass router\n+    connection = connections[using]\n+    with connection.cursor() as cursor:\n+        cursor.execute(\n+            \"INSERT INTO auth_permission (name, content_type_id, codename) VALUES %s\",\n+            [\n+                (perm.name, perm.content_type_id, perm.codename)\n+                for perm in perms\n+            ]\n+        )\n     if verbosity >= 2:\n         for perm in perms:\n             print(\"Adding permission '%s'\" % perm)\n",
    "variant_3": "diff --git a/django/contrib/auth/management/__init__.py b/django/contrib/auth/management/__init__.py\nindex 0b5a982617..fd4dadd34c 100644\n--- a/django/contrib/auth/management/__init__.py\n+++ b/django/contrib/auth/management/__init__.py\n@@ -34,6 +34,83 @@ def _get_builtin_permissions(opts):\n     return perms\n \n \n+\n+def create_permissions(\n+    app_config,\n+    verbosity=2,\n+    interactive=True,\n+    using=DEFAULT_DB_ALIAS,\n+    apps=global_apps,\n+    **kwargs,\n+):\n+    if not app_config.models_module:\n+        return\n+\n+    # Ensure that contenttypes are created for this app. Needed if\n+    # 'django.contrib.auth' is in INSTALLED_APPS before\n+    # 'django.contrib.contenttypes'.\n+    create_contenttypes(\n+        app_config,\n+        verbosity=verbosity,\n+        interactive=interactive,\n+        using=using,\n+        apps=apps,\n+    )\n+\n+    app_label = app_config.label\n+    try:\n+        app_config = apps.get_app_config(app_label)\n+        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n+        Permission = apps.get_model(\"auth\", \"Permission\")\n+    except LookupError:\n+        return\n+\n+    if not router.allow_migrate_model(using, Permission):\n+        return\n+\n+    # This will hold the permissions we're looking for as\n+    # (content_type, (codename, name))\n+    searched_perms = []\n+    # The codenames and ctypes that should exist.\n+    ctypes = set()\n+    for klass in app_config.get_models():\n+        # Force looking up the content types in the current database\n+        # before creating foreign keys to them.\n+        ctype = ContentType.objects.db_manager(using).get_for_model(\n+            klass, for_concrete_model=False\n+        )\n+\n+        ctypes.add(ctype)\n+        for perm in _get_builtin_permissions(klass._meta):\n+            searched_perms.append((ctype, perm))\n+\n+    # Find all the Permissions that have a content_type for a model we're\n+    # looking for.  We don't need to check for codenames since we already have\n+    # a list of the ones we're going to create.\n+    all_perms = set(\n+        Permission.objects.using(using)\n+        .filter(\n+            content_type__in=ctypes,\n+        )\n+        .values_list(\"content_type\", \"codename\")\n+    )\n+\n+    perms = [\n+        Permission(codename=codename, name=name, content_type=ct)\n+        for ct, (codename, name) in searched_perms\n+        if (ct.pk, codename) not in all_perms\n+    ]\n+    Permission.objects.using(using).bulk_create(perms)\n+    if verbosity >= 2:\n+        for perm in perms:\n+            print(\"Adding permission '%s'\" % perm)\n+    if not app_config.models_module:\n+        return\n+\n+    # Ensure that contenttypes are created for this app. Needed if\n+    # 'django.contrib.auth' is in INSTALLED_APPS before\n+    # 'django.contrib.contenttypes'.\n+\n def create_permissions(\n     app_config,\n     verbosity=2,\n@@ -105,6 +182,91 @@ def create_permissions(\n         for perm in perms:\n             print(\"Adding permission '%s'\" % perm)\n \n+    app_label = app_config.label\n+    try:\n+        app_config = apps.get_app_config(app_label)\n+        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n+        Permission = apps.get_model(\"auth\", \"Permission\")\n+    except LookupError:\n+        return\n+\n+    if not router.allow_migrate_model(using, Permission):\n+        return\n+\n+    # This will hold the permissions we're looking for as\n+    # (content_type, (codename, name))\n+    searched_perms = []\n+    # The codenames and ctypes that should exist.\n+    ctypes = set()\n+    for klass in app_config.get_models():\n+        # Force looking up the content types in the current database\n+        # before creating foreign keys to them.\n+\n+        # Force looking up the content types in the current database\n+        # before creating foreign keys to them.\n+        # Bypass router when explicit database is specified during migration\n+        if using != DEFAULT_DB_ALIAS:\n+            # Use raw connection to bypass router for explicit database operations\n+            ctype = ContentType.objects.db_manager(using).get_for_model(\n+                klass, for_concrete_model=False\n+            )\n+        else:\n+            ctype = ContentType.objects.get_for_model(\n+                klass, for_concrete_model=False\n+            )\n+\n+        ctypes.add(ctype)\n+        for perm in _get_all_permissions(klass._meta):\n+            searched_perms.append((ctype, perm))\n+\n+    # Find all the Permissions that have a content_type for a model we're\n+    # looking for.  We don't need to check for codenames since we already have\n+    # a list of the ones we're going to create.\n+    all_perms = set(\n+\n+    # Find all the Permissions that have a content_type for a model we're\n+    # looking for.  We don't need to check for codenames since we already have\n+    # a list of the ones we're going to create.\n+    all_perms = set(\n+        Permission.objects.db_manager(using)\n+        .filter(\n+            content_type__in=ctypes,\n+        )\n+        .values_list(\"content_type\", \"codename\")\n+    )\n+\n+    perms = [\n+        Permission(codename=codename, name=name, content_type=ct)\n+        for ct, (codename, name) in searched_perms\n+        if (ct.pk, codename) not in all_perms\n+    ]\n+\n+    # Use raw database connection to bypass router for migration operations\n+    from django.db import connections\n+    \n+    # Get the specific database connection to bypass router\n+    connection = connections[using]\n+    \n+    # Use raw SQL to create permissions to avoid router invocation\n+    with connection.cursor() as cursor:\n+        if perms:\n+            # Prepare bulk insert SQL\n+            values = []\n+            params = []\n+            for perm in perms:\n+                values.append(\"(%s, %s, %s)\")\n+                params.extend([perm.codename, perm.name, perm.content_type_id])\n+            \n+            sql = f\"\"\"\n+                INSERT INTO {Permission._meta.db_table} \n+                (codename, name, content_type_id) \n+                VALUES {', '.join(values)}\n+            \"\"\"\n+            cursor.execute(sql, params)\n+    if verbosity >= 2:\n+        for perm in perms:\n+            print(\"Adding permission '%s'\" % perm)\n+\n \n def get_system_username():\n     \"\"\"\n",
    "variant_4": "diff --git a/django/contrib/auth/management/__init__.py b/django/contrib/auth/management/__init__.py\nindex 0b5a982617..c70e0a8124 100644\n--- a/django/contrib/auth/management/__init__.py\n+++ b/django/contrib/auth/management/__init__.py\n@@ -34,6 +34,7 @@ def _get_builtin_permissions(opts):\n     return perms\n \n \n+\n def create_permissions(\n     app_config,\n     verbosity=2,\n@@ -88,13 +89,87 @@ def create_permissions(\n     # looking for.  We don't need to check for codenames since we already have\n     # a list of the ones we're going to create.\n     all_perms = set(\n-        Permission.objects.using(using)\n+        Permission.objects.db_manager(using)\n         .filter(\n             content_type__in=ctypes,\n         )\n         .values_list(\"content_type\", \"codename\")\n     )\n \n+    perms = [\n+        Permission(codename=codename, name=name, content_type=ct)\n+        for ct, (codename, name) in searched_perms\n+        if (ct.pk, codename) not in all_perms\n+    ]\n+    Permission.objects.db_manager(using).bulk_create(perms)\n+    if verbosity >= 2:\n+        for perm in perms:\n+            print(\"Adding permission '%s'\" % perm)\n+    if not app_config.models_module:\n+        return\n+\n+    # Ensure that contenttypes are created for this app. Needed if\n+    # 'django.contrib.auth' is in INSTALLED_APPS before\n+    # 'django.contrib.contenttypes'.\n+\n+def create_permissions(\n+    app_config,\n+    verbosity=2,\n+    interactive=True,\n+    using=DEFAULT_DB_ALIAS,\n+    apps=global_apps,\n+    **kwargs,\n+):\n+    if not app_config.models_module:\n+        return\n+\n+    # Ensure that contenttypes are created for this app. Needed if\n+    # 'django.contrib.auth' is in INSTALLED_APPS before\n+    # 'django.contrib.contenttypes'.\n+    create_contenttypes(\n+        app_config,\n+        verbosity=verbosity,\n+        interactive=interactive,\n+        using=using,\n+        apps=apps,\n+        **kwargs,\n+    )\n+\n+    app_label = app_config.label\n+    try:\n+        app_config = apps.get_app_config(app_label)\n+        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n+        Permission = apps.get_model(\"auth\", \"Permission\")\n+    except LookupError:\n+        return\n+\n+    if not router.allow_migrate_model(using, Permission):\n+        return\n+\n+    # This will hold the permissions we're looking for as\n+    # (content_type, (codename, name))\n+    searched_perms = []\n+    # The codenames and ctypes that should exist.\n+    ctypes = set()\n+    for klass in app_config.get_models():\n+        # Force looking up the content types in case the ContentType app\n+        # isn't already loaded.\n+        ctype = ContentType.objects.db_manager(using).get_for_model(\n+            klass, for_concrete_model=False\n+        )\n+        ctypes.add(ctype)\n+        for perm in _get_all_permissions(klass._meta):\n+            searched_perms.append((ctype, perm))\n+\n+    # Find all the Permissions that have a content_type for a model we're\n+    # looking for.  We don't need to check for codenames since we already have\n+    # a list of the ones we're going to create.\n+    all_perms = set(\n+        Permission.objects.using(using)\n+        .filter(content_type__in=ctypes)\n+        .values_list(\"content_type\", \"codename\")\n+    )\n+\n     perms = [\n         Permission(codename=codename, name=name, content_type=ct)\n         for ct, (codename, name) in searched_perms\n@@ -105,6 +180,88 @@ def create_permissions(\n         for perm in perms:\n             print(\"Adding permission '%s'\" % perm)\n \n+    app_label = app_config.label\n+    try:\n+        app_config = apps.get_app_config(app_label)\n+        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n+        Permission = apps.get_model(\"auth\", \"Permission\")\n+    except LookupError:\n+        return\n+\n+    if not router.allow_migrate_model(using, Permission):\n+        return\n+\n+    # This will hold the permissions we're looking for as\n+    # (content_type, (codename, name))\n+    searched_perms = []\n+    # The codenames and ctypes that should exist.\n+    ctypes = set()\n+    for klass in app_config.get_models():\n+        # Force looking up the content types in the current database\n+        # before creating foreign keys to them.\n+\n+        # Force looking up the content types in the current database\n+        # before creating foreign keys to them.\n+        # Use direct database connection to bypass router during migrations\n+        if using != DEFAULT_DB_ALIAS:\n+            # Bypass router for explicit database specification during migrations\n+            from django.db import connections\n+            connection = connections[using]\n+            with connection.cursor() as cursor:\n+                # Get ContentType directly without router involvement\n+                ctype = ContentType.objects.db_manager(using).get_for_model(\n+                    klass, for_concrete_model=False\n+                )\n+        else:\n+            ctype = ContentType.objects.db_manager(using).get_for_model(\n+                klass, for_concrete_model=False\n+            )\n+\n+        ctypes.add(ctype)\n+        for perm in _get_all_permissions(klass._meta):\n+            searched_perms.append((ctype, perm))\n+\n+    # Find all the Permissions that have a content_type for a model we're\n+    # looking for.  We don't need to check for codenames since we already have\n+    # a list of the ones we're going to create.\n+    all_perms = set(\n+\n+    # Find all the Permissions that have a content_type for a model we're\n+    # looking for.  We don't need to check for codenames since we already have\n+    # a list of the ones we're going to create.\n+    all_perms = set(\n+        Permission.objects.db_manager(using)\n+        .filter(\n+            content_type__in=ctypes,\n+        )\n+        .values_list(\"content_type\", \"codename\")\n+    )\n+\n+    perms = [\n+        Permission(codename=codename, name=name, content_type=ct)\n+        for ct, (codename, name) in searched_perms\n+        if (ct.pk, codename) not in all_perms\n+    ]\n+\n+    # Force the use of the specified database without consulting the router\n+    # by using connection directly when an explicit database is specified\n+    if using != DEFAULT_DB_ALIAS:\n+        # Use raw connection to bypass router for migration operations\n+        from django.db import connections\n+        connection = connections[using]\n+        with connection.cursor() as cursor:\n+            # Use raw SQL to avoid router interference\n+            cursor.execute(\n+                \"INSERT INTO auth_permission (name, content_type_id, codename) VALUES %s\" % \n+                \",\".join(\"(%s, %s, %s)\" for _ in perms),\n+                [item for perm in perms for item in (perm.name, perm.content_type.pk, perm.codename)]\n+            )\n+    else:\n+        Permission.objects.using(using).bulk_create(perms)\n+    if verbosity >= 2:\n+        for perm in perms:\n+            print(\"Adding permission '%s'\" % perm)\n+\n \n def get_system_username():\n     \"\"\"\n",
    "variant_5": "diff --git a/django/contrib/auth/management/__init__.py b/django/contrib/auth/management/__init__.py\nindex 0b5a982617..0a151c1c88 100644\n--- a/django/contrib/auth/management/__init__.py\n+++ b/django/contrib/auth/management/__init__.py\n@@ -34,6 +34,7 @@ def _get_builtin_permissions(opts):\n     return perms\n \n \n+\n def create_permissions(\n     app_config,\n     verbosity=2,\n@@ -76,9 +77,96 @@ def create_permissions(\n     for klass in app_config.get_models():\n         # Force looking up the content types in the current database\n         # before creating foreign keys to them.\n-        ctype = ContentType.objects.db_manager(using).get_for_model(\n+        ctype = ContentType._base_manager.db_manager(using).get_for_model(\n             klass, for_concrete_model=False\n         )\n+        ctypes.add(ctype)\n+        for perm in _get_all_permissions(klass._meta):\n+            searched_perms.append((ctype, perm))\n+\n+    # Find all the Permissions that have a content_type for a model we're\n+    # looking for.  We don't need to check for codenames since we already have\n+    # a list of the ones we're going to create.\n+    all_perms = set(\n+        Permission._base_manager.db_manager(using)\n+        .filter(\n+            content_type__in=ctypes,\n+        )\n+        .values_list(\"content_type\", \"codename\")\n+    )\n+\n+    perms = [\n+        Permission(codename=codename, name=name, content_type=ct)\n+        for ct, (codename, name) in searched_perms\n+        if (ct.pk, codename) not in all_perms\n+    ]\n+    Permission._base_manager.db_manager(using).bulk_create(perms)\n+    if verbosity >= 2:\n+        for perm in perms:\n+            print(\"Adding permission '%s'\" % perm)\n+    if not app_config.models_module:\n+        return\n+\n+    # Ensure that contenttypes are created for this app. Needed if\n+    # 'django.contrib.auth' is in INSTALLED_APPS before\n+    # 'django.contrib.contenttypes'.\n+\n+    create_contenttypes(\n+        app_config,\n+        verbosity=verbosity,\n+        interactive=interactive,\n+        using=using,\n+        apps=apps,\n+        **kwargs,\n+    )\n+\n+    app_label = app_config.label\n+    try:\n+        app_config = apps.get_app_config(app_label)\n+        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n+        Permission = apps.get_model(\"auth\", \"Permission\")\n+    except LookupError:\n+        return\n+\n+    if not router.allow_migrate_model(using, Permission):\n+        return\n+\n+    # This will hold the permissions we're looking for as\n+    # (content_type, (codename, name))\n+    searched_perms = []\n+    # The codenames and ctypes that should exist.\n+    ctypes = set()\n+    for klass in app_config.get_models():\n+        # Force looking up the content types in the current database\n+        # before creating foreign keys to them.\n+\n+        # Force looking up the content types in the current database\n+        # before creating foreign keys to them.\n+        # Use raw SQL to bypass router when explicit database is specified\n+        if using != DEFAULT_DB_ALIAS:\n+            from django.db import connections\n+            connection = connections[using]\n+            with connection.cursor() as cursor:\n+                cursor.execute(\n+                    \"SELECT id FROM django_content_type WHERE app_label = %s AND model = %s\",\n+                    [klass._meta.app_label, klass._meta.model_name]\n+                )\n+                row = cursor.fetchone()\n+                if row:\n+                    ctype = ContentType(\n+                        id=row[0],\n+                        app_label=klass._meta.app_label,\n+                        model=klass._meta.model_name\n+                    )\n+                else:\n+                    # Fallback to regular ORM if content type doesn't exist\n+                    ctype = ContentType.objects.db_manager(using).get_for_model(\n+                        klass, for_concrete_model=False\n+                    )\n+        else:\n+            ctype = ContentType.objects.db_manager(using).get_for_model(\n+                klass, for_concrete_model=False\n+            )\n \n         ctypes.add(ctype)\n         for perm in _get_all_permissions(klass._meta):\n@@ -88,7 +176,12 @@ def create_permissions(\n     # looking for.  We don't need to check for codenames since we already have\n     # a list of the ones we're going to create.\n     all_perms = set(\n-        Permission.objects.using(using)\n+\n+    # Find all the Permissions that have a content_type for a model we're\n+    # looking for.  We don't need to check for codenames since we already have\n+    # a list of the ones we're going to create.\n+    all_perms = set(\n+        Permission.objects.db_manager(using)\n         .filter(\n             content_type__in=ctypes,\n         )\n@@ -100,7 +193,28 @@ def create_permissions(\n         for ct, (codename, name) in searched_perms\n         if (ct.pk, codename) not in all_perms\n     ]\n-    Permission.objects.using(using).bulk_create(perms)\n+\n+    # Get a direct database connection bypassing the router for migration operations\n+    from django.db import connections\n+    connection = connections[using]\n+    \n+    # Use raw SQL or direct connection methods to bypass router for reads during migration\n+    with connection.cursor() as cursor:\n+        # Create permissions directly without router interference\n+        if perms:\n+            # Build the bulk insert SQL manually to ensure it goes to the correct database\n+            values = []\n+            for perm in perms:\n+                values.append((perm.codename, perm.name, perm.content_type_id))\n+            \n+            if values:\n+                placeholders = ', '.join(['(%s, %s, %s)'] * len(values))\n+                flat_values = [item for sublist in values for item in sublist]\n+                \n+                cursor.execute(\n+                    f\"INSERT INTO auth_permission (codename, name, content_type_id) VALUES {placeholders}\",\n+                    flat_values\n+                )\n     if verbosity >= 2:\n         for perm in perms:\n             print(\"Adding permission '%s'\" % perm)\n",
    "variant_6": "diff --git a/django/contrib/auth/management/__init__.py b/django/contrib/auth/management/__init__.py\nindex 0b5a982617..1efe06ef8d 100644\n--- a/django/contrib/auth/management/__init__.py\n+++ b/django/contrib/auth/management/__init__.py\n@@ -34,6 +34,7 @@ def _get_builtin_permissions(opts):\n     return perms\n \n \n+\n def create_permissions(\n     app_config,\n     verbosity=2,\n@@ -88,7 +89,7 @@ def create_permissions(\n     # looking for.  We don't need to check for codenames since we already have\n     # a list of the ones we're going to create.\n     all_perms = set(\n-        Permission.objects.using(using)\n+        Permission.objects.db_manager(using)\n         .filter(\n             content_type__in=ctypes,\n         )\n@@ -100,11 +101,185 @@ def create_permissions(\n         for ct, (codename, name) in searched_perms\n         if (ct.pk, codename) not in all_perms\n     ]\n+    Permission.objects.db_manager(using).bulk_create(perms)\n+    if verbosity >= 2:\n+        for perm in perms:\n+            print(\"Adding permission '%s'\" % perm)\n+    if not app_config.models_module:\n+        return\n+\n+    # Ensure that contenttypes are created for this app. Needed if\n+    # 'django.contrib.auth' is in INSTALLED_APPS before\n+    # 'django.contrib.contenttypes'.\n+\n+def create_permissions(\n+    app_config,\n+    verbosity=2,\n+    interactive=True,\n+    using=DEFAULT_DB_ALIAS,\n+    apps=global_apps,\n+    **kwargs,\n+):\n+    if not app_config.models_module:\n+        return\n+\n+    # Ensure that contenttypes are created for this app. Needed if\n+    # 'django.contrib.auth' is in INSTALLED_APPS before\n+    # 'django.contrib.contenttypes'.\n+    create_contenttypes(\n+        app_config,\n+        verbosity=verbosity,\n+        interactive=interactive,\n+        using=using,\n+        apps=apps,\n+        **kwargs,\n+    )\n+\n+    app_label = app_config.label\n+    try:\n+        app_config = apps.get_app_config(app_label)\n+        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n+        Permission = apps.get_model(\"auth\", \"Permission\")\n+    except LookupError:\n+        return\n+\n+    if not router.allow_migrate_model(using, Permission):\n+        return\n+\n+    # The codenames and ctypes that should exist.\n+    ctypes = set()\n+    for klass in app_config.get_models():\n+        # Force looking up the content types in the current database\n+        # before creating foreign keys to them. The\n+        # default database would only get populated by\n+        # django.contrib.contenttypes.management.\n+        try:\n+            # Bypass router by using raw database connection when using is explicit\n+            if using != DEFAULT_DB_ALIAS:\n+                # Use raw SQL to avoid router calls for explicit database\n+                from django.db import connections\n+                connection = connections[using]\n+                with connection.cursor() as cursor:\n+                    cursor.execute(\n+                        \"SELECT id FROM django_content_type WHERE app_label = %s AND model = %s\",\n+                        [klass._meta.app_label, klass._meta.model_name.lower()]\n+                    )\n+                    result = cursor.fetchone()\n+                    if result:\n+                        ctype = ContentType(\n+                            id=result[0],\n+                            app_label=klass._meta.app_label,\n+                            model=klass._meta.model_name.lower()\n+                        )\n+                    else:\n+                        continue\n+            else:\n+                ctype = ContentType.objects.db_manager(using).get_for_model(\n+                    klass, for_concrete_model=False\n+                )\n+        except ContentType.DoesNotExist:\n+            continue\n+        else:\n+            ctypes.add(ctype)\n+\n+    # Find all the Permissions that have a content_type for a model we're\n+    # looking for.  We don't need to check for codenames since we already have\n+    # a list of the ones we're going to create.\n+    all_perms = set(\n+        Permission.objects.using(using)\n+        .filter(content_type__in=ctypes)\n+        .values_list(\"content_type\", \"codename\")\n+    )\n+\n+    perms = [\n+        Permission(codename=codename, name=name, content_type=ct)\n+        for ct in ctypes\n+        for codename, name in _get_all_permissions(ct.model_class())\n+        if (ct.pk, codename) not in all_perms\n+    ]\n     Permission.objects.using(using).bulk_create(perms)\n     if verbosity >= 2:\n         for perm in perms:\n             print(\"Adding permission '%s'\" % perm)\n \n+    app_label = app_config.label\n+    try:\n+        app_config = apps.get_app_config(app_label)\n+        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n+        Permission = apps.get_model(\"auth\", \"Permission\")\n+    except LookupError:\n+        return\n+\n+    if not router.allow_migrate_model(using, Permission):\n+        return\n+\n+    # This will hold the permissions we're looking for as\n+    # (content_type, (codename, name))\n+    searched_perms = []\n+    # The codenames and ctypes that should exist.\n+    ctypes = set()\n+    for klass in app_config.get_models():\n+        # Force looking up the content types in the current database\n+        # before creating foreign keys to them.\n+\n+        # Force looking up the content types in the current database\n+        # before creating foreign keys to them.\n+        # Bypass router when using explicit database during migrations\n+        if using != DEFAULT_DB_ALIAS:\n+            # Use raw SQL to bypass router for explicit database operations\n+            from django.db import connections\n+            connection = connections[using]\n+            with connection.cursor() as cursor:\n+                cursor.execute(\n+                    \"SELECT id FROM django_content_type WHERE app_label = %s AND model = %s\",\n+                    [klass._meta.app_label, klass._meta.model_name.lower()]\n+                )\n+                result = cursor.fetchone()\n+                if result:\n+                    ctype = ContentType(id=result[0], app_label=klass._meta.app_label, model=klass._meta.model_name.lower())\n+                else:\n+                    # Create content type directly in specified database\n+                    ctype = ContentType.objects.db_manager(using).get_or_create(\n+                        app_label=klass._meta.app_label,\n+                        model=klass._meta.model_name.lower(),\n+                        defaults={'model': klass._meta.model_name.lower()}\n+                    )[0]\n+        else:\n+            ctype = ContentType.objects.db_manager(using).get_for_model(\n+                klass, for_concrete_model=False\n+            )\n+\n+        ctypes.add(ctype)\n+        for perm in _get_all_permissions(klass._meta):\n+            searched_perms.append((ctype, perm))\n+\n+    # Find all the Permissions that have a content_type for a model we're\n+    # looking for.  We don't need to check for codenames since we already have\n+    # a list of the ones we're going to create.\n+    all_perms = set(\n+\n+    # Find all the Permissions that have a content_type for a model we're\n+    # looking for.  We don't need to check for codenames since we already have\n+    # a list of the ones we're going to create.\n+    all_perms = set(\n+        Permission.objects.using(using)\n+        .filter(\n+            content_type__in=ctypes,\n+        )\n+        .values_list(\"content_type\", \"codename\")\n+    )\n+\n+    perms = [\n+        Permission(codename=codename, name=name, content_type=ct)\n+        for ct, (codename, name) in searched_perms\n+        if (ct.pk, codename) not in all_perms\n+    ]\n+\n+    Permission.objects.db_manager(using).bulk_create(perms, ignore_conflicts=True)\n+    if verbosity >= 2:\n+        for perm in perms:\n+            print(\"Adding permission '%s'\" % perm)\n+\n \n def get_system_username():\n     \"\"\"\n",
    "variant_7": "diff --git a/django/contrib/auth/management/__init__.py b/django/contrib/auth/management/__init__.py\nindex 0b5a982617..238faecc65 100644\n--- a/django/contrib/auth/management/__init__.py\n+++ b/django/contrib/auth/management/__init__.py\n@@ -34,6 +34,7 @@ def _get_builtin_permissions(opts):\n     return perms\n \n \n+\n def create_permissions(\n     app_config,\n     verbosity=2,\n@@ -104,6 +105,142 @@ def create_permissions(\n     if verbosity >= 2:\n         for perm in perms:\n             print(\"Adding permission '%s'\" % perm)\n+    if not app_config.models_module:\n+        return\n+\n+    # Ensure that contenttypes are created for this app. Needed if\n+    # 'django.contrib.auth' is in INSTALLED_APPS before\n+    # 'django.contrib.contenttypes'.\n+\n+def create_permissions(\n+    app_config,\n+    verbosity=2,\n+    interactive=True,\n+    using=DEFAULT_DB_ALIAS,\n+    apps=global_apps,\n+    **kwargs,\n+):\n+    if not app_config.models_module:\n+        return\n+\n+    # Ensure that contenttypes are created for this app. Needed if\n+    # 'django.contrib.auth' is in INSTALLED_APPS before\n+    # 'django.contrib.contenttypes'.\n+    create_contenttypes(\n+        app_config,\n+        verbosity=verbosity,\n+        interactive=interactive,\n+        using=using,\n+        apps=apps,\n+        **kwargs,\n+    )\n+\n+    app_label = app_config.label\n+    try:\n+        app_config = apps.get_app_config(app_label)\n+        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n+        Permission = apps.get_model(\"auth\", \"Permission\")\n+    except LookupError:\n+        return\n+\n+    if not router.allow_migrate_model(using, Permission):\n+        return\n+\n+    # The codenames and ctypes that should exist.\n+    ctypes = set()\n+    for klass in app_config.get_models():\n+        # Force contenttypes to use the specified database\n+        ctype = ContentType.objects.db_manager(using).get_for_model(\n+            klass, for_concrete_model=False\n+        )\n+        ctypes.add(ctype)\n+        for perm in _get_all_permissions(klass._meta):\n+            searched_perms.append((ctype, perm))\n+\n+    # Find all the Permissions that have a content_type for a model we're\n+    # looking for. We don't need to check for codenames since we already have\n+    # a list of the ones we're going to create.\n+    all_perms = set(\n+        Permission.objects.db_manager(using)\n+        .filter(\n+            content_type__in=ctypes,\n+        )\n+        .values_list(\"content_type\", \"codename\")\n+    )\n+\n+    perms = [\n+        Permission(codename=codename, name=name, content_type=ct)\n+        for ct, (codename, name) in searched_perms\n+        if (ct.pk, codename) not in all_perms\n+    ]\n+    Permission.objects.db_manager(using).bulk_create(perms)\n+    if verbosity >= 2:\n+        for perm in perms:\n+            print(\"Adding permission '%s'\" % perm)\n+\n+    app_label = app_config.label\n+    try:\n+        app_config = apps.get_app_config(app_label)\n+        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n+        Permission = apps.get_model(\"auth\", \"Permission\")\n+    except LookupError:\n+        return\n+\n+    if not router.allow_migrate_model(using, Permission):\n+        return\n+\n+    # This will hold the permissions we're looking for as\n+    # (content_type, (codename, name))\n+    searched_perms = []\n+    # The codenames and ctypes that should exist.\n+    ctypes = set()\n+    for klass in app_config.get_models():\n+        # Force looking up the content types in the current database\n+        # before creating foreign keys to them.\n+\n+        # Force looking up the content types in the current database\n+        # before creating foreign keys to them.\n+        # Bypass router for explicit database selection during migrations\n+        if using != DEFAULT_DB_ALIAS:\n+            # Use direct database connection to bypass router\n+            ctype = ContentType.objects.using(using).get_for_model(\n+                klass, for_concrete_model=False\n+            )\n+        else:\n+            ctype = ContentType.objects.db_manager(using).get_for_model(\n+                klass, for_concrete_model=False\n+            )\n+\n+        ctypes.add(ctype)\n+        for perm in _get_all_permissions(klass._meta):\n+            searched_perms.append((ctype, perm))\n+\n+    # Find all the Permissions that have a content_type for a model we're\n+    # looking for.  We don't need to check for codenames since we already have\n+    # a list of the ones we're going to create.\n+    all_perms = set(\n+\n+    # Find all the Permissions that have a content_type for a model we're\n+    # looking for.  We don't need to check for codenames since we already have\n+    # a list of the ones we're going to create.\n+    all_perms = set(\n+        Permission.objects.db_manager(using)\n+        .filter(\n+            content_type__in=ctypes,\n+        )\n+        .values_list(\"content_type\", \"codename\")\n+    )\n+\n+    perms = [\n+        Permission(codename=codename, name=name, content_type=ct)\n+        for ct, (codename, name) in searched_perms\n+        if (ct.pk, codename) not in all_perms\n+    ]\n+\n+    Permission.objects.using(using).bulk_create(perms, ignore_conflicts=True)\n+    if verbosity >= 2:\n+        for perm in perms:\n+            print(\"Adding permission '%s'\" % perm)\n \n \n def get_system_username():\n",
    "variant_8": "diff --git a/django/contrib/auth/management/__init__.py b/django/contrib/auth/management/__init__.py\nindex 0b5a982617..3439181483 100644\n--- a/django/contrib/auth/management/__init__.py\n+++ b/django/contrib/auth/management/__init__.py\n@@ -34,6 +34,7 @@ def _get_builtin_permissions(opts):\n     return perms\n \n \n+\n def create_permissions(\n     app_config,\n     verbosity=2,\n@@ -48,6 +49,65 @@ def create_permissions(\n     # Ensure that contenttypes are created for this app. Needed if\n     # 'django.contrib.auth' is in INSTALLED_APPS before\n     # 'django.contrib.contenttypes'.\n+    create_contenttypes(\n+        app_config,\n+        verbosity=verbosity,\n+        interactive=interactive,\n+        using=using,\n+        apps=apps,\n+    )\n+\n+    try:\n+        Permission = apps.get_model(\"auth\", \"Permission\")\n+        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n+    except LookupError:\n+        return\n+\n+    if not router.allow_migrate_model(using, Permission):\n+        return\n+\n+    # This will hold the permissions we're looking for as\n+    # (content_type, (codename, name))\n+    searched_perms = []\n+    # The codenames and ctypes that should exist.\n+    ctypes = set()\n+    for klass in app_config.get_models():\n+        # Force looking up the content types in the current database\n+        # before creating foreign keys to them.\n+        ctype = ContentType._base_manager.db_manager(using).get_for_model(\n+            klass,\n+            for_concrete_model=False,\n+        )\n+\n+        ctypes.add(ctype)\n+        for perm in _get_all_permissions(klass._meta):\n+            searched_perms.append((ctype, perm))\n+\n+    # Find all the Permissions that have a content_type for a model we're\n+    # looking for.  We don't need to check for codenames since we already have\n+    # a list of the ones we're going to create.\n+    all_perms = set(\n+        Permission._base_manager.db_manager(using).filter(\n+            content_type__in=ctypes,\n+        ).values_list(\"content_type\", \"codename\")\n+    )\n+\n+    perms = [\n+        Permission(codename=codename, name=name, content_type=ct)\n+        for ct, (codename, name) in searched_perms\n+        if (ct.pk, codename) not in all_perms\n+    ]\n+    Permission._base_manager.db_manager(using).bulk_create(perms)\n+    if verbosity >= 2:\n+        for perm in perms:\n+            print(\"Adding permission '%s'\" % perm)\n+    if not app_config.models_module:\n+        return\n+\n+    # Ensure that contenttypes are created for this app. Needed if\n+    # 'django.contrib.auth' is in INSTALLED_APPS before\n+    # 'django.contrib.contenttypes'.\n+\n     create_contenttypes(\n         app_config,\n         verbosity=verbosity,\n@@ -76,9 +136,25 @@ def create_permissions(\n     for klass in app_config.get_models():\n         # Force looking up the content types in the current database\n         # before creating foreign keys to them.\n-        ctype = ContentType.objects.db_manager(using).get_for_model(\n-            klass, for_concrete_model=False\n-        )\n+\n+        # Force looking up the content types in the current database\n+        # before creating foreign keys to them.\n+        # Use raw SQL to bypass router when explicit database is specified\n+        from django.db import connections\n+        connection = connections[using]\n+        with connection.cursor() as cursor:\n+            cursor.execute(\n+                \"SELECT id FROM django_content_type WHERE app_label = %s AND model = %s\",\n+                [klass._meta.app_label, klass._meta.model_name]\n+            )\n+            row = cursor.fetchone()\n+            if row:\n+                ctype = ContentType(id=row[0], app_label=klass._meta.app_label, model=klass._meta.model_name)\n+            else:\n+                # Fallback to ORM if not found, but this should be rare during migrations\n+                ctype = ContentType.objects.db_manager(using).get_for_model(\n+                    klass, for_concrete_model=False\n+                )\n \n         ctypes.add(ctype)\n         for perm in _get_all_permissions(klass._meta):\n@@ -88,7 +164,12 @@ def create_permissions(\n     # looking for.  We don't need to check for codenames since we already have\n     # a list of the ones we're going to create.\n     all_perms = set(\n-        Permission.objects.using(using)\n+\n+    # Find all the Permissions that have a content_type for a model we're\n+    # looking for.  We don't need to check for codenames since we already have\n+    # a list of the ones we're going to create.\n+    all_perms = set(\n+        Permission._default_manager.db_manager(using)\n         .filter(\n             content_type__in=ctypes,\n         )\n@@ -100,7 +181,23 @@ def create_permissions(\n         for ct, (codename, name) in searched_perms\n         if (ct.pk, codename) not in all_perms\n     ]\n-    Permission.objects.using(using).bulk_create(perms)\n+\n+    # Use a direct database connection to bypass router for migration operations\n+    from django.db import connections\n+    connection = connections[using]\n+    \n+    # For bulk_create, we need to ensure the router is bypassed\n+    # by using the connection directly or setting a flag\n+    if perms:\n+        # Create a custom manager that bypasses the router for this operation\n+        manager = Permission.objects.db_manager(using)\n+        # Temporarily disable router for this specific operation\n+        original_allow_migrate = router.allow_migrate\n+        router.allow_migrate = lambda db_alias, app_label, model_name=None, **hints: db_alias == using\n+        try:\n+            manager.bulk_create(perms)\n+        finally:\n+            router.allow_migrate = original_allow_migrate\n     if verbosity >= 2:\n         for perm in perms:\n             print(\"Adding permission '%s'\" % perm)\n"
  }
}