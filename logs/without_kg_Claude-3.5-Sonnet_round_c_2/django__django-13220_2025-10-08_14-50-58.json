{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/django/django/core/exceptions.py lines 99-184)": "\nclass ValidationError(Exception):\n    \"\"\"An error while validating data.\"\"\"\n    def __init__(self, message, code=None, params=None):\n        \"\"\"\n        The `message` argument can be a single error, a list of errors, or a\n        dictionary that maps field names to lists of errors. What we define as\n        an \"error\" can be either a simple string or an instance of\n        ValidationError with its message attribute set, and what we define as\n        list or dictionary can be an actual `list` or `dict` or an instance\n        of ValidationError with its `error_list` or `error_dict` attribute set.\n        \"\"\"\n        super().__init__(message, code, params)\n\n        if isinstance(message, ValidationError):\n            if hasattr(message, 'error_dict'):\n                message = message.error_dict\n            elif not hasattr(message, 'message'):\n                message = message.error_list\n            else:\n                message, code, params = message.message, message.code, message.params\n\n        if isinstance(message, dict):\n            self.error_dict = {}\n            for field, messages in message.items():\n                if not isinstance(messages, ValidationError):\n                    messages = ValidationError(messages)\n                self.error_dict[field] = messages.error_list\n\n        elif isinstance(message, list):\n            self.error_list = []\n            for message in message:\n                # Normalize plain strings to instances of ValidationError.\n                if not isinstance(message, ValidationError):\n                    message = ValidationError(message)\n                if hasattr(message, 'error_dict'):\n                    self.error_list.extend(sum(message.error_dict.values(), []))\n                else:\n                    self.error_list.extend(message.error_list)\n\n        else:\n            self.message = message\n            self.code = code\n            self.params = params\n            self.error_list = [self]\n\n    @property\n    def message_dict(self):\n        # Trigger an AttributeError if this ValidationError\n        # doesn't have an error_dict.\n        getattr(self, 'error_dict')\n\n        return dict(self)\n\n    @property\n    def messages(self):\n        if hasattr(self, 'error_dict'):\n            return sum(dict(self).values(), [])\n        return list(self)\n\n    def update_error_dict(self, error_dict):\n        if hasattr(self, 'error_dict'):\n            for field, error_list in self.error_dict.items():\n                error_dict.setdefault(field, []).extend(error_list)\n        else:\n            error_dict.setdefault(NON_FIELD_ERRORS, []).extend(self.error_list)\n        return error_dict\n\n    def __iter__(self):\n        if hasattr(self, 'error_dict'):\n            for field, errors in self.error_dict.items():\n                yield field, list(ValidationError(errors))\n        else:\n            for error in self.error_list:\n                message = error.message\n                if error.params:\n                    message %= error.params\n                yield str(message)\n\n    def __str__(self):\n        if hasattr(self, 'error_dict'):\n            return repr(dict(self))\n        return repr(list(self))\n\n    def __repr__(self):\n        return 'ValidationError(%s)' % self\n\n    def __eq__(self, other):\n        if not isinstance(other, ValidationError):\n            return False\n        \n        # Both have error_dict\n        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n            if set(self.error_dict.keys()) != set(other.error_dict.keys()):\n                return False\n            for field in self.error_dict:\n                self_messages = set(str(msg) for msg in self.error_dict[field])\n                other_messages = set(str(msg) for msg in other.error_dict[field])\n                if self_messages != other_messages:\n                    return False\n            return True\n        \n        # Both have error_list\n        elif hasattr(self, 'error_list') and hasattr(other, 'error_list') and \\\n             not hasattr(self, 'error_dict') and not hasattr(other, 'error_dict'):\n            self_messages = set(str(msg) for msg in self.messages)\n            other_messages = set(str(msg) for msg in other.messages)\n            return self_messages == other_messages\n        \n        # Mixed forms - normalize using message_dict or messages\n        else:\n            try:\n                # Try to compare as dicts if both can be converted\n                if hasattr(self, 'error_dict') or hasattr(other, 'error_dict'):\n                    self_dict = self.message_dict if hasattr(self, 'error_dict') else {NON_FIELD_ERRORS: self.messages}\n                    other_dict = other.message_dict if hasattr(other, 'error_dict') else {NON_FIELD_ERRORS: other.messages}\n                    \n                    if set(self_dict.keys()) != set(other_dict.keys()):\n                        return False\n                    for field in self_dict:\n                        self_messages = set(str(msg) for msg in self_dict[field])\n                        other_messages = set(str(msg) for msg in other_dict[field])\n                        if self_messages != other_messages:\n                            return False\n                    return True\n                else:\n                    # Compare as message lists\n                    self_messages = set(str(msg) for msg in self.messages)\n                    other_messages = set(str(msg) for msg in other.messages)\n                    return self_messages == other_messages\n            except AttributeError:\n                return False\n\n    def __hash__(self):\n        if hasattr(self, 'error_dict'):\n            items = []\n            for field, errors in sorted(self.error_dict.items()):\n                field_messages = tuple(sorted(str(msg) for msg in errors))\n                items.append((field, field_messages))\n            return hash(tuple(items))\n        else:\n            messages = tuple(sorted(str(msg) for msg in self.messages))\n            return hash(messages)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/django/django/core/exceptions.py lines 99-184)": [
      "\nclass ValidationError(Exception):\n    \"\"\"An error while validating data.\"\"\"\n    def __init__(self, message, code=None, params=None):\n        \"\"\"\n        The `message` argument can be a single error, a list of errors, or a\n        dictionary that maps field names to lists of errors. What we define as\n        an \"error\" can be either a simple string or an instance of\n        ValidationError with its message attribute set, and what we define as\n        list or dictionary can be an actual `list` or `dict` or an instance\n        of ValidationError with its `error_list` or `error_dict` attribute set.\n        \"\"\"\n        super().__init__(message, code, params)\n\n        if isinstance(message, ValidationError):\n            if hasattr(message, 'error_dict'):\n                message = message.error_dict\n            elif not hasattr(message, 'message'):\n                message = message.error_list\n            else:\n                message, code, params = message.message, message.code, message.params\n\n        if isinstance(message, dict):\n            self.error_dict = {}\n            for field, messages in message.items():\n                if not isinstance(messages, ValidationError):\n                    messages = ValidationError(messages)\n                self.error_dict[field] = messages.error_list\n\n        elif isinstance(message, list):\n            self.error_list = []\n            for message in message:\n                # Normalize plain strings to instances of ValidationError.\n                if not isinstance(message, ValidationError):\n                    message = ValidationError(message)\n                if hasattr(message, 'error_dict'):\n                    self.error_list.extend(sum(message.error_dict.values(), []))\n                else:\n                    self.error_list.extend(message.error_list)\n\n        else:\n            self.message = message\n            self.code = code\n            self.params = params\n            self.error_list = [self]\n\n    @property\n    def message_dict(self):\n        # Trigger an AttributeError if this ValidationError\n        # doesn't have an error_dict.\n        getattr(self, 'error_dict')\n\n        return dict(self)\n\n    @property\n    def messages(self):\n        if hasattr(self, 'error_dict'):\n            return sum(dict(self).values(), [])\n        return list(self)\n\n    def update_error_dict(self, error_dict):\n        if hasattr(self, 'error_dict'):\n            for field, error_list in self.error_dict.items():\n                error_dict.setdefault(field, []).extend(error_list)\n        else:\n            error_dict.setdefault(NON_FIELD_ERRORS, []).extend(self.error_list)\n        return error_dict\n\n    def __iter__(self):\n        if hasattr(self, 'error_dict'):\n            for field, errors in self.error_dict.items():\n                yield field, list(ValidationError(errors))\n        else:\n            for error in self.error_list:\n                message = error.message\n                if error.params:\n                    message %= error.params\n                yield str(message)\n\n    def __str__(self):\n        if hasattr(self, 'error_dict'):\n            return repr(dict(self))\n        return repr(list(self))\n\n    def __repr__(self):\n        return 'ValidationError(%s)' % self\n\n    def __eq__(self, other):\n        if not isinstance(other, ValidationError):\n            return False\n        \n        # If both have error_dict, compare as dictionaries\n        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n            if set(self.error_dict.keys()) != set(other.error_dict.keys()):\n                return False\n            for field in self.error_dict.keys():\n                self_messages = set(str(msg) for msg in self.error_dict[field])\n                other_messages = set(str(msg) for msg in other.error_dict[field])\n                if self_messages != other_messages:\n                    return False\n            return True\n        \n        # If neither has error_dict, compare as lists/single errors\n        elif not hasattr(self, 'error_dict') and not hasattr(other, 'error_dict'):\n            self_messages = set(str(msg) for msg in self.messages)\n            other_messages = set(str(msg) for msg in other.messages)\n            return self_messages == other_messages\n        \n        # Mixed forms - normalize to message comparison\n        else:\n            try:\n                # Try to compare using message_dict if possible\n                if hasattr(self, 'error_dict'):\n                    self_dict = dict(self)\n                    other_dict = {NON_FIELD_ERRORS: other.messages}\n                else:\n                    self_dict = {NON_FIELD_ERRORS: self.messages}\n                    other_dict = dict(other)\n                \n                if set(self_dict.keys()) != set(other_dict.keys()):\n                    return False\n                \n                for field in self_dict.keys():\n                    self_messages = set(str(msg) for msg in self_dict[field])\n                    other_messages = set(str(msg) for msg in other_dict[field])\n                    if self_messages != other_messages:\n                        return False\n                return True\n            except:\n                # Fallback to simple message comparison\n                self_messages = set(str(msg) for msg in self.messages)\n                other_messages = set(str(msg) for msg in other.messages)\n                return self_messages == other_messages\n\n    def __hash__(self):\n        if hasattr(self, 'error_dict'):\n            # Create a frozenset of (field, frozenset(messages)) tuples\n            items = []\n            for field, messages in self.error_dict.items():\n                message_set = frozenset(str(msg) for msg in messages)\n                items.append((field, message_set))\n            return hash(frozenset(items))\n        else:\n            # Hash the set of messages for list/single error forms\n            message_set = frozenset(str(msg) for msg in self.messages)\n            return hash(message_set)\n",
      "\nclass ValidationError(Exception):\n    \"\"\"An error while validating data.\"\"\"\n    def __init__(self, message, code=None, params=None):\n        \"\"\"\n        The `message` argument can be a single error, a list of errors, or a\n        dictionary that maps field names to lists of errors. What we define as\n        an \"error\" can be either a simple string or an instance of\n        ValidationError with its message attribute set, and what we define as\n        list or dictionary can be an actual `list` or `dict` or an instance\n        of ValidationError with its `error_list` or `error_dict` attribute set.\n        \"\"\"\n        super().__init__(message, code, params)\n\n        if isinstance(message, ValidationError):\n            if hasattr(message, 'error_dict'):\n                message = message.error_dict\n            elif not hasattr(message, 'message'):\n                message = message.error_list\n            else:\n                message, code, params = message.message, message.code, message.params\n\n        if isinstance(message, dict):\n            self.error_dict = {}\n            for field, messages in message.items():\n                if not isinstance(messages, ValidationError):\n                    messages = ValidationError(messages)\n                self.error_dict[field] = messages.error_list\n\n        elif isinstance(message, list):\n            self.error_list = []\n            for message in message:\n                # Normalize plain strings to instances of ValidationError.\n                if not isinstance(message, ValidationError):\n                    message = ValidationError(message)\n                if hasattr(message, 'error_dict'):\n                    self.error_list.extend(sum(message.error_dict.values(), []))\n                else:\n                    self.error_list.extend(message.error_list)\n\n        else:\n            self.message = message\n            self.code = code\n            self.params = params\n            self.error_list = [self]\n\n    @property\n    def message_dict(self):\n        # Trigger an AttributeError if this ValidationError\n        # doesn't have an error_dict.\n        getattr(self, 'error_dict')\n\n        return dict(self)\n\n    @property\n    def messages(self):\n        if hasattr(self, 'error_dict'):\n            return sum(dict(self).values(), [])\n        return list(self)\n\n    def update_error_dict(self, error_dict):\n        if hasattr(self, 'error_dict'):\n            for field, error_list in self.error_dict.items():\n                error_dict.setdefault(field, []).extend(error_list)\n        else:\n            error_dict.setdefault(NON_FIELD_ERRORS, []).extend(self.error_list)\n        return error_dict\n\n    def __iter__(self):\n        if hasattr(self, 'error_dict'):\n            for field, errors in self.error_dict.items():\n                yield field, list(ValidationError(errors))\n        else:\n            for error in self.error_list:\n                message = error.message\n                if error.params:\n                    message %= error.params\n                yield str(message)\n\n    def __str__(self):\n        if hasattr(self, 'error_dict'):\n            return repr(dict(self))\n        return repr(list(self))\n\n    def __repr__(self):\n        return 'ValidationError(%s)' % self\n\n    def __eq__(self, other):\n        if not isinstance(other, ValidationError):\n            return False\n        \n        # Both have error_dict (dictionary form)\n        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n            if set(self.error_dict.keys()) != set(other.error_dict.keys()):\n                return False\n            for field in self.error_dict.keys():\n                self_messages = set(str(error) for error in self.error_dict[field])\n                other_messages = set(str(error) for error in other.error_dict[field])\n                if self_messages != other_messages:\n                    return False\n            return True\n        \n        # Both have error_list but not error_dict (list form)\n        elif (hasattr(self, 'error_list') and not hasattr(self, 'error_dict') and\n              hasattr(other, 'error_list') and not hasattr(other, 'error_dict')):\n            self_messages = set(str(error) for error in self.error_list)\n            other_messages = set(str(error) for error in other.error_list)\n            return self_messages == other_messages\n        \n        # Both are single errors (neither has error_dict)\n        elif (not hasattr(self, 'error_dict') and not hasattr(other, 'error_dict') and\n              len(getattr(self, 'error_list', [])) == 1 and len(getattr(other, 'error_list', [])) == 1):\n            return (self.message == other.message and \n                    self.code == other.code and \n                    self.params == other.params)\n        \n        # Mixed forms - normalize using messages property for order-independent comparison\n        else:\n            self_messages = set(self.messages)\n            other_messages = set(other.messages)\n            return self_messages == other_messages\n\n    def __hash__(self):\n        if hasattr(self, 'error_dict'):\n            # For dictionary form, hash based on sorted field-message pairs\n            items = []\n            for field, errors in self.error_dict.items():\n                field_messages = tuple(sorted(str(error) for error in errors))\n                items.append((field, field_messages))\n            return hash(tuple(sorted(items)))\n        elif hasattr(self, 'error_list') and len(self.error_list) > 1:\n            # For list form, hash based on sorted messages\n            messages = tuple(sorted(str(error) for error in self.error_list))\n            return hash(messages)\n        else:\n            # For single error form\n            return hash((self.message, self.code, tuple(sorted(self.params.items())) if self.params else None))\n",
      "\nclass ValidationError(Exception):\n    \"\"\"An error while validating data.\"\"\"\n    def __init__(self, message, code=None, params=None):\n        \"\"\"\n        The `message` argument can be a single error, a list of errors, or a\n        dictionary that maps field names to lists of errors. What we define as\n        an \"error\" can be either a simple string or an instance of\n        ValidationError with its message attribute set, and what we define as\n        list or dictionary can be an actual `list` or `dict` or an instance\n        of ValidationError with its `error_list` or `error_dict` attribute set.\n        \"\"\"\n        super().__init__(message, code, params)\n\n        if isinstance(message, ValidationError):\n            if hasattr(message, 'error_dict'):\n                message = message.error_dict\n            elif not hasattr(message, 'message'):\n                message = message.error_list\n            else:\n                message, code, params = message.message, message.code, message.params\n\n        if isinstance(message, dict):\n            self.error_dict = {}\n            for field, messages in message.items():\n                if not isinstance(messages, ValidationError):\n                    messages = ValidationError(messages)\n                self.error_dict[field] = messages.error_list\n\n        elif isinstance(message, list):\n            self.error_list = []\n            for message in message:\n                # Normalize plain strings to instances of ValidationError.\n                if not isinstance(message, ValidationError):\n                    message = ValidationError(message)\n                if hasattr(message, 'error_dict'):\n                    self.error_list.extend(sum(message.error_dict.values(), []))\n                else:\n                    self.error_list.extend(message.error_list)\n\n        else:\n            self.message = message\n            self.code = code\n            self.params = params\n            self.error_list = [self]\n\n    @property\n    def message_dict(self):\n        # Trigger an AttributeError if this ValidationError\n        # doesn't have an error_dict.\n        getattr(self, 'error_dict')\n\n        return dict(self)\n\n    @property\n    def messages(self):\n        if hasattr(self, 'error_dict'):\n            return sum(dict(self).values(), [])\n        return list(self)\n\n    def update_error_dict(self, error_dict):\n        if hasattr(self, 'error_dict'):\n            for field, error_list in self.error_dict.items():\n                error_dict.setdefault(field, []).extend(error_list)\n        else:\n            error_dict.setdefault(NON_FIELD_ERRORS, []).extend(self.error_list)\n        return error_dict\n\n    def __iter__(self):\n        if hasattr(self, 'error_dict'):\n            for field, errors in self.error_dict.items():\n                yield field, list(ValidationError(errors))\n        else:\n            for error in self.error_list:\n                message = error.message\n                if error.params:\n                    message %= error.params\n                yield str(message)\n\n    def __str__(self):\n        if hasattr(self, 'error_dict'):\n            return repr(dict(self))\n        return repr(list(self))\n\n    def __repr__(self):\n        return 'ValidationError(%s)' % self\n\n    def __eq__(self, other):\n        if not isinstance(other, ValidationError):\n            return False\n        \n        # Both have error_dict - compare as dictionaries\n        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n            if set(self.error_dict.keys()) != set(other.error_dict.keys()):\n                return False\n            for field in self.error_dict:\n                self_messages = set(str(msg) for msg in self.error_dict[field])\n                other_messages = set(str(msg) for msg in other.error_dict[field])\n                if self_messages != other_messages:\n                    return False\n            return True\n        \n        # Both have error_list - compare as sets\n        elif hasattr(self, 'error_list') and hasattr(other, 'error_list'):\n            # Handle single error case (error_list contains [self])\n            if len(self.error_list) == 1 and self.error_list[0] is self and \\\n               len(other.error_list) == 1 and other.error_list[0] is other:\n                return (self.message == other.message and \n                        self.code == other.code and \n                        self.params == other.params)\n            \n            # Compare error lists as sets\n            self_messages = set(str(error) for error in self.error_list)\n            other_messages = set(str(error) for error in other.error_list)\n            return self_messages == other_messages\n        \n        # Mixed types - normalize using messages property and compare as sets\n        else:\n            self_messages = set(self.messages)\n            other_messages = set(other.messages)\n            return self_messages == other_messages\n\n    def __hash__(self):\n        if hasattr(self, 'error_dict'):\n            # Create a frozenset of (field, frozenset(messages)) tuples\n            items = []\n            for field, error_list in self.error_dict.items():\n                messages = frozenset(str(msg) for msg in error_list)\n                items.append((field, messages))\n            return hash(frozenset(items))\n        elif hasattr(self, 'error_list') and len(self.error_list) == 1 and self.error_list[0] is self:\n            # Single error case\n            return hash((self.message, self.code, self.params))\n        else:\n            # Multiple errors case\n            return hash(frozenset(str(error) for error in self.error_list))\n",
      "\nclass ValidationError(Exception):\n    \"\"\"An error while validating data.\"\"\"\n    def __init__(self, message, code=None, params=None):\n        \"\"\"\n        The `message` argument can be a single error, a list of errors, or a\n        dictionary that maps field names to lists of errors. What we define as\n        an \"error\" can be either a simple string or an instance of\n        ValidationError with its message attribute set, and what we define as\n        list or dictionary can be an actual `list` or `dict` or an instance\n        of ValidationError with its `error_list` or `error_dict` attribute set.\n        \"\"\"\n        super().__init__(message, code, params)\n\n        if isinstance(message, ValidationError):\n            if hasattr(message, 'error_dict'):\n                message = message.error_dict\n            elif not hasattr(message, 'message'):\n                message = message.error_list\n            else:\n                message, code, params = message.message, message.code, message.params\n\n        if isinstance(message, dict):\n            self.error_dict = {}\n            for field, messages in message.items():\n                if not isinstance(messages, ValidationError):\n                    messages = ValidationError(messages)\n                self.error_dict[field] = messages.error_list\n\n        elif isinstance(message, list):\n            self.error_list = []\n            for message in message:\n                # Normalize plain strings to instances of ValidationError.\n                if not isinstance(message, ValidationError):\n                    message = ValidationError(message)\n                if hasattr(message, 'error_dict'):\n                    self.error_list.extend(sum(message.error_dict.values(), []))\n                else:\n                    self.error_list.extend(message.error_list)\n\n        else:\n            self.message = message\n            self.code = code\n            self.params = params\n            self.error_list = [self]\n\n    @property\n    def message_dict(self):\n        # Trigger an AttributeError if this ValidationError\n        # doesn't have an error_dict.\n        getattr(self, 'error_dict')\n\n        return dict(self)\n\n    @property\n    def messages(self):\n        if hasattr(self, 'error_dict'):\n            return sum(dict(self).values(), [])\n        return list(self)\n\n    def update_error_dict(self, error_dict):\n        if hasattr(self, 'error_dict'):\n            for field, error_list in self.error_dict.items():\n                error_dict.setdefault(field, []).extend(error_list)\n        else:\n            error_dict.setdefault(NON_FIELD_ERRORS, []).extend(self.error_list)\n        return error_dict\n\n    def __iter__(self):\n        if hasattr(self, 'error_dict'):\n            for field, errors in self.error_dict.items():\n                yield field, list(ValidationError(errors))\n        else:\n            for error in self.error_list:\n                message = error.message\n                if error.params:\n                    message %= error.params\n                yield str(message)\n\n    def __str__(self):\n        if hasattr(self, 'error_dict'):\n            return repr(dict(self))\n        return repr(list(self))\n\n    def __repr__(self):\n        return 'ValidationError(%s)' % self\n\n    def __eq__(self, other):\n        if not isinstance(other, ValidationError):\n            return False\n        \n        # Both have error_dict\n        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n            if set(self.error_dict.keys()) != set(other.error_dict.keys()):\n                return False\n            for field in self.error_dict:\n                self_messages = set(str(msg) for msg in self.error_dict[field])\n                other_messages = set(str(msg) for msg in other.error_dict[field])\n                if self_messages != other_messages:\n                    return False\n            return True\n        \n        # Both have error_list (but not error_dict)\n        elif hasattr(self, 'error_list') and hasattr(other, 'error_list') and \\\n             not hasattr(self, 'error_dict') and not hasattr(other, 'error_dict'):\n            self_messages = set(str(msg) for msg in self.error_list)\n            other_messages = set(str(msg) for msg in other.error_list)\n            return self_messages == other_messages\n        \n        # Single error comparison (both have message, code, params)\n        elif hasattr(self, 'message') and hasattr(other, 'message') and \\\n             not hasattr(self, 'error_dict') and not hasattr(other, 'error_dict'):\n            return (self.message == other.message and \n                    self.code == other.code and \n                    self.params == other.params)\n        \n        # Mixed forms - normalize using messages property for comparison\n        else:\n            self_messages = set(self.messages)\n            other_messages = set(other.messages)\n            return self_messages == other_messages\n\n    def __hash__(self):\n        if hasattr(self, 'error_dict'):\n            # Hash based on sorted field-message pairs\n            items = []\n            for field in sorted(self.error_dict.keys()):\n                field_messages = tuple(sorted(str(msg) for msg in self.error_dict[field]))\n                items.append((field, field_messages))\n            return hash(tuple(items))\n        elif hasattr(self, 'error_list') and len(self.error_list) > 1:\n            # Hash based on sorted messages\n            return hash(tuple(sorted(str(msg) for msg in self.error_list)))\n        else:\n            # Single error\n            return hash((self.message, self.code, self.params))\n",
      "\nclass ValidationError(Exception):\n    \"\"\"An error while validating data.\"\"\"\n    def __init__(self, message, code=None, params=None):\n        \"\"\"\n        The `message` argument can be a single error, a list of errors, or a\n        dictionary that maps field names to lists of errors. What we define as\n        an \"error\" can be either a simple string or an instance of\n        ValidationError with its message attribute set, and what we define as\n        list or dictionary can be an actual `list` or `dict` or an instance\n        of ValidationError with its `error_list` or `error_dict` attribute set.\n        \"\"\"\n        super().__init__(message, code, params)\n\n        if isinstance(message, ValidationError):\n            if hasattr(message, 'error_dict'):\n                message = message.error_dict\n            elif not hasattr(message, 'message'):\n                message = message.error_list\n            else:\n                message, code, params = message.message, message.code, message.params\n\n        if isinstance(message, dict):\n            self.error_dict = {}\n            for field, messages in message.items():\n                if not isinstance(messages, ValidationError):\n                    messages = ValidationError(messages)\n                self.error_dict[field] = messages.error_list\n\n        elif isinstance(message, list):\n            self.error_list = []\n            for message in message:\n                # Normalize plain strings to instances of ValidationError.\n                if not isinstance(message, ValidationError):\n                    message = ValidationError(message)\n                if hasattr(message, 'error_dict'):\n                    self.error_list.extend(sum(message.error_dict.values(), []))\n                else:\n                    self.error_list.extend(message.error_list)\n\n        else:\n            self.message = message\n            self.code = code\n            self.params = params\n            self.error_list = [self]\n\n    @property\n    def message_dict(self):\n        # Trigger an AttributeError if this ValidationError\n        # doesn't have an error_dict.\n        getattr(self, 'error_dict')\n\n        return dict(self)\n\n    @property\n    def messages(self):\n        if hasattr(self, 'error_dict'):\n            return sum(dict(self).values(), [])\n        return list(self)\n\n    def update_error_dict(self, error_dict):\n        if hasattr(self, 'error_dict'):\n            for field, error_list in self.error_dict.items():\n                error_dict.setdefault(field, []).extend(error_list)\n        else:\n            error_dict.setdefault(NON_FIELD_ERRORS, []).extend(self.error_list)\n        return error_dict\n\n    def __iter__(self):\n        if hasattr(self, 'error_dict'):\n            for field, errors in self.error_dict.items():\n                yield field, list(ValidationError(errors))\n        else:\n            for error in self.error_list:\n                message = error.message\n                if error.params:\n                    message %= error.params\n                yield str(message)\n\n    def __str__(self):\n        if hasattr(self, 'error_dict'):\n            return repr(dict(self))\n        return repr(list(self))\n\n    def __repr__(self):\n        return 'ValidationError(%s)' % self\n\n    def __eq__(self, other):\n        if not isinstance(other, ValidationError):\n            return False\n\n        # Compare dictionary form errors\n        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n            if set(self.error_dict.keys()) != set(other.error_dict.keys()):\n                return False\n            for field in self.error_dict.keys():\n                self_messages = set(str(msg) for msg in self.error_dict[field])\n                other_messages = set(str(msg) for msg in other.error_dict[field])\n                if self_messages != other_messages:\n                    return False\n            return True\n\n        # Compare list form errors\n        elif hasattr(self, 'error_list') and hasattr(other, 'error_list') and \\\n             not hasattr(self, 'error_dict') and not hasattr(other, 'error_dict'):\n            self_messages = set(str(msg) for msg in self.messages)\n            other_messages = set(str(msg) for msg in other.messages)\n            return self_messages == other_messages\n\n        # Mixed forms - normalize using message_dict or messages\n        else:\n            try:\n                # Try to compare as dictionaries if both can be converted\n                if hasattr(self, 'error_dict') or hasattr(other, 'error_dict'):\n                    self_dict = self.message_dict if hasattr(self, 'error_dict') else {NON_FIELD_ERRORS: self.messages}\n                    other_dict = other.message_dict if hasattr(other, 'error_dict') else {NON_FIELD_ERRORS: other.messages}\n                    \n                    if set(self_dict.keys()) != set(other_dict.keys()):\n                        return False\n                    for field in self_dict.keys():\n                        self_messages = set(str(msg) for msg in self_dict[field])\n                        other_messages = set(str(msg) for msg in other_dict[field])\n                        if self_messages != other_messages:\n                            return False\n                    return True\n                else:\n                    # Both are simple message forms\n                    self_messages = set(str(msg) for msg in self.messages)\n                    other_messages = set(str(msg) for msg in other.messages)\n                    return self_messages == other_messages\n            except (AttributeError, TypeError):\n                return False\n\n    def __hash__(self):\n        # Make ValidationError hashable by using a frozenset of its messages\n        try:\n            if hasattr(self, 'error_dict'):\n                # Create a frozenset of (field, frozenset(messages)) tuples\n                items = []\n                for field, messages in self.error_dict.items():\n                    field_messages = frozenset(str(msg) for msg in messages)\n                    items.append((field, field_messages))\n                return hash(frozenset(items))\n            else:\n                # Create a frozenset of all messages\n                return hash(frozenset(str(msg) for msg in self.messages))\n        except (AttributeError, TypeError):\n            # Fallback to object's default hash if messages can't be converted\n            return super().__hash__()\n",
      "\nclass ValidationError(Exception):\n    \"\"\"An error while validating data.\"\"\"\n    def __init__(self, message, code=None, params=None):\n        \"\"\"\n        The `message` argument can be a single error, a list of errors, or a\n        dictionary that maps field names to lists of errors. What we define as\n        an \"error\" can be either a simple string or an instance of\n        ValidationError with its message attribute set, and what we define as\n        list or dictionary can be an actual `list` or `dict` or an instance\n        of ValidationError with its `error_list` or `error_dict` attribute set.\n        \"\"\"\n        super().__init__(message, code, params)\n\n        if isinstance(message, ValidationError):\n            if hasattr(message, 'error_dict'):\n                message = message.error_dict\n            elif not hasattr(message, 'message'):\n                message = message.error_list\n            else:\n                message, code, params = message.message, message.code, message.params\n\n        if isinstance(message, dict):\n            self.error_dict = {}\n            for field, messages in message.items():\n                if not isinstance(messages, ValidationError):\n                    messages = ValidationError(messages)\n                self.error_dict[field] = messages.error_list\n\n        elif isinstance(message, list):\n            self.error_list = []\n            for message in message:\n                # Normalize plain strings to instances of ValidationError.\n                if not isinstance(message, ValidationError):\n                    message = ValidationError(message)\n                if hasattr(message, 'error_dict'):\n                    self.error_list.extend(sum(message.error_dict.values(), []))\n                else:\n                    self.error_list.extend(message.error_list)\n\n        else:\n            self.message = message\n            self.code = code\n            self.params = params\n            self.error_list = [self]\n\n    @property\n    def message_dict(self):\n        # Trigger an AttributeError if this ValidationError\n        # doesn't have an error_dict.\n        getattr(self, 'error_dict')\n\n        return dict(self)\n\n    @property\n    def messages(self):\n        if hasattr(self, 'error_dict'):\n            return sum(dict(self).values(), [])\n        return list(self)\n\n    def update_error_dict(self, error_dict):\n        if hasattr(self, 'error_dict'):\n            for field, error_list in self.error_dict.items():\n                error_dict.setdefault(field, []).extend(error_list)\n        else:\n            error_dict.setdefault(NON_FIELD_ERRORS, []).extend(self.error_list)\n        return error_dict\n\n    def __iter__(self):\n        if hasattr(self, 'error_dict'):\n            for field, errors in self.error_dict.items():\n                yield field, list(ValidationError(errors))\n        else:\n            for error in self.error_list:\n                message = error.message\n                if error.params:\n                    message %= error.params\n                yield str(message)\n\n    def __str__(self):\n        if hasattr(self, 'error_dict'):\n            return repr(dict(self))\n        return repr(list(self))\n\n    def __repr__(self):\n        return 'ValidationError(%s)' % self\n\n    def __eq__(self, other):\n        if not isinstance(other, ValidationError):\n            return False\n        \n        # If both have error_dict, compare them\n        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n            if set(self.error_dict.keys()) != set(other.error_dict.keys()):\n                return False\n            for field in self.error_dict:\n                self_messages = set(str(msg) for msg in self.error_dict[field])\n                other_messages = set(str(msg) for msg in other.error_dict[field])\n                if self_messages != other_messages:\n                    return False\n            return True\n        \n        # If both have error_list, compare them order-independently\n        if hasattr(self, 'error_list') and hasattr(other, 'error_list') and not hasattr(self, 'error_dict') and not hasattr(other, 'error_dict'):\n            self_messages = set(str(msg) for msg in self.error_list)\n            other_messages = set(str(msg) for msg in other.error_list)\n            return self_messages == other_messages\n        \n        # If both are single errors, compare message, code, and params\n        if (hasattr(self, 'message') and hasattr(other, 'message') and \n            not hasattr(self, 'error_dict') and not hasattr(other, 'error_dict')):\n            return (self.message == other.message and \n                    self.code == other.code and \n                    self.params == other.params)\n        \n        # For mixed forms, normalize using messages property and compare order-independently\n        try:\n            self_messages = set(self.messages)\n            other_messages = set(other.messages)\n            return self_messages == other_messages\n        except (AttributeError, TypeError):\n            return False\n\n    def __hash__(self):\n        if hasattr(self, 'error_dict'):\n            # Hash based on sorted field names and their message sets\n            items = []\n            for field in sorted(self.error_dict.keys()):\n                field_messages = frozenset(str(msg) for msg in self.error_dict[field])\n                items.append((field, field_messages))\n            return hash(tuple(items))\n        elif hasattr(self, 'error_list') and len(self.error_list) > 1:\n            # Hash based on the set of messages for list errors\n            return hash(frozenset(str(msg) for msg in self.error_list))\n        else:\n            # Hash based on message, code, and params for single errors\n            return hash((self.message, self.code, self.params))\n",
      "\nclass ValidationError(Exception):\n    \"\"\"An error while validating data.\"\"\"\n    def __init__(self, message, code=None, params=None):\n        \"\"\"\n        The `message` argument can be a single error, a list of errors, or a\n        dictionary that maps field names to lists of errors. What we define as\n        an \"error\" can be either a simple string or an instance of\n        ValidationError with its message attribute set, and what we define as\n        list or dictionary can be an actual `list` or `dict` or an instance\n        of ValidationError with its `error_list` or `error_dict` attribute set.\n        \"\"\"\n        super().__init__(message, code, params)\n\n        if isinstance(message, ValidationError):\n            if hasattr(message, 'error_dict'):\n                message = message.error_dict\n            elif not hasattr(message, 'message'):\n                message = message.error_list\n            else:\n                message, code, params = message.message, message.code, message.params\n\n        if isinstance(message, dict):\n            self.error_dict = {}\n            for field, messages in message.items():\n                if not isinstance(messages, ValidationError):\n                    messages = ValidationError(messages)\n                self.error_dict[field] = messages.error_list\n\n        elif isinstance(message, list):\n            self.error_list = []\n            for message in message:\n                # Normalize plain strings to instances of ValidationError.\n                if not isinstance(message, ValidationError):\n                    message = ValidationError(message)\n                if hasattr(message, 'error_dict'):\n                    self.error_list.extend(sum(message.error_dict.values(), []))\n                else:\n                    self.error_list.extend(message.error_list)\n\n        else:\n            self.message = message\n            self.code = code\n            self.params = params\n            self.error_list = [self]\n\n    @property\n    def message_dict(self):\n        # Trigger an AttributeError if this ValidationError\n        # doesn't have an error_dict.\n        getattr(self, 'error_dict')\n\n        return dict(self)\n\n    @property\n    def messages(self):\n        if hasattr(self, 'error_dict'):\n            return sum(dict(self).values(), [])\n        return list(self)\n\n    def update_error_dict(self, error_dict):\n        if hasattr(self, 'error_dict'):\n            for field, error_list in self.error_dict.items():\n                error_dict.setdefault(field, []).extend(error_list)\n        else:\n            error_dict.setdefault(NON_FIELD_ERRORS, []).extend(self.error_list)\n        return error_dict\n\n    def __iter__(self):\n        if hasattr(self, 'error_dict'):\n            for field, errors in self.error_dict.items():\n                yield field, list(ValidationError(errors))\n        else:\n            for error in self.error_list:\n                message = error.message\n                if error.params:\n                    message %= error.params\n                yield str(message)\n\n    def __str__(self):\n        if hasattr(self, 'error_dict'):\n            return repr(dict(self))\n        return repr(list(self))\n\n    def __repr__(self):\n        return 'ValidationError(%s)' % self\n\n    def __eq__(self, other):\n        if not isinstance(other, ValidationError):\n            return False\n        \n        # Both have error_dict (dictionary form)\n        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n            if set(self.error_dict.keys()) != set(other.error_dict.keys()):\n                return False\n            for field in self.error_dict.keys():\n                self_messages = set(str(msg) for msg in self.error_dict[field])\n                other_messages = set(str(msg) for msg in other.error_dict[field])\n                if self_messages != other_messages:\n                    return False\n            return True\n        \n        # Both have error_list but not error_dict (list form)\n        elif (hasattr(self, 'error_list') and not hasattr(self, 'error_dict') and\n              hasattr(other, 'error_list') and not hasattr(other, 'error_dict')):\n            # Check if both are single errors (error_list contains only self)\n            if (len(self.error_list) == 1 and self.error_list[0] is self and\n                len(other.error_list) == 1 and other.error_list[0] is other):\n                # Single error comparison\n                return (self.message == other.message and \n                        self.code == other.code and \n                        self.params == other.params)\n            else:\n                # List comparison - order independent\n                self_messages = set()\n                other_messages = set()\n                \n                for error in self.error_list:\n                    message = error.message\n                    if error.params:\n                        message = message % error.params\n                    self_messages.add(str(message))\n                \n                for error in other.error_list:\n                    message = error.message\n                    if error.params:\n                        message = message % error.params\n                    other_messages.add(str(message))\n                \n                return self_messages == other_messages\n        \n        # Mixed forms - normalize using messages property\n        else:\n            return set(self.messages) == set(other.messages)\n\n    def __hash__(self):\n        if hasattr(self, 'error_dict'):\n            # For dictionary form, hash based on sorted items\n            items = []\n            for field, errors in sorted(self.error_dict.items()):\n                error_messages = tuple(sorted(str(error) for error in errors))\n                items.append((field, error_messages))\n            return hash(tuple(items))\n        elif hasattr(self, 'error_list') and len(self.error_list) == 1 and self.error_list[0] is self:\n            # Single error form\n            return hash((self.message, self.code, self.params))\n        else:\n            # List form\n            messages = []\n            for error in self.error_list:\n                message = error.message\n                if error.params:\n                    message = message % error.params\n                messages.append(str(message))\n            return hash(tuple(sorted(messages)))\n",
      "\nclass ValidationError(Exception):\n    \"\"\"An error while validating data.\"\"\"\n    def __init__(self, message, code=None, params=None):\n        \"\"\"\n        The `message` argument can be a single error, a list of errors, or a\n        dictionary that maps field names to lists of errors. What we define as\n        an \"error\" can be either a simple string or an instance of\n        ValidationError with its message attribute set, and what we define as\n        list or dictionary can be an actual `list` or `dict` or an instance\n        of ValidationError with its `error_list` or `error_dict` attribute set.\n        \"\"\"\n        super().__init__(message, code, params)\n\n        if isinstance(message, ValidationError):\n            if hasattr(message, 'error_dict'):\n                message = message.error_dict\n            elif not hasattr(message, 'message'):\n                message = message.error_list\n            else:\n                message, code, params = message.message, message.code, message.params\n\n        if isinstance(message, dict):\n            self.error_dict = {}\n            for field, messages in message.items():\n                if not isinstance(messages, ValidationError):\n                    messages = ValidationError(messages)\n                self.error_dict[field] = messages.error_list\n\n        elif isinstance(message, list):\n            self.error_list = []\n            for message in message:\n                # Normalize plain strings to instances of ValidationError.\n                if not isinstance(message, ValidationError):\n                    message = ValidationError(message)\n                if hasattr(message, 'error_dict'):\n                    self.error_list.extend(sum(message.error_dict.values(), []))\n                else:\n                    self.error_list.extend(message.error_list)\n\n        else:\n            self.message = message\n            self.code = code\n            self.params = params\n            self.error_list = [self]\n\n    @property\n    def message_dict(self):\n        # Trigger an AttributeError if this ValidationError\n        # doesn't have an error_dict.\n        getattr(self, 'error_dict')\n\n        return dict(self)\n\n    @property\n    def messages(self):\n        if hasattr(self, 'error_dict'):\n            return sum(dict(self).values(), [])\n        return list(self)\n\n    def update_error_dict(self, error_dict):\n        if hasattr(self, 'error_dict'):\n            for field, error_list in self.error_dict.items():\n                error_dict.setdefault(field, []).extend(error_list)\n        else:\n            error_dict.setdefault(NON_FIELD_ERRORS, []).extend(self.error_list)\n        return error_dict\n\n    def __iter__(self):\n        if hasattr(self, 'error_dict'):\n            for field, errors in self.error_dict.items():\n                yield field, list(ValidationError(errors))\n        else:\n            for error in self.error_list:\n                message = error.message\n                if error.params:\n                    message %= error.params\n                yield str(message)\n\n    def __str__(self):\n        if hasattr(self, 'error_dict'):\n            return repr(dict(self))\n        return repr(list(self))\n\n    def __repr__(self):\n        return 'ValidationError(%s)' % self\n\n    def __eq__(self, other):\n        if not isinstance(other, ValidationError):\n            return False\n        \n        # Both have error_dict\n        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n            if set(self.error_dict.keys()) != set(other.error_dict.keys()):\n                return False\n            for field in self.error_dict:\n                self_messages = set(str(msg) for msg in self.error_dict[field])\n                other_messages = set(str(msg) for msg in other.error_dict[field])\n                if self_messages != other_messages:\n                    return False\n            return True\n        \n        # Both have error_list (but not error_dict)\n        elif hasattr(self, 'error_list') and hasattr(other, 'error_list') and \\\n             not hasattr(self, 'error_dict') and not hasattr(other, 'error_dict'):\n            self_messages = set(str(msg) for msg in self.error_list)\n            other_messages = set(str(msg) for msg in other.error_list)\n            return self_messages == other_messages\n        \n        # Different structures - normalize using messages property\n        else:\n            self_messages = set(self.messages)\n            other_messages = set(other.messages)\n            return self_messages == other_messages\n\n    def __hash__(self):\n        if hasattr(self, 'error_dict'):\n            items = []\n            for field in sorted(self.error_dict.keys()):\n                field_messages = frozenset(str(msg) for msg in self.error_dict[field])\n                items.append((field, field_messages))\n            return hash(frozenset(items))\n        else:\n            messages = frozenset(str(msg) for msg in self.error_list)\n            return hash(messages)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/core/exceptions.py b/django/core/exceptions.py\nindex dc084b8692..105ecaa981 100644\n--- a/django/core/exceptions.py\n+++ b/django/core/exceptions.py\n@@ -96,6 +96,7 @@ class FieldError(Exception):\n NON_FIELD_ERRORS = '__all__'\n \n \n+\n class ValidationError(Exception):\n     \"\"\"An error while validating data.\"\"\"\n     def __init__(self, message, code=None, params=None):\n@@ -182,6 +183,49 @@ class ValidationError(Exception):\n     def __repr__(self):\n         return 'ValidationError(%s)' % self\n \n+    def __eq__(self, other):\n+        if not isinstance(other, ValidationError):\n+            return False\n+        \n+        # Both have error_dict (dictionary form)\n+        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n+            if set(self.error_dict.keys()) != set(other.error_dict.keys()):\n+                return False\n+            for field in self.error_dict:\n+                # Compare error lists for each field in order-independent way\n+                self_messages = set(str(error.message) for error in self.error_dict[field])\n+                other_messages = set(str(error.message) for error in other.error_dict[field])\n+                if self_messages != other_messages:\n+                    return False\n+            return True\n+        \n+        # Both have error_list but no error_dict (list form)\n+        elif (hasattr(self, 'error_list') and not hasattr(self, 'error_dict') and\n+              hasattr(other, 'error_list') and not hasattr(other, 'error_dict')):\n+            # For single error form, check if both have single error with same attributes\n+            if (len(self.error_list) == 1 and len(other.error_list) == 1 and\n+                hasattr(self, 'message') and hasattr(other, 'message')):\n+                return (self.message == other.message and \n+                        self.code == other.code and \n+                        self.params == other.params)\n+            # For list form, compare messages in order-independent way\n+            else:\n+                self_messages = set(str(error.message) for error in self.error_list)\n+                other_messages = set(str(error.message) for error in other.error_list)\n+                return self_messages == other_messages\n+        \n+        # Mixed forms - normalize using messages property for comparison\n+        else:\n+            return set(self.messages) == set(other.messages)\n+\n+    def __hash__(self):\n+        # Make ValidationError hashable by using a frozenset of messages\n+        # This ensures equal objects have the same hash\n+        try:\n+            return hash(frozenset(self.messages))\n+        except TypeError:\n+            # If messages contain unhashable types, fall back to id-based hash\n+            return hash(id(self))\n \n class EmptyResultSet(Exception):\n     \"\"\"A database query predicate is impossible.\"\"\"\n",
    "variant_0": "diff --git a/django/core/exceptions.py b/django/core/exceptions.py\nindex dc084b8692..ffb9036bef 100644\n--- a/django/core/exceptions.py\n+++ b/django/core/exceptions.py\n@@ -96,6 +96,7 @@ class FieldError(Exception):\n NON_FIELD_ERRORS = '__all__'\n \n \n+\n class ValidationError(Exception):\n     \"\"\"An error while validating data.\"\"\"\n     def __init__(self, message, code=None, params=None):\n@@ -182,6 +183,62 @@ class ValidationError(Exception):\n     def __repr__(self):\n         return 'ValidationError(%s)' % self\n \n+    def __eq__(self, other):\n+        if not isinstance(other, ValidationError):\n+            return False\n+        \n+        # Both have error_dict\n+        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n+            if set(self.error_dict.keys()) != set(other.error_dict.keys()):\n+                return False\n+            for field in self.error_dict:\n+                self_messages = set(str(msg) for msg in self.error_dict[field])\n+                other_messages = set(str(msg) for msg in other.error_dict[field])\n+                if self_messages != other_messages:\n+                    return False\n+            return True\n+        \n+        # Both have error_list\n+        elif hasattr(self, 'error_list') and hasattr(other, 'error_list') and \\\n+             not hasattr(self, 'error_dict') and not hasattr(other, 'error_dict'):\n+            self_messages = set(str(msg) for msg in self.messages)\n+            other_messages = set(str(msg) for msg in other.messages)\n+            return self_messages == other_messages\n+        \n+        # Mixed forms - normalize using message_dict or messages\n+        else:\n+            try:\n+                # Try to compare as dicts if both can be converted\n+                if hasattr(self, 'error_dict') or hasattr(other, 'error_dict'):\n+                    self_dict = self.message_dict if hasattr(self, 'error_dict') else {NON_FIELD_ERRORS: self.messages}\n+                    other_dict = other.message_dict if hasattr(other, 'error_dict') else {NON_FIELD_ERRORS: other.messages}\n+                    \n+                    if set(self_dict.keys()) != set(other_dict.keys()):\n+                        return False\n+                    for field in self_dict:\n+                        self_messages = set(str(msg) for msg in self_dict[field])\n+                        other_messages = set(str(msg) for msg in other_dict[field])\n+                        if self_messages != other_messages:\n+                            return False\n+                    return True\n+                else:\n+                    # Compare as message lists\n+                    self_messages = set(str(msg) for msg in self.messages)\n+                    other_messages = set(str(msg) for msg in other.messages)\n+                    return self_messages == other_messages\n+            except AttributeError:\n+                return False\n+\n+    def __hash__(self):\n+        if hasattr(self, 'error_dict'):\n+            items = []\n+            for field, errors in sorted(self.error_dict.items()):\n+                field_messages = tuple(sorted(str(msg) for msg in errors))\n+                items.append((field, field_messages))\n+            return hash(tuple(items))\n+        else:\n+            messages = tuple(sorted(str(msg) for msg in self.messages))\n+            return hash(messages)\n \n class EmptyResultSet(Exception):\n     \"\"\"A database query predicate is impossible.\"\"\"\n",
    "variant_1": "diff --git a/django/core/exceptions.py b/django/core/exceptions.py\nindex dc084b8692..b31ec1fea7 100644\n--- a/django/core/exceptions.py\n+++ b/django/core/exceptions.py\n@@ -96,6 +96,7 @@ class FieldError(Exception):\n NON_FIELD_ERRORS = '__all__'\n \n \n+\n class ValidationError(Exception):\n     \"\"\"An error while validating data.\"\"\"\n     def __init__(self, message, code=None, params=None):\n@@ -182,6 +183,65 @@ class ValidationError(Exception):\n     def __repr__(self):\n         return 'ValidationError(%s)' % self\n \n+    def __eq__(self, other):\n+        if not isinstance(other, ValidationError):\n+            return False\n+        \n+        # If both have error_dict, compare as dictionaries\n+        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n+            if set(self.error_dict.keys()) != set(other.error_dict.keys()):\n+                return False\n+            for field in self.error_dict.keys():\n+                self_messages = set(str(msg) for msg in self.error_dict[field])\n+                other_messages = set(str(msg) for msg in other.error_dict[field])\n+                if self_messages != other_messages:\n+                    return False\n+            return True\n+        \n+        # If neither has error_dict, compare as lists/single errors\n+        elif not hasattr(self, 'error_dict') and not hasattr(other, 'error_dict'):\n+            self_messages = set(str(msg) for msg in self.messages)\n+            other_messages = set(str(msg) for msg in other.messages)\n+            return self_messages == other_messages\n+        \n+        # Mixed forms - normalize to message comparison\n+        else:\n+            try:\n+                # Try to compare using message_dict if possible\n+                if hasattr(self, 'error_dict'):\n+                    self_dict = dict(self)\n+                    other_dict = {NON_FIELD_ERRORS: other.messages}\n+                else:\n+                    self_dict = {NON_FIELD_ERRORS: self.messages}\n+                    other_dict = dict(other)\n+                \n+                if set(self_dict.keys()) != set(other_dict.keys()):\n+                    return False\n+                \n+                for field in self_dict.keys():\n+                    self_messages = set(str(msg) for msg in self_dict[field])\n+                    other_messages = set(str(msg) for msg in other_dict[field])\n+                    if self_messages != other_messages:\n+                        return False\n+                return True\n+            except:\n+                # Fallback to simple message comparison\n+                self_messages = set(str(msg) for msg in self.messages)\n+                other_messages = set(str(msg) for msg in other.messages)\n+                return self_messages == other_messages\n+\n+    def __hash__(self):\n+        if hasattr(self, 'error_dict'):\n+            # Create a frozenset of (field, frozenset(messages)) tuples\n+            items = []\n+            for field, messages in self.error_dict.items():\n+                message_set = frozenset(str(msg) for msg in messages)\n+                items.append((field, message_set))\n+            return hash(frozenset(items))\n+        else:\n+            # Hash the set of messages for list/single error forms\n+            message_set = frozenset(str(msg) for msg in self.messages)\n+            return hash(message_set)\n \n class EmptyResultSet(Exception):\n     \"\"\"A database query predicate is impossible.\"\"\"\n",
    "variant_2": "diff --git a/django/core/exceptions.py b/django/core/exceptions.py\nindex dc084b8692..62f4da8fec 100644\n--- a/django/core/exceptions.py\n+++ b/django/core/exceptions.py\n@@ -96,6 +96,7 @@ class FieldError(Exception):\n NON_FIELD_ERRORS = '__all__'\n \n \n+\n class ValidationError(Exception):\n     \"\"\"An error while validating data.\"\"\"\n     def __init__(self, message, code=None, params=None):\n@@ -182,6 +183,56 @@ class ValidationError(Exception):\n     def __repr__(self):\n         return 'ValidationError(%s)' % self\n \n+    def __eq__(self, other):\n+        if not isinstance(other, ValidationError):\n+            return False\n+        \n+        # Both have error_dict (dictionary form)\n+        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n+            if set(self.error_dict.keys()) != set(other.error_dict.keys()):\n+                return False\n+            for field in self.error_dict.keys():\n+                self_messages = set(str(error) for error in self.error_dict[field])\n+                other_messages = set(str(error) for error in other.error_dict[field])\n+                if self_messages != other_messages:\n+                    return False\n+            return True\n+        \n+        # Both have error_list but not error_dict (list form)\n+        elif (hasattr(self, 'error_list') and not hasattr(self, 'error_dict') and\n+              hasattr(other, 'error_list') and not hasattr(other, 'error_dict')):\n+            self_messages = set(str(error) for error in self.error_list)\n+            other_messages = set(str(error) for error in other.error_list)\n+            return self_messages == other_messages\n+        \n+        # Both are single errors (neither has error_dict)\n+        elif (not hasattr(self, 'error_dict') and not hasattr(other, 'error_dict') and\n+              len(getattr(self, 'error_list', [])) == 1 and len(getattr(other, 'error_list', [])) == 1):\n+            return (self.message == other.message and \n+                    self.code == other.code and \n+                    self.params == other.params)\n+        \n+        # Mixed forms - normalize using messages property for order-independent comparison\n+        else:\n+            self_messages = set(self.messages)\n+            other_messages = set(other.messages)\n+            return self_messages == other_messages\n+\n+    def __hash__(self):\n+        if hasattr(self, 'error_dict'):\n+            # For dictionary form, hash based on sorted field-message pairs\n+            items = []\n+            for field, errors in self.error_dict.items():\n+                field_messages = tuple(sorted(str(error) for error in errors))\n+                items.append((field, field_messages))\n+            return hash(tuple(sorted(items)))\n+        elif hasattr(self, 'error_list') and len(self.error_list) > 1:\n+            # For list form, hash based on sorted messages\n+            messages = tuple(sorted(str(error) for error in self.error_list))\n+            return hash(messages)\n+        else:\n+            # For single error form\n+            return hash((self.message, self.code, tuple(sorted(self.params.items())) if self.params else None))\n \n class EmptyResultSet(Exception):\n     \"\"\"A database query predicate is impossible.\"\"\"\n",
    "variant_3": "diff --git a/django/core/exceptions.py b/django/core/exceptions.py\nindex dc084b8692..aca77a5f42 100644\n--- a/django/core/exceptions.py\n+++ b/django/core/exceptions.py\n@@ -96,6 +96,7 @@ class FieldError(Exception):\n NON_FIELD_ERRORS = '__all__'\n \n \n+\n class ValidationError(Exception):\n     \"\"\"An error while validating data.\"\"\"\n     def __init__(self, message, code=None, params=None):\n@@ -182,6 +183,55 @@ class ValidationError(Exception):\n     def __repr__(self):\n         return 'ValidationError(%s)' % self\n \n+    def __eq__(self, other):\n+        if not isinstance(other, ValidationError):\n+            return False\n+        \n+        # Both have error_dict - compare as dictionaries\n+        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n+            if set(self.error_dict.keys()) != set(other.error_dict.keys()):\n+                return False\n+            for field in self.error_dict:\n+                self_messages = set(str(msg) for msg in self.error_dict[field])\n+                other_messages = set(str(msg) for msg in other.error_dict[field])\n+                if self_messages != other_messages:\n+                    return False\n+            return True\n+        \n+        # Both have error_list - compare as sets\n+        elif hasattr(self, 'error_list') and hasattr(other, 'error_list'):\n+            # Handle single error case (error_list contains [self])\n+            if len(self.error_list) == 1 and self.error_list[0] is self and \\\n+               len(other.error_list) == 1 and other.error_list[0] is other:\n+                return (self.message == other.message and \n+                        self.code == other.code and \n+                        self.params == other.params)\n+            \n+            # Compare error lists as sets\n+            self_messages = set(str(error) for error in self.error_list)\n+            other_messages = set(str(error) for error in other.error_list)\n+            return self_messages == other_messages\n+        \n+        # Mixed types - normalize using messages property and compare as sets\n+        else:\n+            self_messages = set(self.messages)\n+            other_messages = set(other.messages)\n+            return self_messages == other_messages\n+\n+    def __hash__(self):\n+        if hasattr(self, 'error_dict'):\n+            # Create a frozenset of (field, frozenset(messages)) tuples\n+            items = []\n+            for field, error_list in self.error_dict.items():\n+                messages = frozenset(str(msg) for msg in error_list)\n+                items.append((field, messages))\n+            return hash(frozenset(items))\n+        elif hasattr(self, 'error_list') and len(self.error_list) == 1 and self.error_list[0] is self:\n+            # Single error case\n+            return hash((self.message, self.code, self.params))\n+        else:\n+            # Multiple errors case\n+            return hash(frozenset(str(error) for error in self.error_list))\n \n class EmptyResultSet(Exception):\n     \"\"\"A database query predicate is impossible.\"\"\"\n",
    "variant_4": "diff --git a/django/core/exceptions.py b/django/core/exceptions.py\nindex dc084b8692..f84fe33c29 100644\n--- a/django/core/exceptions.py\n+++ b/django/core/exceptions.py\n@@ -96,6 +96,7 @@ class FieldError(Exception):\n NON_FIELD_ERRORS = '__all__'\n \n \n+\n class ValidationError(Exception):\n     \"\"\"An error while validating data.\"\"\"\n     def __init__(self, message, code=None, params=None):\n@@ -182,6 +183,55 @@ class ValidationError(Exception):\n     def __repr__(self):\n         return 'ValidationError(%s)' % self\n \n+    def __eq__(self, other):\n+        if not isinstance(other, ValidationError):\n+            return False\n+        \n+        # Both have error_dict\n+        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n+            if set(self.error_dict.keys()) != set(other.error_dict.keys()):\n+                return False\n+            for field in self.error_dict:\n+                self_messages = set(str(msg) for msg in self.error_dict[field])\n+                other_messages = set(str(msg) for msg in other.error_dict[field])\n+                if self_messages != other_messages:\n+                    return False\n+            return True\n+        \n+        # Both have error_list (but not error_dict)\n+        elif hasattr(self, 'error_list') and hasattr(other, 'error_list') and \\\n+             not hasattr(self, 'error_dict') and not hasattr(other, 'error_dict'):\n+            self_messages = set(str(msg) for msg in self.error_list)\n+            other_messages = set(str(msg) for msg in other.error_list)\n+            return self_messages == other_messages\n+        \n+        # Single error comparison (both have message, code, params)\n+        elif hasattr(self, 'message') and hasattr(other, 'message') and \\\n+             not hasattr(self, 'error_dict') and not hasattr(other, 'error_dict'):\n+            return (self.message == other.message and \n+                    self.code == other.code and \n+                    self.params == other.params)\n+        \n+        # Mixed forms - normalize using messages property for comparison\n+        else:\n+            self_messages = set(self.messages)\n+            other_messages = set(other.messages)\n+            return self_messages == other_messages\n+\n+    def __hash__(self):\n+        if hasattr(self, 'error_dict'):\n+            # Hash based on sorted field-message pairs\n+            items = []\n+            for field in sorted(self.error_dict.keys()):\n+                field_messages = tuple(sorted(str(msg) for msg in self.error_dict[field]))\n+                items.append((field, field_messages))\n+            return hash(tuple(items))\n+        elif hasattr(self, 'error_list') and len(self.error_list) > 1:\n+            # Hash based on sorted messages\n+            return hash(tuple(sorted(str(msg) for msg in self.error_list)))\n+        else:\n+            # Single error\n+            return hash((self.message, self.code, self.params))\n \n class EmptyResultSet(Exception):\n     \"\"\"A database query predicate is impossible.\"\"\"\n",
    "variant_5": "diff --git a/django/core/exceptions.py b/django/core/exceptions.py\nindex dc084b8692..fc300d13a6 100644\n--- a/django/core/exceptions.py\n+++ b/django/core/exceptions.py\n@@ -96,6 +96,7 @@ class FieldError(Exception):\n NON_FIELD_ERRORS = '__all__'\n \n \n+\n class ValidationError(Exception):\n     \"\"\"An error while validating data.\"\"\"\n     def __init__(self, message, code=None, params=None):\n@@ -182,6 +183,68 @@ class ValidationError(Exception):\n     def __repr__(self):\n         return 'ValidationError(%s)' % self\n \n+    def __eq__(self, other):\n+        if not isinstance(other, ValidationError):\n+            return False\n+\n+        # Compare dictionary form errors\n+        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n+            if set(self.error_dict.keys()) != set(other.error_dict.keys()):\n+                return False\n+            for field in self.error_dict.keys():\n+                self_messages = set(str(msg) for msg in self.error_dict[field])\n+                other_messages = set(str(msg) for msg in other.error_dict[field])\n+                if self_messages != other_messages:\n+                    return False\n+            return True\n+\n+        # Compare list form errors\n+        elif hasattr(self, 'error_list') and hasattr(other, 'error_list') and \\\n+             not hasattr(self, 'error_dict') and not hasattr(other, 'error_dict'):\n+            self_messages = set(str(msg) for msg in self.messages)\n+            other_messages = set(str(msg) for msg in other.messages)\n+            return self_messages == other_messages\n+\n+        # Mixed forms - normalize using message_dict or messages\n+        else:\n+            try:\n+                # Try to compare as dictionaries if both can be converted\n+                if hasattr(self, 'error_dict') or hasattr(other, 'error_dict'):\n+                    self_dict = self.message_dict if hasattr(self, 'error_dict') else {NON_FIELD_ERRORS: self.messages}\n+                    other_dict = other.message_dict if hasattr(other, 'error_dict') else {NON_FIELD_ERRORS: other.messages}\n+                    \n+                    if set(self_dict.keys()) != set(other_dict.keys()):\n+                        return False\n+                    for field in self_dict.keys():\n+                        self_messages = set(str(msg) for msg in self_dict[field])\n+                        other_messages = set(str(msg) for msg in other_dict[field])\n+                        if self_messages != other_messages:\n+                            return False\n+                    return True\n+                else:\n+                    # Both are simple message forms\n+                    self_messages = set(str(msg) for msg in self.messages)\n+                    other_messages = set(str(msg) for msg in other.messages)\n+                    return self_messages == other_messages\n+            except (AttributeError, TypeError):\n+                return False\n+\n+    def __hash__(self):\n+        # Make ValidationError hashable by using a frozenset of its messages\n+        try:\n+            if hasattr(self, 'error_dict'):\n+                # Create a frozenset of (field, frozenset(messages)) tuples\n+                items = []\n+                for field, messages in self.error_dict.items():\n+                    field_messages = frozenset(str(msg) for msg in messages)\n+                    items.append((field, field_messages))\n+                return hash(frozenset(items))\n+            else:\n+                # Create a frozenset of all messages\n+                return hash(frozenset(str(msg) for msg in self.messages))\n+        except (AttributeError, TypeError):\n+            # Fallback to object's default hash if messages can't be converted\n+            return super().__hash__()\n \n class EmptyResultSet(Exception):\n     \"\"\"A database query predicate is impossible.\"\"\"\n",
    "variant_6": "diff --git a/django/core/exceptions.py b/django/core/exceptions.py\nindex dc084b8692..5f41ab19f3 100644\n--- a/django/core/exceptions.py\n+++ b/django/core/exceptions.py\n@@ -96,6 +96,7 @@ class FieldError(Exception):\n NON_FIELD_ERRORS = '__all__'\n \n \n+\n class ValidationError(Exception):\n     \"\"\"An error while validating data.\"\"\"\n     def __init__(self, message, code=None, params=None):\n@@ -182,6 +183,56 @@ class ValidationError(Exception):\n     def __repr__(self):\n         return 'ValidationError(%s)' % self\n \n+    def __eq__(self, other):\n+        if not isinstance(other, ValidationError):\n+            return False\n+        \n+        # If both have error_dict, compare them\n+        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n+            if set(self.error_dict.keys()) != set(other.error_dict.keys()):\n+                return False\n+            for field in self.error_dict:\n+                self_messages = set(str(msg) for msg in self.error_dict[field])\n+                other_messages = set(str(msg) for msg in other.error_dict[field])\n+                if self_messages != other_messages:\n+                    return False\n+            return True\n+        \n+        # If both have error_list, compare them order-independently\n+        if hasattr(self, 'error_list') and hasattr(other, 'error_list') and not hasattr(self, 'error_dict') and not hasattr(other, 'error_dict'):\n+            self_messages = set(str(msg) for msg in self.error_list)\n+            other_messages = set(str(msg) for msg in other.error_list)\n+            return self_messages == other_messages\n+        \n+        # If both are single errors, compare message, code, and params\n+        if (hasattr(self, 'message') and hasattr(other, 'message') and \n+            not hasattr(self, 'error_dict') and not hasattr(other, 'error_dict')):\n+            return (self.message == other.message and \n+                    self.code == other.code and \n+                    self.params == other.params)\n+        \n+        # For mixed forms, normalize using messages property and compare order-independently\n+        try:\n+            self_messages = set(self.messages)\n+            other_messages = set(other.messages)\n+            return self_messages == other_messages\n+        except (AttributeError, TypeError):\n+            return False\n+\n+    def __hash__(self):\n+        if hasattr(self, 'error_dict'):\n+            # Hash based on sorted field names and their message sets\n+            items = []\n+            for field in sorted(self.error_dict.keys()):\n+                field_messages = frozenset(str(msg) for msg in self.error_dict[field])\n+                items.append((field, field_messages))\n+            return hash(tuple(items))\n+        elif hasattr(self, 'error_list') and len(self.error_list) > 1:\n+            # Hash based on the set of messages for list errors\n+            return hash(frozenset(str(msg) for msg in self.error_list))\n+        else:\n+            # Hash based on message, code, and params for single errors\n+            return hash((self.message, self.code, self.params))\n \n class EmptyResultSet(Exception):\n     \"\"\"A database query predicate is impossible.\"\"\"\n",
    "variant_7": "diff --git a/django/core/exceptions.py b/django/core/exceptions.py\nindex dc084b8692..5377991ba9 100644\n--- a/django/core/exceptions.py\n+++ b/django/core/exceptions.py\n@@ -96,6 +96,7 @@ class FieldError(Exception):\n NON_FIELD_ERRORS = '__all__'\n \n \n+\n class ValidationError(Exception):\n     \"\"\"An error while validating data.\"\"\"\n     def __init__(self, message, code=None, params=None):\n@@ -182,6 +183,74 @@ class ValidationError(Exception):\n     def __repr__(self):\n         return 'ValidationError(%s)' % self\n \n+    def __eq__(self, other):\n+        if not isinstance(other, ValidationError):\n+            return False\n+        \n+        # Both have error_dict (dictionary form)\n+        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n+            if set(self.error_dict.keys()) != set(other.error_dict.keys()):\n+                return False\n+            for field in self.error_dict.keys():\n+                self_messages = set(str(msg) for msg in self.error_dict[field])\n+                other_messages = set(str(msg) for msg in other.error_dict[field])\n+                if self_messages != other_messages:\n+                    return False\n+            return True\n+        \n+        # Both have error_list but not error_dict (list form)\n+        elif (hasattr(self, 'error_list') and not hasattr(self, 'error_dict') and\n+              hasattr(other, 'error_list') and not hasattr(other, 'error_dict')):\n+            # Check if both are single errors (error_list contains only self)\n+            if (len(self.error_list) == 1 and self.error_list[0] is self and\n+                len(other.error_list) == 1 and other.error_list[0] is other):\n+                # Single error comparison\n+                return (self.message == other.message and \n+                        self.code == other.code and \n+                        self.params == other.params)\n+            else:\n+                # List comparison - order independent\n+                self_messages = set()\n+                other_messages = set()\n+                \n+                for error in self.error_list:\n+                    message = error.message\n+                    if error.params:\n+                        message = message % error.params\n+                    self_messages.add(str(message))\n+                \n+                for error in other.error_list:\n+                    message = error.message\n+                    if error.params:\n+                        message = message % error.params\n+                    other_messages.add(str(message))\n+                \n+                return self_messages == other_messages\n+        \n+        # Mixed forms - normalize using messages property\n+        else:\n+            return set(self.messages) == set(other.messages)\n+\n+    def __hash__(self):\n+        if hasattr(self, 'error_dict'):\n+            # For dictionary form, hash based on sorted items\n+            items = []\n+            for field, errors in sorted(self.error_dict.items()):\n+                error_messages = tuple(sorted(str(error) for error in errors))\n+                items.append((field, error_messages))\n+            return hash(tuple(items))\n+        elif hasattr(self, 'error_list') and len(self.error_list) == 1 and self.error_list[0] is self:\n+            # Single error form\n+            return hash((self.message, self.code, self.params))\n+        else:\n+            # List form\n+            messages = []\n+            for error in self.error_list:\n+                message = error.message\n+                if error.params:\n+                    message = message % error.params\n+                messages.append(str(message))\n+            return hash(tuple(sorted(messages)))\n \n class EmptyResultSet(Exception):\n     \"\"\"A database query predicate is impossible.\"\"\"\n",
    "variant_8": "diff --git a/django/core/exceptions.py b/django/core/exceptions.py\nindex dc084b8692..99a74ecf2c 100644\n--- a/django/core/exceptions.py\n+++ b/django/core/exceptions.py\n@@ -96,6 +96,7 @@ class FieldError(Exception):\n NON_FIELD_ERRORS = '__all__'\n \n \n+\n class ValidationError(Exception):\n     \"\"\"An error while validating data.\"\"\"\n     def __init__(self, message, code=None, params=None):\n@@ -182,6 +183,44 @@ class ValidationError(Exception):\n     def __repr__(self):\n         return 'ValidationError(%s)' % self\n \n+    def __eq__(self, other):\n+        if not isinstance(other, ValidationError):\n+            return False\n+        \n+        # Both have error_dict\n+        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):\n+            if set(self.error_dict.keys()) != set(other.error_dict.keys()):\n+                return False\n+            for field in self.error_dict:\n+                self_messages = set(str(msg) for msg in self.error_dict[field])\n+                other_messages = set(str(msg) for msg in other.error_dict[field])\n+                if self_messages != other_messages:\n+                    return False\n+            return True\n+        \n+        # Both have error_list (but not error_dict)\n+        elif hasattr(self, 'error_list') and hasattr(other, 'error_list') and \\\n+             not hasattr(self, 'error_dict') and not hasattr(other, 'error_dict'):\n+            self_messages = set(str(msg) for msg in self.error_list)\n+            other_messages = set(str(msg) for msg in other.error_list)\n+            return self_messages == other_messages\n+        \n+        # Different structures - normalize using messages property\n+        else:\n+            self_messages = set(self.messages)\n+            other_messages = set(other.messages)\n+            return self_messages == other_messages\n+\n+    def __hash__(self):\n+        if hasattr(self, 'error_dict'):\n+            items = []\n+            for field in sorted(self.error_dict.keys()):\n+                field_messages = frozenset(str(msg) for msg in self.error_dict[field])\n+                items.append((field, field_messages))\n+            return hash(frozenset(items))\n+        else:\n+            messages = frozenset(str(msg) for msg in self.error_list)\n+            return hash(messages)\n \n class EmptyResultSet(Exception):\n     \"\"\"A database query predicate is impossible.\"\"\"\n"
  }
}