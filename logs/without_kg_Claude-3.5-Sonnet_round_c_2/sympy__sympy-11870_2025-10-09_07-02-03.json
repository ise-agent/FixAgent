{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/sympy/sympy/simplify/trigsimp.py lines 504-513)": "\n    trigsimpfunc = {\n        'fu': (lambda x: fu(x, **opts)),\n        'matching': (lambda x: futrig(x)),\n        'groebner': (lambda x: groebnersimp(x, **opts)),\n        'combined': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[2, tan]))),\n        'old': lambda x: trigsimp_old(x, **opts),\n                   }[method]\n\n    # Apply exptrigsimp first to handle exponential expressions\n    expr_with_exp_converted = exptrigsimp(expr)\n    return trigsimpfunc(expr_with_exp_converted)\n",
    "Location 2 (/root/hy/projects_2/sympy/sympy/simplify/trigsimp.py lines 487-490)": "\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n        # Apply exptrigsimp as preprocessing when exponential functions are present\n        if expr.has(exp):\n            expr = exptrigsimp(expr)\n    else:\n        method = 'old'\n",
    "Location 3 (/root/hy/projects_2/sympy/sympy/simplify/trigsimp.py lines 516-530)": "\ndef exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    Examples\n    ========\n\n    >>> from sympy import exptrigsimp, exp, cosh, sinh\n    >>> from sympy.abc import z\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n    from sympy.simplify.simplify import bottom_up\n\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        choices.append(e.rewrite(cos))\n        # Also try rewriting exponentials as trigonometric functions\n        if e.has(exp):\n            choices.append(e.rewrite(sin))\n            choices.append(e.rewrite(cos))\n        return min(choices, key=count_ops)\n\n    newexpr = bottom_up(expr, exp_trig)\n\n    # conversion from exp to hyperbolic functions\n    # to trig functions\n    ex = newexpr.rewrite(exp)\n    ex = ex.replace(lambda x: x.is_Pow and x.base == S.Exp1 and x.exp.is_Mul and x.exp.coeff(I), \n                   lambda x: cos(x.exp/I) + I*sin(x.exp/I))\n    ex = TR2i(ex)\n    if ex.has(HyperbolicFunction):\n        ex = hyper_as_trig(ex)\n    ex = TR2i(ex).simplify()\n    # if we have a Boolean, Relational, or Piecewise, do not attempt\n    # further simplification since the expression has been altered\n    if ex.has(S.BooleanTrue):\n        return ex\n    return trigsimp(ex, method='fu')\n",
    "Location 4 (/root/hy/projects_2/sympy/sympy/simplify/trigsimp.py lines 534-542)": "\ndef exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    This is a wrapper around simplify that uses a bottom-up approach, applying\n    specific simplifications in a careful order.\n\n    Examples\n    ========\n\n    >>> from sympy import *\n    >>> from sympy.simplify.trigsimp import exptrigsimp\n    >>> from sympy.abc import z\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n    from sympy.simplify.simplify import bottom_up\n\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        if e.has(exp):\n            choices.append(e.rewrite(sin))\n            choices.append(e.rewrite(cos))\n        choices.append(e.rewrite(cos))\n        return min(*choices, key=count_ops)\n    newexpr = bottom_up(expr, exp_trig)\n",
    "Location 5 (/root/hy/projects_2/sympy/sympy/simplify/trigsimp.py lines 593-602)": "\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', 'fu' and 'old'. If 'matching', simplify the\n    expression recursively by targeting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring). If 'old', uses the old trigsimp algorithm.\n\n    compare:\n    - show input and output from `trigsimp` and `futrig` when different,\n    but returns the `trigsimp` result.\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log, cosh\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e)\n    2\n    >>> trigsimp(log(e))\n    log(2*sin(x)**2 + 2*cos(x)**2)\n    >>> trigsimp(log(e), deep=True)\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) can sometimes lead to a lot\n    more simplification:\n\n    >>> e = (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)\n    >>> trigsimp(e)\n    (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)\n    >>> trigsimp(e, method=\"groebner\")\n    2/cos(x)\n\n    >>> trigsimp(1/cot(x), compare=True)\n          futrig: tan(x)\n    trigsimp: 1/cot(x)\n    1/cot(x)\n\n    \"\"\"\n    from sympy.simplify.fu import fu\n\n    expr = sympify(expr)\n\n    _eval_trigsimp = getattr(expr, '_eval_trigsimp', None)\n    if _eval_trigsimp is not None:\n        return _eval_trigsimp(**opts)\n\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n    else:\n        method = 'old'\n\n    def groebnersimp(ex, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function or e.is_Pow:\n                args = [trigsimp_groebner(x, **opts) for x in args]\n            return e.func(*args)\n        new = traverse(expr)\n        if not isinstance(new, Expr):\n            return new\n        return trigsimp_groebner(new, **opts)\n\n    trigsimpfunc = {\n        'fu': (lambda x: fu(x, **opts)),\n        'matching': (lambda x: futrig(x)),\n        'groebner': groebnersimp,\n        'combined': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[2, tan]))),\n        'old': lambda x: trigsimp_old(x, **opts),\n        }\n    \n    # Apply exptrigsimp preprocessing if expression contains exponentials\n    if expr.has(exp):\n        expr = exptrigsimp(expr)\n    \n    return trigsimpfunc[method](expr)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/sympy/sympy/simplify/trigsimp.py lines 504-513)": [
      "\n    trigsimpfunc = {\n        'fu': (lambda x: fu(x, **opts)),\n        'matching': (lambda x: futrig(x)),\n        'groebner': (lambda x: groebnersimp(x, **opts)),\n        'combined': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[2, tan]))),\n        'old': lambda x: trigsimp_old(x, **opts),\n                   }[method]\n\n    # Apply exptrigsimp as preprocessing if exponential functions are present\n    if expr.has(exp):\n        expr = exptrigsimp(expr)\n\n    return trigsimpfunc(expr)\n",
      "\n    trigsimpfunc = {\n        'fu': (lambda x: fu(x, **opts)),\n        'matching': (lambda x: futrig(x)),\n        'groebner': (lambda x: groebnersimp(x, **opts)),\n        'combined': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[2, tan]))),\n        'old': lambda x: trigsimp_old(x, **opts),\n                   }[method]\n\n    # Apply exptrigsimp as preprocessing for exponential expressions\n    from sympy.functions import exp\n    if expr.has(exp):\n        expr = exptrigsimp(expr)\n\n    return trigsimpfunc(expr)\n",
      "\n    trigsimpfunc = {\n        'fu': (lambda x: fu(x, **opts)),\n        'matching': (lambda x: futrig(x)),\n        'groebner': (lambda x: groebnersimp(x, **opts)),\n        'combined': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[2, tan]))),\n        'old': lambda x: trigsimp_old(x, **opts),\n                   }[method]\n\n    # Apply exptrigsimp as preprocessing to handle exponential expressions\n    processed_expr = exptrigsimp(expr)\n    return trigsimpfunc(processed_expr)\n",
      "\n    trigsimpfunc = {\n        'fu': (lambda x: fu(x, **opts)),\n        'matching': (lambda x: futrig(x)),\n        'groebner': (lambda x: groebnersimp(x, **opts)),\n        'combined': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[2, tan]))),\n        'old': lambda x: trigsimp_old(x, **opts),\n                   }[method]\n\n    # Apply exptrigsimp as preprocessing if exponential functions are present\n    if expr.has(exp):\n        expr = exptrigsimp(expr)\n    \n    return trigsimpfunc(expr)\n",
      "\n    trigsimpfunc = {\n        'fu': (lambda x: fu(exptrigsimp(x), **opts)),\n        'matching': (lambda x: futrig(exptrigsimp(x))),\n        'groebner': (lambda x: groebnersimp(exptrigsimp(x), **opts)),\n        'combined': (lambda x: futrig(groebnersimp(exptrigsimp(x),\n                               polynomial=True, hints=[2, tan]))),\n        'old': lambda x: trigsimp_old(exptrigsimp(x), **opts),\n                   }[method]\n\n    return trigsimpfunc(expr)\n",
      "\n    # Check if expression contains exponential functions and apply exptrigsimp first\n    from sympy.functions import exp\n    if expr.has(exp):\n        expr = exptrigsimp(expr)\n    \n    trigsimpfunc = {\n        'fu': (lambda x: fu(x, **opts)),\n        'matching': (lambda x: futrig(x)),\n        'groebner': (lambda x: groebnersimp(x, **opts)),\n        'combined': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[2, tan]))),\n        'old': lambda x: trigsimp_old(x, **opts),\n                   }[method]\n\n    return trigsimpfunc(expr)\n",
      "\n    # Apply exptrigsimp first if exponential functions are present\n    from sympy.functions import exp\n    if expr.has(exp):\n        expr = exptrigsimp(expr)\n    \n    trigsimpfunc = {\n        'fu': (lambda x: fu(x, **opts)),\n        'matching': (lambda x: futrig(x)),\n        'groebner': (lambda x: groebnersimp(x, **opts)),\n        'combined': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[2, tan]))),\n        'old': lambda x: trigsimp_old(x, **opts),\n                   }[method]\n\n    return trigsimpfunc(expr)\n",
      "\n    trigsimpfunc = {\n        'fu': (lambda x: fu(exptrigsimp(x), **opts)),\n        'matching': (lambda x: futrig(exptrigsimp(x))),\n        'groebner': (lambda x: groebnersimp(exptrigsimp(x), **opts)),\n        'combined': (lambda x: futrig(groebnersimp(exptrigsimp(x),\n                               polynomial=True, hints=[2, tan]))),\n        'old': lambda x: trigsimp_old(exptrigsimp(x), **opts),\n                   }[method]\n\n    return trigsimpfunc(expr)\n"
    ],
    "Location 2 (/root/hy/projects_2/sympy/sympy/simplify/trigsimp.py lines 487-490)": [
      "\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n        # Apply exptrigsimp preprocessing if exponential functions are present\n        if expr.has(exp):\n            expr = exptrigsimp(expr)\n    else:\n        method = 'old'\n",
      "\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n        # Apply exptrigsimp as preprocessing when exponential functions are present\n        if expr.has(exp):\n            expr = exptrigsimp(expr)\n    else:\n        method = 'old'\n",
      "\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n        # Apply exptrigsimp preprocessing if exponential functions are present\n        if expr.has(exp):\n            expr = exptrigsimp(expr)\n    else:\n        method = 'old'\n",
      "\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n        # Apply exptrigsimp as preprocessing when exponential functions are present\n        if expr.has(exp):\n            expr = exptrigsimp(expr)\n    else:\n        method = 'old'\n",
      "\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n        # Apply exptrigsimp preprocessing if exponential functions are present\n        if expr.has(exp):\n            expr = exptrigsimp(expr)\n    else:\n        method = 'old'\n",
      "\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n        \n        # Apply exptrigsimp preprocessing if exponential functions are present\n        if expr.has(exp):\n            expr = exptrigsimp(expr)\n    else:\n        method = 'old'\n",
      "\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n        # Apply exptrigsimp as preprocessing for exponential expressions\n        if any(atom.func.__name__ == 'exp' for atom in expr.atoms() if hasattr(atom, 'func')):\n            expr = exptrigsimp(expr)\n    else:\n        method = 'old'\n",
      "\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n        # Apply exptrigsimp as preprocessing when exponential functions are present\n        if expr.has(exp):\n            expr = exptrigsimp(expr)\n    else:\n        method = 'old'\n"
    ],
    "Location 3 (/root/hy/projects_2/sympy/sympy/simplify/trigsimp.py lines 516-530)": [
      "\ndef exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    Examples\n    ========\n\n    >>> from sympy import exptrigsimp, exp, cosh, sinh\n    >>> from sympy.abc import z\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n    from sympy.simplify.simplify import bottom_up\n\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        choices.append(e.rewrite(cos))\n        # Also try rewriting exp in terms of trig functions\n        if e.has(exp):\n            choices.append(e.rewrite(sin))\n            choices.append(e.rewrite(cos))\n        return min(choices, key=count_ops)\n\n    newexpr = bottom_up(expr, exp_trig)\n\n    # if we didn't change anything and we don't have exp functions,\n    # return the original expression\n    if newexpr == expr and not expr.has(exp):\n        return expr\n\n    # Perform additional trigonometric simplifications\n    from sympy.simplify.fu import TR10i\n    newexpr = TR10i(newexpr)\n    \n    # Convert any remaining complex exponentials to trig functions\n    newexpr = newexpr.rewrite(cos).rewrite(sin)\n    \n    return newexpr\n",
      "\ndef exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    Examples\n    ========\n\n    >>> from sympy import exptrigsimp, exp, cosh, sinh\n    >>> from sympy.abc import z\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n    from sympy.simplify.simplify import bottom_up\n\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        choices.append(e.rewrite(cos))\n        # Also try rewriting exponentials to trigonometric functions\n        if e.has(exp):\n            choices.append(e.rewrite(sin))\n            choices.append(e.rewrite(cos))\n        return min(choices, key=count_ops)\n\n    newexpr = bottom_up(expr, exp_trig)\n\n    # if we didn't change anything and we don't have trig functions\n    # then we can try the fu function\n    if newexpr == expr and not newexpr.has(*_trigs):\n        return expr\n\n    newexpr = TR2i(newexpr)\n    if not newexpr.has(*_trigs):\n        return newexpr\n\n    return newexpr\n",
      "\ndef exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    Examples\n    ========\n\n    >>> from sympy import exptrigsimp, exp, cosh, sinh\n    >>> from sympy.abc import z\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n    from sympy.simplify.simplify import bottom_up\n\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        choices.append(e.rewrite(cos))\n        # Also try rewriting exponentials to trigonometric functions\n        if e.has(exp):\n            choices.append(e.rewrite(sin))\n            choices.append(e.rewrite(cos))\n        return min(choices, key=count_ops)\n\n    newexpr = bottom_up(expr, exp_trig)\n\n    # conversion from exp to hyperbolic functions\n    res = TR2i(newexpr)\n    if res != newexpr:\n        return res\n\n    # if we didn't change much or at all, try the fu method\n    if res.count_ops() >= expr.count_ops():\n        res = fu(expr)\n\n    return res\n",
      "\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', 'old', and 'fu'. If 'matching', simplify the\n    expression recursively by targeting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'old' is the\n    original SymPy algorithm.\n\n    compare:\n    - show input and output from `trigsimp` and `futrig` when different,\n    but returns the `trigsimp` result.\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e)\n    2\n    >>> trigsimp(log(e))\n    log(2*sin(x)**2 + 2*cos(x)**2)\n    >>> trigsimp(log(e), deep=True)\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n    simplification.\n\n    The old trigsimp routine can be accessed as with method 'old'.\n\n    >>> from sympy import coth, tanh\n    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n    >>> trigsimp(t, method='old') == t\n    True\n    >>> trigsimp(t)\n    tanh(x)**7\n\n    \"\"\"\n    from sympy.simplify.fu import fu\n\n    expr = sympify(expr)\n\n    _eval_trigsimp = getattr(expr, '_eval_trigsimp', None)\n    if _eval_trigsimp is not None:\n        return _eval_trigsimp(**opts)\n\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n    else:\n        method = 'old'\n\n    def groebnersimp(ex, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function and isinstance(e, TrigonometricFunction):\n                e = e.func(*args)\n                if e.is_Mul:\n                    ret = []\n                    for x in e.args:\n                        if isinstance(x, TrigonometricFunction):\n                            ret.append(x)\n                    if ret:\n                        return trigsimp_groebner(e, **opts)\n                return e\n            return e.func(*args)\n        new = traverse(ex)\n        if not isinstance(new, Expr):\n            return new\n        return trigsimp_groebner(new, **opts)\n\n    # Apply exptrigsimp first if expression contains exponential functions\n    if expr.has(exp):\n        expr = exptrigsimp(expr)\n\n    trigsimpfunc = {\n        'fu': (lambda x: fu(x, **opts)),\n        'matching': (lambda x: futrig(x)),\n        'groebner': (lambda x: groebnersimp(x, **opts)),\n        'combined': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[2, tan]))),\n        'old': lambda x: trigsimp_old(x, **opts),\n                   }[method]\n\n    return trigsimpfunc(expr)\n",
      "\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', and 'fu'. If 'matching', simplify the\n    expression recursively by targeting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring).\n\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e)\n    2\n\n    Simplification occurs wherever trigonometric functions are located.\n\n    >>> trigsimp(log(e))\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n    simplification.\n\n    The old trigsimp routine can be accessed as with method 'old'.\n\n    >>> from sympy import coth, tanh\n    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n    >>> trigsimp(t, method='old') == t\n    True\n    >>> trigsimp(t)\n    tanh(x)**7\n\n    \"\"\"\n    from sympy.simplify.fu import fu\n\n    expr = sympify(expr)\n\n    _eval_trigsimp = getattr(expr, '_eval_trigsimp', None)\n    if _eval_trigsimp is not None:\n        return _eval_trigsimp(**opts)\n\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n    else:\n        method = 'old'\n\n    def groebnersimp(ex, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function and isinstance(e, TrigonometricFunction):\n                e = e.func(*args)\n                if e.is_Function and isinstance(e, TrigonometricFunction):\n                    e = trigsimp_groebner(e, **opts)\n                return e\n            return e.func(*args)\n        new = traverse(expr)\n        if not isinstance(new, Expr):\n            return new\n        return trigsimp_groebner(new, **opts)\n\n    # Apply exptrigsimp first if expression contains exponential functions\n    if expr.has(exp):\n        expr = exptrigsimp(expr)\n\n    trigsimpfunc = {\n        'fu': (lambda x: fu(x, **opts)),\n        'matching': (lambda x: futrig(x)),\n        'groebner': (lambda x: groebnersimp(x, **opts)),\n        'combined': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[2, tan]))),\n        'old': lambda x: trigsimp_old(x, **opts),\n                   }[method]\n\n    return trigsimpfunc(expr)\n",
      "\ndef exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    Examples\n    ========\n\n    >>> from sympy import exptrigsimp, exp, cosh, sinh\n    >>> from sympy.abc import z\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n    from sympy.simplify.simplify import bottom_up\n\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        choices.append(e.rewrite(cos))\n        # Add sine rewrite to catch exponential forms that become sine\n        if e.has(exp):\n            choices.append(e.rewrite(sin))\n        return min(choices, key=count_ops)\n\n    newexpr = bottom_up(expr, exp_trig)\n\n    # if we didn't change anything and we don't have trig functions\n    # then skip the fu step\n    if newexpr == expr and not newexpr.has(*_trigs):\n        return expr\n\n    # otherwise use fu on everything\n    newexpr = fu(newexpr)\n\n    # rewrite hyperbolics in terms of exp\n    newexpr = newexpr.replace(\n        lambda x: isinstance(x, HyperbolicFunction), hyper_as_trig)\n\n    # if that introduced trig functions, fu it again to reduce then\n    # rewrite in terms of exp once more\n    if newexpr.has(*_trigs):\n        newexpr = fu(newexpr)\n        newexpr = TR2i(newexpr)\n\n    # finally, rewrite in terms of cos if possible (if the expression\n    # is not already in terms of exp)\n    if not newexpr.has(exp):\n        newexpr = newexpr.rewrite(cos)\n\n    return newexpr\n",
      "\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', and 'fu'. If 'matching', simplify the\n    expression recursively by targeting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``groebnersimp``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs\n    the collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring).\n\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e)\n    2\n\n    Simplification occurs wherever trigonometric functions are located.\n\n    >>> trigsimp(log(e))\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n    simplification.\n\n    The old trigsimp routine can be accessed as with method 'old'.\n\n    >>> from sympy import coth, tanh\n    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n    >>> trigsimp(t, method='old') == t\n    True\n    >>> trigsimp(t)\n    tanh(x)**7\n\n    \"\"\"\n    from sympy.simplify.fu import fu\n\n    expr = sympify(expr)\n\n    _eval_trigsimp = getattr(expr, '_eval_trigsimp', None)\n    if _eval_trigsimp is not None:\n        return _eval_trigsimp(**opts)\n\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n    else:\n        method = 'old'\n\n    def groebnersimp(ex, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function and isinstance(e, TrigonometricFunction):\n                e = e.func(*args)\n                if e.is_Mul:\n                    return trigsimp_groebner(e, **opts)\n                return e\n            return e.func(*args)\n        new = traverse(expr)\n        if not isinstance(new, Expr):\n            return new\n        return trigsimp_groebner(new, **opts)\n\n    # Apply exptrigsimp first if expression contains exponential functions\n    if expr.has(exp):\n        expr = exptrigsimp(expr)\n\n    trigsimpfunc = {\n        'fu': (lambda x: fu(x, **opts)),\n        'matching': (lambda x: futrig(x)),\n        'groebner': (lambda x: groebnersimp(x, **opts)),\n        'combined': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[2, tan]))),\n        'old': lambda x: trigsimp_old(x, **opts),\n                   }[method]\n\n    return trigsimpfunc(expr)\n",
      "\ndef exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    Examples\n    ========\n\n    >>> from sympy import exptrigsimp, exp, cosh, sinh\n    >>> from sympy.abc import z\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n    from sympy.simplify.simplify import bottom_up\n\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        choices.append(e.rewrite(cos))\n        # Also try rewriting in terms of sin for expressions like exp(I*x) - exp(-I*x)\n        if e.has(exp):\n            choices.append(e.rewrite(sin))\n        return min(choices, key=count_ops)\n\n    newexpr = bottom_up(expr, exp_trig)\n\n    # XXX todo: deal with sin(x)*cos(x) -> sin(2*x)/2 ...\n    # do one pass to see if any exp's can be simplified.\n    newexpr = bottom_up(newexpr, _osborne)\n    newexpr = bottom_up(newexpr, _osbornei)\n\n    newexpr = bottom_up(newexpr, lambda x: _eapply(x, _mexpand))\n    newexpr = TR2i(newexpr)\n    if newexpr.has(HyperbolicFunction):\n        newexpr = hyper_as_trig(newexpr)\n        newexpr = TR2i(newexpr)\n    # can we ever generate an I where there was none previously?\n    if not (newexpr.has(I) and not expr.has(I)):\n        expr = newexpr\n    return expr\n"
    ],
    "Location 4 (/root/hy/projects_2/sympy/sympy/simplify/trigsimp.py lines 534-542)": [
      "\ndef exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    When ``deep`` is True, the ``expr`` is rewritten in terms of the most\n    economical trigonometric functions. If the expression is a sum or\n    product, this is done term-wise. The result is then passed through\n    the ``trigsimp`` routine. For better results, ``expr`` may be expanded\n    with ``expand_trig`` first.\n\n    Examples\n    ========\n\n    >>> from sympy import exptrigsimp, exp, cosh, sinh\n    >>> from sympy.abc import z\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n    from sympy.simplify.simplify import bottom_up\n\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        if e.has(exp):\n            choices.append(e.rewrite(sin))\n            choices.append(e.rewrite(cos))\n        choices.append(e.rewrite(cos))\n        return min(*choices, key=count_ops)\n    newexpr = bottom_up(expr, exp_trig)\n",
      "\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', 'fu' and 'old'. If 'matching', simplify the\n    expression recursively by targeting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring). If 'old', uses the old version of trigsimp\n    (SymPy 0.7.0 and earlier).\n\n    compare:\n    - show input and output from `trigsimp` and `futrig` when different,\n    but returns the `trigsimp` result.\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e)\n    2\n\n    Simplification occurs wherever trigonometric functions are located.\n\n    >>> trigsimp(log(e))\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n    simplification.\n\n    The old trigsimp routine can be accessed as\n\n    >>> from sympy import cot\n    >>> trigsimp(sin(x)/cos(x), method='old')\n    tan(x)\n\n    \"\"\"\n    from sympy.simplify.fu import fu\n\n    expr = sympify(expr)\n\n    _eval_trigsimp = getattr(expr, '_eval_trigsimp', None)\n    if _eval_trigsimp is not None:\n        return _eval_trigsimp(**opts)\n\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n    else:\n        method = 'old'\n\n    def groebnersimp(ex, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function and e.func in (TrigonometricFunction, HyperbolicFunction):\n                e = e.func(*args)\n                return trigsimp_groebner(e, **opts)\n            return e.func(*args)\n        new = traverse(expr)\n        if not isinstance(expr, Basic):\n            return new\n        return new\n\n    trigsimpfunc = {\n        'fu': (lambda x: fu(x, **opts)),\n        'matching': (lambda x: futrig(x)),\n        'groebner': groebnersimp,\n        'combined': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[2, tan]))),\n        'old': lambda x: trigsimp_old(x, **opts),\n    }\n    \n    # Apply exptrigsimp first if exponential functions are present\n    if expr.has(exp):\n        expr = exptrigsimp(expr)\n    \n    return trigsimpfunc[method](expr)\n",
      "\ndef exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    When ``deep`` is True, the ``trigsimp`` function is applied to all parts\n    of the expression, except to those parts which are not trigonometric\n    (e.g. polynomials).\n\n    Examples\n    ========\n\n    >>> from sympy import symbols, sin, cos, exp, I, sinh, cosh, tan, tanh\n    >>> from sympy.simplify.trigsimp import exptrigsimp\n    >>> from sympy.abc import z\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n    from sympy.simplify.simplify import bottom_up\n\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        if e.has(exp, I):\n            # Try rewriting exponentials with I to trigonometric functions\n            choices.append(e.rewrite(cos))\n            choices.append(e.rewrite(sin))\n        choices.append(e.rewrite(cos))\n        return min(*choices, key=count_ops)\n    newexpr = bottom_up(expr, exp_trig)\n",
      "\ndef exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    When ``deep`` is True, the arguments of the functions are also simplified.\n\n    Examples\n    ========\n\n    >>> from sympy import exptrigsimp, exp, cosh, sinh\n    >>> from sympy.abc import z\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n    from sympy.simplify.simplify import bottom_up\n\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        choices.append(e.rewrite(cos))\n        # Also try rewriting exponentials to trigonometric functions\n        if e.has(exp):\n            choices.append(e.rewrite(sin))\n            choices.append(e.rewrite(cos))\n        return min(*choices, key=count_ops)\n    newexpr = bottom_up(expr, exp_trig)\n",
      "\ndef exp_trig(e):\n    # select the better of e, and e rewritten in terms of exp or trig\n    # functions\n    choices = [e]\n    if e.has(*_trigs):\n        choices.append(e.rewrite(exp))\n    if e.has(exp):\n        choices.append(e.rewrite(sin))\n        choices.append(e.rewrite(cos))\n    choices.append(e.rewrite(cos))\n    return min(*choices, key=count_ops)\nnewexpr = bottom_up(expr, exp_trig)\n",
      "\ndef exp_trig(e):\n    # select the better of e, and e rewritten in terms of exp or trig\n    # functions\n    choices = [e]\n    if e.has(*_trigs):\n        choices.append(e.rewrite(exp))\n    if e.has(exp):\n        choices.append(e.rewrite(sin))\n        choices.append(e.rewrite(cos))\n    choices.append(e.rewrite(cos))\n    return min(*choices, key=count_ops)\nnewexpr = bottom_up(expr, exp_trig)\n",
      "\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', 'fu' and 'old'. If 'matching', simplify the\n    expression recursively by targeting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring). If 'old', uses the old SymPy algorithm.\n\n    compare:\n    - show input and output from `trigsimp` and `futrig` when different,\n    but returns the `trigsimp` result.\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e)\n    2\n    >>> trigsimp(log(e))\n    log(2*sin(x)**2 + 2*cos(x)**2)\n    >>> trigsimp(log(e), deep=True)\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n    simplification.\n\n    The old trigsimp routine can be accessed as with method 'old'.\n\n    >>> from sympy import coth, tanh\n    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n    >>> trigsimp(t, method='old') == t\n    True\n    >>> trigsimp(t)\n    tanh(x)**7\n\n    \"\"\"\n    from sympy.simplify.fu import fu\n\n    expr = sympify(expr)\n\n    _eval_trigsimp = getattr(expr, '_eval_trigsimp', None)\n    if _eval_trigsimp is not None:\n        return _eval_trigsimp(**opts)\n\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n    else:\n        method = 'old'\n\n    def groebnersimp(ex, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function and e.func in _trigs:\n                args = [trigsimp_groebner(x, **opts) for x in args]\n            return e.func(*args)\n        new = traverse(ex)\n        if not isinstance(new, Expr):\n            return new\n        return trigsimp_groebner(new, **opts)\n\n    def futrig(e, **kwargs):\n        return fu(e, **kwargs)\n\n    # Apply exptrigsimp preprocessing if expression contains exponentials\n    if expr.has(exp):\n        expr = exptrigsimp(expr)\n\n    trigsimpfunc = {\n        'fu': futrig,\n        'matching': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[2, tan]))),\n        'groebner': groebnersimp,\n        'combined': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[2]))),\n        'old': lambda x: trigsimp_old(x, **opts),\n        }\n    return trigsimpfunc[method](expr, **opts)\n",
      "\ndef exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    This takes a much more aggressive approach than the other\n    simplification routines, and is capable of returning results in a\n    number of cases where the other routines fail.\n    However, it also fails in some cases.  This routine uses a combination of the\n    hyperbolics-to-trig identities in ``fu`` as well as using ``rewrite`` to\n    express the expression in terms of ``exp``, and then converting back to\n    trig.  ``fu`` and the rewriting approach are applied until there are no\n    more reductions possible.\n\n    Examples\n    ========\n\n    >>> from sympy import exptrigsimp, sinh, cosh, exp, I, sin, cos\n    >>> from sympy.abc import z, k\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    \n    It can also convert exponential expressions to trigonometric forms:\n    \n    >>> exptrigsimp(I/2*(exp(-I*k) - exp(I*k)))\n    sin(k)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n    from sympy.simplify.simplify import bottom_up\n\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        # Always try rewriting in terms of cos/sin to catch exponential expressions\n        choices.append(e.rewrite(cos))\n        choices.append(e.rewrite(sin))\n        return min(*choices, key=count_ops)\n    newexpr = bottom_up(expr, exp_trig)\n"
    ],
    "Location 5 (/root/hy/projects_2/sympy/sympy/simplify/trigsimp.py lines 593-602)": [
      "\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', 'fu' and 'old'. If 'matching', simplify the\n    expression recursively by targetting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring) while `old` refers to a prior implementation of\n    trigsimp.\n\n    compare:\n    - show input and output from `trigsimp` and `fu` when different,\n    but returns the `trigsimp` result.\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log, cot\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e)\n    2\n    >>> trigsimp(log(e))\n    log(2*sin(x)**2 + 2*cos(x)**2)\n    >>> trigsimp(log(e), deep=True)\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) can sometimes lead to a lot\n    more simplification:\n\n    >>> e = (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)\n    >>> trigsimp(e)\n    (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)\n    >>> trigsimp(e, method=\"groebner\")\n    2/cos(x)\n\n    >>> trigsimp(1/cot(x)**2, compare=True)\n          trigsimp: tan(x)**2\n                fu: tan(x)**2\n\n    \"\"\"\n    from sympy.simplify.fu import fu\n\n    expr = sympify(expr)\n\n    _eval_trigsimp = getattr(expr, '_eval_trigsimp', None)\n    if _eval_trigsimp is not None:\n        return _eval_trigsimp(**opts)\n\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n\n        def groebnersimp(ex, **opts):\n            def traverse(e):\n                if e.is_Atom:\n                    return e\n                args = [traverse(x) for x in e.args]\n                if e.is_Function and e.func in (TrigonometricFunction, HyperbolicFunction):\n                    args = [trigsimp_groebner(x, **opts) for x in args]\n                return e.func(*args)\n            new = traverse(expr)\n            if not isinstance(new, Expr):\n                return new\n            return trigsimp_groebner(new, **opts)\n\n        trigsimpfunc = {\n            'fu': (lambda x: fu(x, **opts)),\n            'matching': (lambda x: futrig(x)),\n            'groebner': groebnersimp,\n            'combined': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[2, tan]))),\n            'old': lambda x: trigsimp_old(x, **opts),\n        }\n\n        # Apply exptrigsimp preprocessing if expression contains exponentials\n        if expr.has(exp):\n            expr = exptrigsimp(expr)\n\n        return trigsimpfunc[method](expr)\n\n    return trigsimp_old(expr, **opts)\n",
      "\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', 'fu' and 'old'. If 'matching', simplify the\n    expression recursively by targeting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring). If 'old', uses the old trigsimp routine.\n\n    compare:\n    - show input and output from `trigsimp` and `futrig` when different,\n    but returns the `trigsimp` result.\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log, cosh\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e)\n    2\n    >>> trigsimp(log(e))\n    log(2*sin(x)**2 + 2*cos(x)**2)\n    >>> trigsimp(log(e), deep=True)\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) can sometimes lead to a lot\n    more simplification:\n\n    >>> e = (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)\n    >>> trigsimp(e)\n    (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)\n    >>> trigsimp(e, method=\"groebner\")\n    2/cos(x)\n\n    >>> trigsimp(1/cosh(x) - tanh(x))\n    1/cosh(x) - tanh(x)\n    >>> trigsimp(1/cosh(x) - tanh(x), method=\"groebner\")\n    1/(exp(x) + 1)\n\n    \"\"\"\n    from sympy.simplify.fu import fu\n\n    expr = sympify(expr)\n\n    _eval_trigsimp = getattr(expr, '_eval_trigsimp', None)\n    if _eval_trigsimp is not None:\n        return _eval_trigsimp(**opts)\n\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n    else:\n        method = 'old'\n\n    def groebnersimp(ex, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function or e.is_Pow:\n                args = [trigsimp_groebner(x, **opts) for x in args]\n            return e.func(*args)\n        new = traverse(ex)\n        if not isinstance(new, Expr):\n            return new\n        return trigsimp_groebner(new, **opts)\n\n    trigsimpfunc = {\n        'fu': (lambda x: fu(x, **opts)),\n        'matching': (lambda x: futrig(x)),\n        'groebner': (lambda x: groebnersimp(x, **opts)),\n        'combined': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[2, tan]))),\n        'old': lambda x: trigsimp_old(x, **opts),\n                   }\n    \n    # Apply exptrigsimp as preprocessing if expression contains exponentials\n    if expr.has(exp):\n        expr = exptrigsimp(expr)\n    \n    return trigsimpfunc[method](expr)\n",
      "\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', 'fu' and 'old'. If 'matching', simplify the\n    expression recursively by targeting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring). If 'old', uses the old SymPy trig\n    simplification algorithm.\n\n    compare:\n    - show input and output from `trigsimp` and `futrig` when different,\n    but returns the `trigsimp` result.\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e)\n    2\n    >>> trigsimp(log(e))\n    log(2*sin(x)**2 + 2*cos(x)**2)\n    >>> trigsimp(log(e), deep=True)\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n    simplification.\n\n    The old trigsimp routine can be accessed as\n\n    >>> from sympy import trigsimp_old\n    >>> trigsimp_old(sin(x)**2 + cos(x)**2)\n    1\n\n    \"\"\"\n    from sympy.simplify.fu import fu\n\n    expr = sympify(expr)\n\n    _eval_trigsimp = getattr(expr, '_eval_trigsimp', None)\n    if _eval_trigsimp is not None:\n        return _eval_trigsimp(**opts)\n\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n\n        def groebnersimp(ex, **opts):\n            def traverse(e):\n                if e.is_Atom:\n                    return e\n                args = [traverse(x) for x in e.args]\n                if e.is_Function and isinstance(e, TrigonometricFunction):\n                    args = [trigsimp_groebner(x, **opts) for x in args]\n                return e.func(*args)\n            new = traverse(expr)\n            if not isinstance(new, Expr):\n                return new\n            return trigsimp_groebner(new, **opts)\n\n        def futrig(e, **opts):\n            return fu(e, **opts)\n\n        def matching(expr, **opts):\n            return futrig(trigsimp_groebner(expr, **opts))\n\n        def combined(expr, **opts):\n            return futrig(trigsimp_groebner(expr, polynomial=True, hints=[2, tan]))\n\n        def exptrigsimp_wrapper(expr, **opts):\n            # Apply exptrigsimp first to convert exponentials to trig functions\n            from sympy import exp\n            if expr.has(exp):\n                expr = exptrigsimp(expr)\n            return expr\n\n        trigsimpfunc = {\n            'fu': futrig,\n            'matching': matching,\n            'groebner': groebnersimp,\n            'combined': combined,\n            'old': lambda x, **opts: trigsimp_old(x, **opts),\n        }\n\n        # Apply exptrigsimp preprocessing if expression contains exponentials\n        from sympy import exp\n        if expr.has(exp):\n            expr = exptrigsimp(expr)\n\n        return trigsimpfunc[method](expr, **opts)\n\n    return trigsimp_old(expr, **opts)\n",
      "\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', 'fu' and 'old'. If 'matching', simplify the\n    expression recursively by targeting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring).\n\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e)\n    2\n\n    Simplification occurs wherever trigonometric functions are located.\n\n    >>> trigsimp(log(e))\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n    simplification.\n\n    The old trigsimp routine can be accessed as with method 'old'.\n\n    >>> from sympy import coth, tanh\n    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n    >>> trigsimp(t, method='old') == t\n    True\n    >>> trigsimp(t)\n    tanh(x)**7\n\n    \"\"\"\n    from sympy.simplify.fu import fu\n\n    expr = sympify(expr)\n\n    _eval_trigsimp = getattr(expr, '_eval_trigsimp', None)\n    if _eval_trigsimp is not None:\n        return _eval_trigsimp(**opts)\n\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n    else:\n        method = 'old'\n\n    def groebnersimp(ex, **opts):\n        def traverse(e, **opts):\n            if e.is_Atom:\n                return e\n            args = [traverse(a, **opts) for a in e.args]\n            if e.is_Function and hasattr(e, '_eval_trigsimp'):\n                e = e._eval_trigsimp(**opts)\n            if not isinstance(e, TrigonometricFunction):\n                e = e.func(*args)\n            try:\n                e = trigsimp_groebner(e, **opts)\n            except ValueError:\n                pass\n            return e\n        new = traverse(ex, **opts)\n        if not isinstance(new, Expr):\n            return new\n        return trigsimp_groebner(new, **opts)\n\n    def combsimp(ex, **opts):\n        return trigsimp(groebnersimp(ex,\n                       polynomials=True, hints=[2, tan]),\n                       method='matching')\n\n    def matchsimp(ex, **opts):\n        return futrig(ex)\n\n    def fuids(ex, **opts):\n        return fu(ex)\n\n    def oldsimp(ex, **opts):\n        return trigsimp_old(ex, **opts)\n\n    # Apply exptrigsimp as preprocessing if expression contains exponentials\n    if expr.has(exp):\n        expr = exptrigsimp(expr)\n\n    trigsimpfunc = {\n        'fu': fuids,\n        'matching': matchsimp,\n        'groebner': groebnersimp,\n        'combined': combsimp,\n        'old': oldsimp\n        }\n    return trigsimpfunc[method](expr, **opts)\n",
      "\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', 'old', and 'fu'. If 'matching', simplify the\n    expression recursively by targeting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'old' is the\n    original SymPy algorithm.\n\n    compare:\n    - show input and output from `trigsimp` and `futrig` when different,\n    but returns the `trigsimp` result.\n\n    hint:\n    - a list of transformations to use that might help the algorithm\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e)\n    2\n    >>> trigsimp(log(e))\n    log(2*sin(x)**2 + 2*cos(x)**2)\n    >>> trigsimp(log(e), deep=True)\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n    simplification.\n\n    The old trigsimp routine can be accessed as with method 'old'.\n\n    >>> from sympy import coth, tanh\n    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n    >>> trigsimp(t, method='old') == t\n    True\n    >>> trigsimp(t)\n    tanh(x)**7\n\n    \"\"\"\n    from sympy.simplify.fu import fu\n\n    expr = sympify(expr)\n\n    _eval_trigsimp = getattr(expr, '_eval_trigsimp', None)\n    if _eval_trigsimp is not None:\n        return _eval_trigsimp(**opts)\n\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n\n        def groebnersimp(ex, **opts):\n            def traverse(e):\n                if e.is_Atom:\n                    return e\n                args = [traverse(x) for x in e.args]\n                if e.is_Function and isinstance(e, TrigonometricFunction):\n                    args = [trigsimp_groebner(x, **opts) for x in args]\n                return e.func(*args)\n            new = traverse(ex)\n            if not isinstance(new, Expr):\n                return new\n            return trigsimp_groebner(new, **opts)\n\n        def futrig(e):\n            return fu(e, hyper=False)\n\n        trigsimpfunc = {\n            'fu': futrig,\n            'matching': (lambda x: futrig(groebnersimp(x, polynomial=True, hints=[]))),\n            'groebner': groebnersimp,\n            'combined': (lambda x: futrig(groebnersimp(x, polynomial=True, hints=[]))),\n            'old': lambda x: trigsimp_old(x, **opts),\n        }\n        \n        # Apply exptrigsimp preprocessing if expression contains exponentials\n        if expr.has(exp):\n            expr = exptrigsimp(expr)\n        \n        return trigsimpfunc[method](expr)\n\n    return trigsimp_old(expr, **opts)\n\n\n#-------------------- end of main trigsimp routines --------------------\n\ndef exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    Examples\n    ========\n\n    >>> from sympy import exptrigsimp, exp, cosh, sinh\n    >>> from sympy.abc import z\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n    from sympy.simplify.simplify import bottom_up, simplify\n\n    def exp_trig(e):\n        # select the better of e, and ret pretty much the same\n        # as what trig_split produced, except that exp's have\n        # been expanded to trig functions but lists\n        # of sums are broken into more sums by\n        # rewrite(exp, cos) than by rewrite(exp, sin)\n        choices = [e]\n        if e.has(exp):\n            choices.append(e.rewrite(exp, sin))\n            choices.append(e.rewrite(exp, cos))\n        choices.append(e.rewrite(exp))\n        return min(choices, key=count_ops)\n\n    newexpr = bottom_up(expr, exp_trig)\n\n    def f(rv):\n        if not rv.is_Mul:\n            return rv\n        rvd = rv.as_powers_dict()\n        newd = rvd.copy()\n\n        for k, m in rvd.items():\n            # rewrite hyperbolic functions in terms of exp\n            for t in [sinh, cosh, tanh, coth]:\n                if k.has(t):\n                    k = k.rewrite(t, exp)\n                    if k != rv:\n                        newd[k] += newd.pop(rv, 0)\n                        break\n\n            if k.is_Add:\n                args = k.args\n                if len(args) == 2:\n                    a, b = args\n                    if a == -b:\n                        if a.is_Mul:\n                            a, b = a.as_two_terms()\n                            if a.is_Pow and a.exp.is_integer:\n                                # get the sign right\n                                if a.base == S.Exp1:\n                                    sign = 1\n                                elif a.base == exp(-1):\n                                    sign = -1\n                                else:\n                                    continue\n                                if b == sign*S.ImaginaryUnit:\n                                    k = sin\n                                elif b == sign:\n                                    k = sinh\n                                elif b == -sign*S.ImaginaryUnit:\n                                    k = cos\n                                elif b == -sign:\n                                    k = cosh\n                                else:\n                                    continue\n                                newd[k(abs(a.exp))] += m\n                                newd.pop(rv)\n\n                        elif a.is_Pow and a.exp.is_integer:\n                            if a.base == S.Exp1:\n                                sign = 1\n                            elif a.base == exp(-1):\n                                sign = -1\n                            else:\n                                continue\n                            newd[2*cosh(abs(a.exp))] += m\n                            newd.pop(rv)\n\n                elif len(args) == 3:\n                    # similar to above, but for sin and cos\n                    # looking for Mul terms\n                    # check for the pattern a*exp(I*x) + b*exp(-I*x) + c\n                    a, b, c = args\n                    if (a.is_Mul and b.is_Mul and \n                        len(a.args) == 2 and len(b.args) == 2):\n                        # Get the coefficient and exponential parts\n                        coeff_a, exp_a = a.as_two_terms()\n                        coeff_b, exp_b = b.as_two_terms()\n                        \n                        # Check if we have the pattern coeff*exp(I*x) + coeff*exp(-I*x)\n                        if (exp_a.is_Pow and exp_b.is_Pow and\n                            exp_a.base == S.Exp1 and exp_b.base == S.Exp1 and\n                            exp_a.exp == -exp_b.exp and\n                            exp_a.exp.is_Mul and len(exp_a.exp.args) == 2):\n                            \n                            exp_coeff, exp_arg = exp_a.exp.as_two_terms()\n                            if exp_coeff == S.ImaginaryUnit:\n                                # We have exp(I*x) and exp(-I*x) pattern\n                                if coeff_a == -coeff_b and coeff_a == -S.ImaginaryUnit/2:\n                                    # Pattern: -I/2*exp(I*x) + I/2*exp(-I*x) = sin(x)\n                                    newd[sin(exp_arg)] += m\n                                    newd.pop(rv)\n                                elif coeff_a == coeff_b and coeff_a == S.One/2:\n                                    # Pattern: 1/2*exp(I*x) + 1/2*exp(-I*x) = cos(x)\n                                    newd[cos(exp_arg)] += m\n                                    newd.pop(rv)\n\n        return Mul(*[k**newd[k] for k in newd])\n    newexpr = bottom_up(newexpr, f)\n\n    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n    if newexpr.has(HyperbolicFunction):\n        e, f = hyper_as_trig(newexpr)\n        newexpr = f(TR2i(e))\n    if newexpr.has(TrigonometricFunction):\n        newexpr = TR2i(newexpr)\n\n    # can we ever generate an I where there was none previously?\n    if not (newexpr.has(I) and not expr.has(I)):\n        expr = newexpr\n    return expr\n",
      "\n    # Apply exptrigsimp preprocessing if expression contains exponentials\n    if expr.has(exp):\n        expr = exptrigsimp(expr)\n    \n    if opts.pop('compare', False):\n        f = lambda x: futrig(x, **opts)\n        g = lambda x: _trigsimp(x, **opts)\n        return _compare(expr, f, g)\n\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n    else:\n        method = 'old'\n\n    def groebnersimp(ex, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function and isinstance(e, TrigonometricFunction):\n                e = e.func(*args)\n                if e.is_Function and isinstance(e, TrigonometricFunction):\n                    return _trigsimp(e, **opts)\n                return e\n            return e.func(*args)\n        new = traverse(ex)\n        if not isinstance(new, Expr):\n            return new\n        return _trigsimp(new, deep)\n\n    trigsimpfunc = {\n        'fu': (lambda x: fu(x, **opts)),\n        'matching': (lambda x: futrig(x)),\n        'groebner': groebnersimp,\n        'combined': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[]))),\n        'old': lambda x: trigsimp_old(x, **opts),\n                   }\n    return trigsimpfunc[method](expr)\n",
      "\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', 'fu' and 'old'. If 'matching', simplify the\n    expression recursively by targeting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring).\n\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e)\n    2\n\n    Simplification occurs wherever trigonometric functions are located.\n\n    >>> trigsimp(log(e))\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n    simplification.\n\n    The old trigsimp routine can be accessed as with method 'old'.\n\n    >>> from sympy import coth, tanh\n    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n    >>> trigsimp(t, method='old') == t\n    True\n    >>> trigsimp(t)\n    tanh(x)**7\n\n    \"\"\"\n    from sympy.simplify.fu import fu\n\n    expr = sympify(expr)\n\n    _eval_trigsimp = getattr(expr, '_eval_trigsimp', None)\n    if _eval_trigsimp is not None:\n        return _eval_trigsimp(**opts)\n\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n    else:\n        method = 'old'\n\n    def groebnersimp(ex, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function and isinstance(e, TrigonometricFunction):\n                e = e.func(*args)\n                e = trigsimp_groebner(e, **opts)\n                return e\n            return e.func(*args)\n        new = traverse(expr)\n        if not isinstance(new, Expr):\n            return new\n        return trigsimp_groebner(new, **opts)\n\n    trigsimpfunc = {\n        'fu': (lambda x: fu(x, **opts)),\n        'matching': (lambda x: futrig(x)),\n        'groebner': (lambda x: groebnersimp(x, **opts)),\n        'combined': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[2, tan]))),\n        'old': lambda x: trigsimp_old(x, **opts),\n    }\n\n    # Apply exptrigsimp as preprocessing if exponential functions are present\n    if expr.has(exp):\n        expr = exptrigsimp(expr)\n    \n    return trigsimpfunc[method](expr)\n",
      "\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', 'old', and 'fu'. If 'matching', simplify the\n    expression recursively by targeting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'old' is the\n    original implementation. If 'fu', the expression is rewritten using\n    a collection of transformations (see fu docstring) that mimic those in\n    Axiom.\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e)\n    2\n\n    Simplification occurs wherever trigonometric functions are located.\n\n    >>> trigsimp(log(e))\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n    simplification.\n\n    The old trigsimp routine can be accessed as\n\n    >>> from sympy import trigsimp_old\n    >>> trigsimp_old(sin(x)**2 + cos(x)**2)\n    1\n\n    \"\"\"\n    from sympy.simplify.fu import fu\n\n    expr = sympify(expr)\n\n    _eval_trigsimp = getattr(expr, '_eval_trigsimp', None)\n    if _eval_trigsimp is not None:\n        return _eval_trigsimp(**opts)\n\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n    else:\n        method = 'old'\n\n    def groebnersimp(ex, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function and e.func in (TrigonometricFunction, HyperbolicFunction):\n                args = [trigsimp_groebner(x, **opts) for x in args]\n            return e.func(*args)\n        new = traverse(expr)\n        if not isinstance(new, Expr):\n            return new\n        return trigsimp_groebner(new, **opts)\n\n    trigsimpfunc = {\n        'fu': (lambda x: fu(x, **opts)),\n        'matching': (lambda x: futrig(x)),\n        'groebner': (lambda x: groebnersimp(x, **opts)),\n        'combined': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[2, tan]))),\n        'old': lambda x: trigsimp_old(x, **opts),\n    }\n\n    # Apply exptrigsimp first if exponential functions are present\n    if expr.has(exp):\n        expr = exptrigsimp(expr)\n\n    return trigsimpfunc[method](expr)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sympy/simplify/trigsimp.py b/sympy/simplify/trigsimp.py\nindex 34a3bab3fc..f4486225e7 100644\n--- a/sympy/simplify/trigsimp.py\n+++ b/sympy/simplify/trigsimp.py\n@@ -484,10 +484,10 @@ def trigsimp(expr, **opts):\n     if not old:\n         opts.pop('deep', None)\n         recursive = opts.pop('recursive', None)\n+\n         method = opts.pop('method', 'matching')\n     else:\n         method = 'old'\n-\n     def groebnersimp(ex, **opts):\n         def traverse(e):\n             if e.is_Atom:\n@@ -501,6 +501,11 @@ def traverse(e):\n             return new\n         return trigsimp_groebner(new, **opts)\n \n+\n+    # Apply exptrigsimp as preprocessing if expression contains exponential functions\n+    if expr.has(exp):\n+        expr = exptrigsimp(expr)\n+    \n     trigsimpfunc = {\n         'fu': (lambda x: fu(x, **opts)),\n         'matching': (lambda x: futrig(x)),\n@@ -513,6 +518,7 @@ def traverse(e):\n     return trigsimpfunc(expr)\n \n \n+\n def exptrigsimp(expr):\n     \"\"\"\n     Simplifies exponential / trigonometric / hyperbolic functions.\n@@ -531,6 +537,7 @@ def exptrigsimp(expr):\n     from sympy.simplify.fu import hyper_as_trig, TR2i\n     from sympy.simplify.simplify import bottom_up\n \n+\n     def exp_trig(e):\n         # select the better of e, and e rewritten in terms of exp or trig\n         # functions\n@@ -590,6 +597,7 @@ def signlog(expr, sign=1):\n     newexpr = bottom_up(newexpr, f)\n \n     # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n+\n     if newexpr.has(HyperbolicFunction):\n         e, f = hyper_as_trig(newexpr)\n         newexpr = f(TR2i(e))\n",
    "variant_0": "diff --git a/sympy/simplify/trigsimp.py b/sympy/simplify/trigsimp.py\nindex 34a3bab3fc..dd0f7ee748 100644\n--- a/sympy/simplify/trigsimp.py\n+++ b/sympy/simplify/trigsimp.py\n@@ -480,14 +480,21 @@ def trigsimp(expr, **opts):\n     except AttributeError:\n         pass\n \n+    old = opts.pop('old', False)\n+    if not old:\n+        opts.pop('deep', None)\n+        recursive = opts.pop('recursive', None)\n+\n     old = opts.pop('old', False)\n     if not old:\n         opts.pop('deep', None)\n         recursive = opts.pop('recursive', None)\n         method = opts.pop('method', 'matching')\n+        # Apply exptrigsimp as preprocessing when exponential functions are present\n+        if expr.has(exp):\n+            expr = exptrigsimp(expr)\n     else:\n         method = 'old'\n-\n     def groebnersimp(ex, **opts):\n         def traverse(e):\n             if e.is_Atom:\n@@ -501,6 +508,7 @@ def traverse(e):\n             return new\n         return trigsimp_groebner(new, **opts)\n \n+\n     trigsimpfunc = {\n         'fu': (lambda x: fu(x, **opts)),\n         'matching': (lambda x: futrig(x)),\n@@ -510,7 +518,10 @@ def traverse(e):\n         'old': lambda x: trigsimp_old(x, **opts),\n                    }[method]\n \n-    return trigsimpfunc(expr)\n+    # Apply exptrigsimp first to handle exponential expressions\n+    expr_with_exp_converted = exptrigsimp(expr)\n+    return trigsimpfunc(expr_with_exp_converted)\n+\n \n \n def exptrigsimp(expr):\n@@ -538,6 +549,64 @@ def exp_trig(e):\n         if e.has(*_trigs):\n             choices.append(e.rewrite(exp))\n         choices.append(e.rewrite(cos))\n+        # Also try rewriting exponentials as trigonometric functions\n+        if e.has(exp):\n+            choices.append(e.rewrite(sin))\n+            choices.append(e.rewrite(cos))\n+        return min(choices, key=count_ops)\n+\n+    newexpr = bottom_up(expr, exp_trig)\n+\n+    # conversion from exp to hyperbolic functions\n+    # to trig functions\n+    ex = newexpr.rewrite(exp)\n+    ex = ex.replace(lambda x: x.is_Pow and x.base == S.Exp1 and x.exp.is_Mul and x.exp.coeff(I), \n+                   lambda x: cos(x.exp/I) + I*sin(x.exp/I))\n+    ex = TR2i(ex)\n+    if ex.has(HyperbolicFunction):\n+        ex = hyper_as_trig(ex)\n+    ex = TR2i(ex).simplify()\n+    # if we have a Boolean, Relational, or Piecewise, do not attempt\n+    # further simplification since the expression has been altered\n+    if ex.has(S.BooleanTrue):\n+        return ex\n+    return trigsimp(ex, method='fu')\n+    from sympy.simplify.fu import hyper_as_trig, TR2i\n+    from sympy.simplify.simplify import bottom_up\n+\n+\n+def exptrigsimp(expr):\n+    \"\"\"\n+    Simplifies exponential / trigonometric / hyperbolic functions.\n+\n+    This is a wrapper around simplify that uses a bottom-up approach, applying\n+    specific simplifications in a careful order.\n+\n+    Examples\n+    ========\n+\n+    >>> from sympy import *\n+    >>> from sympy.simplify.trigsimp import exptrigsimp\n+    >>> from sympy.abc import z\n+\n+    >>> exptrigsimp(exp(z) + exp(-z))\n+    2*cosh(z)\n+    >>> exptrigsimp(cosh(z) - sinh(z))\n+    exp(-z)\n+    \"\"\"\n+    from sympy.simplify.fu import hyper_as_trig, TR2i\n+    from sympy.simplify.simplify import bottom_up\n+\n+    def exp_trig(e):\n+        # select the better of e, and e rewritten in terms of exp or trig\n+        # functions\n+        choices = [e]\n+        if e.has(*_trigs):\n+            choices.append(e.rewrite(exp))\n+        if e.has(exp):\n+            choices.append(e.rewrite(sin))\n+            choices.append(e.rewrite(cos))\n+        choices.append(e.rewrite(cos))\n         return min(*choices, key=count_ops)\n     newexpr = bottom_up(expr, exp_trig)\n \n@@ -590,16 +659,100 @@ def signlog(expr, sign=1):\n     newexpr = bottom_up(newexpr, f)\n \n     # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n-    if newexpr.has(HyperbolicFunction):\n-        e, f = hyper_as_trig(newexpr)\n-        newexpr = f(TR2i(e))\n-    if newexpr.has(TrigonometricFunction):\n-        newexpr = TR2i(newexpr)\n-\n-    # can we ever generate an I where there was none previously?\n-    if not (newexpr.has(I) and not expr.has(I)):\n-        expr = newexpr\n-    return expr\n+\n+def trigsimp(expr, **opts):\n+    \"\"\"\n+    reduces expression by using known trig identities\n+\n+    Notes\n+    =====\n+\n+    method:\n+    - Determine the method to use. Valid choices are 'matching' (default),\n+    'groebner', 'combined', 'fu' and 'old'. If 'matching', simplify the\n+    expression recursively by targeting common patterns. If 'groebner', apply\n+    an experimental groebner basis algorithm. In this case further options\n+    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n+    If 'combined', first run the groebner basis algorithm with small\n+    default parameters, then run the 'matching' algorithm. 'fu' runs the\n+    collection of trigonometric transformations described by Fu, et al.\n+    (see the `fu` docstring). If 'old', uses the old trigsimp algorithm.\n+\n+    compare:\n+    - show input and output from `trigsimp` and `futrig` when different,\n+    but returns the `trigsimp` result.\n+\n+    Examples\n+    ========\n+\n+    >>> from sympy import trigsimp, sin, cos, log, cosh\n+    >>> from sympy.abc import x, y\n+    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n+    >>> trigsimp(e)\n+    2\n+    >>> trigsimp(log(e))\n+    log(2*sin(x)**2 + 2*cos(x)**2)\n+    >>> trigsimp(log(e), deep=True)\n+    log(2)\n+\n+    Using `method=\"groebner\"` (or `\"combined\"`) can sometimes lead to a lot\n+    more simplification:\n+\n+    >>> e = (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)\n+    >>> trigsimp(e)\n+    (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)\n+    >>> trigsimp(e, method=\"groebner\")\n+    2/cos(x)\n+\n+    >>> trigsimp(1/cot(x), compare=True)\n+          futrig: tan(x)\n+    trigsimp: 1/cot(x)\n+    1/cot(x)\n+\n+    \"\"\"\n+    from sympy.simplify.fu import fu\n+\n+    expr = sympify(expr)\n+\n+    _eval_trigsimp = getattr(expr, '_eval_trigsimp', None)\n+    if _eval_trigsimp is not None:\n+        return _eval_trigsimp(**opts)\n+\n+    old = opts.pop('old', False)\n+    if not old:\n+        opts.pop('deep', None)\n+        recursive = opts.pop('recursive', None)\n+        method = opts.pop('method', 'matching')\n+    else:\n+        method = 'old'\n+\n+    def groebnersimp(ex, **opts):\n+        def traverse(e):\n+            if e.is_Atom:\n+                return e\n+            args = [traverse(x) for x in e.args]\n+            if e.is_Function or e.is_Pow:\n+                args = [trigsimp_groebner(x, **opts) for x in args]\n+            return e.func(*args)\n+        new = traverse(expr)\n+        if not isinstance(new, Expr):\n+            return new\n+        return trigsimp_groebner(new, **opts)\n+\n+    trigsimpfunc = {\n+        'fu': (lambda x: fu(x, **opts)),\n+        'matching': (lambda x: futrig(x)),\n+        'groebner': groebnersimp,\n+        'combined': (lambda x: futrig(groebnersimp(x,\n+                               polynomial=True, hints=[2, tan]))),\n+        'old': lambda x: trigsimp_old(x, **opts),\n+        }\n+    \n+    # Apply exptrigsimp preprocessing if expression contains exponentials\n+    if expr.has(exp):\n+        expr = exptrigsimp(expr)\n+    \n+    return trigsimpfunc[method](expr)\n \n #-------------------- the old trigsimp routines ---------------------\n \n",
    "variant_1": "diff --git a/sympy/simplify/trigsimp.py b/sympy/simplify/trigsimp.py\nindex 34a3bab3fc..4d64dda06f 100644\n--- a/sympy/simplify/trigsimp.py\n+++ b/sympy/simplify/trigsimp.py\n@@ -480,14 +480,21 @@ def trigsimp(expr, **opts):\n     except AttributeError:\n         pass\n \n+    old = opts.pop('old', False)\n+    if not old:\n+        opts.pop('deep', None)\n+        recursive = opts.pop('recursive', None)\n+\n     old = opts.pop('old', False)\n     if not old:\n         opts.pop('deep', None)\n         recursive = opts.pop('recursive', None)\n         method = opts.pop('method', 'matching')\n+        # Apply exptrigsimp preprocessing if exponential functions are present\n+        if expr.has(exp):\n+            expr = exptrigsimp(expr)\n     else:\n         method = 'old'\n-\n     def groebnersimp(ex, **opts):\n         def traverse(e):\n             if e.is_Atom:\n@@ -501,6 +508,7 @@ def traverse(e):\n             return new\n         return trigsimp_groebner(new, **opts)\n \n+\n     trigsimpfunc = {\n         'fu': (lambda x: fu(x, **opts)),\n         'matching': (lambda x: futrig(x)),\n@@ -510,13 +518,74 @@ def traverse(e):\n         'old': lambda x: trigsimp_old(x, **opts),\n                    }[method]\n \n+    # Apply exptrigsimp as preprocessing if exponential functions are present\n+    if expr.has(exp):\n+        expr = exptrigsimp(expr)\n+\n     return trigsimpfunc(expr)\n \n \n+\n+def exptrigsimp(expr):\n+    \"\"\"\n+    Simplifies exponential / trigonometric / hyperbolic functions.\n+\n+    Examples\n+    ========\n+\n+    >>> from sympy import exptrigsimp, exp, cosh, sinh\n+    >>> from sympy.abc import z\n+\n+    >>> exptrigsimp(exp(z) + exp(-z))\n+    2*cosh(z)\n+    >>> exptrigsimp(cosh(z) - sinh(z))\n+    exp(-z)\n+    \"\"\"\n+    from sympy.simplify.fu import hyper_as_trig, TR2i\n+    from sympy.simplify.simplify import bottom_up\n+\n+    def exp_trig(e):\n+        # select the better of e, and e rewritten in terms of exp or trig\n+        # functions\n+        choices = [e]\n+        if e.has(*_trigs):\n+            choices.append(e.rewrite(exp))\n+        choices.append(e.rewrite(cos))\n+        # Also try rewriting exp in terms of trig functions\n+        if e.has(exp):\n+            choices.append(e.rewrite(sin))\n+            choices.append(e.rewrite(cos))\n+        return min(choices, key=count_ops)\n+\n+    newexpr = bottom_up(expr, exp_trig)\n+\n+    # if we didn't change anything and we don't have exp functions,\n+    # return the original expression\n+    if newexpr == expr and not expr.has(exp):\n+        return expr\n+\n+    # Perform additional trigonometric simplifications\n+    from sympy.simplify.fu import TR10i\n+    newexpr = TR10i(newexpr)\n+    \n+    # Convert any remaining complex exponentials to trig functions\n+    newexpr = newexpr.rewrite(cos).rewrite(sin)\n+    \n+    return newexpr\n+    from sympy.simplify.fu import hyper_as_trig, TR2i\n+    from sympy.simplify.simplify import bottom_up\n+\n+\n def exptrigsimp(expr):\n     \"\"\"\n     Simplifies exponential / trigonometric / hyperbolic functions.\n \n+    When ``deep`` is True, the ``expr`` is rewritten in terms of the most\n+    economical trigonometric functions. If the expression is a sum or\n+    product, this is done term-wise. The result is then passed through\n+    the ``trigsimp`` routine. For better results, ``expr`` may be expanded\n+    with ``expand_trig`` first.\n+\n     Examples\n     ========\n \n@@ -537,6 +606,9 @@ def exp_trig(e):\n         choices = [e]\n         if e.has(*_trigs):\n             choices.append(e.rewrite(exp))\n+        if e.has(exp):\n+            choices.append(e.rewrite(sin))\n+            choices.append(e.rewrite(cos))\n         choices.append(e.rewrite(cos))\n         return min(*choices, key=count_ops)\n     newexpr = bottom_up(expr, exp_trig)\n@@ -590,16 +662,100 @@ def signlog(expr, sign=1):\n     newexpr = bottom_up(newexpr, f)\n \n     # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n-    if newexpr.has(HyperbolicFunction):\n-        e, f = hyper_as_trig(newexpr)\n-        newexpr = f(TR2i(e))\n-    if newexpr.has(TrigonometricFunction):\n-        newexpr = TR2i(newexpr)\n-\n-    # can we ever generate an I where there was none previously?\n-    if not (newexpr.has(I) and not expr.has(I)):\n-        expr = newexpr\n-    return expr\n+\n+def trigsimp(expr, **opts):\n+    \"\"\"\n+    reduces expression by using known trig identities\n+\n+    Notes\n+    =====\n+\n+    method:\n+    - Determine the method to use. Valid choices are 'matching' (default),\n+    'groebner', 'combined', 'fu' and 'old'. If 'matching', simplify the\n+    expression recursively by targetting common patterns. If 'groebner', apply\n+    an experimental groebner basis algorithm. In this case further options\n+    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n+    If 'combined', first run the groebner basis algorithm with small\n+    default parameters, then run the 'matching' algorithm. 'fu' runs the\n+    collection of trigonometric transformations described by Fu, et al.\n+    (see the `fu` docstring) while `old` refers to a prior implementation of\n+    trigsimp.\n+\n+    compare:\n+    - show input and output from `trigsimp` and `fu` when different,\n+    but returns the `trigsimp` result.\n+\n+    Examples\n+    ========\n+\n+    >>> from sympy import trigsimp, sin, cos, log, cot\n+    >>> from sympy.abc import x, y\n+    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n+    >>> trigsimp(e)\n+    2\n+    >>> trigsimp(log(e))\n+    log(2*sin(x)**2 + 2*cos(x)**2)\n+    >>> trigsimp(log(e), deep=True)\n+    log(2)\n+\n+    Using `method=\"groebner\"` (or `\"combined\"`) can sometimes lead to a lot\n+    more simplification:\n+\n+    >>> e = (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)\n+    >>> trigsimp(e)\n+    (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)\n+    >>> trigsimp(e, method=\"groebner\")\n+    2/cos(x)\n+\n+    >>> trigsimp(1/cot(x)**2, compare=True)\n+          trigsimp: tan(x)**2\n+                fu: tan(x)**2\n+\n+    \"\"\"\n+    from sympy.simplify.fu import fu\n+\n+    expr = sympify(expr)\n+\n+    _eval_trigsimp = getattr(expr, '_eval_trigsimp', None)\n+    if _eval_trigsimp is not None:\n+        return _eval_trigsimp(**opts)\n+\n+    old = opts.pop('old', False)\n+    if not old:\n+        opts.pop('deep', None)\n+        recursive = opts.pop('recursive', None)\n+        method = opts.pop('method', 'matching')\n+\n+        def groebnersimp(ex, **opts):\n+            def traverse(e):\n+                if e.is_Atom:\n+                    return e\n+                args = [traverse(x) for x in e.args]\n+                if e.is_Function and e.func in (TrigonometricFunction, HyperbolicFunction):\n+                    args = [trigsimp_groebner(x, **opts) for x in args]\n+                return e.func(*args)\n+            new = traverse(expr)\n+            if not isinstance(new, Expr):\n+                return new\n+            return trigsimp_groebner(new, **opts)\n+\n+        trigsimpfunc = {\n+            'fu': (lambda x: fu(x, **opts)),\n+            'matching': (lambda x: futrig(x)),\n+            'groebner': groebnersimp,\n+            'combined': (lambda x: futrig(groebnersimp(x,\n+                               polynomial=True, hints=[2, tan]))),\n+            'old': lambda x: trigsimp_old(x, **opts),\n+        }\n+\n+        # Apply exptrigsimp preprocessing if expression contains exponentials\n+        if expr.has(exp):\n+            expr = exptrigsimp(expr)\n+\n+        return trigsimpfunc[method](expr)\n+\n+    return trigsimp_old(expr, **opts)\n \n #-------------------- the old trigsimp routines ---------------------\n \n",
    "variant_2": "diff --git a/sympy/simplify/trigsimp.py b/sympy/simplify/trigsimp.py\nindex 34a3bab3fc..967f8fdc6a 100644\n--- a/sympy/simplify/trigsimp.py\n+++ b/sympy/simplify/trigsimp.py\n@@ -480,14 +480,21 @@ def trigsimp(expr, **opts):\n     except AttributeError:\n         pass\n \n+    old = opts.pop('old', False)\n+    if not old:\n+        opts.pop('deep', None)\n+        recursive = opts.pop('recursive', None)\n+\n     old = opts.pop('old', False)\n     if not old:\n         opts.pop('deep', None)\n         recursive = opts.pop('recursive', None)\n         method = opts.pop('method', 'matching')\n+        # Apply exptrigsimp as preprocessing when exponential functions are present\n+        if expr.has(exp):\n+            expr = exptrigsimp(expr)\n     else:\n         method = 'old'\n-\n     def groebnersimp(ex, **opts):\n         def traverse(e):\n             if e.is_Atom:\n@@ -501,6 +508,7 @@ def traverse(e):\n             return new\n         return trigsimp_groebner(new, **opts)\n \n+\n     trigsimpfunc = {\n         'fu': (lambda x: fu(x, **opts)),\n         'matching': (lambda x: futrig(x)),\n@@ -510,9 +518,15 @@ def traverse(e):\n         'old': lambda x: trigsimp_old(x, **opts),\n                    }[method]\n \n+    # Apply exptrigsimp as preprocessing for exponential expressions\n+    from sympy.functions import exp\n+    if expr.has(exp):\n+        expr = exptrigsimp(expr)\n+\n     return trigsimpfunc(expr)\n \n \n+\n def exptrigsimp(expr):\n     \"\"\"\n     Simplifies exponential / trigonometric / hyperbolic functions.\n@@ -538,9 +552,120 @@ def exp_trig(e):\n         if e.has(*_trigs):\n             choices.append(e.rewrite(exp))\n         choices.append(e.rewrite(cos))\n-        return min(*choices, key=count_ops)\n+        # Also try rewriting exponentials to trigonometric functions\n+        if e.has(exp):\n+            choices.append(e.rewrite(sin))\n+            choices.append(e.rewrite(cos))\n+        return min(choices, key=count_ops)\n+\n     newexpr = bottom_up(expr, exp_trig)\n \n+    # if we didn't change anything and we don't have trig functions\n+    # then we can try the fu function\n+    if newexpr == expr and not newexpr.has(*_trigs):\n+        return expr\n+\n+    newexpr = TR2i(newexpr)\n+    if not newexpr.has(*_trigs):\n+        return newexpr\n+\n+    return newexpr\n+    from sympy.simplify.fu import hyper_as_trig, TR2i\n+    from sympy.simplify.simplify import bottom_up\n+\n+\n+def trigsimp(expr, **opts):\n+    \"\"\"\n+    reduces expression by using known trig identities\n+\n+    Notes\n+    =====\n+\n+    method:\n+    - Determine the method to use. Valid choices are 'matching' (default),\n+    'groebner', 'combined', 'fu' and 'old'. If 'matching', simplify the\n+    expression recursively by targeting common patterns. If 'groebner', apply\n+    an experimental groebner basis algorithm. In this case further options\n+    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n+    If 'combined', first run the groebner basis algorithm with small\n+    default parameters, then run the 'matching' algorithm. 'fu' runs the\n+    collection of trigonometric transformations described by Fu, et al.\n+    (see the `fu` docstring). If 'old', uses the old version of trigsimp\n+    (SymPy 0.7.0 and earlier).\n+\n+    compare:\n+    - show input and output from `trigsimp` and `futrig` when different,\n+    but returns the `trigsimp` result.\n+\n+    Examples\n+    ========\n+\n+    >>> from sympy import trigsimp, sin, cos, log\n+    >>> from sympy.abc import x, y\n+    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n+    >>> trigsimp(e)\n+    2\n+\n+    Simplification occurs wherever trigonometric functions are located.\n+\n+    >>> trigsimp(log(e))\n+    log(2)\n+\n+    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n+    simplification.\n+\n+    The old trigsimp routine can be accessed as\n+\n+    >>> from sympy import cot\n+    >>> trigsimp(sin(x)/cos(x), method='old')\n+    tan(x)\n+\n+    \"\"\"\n+    from sympy.simplify.fu import fu\n+\n+    expr = sympify(expr)\n+\n+    _eval_trigsimp = getattr(expr, '_eval_trigsimp', None)\n+    if _eval_trigsimp is not None:\n+        return _eval_trigsimp(**opts)\n+\n+    old = opts.pop('old', False)\n+    if not old:\n+        opts.pop('deep', None)\n+        recursive = opts.pop('recursive', None)\n+        method = opts.pop('method', 'matching')\n+    else:\n+        method = 'old'\n+\n+    def groebnersimp(ex, **opts):\n+        def traverse(e):\n+            if e.is_Atom:\n+                return e\n+            args = [traverse(x) for x in e.args]\n+            if e.is_Function and e.func in (TrigonometricFunction, HyperbolicFunction):\n+                e = e.func(*args)\n+                return trigsimp_groebner(e, **opts)\n+            return e.func(*args)\n+        new = traverse(expr)\n+        if not isinstance(expr, Basic):\n+            return new\n+        return new\n+\n+    trigsimpfunc = {\n+        'fu': (lambda x: fu(x, **opts)),\n+        'matching': (lambda x: futrig(x)),\n+        'groebner': groebnersimp,\n+        'combined': (lambda x: futrig(groebnersimp(x,\n+                               polynomial=True, hints=[2, tan]))),\n+        'old': lambda x: trigsimp_old(x, **opts),\n+    }\n+    \n+    # Apply exptrigsimp first if exponential functions are present\n+    if expr.has(exp):\n+        expr = exptrigsimp(expr)\n+    \n+    return trigsimpfunc[method](expr)\n+\n     def f(rv):\n         if not rv.is_Mul:\n             return rv\n@@ -590,16 +715,100 @@ def signlog(expr, sign=1):\n     newexpr = bottom_up(newexpr, f)\n \n     # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n-    if newexpr.has(HyperbolicFunction):\n-        e, f = hyper_as_trig(newexpr)\n-        newexpr = f(TR2i(e))\n-    if newexpr.has(TrigonometricFunction):\n-        newexpr = TR2i(newexpr)\n-\n-    # can we ever generate an I where there was none previously?\n-    if not (newexpr.has(I) and not expr.has(I)):\n-        expr = newexpr\n-    return expr\n+\n+def trigsimp(expr, **opts):\n+    \"\"\"\n+    reduces expression by using known trig identities\n+\n+    Notes\n+    =====\n+\n+    method:\n+    - Determine the method to use. Valid choices are 'matching' (default),\n+    'groebner', 'combined', 'fu' and 'old'. If 'matching', simplify the\n+    expression recursively by targeting common patterns. If 'groebner', apply\n+    an experimental groebner basis algorithm. In this case further options\n+    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n+    If 'combined', first run the groebner basis algorithm with small\n+    default parameters, then run the 'matching' algorithm. 'fu' runs the\n+    collection of trigonometric transformations described by Fu, et al.\n+    (see the `fu` docstring). If 'old', uses the old trigsimp routine.\n+\n+    compare:\n+    - show input and output from `trigsimp` and `futrig` when different,\n+    but returns the `trigsimp` result.\n+\n+    Examples\n+    ========\n+\n+    >>> from sympy import trigsimp, sin, cos, log, cosh\n+    >>> from sympy.abc import x, y\n+    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n+    >>> trigsimp(e)\n+    2\n+    >>> trigsimp(log(e))\n+    log(2*sin(x)**2 + 2*cos(x)**2)\n+    >>> trigsimp(log(e), deep=True)\n+    log(2)\n+\n+    Using `method=\"groebner\"` (or `\"combined\"`) can sometimes lead to a lot\n+    more simplification:\n+\n+    >>> e = (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)\n+    >>> trigsimp(e)\n+    (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)\n+    >>> trigsimp(e, method=\"groebner\")\n+    2/cos(x)\n+\n+    >>> trigsimp(1/cosh(x) - tanh(x))\n+    1/cosh(x) - tanh(x)\n+    >>> trigsimp(1/cosh(x) - tanh(x), method=\"groebner\")\n+    1/(exp(x) + 1)\n+\n+    \"\"\"\n+    from sympy.simplify.fu import fu\n+\n+    expr = sympify(expr)\n+\n+    _eval_trigsimp = getattr(expr, '_eval_trigsimp', None)\n+    if _eval_trigsimp is not None:\n+        return _eval_trigsimp(**opts)\n+\n+    old = opts.pop('old', False)\n+    if not old:\n+        opts.pop('deep', None)\n+        recursive = opts.pop('recursive', None)\n+        method = opts.pop('method', 'matching')\n+    else:\n+        method = 'old'\n+\n+    def groebnersimp(ex, **opts):\n+        def traverse(e):\n+            if e.is_Atom:\n+                return e\n+            args = [traverse(x) for x in e.args]\n+            if e.is_Function or e.is_Pow:\n+                args = [trigsimp_groebner(x, **opts) for x in args]\n+            return e.func(*args)\n+        new = traverse(ex)\n+        if not isinstance(new, Expr):\n+            return new\n+        return trigsimp_groebner(new, **opts)\n+\n+    trigsimpfunc = {\n+        'fu': (lambda x: fu(x, **opts)),\n+        'matching': (lambda x: futrig(x)),\n+        'groebner': (lambda x: groebnersimp(x, **opts)),\n+        'combined': (lambda x: futrig(groebnersimp(x,\n+                               polynomial=True, hints=[2, tan]))),\n+        'old': lambda x: trigsimp_old(x, **opts),\n+                   }\n+    \n+    # Apply exptrigsimp as preprocessing if expression contains exponentials\n+    if expr.has(exp):\n+        expr = exptrigsimp(expr)\n+    \n+    return trigsimpfunc[method](expr)\n \n #-------------------- the old trigsimp routines ---------------------\n \n",
    "variant_3": "diff --git a/sympy/simplify/trigsimp.py b/sympy/simplify/trigsimp.py\nindex 34a3bab3fc..f000260d5c 100644\n--- a/sympy/simplify/trigsimp.py\n+++ b/sympy/simplify/trigsimp.py\n@@ -480,14 +480,21 @@ def trigsimp(expr, **opts):\n     except AttributeError:\n         pass\n \n+    old = opts.pop('old', False)\n+    if not old:\n+        opts.pop('deep', None)\n+        recursive = opts.pop('recursive', None)\n+\n     old = opts.pop('old', False)\n     if not old:\n         opts.pop('deep', None)\n         recursive = opts.pop('recursive', None)\n         method = opts.pop('method', 'matching')\n+        # Apply exptrigsimp preprocessing if exponential functions are present\n+        if expr.has(exp):\n+            expr = exptrigsimp(expr)\n     else:\n         method = 'old'\n-\n     def groebnersimp(ex, **opts):\n         def traverse(e):\n             if e.is_Atom:\n@@ -501,6 +508,7 @@ def traverse(e):\n             return new\n         return trigsimp_groebner(new, **opts)\n \n+\n     trigsimpfunc = {\n         'fu': (lambda x: fu(x, **opts)),\n         'matching': (lambda x: futrig(x)),\n@@ -510,7 +518,10 @@ def traverse(e):\n         'old': lambda x: trigsimp_old(x, **opts),\n                    }[method]\n \n-    return trigsimpfunc(expr)\n+    # Apply exptrigsimp as preprocessing to handle exponential expressions\n+    processed_expr = exptrigsimp(expr)\n+    return trigsimpfunc(processed_expr)\n+\n \n \n def exptrigsimp(expr):\n@@ -538,6 +549,62 @@ def exp_trig(e):\n         if e.has(*_trigs):\n             choices.append(e.rewrite(exp))\n         choices.append(e.rewrite(cos))\n+        # Also try rewriting exponentials to trigonometric functions\n+        if e.has(exp):\n+            choices.append(e.rewrite(sin))\n+            choices.append(e.rewrite(cos))\n+        return min(choices, key=count_ops)\n+\n+    newexpr = bottom_up(expr, exp_trig)\n+\n+    # conversion from exp to hyperbolic functions\n+    res = TR2i(newexpr)\n+    if res != newexpr:\n+        return res\n+\n+    # if we didn't change much or at all, try the fu method\n+    if res.count_ops() >= expr.count_ops():\n+        res = fu(expr)\n+\n+    return res\n+    from sympy.simplify.fu import hyper_as_trig, TR2i\n+    from sympy.simplify.simplify import bottom_up\n+\n+\n+def exptrigsimp(expr):\n+    \"\"\"\n+    Simplifies exponential / trigonometric / hyperbolic functions.\n+\n+    When ``deep`` is True, the ``trigsimp`` function is applied to all parts\n+    of the expression, except to those parts which are not trigonometric\n+    (e.g. polynomials).\n+\n+    Examples\n+    ========\n+\n+    >>> from sympy import symbols, sin, cos, exp, I, sinh, cosh, tan, tanh\n+    >>> from sympy.simplify.trigsimp import exptrigsimp\n+    >>> from sympy.abc import z\n+\n+    >>> exptrigsimp(exp(z) + exp(-z))\n+    2*cosh(z)\n+    >>> exptrigsimp(cosh(z) - sinh(z))\n+    exp(-z)\n+    \"\"\"\n+    from sympy.simplify.fu import hyper_as_trig, TR2i\n+    from sympy.simplify.simplify import bottom_up\n+\n+    def exp_trig(e):\n+        # select the better of e, and e rewritten in terms of exp or trig\n+        # functions\n+        choices = [e]\n+        if e.has(*_trigs):\n+            choices.append(e.rewrite(exp))\n+        if e.has(exp, I):\n+            # Try rewriting exponentials with I to trigonometric functions\n+            choices.append(e.rewrite(cos))\n+            choices.append(e.rewrite(sin))\n+        choices.append(e.rewrite(cos))\n         return min(*choices, key=count_ops)\n     newexpr = bottom_up(expr, exp_trig)\n \n@@ -590,16 +657,112 @@ def signlog(expr, sign=1):\n     newexpr = bottom_up(newexpr, f)\n \n     # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n-    if newexpr.has(HyperbolicFunction):\n-        e, f = hyper_as_trig(newexpr)\n-        newexpr = f(TR2i(e))\n-    if newexpr.has(TrigonometricFunction):\n-        newexpr = TR2i(newexpr)\n-\n-    # can we ever generate an I where there was none previously?\n-    if not (newexpr.has(I) and not expr.has(I)):\n-        expr = newexpr\n-    return expr\n+\n+def trigsimp(expr, **opts):\n+    \"\"\"\n+    reduces expression by using known trig identities\n+\n+    Notes\n+    =====\n+\n+    method:\n+    - Determine the method to use. Valid choices are 'matching' (default),\n+    'groebner', 'combined', 'fu' and 'old'. If 'matching', simplify the\n+    expression recursively by targeting common patterns. If 'groebner', apply\n+    an experimental groebner basis algorithm. In this case further options\n+    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n+    If 'combined', first run the groebner basis algorithm with small\n+    default parameters, then run the 'matching' algorithm. 'fu' runs the\n+    collection of trigonometric transformations described by Fu, et al.\n+    (see the `fu` docstring). If 'old', uses the old SymPy trig\n+    simplification algorithm.\n+\n+    compare:\n+    - show input and output from `trigsimp` and `futrig` when different,\n+    but returns the `trigsimp` result.\n+\n+    Examples\n+    ========\n+\n+    >>> from sympy import trigsimp, sin, cos, log\n+    >>> from sympy.abc import x, y\n+    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n+    >>> trigsimp(e)\n+    2\n+    >>> trigsimp(log(e))\n+    log(2*sin(x)**2 + 2*cos(x)**2)\n+    >>> trigsimp(log(e), deep=True)\n+    log(2)\n+\n+    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n+    simplification.\n+\n+    The old trigsimp routine can be accessed as\n+\n+    >>> from sympy import trigsimp_old\n+    >>> trigsimp_old(sin(x)**2 + cos(x)**2)\n+    1\n+\n+    \"\"\"\n+    from sympy.simplify.fu import fu\n+\n+    expr = sympify(expr)\n+\n+    _eval_trigsimp = getattr(expr, '_eval_trigsimp', None)\n+    if _eval_trigsimp is not None:\n+        return _eval_trigsimp(**opts)\n+\n+    old = opts.pop('old', False)\n+    if not old:\n+        opts.pop('deep', None)\n+        recursive = opts.pop('recursive', None)\n+        method = opts.pop('method', 'matching')\n+\n+        def groebnersimp(ex, **opts):\n+            def traverse(e):\n+                if e.is_Atom:\n+                    return e\n+                args = [traverse(x) for x in e.args]\n+                if e.is_Function and isinstance(e, TrigonometricFunction):\n+                    args = [trigsimp_groebner(x, **opts) for x in args]\n+                return e.func(*args)\n+            new = traverse(expr)\n+            if not isinstance(new, Expr):\n+                return new\n+            return trigsimp_groebner(new, **opts)\n+\n+        def futrig(e, **opts):\n+            return fu(e, **opts)\n+\n+        def matching(expr, **opts):\n+            return futrig(trigsimp_groebner(expr, **opts))\n+\n+        def combined(expr, **opts):\n+            return futrig(trigsimp_groebner(expr, polynomial=True, hints=[2, tan]))\n+\n+        def exptrigsimp_wrapper(expr, **opts):\n+            # Apply exptrigsimp first to convert exponentials to trig functions\n+            from sympy import exp\n+            if expr.has(exp):\n+                expr = exptrigsimp(expr)\n+            return expr\n+\n+        trigsimpfunc = {\n+            'fu': futrig,\n+            'matching': matching,\n+            'groebner': groebnersimp,\n+            'combined': combined,\n+            'old': lambda x, **opts: trigsimp_old(x, **opts),\n+        }\n+\n+        # Apply exptrigsimp preprocessing if expression contains exponentials\n+        from sympy import exp\n+        if expr.has(exp):\n+            expr = exptrigsimp(expr)\n+\n+        return trigsimpfunc[method](expr, **opts)\n+\n+    return trigsimp_old(expr, **opts)\n \n #-------------------- the old trigsimp routines ---------------------\n \n",
    "variant_4": "diff --git a/sympy/simplify/trigsimp.py b/sympy/simplify/trigsimp.py\nindex 34a3bab3fc..eaa8c8ba70 100644\n--- a/sympy/simplify/trigsimp.py\n+++ b/sympy/simplify/trigsimp.py\n@@ -480,14 +480,21 @@ def trigsimp(expr, **opts):\n     except AttributeError:\n         pass\n \n+    old = opts.pop('old', False)\n+    if not old:\n+        opts.pop('deep', None)\n+        recursive = opts.pop('recursive', None)\n+\n     old = opts.pop('old', False)\n     if not old:\n         opts.pop('deep', None)\n         recursive = opts.pop('recursive', None)\n         method = opts.pop('method', 'matching')\n+        # Apply exptrigsimp as preprocessing when exponential functions are present\n+        if expr.has(exp):\n+            expr = exptrigsimp(expr)\n     else:\n         method = 'old'\n-\n     def groebnersimp(ex, **opts):\n         def traverse(e):\n             if e.is_Atom:\n@@ -501,6 +508,112 @@ def traverse(e):\n             return new\n         return trigsimp_groebner(new, **opts)\n \n+\n+    trigsimpfunc = {\n+        'fu': (lambda x: fu(x, **opts)),\n+        'matching': (lambda x: futrig(x)),\n+        'groebner': (lambda x: groebnersimp(x, **opts)),\n+        'combined': (lambda x: futrig(groebnersimp(x,\n+                               polynomial=True, hints=[2, tan]))),\n+        'old': lambda x: trigsimp_old(x, **opts),\n+                   }[method]\n+\n+    # Apply exptrigsimp as preprocessing if exponential functions are present\n+    if expr.has(exp):\n+        expr = exptrigsimp(expr)\n+    \n+    return trigsimpfunc(expr)\n+\n+\n+\n+def trigsimp(expr, **opts):\n+    \"\"\"\n+    reduces expression by using known trig identities\n+\n+    Notes\n+    =====\n+\n+    method:\n+    - Determine the method to use. Valid choices are 'matching' (default),\n+    'groebner', 'combined', 'old', and 'fu'. If 'matching', simplify the\n+    expression recursively by targeting common patterns. If 'groebner', apply\n+    an experimental groebner basis algorithm. In this case further options\n+    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n+    If 'combined', first run the groebner basis algorithm with small\n+    default parameters, then run the 'matching' algorithm. 'old' is the\n+    original SymPy algorithm.\n+\n+    compare:\n+    - show input and output from `trigsimp` and `futrig` when different,\n+    but returns the `trigsimp` result.\n+\n+    Examples\n+    ========\n+\n+    >>> from sympy import trigsimp, sin, cos, log\n+    >>> from sympy.abc import x, y\n+    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n+    >>> trigsimp(e)\n+    2\n+    >>> trigsimp(log(e))\n+    log(2*sin(x)**2 + 2*cos(x)**2)\n+    >>> trigsimp(log(e), deep=True)\n+    log(2)\n+\n+    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n+    simplification.\n+\n+    The old trigsimp routine can be accessed as with method 'old'.\n+\n+    >>> from sympy import coth, tanh\n+    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n+    >>> trigsimp(t, method='old') == t\n+    True\n+    >>> trigsimp(t)\n+    tanh(x)**7\n+\n+    \"\"\"\n+    from sympy.simplify.fu import fu\n+\n+    expr = sympify(expr)\n+\n+    _eval_trigsimp = getattr(expr, '_eval_trigsimp', None)\n+    if _eval_trigsimp is not None:\n+        return _eval_trigsimp(**opts)\n+\n+    old = opts.pop('old', False)\n+    if not old:\n+        opts.pop('deep', None)\n+        recursive = opts.pop('recursive', None)\n+        method = opts.pop('method', 'matching')\n+    else:\n+        method = 'old'\n+\n+    def groebnersimp(ex, **opts):\n+        def traverse(e):\n+            if e.is_Atom:\n+                return e\n+            args = [traverse(x) for x in e.args]\n+            if e.is_Function and isinstance(e, TrigonometricFunction):\n+                e = e.func(*args)\n+                if e.is_Mul:\n+                    ret = []\n+                    for x in e.args:\n+                        if isinstance(x, TrigonometricFunction):\n+                            ret.append(x)\n+                    if ret:\n+                        return trigsimp_groebner(e, **opts)\n+                return e\n+            return e.func(*args)\n+        new = traverse(ex)\n+        if not isinstance(new, Expr):\n+            return new\n+        return trigsimp_groebner(new, **opts)\n+\n+    # Apply exptrigsimp first if expression contains exponential functions\n+    if expr.has(exp):\n+        expr = exptrigsimp(expr)\n+\n     trigsimpfunc = {\n         'fu': (lambda x: fu(x, **opts)),\n         'matching': (lambda x: futrig(x)),\n@@ -511,12 +624,16 @@ def traverse(e):\n                    }[method]\n \n     return trigsimpfunc(expr)\n+    from sympy.simplify.fu import hyper_as_trig, TR2i\n+    from sympy.simplify.simplify import bottom_up\n \n \n def exptrigsimp(expr):\n     \"\"\"\n     Simplifies exponential / trigonometric / hyperbolic functions.\n \n+    When ``deep`` is True, the arguments of the functions are also simplified.\n+\n     Examples\n     ========\n \n@@ -538,6 +655,10 @@ def exp_trig(e):\n         if e.has(*_trigs):\n             choices.append(e.rewrite(exp))\n         choices.append(e.rewrite(cos))\n+        # Also try rewriting exponentials to trigonometric functions\n+        if e.has(exp):\n+            choices.append(e.rewrite(sin))\n+            choices.append(e.rewrite(cos))\n         return min(*choices, key=count_ops)\n     newexpr = bottom_up(expr, exp_trig)\n \n@@ -590,16 +711,114 @@ def signlog(expr, sign=1):\n     newexpr = bottom_up(newexpr, f)\n \n     # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n-    if newexpr.has(HyperbolicFunction):\n-        e, f = hyper_as_trig(newexpr)\n-        newexpr = f(TR2i(e))\n-    if newexpr.has(TrigonometricFunction):\n-        newexpr = TR2i(newexpr)\n-\n-    # can we ever generate an I where there was none previously?\n-    if not (newexpr.has(I) and not expr.has(I)):\n-        expr = newexpr\n-    return expr\n+\n+def trigsimp(expr, **opts):\n+    \"\"\"\n+    reduces expression by using known trig identities\n+\n+    Notes\n+    =====\n+\n+    method:\n+    - Determine the method to use. Valid choices are 'matching' (default),\n+    'groebner', 'combined', 'fu' and 'old'. If 'matching', simplify the\n+    expression recursively by targeting common patterns. If 'groebner', apply\n+    an experimental groebner basis algorithm. In this case further options\n+    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n+    If 'combined', first run the groebner basis algorithm with small\n+    default parameters, then run the 'matching' algorithm. 'fu' runs the\n+    collection of trigonometric transformations described by Fu, et al.\n+    (see the `fu` docstring).\n+\n+\n+    Examples\n+    ========\n+\n+    >>> from sympy import trigsimp, sin, cos, log\n+    >>> from sympy.abc import x, y\n+    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n+    >>> trigsimp(e)\n+    2\n+\n+    Simplification occurs wherever trigonometric functions are located.\n+\n+    >>> trigsimp(log(e))\n+    log(2)\n+\n+    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n+    simplification.\n+\n+    The old trigsimp routine can be accessed as with method 'old'.\n+\n+    >>> from sympy import coth, tanh\n+    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n+    >>> trigsimp(t, method='old') == t\n+    True\n+    >>> trigsimp(t)\n+    tanh(x)**7\n+\n+    \"\"\"\n+    from sympy.simplify.fu import fu\n+\n+    expr = sympify(expr)\n+\n+    _eval_trigsimp = getattr(expr, '_eval_trigsimp', None)\n+    if _eval_trigsimp is not None:\n+        return _eval_trigsimp(**opts)\n+\n+    old = opts.pop('old', False)\n+    if not old:\n+        opts.pop('deep', None)\n+        recursive = opts.pop('recursive', None)\n+        method = opts.pop('method', 'matching')\n+    else:\n+        method = 'old'\n+\n+    def groebnersimp(ex, **opts):\n+        def traverse(e, **opts):\n+            if e.is_Atom:\n+                return e\n+            args = [traverse(a, **opts) for a in e.args]\n+            if e.is_Function and hasattr(e, '_eval_trigsimp'):\n+                e = e._eval_trigsimp(**opts)\n+            if not isinstance(e, TrigonometricFunction):\n+                e = e.func(*args)\n+            try:\n+                e = trigsimp_groebner(e, **opts)\n+            except ValueError:\n+                pass\n+            return e\n+        new = traverse(ex, **opts)\n+        if not isinstance(new, Expr):\n+            return new\n+        return trigsimp_groebner(new, **opts)\n+\n+    def combsimp(ex, **opts):\n+        return trigsimp(groebnersimp(ex,\n+                       polynomials=True, hints=[2, tan]),\n+                       method='matching')\n+\n+    def matchsimp(ex, **opts):\n+        return futrig(ex)\n+\n+    def fuids(ex, **opts):\n+        return fu(ex)\n+\n+    def oldsimp(ex, **opts):\n+        return trigsimp_old(ex, **opts)\n+\n+    # Apply exptrigsimp as preprocessing if expression contains exponentials\n+    if expr.has(exp):\n+        expr = exptrigsimp(expr)\n+\n+    trigsimpfunc = {\n+        'fu': fuids,\n+        'matching': matchsimp,\n+        'groebner': groebnersimp,\n+        'combined': combsimp,\n+        'old': oldsimp\n+        }\n+    return trigsimpfunc[method](expr, **opts)\n \n #-------------------- the old trigsimp routines ---------------------\n \n",
    "variant_5": "diff --git a/sympy/simplify/trigsimp.py b/sympy/simplify/trigsimp.py\nindex 34a3bab3fc..20bd910912 100644\n--- a/sympy/simplify/trigsimp.py\n+++ b/sympy/simplify/trigsimp.py\n@@ -480,14 +480,21 @@ def trigsimp(expr, **opts):\n     except AttributeError:\n         pass\n \n+    old = opts.pop('old', False)\n+    if not old:\n+        opts.pop('deep', None)\n+        recursive = opts.pop('recursive', None)\n+\n     old = opts.pop('old', False)\n     if not old:\n         opts.pop('deep', None)\n         recursive = opts.pop('recursive', None)\n         method = opts.pop('method', 'matching')\n+        # Apply exptrigsimp preprocessing if exponential functions are present\n+        if expr.has(exp):\n+            expr = exptrigsimp(expr)\n     else:\n         method = 'old'\n-\n     def groebnersimp(ex, **opts):\n         def traverse(e):\n             if e.is_Atom:\n@@ -501,45 +508,128 @@ def traverse(e):\n             return new\n         return trigsimp_groebner(new, **opts)\n \n+\n     trigsimpfunc = {\n-        'fu': (lambda x: fu(x, **opts)),\n-        'matching': (lambda x: futrig(x)),\n-        'groebner': (lambda x: groebnersimp(x, **opts)),\n-        'combined': (lambda x: futrig(groebnersimp(x,\n+        'fu': (lambda x: fu(exptrigsimp(x), **opts)),\n+        'matching': (lambda x: futrig(exptrigsimp(x))),\n+        'groebner': (lambda x: groebnersimp(exptrigsimp(x), **opts)),\n+        'combined': (lambda x: futrig(groebnersimp(exptrigsimp(x),\n                                polynomial=True, hints=[2, tan]))),\n-        'old': lambda x: trigsimp_old(x, **opts),\n+        'old': lambda x: trigsimp_old(exptrigsimp(x), **opts),\n                    }[method]\n \n     return trigsimpfunc(expr)\n \n \n-def exptrigsimp(expr):\n+\n+def trigsimp(expr, **opts):\n     \"\"\"\n-    Simplifies exponential / trigonometric / hyperbolic functions.\n+    reduces expression by using known trig identities\n+\n+    Notes\n+    =====\n+\n+    method:\n+    - Determine the method to use. Valid choices are 'matching' (default),\n+    'groebner', 'combined', and 'fu'. If 'matching', simplify the\n+    expression recursively by targeting common patterns. If 'groebner', apply\n+    an experimental groebner basis algorithm. In this case further options\n+    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n+    If 'combined', first run the groebner basis algorithm with small\n+    default parameters, then run the 'matching' algorithm. 'fu' runs the\n+    collection of trigonometric transformations described by Fu, et al.\n+    (see the `fu` docstring).\n+\n \n     Examples\n     ========\n \n-    >>> from sympy import exptrigsimp, exp, cosh, sinh\n-    >>> from sympy.abc import z\n+    >>> from sympy import trigsimp, sin, cos, log\n+    >>> from sympy.abc import x, y\n+    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n+    >>> trigsimp(e)\n+    2\n+\n+    Simplification occurs wherever trigonometric functions are located.\n+\n+    >>> trigsimp(log(e))\n+    log(2)\n+\n+    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n+    simplification.\n+\n+    The old trigsimp routine can be accessed as with method 'old'.\n+\n+    >>> from sympy import coth, tanh\n+    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n+    >>> trigsimp(t, method='old') == t\n+    True\n+    >>> trigsimp(t)\n+    tanh(x)**7\n \n-    >>> exptrigsimp(exp(z) + exp(-z))\n-    2*cosh(z)\n-    >>> exptrigsimp(cosh(z) - sinh(z))\n-    exp(-z)\n     \"\"\"\n+    from sympy.simplify.fu import fu\n+\n+    expr = sympify(expr)\n+\n+    _eval_trigsimp = getattr(expr, '_eval_trigsimp', None)\n+    if _eval_trigsimp is not None:\n+        return _eval_trigsimp(**opts)\n+\n+    old = opts.pop('old', False)\n+    if not old:\n+        opts.pop('deep', None)\n+        recursive = opts.pop('recursive', None)\n+        method = opts.pop('method', 'matching')\n+    else:\n+        method = 'old'\n+\n+    def groebnersimp(ex, **opts):\n+        def traverse(e):\n+            if e.is_Atom:\n+                return e\n+            args = [traverse(x) for x in e.args]\n+            if e.is_Function and isinstance(e, TrigonometricFunction):\n+                e = e.func(*args)\n+                if e.is_Function and isinstance(e, TrigonometricFunction):\n+                    e = trigsimp_groebner(e, **opts)\n+                return e\n+            return e.func(*args)\n+        new = traverse(expr)\n+        if not isinstance(new, Expr):\n+            return new\n+        return trigsimp_groebner(new, **opts)\n+\n+    # Apply exptrigsimp first if expression contains exponential functions\n+    if expr.has(exp):\n+        expr = exptrigsimp(expr)\n+\n+    trigsimpfunc = {\n+        'fu': (lambda x: fu(x, **opts)),\n+        'matching': (lambda x: futrig(x)),\n+        'groebner': (lambda x: groebnersimp(x, **opts)),\n+        'combined': (lambda x: futrig(groebnersimp(x,\n+                               polynomial=True, hints=[2, tan]))),\n+        'old': lambda x: trigsimp_old(x, **opts),\n+                   }[method]\n+\n+    return trigsimpfunc(expr)\n     from sympy.simplify.fu import hyper_as_trig, TR2i\n     from sympy.simplify.simplify import bottom_up\n \n-    def exp_trig(e):\n-        # select the better of e, and e rewritten in terms of exp or trig\n-        # functions\n-        choices = [e]\n-        if e.has(*_trigs):\n-            choices.append(e.rewrite(exp))\n+\n+def exp_trig(e):\n+    # select the better of e, and e rewritten in terms of exp or trig\n+    # functions\n+    choices = [e]\n+    if e.has(*_trigs):\n+        choices.append(e.rewrite(exp))\n+    if e.has(exp):\n+        choices.append(e.rewrite(sin))\n         choices.append(e.rewrite(cos))\n-        return min(*choices, key=count_ops)\n-    newexpr = bottom_up(expr, exp_trig)\n+    choices.append(e.rewrite(cos))\n+    return min(*choices, key=count_ops)\n+newexpr = bottom_up(expr, exp_trig)\n \n     def f(rv):\n         if not rv.is_Mul:\n@@ -590,6 +680,225 @@ def signlog(expr, sign=1):\n     newexpr = bottom_up(newexpr, f)\n \n     # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n+\n+def trigsimp(expr, **opts):\n+    \"\"\"\n+    reduces expression by using known trig identities\n+\n+    Notes\n+    =====\n+\n+    method:\n+    - Determine the method to use. Valid choices are 'matching' (default),\n+    'groebner', 'combined', 'old', and 'fu'. If 'matching', simplify the\n+    expression recursively by targeting common patterns. If 'groebner', apply\n+    an experimental groebner basis algorithm. In this case further options\n+    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n+    If 'combined', first run the groebner basis algorithm with small\n+    default parameters, then run the 'matching' algorithm. 'old' is the\n+    original SymPy algorithm.\n+\n+    compare:\n+    - show input and output from `trigsimp` and `futrig` when different,\n+    but returns the `trigsimp` result.\n+\n+    hint:\n+    - a list of transformations to use that might help the algorithm\n+\n+    Examples\n+    ========\n+\n+    >>> from sympy import trigsimp, sin, cos, log\n+    >>> from sympy.abc import x, y\n+    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n+    >>> trigsimp(e)\n+    2\n+    >>> trigsimp(log(e))\n+    log(2*sin(x)**2 + 2*cos(x)**2)\n+    >>> trigsimp(log(e), deep=True)\n+    log(2)\n+\n+    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n+    simplification.\n+\n+    The old trigsimp routine can be accessed as with method 'old'.\n+\n+    >>> from sympy import coth, tanh\n+    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n+    >>> trigsimp(t, method='old') == t\n+    True\n+    >>> trigsimp(t)\n+    tanh(x)**7\n+\n+    \"\"\"\n+    from sympy.simplify.fu import fu\n+\n+    expr = sympify(expr)\n+\n+    _eval_trigsimp = getattr(expr, '_eval_trigsimp', None)\n+    if _eval_trigsimp is not None:\n+        return _eval_trigsimp(**opts)\n+\n+    old = opts.pop('old', False)\n+    if not old:\n+        opts.pop('deep', None)\n+        recursive = opts.pop('recursive', None)\n+        method = opts.pop('method', 'matching')\n+\n+        def groebnersimp(ex, **opts):\n+            def traverse(e):\n+                if e.is_Atom:\n+                    return e\n+                args = [traverse(x) for x in e.args]\n+                if e.is_Function and isinstance(e, TrigonometricFunction):\n+                    args = [trigsimp_groebner(x, **opts) for x in args]\n+                return e.func(*args)\n+            new = traverse(ex)\n+            if not isinstance(new, Expr):\n+                return new\n+            return trigsimp_groebner(new, **opts)\n+\n+        def futrig(e):\n+            return fu(e, hyper=False)\n+\n+        trigsimpfunc = {\n+            'fu': futrig,\n+            'matching': (lambda x: futrig(groebnersimp(x, polynomial=True, hints=[]))),\n+            'groebner': groebnersimp,\n+            'combined': (lambda x: futrig(groebnersimp(x, polynomial=True, hints=[]))),\n+            'old': lambda x: trigsimp_old(x, **opts),\n+        }\n+        \n+        # Apply exptrigsimp preprocessing if expression contains exponentials\n+        if expr.has(exp):\n+            expr = exptrigsimp(expr)\n+        \n+        return trigsimpfunc[method](expr)\n+\n+    return trigsimp_old(expr, **opts)\n+\n+\n+#-------------------- end of main trigsimp routines --------------------\n+\n+def exptrigsimp(expr):\n+    \"\"\"\n+    Simplifies exponential / trigonometric / hyperbolic functions.\n+\n+    Examples\n+    ========\n+\n+    >>> from sympy import exptrigsimp, exp, cosh, sinh\n+    >>> from sympy.abc import z\n+\n+    >>> exptrigsimp(exp(z) + exp(-z))\n+    2*cosh(z)\n+    >>> exptrigsimp(cosh(z) - sinh(z))\n+    exp(-z)\n+    \"\"\"\n+    from sympy.simplify.fu import hyper_as_trig, TR2i\n+    from sympy.simplify.simplify import bottom_up, simplify\n+\n+    def exp_trig(e):\n+        # select the better of e, and ret pretty much the same\n+        # as what trig_split produced, except that exp's have\n+        # been expanded to trig functions but lists\n+        # of sums are broken into more sums by\n+        # rewrite(exp, cos) than by rewrite(exp, sin)\n+        choices = [e]\n+        if e.has(exp):\n+            choices.append(e.rewrite(exp, sin))\n+            choices.append(e.rewrite(exp, cos))\n+        choices.append(e.rewrite(exp))\n+        return min(choices, key=count_ops)\n+\n+    newexpr = bottom_up(expr, exp_trig)\n+\n+    def f(rv):\n+        if not rv.is_Mul:\n+            return rv\n+        rvd = rv.as_powers_dict()\n+        newd = rvd.copy()\n+\n+        for k, m in rvd.items():\n+            # rewrite hyperbolic functions in terms of exp\n+            for t in [sinh, cosh, tanh, coth]:\n+                if k.has(t):\n+                    k = k.rewrite(t, exp)\n+                    if k != rv:\n+                        newd[k] += newd.pop(rv, 0)\n+                        break\n+\n+            if k.is_Add:\n+                args = k.args\n+                if len(args) == 2:\n+                    a, b = args\n+                    if a == -b:\n+                        if a.is_Mul:\n+                            a, b = a.as_two_terms()\n+                            if a.is_Pow and a.exp.is_integer:\n+                                # get the sign right\n+                                if a.base == S.Exp1:\n+                                    sign = 1\n+                                elif a.base == exp(-1):\n+                                    sign = -1\n+                                else:\n+                                    continue\n+                                if b == sign*S.ImaginaryUnit:\n+                                    k = sin\n+                                elif b == sign:\n+                                    k = sinh\n+                                elif b == -sign*S.ImaginaryUnit:\n+                                    k = cos\n+                                elif b == -sign:\n+                                    k = cosh\n+                                else:\n+                                    continue\n+                                newd[k(abs(a.exp))] += m\n+                                newd.pop(rv)\n+\n+                        elif a.is_Pow and a.exp.is_integer:\n+                            if a.base == S.Exp1:\n+                                sign = 1\n+                            elif a.base == exp(-1):\n+                                sign = -1\n+                            else:\n+                                continue\n+                            newd[2*cosh(abs(a.exp))] += m\n+                            newd.pop(rv)\n+\n+                elif len(args) == 3:\n+                    # similar to above, but for sin and cos\n+                    # looking for Mul terms\n+                    # check for the pattern a*exp(I*x) + b*exp(-I*x) + c\n+                    a, b, c = args\n+                    if (a.is_Mul and b.is_Mul and \n+                        len(a.args) == 2 and len(b.args) == 2):\n+                        # Get the coefficient and exponential parts\n+                        coeff_a, exp_a = a.as_two_terms()\n+                        coeff_b, exp_b = b.as_two_terms()\n+                        \n+                        # Check if we have the pattern coeff*exp(I*x) + coeff*exp(-I*x)\n+                        if (exp_a.is_Pow and exp_b.is_Pow and\n+                            exp_a.base == S.Exp1 and exp_b.base == S.Exp1 and\n+                            exp_a.exp == -exp_b.exp and\n+                            exp_a.exp.is_Mul and len(exp_a.exp.args) == 2):\n+                            \n+                            exp_coeff, exp_arg = exp_a.exp.as_two_terms()\n+                            if exp_coeff == S.ImaginaryUnit:\n+                                # We have exp(I*x) and exp(-I*x) pattern\n+                                if coeff_a == -coeff_b and coeff_a == -S.ImaginaryUnit/2:\n+                                    # Pattern: -I/2*exp(I*x) + I/2*exp(-I*x) = sin(x)\n+                                    newd[sin(exp_arg)] += m\n+                                    newd.pop(rv)\n+                                elif coeff_a == coeff_b and coeff_a == S.One/2:\n+                                    # Pattern: 1/2*exp(I*x) + 1/2*exp(-I*x) = cos(x)\n+                                    newd[cos(exp_arg)] += m\n+                                    newd.pop(rv)\n+\n+        return Mul(*[k**newd[k] for k in newd])\n+    newexpr = bottom_up(newexpr, f)\n+\n+    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n     if newexpr.has(HyperbolicFunction):\n         e, f = hyper_as_trig(newexpr)\n         newexpr = f(TR2i(e))\n",
    "variant_6": "diff --git a/sympy/simplify/trigsimp.py b/sympy/simplify/trigsimp.py\nindex 34a3bab3fc..9b27850617 100644\n--- a/sympy/simplify/trigsimp.py\n+++ b/sympy/simplify/trigsimp.py\n@@ -480,14 +480,22 @@ def trigsimp(expr, **opts):\n     except AttributeError:\n         pass\n \n+    old = opts.pop('old', False)\n+    if not old:\n+        opts.pop('deep', None)\n+        recursive = opts.pop('recursive', None)\n+\n     old = opts.pop('old', False)\n     if not old:\n         opts.pop('deep', None)\n         recursive = opts.pop('recursive', None)\n         method = opts.pop('method', 'matching')\n+        \n+        # Apply exptrigsimp preprocessing if exponential functions are present\n+        if expr.has(exp):\n+            expr = exptrigsimp(expr)\n     else:\n         method = 'old'\n-\n     def groebnersimp(ex, **opts):\n         def traverse(e):\n             if e.is_Atom:\n@@ -501,6 +509,12 @@ def traverse(e):\n             return new\n         return trigsimp_groebner(new, **opts)\n \n+\n+    # Check if expression contains exponential functions and apply exptrigsimp first\n+    from sympy.functions import exp\n+    if expr.has(exp):\n+        expr = exptrigsimp(expr)\n+    \n     trigsimpfunc = {\n         'fu': (lambda x: fu(x, **opts)),\n         'matching': (lambda x: futrig(x)),\n@@ -513,6 +527,7 @@ def traverse(e):\n     return trigsimpfunc(expr)\n \n \n+\n def exptrigsimp(expr):\n     \"\"\"\n     Simplifies exponential / trigonometric / hyperbolic functions.\n@@ -538,9 +553,54 @@ def exp_trig(e):\n         if e.has(*_trigs):\n             choices.append(e.rewrite(exp))\n         choices.append(e.rewrite(cos))\n-        return min(*choices, key=count_ops)\n+        # Add sine rewrite to catch exponential forms that become sine\n+        if e.has(exp):\n+            choices.append(e.rewrite(sin))\n+        return min(choices, key=count_ops)\n+\n     newexpr = bottom_up(expr, exp_trig)\n \n+    # if we didn't change anything and we don't have trig functions\n+    # then skip the fu step\n+    if newexpr == expr and not newexpr.has(*_trigs):\n+        return expr\n+\n+    # otherwise use fu on everything\n+    newexpr = fu(newexpr)\n+\n+    # rewrite hyperbolics in terms of exp\n+    newexpr = newexpr.replace(\n+        lambda x: isinstance(x, HyperbolicFunction), hyper_as_trig)\n+\n+    # if that introduced trig functions, fu it again to reduce then\n+    # rewrite in terms of exp once more\n+    if newexpr.has(*_trigs):\n+        newexpr = fu(newexpr)\n+        newexpr = TR2i(newexpr)\n+\n+    # finally, rewrite in terms of cos if possible (if the expression\n+    # is not already in terms of exp)\n+    if not newexpr.has(exp):\n+        newexpr = newexpr.rewrite(cos)\n+\n+    return newexpr\n+    from sympy.simplify.fu import hyper_as_trig, TR2i\n+    from sympy.simplify.simplify import bottom_up\n+\n+\n+def exp_trig(e):\n+    # select the better of e, and e rewritten in terms of exp or trig\n+    # functions\n+    choices = [e]\n+    if e.has(*_trigs):\n+        choices.append(e.rewrite(exp))\n+    if e.has(exp):\n+        choices.append(e.rewrite(sin))\n+        choices.append(e.rewrite(cos))\n+    choices.append(e.rewrite(cos))\n+    return min(*choices, key=count_ops)\n+newexpr = bottom_up(expr, exp_trig)\n+\n     def f(rv):\n         if not rv.is_Mul:\n             return rv\n@@ -590,16 +650,49 @@ def signlog(expr, sign=1):\n     newexpr = bottom_up(newexpr, f)\n \n     # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n-    if newexpr.has(HyperbolicFunction):\n-        e, f = hyper_as_trig(newexpr)\n-        newexpr = f(TR2i(e))\n-    if newexpr.has(TrigonometricFunction):\n-        newexpr = TR2i(newexpr)\n \n-    # can we ever generate an I where there was none previously?\n-    if not (newexpr.has(I) and not expr.has(I)):\n-        expr = newexpr\n-    return expr\n+    # Apply exptrigsimp preprocessing if expression contains exponentials\n+    if expr.has(exp):\n+        expr = exptrigsimp(expr)\n+    \n+    if opts.pop('compare', False):\n+        f = lambda x: futrig(x, **opts)\n+        g = lambda x: _trigsimp(x, **opts)\n+        return _compare(expr, f, g)\n+\n+    old = opts.pop('old', False)\n+    if not old:\n+        opts.pop('deep', None)\n+        recursive = opts.pop('recursive', None)\n+        method = opts.pop('method', 'matching')\n+    else:\n+        method = 'old'\n+\n+    def groebnersimp(ex, **opts):\n+        def traverse(e):\n+            if e.is_Atom:\n+                return e\n+            args = [traverse(x) for x in e.args]\n+            if e.is_Function and isinstance(e, TrigonometricFunction):\n+                e = e.func(*args)\n+                if e.is_Function and isinstance(e, TrigonometricFunction):\n+                    return _trigsimp(e, **opts)\n+                return e\n+            return e.func(*args)\n+        new = traverse(ex)\n+        if not isinstance(new, Expr):\n+            return new\n+        return _trigsimp(new, deep)\n+\n+    trigsimpfunc = {\n+        'fu': (lambda x: fu(x, **opts)),\n+        'matching': (lambda x: futrig(x)),\n+        'groebner': groebnersimp,\n+        'combined': (lambda x: futrig(groebnersimp(x,\n+                               polynomial=True, hints=[]))),\n+        'old': lambda x: trigsimp_old(x, **opts),\n+                   }\n+    return trigsimpfunc[method](expr)\n \n #-------------------- the old trigsimp routines ---------------------\n \n",
    "variant_7": "diff --git a/sympy/simplify/trigsimp.py b/sympy/simplify/trigsimp.py\nindex 34a3bab3fc..fd497cc172 100644\n--- a/sympy/simplify/trigsimp.py\n+++ b/sympy/simplify/trigsimp.py\n@@ -480,14 +480,21 @@ def trigsimp(expr, **opts):\n     except AttributeError:\n         pass\n \n+    old = opts.pop('old', False)\n+    if not old:\n+        opts.pop('deep', None)\n+        recursive = opts.pop('recursive', None)\n+\n     old = opts.pop('old', False)\n     if not old:\n         opts.pop('deep', None)\n         recursive = opts.pop('recursive', None)\n         method = opts.pop('method', 'matching')\n+        # Apply exptrigsimp as preprocessing for exponential expressions\n+        if any(atom.func.__name__ == 'exp' for atom in expr.atoms() if hasattr(atom, 'func')):\n+            expr = exptrigsimp(expr)\n     else:\n         method = 'old'\n-\n     def groebnersimp(ex, **opts):\n         def traverse(e):\n             if e.is_Atom:\n@@ -501,6 +508,12 @@ def traverse(e):\n             return new\n         return trigsimp_groebner(new, **opts)\n \n+\n+    # Apply exptrigsimp first if exponential functions are present\n+    from sympy.functions import exp\n+    if expr.has(exp):\n+        expr = exptrigsimp(expr)\n+    \n     trigsimpfunc = {\n         'fu': (lambda x: fu(x, **opts)),\n         'matching': (lambda x: futrig(x)),\n@@ -513,33 +526,197 @@ def traverse(e):\n     return trigsimpfunc(expr)\n \n \n-def exptrigsimp(expr):\n+\n+def trigsimp(expr, **opts):\n     \"\"\"\n-    Simplifies exponential / trigonometric / hyperbolic functions.\n+    reduces expression by using known trig identities\n+\n+    Notes\n+    =====\n+\n+    method:\n+    - Determine the method to use. Valid choices are 'matching' (default),\n+    'groebner', 'combined', and 'fu'. If 'matching', simplify the\n+    expression recursively by targeting common patterns. If 'groebner', apply\n+    an experimental groebner basis algorithm. In this case further options\n+    are forwarded to ``groebnersimp``, please refer to its docstring.\n+    If 'combined', first run the groebner basis algorithm with small\n+    default parameters, then run the 'matching' algorithm. 'fu' runs\n+    the collection of trigonometric transformations described by Fu, et al.\n+    (see the `fu` docstring).\n+\n \n     Examples\n     ========\n \n-    >>> from sympy import exptrigsimp, exp, cosh, sinh\n-    >>> from sympy.abc import z\n+    >>> from sympy import trigsimp, sin, cos, log\n+    >>> from sympy.abc import x, y\n+    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n+    >>> trigsimp(e)\n+    2\n+\n+    Simplification occurs wherever trigonometric functions are located.\n+\n+    >>> trigsimp(log(e))\n+    log(2)\n+\n+    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n+    simplification.\n+\n+    The old trigsimp routine can be accessed as with method 'old'.\n+\n+    >>> from sympy import coth, tanh\n+    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n+    >>> trigsimp(t, method='old') == t\n+    True\n+    >>> trigsimp(t)\n+    tanh(x)**7\n \n-    >>> exptrigsimp(exp(z) + exp(-z))\n-    2*cosh(z)\n-    >>> exptrigsimp(cosh(z) - sinh(z))\n-    exp(-z)\n     \"\"\"\n+    from sympy.simplify.fu import fu\n+\n+    expr = sympify(expr)\n+\n+    _eval_trigsimp = getattr(expr, '_eval_trigsimp', None)\n+    if _eval_trigsimp is not None:\n+        return _eval_trigsimp(**opts)\n+\n+    old = opts.pop('old', False)\n+    if not old:\n+        opts.pop('deep', None)\n+        recursive = opts.pop('recursive', None)\n+        method = opts.pop('method', 'matching')\n+    else:\n+        method = 'old'\n+\n+    def groebnersimp(ex, **opts):\n+        def traverse(e):\n+            if e.is_Atom:\n+                return e\n+            args = [traverse(x) for x in e.args]\n+            if e.is_Function and isinstance(e, TrigonometricFunction):\n+                e = e.func(*args)\n+                if e.is_Mul:\n+                    return trigsimp_groebner(e, **opts)\n+                return e\n+            return e.func(*args)\n+        new = traverse(expr)\n+        if not isinstance(new, Expr):\n+            return new\n+        return trigsimp_groebner(new, **opts)\n+\n+    # Apply exptrigsimp first if expression contains exponential functions\n+    if expr.has(exp):\n+        expr = exptrigsimp(expr)\n+\n+    trigsimpfunc = {\n+        'fu': (lambda x: fu(x, **opts)),\n+        'matching': (lambda x: futrig(x)),\n+        'groebner': (lambda x: groebnersimp(x, **opts)),\n+        'combined': (lambda x: futrig(groebnersimp(x,\n+                               polynomial=True, hints=[2, tan]))),\n+        'old': lambda x: trigsimp_old(x, **opts),\n+                   }[method]\n+\n+    return trigsimpfunc(expr)\n     from sympy.simplify.fu import hyper_as_trig, TR2i\n     from sympy.simplify.simplify import bottom_up\n \n-    def exp_trig(e):\n-        # select the better of e, and e rewritten in terms of exp or trig\n-        # functions\n-        choices = [e]\n-        if e.has(*_trigs):\n-            choices.append(e.rewrite(exp))\n-        choices.append(e.rewrite(cos))\n-        return min(*choices, key=count_ops)\n-    newexpr = bottom_up(expr, exp_trig)\n+\n+def trigsimp(expr, **opts):\n+    \"\"\"\n+    reduces expression by using known trig identities\n+\n+    Notes\n+    =====\n+\n+    method:\n+    - Determine the method to use. Valid choices are 'matching' (default),\n+    'groebner', 'combined', 'fu' and 'old'. If 'matching', simplify the\n+    expression recursively by targeting common patterns. If 'groebner', apply\n+    an experimental groebner basis algorithm. In this case further options\n+    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n+    If 'combined', first run the groebner basis algorithm with small\n+    default parameters, then run the 'matching' algorithm. 'fu' runs the\n+    collection of trigonometric transformations described by Fu, et al.\n+    (see the `fu` docstring). If 'old', uses the old SymPy algorithm.\n+\n+    compare:\n+    - show input and output from `trigsimp` and `futrig` when different,\n+    but returns the `trigsimp` result.\n+\n+    Examples\n+    ========\n+\n+    >>> from sympy import trigsimp, sin, cos, log\n+    >>> from sympy.abc import x, y\n+    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n+    >>> trigsimp(e)\n+    2\n+    >>> trigsimp(log(e))\n+    log(2*sin(x)**2 + 2*cos(x)**2)\n+    >>> trigsimp(log(e), deep=True)\n+    log(2)\n+\n+    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n+    simplification.\n+\n+    The old trigsimp routine can be accessed as with method 'old'.\n+\n+    >>> from sympy import coth, tanh\n+    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n+    >>> trigsimp(t, method='old') == t\n+    True\n+    >>> trigsimp(t)\n+    tanh(x)**7\n+\n+    \"\"\"\n+    from sympy.simplify.fu import fu\n+\n+    expr = sympify(expr)\n+\n+    _eval_trigsimp = getattr(expr, '_eval_trigsimp', None)\n+    if _eval_trigsimp is not None:\n+        return _eval_trigsimp(**opts)\n+\n+    old = opts.pop('old', False)\n+    if not old:\n+        opts.pop('deep', None)\n+        recursive = opts.pop('recursive', None)\n+        method = opts.pop('method', 'matching')\n+    else:\n+        method = 'old'\n+\n+    def groebnersimp(ex, **opts):\n+        def traverse(e):\n+            if e.is_Atom:\n+                return e\n+            args = [traverse(x) for x in e.args]\n+            if e.is_Function and e.func in _trigs:\n+                args = [trigsimp_groebner(x, **opts) for x in args]\n+            return e.func(*args)\n+        new = traverse(ex)\n+        if not isinstance(new, Expr):\n+            return new\n+        return trigsimp_groebner(new, **opts)\n+\n+    def futrig(e, **kwargs):\n+        return fu(e, **kwargs)\n+\n+    # Apply exptrigsimp preprocessing if expression contains exponentials\n+    if expr.has(exp):\n+        expr = exptrigsimp(expr)\n+\n+    trigsimpfunc = {\n+        'fu': futrig,\n+        'matching': (lambda x: futrig(groebnersimp(x,\n+                               polynomial=True, hints=[2, tan]))),\n+        'groebner': groebnersimp,\n+        'combined': (lambda x: futrig(groebnersimp(x,\n+                               polynomial=True, hints=[2]))),\n+        'old': lambda x: trigsimp_old(x, **opts),\n+        }\n+    return trigsimpfunc[method](expr, **opts)\n \n     def f(rv):\n         if not rv.is_Mul:\n@@ -590,16 +767,98 @@ def signlog(expr, sign=1):\n     newexpr = bottom_up(newexpr, f)\n \n     # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n-    if newexpr.has(HyperbolicFunction):\n-        e, f = hyper_as_trig(newexpr)\n-        newexpr = f(TR2i(e))\n-    if newexpr.has(TrigonometricFunction):\n-        newexpr = TR2i(newexpr)\n-\n-    # can we ever generate an I where there was none previously?\n-    if not (newexpr.has(I) and not expr.has(I)):\n-        expr = newexpr\n-    return expr\n+\n+def trigsimp(expr, **opts):\n+    \"\"\"\n+    reduces expression by using known trig identities\n+\n+    Notes\n+    =====\n+\n+    method:\n+    - Determine the method to use. Valid choices are 'matching' (default),\n+    'groebner', 'combined', 'fu' and 'old'. If 'matching', simplify the\n+    expression recursively by targeting common patterns. If 'groebner', apply\n+    an experimental groebner basis algorithm. In this case further options\n+    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n+    If 'combined', first run the groebner basis algorithm with small\n+    default parameters, then run the 'matching' algorithm. 'fu' runs the\n+    collection of trigonometric transformations described by Fu, et al.\n+    (see the `fu` docstring).\n+\n+\n+    Examples\n+    ========\n+\n+    >>> from sympy import trigsimp, sin, cos, log\n+    >>> from sympy.abc import x, y\n+    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n+    >>> trigsimp(e)\n+    2\n+\n+    Simplification occurs wherever trigonometric functions are located.\n+\n+    >>> trigsimp(log(e))\n+    log(2)\n+\n+    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n+    simplification.\n+\n+    The old trigsimp routine can be accessed as with method 'old'.\n+\n+    >>> from sympy import coth, tanh\n+    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n+    >>> trigsimp(t, method='old') == t\n+    True\n+    >>> trigsimp(t)\n+    tanh(x)**7\n+\n+    \"\"\"\n+    from sympy.simplify.fu import fu\n+\n+    expr = sympify(expr)\n+\n+    _eval_trigsimp = getattr(expr, '_eval_trigsimp', None)\n+    if _eval_trigsimp is not None:\n+        return _eval_trigsimp(**opts)\n+\n+    old = opts.pop('old', False)\n+    if not old:\n+        opts.pop('deep', None)\n+        recursive = opts.pop('recursive', None)\n+        method = opts.pop('method', 'matching')\n+    else:\n+        method = 'old'\n+\n+    def groebnersimp(ex, **opts):\n+        def traverse(e):\n+            if e.is_Atom:\n+                return e\n+            args = [traverse(x) for x in e.args]\n+            if e.is_Function and isinstance(e, TrigonometricFunction):\n+                e = e.func(*args)\n+                e = trigsimp_groebner(e, **opts)\n+                return e\n+            return e.func(*args)\n+        new = traverse(expr)\n+        if not isinstance(new, Expr):\n+            return new\n+        return trigsimp_groebner(new, **opts)\n+\n+    trigsimpfunc = {\n+        'fu': (lambda x: fu(x, **opts)),\n+        'matching': (lambda x: futrig(x)),\n+        'groebner': (lambda x: groebnersimp(x, **opts)),\n+        'combined': (lambda x: futrig(groebnersimp(x,\n+                               polynomial=True, hints=[2, tan]))),\n+        'old': lambda x: trigsimp_old(x, **opts),\n+    }\n+\n+    # Apply exptrigsimp as preprocessing if exponential functions are present\n+    if expr.has(exp):\n+        expr = exptrigsimp(expr)\n+    \n+    return trigsimpfunc[method](expr)\n \n #-------------------- the old trigsimp routines ---------------------\n \n",
    "variant_8": "diff --git a/sympy/simplify/trigsimp.py b/sympy/simplify/trigsimp.py\nindex 34a3bab3fc..e6fb289084 100644\n--- a/sympy/simplify/trigsimp.py\n+++ b/sympy/simplify/trigsimp.py\n@@ -480,14 +480,21 @@ def trigsimp(expr, **opts):\n     except AttributeError:\n         pass\n \n+    old = opts.pop('old', False)\n+    if not old:\n+        opts.pop('deep', None)\n+        recursive = opts.pop('recursive', None)\n+\n     old = opts.pop('old', False)\n     if not old:\n         opts.pop('deep', None)\n         recursive = opts.pop('recursive', None)\n         method = opts.pop('method', 'matching')\n+        # Apply exptrigsimp as preprocessing when exponential functions are present\n+        if expr.has(exp):\n+            expr = exptrigsimp(expr)\n     else:\n         method = 'old'\n-\n     def groebnersimp(ex, **opts):\n         def traverse(e):\n             if e.is_Atom:\n@@ -501,18 +508,20 @@ def traverse(e):\n             return new\n         return trigsimp_groebner(new, **opts)\n \n+\n     trigsimpfunc = {\n-        'fu': (lambda x: fu(x, **opts)),\n-        'matching': (lambda x: futrig(x)),\n-        'groebner': (lambda x: groebnersimp(x, **opts)),\n-        'combined': (lambda x: futrig(groebnersimp(x,\n+        'fu': (lambda x: fu(exptrigsimp(x), **opts)),\n+        'matching': (lambda x: futrig(exptrigsimp(x))),\n+        'groebner': (lambda x: groebnersimp(exptrigsimp(x), **opts)),\n+        'combined': (lambda x: futrig(groebnersimp(exptrigsimp(x),\n                                polynomial=True, hints=[2, tan]))),\n-        'old': lambda x: trigsimp_old(x, **opts),\n+        'old': lambda x: trigsimp_old(exptrigsimp(x), **opts),\n                    }[method]\n \n     return trigsimpfunc(expr)\n \n \n+\n def exptrigsimp(expr):\n     \"\"\"\n     Simplifies exponential / trigonometric / hyperbolic functions.\n@@ -538,6 +547,72 @@ def exp_trig(e):\n         if e.has(*_trigs):\n             choices.append(e.rewrite(exp))\n         choices.append(e.rewrite(cos))\n+        # Also try rewriting in terms of sin for expressions like exp(I*x) - exp(-I*x)\n+        if e.has(exp):\n+            choices.append(e.rewrite(sin))\n+        return min(choices, key=count_ops)\n+\n+    newexpr = bottom_up(expr, exp_trig)\n+\n+    # XXX todo: deal with sin(x)*cos(x) -> sin(2*x)/2 ...\n+    # do one pass to see if any exp's can be simplified.\n+    newexpr = bottom_up(newexpr, _osborne)\n+    newexpr = bottom_up(newexpr, _osbornei)\n+\n+    newexpr = bottom_up(newexpr, lambda x: _eapply(x, _mexpand))\n+    newexpr = TR2i(newexpr)\n+    if newexpr.has(HyperbolicFunction):\n+        newexpr = hyper_as_trig(newexpr)\n+        newexpr = TR2i(newexpr)\n+    # can we ever generate an I where there was none previously?\n+    if not (newexpr.has(I) and not expr.has(I)):\n+        expr = newexpr\n+    return expr\n+    from sympy.simplify.fu import hyper_as_trig, TR2i\n+    from sympy.simplify.simplify import bottom_up\n+\n+\n+def exptrigsimp(expr):\n+    \"\"\"\n+    Simplifies exponential / trigonometric / hyperbolic functions.\n+\n+    This takes a much more aggressive approach than the other\n+    simplification routines, and is capable of returning results in a\n+    number of cases where the other routines fail.\n+    However, it also fails in some cases.  This routine uses a combination of the\n+    hyperbolics-to-trig identities in ``fu`` as well as using ``rewrite`` to\n+    express the expression in terms of ``exp``, and then converting back to\n+    trig.  ``fu`` and the rewriting approach are applied until there are no\n+    more reductions possible.\n+\n+    Examples\n+    ========\n+\n+    >>> from sympy import exptrigsimp, sinh, cosh, exp, I, sin, cos\n+    >>> from sympy.abc import z, k\n+\n+    >>> exptrigsimp(exp(z) + exp(-z))\n+    2*cosh(z)\n+    >>> exptrigsimp(cosh(z) - sinh(z))\n+    exp(-z)\n+    \n+    It can also convert exponential expressions to trigonometric forms:\n+    \n+    >>> exptrigsimp(I/2*(exp(-I*k) - exp(I*k)))\n+    sin(k)\n+    \"\"\"\n+    from sympy.simplify.fu import hyper_as_trig, TR2i\n+    from sympy.simplify.simplify import bottom_up\n+\n+    def exp_trig(e):\n+        # select the better of e, and e rewritten in terms of exp or trig\n+        # functions\n+        choices = [e]\n+        if e.has(*_trigs):\n+            choices.append(e.rewrite(exp))\n+        # Always try rewriting in terms of cos/sin to catch exponential expressions\n+        choices.append(e.rewrite(cos))\n+        choices.append(e.rewrite(sin))\n         return min(*choices, key=count_ops)\n     newexpr = bottom_up(expr, exp_trig)\n \n@@ -590,16 +665,93 @@ def signlog(expr, sign=1):\n     newexpr = bottom_up(newexpr, f)\n \n     # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n-    if newexpr.has(HyperbolicFunction):\n-        e, f = hyper_as_trig(newexpr)\n-        newexpr = f(TR2i(e))\n-    if newexpr.has(TrigonometricFunction):\n-        newexpr = TR2i(newexpr)\n \n-    # can we ever generate an I where there was none previously?\n-    if not (newexpr.has(I) and not expr.has(I)):\n-        expr = newexpr\n-    return expr\n+def trigsimp(expr, **opts):\n+    \"\"\"\n+    reduces expression by using known trig identities\n+\n+    Notes\n+    =====\n+\n+    method:\n+    - Determine the method to use. Valid choices are 'matching' (default),\n+    'groebner', 'combined', 'old', and 'fu'. If 'matching', simplify the\n+    expression recursively by targeting common patterns. If 'groebner', apply\n+    an experimental groebner basis algorithm. In this case further options\n+    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n+    If 'combined', first run the groebner basis algorithm with small\n+    default parameters, then run the 'matching' algorithm. 'old' is the\n+    original implementation. If 'fu', the expression is rewritten using\n+    a collection of transformations (see fu docstring) that mimic those in\n+    Axiom.\n+\n+    Examples\n+    ========\n+\n+    >>> from sympy import trigsimp, sin, cos, log\n+    >>> from sympy.abc import x, y\n+    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n+    >>> trigsimp(e)\n+    2\n+\n+    Simplification occurs wherever trigonometric functions are located.\n+\n+    >>> trigsimp(log(e))\n+    log(2)\n+\n+    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n+    simplification.\n+\n+    The old trigsimp routine can be accessed as\n+\n+    >>> from sympy import trigsimp_old\n+    >>> trigsimp_old(sin(x)**2 + cos(x)**2)\n+    1\n+\n+    \"\"\"\n+    from sympy.simplify.fu import fu\n+\n+    expr = sympify(expr)\n+\n+    _eval_trigsimp = getattr(expr, '_eval_trigsimp', None)\n+    if _eval_trigsimp is not None:\n+        return _eval_trigsimp(**opts)\n+\n+    old = opts.pop('old', False)\n+    if not old:\n+        opts.pop('deep', None)\n+        recursive = opts.pop('recursive', None)\n+        method = opts.pop('method', 'matching')\n+    else:\n+        method = 'old'\n+\n+    def groebnersimp(ex, **opts):\n+        def traverse(e):\n+            if e.is_Atom:\n+                return e\n+            args = [traverse(x) for x in e.args]\n+            if e.is_Function and e.func in (TrigonometricFunction, HyperbolicFunction):\n+                args = [trigsimp_groebner(x, **opts) for x in args]\n+            return e.func(*args)\n+        new = traverse(expr)\n+        if not isinstance(new, Expr):\n+            return new\n+        return trigsimp_groebner(new, **opts)\n+\n+    trigsimpfunc = {\n+        'fu': (lambda x: fu(x, **opts)),\n+        'matching': (lambda x: futrig(x)),\n+        'groebner': (lambda x: groebnersimp(x, **opts)),\n+        'combined': (lambda x: futrig(groebnersimp(x,\n+                               polynomial=True, hints=[2, tan]))),\n+        'old': lambda x: trigsimp_old(x, **opts),\n+    }\n+\n+    # Apply exptrigsimp first if exponential functions are present\n+    if expr.has(exp):\n+        expr = exptrigsimp(expr)\n+\n+    return trigsimpfunc[method](expr)\n \n #-------------------- the old trigsimp routines ---------------------\n \n"
  }
}