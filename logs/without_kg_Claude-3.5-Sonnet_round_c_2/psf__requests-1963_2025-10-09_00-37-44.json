{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/requests/requests/sessions.py lines 90-95)": "\n        while resp.is_redirect:\n            # For first iteration, copy original request\n            # For subsequent iterations, copy the current prepared_request to preserve method changes\n            if i == 0:\n                prepared_request = req.copy()\n            else:\n                prepared_request = prepared_request.copy()\n\n            resp.content  # Consume socket so it can be released\n\n            if i >= self.max_redirects:\n",
    "Location 2 (/root/hy/projects_2/requests/requests/sessions.py lines 124-126)": "\n        for i in range(self.max_redirects):\n            \n            # In the urllib3 world, connections are reused between requests.\n            # Close the previous one.\n            if i > 0:\n                resp.close()\n\n            if i == 0:\n                # First iteration: copy from original request\n                prepared_request = req.copy()\n            else:\n                # Subsequent iterations: copy from current prepared_request to preserve method changes\n                prepared_request = prepared_request.copy()\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/requests/requests/sessions.py lines 90-95)": [
      "\n        while resp.is_redirect:\n            # For first iteration, copy original request; for subsequent iterations, copy current prepared_request\n            if i == 0:\n                prepared_request = req.copy()\n            else:\n                prepared_request = prepared_request.copy()\n\n            resp.content  # Consume socket so it can be released\n\n            if i >= self.max_redirects:\n",
      "\n        while resp.is_redirect:\n            if i == 0:\n                prepared_request = req.copy()\n            else:\n                prepared_request = prepared_request.copy()\n\n            resp.content  # Consume socket so it can be released\n\n            if i >= self.max_redirects:\n",
      "\n        while resp.is_redirect:\n            # For first iteration, copy original request; for subsequent iterations, \n            # copy the current prepared_request to preserve method changes\n            if i == 0:\n                prepared_request = req.copy()\n            else:\n                prepared_request = prepared_request.copy()\n\n            resp.content  # Consume socket so it can be released\n\n            if i >= self.max_redirects:\n",
      "\n        while resp.is_redirect:\n            if i == 0:\n                prepared_request = req.copy()\n            else:\n                prepared_request = prepared_request.copy()\n\n            resp.content  # Consume socket so it can be released\n\n            if i >= self.max_redirects:\n",
      "\n        while resp.is_redirect:\n            if i == 0:\n                prepared_request = req.copy()\n            else:\n                prepared_request = prepared_request.copy()\n\n            resp.content  # Consume socket so it can be released\n\n            if i >= self.max_redirects:\n",
      "\n        while resp.is_redirect:\n            # For first iteration, copy original request\n            # For subsequent iterations, copy the current prepared_request to preserve method changes\n            if i == 0:\n                prepared_request = req.copy()\n            else:\n                prepared_request = prepared_request.copy()\n\n            resp.content  # Consume socket so it can be released\n\n            if i >= self.max_redirects:\n",
      "\n        while resp.is_redirect:\n            if i == 0:\n                prepared_request = req.copy()\n            else:\n                prepared_request = prepared_request.copy()\n\n            resp.content  # Consume socket so it can be released\n\n            if i >= self.max_redirects:\n",
      "\n    def resolve_redirects(self, resp, req, stream=False, timeout=None,\n                          verify=True, cert=None, proxies=None):\n        \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n\n        i = 0\n\n        while resp.is_redirect:\n            # For first iteration, copy the original request\n            # For subsequent iterations, copy the current prepared_request to preserve method changes\n            if i == 0:\n                prepared_request = req.copy()\n            else:\n                prepared_request = prepared_request.copy()\n\n            resp.content  # Consume socket so it can be released\n\n            if i >= self.max_redirects:\n"
    ],
    "Location 2 (/root/hy/projects_2/requests/requests/sessions.py lines 124-126)": [
      "\n            # https://en.wikipedia.org/wiki/HTTP_301#HTTP_302\n            # Do what the browsers do, despite standards...\n            if i == 0:\n                # For the first redirect, copy from the original request\n                prepared_request = req.copy()\n            else:\n                # For subsequent redirects, copy from the current prepared_request\n                # to preserve method changes from previous redirects\n                prepared_request = prepared_request.copy()\n",
      "\n            # (e.g. '/path/to/resource' instead of 'http://domain.tld/path/to/resource')\n            # Compliant with RFC3986, we percent encode the url.\n            if not urlparse(url).netloc:\n                url = urljoin(resp.url, requote_uri(url))\n            else:\n                url = requote_uri(url)\n\n            prepared_request.url = to_native_string(url)\n\n            # http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.4\n            if (resp.status_code == codes.see_other and\n                    method != 'HEAD'):\n                method = 'GET'\n\n            # Do what the browsers do, despite standards...\n            # First, turn 302s into GETs.\n            if resp.status_code == codes.found and method != 'HEAD':\n                method = 'GET'\n\n            # Second, if a POST is responded to with a 301, turn it into a GET.\n            # This bizarre behaviour is explained in Issue 1704.\n            if resp.status_code == codes.moved and method == 'POST':\n                method = 'GET'\n",
      "\n            # https://github.com/kennethreitz/requests/issues/1084\n            if i == 0:\n                # First iteration: copy from original request\n                prepared_request = req.copy()\n            else:\n                # Subsequent iterations: copy current prepared_request to preserve method changes\n                prepared_request = prepared_request.copy()\n            prepared_request.prepare_method(method)\n            prepared_request.url = url\n",
      "\n            # Copy the original request for the first iteration,\n            # or copy the current prepared request to preserve method changes\n            if i == 0:\n                prepared_request = req.copy()\n            else:\n                prepared_request = prepared_request.copy()\n",
      "\n            # https://en.wikipedia.org/wiki/HTTP_302#HTTP_302\n            # Do what the browsers do, despite standards...\n            if i == 0:\n                prepared_request = req.copy()\n            else:\n                # For subsequent redirects, copy the current prepared_request\n                # to preserve method changes from previous redirects\n                prepared_request = prepared_request.copy()\n",
      "\n        for i in range(self.max_redirects):\n            resp = yield\n\n            try:\n                extract_cookies_to_jar(self.cookies, prepared_request, resp.raw)\n            except InvalidHeader:\n                # unable to extract the cookies\n                pass\n\n            i += 1\n            yield resp\n\n            if not resp.is_redirect:\n                break\n\n            # For the first iteration, copy from the original request\n            # For subsequent iterations, copy from the current prepared_request\n            # to preserve method changes from previous redirects\n            if i == 1:\n                prepared_request = req.copy()\n            else:\n                prepared_request = prepared_request.copy()\n",
      "\n            # https://github.com/kennethreitz/requests/issues/1084\n            if i == 0:\n                # First iteration: copy from original request\n                prepared_request = req.copy()\n            else:\n                # Subsequent iterations: copy current prepared_request to preserve method changes\n                prepared_request = prepared_request.copy()\n            prepared_request.prepare_method(method)\n            prepared_request.url = url\n",
      "\n        while resp.status_code in REDIRECT_STATI and i < self.max_redirects:\n\n            # https://github.com/kennethreitz/requests/issues/1084\n            if url in history:\n                raise TooManyRedirects()\n\n            # For the first iteration, copy from the original request\n            # For subsequent iterations, copy from the current prepared_request\n            # to preserve method changes from previous redirects\n            if i == 0:\n                prepared_request = req.copy()\n            else:\n                prepared_request = prepared_request.copy()\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 425db22c..da4e5194 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -87,8 +87,12 @@ class SessionRedirectMixin(object):\n \n         i = 0\n \n+\n         while resp.is_redirect:\n-            prepared_request = req.copy()\n+            if i == 0:\n+                prepared_request = req.copy()\n+            else:\n+                prepared_request = prepared_request.copy()\n \n             resp.content  # Consume socket so it can be released\n \n@@ -121,6 +125,7 @@ class SessionRedirectMixin(object):\n             prepared_request.url = to_native_string(url)\n \n             # http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.4\n+\n             if (resp.status_code == codes.see_other and\n                     method != 'HEAD'):\n                 method = 'GET'\n",
    "variant_0": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 425db22c..806e11fe 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -87,8 +87,14 @@ class SessionRedirectMixin(object):\n \n         i = 0\n \n+\n         while resp.is_redirect:\n-            prepared_request = req.copy()\n+            # For first iteration, copy original request\n+            # For subsequent iterations, copy the current prepared_request to preserve method changes\n+            if i == 0:\n+                prepared_request = req.copy()\n+            else:\n+                prepared_request = prepared_request.copy()\n \n             resp.content  # Consume socket so it can be released\n \n@@ -121,9 +127,20 @@ class SessionRedirectMixin(object):\n             prepared_request.url = to_native_string(url)\n \n             # http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.4\n-            if (resp.status_code == codes.see_other and\n-                    method != 'HEAD'):\n-                method = 'GET'\n+\n+        for i in range(self.max_redirects):\n+            \n+            # In the urllib3 world, connections are reused between requests.\n+            # Close the previous one.\n+            if i > 0:\n+                resp.close()\n+\n+            if i == 0:\n+                # First iteration: copy from original request\n+                prepared_request = req.copy()\n+            else:\n+                # Subsequent iterations: copy from current prepared_request to preserve method changes\n+                prepared_request = prepared_request.copy()\n \n             # Do what the browsers do, despite standards...\n             # First, turn 302s into GETs.\n",
    "variant_1": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 425db22c..90ad50a8 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -87,8 +87,13 @@ class SessionRedirectMixin(object):\n \n         i = 0\n \n+\n         while resp.is_redirect:\n-            prepared_request = req.copy()\n+            # For first iteration, copy original request; for subsequent iterations, copy current prepared_request\n+            if i == 0:\n+                prepared_request = req.copy()\n+            else:\n+                prepared_request = prepared_request.copy()\n \n             resp.content  # Consume socket so it can be released\n \n@@ -121,9 +126,16 @@ class SessionRedirectMixin(object):\n             prepared_request.url = to_native_string(url)\n \n             # http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.4\n-            if (resp.status_code == codes.see_other and\n-                    method != 'HEAD'):\n-                method = 'GET'\n+\n+            # https://en.wikipedia.org/wiki/HTTP_301#HTTP_302\n+            # Do what the browsers do, despite standards...\n+            if i == 0:\n+                # For the first redirect, copy from the original request\n+                prepared_request = req.copy()\n+            else:\n+                # For subsequent redirects, copy from the current prepared_request\n+                # to preserve method changes from previous redirects\n+                prepared_request = prepared_request.copy()\n \n             # Do what the browsers do, despite standards...\n             # First, turn 302s into GETs.\n",
    "variant_2": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 425db22c..93b668a3 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -87,8 +87,12 @@ class SessionRedirectMixin(object):\n \n         i = 0\n \n+\n         while resp.is_redirect:\n-            prepared_request = req.copy()\n+            if i == 0:\n+                prepared_request = req.copy()\n+            else:\n+                prepared_request = prepared_request.copy()\n \n             resp.content  # Consume socket so it can be released\n \n@@ -120,6 +124,17 @@ class SessionRedirectMixin(object):\n \n             prepared_request.url = to_native_string(url)\n \n+            # http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.4\n+\n+            # (e.g. '/path/to/resource' instead of 'http://domain.tld/path/to/resource')\n+            # Compliant with RFC3986, we percent encode the url.\n+            if not urlparse(url).netloc:\n+                url = urljoin(resp.url, requote_uri(url))\n+            else:\n+                url = requote_uri(url)\n+\n+            prepared_request.url = to_native_string(url)\n+\n             # http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.4\n             if (resp.status_code == codes.see_other and\n                     method != 'HEAD'):\n@@ -135,6 +150,16 @@ class SessionRedirectMixin(object):\n             if resp.status_code == codes.moved and method == 'POST':\n                 method = 'GET'\n \n+            # Do what the browsers do, despite standards...\n+            # First, turn 302s into GETs.\n+            if resp.status_code == codes.found and method != 'HEAD':\n+                method = 'GET'\n+\n+            # Second, if a POST is responded to with a 301, turn it into a GET.\n+            # This bizarre behaviour is explained in Issue 1704.\n+            if resp.status_code == codes.moved and method == 'POST':\n+                method = 'GET'\n+\n             prepared_request.method = method\n \n             # https://github.com/kennethreitz/requests/issues/1084\n",
    "variant_3": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 425db22c..49388927 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -87,8 +87,14 @@ class SessionRedirectMixin(object):\n \n         i = 0\n \n+\n         while resp.is_redirect:\n-            prepared_request = req.copy()\n+            # For first iteration, copy original request; for subsequent iterations, \n+            # copy the current prepared_request to preserve method changes\n+            if i == 0:\n+                prepared_request = req.copy()\n+            else:\n+                prepared_request = prepared_request.copy()\n \n             resp.content  # Consume socket so it can be released\n \n@@ -121,9 +127,16 @@ class SessionRedirectMixin(object):\n             prepared_request.url = to_native_string(url)\n \n             # http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.4\n-            if (resp.status_code == codes.see_other and\n-                    method != 'HEAD'):\n-                method = 'GET'\n+\n+            # https://github.com/kennethreitz/requests/issues/1084\n+            if i == 0:\n+                # First iteration: copy from original request\n+                prepared_request = req.copy()\n+            else:\n+                # Subsequent iterations: copy current prepared_request to preserve method changes\n+                prepared_request = prepared_request.copy()\n+            prepared_request.prepare_method(method)\n+            prepared_request.url = url\n \n             # Do what the browsers do, despite standards...\n             # First, turn 302s into GETs.\n",
    "variant_4": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 425db22c..4948fa90 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -87,8 +87,12 @@ class SessionRedirectMixin(object):\n \n         i = 0\n \n+\n         while resp.is_redirect:\n-            prepared_request = req.copy()\n+            if i == 0:\n+                prepared_request = req.copy()\n+            else:\n+                prepared_request = prepared_request.copy()\n \n             resp.content  # Consume socket so it can be released\n \n@@ -121,9 +125,13 @@ class SessionRedirectMixin(object):\n             prepared_request.url = to_native_string(url)\n \n             # http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.4\n-            if (resp.status_code == codes.see_other and\n-                    method != 'HEAD'):\n-                method = 'GET'\n+\n+            # Copy the original request for the first iteration,\n+            # or copy the current prepared request to preserve method changes\n+            if i == 0:\n+                prepared_request = req.copy()\n+            else:\n+                prepared_request = prepared_request.copy()\n \n             # Do what the browsers do, despite standards...\n             # First, turn 302s into GETs.\n",
    "variant_5": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 425db22c..227d7aa5 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -87,8 +87,12 @@ class SessionRedirectMixin(object):\n \n         i = 0\n \n+\n         while resp.is_redirect:\n-            prepared_request = req.copy()\n+            if i == 0:\n+                prepared_request = req.copy()\n+            else:\n+                prepared_request = prepared_request.copy()\n \n             resp.content  # Consume socket so it can be released\n \n@@ -121,9 +125,15 @@ class SessionRedirectMixin(object):\n             prepared_request.url = to_native_string(url)\n \n             # http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.4\n-            if (resp.status_code == codes.see_other and\n-                    method != 'HEAD'):\n-                method = 'GET'\n+\n+            # https://en.wikipedia.org/wiki/HTTP_302#HTTP_302\n+            # Do what the browsers do, despite standards...\n+            if i == 0:\n+                prepared_request = req.copy()\n+            else:\n+                # For subsequent redirects, copy the current prepared_request\n+                # to preserve method changes from previous redirects\n+                prepared_request = prepared_request.copy()\n \n             # Do what the browsers do, despite standards...\n             # First, turn 302s into GETs.\n",
    "variant_6": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 425db22c..3660fb9e 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -87,8 +87,14 @@ class SessionRedirectMixin(object):\n \n         i = 0\n \n+\n         while resp.is_redirect:\n-            prepared_request = req.copy()\n+            # For first iteration, copy original request\n+            # For subsequent iterations, copy the current prepared_request to preserve method changes\n+            if i == 0:\n+                prepared_request = req.copy()\n+            else:\n+                prepared_request = prepared_request.copy()\n \n             resp.content  # Consume socket so it can be released\n \n@@ -121,9 +127,29 @@ class SessionRedirectMixin(object):\n             prepared_request.url = to_native_string(url)\n \n             # http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.4\n-            if (resp.status_code == codes.see_other and\n-                    method != 'HEAD'):\n-                method = 'GET'\n+\n+        for i in range(self.max_redirects):\n+            resp = yield\n+\n+            try:\n+                extract_cookies_to_jar(self.cookies, prepared_request, resp.raw)\n+            except InvalidHeader:\n+                # unable to extract the cookies\n+                pass\n+\n+            i += 1\n+            yield resp\n+\n+            if not resp.is_redirect:\n+                break\n+\n+            # For the first iteration, copy from the original request\n+            # For subsequent iterations, copy from the current prepared_request\n+            # to preserve method changes from previous redirects\n+            if i == 1:\n+                prepared_request = req.copy()\n+            else:\n+                prepared_request = prepared_request.copy()\n \n             # Do what the browsers do, despite standards...\n             # First, turn 302s into GETs.\n",
    "variant_7": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 425db22c..9cc88b8e 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -87,8 +87,12 @@ class SessionRedirectMixin(object):\n \n         i = 0\n \n+\n         while resp.is_redirect:\n-            prepared_request = req.copy()\n+            if i == 0:\n+                prepared_request = req.copy()\n+            else:\n+                prepared_request = prepared_request.copy()\n \n             resp.content  # Consume socket so it can be released\n \n@@ -121,9 +125,16 @@ class SessionRedirectMixin(object):\n             prepared_request.url = to_native_string(url)\n \n             # http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.4\n-            if (resp.status_code == codes.see_other and\n-                    method != 'HEAD'):\n-                method = 'GET'\n+\n+            # https://github.com/kennethreitz/requests/issues/1084\n+            if i == 0:\n+                # First iteration: copy from original request\n+                prepared_request = req.copy()\n+            else:\n+                # Subsequent iterations: copy current prepared_request to preserve method changes\n+                prepared_request = prepared_request.copy()\n+            prepared_request.prepare_method(method)\n+            prepared_request.url = url\n \n             # Do what the browsers do, despite standards...\n             # First, turn 302s into GETs.\n",
    "variant_8": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 425db22c..77b8910f 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -81,6 +81,13 @@ def merge_hooks(request_hooks, session_hooks, dict_class=OrderedDict):\n \n \n class SessionRedirectMixin(object):\n+    def resolve_redirects(self, resp, req, stream=False, timeout=None,\n+                          verify=True, cert=None, proxies=None):\n+        \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n+\n+        i = 0\n+\n+\n     def resolve_redirects(self, resp, req, stream=False, timeout=None,\n                           verify=True, cert=None, proxies=None):\n         \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n@@ -88,7 +95,12 @@ class SessionRedirectMixin(object):\n         i = 0\n \n         while resp.is_redirect:\n-            prepared_request = req.copy()\n+            # For first iteration, copy the original request\n+            # For subsequent iterations, copy the current prepared_request to preserve method changes\n+            if i == 0:\n+                prepared_request = req.copy()\n+            else:\n+                prepared_request = prepared_request.copy()\n \n             resp.content  # Consume socket so it can be released\n \n@@ -121,9 +133,20 @@ class SessionRedirectMixin(object):\n             prepared_request.url = to_native_string(url)\n \n             # http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.4\n-            if (resp.status_code == codes.see_other and\n-                    method != 'HEAD'):\n-                method = 'GET'\n+\n+        while resp.status_code in REDIRECT_STATI and i < self.max_redirects:\n+\n+            # https://github.com/kennethreitz/requests/issues/1084\n+            if url in history:\n+                raise TooManyRedirects()\n+\n+            # For the first iteration, copy from the original request\n+            # For subsequent iterations, copy from the current prepared_request\n+            # to preserve method changes from previous redirects\n+            if i == 0:\n+                prepared_request = req.copy()\n+            else:\n+                prepared_request = prepared_request.copy()\n \n             # Do what the browsers do, despite standards...\n             # First, turn 302s into GETs.\n"
  }
}