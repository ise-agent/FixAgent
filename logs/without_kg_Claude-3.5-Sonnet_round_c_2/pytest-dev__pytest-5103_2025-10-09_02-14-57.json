{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/pytest/src/_pytest/assertion/rewrite.py lines 967-992)": "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() calls\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in (\"all\", \"any\") and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Visit the iterable argument\n            iterable_res, iterable_expl = self.visit(iterable_arg)\n            \n            # Create a temporary variable to hold the iterable\n            iterable_var = self.variable()\n            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_res))\n            \n            # Create a result variable\n            result_var = self.variable()\n            \n            # Initialize result based on function type\n            if func_name == \"all\":\n                init_value = ast.NameConstant(True)\n            else:  # any\n                init_value = ast.NameConstant(False)\n            \n            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], init_value))\n            \n            # Create loop variable\n            loop_var = self.variable()\n            \n            # Create the for loop body\n            loop_body = []\n            \n            # Visit the loop variable to get explanation\n            loop_res = ast.Name(loop_var, ast.Load())\n            loop_expl = self.display(loop_res)\n            \n            # Create condition check\n            if func_name == \"all\":\n                # For all(): if not item, set result to False and break\n                condition = ast.UnaryOp(ast.Not(), ast.Name(loop_var, ast.Load()))\n                loop_body.append(ast.If(\n                    condition,\n                    [ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False)),\n                     ast.Break()],\n                    []\n                ))\n            else:  # any\n                # For any(): if item, set result to True and break\n                condition = ast.Name(loop_var, ast.Load())\n                loop_body.append(ast.If(\n                    condition,\n                    [ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True)),\n                     ast.Break()],\n                    []\n                ))\n            \n            # Create the for loop\n            for_loop = ast.For(\n                ast.Name(loop_var, ast.Store()),\n                ast.Name(iterable_var, ast.Load()),\n                loop_body,\n                []\n            )\n            \n            self.statements.append(for_loop)\n            \n            # Create explanation\n            expl = \"%s(%s)\" % (func_name, iterable_expl)\n            res_expl = self.explanation_param(self.display(ast.Name(result_var, ast.Load())))\n            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n            \n            return ast.Name(result_var, ast.Load()), outer_expl\n        \n        # Original generic function call handling\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
    "Location 2 (/root/hy/projects_2/pytest/src/_pytest/assertion/rewrite.py lines 1000-1028)": "\n    def visit_Call_legacy(self, call):\n        \"\"\"\n        visit `ast.Call nodes on 3.4 and below`\n        \"\"\"\n        # Special handling for all() and any() calls\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in (\"all\", \"any\") and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Visit the iterable argument\n            new_iterable, iterable_expl = self.visit(iterable_arg)\n            \n            # Create a temporary variable to hold the iterable\n            iterable_var = self.variable()\n            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], new_iterable))\n            \n            # Create a temporary variable for the result\n            result_var = self.variable()\n            \n            # Create the unrolled logic\n            if func_name == \"all\":\n                # For all(): start with True, set to False if any element is falsy\n                self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True)))\n                \n                # Create loop to check each element\n                loop_var = self.variable()\n                element_var = self.variable()\n                \n                # for element in iterable:\n                #     if not element:\n                #         result = False\n                #         break\n                loop_body = [\n                    ast.Assign([ast.Name(element_var, ast.Store())], ast.Name(loop_var, ast.Load())),\n                    ast.If(\n                        test=ast.UnaryOp(op=ast.Not(), operand=ast.Name(element_var, ast.Load())),\n                        body=[\n                            ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False)),\n                            ast.Break()\n                        ],\n                        orelse=[]\n                    )\n                ]\n            else:  # any()\n                # For any(): start with False, set to True if any element is truthy\n                self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False)))\n                \n                # Create loop to check each element\n                loop_var = self.variable()\n                element_var = self.variable()\n                \n                # for element in iterable:\n                #     if element:\n                #         result = True\n                #         break\n                loop_body = [\n                    ast.Assign([ast.Name(element_var, ast.Store())], ast.Name(loop_var, ast.Load())),\n                    ast.If(\n                        test=ast.Name(element_var, ast.Load()),\n                        body=[\n                            ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True)),\n                            ast.Break()\n                        ],\n                        orelse=[]\n                    )\n                ]\n            \n            # Add the for loop\n            for_loop = ast.For(\n                target=ast.Name(loop_var, ast.Store()),\n                iter=ast.Name(iterable_var, ast.Load()),\n                body=loop_body,\n                orelse=[]\n            )\n            self.statements.append(for_loop)\n            \n            # Create explanation\n            expl = \"%s(%s)\" % (func_name, iterable_expl)\n            res_expl = self.explanation_param(self.display(ast.Name(result_var, ast.Load())))\n            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n            \n            return ast.Name(result_var, ast.Load()), outer_expl\n        \n        # Original generic function call handling\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        new_star = new_kwarg = None\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            new_args.append(res)\n            arg_expls.append(expl)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            arg_expls.append(keyword.arg + \"=\" + expl)\n        if call.starargs:\n            new_star, expl = self.visit(call.starargs)\n            arg_expls.append(\"*\" + expl)\n        if call.kwargs:\n            new_kwarg, expl = self.visit(call.kwargs)\n            arg_expls.append(\"**\" + expl)\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/pytest/src/_pytest/assertion/rewrite.py lines 967-992)": [
      "\ndef visit_Call_35(self, call):\n    \"\"\"\n    visit `ast.Call` nodes on Python3.5 and after\n    \"\"\"\n    # Special handling for all() and any() calls\n    if (isinstance(call.func, ast.Name) and \n        call.func.id in (\"all\", \"any\") and \n        len(call.args) == 1):\n        \n        func_name = call.func.id\n        iterable_arg = call.args[0]\n        \n        # Check if the iterable is a simple list/tuple literal that we can unroll\n        if isinstance(iterable_arg, (ast.List, ast.Tuple)):\n            # Create a temporary variable to hold the result\n            result_var = self.variable()\n            \n            # Generate explanations for each element\n            element_expls = []\n            element_tests = []\n            \n            for i, element in enumerate(iterable_arg.elts):\n                element_res, element_expl = self.visit(element)\n                element_var = self.assign(element_res)\n                element_expls.append(element_expl)\n                element_tests.append(element_var)\n            \n            # Create the explanation showing individual elements\n            elements_str = \", \".join(element_expls)\n            expl = \"%s([%s])\" % (func_name, elements_str)\n            \n            # Generate the actual test based on function type\n            if func_name == \"all\":\n                # For all(), we want to show which element failed\n                test_expr = ast.BoolOp(ast.And(), element_tests)\n            else:  # any()\n                # For any(), we want to show all elements were False\n                test_expr = ast.BoolOp(ast.Or(), element_tests)\n            \n            res = self.assign(test_expr)\n            res_expl = self.explanation_param(self.display(res))\n            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n            return res, outer_expl\n    \n    # Default handling for all other function calls\n    new_func, func_expl = self.visit(call.func)\n    arg_expls = []\n    new_args = []\n    new_kwargs = []\n    for arg in call.args:\n        res, expl = self.visit(arg)\n        arg_expls.append(expl)\n        new_args.append(res)\n    for keyword in call.keywords:\n        res, expl = self.visit(keyword.value)\n        new_kwargs.append(ast.keyword(keyword.arg, res))\n        if keyword.arg:\n            arg_expls.append(keyword.arg + \"=\" + expl)\n        else:  # **args have `arg` keywords with an .arg of None\n            arg_expls.append(\"**\" + expl)\n\n    expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n    new_call = ast.Call(new_func, new_args, new_kwargs)\n    res = self.assign(new_call)\n    res_expl = self.explanation_param(self.display(res))\n    outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n    return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() calls\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in (\"all\", \"any\") and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Handle list/tuple literals specially for better unrolling\n            if isinstance(iterable_arg, (ast.List, ast.Tuple)):\n                elements = iterable_arg.elts\n                if elements:\n                    # Create individual checks for each element\n                    element_checks = []\n                    element_expls = []\n                    \n                    for i, element in enumerate(elements):\n                        elem_res, elem_expl = self.visit(element)\n                        element_checks.append(elem_res)\n                        element_expls.append(elem_expl)\n                    \n                    # Generate explanation showing which element failed\n                    if func_name == \"all\":\n                        # For all(), we want to show the first False element\n                        explanation = \"all([%s])\" % \", \".join(element_expls)\n                    else:  # any()\n                        # For any(), we want to show all False elements\n                        explanation = \"any([%s])\" % \", \".join(element_expls)\n                    \n                    # Create the actual call with visited elements\n                    new_iterable = ast.List(element_checks, iterable_arg.ctx) if isinstance(iterable_arg, ast.List) else ast.Tuple(element_checks, iterable_arg.ctx)\n                    new_call = ast.Call(call.func, [new_iterable], [])\n                    res = self.assign(new_call)\n                    res_expl = self.explanation_param(self.display(res))\n                    outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, explanation)\n                    return res, outer_expl\n        \n        # Default handling for all other calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() calls\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in (\"all\", \"any\") and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Visit the iterable argument\n            iterable_res, iterable_expl = self.visit(iterable_arg)\n            \n            # Create a temporary variable for the iterable\n            iterable_var = self.assign(iterable_res)\n            \n            # Generate explanation showing individual elements\n            temp_var = self.variable()\n            explanation_parts = []\n            \n            # Create loop to check each element\n            loop_var = self.variable()\n            element_var = self.variable()\n            \n            # Build the unrolled explanation\n            if func_name == \"all\":\n                check_explanation = \"where not %s\" % self.display(element_var)\n                overall_expl = \"all(%s)\" % iterable_expl\n            else:  # any\n                check_explanation = \"where %s\" % self.display(element_var)  \n                overall_expl = \"any(%s)\" % iterable_expl\n            \n            # Create the call normally for the result\n            new_call = ast.Call(call.func, [iterable_var], [])\n            res = self.assign(new_call)\n            \n            # Generate detailed explanation\n            res_expl = self.explanation_param(self.display(res))\n            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, overall_expl)\n            \n            return res, outer_expl\n        \n        # Original generic call handling\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() calls to provide better error messages\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in (\"all\", \"any\") and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Visit the iterable argument\n            iterable_res, iterable_expl = self.visit(iterable_arg)\n            \n            # Create a temporary variable to hold the iterable\n            iterable_var = self.variable()\n            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_res))\n            \n            # Create a result variable\n            result_var = self.variable()\n            \n            # Create the unrolled logic\n            if func_name == \"all\":\n                # For all(), we need to check each element and stop on first False\n                self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True)))\n                \n                # Create a loop variable\n                item_var = self.variable()\n                \n                # Create the for loop\n                loop_body = []\n                \n                # Check if item is falsy\n                item_res = ast.Name(item_var, ast.Load())\n                item_expl = self.display(item_res)\n                \n                # If item is falsy, set result to False and break\n                test = ast.UnaryOp(ast.Not(), item_res)\n                loop_body.append(ast.If(\n                    test,\n                    [ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False)),\n                     ast.Break()],\n                    []\n                ))\n                \n                for_loop = ast.For(\n                    target=ast.Name(item_var, ast.Store()),\n                    iter=ast.Name(iterable_var, ast.Load()),\n                    body=loop_body,\n                    orelse=[]\n                )\n                self.statements.append(for_loop)\n                \n            else:  # func_name == \"any\"\n                # For any(), we need to check each element and stop on first True\n                self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False)))\n                \n                # Create a loop variable\n                item_var = self.variable()\n                \n                # Create the for loop\n                loop_body = []\n                \n                # Check if item is truthy\n                item_res = ast.Name(item_var, ast.Load())\n                item_expl = self.display(item_res)\n                \n                # If item is truthy, set result to True and break\n                loop_body.append(ast.If(\n                    item_res,\n                    [ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True)),\n                     ast.Break()],\n                    []\n                ))\n                \n                for_loop = ast.For(\n                    target=ast.Name(item_var, ast.Store()),\n                    iter=ast.Name(iterable_var, ast.Load()),\n                    body=loop_body,\n                    orelse=[]\n                )\n                self.statements.append(for_loop)\n            \n            # Return the result\n            result_name = ast.Name(result_var, ast.Load())\n            expl = \"%s(%s)\" % (func_name, iterable_expl)\n            return result_name, expl\n        \n        # Default handling for other function calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() calls\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in (\"all\", \"any\") and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Visit the iterable argument\n            iterable_expr, iterable_expl = self.visit(iterable_arg)\n            \n            # Create a temporary variable for the iterable\n            iterable_var = self.assign(iterable_expr)\n            \n            # Generate explanation showing each element evaluation\n            explanation_parts = []\n            \n            # Create a loop variable name\n            loop_var = self.variable()\n            \n            # For all(), we want to show the first False element\n            # For any(), we want to show all False elements until we find True\n            if func_name == \"all\":\n                # Generate code that finds the first False element\n                explanation = \"all(%s)\" % iterable_expl\n                res_var = self.variable()\n                \n                # Create the actual all() call for the result\n                new_call = ast.Call(call.func, [iterable_var], [])\n                res = self.assign(new_call)\n                \n                # Create detailed explanation\n                res_expl = self.explanation_param(self.display(res))\n                outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, explanation)\n                \n            else:  # any()\n                # Generate code that shows evaluation of elements\n                explanation = \"any(%s)\" % iterable_expl\n                res_var = self.variable()\n                \n                # Create the actual any() call for the result\n                new_call = ast.Call(call.func, [iterable_var], [])\n                res = self.assign(new_call)\n                \n                # Create detailed explanation\n                res_expl = self.explanation_param(self.display(res))\n                outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, explanation)\n            \n            return res, outer_expl\n        \n        # Original generic call handling\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() calls\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in (\"all\", \"any\") and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Visit the iterable argument\n            iterable_expr, iterable_expl = self.visit(iterable_arg)\n            \n            # Create a temporary variable to store the iterable\n            iter_var = self.variable()\n            self.statements.append(ast.Assign([ast.Name(iter_var, ast.Store())], iterable_expr))\n            \n            # Create a result variable\n            result_var = self.variable()\n            \n            # Generate code to iterate and check each element\n            loop_var = self.variable()\n            element_var = self.variable()\n            \n            # Create the loop body that checks each element\n            if func_name == \"all\":\n                # For all(): if any element is falsy, set result to False and break\n                test_condition = ast.UnaryOp(ast.Not(), ast.Name(element_var, ast.Load()))\n                result_value = ast.NameConstant(False)\n            else:  # any()\n                # For any(): if any element is truthy, set result to True and break\n                test_condition = ast.Name(element_var, ast.Load())\n                result_value = ast.NameConstant(True)\n            \n            # Initialize result variable\n            initial_value = ast.NameConstant(True) if func_name == \"all\" else ast.NameConstant(False)\n            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], initial_value))\n            \n            # Create the for loop with break on condition\n            loop_body = [\n                ast.Assign([ast.Name(element_var, ast.Store())], ast.Name(loop_var, ast.Load())),\n                ast.If(\n                    test_condition,\n                    [\n                        ast.Assign([ast.Name(result_var, ast.Store())], result_value),\n                        ast.Break()\n                    ],\n                    []\n                )\n            ]\n            \n            for_loop = ast.For(\n                target=ast.Name(loop_var, ast.Store()),\n                iter=ast.Name(iter_var, ast.Load()),\n                body=loop_body,\n                orelse=[]\n            )\n            \n            self.statements.append(for_loop)\n            \n            # Generate explanation\n            expl = \"%s(%s)\" % (func_name, iterable_expl)\n            res_expl = self.explanation_param(self.display(ast.Name(result_var, ast.Load())))\n            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n            \n            return ast.Name(result_var, ast.Load()), outer_expl\n        \n        # Original generic function call handling\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() calls to provide better error messages\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in (\"all\", \"any\") and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Visit the iterable argument\n            iterable_res, iterable_expl = self.visit(iterable_arg)\n            \n            # Create a temporary variable to hold the iterable\n            iterable_var = self.variable()\n            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_res))\n            \n            # Create a loop variable\n            item_var = self.variable()\n            \n            # Create explanation for the overall call\n            call_expl = \"%s(%s)\" % (func_name, iterable_expl)\n            \n            # For all(): check each item is truthy, fail on first falsy\n            # For any(): check each item is truthy, succeed on first truthy\n            if func_name == \"all\":\n                # Generate: for item in iterable: if not item: return False\n                loop_body = []\n                item_res, item_expl = self.visit(ast.Name(item_var, ast.Load()))\n                not_item = ast.UnaryOp(ast.Not(), item_res)\n                not_item_res = self.assign(not_item)\n                \n                # Create explanation for the failing item\n                explanation = \"assert %s\" % (item_expl,)\n                template = ast.Str(explanation)\n                msg = self.helper(\"_format_explanation\", template)\n                \n                # If not item, raise assertion error with explanation\n                raise_stmt = ast.Raise(\n                    ast.Call(\n                        ast.Name(\"AssertionError\", ast.Load()),\n                        [msg], []\n                    ), None\n                )\n                \n                condition = ast.If(not_item_res, [raise_stmt], [])\n                loop_body.append(condition)\n                \n                # Create the for loop\n                loop = ast.For(\n                    ast.Name(item_var, ast.Store()),\n                    ast.Name(iterable_var, ast.Load()),\n                    loop_body,\n                    []\n                )\n                self.statements.append(loop)\n                \n                # If we get here, all items were truthy\n                result = self.assign(ast.NameConstant(True))\n                \n            else:  # func_name == \"any\"\n                # Generate: for item in iterable: if item: return True\n                loop_body = []\n                item_res, item_expl = self.visit(ast.Name(item_var, ast.Load()))\n                \n                # If item is truthy, return True\n                return_stmt = ast.Return(ast.NameConstant(True))\n                condition = ast.If(item_res, [return_stmt], [])\n                loop_body.append(condition)\n                \n                # Create the for loop\n                loop = ast.For(\n                    ast.Name(item_var, ast.Store()),\n                    ast.Name(iterable_var, ast.Load()),\n                    loop_body,\n                    []\n                )\n                self.statements.append(loop)\n                \n                # If we get here, no items were truthy - create failure explanation\n                explanation = \"assert %s\\n{%s = %s\\n}\" % (call_expl, call_expl, call_expl)\n                template = ast.Str(explanation)\n                msg = self.helper(\"_format_explanation\", template)\n                \n                raise_stmt = ast.Raise(\n                    ast.Call(\n                        ast.Name(\"AssertionError\", ast.Load()),\n                        [msg], []\n                    ), None\n                )\n                self.statements.append(raise_stmt)\n                \n                # This won't be reached, but needed for AST structure\n                result = self.assign(ast.NameConstant(False))\n            \n            return result, call_expl\n        \n        # Original generic function call handling\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        # Special handling for all() and any() calls\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in (\"all\", \"any\") and \n            len(call.args) == 1):\n            \n            # Get the iterable argument\n            iterable_arg = call.args[0]\n            iterable_expr, iterable_expl = self.visit(iterable_arg)\n            \n            # Create a temporary variable for the iterable\n            iterable_var = self.assign(iterable_expr)\n            \n            # Generate code to iterate and check each element\n            if call.func.id == \"all\":\n                # For all(): check each element is truthy\n                element_var = self.variable()\n                element_check = ast.IfTest(\n                    test=ast.UnaryOp(op=ast.Not(), operand=ast.Name(id=element_var, ctx=ast.Load())),\n                    msg=ast.Str(s=\"assert {element}\")\n                )\n                loop_code = ast.For(\n                    target=ast.Name(id=element_var, ctx=ast.Store()),\n                    iter=ast.Name(id=iterable_var, ctx=ast.Load()),\n                    body=[element_check],\n                    orelse=[]\n                )\n            else:  # any()\n                # For any(): check if any element is truthy\n                found_var = self.variable()\n                element_var = self.variable()\n                \n                # Initialize found flag\n                init_found = ast.Assign(\n                    targets=[ast.Name(id=found_var, ctx=ast.Store())],\n                    value=ast.NameConstant(value=False)\n                )\n                \n                # Check each element\n                element_check = ast.If(\n                    test=ast.Name(id=element_var, ctx=ast.Load()),\n                    body=[ast.Assign(\n                        targets=[ast.Name(id=found_var, ctx=ast.Store())],\n                        value=ast.NameConstant(value=True)\n                    )],\n                    orelse=[]\n                )\n                \n                loop_code = ast.For(\n                    target=ast.Name(id=element_var, ctx=ast.Store()),\n                    iter=ast.Name(id=iterable_var, ctx=ast.Load()),\n                    body=[element_check],\n                    orelse=[]\n                )\n            \n            # Create explanation showing which elements were checked\n            expl = \"%s(%s)\" % (call.func.id, iterable_expl)\n            res = self.assign(ast.Call(call.func, [iterable_var], []))\n            res_expl = self.explanation_param(self.display(res))\n            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n            return res, outer_expl\n        \n        # Default handling for other function calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n"
    ],
    "Location 2 (/root/hy/projects_2/pytest/src/_pytest/assertion/rewrite.py lines 1000-1028)": [
      "\n    def visit_Call_legacy(self, call):\n        \"\"\"\n        visit `ast.Call nodes on 3.4 and below`\n        \"\"\"\n        # Special handling for all() and any() calls\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in (\"all\", \"any\") and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Visit the iterable argument\n            new_iterable, iterable_expl = self.visit(iterable_arg)\n            \n            # Create a temporary variable to store the iterable\n            iterable_var = self.variable()\n            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], new_iterable))\n            \n            # Create a result variable\n            result_var = self.variable()\n            \n            # Create the unrolled logic\n            if func_name == \"all\":\n                # For all(): start with True, set to False if any element is falsy\n                self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], ast.Constant(True)))\n                \n                # Create loop to check each element\n                loop_var = self.variable()\n                element_var = self.variable()\n                \n                # for element in iterable:\n                #     if not element:\n                #         result = False\n                #         break\n                loop_body = [\n                    ast.Assign([ast.Name(element_var, ast.Store())], ast.Name(loop_var, ast.Load())),\n                    ast.If(\n                        test=ast.UnaryOp(ast.Not(), ast.Name(element_var, ast.Load())),\n                        body=[\n                            ast.Assign([ast.Name(result_var, ast.Store())], ast.Constant(False)),\n                            ast.Break()\n                        ],\n                        orelse=[]\n                    )\n                ]\n            else:  # any()\n                # For any(): start with False, set to True if any element is truthy\n                self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], ast.Constant(False)))\n                \n                # Create loop to check each element\n                loop_var = self.variable()\n                element_var = self.variable()\n                \n                # for element in iterable:\n                #     if element:\n                #         result = True\n                #         break\n                loop_body = [\n                    ast.Assign([ast.Name(element_var, ast.Store())], ast.Name(loop_var, ast.Load())),\n                    ast.If(\n                        test=ast.Name(element_var, ast.Load()),\n                        body=[\n                            ast.Assign([ast.Name(result_var, ast.Store())], ast.Constant(True)),\n                            ast.Break()\n                        ],\n                        orelse=[]\n                    )\n                ]\n            \n            # Add the for loop\n            for_loop = ast.For(\n                target=ast.Name(loop_var, ast.Store()),\n                iter=ast.Name(iterable_var, ast.Load()),\n                body=loop_body,\n                orelse=[]\n            )\n            self.statements.append(for_loop)\n            \n            # Create explanation\n            expl = \"%s(%s)\" % (func_name, iterable_expl)\n            res_expl = self.explanation_param(self.display(ast.Name(result_var, ast.Load())))\n            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n            \n            return ast.Name(result_var, ast.Load()), outer_expl\n        \n        # Original generic function call handling\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        new_star = new_kwarg = None\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            new_args.append(res)\n            arg_expls.append(expl)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            arg_expls.append(keyword.arg + \"=\" + expl)\n        if call.starargs:\n            new_star, expl = self.visit(call.starargs)\n            arg_expls.append(\"*\" + expl)\n        if call.kwargs:\n            new_kwarg, expl = self.visit(call.kwargs)\n            arg_expls.append(\"**\" + expl)\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_legacy(self, call):\n        \"\"\"\n        visit `ast.Call nodes on 3.4 and below`\n        \"\"\"\n        # Special handling for all() and any() calls\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in (\"all\", \"any\") and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Visit the iterable argument\n            new_iterable, iterable_expl = self.visit(iterable_arg)\n            \n            # Create a temporary variable to store the iterable\n            iterable_var = self.variable()\n            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], new_iterable))\n            \n            # Create a temporary variable for the result\n            result_var = self.variable()\n            \n            # Generate code to iterate and check each element\n            iter_var = self.variable()\n            element_var = self.variable()\n            \n            # Initialize result based on function type\n            init_value = ast.NameConstant(True) if func_name == \"all\" else ast.NameConstant(False)\n            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], init_value))\n            \n            # Create the for loop\n            loop_target = ast.Name(element_var, ast.Store())\n            loop_iter = ast.Name(iterable_var, ast.Load())\n            \n            # Create the loop body\n            element_node = ast.Name(element_var, ast.Load())\n            element_res, element_expl = self.visit(element_node)\n            \n            if func_name == \"all\":\n                # For all(), if any element is False, set result to False and break\n                test = ast.UnaryOp(ast.Not(), element_res)\n                body = [\n                    ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False)),\n                    ast.Break()\n                ]\n            else:  # any()\n                # For any(), if any element is True, set result to True and break\n                test = element_res\n                body = [\n                    ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True)),\n                    ast.Break()\n                ]\n            \n            if_stmt = ast.If(test, body, [])\n            for_loop = ast.For(loop_target, loop_iter, [if_stmt], [])\n            self.statements.append(for_loop)\n            \n            # Return the result\n            result_node = ast.Name(result_var, ast.Load())\n            res = self.assign(result_node)\n            res_expl = self.explanation_param(self.display(res))\n            \n            # Create explanation\n            expl = \"%s(%s)\" % (func_name, iterable_expl)\n            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n            return res, outer_expl\n        \n        # Original logic for other function calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        new_star = new_kwarg = None\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            new_args.append(res)\n            arg_expls.append(expl)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            arg_expls.append(keyword.arg + \"=\" + expl)\n        if call.starargs:\n            new_star, expl = self.visit(call.starargs)\n            arg_expls.append(\"*\" + expl)\n        if call.kwargs:\n            new_kwarg, expl = self.visit(call.kwargs)\n            arg_expls.append(\"**\" + expl)\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\ndef visit_Call_legacy(self, call):\n    \"\"\"\n    visit `ast.Call nodes on 3.4 and below`\n    \"\"\"\n    # Special handling for all() and any() calls\n    if (isinstance(call.func, ast.Name) and \n        call.func.id in (\"all\", \"any\") and \n        len(call.args) == 1):\n        \n        func_name = call.func.id\n        iterable_arg = call.args[0]\n        \n        # Visit the iterable to get its representation\n        iterable_res, iterable_expl = self.visit(iterable_arg)\n        \n        # Create a temporary variable to store the iterable\n        iter_var = self.variable()\n        self.statements.append(ast.Assign([ast.Name(iter_var, ast.Store())], iterable_res))\n        \n        # Create a result variable\n        result_var = self.variable()\n        \n        # Initialize result based on function type\n        if func_name == \"all\":\n            init_value = ast.NameConstant(True)\n        else:  # any\n            init_value = ast.NameConstant(False)\n        \n        self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], init_value))\n        \n        # Create loop variable\n        loop_var = self.variable()\n        \n        # Create the for loop body\n        loop_body = []\n        \n        # Get explanation for the current element\n        elem_res = self.variable()\n        loop_body.append(ast.Assign([ast.Name(elem_res, ast.Store())], ast.Name(loop_var, ast.Load())))\n        \n        # Create condition check\n        if func_name == \"all\":\n            # For all(), if any element is False, set result to False and break\n            condition = ast.UnaryOp(ast.Not(), ast.Name(loop_var, ast.Load()))\n            result_assign = ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False))\n        else:  # any\n            # For any(), if any element is True, set result to True and break\n            condition = ast.Name(loop_var, ast.Load())\n            result_assign = ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True))\n        \n        if_body = [result_assign, ast.Break()]\n        if_stmt = ast.If(condition, if_body, [])\n        loop_body.append(if_stmt)\n        \n        # Create the for loop\n        for_loop = ast.For(\n            target=ast.Name(loop_var, ast.Store()),\n            iter=ast.Name(iter_var, ast.Load()),\n            body=loop_body,\n            orelse=[]\n        )\n        \n        self.statements.append(for_loop)\n        \n        # Return the result\n        res = ast.Name(result_var, ast.Load())\n        res_var = self.assign(res)\n        res_expl = self.explanation_param(self.display(res_var))\n        \n        # Create explanation\n        expl = \"%s(%s)\" % (func_name, iterable_expl)\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        \n        return res_var, outer_expl\n    \n    # Original code for other function calls\n    new_func, func_expl = self.visit(call.func)\n    arg_expls = []\n    new_args = []\n    new_kwargs = []\n    new_star = new_kwarg = None\n    for arg in call.args:\n        res, expl = self.visit(arg)\n        new_args.append(res)\n        arg_expls.append(expl)\n    for keyword in call.keywords:\n        res, expl = self.visit(keyword.value)\n        new_kwargs.append(ast.keyword(keyword.arg, res))\n        arg_expls.append(keyword.arg + \"=\" + expl)\n    if call.starargs:\n        new_star, expl = self.visit(call.starargs)\n        arg_expls.append(\"*\" + expl)\n    if call.kwargs:\n        new_kwarg, expl = self.visit(call.kwargs)\n        arg_expls.append(\"**\" + expl)\n    expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n    new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n    res = self.assign(new_call)\n    res_expl = self.explanation_param(self.display(res))\n    outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n    return res, outer_expl\n",
      "\n    def visit_Call_legacy(self, call):\n        \"\"\"\n        visit `ast.Call nodes on 3.4 and below`\n        \"\"\"\n        # Special handling for all() and any() calls\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in (\"all\", \"any\") and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Visit the iterable argument\n            new_iterable, iterable_expl = self.visit(iterable_arg)\n            \n            # Create a temporary variable to store the iterable\n            iterable_var = self.variable()\n            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], new_iterable))\n            \n            # Create a temporary variable for the result\n            result_var = self.variable()\n            \n            # Create the unrolled logic\n            if func_name == \"all\":\n                # For all(), we need to check each element and fail on the first False\n                loop_var = self.variable()\n                element_var = self.variable()\n                \n                # Create the for loop to check each element\n                for_loop = ast.For(\n                    target=ast.Name(loop_var, ast.Store()),\n                    iter=ast.Name(iterable_var, ast.Load()),\n                    body=[\n                        ast.Assign([ast.Name(element_var, ast.Store())], ast.Name(loop_var, ast.Load())),\n                        ast.If(\n                            test=ast.UnaryOp(ast.Not(), ast.Name(element_var, ast.Load())),\n                            body=[\n                                ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False)),\n                                ast.Break()\n                            ],\n                            orelse=[]\n                        )\n                    ],\n                    orelse=[\n                        ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True))\n                    ]\n                )\n                \n                # Initialize result to True\n                self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True)))\n                self.statements.append(for_loop)\n                \n            else:  # func_name == \"any\"\n                # For any(), we need to check each element and succeed on the first True\n                loop_var = self.variable()\n                element_var = self.variable()\n                \n                # Create the for loop to check each element\n                for_loop = ast.For(\n                    target=ast.Name(loop_var, ast.Store()),\n                    iter=ast.Name(iterable_var, ast.Load()),\n                    body=[\n                        ast.Assign([ast.Name(element_var, ast.Store())], ast.Name(loop_var, ast.Load())),\n                        ast.If(\n                            test=ast.Name(element_var, ast.Load()),\n                            body=[\n                                ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True)),\n                                ast.Break()\n                            ],\n                            orelse=[]\n                        )\n                    ],\n                    orelse=[\n                        ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False))\n                    ]\n                )\n                \n                # Initialize result to False\n                self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False)))\n                self.statements.append(for_loop)\n            \n            # Create explanation\n            res_expl = self.explanation_param(self.display(ast.Name(result_var, ast.Load())))\n            expl = \"%s(%s)\" % (func_name, iterable_expl)\n            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n            \n            return ast.Name(result_var, ast.Load()), outer_expl\n        \n        # Original generic function call handling\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        new_star = new_kwarg = None\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            new_args.append(res)\n            arg_expls.append(expl)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            arg_expls.append(keyword.arg + \"=\" + expl)\n        if call.starargs:\n            new_star, expl = self.visit(call.starargs)\n            arg_expls.append(\"*\" + expl)\n        if call.kwargs:\n            new_kwarg, expl = self.visit(call.kwargs)\n            arg_expls.append(\"**\" + expl)\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_legacy(self, call):\n        \"\"\"\n        visit `ast.Call nodes on 3.4 and below`\n        \"\"\"\n        # Special handling for all() and any() functions\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in (\"all\", \"any\") and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Visit the iterable argument\n            new_iterable, iterable_expl = self.visit(iterable_arg)\n            \n            # Create a temporary variable for the iterable\n            iterable_var = self.variable()\n            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], new_iterable))\n            \n            # Create the result variable\n            result_var = self.variable()\n            \n            # Generate code to iterate and check each element\n            iter_var = self.variable()\n            element_var = self.variable()\n            \n            # Create the for loop to check each element\n            loop_body = []\n            \n            # Visit each element and create assertion-like checks\n            element_check_var = self.variable()\n            element_node = ast.Name(element_var, ast.Load())\n            element_res, element_expl = self.visit(element_node)\n            \n            # For all(): if any element is False, store it and break\n            # For any(): if any element is True, store it and break\n            if func_name == \"all\":\n                # Check if element is falsy\n                test = ast.UnaryOp(ast.Not(), element_res)\n                check_stmt = ast.If(\n                    test,\n                    [ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False)),\n                     ast.Break()],\n                    []\n                )\n            else:  # any()\n                # Check if element is truthy\n                check_stmt = ast.If(\n                    element_res,\n                    [ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True)),\n                     ast.Break()],\n                    []\n                )\n            \n            loop_body.append(check_stmt)\n            \n            # Create the for loop\n            for_loop = ast.For(\n                ast.Name(element_var, ast.Store()),\n                ast.Call(ast.Name(\"iter\", ast.Load()), [ast.Name(iterable_var, ast.Load())], [], None, None),\n                loop_body,\n                []\n            )\n            \n            # Initialize result variable\n            if func_name == \"all\":\n                init_value = ast.NameConstant(True)\n            else:  # any()\n                init_value = ast.NameConstant(False)\n            \n            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], init_value))\n            self.statements.append(for_loop)\n            \n            # Create explanation\n            expl = \"%s(%s)\" % (func_name, iterable_expl)\n            res_expl = self.explanation_param(ast.Name(result_var, ast.Load()))\n            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n            \n            return ast.Name(result_var, ast.Load()), outer_expl\n        \n        # Original generic function call handling\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        new_star = new_kwarg = None\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            new_args.append(res)\n            arg_expls.append(expl)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            arg_expls.append(keyword.arg + \"=\" + expl)\n        if call.starargs:\n            new_star, expl = self.visit(call.starargs)\n            arg_expls.append(\"*\" + expl)\n        if call.kwargs:\n            new_kwarg, expl = self.visit(call.kwargs)\n            arg_expls.append(\"**\" + expl)\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_legacy(self, call):\n        \"\"\"\n        visit `ast.Call nodes on 3.4 and below`\n        \"\"\"\n        # Special handling for all() and any() calls\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in (\"all\", \"any\") and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Visit the iterable argument\n            iterable_res, iterable_expl = self.visit(iterable_arg)\n            \n            # Create a temporary variable for the iterable\n            iterable_var = self.variable()\n            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_res))\n            \n            # Create a result variable\n            result_var = self.variable()\n            \n            # Create the unrolled logic\n            if func_name == \"all\":\n                # For all(): start with True, set to False if any element is falsy\n                self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True)))\n                \n                # Create loop variable\n                loop_var = self.variable()\n                \n                # Create the for loop body\n                loop_body = []\n                \n                # Create condition check\n                cond_var = self.variable()\n                loop_body.append(ast.Assign([ast.Name(cond_var, ast.Store())], ast.Name(loop_var, ast.Load())))\n                \n                # If condition is falsy, set result to False and break\n                if_body = [\n                    ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False)),\n                    ast.Break()\n                ]\n                \n                loop_body.append(ast.If(\n                    ast.UnaryOp(ast.Not(), ast.Name(cond_var, ast.Load())),\n                    if_body,\n                    []\n                ))\n                \n                # Create the for loop\n                for_loop = ast.For(\n                    ast.Name(loop_var, ast.Store()),\n                    ast.Name(iterable_var, ast.Load()),\n                    loop_body,\n                    []\n                )\n                self.statements.append(for_loop)\n                \n            else:  # any()\n                # For any(): start with False, set to True if any element is truthy\n                self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False)))\n                \n                # Create loop variable\n                loop_var = self.variable()\n                \n                # Create the for loop body\n                loop_body = []\n                \n                # Create condition check\n                cond_var = self.variable()\n                loop_body.append(ast.Assign([ast.Name(cond_var, ast.Store())], ast.Name(loop_var, ast.Load())))\n                \n                # If condition is truthy, set result to True and break\n                if_body = [\n                    ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True)),\n                    ast.Break()\n                ]\n                \n                loop_body.append(ast.If(\n                    ast.Name(cond_var, ast.Load()),\n                    if_body,\n                    []\n                ))\n                \n                # Create the for loop\n                for_loop = ast.For(\n                    ast.Name(loop_var, ast.Store()),\n                    ast.Name(iterable_var, ast.Load()),\n                    loop_body,\n                    []\n                )\n                self.statements.append(for_loop)\n            \n            # Create explanation\n            expl = \"%s(%s)\" % (func_name, iterable_expl)\n            res_expl = self.explanation_param(self.display(ast.Name(result_var, ast.Load())))\n            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n            \n            return ast.Name(result_var, ast.Load()), outer_expl\n        \n        # Original logic for other function calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        new_star = new_kwarg = None\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            new_args.append(res)\n            arg_expls.append(expl)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            arg_expls.append(keyword.arg + \"=\" + expl)\n        if call.starargs:\n            new_star, expl = self.visit(call.starargs)\n            arg_expls.append(\"*\" + expl)\n        if call.kwargs:\n            new_kwarg, expl = self.visit(call.kwargs)\n            arg_expls.append(\"**\" + expl)\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_legacy(self, call):\n        \"\"\"\n        visit `ast.Call nodes on 3.4 and below`\n        \"\"\"\n        # Special handling for all() and any() calls\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in (\"all\", \"any\") and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Visit the iterable argument\n            new_iterable, iterable_expl = self.visit(iterable_arg)\n            \n            # Create a temporary variable to store the iterable\n            iterable_var = self.variable()\n            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], new_iterable))\n            \n            # Create a result variable\n            result_var = self.variable()\n            \n            # Create the unrolled logic\n            if func_name == \"all\":\n                # For all(): start with True, set to False if any element is falsy\n                self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True)))\n                \n                # Create loop to check each element\n                loop_var = self.variable()\n                element_var = self.variable()\n                \n                # for element in iterable:\n                #     if not element:\n                #         result = False\n                #         break\n                loop_body = [\n                    ast.Assign([ast.Name(element_var, ast.Store())], ast.Name(loop_var, ast.Load())),\n                    ast.If(\n                        test=ast.UnaryOp(op=ast.Not(), operand=ast.Name(element_var, ast.Load())),\n                        body=[\n                            ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False)),\n                            ast.Break()\n                        ],\n                        orelse=[]\n                    )\n                ]\n            else:  # any()\n                # For any(): start with False, set to True if any element is truthy\n                self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False)))\n                \n                # Create loop to check each element\n                loop_var = self.variable()\n                element_var = self.variable()\n                \n                # for element in iterable:\n                #     if element:\n                #         result = True\n                #         break\n                loop_body = [\n                    ast.Assign([ast.Name(element_var, ast.Store())], ast.Name(loop_var, ast.Load())),\n                    ast.If(\n                        test=ast.Name(element_var, ast.Load()),\n                        body=[\n                            ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True)),\n                            ast.Break()\n                        ],\n                        orelse=[]\n                    )\n                ]\n            \n            for_loop = ast.For(\n                target=ast.Name(loop_var, ast.Store()),\n                iter=ast.Name(iterable_var, ast.Load()),\n                body=loop_body,\n                orelse=[]\n            )\n            self.statements.append(for_loop)\n            \n            # Generate explanation\n            expl = \"%s(%s)\" % (func_name, iterable_expl)\n            res_expl = self.explanation_param(self.display(ast.Name(result_var, ast.Load())))\n            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n            \n            return ast.Name(result_var, ast.Load()), outer_expl\n        \n        # Original generic function call handling\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        new_star = new_kwarg = None\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            new_args.append(res)\n            arg_expls.append(expl)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            arg_expls.append(keyword.arg + \"=\" + expl)\n        if call.starargs:\n            new_star, expl = self.visit(call.starargs)\n            arg_expls.append(\"*\" + expl)\n        if call.kwargs:\n            new_kwarg, expl = self.visit(call.kwargs)\n            arg_expls.append(\"**\" + expl)\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n",
      "\n    def visit_Call_legacy(self, call):\n        \"\"\"\n        visit `ast.Call nodes on 3.4 and below`\n        \"\"\"\n        # Special handling for all() and any() calls\n        if (isinstance(call.func, ast.Name) and \n            call.func.id in (\"all\", \"any\") and \n            len(call.args) == 1):\n            \n            func_name = call.func.id\n            iterable_arg = call.args[0]\n            \n            # Visit the iterable argument\n            iterable_res, iterable_expl = self.visit(iterable_arg)\n            \n            # Create a temporary variable for the iterable\n            iterable_var = self.variable()\n            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_res))\n            \n            # Create result variable\n            result_var = self.variable()\n            \n            # For all(), start with True and AND each element\n            # For any(), start with False and OR each element\n            if func_name == \"all\":\n                init_value = ast.NameConstant(True)\n                # Create a loop that checks each element\n                loop_var = self.variable()\n                element_var = self.variable()\n                \n                # result = True\n                self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], init_value))\n                \n                # for element in iterable:\n                #     if not element:\n                #         result = False\n                #         break\n                loop_body = [\n                    ast.If(\n                        test=ast.UnaryOp(op=ast.Not(), operand=ast.Name(element_var, ast.Load())),\n                        body=[\n                            ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False)),\n                            ast.Break()\n                        ],\n                        orelse=[]\n                    )\n                ]\n                \n                for_loop = ast.For(\n                    target=ast.Name(element_var, ast.Store()),\n                    iter=ast.Name(iterable_var, ast.Load()),\n                    body=loop_body,\n                    orelse=[]\n                )\n                self.statements.append(for_loop)\n                \n            else:  # any()\n                init_value = ast.NameConstant(False)\n                loop_var = self.variable()\n                element_var = self.variable()\n                \n                # result = False\n                self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], init_value))\n                \n                # for element in iterable:\n                #     if element:\n                #         result = True\n                #         break\n                loop_body = [\n                    ast.If(\n                        test=ast.Name(element_var, ast.Load()),\n                        body=[\n                            ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True)),\n                            ast.Break()\n                        ],\n                        orelse=[]\n                    )\n                ]\n                \n                for_loop = ast.For(\n                    target=ast.Name(element_var, ast.Store()),\n                    iter=ast.Name(iterable_var, ast.Load()),\n                    body=loop_body,\n                    orelse=[]\n                )\n                self.statements.append(for_loop)\n            \n            # Create explanation\n            expl = \"%s(%s)\" % (func_name, iterable_expl)\n            res_expl = self.explanation_param(self.display(ast.Name(result_var, ast.Load())))\n            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n            \n            return ast.Name(result_var, ast.Load()), outer_expl\n        \n        # Original implementation for other function calls\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        new_star = new_kwarg = None\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            new_args.append(res)\n            arg_expls.append(expl)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            arg_expls.append(keyword.arg + \"=\" + expl)\n        if call.starargs:\n            new_star, expl = self.visit(call.starargs)\n            arg_expls.append(\"*\" + expl)\n        if call.kwargs:\n            new_kwarg, expl = self.visit(call.kwargs)\n            arg_expls.append(\"**\" + expl)\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2903b8995..75ea12d34 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -964,10 +964,87 @@ warn_explicit(\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return res, explanation\n \n+\n     def visit_Call_35(self, call):\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n+        # Special handling for all() and any() calls to provide better error messages\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in (\"all\", \"any\") and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Visit the iterable argument to get its AST representation\n+            iterable_res, iterable_expl = self.visit(iterable_arg)\n+            \n+            # Create a temporary variable to store the iterable\n+            iterable_var = self.variable()\n+            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_res))\n+            \n+            # Create a loop variable\n+            loop_var = self.variable()\n+            \n+            # Create the result variable\n+            result_var = self.variable()\n+            \n+            # Initialize result based on function type\n+            if func_name == \"all\":\n+                init_value = ast.NameConstant(True)\n+            else:  # any\n+                init_value = ast.NameConstant(False)\n+            \n+            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], init_value))\n+            \n+            # Create the for loop body\n+            loop_body = []\n+            \n+            # Visit the loop variable to create assertion-friendly code\n+            loop_var_node = ast.Name(loop_var, ast.Load())\n+            element_res, element_expl = self.visit(loop_var_node)\n+            \n+            # Create condition check\n+            if func_name == \"all\":\n+                # For all(): if not element, set result to False and break\n+                condition = ast.UnaryOp(ast.Not(), loop_var_node)\n+                loop_body.append(ast.If(\n+                    condition,\n+                    [ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False)),\n+                     ast.Break()],\n+                    []\n+                ))\n+            else:  # any\n+                # For any(): if element, set result to True and break\n+                loop_body.append(ast.If(\n+                    loop_var_node,\n+                    [ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True)),\n+                     ast.Break()],\n+                    []\n+                ))\n+            \n+            # Create the for loop\n+            for_loop = ast.For(\n+                target=ast.Name(loop_var, ast.Store()),\n+                iter=ast.Name(iterable_var, ast.Load()),\n+                body=loop_body,\n+                orelse=[]\n+            )\n+            \n+            self.statements.append(for_loop)\n+            \n+            # Return the result variable\n+            result_node = ast.Name(result_var, ast.Load())\n+            res_expl = self.explanation_param(self.display(result_node))\n+            \n+            # Create explanation showing the unrolled iteration\n+            expl = \"%s(%s)\" % (func_name, iterable_expl)\n+            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+            \n+            return result_node, outer_expl\n+        \n+        # Fall back to generic function call handling\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -997,10 +1074,87 @@ warn_explicit(\n         new_starred = ast.Starred(res, starred.ctx)\n         return new_starred, \"*\" + expl\n \n+\n     def visit_Call_legacy(self, call):\n         \"\"\"\n         visit `ast.Call nodes on 3.4 and below`\n         \"\"\"\n+        # Special handling for all() and any() calls to provide better error messages\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in (\"all\", \"any\") and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Visit the iterable argument to get its AST representation\n+            iterable_res, iterable_expl = self.visit(iterable_arg)\n+            \n+            # Create a temporary variable to store the iterable\n+            iterable_var = self.variable()\n+            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_res))\n+            \n+            # Create a loop variable\n+            loop_var = self.variable()\n+            \n+            # Create the result variable\n+            result_var = self.variable()\n+            \n+            # Initialize result based on function type\n+            if func_name == \"all\":\n+                init_value = ast.NameConstant(True)\n+            else:  # any\n+                init_value = ast.NameConstant(False)\n+            \n+            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], init_value))\n+            \n+            # Create the for loop body\n+            loop_body = []\n+            \n+            # Visit the loop variable to create assertion-friendly code\n+            loop_var_node = ast.Name(loop_var, ast.Load())\n+            element_res, element_expl = self.visit(loop_var_node)\n+            \n+            # Create condition check\n+            if func_name == \"all\":\n+                # For all(): if not element, set result to False and break\n+                condition = ast.UnaryOp(ast.Not(), loop_var_node)\n+                loop_body.append(ast.If(\n+                    condition,\n+                    [ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False)),\n+                     ast.Break()],\n+                    []\n+                ))\n+            else:  # any\n+                # For any(): if element, set result to True and break\n+                loop_body.append(ast.If(\n+                    loop_var_node,\n+                    [ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True)),\n+                     ast.Break()],\n+                    []\n+                ))\n+            \n+            # Create the for loop\n+            for_loop = ast.For(\n+                target=ast.Name(loop_var, ast.Store()),\n+                iter=ast.Name(iterable_var, ast.Load()),\n+                body=loop_body,\n+                orelse=[]\n+            )\n+            \n+            self.statements.append(for_loop)\n+            \n+            # Return the result variable\n+            result_node = ast.Name(result_var, ast.Load())\n+            res_expl = self.explanation_param(self.display(result_node))\n+            \n+            # Create explanation showing the unrolled iteration\n+            expl = \"%s(%s)\" % (func_name, iterable_expl)\n+            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+            \n+            return result_node, outer_expl\n+        \n+        # Fall back to generic function call handling\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n",
    "variant_0": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2903b8995..213f56ad7 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -964,10 +964,85 @@ warn_explicit(\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return res, explanation\n \n+\n     def visit_Call_35(self, call):\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n+        # Special handling for all() and any() calls\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in (\"all\", \"any\") and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Visit the iterable argument\n+            iterable_res, iterable_expl = self.visit(iterable_arg)\n+            \n+            # Create a temporary variable to hold the iterable\n+            iterable_var = self.variable()\n+            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_res))\n+            \n+            # Create a result variable\n+            result_var = self.variable()\n+            \n+            # Initialize result based on function type\n+            if func_name == \"all\":\n+                init_value = ast.NameConstant(True)\n+            else:  # any\n+                init_value = ast.NameConstant(False)\n+            \n+            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], init_value))\n+            \n+            # Create loop variable\n+            loop_var = self.variable()\n+            \n+            # Create the for loop body\n+            loop_body = []\n+            \n+            # Visit the loop variable to get explanation\n+            loop_res = ast.Name(loop_var, ast.Load())\n+            loop_expl = self.display(loop_res)\n+            \n+            # Create condition check\n+            if func_name == \"all\":\n+                # For all(): if not item, set result to False and break\n+                condition = ast.UnaryOp(ast.Not(), ast.Name(loop_var, ast.Load()))\n+                loop_body.append(ast.If(\n+                    condition,\n+                    [ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False)),\n+                     ast.Break()],\n+                    []\n+                ))\n+            else:  # any\n+                # For any(): if item, set result to True and break\n+                condition = ast.Name(loop_var, ast.Load())\n+                loop_body.append(ast.If(\n+                    condition,\n+                    [ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True)),\n+                     ast.Break()],\n+                    []\n+                ))\n+            \n+            # Create the for loop\n+            for_loop = ast.For(\n+                ast.Name(loop_var, ast.Store()),\n+                ast.Name(iterable_var, ast.Load()),\n+                loop_body,\n+                []\n+            )\n+            \n+            self.statements.append(for_loop)\n+            \n+            # Create explanation\n+            expl = \"%s(%s)\" % (func_name, iterable_expl)\n+            res_expl = self.explanation_param(self.display(ast.Name(result_var, ast.Load())))\n+            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+            \n+            return ast.Name(result_var, ast.Load()), outer_expl\n+        \n+        # Original generic function call handling\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -997,10 +1072,94 @@ warn_explicit(\n         new_starred = ast.Starred(res, starred.ctx)\n         return new_starred, \"*\" + expl\n \n+\n     def visit_Call_legacy(self, call):\n         \"\"\"\n         visit `ast.Call nodes on 3.4 and below`\n         \"\"\"\n+        # Special handling for all() and any() calls\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in (\"all\", \"any\") and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Visit the iterable argument\n+            new_iterable, iterable_expl = self.visit(iterable_arg)\n+            \n+            # Create a temporary variable to hold the iterable\n+            iterable_var = self.variable()\n+            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], new_iterable))\n+            \n+            # Create a temporary variable for the result\n+            result_var = self.variable()\n+            \n+            # Create the unrolled logic\n+            if func_name == \"all\":\n+                # For all(): start with True, set to False if any element is falsy\n+                self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True)))\n+                \n+                # Create loop to check each element\n+                loop_var = self.variable()\n+                element_var = self.variable()\n+                \n+                # for element in iterable:\n+                #     if not element:\n+                #         result = False\n+                #         break\n+                loop_body = [\n+                    ast.Assign([ast.Name(element_var, ast.Store())], ast.Name(loop_var, ast.Load())),\n+                    ast.If(\n+                        test=ast.UnaryOp(op=ast.Not(), operand=ast.Name(element_var, ast.Load())),\n+                        body=[\n+                            ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False)),\n+                            ast.Break()\n+                        ],\n+                        orelse=[]\n+                    )\n+                ]\n+            else:  # any()\n+                # For any(): start with False, set to True if any element is truthy\n+                self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False)))\n+                \n+                # Create loop to check each element\n+                loop_var = self.variable()\n+                element_var = self.variable()\n+                \n+                # for element in iterable:\n+                #     if element:\n+                #         result = True\n+                #         break\n+                loop_body = [\n+                    ast.Assign([ast.Name(element_var, ast.Store())], ast.Name(loop_var, ast.Load())),\n+                    ast.If(\n+                        test=ast.Name(element_var, ast.Load()),\n+                        body=[\n+                            ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True)),\n+                            ast.Break()\n+                        ],\n+                        orelse=[]\n+                    )\n+                ]\n+            \n+            # Add the for loop\n+            for_loop = ast.For(\n+                target=ast.Name(loop_var, ast.Store()),\n+                iter=ast.Name(iterable_var, ast.Load()),\n+                body=loop_body,\n+                orelse=[]\n+            )\n+            self.statements.append(for_loop)\n+            \n+            # Create explanation\n+            expl = \"%s(%s)\" % (func_name, iterable_expl)\n+            res_expl = self.explanation_param(self.display(ast.Name(result_var, ast.Load())))\n+            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+            \n+            return ast.Name(result_var, ast.Load()), outer_expl\n+        \n+        # Original generic function call handling\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n",
    "variant_1": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2903b8995..6c0b00f34 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -964,32 +964,74 @@ warn_explicit(\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return res, explanation\n \n-    def visit_Call_35(self, call):\n-        \"\"\"\n-        visit `ast.Call` nodes on Python3.5 and after\n-        \"\"\"\n-        new_func, func_expl = self.visit(call.func)\n-        arg_expls = []\n-        new_args = []\n-        new_kwargs = []\n-        for arg in call.args:\n-            res, expl = self.visit(arg)\n-            arg_expls.append(expl)\n-            new_args.append(res)\n-        for keyword in call.keywords:\n-            res, expl = self.visit(keyword.value)\n-            new_kwargs.append(ast.keyword(keyword.arg, res))\n-            if keyword.arg:\n-                arg_expls.append(keyword.arg + \"=\" + expl)\n-            else:  # **args have `arg` keywords with an .arg of None\n-                arg_expls.append(\"**\" + expl)\n \n-        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n-        new_call = ast.Call(new_func, new_args, new_kwargs)\n-        res = self.assign(new_call)\n-        res_expl = self.explanation_param(self.display(res))\n-        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n-        return res, outer_expl\n+def visit_Call_35(self, call):\n+    \"\"\"\n+    visit `ast.Call` nodes on Python3.5 and after\n+    \"\"\"\n+    # Special handling for all() and any() calls\n+    if (isinstance(call.func, ast.Name) and \n+        call.func.id in (\"all\", \"any\") and \n+        len(call.args) == 1):\n+        \n+        func_name = call.func.id\n+        iterable_arg = call.args[0]\n+        \n+        # Check if the iterable is a simple list/tuple literal that we can unroll\n+        if isinstance(iterable_arg, (ast.List, ast.Tuple)):\n+            # Create a temporary variable to hold the result\n+            result_var = self.variable()\n+            \n+            # Generate explanations for each element\n+            element_expls = []\n+            element_tests = []\n+            \n+            for i, element in enumerate(iterable_arg.elts):\n+                element_res, element_expl = self.visit(element)\n+                element_var = self.assign(element_res)\n+                element_expls.append(element_expl)\n+                element_tests.append(element_var)\n+            \n+            # Create the explanation showing individual elements\n+            elements_str = \", \".join(element_expls)\n+            expl = \"%s([%s])\" % (func_name, elements_str)\n+            \n+            # Generate the actual test based on function type\n+            if func_name == \"all\":\n+                # For all(), we want to show which element failed\n+                test_expr = ast.BoolOp(ast.And(), element_tests)\n+            else:  # any()\n+                # For any(), we want to show all elements were False\n+                test_expr = ast.BoolOp(ast.Or(), element_tests)\n+            \n+            res = self.assign(test_expr)\n+            res_expl = self.explanation_param(self.display(res))\n+            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+            return res, outer_expl\n+    \n+    # Default handling for all other function calls\n+    new_func, func_expl = self.visit(call.func)\n+    arg_expls = []\n+    new_args = []\n+    new_kwargs = []\n+    for arg in call.args:\n+        res, expl = self.visit(arg)\n+        arg_expls.append(expl)\n+        new_args.append(res)\n+    for keyword in call.keywords:\n+        res, expl = self.visit(keyword.value)\n+        new_kwargs.append(ast.keyword(keyword.arg, res))\n+        if keyword.arg:\n+            arg_expls.append(keyword.arg + \"=\" + expl)\n+        else:  # **args have `arg` keywords with an .arg of None\n+            arg_expls.append(\"**\" + expl)\n+\n+    expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n+    new_call = ast.Call(new_func, new_args, new_kwargs)\n+    res = self.assign(new_call)\n+    res_expl = self.explanation_param(self.display(res))\n+    outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+    return res, outer_expl\n \n     def visit_Starred(self, starred):\n         # From Python 3.5, a Starred node can appear in a function call\n@@ -997,10 +1039,94 @@ warn_explicit(\n         new_starred = ast.Starred(res, starred.ctx)\n         return new_starred, \"*\" + expl\n \n+\n     def visit_Call_legacy(self, call):\n         \"\"\"\n         visit `ast.Call nodes on 3.4 and below`\n         \"\"\"\n+        # Special handling for all() and any() calls\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in (\"all\", \"any\") and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Visit the iterable argument\n+            new_iterable, iterable_expl = self.visit(iterable_arg)\n+            \n+            # Create a temporary variable to store the iterable\n+            iterable_var = self.variable()\n+            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], new_iterable))\n+            \n+            # Create a result variable\n+            result_var = self.variable()\n+            \n+            # Create the unrolled logic\n+            if func_name == \"all\":\n+                # For all(): start with True, set to False if any element is falsy\n+                self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], ast.Constant(True)))\n+                \n+                # Create loop to check each element\n+                loop_var = self.variable()\n+                element_var = self.variable()\n+                \n+                # for element in iterable:\n+                #     if not element:\n+                #         result = False\n+                #         break\n+                loop_body = [\n+                    ast.Assign([ast.Name(element_var, ast.Store())], ast.Name(loop_var, ast.Load())),\n+                    ast.If(\n+                        test=ast.UnaryOp(ast.Not(), ast.Name(element_var, ast.Load())),\n+                        body=[\n+                            ast.Assign([ast.Name(result_var, ast.Store())], ast.Constant(False)),\n+                            ast.Break()\n+                        ],\n+                        orelse=[]\n+                    )\n+                ]\n+            else:  # any()\n+                # For any(): start with False, set to True if any element is truthy\n+                self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], ast.Constant(False)))\n+                \n+                # Create loop to check each element\n+                loop_var = self.variable()\n+                element_var = self.variable()\n+                \n+                # for element in iterable:\n+                #     if element:\n+                #         result = True\n+                #         break\n+                loop_body = [\n+                    ast.Assign([ast.Name(element_var, ast.Store())], ast.Name(loop_var, ast.Load())),\n+                    ast.If(\n+                        test=ast.Name(element_var, ast.Load()),\n+                        body=[\n+                            ast.Assign([ast.Name(result_var, ast.Store())], ast.Constant(True)),\n+                            ast.Break()\n+                        ],\n+                        orelse=[]\n+                    )\n+                ]\n+            \n+            # Add the for loop\n+            for_loop = ast.For(\n+                target=ast.Name(loop_var, ast.Store()),\n+                iter=ast.Name(iterable_var, ast.Load()),\n+                body=loop_body,\n+                orelse=[]\n+            )\n+            self.statements.append(for_loop)\n+            \n+            # Create explanation\n+            expl = \"%s(%s)\" % (func_name, iterable_expl)\n+            res_expl = self.explanation_param(self.display(ast.Name(result_var, ast.Load())))\n+            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+            \n+            return ast.Name(result_var, ast.Load()), outer_expl\n+        \n+        # Original generic function call handling\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n",
    "variant_2": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2903b8995..f9cfb887d 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -964,10 +964,49 @@ warn_explicit(\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return res, explanation\n \n+\n     def visit_Call_35(self, call):\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n+        # Special handling for all() and any() calls\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in (\"all\", \"any\") and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Handle list/tuple literals specially for better unrolling\n+            if isinstance(iterable_arg, (ast.List, ast.Tuple)):\n+                elements = iterable_arg.elts\n+                if elements:\n+                    # Create individual checks for each element\n+                    element_checks = []\n+                    element_expls = []\n+                    \n+                    for i, element in enumerate(elements):\n+                        elem_res, elem_expl = self.visit(element)\n+                        element_checks.append(elem_res)\n+                        element_expls.append(elem_expl)\n+                    \n+                    # Generate explanation showing which element failed\n+                    if func_name == \"all\":\n+                        # For all(), we want to show the first False element\n+                        explanation = \"all([%s])\" % \", \".join(element_expls)\n+                    else:  # any()\n+                        # For any(), we want to show all False elements\n+                        explanation = \"any([%s])\" % \", \".join(element_expls)\n+                    \n+                    # Create the actual call with visited elements\n+                    new_iterable = ast.List(element_checks, iterable_arg.ctx) if isinstance(iterable_arg, ast.List) else ast.Tuple(element_checks, iterable_arg.ctx)\n+                    new_call = ast.Call(call.func, [new_iterable], [])\n+                    res = self.assign(new_call)\n+                    res_expl = self.explanation_param(self.display(res))\n+                    outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, explanation)\n+                    return res, outer_expl\n+        \n+        # Default handling for all other calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -997,10 +1036,75 @@ warn_explicit(\n         new_starred = ast.Starred(res, starred.ctx)\n         return new_starred, \"*\" + expl\n \n+\n     def visit_Call_legacy(self, call):\n         \"\"\"\n         visit `ast.Call nodes on 3.4 and below`\n         \"\"\"\n+        # Special handling for all() and any() calls\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in (\"all\", \"any\") and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Visit the iterable argument\n+            new_iterable, iterable_expl = self.visit(iterable_arg)\n+            \n+            # Create a temporary variable to store the iterable\n+            iterable_var = self.variable()\n+            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], new_iterable))\n+            \n+            # Create a temporary variable for the result\n+            result_var = self.variable()\n+            \n+            # Generate code to iterate and check each element\n+            iter_var = self.variable()\n+            element_var = self.variable()\n+            \n+            # Initialize result based on function type\n+            init_value = ast.NameConstant(True) if func_name == \"all\" else ast.NameConstant(False)\n+            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], init_value))\n+            \n+            # Create the for loop\n+            loop_target = ast.Name(element_var, ast.Store())\n+            loop_iter = ast.Name(iterable_var, ast.Load())\n+            \n+            # Create the loop body\n+            element_node = ast.Name(element_var, ast.Load())\n+            element_res, element_expl = self.visit(element_node)\n+            \n+            if func_name == \"all\":\n+                # For all(), if any element is False, set result to False and break\n+                test = ast.UnaryOp(ast.Not(), element_res)\n+                body = [\n+                    ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False)),\n+                    ast.Break()\n+                ]\n+            else:  # any()\n+                # For any(), if any element is True, set result to True and break\n+                test = element_res\n+                body = [\n+                    ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True)),\n+                    ast.Break()\n+                ]\n+            \n+            if_stmt = ast.If(test, body, [])\n+            for_loop = ast.For(loop_target, loop_iter, [if_stmt], [])\n+            self.statements.append(for_loop)\n+            \n+            # Return the result\n+            result_node = ast.Name(result_var, ast.Load())\n+            res = self.assign(result_node)\n+            res_expl = self.explanation_param(self.display(res))\n+            \n+            # Create explanation\n+            expl = \"%s(%s)\" % (func_name, iterable_expl)\n+            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+            return res, outer_expl\n+        \n+        # Original logic for other function calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n",
    "variant_3": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2903b8995..72fcbfa56 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -964,10 +964,52 @@ warn_explicit(\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return res, explanation\n \n+\n     def visit_Call_35(self, call):\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n+        # Special handling for all() and any() calls\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in (\"all\", \"any\") and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Visit the iterable argument\n+            iterable_res, iterable_expl = self.visit(iterable_arg)\n+            \n+            # Create a temporary variable for the iterable\n+            iterable_var = self.assign(iterable_res)\n+            \n+            # Generate explanation showing individual elements\n+            temp_var = self.variable()\n+            explanation_parts = []\n+            \n+            # Create loop to check each element\n+            loop_var = self.variable()\n+            element_var = self.variable()\n+            \n+            # Build the unrolled explanation\n+            if func_name == \"all\":\n+                check_explanation = \"where not %s\" % self.display(element_var)\n+                overall_expl = \"all(%s)\" % iterable_expl\n+            else:  # any\n+                check_explanation = \"where %s\" % self.display(element_var)  \n+                overall_expl = \"any(%s)\" % iterable_expl\n+            \n+            # Create the call normally for the result\n+            new_call = ast.Call(call.func, [iterable_var], [])\n+            res = self.assign(new_call)\n+            \n+            # Generate detailed explanation\n+            res_expl = self.explanation_param(self.display(res))\n+            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, overall_expl)\n+            \n+            return res, outer_expl\n+        \n+        # Original generic call handling\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -997,35 +1039,108 @@ warn_explicit(\n         new_starred = ast.Starred(res, starred.ctx)\n         return new_starred, \"*\" + expl\n \n-    def visit_Call_legacy(self, call):\n-        \"\"\"\n-        visit `ast.Call nodes on 3.4 and below`\n-        \"\"\"\n-        new_func, func_expl = self.visit(call.func)\n-        arg_expls = []\n-        new_args = []\n-        new_kwargs = []\n-        new_star = new_kwarg = None\n-        for arg in call.args:\n-            res, expl = self.visit(arg)\n-            new_args.append(res)\n-            arg_expls.append(expl)\n-        for keyword in call.keywords:\n-            res, expl = self.visit(keyword.value)\n-            new_kwargs.append(ast.keyword(keyword.arg, res))\n-            arg_expls.append(keyword.arg + \"=\" + expl)\n-        if call.starargs:\n-            new_star, expl = self.visit(call.starargs)\n-            arg_expls.append(\"*\" + expl)\n-        if call.kwargs:\n-            new_kwarg, expl = self.visit(call.kwargs)\n-            arg_expls.append(\"**\" + expl)\n-        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n-        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n-        res = self.assign(new_call)\n-        res_expl = self.explanation_param(self.display(res))\n+\n+def visit_Call_legacy(self, call):\n+    \"\"\"\n+    visit `ast.Call nodes on 3.4 and below`\n+    \"\"\"\n+    # Special handling for all() and any() calls\n+    if (isinstance(call.func, ast.Name) and \n+        call.func.id in (\"all\", \"any\") and \n+        len(call.args) == 1):\n+        \n+        func_name = call.func.id\n+        iterable_arg = call.args[0]\n+        \n+        # Visit the iterable to get its representation\n+        iterable_res, iterable_expl = self.visit(iterable_arg)\n+        \n+        # Create a temporary variable to store the iterable\n+        iter_var = self.variable()\n+        self.statements.append(ast.Assign([ast.Name(iter_var, ast.Store())], iterable_res))\n+        \n+        # Create a result variable\n+        result_var = self.variable()\n+        \n+        # Initialize result based on function type\n+        if func_name == \"all\":\n+            init_value = ast.NameConstant(True)\n+        else:  # any\n+            init_value = ast.NameConstant(False)\n+        \n+        self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], init_value))\n+        \n+        # Create loop variable\n+        loop_var = self.variable()\n+        \n+        # Create the for loop body\n+        loop_body = []\n+        \n+        # Get explanation for the current element\n+        elem_res = self.variable()\n+        loop_body.append(ast.Assign([ast.Name(elem_res, ast.Store())], ast.Name(loop_var, ast.Load())))\n+        \n+        # Create condition check\n+        if func_name == \"all\":\n+            # For all(), if any element is False, set result to False and break\n+            condition = ast.UnaryOp(ast.Not(), ast.Name(loop_var, ast.Load()))\n+            result_assign = ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False))\n+        else:  # any\n+            # For any(), if any element is True, set result to True and break\n+            condition = ast.Name(loop_var, ast.Load())\n+            result_assign = ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True))\n+        \n+        if_body = [result_assign, ast.Break()]\n+        if_stmt = ast.If(condition, if_body, [])\n+        loop_body.append(if_stmt)\n+        \n+        # Create the for loop\n+        for_loop = ast.For(\n+            target=ast.Name(loop_var, ast.Store()),\n+            iter=ast.Name(iter_var, ast.Load()),\n+            body=loop_body,\n+            orelse=[]\n+        )\n+        \n+        self.statements.append(for_loop)\n+        \n+        # Return the result\n+        res = ast.Name(result_var, ast.Load())\n+        res_var = self.assign(res)\n+        res_expl = self.explanation_param(self.display(res_var))\n+        \n+        # Create explanation\n+        expl = \"%s(%s)\" % (func_name, iterable_expl)\n         outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n-        return res, outer_expl\n+        \n+        return res_var, outer_expl\n+    \n+    # Original code for other function calls\n+    new_func, func_expl = self.visit(call.func)\n+    arg_expls = []\n+    new_args = []\n+    new_kwargs = []\n+    new_star = new_kwarg = None\n+    for arg in call.args:\n+        res, expl = self.visit(arg)\n+        new_args.append(res)\n+        arg_expls.append(expl)\n+    for keyword in call.keywords:\n+        res, expl = self.visit(keyword.value)\n+        new_kwargs.append(ast.keyword(keyword.arg, res))\n+        arg_expls.append(keyword.arg + \"=\" + expl)\n+    if call.starargs:\n+        new_star, expl = self.visit(call.starargs)\n+        arg_expls.append(\"*\" + expl)\n+    if call.kwargs:\n+        new_kwarg, expl = self.visit(call.kwargs)\n+        arg_expls.append(\"**\" + expl)\n+    expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n+    new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n+    res = self.assign(new_call)\n+    res_expl = self.explanation_param(self.display(res))\n+    outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+    return res, outer_expl\n \n     # ast.Call signature changed on 3.5,\n     # conditionally change  which methods is named\n",
    "variant_4": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2903b8995..4a818f015 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -964,10 +964,97 @@ warn_explicit(\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return res, explanation\n \n+\n     def visit_Call_35(self, call):\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n+        # Special handling for all() and any() calls to provide better error messages\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in (\"all\", \"any\") and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Visit the iterable argument\n+            iterable_res, iterable_expl = self.visit(iterable_arg)\n+            \n+            # Create a temporary variable to hold the iterable\n+            iterable_var = self.variable()\n+            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_res))\n+            \n+            # Create a result variable\n+            result_var = self.variable()\n+            \n+            # Create the unrolled logic\n+            if func_name == \"all\":\n+                # For all(), we need to check each element and stop on first False\n+                self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True)))\n+                \n+                # Create a loop variable\n+                item_var = self.variable()\n+                \n+                # Create the for loop\n+                loop_body = []\n+                \n+                # Check if item is falsy\n+                item_res = ast.Name(item_var, ast.Load())\n+                item_expl = self.display(item_res)\n+                \n+                # If item is falsy, set result to False and break\n+                test = ast.UnaryOp(ast.Not(), item_res)\n+                loop_body.append(ast.If(\n+                    test,\n+                    [ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False)),\n+                     ast.Break()],\n+                    []\n+                ))\n+                \n+                for_loop = ast.For(\n+                    target=ast.Name(item_var, ast.Store()),\n+                    iter=ast.Name(iterable_var, ast.Load()),\n+                    body=loop_body,\n+                    orelse=[]\n+                )\n+                self.statements.append(for_loop)\n+                \n+            else:  # func_name == \"any\"\n+                # For any(), we need to check each element and stop on first True\n+                self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False)))\n+                \n+                # Create a loop variable\n+                item_var = self.variable()\n+                \n+                # Create the for loop\n+                loop_body = []\n+                \n+                # Check if item is truthy\n+                item_res = ast.Name(item_var, ast.Load())\n+                item_expl = self.display(item_res)\n+                \n+                # If item is truthy, set result to True and break\n+                loop_body.append(ast.If(\n+                    item_res,\n+                    [ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True)),\n+                     ast.Break()],\n+                    []\n+                ))\n+                \n+                for_loop = ast.For(\n+                    target=ast.Name(item_var, ast.Store()),\n+                    iter=ast.Name(iterable_var, ast.Load()),\n+                    body=loop_body,\n+                    orelse=[]\n+                )\n+                self.statements.append(for_loop)\n+            \n+            # Return the result\n+            result_name = ast.Name(result_var, ast.Load())\n+            expl = \"%s(%s)\" % (func_name, iterable_expl)\n+            return result_name, expl\n+        \n+        # Default handling for other function calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -997,10 +1084,96 @@ warn_explicit(\n         new_starred = ast.Starred(res, starred.ctx)\n         return new_starred, \"*\" + expl\n \n+\n     def visit_Call_legacy(self, call):\n         \"\"\"\n         visit `ast.Call nodes on 3.4 and below`\n         \"\"\"\n+        # Special handling for all() and any() calls\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in (\"all\", \"any\") and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Visit the iterable argument\n+            new_iterable, iterable_expl = self.visit(iterable_arg)\n+            \n+            # Create a temporary variable to store the iterable\n+            iterable_var = self.variable()\n+            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], new_iterable))\n+            \n+            # Create a temporary variable for the result\n+            result_var = self.variable()\n+            \n+            # Create the unrolled logic\n+            if func_name == \"all\":\n+                # For all(), we need to check each element and fail on the first False\n+                loop_var = self.variable()\n+                element_var = self.variable()\n+                \n+                # Create the for loop to check each element\n+                for_loop = ast.For(\n+                    target=ast.Name(loop_var, ast.Store()),\n+                    iter=ast.Name(iterable_var, ast.Load()),\n+                    body=[\n+                        ast.Assign([ast.Name(element_var, ast.Store())], ast.Name(loop_var, ast.Load())),\n+                        ast.If(\n+                            test=ast.UnaryOp(ast.Not(), ast.Name(element_var, ast.Load())),\n+                            body=[\n+                                ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False)),\n+                                ast.Break()\n+                            ],\n+                            orelse=[]\n+                        )\n+                    ],\n+                    orelse=[\n+                        ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True))\n+                    ]\n+                )\n+                \n+                # Initialize result to True\n+                self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True)))\n+                self.statements.append(for_loop)\n+                \n+            else:  # func_name == \"any\"\n+                # For any(), we need to check each element and succeed on the first True\n+                loop_var = self.variable()\n+                element_var = self.variable()\n+                \n+                # Create the for loop to check each element\n+                for_loop = ast.For(\n+                    target=ast.Name(loop_var, ast.Store()),\n+                    iter=ast.Name(iterable_var, ast.Load()),\n+                    body=[\n+                        ast.Assign([ast.Name(element_var, ast.Store())], ast.Name(loop_var, ast.Load())),\n+                        ast.If(\n+                            test=ast.Name(element_var, ast.Load()),\n+                            body=[\n+                                ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True)),\n+                                ast.Break()\n+                            ],\n+                            orelse=[]\n+                        )\n+                    ],\n+                    orelse=[\n+                        ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False))\n+                    ]\n+                )\n+                \n+                # Initialize result to False\n+                self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False)))\n+                self.statements.append(for_loop)\n+            \n+            # Create explanation\n+            res_expl = self.explanation_param(self.display(ast.Name(result_var, ast.Load())))\n+            expl = \"%s(%s)\" % (func_name, iterable_expl)\n+            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+            \n+            return ast.Name(result_var, ast.Load()), outer_expl\n+        \n+        # Original generic function call handling\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n",
    "variant_5": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2903b8995..247dfd5b2 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -964,10 +964,62 @@ warn_explicit(\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return res, explanation\n \n+\n     def visit_Call_35(self, call):\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n+        # Special handling for all() and any() calls\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in (\"all\", \"any\") and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Visit the iterable argument\n+            iterable_expr, iterable_expl = self.visit(iterable_arg)\n+            \n+            # Create a temporary variable for the iterable\n+            iterable_var = self.assign(iterable_expr)\n+            \n+            # Generate explanation showing each element evaluation\n+            explanation_parts = []\n+            \n+            # Create a loop variable name\n+            loop_var = self.variable()\n+            \n+            # For all(), we want to show the first False element\n+            # For any(), we want to show all False elements until we find True\n+            if func_name == \"all\":\n+                # Generate code that finds the first False element\n+                explanation = \"all(%s)\" % iterable_expl\n+                res_var = self.variable()\n+                \n+                # Create the actual all() call for the result\n+                new_call = ast.Call(call.func, [iterable_var], [])\n+                res = self.assign(new_call)\n+                \n+                # Create detailed explanation\n+                res_expl = self.explanation_param(self.display(res))\n+                outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, explanation)\n+                \n+            else:  # any()\n+                # Generate code that shows evaluation of elements\n+                explanation = \"any(%s)\" % iterable_expl\n+                res_var = self.variable()\n+                \n+                # Create the actual any() call for the result\n+                new_call = ast.Call(call.func, [iterable_var], [])\n+                res = self.assign(new_call)\n+                \n+                # Create detailed explanation\n+                res_expl = self.explanation_param(self.display(res))\n+                outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, explanation)\n+            \n+            return res, outer_expl\n+        \n+        # Original generic call handling\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -997,10 +1049,88 @@ warn_explicit(\n         new_starred = ast.Starred(res, starred.ctx)\n         return new_starred, \"*\" + expl\n \n+\n     def visit_Call_legacy(self, call):\n         \"\"\"\n         visit `ast.Call nodes on 3.4 and below`\n         \"\"\"\n+        # Special handling for all() and any() functions\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in (\"all\", \"any\") and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Visit the iterable argument\n+            new_iterable, iterable_expl = self.visit(iterable_arg)\n+            \n+            # Create a temporary variable for the iterable\n+            iterable_var = self.variable()\n+            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], new_iterable))\n+            \n+            # Create the result variable\n+            result_var = self.variable()\n+            \n+            # Generate code to iterate and check each element\n+            iter_var = self.variable()\n+            element_var = self.variable()\n+            \n+            # Create the for loop to check each element\n+            loop_body = []\n+            \n+            # Visit each element and create assertion-like checks\n+            element_check_var = self.variable()\n+            element_node = ast.Name(element_var, ast.Load())\n+            element_res, element_expl = self.visit(element_node)\n+            \n+            # For all(): if any element is False, store it and break\n+            # For any(): if any element is True, store it and break\n+            if func_name == \"all\":\n+                # Check if element is falsy\n+                test = ast.UnaryOp(ast.Not(), element_res)\n+                check_stmt = ast.If(\n+                    test,\n+                    [ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False)),\n+                     ast.Break()],\n+                    []\n+                )\n+            else:  # any()\n+                # Check if element is truthy\n+                check_stmt = ast.If(\n+                    element_res,\n+                    [ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True)),\n+                     ast.Break()],\n+                    []\n+                )\n+            \n+            loop_body.append(check_stmt)\n+            \n+            # Create the for loop\n+            for_loop = ast.For(\n+                ast.Name(element_var, ast.Store()),\n+                ast.Call(ast.Name(\"iter\", ast.Load()), [ast.Name(iterable_var, ast.Load())], [], None, None),\n+                loop_body,\n+                []\n+            )\n+            \n+            # Initialize result variable\n+            if func_name == \"all\":\n+                init_value = ast.NameConstant(True)\n+            else:  # any()\n+                init_value = ast.NameConstant(False)\n+            \n+            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], init_value))\n+            self.statements.append(for_loop)\n+            \n+            # Create explanation\n+            expl = \"%s(%s)\" % (func_name, iterable_expl)\n+            res_expl = self.explanation_param(ast.Name(result_var, ast.Load()))\n+            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+            \n+            return ast.Name(result_var, ast.Load()), outer_expl\n+        \n+        # Original generic function call handling\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n",
    "variant_6": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2903b8995..e37c39e74 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -964,10 +964,77 @@ warn_explicit(\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return res, explanation\n \n+\n     def visit_Call_35(self, call):\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n+        # Special handling for all() and any() calls\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in (\"all\", \"any\") and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Visit the iterable argument\n+            iterable_expr, iterable_expl = self.visit(iterable_arg)\n+            \n+            # Create a temporary variable to store the iterable\n+            iter_var = self.variable()\n+            self.statements.append(ast.Assign([ast.Name(iter_var, ast.Store())], iterable_expr))\n+            \n+            # Create a result variable\n+            result_var = self.variable()\n+            \n+            # Generate code to iterate and check each element\n+            loop_var = self.variable()\n+            element_var = self.variable()\n+            \n+            # Create the loop body that checks each element\n+            if func_name == \"all\":\n+                # For all(): if any element is falsy, set result to False and break\n+                test_condition = ast.UnaryOp(ast.Not(), ast.Name(element_var, ast.Load()))\n+                result_value = ast.NameConstant(False)\n+            else:  # any()\n+                # For any(): if any element is truthy, set result to True and break\n+                test_condition = ast.Name(element_var, ast.Load())\n+                result_value = ast.NameConstant(True)\n+            \n+            # Initialize result variable\n+            initial_value = ast.NameConstant(True) if func_name == \"all\" else ast.NameConstant(False)\n+            self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], initial_value))\n+            \n+            # Create the for loop with break on condition\n+            loop_body = [\n+                ast.Assign([ast.Name(element_var, ast.Store())], ast.Name(loop_var, ast.Load())),\n+                ast.If(\n+                    test_condition,\n+                    [\n+                        ast.Assign([ast.Name(result_var, ast.Store())], result_value),\n+                        ast.Break()\n+                    ],\n+                    []\n+                )\n+            ]\n+            \n+            for_loop = ast.For(\n+                target=ast.Name(loop_var, ast.Store()),\n+                iter=ast.Name(iter_var, ast.Load()),\n+                body=loop_body,\n+                orelse=[]\n+            )\n+            \n+            self.statements.append(for_loop)\n+            \n+            # Generate explanation\n+            expl = \"%s(%s)\" % (func_name, iterable_expl)\n+            res_expl = self.explanation_param(self.display(ast.Name(result_var, ast.Load())))\n+            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+            \n+            return ast.Name(result_var, ast.Load()), outer_expl\n+        \n+        # Original generic function call handling\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -997,10 +1064,108 @@ warn_explicit(\n         new_starred = ast.Starred(res, starred.ctx)\n         return new_starred, \"*\" + expl\n \n+\n     def visit_Call_legacy(self, call):\n         \"\"\"\n         visit `ast.Call nodes on 3.4 and below`\n         \"\"\"\n+        # Special handling for all() and any() calls\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in (\"all\", \"any\") and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Visit the iterable argument\n+            iterable_res, iterable_expl = self.visit(iterable_arg)\n+            \n+            # Create a temporary variable for the iterable\n+            iterable_var = self.variable()\n+            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_res))\n+            \n+            # Create a result variable\n+            result_var = self.variable()\n+            \n+            # Create the unrolled logic\n+            if func_name == \"all\":\n+                # For all(): start with True, set to False if any element is falsy\n+                self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True)))\n+                \n+                # Create loop variable\n+                loop_var = self.variable()\n+                \n+                # Create the for loop body\n+                loop_body = []\n+                \n+                # Create condition check\n+                cond_var = self.variable()\n+                loop_body.append(ast.Assign([ast.Name(cond_var, ast.Store())], ast.Name(loop_var, ast.Load())))\n+                \n+                # If condition is falsy, set result to False and break\n+                if_body = [\n+                    ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False)),\n+                    ast.Break()\n+                ]\n+                \n+                loop_body.append(ast.If(\n+                    ast.UnaryOp(ast.Not(), ast.Name(cond_var, ast.Load())),\n+                    if_body,\n+                    []\n+                ))\n+                \n+                # Create the for loop\n+                for_loop = ast.For(\n+                    ast.Name(loop_var, ast.Store()),\n+                    ast.Name(iterable_var, ast.Load()),\n+                    loop_body,\n+                    []\n+                )\n+                self.statements.append(for_loop)\n+                \n+            else:  # any()\n+                # For any(): start with False, set to True if any element is truthy\n+                self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False)))\n+                \n+                # Create loop variable\n+                loop_var = self.variable()\n+                \n+                # Create the for loop body\n+                loop_body = []\n+                \n+                # Create condition check\n+                cond_var = self.variable()\n+                loop_body.append(ast.Assign([ast.Name(cond_var, ast.Store())], ast.Name(loop_var, ast.Load())))\n+                \n+                # If condition is truthy, set result to True and break\n+                if_body = [\n+                    ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True)),\n+                    ast.Break()\n+                ]\n+                \n+                loop_body.append(ast.If(\n+                    ast.Name(cond_var, ast.Load()),\n+                    if_body,\n+                    []\n+                ))\n+                \n+                # Create the for loop\n+                for_loop = ast.For(\n+                    ast.Name(loop_var, ast.Store()),\n+                    ast.Name(iterable_var, ast.Load()),\n+                    loop_body,\n+                    []\n+                )\n+                self.statements.append(for_loop)\n+            \n+            # Create explanation\n+            expl = \"%s(%s)\" % (func_name, iterable_expl)\n+            res_expl = self.explanation_param(self.display(ast.Name(result_var, ast.Load())))\n+            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+            \n+            return ast.Name(result_var, ast.Load()), outer_expl\n+        \n+        # Original logic for other function calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n",
    "variant_7": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2903b8995..a4f0487ab 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -964,10 +964,107 @@ warn_explicit(\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return res, explanation\n \n+\n     def visit_Call_35(self, call):\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n+        # Special handling for all() and any() calls to provide better error messages\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in (\"all\", \"any\") and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Visit the iterable argument\n+            iterable_res, iterable_expl = self.visit(iterable_arg)\n+            \n+            # Create a temporary variable to hold the iterable\n+            iterable_var = self.variable()\n+            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_res))\n+            \n+            # Create a loop variable\n+            item_var = self.variable()\n+            \n+            # Create explanation for the overall call\n+            call_expl = \"%s(%s)\" % (func_name, iterable_expl)\n+            \n+            # For all(): check each item is truthy, fail on first falsy\n+            # For any(): check each item is truthy, succeed on first truthy\n+            if func_name == \"all\":\n+                # Generate: for item in iterable: if not item: return False\n+                loop_body = []\n+                item_res, item_expl = self.visit(ast.Name(item_var, ast.Load()))\n+                not_item = ast.UnaryOp(ast.Not(), item_res)\n+                not_item_res = self.assign(not_item)\n+                \n+                # Create explanation for the failing item\n+                explanation = \"assert %s\" % (item_expl,)\n+                template = ast.Str(explanation)\n+                msg = self.helper(\"_format_explanation\", template)\n+                \n+                # If not item, raise assertion error with explanation\n+                raise_stmt = ast.Raise(\n+                    ast.Call(\n+                        ast.Name(\"AssertionError\", ast.Load()),\n+                        [msg], []\n+                    ), None\n+                )\n+                \n+                condition = ast.If(not_item_res, [raise_stmt], [])\n+                loop_body.append(condition)\n+                \n+                # Create the for loop\n+                loop = ast.For(\n+                    ast.Name(item_var, ast.Store()),\n+                    ast.Name(iterable_var, ast.Load()),\n+                    loop_body,\n+                    []\n+                )\n+                self.statements.append(loop)\n+                \n+                # If we get here, all items were truthy\n+                result = self.assign(ast.NameConstant(True))\n+                \n+            else:  # func_name == \"any\"\n+                # Generate: for item in iterable: if item: return True\n+                loop_body = []\n+                item_res, item_expl = self.visit(ast.Name(item_var, ast.Load()))\n+                \n+                # If item is truthy, return True\n+                return_stmt = ast.Return(ast.NameConstant(True))\n+                condition = ast.If(item_res, [return_stmt], [])\n+                loop_body.append(condition)\n+                \n+                # Create the for loop\n+                loop = ast.For(\n+                    ast.Name(item_var, ast.Store()),\n+                    ast.Name(iterable_var, ast.Load()),\n+                    loop_body,\n+                    []\n+                )\n+                self.statements.append(loop)\n+                \n+                # If we get here, no items were truthy - create failure explanation\n+                explanation = \"assert %s\\n{%s = %s\\n}\" % (call_expl, call_expl, call_expl)\n+                template = ast.Str(explanation)\n+                msg = self.helper(\"_format_explanation\", template)\n+                \n+                raise_stmt = ast.Raise(\n+                    ast.Call(\n+                        ast.Name(\"AssertionError\", ast.Load()),\n+                        [msg], []\n+                    ), None\n+                )\n+                self.statements.append(raise_stmt)\n+                \n+                # This won't be reached, but needed for AST structure\n+                result = self.assign(ast.NameConstant(False))\n+            \n+            return result, call_expl\n+        \n+        # Original generic function call handling\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -997,10 +1094,93 @@ warn_explicit(\n         new_starred = ast.Starred(res, starred.ctx)\n         return new_starred, \"*\" + expl\n \n+\n     def visit_Call_legacy(self, call):\n         \"\"\"\n         visit `ast.Call nodes on 3.4 and below`\n         \"\"\"\n+        # Special handling for all() and any() calls\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in (\"all\", \"any\") and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Visit the iterable argument\n+            new_iterable, iterable_expl = self.visit(iterable_arg)\n+            \n+            # Create a temporary variable to store the iterable\n+            iterable_var = self.variable()\n+            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], new_iterable))\n+            \n+            # Create a result variable\n+            result_var = self.variable()\n+            \n+            # Create the unrolled logic\n+            if func_name == \"all\":\n+                # For all(): start with True, set to False if any element is falsy\n+                self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True)))\n+                \n+                # Create loop to check each element\n+                loop_var = self.variable()\n+                element_var = self.variable()\n+                \n+                # for element in iterable:\n+                #     if not element:\n+                #         result = False\n+                #         break\n+                loop_body = [\n+                    ast.Assign([ast.Name(element_var, ast.Store())], ast.Name(loop_var, ast.Load())),\n+                    ast.If(\n+                        test=ast.UnaryOp(op=ast.Not(), operand=ast.Name(element_var, ast.Load())),\n+                        body=[\n+                            ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False)),\n+                            ast.Break()\n+                        ],\n+                        orelse=[]\n+                    )\n+                ]\n+            else:  # any()\n+                # For any(): start with False, set to True if any element is truthy\n+                self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False)))\n+                \n+                # Create loop to check each element\n+                loop_var = self.variable()\n+                element_var = self.variable()\n+                \n+                # for element in iterable:\n+                #     if element:\n+                #         result = True\n+                #         break\n+                loop_body = [\n+                    ast.Assign([ast.Name(element_var, ast.Store())], ast.Name(loop_var, ast.Load())),\n+                    ast.If(\n+                        test=ast.Name(element_var, ast.Load()),\n+                        body=[\n+                            ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True)),\n+                            ast.Break()\n+                        ],\n+                        orelse=[]\n+                    )\n+                ]\n+            \n+            for_loop = ast.For(\n+                target=ast.Name(loop_var, ast.Store()),\n+                iter=ast.Name(iterable_var, ast.Load()),\n+                body=loop_body,\n+                orelse=[]\n+            )\n+            self.statements.append(for_loop)\n+            \n+            # Generate explanation\n+            expl = \"%s(%s)\" % (func_name, iterable_expl)\n+            res_expl = self.explanation_param(self.display(ast.Name(result_var, ast.Load())))\n+            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+            \n+            return ast.Name(result_var, ast.Load()), outer_expl\n+        \n+        # Original generic function call handling\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n",
    "variant_8": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 2903b8995..291e3dfa7 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -964,10 +964,73 @@ warn_explicit(\n         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n         return res, explanation\n \n+\n     def visit_Call_35(self, call):\n         \"\"\"\n         visit `ast.Call` nodes on Python3.5 and after\n         \"\"\"\n+        # Special handling for all() and any() calls\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in (\"all\", \"any\") and \n+            len(call.args) == 1):\n+            \n+            # Get the iterable argument\n+            iterable_arg = call.args[0]\n+            iterable_expr, iterable_expl = self.visit(iterable_arg)\n+            \n+            # Create a temporary variable for the iterable\n+            iterable_var = self.assign(iterable_expr)\n+            \n+            # Generate code to iterate and check each element\n+            if call.func.id == \"all\":\n+                # For all(): check each element is truthy\n+                element_var = self.variable()\n+                element_check = ast.IfTest(\n+                    test=ast.UnaryOp(op=ast.Not(), operand=ast.Name(id=element_var, ctx=ast.Load())),\n+                    msg=ast.Str(s=\"assert {element}\")\n+                )\n+                loop_code = ast.For(\n+                    target=ast.Name(id=element_var, ctx=ast.Store()),\n+                    iter=ast.Name(id=iterable_var, ctx=ast.Load()),\n+                    body=[element_check],\n+                    orelse=[]\n+                )\n+            else:  # any()\n+                # For any(): check if any element is truthy\n+                found_var = self.variable()\n+                element_var = self.variable()\n+                \n+                # Initialize found flag\n+                init_found = ast.Assign(\n+                    targets=[ast.Name(id=found_var, ctx=ast.Store())],\n+                    value=ast.NameConstant(value=False)\n+                )\n+                \n+                # Check each element\n+                element_check = ast.If(\n+                    test=ast.Name(id=element_var, ctx=ast.Load()),\n+                    body=[ast.Assign(\n+                        targets=[ast.Name(id=found_var, ctx=ast.Store())],\n+                        value=ast.NameConstant(value=True)\n+                    )],\n+                    orelse=[]\n+                )\n+                \n+                loop_code = ast.For(\n+                    target=ast.Name(id=element_var, ctx=ast.Store()),\n+                    iter=ast.Name(id=iterable_var, ctx=ast.Load()),\n+                    body=[element_check],\n+                    orelse=[]\n+                )\n+            \n+            # Create explanation showing which elements were checked\n+            expl = \"%s(%s)\" % (call.func.id, iterable_expl)\n+            res = self.assign(ast.Call(call.func, [iterable_var], []))\n+            res_expl = self.explanation_param(self.display(res))\n+            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+            return res, outer_expl\n+        \n+        # Default handling for other function calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n@@ -997,10 +1060,102 @@ warn_explicit(\n         new_starred = ast.Starred(res, starred.ctx)\n         return new_starred, \"*\" + expl\n \n+\n     def visit_Call_legacy(self, call):\n         \"\"\"\n         visit `ast.Call nodes on 3.4 and below`\n         \"\"\"\n+        # Special handling for all() and any() calls\n+        if (isinstance(call.func, ast.Name) and \n+            call.func.id in (\"all\", \"any\") and \n+            len(call.args) == 1):\n+            \n+            func_name = call.func.id\n+            iterable_arg = call.args[0]\n+            \n+            # Visit the iterable argument\n+            iterable_res, iterable_expl = self.visit(iterable_arg)\n+            \n+            # Create a temporary variable for the iterable\n+            iterable_var = self.variable()\n+            self.statements.append(ast.Assign([ast.Name(iterable_var, ast.Store())], iterable_res))\n+            \n+            # Create result variable\n+            result_var = self.variable()\n+            \n+            # For all(), start with True and AND each element\n+            # For any(), start with False and OR each element\n+            if func_name == \"all\":\n+                init_value = ast.NameConstant(True)\n+                # Create a loop that checks each element\n+                loop_var = self.variable()\n+                element_var = self.variable()\n+                \n+                # result = True\n+                self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], init_value))\n+                \n+                # for element in iterable:\n+                #     if not element:\n+                #         result = False\n+                #         break\n+                loop_body = [\n+                    ast.If(\n+                        test=ast.UnaryOp(op=ast.Not(), operand=ast.Name(element_var, ast.Load())),\n+                        body=[\n+                            ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(False)),\n+                            ast.Break()\n+                        ],\n+                        orelse=[]\n+                    )\n+                ]\n+                \n+                for_loop = ast.For(\n+                    target=ast.Name(element_var, ast.Store()),\n+                    iter=ast.Name(iterable_var, ast.Load()),\n+                    body=loop_body,\n+                    orelse=[]\n+                )\n+                self.statements.append(for_loop)\n+                \n+            else:  # any()\n+                init_value = ast.NameConstant(False)\n+                loop_var = self.variable()\n+                element_var = self.variable()\n+                \n+                # result = False\n+                self.statements.append(ast.Assign([ast.Name(result_var, ast.Store())], init_value))\n+                \n+                # for element in iterable:\n+                #     if element:\n+                #         result = True\n+                #         break\n+                loop_body = [\n+                    ast.If(\n+                        test=ast.Name(element_var, ast.Load()),\n+                        body=[\n+                            ast.Assign([ast.Name(result_var, ast.Store())], ast.NameConstant(True)),\n+                            ast.Break()\n+                        ],\n+                        orelse=[]\n+                    )\n+                ]\n+                \n+                for_loop = ast.For(\n+                    target=ast.Name(element_var, ast.Store()),\n+                    iter=ast.Name(iterable_var, ast.Load()),\n+                    body=loop_body,\n+                    orelse=[]\n+                )\n+                self.statements.append(for_loop)\n+            \n+            # Create explanation\n+            expl = \"%s(%s)\" % (func_name, iterable_expl)\n+            res_expl = self.explanation_param(self.display(ast.Name(result_var, ast.Load())))\n+            outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n+            \n+            return ast.Name(result_var, ast.Load()), outer_expl\n+        \n+        # Original implementation for other function calls\n         new_func, func_expl = self.visit(call.func)\n         arg_expls = []\n         new_args = []\n"
  }
}