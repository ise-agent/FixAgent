{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/matplotlib/lib/matplotlib/widgets.py lines 529-552)": "\ndef _update(self, event):\n    \"\"\"Update the slider position.\"\"\"\n    if self.ignore(event) or event.button != 1:\n        return\n\n    if event.name == 'button_press_event' and event.inaxes == self.ax:\n        self.drag_active = True\n        event.canvas.grab_mouse(self.ax)\n\n    if not self.drag_active:\n        return\n\n    elif ((event.name == 'button_release_event') or\n          (event.name == 'button_press_event' and\n           event.inaxes != self.ax)):\n        self.drag_active = False\n        event.canvas.release_mouse(self.ax)\n        # Execute any pending callbacks after drag is complete\n        if hasattr(self, '_pending_callback_val'):\n            val = self._pending_callback_val\n            delattr(self, '_pending_callback_val')\n            self.set_val(val)\n        return\n    if self.orientation == 'vertical':\n        val = self._value_in_bounds(event.ydata)\n    else:\n        val = self._value_in_bounds(event.xdata)\n    if val not in [None, self.val]:\n        # Store callback for later execution if drag is active\n        if self.drag_active:\n            self._pending_callback_val = val\n            # Update visual without triggering callbacks\n            self.val = val\n            xy = self.poly.xy\n            if self.orientation == 'vertical':\n                xy[1] = 0, val\n                xy[2] = 1, val\n            else:\n                xy[2] = val, 1\n                xy[3] = val, 0\n            self.poly.xy = xy\n            if self.drawon:\n                self.ax.figure.canvas.draw_idle()\n        else:\n            self.set_val(val)\n",
    "Location 2 (/root/hy/projects_2/matplotlib/lib/matplotlib/widgets.py lines 563-586)": "\ndef set_val(self, val):\n    \"\"\"\n    Set slider value to *val*.\n\n    Parameters\n    ----------\n    val : float\n    \"\"\"\n    xy = self.poly.xy\n    if self.orientation == 'vertical':\n        xy[1] = .25, val\n        xy[2] = .75, val\n        self._handle.set_ydata([val])\n    else:\n        xy[2] = val, .75\n        xy[3] = val, .25\n        self._handle.set_xdata([val])\n    self.poly.xy = xy\n    self.valtext.set_text(self._format(val))\n    if self.drawon:\n        self.ax.figure.canvas.draw_idle()\n    self.val = val\n    if self.eventson:\n        # Defer callback execution if we're in the middle of a drag operation\n        if hasattr(self, '_active') and self._active:\n            # Store the callback for later execution\n            if not hasattr(self, '_pending_callbacks'):\n                self._pending_callbacks = []\n            self._pending_callbacks.append(('changed', val))\n        else:\n            self._observers.process('changed', val)\n",
    "Location 3 (/root/hy/projects_2/matplotlib/lib/matplotlib/widgets.py lines 297-300)": "\n    def _update(self, event):\n        \"\"\"Update the slider position.\"\"\"\n        if self.ignore(event) or event.inaxes != self.ax:\n            return\n\n        if event.name == \"button_press_event\" and event.button != 1:\n            return\n\n        if event.name == \"button_press_event\":\n            self._active_handle = self._get_active_handle(event)\n            if self._active_handle is None:\n                # Outside slider, no handle interaction.\n                return\n            self._pending_callbacks = []\n        elif event.name == \"button_release_event\":\n            if self._active_handle is None:\n                return\n            # Execute any pending callbacks after drag is complete\n            for callback in getattr(self, '_pending_callbacks', []):\n                callback()\n            self._pending_callbacks = []\n            self._active_handle = None\n            return\n\n        # Handle position during drag\n        if self._active_handle is None:\n            return\n\n        # Determine new value(s)\n        if self._active_handle == \"min\":\n            if event.name == \"motion_notify_event\":\n                self._set_min(self._value_in_bounds(event), execute_callbacks=False)\n            else:\n                self._set_min(self._value_in_bounds(event))\n        else:\n            if event.name == \"motion_notify_event\":\n                self._set_max(self._value_in_bounds(event), execute_callbacks=False)\n            else:\n                self._set_max(self._value_in_bounds(event))\n\n    def set_val(self, val):\n        \"\"\"\n        Set slider value to *val*.\n\n        Parameters\n        ----------\n        val : tuple or array-like of length 2\n        \"\"\"\n        val = np.sort(val)\n        _api.check_shape((2,), val=val)\n        vmin, vmax = val\n        vmin = self._value_in_bounds(SimpleNamespace(xdata=vmin))\n        vmax = self._value_in_bounds(SimpleNamespace(xdata=vmax))\n        if (vmin, vmax) != (self.val[0], self.val[1]):\n            self.val = (vmin, vmax)\n            self._update_selection_poly()\n            \n            # Check if we're in the middle of a drag operation\n            if hasattr(self, '_active_handle') and self._active_handle is not None:\n                # Store callback for later execution\n                if not hasattr(self, '_pending_callbacks'):\n                    self._pending_callbacks = []\n                self._pending_callbacks.append(lambda: self._observers.process(\"changed\", self.val))\n            else:\n                # Execute callback immediately if not dragging\n                self._observers.process(\"changed\", self.val)\n\n    def _set_min(self, val, execute_callbacks=True):\n        if val != self.val[0]:\n            self.val = (val, self.val[1])\n            self._update_selection_poly()\n            if execute_callbacks:\n                self._observers.process(\"changed\", self.val)\n\n    def _set_max(self, val, execute_callbacks=True):\n        if val != self.val[1]:\n            self.val = (self.val[0], val)\n            self._update_selection_poly()\n            if execute_callbacks:\n                self._observers.process(\"changed\", self.val)\n",
    "Location 4 (/root/hy/projects_2/matplotlib/lib/matplotlib/widgets.py lines 534-546)": "\n    def _update(self, event):\n        \"\"\"Update the slider position.\"\"\"\n        if self.ignore(event) or event.button != 1:\n            return\n\n        if event.name == 'button_press_event' and event.inaxes == self.ax:\n            self.drag_active = True\n            event.canvas.grab_mouse(self.ax)\n\n        if not self.drag_active:\n            return\n\n        elif ((event.name == 'button_release_event') or\n              (event.name == 'button_press_event' and\n               event.inaxes != self.ax)):\n            self.drag_active = False\n            event.canvas.release_mouse(self.ax)\n            # Execute any pending callbacks after drag is complete\n            if hasattr(self, '_pending_callbacks') and self._pending_callbacks:\n                for callback in self._pending_callbacks:\n                    callback()\n                self._pending_callbacks = []\n            return\n        if self.orientation == 'vertical':\n            val = self._value_in_bounds(event.ydata)\n        else:\n            val = self._value_in_bounds(event.xdata)\n        if val not in [None, self.val]:\n            self.set_val(val)\n",
    "Location 5 (/root/hy/projects_2/matplotlib/lib/matplotlib/widgets.py lines 217-228)": "\n    def _click(self, event):\n        if self.ignore(event) or event.inaxes != self.ax or not self.eventson:\n            return\n        if event.canvas.mouse_grabber != self.ax:\n            event.canvas.grab_mouse(self.ax)\n\n    def _release(self, event):\n        if self.ignore(event) or event.canvas.mouse_grabber != self.ax:\n            return\n        event.canvas.release_mouse(self.ax)\n        if self.eventson and event.inaxes == self.ax:\n            # Store current event connections before callback execution\n            stored_connections = getattr(self, '_stored_connections', None)\n            if stored_connections is None:\n                stored_connections = list(self._observers.callbacks.items())\n            \n            # Execute callback\n            self._observers.process('clicked', event)\n            \n            # Restore connections if they were lost during callback\n            if hasattr(self, 'ax') and self.ax is not None:\n                current_connections = list(self._observers.callbacks.items())\n                if len(current_connections) != len(stored_connections):\n                    # Connections were lost, restore them\n                    for signal, callback_dict in stored_connections:\n                        if signal not in self._observers.callbacks:\n                            self._observers.callbacks[signal] = callback_dict\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/matplotlib/lib/matplotlib/widgets.py lines 529-552)": [
      "\n    def _update(self, event):\n        \"\"\"Update the slider position.\"\"\"\n        if self.ignore(event) or event.button != 1:\n            return\n\n        if event.name == 'button_press_event' and event.inaxes == self.ax:\n            self.drag_active = True\n            event.canvas.grab_mouse(self.ax)\n\n        if not self.drag_active:\n            return\n\n        elif ((event.name == 'button_release_event') or\n              (event.name == 'button_press_event' and\n               event.inaxes != self.ax)):\n            self.drag_active = False\n            event.canvas.release_mouse(self.ax)\n            # Execute any pending callbacks after drag is complete\n            if hasattr(self, '_pending_val') and self._pending_val is not None:\n                self.set_val(self._pending_val)\n                self._pending_val = None\n            return\n        if self.orientation == 'vertical':\n            val = self._value_in_bounds(event.ydata)\n        else:\n            val = self._value_in_bounds(event.xdata)\n        if val not in [None, self.val]:\n            # Store the value for later execution instead of calling set_val immediately\n            self._pending_val = val\n            # Update visual position immediately but defer callbacks\n            self._set_val_without_callbacks(val)\n",
      "\n    def _update(self, event):\n        \"\"\"Update the slider position.\"\"\"\n        if self.ignore(event) or event.button != 1:\n            return\n\n        if event.name == 'button_press_event' and event.inaxes == self.ax:\n            self.drag_active = True\n            event.canvas.grab_mouse(self.ax)\n\n        if not self.drag_active:\n            return\n\n        elif ((event.name == 'button_release_event') or\n              (event.name == 'button_press_event' and\n               event.inaxes != self.ax)):\n            self.drag_active = False\n            event.canvas.release_mouse(self.ax)\n            # Execute any pending callbacks after drag is complete\n            if hasattr(self, '_pending_val') and self._pending_val is not None:\n                pending_val = self._pending_val\n                self._pending_val = None\n                self.set_val(pending_val)\n            return\n        if self.orientation == 'vertical':\n            val = self._value_in_bounds(event.ydata)\n        else:\n            val = self._value_in_bounds(event.xdata)\n        if val not in [None, self.val]:\n            # Store the value instead of calling set_val immediately during drag\n            if self.drag_active:\n                self._pending_val = val\n                # Update visual position without triggering callbacks\n                self.val = val\n                if self.poly is not None:\n                    if self.orientation == 'vertical':\n                        xy = self.poly.xy\n                        xy[1] = 0, val\n                        xy[2] = 1, val\n                    else:\n                        xy = self.poly.xy\n                        xy[2] = val, 1\n                        xy[3] = val, 0\n                if self.hline:\n                    self.hline.set_ydata([val])\n                if self.vline:\n                    self.vline.set_xdata([val])\n                self.valtext.set_text(self._format(val))\n                if self.drawon:\n                    self.ax.figure.canvas.draw_idle()\n            else:\n                self.set_val(val)\n",
      "\n    def _update(self, event):\n        \"\"\"Update the slider position.\"\"\"\n        if self.ignore(event) or event.button != 1:\n            return\n\n        if event.name == 'button_press_event' and event.inaxes == self.ax:\n            self.drag_active = True\n            event.canvas.grab_mouse(self.ax)\n\n        if not self.drag_active:\n            return\n\n        elif ((event.name == 'button_release_event') or\n              (event.name == 'button_press_event' and\n               event.inaxes != self.ax)):\n            self.drag_active = False\n            event.canvas.release_mouse(self.ax)\n            # Execute any pending callbacks after drag is complete\n            if hasattr(self, '_pending_val') and self._pending_val != self.val:\n                self.set_val(self._pending_val)\n                delattr(self, '_pending_val')\n            return\n        if self.orientation == 'vertical':\n            val = self._value_in_bounds(event.ydata)\n        else:\n            val = self._value_in_bounds(event.xdata)\n        if val not in [None, self.val]:\n            # Store the value but don't execute callbacks during drag\n            if self.drag_active:\n                self._pending_val = val\n                # Update visual position without triggering callbacks\n                self._set_val_without_callback(val)\n            else:\n                self.set_val(val)\n",
      "\ndef _update(self, event):\n    \"\"\"Update the slider position.\"\"\"\n    if self.ignore(event) or event.button != 1:\n        return\n\n    if event.name == 'button_press_event' and event.inaxes == self.ax:\n        self.drag_active = True\n        event.canvas.grab_mouse(self.ax)\n\n    if not self.drag_active:\n        return\n\n    elif ((event.name == 'button_release_event') or\n          (event.name == 'button_press_event' and\n           event.inaxes != self.ax)):\n        self.drag_active = False\n        event.canvas.release_mouse(self.ax)\n        # Execute any pending callbacks after drag completion\n        if hasattr(self, '_pending_callbacks') and self._pending_callbacks:\n            for callback in self._pending_callbacks:\n                callback()\n            self._pending_callbacks = []\n        return\n    if self.orientation == 'vertical':\n        val = self._value_in_bounds(event.ydata)\n    else:\n        val = self._value_in_bounds(event.xdata)\n    if val not in [None, self.val]:\n        self.set_val(val)\n",
      "\n    def _update(self, event):\n        \"\"\"Update the slider position.\"\"\"\n        if self.ignore(event) or event.button != 1:\n            return\n\n        if event.name == 'button_press_event' and event.inaxes == self.ax:\n            self.drag_active = True\n            self._pending_callbacks = []\n            event.canvas.grab_mouse(self.ax)\n\n        if not self.drag_active:\n            return\n\n        elif ((event.name == 'button_release_event') or\n              (event.name == 'button_press_event' and\n               event.inaxes != self.ax)):\n            self.drag_active = False\n            event.canvas.release_mouse(self.ax)\n            # Execute any pending callbacks after drag is complete\n            if hasattr(self, '_pending_callbacks'):\n                for callback in self._pending_callbacks:\n                    callback()\n                self._pending_callbacks = []\n            return\n        if self.orientation == 'vertical':\n            val = self._value_in_bounds(event.ydata)\n        else:\n            val = self._value_in_bounds(event.xdata)\n        if val not in [None, self.val]:\n            self.set_val(val, defer_callbacks=True)\n",
      "\n    def _update(self, event):\n        \"\"\"Update the slider position.\"\"\"\n        if self.ignore(event) or event.button != 1:\n            return\n\n        if event.name == 'button_press_event' and event.inaxes == self.ax:\n            self.drag_active = True\n            event.canvas.grab_mouse(self.ax)\n\n        if not self.drag_active:\n            return\n\n        elif ((event.name == 'button_release_event') or\n              (event.name == 'button_press_event' and\n               event.inaxes != self.ax)):\n            self.drag_active = False\n            event.canvas.release_mouse(self.ax)\n            # Execute any pending callbacks after drag is complete\n            if hasattr(self, '_pending_callback_val'):\n                self.set_val(self._pending_callback_val)\n                delattr(self, '_pending_callback_val')\n            return\n        if self.orientation == 'vertical':\n            val = self._value_in_bounds(event.ydata)\n        else:\n            val = self._value_in_bounds(event.xdata)\n        if val not in [None, self.val]:\n            # Store the value for callback execution after drag ends\n            if self.drag_active and hasattr(self, 'drag_active'):\n                self._pending_callback_val = val\n                # Update visual position without triggering callbacks\n                self.val = val\n                xy = self.poly.xy\n                if self.orientation == 'vertical':\n                    xy[1] = 0, val\n                    xy[2] = 1, val\n                else:\n                    xy[2] = val, 1\n                    xy[3] = val, 0\n                self.poly.xy = xy\n                self.valtext.set_text(self._format(val))\n                if self.drawon:\n                    self.ax.figure.canvas.draw_idle()\n            else:\n                self.set_val(val)\n",
      "\ndef _update(self, event):\n    \"\"\"Update the slider position.\"\"\"\n    if self.ignore(event) or event.button != 1:\n        return\n\n    if event.name == 'button_press_event' and event.inaxes == self.ax:\n        self.drag_active = True\n        event.canvas.grab_mouse(self.ax)\n\n    if not self.drag_active:\n        return\n\n    elif ((event.name == 'button_release_event') or\n          (event.name == 'button_press_event' and\n           event.inaxes != self.ax)):\n        self.drag_active = False\n        event.canvas.release_mouse(self.ax)\n        # Execute any pending callbacks after drag is complete\n        if hasattr(self, '_pending_callback_val'):\n            self._call_observers('changed', self._pending_callback_val)\n            delattr(self, '_pending_callback_val')\n        return\n    \n    if self.orientation == 'vertical':\n        val = self._value_in_bounds(event.ydata)\n    else:\n        val = self._value_in_bounds(event.xdata)\n    if val not in [None, self.val]:\n        self.set_val(val, defer_callback=True)\n",
      "\n    def _update(self, event):\n        \"\"\"Update the slider position.\"\"\"\n        if self.ignore(event) or event.button != 1:\n            return\n\n        if event.name == 'button_press_event' and event.inaxes == self.ax:\n            self.drag_active = True\n            event.canvas.grab_mouse(self.ax)\n\n        if not self.drag_active:\n            return\n\n        elif ((event.name == 'button_release_event') or\n              (event.name == 'button_press_event' and\n               event.inaxes != self.ax)):\n            self.drag_active = False\n            event.canvas.release_mouse(self.ax)\n            # Execute any deferred callbacks after drag is complete\n            if hasattr(self, '_deferred_callback_val'):\n                self.set_val(self._deferred_callback_val)\n                delattr(self, '_deferred_callback_val')\n            return\n        if self.orientation == 'vertical':\n            val = self._value_in_bounds(event.ydata)\n        else:\n            val = self._value_in_bounds(event.xdata)\n        if val not in [None, self.val]:\n            # Store the callback for execution after drag is complete\n            if self.drag_active:\n                self._deferred_callback_val = val\n                # Update visual state without triggering callbacks\n                self.val = val\n                if self.drawon:\n                    if self.orientation == 'vertical':\n                        self.poly.set_xy(self._make_vertices(val, self.val))\n                    else:\n                        self.poly.set_xy(self._make_vertices(self.val, val))\n                    if self.drawon:\n                        self.ax.figure.canvas.draw_idle()\n            else:\n                self.set_val(val)\n"
    ],
    "Location 2 (/root/hy/projects_2/matplotlib/lib/matplotlib/widgets.py lines 563-586)": [
      "\n    def set_val(self, val):\n        \"\"\"\n        Set slider value to *val*.\n\n        Parameters\n        ----------\n        val : float\n        \"\"\"\n        xy = self.poly.xy\n        if self.orientation == 'vertical':\n            xy[1] = .25, val\n            xy[2] = .75, val\n            self._handle.set_ydata([val])\n        else:\n            xy[2] = val, .75\n            xy[3] = val, .25\n            self._handle.set_xdata([val])\n        self.poly.xy = xy\n        self.valtext.set_text(self._format(val))\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n        self.val = val\n        if self.eventson:\n            # Defer callback execution if currently dragging to prevent\n            # axes destruction from breaking event connections\n            if hasattr(self, '_active') and self._active:\n                if not hasattr(self, '_pending_callbacks'):\n                    self._pending_callbacks = []\n                self._pending_callbacks.append(('changed', val))\n            else:\n                self._observers.process('changed', val)\n",
      "\n    def set_val(self, val):\n        \"\"\"\n        Set slider value to *val*.\n\n        Parameters\n        ----------\n        val : float\n        \"\"\"\n        xy = self.poly.xy\n        if self.orientation == 'vertical':\n            xy[1] = .25, val\n            xy[2] = .75, val\n            self._handle.set_ydata([val])\n        else:\n            xy[2] = val, .75\n            xy[3] = val, .25\n            self._handle.set_xdata([val])\n        self.poly.xy = xy\n        self.valtext.set_text(self._format(val))\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n        self.val = val\n        if self.eventson:\n            # Check if we're in the middle of a drag operation\n            if hasattr(self, '_active') and self._active:\n                # Store the callback for later execution\n                if not hasattr(self, '_pending_callback'):\n                    self._pending_callback = []\n                self._pending_callback.append(('changed', val))\n            else:\n                self._observers.process('changed', val)\n",
      "\n    def set_val(self, val):\n        \"\"\"\n        Set slider value to *val*.\n\n        Parameters\n        ----------\n        val : float\n        \"\"\"\n        xy = self.poly.xy\n        if self.orientation == 'vertical':\n            xy[1] = .25, val\n            xy[2] = .75, val\n            self._handle.set_ydata([val])\n        else:\n            xy[2] = val, .75\n            xy[3] = val, .25\n            self._handle.set_xdata([val])\n        self.poly.xy = xy\n        self.valtext.set_text(self._format(val))\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n        self.val = val\n        if self.eventson:\n            # Defer callback execution if we're in the middle of a drag operation\n            if hasattr(self, '_active') and self._active:\n                self._pending_callbacks = getattr(self, '_pending_callbacks', [])\n                self._pending_callbacks.append(('changed', val))\n            else:\n                self._observers.process('changed', val)\n",
      "\n    def set_val(self, val):\n        \"\"\"\n        Set slider value to *val*.\n\n        Parameters\n        ----------\n        val : float\n        \"\"\"\n        xy = self.poly.xy\n        if self.orientation == 'vertical':\n            xy[1] = .25, val\n            xy[2] = .75, val\n            self._handle.set_ydata([val])\n        else:\n            xy[2] = val, .75\n            xy[3] = val, .25\n            self._handle.set_xdata([val])\n        self.poly.xy = xy\n        self.valtext.set_text(self._format(val))\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n        self.val = val\n        if self.eventson:\n            # Defer callback execution if we're in the middle of a drag operation\n            if hasattr(self, '_active') and self._active:\n                self._pending_callback_val = val\n            else:\n                self._observers.process('changed', val)\n",
      "\n    def set_val(self, val):\n        \"\"\"\n        Set slider value to *val*.\n\n        Parameters\n        ----------\n        val : float\n        \"\"\"\n        xy = self.poly.xy\n        if self.orientation == 'vertical':\n            xy[1] = .25, val\n            xy[2] = .75, val\n            self._handle.set_ydata([val])\n        else:\n            xy[2] = val, .75\n            xy[3] = val, .25\n            self._handle.set_xdata([val])\n        self.poly.xy = xy\n        self.valtext.set_text(self._format(val))\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n        self.val = val\n        if self.eventson:\n            # Defer callback execution if we're in the middle of a drag operation\n            if hasattr(self, '_dragging') and self._dragging:\n                self._pending_callback = val\n            else:\n                self._observers.process('changed', val)\n",
      "\n    def set_val(self, val):\n        \"\"\"\n        Set slider value to *val*.\n\n        Parameters\n        ----------\n        val : float\n        \"\"\"\n        xy = self.poly.xy\n        if self.orientation == 'vertical':\n            xy[1] = .25, val\n            xy[2] = .75, val\n            self._handle.set_ydata([val])\n        else:\n            xy[2] = val, .75\n            xy[3] = val, .25\n            self._handle.set_xdata([val])\n        self.poly.xy = xy\n        self.valtext.set_text(self._format(val))\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n        self.val = val\n        if self.eventson:\n            # Check if we're in the middle of a drag operation\n            if hasattr(self, '_active') and self._active:\n                # Store callback for later execution to avoid axes destruction during drag\n                if not hasattr(self, '_pending_callbacks'):\n                    self._pending_callbacks = []\n                self._pending_callbacks.append(('changed', val))\n            else:\n                self._observers.process('changed', val)\n",
      "\n    def set_val(self, val):\n        \"\"\"\n        Set slider value to *val*.\n\n        Parameters\n        ----------\n        val : float\n        \"\"\"\n        xy = self.poly.xy\n        if self.orientation == 'vertical':\n            xy[1] = .25, val\n            xy[2] = .75, val\n            self._handle.set_ydata([val])\n        else:\n            xy[2] = val, .75\n            xy[3] = val, .25\n            self._handle.set_xdata([val])\n        self.poly.xy = xy\n        self.valtext.set_text(self._format(val))\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n        self.val = val\n        if self.eventson:\n            # Check if we're in the middle of a drag operation\n            if hasattr(self, '_active') and self._active:\n                # Store callback for later execution\n                if not hasattr(self, '_pending_callback'):\n                    self._pending_callback = None\n                self._pending_callback = val\n            else:\n                # Execute callback immediately if not dragging\n                self._observers.process('changed', val)\n",
      "\ndef set_val(self, val):\n    \"\"\"\n    Set slider value to *val*.\n\n    Parameters\n    ----------\n    val : float\n    \"\"\"\n    xy = self.poly.xy\n    if self.orientation == 'vertical':\n        xy[1] = .25, val\n        xy[2] = .75, val\n        self._handle.set_ydata([val])\n    else:\n        xy[2] = val, .75\n        xy[3] = val, .25\n        self._handle.set_xdata([val])\n    self.poly.xy = xy\n    self.valtext.set_text(self._format(val))\n    if self.drawon:\n        self.ax.figure.canvas.draw_idle()\n    self.val = val\n    if self.eventson:\n        # Check if we're in the middle of a drag operation\n        if hasattr(self, '_active') and self._active:\n            # Store callback for later execution after drag completes\n            if not hasattr(self, '_pending_callback'):\n                self._pending_callback = True\n        else:\n            self._observers.process('changed', val)\n"
    ],
    "Location 3 (/root/hy/projects_2/matplotlib/lib/matplotlib/widgets.py lines 297-300)": [
      "\ndef set_val(self, val):\n    \"\"\"\n    Set slider value to *val*.\n\n    Parameters\n    ----------\n    val : array-like\n        value of the slider\n    \"\"\"\n    val = np.sort(val)\n    _api.check_shape((2,), val=val)\n    val[0] = self._stepped_value(val[0])\n    val[1] = self._stepped_value(val[1])\n    val[0] = np.clip(val[0], self.valmin, self.valmax)\n    val[1] = np.clip(val[1], self.valmin, self.valmax)\n    if np.any(self.val != val):\n        self.val = val\n        self._update_val_from_pos()\n        # Defer callback execution if drag is active to prevent axis destruction\n        if hasattr(self, '_active') and self._active:\n            self._pending_callbacks = True\n        else:\n            self._observers.process(\"changed\", val)\n",
      "\n    def _update(self, event):\n        \"\"\"Update the slider position.\"\"\"\n        if self.ignore(event) or event.inaxes != self.ax:\n            return\n\n        if event.name == 'button_press_event' and event.inaxes == self.ax:\n            self.eventson = True\n            self._active_handle = self._get_active_handle(event)\n            if self._active_handle is None:\n                # Out of bounds\n                return\n            else:\n                self.set_val(self._slice_val(event, self._active_handle))\n        elif event.name == 'motion_notify_event' and self.eventson:\n            if self._active_handle is None:\n                # Shouldn't happen if eventson is True, but be defensive.\n                return\n            else:\n                self.set_val(self._slice_val(event, self._active_handle))\n        elif event.name == 'button_release_event' and self.eventson:\n            self.eventson = False\n            self._active_handle = None\n            # Execute any pending callbacks after drag is complete\n            if hasattr(self, '_pending_callbacks') and self._pending_callbacks:\n                for callback_data in self._pending_callbacks:\n                    callback_data()\n                self._pending_callbacks.clear()\n\n    def set_val(self, val):\n        \"\"\"\n        Set slider value to *val*.\n\n        Parameters\n        ----------\n        val : array-like\n            The slider positions to set.\n        \"\"\"\n        val = np.sort(val)\n        _api.check_shape((2,), val=val)\n        val[0] = self._stepped_value(val[0])\n        val[1] = self._stepped_value(val[1])\n        xy = self.poly.xy\n        if self.orientation == 'vertical':\n            xy[0] = .25, val[0]\n            xy[1] = .25, val[1]\n            xy[2] = .75, val[1]\n            xy[3] = .75, val[0]\n            xy[4] = .25, val[0]\n        else:\n            xy[0] = val[0], .25\n            xy[1] = val[0], .75\n            xy[2] = val[1], .75\n            xy[3] = val[1], .25\n            xy[4] = val[0], .25\n\n        self.poly.xy = xy\n        self.valtext.set_text(self._format(val))\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n        self.val = val\n        \n        # Defer callbacks during active drag operations\n        if hasattr(self, 'eventson') and self.eventson:\n            if not hasattr(self, '_pending_callbacks'):\n                self._pending_callbacks = []\n            self._pending_callbacks.append(lambda: self._observers.process('changed', val))\n        else:\n            self._observers.process('changed', val)\n",
      "\n    def _update(self, event):\n        \"\"\"Update the slider position.\"\"\"\n        if self.ignore(event) or event.inaxes != self.ax:\n            return\n\n        if event.name == \"button_press_event\" and event.button != 1:\n            return\n\n        if event.name == \"button_press_event\":\n            self._active_handle = self._get_active_handle(event)\n            if self._active_handle is None:\n                # Outside slider, no update needed.\n                return\n            self._pending_callbacks = []  # Initialize pending callbacks list\n        elif event.name == \"button_release_event\" or self._active_handle is None:\n            # Execute any pending callbacks after drag completion\n            if hasattr(self, '_pending_callbacks') and self._pending_callbacks:\n                for callback in self._pending_callbacks:\n                    callback()\n                self._pending_callbacks = []\n            self._active_handle = None\n            return\n\n        # continue with existing drag update logic...\n        if self._active_handle:\n            click_location = event.xdata if self.orientation == \"horizontal\" else event.ydata\n            if click_location is not None:\n                new_val = self._value_in_bounds(click_location)\n                if self._active_handle == \"min\":\n                    if new_val <= self.val[1]:\n                        self.val = (new_val, self.val[1])\n                elif self._active_handle == \"max\":\n                    if new_val >= self.val[0]:\n                        self.val = (self.val[0], new_val)\n                else:  # Both handles selected\n                    self.val = (new_val, new_val)\n                \n                # Store callback for later execution instead of immediate execution\n                if hasattr(self, '_pending_callbacks'):\n                    self._pending_callbacks.append(lambda: self._observers.process(\"changed\", self.val))\n                else:\n                    # Fallback for cases where pending callbacks aren't initialized\n                    self._observers.process(\"changed\", self.val)\n\n        self._update_selection_poly()\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n",
      "\n    def _update(self, event):\n        \"\"\"Update the slider position.\"\"\"\n        if self.ignore(event) or event.inaxes != self.ax:\n            return\n\n        if event.name == \"button_press_event\" and event.button != 1:\n            return\n\n        if event.name == \"button_press_event\":\n            self._active_handle = self._get_active_handle(event)\n            if self._active_handle is None:\n                # Outside slider, no handle to move.\n                return\n        elif event.name == \"button_release_event\":\n            if self._active_handle is None:\n                return\n            # Execute any pending callbacks after drag completion\n            if hasattr(self, '_pending_callbacks') and self._pending_callbacks:\n                for callback_data in self._pending_callbacks:\n                    callback_data()\n                self._pending_callbacks = []\n            self._active_handle = None\n            return\n\n        # Determine new value(s)\n        if self._active_handle == \"min\":\n            if event.name == \"motion_notify_event\":\n                self.set_min(self._value_in_bounds(event))\n            else:\n                self.set_min(self._value_in_bounds(event))\n        elif self._active_handle == \"max\":\n            if event.name == \"motion_notify_event\":\n                self.set_max(self._value_in_bounds(event))\n            else:\n                self.set_max(self._value_in_bounds(event))\n",
      "\n    def _update(self, event):\n        \"\"\"Update the slider position.\"\"\"\n        if self.ignore(event) or event.button != 1:\n            return\n\n        if event.name == \"button_press_event\" and event.inaxes == self.ax:\n            self.eventson = True\n            xy = self.ax.transData.inverted().transform((event.x, event.y))\n            self._active_handle = self._handles[np.argmin(\n                np.abs([h.get_xdata()[0] - xy[0] for h in self._handles]))]\n            # Store pending callbacks to execute after drag completion\n            self._pending_callbacks = []\n\n        if not self.eventson:\n            return\n\n        if event.name == \"motion_notify_event\":\n            xy = self.ax.transData.inverted().transform((event.x, event.y))\n            if self._active_handle:\n                # Update position without triggering callbacks during drag\n                if self._active_handle == self._handles[0]:\n                    self._val = (self._stepped_value(xy[0]), self.val[1])\n                else:\n                    self._val = (self.val[0], self._stepped_value(xy[0]))\n                if self.val[0] > self.val[1]:\n                    self._val = self.val[1], self.val[0]\n                self._update_selection_poly()\n                # Store callback for later execution instead of immediate call\n                self._pending_callbacks = [self._observers.process]\n                \n        elif event.name == \"button_release_event\":\n            self.eventson = False\n            self._active_handle = None\n            # Execute any pending callbacks now that drag is complete\n            if hasattr(self, '_pending_callbacks'):\n                for callback in self._pending_callbacks:\n                    try:\n                        callback(\"changed\", self.val)\n                    except Exception:\n                        # Widget may have been destroyed during callback\n                        pass\n                self._pending_callbacks = []\n",
      "\n        self.connect_event(\"button_press_event\", self._update)\n        self.connect_event(\"button_release_event\", self._update)\n        if dragging:\n            self.connect_event(\"motion_notify_event\", self._update)\n        self._observers = cbook.CallbackRegistry(signals=[\"changed\"])\n        self._pending_callbacks = []  # Store callbacks during drag operations\n        self._dragging = False  # Track drag state\n",
      "\ndef _update(self, event):\n    \"\"\"Update the slider position.\"\"\"\n    if self.ignore(event) or event.inaxes != self.ax:\n        return\n\n    if event.name == \"button_press_event\" and event.inaxes == self.ax:\n        self.drag_active = True\n        # Store callbacks to execute after drag completion\n        self._pending_callbacks = []\n\n    val = self._value_in_bounds(event)\n    if not self.drag_active or self.drag_active:\n        if self._active_handle is None:\n            self._active_handle = np.argmin(np.abs([val - self.val[0],\n                                                    val - self.val[1]]))\n        # Avoid recursion by directly updating without triggering callbacks during drag\n        if hasattr(self, 'drag_active') and self.drag_active and event.name != \"button_release_event\":\n            # Store the callback for later execution\n            old_val = self.val\n            self._process_value(val)\n            if not np.array_equal(old_val, self.val):\n                if not hasattr(self, '_pending_callbacks'):\n                    self._pending_callbacks = []\n                self._pending_callbacks.append(lambda: self._observers.process('changed', self.val))\n        else:\n            self.set_val(val)\n\n    if event.name == \"button_release_event\":\n        self.drag_active = False\n        self._active_handle = None\n        # Execute any pending callbacks after drag completion\n        if hasattr(self, '_pending_callbacks'):\n            for callback in self._pending_callbacks:\n                callback()\n            self._pending_callbacks = []\n",
      "\n    def _update(self, event):\n        \"\"\"Update the slider position.\"\"\"\n        if self.ignore(event) or event.inaxes != self.ax:\n            return\n\n        if event.name == \"button_press_event\" and event.inaxes == self.ax:\n            self.eventson = True\n            event.canvas.grab_mouse(self.ax)\n            # Store pending callbacks to execute after drag completion\n            self._pending_callbacks = []\n\n        if not self.eventson:\n            return\n\n        if event.name == \"button_release_event\" or \\\n                (self.closedmax and event.xdata >= self.valmax) or \\\n                (self.closedmin and event.xdata <= self.valmin):\n\n            if not self.dragging:\n                return\n            self.eventson = False\n            event.canvas.release_mouse(self.ax)\n            \n            # Execute any pending callbacks after drag completion\n            if hasattr(self, '_pending_callbacks'):\n                for callback_args in self._pending_callbacks:\n                    try:\n                        self._observers.process(*callback_args)\n                    except Exception:\n                        pass  # Handle callback errors gracefully\n                delattr(self, '_pending_callbacks')\n            return\n\n        if event.inaxes != self.ax:\n            return\n\n        val = self._value_in_bounds(event)\n        if not self.dragging:\n            if np.abs(val - self.val) >= self.valfmt_callback_threshold:\n                # Store callback for later execution during drag\n                if hasattr(self, '_pending_callbacks'):\n                    self._pending_callbacks.append((\"changed\", self.val))\n                else:\n                    self._observers.process(\"changed\", self.val)\n        self.set_val(val, during_drag=True)\n"
    ],
    "Location 4 (/root/hy/projects_2/matplotlib/lib/matplotlib/widgets.py lines 534-546)": [
      "\n    def _update(self, event):\n        \"\"\"Update the slider position.\"\"\"\n        if self.ignore(event) or event.button != 1:\n            return\n\n        if event.name == 'button_press_event' and event.inaxes == self.ax:\n            self.drag_active = True\n            event.canvas.grab_mouse(self.ax)\n\n        if not self.drag_active:\n            return\n\n        elif ((event.name == 'button_release_event') or\n              (event.name == 'button_press_event' and\n               event.inaxes != self.ax)):\n            self.drag_active = False\n            event.canvas.release_mouse(self.ax)\n            # Execute any pending callbacks after drag completion\n            if hasattr(self, '_pending_callbacks') and self._pending_callbacks:\n                for callback_info in self._pending_callbacks:\n                    callback_info['func'](callback_info['val'])\n                self._pending_callbacks = []\n            return\n        if self.orientation == 'vertical':\n            val = self._value_in_bounds(event.ydata)\n        else:\n            val = self._value_in_bounds(event.xdata)\n        if val not in [None, self.val]:\n            self.set_val(val)\n",
      "\n    def _update(self, event):\n        \"\"\"Update the slider position.\"\"\"\n        if self.ignore(event) or event.button != 1:\n            return\n\n        if event.name == 'button_press_event' and event.inaxes == self.ax:\n            self.drag_active = True\n            event.canvas.grab_mouse(self.ax)\n\n        if not self.drag_active:\n            return\n\n        elif ((event.name == 'button_release_event') or\n              (event.name == 'button_press_event' and\n               event.inaxes != self.ax)):\n            self.drag_active = False\n            event.canvas.release_mouse(self.ax)\n            # Execute any pending callbacks after drag is complete\n            if hasattr(self, '_pending_callbacks') and self._pending_callbacks:\n                for callback_args in self._pending_callbacks:\n                    self.observers.process(*callback_args)\n                self._pending_callbacks.clear()\n            return\n        if self.orientation == 'vertical':\n            val = self._value_in_bounds(event.ydata)\n        else:\n            val = self._value_in_bounds(event.xdata)\n        if val not in [None, self.val]:\n            self.set_val(val)\n",
      "\n    def _update(self, event):\n        \"\"\"Update the slider position.\"\"\"\n        if self.ignore(event) or event.button != 1:\n            return\n\n        if event.name == 'button_press_event' and event.inaxes == self.ax:\n            self.drag_active = True\n            event.canvas.grab_mouse(self.ax)\n\n        if not self.drag_active:\n            return\n\n        elif ((event.name == 'button_release_event') or\n              (event.name == 'button_press_event' and\n               event.inaxes != self.ax)):\n            self.drag_active = False\n            event.canvas.release_mouse(self.ax)\n            # Execute any pending callbacks after drag completion\n            if hasattr(self, '_pending_callback') and self._pending_callback:\n                self._pending_callback()\n                self._pending_callback = None\n            return\n        if self.orientation == 'vertical':\n            val = self._value_in_bounds(event.ydata)\n        else:\n            val = self._value_in_bounds(event.xdata)\n        if val not in [None, self.val]:\n            self.set_val(val, defer_callback=True)\n",
      "\n    def _update(self, event):\n        \"\"\"Update the slider position.\"\"\"\n        if self.ignore(event) or event.button != 1:\n            return\n\n        if event.name == 'button_press_event' and event.inaxes == self.ax:\n            self.drag_active = True\n            event.canvas.grab_mouse(self.ax)\n\n        if not self.drag_active:\n            return\n\n        elif ((event.name == 'button_release_event') or\n              (event.name == 'button_press_event' and\n               event.inaxes != self.ax)):\n            self.drag_active = False\n            event.canvas.release_mouse(self.ax)\n            # Execute any pending callbacks after drag completion\n            if hasattr(self, '_pending_callbacks') and self._pending_callbacks:\n                for callback_args in self._pending_callbacks:\n                    try:\n                        self.observers.process(*callback_args)\n                    except Exception:\n                        # Silently ignore callback errors to prevent widget breakage\n                        pass\n                self._pending_callbacks.clear()\n            return\n        if self.orientation == 'vertical':\n            val = self._value_in_bounds(event.ydata)\n        else:\n            val = self._value_in_bounds(event.xdata)\n        if val not in [None, self.val]:\n            self.set_val(val)\n",
      "\ndef _update(self, event):\n    \"\"\"Update the slider position.\"\"\"\n    if self.ignore(event) or event.button != 1:\n        return\n\n    if event.name == 'button_press_event' and event.inaxes == self.ax:\n        self.drag_active = True\n        event.canvas.grab_mouse(self.ax)\n\n    if not self.drag_active:\n        return\n\n    elif ((event.name == 'button_release_event') or\n          (event.name == 'button_press_event' and\n           event.inaxes != self.ax)):\n        self.drag_active = False\n        event.canvas.release_mouse(self.ax)\n        # Execute any pending callbacks after drag completion\n        if hasattr(self, '_pending_callback_val'):\n            pending_val = self._pending_callback_val\n            del self._pending_callback_val\n            self._call_observers(pending_val)\n        return\n    \n    if self.orientation == 'vertical':\n        val = self._value_in_bounds(event.ydata)\n    else:\n        val = self._value_in_bounds(event.xdata)\n    if val not in [None, self.val]:\n        # Store the value for callback execution after drag completion\n        self._pending_callback_val = val\n        # Update the slider position immediately but defer callbacks\n        self._set_val_without_callback(val)\n",
      "\n    def _update(self, event):\n        \"\"\"Update the slider position.\"\"\"\n        if self.ignore(event) or event.button != 1:\n            return\n\n        if event.name == 'button_press_event' and event.inaxes == self.ax:\n            self.drag_active = True\n            event.canvas.grab_mouse(self.ax)\n\n        if not self.drag_active:\n            return\n\n        elif ((event.name == 'button_release_event') or\n              (event.name == 'button_press_event' and\n               event.inaxes != self.ax)):\n            self.drag_active = False\n            event.canvas.release_mouse(self.ax)\n            # Execute any pending callbacks after drag is complete\n            if hasattr(self, '_pending_callbacks') and self._pending_callbacks:\n                for callback_args in self._pending_callbacks:\n                    self.observers.process(*callback_args)\n                self._pending_callbacks = []\n            return\n        if self.orientation == 'vertical':\n            val = self._value_in_bounds(event.ydata)\n        else:\n            val = self._value_in_bounds(event.xdata)\n        if val not in [None, self.val]:\n            self.set_val(val)\n",
      "\n    def _update(self, event):\n        \"\"\"Update the slider position.\"\"\"\n        if self.ignore(event) or event.button != 1:\n            return\n\n        if event.name == 'button_press_event' and event.inaxes == self.ax:\n            self.drag_active = True\n            event.canvas.grab_mouse(self.ax)\n\n        if not self.drag_active:\n            return\n\n        elif ((event.name == 'button_release_event') or\n              (event.name == 'button_press_event' and\n               event.inaxes != self.ax)):\n            self.drag_active = False\n            event.canvas.release_mouse(self.ax)\n            # Execute any pending callbacks after drag completion\n            if hasattr(self, '_pending_callback_val') and self._pending_callback_val is not None:\n                self._call_observers(self._pending_callback_val)\n                self._pending_callback_val = None\n            return\n        if self.orientation == 'vertical':\n            val = self._value_in_bounds(event.ydata)\n        else:\n            val = self._value_in_bounds(event.xdata)\n        if val not in [None, self.val]:\n            self.set_val(val)\n",
      "\ndef _update(self, event):\n    \"\"\"Update the slider position.\"\"\"\n    if self.ignore(event) or event.button != 1:\n        return\n\n    if event.name == 'button_press_event' and event.inaxes == self.ax:\n        self.drag_active = True\n        event.canvas.grab_mouse(self.ax)\n\n    if not self.drag_active:\n        return\n\n    elif ((event.name == 'button_release_event') or\n          (event.name == 'button_press_event' and\n           event.inaxes != self.ax)):\n        self.drag_active = False\n        event.canvas.release_mouse(self.ax)\n        # Execute any pending callbacks after drag completion\n        if hasattr(self, '_pending_callbacks') and self._pending_callbacks:\n            for callback_val in self._pending_callbacks:\n                self.observers.process('changed', callback_val)\n            self._pending_callbacks = []\n        return\n    \n    if self.orientation == 'vertical':\n        val = self._value_in_bounds(event.ydata)\n    else:\n        val = self._value_in_bounds(event.xdata)\n    if val not in [None, self.val]:\n        # Store the callback for later execution instead of immediate execution\n        if not hasattr(self, '_pending_callbacks'):\n            self._pending_callbacks = []\n        self._pending_callbacks.append(val)\n        # Update the visual state immediately but defer callbacks\n        self._set_val_without_callback(val)\n"
    ],
    "Location 5 (/root/hy/projects_2/matplotlib/lib/matplotlib/widgets.py lines 217-228)": [
      "\ndef _click(self, event):\n    if self.ignore(event) or event.inaxes != self.ax or not self.eventson:\n        return\n    if event.canvas.mouse_grabber != self.ax:\n        event.canvas.grab_mouse(self.ax)\n\ndef _release(self, event):\n    if self.ignore(event) or event.canvas.mouse_grabber != self.ax:\n        return\n    event.canvas.release_mouse(self.ax)\n    if self.eventson and event.inaxes == self.ax:\n        # Store current axes state before processing callbacks\n        current_ax = self.ax\n        current_canvas = event.canvas\n        \n        # Process the clicked event\n        self._observers.process('clicked', event)\n        \n        # Check if axes/canvas still exist and are valid after callback\n        if (hasattr(self, 'ax') and self.ax is not None and \n            self.ax.figure is not None and \n            self.ax.figure.canvas is not None):\n            # Axes survived callback execution, continue normally\n            pass\n        else:\n            # Axes were destroyed, need to handle gracefully\n            self.ax = None\n",
      "\ndef _click(self, event):\n    if self.ignore(event) or event.inaxes != self.ax or not self.eventson:\n        return\n    if event.canvas.mouse_grabber != self.ax:\n        event.canvas.grab_mouse(self.ax)\n\ndef _release(self, event):\n    if self.ignore(event) or event.canvas.mouse_grabber != self.ax:\n        return\n    event.canvas.release_mouse(self.ax)\n    if self.eventson and event.inaxes == self.ax:\n        # Store current event connection state before processing callbacks\n        was_connected = hasattr(self, '_event_cids') and self._event_cids\n        self._observers.process('clicked', event)\n        # If axes were destroyed during callback, reconnect events\n        if was_connected and (not hasattr(self, '_event_cids') or not self._event_cids):\n            self._reconnect_events()\n",
      "\n    def _click(self, event):\n        if self.ignore(event) or event.inaxes != self.ax or not self.eventson:\n            return\n        if event.canvas.mouse_grabber != self.ax:\n            event.canvas.grab_mouse(self.ax)\n\n    def _release(self, event):\n        if self.ignore(event) or event.canvas.mouse_grabber != self.ax:\n            return\n        event.canvas.release_mouse(self.ax)\n        if self.eventson and event.inaxes == self.ax:\n            # Store the event for deferred callback execution\n            self._pending_callback_event = event\n            # Use after_idle to defer callback execution until after all events are processed\n            if hasattr(event.canvas, 'get_tk_widget'):\n                # Tkinter backend\n                event.canvas.get_tk_widget().after_idle(self._execute_pending_callback)\n            else:\n                # Other backends - execute immediately as fallback\n                self._observers.process('clicked', event)\n\n    def _execute_pending_callback(self):\n        \"\"\"Execute any pending callback after event processing is complete.\"\"\"\n        if hasattr(self, '_pending_callback_event'):\n            event = self._pending_callback_event\n            delattr(self, '_pending_callback_event')\n            self._observers.process('clicked', event)\n",
      "\n    def _click(self, event):\n        if self.ignore(event) or event.inaxes != self.ax or not self.eventson:\n            return\n        if event.canvas.mouse_grabber != self.ax:\n            event.canvas.grab_mouse(self.ax)\n\n    def _release(self, event):\n        if self.ignore(event) or event.canvas.mouse_grabber != self.ax:\n            return\n        event.canvas.release_mouse(self.ax)\n        if self.eventson and event.inaxes == self.ax:\n            # Store current axes and canvas references before callback execution\n            current_ax = self.ax\n            current_canvas = event.canvas\n            self._observers.process('clicked', event)\n            # Verify axes and canvas are still valid after callback\n            if (hasattr(self, 'ax') and self.ax is not None and \n                hasattr(self.ax, 'figure') and self.ax.figure is not None):\n                # Re-establish event connections if they were lost\n                if not hasattr(self, '_cids') or not self._cids:\n                    self.connect_event('button_press_event', self._click)\n                    self.connect_event('button_release_event', self._release)\n                    self.connect_event('motion_notify_event', self._motion)\n",
      "\ndef _click(self, event):\n    if self.ignore(event) or event.inaxes != self.ax or not self.eventson:\n        return\n    if event.canvas.mouse_grabber != self.ax:\n        event.canvas.grab_mouse(self.ax)\n\ndef _release(self, event):\n    if self.ignore(event) or event.canvas.mouse_grabber != self.ax:\n        return\n    event.canvas.release_mouse(self.ax)\n    if self.eventson and event.inaxes == self.ax:\n        # Store callback execution state to prevent interference from axes destruction\n        observers = self._observers\n        # Execute callback after ensuring mouse state is clean\n        observers.process('clicked', event)\n",
      "\n    def _click(self, event):\n        if self.ignore(event) or event.inaxes != self.ax or not self.eventson:\n            return\n        if event.canvas.mouse_grabber != self.ax:\n            event.canvas.grab_mouse(self.ax)\n\n    def _release(self, event):\n        if self.ignore(event) or event.canvas.mouse_grabber != self.ax:\n            return\n        event.canvas.release_mouse(self.ax)\n        if self.eventson and event.inaxes == self.ax:\n            # Defer callback execution to avoid axis destruction during event handling\n            def _deferred_callback():\n                self._observers.process('clicked', event)\n            event.canvas.start_event_loop(timeout=0.001)  # Allow event processing to complete\n            _deferred_callback()\n",
      "\ndef _click(self, event):\n    if self.ignore(event) or event.inaxes != self.ax or not self.eventson:\n        return\n    if event.canvas.mouse_grabber != self.ax:\n        event.canvas.grab_mouse(self.ax)\n\ndef _release(self, event):\n    if self.ignore(event) or event.canvas.mouse_grabber != self.ax:\n        return\n    event.canvas.release_mouse(self.ax)\n    if self.eventson and event.inaxes == self.ax:\n        # Store current state before processing callbacks to handle potential axis destruction\n        ax_ref = self.ax\n        observers_ref = self._observers\n        try:\n            observers_ref.process('clicked', event)\n        except Exception:\n            # If axes were destroyed during callback, silently continue\n            pass\n",
      "\n    def _click(self, event):\n        if self.ignore(event) or event.inaxes != self.ax or not self.eventson:\n            return\n        if event.canvas.mouse_grabber != self.ax:\n            event.canvas.grab_mouse(self.ax)\n\n    def _release(self, event):\n        if self.ignore(event) or event.canvas.mouse_grabber != self.ax:\n            return\n        event.canvas.release_mouse(self.ax)\n        if self.eventson and event.inaxes == self.ax:\n            # Store current axes reference before callback execution\n            current_ax = self.ax\n            self._observers.process('clicked', event)\n            # Re-establish event connections if axes was destroyed and recreated\n            if self.ax != current_ax:\n                self.disconnect_events()\n                self.connect_event('button_press_event', self._click)\n                self.connect_event('button_release_event', self._release)\n                self.connect_event('motion_notify_event', self._motion)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex ebe5da43e2..0d6d1ae433 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -214,6 +214,7 @@ class Button(AxesWidget):\n         self.color = color\n         self.hovercolor = hovercolor\n \n+\n     def _click(self, event):\n         if self.ignore(event) or event.inaxes != self.ax or not self.eventson:\n             return\n@@ -294,6 +295,7 @@ class SliderBase(AxesWidget):\n         ax.set_axis_off()\n         ax.set_navigate(False)\n \n+\n         self.connect_event(\"button_press_event\", self._update)\n         self.connect_event(\"button_release_event\", self._update)\n         if dragging:\n@@ -526,6 +528,7 @@ class Slider(SliderBase):\n             val = self.slidermax.val\n         return val\n \n+\n     def _update(self, event):\n         \"\"\"Update the slider position.\"\"\"\n         if self.ignore(event) or event.button != 1:\n@@ -543,6 +546,11 @@ class Slider(SliderBase):\n                event.inaxes != self.ax)):\n             self.drag_active = False\n             event.canvas.release_mouse(self.ax)\n+            # Execute any pending callbacks after drag is complete\n+            if hasattr(self, '_pending_callback_val') and self._pending_callback_val is not None:\n+                if self.eventson:\n+                    self._observers.process('changed', self._pending_callback_val)\n+                self._pending_callback_val = None\n             return\n         if self.orientation == 'vertical':\n             val = self._value_in_bounds(event.ydata)\n@@ -550,6 +558,9 @@ class Slider(SliderBase):\n             val = self._value_in_bounds(event.xdata)\n         if val not in [None, self.val]:\n             self.set_val(val)\n+            val = self._value_in_bounds(event.xdata)\n+        if val not in [None, self.val]:\n+            self.set_val(val)\n \n     def _format(self, val):\n         \"\"\"Pretty-print *val*.\"\"\"\n@@ -560,6 +571,7 @@ class Slider(SliderBase):\n             # fmt.get_offset is actually the multiplicative factor, if any.\n             return s + self._fmt.get_offset()\n \n+\n     def set_val(self, val):\n         \"\"\"\n         Set slider value to *val*.\n@@ -583,7 +595,11 @@ class Slider(SliderBase):\n             self.ax.figure.canvas.draw_idle()\n         self.val = val\n         if self.eventson:\n-            self._observers.process('changed', val)\n+            # Defer callback execution if drag is active to prevent axes destruction\n+            if hasattr(self, 'drag_active') and self.drag_active:\n+                self._pending_callback_val = val\n+            else:\n+                self._observers.process('changed', val)\n \n     def on_changed(self, func):\n         \"\"\"\n",
    "variant_0": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex ebe5da43e2..ee70649d46 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -214,6 +214,7 @@ class Button(AxesWidget):\n         self.color = color\n         self.hovercolor = hovercolor\n \n+\n     def _click(self, event):\n         if self.ignore(event) or event.inaxes != self.ax or not self.eventson:\n             return\n@@ -225,7 +226,22 @@ class Button(AxesWidget):\n             return\n         event.canvas.release_mouse(self.ax)\n         if self.eventson and event.inaxes == self.ax:\n+            # Store current event connections before callback execution\n+            stored_connections = getattr(self, '_stored_connections', None)\n+            if stored_connections is None:\n+                stored_connections = list(self._observers.callbacks.items())\n+            \n+            # Execute callback\n             self._observers.process('clicked', event)\n+            \n+            # Restore connections if they were lost during callback\n+            if hasattr(self, 'ax') and self.ax is not None:\n+                current_connections = list(self._observers.callbacks.items())\n+                if len(current_connections) != len(stored_connections):\n+                    # Connections were lost, restore them\n+                    for signal, callback_dict in stored_connections:\n+                        if signal not in self._observers.callbacks:\n+                            self._observers.callbacks[signal] = callback_dict\n \n     def _motion(self, event):\n         if self.ignore(event):\n@@ -294,10 +310,87 @@ class SliderBase(AxesWidget):\n         ax.set_axis_off()\n         ax.set_navigate(False)\n \n-        self.connect_event(\"button_press_event\", self._update)\n-        self.connect_event(\"button_release_event\", self._update)\n-        if dragging:\n-            self.connect_event(\"motion_notify_event\", self._update)\n+\n+    def _update(self, event):\n+        \"\"\"Update the slider position.\"\"\"\n+        if self.ignore(event) or event.inaxes != self.ax:\n+            return\n+\n+        if event.name == \"button_press_event\" and event.button != 1:\n+            return\n+\n+        if event.name == \"button_press_event\":\n+            self._active_handle = self._get_active_handle(event)\n+            if self._active_handle is None:\n+                # Outside slider, no handle interaction.\n+                return\n+            self._pending_callbacks = []\n+        elif event.name == \"button_release_event\":\n+            if self._active_handle is None:\n+                return\n+            # Execute any pending callbacks after drag is complete\n+            for callback in getattr(self, '_pending_callbacks', []):\n+                callback()\n+            self._pending_callbacks = []\n+            self._active_handle = None\n+            return\n+\n+        # Handle position during drag\n+        if self._active_handle is None:\n+            return\n+\n+        # Determine new value(s)\n+        if self._active_handle == \"min\":\n+            if event.name == \"motion_notify_event\":\n+                self._set_min(self._value_in_bounds(event), execute_callbacks=False)\n+            else:\n+                self._set_min(self._value_in_bounds(event))\n+        else:\n+            if event.name == \"motion_notify_event\":\n+                self._set_max(self._value_in_bounds(event), execute_callbacks=False)\n+            else:\n+                self._set_max(self._value_in_bounds(event))\n+\n+    def set_val(self, val):\n+        \"\"\"\n+        Set slider value to *val*.\n+\n+        Parameters\n+        ----------\n+        val : tuple or array-like of length 2\n+        \"\"\"\n+        val = np.sort(val)\n+        _api.check_shape((2,), val=val)\n+        vmin, vmax = val\n+        vmin = self._value_in_bounds(SimpleNamespace(xdata=vmin))\n+        vmax = self._value_in_bounds(SimpleNamespace(xdata=vmax))\n+        if (vmin, vmax) != (self.val[0], self.val[1]):\n+            self.val = (vmin, vmax)\n+            self._update_selection_poly()\n+            \n+            # Check if we're in the middle of a drag operation\n+            if hasattr(self, '_active_handle') and self._active_handle is not None:\n+                # Store callback for later execution\n+                if not hasattr(self, '_pending_callbacks'):\n+                    self._pending_callbacks = []\n+                self._pending_callbacks.append(lambda: self._observers.process(\"changed\", self.val))\n+            else:\n+                # Execute callback immediately if not dragging\n+                self._observers.process(\"changed\", self.val)\n+\n+    def _set_min(self, val, execute_callbacks=True):\n+        if val != self.val[0]:\n+            self.val = (val, self.val[1])\n+            self._update_selection_poly()\n+            if execute_callbacks:\n+                self._observers.process(\"changed\", self.val)\n+\n+    def _set_max(self, val, execute_callbacks=True):\n+        if val != self.val[1]:\n+            self.val = (self.val[0], val)\n+            self._update_selection_poly()\n+            if execute_callbacks:\n+                self._observers.process(\"changed\", self.val)\n         self._observers = cbook.CallbackRegistry(signals=[\"changed\"])\n \n     def _stepped_value(self, val):\n@@ -526,23 +619,56 @@ class Slider(SliderBase):\n             val = self.slidermax.val\n         return val\n \n-    def _update(self, event):\n-        \"\"\"Update the slider position.\"\"\"\n-        if self.ignore(event) or event.button != 1:\n-            return\n \n-        if event.name == 'button_press_event' and event.inaxes == self.ax:\n-            self.drag_active = True\n-            event.canvas.grab_mouse(self.ax)\n+def _update(self, event):\n+    \"\"\"Update the slider position.\"\"\"\n+    if self.ignore(event) or event.button != 1:\n+        return\n \n-        if not self.drag_active:\n-            return\n+    if event.name == 'button_press_event' and event.inaxes == self.ax:\n+        self.drag_active = True\n+        event.canvas.grab_mouse(self.ax)\n \n-        elif ((event.name == 'button_release_event') or\n-              (event.name == 'button_press_event' and\n-               event.inaxes != self.ax)):\n-            self.drag_active = False\n-            event.canvas.release_mouse(self.ax)\n+    if not self.drag_active:\n+        return\n+\n+    elif ((event.name == 'button_release_event') or\n+          (event.name == 'button_press_event' and\n+           event.inaxes != self.ax)):\n+        self.drag_active = False\n+        event.canvas.release_mouse(self.ax)\n+        # Execute any pending callbacks after drag is complete\n+        if hasattr(self, '_pending_callback_val'):\n+            val = self._pending_callback_val\n+            delattr(self, '_pending_callback_val')\n+            self.set_val(val)\n+        return\n+    if self.orientation == 'vertical':\n+        val = self._value_in_bounds(event.ydata)\n+    else:\n+        val = self._value_in_bounds(event.xdata)\n+    if val not in [None, self.val]:\n+        # Store callback for later execution if drag is active\n+        if self.drag_active:\n+            self._pending_callback_val = val\n+            # Update visual without triggering callbacks\n+            self.val = val\n+            xy = self.poly.xy\n+            if self.orientation == 'vertical':\n+                xy[1] = 0, val\n+                xy[2] = 1, val\n+            else:\n+                xy[2] = val, 1\n+                xy[3] = val, 0\n+            self.poly.xy = xy\n+            if self.drawon:\n+                self.ax.figure.canvas.draw_idle()\n+        else:\n+            self.set_val(val)\n+            if hasattr(self, '_pending_callbacks') and self._pending_callbacks:\n+                for callback in self._pending_callbacks:\n+                    callback()\n+                self._pending_callbacks = []\n             return\n         if self.orientation == 'vertical':\n             val = self._value_in_bounds(event.ydata)\n@@ -550,6 +676,12 @@ class Slider(SliderBase):\n             val = self._value_in_bounds(event.xdata)\n         if val not in [None, self.val]:\n             self.set_val(val)\n+        if self.orientation == 'vertical':\n+            val = self._value_in_bounds(event.ydata)\n+        else:\n+            val = self._value_in_bounds(event.xdata)\n+        if val not in [None, self.val]:\n+            self.set_val(val)\n \n     def _format(self, val):\n         \"\"\"Pretty-print *val*.\"\"\"\n@@ -560,29 +692,37 @@ class Slider(SliderBase):\n             # fmt.get_offset is actually the multiplicative factor, if any.\n             return s + self._fmt.get_offset()\n \n-    def set_val(self, val):\n-        \"\"\"\n-        Set slider value to *val*.\n \n-        Parameters\n-        ----------\n-        val : float\n-        \"\"\"\n-        xy = self.poly.xy\n-        if self.orientation == 'vertical':\n-            xy[1] = .25, val\n-            xy[2] = .75, val\n-            self._handle.set_ydata([val])\n+def set_val(self, val):\n+    \"\"\"\n+    Set slider value to *val*.\n+\n+    Parameters\n+    ----------\n+    val : float\n+    \"\"\"\n+    xy = self.poly.xy\n+    if self.orientation == 'vertical':\n+        xy[1] = .25, val\n+        xy[2] = .75, val\n+        self._handle.set_ydata([val])\n+    else:\n+        xy[2] = val, .75\n+        xy[3] = val, .25\n+        self._handle.set_xdata([val])\n+    self.poly.xy = xy\n+    self.valtext.set_text(self._format(val))\n+    if self.drawon:\n+        self.ax.figure.canvas.draw_idle()\n+    self.val = val\n+    if self.eventson:\n+        # Defer callback execution if we're in the middle of a drag operation\n+        if hasattr(self, '_active') and self._active:\n+            # Store the callback for later execution\n+            if not hasattr(self, '_pending_callbacks'):\n+                self._pending_callbacks = []\n+            self._pending_callbacks.append(('changed', val))\n         else:\n-            xy[2] = val, .75\n-            xy[3] = val, .25\n-            self._handle.set_xdata([val])\n-        self.poly.xy = xy\n-        self.valtext.set_text(self._format(val))\n-        if self.drawon:\n-            self.ax.figure.canvas.draw_idle()\n-        self.val = val\n-        if self.eventson:\n             self._observers.process('changed', val)\n \n     def on_changed(self, func):\n",
    "variant_1": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex ebe5da43e2..6a662fd77e 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -214,18 +214,34 @@ class Button(AxesWidget):\n         self.color = color\n         self.hovercolor = hovercolor\n \n-    def _click(self, event):\n-        if self.ignore(event) or event.inaxes != self.ax or not self.eventson:\n-            return\n-        if event.canvas.mouse_grabber != self.ax:\n-            event.canvas.grab_mouse(self.ax)\n \n-    def _release(self, event):\n-        if self.ignore(event) or event.canvas.mouse_grabber != self.ax:\n-            return\n-        event.canvas.release_mouse(self.ax)\n-        if self.eventson and event.inaxes == self.ax:\n-            self._observers.process('clicked', event)\n+def _click(self, event):\n+    if self.ignore(event) or event.inaxes != self.ax or not self.eventson:\n+        return\n+    if event.canvas.mouse_grabber != self.ax:\n+        event.canvas.grab_mouse(self.ax)\n+\n+def _release(self, event):\n+    if self.ignore(event) or event.canvas.mouse_grabber != self.ax:\n+        return\n+    event.canvas.release_mouse(self.ax)\n+    if self.eventson and event.inaxes == self.ax:\n+        # Store current axes state before processing callbacks\n+        current_ax = self.ax\n+        current_canvas = event.canvas\n+        \n+        # Process the clicked event\n+        self._observers.process('clicked', event)\n+        \n+        # Check if axes/canvas still exist and are valid after callback\n+        if (hasattr(self, 'ax') and self.ax is not None and \n+            self.ax.figure is not None and \n+            self.ax.figure.canvas is not None):\n+            # Axes survived callback execution, continue normally\n+            pass\n+        else:\n+            # Axes were destroyed, need to handle gracefully\n+            self.ax = None\n \n     def _motion(self, event):\n         if self.ignore(event):\n@@ -294,10 +310,30 @@ class SliderBase(AxesWidget):\n         ax.set_axis_off()\n         ax.set_navigate(False)\n \n-        self.connect_event(\"button_press_event\", self._update)\n-        self.connect_event(\"button_release_event\", self._update)\n-        if dragging:\n-            self.connect_event(\"motion_notify_event\", self._update)\n+\n+def set_val(self, val):\n+    \"\"\"\n+    Set slider value to *val*.\n+\n+    Parameters\n+    ----------\n+    val : array-like\n+        value of the slider\n+    \"\"\"\n+    val = np.sort(val)\n+    _api.check_shape((2,), val=val)\n+    val[0] = self._stepped_value(val[0])\n+    val[1] = self._stepped_value(val[1])\n+    val[0] = np.clip(val[0], self.valmin, self.valmax)\n+    val[1] = np.clip(val[1], self.valmin, self.valmax)\n+    if np.any(self.val != val):\n+        self.val = val\n+        self._update_val_from_pos()\n+        # Defer callback execution if drag is active to prevent axis destruction\n+        if hasattr(self, '_active') and self._active:\n+            self._pending_callbacks = True\n+        else:\n+            self._observers.process(\"changed\", val)\n         self._observers = cbook.CallbackRegistry(signals=[\"changed\"])\n \n     def _stepped_value(self, val):\n@@ -526,6 +562,7 @@ class Slider(SliderBase):\n             val = self.slidermax.val\n         return val\n \n+\n     def _update(self, event):\n         \"\"\"Update the slider position.\"\"\"\n         if self.ignore(event) or event.button != 1:\n@@ -543,6 +580,24 @@ class Slider(SliderBase):\n                event.inaxes != self.ax)):\n             self.drag_active = False\n             event.canvas.release_mouse(self.ax)\n+            # Execute any pending callbacks after drag is complete\n+            if hasattr(self, '_pending_val') and self._pending_val is not None:\n+                self.set_val(self._pending_val)\n+                self._pending_val = None\n+            return\n+        if self.orientation == 'vertical':\n+            val = self._value_in_bounds(event.ydata)\n+        else:\n+            val = self._value_in_bounds(event.xdata)\n+        if val not in [None, self.val]:\n+            # Store the value for later execution instead of calling set_val immediately\n+            self._pending_val = val\n+            # Update visual position immediately but defer callbacks\n+            self._set_val_without_callbacks(val)\n+            if hasattr(self, '_pending_callbacks') and self._pending_callbacks:\n+                for callback_info in self._pending_callbacks:\n+                    callback_info['func'](callback_info['val'])\n+                self._pending_callbacks = []\n             return\n         if self.orientation == 'vertical':\n             val = self._value_in_bounds(event.ydata)\n@@ -550,6 +605,12 @@ class Slider(SliderBase):\n             val = self._value_in_bounds(event.xdata)\n         if val not in [None, self.val]:\n             self.set_val(val)\n+        if self.orientation == 'vertical':\n+            val = self._value_in_bounds(event.ydata)\n+        else:\n+            val = self._value_in_bounds(event.xdata)\n+        if val not in [None, self.val]:\n+            self.set_val(val)\n \n     def _format(self, val):\n         \"\"\"Pretty-print *val*.\"\"\"\n@@ -560,6 +621,7 @@ class Slider(SliderBase):\n             # fmt.get_offset is actually the multiplicative factor, if any.\n             return s + self._fmt.get_offset()\n \n+\n     def set_val(self, val):\n         \"\"\"\n         Set slider value to *val*.\n@@ -583,7 +645,14 @@ class Slider(SliderBase):\n             self.ax.figure.canvas.draw_idle()\n         self.val = val\n         if self.eventson:\n-            self._observers.process('changed', val)\n+            # Defer callback execution if currently dragging to prevent\n+            # axes destruction from breaking event connections\n+            if hasattr(self, '_active') and self._active:\n+                if not hasattr(self, '_pending_callbacks'):\n+                    self._pending_callbacks = []\n+                self._pending_callbacks.append(('changed', val))\n+            else:\n+                self._observers.process('changed', val)\n \n     def on_changed(self, func):\n         \"\"\"\n",
    "variant_2": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex ebe5da43e2..0b3a035d4e 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -214,18 +214,24 @@ class Button(AxesWidget):\n         self.color = color\n         self.hovercolor = hovercolor\n \n-    def _click(self, event):\n-        if self.ignore(event) or event.inaxes != self.ax or not self.eventson:\n-            return\n-        if event.canvas.mouse_grabber != self.ax:\n-            event.canvas.grab_mouse(self.ax)\n \n-    def _release(self, event):\n-        if self.ignore(event) or event.canvas.mouse_grabber != self.ax:\n-            return\n-        event.canvas.release_mouse(self.ax)\n-        if self.eventson and event.inaxes == self.ax:\n-            self._observers.process('clicked', event)\n+def _click(self, event):\n+    if self.ignore(event) or event.inaxes != self.ax or not self.eventson:\n+        return\n+    if event.canvas.mouse_grabber != self.ax:\n+        event.canvas.grab_mouse(self.ax)\n+\n+def _release(self, event):\n+    if self.ignore(event) or event.canvas.mouse_grabber != self.ax:\n+        return\n+    event.canvas.release_mouse(self.ax)\n+    if self.eventson and event.inaxes == self.ax:\n+        # Store current event connection state before processing callbacks\n+        was_connected = hasattr(self, '_event_cids') and self._event_cids\n+        self._observers.process('clicked', event)\n+        # If axes were destroyed during callback, reconnect events\n+        if was_connected and (not hasattr(self, '_event_cids') or not self._event_cids):\n+            self._reconnect_events()\n \n     def _motion(self, event):\n         if self.ignore(event):\n@@ -294,10 +300,75 @@ class SliderBase(AxesWidget):\n         ax.set_axis_off()\n         ax.set_navigate(False)\n \n-        self.connect_event(\"button_press_event\", self._update)\n-        self.connect_event(\"button_release_event\", self._update)\n-        if dragging:\n-            self.connect_event(\"motion_notify_event\", self._update)\n+\n+    def _update(self, event):\n+        \"\"\"Update the slider position.\"\"\"\n+        if self.ignore(event) or event.inaxes != self.ax:\n+            return\n+\n+        if event.name == 'button_press_event' and event.inaxes == self.ax:\n+            self.eventson = True\n+            self._active_handle = self._get_active_handle(event)\n+            if self._active_handle is None:\n+                # Out of bounds\n+                return\n+            else:\n+                self.set_val(self._slice_val(event, self._active_handle))\n+        elif event.name == 'motion_notify_event' and self.eventson:\n+            if self._active_handle is None:\n+                # Shouldn't happen if eventson is True, but be defensive.\n+                return\n+            else:\n+                self.set_val(self._slice_val(event, self._active_handle))\n+        elif event.name == 'button_release_event' and self.eventson:\n+            self.eventson = False\n+            self._active_handle = None\n+            # Execute any pending callbacks after drag is complete\n+            if hasattr(self, '_pending_callbacks') and self._pending_callbacks:\n+                for callback_data in self._pending_callbacks:\n+                    callback_data()\n+                self._pending_callbacks.clear()\n+\n+    def set_val(self, val):\n+        \"\"\"\n+        Set slider value to *val*.\n+\n+        Parameters\n+        ----------\n+        val : array-like\n+            The slider positions to set.\n+        \"\"\"\n+        val = np.sort(val)\n+        _api.check_shape((2,), val=val)\n+        val[0] = self._stepped_value(val[0])\n+        val[1] = self._stepped_value(val[1])\n+        xy = self.poly.xy\n+        if self.orientation == 'vertical':\n+            xy[0] = .25, val[0]\n+            xy[1] = .25, val[1]\n+            xy[2] = .75, val[1]\n+            xy[3] = .75, val[0]\n+            xy[4] = .25, val[0]\n+        else:\n+            xy[0] = val[0], .25\n+            xy[1] = val[0], .75\n+            xy[2] = val[1], .75\n+            xy[3] = val[1], .25\n+            xy[4] = val[0], .25\n+\n+        self.poly.xy = xy\n+        self.valtext.set_text(self._format(val))\n+        if self.drawon:\n+            self.ax.figure.canvas.draw_idle()\n+        self.val = val\n+        \n+        # Defer callbacks during active drag operations\n+        if hasattr(self, 'eventson') and self.eventson:\n+            if not hasattr(self, '_pending_callbacks'):\n+                self._pending_callbacks = []\n+            self._pending_callbacks.append(lambda: self._observers.process('changed', val))\n+        else:\n+            self._observers.process('changed', val)\n         self._observers = cbook.CallbackRegistry(signals=[\"changed\"])\n \n     def _stepped_value(self, val):\n@@ -526,6 +597,7 @@ class Slider(SliderBase):\n             val = self.slidermax.val\n         return val\n \n+\n     def _update(self, event):\n         \"\"\"Update the slider position.\"\"\"\n         if self.ignore(event) or event.button != 1:\n@@ -543,6 +615,44 @@ class Slider(SliderBase):\n                event.inaxes != self.ax)):\n             self.drag_active = False\n             event.canvas.release_mouse(self.ax)\n+            # Execute any pending callbacks after drag is complete\n+            if hasattr(self, '_pending_val') and self._pending_val is not None:\n+                pending_val = self._pending_val\n+                self._pending_val = None\n+                self.set_val(pending_val)\n+            return\n+        if self.orientation == 'vertical':\n+            val = self._value_in_bounds(event.ydata)\n+        else:\n+            val = self._value_in_bounds(event.xdata)\n+        if val not in [None, self.val]:\n+            # Store the value instead of calling set_val immediately during drag\n+            if self.drag_active:\n+                self._pending_val = val\n+                # Update visual position without triggering callbacks\n+                self.val = val\n+                if self.poly is not None:\n+                    if self.orientation == 'vertical':\n+                        xy = self.poly.xy\n+                        xy[1] = 0, val\n+                        xy[2] = 1, val\n+                    else:\n+                        xy = self.poly.xy\n+                        xy[2] = val, 1\n+                        xy[3] = val, 0\n+                if self.hline:\n+                    self.hline.set_ydata([val])\n+                if self.vline:\n+                    self.vline.set_xdata([val])\n+                self.valtext.set_text(self._format(val))\n+                if self.drawon:\n+                    self.ax.figure.canvas.draw_idle()\n+            else:\n+                self.set_val(val)\n+            if hasattr(self, '_pending_callbacks') and self._pending_callbacks:\n+                for callback_args in self._pending_callbacks:\n+                    self.observers.process(*callback_args)\n+                self._pending_callbacks.clear()\n             return\n         if self.orientation == 'vertical':\n             val = self._value_in_bounds(event.ydata)\n@@ -550,6 +660,12 @@ class Slider(SliderBase):\n             val = self._value_in_bounds(event.xdata)\n         if val not in [None, self.val]:\n             self.set_val(val)\n+        if self.orientation == 'vertical':\n+            val = self._value_in_bounds(event.ydata)\n+        else:\n+            val = self._value_in_bounds(event.xdata)\n+        if val not in [None, self.val]:\n+            self.set_val(val)\n \n     def _format(self, val):\n         \"\"\"Pretty-print *val*.\"\"\"\n@@ -560,6 +676,7 @@ class Slider(SliderBase):\n             # fmt.get_offset is actually the multiplicative factor, if any.\n             return s + self._fmt.get_offset()\n \n+\n     def set_val(self, val):\n         \"\"\"\n         Set slider value to *val*.\n@@ -583,7 +700,14 @@ class Slider(SliderBase):\n             self.ax.figure.canvas.draw_idle()\n         self.val = val\n         if self.eventson:\n-            self._observers.process('changed', val)\n+            # Check if we're in the middle of a drag operation\n+            if hasattr(self, '_active') and self._active:\n+                # Store the callback for later execution\n+                if not hasattr(self, '_pending_callback'):\n+                    self._pending_callback = []\n+                self._pending_callback.append(('changed', val))\n+            else:\n+                self._observers.process('changed', val)\n \n     def on_changed(self, func):\n         \"\"\"\n",
    "variant_3": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex ebe5da43e2..7371e200cd 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -214,6 +214,7 @@ class Button(AxesWidget):\n         self.color = color\n         self.hovercolor = hovercolor\n \n+\n     def _click(self, event):\n         if self.ignore(event) or event.inaxes != self.ax or not self.eventson:\n             return\n@@ -225,6 +226,21 @@ class Button(AxesWidget):\n             return\n         event.canvas.release_mouse(self.ax)\n         if self.eventson and event.inaxes == self.ax:\n+            # Store the event for deferred callback execution\n+            self._pending_callback_event = event\n+            # Use after_idle to defer callback execution until after all events are processed\n+            if hasattr(event.canvas, 'get_tk_widget'):\n+                # Tkinter backend\n+                event.canvas.get_tk_widget().after_idle(self._execute_pending_callback)\n+            else:\n+                # Other backends - execute immediately as fallback\n+                self._observers.process('clicked', event)\n+\n+    def _execute_pending_callback(self):\n+        \"\"\"Execute any pending callback after event processing is complete.\"\"\"\n+        if hasattr(self, '_pending_callback_event'):\n+            event = self._pending_callback_event\n+            delattr(self, '_pending_callback_event')\n             self._observers.process('clicked', event)\n \n     def _motion(self, event):\n@@ -294,10 +310,54 @@ class SliderBase(AxesWidget):\n         ax.set_axis_off()\n         ax.set_navigate(False)\n \n-        self.connect_event(\"button_press_event\", self._update)\n-        self.connect_event(\"button_release_event\", self._update)\n-        if dragging:\n-            self.connect_event(\"motion_notify_event\", self._update)\n+\n+    def _update(self, event):\n+        \"\"\"Update the slider position.\"\"\"\n+        if self.ignore(event) or event.inaxes != self.ax:\n+            return\n+\n+        if event.name == \"button_press_event\" and event.button != 1:\n+            return\n+\n+        if event.name == \"button_press_event\":\n+            self._active_handle = self._get_active_handle(event)\n+            if self._active_handle is None:\n+                # Outside slider, no update needed.\n+                return\n+            self._pending_callbacks = []  # Initialize pending callbacks list\n+        elif event.name == \"button_release_event\" or self._active_handle is None:\n+            # Execute any pending callbacks after drag completion\n+            if hasattr(self, '_pending_callbacks') and self._pending_callbacks:\n+                for callback in self._pending_callbacks:\n+                    callback()\n+                self._pending_callbacks = []\n+            self._active_handle = None\n+            return\n+\n+        # continue with existing drag update logic...\n+        if self._active_handle:\n+            click_location = event.xdata if self.orientation == \"horizontal\" else event.ydata\n+            if click_location is not None:\n+                new_val = self._value_in_bounds(click_location)\n+                if self._active_handle == \"min\":\n+                    if new_val <= self.val[1]:\n+                        self.val = (new_val, self.val[1])\n+                elif self._active_handle == \"max\":\n+                    if new_val >= self.val[0]:\n+                        self.val = (self.val[0], new_val)\n+                else:  # Both handles selected\n+                    self.val = (new_val, new_val)\n+                \n+                # Store callback for later execution instead of immediate execution\n+                if hasattr(self, '_pending_callbacks'):\n+                    self._pending_callbacks.append(lambda: self._observers.process(\"changed\", self.val))\n+                else:\n+                    # Fallback for cases where pending callbacks aren't initialized\n+                    self._observers.process(\"changed\", self.val)\n+\n+        self._update_selection_poly()\n+        if self.drawon:\n+            self.ax.figure.canvas.draw_idle()\n         self._observers = cbook.CallbackRegistry(signals=[\"changed\"])\n \n     def _stepped_value(self, val):\n@@ -526,6 +586,7 @@ class Slider(SliderBase):\n             val = self.slidermax.val\n         return val\n \n+\n     def _update(self, event):\n         \"\"\"Update the slider position.\"\"\"\n         if self.ignore(event) or event.button != 1:\n@@ -543,11 +604,37 @@ class Slider(SliderBase):\n                event.inaxes != self.ax)):\n             self.drag_active = False\n             event.canvas.release_mouse(self.ax)\n+            # Execute any pending callbacks after drag is complete\n+            if hasattr(self, '_pending_val') and self._pending_val != self.val:\n+                self.set_val(self._pending_val)\n+                delattr(self, '_pending_val')\n+            return\n+        if self.orientation == 'vertical':\n+            val = self._value_in_bounds(event.ydata)\n+        else:\n+            val = self._value_in_bounds(event.xdata)\n+        if val not in [None, self.val]:\n+            # Store the value but don't execute callbacks during drag\n+            if self.drag_active:\n+                self._pending_val = val\n+                # Update visual position without triggering callbacks\n+                self._set_val_without_callback(val)\n+            else:\n+                self.set_val(val)\n+            if hasattr(self, '_pending_callback') and self._pending_callback:\n+                self._pending_callback()\n+                self._pending_callback = None\n             return\n         if self.orientation == 'vertical':\n             val = self._value_in_bounds(event.ydata)\n         else:\n             val = self._value_in_bounds(event.xdata)\n+        if val not in [None, self.val]:\n+            self.set_val(val, defer_callback=True)\n+        if self.orientation == 'vertical':\n+            val = self._value_in_bounds(event.ydata)\n+        else:\n+            val = self._value_in_bounds(event.xdata)\n         if val not in [None, self.val]:\n             self.set_val(val)\n \n@@ -560,6 +647,7 @@ class Slider(SliderBase):\n             # fmt.get_offset is actually the multiplicative factor, if any.\n             return s + self._fmt.get_offset()\n \n+\n     def set_val(self, val):\n         \"\"\"\n         Set slider value to *val*.\n@@ -583,7 +671,12 @@ class Slider(SliderBase):\n             self.ax.figure.canvas.draw_idle()\n         self.val = val\n         if self.eventson:\n-            self._observers.process('changed', val)\n+            # Defer callback execution if we're in the middle of a drag operation\n+            if hasattr(self, '_active') and self._active:\n+                self._pending_callbacks = getattr(self, '_pending_callbacks', [])\n+                self._pending_callbacks.append(('changed', val))\n+            else:\n+                self._observers.process('changed', val)\n \n     def on_changed(self, func):\n         \"\"\"\n",
    "variant_4": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex ebe5da43e2..489496cd0f 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -214,6 +214,7 @@ class Button(AxesWidget):\n         self.color = color\n         self.hovercolor = hovercolor\n \n+\n     def _click(self, event):\n         if self.ignore(event) or event.inaxes != self.ax or not self.eventson:\n             return\n@@ -225,7 +226,18 @@ class Button(AxesWidget):\n             return\n         event.canvas.release_mouse(self.ax)\n         if self.eventson and event.inaxes == self.ax:\n+            # Store current axes and canvas references before callback execution\n+            current_ax = self.ax\n+            current_canvas = event.canvas\n             self._observers.process('clicked', event)\n+            # Verify axes and canvas are still valid after callback\n+            if (hasattr(self, 'ax') and self.ax is not None and \n+                hasattr(self.ax, 'figure') and self.ax.figure is not None):\n+                # Re-establish event connections if they were lost\n+                if not hasattr(self, '_cids') or not self._cids:\n+                    self.connect_event('button_press_event', self._click)\n+                    self.connect_event('button_release_event', self._release)\n+                    self.connect_event('motion_notify_event', self._motion)\n \n     def _motion(self, event):\n         if self.ignore(event):\n@@ -294,10 +306,42 @@ class SliderBase(AxesWidget):\n         ax.set_axis_off()\n         ax.set_navigate(False)\n \n-        self.connect_event(\"button_press_event\", self._update)\n-        self.connect_event(\"button_release_event\", self._update)\n-        if dragging:\n-            self.connect_event(\"motion_notify_event\", self._update)\n+\n+    def _update(self, event):\n+        \"\"\"Update the slider position.\"\"\"\n+        if self.ignore(event) or event.inaxes != self.ax:\n+            return\n+\n+        if event.name == \"button_press_event\" and event.button != 1:\n+            return\n+\n+        if event.name == \"button_press_event\":\n+            self._active_handle = self._get_active_handle(event)\n+            if self._active_handle is None:\n+                # Outside slider, no handle to move.\n+                return\n+        elif event.name == \"button_release_event\":\n+            if self._active_handle is None:\n+                return\n+            # Execute any pending callbacks after drag completion\n+            if hasattr(self, '_pending_callbacks') and self._pending_callbacks:\n+                for callback_data in self._pending_callbacks:\n+                    callback_data()\n+                self._pending_callbacks = []\n+            self._active_handle = None\n+            return\n+\n+        # Determine new value(s)\n+        if self._active_handle == \"min\":\n+            if event.name == \"motion_notify_event\":\n+                self.set_min(self._value_in_bounds(event))\n+            else:\n+                self.set_min(self._value_in_bounds(event))\n+        elif self._active_handle == \"max\":\n+            if event.name == \"motion_notify_event\":\n+                self.set_max(self._value_in_bounds(event))\n+            else:\n+                self.set_max(self._value_in_bounds(event))\n         self._observers = cbook.CallbackRegistry(signals=[\"changed\"])\n \n     def _stepped_value(self, val):\n@@ -526,23 +570,44 @@ class Slider(SliderBase):\n             val = self.slidermax.val\n         return val\n \n-    def _update(self, event):\n-        \"\"\"Update the slider position.\"\"\"\n-        if self.ignore(event) or event.button != 1:\n-            return\n \n-        if event.name == 'button_press_event' and event.inaxes == self.ax:\n-            self.drag_active = True\n-            event.canvas.grab_mouse(self.ax)\n+def _update(self, event):\n+    \"\"\"Update the slider position.\"\"\"\n+    if self.ignore(event) or event.button != 1:\n+        return\n \n-        if not self.drag_active:\n-            return\n+    if event.name == 'button_press_event' and event.inaxes == self.ax:\n+        self.drag_active = True\n+        event.canvas.grab_mouse(self.ax)\n \n-        elif ((event.name == 'button_release_event') or\n-              (event.name == 'button_press_event' and\n-               event.inaxes != self.ax)):\n-            self.drag_active = False\n-            event.canvas.release_mouse(self.ax)\n+    if not self.drag_active:\n+        return\n+\n+    elif ((event.name == 'button_release_event') or\n+          (event.name == 'button_press_event' and\n+           event.inaxes != self.ax)):\n+        self.drag_active = False\n+        event.canvas.release_mouse(self.ax)\n+        # Execute any pending callbacks after drag completion\n+        if hasattr(self, '_pending_callbacks') and self._pending_callbacks:\n+            for callback in self._pending_callbacks:\n+                callback()\n+            self._pending_callbacks = []\n+        return\n+    if self.orientation == 'vertical':\n+        val = self._value_in_bounds(event.ydata)\n+    else:\n+        val = self._value_in_bounds(event.xdata)\n+    if val not in [None, self.val]:\n+        self.set_val(val)\n+            if hasattr(self, '_pending_callbacks') and self._pending_callbacks:\n+                for callback_args in self._pending_callbacks:\n+                    try:\n+                        self.observers.process(*callback_args)\n+                    except Exception:\n+                        # Silently ignore callback errors to prevent widget breakage\n+                        pass\n+                self._pending_callbacks.clear()\n             return\n         if self.orientation == 'vertical':\n             val = self._value_in_bounds(event.ydata)\n@@ -550,6 +615,12 @@ class Slider(SliderBase):\n             val = self._value_in_bounds(event.xdata)\n         if val not in [None, self.val]:\n             self.set_val(val)\n+        if self.orientation == 'vertical':\n+            val = self._value_in_bounds(event.ydata)\n+        else:\n+            val = self._value_in_bounds(event.xdata)\n+        if val not in [None, self.val]:\n+            self.set_val(val)\n \n     def _format(self, val):\n         \"\"\"Pretty-print *val*.\"\"\"\n@@ -560,6 +631,7 @@ class Slider(SliderBase):\n             # fmt.get_offset is actually the multiplicative factor, if any.\n             return s + self._fmt.get_offset()\n \n+\n     def set_val(self, val):\n         \"\"\"\n         Set slider value to *val*.\n@@ -583,7 +655,11 @@ class Slider(SliderBase):\n             self.ax.figure.canvas.draw_idle()\n         self.val = val\n         if self.eventson:\n-            self._observers.process('changed', val)\n+            # Defer callback execution if we're in the middle of a drag operation\n+            if hasattr(self, '_active') and self._active:\n+                self._pending_callback_val = val\n+            else:\n+                self._observers.process('changed', val)\n \n     def on_changed(self, func):\n         \"\"\"\n",
    "variant_5": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex ebe5da43e2..313623adb9 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -214,18 +214,22 @@ class Button(AxesWidget):\n         self.color = color\n         self.hovercolor = hovercolor\n \n-    def _click(self, event):\n-        if self.ignore(event) or event.inaxes != self.ax or not self.eventson:\n-            return\n-        if event.canvas.mouse_grabber != self.ax:\n-            event.canvas.grab_mouse(self.ax)\n \n-    def _release(self, event):\n-        if self.ignore(event) or event.canvas.mouse_grabber != self.ax:\n-            return\n-        event.canvas.release_mouse(self.ax)\n-        if self.eventson and event.inaxes == self.ax:\n-            self._observers.process('clicked', event)\n+def _click(self, event):\n+    if self.ignore(event) or event.inaxes != self.ax or not self.eventson:\n+        return\n+    if event.canvas.mouse_grabber != self.ax:\n+        event.canvas.grab_mouse(self.ax)\n+\n+def _release(self, event):\n+    if self.ignore(event) or event.canvas.mouse_grabber != self.ax:\n+        return\n+    event.canvas.release_mouse(self.ax)\n+    if self.eventson and event.inaxes == self.ax:\n+        # Store callback execution state to prevent interference from axes destruction\n+        observers = self._observers\n+        # Execute callback after ensuring mouse state is clean\n+        observers.process('clicked', event)\n \n     def _motion(self, event):\n         if self.ignore(event):\n@@ -294,10 +298,49 @@ class SliderBase(AxesWidget):\n         ax.set_axis_off()\n         ax.set_navigate(False)\n \n-        self.connect_event(\"button_press_event\", self._update)\n-        self.connect_event(\"button_release_event\", self._update)\n-        if dragging:\n-            self.connect_event(\"motion_notify_event\", self._update)\n+\n+    def _update(self, event):\n+        \"\"\"Update the slider position.\"\"\"\n+        if self.ignore(event) or event.button != 1:\n+            return\n+\n+        if event.name == \"button_press_event\" and event.inaxes == self.ax:\n+            self.eventson = True\n+            xy = self.ax.transData.inverted().transform((event.x, event.y))\n+            self._active_handle = self._handles[np.argmin(\n+                np.abs([h.get_xdata()[0] - xy[0] for h in self._handles]))]\n+            # Store pending callbacks to execute after drag completion\n+            self._pending_callbacks = []\n+\n+        if not self.eventson:\n+            return\n+\n+        if event.name == \"motion_notify_event\":\n+            xy = self.ax.transData.inverted().transform((event.x, event.y))\n+            if self._active_handle:\n+                # Update position without triggering callbacks during drag\n+                if self._active_handle == self._handles[0]:\n+                    self._val = (self._stepped_value(xy[0]), self.val[1])\n+                else:\n+                    self._val = (self.val[0], self._stepped_value(xy[0]))\n+                if self.val[0] > self.val[1]:\n+                    self._val = self.val[1], self.val[0]\n+                self._update_selection_poly()\n+                # Store callback for later execution instead of immediate call\n+                self._pending_callbacks = [self._observers.process]\n+                \n+        elif event.name == \"button_release_event\":\n+            self.eventson = False\n+            self._active_handle = None\n+            # Execute any pending callbacks now that drag is complete\n+            if hasattr(self, '_pending_callbacks'):\n+                for callback in self._pending_callbacks:\n+                    try:\n+                        callback(\"changed\", self.val)\n+                    except Exception:\n+                        # Widget may have been destroyed during callback\n+                        pass\n+                self._pending_callbacks = []\n         self._observers = cbook.CallbackRegistry(signals=[\"changed\"])\n \n     def _stepped_value(self, val):\n@@ -526,6 +569,7 @@ class Slider(SliderBase):\n             val = self.slidermax.val\n         return val\n \n+\n     def _update(self, event):\n         \"\"\"Update the slider position.\"\"\"\n         if self.ignore(event) or event.button != 1:\n@@ -533,6 +577,7 @@ class Slider(SliderBase):\n \n         if event.name == 'button_press_event' and event.inaxes == self.ax:\n             self.drag_active = True\n+            self._pending_callbacks = []\n             event.canvas.grab_mouse(self.ax)\n \n         if not self.drag_active:\n@@ -543,7 +588,33 @@ class Slider(SliderBase):\n                event.inaxes != self.ax)):\n             self.drag_active = False\n             event.canvas.release_mouse(self.ax)\n+            # Execute any pending callbacks after drag is complete\n+            if hasattr(self, '_pending_callbacks'):\n+                for callback in self._pending_callbacks:\n+                    callback()\n+                self._pending_callbacks = []\n             return\n+        if self.orientation == 'vertical':\n+            val = self._value_in_bounds(event.ydata)\n+        else:\n+            val = self._value_in_bounds(event.xdata)\n+        if val not in [None, self.val]:\n+            self.set_val(val, defer_callbacks=True)\n+        if hasattr(self, '_pending_callback_val'):\n+            pending_val = self._pending_callback_val\n+            del self._pending_callback_val\n+            self._call_observers(pending_val)\n+        return\n+    \n+    if self.orientation == 'vertical':\n+        val = self._value_in_bounds(event.ydata)\n+    else:\n+        val = self._value_in_bounds(event.xdata)\n+    if val not in [None, self.val]:\n+        # Store the value for callback execution after drag completion\n+        self._pending_callback_val = val\n+        # Update the slider position immediately but defer callbacks\n+        self._set_val_without_callback(val)\n         if self.orientation == 'vertical':\n             val = self._value_in_bounds(event.ydata)\n         else:\n@@ -560,6 +631,7 @@ class Slider(SliderBase):\n             # fmt.get_offset is actually the multiplicative factor, if any.\n             return s + self._fmt.get_offset()\n \n+\n     def set_val(self, val):\n         \"\"\"\n         Set slider value to *val*.\n@@ -583,7 +655,11 @@ class Slider(SliderBase):\n             self.ax.figure.canvas.draw_idle()\n         self.val = val\n         if self.eventson:\n-            self._observers.process('changed', val)\n+            # Defer callback execution if we're in the middle of a drag operation\n+            if hasattr(self, '_dragging') and self._dragging:\n+                self._pending_callback = val\n+            else:\n+                self._observers.process('changed', val)\n \n     def on_changed(self, func):\n         \"\"\"\n",
    "variant_6": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex ebe5da43e2..6cbe92a5e3 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -214,6 +214,7 @@ class Button(AxesWidget):\n         self.color = color\n         self.hovercolor = hovercolor\n \n+\n     def _click(self, event):\n         if self.ignore(event) or event.inaxes != self.ax or not self.eventson:\n             return\n@@ -225,7 +226,11 @@ class Button(AxesWidget):\n             return\n         event.canvas.release_mouse(self.ax)\n         if self.eventson and event.inaxes == self.ax:\n-            self._observers.process('clicked', event)\n+            # Defer callback execution to avoid axis destruction during event handling\n+            def _deferred_callback():\n+                self._observers.process('clicked', event)\n+            event.canvas.start_event_loop(timeout=0.001)  # Allow event processing to complete\n+            _deferred_callback()\n \n     def _motion(self, event):\n         if self.ignore(event):\n@@ -294,11 +299,15 @@ class SliderBase(AxesWidget):\n         ax.set_axis_off()\n         ax.set_navigate(False)\n \n+\n         self.connect_event(\"button_press_event\", self._update)\n         self.connect_event(\"button_release_event\", self._update)\n         if dragging:\n             self.connect_event(\"motion_notify_event\", self._update)\n         self._observers = cbook.CallbackRegistry(signals=[\"changed\"])\n+        self._pending_callbacks = []  # Store callbacks during drag operations\n+        self._dragging = False  # Track drag state\n+        self._observers = cbook.CallbackRegistry(signals=[\"changed\"])\n \n     def _stepped_value(self, val):\n         \"\"\"Return *val* coerced to closest number in the ``valstep`` grid.\"\"\"\n@@ -526,6 +535,7 @@ class Slider(SliderBase):\n             val = self.slidermax.val\n         return val\n \n+\n     def _update(self, event):\n         \"\"\"Update the slider position.\"\"\"\n         if self.ignore(event) or event.button != 1:\n@@ -543,6 +553,38 @@ class Slider(SliderBase):\n                event.inaxes != self.ax)):\n             self.drag_active = False\n             event.canvas.release_mouse(self.ax)\n+            # Execute any pending callbacks after drag is complete\n+            if hasattr(self, '_pending_callback_val'):\n+                self.set_val(self._pending_callback_val)\n+                delattr(self, '_pending_callback_val')\n+            return\n+        if self.orientation == 'vertical':\n+            val = self._value_in_bounds(event.ydata)\n+        else:\n+            val = self._value_in_bounds(event.xdata)\n+        if val not in [None, self.val]:\n+            # Store the value for callback execution after drag ends\n+            if self.drag_active and hasattr(self, 'drag_active'):\n+                self._pending_callback_val = val\n+                # Update visual position without triggering callbacks\n+                self.val = val\n+                xy = self.poly.xy\n+                if self.orientation == 'vertical':\n+                    xy[1] = 0, val\n+                    xy[2] = 1, val\n+                else:\n+                    xy[2] = val, 1\n+                    xy[3] = val, 0\n+                self.poly.xy = xy\n+                self.valtext.set_text(self._format(val))\n+                if self.drawon:\n+                    self.ax.figure.canvas.draw_idle()\n+            else:\n+                self.set_val(val)\n+            if hasattr(self, '_pending_callbacks') and self._pending_callbacks:\n+                for callback_args in self._pending_callbacks:\n+                    self.observers.process(*callback_args)\n+                self._pending_callbacks = []\n             return\n         if self.orientation == 'vertical':\n             val = self._value_in_bounds(event.ydata)\n@@ -550,6 +592,12 @@ class Slider(SliderBase):\n             val = self._value_in_bounds(event.xdata)\n         if val not in [None, self.val]:\n             self.set_val(val)\n+        if self.orientation == 'vertical':\n+            val = self._value_in_bounds(event.ydata)\n+        else:\n+            val = self._value_in_bounds(event.xdata)\n+        if val not in [None, self.val]:\n+            self.set_val(val)\n \n     def _format(self, val):\n         \"\"\"Pretty-print *val*.\"\"\"\n@@ -560,6 +608,7 @@ class Slider(SliderBase):\n             # fmt.get_offset is actually the multiplicative factor, if any.\n             return s + self._fmt.get_offset()\n \n+\n     def set_val(self, val):\n         \"\"\"\n         Set slider value to *val*.\n@@ -583,7 +632,14 @@ class Slider(SliderBase):\n             self.ax.figure.canvas.draw_idle()\n         self.val = val\n         if self.eventson:\n-            self._observers.process('changed', val)\n+            # Check if we're in the middle of a drag operation\n+            if hasattr(self, '_active') and self._active:\n+                # Store callback for later execution to avoid axes destruction during drag\n+                if not hasattr(self, '_pending_callbacks'):\n+                    self._pending_callbacks = []\n+                self._pending_callbacks.append(('changed', val))\n+            else:\n+                self._observers.process('changed', val)\n \n     def on_changed(self, func):\n         \"\"\"\n",
    "variant_7": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex ebe5da43e2..1e3198c069 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -214,18 +214,26 @@ class Button(AxesWidget):\n         self.color = color\n         self.hovercolor = hovercolor\n \n-    def _click(self, event):\n-        if self.ignore(event) or event.inaxes != self.ax or not self.eventson:\n-            return\n-        if event.canvas.mouse_grabber != self.ax:\n-            event.canvas.grab_mouse(self.ax)\n \n-    def _release(self, event):\n-        if self.ignore(event) or event.canvas.mouse_grabber != self.ax:\n-            return\n-        event.canvas.release_mouse(self.ax)\n-        if self.eventson and event.inaxes == self.ax:\n-            self._observers.process('clicked', event)\n+def _click(self, event):\n+    if self.ignore(event) or event.inaxes != self.ax or not self.eventson:\n+        return\n+    if event.canvas.mouse_grabber != self.ax:\n+        event.canvas.grab_mouse(self.ax)\n+\n+def _release(self, event):\n+    if self.ignore(event) or event.canvas.mouse_grabber != self.ax:\n+        return\n+    event.canvas.release_mouse(self.ax)\n+    if self.eventson and event.inaxes == self.ax:\n+        # Store current state before processing callbacks to handle potential axis destruction\n+        ax_ref = self.ax\n+        observers_ref = self._observers\n+        try:\n+            observers_ref.process('clicked', event)\n+        except Exception:\n+            # If axes were destroyed during callback, silently continue\n+            pass\n \n     def _motion(self, event):\n         if self.ignore(event):\n@@ -294,10 +302,42 @@ class SliderBase(AxesWidget):\n         ax.set_axis_off()\n         ax.set_navigate(False)\n \n-        self.connect_event(\"button_press_event\", self._update)\n-        self.connect_event(\"button_release_event\", self._update)\n-        if dragging:\n-            self.connect_event(\"motion_notify_event\", self._update)\n+\n+def _update(self, event):\n+    \"\"\"Update the slider position.\"\"\"\n+    if self.ignore(event) or event.inaxes != self.ax:\n+        return\n+\n+    if event.name == \"button_press_event\" and event.inaxes == self.ax:\n+        self.drag_active = True\n+        # Store callbacks to execute after drag completion\n+        self._pending_callbacks = []\n+\n+    val = self._value_in_bounds(event)\n+    if not self.drag_active or self.drag_active:\n+        if self._active_handle is None:\n+            self._active_handle = np.argmin(np.abs([val - self.val[0],\n+                                                    val - self.val[1]]))\n+        # Avoid recursion by directly updating without triggering callbacks during drag\n+        if hasattr(self, 'drag_active') and self.drag_active and event.name != \"button_release_event\":\n+            # Store the callback for later execution\n+            old_val = self.val\n+            self._process_value(val)\n+            if not np.array_equal(old_val, self.val):\n+                if not hasattr(self, '_pending_callbacks'):\n+                    self._pending_callbacks = []\n+                self._pending_callbacks.append(lambda: self._observers.process('changed', self.val))\n+        else:\n+            self.set_val(val)\n+\n+    if event.name == \"button_release_event\":\n+        self.drag_active = False\n+        self._active_handle = None\n+        # Execute any pending callbacks after drag completion\n+        if hasattr(self, '_pending_callbacks'):\n+            for callback in self._pending_callbacks:\n+                callback()\n+            self._pending_callbacks = []\n         self._observers = cbook.CallbackRegistry(signals=[\"changed\"])\n \n     def _stepped_value(self, val):\n@@ -526,23 +566,39 @@ class Slider(SliderBase):\n             val = self.slidermax.val\n         return val\n \n-    def _update(self, event):\n-        \"\"\"Update the slider position.\"\"\"\n-        if self.ignore(event) or event.button != 1:\n-            return\n \n-        if event.name == 'button_press_event' and event.inaxes == self.ax:\n-            self.drag_active = True\n-            event.canvas.grab_mouse(self.ax)\n+def _update(self, event):\n+    \"\"\"Update the slider position.\"\"\"\n+    if self.ignore(event) or event.button != 1:\n+        return\n \n-        if not self.drag_active:\n-            return\n+    if event.name == 'button_press_event' and event.inaxes == self.ax:\n+        self.drag_active = True\n+        event.canvas.grab_mouse(self.ax)\n \n-        elif ((event.name == 'button_release_event') or\n-              (event.name == 'button_press_event' and\n-               event.inaxes != self.ax)):\n-            self.drag_active = False\n-            event.canvas.release_mouse(self.ax)\n+    if not self.drag_active:\n+        return\n+\n+    elif ((event.name == 'button_release_event') or\n+          (event.name == 'button_press_event' and\n+           event.inaxes != self.ax)):\n+        self.drag_active = False\n+        event.canvas.release_mouse(self.ax)\n+        # Execute any pending callbacks after drag is complete\n+        if hasattr(self, '_pending_callback_val'):\n+            self._call_observers('changed', self._pending_callback_val)\n+            delattr(self, '_pending_callback_val')\n+        return\n+    \n+    if self.orientation == 'vertical':\n+        val = self._value_in_bounds(event.ydata)\n+    else:\n+        val = self._value_in_bounds(event.xdata)\n+    if val not in [None, self.val]:\n+        self.set_val(val, defer_callback=True)\n+            if hasattr(self, '_pending_callback_val') and self._pending_callback_val is not None:\n+                self._call_observers(self._pending_callback_val)\n+                self._pending_callback_val = None\n             return\n         if self.orientation == 'vertical':\n             val = self._value_in_bounds(event.ydata)\n@@ -550,6 +606,12 @@ class Slider(SliderBase):\n             val = self._value_in_bounds(event.xdata)\n         if val not in [None, self.val]:\n             self.set_val(val)\n+        if self.orientation == 'vertical':\n+            val = self._value_in_bounds(event.ydata)\n+        else:\n+            val = self._value_in_bounds(event.xdata)\n+        if val not in [None, self.val]:\n+            self.set_val(val)\n \n     def _format(self, val):\n         \"\"\"Pretty-print *val*.\"\"\"\n@@ -560,6 +622,7 @@ class Slider(SliderBase):\n             # fmt.get_offset is actually the multiplicative factor, if any.\n             return s + self._fmt.get_offset()\n \n+\n     def set_val(self, val):\n         \"\"\"\n         Set slider value to *val*.\n@@ -583,7 +646,15 @@ class Slider(SliderBase):\n             self.ax.figure.canvas.draw_idle()\n         self.val = val\n         if self.eventson:\n-            self._observers.process('changed', val)\n+            # Check if we're in the middle of a drag operation\n+            if hasattr(self, '_active') and self._active:\n+                # Store callback for later execution\n+                if not hasattr(self, '_pending_callback'):\n+                    self._pending_callback = None\n+                self._pending_callback = val\n+            else:\n+                # Execute callback immediately if not dragging\n+                self._observers.process('changed', val)\n \n     def on_changed(self, func):\n         \"\"\"\n",
    "variant_8": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex ebe5da43e2..d2f32cf4f7 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -214,6 +214,7 @@ class Button(AxesWidget):\n         self.color = color\n         self.hovercolor = hovercolor\n \n+\n     def _click(self, event):\n         if self.ignore(event) or event.inaxes != self.ax or not self.eventson:\n             return\n@@ -225,7 +226,15 @@ class Button(AxesWidget):\n             return\n         event.canvas.release_mouse(self.ax)\n         if self.eventson and event.inaxes == self.ax:\n+            # Store current axes reference before callback execution\n+            current_ax = self.ax\n             self._observers.process('clicked', event)\n+            # Re-establish event connections if axes was destroyed and recreated\n+            if self.ax != current_ax:\n+                self.disconnect_events()\n+                self.connect_event('button_press_event', self._click)\n+                self.connect_event('button_release_event', self._release)\n+                self.connect_event('motion_notify_event', self._motion)\n \n     def _motion(self, event):\n         if self.ignore(event):\n@@ -294,10 +303,52 @@ class SliderBase(AxesWidget):\n         ax.set_axis_off()\n         ax.set_navigate(False)\n \n-        self.connect_event(\"button_press_event\", self._update)\n-        self.connect_event(\"button_release_event\", self._update)\n-        if dragging:\n-            self.connect_event(\"motion_notify_event\", self._update)\n+\n+    def _update(self, event):\n+        \"\"\"Update the slider position.\"\"\"\n+        if self.ignore(event) or event.inaxes != self.ax:\n+            return\n+\n+        if event.name == \"button_press_event\" and event.inaxes == self.ax:\n+            self.eventson = True\n+            event.canvas.grab_mouse(self.ax)\n+            # Store pending callbacks to execute after drag completion\n+            self._pending_callbacks = []\n+\n+        if not self.eventson:\n+            return\n+\n+        if event.name == \"button_release_event\" or \\\n+                (self.closedmax and event.xdata >= self.valmax) or \\\n+                (self.closedmin and event.xdata <= self.valmin):\n+\n+            if not self.dragging:\n+                return\n+            self.eventson = False\n+            event.canvas.release_mouse(self.ax)\n+            \n+            # Execute any pending callbacks after drag completion\n+            if hasattr(self, '_pending_callbacks'):\n+                for callback_args in self._pending_callbacks:\n+                    try:\n+                        self._observers.process(*callback_args)\n+                    except Exception:\n+                        pass  # Handle callback errors gracefully\n+                delattr(self, '_pending_callbacks')\n+            return\n+\n+        if event.inaxes != self.ax:\n+            return\n+\n+        val = self._value_in_bounds(event)\n+        if not self.dragging:\n+            if np.abs(val - self.val) >= self.valfmt_callback_threshold:\n+                # Store callback for later execution during drag\n+                if hasattr(self, '_pending_callbacks'):\n+                    self._pending_callbacks.append((\"changed\", self.val))\n+                else:\n+                    self._observers.process(\"changed\", self.val)\n+        self.set_val(val, during_drag=True)\n         self._observers = cbook.CallbackRegistry(signals=[\"changed\"])\n \n     def _stepped_value(self, val):\n@@ -526,6 +577,7 @@ class Slider(SliderBase):\n             val = self.slidermax.val\n         return val\n \n+\n     def _update(self, event):\n         \"\"\"Update the slider position.\"\"\"\n         if self.ignore(event) or event.button != 1:\n@@ -543,7 +595,47 @@ class Slider(SliderBase):\n                event.inaxes != self.ax)):\n             self.drag_active = False\n             event.canvas.release_mouse(self.ax)\n+            # Execute any deferred callbacks after drag is complete\n+            if hasattr(self, '_deferred_callback_val'):\n+                self.set_val(self._deferred_callback_val)\n+                delattr(self, '_deferred_callback_val')\n             return\n+        if self.orientation == 'vertical':\n+            val = self._value_in_bounds(event.ydata)\n+        else:\n+            val = self._value_in_bounds(event.xdata)\n+        if val not in [None, self.val]:\n+            # Store the callback for execution after drag is complete\n+            if self.drag_active:\n+                self._deferred_callback_val = val\n+                # Update visual state without triggering callbacks\n+                self.val = val\n+                if self.drawon:\n+                    if self.orientation == 'vertical':\n+                        self.poly.set_xy(self._make_vertices(val, self.val))\n+                    else:\n+                        self.poly.set_xy(self._make_vertices(self.val, val))\n+                    if self.drawon:\n+                        self.ax.figure.canvas.draw_idle()\n+            else:\n+                self.set_val(val)\n+        if hasattr(self, '_pending_callbacks') and self._pending_callbacks:\n+            for callback_val in self._pending_callbacks:\n+                self.observers.process('changed', callback_val)\n+            self._pending_callbacks = []\n+        return\n+    \n+    if self.orientation == 'vertical':\n+        val = self._value_in_bounds(event.ydata)\n+    else:\n+        val = self._value_in_bounds(event.xdata)\n+    if val not in [None, self.val]:\n+        # Store the callback for later execution instead of immediate execution\n+        if not hasattr(self, '_pending_callbacks'):\n+            self._pending_callbacks = []\n+        self._pending_callbacks.append(val)\n+        # Update the visual state immediately but defer callbacks\n+        self._set_val_without_callback(val)\n         if self.orientation == 'vertical':\n             val = self._value_in_bounds(event.ydata)\n         else:\n@@ -560,29 +652,36 @@ class Slider(SliderBase):\n             # fmt.get_offset is actually the multiplicative factor, if any.\n             return s + self._fmt.get_offset()\n \n-    def set_val(self, val):\n-        \"\"\"\n-        Set slider value to *val*.\n \n-        Parameters\n-        ----------\n-        val : float\n-        \"\"\"\n-        xy = self.poly.xy\n-        if self.orientation == 'vertical':\n-            xy[1] = .25, val\n-            xy[2] = .75, val\n-            self._handle.set_ydata([val])\n+def set_val(self, val):\n+    \"\"\"\n+    Set slider value to *val*.\n+\n+    Parameters\n+    ----------\n+    val : float\n+    \"\"\"\n+    xy = self.poly.xy\n+    if self.orientation == 'vertical':\n+        xy[1] = .25, val\n+        xy[2] = .75, val\n+        self._handle.set_ydata([val])\n+    else:\n+        xy[2] = val, .75\n+        xy[3] = val, .25\n+        self._handle.set_xdata([val])\n+    self.poly.xy = xy\n+    self.valtext.set_text(self._format(val))\n+    if self.drawon:\n+        self.ax.figure.canvas.draw_idle()\n+    self.val = val\n+    if self.eventson:\n+        # Check if we're in the middle of a drag operation\n+        if hasattr(self, '_active') and self._active:\n+            # Store callback for later execution after drag completes\n+            if not hasattr(self, '_pending_callback'):\n+                self._pending_callback = True\n         else:\n-            xy[2] = val, .75\n-            xy[3] = val, .25\n-            self._handle.set_xdata([val])\n-        self.poly.xy = xy\n-        self.valtext.set_text(self._format(val))\n-        if self.drawon:\n-            self.ax.figure.canvas.draw_idle()\n-        self.val = val\n-        if self.eventson:\n             self._observers.process('changed', val)\n \n     def on_changed(self, func):\n"
  }
}