{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/django/django/db/backends/base/creation.py lines 77-78)": "\n        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n            self.connection._test_serialized_contents = self.serialize_db_to_string()\n",
    "Location 2 (/root/hy/projects_2/django/django/db/backends/base/creation.py lines 61-71)": "\n        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n            self.connection._test_serialized_contents = self.serialize_db_to_string()\n",
    "Location 3 (/root/hy/projects_2/django/django/db/backends/base/creation.py lines 115-118)": "\n            if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n                self.connection._test_serialized_contents = self.serialize_db_to_string()\n",
    "Location 4 (/root/hy/projects_2/django/django/db/backends/base/creation.py lines 100-122)": "\ndef serialize_db_to_string(self):\n    \"\"\"\n    Serialize all data in the database into a JSON string.\n    Designed only for test runner usage; will not handle large\n    amounts of data.\n    \"\"\"\n    # Skip serialization if migrations weren't run\n    if not self.connection.settings_dict['TEST']['MIGRATE']:\n        return ''\n    \n    # Iteratively return every object for all models to serialize.\n    def get_objects():\n        from django.db.migrations.loader import MigrationLoader\n        loader = MigrationLoader(self.connection)\n        for app_config in apps.get_app_configs():\n            if (\n                app_config.models_module is not None and\n                app_config.label in loader.migrated_apps and\n                app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n            ):\n                for model in app_config.get_models():\n                    if (\n                        model._meta.can_migrate(self.connection) and\n                        router.allow_migrate_model(self.connection.alias, model)\n                    ):\n                        queryset = model._default_manager.using(\n                            self.connection.alias,\n                        ).order_by(model._meta.pk.name)\n                        yield from queryset.iterator()\n    # Serialize to a string\n    out = StringIO()\n    serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n    return out.getvalue()\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/django/django/db/backends/base/creation.py lines 77-78)": [
      "\n        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n            self.connection._test_serialized_contents = self.serialize_db_to_string()\n",
      "\n        # We then serialize the current state of the database into a string\n        # and store it on the connection. This slightly horrific process is so people\n        # who are testing on databases without transactions or who are using\n        # a TransactionTestCase still get a clean database on every test run.\n        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n            self.connection._test_serialized_contents = self.serialize_db_to_string()\n",
      "\n        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n            self.connection._test_serialized_contents = self.serialize_db_to_string()\n",
      "\n        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n            self.connection._test_serialized_contents = self.serialize_db_to_string()\n",
      "\n        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n            self.connection._test_serialized_contents = self.serialize_db_to_string()\n",
      "\n        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n            self.connection._test_serialized_contents = self.serialize_db_to_string()\n",
      "\n        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n            self.connection._test_serialized_contents = self.serialize_db_to_string()\n",
      "\n        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n            self.connection._test_serialized_contents = self.serialize_db_to_string()\n"
    ],
    "Location 2 (/root/hy/projects_2/django/django/db/backends/base/creation.py lines 61-71)": [
      "\n        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n            self.connection._test_serialized_contents = self.serialize_db_to_string()\n",
      "\n        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n            self.connection._test_serialized_contents = self.serialize_db_to_string()\n",
      "\n        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n            self.connection._test_serialized_contents = self.serialize_db_to_string()\n",
      "\n        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n            self.connection._test_serialized_contents = self.serialize_db_to_string()\n",
      "\n        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n            self.connection._test_serialized_contents = self.serialize_db_to_string()\n",
      "\n        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n            self.connection._test_serialized_contents = self.serialize_db_to_string()\n",
      "\n        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n            self.connection._test_serialized_contents = self.serialize_db_to_string()\n",
      "\n        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n            self.connection._test_serialized_contents = self.serialize_db_to_string()\n"
    ],
    "Location 3 (/root/hy/projects_2/django/django/db/backends/base/creation.py lines 115-118)": [
      "\n        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n            self.connection._test_serialized_contents = self.serialize_db_to_string()\n",
      "\n        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n            self.connection._test_serialized_contents = self.serialize_db_to_string()\n",
      "\n        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n            self.connection._test_serialized_contents = self.serialize_db_to_string()\n",
      "\n        # Serialize the database if requested\n        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n            self.connection._test_serialized_contents = self.serialize_db_to_string()\n",
      "\n        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n            self.connection._test_serialized_contents = self.serialize_db_to_string()\n",
      "\n        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n            self.connection._test_serialized_contents = self.serialize_db_to_string()\n",
      "\n        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n            self.connection._test_serialized_contents = self.serialize_db_to_string()\n",
      "\n                if (\n                    app_config.models_module is not None and\n                    app_config.label in loader.migrated_apps and\n                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n                ):\n                    for model in app_config.get_models():\n                        if (\n                            model._meta.can_migrate(self.connection) and\n                            router.allow_migrate_model(self.connection.alias, model)\n                        ):\n                            try:\n                                queryset = model._default_manager.using(\n                                    self.connection.alias,\n                                ).order_by(model._meta.pk.name)\n                                yield from queryset.iterator()\n                            except Exception:\n                                # Skip models whose tables don't exist (e.g., when MIGRATE=False)\n                                continue\n"
    ],
    "Location 4 (/root/hy/projects_2/django/django/db/backends/base/creation.py lines 100-122)": [
      "\n    def create_test_db(self, verbosity=1, autoclobber=False, serialize=True, keepdb=False):\n        \"\"\"\n        Create a test database, prompting the user for confirmation if the\n        database already exists. Return the name of the test database created.\n        \"\"\"\n        # Don't import django.core.management if it isn't needed.\n        from django.core.management import call_command\n\n        test_database_name = self._get_test_db_name()\n\n        if verbosity >= 1:\n            action = 'Creating'\n            if keepdb:\n                action = 'Using existing'\n\n            print(f\"{action} test database for alias {self.connection.alias!r}...\")\n\n        # We could skip this call if keepdb is True, but we instead\n        # give it the keepdb param. This is to handle the case\n        # where the test DB doesn't exist, in which case we need to\n        # create it, then just not destroy it. If we instead skip\n        # this, we will get an exception.\n        self._create_test_db(test_database_name, verbosity, keepdb)\n\n        self.connection.close()\n        self.connection.settings_dict[\"NAME\"] = test_database_name\n        self.connection.ensure_connection()\n        self.connection.prepare_database()\n\n        # We report migrate messages at one level lower than that\n        # requested. This ensures we don't get flooded with messages during\n        # testing (unless you really ask to be flooded).\n        call_command(\n            'migrate',\n            verbosity=max(verbosity - 1, 0),\n            interactive=False,\n            database=self.connection.alias,\n            run_syncdb=True,\n        )\n\n        # We then serialize the current state of the database into a string\n        # and store it on the connection. This slightly horrific process is so people\n        # who are testing on databases without transactions or who are using\n        # a TransactionTestCase still get a clean database on every test run.\n        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n            self.connection._test_serialized_contents = self.serialize_db_to_string()\n\n        return test_database_name\n",
      "\n    def serialize_db_to_string(self):\n        \"\"\"\n        Serialize all data in the database into a JSON string.\n        Designed only for test runner usage; will not handle large\n        amounts of data.\n        \"\"\"\n        # Skip serialization if migrations weren't run\n        if not self.connection.settings_dict['TEST']['MIGRATE']:\n            return ''\n            \n        # Iteratively return every object for all models to serialize.\n        def get_objects():\n            from django.db.migrations.loader import MigrationLoader\n            loader = MigrationLoader(self.connection)\n            for app_config in apps.get_app_configs():\n                if (\n                    app_config.models_module is not None and\n                    app_config.label in loader.migrated_apps and\n                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n                ):\n                    for model in app_config.get_models():\n                        if (\n                            model._meta.can_migrate(self.connection) and\n                            router.allow_migrate_model(self.connection.alias, model)\n                        ):\n                            queryset = model._default_manager.using(\n                                self.connection.alias,\n                            ).order_by(model._meta.pk.name)\n                            yield from queryset.iterator()\n        # Serialize to a string\n        out = StringIO()\n        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n        return out.getvalue()\n",
      "\n    def _create_test_db(self, verbosity, autoclobber, keepdb=False):\n        \"\"\"\n        Internal implementation - create the test db tables.\n        \"\"\"\n        test_database_name = self._get_test_db_name()\n        test_db_params = {\n            'dbname': self.connection.ops.quote_name(test_database_name),\n        }\n        # Create the test database and connect to it.\n        with self._nodb_cursor() as cursor:\n            try:\n                self._execute_create_test_db(cursor, test_db_params, keepdb)\n            except Exception as e:\n                # if we want to keep the db, then no need to do any of the below,\n                # just return and skip it all.\n                if keepdb:\n                    return test_database_name\n                self.log('Got an error creating the test database: %s' % e)\n                if not autoclobber:\n                    confirm = input(\n                        \"Type 'yes' if you would like to try deleting the test \"\n                        \"database '%s', or 'no' to cancel: \" % test_database_name)\n                if autoclobber or confirm == 'yes':\n                    try:\n                        if verbosity >= 1:\n                            self.log('Destroying old test database for alias %s...' % (\n                                self.connection.alias,\n                            ))\n                        cursor.execute('DROP DATABASE %s' % test_db_params['dbname'])\n                        self._execute_create_test_db(cursor, test_db_params, keepdb)\n                    except Exception as e:\n                        self.log('Got an error recreating the test database: %s' % e)\n                        sys.exit(2)\n                else:\n                    self.log('Tests cancelled.')\n                    sys.exit(1)\n\n        return test_database_name\n\n    def _clone_test_db(self, suffix, verbosity, keepdb=False):\n        \"\"\"\n        Clone a test database.\n        \"\"\"\n        source_database_name = self.connection.settings_dict['NAME']\n        target_database_name = self.get_test_db_clone_settings(suffix)['NAME']\n        test_db_params = {\n            'dbname': self.connection.ops.quote_name(target_database_name),\n            'suffix': suffix,\n        }\n        with self._nodb_cursor() as cursor:\n            try:\n                self._clone_db(cursor, source_database_name, target_database_name)\n            except Exception as e:\n                if keepdb:\n                    return\n                self.log('Got an error cloning the test database: %s' % e)\n                sys.exit(2)\n\n    def destroy_test_db(self, old_database_name, verbosity=1, keepdb=False, suffix=None):\n        \"\"\"\n        Destroy a test database, prompting the user for confirmation if the\n        database already exists.\n        \"\"\"\n        self.connection.close()\n        if suffix is None:\n            test_database_name = self.connection.settings_dict['NAME']\n        else:\n            test_database_name = self.get_test_db_clone_settings(suffix)['NAME']\n\n        if verbosity >= 1:\n            action = 'Destroying'\n            if keepdb:\n                action = 'Preserving'\n            self.log('%s test database for alias %s...' % (action, self.connection.alias))\n\n        # Temporarily use a new connection and a database that exists.\n        # Note that if the database we're trying to delete doesn't exist, a\n        # database error will be raised, but that's OK because Django doesn't\n        # consider that an error and will skip the destroy.\n        settings_dict = self.connection.settings_dict.copy()\n        settings_dict['NAME'] = old_database_name\n        backend = load_backend(settings_dict['ENGINE'])\n        new_connection = backend.DatabaseWrapper(\n            settings_dict,\n            alias=self.connection.alias,\n        )\n        new_connection.connect()\n        self.set_as_test_mirror(new_connection.settings_dict)\n\n        # We could be attempting to run on a database that doesn't exist, so\n        # check if it exists at all first.\n        if new_connection.introspection.get_table_list(new_connection.cursor()):\n            # If we get here then we have a working database connection, which\n            # means the database exists. Don't destroy it if we're told not to.\n            if keepdb:\n                return\n            if not autoclobber:\n                confirm = input(\n                    \"Type 'yes' if you would like to try deleting the test \"\n                    \"database '%s', or 'no' to cancel: \" % test_database_name)\n            if autoclobber or confirm == 'yes':\n                try:\n                    if verbosity >= 1:\n                        self.log('Destroying old test database for alias %s...' % (\n                            self.connection.alias,\n                        ))\n                    new_connection.ops.destroy_test_db(test_database_name, verbosity)\n                except Exception as e:\n                    self.log('Got an error destroying the old test database: %s' % e)\n                    sys.exit(2)\n            else:\n                self.log(\"Tests cancelled -- test database cannot be recreated.\")\n                sys.exit(1)\n        else:\n            self.log(\"Test database doesn't appear to exist. Skipping teardown.\")\n\n    def serialize_db_to_string(self):\n        \"\"\"\n        Serialize all data in the database into a JSON string.\n        Designed only for test runner usage; will not handle large\n        amounts of data.\n        \"\"\"\n        # Skip serialization if migrations weren't run\n        if not self.connection.settings_dict['TEST']['MIGRATE']:\n            return ''\n        \n        # Iteratively return every object for all models to serialize.\n        def get_objects():\n            from django.db.migrations.loader import MigrationLoader\n            loader = MigrationLoader(self.connection)\n            for app_config in apps.get_app_configs():\n                if (\n                    app_config.models_module is not None and\n                    app_config.label in loader.migrated_apps and\n                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n                ):\n                    for model in app_config.get_models():\n                        if (\n                            model._meta.can_migrate(self.connection) and\n                            router.allow_migrate_model(self.connection.alias, model)\n                        ):\n                            queryset = model._default_manager.using(\n                                self.connection.alias,\n                            ).order_by(model._meta.pk.name)\n                            yield from queryset.iterator()\n        # Serialize to a string\n        out = StringIO()\n        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n        return out.getvalue()\n",
      "\n    def _create_test_db(self, verbosity, autoclobber, keepdb=False):\n        \"\"\"\n        Internal implementation - create the test db tables.\n        \"\"\"\n        test_database_name = self._get_test_db_name()\n        test_db_params = {\n            'dbname': self.connection.ops.quote_name(test_database_name),\n            'suffix': self.sql_table_creation_suffix(),\n        }\n        # Create the test database and connect to it.\n        with self._nodb_cursor() as cursor:\n            try:\n                self._execute_create_test_db(cursor, test_db_params, keepdb)\n            except Exception as e:\n                # if we want to keep the db, then no need to do any of the below,\n                # just return and skip it all.\n                if keepdb:\n                    return test_database_name\n                self.log('Got an error creating the test database: %s' % e)\n                if not autoclobber:\n                    confirm = input(\n                        \"Type 'yes' if you would like to try deleting the test \"\n                        \"database '%s', or 'no' to cancel: \" % test_database_name)\n                if autoclobber or confirm == 'yes':\n                    try:\n                        if verbosity >= 1:\n                            self.log('Destroying old test database for alias %s...' % (\n                                self.connection.alias,\n                            ))\n                        cursor.execute('DROP DATABASE %(dbname)s' % test_db_params)\n                        self._execute_create_test_db(cursor, test_db_params, keepdb)\n                    except Exception as e:\n                        self.log('Got an error recreating the test database: %s' % e)\n                        sys.exit(2)\n                else:\n                    self.log('Tests cancelled.')\n                    sys.exit(1)\n\n        return test_database_name\n\n    def _clone_test_db(self, suffix, verbosity, keepdb=False):\n        \"\"\"\n        Clone a test database.\n        \"\"\"\n        source_database_name = self.connection.settings_dict['NAME']\n        target_database_name = self.get_test_db_clone_settings(suffix)['NAME']\n        test_db_params = {\n            'dbname': self.connection.ops.quote_name(target_database_name),\n            'suffix': self.sql_table_creation_suffix(),\n        }\n        with self._nodb_cursor() as cursor:\n            try:\n                self._execute_create_test_db(cursor, test_db_params, keepdb)\n            except Exception:\n                if keepdb:\n                    return\n                raise\n\n        # Skip cloning if migrations weren't run\n        if not self.connection.settings_dict['TEST']['MIGRATE']:\n            return\n\n        self.connection.ops.clone_test_database(\n            suffix, verbosity, autoclobber=not keepdb\n        )\n\n    def _get_database_display_str(self, verbosity, test_database_name):\n        \"\"\"\n        Return display string for a database for use in various actions.\n        \"\"\"\n        return \"'%s'%s\" % (\n            self.connection.alias,\n            (\" ('%s')\" % test_database_name) if verbosity >= 2 else '',\n        )\n\n    def _get_test_db_name(self):\n        \"\"\"\n        Internal implementation - return the name of the test DB that will be\n        created. Only useful when called from create_test_db() and\n        _create_test_db() and when no external munging is done with the 'NAME'\n        settings.\n        \"\"\"\n        if self.connection.settings_dict['TEST']['NAME']:\n            return self.connection.settings_dict['TEST']['NAME']\n        return TEST_DATABASE_PREFIX + self.connection.settings_dict['NAME']\n\n    def _execute_create_test_db(self, cursor, parameters, keepdb=False):\n        cursor.execute('CREATE DATABASE %(dbname)s %(suffix)s' % parameters)\n\n    def _destroy_test_db(self, test_database_name, verbosity):\n        \"\"\"\n        Internal implementation - remove the test db tables.\n        \"\"\"\n        # Remove the test database to clean up after\n        # ourselves. Connect to the previous database (not the test database)\n        # to do so, because it's not allowed to delete a database while being\n        # connected to it.\n        with self._nodb_cursor() as cursor:\n            cursor.execute(\"DROP DATABASE %s\"\n                           % self.connection.ops.quote_name(test_database_name))\n\n    def sql_table_creation_suffix(self):\n        \"\"\"\n        SQL to append to the end of the test table creation statements.\n        \"\"\"\n        return ''\n\n    def setup_test_db(self, verbosity=1, autoclobber=False, serialize=True, keepdb=False):\n        \"\"\"\n        Create a test database, prompting the user for confirmation if the\n        database already exists. Return the name of the test database created.\n        \"\"\"\n        # Don't import django.core.management if it isn't needed.\n        from django.core.management import call_command\n\n        test_database_name = self._get_test_db_name()\n\n        if verbosity >= 1:\n            action = 'Creating'\n            if keepdb:\n                action = 'Using existing'\n\n            self.log('%s test database for alias %s...' % (\n                action,\n                self._get_database_display_str(verbosity, test_database_name),\n            ))\n\n        # We could skip this call if keepdb is True, but we instead\n        # give it the keepdb param. This is to handle the case\n        # where the test DB doesn't exist, in which case we need to\n        # create it, then just not destroy it. If we instead skip\n        # this, we will get an exception.\n        self._create_test_db(verbosity, autoclobber, keepdb)\n\n        self.connection.close()\n        settings.DATABASES[self.connection.alias][\"NAME\"] = test_database_name\n        self.connection.settings_dict[\"NAME\"] = test_database_name\n\n        if self.connection.settings_dict['TEST']['MIGRATE']:\n            # We report migrate messages at one level lower than that\n            # requested. This ensures we don't get flooded with messages during\n            # testing (unless you really ask to be flooded).\n            call_command(\n                'migrate',\n                verbosity=max(verbosity - 1, 0),\n                interactive=False,\n                database=self.connection.alias,\n                run_syncdb=True,\n            )\n\n        # We then serialize the current state of the database into a string\n        # and store it on the connection. This slightly horrific process is so people\n        # who are testing on databases without transactions or who are using\n        # a TransactionTestCase still get a clean database on every test run.\n        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n            self.connection._test_serialized_contents = self.serialize_db_to_string()\n\n        call_command('createcachetable', database=self.connection.alias)\n\n        # Ensure a connection for the side effect of initializing the test\n        # database.\n        self.connection.ensure_connection()\n\n        return test_database_name\n\n    def setup_worker_connection(self, primary_settings_dict):\n        \"\"\"\n        Clone a database and set up this test to use it.\n\n        This method is used by the primary/worker mechanism during parallel\n        testing.\n        \"\"\"\n        database_name = primary_settings_dict['NAME']\n        if not database_name.startswith(TEST_DATABASE_PREFIX):\n            raise Exception(\n                \"When using the --parallel option, the database name '%s' \"\n                \"must be prefixed with '%s'.\" % (\n                    database_name, TEST_DATABASE_PREFIX,\n                )\n            )\n        # We need to make a deepcopy of the settings_dict because\n        # setup_test_db modifies its 'NAME' value.\n        settings_dict = copy.deepcopy(self.connection.settings_dict)\n        settings_dict['NAME'] = primary_settings_dict['NAME']\n        self.connection.settings_dict = settings_dict\n        # Record the connection's previous database name\n        previous_database_name = self.connection.settings_dict['NAME']\n        # Create a test database name by cloning the primary database.\n        clone_suffix = str(os.getpid())\n        self._clone_test_db(clone_suffix, verbosity=0, keepdb=True)\n        # Set this database connection's name to the cloned database.\n        self.connection.settings_dict['NAME'] = self.get_test_db_clone_settings(clone_suffix)['NAME']\n        # Store the original database name so we can restore it later.\n        self.connection.settings_dict['NAME'] = previous_database_name\n\n    def get_test_db_clone_settings(self, suffix):\n        \"\"\"\n        Return a modified connection settings dict for the n-th clone of a DB.\n        \"\"\"\n        # When this function is called, the test database has been created\n        # already and its name has been copied to settings_dict['NAME'] so\n        # we don't need to call _get_test_db_name.\n        orig_settings_dict = self.connection.settings_dict\n        return {**orig_settings_dict, 'NAME': '{}_{}'.format(orig_settings_dict['NAME'], suffix)}\n\n    def set_as_test_mirror(self, primary_settings_dict):\n        \"\"\"\n        Set this database up to be used in testing as a mirror of a primary\n        database whose settings are given.\n        \"\"\"\n        self.connection.settings_dict['NAME'] = primary_settings_dict['NAME']\n\n    def serialize_db_to_string(self):\n        \"\"\"\n        Serialize all data in the database into a JSON string.\n        Designed only for test runner usage; will not handle large\n        amounts of data.\n        \"\"\"\n        # Iteratively return every object for all models to serialize.\n        def get_objects():\n            from django.db.migrations.loader import MigrationLoader\n            loader = MigrationLoader(self.connection)\n            for app_config in apps.get_app_configs():\n                if (\n                    app_config.models_module is not None and\n                    app_config.label in loader.migrated_apps and\n                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n                ):\n                    for model in app_config.get_models():\n                        if (\n                            model._meta.can_migrate(self.connection) and\n                            router.allow_migrate_model(self.connection.alias, model)\n                        ):\n                            queryset = model._default_manager.using(\n                                self.connection.alias,\n                            ).order_by(model._meta.pk.name)\n                            yield from queryset.iterator()\n        # Serialize to a string\n        out = StringIO()\n        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n        return out.getvalue()\n",
      "\ndef serialize_db_to_string(self):\n    \"\"\"\n    Serialize all data in the database into a JSON string.\n    Designed only for test runner usage; will not handle large\n    amounts of data.\n    \"\"\"\n    # Skip serialization if migrations weren't run\n    if not self.connection.settings_dict['TEST']['MIGRATE']:\n        return ''\n    \n    # Iteratively return every object for all models to serialize.\n    def get_objects():\n        from django.db.migrations.loader import MigrationLoader\n        loader = MigrationLoader(self.connection)\n        for app_config in apps.get_app_configs():\n            if (\n                app_config.models_module is not None and\n                app_config.label in loader.migrated_apps and\n                app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n            ):\n                for model in app_config.get_models():\n                    if (\n                        model._meta.can_migrate(self.connection) and\n                        router.allow_migrate_model(self.connection.alias, model)\n                    ):\n                        queryset = model._default_manager.using(\n                            self.connection.alias,\n                        ).order_by(model._meta.pk.name)\n                        yield from queryset.iterator()\n    # Serialize to a string\n    out = StringIO()\n    serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n    return out.getvalue()\n",
      "\n    def _create_test_db(self, verbosity, autoclobber, keepdb=False):\n        \"\"\"\n        Internal implementation - create the test db tables.\n        \"\"\"\n        test_database_name = self._get_test_db_name()\n        test_db_params = {\n            'dbname': self.connection.ops.quote_name(test_database_name),\n            'suffix': self.sql_table_creation_suffix(),\n        }\n        # Create the test database and connect to it.\n        with self._nodb_cursor() as cursor:\n            try:\n                self._execute_create_test_db(cursor, test_db_params, keepdb)\n            except Exception as e:\n                # if we want to keep the db, then no need to do any of the below,\n                # just return and skip it all.\n                if keepdb:\n                    return test_database_name\n                self.log('Got an error creating the test database: %s' % e)\n                if not autoclobber:\n                    confirm = input(\n                        \"Type 'yes' if you would like to try deleting the test \"\n                        \"database '%s', or 'no' to cancel: \" % test_database_name)\n                if autoclobber or confirm == 'yes':\n                    try:\n                        if verbosity >= 1:\n                            self.log('Destroying old test database for alias %s...' % (\n                                self.connection.alias,\n                            ))\n                        cursor.execute('DROP DATABASE %(dbname)s' % test_db_params)\n                        self._execute_create_test_db(cursor, test_db_params, keepdb)\n                    except Exception as e:\n                        self.log('Got an error recreating the test database: %s' % e)\n                        sys.exit(2)\n                else:\n                    self.log('Tests cancelled.')\n                    sys.exit(1)\n\n        return test_database_name\n\n    def _clone_test_db(self, suffix, verbosity, keepdb=False):\n        \"\"\"\n        Internal implementation - duplicate the test db tables.\n        \"\"\"\n        source_database_name = self.connection.settings_dict['NAME']\n        target_database_name = self.get_test_db_clone_settings(suffix)['NAME']\n        test_db_params = {\n            'dbname': self.connection.ops.quote_name(target_database_name),\n            'suffix': self.sql_table_creation_suffix(),\n        }\n        with self._nodb_cursor() as cursor:\n            try:\n                self._execute_create_test_db(cursor, test_db_params, keepdb)\n            except Exception:\n                if keepdb:\n                    return\n                raise\n\n        # Migrate the test database.\n        call_command(\n            'migrate',\n            verbosity=max(verbosity - 1, 0),\n            interactive=False,\n            database=self.connection.alias,\n            run_syncdb=True,\n        )\n\n        # Copy the data from the original database.\n        if self.connection.settings_dict['TEST'].get('MIGRATE', True):\n            # Don't import django.core.management if it isn't needed.\n            from django.core.management import call_command\n            call_command(\n                'loaddata',\n                self.connection._test_serialized_contents,\n                verbosity=0,\n                database=self.connection.alias,\n            )\n\n    def setup_test_environment(self, **kwargs):\n        pass\n\n    def teardown_test_environment(self, **kwargs):\n        pass\n\n    def set_as_test_mirror(self, primary_settings_dict):\n        \"\"\"\n        Set this database up to be used in testing as a mirror of a primary\n        database whose settings are given.\n        \"\"\"\n        self.connection.settings_dict['NAME'] = primary_settings_dict['NAME']\n\n    def serialize_db_to_string(self):\n        \"\"\"\n        Serialize all data in the database into a JSON string.\n        Designed only for test runner usage; will not handle large\n        amounts of data.\n        \"\"\"\n        # Skip serialization if migrations weren't run\n        if not self.connection.settings_dict['TEST'].get('MIGRATE', True):\n            return ''\n            \n        # Iteratively return every object for all models to serialize.\n        def get_objects():\n            from django.db.migrations.loader import MigrationLoader\n            loader = MigrationLoader(self.connection)\n            for app_config in apps.get_app_configs():\n                if (\n                    app_config.models_module is not None and\n                    app_config.label in loader.migrated_apps and\n                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n                ):\n                    for model in app_config.get_models():\n                        if (\n                            model._meta.can_migrate(self.connection) and\n                            router.allow_migrate_model(self.connection.alias, model)\n                        ):\n                            queryset = model._default_manager.using(\n                                self.connection.alias,\n                            ).order_by(model._meta.pk.name)\n                            yield from queryset.iterator()\n        # Serialize to a string\n        out = StringIO()\n        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n        return out.getvalue()\n",
      "\n    def serialize_db_to_string(self):\n        \"\"\"\n        Serialize all data in the database into a JSON string.\n        Designed only for test runner usage; will not handle large\n        amounts of data.\n        \"\"\"\n        # Skip serialization if migrations weren't run\n        if not self.connection.settings_dict['TEST']['MIGRATE']:\n            return ''\n        \n        # Iteratively return every object for all models to serialize.\n        def get_objects():\n            from django.db.migrations.loader import MigrationLoader\n            loader = MigrationLoader(self.connection)\n            for app_config in apps.get_app_configs():\n                if (\n                    app_config.models_module is not None and\n                    app_config.label in loader.migrated_apps and\n                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n                ):\n                    for model in app_config.get_models():\n                        if (\n                            model._meta.can_migrate(self.connection) and\n                            router.allow_migrate_model(self.connection.alias, model)\n                        ):\n                            queryset = model._default_manager.using(\n                                self.connection.alias,\n                            ).order_by(model._meta.pk.name)\n                            yield from queryset.iterator()\n        # Serialize to a string\n        out = StringIO()\n        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n        return out.getvalue()\n",
      "\n    def _create_test_db(self, verbosity, autoclobber, keepdb=False):\n        \"\"\"\n        Internal implementation - create the test db tables.\n        \"\"\"\n        test_database_name = self._get_test_db_name()\n        test_db_params = {\n            'dbname': self.connection.ops.quote_name(test_database_name),\n        }\n        # Create the test database and connect to it.\n        with self._nodb_cursor() as cursor:\n            try:\n                self._execute_create_test_db(cursor, test_db_params, keepdb)\n            except Exception as e:\n                # if we want to keep the db, then no need to do any of the below,\n                # just return and skip it all.\n                if keepdb:\n                    return test_database_name\n                self.log('Got an error creating the test database: %s' % e)\n                if not autoclobber:\n                    confirm = input(\n                        \"Type 'yes' if you would like to try deleting the test \"\n                        \"database '%s', or 'no' to cancel: \" % test_database_name\n                    )\n                if autoclobber or confirm == 'yes':\n                    try:\n                        if verbosity >= 1:\n                            self.log('Destroying old test database for alias %s...' % (\n                                self.connection.alias,\n                            ))\n                        cursor.execute('DROP DATABASE %(dbname)s' % test_db_params)\n                        self._execute_create_test_db(cursor, test_db_params, keepdb)\n                    except Exception as e:\n                        self.log('Got an error recreating the test database: %s' % e)\n                        sys.exit(2)\n                else:\n                    self.log('Tests cancelled.')\n                    sys.exit(1)\n\n        return test_database_name\n\n    def _clone_test_db(self, suffix, verbosity, keepdb=False):\n        \"\"\"\n        Clone a test database.\n        \"\"\"\n        source_database_name = self.connection.settings_dict['NAME']\n        target_database_name = self.get_test_db_clone_settings(suffix)['NAME']\n        test_db_params = {\n            'dbname': self.connection.ops.quote_name(target_database_name),\n            'source_dbname': self.connection.ops.quote_name(source_database_name),\n        }\n        with self._nodb_cursor() as cursor:\n            try:\n                self._execute_create_test_db(cursor, test_db_params, keepdb)\n            except Exception:\n                if keepdb:\n                    # If the database should be kept, skip the error.\n                    return\n                raise\n        # Record the connection's database name\n        self.connection.settings_dict['NAME'] = target_database_name\n\n    def destroy_test_db(self, old_database_name, verbosity=1, keepdb=False, suffix=None):\n        \"\"\"\n        Destroy a test database, prompting the user for confirmation if the\n        database already exists.\n        \"\"\"\n        self.connection.close()\n        if suffix is None:\n            test_database_name = self.connection.settings_dict['NAME']\n        else:\n            test_database_name = self.get_test_db_clone_settings(suffix)['NAME']\n\n        if verbosity >= 1:\n            action = 'Destroying'\n            if keepdb:\n                action = 'Preserving'\n            self.log('%s test database for alias %s...' % (\n                action,\n                self.connection.alias[:-len(suffix)] if suffix else self.connection.alias,\n            ))\n\n        # if we want to preserve the database\n        # skip the actual destroying piece.\n        if not keepdb:\n            self._destroy_test_db(test_database_name, verbosity)\n\n        # Restore the original database name\n        self.connection.settings_dict['NAME'] = old_database_name\n\n    def sql_table_creation_suffix(self):\n        \"\"\"\n        SQL to append to the end of the test table creation statements.\n        \"\"\"\n        return ''\n\n    def test_db_signature(self):\n        \"\"\"\n        Return a tuple with elements of self.connection.settings_dict (a\n        DATABASES setting value) that uniquely identify a database\n        accordingly to the RDBMS particularities.\n        \"\"\"\n        settings_dict = self.connection.settings_dict\n        return (\n            settings_dict['HOST'],\n            settings_dict['PORT'],\n            settings_dict['ENGINE'],\n            settings_dict['NAME']\n        )\n\n    def setup_worker_connection(self, _worker_id):\n        \"\"\"\n        Set up the database connection for a worker in a multi-processing context.\n        \"\"\"\n        settings_dict = self.connection.settings_dict\n        if settings_dict['TEST']['MIGRATE']:\n            # Ensure each worker gets a separate database.\n            settings_dict['NAME'] = '{}_{}'.format(\n                settings_dict['NAME'],\n                _worker_id,\n            )\n\n    def mark_expected_failures_and_skips(self):\n        \"\"\"\n        Mark tests in the test suite that are expected to fail on this database.\n        \"\"\"\n        for test_name in self.connection.features.django_test_expected_failures:\n            test_case_name, _, test_method_name = test_name.rpartition('.')\n            test_app = test_name.split('.')[0]\n            # Importing here to avoid problems with circular imports\n            test_module = __import__(test_app + '.tests', fromlist=[''])\n            test_class = getattr(test_module, test_case_name.split('.')[-1])\n            test_method = getattr(test_class, test_method_name)\n            test_method = expectedFailure(test_method)\n            setattr(test_class, test_method_name, test_method)\n\n        for test_name in self.connection.features.django_test_skips:\n            test_case_name, _, test_method_name = test_name.rpartition('.')\n            test_app = test_name.split('.')[0]\n            # Importing here to avoid problems with circular imports\n            test_module = __import__(test_app + '.tests', fromlist=[''])\n            test_class = getattr(test_module, test_case_name.split('.')[-1])\n            test_method = getattr(test_class, test_method_name)\n            test_method = skip('contains expected failures')(test_method)\n            setattr(test_class, test_method_name, test_method)\n\n    def setup_worker_connection(self, _worker_id):\n        \"\"\"\n        Set up the database connection for a worker in a multi-processing context.\n        \"\"\"\n        settings_dict = self.connection.settings_dict\n        if settings_dict['TEST']['MIGRATE']:\n            # Ensure each worker gets a separate database.\n            settings_dict['NAME'] = '{}_{}'.format(\n                settings_dict['NAME'],\n                _worker_id,\n            )\n\n    def _copy_primary_database_settings(self, primary_settings_dict):\n        \"\"\"\n        Copy the primary database settings to the test database settings.\n        \"\"\"\n        self.connection.settings_dict['NAME'] = primary_settings_dict['NAME']\n\n    def serialize_db_to_string(self):\n        \"\"\"\n        Serialize all data in the database into a JSON string.\n        Designed only for test runner usage; will not handle large\n        amounts of data.\n        \"\"\"\n        # Skip serialization if migrations weren't run\n        if not self.connection.settings_dict['TEST']['MIGRATE']:\n            return ''\n        \n        # Iteratively return every object for all models to serialize.\n        def get_objects():\n            loader = MigrationLoader(self.connection)\n            for app_config in apps.get_app_configs():\n                if (\n                    app_config.models_module is not None and\n                    app_config.label in loader.migrated_apps and\n                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n                ):\n                    for model in app_config.get_models():\n                        if (\n                            model._meta.can_migrate(self.connection) and\n                            router.allow_migrate_model(self.connection.alias, model)\n                        ):\n                            queryset = model._default_manager.using(\n                                self.connection.alias,\n                            ).order_by(model._meta.pk.name)\n                            yield from queryset.iterator()\n        # Serialize to a string\n        out = StringIO()\n        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n        return out.getvalue()\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/backends/base/creation.py b/django/db/backends/base/creation.py\nindex 503f7f56fd..7c4fd99741 100644\n--- a/django/db/backends/base/creation.py\n+++ b/django/db/backends/base/creation.py\n@@ -58,6 +58,7 @@ class BaseDatabaseCreation:\n         settings.DATABASES[self.connection.alias][\"NAME\"] = test_database_name\n         self.connection.settings_dict[\"NAME\"] = test_database_name\n \n+\n         if self.connection.settings_dict['TEST']['MIGRATE']:\n             # We report migrate messages at one level lower than that\n             # requested. This ensures we don't get flooded with messages during\n@@ -74,7 +75,8 @@ class BaseDatabaseCreation:\n         # and store it on the connection. This slightly horrific process is so people\n         # who are testing on databases without transactions or who are using\n         # a TransactionTestCase still get a clean database on every test run.\n-        if serialize:\n+\n+        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n             self.connection._test_serialized_contents = self.serialize_db_to_string()\n \n         call_command('createcachetable', database=self.connection.alias)\n@@ -97,6 +99,11 @@ class BaseDatabaseCreation:\n         Designed only for test runner usage; will not handle large\n         amounts of data.\n         \"\"\"\n+\n+        # Skip serialization if migrations weren't run\n+        if not self.connection.settings_dict['TEST']['MIGRATE']:\n+            return ''\n+        \n         # Iteratively return every object for all models to serialize.\n         def get_objects():\n             from django.db.migrations.loader import MigrationLoader\n@@ -112,10 +119,19 @@ class BaseDatabaseCreation:\n                             model._meta.can_migrate(self.connection) and\n                             router.allow_migrate_model(self.connection.alias, model)\n                         ):\n-                            queryset = model._default_manager.using(\n-                                self.connection.alias,\n-                            ).order_by(model._meta.pk.name)\n-                            yield from queryset.iterator()\n+                            try:\n+                                queryset = model._default_manager.using(\n+                                    self.connection.alias,\n+                                ).order_by(model._meta.pk.name)\n+                                yield from queryset.iterator()\n+                            except Exception:\n+                                # Skip models whose tables don't exist (e.g., when MIGRATE=False)\n+                                continue\n+        # Serialize to a string\n+        out = StringIO()\n+        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n+        return out.getvalue()\n+                                continue\n         # Serialize to a string\n         out = StringIO()\n         serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n",
    "variant_0": "diff --git a/django/db/backends/base/creation.py b/django/db/backends/base/creation.py\nindex 503f7f56fd..544fc25a11 100644\n--- a/django/db/backends/base/creation.py\n+++ b/django/db/backends/base/creation.py\n@@ -58,23 +58,16 @@ class BaseDatabaseCreation:\n         settings.DATABASES[self.connection.alias][\"NAME\"] = test_database_name\n         self.connection.settings_dict[\"NAME\"] = test_database_name\n \n-        if self.connection.settings_dict['TEST']['MIGRATE']:\n-            # We report migrate messages at one level lower than that\n-            # requested. This ensures we don't get flooded with messages during\n-            # testing (unless you really ask to be flooded).\n-            call_command(\n-                'migrate',\n-                verbosity=max(verbosity - 1, 0),\n-                interactive=False,\n-                database=self.connection.alias,\n-                run_syncdb=True,\n-            )\n+\n+        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n+            self.connection._test_serialized_contents = self.serialize_db_to_string()\n \n         # We then serialize the current state of the database into a string\n         # and store it on the connection. This slightly horrific process is so people\n         # who are testing on databases without transactions or who are using\n         # a TransactionTestCase still get a clean database on every test run.\n-        if serialize:\n+\n+        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n             self.connection._test_serialized_contents = self.serialize_db_to_string()\n \n         call_command('createcachetable', database=self.connection.alias)\n@@ -97,30 +90,40 @@ class BaseDatabaseCreation:\n         Designed only for test runner usage; will not handle large\n         amounts of data.\n         \"\"\"\n-        # Iteratively return every object for all models to serialize.\n-        def get_objects():\n-            from django.db.migrations.loader import MigrationLoader\n-            loader = MigrationLoader(self.connection)\n-            for app_config in apps.get_app_configs():\n-                if (\n-                    app_config.models_module is not None and\n-                    app_config.label in loader.migrated_apps and\n-                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n-                ):\n-                    for model in app_config.get_models():\n-                        if (\n-                            model._meta.can_migrate(self.connection) and\n-                            router.allow_migrate_model(self.connection.alias, model)\n-                        ):\n-                            queryset = model._default_manager.using(\n-                                self.connection.alias,\n-                            ).order_by(model._meta.pk.name)\n-                            yield from queryset.iterator()\n-        # Serialize to a string\n-        out = StringIO()\n-        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n-        return out.getvalue()\n \n+def serialize_db_to_string(self):\n+    \"\"\"\n+    Serialize all data in the database into a JSON string.\n+    Designed only for test runner usage; will not handle large\n+    amounts of data.\n+    \"\"\"\n+    # Skip serialization if migrations weren't run\n+    if not self.connection.settings_dict['TEST']['MIGRATE']:\n+        return ''\n+    \n+    # Iteratively return every object for all models to serialize.\n+    def get_objects():\n+        from django.db.migrations.loader import MigrationLoader\n+        loader = MigrationLoader(self.connection)\n+        for app_config in apps.get_app_configs():\n+            if (\n+                app_config.models_module is not None and\n+                app_config.label in loader.migrated_apps and\n+                app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n+            ):\n+                for model in app_config.get_models():\n+                    if (\n+                        model._meta.can_migrate(self.connection) and\n+                        router.allow_migrate_model(self.connection.alias, model)\n+                    ):\n+                        queryset = model._default_manager.using(\n+                            self.connection.alias,\n+                        ).order_by(model._meta.pk.name)\n+                        yield from queryset.iterator()\n+    # Serialize to a string\n+    out = StringIO()\n+    serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n+    return out.getvalue()\n     def deserialize_db_from_string(self, data):\n         \"\"\"\n         Reload the database with data from a string generated by\n",
    "variant_1": "diff --git a/django/db/backends/base/creation.py b/django/db/backends/base/creation.py\nindex 503f7f56fd..c41524b4de 100644\n--- a/django/db/backends/base/creation.py\n+++ b/django/db/backends/base/creation.py\n@@ -58,23 +58,16 @@ class BaseDatabaseCreation:\n         settings.DATABASES[self.connection.alias][\"NAME\"] = test_database_name\n         self.connection.settings_dict[\"NAME\"] = test_database_name\n \n-        if self.connection.settings_dict['TEST']['MIGRATE']:\n-            # We report migrate messages at one level lower than that\n-            # requested. This ensures we don't get flooded with messages during\n-            # testing (unless you really ask to be flooded).\n-            call_command(\n-                'migrate',\n-                verbosity=max(verbosity - 1, 0),\n-                interactive=False,\n-                database=self.connection.alias,\n-                run_syncdb=True,\n-            )\n+\n+        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n+            self.connection._test_serialized_contents = self.serialize_db_to_string()\n \n         # We then serialize the current state of the database into a string\n         # and store it on the connection. This slightly horrific process is so people\n         # who are testing on databases without transactions or who are using\n         # a TransactionTestCase still get a clean database on every test run.\n-        if serialize:\n+\n+        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n             self.connection._test_serialized_contents = self.serialize_db_to_string()\n \n         call_command('createcachetable', database=self.connection.alias)\n@@ -97,30 +90,55 @@ class BaseDatabaseCreation:\n         Designed only for test runner usage; will not handle large\n         amounts of data.\n         \"\"\"\n-        # Iteratively return every object for all models to serialize.\n-        def get_objects():\n-            from django.db.migrations.loader import MigrationLoader\n-            loader = MigrationLoader(self.connection)\n-            for app_config in apps.get_app_configs():\n-                if (\n-                    app_config.models_module is not None and\n-                    app_config.label in loader.migrated_apps and\n-                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n-                ):\n-                    for model in app_config.get_models():\n-                        if (\n-                            model._meta.can_migrate(self.connection) and\n-                            router.allow_migrate_model(self.connection.alias, model)\n-                        ):\n-                            queryset = model._default_manager.using(\n-                                self.connection.alias,\n-                            ).order_by(model._meta.pk.name)\n-                            yield from queryset.iterator()\n-        # Serialize to a string\n-        out = StringIO()\n-        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n-        return out.getvalue()\n \n+    def create_test_db(self, verbosity=1, autoclobber=False, serialize=True, keepdb=False):\n+        \"\"\"\n+        Create a test database, prompting the user for confirmation if the\n+        database already exists. Return the name of the test database created.\n+        \"\"\"\n+        # Don't import django.core.management if it isn't needed.\n+        from django.core.management import call_command\n+\n+        test_database_name = self._get_test_db_name()\n+\n+        if verbosity >= 1:\n+            action = 'Creating'\n+            if keepdb:\n+                action = 'Using existing'\n+\n+            print(f\"{action} test database for alias {self.connection.alias!r}...\")\n+\n+        # We could skip this call if keepdb is True, but we instead\n+        # give it the keepdb param. This is to handle the case\n+        # where the test DB doesn't exist, in which case we need to\n+        # create it, then just not destroy it. If we instead skip\n+        # this, we will get an exception.\n+        self._create_test_db(test_database_name, verbosity, keepdb)\n+\n+        self.connection.close()\n+        self.connection.settings_dict[\"NAME\"] = test_database_name\n+        self.connection.ensure_connection()\n+        self.connection.prepare_database()\n+\n+        # We report migrate messages at one level lower than that\n+        # requested. This ensures we don't get flooded with messages during\n+        # testing (unless you really ask to be flooded).\n+        call_command(\n+            'migrate',\n+            verbosity=max(verbosity - 1, 0),\n+            interactive=False,\n+            database=self.connection.alias,\n+            run_syncdb=True,\n+        )\n+\n+        # We then serialize the current state of the database into a string\n+        # and store it on the connection. This slightly horrific process is so people\n+        # who are testing on databases without transactions or who are using\n+        # a TransactionTestCase still get a clean database on every test run.\n+        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n+            self.connection._test_serialized_contents = self.serialize_db_to_string()\n+\n+        return test_database_name\n     def deserialize_db_from_string(self, data):\n         \"\"\"\n         Reload the database with data from a string generated by\n",
    "variant_2": "diff --git a/django/db/backends/base/creation.py b/django/db/backends/base/creation.py\nindex 503f7f56fd..036f31d50d 100644\n--- a/django/db/backends/base/creation.py\n+++ b/django/db/backends/base/creation.py\n@@ -58,23 +58,20 @@ class BaseDatabaseCreation:\n         settings.DATABASES[self.connection.alias][\"NAME\"] = test_database_name\n         self.connection.settings_dict[\"NAME\"] = test_database_name\n \n-        if self.connection.settings_dict['TEST']['MIGRATE']:\n-            # We report migrate messages at one level lower than that\n-            # requested. This ensures we don't get flooded with messages during\n-            # testing (unless you really ask to be flooded).\n-            call_command(\n-                'migrate',\n-                verbosity=max(verbosity - 1, 0),\n-                interactive=False,\n-                database=self.connection.alias,\n-                run_syncdb=True,\n-            )\n+\n+        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n+            self.connection._test_serialized_contents = self.serialize_db_to_string()\n+\n+        # We then serialize the current state of the database into a string\n+        # and store it on the connection. This slightly horrific process is so people\n+        # who are testing on databases without transactions or who are using\n+        # a TransactionTestCase still get a clean database on every test run.\n \n         # We then serialize the current state of the database into a string\n         # and store it on the connection. This slightly horrific process is so people\n         # who are testing on databases without transactions or who are using\n         # a TransactionTestCase still get a clean database on every test run.\n-        if serialize:\n+        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n             self.connection._test_serialized_contents = self.serialize_db_to_string()\n \n         call_command('createcachetable', database=self.connection.alias)\n@@ -97,6 +94,17 @@ class BaseDatabaseCreation:\n         Designed only for test runner usage; will not handle large\n         amounts of data.\n         \"\"\"\n+\n+    def serialize_db_to_string(self):\n+        \"\"\"\n+        Serialize all data in the database into a JSON string.\n+        Designed only for test runner usage; will not handle large\n+        amounts of data.\n+        \"\"\"\n+        # Skip serialization if migrations weren't run\n+        if not self.connection.settings_dict['TEST']['MIGRATE']:\n+            return ''\n+            \n         # Iteratively return every object for all models to serialize.\n         def get_objects():\n             from django.db.migrations.loader import MigrationLoader\n@@ -120,7 +128,6 @@ class BaseDatabaseCreation:\n         out = StringIO()\n         serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n         return out.getvalue()\n-\n     def deserialize_db_from_string(self, data):\n         \"\"\"\n         Reload the database with data from a string generated by\n",
    "variant_3": "diff --git a/django/db/backends/base/creation.py b/django/db/backends/base/creation.py\nindex 503f7f56fd..03289ba494 100644\n--- a/django/db/backends/base/creation.py\n+++ b/django/db/backends/base/creation.py\n@@ -58,23 +58,16 @@ class BaseDatabaseCreation:\n         settings.DATABASES[self.connection.alias][\"NAME\"] = test_database_name\n         self.connection.settings_dict[\"NAME\"] = test_database_name\n \n-        if self.connection.settings_dict['TEST']['MIGRATE']:\n-            # We report migrate messages at one level lower than that\n-            # requested. This ensures we don't get flooded with messages during\n-            # testing (unless you really ask to be flooded).\n-            call_command(\n-                'migrate',\n-                verbosity=max(verbosity - 1, 0),\n-                interactive=False,\n-                database=self.connection.alias,\n-                run_syncdb=True,\n-            )\n+\n+        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n+            self.connection._test_serialized_contents = self.serialize_db_to_string()\n \n         # We then serialize the current state of the database into a string\n         # and store it on the connection. This slightly horrific process is so people\n         # who are testing on databases without transactions or who are using\n         # a TransactionTestCase still get a clean database on every test run.\n-        if serialize:\n+\n+        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n             self.connection._test_serialized_contents = self.serialize_db_to_string()\n \n         call_command('createcachetable', database=self.connection.alias)\n@@ -97,6 +90,133 @@ class BaseDatabaseCreation:\n         Designed only for test runner usage; will not handle large\n         amounts of data.\n         \"\"\"\n+\n+    def _create_test_db(self, verbosity, autoclobber, keepdb=False):\n+        \"\"\"\n+        Internal implementation - create the test db tables.\n+        \"\"\"\n+        test_database_name = self._get_test_db_name()\n+        test_db_params = {\n+            'dbname': self.connection.ops.quote_name(test_database_name),\n+        }\n+        # Create the test database and connect to it.\n+        with self._nodb_cursor() as cursor:\n+            try:\n+                self._execute_create_test_db(cursor, test_db_params, keepdb)\n+            except Exception as e:\n+                # if we want to keep the db, then no need to do any of the below,\n+                # just return and skip it all.\n+                if keepdb:\n+                    return test_database_name\n+                self.log('Got an error creating the test database: %s' % e)\n+                if not autoclobber:\n+                    confirm = input(\n+                        \"Type 'yes' if you would like to try deleting the test \"\n+                        \"database '%s', or 'no' to cancel: \" % test_database_name)\n+                if autoclobber or confirm == 'yes':\n+                    try:\n+                        if verbosity >= 1:\n+                            self.log('Destroying old test database for alias %s...' % (\n+                                self.connection.alias,\n+                            ))\n+                        cursor.execute('DROP DATABASE %s' % test_db_params['dbname'])\n+                        self._execute_create_test_db(cursor, test_db_params, keepdb)\n+                    except Exception as e:\n+                        self.log('Got an error recreating the test database: %s' % e)\n+                        sys.exit(2)\n+                else:\n+                    self.log('Tests cancelled.')\n+                    sys.exit(1)\n+\n+        return test_database_name\n+\n+    def _clone_test_db(self, suffix, verbosity, keepdb=False):\n+        \"\"\"\n+        Clone a test database.\n+        \"\"\"\n+        source_database_name = self.connection.settings_dict['NAME']\n+        target_database_name = self.get_test_db_clone_settings(suffix)['NAME']\n+        test_db_params = {\n+            'dbname': self.connection.ops.quote_name(target_database_name),\n+            'suffix': suffix,\n+        }\n+        with self._nodb_cursor() as cursor:\n+            try:\n+                self._clone_db(cursor, source_database_name, target_database_name)\n+            except Exception as e:\n+                if keepdb:\n+                    return\n+                self.log('Got an error cloning the test database: %s' % e)\n+                sys.exit(2)\n+\n+    def destroy_test_db(self, old_database_name, verbosity=1, keepdb=False, suffix=None):\n+        \"\"\"\n+        Destroy a test database, prompting the user for confirmation if the\n+        database already exists.\n+        \"\"\"\n+        self.connection.close()\n+        if suffix is None:\n+            test_database_name = self.connection.settings_dict['NAME']\n+        else:\n+            test_database_name = self.get_test_db_clone_settings(suffix)['NAME']\n+\n+        if verbosity >= 1:\n+            action = 'Destroying'\n+            if keepdb:\n+                action = 'Preserving'\n+            self.log('%s test database for alias %s...' % (action, self.connection.alias))\n+\n+        # Temporarily use a new connection and a database that exists.\n+        # Note that if the database we're trying to delete doesn't exist, a\n+        # database error will be raised, but that's OK because Django doesn't\n+        # consider that an error and will skip the destroy.\n+        settings_dict = self.connection.settings_dict.copy()\n+        settings_dict['NAME'] = old_database_name\n+        backend = load_backend(settings_dict['ENGINE'])\n+        new_connection = backend.DatabaseWrapper(\n+            settings_dict,\n+            alias=self.connection.alias,\n+        )\n+        new_connection.connect()\n+        self.set_as_test_mirror(new_connection.settings_dict)\n+\n+        # We could be attempting to run on a database that doesn't exist, so\n+        # check if it exists at all first.\n+        if new_connection.introspection.get_table_list(new_connection.cursor()):\n+            # If we get here then we have a working database connection, which\n+            # means the database exists. Don't destroy it if we're told not to.\n+            if keepdb:\n+                return\n+            if not autoclobber:\n+                confirm = input(\n+                    \"Type 'yes' if you would like to try deleting the test \"\n+                    \"database '%s', or 'no' to cancel: \" % test_database_name)\n+            if autoclobber or confirm == 'yes':\n+                try:\n+                    if verbosity >= 1:\n+                        self.log('Destroying old test database for alias %s...' % (\n+                            self.connection.alias,\n+                        ))\n+                    new_connection.ops.destroy_test_db(test_database_name, verbosity)\n+                except Exception as e:\n+                    self.log('Got an error destroying the old test database: %s' % e)\n+                    sys.exit(2)\n+            else:\n+                self.log(\"Tests cancelled -- test database cannot be recreated.\")\n+                sys.exit(1)\n+        else:\n+            self.log(\"Test database doesn't appear to exist. Skipping teardown.\")\n+\n+    def serialize_db_to_string(self):\n+        \"\"\"\n+        Serialize all data in the database into a JSON string.\n+        Designed only for test runner usage; will not handle large\n+        amounts of data.\n+        \"\"\"\n+        # Skip serialization if migrations weren't run\n+        if not self.connection.settings_dict['TEST']['MIGRATE']:\n+            return ''\n+        \n         # Iteratively return every object for all models to serialize.\n         def get_objects():\n             from django.db.migrations.loader import MigrationLoader\n@@ -120,7 +240,6 @@ class BaseDatabaseCreation:\n         out = StringIO()\n         serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n         return out.getvalue()\n-\n     def deserialize_db_from_string(self, data):\n         \"\"\"\n         Reload the database with data from a string generated by\n",
    "variant_4": "diff --git a/django/db/backends/base/creation.py b/django/db/backends/base/creation.py\nindex 503f7f56fd..15b9b8d643 100644\n--- a/django/db/backends/base/creation.py\n+++ b/django/db/backends/base/creation.py\n@@ -58,6 +58,177 @@ class BaseDatabaseCreation:\n         settings.DATABASES[self.connection.alias][\"NAME\"] = test_database_name\n         self.connection.settings_dict[\"NAME\"] = test_database_name\n \n+\n+        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n+            self.connection._test_serialized_contents = self.serialize_db_to_string()\n+\n+        # We then serialize the current state of the database into a string\n+        # and store it on the connection. This slightly horrific process is so people\n+        # who are testing on databases without transactions or who are using\n+        # a TransactionTestCase still get a clean database on every test run.\n+\n+        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n+            self.connection._test_serialized_contents = self.serialize_db_to_string()\n+\n+        call_command('createcachetable', database=self.connection.alias)\n+\n+        # Ensure a connection for the side effect of initializing the test database.\n+        self.connection.ensure_connection()\n+\n+        return test_database_name\n+\n+    def set_as_test_mirror(self, primary_settings_dict):\n+        \"\"\"\n+        Set this database up to be used in testing as a mirror of a primary\n+        database whose settings are given.\n+        \"\"\"\n+        self.connection.settings_dict['NAME'] = primary_settings_dict['NAME']\n+\n+    def serialize_db_to_string(self):\n+        \"\"\"\n+        Serialize all data in the database into a JSON string.\n+        Designed only for test runner usage; will not handle large\n+        amounts of data.\n+        \"\"\"\n+\n+    def _create_test_db(self, verbosity, autoclobber, keepdb=False):\n+        \"\"\"\n+        Internal implementation - create the test db tables.\n+        \"\"\"\n+        test_database_name = self._get_test_db_name()\n+        test_db_params = {\n+            'dbname': self.connection.ops.quote_name(test_database_name),\n+            'suffix': self.sql_table_creation_suffix(),\n+        }\n+        # Create the test database and connect to it.\n+        with self._nodb_cursor() as cursor:\n+            try:\n+                self._execute_create_test_db(cursor, test_db_params, keepdb)\n+            except Exception as e:\n+                # if we want to keep the db, then no need to do any of the below,\n+                # just return and skip it all.\n+                if keepdb:\n+                    return test_database_name\n+                self.log('Got an error creating the test database: %s' % e)\n+                if not autoclobber:\n+                    confirm = input(\n+                        \"Type 'yes' if you would like to try deleting the test \"\n+                        \"database '%s', or 'no' to cancel: \" % test_database_name)\n+                if autoclobber or confirm == 'yes':\n+                    try:\n+                        if verbosity >= 1:\n+                            self.log('Destroying old test database for alias %s...' % (\n+                                self.connection.alias,\n+                            ))\n+                        cursor.execute('DROP DATABASE %(dbname)s' % test_db_params)\n+                        self._execute_create_test_db(cursor, test_db_params, keepdb)\n+                    except Exception as e:\n+                        self.log('Got an error recreating the test database: %s' % e)\n+                        sys.exit(2)\n+                else:\n+                    self.log('Tests cancelled.')\n+                    sys.exit(1)\n+\n+        return test_database_name\n+\n+    def _clone_test_db(self, suffix, verbosity, keepdb=False):\n+        \"\"\"\n+        Clone a test database.\n+        \"\"\"\n+        source_database_name = self.connection.settings_dict['NAME']\n+        target_database_name = self.get_test_db_clone_settings(suffix)['NAME']\n+        test_db_params = {\n+            'dbname': self.connection.ops.quote_name(target_database_name),\n+            'suffix': self.sql_table_creation_suffix(),\n+        }\n+        with self._nodb_cursor() as cursor:\n+            try:\n+                self._execute_create_test_db(cursor, test_db_params, keepdb)\n+            except Exception:\n+                if keepdb:\n+                    return\n+                raise\n+\n+        # Skip cloning if migrations weren't run\n+        if not self.connection.settings_dict['TEST']['MIGRATE']:\n+            return\n+\n+        self.connection.ops.clone_test_database(\n+            suffix, verbosity, autoclobber=not keepdb\n+        )\n+\n+    def _get_database_display_str(self, verbosity, test_database_name):\n+        \"\"\"\n+        Return display string for a database for use in various actions.\n+        \"\"\"\n+        return \"'%s'%s\" % (\n+            self.connection.alias,\n+            (\" ('%s')\" % test_database_name) if verbosity >= 2 else '',\n+        )\n+\n+    def _get_test_db_name(self):\n+        \"\"\"\n+        Internal implementation - return the name of the test DB that will be\n+        created. Only useful when called from create_test_db() and\n+        _create_test_db() and when no external munging is done with the 'NAME'\n+        settings.\n+        \"\"\"\n+        if self.connection.settings_dict['TEST']['NAME']:\n+            return self.connection.settings_dict['TEST']['NAME']\n+        return TEST_DATABASE_PREFIX + self.connection.settings_dict['NAME']\n+\n+    def _execute_create_test_db(self, cursor, parameters, keepdb=False):\n+        cursor.execute('CREATE DATABASE %(dbname)s %(suffix)s' % parameters)\n+\n+    def _destroy_test_db(self, test_database_name, verbosity):\n+        \"\"\"\n+        Internal implementation - remove the test db tables.\n+        \"\"\"\n+        # Remove the test database to clean up after\n+        # ourselves. Connect to the previous database (not the test database)\n+        # to do so, because it's not allowed to delete a database while being\n+        # connected to it.\n+        with self._nodb_cursor() as cursor:\n+            cursor.execute(\"DROP DATABASE %s\"\n+                           % self.connection.ops.quote_name(test_database_name))\n+\n+    def sql_table_creation_suffix(self):\n+        \"\"\"\n+        SQL to append to the end of the test table creation statements.\n+        \"\"\"\n+        return ''\n+\n+    def setup_test_db(self, verbosity=1, autoclobber=False, serialize=True, keepdb=False):\n+        \"\"\"\n+        Create a test database, prompting the user for confirmation if the\n+        database already exists. Return the name of the test database created.\n+        \"\"\"\n+        # Don't import django.core.management if it isn't needed.\n+        from django.core.management import call_command\n+\n+        test_database_name = self._get_test_db_name()\n+\n+        if verbosity >= 1:\n+            action = 'Creating'\n+            if keepdb:\n+                action = 'Using existing'\n+\n+            self.log('%s test database for alias %s...' % (\n+                action,\n+                self._get_database_display_str(verbosity, test_database_name),\n+            ))\n+\n+        # We could skip this call if keepdb is True, but we instead\n+        # give it the keepdb param. This is to handle the case\n+        # where the test DB doesn't exist, in which case we need to\n+        # create it, then just not destroy it. If we instead skip\n+        # this, we will get an exception.\n+        self._create_test_db(verbosity, autoclobber, keepdb)\n+\n+        self.connection.close()\n+        settings.DATABASES[self.connection.alias][\"NAME\"] = test_database_name\n+        self.connection.settings_dict[\"NAME\"] = test_database_name\n+\n         if self.connection.settings_dict['TEST']['MIGRATE']:\n             # We report migrate messages at one level lower than that\n             # requested. This ensures we don't get flooded with messages during\n@@ -74,16 +245,57 @@ class BaseDatabaseCreation:\n         # and store it on the connection. This slightly horrific process is so people\n         # who are testing on databases without transactions or who are using\n         # a TransactionTestCase still get a clean database on every test run.\n-        if serialize:\n+        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n             self.connection._test_serialized_contents = self.serialize_db_to_string()\n \n         call_command('createcachetable', database=self.connection.alias)\n \n-        # Ensure a connection for the side effect of initializing the test database.\n+        # Ensure a connection for the side effect of initializing the test\n+        # database.\n         self.connection.ensure_connection()\n \n         return test_database_name\n \n+    def setup_worker_connection(self, primary_settings_dict):\n+        \"\"\"\n+        Clone a database and set up this test to use it.\n+\n+        This method is used by the primary/worker mechanism during parallel\n+        testing.\n+        \"\"\"\n+        database_name = primary_settings_dict['NAME']\n+        if not database_name.startswith(TEST_DATABASE_PREFIX):\n+            raise Exception(\n+                \"When using the --parallel option, the database name '%s' \"\n+                \"must be prefixed with '%s'.\" % (\n+                    database_name, TEST_DATABASE_PREFIX,\n+                )\n+            )\n+        # We need to make a deepcopy of the settings_dict because\n+        # setup_test_db modifies its 'NAME' value.\n+        settings_dict = copy.deepcopy(self.connection.settings_dict)\n+        settings_dict['NAME'] = primary_settings_dict['NAME']\n+        self.connection.settings_dict = settings_dict\n+        # Record the connection's previous database name\n+        previous_database_name = self.connection.settings_dict['NAME']\n+        # Create a test database name by cloning the primary database.\n+        clone_suffix = str(os.getpid())\n+        self._clone_test_db(clone_suffix, verbosity=0, keepdb=True)\n+        # Set this database connection's name to the cloned database.\n+        self.connection.settings_dict['NAME'] = self.get_test_db_clone_settings(clone_suffix)['NAME']\n+        # Store the original database name so we can restore it later.\n+        self.connection.settings_dict['NAME'] = previous_database_name\n+\n+    def get_test_db_clone_settings(self, suffix):\n+        \"\"\"\n+        Return a modified connection settings dict for the n-th clone of a DB.\n+        \"\"\"\n+        # When this function is called, the test database has been created\n+        # already and its name has been copied to settings_dict['NAME'] so\n+        # we don't need to call _get_test_db_name.\n+        orig_settings_dict = self.connection.settings_dict\n+        return {**orig_settings_dict, 'NAME': '{}_{}'.format(orig_settings_dict['NAME'], suffix)}\n+\n     def set_as_test_mirror(self, primary_settings_dict):\n         \"\"\"\n         Set this database up to be used in testing as a mirror of a primary\n",
    "variant_5": "diff --git a/django/db/backends/base/creation.py b/django/db/backends/base/creation.py\nindex 503f7f56fd..544fc25a11 100644\n--- a/django/db/backends/base/creation.py\n+++ b/django/db/backends/base/creation.py\n@@ -58,23 +58,16 @@ class BaseDatabaseCreation:\n         settings.DATABASES[self.connection.alias][\"NAME\"] = test_database_name\n         self.connection.settings_dict[\"NAME\"] = test_database_name\n \n-        if self.connection.settings_dict['TEST']['MIGRATE']:\n-            # We report migrate messages at one level lower than that\n-            # requested. This ensures we don't get flooded with messages during\n-            # testing (unless you really ask to be flooded).\n-            call_command(\n-                'migrate',\n-                verbosity=max(verbosity - 1, 0),\n-                interactive=False,\n-                database=self.connection.alias,\n-                run_syncdb=True,\n-            )\n+\n+        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n+            self.connection._test_serialized_contents = self.serialize_db_to_string()\n \n         # We then serialize the current state of the database into a string\n         # and store it on the connection. This slightly horrific process is so people\n         # who are testing on databases without transactions or who are using\n         # a TransactionTestCase still get a clean database on every test run.\n-        if serialize:\n+\n+        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n             self.connection._test_serialized_contents = self.serialize_db_to_string()\n \n         call_command('createcachetable', database=self.connection.alias)\n@@ -97,30 +90,40 @@ class BaseDatabaseCreation:\n         Designed only for test runner usage; will not handle large\n         amounts of data.\n         \"\"\"\n-        # Iteratively return every object for all models to serialize.\n-        def get_objects():\n-            from django.db.migrations.loader import MigrationLoader\n-            loader = MigrationLoader(self.connection)\n-            for app_config in apps.get_app_configs():\n-                if (\n-                    app_config.models_module is not None and\n-                    app_config.label in loader.migrated_apps and\n-                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n-                ):\n-                    for model in app_config.get_models():\n-                        if (\n-                            model._meta.can_migrate(self.connection) and\n-                            router.allow_migrate_model(self.connection.alias, model)\n-                        ):\n-                            queryset = model._default_manager.using(\n-                                self.connection.alias,\n-                            ).order_by(model._meta.pk.name)\n-                            yield from queryset.iterator()\n-        # Serialize to a string\n-        out = StringIO()\n-        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n-        return out.getvalue()\n \n+def serialize_db_to_string(self):\n+    \"\"\"\n+    Serialize all data in the database into a JSON string.\n+    Designed only for test runner usage; will not handle large\n+    amounts of data.\n+    \"\"\"\n+    # Skip serialization if migrations weren't run\n+    if not self.connection.settings_dict['TEST']['MIGRATE']:\n+        return ''\n+    \n+    # Iteratively return every object for all models to serialize.\n+    def get_objects():\n+        from django.db.migrations.loader import MigrationLoader\n+        loader = MigrationLoader(self.connection)\n+        for app_config in apps.get_app_configs():\n+            if (\n+                app_config.models_module is not None and\n+                app_config.label in loader.migrated_apps and\n+                app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n+            ):\n+                for model in app_config.get_models():\n+                    if (\n+                        model._meta.can_migrate(self.connection) and\n+                        router.allow_migrate_model(self.connection.alias, model)\n+                    ):\n+                        queryset = model._default_manager.using(\n+                            self.connection.alias,\n+                        ).order_by(model._meta.pk.name)\n+                        yield from queryset.iterator()\n+    # Serialize to a string\n+    out = StringIO()\n+    serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n+    return out.getvalue()\n     def deserialize_db_from_string(self, data):\n         \"\"\"\n         Reload the database with data from a string generated by\n",
    "variant_6": "diff --git a/django/db/backends/base/creation.py b/django/db/backends/base/creation.py\nindex 503f7f56fd..7b8081f41e 100644\n--- a/django/db/backends/base/creation.py\n+++ b/django/db/backends/base/creation.py\n@@ -58,23 +58,16 @@ class BaseDatabaseCreation:\n         settings.DATABASES[self.connection.alias][\"NAME\"] = test_database_name\n         self.connection.settings_dict[\"NAME\"] = test_database_name\n \n-        if self.connection.settings_dict['TEST']['MIGRATE']:\n-            # We report migrate messages at one level lower than that\n-            # requested. This ensures we don't get flooded with messages during\n-            # testing (unless you really ask to be flooded).\n-            call_command(\n-                'migrate',\n-                verbosity=max(verbosity - 1, 0),\n-                interactive=False,\n-                database=self.connection.alias,\n-                run_syncdb=True,\n-            )\n+\n+        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n+            self.connection._test_serialized_contents = self.serialize_db_to_string()\n \n         # We then serialize the current state of the database into a string\n         # and store it on the connection. This slightly horrific process is so people\n         # who are testing on databases without transactions or who are using\n         # a TransactionTestCase still get a clean database on every test run.\n-        if serialize:\n+\n+        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n             self.connection._test_serialized_contents = self.serialize_db_to_string()\n \n         call_command('createcachetable', database=self.connection.alias)\n@@ -97,6 +90,108 @@ class BaseDatabaseCreation:\n         Designed only for test runner usage; will not handle large\n         amounts of data.\n         \"\"\"\n+\n+    def _create_test_db(self, verbosity, autoclobber, keepdb=False):\n+        \"\"\"\n+        Internal implementation - create the test db tables.\n+        \"\"\"\n+        test_database_name = self._get_test_db_name()\n+        test_db_params = {\n+            'dbname': self.connection.ops.quote_name(test_database_name),\n+            'suffix': self.sql_table_creation_suffix(),\n+        }\n+        # Create the test database and connect to it.\n+        with self._nodb_cursor() as cursor:\n+            try:\n+                self._execute_create_test_db(cursor, test_db_params, keepdb)\n+            except Exception as e:\n+                # if we want to keep the db, then no need to do any of the below,\n+                # just return and skip it all.\n+                if keepdb:\n+                    return test_database_name\n+                self.log('Got an error creating the test database: %s' % e)\n+                if not autoclobber:\n+                    confirm = input(\n+                        \"Type 'yes' if you would like to try deleting the test \"\n+                        \"database '%s', or 'no' to cancel: \" % test_database_name)\n+                if autoclobber or confirm == 'yes':\n+                    try:\n+                        if verbosity >= 1:\n+                            self.log('Destroying old test database for alias %s...' % (\n+                                self.connection.alias,\n+                            ))\n+                        cursor.execute('DROP DATABASE %(dbname)s' % test_db_params)\n+                        self._execute_create_test_db(cursor, test_db_params, keepdb)\n+                    except Exception as e:\n+                        self.log('Got an error recreating the test database: %s' % e)\n+                        sys.exit(2)\n+                else:\n+                    self.log('Tests cancelled.')\n+                    sys.exit(1)\n+\n+        return test_database_name\n+\n+    def _clone_test_db(self, suffix, verbosity, keepdb=False):\n+        \"\"\"\n+        Internal implementation - duplicate the test db tables.\n+        \"\"\"\n+        source_database_name = self.connection.settings_dict['NAME']\n+        target_database_name = self.get_test_db_clone_settings(suffix)['NAME']\n+        test_db_params = {\n+            'dbname': self.connection.ops.quote_name(target_database_name),\n+            'suffix': self.sql_table_creation_suffix(),\n+        }\n+        with self._nodb_cursor() as cursor:\n+            try:\n+                self._execute_create_test_db(cursor, test_db_params, keepdb)\n+            except Exception:\n+                if keepdb:\n+                    return\n+                raise\n+\n+        # Migrate the test database.\n+        call_command(\n+            'migrate',\n+            verbosity=max(verbosity - 1, 0),\n+            interactive=False,\n+            database=self.connection.alias,\n+            run_syncdb=True,\n+        )\n+\n+        # Copy the data from the original database.\n+        if self.connection.settings_dict['TEST'].get('MIGRATE', True):\n+            # Don't import django.core.management if it isn't needed.\n+            from django.core.management import call_command\n+            call_command(\n+                'loaddata',\n+                self.connection._test_serialized_contents,\n+                verbosity=0,\n+                database=self.connection.alias,\n+            )\n+\n+    def setup_test_environment(self, **kwargs):\n+        pass\n+\n+    def teardown_test_environment(self, **kwargs):\n+        pass\n+\n+    def set_as_test_mirror(self, primary_settings_dict):\n+        \"\"\"\n+        Set this database up to be used in testing as a mirror of a primary\n+        database whose settings are given.\n+        \"\"\"\n+        self.connection.settings_dict['NAME'] = primary_settings_dict['NAME']\n+\n+    def serialize_db_to_string(self):\n+        \"\"\"\n+        Serialize all data in the database into a JSON string.\n+        Designed only for test runner usage; will not handle large\n+        amounts of data.\n+        \"\"\"\n+        # Skip serialization if migrations weren't run\n+        if not self.connection.settings_dict['TEST'].get('MIGRATE', True):\n+            return ''\n+            \n         # Iteratively return every object for all models to serialize.\n         def get_objects():\n             from django.db.migrations.loader import MigrationLoader\n@@ -120,7 +215,6 @@ class BaseDatabaseCreation:\n         out = StringIO()\n         serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n         return out.getvalue()\n-\n     def deserialize_db_from_string(self, data):\n         \"\"\"\n         Reload the database with data from a string generated by\n",
    "variant_7": "diff --git a/django/db/backends/base/creation.py b/django/db/backends/base/creation.py\nindex 503f7f56fd..bdef02e5a6 100644\n--- a/django/db/backends/base/creation.py\n+++ b/django/db/backends/base/creation.py\n@@ -58,23 +58,16 @@ class BaseDatabaseCreation:\n         settings.DATABASES[self.connection.alias][\"NAME\"] = test_database_name\n         self.connection.settings_dict[\"NAME\"] = test_database_name\n \n-        if self.connection.settings_dict['TEST']['MIGRATE']:\n-            # We report migrate messages at one level lower than that\n-            # requested. This ensures we don't get flooded with messages during\n-            # testing (unless you really ask to be flooded).\n-            call_command(\n-                'migrate',\n-                verbosity=max(verbosity - 1, 0),\n-                interactive=False,\n-                database=self.connection.alias,\n-                run_syncdb=True,\n-            )\n+\n+        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n+            self.connection._test_serialized_contents = self.serialize_db_to_string()\n \n         # We then serialize the current state of the database into a string\n         # and store it on the connection. This slightly horrific process is so people\n         # who are testing on databases without transactions or who are using\n         # a TransactionTestCase still get a clean database on every test run.\n-        if serialize:\n+\n+        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n             self.connection._test_serialized_contents = self.serialize_db_to_string()\n \n         call_command('createcachetable', database=self.connection.alias)\n@@ -97,6 +90,17 @@ class BaseDatabaseCreation:\n         Designed only for test runner usage; will not handle large\n         amounts of data.\n         \"\"\"\n+\n+    def serialize_db_to_string(self):\n+        \"\"\"\n+        Serialize all data in the database into a JSON string.\n+        Designed only for test runner usage; will not handle large\n+        amounts of data.\n+        \"\"\"\n+        # Skip serialization if migrations weren't run\n+        if not self.connection.settings_dict['TEST']['MIGRATE']:\n+            return ''\n+        \n         # Iteratively return every object for all models to serialize.\n         def get_objects():\n             from django.db.migrations.loader import MigrationLoader\n@@ -120,7 +124,6 @@ class BaseDatabaseCreation:\n         out = StringIO()\n         serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n         return out.getvalue()\n-\n     def deserialize_db_from_string(self, data):\n         \"\"\"\n         Reload the database with data from a string generated by\n",
    "variant_8": "diff --git a/django/db/backends/base/creation.py b/django/db/backends/base/creation.py\nindex 503f7f56fd..afd97db96e 100644\n--- a/django/db/backends/base/creation.py\n+++ b/django/db/backends/base/creation.py\n@@ -58,23 +58,16 @@ class BaseDatabaseCreation:\n         settings.DATABASES[self.connection.alias][\"NAME\"] = test_database_name\n         self.connection.settings_dict[\"NAME\"] = test_database_name\n \n-        if self.connection.settings_dict['TEST']['MIGRATE']:\n-            # We report migrate messages at one level lower than that\n-            # requested. This ensures we don't get flooded with messages during\n-            # testing (unless you really ask to be flooded).\n-            call_command(\n-                'migrate',\n-                verbosity=max(verbosity - 1, 0),\n-                interactive=False,\n-                database=self.connection.alias,\n-                run_syncdb=True,\n-            )\n+\n+        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n+            self.connection._test_serialized_contents = self.serialize_db_to_string()\n \n         # We then serialize the current state of the database into a string\n         # and store it on the connection. This slightly horrific process is so people\n         # who are testing on databases without transactions or who are using\n         # a TransactionTestCase still get a clean database on every test run.\n-        if serialize:\n+\n+        if serialize and self.connection.settings_dict['TEST']['MIGRATE']:\n             self.connection._test_serialized_contents = self.serialize_db_to_string()\n \n         call_command('createcachetable', database=self.connection.alias)\n@@ -97,9 +90,182 @@ class BaseDatabaseCreation:\n         Designed only for test runner usage; will not handle large\n         amounts of data.\n         \"\"\"\n+\n+    def _create_test_db(self, verbosity, autoclobber, keepdb=False):\n+        \"\"\"\n+        Internal implementation - create the test db tables.\n+        \"\"\"\n+        test_database_name = self._get_test_db_name()\n+        test_db_params = {\n+            'dbname': self.connection.ops.quote_name(test_database_name),\n+        }\n+        # Create the test database and connect to it.\n+        with self._nodb_cursor() as cursor:\n+            try:\n+                self._execute_create_test_db(cursor, test_db_params, keepdb)\n+            except Exception as e:\n+                # if we want to keep the db, then no need to do any of the below,\n+                # just return and skip it all.\n+                if keepdb:\n+                    return test_database_name\n+                self.log('Got an error creating the test database: %s' % e)\n+                if not autoclobber:\n+                    confirm = input(\n+                        \"Type 'yes' if you would like to try deleting the test \"\n+                        \"database '%s', or 'no' to cancel: \" % test_database_name\n+                    )\n+                if autoclobber or confirm == 'yes':\n+                    try:\n+                        if verbosity >= 1:\n+                            self.log('Destroying old test database for alias %s...' % (\n+                                self.connection.alias,\n+                            ))\n+                        cursor.execute('DROP DATABASE %(dbname)s' % test_db_params)\n+                        self._execute_create_test_db(cursor, test_db_params, keepdb)\n+                    except Exception as e:\n+                        self.log('Got an error recreating the test database: %s' % e)\n+                        sys.exit(2)\n+                else:\n+                    self.log('Tests cancelled.')\n+                    sys.exit(1)\n+\n+        return test_database_name\n+\n+    def _clone_test_db(self, suffix, verbosity, keepdb=False):\n+        \"\"\"\n+        Clone a test database.\n+        \"\"\"\n+        source_database_name = self.connection.settings_dict['NAME']\n+        target_database_name = self.get_test_db_clone_settings(suffix)['NAME']\n+        test_db_params = {\n+            'dbname': self.connection.ops.quote_name(target_database_name),\n+            'source_dbname': self.connection.ops.quote_name(source_database_name),\n+        }\n+        with self._nodb_cursor() as cursor:\n+            try:\n+                self._execute_create_test_db(cursor, test_db_params, keepdb)\n+            except Exception:\n+                if keepdb:\n+                    # If the database should be kept, skip the error.\n+                    return\n+                raise\n+        # Record the connection's database name\n+        self.connection.settings_dict['NAME'] = target_database_name\n+\n+    def destroy_test_db(self, old_database_name, verbosity=1, keepdb=False, suffix=None):\n+        \"\"\"\n+        Destroy a test database, prompting the user for confirmation if the\n+        database already exists.\n+        \"\"\"\n+        self.connection.close()\n+        if suffix is None:\n+            test_database_name = self.connection.settings_dict['NAME']\n+        else:\n+            test_database_name = self.get_test_db_clone_settings(suffix)['NAME']\n+\n+        if verbosity >= 1:\n+            action = 'Destroying'\n+            if keepdb:\n+                action = 'Preserving'\n+            self.log('%s test database for alias %s...' % (\n+                action,\n+                self.connection.alias[:-len(suffix)] if suffix else self.connection.alias,\n+            ))\n+\n+        # if we want to preserve the database\n+        # skip the actual destroying piece.\n+        if not keepdb:\n+            self._destroy_test_db(test_database_name, verbosity)\n+\n+        # Restore the original database name\n+        self.connection.settings_dict['NAME'] = old_database_name\n+\n+    def sql_table_creation_suffix(self):\n+        \"\"\"\n+        SQL to append to the end of the test table creation statements.\n+        \"\"\"\n+        return ''\n+\n+    def test_db_signature(self):\n+        \"\"\"\n+        Return a tuple with elements of self.connection.settings_dict (a\n+        DATABASES setting value) that uniquely identify a database\n+        accordingly to the RDBMS particularities.\n+        \"\"\"\n+        settings_dict = self.connection.settings_dict\n+        return (\n+            settings_dict['HOST'],\n+            settings_dict['PORT'],\n+            settings_dict['ENGINE'],\n+            settings_dict['NAME']\n+        )\n+\n+    def setup_worker_connection(self, _worker_id):\n+        \"\"\"\n+        Set up the database connection for a worker in a multi-processing context.\n+        \"\"\"\n+        settings_dict = self.connection.settings_dict\n+        if settings_dict['TEST']['MIGRATE']:\n+            # Ensure each worker gets a separate database.\n+            settings_dict['NAME'] = '{}_{}'.format(\n+                settings_dict['NAME'],\n+                _worker_id,\n+            )\n+\n+    def mark_expected_failures_and_skips(self):\n+        \"\"\"\n+        Mark tests in the test suite that are expected to fail on this database.\n+        \"\"\"\n+        for test_name in self.connection.features.django_test_expected_failures:\n+            test_case_name, _, test_method_name = test_name.rpartition('.')\n+            test_app = test_name.split('.')[0]\n+            # Importing here to avoid problems with circular imports\n+            test_module = __import__(test_app + '.tests', fromlist=[''])\n+            test_class = getattr(test_module, test_case_name.split('.')[-1])\n+            test_method = getattr(test_class, test_method_name)\n+            test_method = expectedFailure(test_method)\n+            setattr(test_class, test_method_name, test_method)\n+\n+        for test_name in self.connection.features.django_test_skips:\n+            test_case_name, _, test_method_name = test_name.rpartition('.')\n+            test_app = test_name.split('.')[0]\n+            # Importing here to avoid problems with circular imports\n+            test_module = __import__(test_app + '.tests', fromlist=[''])\n+            test_class = getattr(test_module, test_case_name.split('.')[-1])\n+            test_method = getattr(test_class, test_method_name)\n+            test_method = skip('contains expected failures')(test_method)\n+            setattr(test_class, test_method_name, test_method)\n+\n+    def setup_worker_connection(self, _worker_id):\n+        \"\"\"\n+        Set up the database connection for a worker in a multi-processing context.\n+        \"\"\"\n+        settings_dict = self.connection.settings_dict\n+        if settings_dict['TEST']['MIGRATE']:\n+            # Ensure each worker gets a separate database.\n+            settings_dict['NAME'] = '{}_{}'.format(\n+                settings_dict['NAME'],\n+                _worker_id,\n+            )\n+\n+    def _copy_primary_database_settings(self, primary_settings_dict):\n+        \"\"\"\n+        Copy the primary database settings to the test database settings.\n+        \"\"\"\n+        self.connection.settings_dict['NAME'] = primary_settings_dict['NAME']\n+\n+    def serialize_db_to_string(self):\n+        \"\"\"\n+        Serialize all data in the database into a JSON string.\n+        Designed only for test runner usage; will not handle large\n+        amounts of data.\n+        \"\"\"\n+        # Skip serialization if migrations weren't run\n+        if not self.connection.settings_dict['TEST']['MIGRATE']:\n+            return ''\n+        \n         # Iteratively return every object for all models to serialize.\n         def get_objects():\n-            from django.db.migrations.loader import MigrationLoader\n             loader = MigrationLoader(self.connection)\n             for app_config in apps.get_app_configs():\n                 if (\n@@ -119,6 +285,21 @@ class BaseDatabaseCreation:\n         # Serialize to a string\n         out = StringIO()\n         serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n+        return out.getvalue()\n+                            model._meta.can_migrate(self.connection) and\n+                            router.allow_migrate_model(self.connection.alias, model)\n+                        ):\n+                            try:\n+                                queryset = model._default_manager.using(\n+                                    self.connection.alias,\n+                                ).order_by(model._meta.pk.name)\n+                                yield from queryset.iterator()\n+                            except Exception:\n+                                # Skip models whose tables don't exist (e.g., when MIGRATE=False)\n+                                continue\n+        # Serialize to a string\n+        out = StringIO()\n+        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n         return out.getvalue()\n \n     def deserialize_db_from_string(self, data):\n"
  }
}