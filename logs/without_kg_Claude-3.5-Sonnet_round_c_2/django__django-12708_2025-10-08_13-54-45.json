{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/django/django/db/backends/base/schema.py lines 402-416)": "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # Make constraint filtering more specific to avoid conflicts between\n        # unique_together and index_together on the same fields\n        filter_kwargs = constraint_kwargs.copy()\n        if constraint_kwargs.get('index') and not constraint_kwargs.get('unique'):\n            # When deleting index constraints, explicitly exclude unique constraints\n            filter_kwargs['unique'] = False\n        elif constraint_kwargs.get('unique') and not constraint_kwargs.get('index'):\n            # When deleting unique constraints, explicitly exclude index constraints\n            filter_kwargs['index'] = False\n            \n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **filter_kwargs\n        )\n        if len(constraint_names) != 1:\n            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                len(constraint_names),\n                model._meta.db_table,\n                \", \".join(columns),\n            ))\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
    "Location 2 (/root/hy/projects_2/django/django/db/backends/base/schema.py lines 394-396)": "\n    def alter_index_together(self, model, old_index_together, new_index_together):\n        \"\"\"\n        Deal with a model changing its index_together. The input\n        index_togethers must be doubly-nested, not the single-nested\n        [\"foo\", \"bar\"] format.\n        \"\"\"\n        olds = {tuple(fields) for fields in old_index_together}\n        news = {tuple(fields) for fields in new_index_together}\n        # Deleted indexes\n        for fields in olds.difference(news):\n            self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n",
    "Location 3 (/root/hy/projects_2/django/django/db/backends/base/schema.py lines 378-380)": "\n        # Deleted uniques\n        for fields in olds.difference(news):\n            self._delete_composed_index(model, fields, {'unique': True, 'index': False}, self.sql_delete_unique)\n",
    "Location 4 (/root/hy/projects_2/django/django/db/backends/base/schema.py lines 1154-1170)": "\n    def _constraint_names(self, model, column_names=None, unique=None, primary_key=None,\n                          index=None, foreign_key=None, check=None, type_=None, exclude=None):\n        \"\"\"Return all constraint names matching the columns and conditions.\"\"\"\n        if column_names is not None:\n            column_names = [\n                self.connection.introspection.identifier_converter(name)\n                for name in column_names\n            ]\n        with self.connection.cursor() as cursor:\n            constraints = self.connection.introspection.get_constraints(cursor, model._meta.db_table)\n        result = []\n        for name, infodict in constraints.items():\n            if column_names is None or column_names == infodict['columns']:\n                if unique is not None and infodict['unique'] != unique:\n                    continue\n                if primary_key is not None and infodict['primary_key'] != primary_key:\n                    continue\n                if index is not None and infodict['index'] != index:\n                    continue\n                # When both unique and index filters are specified, ensure the constraint\n                # matches both criteria to distinguish between different constraint types\n                if (unique is not None and index is not None and \n                    (infodict['unique'] != unique or infodict['index'] != index)):\n                    continue\n                if check is not None and infodict['check'] != check:\n                    continue\n                if foreign_key is not None and not infodict['foreign_key']:\n                    continue\n                if type_ is not None and infodict['type'] != type_:\n                    continue\n                if not exclude or name not in exclude:\n                    result.append(name)\n        return result\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/django/django/db/backends/base/schema.py lines 402-416)": [
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # Enhanced constraint filtering to distinguish between index and unique constraints\n        filter_kwargs = constraint_kwargs.copy()\n        if constraint_kwargs.get('index') and 'unique' not in constraint_kwargs:\n            filter_kwargs['unique'] = False\n        elif constraint_kwargs.get('unique') and 'index' not in constraint_kwargs:\n            filter_kwargs['index'] = False\n            \n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **filter_kwargs\n        )\n        if len(constraint_names) != 1:\n            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                len(constraint_names),\n                model._meta.db_table,\n                \", \".join(columns),\n            ))\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # Make constraint filtering more specific to avoid conflicts between\n        # unique_together and index_together constraints on the same fields\n        filter_kwargs = constraint_kwargs.copy()\n        if constraint_kwargs.get('index'):\n            # When deleting index constraints, exclude unique constraints\n            filter_kwargs['unique'] = False\n        elif constraint_kwargs.get('unique'):\n            # When deleting unique constraints, exclude index constraints\n            filter_kwargs['index'] = False\n        \n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **filter_kwargs\n        )\n        if len(constraint_names) != 1:\n            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                len(constraint_names),\n                model._meta.db_table,\n                \", \".join(columns),\n            ))\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\ndef _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n    meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n    meta_index_names = {constraint.name for constraint in model._meta.indexes}\n    columns = [model._meta.get_field(field).column for field in fields]\n    \n    # Make constraint filtering more specific to avoid conflicts between\n    # unique_together and index_together on the same fields\n    filter_kwargs = constraint_kwargs.copy()\n    if constraint_kwargs.get('index') and not constraint_kwargs.get('unique', True):\n        # When deleting index constraints, explicitly exclude unique constraints\n        filter_kwargs['unique'] = False\n    elif constraint_kwargs.get('unique') and not constraint_kwargs.get('index', True):\n        # When deleting unique constraints, explicitly exclude index constraints\n        filter_kwargs['index'] = False\n    \n    constraint_names = self._constraint_names(\n        model, columns, exclude=meta_constraint_names | meta_index_names,\n        **filter_kwargs\n    )\n    if len(constraint_names) != 1:\n        raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n            len(constraint_names),\n            model._meta.db_table,\n            \", \".join(columns),\n        ))\n    self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # Make constraint filtering more specific to avoid conflicts between\n        # index_together and unique_together constraints on same fields\n        filter_kwargs = constraint_kwargs.copy()\n        if constraint_kwargs.get('index') and constraint_kwargs.get('unique') is None:\n            filter_kwargs['unique'] = False\n        elif constraint_kwargs.get('unique') and constraint_kwargs.get('index') is None:\n            filter_kwargs['index'] = False\n            \n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **filter_kwargs\n        )\n        if len(constraint_names) != 1:\n            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                len(constraint_names),\n                model._meta.db_table,\n                \", \".join(columns),\n            ))\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # Enhanced constraint filtering to distinguish between index and unique constraints\n        exclude_names = meta_constraint_names | meta_index_names\n        if constraint_kwargs.get('index') and constraint_kwargs.get('unique') is False:\n            # When deleting index constraints, also exclude unique constraints\n            constraint_kwargs = dict(constraint_kwargs, unique=False)\n        elif constraint_kwargs.get('unique') and constraint_kwargs.get('index') is False:\n            # When deleting unique constraints, also exclude index constraints\n            constraint_kwargs = dict(constraint_kwargs, index=False)\n            \n        constraint_names = self._constraint_names(\n            model, columns, exclude=exclude_names,\n            **constraint_kwargs\n        )\n        if len(constraint_names) != 1:\n            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                len(constraint_names),\n                model._meta.db_table,\n                \", \".join(columns),\n            ))\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # Enhanced constraint filtering to distinguish between constraint types\n        filter_kwargs = constraint_kwargs.copy()\n        if constraint_kwargs.get('index') and 'unique' not in constraint_kwargs:\n            filter_kwargs['unique'] = False\n        elif constraint_kwargs.get('unique') and 'index' not in constraint_kwargs:\n            filter_kwargs['index'] = False\n            \n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **filter_kwargs\n        )\n        if len(constraint_names) != 1:\n            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                len(constraint_names),\n                model._meta.db_table,\n                \", \".join(columns),\n            ))\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # Make constraint filtering more specific to avoid conflicts between\n        # unique_together and index_together constraints on the same fields\n        filter_kwargs = constraint_kwargs.copy()\n        if constraint_kwargs.get('index') and not constraint_kwargs.get('unique', True):\n            filter_kwargs['unique'] = False\n        elif constraint_kwargs.get('unique') and not constraint_kwargs.get('index', True):\n            filter_kwargs['index'] = False\n            \n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **filter_kwargs\n        )\n        if len(constraint_names) != 1:\n            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                len(constraint_names),\n                model._meta.db_table,\n                \", \".join(columns),\n            ))\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        \n        # Enhanced constraint filtering to distinguish between unique and index constraints\n        filter_kwargs = constraint_kwargs.copy()\n        if constraint_kwargs.get('index') and not constraint_kwargs.get('unique', True):\n            # When deleting index constraints, explicitly exclude unique constraints\n            filter_kwargs['unique'] = False\n        elif constraint_kwargs.get('unique') and not constraint_kwargs.get('index', True):\n            # When deleting unique constraints, explicitly exclude index constraints\n            filter_kwargs['index'] = False\n            \n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **filter_kwargs\n        )\n        if len(constraint_names) != 1:\n            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                len(constraint_names),\n                model._meta.db_table,\n                \", \".join(columns),\n            ))\n        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n"
    ],
    "Location 2 (/root/hy/projects_2/django/django/db/backends/base/schema.py lines 394-396)": [
      "\n    def alter_index_together(self, model, old_index_together, new_index_together):\n        \"\"\"\n        Deal with a model changing its index_together. The input\n        index_togethers must be doubly-nested, not the single-nested\n        [\"foo\", \"bar\"] format.\n        \"\"\"\n        olds = {tuple(fields) for fields in old_index_together}\n        news = {tuple(fields) for fields in new_index_together}\n        # Deleted indexes\n        for fields in olds.difference(news):\n            self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n        # Created indexes\n        for field_names in news.difference(olds):\n            fields = [model._meta.get_field(field) for field in field_names]\n            self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n",
      "\n    def alter_index_together(self, model, old_index_together, new_index_together):\n        \"\"\"\n        Deal with a model changing its index_together. The input\n        index_togethers must be doubly-nested, not the single-nested\n        [\"foo\", \"bar\"] format.\n        \"\"\"\n        olds = {tuple(fields) for fields in old_index_together}\n        news = {tuple(fields) for fields in new_index_together}\n        # Deleted indexes\n        for fields in olds.difference(news):\n            self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n",
      "\n    def alter_index_together(self, model, old_index_together, new_index_together):\n        \"\"\"\n        Deal with a model changing its index_together. The input\n        index_togethers must be doubly-nested, not the single-nested\n        [\"foo\", \"bar\"] format.\n        \"\"\"\n        olds = {tuple(fields) for fields in old_index_together}\n        news = {tuple(fields) for fields in new_index_together}\n        # Deleted indexes\n        for fields in olds.difference(news):\n            self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n",
      "\n    def alter_index_together(self, model, old_index_together, new_index_together):\n        \"\"\"\n        Deal with a model changing its index_together. The input\n        index_togethers must be doubly-nested, not the single-nested\n        [\"foo\", \"bar\"] format.\n        \"\"\"\n        olds = {tuple(fields) for fields in old_index_together}\n        news = {tuple(fields) for fields in new_index_together}\n        # Deleted indexes\n        for fields in olds.difference(news):\n            self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n        # Created indexes\n        for field_names in news.difference(olds):\n            fields = [model._meta.get_field(field) for field in field_names]\n            self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n",
      "\n    def alter_index_together(self, model, old_index_together, new_index_together):\n        \"\"\"\n        Deal with a model changing its index_together. The input\n        index_togethers must be doubly-nested, not the single-nested\n        [\"foo\", \"bar\"] format.\n        \"\"\"\n        olds = {tuple(fields) for fields in old_index_together}\n        news = {tuple(fields) for fields in new_index_together}\n        # Deleted indexes\n        for fields in olds.difference(news):\n            self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n        # Created indexes\n        for field_names in news.difference(olds):\n            fields = [model._meta.get_field(field) for field in field_names]\n            self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n",
      "\n    def alter_index_together(self, model, old_index_together, new_index_together):\n        \"\"\"\n        Deal with a model changing its index_together. The input\n        index_togethers must be doubly-nested, not the single-nested\n        [\"foo\", \"bar\"] format.\n        \"\"\"\n        olds = {tuple(fields) for fields in old_index_together}\n        news = {tuple(fields) for fields in new_index_together}\n        # Deleted indexes\n        for fields in olds.difference(news):\n            self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n",
      "\n    def alter_index_together(self, model, old_index_together, new_index_together):\n        \"\"\"\n        Deal with a model changing its index_together. The input\n        index_togethers must be doubly-nested, not the single-nested\n        [\"foo\", \"bar\"] format.\n        \"\"\"\n        olds = {tuple(fields) for fields in old_index_together}\n        news = {tuple(fields) for fields in new_index_together}\n        # Deleted indexes\n        for fields in olds.difference(news):\n            self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n",
      "\n    def alter_index_together(self, model, old_index_together, new_index_together):\n        \"\"\"\n        Deal with a model changing its index_together. The input\n        index_togethers must be doubly-nested, not the single-nested\n        [\"foo\", \"bar\"] format.\n        \"\"\"\n        olds = {tuple(fields) for fields in old_index_together}\n        news = {tuple(fields) for fields in new_index_together}\n        # Deleted indexes\n        for fields in olds.difference(news):\n            self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n        # Created indexes\n        for field_names in news.difference(olds):\n            fields = [model._meta.get_field(field) for field in field_names]\n            self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n"
    ],
    "Location 3 (/root/hy/projects_2/django/django/db/backends/base/schema.py lines 378-380)": [
      "\n        # Deleted uniques\n        for fields in olds.difference(news):\n            self._delete_composed_index(model, fields, {'unique': True, 'index': False}, self.sql_delete_unique)\n",
      "\n        # Deleted uniques\n        for fields in olds.difference(news):\n            self._delete_composed_index(model, fields, {'unique': True, 'index': False}, self.sql_delete_unique)\n",
      "\n        # Deleted uniques\n        for fields in olds.difference(news):\n            self._delete_composed_index(model, fields, {'unique': True, 'index': False}, self.sql_delete_unique)\n",
      "\n        # Deleted uniques\n        for fields in olds.difference(news):\n            self._delete_composed_index(model, fields, {'unique': True, 'index': False}, self.sql_delete_unique)\n",
      "\n        # Deleted uniques\n        for fields in olds.difference(news):\n            self._delete_composed_index(model, fields, {'unique': True, 'index': False}, self.sql_delete_unique)\n",
      "\n        # Deleted uniques\n        for fields in olds.difference(news):\n            self._delete_composed_index(model, fields, {'unique': True, 'index': False}, self.sql_delete_unique)\n",
      "\n        # Deleted uniques\n        for fields in olds.difference(news):\n            self._delete_composed_index(model, fields, {'unique': True, 'index': False}, self.sql_delete_unique)\n",
      "\n        # Deleted uniques\n        for fields in olds.difference(news):\n            self._delete_composed_index(model, fields, {'unique': True, 'index': False}, self.sql_delete_unique)\n"
    ],
    "Location 4 (/root/hy/projects_2/django/django/db/backends/base/schema.py lines 1154-1170)": [
      "\n    def _constraint_names(self, model, column_names=None, unique=None, primary_key=None, index=None, foreign_key=None,\n                          check=None, type_=None, exclude=None):\n        \"\"\"Return all constraint names matching the columns and conditions.\"\"\"\n        if column_names is not None:\n            column_names = [\n                self.connection.introspection.identifier_converter(name)\n                for name in column_names\n            ]\n        with self.connection.cursor() as cursor:\n            constraints = self.connection.introspection.get_constraints(cursor, model._meta.db_table)\n        result = []\n        for name, infodict in constraints.items():\n            if column_names is None or column_names == infodict['columns']:\n                if unique is not None and infodict['unique'] != unique:\n                    continue\n                if primary_key is not None and infodict['primary_key'] != primary_key:\n                    continue\n                if index is not None and infodict['index'] != index:\n                    continue\n                # When both unique and index are specified, ensure the constraint\n                # matches both criteria (e.g., unique=False and index=True means\n                # we want index constraints that are not unique constraints)\n                if unique is not None and index is not None:\n                    if infodict['unique'] != unique or infodict['index'] != index:\n                        continue\n                if check is not None and infodict['check'] != check:\n                    continue\n                if foreign_key is not None and not infodict['foreign_key']:\n                    continue\n                if type_ is not None and infodict['type'] != type_:\n                    continue\n                if not exclude or name not in exclude:\n                    result.append(name)\n        return result\n",
      "\n    def _constraint_names(self, model, column_names=None, unique=None,\n                          primary_key=None, index=None, foreign_key=None,\n                          check=None, type_=None, exclude=None):\n        \"\"\"Return all constraint names matching the columns and conditions.\"\"\"\n        if column_names is not None:\n            column_names = [\n                self.connection.introspection.identifier_converter(name)\n                for name in column_names\n            ]\n        with self.connection.cursor() as cursor:\n            constraints = self.connection.introspection.get_constraints(cursor, model._meta.db_table)\n        result = []\n        for name, infodict in constraints.items():\n            if column_names is None or column_names == infodict['columns']:\n                if unique is not None and infodict['unique'] != unique:\n                    continue\n                if primary_key is not None and infodict['primary_key'] != primary_key:\n                    continue\n                if index is not None and infodict['index'] != index:\n                    continue\n                if check is not None and infodict['check'] != check:\n                    continue\n                if foreign_key is not None and not infodict['foreign_key']:\n                    continue\n                if type_ is not None and infodict['type'] != type_:\n                    continue\n                # When both unique and index are specified, ensure they match exactly\n                if unique is not None and index is not None:\n                    if infodict['unique'] != unique or infodict['index'] != index:\n                        continue\n                if not exclude or name not in exclude:\n                    result.append(name)\n        return result\n",
      "\n    def _constraint_names(self, model, column_names=None, unique=None, primary_key=None, index=None, foreign_key=None,\n                          check=None, type_=None, exclude=None):\n        \"\"\"Return all constraint names matching the columns and conditions.\"\"\"\n        if column_names is not None:\n            column_names = [\n                self.connection.introspection.identifier_converter(name)\n                for name in column_names\n            ]\n        with self.connection.cursor() as cursor:\n            constraints = self.connection.introspection.get_constraints(cursor, model._meta.db_table)\n        result = []\n        for name, infodict in constraints.items():\n            if column_names is None or column_names == infodict['columns']:\n                if unique is not None and infodict['unique'] != unique:\n                    continue\n                if primary_key is not None and infodict['primary_key'] != primary_key:\n                    continue\n                if index is not None and infodict['index'] != index:\n                    continue\n                if check is not None and infodict['check'] != check:\n                    continue\n                if foreign_key is not None and not infodict['foreign_key']:\n                    continue\n                if type_ is not None and infodict['type'] != type_:\n                    continue\n                # When both unique and index are specified, ensure constraint matches both criteria\n                if unique is not None and index is not None:\n                    if infodict['unique'] != unique or infodict['index'] != index:\n                        continue\n                if not exclude or name not in exclude:\n                    result.append(name)\n        return result\n",
      "\n    def _constraint_names(self, model, column_names=None, unique=None,\n                          primary_key=None, index=None, foreign_key=None,\n                          check=None, type_=None, exclude=None):\n        \"\"\"Return all constraint names matching the columns and conditions.\"\"\"\n        if column_names is not None:\n            column_names = [\n                self.connection.introspection.identifier_converter(name)\n                for name in column_names\n            ]\n        with self.connection.cursor() as cursor:\n            constraints = self.connection.introspection.get_constraints(cursor, model._meta.db_table)\n        result = []\n        for name, infodict in constraints.items():\n            if column_names is None or column_names == infodict['columns']:\n                if unique is not None and infodict['unique'] != unique:\n                    continue\n                if primary_key is not None and infodict['primary_key'] != primary_key:\n                    continue\n                if index is not None and infodict['index'] != index:\n                    continue\n                if check is not None and infodict['check'] != check:\n                    continue\n                if foreign_key is not None and not infodict['foreign_key']:\n                    continue\n                if type_ is not None and infodict['type'] != type_:\n                    continue\n                # Additional filtering for unique/index combination\n                if unique is False and index is True:\n                    # Only include non-unique indexes\n                    if infodict['unique'] or not infodict['index']:\n                        continue\n                elif unique is True and index is False:\n                    # Only include unique constraints that are not regular indexes\n                    if not infodict['unique'] or (infodict['index'] and not infodict['unique']):\n                        continue\n                if not exclude or name not in exclude:\n                    result.append(name)\n        return result\n",
      "\n    def _constraint_names(self, model, column_names=None, unique=None,\n                          primary_key=None, index=None, foreign_key=None,\n                          check=None, type_=None, exclude=None):\n        \"\"\"Return all constraint names matching the columns and conditions.\"\"\"\n        if column_names is not None:\n            column_names = [\n                self.connection.introspection.identifier_converter(name)\n                for name in column_names\n            ]\n        with self.connection.cursor() as cursor:\n            constraints = self.connection.introspection.get_constraints(cursor, model._meta.db_table)\n        result = []\n        for name, infodict in constraints.items():\n            if column_names is None or column_names == infodict['columns']:\n                if unique is not None and infodict['unique'] != unique:\n                    continue\n                if primary_key is not None and infodict['primary_key'] != primary_key:\n                    continue\n                if index is not None and infodict['index'] != index:\n                    continue\n                if check is not None and infodict['check'] != check:\n                    continue\n                if foreign_key is not None and not infodict['foreign_key']:\n                    continue\n                if type_ is not None and infodict['type'] != type_:\n                    continue\n                # When both unique and index are specified, ensure they match both criteria\n                if unique is not None and index is not None:\n                    if infodict['unique'] != unique or infodict['index'] != index:\n                        continue\n                if not exclude or name not in exclude:\n                    result.append(name)\n        return result\n",
      "\n    def _constraint_names(self, model, column_names=None, unique=None, primary_key=None, index=None, foreign_key=None,\n                          check=None, type_=None, exclude=None):\n        \"\"\"Return all constraint names matching the columns and conditions.\"\"\"\n        if column_names is not None:\n            column_names = [\n                self.connection.introspection.identifier_converter(name)\n                for name in column_names\n            ]\n        with self.connection.cursor() as cursor:\n            constraints = self.connection.introspection.get_constraints(cursor, model._meta.db_table)\n        result = []\n        for name, infodict in constraints.items():\n            if column_names is None or column_names == infodict['columns']:\n                if unique is not None and infodict['unique'] != unique:\n                    continue\n                if primary_key is not None and infodict['primary_key'] != primary_key:\n                    continue\n                if index is not None and infodict['index'] != index:\n                    continue\n                if check is not None and infodict['check'] != check:\n                    continue\n                if foreign_key is not None and not infodict['foreign_key']:\n                    continue\n                if type_ is not None and infodict['type'] != type_:\n                    continue\n                # When both unique and index are specified, ensure they don't conflict\n                if unique is not None and index is not None:\n                    if unique and infodict['index'] and not infodict['unique']:\n                        continue\n                    if index and infodict['unique'] and not infodict['index']:\n                        continue\n                if not exclude or name not in exclude:\n                    result.append(name)\n        return result\n",
      "\n    def _constraint_names(self, model, column_names=None, unique=None, primary_key=None, index=None, foreign_key=None,\n                          check=None, type_=None, exclude=None):\n        \"\"\"Return all constraint names matching the columns and conditions.\"\"\"\n        if column_names is not None:\n            column_names = [\n                self.connection.introspection.identifier_converter(name)\n                for name in column_names\n            ]\n        with self.connection.cursor() as cursor:\n            constraints = self.connection.introspection.get_constraints(cursor, model._meta.db_table)\n        result = []\n        for name, infodict in constraints.items():\n            if column_names is None or column_names == infodict['columns']:\n                if unique is not None and infodict['unique'] != unique:\n                    continue\n                if primary_key is not None and infodict['primary_key'] != primary_key:\n                    continue\n                if index is not None and infodict['index'] != index:\n                    continue\n                # When both unique and index filters are specified, ensure the constraint\n                # matches both criteria to distinguish between different constraint types\n                # on the same columns\n                if (unique is not None and index is not None and \n                    (infodict['unique'] != unique or infodict['index'] != index)):\n                    continue\n                if check is not None and infodict['check'] != check:\n                    continue\n                if foreign_key is not None and not infodict['foreign_key']:\n                    continue\n                if type_ is not None and infodict['type'] != type_:\n                    continue\n                if not exclude or name not in exclude:\n                    result.append(name)\n        return result\n",
      "\n    def _constraint_names(self, model, column_names=None, unique=None, primary_key=None, index=None, foreign_key=None,\n                          check=None, type_=None, exclude=None):\n        \"\"\"Return all constraint names matching the columns and conditions.\"\"\"\n        if column_names is not None:\n            column_names = [\n                self.connection.introspection.identifier_converter(name)\n                for name in column_names\n            ]\n        with self.connection.cursor() as cursor:\n            constraints = self.connection.introspection.get_constraints(cursor, model._meta.db_table)\n        result = []\n        for name, infodict in constraints.items():\n            if column_names is None or column_names == infodict['columns']:\n                if unique is not None and infodict['unique'] != unique:\n                    continue\n                if primary_key is not None and infodict['primary_key'] != primary_key:\n                    continue\n                if index is not None and infodict['index'] != index:\n                    continue\n                # When both unique and index are specified, ensure both conditions are met\n                if unique is not None and index is not None:\n                    if infodict['unique'] != unique or infodict['index'] != index:\n                        continue\n                if check is not None and infodict['check'] != check:\n                    continue\n                if foreign_key is not None and not infodict['foreign_key']:\n                    continue\n                if type_ is not None and infodict['type'] != type_:\n                    continue\n                if not exclude or name not in exclude:\n                    result.append(name)\n        return result\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..4fef9168a0 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -375,9 +375,10 @@ class BaseDatabaseSchemaEditor:\n         \"\"\"\n         olds = {tuple(fields) for fields in old_unique_together}\n         news = {tuple(fields) for fields in new_unique_together}\n+\n         # Deleted uniques\n         for fields in olds.difference(news):\n-            self._delete_composed_index(model, fields, {'unique': True}, self.sql_delete_unique)\n+            self._delete_composed_index(model, fields, {'unique': True, 'index': False}, self.sql_delete_unique)\n         # Created uniques\n         for fields in news.difference(olds):\n             columns = [model._meta.get_field(field).column for field in fields]\n@@ -391,14 +392,16 @@ class BaseDatabaseSchemaEditor:\n         \"\"\"\n         olds = {tuple(fields) for fields in old_index_together}\n         news = {tuple(fields) for fields in new_index_together}\n+\n         # Deleted indexes\n         for fields in olds.difference(news):\n-            self._delete_composed_index(model, fields, {'index': True}, self.sql_delete_index)\n+            self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n         # Created indexes\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n \n+\n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n@@ -1151,6 +1154,7 @@ class BaseDatabaseSchemaEditor:\n         with self.connection.cursor() as cursor:\n             constraints = self.connection.introspection.get_constraints(cursor, model._meta.db_table)\n         result = []\n+\n         for name, infodict in constraints.items():\n             if column_names is None or column_names == infodict['columns']:\n                 if unique is not None and infodict['unique'] != unique:\n",
    "variant_0": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..f58d3fcaf7 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -375,14 +375,24 @@ class BaseDatabaseSchemaEditor:\n         \"\"\"\n         olds = {tuple(fields) for fields in old_unique_together}\n         news = {tuple(fields) for fields in new_unique_together}\n+\n         # Deleted uniques\n         for fields in olds.difference(news):\n-            self._delete_composed_index(model, fields, {'unique': True}, self.sql_delete_unique)\n+            self._delete_composed_index(model, fields, {'unique': True, 'index': False}, self.sql_delete_unique)\n         # Created uniques\n         for fields in news.difference(olds):\n             columns = [model._meta.get_field(field).column for field in fields]\n             self.execute(self._create_unique_sql(model, columns))\n \n+    def alter_index_together(self, model, old_index_together, new_index_together):\n+        \"\"\"\n+        Deal with a model changing its index_together. The input\n+        index_togethers must be doubly-nested, not the single-nested\n+        [\"foo\", \"bar\"] format.\n+        \"\"\"\n+        olds = {tuple(fields) for fields in old_index_together}\n+        news = {tuple(fields) for fields in new_index_together}\n+\n     def alter_index_together(self, model, old_index_together, new_index_together):\n         \"\"\"\n         Deal with a model changing its index_together. The input\n@@ -393,19 +403,31 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_index_together}\n         # Deleted indexes\n         for fields in olds.difference(news):\n-            self._delete_composed_index(model, fields, {'index': True}, self.sql_delete_index)\n+            self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n         # Created indexes\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n \n+\n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n+        \n+        # Make constraint filtering more specific to avoid conflicts between\n+        # unique_together and index_together on the same fields\n+        filter_kwargs = constraint_kwargs.copy()\n+        if constraint_kwargs.get('index') and not constraint_kwargs.get('unique'):\n+            # When deleting index constraints, explicitly exclude unique constraints\n+            filter_kwargs['unique'] = False\n+        elif constraint_kwargs.get('unique') and not constraint_kwargs.get('index'):\n+            # When deleting unique constraints, explicitly exclude index constraints\n+            filter_kwargs['index'] = False\n+            \n         constraint_names = self._constraint_names(\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n-            **constraint_kwargs\n+            **filter_kwargs\n         )\n         if len(constraint_names) != 1:\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n@@ -1151,6 +1173,18 @@ class BaseDatabaseSchemaEditor:\n         with self.connection.cursor() as cursor:\n             constraints = self.connection.introspection.get_constraints(cursor, model._meta.db_table)\n         result = []\n+\n+    def _constraint_names(self, model, column_names=None, unique=None, primary_key=None,\n+                          index=None, foreign_key=None, check=None, type_=None, exclude=None):\n+        \"\"\"Return all constraint names matching the columns and conditions.\"\"\"\n+        if column_names is not None:\n+            column_names = [\n+                self.connection.introspection.identifier_converter(name)\n+                for name in column_names\n+            ]\n+        with self.connection.cursor() as cursor:\n+            constraints = self.connection.introspection.get_constraints(cursor, model._meta.db_table)\n+        result = []\n         for name, infodict in constraints.items():\n             if column_names is None or column_names == infodict['columns']:\n                 if unique is not None and infodict['unique'] != unique:\n@@ -1159,6 +1193,11 @@ class BaseDatabaseSchemaEditor:\n                     continue\n                 if index is not None and infodict['index'] != index:\n                     continue\n+                # When both unique and index filters are specified, ensure the constraint\n+                # matches both criteria to distinguish between different constraint types\n+                if (unique is not None and index is not None and \n+                    (infodict['unique'] != unique or infodict['index'] != index)):\n+                    continue\n                 if check is not None and infodict['check'] != check:\n                     continue\n                 if foreign_key is not None and not infodict['foreign_key']:\n",
    "variant_1": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..9d4fa256f4 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -375,14 +375,24 @@ class BaseDatabaseSchemaEditor:\n         \"\"\"\n         olds = {tuple(fields) for fields in old_unique_together}\n         news = {tuple(fields) for fields in new_unique_together}\n+\n         # Deleted uniques\n         for fields in olds.difference(news):\n-            self._delete_composed_index(model, fields, {'unique': True}, self.sql_delete_unique)\n+            self._delete_composed_index(model, fields, {'unique': True, 'index': False}, self.sql_delete_unique)\n         # Created uniques\n         for fields in news.difference(olds):\n             columns = [model._meta.get_field(field).column for field in fields]\n             self.execute(self._create_unique_sql(model, columns))\n \n+    def alter_index_together(self, model, old_index_together, new_index_together):\n+        \"\"\"\n+        Deal with a model changing its index_together. The input\n+        index_togethers must be doubly-nested, not the single-nested\n+        [\"foo\", \"bar\"] format.\n+        \"\"\"\n+        olds = {tuple(fields) for fields in old_index_together}\n+        news = {tuple(fields) for fields in new_index_together}\n+\n     def alter_index_together(self, model, old_index_together, new_index_together):\n         \"\"\"\n         Deal with a model changing its index_together. The input\n@@ -393,19 +403,32 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_index_together}\n         # Deleted indexes\n         for fields in olds.difference(news):\n-            self._delete_composed_index(model, fields, {'index': True}, self.sql_delete_index)\n+            self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n+        # Created indexes\n+        for field_names in news.difference(olds):\n+            fields = [model._meta.get_field(field) for field in field_names]\n+            self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n         # Created indexes\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n \n+\n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n+        \n+        # Enhanced constraint filtering to distinguish between index and unique constraints\n+        filter_kwargs = constraint_kwargs.copy()\n+        if constraint_kwargs.get('index') and 'unique' not in constraint_kwargs:\n+            filter_kwargs['unique'] = False\n+        elif constraint_kwargs.get('unique') and 'index' not in constraint_kwargs:\n+            filter_kwargs['index'] = False\n+            \n         constraint_names = self._constraint_names(\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n-            **constraint_kwargs\n+            **filter_kwargs\n         )\n         if len(constraint_names) != 1:\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n@@ -1151,6 +1174,18 @@ class BaseDatabaseSchemaEditor:\n         with self.connection.cursor() as cursor:\n             constraints = self.connection.introspection.get_constraints(cursor, model._meta.db_table)\n         result = []\n+\n+    def _constraint_names(self, model, column_names=None, unique=None, primary_key=None, index=None, foreign_key=None,\n+                          check=None, type_=None, exclude=None):\n+        \"\"\"Return all constraint names matching the columns and conditions.\"\"\"\n+        if column_names is not None:\n+            column_names = [\n+                self.connection.introspection.identifier_converter(name)\n+                for name in column_names\n+            ]\n+        with self.connection.cursor() as cursor:\n+            constraints = self.connection.introspection.get_constraints(cursor, model._meta.db_table)\n+        result = []\n         for name, infodict in constraints.items():\n             if column_names is None or column_names == infodict['columns']:\n                 if unique is not None and infodict['unique'] != unique:\n@@ -1159,6 +1194,12 @@ class BaseDatabaseSchemaEditor:\n                     continue\n                 if index is not None and infodict['index'] != index:\n                     continue\n+                # When both unique and index are specified, ensure the constraint\n+                # matches both criteria (e.g., unique=False and index=True means\n+                # we want index constraints that are not unique constraints)\n+                if unique is not None and index is not None:\n+                    if infodict['unique'] != unique or infodict['index'] != index:\n+                        continue\n                 if check is not None and infodict['check'] != check:\n                     continue\n                 if foreign_key is not None and not infodict['foreign_key']:\n",
    "variant_2": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..8aa3e39410 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -375,14 +375,24 @@ class BaseDatabaseSchemaEditor:\n         \"\"\"\n         olds = {tuple(fields) for fields in old_unique_together}\n         news = {tuple(fields) for fields in new_unique_together}\n+\n         # Deleted uniques\n         for fields in olds.difference(news):\n-            self._delete_composed_index(model, fields, {'unique': True}, self.sql_delete_unique)\n+            self._delete_composed_index(model, fields, {'unique': True, 'index': False}, self.sql_delete_unique)\n         # Created uniques\n         for fields in news.difference(olds):\n             columns = [model._meta.get_field(field).column for field in fields]\n             self.execute(self._create_unique_sql(model, columns))\n \n+    def alter_index_together(self, model, old_index_together, new_index_together):\n+        \"\"\"\n+        Deal with a model changing its index_together. The input\n+        index_togethers must be doubly-nested, not the single-nested\n+        [\"foo\", \"bar\"] format.\n+        \"\"\"\n+        olds = {tuple(fields) for fields in old_index_together}\n+        news = {tuple(fields) for fields in new_index_together}\n+\n     def alter_index_together(self, model, old_index_together, new_index_together):\n         \"\"\"\n         Deal with a model changing its index_together. The input\n@@ -393,19 +403,31 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_index_together}\n         # Deleted indexes\n         for fields in olds.difference(news):\n-            self._delete_composed_index(model, fields, {'index': True}, self.sql_delete_index)\n+            self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n         # Created indexes\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n \n+\n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n+        \n+        # Make constraint filtering more specific to avoid conflicts between\n+        # unique_together and index_together constraints on the same fields\n+        filter_kwargs = constraint_kwargs.copy()\n+        if constraint_kwargs.get('index'):\n+            # When deleting index constraints, exclude unique constraints\n+            filter_kwargs['unique'] = False\n+        elif constraint_kwargs.get('unique'):\n+            # When deleting unique constraints, exclude index constraints\n+            filter_kwargs['index'] = False\n+        \n         constraint_names = self._constraint_names(\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n-            **constraint_kwargs\n+            **filter_kwargs\n         )\n         if len(constraint_names) != 1:\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n@@ -1139,6 +1161,19 @@ class BaseDatabaseSchemaEditor:\n             name=self.quote_name(name),\n         )\n \n+    def _constraint_names(self, model, column_names=None, unique=None,\n+                          primary_key=None, index=None, foreign_key=None,\n+                          check=None, type_=None, exclude=None):\n+        \"\"\"Return all constraint names matching the columns and conditions.\"\"\"\n+        if column_names is not None:\n+            column_names = [\n+                self.connection.introspection.identifier_converter(name)\n+                for name in column_names\n+            ]\n+        with self.connection.cursor() as cursor:\n+            constraints = self.connection.introspection.get_constraints(cursor, model._meta.db_table)\n+        result = []\n+\n     def _constraint_names(self, model, column_names=None, unique=None,\n                           primary_key=None, index=None, foreign_key=None,\n                           check=None, type_=None, exclude=None):\n@@ -1165,6 +1200,10 @@ class BaseDatabaseSchemaEditor:\n                     continue\n                 if type_ is not None and infodict['type'] != type_:\n                     continue\n+                # When both unique and index are specified, ensure they match exactly\n+                if unique is not None and index is not None:\n+                    if infodict['unique'] != unique or infodict['index'] != index:\n+                        continue\n                 if not exclude or name not in exclude:\n                     result.append(name)\n         return result\n",
    "variant_3": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..e58b64090f 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -375,14 +375,24 @@ class BaseDatabaseSchemaEditor:\n         \"\"\"\n         olds = {tuple(fields) for fields in old_unique_together}\n         news = {tuple(fields) for fields in new_unique_together}\n+\n         # Deleted uniques\n         for fields in olds.difference(news):\n-            self._delete_composed_index(model, fields, {'unique': True}, self.sql_delete_unique)\n+            self._delete_composed_index(model, fields, {'unique': True, 'index': False}, self.sql_delete_unique)\n         # Created uniques\n         for fields in news.difference(olds):\n             columns = [model._meta.get_field(field).column for field in fields]\n             self.execute(self._create_unique_sql(model, columns))\n \n+    def alter_index_together(self, model, old_index_together, new_index_together):\n+        \"\"\"\n+        Deal with a model changing its index_together. The input\n+        index_togethers must be doubly-nested, not the single-nested\n+        [\"foo\", \"bar\"] format.\n+        \"\"\"\n+        olds = {tuple(fields) for fields in old_index_together}\n+        news = {tuple(fields) for fields in new_index_together}\n+\n     def alter_index_together(self, model, old_index_together, new_index_together):\n         \"\"\"\n         Deal with a model changing its index_together. The input\n@@ -393,27 +403,39 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_index_together}\n         # Deleted indexes\n         for fields in olds.difference(news):\n-            self._delete_composed_index(model, fields, {'index': True}, self.sql_delete_index)\n+            self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n         # Created indexes\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n \n-    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n-        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n-        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n-        columns = [model._meta.get_field(field).column for field in fields]\n-        constraint_names = self._constraint_names(\n-            model, columns, exclude=meta_constraint_names | meta_index_names,\n-            **constraint_kwargs\n-        )\n-        if len(constraint_names) != 1:\n-            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n-                len(constraint_names),\n-                model._meta.db_table,\n-                \", \".join(columns),\n-            ))\n-        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+\n+def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+    meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n+    meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+    columns = [model._meta.get_field(field).column for field in fields]\n+    \n+    # Make constraint filtering more specific to avoid conflicts between\n+    # unique_together and index_together on the same fields\n+    filter_kwargs = constraint_kwargs.copy()\n+    if constraint_kwargs.get('index') and not constraint_kwargs.get('unique', True):\n+        # When deleting index constraints, explicitly exclude unique constraints\n+        filter_kwargs['unique'] = False\n+    elif constraint_kwargs.get('unique') and not constraint_kwargs.get('index', True):\n+        # When deleting unique constraints, explicitly exclude index constraints\n+        filter_kwargs['index'] = False\n+    \n+    constraint_names = self._constraint_names(\n+        model, columns, exclude=meta_constraint_names | meta_index_names,\n+        **filter_kwargs\n+    )\n+    if len(constraint_names) != 1:\n+        raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+            len(constraint_names),\n+            model._meta.db_table,\n+            \", \".join(columns),\n+        ))\n+    self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def alter_db_table(self, model, old_db_table, new_db_table):\n         \"\"\"Rename the table a model points to.\"\"\"\n@@ -1151,6 +1173,18 @@ class BaseDatabaseSchemaEditor:\n         with self.connection.cursor() as cursor:\n             constraints = self.connection.introspection.get_constraints(cursor, model._meta.db_table)\n         result = []\n+\n+    def _constraint_names(self, model, column_names=None, unique=None, primary_key=None, index=None, foreign_key=None,\n+                          check=None, type_=None, exclude=None):\n+        \"\"\"Return all constraint names matching the columns and conditions.\"\"\"\n+        if column_names is not None:\n+            column_names = [\n+                self.connection.introspection.identifier_converter(name)\n+                for name in column_names\n+            ]\n+        with self.connection.cursor() as cursor:\n+            constraints = self.connection.introspection.get_constraints(cursor, model._meta.db_table)\n+        result = []\n         for name, infodict in constraints.items():\n             if column_names is None or column_names == infodict['columns']:\n                 if unique is not None and infodict['unique'] != unique:\n@@ -1165,6 +1199,10 @@ class BaseDatabaseSchemaEditor:\n                     continue\n                 if type_ is not None and infodict['type'] != type_:\n                     continue\n+                # When both unique and index are specified, ensure constraint matches both criteria\n+                if unique is not None and index is not None:\n+                    if infodict['unique'] != unique or infodict['index'] != index:\n+                        continue\n                 if not exclude or name not in exclude:\n                     result.append(name)\n         return result\n",
    "variant_4": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..d3fa117b04 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -375,14 +375,24 @@ class BaseDatabaseSchemaEditor:\n         \"\"\"\n         olds = {tuple(fields) for fields in old_unique_together}\n         news = {tuple(fields) for fields in new_unique_together}\n+\n         # Deleted uniques\n         for fields in olds.difference(news):\n-            self._delete_composed_index(model, fields, {'unique': True}, self.sql_delete_unique)\n+            self._delete_composed_index(model, fields, {'unique': True, 'index': False}, self.sql_delete_unique)\n         # Created uniques\n         for fields in news.difference(olds):\n             columns = [model._meta.get_field(field).column for field in fields]\n             self.execute(self._create_unique_sql(model, columns))\n \n+    def alter_index_together(self, model, old_index_together, new_index_together):\n+        \"\"\"\n+        Deal with a model changing its index_together. The input\n+        index_togethers must be doubly-nested, not the single-nested\n+        [\"foo\", \"bar\"] format.\n+        \"\"\"\n+        olds = {tuple(fields) for fields in old_index_together}\n+        news = {tuple(fields) for fields in new_index_together}\n+\n     def alter_index_together(self, model, old_index_together, new_index_together):\n         \"\"\"\n         Deal with a model changing its index_together. The input\n@@ -393,19 +403,33 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_index_together}\n         # Deleted indexes\n         for fields in olds.difference(news):\n-            self._delete_composed_index(model, fields, {'index': True}, self.sql_delete_index)\n+            self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n+        # Created indexes\n+        for field_names in news.difference(olds):\n+            fields = [model._meta.get_field(field) for field in field_names]\n+            self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n         # Created indexes\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n \n+\n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n+        \n+        # Make constraint filtering more specific to avoid conflicts between\n+        # index_together and unique_together constraints on same fields\n+        filter_kwargs = constraint_kwargs.copy()\n+        if constraint_kwargs.get('index') and constraint_kwargs.get('unique') is None:\n+            filter_kwargs['unique'] = False\n+        elif constraint_kwargs.get('unique') and constraint_kwargs.get('index') is None:\n+            filter_kwargs['index'] = False\n+            \n         constraint_names = self._constraint_names(\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n-            **constraint_kwargs\n+            **filter_kwargs\n         )\n         if len(constraint_names) != 1:\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n@@ -1139,6 +1163,19 @@ class BaseDatabaseSchemaEditor:\n             name=self.quote_name(name),\n         )\n \n+    def _constraint_names(self, model, column_names=None, unique=None,\n+                          primary_key=None, index=None, foreign_key=None,\n+                          check=None, type_=None, exclude=None):\n+        \"\"\"Return all constraint names matching the columns and conditions.\"\"\"\n+        if column_names is not None:\n+            column_names = [\n+                self.connection.introspection.identifier_converter(name)\n+                for name in column_names\n+            ]\n+        with self.connection.cursor() as cursor:\n+            constraints = self.connection.introspection.get_constraints(cursor, model._meta.db_table)\n+        result = []\n+\n     def _constraint_names(self, model, column_names=None, unique=None,\n                           primary_key=None, index=None, foreign_key=None,\n                           check=None, type_=None, exclude=None):\n@@ -1165,6 +1202,15 @@ class BaseDatabaseSchemaEditor:\n                     continue\n                 if type_ is not None and infodict['type'] != type_:\n                     continue\n+                # Additional filtering for unique/index combination\n+                if unique is False and index is True:\n+                    # Only include non-unique indexes\n+                    if infodict['unique'] or not infodict['index']:\n+                        continue\n+                elif unique is True and index is False:\n+                    # Only include unique constraints that are not regular indexes\n+                    if not infodict['unique'] or (infodict['index'] and not infodict['unique']):\n+                        continue\n                 if not exclude or name not in exclude:\n                     result.append(name)\n         return result\n",
    "variant_5": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..82eab9911b 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -375,14 +375,24 @@ class BaseDatabaseSchemaEditor:\n         \"\"\"\n         olds = {tuple(fields) for fields in old_unique_together}\n         news = {tuple(fields) for fields in new_unique_together}\n+\n         # Deleted uniques\n         for fields in olds.difference(news):\n-            self._delete_composed_index(model, fields, {'unique': True}, self.sql_delete_unique)\n+            self._delete_composed_index(model, fields, {'unique': True, 'index': False}, self.sql_delete_unique)\n         # Created uniques\n         for fields in news.difference(olds):\n             columns = [model._meta.get_field(field).column for field in fields]\n             self.execute(self._create_unique_sql(model, columns))\n \n+    def alter_index_together(self, model, old_index_together, new_index_together):\n+        \"\"\"\n+        Deal with a model changing its index_together. The input\n+        index_togethers must be doubly-nested, not the single-nested\n+        [\"foo\", \"bar\"] format.\n+        \"\"\"\n+        olds = {tuple(fields) for fields in old_index_together}\n+        news = {tuple(fields) for fields in new_index_together}\n+\n     def alter_index_together(self, model, old_index_together, new_index_together):\n         \"\"\"\n         Deal with a model changing its index_together. The input\n@@ -393,18 +403,33 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_index_together}\n         # Deleted indexes\n         for fields in olds.difference(news):\n-            self._delete_composed_index(model, fields, {'index': True}, self.sql_delete_index)\n+            self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n+        # Created indexes\n+        for field_names in news.difference(olds):\n+            fields = [model._meta.get_field(field) for field in field_names]\n+            self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n         # Created indexes\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n \n+\n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n+        \n+        # Enhanced constraint filtering to distinguish between index and unique constraints\n+        exclude_names = meta_constraint_names | meta_index_names\n+        if constraint_kwargs.get('index') and constraint_kwargs.get('unique') is False:\n+            # When deleting index constraints, also exclude unique constraints\n+            constraint_kwargs = dict(constraint_kwargs, unique=False)\n+        elif constraint_kwargs.get('unique') and constraint_kwargs.get('index') is False:\n+            # When deleting unique constraints, also exclude index constraints\n+            constraint_kwargs = dict(constraint_kwargs, index=False)\n+            \n         constraint_names = self._constraint_names(\n-            model, columns, exclude=meta_constraint_names | meta_index_names,\n+            model, columns, exclude=exclude_names,\n             **constraint_kwargs\n         )\n         if len(constraint_names) != 1:\n@@ -1139,6 +1164,19 @@ class BaseDatabaseSchemaEditor:\n             name=self.quote_name(name),\n         )\n \n+    def _constraint_names(self, model, column_names=None, unique=None,\n+                          primary_key=None, index=None, foreign_key=None,\n+                          check=None, type_=None, exclude=None):\n+        \"\"\"Return all constraint names matching the columns and conditions.\"\"\"\n+        if column_names is not None:\n+            column_names = [\n+                self.connection.introspection.identifier_converter(name)\n+                for name in column_names\n+            ]\n+        with self.connection.cursor() as cursor:\n+            constraints = self.connection.introspection.get_constraints(cursor, model._meta.db_table)\n+        result = []\n+\n     def _constraint_names(self, model, column_names=None, unique=None,\n                           primary_key=None, index=None, foreign_key=None,\n                           check=None, type_=None, exclude=None):\n@@ -1165,6 +1203,10 @@ class BaseDatabaseSchemaEditor:\n                     continue\n                 if type_ is not None and infodict['type'] != type_:\n                     continue\n+                # When both unique and index are specified, ensure they match both criteria\n+                if unique is not None and index is not None:\n+                    if infodict['unique'] != unique or infodict['index'] != index:\n+                        continue\n                 if not exclude or name not in exclude:\n                     result.append(name)\n         return result\n",
    "variant_6": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..3947366d98 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -375,14 +375,24 @@ class BaseDatabaseSchemaEditor:\n         \"\"\"\n         olds = {tuple(fields) for fields in old_unique_together}\n         news = {tuple(fields) for fields in new_unique_together}\n+\n         # Deleted uniques\n         for fields in olds.difference(news):\n-            self._delete_composed_index(model, fields, {'unique': True}, self.sql_delete_unique)\n+            self._delete_composed_index(model, fields, {'unique': True, 'index': False}, self.sql_delete_unique)\n         # Created uniques\n         for fields in news.difference(olds):\n             columns = [model._meta.get_field(field).column for field in fields]\n             self.execute(self._create_unique_sql(model, columns))\n \n+    def alter_index_together(self, model, old_index_together, new_index_together):\n+        \"\"\"\n+        Deal with a model changing its index_together. The input\n+        index_togethers must be doubly-nested, not the single-nested\n+        [\"foo\", \"bar\"] format.\n+        \"\"\"\n+        olds = {tuple(fields) for fields in old_index_together}\n+        news = {tuple(fields) for fields in new_index_together}\n+\n     def alter_index_together(self, model, old_index_together, new_index_together):\n         \"\"\"\n         Deal with a model changing its index_together. The input\n@@ -393,19 +403,28 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_index_together}\n         # Deleted indexes\n         for fields in olds.difference(news):\n-            self._delete_composed_index(model, fields, {'index': True}, self.sql_delete_index)\n+            self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n         # Created indexes\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n \n+\n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n+        \n+        # Enhanced constraint filtering to distinguish between constraint types\n+        filter_kwargs = constraint_kwargs.copy()\n+        if constraint_kwargs.get('index') and 'unique' not in constraint_kwargs:\n+            filter_kwargs['unique'] = False\n+        elif constraint_kwargs.get('unique') and 'index' not in constraint_kwargs:\n+            filter_kwargs['index'] = False\n+            \n         constraint_names = self._constraint_names(\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n-            **constraint_kwargs\n+            **filter_kwargs\n         )\n         if len(constraint_names) != 1:\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n@@ -1151,6 +1170,18 @@ class BaseDatabaseSchemaEditor:\n         with self.connection.cursor() as cursor:\n             constraints = self.connection.introspection.get_constraints(cursor, model._meta.db_table)\n         result = []\n+\n+    def _constraint_names(self, model, column_names=None, unique=None, primary_key=None, index=None, foreign_key=None,\n+                          check=None, type_=None, exclude=None):\n+        \"\"\"Return all constraint names matching the columns and conditions.\"\"\"\n+        if column_names is not None:\n+            column_names = [\n+                self.connection.introspection.identifier_converter(name)\n+                for name in column_names\n+            ]\n+        with self.connection.cursor() as cursor:\n+            constraints = self.connection.introspection.get_constraints(cursor, model._meta.db_table)\n+        result = []\n         for name, infodict in constraints.items():\n             if column_names is None or column_names == infodict['columns']:\n                 if unique is not None and infodict['unique'] != unique:\n@@ -1165,6 +1196,12 @@ class BaseDatabaseSchemaEditor:\n                     continue\n                 if type_ is not None and infodict['type'] != type_:\n                     continue\n+                # When both unique and index are specified, ensure they don't conflict\n+                if unique is not None and index is not None:\n+                    if unique and infodict['index'] and not infodict['unique']:\n+                        continue\n+                    if index and infodict['unique'] and not infodict['index']:\n+                        continue\n                 if not exclude or name not in exclude:\n                     result.append(name)\n         return result\n",
    "variant_7": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..adb7cd6713 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -375,14 +375,24 @@ class BaseDatabaseSchemaEditor:\n         \"\"\"\n         olds = {tuple(fields) for fields in old_unique_together}\n         news = {tuple(fields) for fields in new_unique_together}\n+\n         # Deleted uniques\n         for fields in olds.difference(news):\n-            self._delete_composed_index(model, fields, {'unique': True}, self.sql_delete_unique)\n+            self._delete_composed_index(model, fields, {'unique': True, 'index': False}, self.sql_delete_unique)\n         # Created uniques\n         for fields in news.difference(olds):\n             columns = [model._meta.get_field(field).column for field in fields]\n             self.execute(self._create_unique_sql(model, columns))\n \n+    def alter_index_together(self, model, old_index_together, new_index_together):\n+        \"\"\"\n+        Deal with a model changing its index_together. The input\n+        index_togethers must be doubly-nested, not the single-nested\n+        [\"foo\", \"bar\"] format.\n+        \"\"\"\n+        olds = {tuple(fields) for fields in old_index_together}\n+        news = {tuple(fields) for fields in new_index_together}\n+\n     def alter_index_together(self, model, old_index_together, new_index_together):\n         \"\"\"\n         Deal with a model changing its index_together. The input\n@@ -393,19 +403,29 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_index_together}\n         # Deleted indexes\n         for fields in olds.difference(news):\n-            self._delete_composed_index(model, fields, {'index': True}, self.sql_delete_index)\n+            self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n         # Created indexes\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n \n+\n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n+        \n+        # Make constraint filtering more specific to avoid conflicts between\n+        # unique_together and index_together constraints on the same fields\n+        filter_kwargs = constraint_kwargs.copy()\n+        if constraint_kwargs.get('index') and not constraint_kwargs.get('unique', True):\n+            filter_kwargs['unique'] = False\n+        elif constraint_kwargs.get('unique') and not constraint_kwargs.get('index', True):\n+            filter_kwargs['index'] = False\n+            \n         constraint_names = self._constraint_names(\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n-            **constraint_kwargs\n+            **filter_kwargs\n         )\n         if len(constraint_names) != 1:\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n@@ -1151,6 +1171,18 @@ class BaseDatabaseSchemaEditor:\n         with self.connection.cursor() as cursor:\n             constraints = self.connection.introspection.get_constraints(cursor, model._meta.db_table)\n         result = []\n+\n+    def _constraint_names(self, model, column_names=None, unique=None, primary_key=None, index=None, foreign_key=None,\n+                          check=None, type_=None, exclude=None):\n+        \"\"\"Return all constraint names matching the columns and conditions.\"\"\"\n+        if column_names is not None:\n+            column_names = [\n+                self.connection.introspection.identifier_converter(name)\n+                for name in column_names\n+            ]\n+        with self.connection.cursor() as cursor:\n+            constraints = self.connection.introspection.get_constraints(cursor, model._meta.db_table)\n+        result = []\n         for name, infodict in constraints.items():\n             if column_names is None or column_names == infodict['columns']:\n                 if unique is not None and infodict['unique'] != unique:\n@@ -1159,6 +1191,12 @@ class BaseDatabaseSchemaEditor:\n                     continue\n                 if index is not None and infodict['index'] != index:\n                     continue\n+                # When both unique and index filters are specified, ensure the constraint\n+                # matches both criteria to distinguish between different constraint types\n+                # on the same columns\n+                if (unique is not None and index is not None and \n+                    (infodict['unique'] != unique or infodict['index'] != index)):\n+                    continue\n                 if check is not None and infodict['check'] != check:\n                     continue\n                 if foreign_key is not None and not infodict['foreign_key']:\n",
    "variant_8": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..86dbf6e921 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -375,14 +375,24 @@ class BaseDatabaseSchemaEditor:\n         \"\"\"\n         olds = {tuple(fields) for fields in old_unique_together}\n         news = {tuple(fields) for fields in new_unique_together}\n+\n         # Deleted uniques\n         for fields in olds.difference(news):\n-            self._delete_composed_index(model, fields, {'unique': True}, self.sql_delete_unique)\n+            self._delete_composed_index(model, fields, {'unique': True, 'index': False}, self.sql_delete_unique)\n         # Created uniques\n         for fields in news.difference(olds):\n             columns = [model._meta.get_field(field).column for field in fields]\n             self.execute(self._create_unique_sql(model, columns))\n \n+    def alter_index_together(self, model, old_index_together, new_index_together):\n+        \"\"\"\n+        Deal with a model changing its index_together. The input\n+        index_togethers must be doubly-nested, not the single-nested\n+        [\"foo\", \"bar\"] format.\n+        \"\"\"\n+        olds = {tuple(fields) for fields in old_index_together}\n+        news = {tuple(fields) for fields in new_index_together}\n+\n     def alter_index_together(self, model, old_index_together, new_index_together):\n         \"\"\"\n         Deal with a model changing its index_together. The input\n@@ -393,19 +403,34 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_index_together}\n         # Deleted indexes\n         for fields in olds.difference(news):\n-            self._delete_composed_index(model, fields, {'index': True}, self.sql_delete_index)\n+            self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n+        # Created indexes\n+        for field_names in news.difference(olds):\n+            fields = [model._meta.get_field(field) for field in field_names]\n+            self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n         # Created indexes\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n \n+\n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n+        \n+        # Enhanced constraint filtering to distinguish between unique and index constraints\n+        filter_kwargs = constraint_kwargs.copy()\n+        if constraint_kwargs.get('index') and not constraint_kwargs.get('unique', True):\n+            # When deleting index constraints, explicitly exclude unique constraints\n+            filter_kwargs['unique'] = False\n+        elif constraint_kwargs.get('unique') and not constraint_kwargs.get('index', True):\n+            # When deleting unique constraints, explicitly exclude index constraints\n+            filter_kwargs['index'] = False\n+            \n         constraint_names = self._constraint_names(\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n-            **constraint_kwargs\n+            **filter_kwargs\n         )\n         if len(constraint_names) != 1:\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n@@ -1151,6 +1176,18 @@ class BaseDatabaseSchemaEditor:\n         with self.connection.cursor() as cursor:\n             constraints = self.connection.introspection.get_constraints(cursor, model._meta.db_table)\n         result = []\n+\n+    def _constraint_names(self, model, column_names=None, unique=None, primary_key=None, index=None, foreign_key=None,\n+                          check=None, type_=None, exclude=None):\n+        \"\"\"Return all constraint names matching the columns and conditions.\"\"\"\n+        if column_names is not None:\n+            column_names = [\n+                self.connection.introspection.identifier_converter(name)\n+                for name in column_names\n+            ]\n+        with self.connection.cursor() as cursor:\n+            constraints = self.connection.introspection.get_constraints(cursor, model._meta.db_table)\n+        result = []\n         for name, infodict in constraints.items():\n             if column_names is None or column_names == infodict['columns']:\n                 if unique is not None and infodict['unique'] != unique:\n@@ -1159,6 +1196,10 @@ class BaseDatabaseSchemaEditor:\n                     continue\n                 if index is not None and infodict['index'] != index:\n                     continue\n+                # When both unique and index are specified, ensure both conditions are met\n+                if unique is not None and index is not None:\n+                    if infodict['unique'] != unique or infodict['index'] != index:\n+                        continue\n                 if check is not None and infodict['check'] != check:\n                     continue\n                 if foreign_key is not None and not infodict['foreign_key']:\n"
  }
}