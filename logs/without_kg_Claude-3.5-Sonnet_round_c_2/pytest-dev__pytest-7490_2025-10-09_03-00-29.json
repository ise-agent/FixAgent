{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/pytest/src/_pytest/skipping.py lines 249-255)": "\n@hookimpl(hookwrapper=True)\ndef pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n    xfailed = item._store.get(xfailed_key, None)\n    # Always re-evaluate to catch dynamically added xfail markers\n    item._store[xfailed_key] = xfailed = evaluate_xfail_marks(item)\n\n    if not item.config.option.runxfail:\n        if xfailed and not xfailed.run:\n            xfail(\"[NOTRUN] \" + xfailed.reason)\n\n    yield\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/pytest/src/_pytest/skipping.py lines 249-255)": [
      "\n@hookimpl(hookwrapper=True)\ndef pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n    xfailed = item._store.get(xfailed_key, None)\n    # Always re-evaluate to catch dynamically added xfail markers\n    item._store[xfailed_key] = xfailed = evaluate_xfail_marks(item)\n\n    if not item.config.option.runxfail:\n        if xfailed and not xfailed.run:\n            xfail(\"[NOTRUN] \" + xfailed.reason)\n\n    yield\n",
      "\n@hookimpl(hookwrapper=True)\ndef pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n    xfailed = item._store.get(xfailed_key, None)\n    # Always re-evaluate to catch dynamically added xfail markers\n    item._store[xfailed_key] = xfailed = evaluate_xfail_marks(item)\n\n    if not item.config.option.runxfail:\n        if xfailed and not xfailed.run:\n            xfail(\"[NOTRUN] \" + xfailed.reason)\n\n    yield\n",
      "\n@hookimpl(hookwrapper=True)\ndef pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n    xfailed = item._store.get(xfailed_key, None)\n    # Always re-evaluate to catch dynamically added xfail markers\n    item._store[xfailed_key] = xfailed = evaluate_xfail_marks(item)\n\n    if not item.config.option.runxfail:\n        if xfailed and not xfailed.run:\n            xfail(\"[NOTRUN] \" + xfailed.reason)\n\n    yield\n",
      "\n@hookimpl(hookwrapper=True)\ndef pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n    xfailed = item._store.get(xfailed_key, None)\n    # Always re-evaluate to catch dynamically added xfail markers\n    item._store[xfailed_key] = xfailed = evaluate_xfail_marks(item)\n\n    if not item.config.option.runxfail:\n        if xfailed and not xfailed.run:\n            xfail(\"[NOTRUN] \" + xfailed.reason)\n\n    yield\n",
      "\n@hookimpl(hookwrapper=True)\ndef pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n    xfailed = item._store.get(xfailed_key, None)\n    # Always re-evaluate to catch dynamically added xfail markers\n    item._store[xfailed_key] = xfailed = evaluate_xfail_marks(item)\n\n    if not item.config.option.runxfail:\n        if xfailed and not xfailed.run:\n            xfail(\"[NOTRUN] \" + xfailed.reason)\n\n    yield\n",
      "\n@hookimpl(hookwrapper=True)\ndef pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n    xfailed = item._store.get(xfailed_key, None)\n    # Always re-evaluate to catch dynamically added xfail markers\n    item._store[xfailed_key] = xfailed = evaluate_xfail_marks(item)\n\n    if not item.config.option.runxfail:\n        if xfailed and not xfailed.run:\n            xfail(\"[NOTRUN] \" + xfailed.reason)\n\n    yield\n",
      "\n@hookimpl(hookwrapper=True)\ndef pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n    xfailed = item._store.get(xfailed_key, None)\n    # Always re-evaluate to catch dynamically added xfail markers\n    item._store[xfailed_key] = xfailed = evaluate_xfail_marks(item)\n\n    if not item.config.option.runxfail:\n        if xfailed and not xfailed.run:\n            xfail(\"[NOTRUN] \" + xfailed.reason)\n\n    yield\n",
      "\n@hookimpl(hookwrapper=True)\ndef pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n    xfailed = item._store.get(xfailed_key, None)\n    # Always re-evaluate to catch dynamically added xfail markers\n    item._store[xfailed_key] = xfailed = evaluate_xfail_marks(item)\n\n    if not item.config.option.runxfail:\n        if xfailed and not xfailed.run:\n            xfail(\"[NOTRUN] \" + xfailed.reason)\n\n    yield\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex 335e10996..781c97e45 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -246,9 +246,10 @@ def pytest_runtest_setup(item: Item) -> None:\n \n @hookimpl(hookwrapper=True)\n def pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n+\n     xfailed = item._store.get(xfailed_key, None)\n-    if xfailed is None:\n-        item._store[xfailed_key] = xfailed = evaluate_xfail_marks(item)\n+    # Always re-evaluate to catch dynamically added xfail markers\n+    item._store[xfailed_key] = xfailed = evaluate_xfail_marks(item)\n \n     if not item.config.option.runxfail:\n         if xfailed and not xfailed.run:\n",
    "variant_0": "diff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex 335e10996..66f77d840 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -244,11 +244,14 @@ def pytest_runtest_setup(item: Item) -> None:\n             xfail(\"[NOTRUN] \" + xfailed.reason)\n \n \n+@hookimpl(hookwrapper=True)\n+def pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n+\n @hookimpl(hookwrapper=True)\n def pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n     xfailed = item._store.get(xfailed_key, None)\n-    if xfailed is None:\n-        item._store[xfailed_key] = xfailed = evaluate_xfail_marks(item)\n+    # Always re-evaluate to catch dynamically added xfail markers\n+    item._store[xfailed_key] = xfailed = evaluate_xfail_marks(item)\n \n     if not item.config.option.runxfail:\n         if xfailed and not xfailed.run:\n@@ -256,6 +259,8 @@ def pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n \n     yield\n \n+    yield\n+\n \n @hookimpl(hookwrapper=True)\n def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n",
    "variant_1": "diff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex 335e10996..66f77d840 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -244,11 +244,14 @@ def pytest_runtest_setup(item: Item) -> None:\n             xfail(\"[NOTRUN] \" + xfailed.reason)\n \n \n+@hookimpl(hookwrapper=True)\n+def pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n+\n @hookimpl(hookwrapper=True)\n def pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n     xfailed = item._store.get(xfailed_key, None)\n-    if xfailed is None:\n-        item._store[xfailed_key] = xfailed = evaluate_xfail_marks(item)\n+    # Always re-evaluate to catch dynamically added xfail markers\n+    item._store[xfailed_key] = xfailed = evaluate_xfail_marks(item)\n \n     if not item.config.option.runxfail:\n         if xfailed and not xfailed.run:\n@@ -256,6 +259,8 @@ def pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n \n     yield\n \n+    yield\n+\n \n @hookimpl(hookwrapper=True)\n def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n",
    "variant_2": "diff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex 335e10996..66f77d840 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -244,11 +244,14 @@ def pytest_runtest_setup(item: Item) -> None:\n             xfail(\"[NOTRUN] \" + xfailed.reason)\n \n \n+@hookimpl(hookwrapper=True)\n+def pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n+\n @hookimpl(hookwrapper=True)\n def pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n     xfailed = item._store.get(xfailed_key, None)\n-    if xfailed is None:\n-        item._store[xfailed_key] = xfailed = evaluate_xfail_marks(item)\n+    # Always re-evaluate to catch dynamically added xfail markers\n+    item._store[xfailed_key] = xfailed = evaluate_xfail_marks(item)\n \n     if not item.config.option.runxfail:\n         if xfailed and not xfailed.run:\n@@ -256,6 +259,8 @@ def pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n \n     yield\n \n+    yield\n+\n \n @hookimpl(hookwrapper=True)\n def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n",
    "variant_3": "diff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex 335e10996..66f77d840 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -244,11 +244,14 @@ def pytest_runtest_setup(item: Item) -> None:\n             xfail(\"[NOTRUN] \" + xfailed.reason)\n \n \n+@hookimpl(hookwrapper=True)\n+def pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n+\n @hookimpl(hookwrapper=True)\n def pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n     xfailed = item._store.get(xfailed_key, None)\n-    if xfailed is None:\n-        item._store[xfailed_key] = xfailed = evaluate_xfail_marks(item)\n+    # Always re-evaluate to catch dynamically added xfail markers\n+    item._store[xfailed_key] = xfailed = evaluate_xfail_marks(item)\n \n     if not item.config.option.runxfail:\n         if xfailed and not xfailed.run:\n@@ -256,6 +259,8 @@ def pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n \n     yield\n \n+    yield\n+\n \n @hookimpl(hookwrapper=True)\n def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n",
    "variant_4": "diff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex 335e10996..66f77d840 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -244,11 +244,14 @@ def pytest_runtest_setup(item: Item) -> None:\n             xfail(\"[NOTRUN] \" + xfailed.reason)\n \n \n+@hookimpl(hookwrapper=True)\n+def pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n+\n @hookimpl(hookwrapper=True)\n def pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n     xfailed = item._store.get(xfailed_key, None)\n-    if xfailed is None:\n-        item._store[xfailed_key] = xfailed = evaluate_xfail_marks(item)\n+    # Always re-evaluate to catch dynamically added xfail markers\n+    item._store[xfailed_key] = xfailed = evaluate_xfail_marks(item)\n \n     if not item.config.option.runxfail:\n         if xfailed and not xfailed.run:\n@@ -256,6 +259,8 @@ def pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n \n     yield\n \n+    yield\n+\n \n @hookimpl(hookwrapper=True)\n def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n",
    "variant_5": "diff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex 335e10996..66f77d840 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -244,11 +244,14 @@ def pytest_runtest_setup(item: Item) -> None:\n             xfail(\"[NOTRUN] \" + xfailed.reason)\n \n \n+@hookimpl(hookwrapper=True)\n+def pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n+\n @hookimpl(hookwrapper=True)\n def pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n     xfailed = item._store.get(xfailed_key, None)\n-    if xfailed is None:\n-        item._store[xfailed_key] = xfailed = evaluate_xfail_marks(item)\n+    # Always re-evaluate to catch dynamically added xfail markers\n+    item._store[xfailed_key] = xfailed = evaluate_xfail_marks(item)\n \n     if not item.config.option.runxfail:\n         if xfailed and not xfailed.run:\n@@ -256,6 +259,8 @@ def pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n \n     yield\n \n+    yield\n+\n \n @hookimpl(hookwrapper=True)\n def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n",
    "variant_6": "diff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex 335e10996..66f77d840 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -244,11 +244,14 @@ def pytest_runtest_setup(item: Item) -> None:\n             xfail(\"[NOTRUN] \" + xfailed.reason)\n \n \n+@hookimpl(hookwrapper=True)\n+def pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n+\n @hookimpl(hookwrapper=True)\n def pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n     xfailed = item._store.get(xfailed_key, None)\n-    if xfailed is None:\n-        item._store[xfailed_key] = xfailed = evaluate_xfail_marks(item)\n+    # Always re-evaluate to catch dynamically added xfail markers\n+    item._store[xfailed_key] = xfailed = evaluate_xfail_marks(item)\n \n     if not item.config.option.runxfail:\n         if xfailed and not xfailed.run:\n@@ -256,6 +259,8 @@ def pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n \n     yield\n \n+    yield\n+\n \n @hookimpl(hookwrapper=True)\n def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n",
    "variant_7": "diff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex 335e10996..66f77d840 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -244,11 +244,14 @@ def pytest_runtest_setup(item: Item) -> None:\n             xfail(\"[NOTRUN] \" + xfailed.reason)\n \n \n+@hookimpl(hookwrapper=True)\n+def pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n+\n @hookimpl(hookwrapper=True)\n def pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n     xfailed = item._store.get(xfailed_key, None)\n-    if xfailed is None:\n-        item._store[xfailed_key] = xfailed = evaluate_xfail_marks(item)\n+    # Always re-evaluate to catch dynamically added xfail markers\n+    item._store[xfailed_key] = xfailed = evaluate_xfail_marks(item)\n \n     if not item.config.option.runxfail:\n         if xfailed and not xfailed.run:\n@@ -256,6 +259,8 @@ def pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n \n     yield\n \n+    yield\n+\n \n @hookimpl(hookwrapper=True)\n def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n",
    "variant_8": "diff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py\nindex 335e10996..66f77d840 100644\n--- a/src/_pytest/skipping.py\n+++ b/src/_pytest/skipping.py\n@@ -244,11 +244,14 @@ def pytest_runtest_setup(item: Item) -> None:\n             xfail(\"[NOTRUN] \" + xfailed.reason)\n \n \n+@hookimpl(hookwrapper=True)\n+def pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n+\n @hookimpl(hookwrapper=True)\n def pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n     xfailed = item._store.get(xfailed_key, None)\n-    if xfailed is None:\n-        item._store[xfailed_key] = xfailed = evaluate_xfail_marks(item)\n+    # Always re-evaluate to catch dynamically added xfail markers\n+    item._store[xfailed_key] = xfailed = evaluate_xfail_marks(item)\n \n     if not item.config.option.runxfail:\n         if xfailed and not xfailed.run:\n@@ -256,6 +259,8 @@ def pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n \n     yield\n \n+    yield\n+\n \n @hookimpl(hookwrapper=True)\n def pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n"
  }
}