{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/django/django/core/management/commands/sqlmigrate.py lines 59-59)": "\n        # Show begin/end around output only for atomic migrations\n        self.output_transaction = migration.atomic and connection.features.can_rollback_ddl\n",
    "Location 2 (/root/hy/projects_2/django/tests/migrations/test_commands.py lines 618-618)": "\n\n    def test_sqlmigrate_for_non_ddl_rollback_database(self):\n        \"\"\"\n        Transaction wrappers aren't shown for databases that don't support DDL rollback.\n        \"\"\"\n        with mock.patch.object(connection.features, 'can_rollback_ddl', False):\n            out = io.StringIO()\n            call_command(\"sqlmigrate\", \"migrations\", \"0001\", stdout=out)\n            output = out.getvalue().lower()\n            queries = [q.strip() for q in output.splitlines()]\n            if connection.ops.start_transaction_sql():\n                self.assertNotIn(connection.ops.start_transaction_sql().lower(), queries)\n            self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/django/django/core/management/commands/sqlmigrate.py lines 59-59)": [
      "\n        # Show begin/end around output only for atomic migrations\n        self.output_transaction = migration.atomic and connection.features.can_rollback_ddl\n",
      "\n        # Show begin/end around output only for atomic migrations\n        self.output_transaction = migration.atomic and connection.features.can_rollback_ddl\n",
      "\n        # Show begin/end around output only for atomic migrations\n        self.output_transaction = migration.atomic and connection.features.can_rollback_ddl\n",
      "\n        # Show begin/end around output only for atomic migrations\n        self.output_transaction = migration.atomic and connection.features.can_rollback_ddl\n",
      "\n        # Show begin/end around output only for atomic migrations\n        self.output_transaction = migration.atomic and connection.features.can_rollback_ddl\n",
      "\n        # Show begin/end around output only for atomic migrations\n        self.output_transaction = migration.atomic and connection.features.can_rollback_ddl\n",
      "\n        # Show begin/end around output only for atomic migrations\n        self.output_transaction = migration.atomic and connection.features.can_rollback_ddl\n",
      "\n        # Show begin/end around output only for atomic migrations\n        self.output_transaction = migration.atomic and connection.features.can_rollback_ddl\n"
    ],
    "Location 2 (/root/hy/projects_2/django/tests/migrations/test_commands.py lines 618-618)": [
      "\n\n    def test_sqlmigrate_for_non_ddl_rollback_database(self):\n        \"\"\"\n        Transaction wrappers aren't shown for databases that don't support DDL rollback.\n        \"\"\"\n        with mock.patch.object(connection.features, 'can_rollback_ddl', False):\n            out = io.StringIO()\n            call_command(\"sqlmigrate\", \"migrations\", \"0001\", stdout=out)\n            output = out.getvalue().lower()\n            queries = [q.strip() for q in output.splitlines()]\n            if connection.ops.start_transaction_sql():\n                self.assertNotIn(connection.ops.start_transaction_sql().lower(), queries)\n            self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n",
      "\n\n    def test_sqlmigrate_for_non_ddl_rollback_database(self):\n        \"\"\"\n        Transaction wrappers aren't shown for databases that don't support DDL rollback.\n        \"\"\"\n        with mock.patch.object(connection.features, 'can_rollback_ddl', False):\n            out = io.StringIO()\n            call_command(\"sqlmigrate\", \"migrations\", \"0001\", stdout=out)\n            output = out.getvalue().lower()\n            queries = [q.strip() for q in output.splitlines()]\n            if connection.ops.start_transaction_sql():\n                self.assertNotIn(connection.ops.start_transaction_sql().lower(), queries)\n            self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n",
      "\n\n    def test_sqlmigrate_for_non_ddl_rollback_database(self):\n        \"\"\"\n        Transaction wrappers aren't shown for databases that don't support DDL rollback.\n        \"\"\"\n        with mock.patch.object(connection.features, 'can_rollback_ddl', False):\n            out = io.StringIO()\n            call_command(\"sqlmigrate\", \"migrations\", \"0001\", stdout=out)\n            output = out.getvalue().lower()\n            queries = [q.strip() for q in output.splitlines()]\n            if connection.ops.start_transaction_sql():\n                self.assertNotIn(connection.ops.start_transaction_sql().lower(), queries)\n            self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n",
      "\n\n    def test_sqlmigrate_for_non_ddl_rollback_database(self):\n        \"\"\"\n        Transaction wrappers aren't shown for databases that don't support DDL rollback.\n        \"\"\"\n        with mock.patch.object(connection.features, 'can_rollback_ddl', False):\n            out = io.StringIO()\n            call_command(\"sqlmigrate\", \"migrations\", \"0001\", stdout=out)\n            output = out.getvalue().lower()\n            queries = [q.strip() for q in output.splitlines()]\n            if connection.ops.start_transaction_sql():\n                self.assertNotIn(connection.ops.start_transaction_sql().lower(), queries)\n            self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n",
      "\n\n    def test_sqlmigrate_for_non_ddl_rollback_database(self):\n        \"\"\"\n        Transaction wrappers aren't shown for databases that don't support DDL rollback.\n        \"\"\"\n        with mock.patch.object(connection.features, 'can_rollback_ddl', False):\n            out = io.StringIO()\n            call_command(\"sqlmigrate\", \"migrations\", \"0001\", stdout=out)\n            output = out.getvalue().lower()\n            queries = [q.strip() for q in output.splitlines()]\n            if connection.ops.start_transaction_sql():\n                self.assertNotIn(connection.ops.start_transaction_sql().lower(), queries)\n            self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n",
      "\n\n    def test_sqlmigrate_for_non_ddl_rollback_database(self):\n        \"\"\"\n        Transaction wrappers aren't shown for databases that don't support DDL rollback.\n        \"\"\"\n        with mock.patch.object(connection.features, 'can_rollback_ddl', False):\n            out = io.StringIO()\n            call_command(\"sqlmigrate\", \"migrations\", \"0001\", stdout=out)\n            output = out.getvalue().lower()\n            queries = [q.strip() for q in output.splitlines()]\n            if connection.ops.start_transaction_sql():\n                self.assertNotIn(connection.ops.start_transaction_sql().lower(), queries)\n            self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n",
      "\n\n    def test_sqlmigrate_for_non_ddl_rollback_database(self):\n        \"\"\"\n        Transaction wrappers aren't shown for databases that don't support DDL rollback.\n        \"\"\"\n        with mock.patch.object(connection.features, 'can_rollback_ddl', False):\n            out = io.StringIO()\n            call_command(\"sqlmigrate\", \"migrations\", \"0001\", stdout=out)\n            output = out.getvalue().lower()\n            queries = [q.strip() for q in output.splitlines()]\n            if connection.ops.start_transaction_sql():\n                self.assertNotIn(connection.ops.start_transaction_sql().lower(), queries)\n            self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n",
      "\n\n    def test_sqlmigrate_for_non_ddl_rollback_database(self):\n        \"\"\"\n        Transaction wrappers aren't shown for databases that don't support DDL rollback.\n        \"\"\"\n        with mock.patch.object(connection.features, 'can_rollback_ddl', False):\n            out = io.StringIO()\n            call_command(\"sqlmigrate\", \"migrations\", \"0001\", stdout=out)\n            output = out.getvalue().lower()\n            queries = [q.strip() for q in output.splitlines()]\n            if connection.ops.start_transaction_sql():\n                self.assertNotIn(connection.ops.start_transaction_sql().lower(), queries)\n            self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/core/management/commands/sqlmigrate.py b/django/core/management/commands/sqlmigrate.py\nindex f0b663222a..172fccf8b0 100644\n--- a/django/core/management/commands/sqlmigrate.py\n+++ b/django/core/management/commands/sqlmigrate.py\n@@ -56,7 +56,8 @@ class Command(BaseCommand):\n         targets = [(app_label, migration.name)]\n \n         # Show begin/end around output only for atomic migrations\n-        self.output_transaction = migration.atomic\n+\n+        self.output_transaction = migration.atomic and connection.features.can_rollback_ddl\n \n         # Make a plan that represents just the requested migrations and show SQL\n         # for it\ndiff --git a/tests/migrations/test_commands.py b/tests/migrations/test_commands.py\nindex 0e8fa9fdd1..70d4f0ec61 100644\n--- a/tests/migrations/test_commands.py\n+++ b/tests/migrations/test_commands.py\n@@ -616,6 +616,20 @@ class MigrateTests(MigrationTestBase):\n             self.assertNotIn(connection.ops.start_transaction_sql().lower(), queries)\n         self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n \n+\n+    @override_settings(MIGRATION_MODULES={\"migrations\": \"migrations.test_migrations\"})\n+    def test_sqlmigrate_for_non_ddl_rollback_database(self):\n+        \"\"\"\n+        Transaction wrappers aren't shown for databases that don't support DDL rollback.\n+        \"\"\"\n+        with mock.patch.object(connection.features, 'can_rollback_ddl', False):\n+            out = io.StringIO()\n+            call_command(\"sqlmigrate\", \"migrations\", \"0001\", stdout=out)\n+            output = out.getvalue().lower()\n+            queries = [q.strip() for q in output.splitlines()]\n+            if connection.ops.start_transaction_sql():\n+                self.assertNotIn(connection.ops.start_transaction_sql().lower(), queries)\n+            self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n     @override_settings(\n         INSTALLED_APPS=[\n             \"migrations.migrations_test_apps.migrated_app\",\n",
    "variant_0": "diff --git a/django/core/management/commands/sqlmigrate.py b/django/core/management/commands/sqlmigrate.py\nindex f0b663222a..979908c31a 100644\n--- a/django/core/management/commands/sqlmigrate.py\n+++ b/django/core/management/commands/sqlmigrate.py\n@@ -56,7 +56,9 @@ class Command(BaseCommand):\n         targets = [(app_label, migration.name)]\n \n         # Show begin/end around output only for atomic migrations\n-        self.output_transaction = migration.atomic\n+\n+        # Show begin/end around output only for atomic migrations\n+        self.output_transaction = migration.atomic and connection.features.can_rollback_ddl\n \n         # Make a plan that represents just the requested migrations and show SQL\n         # for it\ndiff --git a/tests/migrations/test_commands.py b/tests/migrations/test_commands.py\nindex 0e8fa9fdd1..cef70a35d2 100644\n--- a/tests/migrations/test_commands.py\n+++ b/tests/migrations/test_commands.py\n@@ -616,6 +616,19 @@ class MigrateTests(MigrationTestBase):\n             self.assertNotIn(connection.ops.start_transaction_sql().lower(), queries)\n         self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n \n+\n+    def test_sqlmigrate_for_non_ddl_rollback_database(self):\n+        \"\"\"\n+        Transaction wrappers aren't shown for databases that don't support DDL rollback.\n+        \"\"\"\n+        with mock.patch.object(connection.features, 'can_rollback_ddl', False):\n+            out = io.StringIO()\n+            call_command(\"sqlmigrate\", \"migrations\", \"0001\", stdout=out)\n+            output = out.getvalue().lower()\n+            queries = [q.strip() for q in output.splitlines()]\n+            if connection.ops.start_transaction_sql():\n+                self.assertNotIn(connection.ops.start_transaction_sql().lower(), queries)\n+            self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n     @override_settings(\n         INSTALLED_APPS=[\n             \"migrations.migrations_test_apps.migrated_app\",\n",
    "variant_1": "diff --git a/django/core/management/commands/sqlmigrate.py b/django/core/management/commands/sqlmigrate.py\nindex f0b663222a..979908c31a 100644\n--- a/django/core/management/commands/sqlmigrate.py\n+++ b/django/core/management/commands/sqlmigrate.py\n@@ -56,7 +56,9 @@ class Command(BaseCommand):\n         targets = [(app_label, migration.name)]\n \n         # Show begin/end around output only for atomic migrations\n-        self.output_transaction = migration.atomic\n+\n+        # Show begin/end around output only for atomic migrations\n+        self.output_transaction = migration.atomic and connection.features.can_rollback_ddl\n \n         # Make a plan that represents just the requested migrations and show SQL\n         # for it\ndiff --git a/tests/migrations/test_commands.py b/tests/migrations/test_commands.py\nindex 0e8fa9fdd1..cef70a35d2 100644\n--- a/tests/migrations/test_commands.py\n+++ b/tests/migrations/test_commands.py\n@@ -616,6 +616,19 @@ class MigrateTests(MigrationTestBase):\n             self.assertNotIn(connection.ops.start_transaction_sql().lower(), queries)\n         self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n \n+\n+    def test_sqlmigrate_for_non_ddl_rollback_database(self):\n+        \"\"\"\n+        Transaction wrappers aren't shown for databases that don't support DDL rollback.\n+        \"\"\"\n+        with mock.patch.object(connection.features, 'can_rollback_ddl', False):\n+            out = io.StringIO()\n+            call_command(\"sqlmigrate\", \"migrations\", \"0001\", stdout=out)\n+            output = out.getvalue().lower()\n+            queries = [q.strip() for q in output.splitlines()]\n+            if connection.ops.start_transaction_sql():\n+                self.assertNotIn(connection.ops.start_transaction_sql().lower(), queries)\n+            self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n     @override_settings(\n         INSTALLED_APPS=[\n             \"migrations.migrations_test_apps.migrated_app\",\n",
    "variant_2": "diff --git a/django/core/management/commands/sqlmigrate.py b/django/core/management/commands/sqlmigrate.py\nindex f0b663222a..979908c31a 100644\n--- a/django/core/management/commands/sqlmigrate.py\n+++ b/django/core/management/commands/sqlmigrate.py\n@@ -56,7 +56,9 @@ class Command(BaseCommand):\n         targets = [(app_label, migration.name)]\n \n         # Show begin/end around output only for atomic migrations\n-        self.output_transaction = migration.atomic\n+\n+        # Show begin/end around output only for atomic migrations\n+        self.output_transaction = migration.atomic and connection.features.can_rollback_ddl\n \n         # Make a plan that represents just the requested migrations and show SQL\n         # for it\ndiff --git a/tests/migrations/test_commands.py b/tests/migrations/test_commands.py\nindex 0e8fa9fdd1..cef70a35d2 100644\n--- a/tests/migrations/test_commands.py\n+++ b/tests/migrations/test_commands.py\n@@ -616,6 +616,19 @@ class MigrateTests(MigrationTestBase):\n             self.assertNotIn(connection.ops.start_transaction_sql().lower(), queries)\n         self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n \n+\n+    def test_sqlmigrate_for_non_ddl_rollback_database(self):\n+        \"\"\"\n+        Transaction wrappers aren't shown for databases that don't support DDL rollback.\n+        \"\"\"\n+        with mock.patch.object(connection.features, 'can_rollback_ddl', False):\n+            out = io.StringIO()\n+            call_command(\"sqlmigrate\", \"migrations\", \"0001\", stdout=out)\n+            output = out.getvalue().lower()\n+            queries = [q.strip() for q in output.splitlines()]\n+            if connection.ops.start_transaction_sql():\n+                self.assertNotIn(connection.ops.start_transaction_sql().lower(), queries)\n+            self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n     @override_settings(\n         INSTALLED_APPS=[\n             \"migrations.migrations_test_apps.migrated_app\",\n",
    "variant_3": "diff --git a/django/core/management/commands/sqlmigrate.py b/django/core/management/commands/sqlmigrate.py\nindex f0b663222a..979908c31a 100644\n--- a/django/core/management/commands/sqlmigrate.py\n+++ b/django/core/management/commands/sqlmigrate.py\n@@ -56,7 +56,9 @@ class Command(BaseCommand):\n         targets = [(app_label, migration.name)]\n \n         # Show begin/end around output only for atomic migrations\n-        self.output_transaction = migration.atomic\n+\n+        # Show begin/end around output only for atomic migrations\n+        self.output_transaction = migration.atomic and connection.features.can_rollback_ddl\n \n         # Make a plan that represents just the requested migrations and show SQL\n         # for it\ndiff --git a/tests/migrations/test_commands.py b/tests/migrations/test_commands.py\nindex 0e8fa9fdd1..cef70a35d2 100644\n--- a/tests/migrations/test_commands.py\n+++ b/tests/migrations/test_commands.py\n@@ -616,6 +616,19 @@ class MigrateTests(MigrationTestBase):\n             self.assertNotIn(connection.ops.start_transaction_sql().lower(), queries)\n         self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n \n+\n+    def test_sqlmigrate_for_non_ddl_rollback_database(self):\n+        \"\"\"\n+        Transaction wrappers aren't shown for databases that don't support DDL rollback.\n+        \"\"\"\n+        with mock.patch.object(connection.features, 'can_rollback_ddl', False):\n+            out = io.StringIO()\n+            call_command(\"sqlmigrate\", \"migrations\", \"0001\", stdout=out)\n+            output = out.getvalue().lower()\n+            queries = [q.strip() for q in output.splitlines()]\n+            if connection.ops.start_transaction_sql():\n+                self.assertNotIn(connection.ops.start_transaction_sql().lower(), queries)\n+            self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n     @override_settings(\n         INSTALLED_APPS=[\n             \"migrations.migrations_test_apps.migrated_app\",\n",
    "variant_4": "diff --git a/django/core/management/commands/sqlmigrate.py b/django/core/management/commands/sqlmigrate.py\nindex f0b663222a..979908c31a 100644\n--- a/django/core/management/commands/sqlmigrate.py\n+++ b/django/core/management/commands/sqlmigrate.py\n@@ -56,7 +56,9 @@ class Command(BaseCommand):\n         targets = [(app_label, migration.name)]\n \n         # Show begin/end around output only for atomic migrations\n-        self.output_transaction = migration.atomic\n+\n+        # Show begin/end around output only for atomic migrations\n+        self.output_transaction = migration.atomic and connection.features.can_rollback_ddl\n \n         # Make a plan that represents just the requested migrations and show SQL\n         # for it\ndiff --git a/tests/migrations/test_commands.py b/tests/migrations/test_commands.py\nindex 0e8fa9fdd1..cef70a35d2 100644\n--- a/tests/migrations/test_commands.py\n+++ b/tests/migrations/test_commands.py\n@@ -616,6 +616,19 @@ class MigrateTests(MigrationTestBase):\n             self.assertNotIn(connection.ops.start_transaction_sql().lower(), queries)\n         self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n \n+\n+    def test_sqlmigrate_for_non_ddl_rollback_database(self):\n+        \"\"\"\n+        Transaction wrappers aren't shown for databases that don't support DDL rollback.\n+        \"\"\"\n+        with mock.patch.object(connection.features, 'can_rollback_ddl', False):\n+            out = io.StringIO()\n+            call_command(\"sqlmigrate\", \"migrations\", \"0001\", stdout=out)\n+            output = out.getvalue().lower()\n+            queries = [q.strip() for q in output.splitlines()]\n+            if connection.ops.start_transaction_sql():\n+                self.assertNotIn(connection.ops.start_transaction_sql().lower(), queries)\n+            self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n     @override_settings(\n         INSTALLED_APPS=[\n             \"migrations.migrations_test_apps.migrated_app\",\n",
    "variant_5": "diff --git a/django/core/management/commands/sqlmigrate.py b/django/core/management/commands/sqlmigrate.py\nindex f0b663222a..979908c31a 100644\n--- a/django/core/management/commands/sqlmigrate.py\n+++ b/django/core/management/commands/sqlmigrate.py\n@@ -56,7 +56,9 @@ class Command(BaseCommand):\n         targets = [(app_label, migration.name)]\n \n         # Show begin/end around output only for atomic migrations\n-        self.output_transaction = migration.atomic\n+\n+        # Show begin/end around output only for atomic migrations\n+        self.output_transaction = migration.atomic and connection.features.can_rollback_ddl\n \n         # Make a plan that represents just the requested migrations and show SQL\n         # for it\ndiff --git a/tests/migrations/test_commands.py b/tests/migrations/test_commands.py\nindex 0e8fa9fdd1..cef70a35d2 100644\n--- a/tests/migrations/test_commands.py\n+++ b/tests/migrations/test_commands.py\n@@ -616,6 +616,19 @@ class MigrateTests(MigrationTestBase):\n             self.assertNotIn(connection.ops.start_transaction_sql().lower(), queries)\n         self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n \n+\n+    def test_sqlmigrate_for_non_ddl_rollback_database(self):\n+        \"\"\"\n+        Transaction wrappers aren't shown for databases that don't support DDL rollback.\n+        \"\"\"\n+        with mock.patch.object(connection.features, 'can_rollback_ddl', False):\n+            out = io.StringIO()\n+            call_command(\"sqlmigrate\", \"migrations\", \"0001\", stdout=out)\n+            output = out.getvalue().lower()\n+            queries = [q.strip() for q in output.splitlines()]\n+            if connection.ops.start_transaction_sql():\n+                self.assertNotIn(connection.ops.start_transaction_sql().lower(), queries)\n+            self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n     @override_settings(\n         INSTALLED_APPS=[\n             \"migrations.migrations_test_apps.migrated_app\",\n",
    "variant_6": "diff --git a/django/core/management/commands/sqlmigrate.py b/django/core/management/commands/sqlmigrate.py\nindex f0b663222a..979908c31a 100644\n--- a/django/core/management/commands/sqlmigrate.py\n+++ b/django/core/management/commands/sqlmigrate.py\n@@ -56,7 +56,9 @@ class Command(BaseCommand):\n         targets = [(app_label, migration.name)]\n \n         # Show begin/end around output only for atomic migrations\n-        self.output_transaction = migration.atomic\n+\n+        # Show begin/end around output only for atomic migrations\n+        self.output_transaction = migration.atomic and connection.features.can_rollback_ddl\n \n         # Make a plan that represents just the requested migrations and show SQL\n         # for it\ndiff --git a/tests/migrations/test_commands.py b/tests/migrations/test_commands.py\nindex 0e8fa9fdd1..cef70a35d2 100644\n--- a/tests/migrations/test_commands.py\n+++ b/tests/migrations/test_commands.py\n@@ -616,6 +616,19 @@ class MigrateTests(MigrationTestBase):\n             self.assertNotIn(connection.ops.start_transaction_sql().lower(), queries)\n         self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n \n+\n+    def test_sqlmigrate_for_non_ddl_rollback_database(self):\n+        \"\"\"\n+        Transaction wrappers aren't shown for databases that don't support DDL rollback.\n+        \"\"\"\n+        with mock.patch.object(connection.features, 'can_rollback_ddl', False):\n+            out = io.StringIO()\n+            call_command(\"sqlmigrate\", \"migrations\", \"0001\", stdout=out)\n+            output = out.getvalue().lower()\n+            queries = [q.strip() for q in output.splitlines()]\n+            if connection.ops.start_transaction_sql():\n+                self.assertNotIn(connection.ops.start_transaction_sql().lower(), queries)\n+            self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n     @override_settings(\n         INSTALLED_APPS=[\n             \"migrations.migrations_test_apps.migrated_app\",\n",
    "variant_7": "diff --git a/django/core/management/commands/sqlmigrate.py b/django/core/management/commands/sqlmigrate.py\nindex f0b663222a..979908c31a 100644\n--- a/django/core/management/commands/sqlmigrate.py\n+++ b/django/core/management/commands/sqlmigrate.py\n@@ -56,7 +56,9 @@ class Command(BaseCommand):\n         targets = [(app_label, migration.name)]\n \n         # Show begin/end around output only for atomic migrations\n-        self.output_transaction = migration.atomic\n+\n+        # Show begin/end around output only for atomic migrations\n+        self.output_transaction = migration.atomic and connection.features.can_rollback_ddl\n \n         # Make a plan that represents just the requested migrations and show SQL\n         # for it\ndiff --git a/tests/migrations/test_commands.py b/tests/migrations/test_commands.py\nindex 0e8fa9fdd1..cef70a35d2 100644\n--- a/tests/migrations/test_commands.py\n+++ b/tests/migrations/test_commands.py\n@@ -616,6 +616,19 @@ class MigrateTests(MigrationTestBase):\n             self.assertNotIn(connection.ops.start_transaction_sql().lower(), queries)\n         self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n \n+\n+    def test_sqlmigrate_for_non_ddl_rollback_database(self):\n+        \"\"\"\n+        Transaction wrappers aren't shown for databases that don't support DDL rollback.\n+        \"\"\"\n+        with mock.patch.object(connection.features, 'can_rollback_ddl', False):\n+            out = io.StringIO()\n+            call_command(\"sqlmigrate\", \"migrations\", \"0001\", stdout=out)\n+            output = out.getvalue().lower()\n+            queries = [q.strip() for q in output.splitlines()]\n+            if connection.ops.start_transaction_sql():\n+                self.assertNotIn(connection.ops.start_transaction_sql().lower(), queries)\n+            self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n     @override_settings(\n         INSTALLED_APPS=[\n             \"migrations.migrations_test_apps.migrated_app\",\n",
    "variant_8": "diff --git a/django/core/management/commands/sqlmigrate.py b/django/core/management/commands/sqlmigrate.py\nindex f0b663222a..979908c31a 100644\n--- a/django/core/management/commands/sqlmigrate.py\n+++ b/django/core/management/commands/sqlmigrate.py\n@@ -56,7 +56,9 @@ class Command(BaseCommand):\n         targets = [(app_label, migration.name)]\n \n         # Show begin/end around output only for atomic migrations\n-        self.output_transaction = migration.atomic\n+\n+        # Show begin/end around output only for atomic migrations\n+        self.output_transaction = migration.atomic and connection.features.can_rollback_ddl\n \n         # Make a plan that represents just the requested migrations and show SQL\n         # for it\ndiff --git a/tests/migrations/test_commands.py b/tests/migrations/test_commands.py\nindex 0e8fa9fdd1..cef70a35d2 100644\n--- a/tests/migrations/test_commands.py\n+++ b/tests/migrations/test_commands.py\n@@ -616,6 +616,19 @@ class MigrateTests(MigrationTestBase):\n             self.assertNotIn(connection.ops.start_transaction_sql().lower(), queries)\n         self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n \n+\n+    def test_sqlmigrate_for_non_ddl_rollback_database(self):\n+        \"\"\"\n+        Transaction wrappers aren't shown for databases that don't support DDL rollback.\n+        \"\"\"\n+        with mock.patch.object(connection.features, 'can_rollback_ddl', False):\n+            out = io.StringIO()\n+            call_command(\"sqlmigrate\", \"migrations\", \"0001\", stdout=out)\n+            output = out.getvalue().lower()\n+            queries = [q.strip() for q in output.splitlines()]\n+            if connection.ops.start_transaction_sql():\n+                self.assertNotIn(connection.ops.start_transaction_sql().lower(), queries)\n+            self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n     @override_settings(\n         INSTALLED_APPS=[\n             \"migrations.migrations_test_apps.migrated_app\",\n"
  }
}