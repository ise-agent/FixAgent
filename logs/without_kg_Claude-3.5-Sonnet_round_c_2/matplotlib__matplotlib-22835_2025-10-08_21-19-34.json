{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/matplotlib/lib/matplotlib/artist.py lines 1307-1308)": "\n            if np.isfinite(normed):\n                # Midpoints of neighboring color intervals.\n                try:\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Norm is not invertible (e.g., BoundaryNorm)\n                    g_sig_digits = 3\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n",
    "Location 2 (/root/hy/projects_2/matplotlib/lib/matplotlib/artist.py lines 1305-1312)": "\n        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n            # This block logically belongs to ScalarMappable, but can't be\n            # implemented in it because most ScalarMappable subclasses inherit\n            # from Artist first and from ScalarMappable second, so\n            # Artist.format_cursor_data would always have precedence over\n            # ScalarMappable.format_cursor_data.\n            n = self.cmap.N\n            if np.ma.getmask(data):\n                return \"[]\"\n            normed = self.norm(data)\n            if np.isfinite(normed):\n                try:\n                    # Midpoints of neighboring color intervals.\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Norm is not invertible (e.g., BoundaryNorm)\n                    g_sig_digits = 3\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n",
    "Location 3 (/root/hy/projects_2/matplotlib/lib/matplotlib/colors.py lines 1904-1912)": "\n    def format_cursor_data(self, data):\n        \"\"\"\n        Return a string representation of *data*.\n\n        .. note::\n            This method is intended to be overridden by artist subclasses.\n            As an end-user of Matplotlib you will most likely not call this\n            method yourself.\n\n        The default implementation converts ints and floats and arrays of ints\n        and floats into a comma-separated string enclosed in square brackets,\n        unless the artist has an associated colorbar, in which case scalar\n        values are formatted using the colorbar's formatter.\n\n        See Also\n        --------\n        get_cursor_data\n        \"\"\"\n        try:\n            if self.get_array() is not None:\n                # Scalarmappable\n                if np.ndim(data) == 0:\n                    # If this is a Scalarmappable with a colorbar, then try to use\n                    # the colorbar's formatter; otherwise, just use the default\n                    # str() conversion.\n                    if self.colorbar is not None:\n                        return self.colorbar.formatter.format_data_short(data)\n                    else:\n                        try:\n                            normed = self.norm(data)\n                        except TypeError:\n                            return str(data)\n                        if not np.isfinite(normed):\n                            return str(data)\n                        try:\n                            # Calculate precision based on norm.inverse if available\n                            g_sig_digits = int(np.ceil(-np.log10(\n                                abs(self.norm.inverse(normed + self.norm.vmax/256) -\n                                    self.norm.inverse(normed)))))\n                        except (ValueError, AttributeError):\n                            # Fallback for non-invertible norms (like BoundaryNorm)\n                            # or norms without inverse method\n                            g_sig_digits = 3\n                        if g_sig_digits <= 0:\n                            g_sig_digits = 3\n                        return \"{:-#.{}g}\".format(data, g_sig_digits)\n        except (TypeError, IndexError):\n            pass\n        return str(data)\n",
    "Location 4 (/root/hy/projects_2/matplotlib/lib/matplotlib/artist.py lines 1277-1295)": "\n    def format_cursor_data(self, data):\n        \"\"\"\n        Return a string representation of *data*.\n\n        .. note::\n            This method is intended to be overridden by artist subclasses.\n            As an end-user of Matplotlib you will most likely not call this\n            method yourself.\n\n        The default implementation converts ints and floats and arrays of ints\n        and floats into a comma-separated string enclosed in square brackets,\n        unless the artist has an associated colorbar, in which case scalar\n        values are formatted using the colorbar's formatter.\n\n        See Also\n        --------\n        get_cursor_data\n        \"\"\"\n        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n            # This block logically belongs to ScalarMappable, but can't be\n            # implemented in it because most ScalarMappable subclasses inherit\n            # from Artist first and from ScalarMappable second, so\n            # Artist.format_cursor_data would always have precedence over\n            # ScalarMappable.format_cursor_data.\n            n = self.cmap.N\n            if np.ma.getmask(data):\n                return \"[]\"\n            normed = self.norm(data)\n            if np.isfinite(normed):\n                # Calculate significant digits, handling non-invertible norms\n                try:\n                    inv_data = self.norm.inverse(normed)\n                    g_sig_digits = cbook._g_sig_digits(inv_data, data)\n                except ValueError:\n                    # Norm is not invertible (e.g., BoundaryNorm)\n                    g_sig_digits = 3\n            else:\n                g_sig_digits = 3\n            # Format using colorbar formatter\n            return \"[{}]\".format(self.cmap.colorbar.format_ticks([data])[0])\n        # Handle arrays and other data types\n        try:\n            return cbook.format_approx(data, g_sig_digits)\n        except (TypeError, ValueError):\n            return str(data)\n",
    "Location 5 (/root/hy/projects_2/matplotlib/lib/matplotlib/artist.py lines 1-20)": "\ndef format_cursor_data(self, data):\n    \"\"\"\n    Return a string representation of *data*.\n\n    .. note::\n        This method is intended to be overridden by artist subclasses.\n        As an end-user of Matplotlib you will most likely not call this\n        method yourself.\n\n    The default implementation converts ints and floats and arrays of ints\n    and floats into a comma-separated string enclosed in square brackets,\n    unless the artist has an associated colormap, in which case scalar data\n    is formatted using the colormap's normalization and colorbar ticklabels.\n    See also `.ScalarMappable.format_cursor_data`.\n    \"\"\"\n    try:\n        # If this artist has an associated colormap, format using\n        # the colormap's normalization and colorbar ticklabels\n        if hasattr(self, 'get_cmap'):\n            # Attempt to use the colormap's normalization\n            normed = self.norm(data)\n            if np.ma.is_masked(normed):\n                return \"masked\"\n            \n            try:\n                # Try to get inverse for precision calculation\n                inverse_data = self.norm.inverse(normed)\n                g_sig_digits = cbook._g_sig_digits(inverse_data, data)\n            except (ValueError, AttributeError):\n                # Fallback for non-invertible norms like BoundaryNorm\n                g_sig_digits = 3\n            \n            if not np.isfinite(normed):\n                return \"out of range\"\n            \n            # Format the data value with appropriate precision\n            return \"{:.{}g}\".format(data, g_sig_digits)\n    except (TypeError, IndexError):\n        pass\n    \n    # Fallback to default formatting\n    return repr(data)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/matplotlib/lib/matplotlib/artist.py lines 1307-1308)": [
      "\n            if np.isfinite(normed):\n                # Midpoints of neighboring color intervals.\n                try:\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Norm is not invertible (e.g., BoundaryNorm)\n                    g_sig_digits = 3\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n",
      "\n            if np.isfinite(normed):\n                # Midpoints of neighboring color intervals.\n                try:\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Norm is not invertible (e.g., BoundaryNorm)\n                    g_sig_digits = 3\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n",
      "\n            if np.isfinite(normed):\n                # Midpoints of neighboring color intervals.\n                try:\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Norm is not invertible (e.g., BoundaryNorm)\n                    g_sig_digits = 3\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n",
      "\n            if np.isfinite(normed):\n                # Midpoints of neighboring color intervals.\n                try:\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Norm is not invertible (e.g., BoundaryNorm)\n                    g_sig_digits = 3\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n",
      "\n            if np.isfinite(normed):\n                # Midpoints of neighboring color intervals.\n                try:\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Norm is not invertible (e.g., BoundaryNorm)\n                    g_sig_digits = 3\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n",
      "\n            if np.isfinite(normed):\n                # Midpoints of neighboring color intervals.\n                try:\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Norm is not invertible (e.g., BoundaryNorm)\n                    g_sig_digits = 3\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n",
      "\n            if np.isfinite(normed):\n                # Midpoints of neighboring color intervals.\n                try:\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Norm is not invertible (e.g., BoundaryNorm)\n                    g_sig_digits = 3\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n",
      "\n            normed = self.norm(data)\n            if np.isfinite(normed):\n                # Midpoints of neighboring color intervals.\n                try:\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Norm is not invertible (e.g., BoundaryNorm)\n                    g_sig_digits = 3\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n"
    ],
    "Location 2 (/root/hy/projects_2/matplotlib/lib/matplotlib/artist.py lines 1305-1312)": [
      "\n        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n            # This block logically belongs to ScalarMappable, but can't be\n            # implemented in it because most ScalarMappable subclasses inherit\n            # from Artist first and from ScalarMappable second, so\n            # Artist.format_cursor_data would always have precedence over\n            # ScalarMappable.format_cursor_data.\n            n = self.cmap.N\n            if np.ma.getmask(data):\n                return \"[]\"\n            normed = self.norm(data)\n            if np.isfinite(normed):\n                # Midpoints of neighboring color intervals.\n                try:\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Norm is not invertible (e.g., BoundaryNorm)\n                    g_sig_digits = 3  # Consistent with default below.\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n",
      "\n        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n            # This block logically belongs to ScalarMappable, but can't be\n            # implemented in it because most ScalarMappable subclasses inherit\n            # from Artist first and from ScalarMappable second, so\n            # Artist.format_cursor_data would always have precedence over\n            # ScalarMappable.format_cursor_data.\n            n = self.cmap.N\n            if np.ma.getmask(data):\n                return \"[]\"\n            normed = self.norm(data)\n            if np.isfinite(normed):\n                # Midpoints of neighboring color intervals.\n                try:\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Norm is not invertible (e.g., BoundaryNorm)\n                    g_sig_digits = 3\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n",
      "\n        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n            # This block logically belongs to ScalarMappable, but can't be\n            # implemented in it because most ScalarMappable subclasses inherit\n            # from Artist first and from ScalarMappable second, so\n            # Artist.format_cursor_data would always have precedence over\n            # ScalarMappable.format_cursor_data.\n            n = self.cmap.N\n            if np.ma.getmask(data):\n                return \"[]\"\n            normed = self.norm(data)\n            if np.isfinite(normed):\n                # Midpoints of neighboring color intervals.\n                try:\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except (ValueError, AttributeError):\n                    # Norm is not invertible (e.g., BoundaryNorm) or doesn't have inverse\n                    g_sig_digits = 3  # Use default precision\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n",
      "\n        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n            # This block logically belongs to ScalarMappable, but can't be\n            # implemented in it because most ScalarMappable subclasses inherit\n            # from Artist first and from ScalarMappable second, so\n            # Artist.format_cursor_data would always have precedence over\n            # ScalarMappable.format_cursor_data.\n            n = self.cmap.N\n            if np.ma.getmask(data):\n                return \"[]\"\n            normed = self.norm(data)\n            if np.isfinite(normed):\n                # Midpoints of neighboring color intervals.\n                try:\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Norm is not invertible (e.g., BoundaryNorm)\n                    g_sig_digits = 3\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n",
      "\n        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n            # This block logically belongs to ScalarMappable, but can't be\n            # implemented in it because most ScalarMappable subclasses inherit\n            # from Artist first and from ScalarMappable second, so\n            # Artist.format_cursor_data would always have precedence over\n            # ScalarMappable.format_cursor_data.\n            n = self.cmap.N\n            if np.ma.getmask(data):\n                return \"[]\"\n            normed = self.norm(data)\n            if np.isfinite(normed):\n                # Midpoints of neighboring color intervals.\n                try:\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Norm is not invertible (e.g., BoundaryNorm)\n                    g_sig_digits = 3\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n",
      "\n        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n            # This block logically belongs to ScalarMappable, but can't be\n            # implemented in it because most ScalarMappable subclasses inherit\n            # from Artist first and from ScalarMappable second, so\n            # Artist.format_cursor_data would always have precedence over\n            # ScalarMappable.format_cursor_data.\n            n = self.cmap.N\n            if np.ma.getmask(data):\n                return \"[]\"\n            normed = self.norm(data)\n            if np.isfinite(normed):\n                # Midpoints of neighboring color intervals.\n                try:\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Norm is not invertible (e.g., BoundaryNorm)\n                    g_sig_digits = 3  # Consistent with default below.\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n",
      "\n        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n            # This block logically belongs to ScalarMappable, but can't be\n            # implemented in it because most ScalarMappable subclasses inherit\n            # from Artist first and from ScalarMappable second, so\n            # Artist.format_cursor_data would always have precedence over\n            # ScalarMappable.format_cursor_data.\n            n = self.cmap.N\n            if np.ma.getmask(data):\n                return \"[]\"\n            normed = self.norm(data)\n            if np.isfinite(normed):\n                try:\n                    # Midpoints of neighboring color intervals.\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Norm is not invertible (e.g., BoundaryNorm)\n                    g_sig_digits = 3\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n",
      "\n        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n            # This block logically belongs to ScalarMappable, but can't be\n            # implemented in it because most ScalarMappable subclasses inherit\n            # from Artist first and from ScalarMappable second, so\n            # Artist.format_cursor_data would always have precedence over\n            # ScalarMappable.format_cursor_data.\n            n = self.cmap.N\n            if np.ma.getmask(data):\n                return \"[]\"\n            normed = self.norm(data)\n            if np.isfinite(normed):\n                # Midpoints of neighboring color intervals.\n                try:\n                    neighbors = self.norm.inverse(\n                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                    g_sig_digits = cbook._g_sig_digits(data, delta)\n                except ValueError:\n                    # Norm is not invertible (e.g., BoundaryNorm), use default\n                    g_sig_digits = 3\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n"
    ],
    "Location 3 (/root/hy/projects_2/matplotlib/lib/matplotlib/colors.py lines 1904-1912)": [
      "\n    def format_cursor_data(self, data):\n        \"\"\"\n        Return a string representation of *data*.\n\n        .. note::\n            This method is intended to be overridden by artist subclasses.\n            As an end-user of Matplotlib you will most likely not call this\n            method yourself.\n\n        The default implementation converts ints and floats and arrays of ints\n        and floats into a comma-separated string enclosed in square brackets,\n        unless the artist has an associated colorbar, in which case scalar\n        values are formatted using the colorbar's formatter.\n\n        See Also\n        --------\n        ScalarMappable.format_cursor_data\n        \"\"\"\n        try:\n            # Check if this is a scalar mappable with a colorbar formatter\n            if hasattr(self, 'colorbar') and self.colorbar is not None:\n                return self.colorbar.format_cursor_data(data)\n        except Exception:\n            pass\n        \n        # Default formatting for regular data\n        if np.ndim(data) == 0:\n            # Scalar data\n            if isinstance(data, (int, np.integer)):\n                return f\"{data:d}\"\n            elif isinstance(data, (float, np.floating)):\n                return f\"{data:g}\"\n            else:\n                return str(data)\n        else:\n            # Array data - format as comma-separated values in brackets\n            flat_data = np.asarray(data).flat\n            formatted_values = []\n            for val in flat_data:\n                if isinstance(val, (int, np.integer)):\n                    formatted_values.append(f\"{val:d}\")\n                elif isinstance(val, (float, np.floating)):\n                    formatted_values.append(f\"{val:g}\")\n                else:\n                    formatted_values.append(str(val))\n            return \"[\" + \", \".join(formatted_values) + \"]\"\n",
      "\ndef format_cursor_data(self, data):\n    \"\"\"\n    Return a string representation of *data*.\n\n    .. note::\n        This method is intended to be overridden by artist subclasses.\n        As an end-user of Matplotlib you will most likely not call this\n        method yourself.\n\n    The default implementation converts ints and floats and arrays of ints\n    and floats into a comma-separated string enclosed in square brackets,\n    unless the artist has an associated colorbar, in which case scalar\n    values are formatted using the colorbar's formatter.\n\n    See Also\n    --------\n    ScalarMappable.format_cursor_data\n    \"\"\"\n    try:\n        # Check if this is a scalar mappable with a colorbar\n        if hasattr(self, 'colorbar') and self.colorbar is not None:\n            return self.colorbar.format_cursor_data(data)\n        # Check if this is a scalar mappable with a norm (but no colorbar)\n        elif hasattr(self, 'norm') and self.norm is not None:\n            # Try to use the norm's inverse to determine appropriate precision\n            try:\n                normed = self.norm(data)\n                if np.isfinite(normed):\n                    inverse_data = self.norm.inverse(normed)\n                    g_sig_digits = cbook._g_sig_digits(inverse_data, 0.001)\n                else:\n                    g_sig_digits = 3\n            except (ValueError, AttributeError):\n                # Handle non-invertible norms (like BoundaryNorm) or other errors\n                g_sig_digits = 3\n            \n            return cbook._auto_format_str % (g_sig_digits, data)\n    except Exception:\n        pass\n    \n    # Default formatting for non-scalar mappable artists\n    if isinstance(data, np.ma.MaskedArray) and data.mask.all():\n        return \"masked\"\n    \n    try:\n        return cbook.format_approx(data, 0.01)\n    except (TypeError, ValueError):\n        return repr(data)\n",
      "\n    def format_cursor_data(self, data):\n        \"\"\"\n        Return a string representation of *data*.\n\n        .. note::\n            This method is intended to be overridden by artist subclasses.\n            As an end-user of Matplotlib you will most likely not call this\n            method yourself.\n\n        The default implementation converts ints and floats and arrays of ints\n        and floats into a comma-separated string enclosed in square brackets,\n        unless the artist has an associated colorbar, in which case scalar\n        values are formatted using the colorbar's formatter.\n\n        See Also\n        --------\n        .axes.Axes.format_cursor_data\n        \"\"\"\n        try:\n            # shape = data.shape  # Check it's not a scalar.\n            if data.shape == ():\n                # Scalar case: `data` is a numpy scalar.\n                if hasattr(self, 'get_cmap'):\n                    # ColormappedArtist.\n                    if self.get_array() is not None:\n                        # Formatter should be set by the colorbar.\n                        try:\n                            normed = self.norm.inverse(self.norm(data))\n                        except (ValueError, AttributeError):\n                            # Handle non-invertible norms like BoundaryNorm\n                            g_sig_digits = 3\n                        else:\n                            if np.isfinite(normed):\n                                g_sig_digits = cbook._g_sig_digits(data, normed)\n                            else:\n                                g_sig_digits = 3\n                        return self.cbar.formatter._format_vmin_vmax(\n                            data, g_sig_digits)\n                return f'{data:1.3g}'\n            else:\n                # Non-scalar case: `data` is a numpy array.\n                return '[' + ', '.join(f'{item:1.3g}' for item in data) + ']'\n        except (ValueError, IndexError):\n            # ValueError if data is not a number.\n            # IndexError if data is not NumPy array-like.\n            return str(data)\n",
      "\n    def format_cursor_data(self, data):\n        \"\"\"\n        Return a string representation of *data*.\n\n        .. note::\n            This method is intended to be overridden by artist subclasses.\n            As an end-user of Matplotlib you will most likely not call this\n            method yourself.\n\n        The default implementation converts ints and floats and arrays of ints\n        and floats into a comma-separated string enclosed in square brackets,\n        unless the artist has an associated colorbar, in which case scalar\n        values are formatted using the colorbar's formatter.\n\n        See Also\n        --------\n        get_cursor_data\n        \"\"\"\n        try:\n            # casting to float is safe for python types, and\n            # we don't want to support other types such as\n            # datetime which may be in an array\n            data = np.asarray(data, dtype=float)\n        except (TypeError, ValueError):\n            data = np.asarray(data)\n        data_str = np.array2string(data, separator=', ', suppress_small=True)\n        if self.get_array() is not None:\n            # Formatter for colormapped data\n            normed = self.norm(data)\n            if np.isfinite(normed).all():\n                try:\n                    inverse_normed = self.norm.inverse(normed)\n                    g_sig_digits = 3\n                    if inverse_normed.size > 1:\n                        delta = np.ptp(inverse_normed)\n                        if delta:\n                            g_sig_digits = max(\n                                1,\n                                np.ceil(-np.log10(delta)).astype(int)\n                            )\n                except (ValueError, AttributeError):\n                    # Handle non-invertible norms like BoundaryNorm\n                    g_sig_digits = 3\n                fmt = f\"{{:.{g_sig_digits}g}}\"\n            else:\n                g_sig_digits = 3\n                fmt = f\"{{:.{g_sig_digits}g}}\"\n            if data.ndim == 0:\n                # it's a single number (not an array)\n                return fmt.format(data.item())\n            else:\n                # it's an array, format each element with the same precision\n                return \"[\" + \", \".join(fmt.format(x) for x in data.flat) + \"]\"\n        else:\n            return data_str\n",
      "\n    def format_cursor_data(self, data):\n        \"\"\"\n        Return a string representation of *data*.\n\n        .. note::\n            This method is intended to be overridden by artist subclasses.\n            As an end-user of Matplotlib you will most likely not call this\n            method yourself.\n\n        The default implementation converts ints and floats and arrays of ints\n        and floats into a comma-separated string enclosed in square brackets,\n        unless the artist has an associated colorbar, in which case scalar\n        values are formatted using the colorbar's formatter.\n\n        See Also\n        --------\n        get_cursor_data\n        \"\"\"\n        try:\n            if self._mouseover_set.intersection(\n                    ['c', 'colors', 'facecolor', 'facecolors', 'edgecolors']):\n                # This is a color-like attribute\n                if np.ndim(data) == 0:\n                    # it's a scalar, not an array\n                    normed = self.norm(data)\n                    if np.isfinite(normed):\n                        # Attempt to get significant digits from inverse\n                        try:\n                            g_sig_digits = cbook._g_sig_digits(data, self.norm.inverse(normed))\n                        except ValueError:\n                            # Norm is not invertible (e.g., BoundaryNorm)\n                            g_sig_digits = 3\n                    else:\n                        g_sig_digits = 3\n                    return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n        except (TypeError, IndexError):\n            pass\n\n        try:\n            return '[' + ', '.join(cbook._auto_format_str(v)\n                                   for v in cbook._sanitize_sequence(data.flat)) + ']'\n        except (TypeError, AttributeError):\n            return str(data)\n",
      "\n    def format_cursor_data(self, data):\n        \"\"\"\n        Return a string representation of *data*.\n\n        .. note::\n            This method is intended to be overridden by artist subclasses.\n            As an end-user of Matplotlib you will most likely not call this\n            method yourself.\n\n        The default implementation converts ints and floats and arrays of ints\n        and floats into a comma-separated string enclosed in square brackets,\n        unless the artist has an associated colorbar, in which case scalar\n        values are formatted using the colorbar's formatter.\n\n        See Also\n        --------\n        get_cursor_data\n        \"\"\"\n        try:\n            if self.get_array() is not None:\n                # Scalarmappable\n                if np.ndim(data) == 0:\n                    # If normed is True, we have a ScalarMappable, so we check\n                    # if the incoming data is suitable for the normalization\n                    normed = self.norm(data)\n                    if np.isfinite(normed):\n                        try:\n                            # Try to calculate significant digits using inverse\n                            value = self.norm.inverse(normed)\n                            g_sig_digits = cbook._g_sig_digits(data, value)\n                        except (ValueError, AttributeError):\n                            # Fallback for non-invertible norms like BoundaryNorm\n                            g_sig_digits = 3\n                    else:\n                        g_sig_digits = 3\n                    # Apply the colorbar formatter, or default\n                    if hasattr(self, 'colorbar') and self.colorbar is not None:\n                        return self.colorbar.formatter.format_data_short(data)\n                    else:\n                        return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n        except (TypeError, IndexError):\n            pass\n\n        try:\n            return \"[{}]\".format(cbook._auto_format_str(data))\n        except (TypeError, IndexError):\n            return str(data)\n",
      "\n    def format_cursor_data(self, data):\n        \"\"\"\n        Return a string representation of *data*.\n\n        .. note::\n            This method is intended to be overridden by artist subclasses.\n            As an end-user of Matplotlib you will most likely not call this\n            method yourself.\n\n        The default implementation converts ints and floats and arrays of ints\n        and floats into a comma-separated string enclosed in square brackets,\n        unless the artist has an associated colorbar, in which case scalar\n        values are formatted using the colorbar's formatter.\n\n        See Also\n        --------\n        get_cursor_data\n        \"\"\"\n        try:\n            if self.get_array() is not None:\n                # Scalarmappable\n                if np.ndim(data) == 0:\n                    # Try to calculate precision based on inverse normalization\n                    try:\n                        normed = self.norm(data)\n                        if np.isfinite(normed):\n                            g_sig_digits = 3 - np.log10(\n                                abs(self.norm.inverse(normed + self.norm.inverse(1e-3))\n                                    - self.norm.inverse(normed)))\n                        else:\n                            g_sig_digits = 3\n                    except (ValueError, AttributeError):\n                        # Handle non-invertible norms (like BoundaryNorm) or other issues\n                        g_sig_digits = 3\n                    return f\"[{data:.{g_sig_digits:0.0f}g}]\"\n        except (TypeError, IndexError):\n            pass\n\n        try:\n            return \"[\" + \", \".join(f\"{val:0.3g}\" for val in data.flat) + \"]\"\n        except (AttributeError, TypeError):\n            return f\"[{data!r}]\"\n",
      "\n    def format_cursor_data(self, data):\n        \"\"\"\n        Return a string representation of *data*.\n\n        .. note::\n            This method is intended to be overridden by artist subclasses.\n            As an end-user of Matplotlib you will most likely not call this\n            method yourself.\n\n        The default implementation converts ints and floats and arrays of ints\n        and floats into a comma-separated string enclosed in square brackets,\n        unless the artist has an associated colorbar, in which case scalar\n        values are formatted using the colorbar's formatter.\n\n        See Also\n        --------\n        get_cursor_data\n        \"\"\"\n        try:\n            from matplotlib import ticker\n            # If this artist has an associated colorbar, don't bother trying\n            # to use the default formatting (which doesn't account for the\n            # colorbar's formatter or locator).\n            for parent in self.axes.get_children():\n                if hasattr(parent, 'colorbar') and parent.colorbar is not None:\n                    # Colorbars have their own normalization, colormap; but\n                    # the data of this artist.\n                    return parent.colorbar.format_cursor_data(data)\n        except (AttributeError, IndexError):\n            pass\n\n        data_str = _format_approx(data, 6)\n        if data is not np.ma.masked:\n            try:\n                normed = self.norm(data)\n            except (TypeError, ValueError):\n                pass\n            else:\n                if normed is not np.ma.masked:\n                    # Attempt to calculate precision based on inverse norm\n                    try:\n                        inverse_data = self.norm.inverse(normed)\n                        g_sig_digits = cbook._g_sig_digits(data, inverse_data)\n                    except (ValueError, AttributeError):\n                        # Use default precision for non-invertible norms like BoundaryNorm\n                        g_sig_digits = 3\n                    if g_sig_digits < 6:\n                        data_str = _format_approx(data, g_sig_digits)\n        return data_str\n"
    ],
    "Location 4 (/root/hy/projects_2/matplotlib/lib/matplotlib/artist.py lines 1277-1295)": [
      "\n    def format_cursor_data(self, data):\n        \"\"\"\n        Return a string representation of *data*.\n\n        .. note::\n            This method is intended to be overridden by artist subclasses.\n            As an end-user of Matplotlib you will most likely not call this\n            method yourself.\n\n        The default implementation converts ints and floats and arrays of ints\n        and floats into a comma-separated string enclosed in square brackets,\n        unless the artist has an associated colorbar, in which case scalar\n        values are formatted using the colorbar's formatter.\n\n        See Also\n        --------\n        get_cursor_data\n        \"\"\"\n        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n            # This block logically belongs to ScalarMappable, but can't be\n            # implemented in it because most ScalarMappable subclasses inherit\n            # from Artist first and from ScalarMappable second, so\n            # Artist.format_cursor_data would always have precedence over\n            # ScalarMappable.format_cursor_data.\n            n = self.cmap.N\n            if np.ma.getmask(data):\n                return \"[]\"\n            normed = self.norm(data)\n            if np.isfinite(normed):\n                # Calculate significant digits for formatting based on colormap\n                # resolution, but handle non-invertible norms gracefully\n                try:\n                    g_sig_digits = max(\n                        np.ceil(np.log10(n)).astype(int), 1)\n                    inverse_normed = self.norm.inverse(\n                        (int(normed * n) + 0.5) / n)\n                    delta = abs(data - inverse_normed)\n                    g_sig_digits += np.ceil(np.log10(1 / delta)).astype(int)\n                except (ValueError, AttributeError):\n                    # Fallback for non-invertible norms (e.g., BoundaryNorm)\n                    g_sig_digits = 3\n                return cbook._g_sig_digits(data, g_sig_digits)\n            else:\n                return \"[]\"\n        try:\n            return '[' + ', '.join(cbook._g_sig_digits(val, 3)\n                                   for val in data.flat) + ']'\n        except (TypeError, AttributeError):\n            return str(data)\n",
      "\n    def format_cursor_data(self, data):\n        \"\"\"\n        Return a string representation of *data*.\n\n        .. note::\n            This method is intended to be overridden by artist subclasses.\n            As an end-user of Matplotlib you will most likely not call this\n            method yourself.\n\n        The default implementation converts ints and floats and arrays of ints\n        and floats into a comma-separated string enclosed in square brackets,\n        unless the artist has an associated colorbar, in which case scalar\n        values are formatted using the colorbar's formatter.\n\n        See Also\n        --------\n        get_cursor_data\n        \"\"\"\n        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n            # This block logically belongs to ScalarMappable, but can't be\n            # implemented in it because most ScalarMappable subclasses inherit\n            # from Artist first and from ScalarMappable second, so\n            # Artist.format_cursor_data would always have precedence over\n            # ScalarMappable.format_cursor_data.\n            n = self.cmap.N\n            if np.ma.getmask(data):\n                return \"[]\"\n            normed = self.norm(data)\n            if np.isfinite(normed):\n                # Calculate significant digits based on colormap resolution,\n                # but handle non-invertible norms gracefully\n                try:\n                    s = self.norm.inverse(np.linspace(0, 1, n))\n                    g_sig_digits = cbook._g_sig_digits(s, 0.001)\n                except ValueError:\n                    # Handle non-invertible norms (e.g., BoundaryNorm)\n                    g_sig_digits = 3\n            else:\n                g_sig_digits = 3\n            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n        return '[{!r}]'.format(data)\n",
      "\n    def format_cursor_data(self, data):\n        \"\"\"\n        Return a string representation of *data*.\n\n        .. note::\n            This method is intended to be overridden by artist subclasses.\n            As an end-user of Matplotlib you will most likely not call this\n            method yourself.\n\n        The default implementation converts ints and floats and arrays of ints\n        and floats into a comma-separated string enclosed in square brackets,\n        unless the artist has an associated colorbar, in which case scalar\n        values are formatted using the colorbar's formatter.\n\n        See Also\n        --------\n        get_cursor_data\n        \"\"\"\n        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n            # This block logically belongs to ScalarMappable, but can't be\n            # implemented in it because most ScalarMappable subclasses inherit\n            # from Artist first and from ScalarMappable second, so\n            # Artist.format_cursor_data would always have precedence over\n            # ScalarMappable.format_cursor_data.\n            n = self.cmap.N\n            if np.ma.getmask(data):\n                return \"[]\"\n            normed = self.norm(data)\n            if np.isfinite(normed):\n                # Calculate significant digits, handling non-invertible norms\n                try:\n                    inverse_normed = self.norm.inverse(normed)\n                    g_sig_digits = cbook._g_sig_digits(inverse_normed, 0.001)\n                except (ValueError, AttributeError):\n                    # Fallback for non-invertible norms like BoundaryNorm\n                    g_sig_digits = 3\n            else:\n                g_sig_digits = 3\n            return self.colorbar.formatter.format_data_short(data.item(),\n                                                             g_sig_digits)\n        try:\n            return '[' + ', '.join(cbook._strip_math(\n                format(val, 'g') if isinstance(val, Number) else str(val))\n                for val in np.atleast_1d(data)) + ']'\n        except (TypeError, ValueError):\n            return str(data)\n",
      "\n    def format_cursor_data(self, data):\n        \"\"\"\n        Return a string representation of *data*.\n\n        .. note::\n            This method is intended to be overridden by artist subclasses.\n            As an end-user of Matplotlib you will most likely not call this\n            method yourself.\n\n        The default implementation converts ints and floats and arrays of ints\n        and floats into a comma-separated string enclosed in square brackets,\n        unless the artist has an associated colorbar, in which case scalar\n        values are formatted using the colorbar's formatter.\n\n        See Also\n        --------\n        get_cursor_data\n        \"\"\"\n        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n            # This block logically belongs to ScalarMappable, but can't be\n            # implemented in it because most ScalarMappable subclasses inherit\n            # from Artist first and from ScalarMappable second, so\n            # Artist.format_cursor_data would always have precedence over\n            # ScalarMappable.format_cursor_data.\n            n = self.cmap.N\n            if np.ma.getmask(data):\n                return \"[]\"\n            normed = self.norm(data)\n            if np.isfinite(normed):\n                # Calculate significant digits for formatting\n                try:\n                    # Try to use inverse for precision calculation\n                    delta = abs(self.norm.inverse(normed + 0.5/n) - self.norm.inverse(normed - 0.5/n))\n                    g_sig_digits = max(1, int(np.ceil(-np.log10(delta))))\n                except (AttributeError, ValueError):\n                    # Handle non-invertible norms like BoundaryNorm\n                    g_sig_digits = 3\n                return self.cmap.colorbar.formatter.format_data_short(data)\n            else:\n                return \"[]\"\n        return cbook._auto_format_str(data)\n",
      "\n    def format_cursor_data(self, data):\n        \"\"\"\n        Return a string representation of *data*.\n\n        .. note::\n            This method is intended to be overridden by artist subclasses.\n            As an end-user of Matplotlib you will most likely not call this\n            method yourself.\n\n        The default implementation converts ints and floats and arrays of ints\n        and floats into a comma-separated string enclosed in square brackets,\n        unless the artist has an associated colorbar, in which case scalar\n        values are formatted using the colorbar's formatter.\n\n        See Also\n        --------\n        get_cursor_data\n        \"\"\"\n        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n            # This block logically belongs to ScalarMappable, but can't be\n            # implemented in it because most ScalarMappable subclasses inherit\n            # from Artist first and from ScalarMappable second, so\n            # Artist.format_cursor_data would always have precedence over\n            # ScalarMappable.format_cursor_data.\n            n = self.cmap.N\n            if np.ma.getmask(data):\n                return \"[]\"\n            normed = self.norm(data)\n            if np.isfinite(normed):\n                # Only compute precision if norm is invertible\n                try:\n                    inverse_normed = self.norm.inverse(normed)\n                    g_sig_digits = cbook._g_sig_digits(inverse_normed, 0.001)\n                except ValueError:\n                    # Some norms like BoundaryNorm are not invertible\n                    g_sig_digits = 3\n                s = cbook._g_sig_digits(data, 0.001)\n                s = max(s, g_sig_digits)\n                return \"[{:-#.{}g}]\".format(data, s)\n            else:\n                return \"[]\"\n        try:\n            return '[' + ', '.join(cbook._g_sig_digits(v, 0.001)\n                                   for v in data.flat) + ']'\n        except (AttributeError, TypeError):\n            return str(data)\n",
      "\n    def format_cursor_data(self, data):\n        \"\"\"\n        Return a string representation of *data*.\n\n        .. note::\n            This method is intended to be overridden by artist subclasses.\n            As an end-user of Matplotlib you will most likely not call this\n            method yourself.\n\n        The default implementation converts ints and floats and arrays of ints\n        and floats into a comma-separated string enclosed in square brackets,\n        unless the artist has an associated colorbar, in which case scalar\n        values are formatted using the colorbar's formatter.\n\n        See Also\n        --------\n        get_cursor_data\n        \"\"\"\n        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n            # This block logically belongs to ScalarMappable, but can't be\n            # implemented in it because most ScalarMappable subclasses inherit\n            # from Artist first and from ScalarMappable second, so\n            # Artist.format_cursor_data would always have precedence over\n            # ScalarMappable.format_cursor_data.\n            n = self.cmap.N\n            if np.ma.getmask(data):\n                return \"[]\"\n            normed = self.norm(data)\n            if np.isfinite(normed):\n                # Calculate significant digits, handling non-invertible norms\n                try:\n                    inverse_normed = self.norm.inverse(normed)\n                    g_sig_digits = cbook._g_sig_digits(inverse_normed, 0.001)\n                except ValueError:\n                    # Norm is not invertible (e.g., BoundaryNorm)\n                    g_sig_digits = 3\n                # Don't strip trailing zeros if it's an integer.\n                formatted = (\n                    (\"{:.%df}\" if g_sig_digits > 0 else \"{:.0f}\")\n                    % g_sig_digits\n                ).format(self.norm.inverse(normed) if g_sig_digits > 0 else normed)\n                return formatted\n            else:\n                return \"[]\"\n        return \"[{!r}]\".format(data)\n",
      "\n    def format_cursor_data(self, data):\n        \"\"\"\n        Return a string representation of *data*.\n\n        .. note::\n            This method is intended to be overridden by artist subclasses.\n            As an end-user of Matplotlib you will most likely not call this\n            method yourself.\n\n        The default implementation converts ints and floats and arrays of ints\n        and floats into a comma-separated string enclosed in square brackets,\n        unless the artist has an associated colorbar, in which case scalar\n        values are formatted using the colorbar's formatter.\n\n        See Also\n        --------\n        get_cursor_data\n        \"\"\"\n        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n            # This block logically belongs to ScalarMappable, but can't be\n            # implemented in it because most ScalarMappable subclasses inherit\n            # from Artist first and from ScalarMappable second, so\n            # Artist.format_cursor_data would always have precedence over\n            # ScalarMappable.format_cursor_data.\n            n = self.cmap.N\n            if np.ma.getmask(data):\n                return \"[]\"\n            normed = self.norm(data)\n            if np.isfinite(normed):\n                # Calculate g_sig_digits for significant digits formatting\n                try:\n                    # Try to get the inverse for precise g_sig_digits calculation\n                    inverse_normed = self.norm.inverse(normed)\n                    # Only use data if it's different from inverse_normed,\n                    # otherwise use the inverse for precision calculation\n                    g_sig_digits = cbook._g_sig_digits(data, delta=1/n)\n                except (ValueError, AttributeError):\n                    # Fallback for non-invertible norms (like BoundaryNorm)\n                    # or norms without inverse method\n                    g_sig_digits = 3\n            else:\n                g_sig_digits = 3\n            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n        try:\n            return \"[{}]\".format(cbook._strip_comment(repr(data)))\n        except TypeError:\n            return \"[{}]\".format(data)\n",
      "\n    def format_cursor_data(self, data):\n        \"\"\"\n        Return a string representation of *data*.\n\n        .. note::\n            This method is intended to be overridden by artist subclasses.\n            As an end-user of Matplotlib you will most likely not call this\n            method yourself.\n\n        The default implementation converts ints and floats and arrays of ints\n        and floats into a comma-separated string enclosed in square brackets,\n        unless the artist has an associated colorbar, in which case scalar\n        values are formatted using the colorbar's formatter.\n\n        See Also\n        --------\n        get_cursor_data\n        \"\"\"\n        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n            # This block logically belongs to ScalarMappable, but can't be\n            # implemented in it because most ScalarMappable subclasses inherit\n            # from Artist first and from ScalarMappable second, so\n            # Artist.format_cursor_data would always have precedence over\n            # ScalarMappable.format_cursor_data.\n            n = self.cmap.N\n            if np.ma.getmask(data):\n                return \"[]\"\n            normed = self.norm(data)\n            if np.isfinite(normed):\n                # Calculate significant digits for formatting\n                try:\n                    # Try to use inverse to determine precision\n                    inverse_normed = self.norm.inverse(normed)\n                    g_sig_digits = max(\n                        np.ceil(np.log10(np.abs(inverse_normed))).astype(int) + 1,\n                        1) if inverse_normed != 0 else 1\n                except ValueError:\n                    # Handle non-invertible norms (like BoundaryNorm)\n                    g_sig_digits = 3\n                \n                delta = normed / n * (n - 1)\n                g_sig_digits = max(\n                    np.ceil(np.log10(np.abs(delta))).astype(int) + 1,\n                    1) if delta != 0 else 1\n                return f\"[{data:.{g_sig_digits}g}]\"\n            else:\n                return \"[{:g}]\".format(data)\n        return \"[\" + \", \".join(f\"{item:g}\" for item in np.atleast_1d(data)) + \"]\"\n"
    ],
    "Location 5 (/root/hy/projects_2/matplotlib/lib/matplotlib/artist.py lines 1-20)": [
      "\ndef format_cursor_data(self, data):\n    \"\"\"\n    Return a string representation of *data*.\n\n    .. note::\n        This method is intended to be overridden by artist subclasses.\n        As an end-user of Matplotlib you will most likely not call this\n        method yourself.\n\n    The default implementation converts ints and floats and arrays of ints\n    and floats into a comma-separated string enclosed in square brackets,\n    unless the artist has an associated colorbar, in which case scalar\n    values are formatted using the colorbar's formatter.\n\n    See Also\n    --------\n    get_cursor_data\n    \"\"\"\n    try:\n        # Note: This check needs to happen first so that\n        # numpy.ma.core.MaskedConstant.item does not get called if data is\n        # a masked value.\n        if np.ma.is_masked(data):\n            return \"[]\"\n    except (TypeError, AttributeError):\n        pass\n\n    if hasattr(self, 'norm') and self.norm is not None:\n        # Formatting for scalars using the colorbar formatter.\n        if np.ndim(data) == 0:\n            normed = self.norm(data)\n            if np.isfinite(normed):\n                try:\n                    # Try to calculate precision based on inverse norm\n                    g_sig_digits = cbook._g_sig_digits(data, self.norm.inverse(normed))\n                except ValueError:\n                    # Fallback for non-invertible norms like BoundaryNorm\n                    g_sig_digits = 3\n            else:\n                g_sig_digits = 3\n            return cbook._auto_format_str % (g_sig_digits, data)\n    return repr(data)\n",
      "\ndef format_cursor_data(self, data):\n    \"\"\"\n    Return a string representation of *data*.\n\n    .. note::\n        This method is intended to be overridden by artist subclasses.\n        As an end-user of Matplotlib you will most likely not call this\n        method yourself.\n\n    The default implementation converts ints and floats and arrays of ints\n    and floats into a comma-separated string enclosed in square brackets,\n    unless the artist has an associated colorbar, in which case scalar\n    values are formatted using the colorbar's formatter.\n\n    See Also\n    --------\n    .Axes.format_cursor_data\n    \"\"\"\n    try:\n        # casting to float is to unpack 0d arrays\n        data = float(data)\n    except (TypeError, ValueError):\n        pass\n    else:\n        if hasattr(self, 'norm') and self.norm is not None:\n            # Wrap in an array so we can use the colorbar's formatter\n            normed = self.norm([data])\n            if len(normed):\n                normed = normed[0]\n                if np.isfinite(normed):\n                    try:\n                        # Calculate significant digits based on the inverse transform\n                        data_range = abs(self.norm.inverse([normed + 0.5]) -\n                                       self.norm.inverse([normed - 0.5]))\n                        g_sig_digits = max(1, int(np.ceil(-np.log10(data_range))))\n                    except (ValueError, AttributeError):\n                        # Handle non-invertible norms (like BoundaryNorm) or other errors\n                        g_sig_digits = 3\n                else:\n                    g_sig_digits = 3\n                return (\n                    f\"[{type(self).__name__}] \"\n                    f\"{cbook._g_sig_digits(data, g_sig_digits)}\"\n                )\n    return f\"[{type(self).__name__}] {data!r}\"\n",
      "\ndef format_cursor_data(self, data):\n    \"\"\"\n    Return a string representation of *data*.\n\n    .. note::\n        This method is intended to be overridden by artist subclasses.\n        As an end-user of Matplotlib you will most likely not call this\n        method yourself.\n\n    The default implementation converts ints and floats and arrays of ints\n    and floats into a comma-separated string enclosed in square brackets,\n    unless the artist has an associated colorbar, in which case scalar\n    values are formatted using the colorbar's formatter.\n\n    See Also\n    --------\n    get_cursor_data\n    \"\"\"\n    try:\n        if self.get_array() is not None:\n            # Scalars or 0-D arrays get converted to float to avoid\n            # Decimal-related issues with Colorbar formatting\n            if np.ndim(data) == 0:\n                data = float(data)\n            if self.norm is not None:\n                normed = self.norm(data)\n                if np.isfinite(normed):\n                    try:\n                        g_sig_digits = 3 - int(np.ceil(np.log10(np.abs(\n                            self.norm.inverse(normed + self.norm.inverse(normed) * 1e-8) -\n                            self.norm.inverse(normed)))))\n                    except ValueError:\n                        # Handle non-invertible norms like BoundaryNorm\n                        g_sig_digits = 3\n                else:\n                    g_sig_digits = 3\n                data = (f\"{data:0.{g_sig_digits}g}\" if g_sig_digits > 0 else\n                        f\"{data:0.3g}\")\n        return data\n    except (TypeError, np.ma.MaskError):\n        return \"[]\"\n",
      "\ndef format_cursor_data(self, data):\n    \"\"\"\n    Return a string representation of *data*.\n\n    .. note::\n        This method is intended to be overridden by artist subclasses.\n        As an end-user of Matplotlib you will most likely not call this\n        method yourself.\n\n    The default implementation converts ints and floats and arrays of ints\n    and floats into a comma-separated string enclosed in square brackets,\n    unless the artist has an associated colorbar, in which case scalar\n    values are formatted using the colorbar's formatter.\n\n    See Also\n    --------\n    get_cursor_data\n    \"\"\"\n    try:\n        # Check if this is a scalar and we have a colorbar\n        if np.isscalar(data) and hasattr(self, 'colorbar') and self.colorbar:\n            return self.colorbar.formatter.format_ticks([data])[0]\n        # Check if we have a norm for formatting\n        elif hasattr(self, 'norm') and self.norm is not None and np.isscalar(data):\n            if not np.isfinite(data):\n                return \"[]\"\n            normed = self.norm(data)\n            if np.isfinite(normed):\n                # Try to use inverse for precision calculation\n                try:\n                    inverse_data = self.norm.inverse(normed)\n                    g_sig_digits = cbook._g_sig_digits(data, inverse_data)\n                except (ValueError, AttributeError):\n                    # Fallback for non-invertible norms like BoundaryNorm\n                    g_sig_digits = 3\n            else:\n                g_sig_digits = 3\n            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n        else:\n            return '[' + ', '.join(cbook._str_lower_float(item) for item in data.flat) + ']'\n    except (TypeError, IndexError):\n        return str(data)\n",
      "\n    def format_cursor_data(self, data):\n        \"\"\"\n        Return a string representation of *data*.\n\n        .. note::\n            This method is intended to be overridden by artist subclasses.\n            As an end-user of Matplotlib you will most likely not call this\n            method yourself.\n\n        The default implementation converts ints and floats and arrays of ints\n        and floats into a comma-separated string enclosed in square brackets,\n        unless the artist has an associated colorbar, in which case scalar\n        values are formatted using the colorbar's formatter.\n\n        See Also\n        --------\n        .Axes.format_cursor_data\n        \"\"\"\n        try:\n            # Cast to float to avoid errors in isfinite() for non-numeric data\n            data = float(data)\n        except (TypeError, ValueError):\n            pass\n        if hasattr(self, 'norm') and self.norm is not None:\n            # Scalars have no size, but check the type anyway just to be safe.\n            if np.isscalar(data) or data.size == 1:\n                normed = self.norm(data)\n                if np.isfinite(normed):\n                    try:\n                        # Try to get inverse for precision calculation\n                        inverse_data = self.norm.inverse(normed)\n                        g_sig_digits = cbook._g_sig_digits(data, inverse_data)\n                    except (ValueError, AttributeError):\n                        # Fallback for non-invertible norms like BoundaryNorm\n                        g_sig_digits = 3\n                else:\n                    g_sig_digits = 3\n                return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n        return \"[{:0.6g}]\".format(data)\n",
      "\n    def format_cursor_data(self, data):\n        \"\"\"\n        Return a string representation of *data*.\n\n        .. note::\n            This method is intended to be overridden by artist subclasses.\n            As an end-user of Matplotlib you will most likely not call this\n            method yourself.\n\n        The default implementation converts ints and floats and arrays of ints\n        and floats into a comma-separated string enclosed in square brackets,\n        unless the artist has an associated colorbar, in which case scalar\n        values are formatted using the colorbar's formatter.\n\n        See Also\n        --------\n        .Axes.format_cursor_data\n        \"\"\"\n        try:\n            # Check if this is a scalar and we have a colorbar formatter\n            if (\n                np.isscalar(data) or (\n                    isinstance(data, np.ndarray) and data.ndim == 0\n                )\n            ):\n                # Check if we have a colorbar with a formatter\n                if hasattr(self, 'colorbar') and self.colorbar is not None:\n                    return self.colorbar.formatter.format_data_short(data)\n                \n                # Check if we have a norm to format with\n                if hasattr(self, 'norm') and self.norm is not None:\n                    # For scalar data, try to use the norm to determine precision\n                    try:\n                        normed = self.norm(data)\n                        if np.isfinite(normed):\n                            # Try to get the inverse to determine precision\n                            try:\n                                inverse_data = self.norm.inverse(normed)\n                                if np.isfinite(inverse_data):\n                                    g_sig_digits = cbook._g_sig_digits(data, inverse_data)\n                                else:\n                                    g_sig_digits = 3  # default fallback\n                            except (ValueError, AttributeError):\n                                # Norm is not invertible (e.g., BoundaryNorm)\n                                g_sig_digits = 3  # default fallback\n                        else:\n                            g_sig_digits = 3  # default fallback\n                        return f\"{data:0.{g_sig_digits}g}\"\n                    except (ValueError, TypeError):\n                        # Norm failed, fall back to default formatting\n                        pass\n            \n            # Default formatting for non-scalar or when norm formatting fails\n            return '[' + ', '.join(cbook._recursive_format(\n                item, lambda x: f\"{x:0.3g}\" if isinstance(x, (int, float)) else str(x)\n            ) for item in np.atleast_1d(data)) + ']'\n        except Exception:\n            # Ultimate fallback for any unexpected errors\n            return str(data)\n",
      "\ndef format_cursor_data(self, data):\n    \"\"\"\n    Return a string representation of *data*.\n\n    .. note::\n        This method is intended to be overridden by artist subclasses.\n        As an end-user of Matplotlib you will most likely not call this\n        method yourself.\n\n    The default implementation converts ints and floats and arrays of ints\n    and floats into a comma-separated string enclosed in square brackets,\n    unless the artist has an associated colorbar, in which case scalar\n    values are formatted using the colorbar's formatter.\n\n    See Also\n    --------\n    get_cursor_data\n    \"\"\"\n    try:\n        from matplotlib.backend_bases import MouseEvent\n        if isinstance(data, MouseEvent):\n            # Deprecated, but we still need to handle it.\n            data = data.ydata, data.xdata\n    except ImportError:\n        pass\n\n    data_str = '[{!r}]'.format(data)\n    if self.get_array() is not None:\n        # Append the scalar data value to the string\n        if np.ndim(data) == 0:\n            # If normed, add the normed data value in parentheses\n            if self.norm is not None:\n                normed = self.norm(data)\n                if np.isfinite(normed):\n                    # Calculate g_sig_digits\n                    try:\n                        g_sig_digits = 3\n                        if self.norm.vmin is not None and self.norm.vmax is not None:\n                            # Try to use inverse to calculate precision\n                            delta = self.norm.inverse(self.norm.vmax) - self.norm.inverse(self.norm.vmin)\n                            g_sig_digits = int(np.ceil(np.log10(self.get_array().size / delta)))\n                    except (ValueError, AttributeError):\n                        # Fallback for non-invertible norms like BoundaryNorm\n                        g_sig_digits = 3\n                    \n                    data_str += ' ({normed:.{g_sig_digits}g})'.format(\n                        normed=normed, g_sig_digits=g_sig_digits)\n    return data_str\n",
      "\ndef format_cursor_data(self, data):\n    \"\"\"\n    Return a string representation of *data*.\n\n    .. note::\n        This method is intended to be overridden by artist subclasses.\n        As an end-user of Matplotlib you will most likely not call this\n        method yourself.\n\n    The default implementation converts ints and floats and arrays of ints\n    and floats into a comma-separated string enclosed in square brackets,\n    unless the artist has an associated colormap, in which case scalar data\n    is formatted using the colormap's normalization and colorbar ticklabels.\n    See also `.ScalarMappable.format_cursor_data`.\n    \"\"\"\n    try:\n        # Check if this is a scalar mappable with a colormap\n        norm = getattr(self, 'norm', None)\n        if norm is not None:\n            # Attempt to use the norm's inverse for precision calculation\n            try:\n                normed = self.norm(data)\n                if np.isfinite(normed):\n                    # Calculate precision based on the inverse transform\n                    inverse_data = self.norm.inverse(normed)\n                    g_sig_digits = cbook._g_sig_digits(inverse_data, 0.001)\n                else:\n                    g_sig_digits = 3\n            except (ValueError, AttributeError):\n                # Handle non-invertible norms (like BoundaryNorm) or other issues\n                g_sig_digits = 3\n            \n            # Try to get tick formatter from associated colorbar\n            try:\n                return self.cbar.formatter.format_data_short(data).strip()\n            except AttributeError:\n                pass\n            \n            # Fall back to default formatting with calculated precision\n            try:\n                return \"{:-#.{}g}\".format(data, g_sig_digits)\n            except (ValueError, TypeError):\n                return str(data)\n    except AttributeError:\n        pass\n    \n    # Default formatting for non-scalar mappable artists\n    return cbook._recursive_format(data)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..25b6267170 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1,3 +1,4 @@\n+\n from collections import namedtuple\n import contextlib\n from functools import wraps\n@@ -1274,6 +1275,7 @@ class Artist:\n         \"\"\"\n         return None\n \n+\n     def format_cursor_data(self, data):\n         \"\"\"\n         Return a string representation of *data*.\n@@ -1302,14 +1304,20 @@ class Artist:\n             if np.ma.getmask(data):\n                 return \"[]\"\n             normed = self.norm(data)\n+\n             if np.isfinite(normed):\n                 # Midpoints of neighboring color intervals.\n-                neighbors = self.norm.inverse(\n-                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n-                delta = abs(neighbors - data).max()\n-                g_sig_digits = cbook._g_sig_digits(data, delta)\n+                try:\n+                    neighbors = self.norm.inverse(\n+                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                    delta = abs(neighbors - data).max()\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # BoundaryNorm and other non-invertible norms\n+                    g_sig_digits = 3  # Consistent with default below.\n             else:\n                 g_sig_digits = 3  # Consistent with default below.\n+                g_sig_digits = 3  # Consistent with default below.\n             return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n         else:\n             try:\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..f165c23b2c 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1901,6 +1901,7 @@ class BoundaryNorm(Normalize):\n             ret = int(ret[0])  # assume python scalar\n         return ret\n \n+\n     def inverse(self, value):\n         \"\"\"\n         Raises\n",
    "variant_0": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..83b7e34cb7 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1,23 +1,46 @@\n-from collections import namedtuple\n-import contextlib\n-from functools import wraps\n-import inspect\n-from inspect import Signature, Parameter\n-import logging\n-from numbers import Number\n-import re\n-import warnings\n \n-import numpy as np\n-\n-import matplotlib as mpl\n-from . import _api, cbook\n-from .cm import ScalarMappable\n-from .path import Path\n-from .transforms import (Bbox, IdentityTransform, Transform, TransformedBbox,\n-                         TransformedPatchPath, TransformedPath)\n-\n-_log = logging.getLogger(__name__)\n+def format_cursor_data(self, data):\n+    \"\"\"\n+    Return a string representation of *data*.\n+\n+    .. note::\n+        This method is intended to be overridden by artist subclasses.\n+        As an end-user of Matplotlib you will most likely not call this\n+        method yourself.\n+\n+    The default implementation converts ints and floats and arrays of ints\n+    and floats into a comma-separated string enclosed in square brackets,\n+    unless the artist has an associated colormap, in which case scalar data\n+    is formatted using the colormap's normalization and colorbar ticklabels.\n+    See also `.ScalarMappable.format_cursor_data`.\n+    \"\"\"\n+    try:\n+        # If this artist has an associated colormap, format using\n+        # the colormap's normalization and colorbar ticklabels\n+        if hasattr(self, 'get_cmap'):\n+            # Attempt to use the colormap's normalization\n+            normed = self.norm(data)\n+            if np.ma.is_masked(normed):\n+                return \"masked\"\n+            \n+            try:\n+                # Try to get inverse for precision calculation\n+                inverse_data = self.norm.inverse(normed)\n+                g_sig_digits = cbook._g_sig_digits(inverse_data, data)\n+            except (ValueError, AttributeError):\n+                # Fallback for non-invertible norms like BoundaryNorm\n+                g_sig_digits = 3\n+            \n+            if not np.isfinite(normed):\n+                return \"out of range\"\n+            \n+            # Format the data value with appropriate precision\n+            return \"{:.{}g}\".format(data, g_sig_digits)\n+    except (TypeError, IndexError):\n+        pass\n+    \n+    # Fallback to default formatting\n+    return repr(data)\n \n \n def allow_rasterization(draw):\n@@ -1274,6 +1297,7 @@ class Artist:\n         \"\"\"\n         return None\n \n+\n     def format_cursor_data(self, data):\n         \"\"\"\n         Return a string representation of *data*.\n@@ -1303,9 +1327,61 @@ class Artist:\n                 return \"[]\"\n             normed = self.norm(data)\n             if np.isfinite(normed):\n-                # Midpoints of neighboring color intervals.\n-                neighbors = self.norm.inverse(\n-                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                # Calculate significant digits, handling non-invertible norms\n+                try:\n+                    inv_data = self.norm.inverse(normed)\n+                    g_sig_digits = cbook._g_sig_digits(inv_data, data)\n+                except ValueError:\n+                    # Norm is not invertible (e.g., BoundaryNorm)\n+                    g_sig_digits = 3\n+            else:\n+                g_sig_digits = 3\n+            # Format using colorbar formatter\n+            return \"[{}]\".format(self.cmap.colorbar.format_ticks([data])[0])\n+        # Handle arrays and other data types\n+        try:\n+            return cbook.format_approx(data, g_sig_digits)\n+        except (TypeError, ValueError):\n+            return str(data)\n+            # This block logically belongs to ScalarMappable, but can't be\n+            # implemented in it because most ScalarMappable subclasses inherit\n+            # from Artist first and from ScalarMappable second, so\n+            # Artist.format_cursor_data would always have precedence over\n+            # ScalarMappable.format_cursor_data.\n+            n = self.cmap.N\n+            if np.ma.getmask(data):\n+                return \"[]\"\n+            normed = self.norm(data)\n+\n+        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n+            # This block logically belongs to ScalarMappable, but can't be\n+            # implemented in it because most ScalarMappable subclasses inherit\n+            # from Artist first and from ScalarMappable second, so\n+            # Artist.format_cursor_data would always have precedence over\n+            # ScalarMappable.format_cursor_data.\n+            n = self.cmap.N\n+            if np.ma.getmask(data):\n+                return \"[]\"\n+            normed = self.norm(data)\n+            if np.isfinite(normed):\n+                try:\n+                    # Midpoints of neighboring color intervals.\n+                    neighbors = self.norm.inverse(\n+                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                    delta = abs(neighbors - data).max()\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Norm is not invertible (e.g., BoundaryNorm)\n+                    g_sig_digits = 3\n+            else:\n+                g_sig_digits = 3  # Consistent with default below.\n+                    delta = abs(neighbors - data).max()\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Norm is not invertible (e.g., BoundaryNorm)\n+                    g_sig_digits = 3\n+            else:\n+                g_sig_digits = 3  # Consistent with default below.\n                 delta = abs(neighbors - data).max()\n                 g_sig_digits = cbook._g_sig_digits(data, delta)\n             else:\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..d1b66928e9 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1901,15 +1901,56 @@ class BoundaryNorm(Normalize):\n             ret = int(ret[0])  # assume python scalar\n         return ret\n \n-    def inverse(self, value):\n+\n+    def format_cursor_data(self, data):\n         \"\"\"\n-        Raises\n-        ------\n-        ValueError\n-            BoundaryNorm is not invertible, so calling this method will always\n-            raise an error\n+        Return a string representation of *data*.\n+\n+        .. note::\n+            This method is intended to be overridden by artist subclasses.\n+            As an end-user of Matplotlib you will most likely not call this\n+            method yourself.\n+\n+        The default implementation converts ints and floats and arrays of ints\n+        and floats into a comma-separated string enclosed in square brackets,\n+        unless the artist has an associated colorbar, in which case scalar\n+        values are formatted using the colorbar's formatter.\n+\n+        See Also\n+        --------\n+        get_cursor_data\n         \"\"\"\n-        raise ValueError(\"BoundaryNorm is not invertible\")\n+        try:\n+            if self.get_array() is not None:\n+                # Scalarmappable\n+                if np.ndim(data) == 0:\n+                    # If this is a Scalarmappable with a colorbar, then try to use\n+                    # the colorbar's formatter; otherwise, just use the default\n+                    # str() conversion.\n+                    if self.colorbar is not None:\n+                        return self.colorbar.formatter.format_data_short(data)\n+                    else:\n+                        try:\n+                            normed = self.norm(data)\n+                        except TypeError:\n+                            return str(data)\n+                        if not np.isfinite(normed):\n+                            return str(data)\n+                        try:\n+                            # Calculate precision based on norm.inverse if available\n+                            g_sig_digits = int(np.ceil(-np.log10(\n+                                abs(self.norm.inverse(normed + self.norm.vmax/256) -\n+                                    self.norm.inverse(normed)))))\n+                        except (ValueError, AttributeError):\n+                            # Fallback for non-invertible norms (like BoundaryNorm)\n+                            # or norms without inverse method\n+                            g_sig_digits = 3\n+                        if g_sig_digits <= 0:\n+                            g_sig_digits = 3\n+                        return \"{:-#.{}g}\".format(data, g_sig_digits)\n+        except (TypeError, IndexError):\n+            pass\n+        return str(data)\n \n \n class NoNorm(Normalize):\n",
    "variant_1": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..4bc782437d 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1,23 +1,46 @@\n-from collections import namedtuple\n-import contextlib\n-from functools import wraps\n-import inspect\n-from inspect import Signature, Parameter\n-import logging\n-from numbers import Number\n-import re\n-import warnings\n \n-import numpy as np\n+def format_cursor_data(self, data):\n+    \"\"\"\n+    Return a string representation of *data*.\n+\n+    .. note::\n+        This method is intended to be overridden by artist subclasses.\n+        As an end-user of Matplotlib you will most likely not call this\n+        method yourself.\n \n-import matplotlib as mpl\n-from . import _api, cbook\n-from .cm import ScalarMappable\n-from .path import Path\n-from .transforms import (Bbox, IdentityTransform, Transform, TransformedBbox,\n-                         TransformedPatchPath, TransformedPath)\n+    The default implementation converts ints and floats and arrays of ints\n+    and floats into a comma-separated string enclosed in square brackets,\n+    unless the artist has an associated colorbar, in which case scalar\n+    values are formatted using the colorbar's formatter.\n \n-_log = logging.getLogger(__name__)\n+    See Also\n+    --------\n+    get_cursor_data\n+    \"\"\"\n+    try:\n+        # Note: This check needs to happen first so that\n+        # numpy.ma.core.MaskedConstant.item does not get called if data is\n+        # a masked value.\n+        if np.ma.is_masked(data):\n+            return \"[]\"\n+    except (TypeError, AttributeError):\n+        pass\n+\n+    if hasattr(self, 'norm') and self.norm is not None:\n+        # Formatting for scalars using the colorbar formatter.\n+        if np.ndim(data) == 0:\n+            normed = self.norm(data)\n+            if np.isfinite(normed):\n+                try:\n+                    # Try to calculate precision based on inverse norm\n+                    g_sig_digits = cbook._g_sig_digits(data, self.norm.inverse(normed))\n+                except ValueError:\n+                    # Fallback for non-invertible norms like BoundaryNorm\n+                    g_sig_digits = 3\n+            else:\n+                g_sig_digits = 3\n+            return cbook._auto_format_str % (g_sig_digits, data)\n+    return repr(data)\n \n \n def allow_rasterization(draw):\n@@ -1274,6 +1297,7 @@ class Artist:\n         \"\"\"\n         return None\n \n+\n     def format_cursor_data(self, data):\n         \"\"\"\n         Return a string representation of *data*.\n@@ -1292,6 +1316,47 @@ class Artist:\n         --------\n         get_cursor_data\n         \"\"\"\n+        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n+            # This block logically belongs to ScalarMappable, but can't be\n+            # implemented in it because most ScalarMappable subclasses inherit\n+            # from Artist first and from ScalarMappable second, so\n+            # Artist.format_cursor_data would always have precedence over\n+            # ScalarMappable.format_cursor_data.\n+            n = self.cmap.N\n+            if np.ma.getmask(data):\n+                return \"[]\"\n+            normed = self.norm(data)\n+            if np.isfinite(normed):\n+                # Calculate significant digits for formatting based on colormap\n+                # resolution, but handle non-invertible norms gracefully\n+                try:\n+                    g_sig_digits = max(\n+                        np.ceil(np.log10(n)).astype(int), 1)\n+                    inverse_normed = self.norm.inverse(\n+                        (int(normed * n) + 0.5) / n)\n+                    delta = abs(data - inverse_normed)\n+                    g_sig_digits += np.ceil(np.log10(1 / delta)).astype(int)\n+                except (ValueError, AttributeError):\n+                    # Fallback for non-invertible norms (e.g., BoundaryNorm)\n+                    g_sig_digits = 3\n+                return cbook._g_sig_digits(data, g_sig_digits)\n+            else:\n+                return \"[]\"\n+        try:\n+            return '[' + ', '.join(cbook._g_sig_digits(val, 3)\n+                                   for val in data.flat) + ']'\n+        except (TypeError, AttributeError):\n+            return str(data)\n+            # This block logically belongs to ScalarMappable, but can't be\n+            # implemented in it because most ScalarMappable subclasses inherit\n+            # from Artist first and from ScalarMappable second, so\n+            # Artist.format_cursor_data would always have precedence over\n+            # ScalarMappable.format_cursor_data.\n+            n = self.cmap.N\n+            if np.ma.getmask(data):\n+                return \"[]\"\n+            normed = self.norm(data)\n+\n         if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n             # This block logically belongs to ScalarMappable, but can't be\n             # implemented in it because most ScalarMappable subclasses inherit\n@@ -1304,8 +1369,23 @@ class Artist:\n             normed = self.norm(data)\n             if np.isfinite(normed):\n                 # Midpoints of neighboring color intervals.\n-                neighbors = self.norm.inverse(\n-                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                try:\n+                    neighbors = self.norm.inverse(\n+                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                    delta = abs(neighbors - data).max()\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Norm is not invertible (e.g., BoundaryNorm)\n+                    g_sig_digits = 3  # Consistent with default below.\n+            else:\n+                g_sig_digits = 3  # Consistent with default below.\n+                    delta = abs(neighbors - data).max()\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Norm is not invertible (e.g., BoundaryNorm)\n+                    g_sig_digits = 3\n+            else:\n+                g_sig_digits = 3  # Consistent with default below.\n                 delta = abs(neighbors - data).max()\n                 g_sig_digits = cbook._g_sig_digits(data, delta)\n             else:\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..1bd0a14c5a 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1901,15 +1901,53 @@ class BoundaryNorm(Normalize):\n             ret = int(ret[0])  # assume python scalar\n         return ret\n \n-    def inverse(self, value):\n+\n+    def format_cursor_data(self, data):\n         \"\"\"\n-        Raises\n-        ------\n-        ValueError\n-            BoundaryNorm is not invertible, so calling this method will always\n-            raise an error\n+        Return a string representation of *data*.\n+\n+        .. note::\n+            This method is intended to be overridden by artist subclasses.\n+            As an end-user of Matplotlib you will most likely not call this\n+            method yourself.\n+\n+        The default implementation converts ints and floats and arrays of ints\n+        and floats into a comma-separated string enclosed in square brackets,\n+        unless the artist has an associated colorbar, in which case scalar\n+        values are formatted using the colorbar's formatter.\n+\n+        See Also\n+        --------\n+        ScalarMappable.format_cursor_data\n         \"\"\"\n-        raise ValueError(\"BoundaryNorm is not invertible\")\n+        try:\n+            # Check if this is a scalar mappable with a colorbar formatter\n+            if hasattr(self, 'colorbar') and self.colorbar is not None:\n+                return self.colorbar.format_cursor_data(data)\n+        except Exception:\n+            pass\n+        \n+        # Default formatting for regular data\n+        if np.ndim(data) == 0:\n+            # Scalar data\n+            if isinstance(data, (int, np.integer)):\n+                return f\"{data:d}\"\n+            elif isinstance(data, (float, np.floating)):\n+                return f\"{data:g}\"\n+            else:\n+                return str(data)\n+        else:\n+            # Array data - format as comma-separated values in brackets\n+            flat_data = np.asarray(data).flat\n+            formatted_values = []\n+            for val in flat_data:\n+                if isinstance(val, (int, np.integer)):\n+                    formatted_values.append(f\"{val:d}\")\n+                elif isinstance(val, (float, np.floating)):\n+                    formatted_values.append(f\"{val:g}\")\n+                else:\n+                    formatted_values.append(str(val))\n+            return \"[\" + \", \".join(formatted_values) + \"]\"\n \n \n class NoNorm(Normalize):\n",
    "variant_2": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..4f0428a9ec 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1,23 +1,49 @@\n-from collections import namedtuple\n-import contextlib\n-from functools import wraps\n-import inspect\n-from inspect import Signature, Parameter\n-import logging\n-from numbers import Number\n-import re\n-import warnings\n \n-import numpy as np\n+def format_cursor_data(self, data):\n+    \"\"\"\n+    Return a string representation of *data*.\n+\n+    .. note::\n+        This method is intended to be overridden by artist subclasses.\n+        As an end-user of Matplotlib you will most likely not call this\n+        method yourself.\n \n-import matplotlib as mpl\n-from . import _api, cbook\n-from .cm import ScalarMappable\n-from .path import Path\n-from .transforms import (Bbox, IdentityTransform, Transform, TransformedBbox,\n-                         TransformedPatchPath, TransformedPath)\n+    The default implementation converts ints and floats and arrays of ints\n+    and floats into a comma-separated string enclosed in square brackets,\n+    unless the artist has an associated colorbar, in which case scalar\n+    values are formatted using the colorbar's formatter.\n \n-_log = logging.getLogger(__name__)\n+    See Also\n+    --------\n+    .Axes.format_cursor_data\n+    \"\"\"\n+    try:\n+        # casting to float is to unpack 0d arrays\n+        data = float(data)\n+    except (TypeError, ValueError):\n+        pass\n+    else:\n+        if hasattr(self, 'norm') and self.norm is not None:\n+            # Wrap in an array so we can use the colorbar's formatter\n+            normed = self.norm([data])\n+            if len(normed):\n+                normed = normed[0]\n+                if np.isfinite(normed):\n+                    try:\n+                        # Calculate significant digits based on the inverse transform\n+                        data_range = abs(self.norm.inverse([normed + 0.5]) -\n+                                       self.norm.inverse([normed - 0.5]))\n+                        g_sig_digits = max(1, int(np.ceil(-np.log10(data_range))))\n+                    except (ValueError, AttributeError):\n+                        # Handle non-invertible norms (like BoundaryNorm) or other errors\n+                        g_sig_digits = 3\n+                else:\n+                    g_sig_digits = 3\n+                return (\n+                    f\"[{type(self).__name__}] \"\n+                    f\"{cbook._g_sig_digits(data, g_sig_digits)}\"\n+                )\n+    return f\"[{type(self).__name__}] {data!r}\"\n \n \n def allow_rasterization(draw):\n@@ -1274,6 +1300,7 @@ class Artist:\n         \"\"\"\n         return None\n \n+\n     def format_cursor_data(self, data):\n         \"\"\"\n         Return a string representation of *data*.\n@@ -1292,6 +1319,39 @@ class Artist:\n         --------\n         get_cursor_data\n         \"\"\"\n+        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n+            # This block logically belongs to ScalarMappable, but can't be\n+            # implemented in it because most ScalarMappable subclasses inherit\n+            # from Artist first and from ScalarMappable second, so\n+            # Artist.format_cursor_data would always have precedence over\n+            # ScalarMappable.format_cursor_data.\n+            n = self.cmap.N\n+            if np.ma.getmask(data):\n+                return \"[]\"\n+            normed = self.norm(data)\n+            if np.isfinite(normed):\n+                # Calculate significant digits based on colormap resolution,\n+                # but handle non-invertible norms gracefully\n+                try:\n+                    s = self.norm.inverse(np.linspace(0, 1, n))\n+                    g_sig_digits = cbook._g_sig_digits(s, 0.001)\n+                except ValueError:\n+                    # Handle non-invertible norms (e.g., BoundaryNorm)\n+                    g_sig_digits = 3\n+            else:\n+                g_sig_digits = 3\n+            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n+        return '[{!r}]'.format(data)\n+            # This block logically belongs to ScalarMappable, but can't be\n+            # implemented in it because most ScalarMappable subclasses inherit\n+            # from Artist first and from ScalarMappable second, so\n+            # Artist.format_cursor_data would always have precedence over\n+            # ScalarMappable.format_cursor_data.\n+            n = self.cmap.N\n+            if np.ma.getmask(data):\n+                return \"[]\"\n+            normed = self.norm(data)\n+\n         if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n             # This block logically belongs to ScalarMappable, but can't be\n             # implemented in it because most ScalarMappable subclasses inherit\n@@ -1304,8 +1364,24 @@ class Artist:\n             normed = self.norm(data)\n             if np.isfinite(normed):\n                 # Midpoints of neighboring color intervals.\n-                neighbors = self.norm.inverse(\n-                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                try:\n+                    neighbors = self.norm.inverse(\n+                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                    delta = abs(neighbors - data).max()\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Norm is not invertible (e.g., BoundaryNorm)\n+                    g_sig_digits = 3\n+            else:\n+                g_sig_digits = 3  # Consistent with default below.\n+            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n+                    delta = abs(neighbors - data).max()\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Norm is not invertible (e.g., BoundaryNorm)\n+                    g_sig_digits = 3\n+            else:\n+                g_sig_digits = 3  # Consistent with default below.\n                 delta = abs(neighbors - data).max()\n                 g_sig_digits = cbook._g_sig_digits(data, delta)\n             else:\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..3b5d88adaf 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1901,15 +1901,55 @@ class BoundaryNorm(Normalize):\n             ret = int(ret[0])  # assume python scalar\n         return ret\n \n-    def inverse(self, value):\n-        \"\"\"\n-        Raises\n-        ------\n-        ValueError\n-            BoundaryNorm is not invertible, so calling this method will always\n-            raise an error\n-        \"\"\"\n-        raise ValueError(\"BoundaryNorm is not invertible\")\n+\n+def format_cursor_data(self, data):\n+    \"\"\"\n+    Return a string representation of *data*.\n+\n+    .. note::\n+        This method is intended to be overridden by artist subclasses.\n+        As an end-user of Matplotlib you will most likely not call this\n+        method yourself.\n+\n+    The default implementation converts ints and floats and arrays of ints\n+    and floats into a comma-separated string enclosed in square brackets,\n+    unless the artist has an associated colorbar, in which case scalar\n+    values are formatted using the colorbar's formatter.\n+\n+    See Also\n+    --------\n+    ScalarMappable.format_cursor_data\n+    \"\"\"\n+    try:\n+        # Check if this is a scalar mappable with a colorbar\n+        if hasattr(self, 'colorbar') and self.colorbar is not None:\n+            return self.colorbar.format_cursor_data(data)\n+        # Check if this is a scalar mappable with a norm (but no colorbar)\n+        elif hasattr(self, 'norm') and self.norm is not None:\n+            # Try to use the norm's inverse to determine appropriate precision\n+            try:\n+                normed = self.norm(data)\n+                if np.isfinite(normed):\n+                    inverse_data = self.norm.inverse(normed)\n+                    g_sig_digits = cbook._g_sig_digits(inverse_data, 0.001)\n+                else:\n+                    g_sig_digits = 3\n+            except (ValueError, AttributeError):\n+                # Handle non-invertible norms (like BoundaryNorm) or other errors\n+                g_sig_digits = 3\n+            \n+            return cbook._auto_format_str % (g_sig_digits, data)\n+    except Exception:\n+        pass\n+    \n+    # Default formatting for non-scalar mappable artists\n+    if isinstance(data, np.ma.MaskedArray) and data.mask.all():\n+        return \"masked\"\n+    \n+    try:\n+        return cbook.format_approx(data, 0.01)\n+    except (TypeError, ValueError):\n+        return repr(data)\n \n \n class NoNorm(Normalize):\n",
    "variant_3": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..aa4618b6d2 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1,23 +1,45 @@\n-from collections import namedtuple\n-import contextlib\n-from functools import wraps\n-import inspect\n-from inspect import Signature, Parameter\n-import logging\n-from numbers import Number\n-import re\n-import warnings\n \n-import numpy as np\n+def format_cursor_data(self, data):\n+    \"\"\"\n+    Return a string representation of *data*.\n \n-import matplotlib as mpl\n-from . import _api, cbook\n-from .cm import ScalarMappable\n-from .path import Path\n-from .transforms import (Bbox, IdentityTransform, Transform, TransformedBbox,\n-                         TransformedPatchPath, TransformedPath)\n+    .. note::\n+        This method is intended to be overridden by artist subclasses.\n+        As an end-user of Matplotlib you will most likely not call this\n+        method yourself.\n \n-_log = logging.getLogger(__name__)\n+    The default implementation converts ints and floats and arrays of ints\n+    and floats into a comma-separated string enclosed in square brackets,\n+    unless the artist has an associated colorbar, in which case scalar\n+    values are formatted using the colorbar's formatter.\n+\n+    See Also\n+    --------\n+    get_cursor_data\n+    \"\"\"\n+    try:\n+        if self.get_array() is not None:\n+            # Scalars or 0-D arrays get converted to float to avoid\n+            # Decimal-related issues with Colorbar formatting\n+            if np.ndim(data) == 0:\n+                data = float(data)\n+            if self.norm is not None:\n+                normed = self.norm(data)\n+                if np.isfinite(normed):\n+                    try:\n+                        g_sig_digits = 3 - int(np.ceil(np.log10(np.abs(\n+                            self.norm.inverse(normed + self.norm.inverse(normed) * 1e-8) -\n+                            self.norm.inverse(normed)))))\n+                    except ValueError:\n+                        # Handle non-invertible norms like BoundaryNorm\n+                        g_sig_digits = 3\n+                else:\n+                    g_sig_digits = 3\n+                data = (f\"{data:0.{g_sig_digits}g}\" if g_sig_digits > 0 else\n+                        f\"{data:0.3g}\")\n+        return data\n+    except (TypeError, np.ma.MaskError):\n+        return \"[]\"\n \n \n def allow_rasterization(draw):\n@@ -1274,6 +1296,7 @@ class Artist:\n         \"\"\"\n         return None\n \n+\n     def format_cursor_data(self, data):\n         \"\"\"\n         Return a string representation of *data*.\n@@ -1292,6 +1315,44 @@ class Artist:\n         --------\n         get_cursor_data\n         \"\"\"\n+        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n+            # This block logically belongs to ScalarMappable, but can't be\n+            # implemented in it because most ScalarMappable subclasses inherit\n+            # from Artist first and from ScalarMappable second, so\n+            # Artist.format_cursor_data would always have precedence over\n+            # ScalarMappable.format_cursor_data.\n+            n = self.cmap.N\n+            if np.ma.getmask(data):\n+                return \"[]\"\n+            normed = self.norm(data)\n+            if np.isfinite(normed):\n+                # Calculate significant digits, handling non-invertible norms\n+                try:\n+                    inverse_normed = self.norm.inverse(normed)\n+                    g_sig_digits = cbook._g_sig_digits(inverse_normed, 0.001)\n+                except (ValueError, AttributeError):\n+                    # Fallback for non-invertible norms like BoundaryNorm\n+                    g_sig_digits = 3\n+            else:\n+                g_sig_digits = 3\n+            return self.colorbar.formatter.format_data_short(data.item(),\n+                                                             g_sig_digits)\n+        try:\n+            return '[' + ', '.join(cbook._strip_math(\n+                format(val, 'g') if isinstance(val, Number) else str(val))\n+                for val in np.atleast_1d(data)) + ']'\n+        except (TypeError, ValueError):\n+            return str(data)\n+            # This block logically belongs to ScalarMappable, but can't be\n+            # implemented in it because most ScalarMappable subclasses inherit\n+            # from Artist first and from ScalarMappable second, so\n+            # Artist.format_cursor_data would always have precedence over\n+            # ScalarMappable.format_cursor_data.\n+            n = self.cmap.N\n+            if np.ma.getmask(data):\n+                return \"[]\"\n+            normed = self.norm(data)\n+\n         if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n             # This block logically belongs to ScalarMappable, but can't be\n             # implemented in it because most ScalarMappable subclasses inherit\n@@ -1304,8 +1365,24 @@ class Artist:\n             normed = self.norm(data)\n             if np.isfinite(normed):\n                 # Midpoints of neighboring color intervals.\n-                neighbors = self.norm.inverse(\n-                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                try:\n+                    neighbors = self.norm.inverse(\n+                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                    delta = abs(neighbors - data).max()\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except (ValueError, AttributeError):\n+                    # Norm is not invertible (e.g., BoundaryNorm) or doesn't have inverse\n+                    g_sig_digits = 3  # Use default precision\n+            else:\n+                g_sig_digits = 3  # Consistent with default below.\n+            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n+                    delta = abs(neighbors - data).max()\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Norm is not invertible (e.g., BoundaryNorm)\n+                    g_sig_digits = 3\n+            else:\n+                g_sig_digits = 3  # Consistent with default below.\n                 delta = abs(neighbors - data).max()\n                 g_sig_digits = cbook._g_sig_digits(data, delta)\n             else:\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..0166356949 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1901,15 +1901,53 @@ class BoundaryNorm(Normalize):\n             ret = int(ret[0])  # assume python scalar\n         return ret\n \n-    def inverse(self, value):\n+\n+    def format_cursor_data(self, data):\n         \"\"\"\n-        Raises\n-        ------\n-        ValueError\n-            BoundaryNorm is not invertible, so calling this method will always\n-            raise an error\n+        Return a string representation of *data*.\n+\n+        .. note::\n+            This method is intended to be overridden by artist subclasses.\n+            As an end-user of Matplotlib you will most likely not call this\n+            method yourself.\n+\n+        The default implementation converts ints and floats and arrays of ints\n+        and floats into a comma-separated string enclosed in square brackets,\n+        unless the artist has an associated colorbar, in which case scalar\n+        values are formatted using the colorbar's formatter.\n+\n+        See Also\n+        --------\n+        .axes.Axes.format_cursor_data\n         \"\"\"\n-        raise ValueError(\"BoundaryNorm is not invertible\")\n+        try:\n+            # shape = data.shape  # Check it's not a scalar.\n+            if data.shape == ():\n+                # Scalar case: `data` is a numpy scalar.\n+                if hasattr(self, 'get_cmap'):\n+                    # ColormappedArtist.\n+                    if self.get_array() is not None:\n+                        # Formatter should be set by the colorbar.\n+                        try:\n+                            normed = self.norm.inverse(self.norm(data))\n+                        except (ValueError, AttributeError):\n+                            # Handle non-invertible norms like BoundaryNorm\n+                            g_sig_digits = 3\n+                        else:\n+                            if np.isfinite(normed):\n+                                g_sig_digits = cbook._g_sig_digits(data, normed)\n+                            else:\n+                                g_sig_digits = 3\n+                        return self.cbar.formatter._format_vmin_vmax(\n+                            data, g_sig_digits)\n+                return f'{data:1.3g}'\n+            else:\n+                # Non-scalar case: `data` is a numpy array.\n+                return '[' + ', '.join(f'{item:1.3g}' for item in data) + ']'\n+        except (ValueError, IndexError):\n+            # ValueError if data is not a number.\n+            # IndexError if data is not NumPy array-like.\n+            return str(data)\n \n \n class NoNorm(Normalize):\n",
    "variant_4": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..d395a9b7b6 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1,23 +1,46 @@\n-from collections import namedtuple\n-import contextlib\n-from functools import wraps\n-import inspect\n-from inspect import Signature, Parameter\n-import logging\n-from numbers import Number\n-import re\n-import warnings\n \n-import numpy as np\n+def format_cursor_data(self, data):\n+    \"\"\"\n+    Return a string representation of *data*.\n \n-import matplotlib as mpl\n-from . import _api, cbook\n-from .cm import ScalarMappable\n-from .path import Path\n-from .transforms import (Bbox, IdentityTransform, Transform, TransformedBbox,\n-                         TransformedPatchPath, TransformedPath)\n+    .. note::\n+        This method is intended to be overridden by artist subclasses.\n+        As an end-user of Matplotlib you will most likely not call this\n+        method yourself.\n \n-_log = logging.getLogger(__name__)\n+    The default implementation converts ints and floats and arrays of ints\n+    and floats into a comma-separated string enclosed in square brackets,\n+    unless the artist has an associated colorbar, in which case scalar\n+    values are formatted using the colorbar's formatter.\n+\n+    See Also\n+    --------\n+    get_cursor_data\n+    \"\"\"\n+    try:\n+        # Check if this is a scalar and we have a colorbar\n+        if np.isscalar(data) and hasattr(self, 'colorbar') and self.colorbar:\n+            return self.colorbar.formatter.format_ticks([data])[0]\n+        # Check if we have a norm for formatting\n+        elif hasattr(self, 'norm') and self.norm is not None and np.isscalar(data):\n+            if not np.isfinite(data):\n+                return \"[]\"\n+            normed = self.norm(data)\n+            if np.isfinite(normed):\n+                # Try to use inverse for precision calculation\n+                try:\n+                    inverse_data = self.norm.inverse(normed)\n+                    g_sig_digits = cbook._g_sig_digits(data, inverse_data)\n+                except (ValueError, AttributeError):\n+                    # Fallback for non-invertible norms like BoundaryNorm\n+                    g_sig_digits = 3\n+            else:\n+                g_sig_digits = 3\n+            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n+        else:\n+            return '[' + ', '.join(cbook._str_lower_float(item) for item in data.flat) + ']'\n+    except (TypeError, IndexError):\n+        return str(data)\n \n \n def allow_rasterization(draw):\n@@ -1274,6 +1297,7 @@ class Artist:\n         \"\"\"\n         return None\n \n+\n     def format_cursor_data(self, data):\n         \"\"\"\n         Return a string representation of *data*.\n@@ -1292,6 +1316,39 @@ class Artist:\n         --------\n         get_cursor_data\n         \"\"\"\n+        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n+            # This block logically belongs to ScalarMappable, but can't be\n+            # implemented in it because most ScalarMappable subclasses inherit\n+            # from Artist first and from ScalarMappable second, so\n+            # Artist.format_cursor_data would always have precedence over\n+            # ScalarMappable.format_cursor_data.\n+            n = self.cmap.N\n+            if np.ma.getmask(data):\n+                return \"[]\"\n+            normed = self.norm(data)\n+            if np.isfinite(normed):\n+                # Calculate significant digits for formatting\n+                try:\n+                    # Try to use inverse for precision calculation\n+                    delta = abs(self.norm.inverse(normed + 0.5/n) - self.norm.inverse(normed - 0.5/n))\n+                    g_sig_digits = max(1, int(np.ceil(-np.log10(delta))))\n+                except (AttributeError, ValueError):\n+                    # Handle non-invertible norms like BoundaryNorm\n+                    g_sig_digits = 3\n+                return self.cmap.colorbar.formatter.format_data_short(data)\n+            else:\n+                return \"[]\"\n+        return cbook._auto_format_str(data)\n+            # This block logically belongs to ScalarMappable, but can't be\n+            # implemented in it because most ScalarMappable subclasses inherit\n+            # from Artist first and from ScalarMappable second, so\n+            # Artist.format_cursor_data would always have precedence over\n+            # ScalarMappable.format_cursor_data.\n+            n = self.cmap.N\n+            if np.ma.getmask(data):\n+                return \"[]\"\n+            normed = self.norm(data)\n+\n         if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n             # This block logically belongs to ScalarMappable, but can't be\n             # implemented in it because most ScalarMappable subclasses inherit\n@@ -1304,8 +1361,24 @@ class Artist:\n             normed = self.norm(data)\n             if np.isfinite(normed):\n                 # Midpoints of neighboring color intervals.\n-                neighbors = self.norm.inverse(\n-                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                try:\n+                    neighbors = self.norm.inverse(\n+                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                    delta = abs(neighbors - data).max()\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Norm is not invertible (e.g., BoundaryNorm)\n+                    g_sig_digits = 3\n+            else:\n+                g_sig_digits = 3  # Consistent with default below.\n+            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n+                    delta = abs(neighbors - data).max()\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Norm is not invertible (e.g., BoundaryNorm)\n+                    g_sig_digits = 3\n+            else:\n+                g_sig_digits = 3  # Consistent with default below.\n                 delta = abs(neighbors - data).max()\n                 g_sig_digits = cbook._g_sig_digits(data, delta)\n             else:\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..802cf17032 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1901,15 +1901,62 @@ class BoundaryNorm(Normalize):\n             ret = int(ret[0])  # assume python scalar\n         return ret\n \n-    def inverse(self, value):\n+\n+    def format_cursor_data(self, data):\n         \"\"\"\n-        Raises\n-        ------\n-        ValueError\n-            BoundaryNorm is not invertible, so calling this method will always\n-            raise an error\n+        Return a string representation of *data*.\n+\n+        .. note::\n+            This method is intended to be overridden by artist subclasses.\n+            As an end-user of Matplotlib you will most likely not call this\n+            method yourself.\n+\n+        The default implementation converts ints and floats and arrays of ints\n+        and floats into a comma-separated string enclosed in square brackets,\n+        unless the artist has an associated colorbar, in which case scalar\n+        values are formatted using the colorbar's formatter.\n+\n+        See Also\n+        --------\n+        get_cursor_data\n         \"\"\"\n-        raise ValueError(\"BoundaryNorm is not invertible\")\n+        try:\n+            # casting to float is safe for python types, and\n+            # we don't want to support other types such as\n+            # datetime which may be in an array\n+            data = np.asarray(data, dtype=float)\n+        except (TypeError, ValueError):\n+            data = np.asarray(data)\n+        data_str = np.array2string(data, separator=', ', suppress_small=True)\n+        if self.get_array() is not None:\n+            # Formatter for colormapped data\n+            normed = self.norm(data)\n+            if np.isfinite(normed).all():\n+                try:\n+                    inverse_normed = self.norm.inverse(normed)\n+                    g_sig_digits = 3\n+                    if inverse_normed.size > 1:\n+                        delta = np.ptp(inverse_normed)\n+                        if delta:\n+                            g_sig_digits = max(\n+                                1,\n+                                np.ceil(-np.log10(delta)).astype(int)\n+                            )\n+                except (ValueError, AttributeError):\n+                    # Handle non-invertible norms like BoundaryNorm\n+                    g_sig_digits = 3\n+                fmt = f\"{{:.{g_sig_digits}g}}\"\n+            else:\n+                g_sig_digits = 3\n+                fmt = f\"{{:.{g_sig_digits}g}}\"\n+            if data.ndim == 0:\n+                # it's a single number (not an array)\n+                return fmt.format(data.item())\n+            else:\n+                # it's an array, format each element with the same precision\n+                return \"[\" + \", \".join(fmt.format(x) for x in data.flat) + \"]\"\n+        else:\n+            return data_str\n \n \n class NoNorm(Normalize):\n",
    "variant_5": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..21814e40fa 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1,23 +1,43 @@\n-from collections import namedtuple\n-import contextlib\n-from functools import wraps\n-import inspect\n-from inspect import Signature, Parameter\n-import logging\n-from numbers import Number\n-import re\n-import warnings\n \n-import numpy as np\n+    def format_cursor_data(self, data):\n+        \"\"\"\n+        Return a string representation of *data*.\n+\n+        .. note::\n+            This method is intended to be overridden by artist subclasses.\n+            As an end-user of Matplotlib you will most likely not call this\n+            method yourself.\n \n-import matplotlib as mpl\n-from . import _api, cbook\n-from .cm import ScalarMappable\n-from .path import Path\n-from .transforms import (Bbox, IdentityTransform, Transform, TransformedBbox,\n-                         TransformedPatchPath, TransformedPath)\n+        The default implementation converts ints and floats and arrays of ints\n+        and floats into a comma-separated string enclosed in square brackets,\n+        unless the artist has an associated colorbar, in which case scalar\n+        values are formatted using the colorbar's formatter.\n \n-_log = logging.getLogger(__name__)\n+        See Also\n+        --------\n+        .Axes.format_cursor_data\n+        \"\"\"\n+        try:\n+            # Cast to float to avoid errors in isfinite() for non-numeric data\n+            data = float(data)\n+        except (TypeError, ValueError):\n+            pass\n+        if hasattr(self, 'norm') and self.norm is not None:\n+            # Scalars have no size, but check the type anyway just to be safe.\n+            if np.isscalar(data) or data.size == 1:\n+                normed = self.norm(data)\n+                if np.isfinite(normed):\n+                    try:\n+                        # Try to get inverse for precision calculation\n+                        inverse_data = self.norm.inverse(normed)\n+                        g_sig_digits = cbook._g_sig_digits(data, inverse_data)\n+                    except (ValueError, AttributeError):\n+                        # Fallback for non-invertible norms like BoundaryNorm\n+                        g_sig_digits = 3\n+                else:\n+                    g_sig_digits = 3\n+                return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n+        return \"[{:0.6g}]\".format(data)\n \n \n def allow_rasterization(draw):\n@@ -1274,6 +1294,7 @@ class Artist:\n         \"\"\"\n         return None\n \n+\n     def format_cursor_data(self, data):\n         \"\"\"\n         Return a string representation of *data*.\n@@ -1292,6 +1313,44 @@ class Artist:\n         --------\n         get_cursor_data\n         \"\"\"\n+        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n+            # This block logically belongs to ScalarMappable, but can't be\n+            # implemented in it because most ScalarMappable subclasses inherit\n+            # from Artist first and from ScalarMappable second, so\n+            # Artist.format_cursor_data would always have precedence over\n+            # ScalarMappable.format_cursor_data.\n+            n = self.cmap.N\n+            if np.ma.getmask(data):\n+                return \"[]\"\n+            normed = self.norm(data)\n+            if np.isfinite(normed):\n+                # Only compute precision if norm is invertible\n+                try:\n+                    inverse_normed = self.norm.inverse(normed)\n+                    g_sig_digits = cbook._g_sig_digits(inverse_normed, 0.001)\n+                except ValueError:\n+                    # Some norms like BoundaryNorm are not invertible\n+                    g_sig_digits = 3\n+                s = cbook._g_sig_digits(data, 0.001)\n+                s = max(s, g_sig_digits)\n+                return \"[{:-#.{}g}]\".format(data, s)\n+            else:\n+                return \"[]\"\n+        try:\n+            return '[' + ', '.join(cbook._g_sig_digits(v, 0.001)\n+                                   for v in data.flat) + ']'\n+        except (AttributeError, TypeError):\n+            return str(data)\n+            # This block logically belongs to ScalarMappable, but can't be\n+            # implemented in it because most ScalarMappable subclasses inherit\n+            # from Artist first and from ScalarMappable second, so\n+            # Artist.format_cursor_data would always have precedence over\n+            # ScalarMappable.format_cursor_data.\n+            n = self.cmap.N\n+            if np.ma.getmask(data):\n+                return \"[]\"\n+            normed = self.norm(data)\n+\n         if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n             # This block logically belongs to ScalarMappable, but can't be\n             # implemented in it because most ScalarMappable subclasses inherit\n@@ -1304,8 +1363,23 @@ class Artist:\n             normed = self.norm(data)\n             if np.isfinite(normed):\n                 # Midpoints of neighboring color intervals.\n-                neighbors = self.norm.inverse(\n-                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                try:\n+                    neighbors = self.norm.inverse(\n+                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                    delta = abs(neighbors - data).max()\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Norm is not invertible (e.g., BoundaryNorm)\n+                    g_sig_digits = 3\n+            else:\n+                g_sig_digits = 3  # Consistent with default below.\n+                    delta = abs(neighbors - data).max()\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Norm is not invertible (e.g., BoundaryNorm)\n+                    g_sig_digits = 3\n+            else:\n+                g_sig_digits = 3  # Consistent with default below.\n                 delta = abs(neighbors - data).max()\n                 g_sig_digits = cbook._g_sig_digits(data, delta)\n             else:\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..5f1156b4ae 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1901,15 +1901,50 @@ class BoundaryNorm(Normalize):\n             ret = int(ret[0])  # assume python scalar\n         return ret\n \n-    def inverse(self, value):\n+\n+    def format_cursor_data(self, data):\n         \"\"\"\n-        Raises\n-        ------\n-        ValueError\n-            BoundaryNorm is not invertible, so calling this method will always\n-            raise an error\n+        Return a string representation of *data*.\n+\n+        .. note::\n+            This method is intended to be overridden by artist subclasses.\n+            As an end-user of Matplotlib you will most likely not call this\n+            method yourself.\n+\n+        The default implementation converts ints and floats and arrays of ints\n+        and floats into a comma-separated string enclosed in square brackets,\n+        unless the artist has an associated colorbar, in which case scalar\n+        values are formatted using the colorbar's formatter.\n+\n+        See Also\n+        --------\n+        get_cursor_data\n         \"\"\"\n-        raise ValueError(\"BoundaryNorm is not invertible\")\n+        try:\n+            if self._mouseover_set.intersection(\n+                    ['c', 'colors', 'facecolor', 'facecolors', 'edgecolors']):\n+                # This is a color-like attribute\n+                if np.ndim(data) == 0:\n+                    # it's a scalar, not an array\n+                    normed = self.norm(data)\n+                    if np.isfinite(normed):\n+                        # Attempt to get significant digits from inverse\n+                        try:\n+                            g_sig_digits = cbook._g_sig_digits(data, self.norm.inverse(normed))\n+                        except ValueError:\n+                            # Norm is not invertible (e.g., BoundaryNorm)\n+                            g_sig_digits = 3\n+                    else:\n+                        g_sig_digits = 3\n+                    return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n+        except (TypeError, IndexError):\n+            pass\n+\n+        try:\n+            return '[' + ', '.join(cbook._auto_format_str(v)\n+                                   for v in cbook._sanitize_sequence(data.flat)) + ']'\n+        except (TypeError, AttributeError):\n+            return str(data)\n \n \n class NoNorm(Normalize):\n",
    "variant_6": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..64f269d3af 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1,23 +1,63 @@\n-from collections import namedtuple\n-import contextlib\n-from functools import wraps\n-import inspect\n-from inspect import Signature, Parameter\n-import logging\n-from numbers import Number\n-import re\n-import warnings\n \n-import numpy as np\n+    def format_cursor_data(self, data):\n+        \"\"\"\n+        Return a string representation of *data*.\n \n-import matplotlib as mpl\n-from . import _api, cbook\n-from .cm import ScalarMappable\n-from .path import Path\n-from .transforms import (Bbox, IdentityTransform, Transform, TransformedBbox,\n-                         TransformedPatchPath, TransformedPath)\n+        .. note::\n+            This method is intended to be overridden by artist subclasses.\n+            As an end-user of Matplotlib you will most likely not call this\n+            method yourself.\n \n-_log = logging.getLogger(__name__)\n+        The default implementation converts ints and floats and arrays of ints\n+        and floats into a comma-separated string enclosed in square brackets,\n+        unless the artist has an associated colorbar, in which case scalar\n+        values are formatted using the colorbar's formatter.\n+\n+        See Also\n+        --------\n+        .Axes.format_cursor_data\n+        \"\"\"\n+        try:\n+            # Check if this is a scalar and we have a colorbar formatter\n+            if (\n+                np.isscalar(data) or (\n+                    isinstance(data, np.ndarray) and data.ndim == 0\n+                )\n+            ):\n+                # Check if we have a colorbar with a formatter\n+                if hasattr(self, 'colorbar') and self.colorbar is not None:\n+                    return self.colorbar.formatter.format_data_short(data)\n+                \n+                # Check if we have a norm to format with\n+                if hasattr(self, 'norm') and self.norm is not None:\n+                    # For scalar data, try to use the norm to determine precision\n+                    try:\n+                        normed = self.norm(data)\n+                        if np.isfinite(normed):\n+                            # Try to get the inverse to determine precision\n+                            try:\n+                                inverse_data = self.norm.inverse(normed)\n+                                if np.isfinite(inverse_data):\n+                                    g_sig_digits = cbook._g_sig_digits(data, inverse_data)\n+                                else:\n+                                    g_sig_digits = 3  # default fallback\n+                            except (ValueError, AttributeError):\n+                                # Norm is not invertible (e.g., BoundaryNorm)\n+                                g_sig_digits = 3  # default fallback\n+                        else:\n+                            g_sig_digits = 3  # default fallback\n+                        return f\"{data:0.{g_sig_digits}g}\"\n+                    except (ValueError, TypeError):\n+                        # Norm failed, fall back to default formatting\n+                        pass\n+            \n+            # Default formatting for non-scalar or when norm formatting fails\n+            return '[' + ', '.join(cbook._recursive_format(\n+                item, lambda x: f\"{x:0.3g}\" if isinstance(x, (int, float)) else str(x)\n+            ) for item in np.atleast_1d(data)) + ']'\n+        except Exception:\n+            # Ultimate fallback for any unexpected errors\n+            return str(data)\n \n \n def allow_rasterization(draw):\n@@ -1274,6 +1314,7 @@ class Artist:\n         \"\"\"\n         return None\n \n+\n     def format_cursor_data(self, data):\n         \"\"\"\n         Return a string representation of *data*.\n@@ -1292,6 +1333,43 @@ class Artist:\n         --------\n         get_cursor_data\n         \"\"\"\n+        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n+            # This block logically belongs to ScalarMappable, but can't be\n+            # implemented in it because most ScalarMappable subclasses inherit\n+            # from Artist first and from ScalarMappable second, so\n+            # Artist.format_cursor_data would always have precedence over\n+            # ScalarMappable.format_cursor_data.\n+            n = self.cmap.N\n+            if np.ma.getmask(data):\n+                return \"[]\"\n+            normed = self.norm(data)\n+            if np.isfinite(normed):\n+                # Calculate significant digits, handling non-invertible norms\n+                try:\n+                    inverse_normed = self.norm.inverse(normed)\n+                    g_sig_digits = cbook._g_sig_digits(inverse_normed, 0.001)\n+                except ValueError:\n+                    # Norm is not invertible (e.g., BoundaryNorm)\n+                    g_sig_digits = 3\n+                # Don't strip trailing zeros if it's an integer.\n+                formatted = (\n+                    (\"{:.%df}\" if g_sig_digits > 0 else \"{:.0f}\")\n+                    % g_sig_digits\n+                ).format(self.norm.inverse(normed) if g_sig_digits > 0 else normed)\n+                return formatted\n+            else:\n+                return \"[]\"\n+        return \"[{!r}]\".format(data)\n+            # This block logically belongs to ScalarMappable, but can't be\n+            # implemented in it because most ScalarMappable subclasses inherit\n+            # from Artist first and from ScalarMappable second, so\n+            # Artist.format_cursor_data would always have precedence over\n+            # ScalarMappable.format_cursor_data.\n+            n = self.cmap.N\n+            if np.ma.getmask(data):\n+                return \"[]\"\n+            normed = self.norm(data)\n+\n         if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n             # This block logically belongs to ScalarMappable, but can't be\n             # implemented in it because most ScalarMappable subclasses inherit\n@@ -1304,8 +1382,24 @@ class Artist:\n             normed = self.norm(data)\n             if np.isfinite(normed):\n                 # Midpoints of neighboring color intervals.\n-                neighbors = self.norm.inverse(\n-                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                try:\n+                    neighbors = self.norm.inverse(\n+                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                    delta = abs(neighbors - data).max()\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Norm is not invertible (e.g., BoundaryNorm)\n+                    g_sig_digits = 3  # Consistent with default below.\n+            else:\n+                g_sig_digits = 3  # Consistent with default below.\n+            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n+                    delta = abs(neighbors - data).max()\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Norm is not invertible (e.g., BoundaryNorm)\n+                    g_sig_digits = 3\n+            else:\n+                g_sig_digits = 3  # Consistent with default below.\n                 delta = abs(neighbors - data).max()\n                 g_sig_digits = cbook._g_sig_digits(data, delta)\n             else:\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..12ed552f31 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1901,15 +1901,54 @@ class BoundaryNorm(Normalize):\n             ret = int(ret[0])  # assume python scalar\n         return ret\n \n-    def inverse(self, value):\n+\n+    def format_cursor_data(self, data):\n         \"\"\"\n-        Raises\n-        ------\n-        ValueError\n-            BoundaryNorm is not invertible, so calling this method will always\n-            raise an error\n+        Return a string representation of *data*.\n+\n+        .. note::\n+            This method is intended to be overridden by artist subclasses.\n+            As an end-user of Matplotlib you will most likely not call this\n+            method yourself.\n+\n+        The default implementation converts ints and floats and arrays of ints\n+        and floats into a comma-separated string enclosed in square brackets,\n+        unless the artist has an associated colorbar, in which case scalar\n+        values are formatted using the colorbar's formatter.\n+\n+        See Also\n+        --------\n+        get_cursor_data\n         \"\"\"\n-        raise ValueError(\"BoundaryNorm is not invertible\")\n+        try:\n+            if self.get_array() is not None:\n+                # Scalarmappable\n+                if np.ndim(data) == 0:\n+                    # If normed is True, we have a ScalarMappable, so we check\n+                    # if the incoming data is suitable for the normalization\n+                    normed = self.norm(data)\n+                    if np.isfinite(normed):\n+                        try:\n+                            # Try to calculate significant digits using inverse\n+                            value = self.norm.inverse(normed)\n+                            g_sig_digits = cbook._g_sig_digits(data, value)\n+                        except (ValueError, AttributeError):\n+                            # Fallback for non-invertible norms like BoundaryNorm\n+                            g_sig_digits = 3\n+                    else:\n+                        g_sig_digits = 3\n+                    # Apply the colorbar formatter, or default\n+                    if hasattr(self, 'colorbar') and self.colorbar is not None:\n+                        return self.colorbar.formatter.format_data_short(data)\n+                    else:\n+                        return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n+        except (TypeError, IndexError):\n+            pass\n+\n+        try:\n+            return \"[{}]\".format(cbook._auto_format_str(data))\n+        except (TypeError, IndexError):\n+            return str(data)\n \n \n class NoNorm(Normalize):\n",
    "variant_7": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..25f47db5c5 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1,23 +1,52 @@\n-from collections import namedtuple\n-import contextlib\n-from functools import wraps\n-import inspect\n-from inspect import Signature, Parameter\n-import logging\n-from numbers import Number\n-import re\n-import warnings\n \n-import numpy as np\n+def format_cursor_data(self, data):\n+    \"\"\"\n+    Return a string representation of *data*.\n \n-import matplotlib as mpl\n-from . import _api, cbook\n-from .cm import ScalarMappable\n-from .path import Path\n-from .transforms import (Bbox, IdentityTransform, Transform, TransformedBbox,\n-                         TransformedPatchPath, TransformedPath)\n+    .. note::\n+        This method is intended to be overridden by artist subclasses.\n+        As an end-user of Matplotlib you will most likely not call this\n+        method yourself.\n \n-_log = logging.getLogger(__name__)\n+    The default implementation converts ints and floats and arrays of ints\n+    and floats into a comma-separated string enclosed in square brackets,\n+    unless the artist has an associated colorbar, in which case scalar\n+    values are formatted using the colorbar's formatter.\n+\n+    See Also\n+    --------\n+    get_cursor_data\n+    \"\"\"\n+    try:\n+        from matplotlib.backend_bases import MouseEvent\n+        if isinstance(data, MouseEvent):\n+            # Deprecated, but we still need to handle it.\n+            data = data.ydata, data.xdata\n+    except ImportError:\n+        pass\n+\n+    data_str = '[{!r}]'.format(data)\n+    if self.get_array() is not None:\n+        # Append the scalar data value to the string\n+        if np.ndim(data) == 0:\n+            # If normed, add the normed data value in parentheses\n+            if self.norm is not None:\n+                normed = self.norm(data)\n+                if np.isfinite(normed):\n+                    # Calculate g_sig_digits\n+                    try:\n+                        g_sig_digits = 3\n+                        if self.norm.vmin is not None and self.norm.vmax is not None:\n+                            # Try to use inverse to calculate precision\n+                            delta = self.norm.inverse(self.norm.vmax) - self.norm.inverse(self.norm.vmin)\n+                            g_sig_digits = int(np.ceil(np.log10(self.get_array().size / delta)))\n+                    except (ValueError, AttributeError):\n+                        # Fallback for non-invertible norms like BoundaryNorm\n+                        g_sig_digits = 3\n+                    \n+                    data_str += ' ({normed:.{g_sig_digits}g})'.format(\n+                        normed=normed, g_sig_digits=g_sig_digits)\n+    return data_str\n \n \n def allow_rasterization(draw):\n@@ -1274,6 +1303,7 @@ class Artist:\n         \"\"\"\n         return None\n \n+\n     def format_cursor_data(self, data):\n         \"\"\"\n         Return a string representation of *data*.\n@@ -1303,9 +1333,63 @@ class Artist:\n                 return \"[]\"\n             normed = self.norm(data)\n             if np.isfinite(normed):\n-                # Midpoints of neighboring color intervals.\n-                neighbors = self.norm.inverse(\n-                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                # Calculate g_sig_digits for significant digits formatting\n+                try:\n+                    # Try to get the inverse for precise g_sig_digits calculation\n+                    inverse_normed = self.norm.inverse(normed)\n+                    # Only use data if it's different from inverse_normed,\n+                    # otherwise use the inverse for precision calculation\n+                    g_sig_digits = cbook._g_sig_digits(data, delta=1/n)\n+                except (ValueError, AttributeError):\n+                    # Fallback for non-invertible norms (like BoundaryNorm)\n+                    # or norms without inverse method\n+                    g_sig_digits = 3\n+            else:\n+                g_sig_digits = 3\n+            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n+        try:\n+            return \"[{}]\".format(cbook._strip_comment(repr(data)))\n+        except TypeError:\n+            return \"[{}]\".format(data)\n+            # This block logically belongs to ScalarMappable, but can't be\n+            # implemented in it because most ScalarMappable subclasses inherit\n+            # from Artist first and from ScalarMappable second, so\n+            # Artist.format_cursor_data would always have precedence over\n+            # ScalarMappable.format_cursor_data.\n+            n = self.cmap.N\n+            if np.ma.getmask(data):\n+                return \"[]\"\n+            normed = self.norm(data)\n+\n+        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n+            # This block logically belongs to ScalarMappable, but can't be\n+            # implemented in it because most ScalarMappable subclasses inherit\n+            # from Artist first and from ScalarMappable second, so\n+            # Artist.format_cursor_data would always have precedence over\n+            # ScalarMappable.format_cursor_data.\n+            n = self.cmap.N\n+            if np.ma.getmask(data):\n+                return \"[]\"\n+            normed = self.norm(data)\n+            if np.isfinite(normed):\n+                try:\n+                    # Midpoints of neighboring color intervals.\n+                    neighbors = self.norm.inverse(\n+                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                    delta = abs(neighbors - data).max()\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Norm is not invertible (e.g., BoundaryNorm)\n+                    g_sig_digits = 3\n+            else:\n+                g_sig_digits = 3  # Consistent with default below.\n+                    delta = abs(neighbors - data).max()\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Norm is not invertible (e.g., BoundaryNorm)\n+                    g_sig_digits = 3\n+            else:\n+                g_sig_digits = 3  # Consistent with default below.\n                 delta = abs(neighbors - data).max()\n                 g_sig_digits = cbook._g_sig_digits(data, delta)\n             else:\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..436c83426b 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1901,15 +1901,49 @@ class BoundaryNorm(Normalize):\n             ret = int(ret[0])  # assume python scalar\n         return ret\n \n-    def inverse(self, value):\n+\n+    def format_cursor_data(self, data):\n         \"\"\"\n-        Raises\n-        ------\n-        ValueError\n-            BoundaryNorm is not invertible, so calling this method will always\n-            raise an error\n+        Return a string representation of *data*.\n+\n+        .. note::\n+            This method is intended to be overridden by artist subclasses.\n+            As an end-user of Matplotlib you will most likely not call this\n+            method yourself.\n+\n+        The default implementation converts ints and floats and arrays of ints\n+        and floats into a comma-separated string enclosed in square brackets,\n+        unless the artist has an associated colorbar, in which case scalar\n+        values are formatted using the colorbar's formatter.\n+\n+        See Also\n+        --------\n+        get_cursor_data\n         \"\"\"\n-        raise ValueError(\"BoundaryNorm is not invertible\")\n+        try:\n+            if self.get_array() is not None:\n+                # Scalarmappable\n+                if np.ndim(data) == 0:\n+                    # Try to calculate precision based on inverse normalization\n+                    try:\n+                        normed = self.norm(data)\n+                        if np.isfinite(normed):\n+                            g_sig_digits = 3 - np.log10(\n+                                abs(self.norm.inverse(normed + self.norm.inverse(1e-3))\n+                                    - self.norm.inverse(normed)))\n+                        else:\n+                            g_sig_digits = 3\n+                    except (ValueError, AttributeError):\n+                        # Handle non-invertible norms (like BoundaryNorm) or other issues\n+                        g_sig_digits = 3\n+                    return f\"[{data:.{g_sig_digits:0.0f}g}]\"\n+        except (TypeError, IndexError):\n+            pass\n+\n+        try:\n+            return \"[\" + \", \".join(f\"{val:0.3g}\" for val in data.flat) + \"]\"\n+        except (AttributeError, TypeError):\n+            return f\"[{data!r}]\"\n \n \n class NoNorm(Normalize):\n",
    "variant_8": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..0216082ae5 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1,23 +1,52 @@\n-from collections import namedtuple\n-import contextlib\n-from functools import wraps\n-import inspect\n-from inspect import Signature, Parameter\n-import logging\n-from numbers import Number\n-import re\n-import warnings\n \n-import numpy as np\n-\n-import matplotlib as mpl\n-from . import _api, cbook\n-from .cm import ScalarMappable\n-from .path import Path\n-from .transforms import (Bbox, IdentityTransform, Transform, TransformedBbox,\n-                         TransformedPatchPath, TransformedPath)\n-\n-_log = logging.getLogger(__name__)\n+def format_cursor_data(self, data):\n+    \"\"\"\n+    Return a string representation of *data*.\n+\n+    .. note::\n+        This method is intended to be overridden by artist subclasses.\n+        As an end-user of Matplotlib you will most likely not call this\n+        method yourself.\n+\n+    The default implementation converts ints and floats and arrays of ints\n+    and floats into a comma-separated string enclosed in square brackets,\n+    unless the artist has an associated colormap, in which case scalar data\n+    is formatted using the colormap's normalization and colorbar ticklabels.\n+    See also `.ScalarMappable.format_cursor_data`.\n+    \"\"\"\n+    try:\n+        # Check if this is a scalar mappable with a colormap\n+        norm = getattr(self, 'norm', None)\n+        if norm is not None:\n+            # Attempt to use the norm's inverse for precision calculation\n+            try:\n+                normed = self.norm(data)\n+                if np.isfinite(normed):\n+                    # Calculate precision based on the inverse transform\n+                    inverse_data = self.norm.inverse(normed)\n+                    g_sig_digits = cbook._g_sig_digits(inverse_data, 0.001)\n+                else:\n+                    g_sig_digits = 3\n+            except (ValueError, AttributeError):\n+                # Handle non-invertible norms (like BoundaryNorm) or other issues\n+                g_sig_digits = 3\n+            \n+            # Try to get tick formatter from associated colorbar\n+            try:\n+                return self.cbar.formatter.format_data_short(data).strip()\n+            except AttributeError:\n+                pass\n+            \n+            # Fall back to default formatting with calculated precision\n+            try:\n+                return \"{:-#.{}g}\".format(data, g_sig_digits)\n+            except (ValueError, TypeError):\n+                return str(data)\n+    except AttributeError:\n+        pass\n+    \n+    # Default formatting for non-scalar mappable artists\n+    return cbook._recursive_format(data)\n \n \n def allow_rasterization(draw):\n@@ -1274,6 +1303,7 @@ class Artist:\n         \"\"\"\n         return None\n \n+\n     def format_cursor_data(self, data):\n         \"\"\"\n         Return a string representation of *data*.\n@@ -1292,6 +1322,46 @@ class Artist:\n         --------\n         get_cursor_data\n         \"\"\"\n+        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n+            # This block logically belongs to ScalarMappable, but can't be\n+            # implemented in it because most ScalarMappable subclasses inherit\n+            # from Artist first and from ScalarMappable second, so\n+            # Artist.format_cursor_data would always have precedence over\n+            # ScalarMappable.format_cursor_data.\n+            n = self.cmap.N\n+            if np.ma.getmask(data):\n+                return \"[]\"\n+            normed = self.norm(data)\n+            if np.isfinite(normed):\n+                # Calculate significant digits for formatting\n+                try:\n+                    # Try to use inverse to determine precision\n+                    inverse_normed = self.norm.inverse(normed)\n+                    g_sig_digits = max(\n+                        np.ceil(np.log10(np.abs(inverse_normed))).astype(int) + 1,\n+                        1) if inverse_normed != 0 else 1\n+                except ValueError:\n+                    # Handle non-invertible norms (like BoundaryNorm)\n+                    g_sig_digits = 3\n+                \n+                delta = normed / n * (n - 1)\n+                g_sig_digits = max(\n+                    np.ceil(np.log10(np.abs(delta))).astype(int) + 1,\n+                    1) if delta != 0 else 1\n+                return f\"[{data:.{g_sig_digits}g}]\"\n+            else:\n+                return \"[{:g}]\".format(data)\n+        return \"[\" + \", \".join(f\"{item:g}\" for item in np.atleast_1d(data)) + \"]\"\n+            # This block logically belongs to ScalarMappable, but can't be\n+            # implemented in it because most ScalarMappable subclasses inherit\n+            # from Artist first and from ScalarMappable second, so\n+            # Artist.format_cursor_data would always have precedence over\n+            # ScalarMappable.format_cursor_data.\n+            n = self.cmap.N\n+            if np.ma.getmask(data):\n+                return \"[]\"\n+            normed = self.norm(data)\n+\n         if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n             # This block logically belongs to ScalarMappable, but can't be\n             # implemented in it because most ScalarMappable subclasses inherit\n@@ -1304,8 +1374,25 @@ class Artist:\n             normed = self.norm(data)\n             if np.isfinite(normed):\n                 # Midpoints of neighboring color intervals.\n-                neighbors = self.norm.inverse(\n-                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                try:\n+                    neighbors = self.norm.inverse(\n+                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                    delta = abs(neighbors - data).max()\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Norm is not invertible (e.g., BoundaryNorm), use default\n+                    g_sig_digits = 3\n+            else:\n+                g_sig_digits = 3  # Consistent with default below.\n+            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n+                        (int(self.norm(data) * n) + np.array([0, 1])) / n)\n+                    delta = abs(neighbors - data).max()\n+                    g_sig_digits = cbook._g_sig_digits(data, delta)\n+                except ValueError:\n+                    # Norm is not invertible (e.g., BoundaryNorm)\n+                    g_sig_digits = 3\n+            else:\n+                g_sig_digits = 3  # Consistent with default below.\n                 delta = abs(neighbors - data).max()\n                 g_sig_digits = cbook._g_sig_digits(data, delta)\n             else:\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..dd40b0cff2 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1901,15 +1901,56 @@ class BoundaryNorm(Normalize):\n             ret = int(ret[0])  # assume python scalar\n         return ret\n \n-    def inverse(self, value):\n+\n+    def format_cursor_data(self, data):\n         \"\"\"\n-        Raises\n-        ------\n-        ValueError\n-            BoundaryNorm is not invertible, so calling this method will always\n-            raise an error\n+        Return a string representation of *data*.\n+\n+        .. note::\n+            This method is intended to be overridden by artist subclasses.\n+            As an end-user of Matplotlib you will most likely not call this\n+            method yourself.\n+\n+        The default implementation converts ints and floats and arrays of ints\n+        and floats into a comma-separated string enclosed in square brackets,\n+        unless the artist has an associated colorbar, in which case scalar\n+        values are formatted using the colorbar's formatter.\n+\n+        See Also\n+        --------\n+        get_cursor_data\n         \"\"\"\n-        raise ValueError(\"BoundaryNorm is not invertible\")\n+        try:\n+            from matplotlib import ticker\n+            # If this artist has an associated colorbar, don't bother trying\n+            # to use the default formatting (which doesn't account for the\n+            # colorbar's formatter or locator).\n+            for parent in self.axes.get_children():\n+                if hasattr(parent, 'colorbar') and parent.colorbar is not None:\n+                    # Colorbars have their own normalization, colormap; but\n+                    # the data of this artist.\n+                    return parent.colorbar.format_cursor_data(data)\n+        except (AttributeError, IndexError):\n+            pass\n+\n+        data_str = _format_approx(data, 6)\n+        if data is not np.ma.masked:\n+            try:\n+                normed = self.norm(data)\n+            except (TypeError, ValueError):\n+                pass\n+            else:\n+                if normed is not np.ma.masked:\n+                    # Attempt to calculate precision based on inverse norm\n+                    try:\n+                        inverse_data = self.norm.inverse(normed)\n+                        g_sig_digits = cbook._g_sig_digits(data, inverse_data)\n+                    except (ValueError, AttributeError):\n+                        # Use default precision for non-invertible norms like BoundaryNorm\n+                        g_sig_digits = 3\n+                    if g_sig_digits < 6:\n+                        data_str = _format_approx(data, g_sig_digits)\n+        return data_str\n \n \n class NoNorm(Normalize):\n"
  }
}