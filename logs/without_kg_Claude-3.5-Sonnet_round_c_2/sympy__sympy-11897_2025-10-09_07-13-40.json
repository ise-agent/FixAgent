{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/sympy/sympy/printing/latex.py lines 464-466)": "\n        elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:\n            # For exponential functions like exp(-x), keep the negative exponent form\n            # to maintain consistency with pretty printer\n            if hasattr(expr.base, 'name') and expr.base.name == 'exp':\n                if expr.base.is_Function:\n                    return self._print(expr.base, self._print(expr.exp))\n                else:\n                    base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n                    return r\"%s^{%s}\" % (base, self._print(expr.exp))\n            # For other cases like 1/x, use Mul printing\n            return self._print_Mul(expr)\n",
    "Location 2 (/root/hy/projects_2/sympy/sympy/printing/latex.py lines 359-360)": "\n        from sympy.simplify import fraction\n        numer, denom = expr.as_numer_denom()\n",
    "Location 3 (/root/hy/projects_2/sympy/sympy/printing/latex.py lines 402-430)": "\n            if self._settings['fold_short_frac'] \\\n                    and ldenom <= 2 and not \"^\" in sdenom:\n                # handle short fractions\n                if self._needs_mul_brackets(numer, last=False):\n                    tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n                else:\n                    tex += r\"%s / %s\" % (snumer, sdenom)\n            elif len(snumer.split()) > ratio*ldenom:\n                # handle long fractions\n                if self._needs_mul_brackets(numer, last=True):\n                    tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n                        % (sdenom, separator, snumer)\n                elif numer.is_Mul:\n                    # split a long numerator\n                    a = S.One\n                    b = S.One\n                    for x in numer.args:\n                        if self._needs_mul_brackets(x, last=False) or \\\n                                len(convert(a*x).split()) > ratio*ldenom or \\\n                                (b.is_commutative is x.is_commutative is False):\n                            b *= x\n                        else:\n                            a *= x\n                    if self._needs_mul_brackets(b, last=True):\n                        tex += r\"\\frac{%s}{%s}%s\\left(%s\\right)\" \\\n                            % (convert(a), sdenom, separator, convert(b))\n                    else:\n                        tex += r\"\\frac{%s}{%s}%s%s\" \\\n                            % (convert(a), sdenom, separator, convert(b))\n",
    "Location 4 (/root/hy/projects_2/sympy/sympy/simplify/radsimp.py lines 960-966)": "\n                elif exact:\n                    # Be more conservative with exact=True to maintain consistency\n                    # Don't convert exp(-x) to fraction form to match pretty printer\n                    if ex.is_constant() and not (term.func is exp):\n                        denom.append(Pow(b, -ex))\n                    else:\n                        numer.append(term)\n                else:\n                    denom.append(Pow(b, -ex))\n",
    "Location 5 (/root/hy/projects_2/sympy/sympy/printing/latex.py lines 393-401)": "\n        if denom is S.One:\n            # use the original expression here, since fraction() may have\n            # altered it when producing numer and denom\n            tex += convert(expr)\n        else:\n            snumer = convert(numer)\n            sdenom = convert(denom)\n            ldenom = len(sdenom.split())\n            ratio = self._settings['long_frac_ratio']\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/sympy/sympy/printing/latex.py lines 464-466)": [
      "\n        elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:\n            # For exponential functions with negative exponents, keep them as powers\n            # to maintain consistency with pretty printer (e.g., exp(-x) not 1/exp(x))\n            if hasattr(expr.base, 'func') and str(expr.base.func) == 'exp':\n                base = self.parenthesize(expr.base.args[0], PRECEDENCE['Pow'])\n                return r\"e^{-%s}\" % base\n            # For other cases like x**(-1), convert to fraction form\n            return self._print_Mul(expr)\n",
      "\n        elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:\n            # For exponential functions like exp(-x), keep them in exponential form\n            # to maintain consistency with pretty printer\n            if hasattr(expr.base, 'name') and expr.base.name == 'exp':\n                if expr.base.is_Function:\n                    return self._print(expr.base, self._print(expr.exp))\n                else:\n                    base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n                    return r\"%s^{%s}\" % (base, self._print(expr.exp))\n            # For other cases like 1/x, use fraction form\n            return self._print_Mul(expr)\n",
      "\n        elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:\n            # For exponential functions with negative exponents, keep the original form\n            # to maintain consistency with pretty printer\n            if expr.base == S.Exp1:  # e^(-x) should stay as e^(-x), not 1/e^x\n                if expr.base.is_Function:\n                    return self._print(expr.base, self._print(expr.exp))\n                else:\n                    base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n                    return r\"%s^{%s}\" % (base, self._print(expr.exp))\n            # For other cases like x^(-1), still use fraction form\n            return self._print_Mul(expr)\n",
      "\n        elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:\n            # Handle negative rational exponents directly instead of delegating to _print_Mul\n            # to maintain consistency with pretty printer\n            if expr.exp == -1:\n                # For simple x^(-1), use fraction format\n                return self._print_Mul(expr)\n            else:\n                # For other negative exponents like exp(-x), keep exponential form\n                base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n                exp = self._print(expr.exp)\n                if expr.base.is_Function:\n                    return self._print(expr.base, exp)\n                else:\n                    return r\"%s^{%s}\" % (base, exp)\n",
      "\n        elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:\n            # Handle negative rational exponents directly instead of delegating to _print_Mul\n            # to maintain consistency with pretty printer\n            if expr.exp == -1:\n                # For simple cases like x^(-1), use fraction format\n                return self._print_Mul(expr)\n            else:\n                # For other negative exponents, keep exponential form\n                base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n                exp = self._print(expr.exp)\n                if expr.base.is_Function:\n                    return self._print(expr.base, exp)\n                else:\n                    return r\"%s^{%s}\" % (base, exp)\n",
      "\n        elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:\n            # Handle negative rational exponents directly instead of delegating to _print_Mul\n            # to maintain consistency with pretty printer\n            if expr.exp == -1:\n                # For x**-1, format as \\frac{1}{x}\n                return r\"\\frac{1}{%s}\" % self.parenthesize(expr.base, PRECEDENCE['Pow'])\n            else:\n                # For other negative rational exponents, keep the exponential form\n                # e.g., exp(-x) stays as e^{-x} instead of becoming \\frac{1}{e^{x}}\n                base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n                exp = self._print(expr.exp)\n                if expr.base.is_Function:\n                    return self._print(expr.base, exp)\n                else:\n                    return r\"%s^{%s}\" % (base, exp)\n",
      "\n        elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:\n            # Handle negative exponents consistently with pretty printer\n            # Don't delegate to _print_Mul for exponential functions to avoid unwanted fraction conversion\n            if expr.base.func.__name__ == 'exp':\n                # For exp(-x), print as e^{-x} to match pretty printer's â„¯^(-x)\n                base = self.parenthesize(expr.base.args[0], PRECEDENCE['Mul'])\n                return r\"e^{-%s}\" % base\n            else:\n                # For other cases like x^(-1), use fraction form\n                return self._print_Mul(expr)\n",
      "\n        elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:\n            # For expressions like exp(-x), keep the exponential form instead of converting to fraction\n            # This maintains consistency with pretty printer output\n            if expr.base.func.__name__ == 'exp':\n                base = self.parenthesize(expr.base.args[0], PRECEDENCE['Mul'])\n                return r\"e^{%s \\cdot %s}\" % (self._print(expr.exp), base)\n            # For other cases like x**(-1), use fraction form\n            return self._print_Mul(expr)\n"
    ],
    "Location 2 (/root/hy/projects_2/sympy/sympy/printing/latex.py lines 359-360)": [
      "\n        include_parens = False\n        if _coeff_isneg(expr):\n            expr = -expr\n            tex = \"- \"\n            if expr.is_Add:\n                tex += \"(\"\n                include_parens = True\n        else:\n            tex = \"\"\n\n        # Use as_numer_denom() instead of fraction() to preserve structure\n        numer, denom = expr.as_numer_denom()\n",
      "\n        # Use a more conservative approach that preserves expression structure\n        # instead of fraction() which can restructure expressions unnecessarily\n        numer, denom = expr.as_numer_denom()\n",
      "\n        from sympy.simplify import fraction\n        numer, denom = expr.as_numer_denom()\n",
      "\n        from sympy.simplify import fraction\n        numer, denom = expr.as_numer_denom()\n",
      "\n        from sympy.simplify import fraction\n        numer, denom = expr.as_numer_denom()\n",
      "\n        include_parens = False\n        if _coeff_isneg(expr):\n            expr = -expr\n            tex = \"- \"\n            if expr.is_Add:\n                tex += \"(\"\n                include_parens = True\n        else:\n            tex = \"\"\n\n        # Use as_numer_denom() instead of fraction() to preserve structure\n        numer, denom = expr.as_numer_denom()\n",
      "\n        include_parens = False\n        if _coeff_isneg(expr):\n            expr = -expr\n            tex = \"- \"\n            if expr.is_Add:\n                tex += \"(\"\n                include_parens = True\n        else:\n            tex = \"\"\n\n        # Use as_numer_denom() instead of fraction() to preserve structure\n        numer, denom = expr.as_numer_denom()\n",
      "\n        include_parens = False\n        if _coeff_isneg(expr):\n            expr = -expr\n            tex = \"- \"\n            if expr.is_Add:\n                tex += \"(\"\n                include_parens = True\n        else:\n            tex = \"\"\n\n        # Use as_numer_denom() instead of fraction() to preserve structure\n        numer, denom = expr.as_numer_denom()\n"
    ],
    "Location 3 (/root/hy/projects_2/sympy/sympy/printing/latex.py lines 402-430)": [
      "\n            if self._settings['fold_short_frac'] \\\n                    and ldenom <= 2 and not \"^\" in sdenom:\n                # handle short fractions\n                if self._needs_mul_brackets(numer, last=False):\n                    tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n                else:\n                    tex += r\"%s / %s\" % (snumer, sdenom)\n            elif len(snumer.split()) > ratio*ldenom:\n                # handle long fractions\n                if self._needs_mul_brackets(numer, last=True):\n                    tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n                        % (sdenom, separator, snumer)\n                elif numer.is_Mul:\n                    # split a long numerator\n                    a = S.One\n                    b = S.One\n                    for x in numer.args:\n                        if self._needs_mul_brackets(x, last=False) or \\\n                                len(convert(a*x).split()) > ratio*ldenom or \\\n                                (b.is_commutative is x.is_commutative is False):\n                            b *= x\n                        else:\n                            a *= x\n                    if self._needs_mul_brackets(b, last=True):\n                        tex += r\"\\frac{%s}{%s}%s\\left(%s\\right)\" \\\n                            % (convert(a), sdenom, separator, convert(b))\n                    else:\n                        tex += r\"\\frac{%s}{%s}%s%s\" \\\n                            % (convert(a), sdenom, separator, convert(b))\n",
      "\n            if self._settings['fold_short_frac'] \\\n                    and ldenom <= 2 and not \"^\" in sdenom:\n                # handle short fractions\n                if self._needs_mul_brackets(numer, last=False):\n                    tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n                else:\n                    tex += r\"%s / %s\" % (snumer, sdenom)\n            elif len(snumer.split()) > ratio*ldenom:\n                # handle long fractions\n                if self._needs_mul_brackets(numer, last=True):\n                    tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n                        % (sdenom, separator, snumer)\n                elif numer.is_Mul:\n                    # split a long numerator\n                    a = S.One\n                    b = S.One\n                    for x in numer.args:\n                        if self._needs_mul_brackets(x, last=False) or \\\n                                len(convert(a*x).split()) > ratio*ldenom or \\\n                                (b.is_commutative is x.is_commutative is False):\n                            b *= x\n                        else:\n                            a *= x\n                    if self._needs_mul_brackets(b, last=True):\n                        tex += r\"\\frac{%s}{%s}%s\\left(%s\\right)\" \\\n                            % (convert(a), sdenom, separator, convert(b))\n                    else:\n                        tex += r\"\\frac{%s}{%s}%s%s\" \\\n                            % (convert(a), sdenom, separator, convert(b))\n",
      "\n            if self._settings['fold_short_frac'] \\\n                    and ldenom <= 2 and not \"^\" in sdenom:\n                # handle short fractions\n                if self._needs_mul_brackets(numer, last=False):\n                    tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n                else:\n                    tex += r\"%s / %s\" % (snumer, sdenom)\n            elif len(snumer.split()) > ratio*ldenom:\n                # handle long fractions\n                if self._needs_mul_brackets(numer, last=True):\n                    tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n                        % (sdenom, separator, snumer)\n                elif numer.is_Mul:\n                    # split a long numerator\n                    a = S.One\n                    b = S.One\n                    for x in numer.args:\n                        if self._needs_mul_brackets(x, last=False) or \\\n                                len(convert(a*x).split()) > ratio*ldenom or \\\n                                (b.is_commutative is x.is_commutative is False):\n                            b *= x\n                        else:\n                            a *= x\n                    if self._needs_mul_brackets(b, last=True):\n                        tex += r\"\\frac{%s}{%s}%s\\left(%s\\right)\" \\\n                            % (convert(a), sdenom, separator, convert(b))\n                    else:\n                        tex += r\"\\frac{%s}{%s}%s%s\" \\\n                            % (convert(a), sdenom, separator, convert(b))\n",
      "\n            if self._settings['fold_short_frac'] \\\n                    and ldenom <= 2 and not \"^\" in sdenom:\n                # handle short fractions\n                if self._needs_mul_brackets(numer, last=False):\n                    tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n                else:\n                    tex += r\"%s / %s\" % (snumer, sdenom)\n            elif len(snumer.split()) > ratio*ldenom:\n                # handle long fractions\n                if self._needs_mul_brackets(numer, last=True):\n                    tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n                        % (sdenom, separator, snumer)\n                elif numer.is_Mul:\n                    # split a long numerator\n                    a = S.One\n                    b = S.One\n                    for x in numer.args:\n                        if self._needs_mul_brackets(x, last=False) or \\\n                                len(convert(a*x).split()) > ratio*ldenom or \\\n                                (b.is_commutative is x.is_commutative is False):\n                            b *= x\n                        else:\n                            a *= x\n                    if self._needs_mul_brackets(b, last=True):\n                        tex += r\"\\frac{%s}{%s}%s\\left(%s\\right)\" \\\n                            % (convert(a), sdenom, separator, convert(b))\n                    else:\n                        tex += r\"\\frac{%s}{%s}%s%s\" \\\n                            % (convert(a), sdenom, separator, convert(b))\n",
      "\n            if self._settings['fold_short_frac'] \\\n                    and ldenom <= 2 and not \"^\" in sdenom:\n                # handle short fractions\n                if self._needs_mul_brackets(numer, last=False):\n                    tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n                else:\n                    tex += r\"%s / %s\" % (snumer, sdenom)\n            elif len(snumer.split()) > ratio*ldenom:\n                # handle long fractions\n                if self._needs_mul_brackets(numer, last=True):\n                    tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n                        % (sdenom, separator, snumer)\n                elif numer.is_Mul:\n                    # split a long numerator\n                    a = S.One\n                    b = S.One\n                    for x in numer.args:\n                        if self._needs_mul_brackets(x, last=False) or \\\n                                len(convert(a*x).split()) > ratio*ldenom or \\\n                                (b.is_commutative is x.is_commutative is False):\n                            b *= x\n                        else:\n                            a *= x\n                    if self._needs_mul_brackets(b, last=True):\n                        tex += r\"\\frac{%s}{%s}%s\\left(%s\\right)\" \\\n                            % (convert(a), sdenom, separator, convert(b))\n                    else:\n                        tex += r\"\\frac{%s}{%s}%s%s\" \\\n                            % (convert(a), sdenom, separator, convert(b))\n",
      "\n            if self._settings['fold_short_frac'] \\\n                    and ldenom <= 2 and not \"^\" in sdenom:\n                # handle short fractions\n                if self._needs_mul_brackets(numer, last=False):\n                    tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n                else:\n                    tex += r\"%s / %s\" % (snumer, sdenom)\n            elif len(snumer.split()) > ratio*ldenom:\n                # handle long fractions\n                if self._needs_mul_brackets(numer, last=True):\n                    tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n                        % (sdenom, separator, snumer)\n                elif numer.is_Mul:\n                    # split a long numerator\n                    a = S.One\n                    b = S.One\n                    for x in numer.args:\n                        if self._needs_mul_brackets(x, last=False) or \\\n                                len(convert(a*x).split()) > ratio*ldenom or \\\n                                (b.is_commutative is x.is_commutative is False):\n                            b *= x\n                        else:\n                            a *= x\n                    if self._needs_mul_brackets(b, last=True):\n                        tex += r\"\\frac{%s}{%s}%s\\left(%s\\right)\" \\\n                            % (convert(a), sdenom, separator, convert(b))\n                    else:\n                        tex += r\"\\frac{%s}{%s}%s%s\" \\\n                            % (convert(a), sdenom, separator, convert(b))\n",
      "\n            if self._settings['fold_short_frac'] \\\n                    and ldenom <= 2 and not \"^\" in sdenom:\n                # handle short fractions\n                if self._needs_mul_brackets(numer, last=False):\n                    tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n                else:\n                    tex += r\"%s / %s\" % (snumer, sdenom)\n            elif len(snumer.split()) > ratio*ldenom:\n                # handle long fractions\n                if self._needs_mul_brackets(numer, last=True):\n                    tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n                        % (sdenom, separator, snumer)\n                elif numer.is_Mul:\n                    # split a long numerator\n                    a = S.One\n                    b = S.One\n                    for x in numer.args:\n                        if self._needs_mul_brackets(x, last=False) or \\\n                                len(convert(a*x).split()) > ratio*ldenom or \\\n                                (b.is_commutative is x.is_commutative is False):\n                            b *= x\n                        else:\n                            a *= x\n                    if self._needs_mul_brackets(b, last=True):\n                        tex += r\"\\frac{%s}{%s}%s\\left(%s\\right)\" \\\n                            % (convert(a), sdenom, separator, convert(b))\n                    else:\n                        tex += r\"\\frac{%s}{%s}%s%s\" \\\n                            % (convert(a), sdenom, separator, convert(b))\n",
      "\n            if self._settings['fold_short_frac'] \\\n                    and ldenom <= 2 and not \"^\" in sdenom:\n                # handle short fractions\n                if self._needs_mul_brackets(numer, last=False):\n                    tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n                else:\n                    tex += r\"%s / %s\" % (snumer, sdenom)\n            elif len(snumer.split()) > ratio*ldenom:\n                # handle long fractions\n                if self._needs_mul_brackets(numer, last=True):\n                    tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n                        % (sdenom, separator, snumer)\n                elif numer.is_Mul:\n                    # split a long numerator\n                    a = S.One\n                    b = S.One\n                    for x in numer.args:\n                        if self._needs_mul_brackets(x, last=False) or \\\n                                len(convert(a*x).split()) > ratio*ldenom or \\\n                                (b.is_commutative is x.is_commutative is False):\n                            b *= x\n                        else:\n                            a *= x\n                    if self._needs_mul_brackets(b, last=True):\n                        tex += r\"\\frac{%s}{%s}%s\\left(%s\\right)\" \\\n                            % (convert(a), sdenom, separator, convert(b))\n                    else:\n                        tex += r\"\\frac{%s}{%s}%s%s\" \\\n                            % (convert(a), sdenom, separator, convert(b))\n                else:\n                    tex += r\"\\frac{1}{%s}%s%s\" % (sdenom, separator, snumer)\n            else:\n                # Preserve parentheses for Add expressions in denominators\n                if denom.is_Add and len(denom.args) > 1:\n                    # Check if original expression structure should be preserved\n                    original_denom_str = convert(denom)\n                    if not original_denom_str.startswith(r'\\left('):\n                        sdenom = r'\\left(%s\\right)' % sdenom\n                tex += r\"\\frac{%s}{%s}\" % (snumer, sdenom)\n"
    ],
    "Location 4 (/root/hy/projects_2/sympy/sympy/simplify/radsimp.py lines 960-966)": [
      "\n                elif exact:\n                    # For exponential functions with negative exponents, keep in numerator\n                    # to maintain consistency with pretty printer\n                    if b.func is exp:\n                        numer.append(term)\n                    elif ex.is_constant():\n                        denom.append(Pow(b, -ex))\n                    else:\n                        numer.append(term)\n                else:\n                    denom.append(Pow(b, -ex))\n",
      "\n                elif exact:\n                    # For exact mode, be more conservative with negative exponents\n                    # to maintain consistency with pretty printer\n                    if ex.is_constant() and not (term.func is exp):\n                        denom.append(Pow(b, -ex))\n                    else:\n                        numer.append(term)\n                else:\n                    denom.append(Pow(b, -ex))\n",
      "\n                elif exact:\n                    # For exact mode, be more conservative with negative exponents\n                    # to maintain consistency with pretty printer\n                    if ex.is_constant() and not (term.func is exp):\n                        denom.append(Pow(b, -ex))\n                    else:\n                        numer.append(term)\n                else:\n                    denom.append(Pow(b, -ex))\n",
      "\n                elif exact:\n                    # For exponential functions with negative exponents, keep in original form\n                    # to maintain consistency with pretty printer\n                    if b.func is exp:\n                        numer.append(term)\n                    elif ex.is_constant():\n                        denom.append(Pow(b, -ex))\n                    else:\n                        numer.append(term)\n                else:\n                    denom.append(Pow(b, -ex))\n",
      "\n                elif exact:\n                    # For exact mode, be more conservative about moving terms to denominator\n                    # to maintain consistency with pretty printer\n                    if ex.is_constant() and not (term.func is exp):\n                        denom.append(Pow(b, -ex))\n                    else:\n                        numer.append(term)\n                else:\n                    denom.append(Pow(b, -ex))\n",
      "\n                elif exact:\n                    # For exact mode, be more conservative with exponential functions\n                    # to maintain consistency with pretty printer\n                    if b.func is exp:\n                        numer.append(term)\n                    elif ex.is_constant():\n                        denom.append(Pow(b, -ex))\n                    else:\n                        numer.append(term)\n                else:\n                    denom.append(Pow(b, -ex))\n",
      "\n            elif exact:\n                # For exact mode, be more conservative about converting to fractions\n                # especially for exponential functions to maintain consistency with pretty printer\n                if b.func is exp:\n                    # Keep exp(-x) in numerator as is, don't convert to 1/exp(x)\n                    numer.append(term)\n                elif ex.is_constant():\n                    denom.append(Pow(b, -ex))\n                else:\n                    numer.append(term)\n            else:\n                denom.append(Pow(b, -ex))\n",
      "\n                elif exact:\n                    # For exact mode, be more conservative about moving terms to denominator\n                    # to maintain consistency with pretty printer output\n                    if ex.is_constant() and not (term.func is exp):\n                        denom.append(Pow(b, -ex))\n                    else:\n                        numer.append(term)\n                else:\n                    denom.append(Pow(b, -ex))\n"
    ],
    "Location 5 (/root/hy/projects_2/sympy/sympy/printing/latex.py lines 393-401)": [
      "\n        if denom is S.One:\n            # use the original expression here, since fraction() may have\n            # altered it when producing numer and denom\n            tex += convert(expr)\n        else:\n            snumer = convert(numer)\n            sdenom = convert(denom)\n            ldenom = len(sdenom.split())\n            ratio = self._settings['long_frac_ratio']\n",
      "\n        if denom is S.One:\n            # use the original expression here, since fraction() may have\n            # altered it when producing numer and denom\n            tex += convert(expr)\n        else:\n            snumer = convert(numer)\n            sdenom = convert(denom)\n            ldenom = len(sdenom.split())\n            ratio = self._settings['long_frac_ratio']\n",
      "\n        if denom is S.One:\n            # use the original expression here, since fraction() may have\n            # altered it when producing numer and denom\n            tex += convert(expr)\n        else:\n            snumer = convert(numer)\n            sdenom = convert(denom)\n            ldenom = len(sdenom.split())\n            ratio = self._settings['long_frac_ratio']\n",
      "\n        if denom is S.One:\n            # use the original expression here, since fraction() may have\n            # altered it when producing numer and denom\n            tex += convert(expr)\n        else:\n            snumer = convert(numer)\n            sdenom = convert(denom)\n            ldenom = len(sdenom.split())\n            ratio = self._settings['long_frac_ratio']\n",
      "\n        if denom is S.One:\n            # use the original expression here, since fraction() may have\n            # altered it when producing numer and denom\n            tex += convert(expr)\n        else:\n            snumer = convert(numer)\n            sdenom = convert(denom)\n            ldenom = len(sdenom.split())\n            ratio = self._settings['long_frac_ratio']\n",
      "\n        if denom is S.One:\n            # use the original expression here, since fraction() may have\n            # altered it when producing numer and denom\n            tex += convert(expr)\n        else:\n            snumer = convert(numer)\n            sdenom = convert(denom)\n            ldenom = len(sdenom.split())\n            ratio = self._settings['long_frac_ratio']\n",
      "\n        if denom is S.One:\n            # use the original expression here, since fraction() may have\n            # altered it when producing numer and denom\n            tex += convert(expr)\n        else:\n            snumer = convert(numer)\n            sdenom = convert(denom)\n            ldenom = len(sdenom.split())\n            ratio = self._settings['long_frac_ratio']\n",
      "\n        if denom is S.One:\n            # use the original expression here, since fraction() may have\n            # altered it when producing numer and denom\n            tex += convert(expr)\n        else:\n            snumer = convert(numer)\n            sdenom = convert(denom)\n            ldenom = len(sdenom.split())\n            ratio = self._settings['long_frac_ratio']\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex 1edc712358..4466fcae7e 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -356,8 +356,9 @@ def _print_Mul(self, expr):\n         else:\n             tex = \"\"\n \n-        from sympy.simplify import fraction\n-        numer, denom = fraction(expr, exact=True)\n+\n+        # Use as_numer_denom() instead of fraction() to preserve structure better\n+        numer, denom = expr.as_numer_denom()\n         separator = self._settings['mul_symbol_latex']\n         numbersep = self._settings['mul_symbol_latex_numbers']\n \n@@ -390,6 +391,7 @@ def convert(expr):\n                     last_term_tex = term_tex\n                 return _tex\n \n+\n         if denom is S.One:\n             # use the original expression here, since fraction() may have\n             # altered it when producing numer and denom\n@@ -399,6 +401,7 @@ def convert(expr):\n             sdenom = convert(denom)\n             ldenom = len(sdenom.split())\n             ratio = self._settings['long_frac_ratio']\n+\n             if self._settings['fold_short_frac'] \\\n                     and ldenom <= 2 and not \"^\" in sdenom:\n                 # handle short fractions\n@@ -461,9 +464,17 @@ def _print_Pow(self, expr):\n             if expr.base.is_Function:\n                 return self._print(expr.base, \"%s/%s\" % (p, q))\n             return r\"%s^{%s/%s}\" % (base, p, q)\n+\n         elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:\n-            # Things like 1/x\n-            return self._print_Mul(expr)\n+            # Handle negative exponents directly instead of delegating to _print_Mul\n+            # This preserves expressions like exp(-x) as e^{-x} instead of 1/e^x\n+            if expr.base.func is exp:\n+                # For exponential functions, keep the negative exponent format\n+                base = self.parenthesize(expr.base.args[0], PRECEDENCE['Mul'])\n+                return r\"e^{- %s}\" % base\n+            else:\n+                # For other cases like x^(-1), still use fraction format\n+                return self._print_Mul(expr)\n         else:\n             if expr.base.is_Function:\n                 return self._print(expr.base, self._print(expr.exp))\ndiff --git a/sympy/simplify/radsimp.py b/sympy/simplify/radsimp.py\nindex dca048918b..cbbfcd850f 100644\n--- a/sympy/simplify/radsimp.py\n+++ b/sympy/simplify/radsimp.py\n@@ -957,9 +957,15 @@ def fraction(expr, exact=False):\n             if ex.is_negative:\n                 if ex is S.NegativeOne:\n                     denom.append(b)\n+\n                 elif exact:\n                     if ex.is_constant():\n-                        denom.append(Pow(b, -ex))\n+                        # For exponential functions with negative exponents, preserve them in numerator\n+                        # when exact=True to maintain consistency with pretty printer\n+                        if b.func is exp:\n+                            numer.append(term)\n+                        else:\n+                            denom.append(Pow(b, -ex))\n                     else:\n                         numer.append(term)\n                 else:\n",
    "variant_0": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex 1edc712358..ec058cd8ab 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -356,8 +356,9 @@ def _print_Mul(self, expr):\n         else:\n             tex = \"\"\n \n+\n         from sympy.simplify import fraction\n-        numer, denom = fraction(expr, exact=True)\n+        numer, denom = expr.as_numer_denom()\n         separator = self._settings['mul_symbol_latex']\n         numbersep = self._settings['mul_symbol_latex_numbers']\n \n@@ -390,6 +391,7 @@ def convert(expr):\n                     last_term_tex = term_tex\n                 return _tex\n \n+\n         if denom is S.One:\n             # use the original expression here, since fraction() may have\n             # altered it when producing numer and denom\n@@ -399,6 +401,7 @@ def convert(expr):\n             sdenom = convert(denom)\n             ldenom = len(sdenom.split())\n             ratio = self._settings['long_frac_ratio']\n+\n             if self._settings['fold_short_frac'] \\\n                     and ldenom <= 2 and not \"^\" in sdenom:\n                 # handle short fractions\n@@ -461,8 +464,17 @@ def _print_Pow(self, expr):\n             if expr.base.is_Function:\n                 return self._print(expr.base, \"%s/%s\" % (p, q))\n             return r\"%s^{%s/%s}\" % (base, p, q)\n+\n         elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:\n-            # Things like 1/x\n+            # For exponential functions like exp(-x), keep the negative exponent form\n+            # to maintain consistency with pretty printer\n+            if hasattr(expr.base, 'name') and expr.base.name == 'exp':\n+                if expr.base.is_Function:\n+                    return self._print(expr.base, self._print(expr.exp))\n+                else:\n+                    base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n+                    return r\"%s^{%s}\" % (base, self._print(expr.exp))\n+            # For other cases like 1/x, use Mul printing\n             return self._print_Mul(expr)\n         else:\n             if expr.base.is_Function:\ndiff --git a/sympy/simplify/radsimp.py b/sympy/simplify/radsimp.py\nindex dca048918b..9412baeb85 100644\n--- a/sympy/simplify/radsimp.py\n+++ b/sympy/simplify/radsimp.py\n@@ -957,8 +957,11 @@ def fraction(expr, exact=False):\n             if ex.is_negative:\n                 if ex is S.NegativeOne:\n                     denom.append(b)\n+\n                 elif exact:\n-                    if ex.is_constant():\n+                    # Be more conservative with exact=True to maintain consistency\n+                    # Don't convert exp(-x) to fraction form to match pretty printer\n+                    if ex.is_constant() and not (term.func is exp):\n                         denom.append(Pow(b, -ex))\n                     else:\n                         numer.append(term)\n",
    "variant_1": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex 1edc712358..f025f31b19 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -356,8 +356,19 @@ def _print_Mul(self, expr):\n         else:\n             tex = \"\"\n \n-        from sympy.simplify import fraction\n-        numer, denom = fraction(expr, exact=True)\n+\n+        include_parens = False\n+        if _coeff_isneg(expr):\n+            expr = -expr\n+            tex = \"- \"\n+            if expr.is_Add:\n+                tex += \"(\"\n+                include_parens = True\n+        else:\n+            tex = \"\"\n+\n+        # Use as_numer_denom() instead of fraction() to preserve structure\n+        numer, denom = expr.as_numer_denom()\n         separator = self._settings['mul_symbol_latex']\n         numbersep = self._settings['mul_symbol_latex_numbers']\n \n@@ -390,6 +401,7 @@ def convert(expr):\n                     last_term_tex = term_tex\n                 return _tex\n \n+\n         if denom is S.One:\n             # use the original expression here, since fraction() may have\n             # altered it when producing numer and denom\n@@ -399,6 +411,7 @@ def convert(expr):\n             sdenom = convert(denom)\n             ldenom = len(sdenom.split())\n             ratio = self._settings['long_frac_ratio']\n+\n             if self._settings['fold_short_frac'] \\\n                     and ldenom <= 2 and not \"^\" in sdenom:\n                 # handle short fractions\n@@ -461,8 +474,14 @@ def _print_Pow(self, expr):\n             if expr.base.is_Function:\n                 return self._print(expr.base, \"%s/%s\" % (p, q))\n             return r\"%s^{%s/%s}\" % (base, p, q)\n+\n         elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:\n-            # Things like 1/x\n+            # For exponential functions with negative exponents, keep them as powers\n+            # to maintain consistency with pretty printer (e.g., exp(-x) not 1/exp(x))\n+            if hasattr(expr.base, 'func') and str(expr.base.func) == 'exp':\n+                base = self.parenthesize(expr.base.args[0], PRECEDENCE['Pow'])\n+                return r\"e^{-%s}\" % base\n+            # For other cases like x**(-1), convert to fraction form\n             return self._print_Mul(expr)\n         else:\n             if expr.base.is_Function:\ndiff --git a/sympy/simplify/radsimp.py b/sympy/simplify/radsimp.py\nindex dca048918b..fcdff7b8d9 100644\n--- a/sympy/simplify/radsimp.py\n+++ b/sympy/simplify/radsimp.py\n@@ -957,8 +957,13 @@ def fraction(expr, exact=False):\n             if ex.is_negative:\n                 if ex is S.NegativeOne:\n                     denom.append(b)\n+\n                 elif exact:\n-                    if ex.is_constant():\n+                    # For exponential functions with negative exponents, keep in numerator\n+                    # to maintain consistency with pretty printer\n+                    if b.func is exp:\n+                        numer.append(term)\n+                    elif ex.is_constant():\n                         denom.append(Pow(b, -ex))\n                     else:\n                         numer.append(term)\n",
    "variant_2": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex 1edc712358..5960475adb 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -356,8 +356,10 @@ def _print_Mul(self, expr):\n         else:\n             tex = \"\"\n \n-        from sympy.simplify import fraction\n-        numer, denom = fraction(expr, exact=True)\n+\n+        # Use a more conservative approach that preserves expression structure\n+        # instead of fraction() which can restructure expressions unnecessarily\n+        numer, denom = expr.as_numer_denom()\n         separator = self._settings['mul_symbol_latex']\n         numbersep = self._settings['mul_symbol_latex_numbers']\n \n@@ -390,6 +392,7 @@ def convert(expr):\n                     last_term_tex = term_tex\n                 return _tex\n \n+\n         if denom is S.One:\n             # use the original expression here, since fraction() may have\n             # altered it when producing numer and denom\n@@ -399,6 +402,7 @@ def convert(expr):\n             sdenom = convert(denom)\n             ldenom = len(sdenom.split())\n             ratio = self._settings['long_frac_ratio']\n+\n             if self._settings['fold_short_frac'] \\\n                     and ldenom <= 2 and not \"^\" in sdenom:\n                 # handle short fractions\n@@ -461,8 +465,17 @@ def _print_Pow(self, expr):\n             if expr.base.is_Function:\n                 return self._print(expr.base, \"%s/%s\" % (p, q))\n             return r\"%s^{%s/%s}\" % (base, p, q)\n+\n         elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:\n-            # Things like 1/x\n+            # For exponential functions like exp(-x), keep them in exponential form\n+            # to maintain consistency with pretty printer\n+            if hasattr(expr.base, 'name') and expr.base.name == 'exp':\n+                if expr.base.is_Function:\n+                    return self._print(expr.base, self._print(expr.exp))\n+                else:\n+                    base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n+                    return r\"%s^{%s}\" % (base, self._print(expr.exp))\n+            # For other cases like 1/x, use fraction form\n             return self._print_Mul(expr)\n         else:\n             if expr.base.is_Function:\ndiff --git a/sympy/simplify/radsimp.py b/sympy/simplify/radsimp.py\nindex dca048918b..f2072fad05 100644\n--- a/sympy/simplify/radsimp.py\n+++ b/sympy/simplify/radsimp.py\n@@ -957,8 +957,11 @@ def fraction(expr, exact=False):\n             if ex.is_negative:\n                 if ex is S.NegativeOne:\n                     denom.append(b)\n+\n                 elif exact:\n-                    if ex.is_constant():\n+                    # For exact mode, be more conservative with negative exponents\n+                    # to maintain consistency with pretty printer\n+                    if ex.is_constant() and not (term.func is exp):\n                         denom.append(Pow(b, -ex))\n                     else:\n                         numer.append(term)\n",
    "variant_3": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex 1edc712358..0ee3161a24 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -356,8 +356,9 @@ def _print_Mul(self, expr):\n         else:\n             tex = \"\"\n \n+\n         from sympy.simplify import fraction\n-        numer, denom = fraction(expr, exact=True)\n+        numer, denom = expr.as_numer_denom()\n         separator = self._settings['mul_symbol_latex']\n         numbersep = self._settings['mul_symbol_latex_numbers']\n \n@@ -390,6 +391,7 @@ def convert(expr):\n                     last_term_tex = term_tex\n                 return _tex\n \n+\n         if denom is S.One:\n             # use the original expression here, since fraction() may have\n             # altered it when producing numer and denom\n@@ -399,6 +401,7 @@ def convert(expr):\n             sdenom = convert(denom)\n             ldenom = len(sdenom.split())\n             ratio = self._settings['long_frac_ratio']\n+\n             if self._settings['fold_short_frac'] \\\n                     and ldenom <= 2 and not \"^\" in sdenom:\n                 # handle short fractions\n@@ -461,8 +464,17 @@ def _print_Pow(self, expr):\n             if expr.base.is_Function:\n                 return self._print(expr.base, \"%s/%s\" % (p, q))\n             return r\"%s^{%s/%s}\" % (base, p, q)\n+\n         elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:\n-            # Things like 1/x\n+            # For exponential functions with negative exponents, keep the original form\n+            # to maintain consistency with pretty printer\n+            if expr.base == S.Exp1:  # e^(-x) should stay as e^(-x), not 1/e^x\n+                if expr.base.is_Function:\n+                    return self._print(expr.base, self._print(expr.exp))\n+                else:\n+                    base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n+                    return r\"%s^{%s}\" % (base, self._print(expr.exp))\n+            # For other cases like x^(-1), still use fraction form\n             return self._print_Mul(expr)\n         else:\n             if expr.base.is_Function:\ndiff --git a/sympy/simplify/radsimp.py b/sympy/simplify/radsimp.py\nindex dca048918b..f2072fad05 100644\n--- a/sympy/simplify/radsimp.py\n+++ b/sympy/simplify/radsimp.py\n@@ -957,8 +957,11 @@ def fraction(expr, exact=False):\n             if ex.is_negative:\n                 if ex is S.NegativeOne:\n                     denom.append(b)\n+\n                 elif exact:\n-                    if ex.is_constant():\n+                    # For exact mode, be more conservative with negative exponents\n+                    # to maintain consistency with pretty printer\n+                    if ex.is_constant() and not (term.func is exp):\n                         denom.append(Pow(b, -ex))\n                     else:\n                         numer.append(term)\n",
    "variant_4": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex 1edc712358..8d89585bee 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -356,8 +356,9 @@ def _print_Mul(self, expr):\n         else:\n             tex = \"\"\n \n+\n         from sympy.simplify import fraction\n-        numer, denom = fraction(expr, exact=True)\n+        numer, denom = expr.as_numer_denom()\n         separator = self._settings['mul_symbol_latex']\n         numbersep = self._settings['mul_symbol_latex_numbers']\n \n@@ -390,6 +391,7 @@ def convert(expr):\n                     last_term_tex = term_tex\n                 return _tex\n \n+\n         if denom is S.One:\n             # use the original expression here, since fraction() may have\n             # altered it when producing numer and denom\n@@ -399,6 +401,7 @@ def convert(expr):\n             sdenom = convert(denom)\n             ldenom = len(sdenom.split())\n             ratio = self._settings['long_frac_ratio']\n+\n             if self._settings['fold_short_frac'] \\\n                     and ldenom <= 2 and not \"^\" in sdenom:\n                 # handle short fractions\n@@ -461,9 +464,21 @@ def _print_Pow(self, expr):\n             if expr.base.is_Function:\n                 return self._print(expr.base, \"%s/%s\" % (p, q))\n             return r\"%s^{%s/%s}\" % (base, p, q)\n+\n         elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:\n-            # Things like 1/x\n-            return self._print_Mul(expr)\n+            # Handle negative rational exponents directly instead of delegating to _print_Mul\n+            # to maintain consistency with pretty printer\n+            if expr.exp == -1:\n+                # For simple x^(-1), use fraction format\n+                return self._print_Mul(expr)\n+            else:\n+                # For other negative exponents like exp(-x), keep exponential form\n+                base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n+                exp = self._print(expr.exp)\n+                if expr.base.is_Function:\n+                    return self._print(expr.base, exp)\n+                else:\n+                    return r\"%s^{%s}\" % (base, exp)\n         else:\n             if expr.base.is_Function:\n                 return self._print(expr.base, self._print(expr.exp))\ndiff --git a/sympy/simplify/radsimp.py b/sympy/simplify/radsimp.py\nindex dca048918b..900f3242b5 100644\n--- a/sympy/simplify/radsimp.py\n+++ b/sympy/simplify/radsimp.py\n@@ -957,8 +957,13 @@ def fraction(expr, exact=False):\n             if ex.is_negative:\n                 if ex is S.NegativeOne:\n                     denom.append(b)\n+\n                 elif exact:\n-                    if ex.is_constant():\n+                    # For exponential functions with negative exponents, keep in original form\n+                    # to maintain consistency with pretty printer\n+                    if b.func is exp:\n+                        numer.append(term)\n+                    elif ex.is_constant():\n                         denom.append(Pow(b, -ex))\n                     else:\n                         numer.append(term)\n",
    "variant_5": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex 1edc712358..3a1c5a0444 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -356,8 +356,9 @@ def _print_Mul(self, expr):\n         else:\n             tex = \"\"\n \n+\n         from sympy.simplify import fraction\n-        numer, denom = fraction(expr, exact=True)\n+        numer, denom = expr.as_numer_denom()\n         separator = self._settings['mul_symbol_latex']\n         numbersep = self._settings['mul_symbol_latex_numbers']\n \n@@ -390,6 +391,7 @@ def convert(expr):\n                     last_term_tex = term_tex\n                 return _tex\n \n+\n         if denom is S.One:\n             # use the original expression here, since fraction() may have\n             # altered it when producing numer and denom\n@@ -399,6 +401,7 @@ def convert(expr):\n             sdenom = convert(denom)\n             ldenom = len(sdenom.split())\n             ratio = self._settings['long_frac_ratio']\n+\n             if self._settings['fold_short_frac'] \\\n                     and ldenom <= 2 and not \"^\" in sdenom:\n                 # handle short fractions\n@@ -461,9 +464,21 @@ def _print_Pow(self, expr):\n             if expr.base.is_Function:\n                 return self._print(expr.base, \"%s/%s\" % (p, q))\n             return r\"%s^{%s/%s}\" % (base, p, q)\n+\n         elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:\n-            # Things like 1/x\n-            return self._print_Mul(expr)\n+            # Handle negative rational exponents directly instead of delegating to _print_Mul\n+            # to maintain consistency with pretty printer\n+            if expr.exp == -1:\n+                # For simple cases like x^(-1), use fraction format\n+                return self._print_Mul(expr)\n+            else:\n+                # For other negative exponents, keep exponential form\n+                base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n+                exp = self._print(expr.exp)\n+                if expr.base.is_Function:\n+                    return self._print(expr.base, exp)\n+                else:\n+                    return r\"%s^{%s}\" % (base, exp)\n         else:\n             if expr.base.is_Function:\n                 return self._print(expr.base, self._print(expr.exp))\ndiff --git a/sympy/simplify/radsimp.py b/sympy/simplify/radsimp.py\nindex dca048918b..5ed5cb9997 100644\n--- a/sympy/simplify/radsimp.py\n+++ b/sympy/simplify/radsimp.py\n@@ -957,8 +957,11 @@ def fraction(expr, exact=False):\n             if ex.is_negative:\n                 if ex is S.NegativeOne:\n                     denom.append(b)\n+\n                 elif exact:\n-                    if ex.is_constant():\n+                    # For exact mode, be more conservative about moving terms to denominator\n+                    # to maintain consistency with pretty printer\n+                    if ex.is_constant() and not (term.func is exp):\n                         denom.append(Pow(b, -ex))\n                     else:\n                         numer.append(term)\n",
    "variant_6": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex 1edc712358..b18779cf9d 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -356,8 +356,19 @@ def _print_Mul(self, expr):\n         else:\n             tex = \"\"\n \n-        from sympy.simplify import fraction\n-        numer, denom = fraction(expr, exact=True)\n+\n+        include_parens = False\n+        if _coeff_isneg(expr):\n+            expr = -expr\n+            tex = \"- \"\n+            if expr.is_Add:\n+                tex += \"(\"\n+                include_parens = True\n+        else:\n+            tex = \"\"\n+\n+        # Use as_numer_denom() instead of fraction() to preserve structure\n+        numer, denom = expr.as_numer_denom()\n         separator = self._settings['mul_symbol_latex']\n         numbersep = self._settings['mul_symbol_latex_numbers']\n \n@@ -390,6 +401,7 @@ def convert(expr):\n                     last_term_tex = term_tex\n                 return _tex\n \n+\n         if denom is S.One:\n             # use the original expression here, since fraction() may have\n             # altered it when producing numer and denom\n@@ -399,6 +411,7 @@ def convert(expr):\n             sdenom = convert(denom)\n             ldenom = len(sdenom.split())\n             ratio = self._settings['long_frac_ratio']\n+\n             if self._settings['fold_short_frac'] \\\n                     and ldenom <= 2 and not \"^\" in sdenom:\n                 # handle short fractions\n@@ -461,9 +474,22 @@ def _print_Pow(self, expr):\n             if expr.base.is_Function:\n                 return self._print(expr.base, \"%s/%s\" % (p, q))\n             return r\"%s^{%s/%s}\" % (base, p, q)\n+\n         elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:\n-            # Things like 1/x\n-            return self._print_Mul(expr)\n+            # Handle negative rational exponents directly instead of delegating to _print_Mul\n+            # to maintain consistency with pretty printer\n+            if expr.exp == -1:\n+                # For x**-1, format as \\frac{1}{x}\n+                return r\"\\frac{1}{%s}\" % self.parenthesize(expr.base, PRECEDENCE['Pow'])\n+            else:\n+                # For other negative rational exponents, keep the exponential form\n+                # e.g., exp(-x) stays as e^{-x} instead of becoming \\frac{1}{e^{x}}\n+                base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n+                exp = self._print(expr.exp)\n+                if expr.base.is_Function:\n+                    return self._print(expr.base, exp)\n+                else:\n+                    return r\"%s^{%s}\" % (base, exp)\n         else:\n             if expr.base.is_Function:\n                 return self._print(expr.base, self._print(expr.exp))\ndiff --git a/sympy/simplify/radsimp.py b/sympy/simplify/radsimp.py\nindex dca048918b..1239d67460 100644\n--- a/sympy/simplify/radsimp.py\n+++ b/sympy/simplify/radsimp.py\n@@ -957,8 +957,13 @@ def fraction(expr, exact=False):\n             if ex.is_negative:\n                 if ex is S.NegativeOne:\n                     denom.append(b)\n+\n                 elif exact:\n-                    if ex.is_constant():\n+                    # For exact mode, be more conservative with exponential functions\n+                    # to maintain consistency with pretty printer\n+                    if b.func is exp:\n+                        numer.append(term)\n+                    elif ex.is_constant():\n                         denom.append(Pow(b, -ex))\n                     else:\n                         numer.append(term)\n",
    "variant_7": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex 1edc712358..19be21c8d1 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -356,8 +356,19 @@ def _print_Mul(self, expr):\n         else:\n             tex = \"\"\n \n-        from sympy.simplify import fraction\n-        numer, denom = fraction(expr, exact=True)\n+\n+        include_parens = False\n+        if _coeff_isneg(expr):\n+            expr = -expr\n+            tex = \"- \"\n+            if expr.is_Add:\n+                tex += \"(\"\n+                include_parens = True\n+        else:\n+            tex = \"\"\n+\n+        # Use as_numer_denom() instead of fraction() to preserve structure\n+        numer, denom = expr.as_numer_denom()\n         separator = self._settings['mul_symbol_latex']\n         numbersep = self._settings['mul_symbol_latex_numbers']\n \n@@ -390,6 +401,7 @@ def convert(expr):\n                     last_term_tex = term_tex\n                 return _tex\n \n+\n         if denom is S.One:\n             # use the original expression here, since fraction() may have\n             # altered it when producing numer and denom\n@@ -399,6 +411,7 @@ def convert(expr):\n             sdenom = convert(denom)\n             ldenom = len(sdenom.split())\n             ratio = self._settings['long_frac_ratio']\n+\n             if self._settings['fold_short_frac'] \\\n                     and ldenom <= 2 and not \"^\" in sdenom:\n                 # handle short fractions\n@@ -461,9 +474,17 @@ def _print_Pow(self, expr):\n             if expr.base.is_Function:\n                 return self._print(expr.base, \"%s/%s\" % (p, q))\n             return r\"%s^{%s/%s}\" % (base, p, q)\n+\n         elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:\n-            # Things like 1/x\n-            return self._print_Mul(expr)\n+            # Handle negative exponents consistently with pretty printer\n+            # Don't delegate to _print_Mul for exponential functions to avoid unwanted fraction conversion\n+            if expr.base.func.__name__ == 'exp':\n+                # For exp(-x), print as e^{-x} to match pretty printer's â„¯^(-x)\n+                base = self.parenthesize(expr.base.args[0], PRECEDENCE['Mul'])\n+                return r\"e^{-%s}\" % base\n+            else:\n+                # For other cases like x^(-1), use fraction form\n+                return self._print_Mul(expr)\n         else:\n             if expr.base.is_Function:\n                 return self._print(expr.base, self._print(expr.exp))\ndiff --git a/sympy/simplify/radsimp.py b/sympy/simplify/radsimp.py\nindex dca048918b..b70c1b332c 100644\n--- a/sympy/simplify/radsimp.py\n+++ b/sympy/simplify/radsimp.py\n@@ -957,13 +957,19 @@ def fraction(expr, exact=False):\n             if ex.is_negative:\n                 if ex is S.NegativeOne:\n                     denom.append(b)\n-                elif exact:\n-                    if ex.is_constant():\n-                        denom.append(Pow(b, -ex))\n-                    else:\n-                        numer.append(term)\n-                else:\n+\n+            elif exact:\n+                # For exact mode, be more conservative about converting to fractions\n+                # especially for exponential functions to maintain consistency with pretty printer\n+                if b.func is exp:\n+                    # Keep exp(-x) in numerator as is, don't convert to 1/exp(x)\n+                    numer.append(term)\n+                elif ex.is_constant():\n                     denom.append(Pow(b, -ex))\n+                else:\n+                    numer.append(term)\n+            else:\n+                denom.append(Pow(b, -ex))\n             elif ex.is_positive:\n                 numer.append(term)\n             elif not exact and ex.is_Mul:\n",
    "variant_8": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\nindex 1edc712358..87860df752 100644\n--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -356,8 +356,19 @@ def _print_Mul(self, expr):\n         else:\n             tex = \"\"\n \n-        from sympy.simplify import fraction\n-        numer, denom = fraction(expr, exact=True)\n+\n+        include_parens = False\n+        if _coeff_isneg(expr):\n+            expr = -expr\n+            tex = \"- \"\n+            if expr.is_Add:\n+                tex += \"(\"\n+                include_parens = True\n+        else:\n+            tex = \"\"\n+\n+        # Use as_numer_denom() instead of fraction() to preserve structure\n+        numer, denom = expr.as_numer_denom()\n         separator = self._settings['mul_symbol_latex']\n         numbersep = self._settings['mul_symbol_latex_numbers']\n \n@@ -390,6 +401,7 @@ def convert(expr):\n                     last_term_tex = term_tex\n                 return _tex\n \n+\n         if denom is S.One:\n             # use the original expression here, since fraction() may have\n             # altered it when producing numer and denom\n@@ -399,6 +411,7 @@ def convert(expr):\n             sdenom = convert(denom)\n             ldenom = len(sdenom.split())\n             ratio = self._settings['long_frac_ratio']\n+\n             if self._settings['fold_short_frac'] \\\n                     and ldenom <= 2 and not \"^\" in sdenom:\n                 # handle short fractions\n@@ -430,6 +443,16 @@ def convert(expr):\n                             % (convert(a), sdenom, separator, convert(b))\n                 else:\n                     tex += r\"\\frac{1}{%s}%s%s\" % (sdenom, separator, snumer)\n+            else:\n+                # Preserve parentheses for Add expressions in denominators\n+                if denom.is_Add and len(denom.args) > 1:\n+                    # Check if original expression structure should be preserved\n+                    original_denom_str = convert(denom)\n+                    if not original_denom_str.startswith(r'\\left('):\n+                        sdenom = r'\\left(%s\\right)' % sdenom\n+                tex += r\"\\frac{%s}{%s}\" % (snumer, sdenom)\n+                else:\n+                    tex += r\"\\frac{1}{%s}%s%s\" % (sdenom, separator, snumer)\n             else:\n                 tex += r\"\\frac{%s}{%s}\" % (snumer, sdenom)\n \n@@ -461,8 +484,14 @@ def _print_Pow(self, expr):\n             if expr.base.is_Function:\n                 return self._print(expr.base, \"%s/%s\" % (p, q))\n             return r\"%s^{%s/%s}\" % (base, p, q)\n+\n         elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:\n-            # Things like 1/x\n+            # For expressions like exp(-x), keep the exponential form instead of converting to fraction\n+            # This maintains consistency with pretty printer output\n+            if expr.base.func.__name__ == 'exp':\n+                base = self.parenthesize(expr.base.args[0], PRECEDENCE['Mul'])\n+                return r\"e^{%s \\cdot %s}\" % (self._print(expr.exp), base)\n+            # For other cases like x**(-1), use fraction form\n             return self._print_Mul(expr)\n         else:\n             if expr.base.is_Function:\ndiff --git a/sympy/simplify/radsimp.py b/sympy/simplify/radsimp.py\nindex dca048918b..296d478e12 100644\n--- a/sympy/simplify/radsimp.py\n+++ b/sympy/simplify/radsimp.py\n@@ -957,8 +957,11 @@ def fraction(expr, exact=False):\n             if ex.is_negative:\n                 if ex is S.NegativeOne:\n                     denom.append(b)\n+\n                 elif exact:\n-                    if ex.is_constant():\n+                    # For exact mode, be more conservative about moving terms to denominator\n+                    # to maintain consistency with pretty printer output\n+                    if ex.is_constant() and not (term.func is exp):\n                         denom.append(Pow(b, -ex))\n                     else:\n                         numer.append(term)\n"
  }
}