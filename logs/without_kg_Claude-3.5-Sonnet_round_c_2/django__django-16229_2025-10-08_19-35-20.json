{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/django/django/forms/boundfield.py lines 141-153)": "\n    def _has_changed(self):\n        field = self.field\n        if field.show_hidden_initial:\n            # For callable defaults (like default=list), use the properly evaluated\n            # initial value instead of cached hidden widget data to avoid stale values\n            if callable(field.initial):\n                initial_value = self.initial\n            else:\n                hidden_widget = field.hidden_widget()\n                initial_value = self.form._widget_data_value(\n                    hidden_widget,\n                    self.html_initial_name,\n                )\n                try:\n                    initial_value = field.to_python(initial_value)\n                except ValidationError:\n                    # Always assume data has changed if validation fails.\n                    return True\n        else:\n            initial_value = self.initial\n        return field.has_changed(initial_value, self.data)\n",
    "Location 2 (/root/hy/projects_2/django/django/forms/forms.py lines 520-522)": "\n    def _has_changed(self, initial, data):\n        \"\"\"Return True if data differs from initial.\"\"\"\n        # Always check for changes if the field has a callable initial value\n        # to ensure fresh evaluation on each form submission (fixes ArrayField issue)\n        if callable(self.field.initial):\n            initial_value = self.initial\n        elif self.form.show_hidden_initial:\n            initial_value = self.form._widget_data_value(\n                self.form.get_initial_for_field(self.field, self.name),\n                self.field.hidden_widget(),\n            )\n        else:\n            initial_value = initial\n        if initial_value is None:\n            initial_value = \"\"\n        if data is None:\n            data = \"\"\n        return initial_value != data\n",
    "Location 3 (/root/hy/projects_2/django/django/forms/boundfield.py lines 254-255)": "\n@cached_property\ndef initial(self):\n    return self.form.get_initial_for_field(self.field, self.name)\n",
    "Location 4 (/root/hy/projects_2/django/django/forms/fields.py lines 104-104)": "\n    def _has_changed(self, initial, data):\n        \"\"\"Return True if data differs from initial.\"\"\"\n        # Always call the field's has_changed() because the field's\n        # has_changed() might do some normalization on the data values.\n        # Check for callable defaults when show_hidden_initial is True\n        if self.form.show_hidden_initial and callable(self.field.initial):\n            initial_value = self.initial\n        else:\n            initial_value = initial\n        return self.field.has_changed(initial_value, data)\n",
    "Location 5 (/root/hy/projects_2/django/django/forms/fields.py lines 134-134)": "\n        self.show_hidden_initial = show_hidden_initial\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/django/django/forms/boundfield.py lines 141-153)": [
      "\n    def _has_changed(self):\n        field = self.field\n        if field.show_hidden_initial:\n            # For callable defaults (like default=list), use the properly evaluated\n            # initial value instead of the cached hidden widget value\n            if callable(field.initial):\n                initial_value = self.initial\n            else:\n                hidden_widget = field.hidden_widget()\n                initial_value = self.form._widget_data_value(\n                    hidden_widget,\n                    self.html_initial_name,\n                )\n                try:\n                    initial_value = field.to_python(initial_value)\n                except ValidationError:\n                    # Always assume data has changed if validation fails.\n                    return True\n        else:\n            initial_value = self.initial\n        return field.has_changed(initial_value, self.data)\n",
      "\n    def _has_changed(self):\n        field = self.field\n        if field.show_hidden_initial:\n            # For callable defaults (like default=list), use the properly evaluated\n            # initial value instead of cached hidden widget data to avoid stale values\n            if callable(field.initial):\n                initial_value = self.initial\n            else:\n                hidden_widget = field.hidden_widget()\n                initial_value = self.form._widget_data_value(\n                    hidden_widget,\n                    self.html_initial_name,\n                )\n                try:\n                    initial_value = field.to_python(initial_value)\n                except ValidationError:\n                    # Always assume data has changed if validation fails.\n                    return True\n        else:\n            initial_value = self.initial\n        return field.has_changed(initial_value, self.data)\n",
      "\n    def _has_changed(self):\n        field = self.field\n        if field.show_hidden_initial:\n            # For callable defaults (like default=list), use the properly evaluated\n            # initial value instead of the cached hidden value to prevent stale data\n            if callable(field.initial):\n                initial_value = self.initial\n            else:\n                hidden_widget = field.hidden_widget()\n                initial_value = self.form._widget_data_value(\n                    hidden_widget,\n                    self.html_initial_name,\n                )\n                try:\n                    initial_value = field.to_python(initial_value)\n                except ValidationError:\n                    # Always assume data has changed if validation fails.\n                    return True\n        else:\n            initial_value = self.initial\n        return field.has_changed(initial_value, self.data)\n",
      "\n    def _has_changed(self):\n        field = self.field\n        if field.show_hidden_initial:\n            # For callable defaults (like default=list), use the properly evaluated\n            # initial value instead of cached hidden widget data to avoid stale values\n            if callable(field.initial):\n                initial_value = self.initial\n            else:\n                hidden_widget = field.hidden_widget()\n                initial_value = self.form._widget_data_value(\n                    hidden_widget,\n                    self.html_initial_name,\n                )\n                try:\n                    initial_value = field.to_python(initial_value)\n                except ValidationError:\n                    # Always assume data has changed if validation fails.\n                    return True\n        else:\n            initial_value = self.initial\n        return field.has_changed(initial_value, self.data)\n",
      "\n    def _has_changed(self):\n        field = self.field\n        if field.show_hidden_initial:\n            # For callable defaults (like list), use the properly evaluated initial value\n            # instead of the cached hidden widget value to avoid stale data\n            if callable(field.initial):\n                initial_value = self.initial\n            else:\n                hidden_widget = field.hidden_widget()\n                initial_value = self.form._widget_data_value(\n                    hidden_widget,\n                    self.html_initial_name,\n                )\n                try:\n                    initial_value = field.to_python(initial_value)\n                except ValidationError:\n                    # Always assume data has changed if validation fails.\n                    return True\n        else:\n            initial_value = self.initial\n        return field.has_changed(initial_value, self.data)\n",
      "\n    def _has_changed(self):\n        field = self.field\n        if field.show_hidden_initial:\n            # For callable defaults (like default=list), use the properly evaluated\n            # initial value instead of the cached hidden widget value\n            if callable(field.initial):\n                initial_value = self.initial\n            else:\n                hidden_widget = field.hidden_widget()\n                initial_value = self.form._widget_data_value(\n                    hidden_widget,\n                    self.html_initial_name,\n                )\n                try:\n                    initial_value = field.to_python(initial_value)\n                except ValidationError:\n                    # Always assume data has changed if validation fails.\n                    return True\n        else:\n            initial_value = self.initial\n        return field.has_changed(initial_value, self.data)\n",
      "\n    def _has_changed(self):\n        field = self.field\n        if field.show_hidden_initial:\n            # For callable defaults (like default=list), use the properly evaluated\n            # initial value instead of cached hidden widget data to avoid stale values\n            if callable(field.initial):\n                initial_value = self.initial\n            else:\n                hidden_widget = field.hidden_widget()\n                initial_value = self.form._widget_data_value(\n                    hidden_widget,\n                    self.html_initial_name,\n                )\n                try:\n                    initial_value = field.to_python(initial_value)\n                except ValidationError:\n                    # Always assume data has changed if validation fails.\n                    return True\n        else:\n            initial_value = self.initial\n        return field.has_changed(initial_value, self.data)\n",
      "\n    def _has_changed(self):\n        field = self.field\n        if field.show_hidden_initial:\n            # For callable defaults like default=list, use the properly evaluated\n            # initial value instead of cached hidden widget data\n            if callable(field.initial):\n                initial_value = self.initial\n            else:\n                hidden_widget = field.hidden_widget()\n                initial_value = self.form._widget_data_value(\n                    hidden_widget,\n                    self.html_initial_name,\n                )\n                try:\n                    initial_value = field.to_python(initial_value)\n                except ValidationError:\n                    # Always assume data has changed if validation fails.\n                    return True\n        else:\n            initial_value = self.initial\n        return field.has_changed(initial_value, self.data)\n"
    ],
    "Location 2 (/root/hy/projects_2/django/django/forms/forms.py lines 520-522)": [
      "\n    def _has_changed(self, initial, data):\n        \"\"\"Return True if data differs from initial.\"\"\"\n        # Always check for changes if show_hidden_initial is disabled or if\n        # field.initial is callable (e.g., default=list for ArrayField)\n        if not self.form.show_hidden_initial or callable(self.field.initial):\n            # Use the properly evaluated initial value for callable defaults\n            initial_value = self.initial if callable(self.field.initial) else initial\n            return self.field.has_changed(initial_value, data)\n        \n        # For backward compatibility with existing hidden initial behavior\n        if self.field.show_hidden_initial:\n            initial_value = self.form.get_initial_for_field(self.field, self.name)\n            return self.field.has_changed(initial_value, data)\n        return self.field.has_changed(initial, data)\n",
      "\n    def _has_changed(self, initial, data):\n        \"\"\"Return True if data differs from initial.\"\"\"\n        # Always check using the current initial value for callable defaults\n        if callable(self.field.initial):\n            initial_value = self.initial\n        else:\n            # For hidden widgets, initial value is passed from the form.\n            if self.field.show_hidden_initial:\n                initial_value = self.form._widget_data_value(\n                    self.field.hidden_widget(), self.html_initial_name\n                )\n            else:\n                initial_value = initial\n        if self.field.show_hidden_initial:\n            initial_value = initial_value or initial\n        return self.field.widget.value_omitted_from_data(\n            self.data, self.form.files, self.html_name\n        ) or self.field.has_changed(initial_value, data)\n",
      "\n    def get_initial_for_field(self, field, field_name):\n        \"\"\"\n        Return initial data for field on form. Use initial data from the form\n        or the field, in that order. Evaluate callable values.\n        \"\"\"\n        value = self.initial.get(field_name, field.initial)\n        if callable(value):\n            value = value()\n        # If this is an auto-generated default date, nix the microseconds\n        # for standardized handling. See #22502.\n        if (\n            isinstance(value, (datetime.datetime, datetime.time))\n            and not field.widget.supports_microseconds\n        ):\n            value = value.replace(microsecond=0)\n        return value\n",
      "\n    def _has_changed(self, initial, data):\n        \"\"\"Return True if data differs from initial.\"\"\"\n        # Always check against the initial data\n        # For a checkbox input, the initial data is a boolean value,\n        # but the data from a form submission is a string, so we need\n        # to convert it.\n        if self.field.show_hidden_initial:\n            # Check if field has callable initial value that needs fresh evaluation\n            if callable(self.field.initial):\n                initial_value = self.initial\n            else:\n                initial_value = self.form.get_initial_for_field(\n                    self.field, self.name\n                )\n            return self.field.widget.value_changed(initial_value, data)\n        return self.field.widget.value_changed(initial, data)\n",
      "\n    def _has_changed(self, initial, data):\n        \"\"\"Return True if data differs from initial.\"\"\"\n        # Always check the field's show_hidden_initial attribute; a HiddenInput\n        # widget alone is not enough to determine if the field is hidden.\n        if self.field.show_hidden_initial:\n            # Check if field has a callable initial value (like default=list)\n            if callable(self.field.initial):\n                # Use the properly evaluated initial value instead of cached hidden value\n                initial_value = self.initial\n            else:\n                # Use the hidden widget's value for non-callable defaults\n                initial_value = self.field.widget.value_from_datadict(\n                    self.form.data, self.form.files, self.add_initial_prefix(self.name)\n                )\n        else:\n            initial_value = initial\n        try:\n            data = self.field.to_python(data)\n        except ValidationError:\n            return True\n        return self.field.has_changed(initial_value, data)\n",
      "\n    def _has_changed(self, initial, data):\n        \"\"\"Return True if data differs from initial.\"\"\"\n        # Always check the field's show_hidden_initial attribute; a subclass\n        # overriding widget can provide a widget that renders initial data as\n        # a hidden field.\n        if self.field.show_hidden_initial:\n            # If the field has a callable initial value (like default=list),\n            # use the evaluated initial value instead of cached hidden value\n            if callable(self.field.initial):\n                initial_value = self.initial\n            else:\n                initial_value = self.form.get_initial_for_field(\n                    self.field, self.name\n                )\n            return self.field.widget.value_omitted_from_data(\n                self.data, self.files, self.html_initial_name\n            ) or self.field.widget._has_changed(initial_value, data)\n        return self.field._has_changed(initial, data)\n",
      "\n    def _has_changed(self, initial, data):\n        \"\"\"Return True if data differs from initial.\"\"\"\n        # Always check for changes if the field has a callable initial value\n        # to avoid using stale cached values from hidden inputs\n        if callable(self.field.initial):\n            initial_value = self.initial\n        else:\n            # For fields with show_hidden_initial=True, the initial value may be\n            # None if the form bound data was erroneous.\n            if self.form._widget_data_value(self.field.widget, self.html_initial_name) is not None:\n                initial_value = self.field.widget.value_from_datadict(\n                    self.form.data, self.form.files, self.html_initial_name,\n                )\n            else:\n                initial_value = initial\n        return self.field.has_changed(initial_value, data)\n",
      "\n    def _has_changed(self, initial, data):\n        \"\"\"Return True if data differs from initial.\"\"\"\n        # Always check if data is empty and initial is not, or vice versa.\n        if initial is None:\n            initial_value = ''\n        else:\n            initial_value = initial\n        if hasattr(self, '_initial_value'):\n            initial_value = self._initial_value\n        \n        # For fields with callable initial values, use the properly evaluated initial\n        # instead of potentially stale hidden values\n        if callable(self.field.initial):\n            initial_value = self.initial\n        elif self.form.show_hidden_initial:\n            warnings.warn(\n                'show_hidden_initial is deprecated and will be removed in Django 5.0.',\n                RemovedInDjango50Warning,\n                stacklevel=2,\n            )\n            initial_prefixed_name = self.form.add_initial_prefix(self.name)\n            hidden_widget = self.field.hidden_widget()\n            try:\n                initial_value = self.form.data[initial_prefixed_name]\n            except KeyError:\n                # A missing value means False for a checkbox, for example.\n                initial_value = ''\n        return self.field.widget.value_omitted_from_data(\n            self.form.data, self.form.files, self.html_name,\n        ) or self.field.widget._has_changed(initial_value, data)\n"
    ],
    "Location 3 (/root/hy/projects_2/django/django/forms/boundfield.py lines 254-255)": [
      "\n@cached_property\ndef initial(self):\n    return self.form.get_initial_for_field(self.field, self.name)\n",
      "\n    def _has_changed(self, initial, data):\n        \"\"\"Return True if data differs from initial.\"\"\"\n        # Always call the field's has_changed() method; this handles\n        # field-specific logic for comparing data.\n        if hasattr(self.field, 'has_changed'):\n            return self.field.has_changed(initial, data)\n        # For fields without has_changed(), use default comparison.\n        # For callable defaults (like default=list), use the evaluated initial value\n        # instead of cached hidden values to prevent stale data issues.\n        if callable(self.field.initial):\n            initial = self.initial\n        return initial != data\n",
      "\n@cached_property\ndef initial(self):\n    return self.form.get_initial_for_field(self.field, self.name)\n",
      "\n    def _has_changed(self, initial, data):\n        \"\"\"Return True if data differs from initial.\"\"\"\n        # Always call the field's has_changed() because the field's\n        # has_changed() might do some normalization on the data.\n        if callable(self.field.initial):\n            # For callable defaults, use the properly evaluated initial value\n            # instead of cached hidden values to ensure fresh evaluation\n            initial_value = self.initial\n        else:\n            initial_value = initial\n        return self.field.has_changed(initial_value, data)\n",
      "\n    def _has_changed(self, initial, data):\n        \"\"\"Return True if data differs from initial.\"\"\"\n        # Always show the field if the user explicitly sets show_hidden_initial.\n        if self.form.show_hidden_initial:\n            initial_value = initial\n            # For callable defaults (like default=list), use the properly evaluated\n            # initial value instead of potentially stale cached hidden values\n            if callable(self.field.initial):\n                initial_value = self.initial\n            return initial_value != data\n        return self.field.has_changed(initial, data)\n",
      "\n    def _has_changed(self, initial, data):\n        \"\"\"Return True if data differs from initial.\"\"\"\n        # Always show initial value for hidden widgets because it can be\n        # beneficial (e.g., widgets for referencing parent model in inline\n        # forms may not be rendered, but may hold such values).\n        # An exception is made for callable defaults to prevent stale cached values\n        if self.field.show_hidden_initial and not callable(self.field.initial):\n            initial_value = self.form.get_initial_for_field(self.field, self.name)\n            try:\n                initial_value = self.field.to_python(initial_value)\n            except ValidationError:\n                # Always assume data has changed if validation fails.\n                return True\n        # For callable defaults, use the properly evaluated initial value\n        elif callable(self.field.initial):\n            initial_value = self.initial\n        else:\n            initial_value = initial\n        return self.field.has_changed(initial_value, data)\n",
      "\n    def _has_changed(self, initial, data):\n        \"\"\"Return True if data differs from initial.\"\"\"\n        # Always check for changes using the current initial value\n        # if the field has a callable initial to avoid using stale cached values\n        if callable(self.field.initial):\n            initial_value = self.initial\n        else:\n            initial_value = initial\n        \n        # For purposes of seeing whether something has changed, None is\n        # the same as an empty string, if the data or initial value we get\n        # is None, replace it with ''.\n        initial_value = initial_value if initial_value is not None else ''\n        data_value = data if data is not None else ''\n        return initial_value != data_value\n",
      "\n    def _has_changed(self, initial, data):\n        \"\"\"Return True if data differs from initial.\"\"\"\n        # Always show when we have no initial data\n        # For cases where initial was provided, check if we have a change\n        if initial is None:\n            return bool(data)\n        \n        # Handle callable defaults properly by using evaluated initial value\n        if callable(self.field.initial):\n            # Use the properly evaluated initial value instead of cached hidden value\n            initial = self.initial\n        \n        # For a MultiValueField, compare each field individually.\n        if hasattr(self.field, 'fields'):\n            if self.form.is_bound:\n                widget = self.field.widget\n                data = widget.decompress(data)\n            if not isinstance(initial, list):\n                initial = widget.decompress(initial)\n            if len(data) != len(initial):\n                return True\n            for field, initial, data in zip(self.field.fields, initial, data):\n                try:\n                    initial = field.to_python(initial)\n                except ValidationError:\n                    return True\n                if field.has_changed(initial, data):\n                    return True\n            return False\n        return self.field.has_changed(initial, data)\n"
    ],
    "Location 4 (/root/hy/projects_2/django/django/forms/fields.py lines 104-104)": [
      "\n    def _has_changed(self, initial, data):\n        \"\"\"Return True if data differs from initial.\"\"\"\n        # Always return False if the field is disabled since self.bound_data\n        # always uses the initial value in this case.\n        if self.field.disabled:\n            return False\n        try:\n            data = self.field.to_python(data)\n            if hasattr(self, '_initial'):\n                # For callable defaults, use the properly evaluated initial value\n                # instead of the cached hidden value to prevent stale data issues\n                if callable(self.field.initial):\n                    initial = self.initial\n                else:\n                    initial = self._initial\n            else:\n                initial = self.initial\n            return self.field.has_changed(initial, data)\n        except ValidationError:\n            return True\n",
      "\n    def _has_changed(self, initial, data):\n        \"\"\"Return True if data differs from initial.\"\"\"\n        # Always return False if the field is disabled since self.data is\n        # not updated in the form.clean() method.\n        if self.field.disabled:\n            return False\n        try:\n            data = self.field.to_python(data)\n            if hasattr(self, '_coerce'):\n                return self._coerce(data) != self._coerce(initial)\n        except ValidationError:\n            return True\n        # For purposes of seeing whether something has changed, None is\n        # the same as an empty string, if the data or initial value we get\n        # is None, replace it with ''.\n        initial_value = initial\n        # Handle callable defaults properly by using evaluated initial value\n        if callable(self.field.initial):\n            initial_value = self.initial\n        elif self.field.show_hidden_initial:\n            initial_value = self.form.initial.get(self.name, self.field.initial)\n        if initial_value is None:\n            initial_value = ''\n        if data is None:\n            data = ''\n        return initial_value != data\n",
      "\n    def _has_changed(self, initial, data):\n        \"\"\"Return True if data differs from initial.\"\"\"\n        # Always return False if the field is disabled since self.bound_data\n        # always uses the initial value in this case.\n        if self.field.disabled:\n            return False\n        try:\n            data = self.field.to_python(data)\n            if hasattr(self, '_initial'):\n                initial_value = self._initial\n            else:\n                # For callable defaults, use properly evaluated initial value\n                if callable(self.field.initial):\n                    initial_value = self.initial\n                else:\n                    initial_value = initial\n            return self.field.has_changed(initial_value, data)\n        except ValidationError:\n            return True\n",
      "\n    def _has_changed(self, initial, data):\n        \"\"\"Return True if data differs from initial.\"\"\"\n        # Always return False if the field is disabled since self.data is\n        # not updated in the form's __init__() method.\n        if self.field.disabled:\n            return False\n        try:\n            data = self.field.to_python(data)\n            if hasattr(self, '_coerce'):\n                return self._coerce(data) != self._coerce(initial)\n        except ValidationError:\n            return True\n        # For purposes of seeing whether something has changed, None is\n        # the same as an empty string, if the data or initial value we get\n        # is None, replace it with ''.\n        initial_value = initial if initial is not None else ''\n        data_value = data if data is not None else ''\n        \n        # Handle callable defaults by using the properly evaluated initial value\n        if callable(self.field.initial):\n            initial_value = self.initial if self.initial is not None else ''\n        \n        return initial_value != data_value\n",
      "\n    def _has_changed(self, initial, data):\n        \"\"\"Return True if data differs from initial.\"\"\"\n        # Always return False if the field is disabled since self.bound_data\n        # always uses the initial value in this case.\n        if self.field.disabled:\n            return False\n        try:\n            data = self.field.to_python(data)\n            if hasattr(self, '_initial'):\n                # For callable defaults like default=list, use the properly evaluated\n                # initial value instead of the cached hidden value\n                if callable(self.field.initial):\n                    initial = self.initial\n                else:\n                    initial = self._initial\n            else:\n                initial = self.field.to_python(initial)\n            return self.field.has_changed(initial, data)\n        except ValidationError:\n            return True\n",
      "\n    def _has_changed(self, initial, data):\n        \"\"\"Return True if data differs from initial.\"\"\"\n        # Always compare against a string because that's what data will be.\n        # This is not entirely correct for e.g. multiple select fields, but\n        # it's better than nothing.\n        if data is None:\n            data_value = ''\n        else:\n            data_value = data\n        if initial is None:\n            # Use field's initial value if it's callable, otherwise use empty string\n            if callable(self.field.initial):\n                initial_value = self.initial\n            else:\n                initial_value = ''\n        else:\n            if isinstance(initial, bool):\n                # Special case for boolean values which may be represented as\n                # strings '1' and '0' in widgets. Use the string representation\n                # for comparison.\n                initial_value = str(initial)\n            else:\n                initial_value = initial\n        return initial_value != data_value\n",
      "\n    def _has_changed(self, initial, data):\n        \"\"\"Return True if data differs from initial.\"\"\"\n        # Always return False if the field is disabled since self.bound_data\n        # always uses the initial value in this case.\n        if self.field.disabled:\n            return False\n        try:\n            data = self.field.to_python(data)\n            if hasattr(self, '_initial'):\n                # For callable defaults, use the properly evaluated initial value\n                # instead of the cached hidden value to avoid stale data\n                if callable(self.field.initial):\n                    initial = self.initial\n                else:\n                    initial = self._initial\n            else:\n                initial = self.field.to_python(initial)\n            return self.field.has_changed(initial, data)\n        except ValidationError:\n            return True\n",
      "\n    def _has_changed(self, initial, data):\n        \"\"\"Return True if data differs from initial.\"\"\"\n        # Always return False if the field is disabled since self.data is\n        # not updated in the form.clean() method.\n        if self.field.disabled:\n            return False\n        try:\n            data = self.field.to_python(data)\n            if hasattr(self, '_coerce'):\n                return self._coerce(data) != self._coerce(initial)\n        except ValidationError:\n            return True\n        # For purposes of seeing whether something has changed, None is\n        # the same as an empty string, if the data or initial value we get\n        # is None, replace it with ''.\n        initial_value = initial\n        if callable(self.field.initial):\n            initial_value = self.initial\n        if initial_value is None:\n            initial_value = ''\n        if data is None:\n            data = ''\n        return initial_value != data\n"
    ],
    "Location 5 (/root/hy/projects_2/django/django/forms/fields.py lines 134-134)": [
      "\n        self.show_hidden_initial = show_hidden_initial\n",
      "\n        self.show_hidden_initial = show_hidden_initial\n",
      "\n        self.show_hidden_initial = show_hidden_initial\n",
      "\n        self.show_hidden_initial = show_hidden_initial\n",
      "\n        self.show_hidden_initial = show_hidden_initial\n",
      "\n        self.show_hidden_initial = show_hidden_initial\n",
      "\n        self.show_hidden_initial = show_hidden_initial\n",
      "\n        self.show_hidden_initial = show_hidden_initial\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/forms/boundfield.py b/django/forms/boundfield.py\nindex 9f2ae59ab4..1b26dbfe99 100644\n--- a/django/forms/boundfield.py\n+++ b/django/forms/boundfield.py\n@@ -138,17 +138,22 @@ class BoundField:\n \n     def _has_changed(self):\n         field = self.field\n+\n         if field.show_hidden_initial:\n-            hidden_widget = field.hidden_widget()\n-            initial_value = self.form._widget_data_value(\n-                hidden_widget,\n-                self.html_initial_name,\n-            )\n-            try:\n-                initial_value = field.to_python(initial_value)\n-            except ValidationError:\n-                # Always assume data has changed if validation fails.\n-                return True\n+            # Check if field has callable default - if so, use properly evaluated initial value\n+            if callable(field.initial):\n+                initial_value = self.initial\n+            else:\n+                hidden_widget = field.hidden_widget()\n+                initial_value = self.form._widget_data_value(\n+                    hidden_widget,\n+                    self.html_initial_name,\n+                )\n+                try:\n+                    initial_value = field.to_python(initial_value)\n+                except ValidationError:\n+                    # Always assume data has changed if validation fails.\n+                    return True\n         else:\n             initial_value = self.initial\n         return field.has_changed(initial_value, self.data)\n@@ -250,6 +255,8 @@ class BoundField:\n         id_ = widget.attrs.get(\"id\") or self.auto_id\n         return widget.id_for_label(id_)\n \n+    @cached_property\n+\n     @cached_property\n     def initial(self):\n         return self.form.get_initial_for_field(self.field, self.name)\ndiff --git a/django/forms/fields.py b/django/forms/fields.py\nindex 46de2f53a0..e03599a05d 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -101,6 +101,7 @@ class Field:\n         initial=None,\n         help_text=\"\",\n         error_messages=None,\n+\n         show_hidden_initial=False,\n         validators=(),\n         localize=False,\n@@ -131,6 +132,7 @@ class Field:\n         # label_suffix -- Suffix to be added to the label. Overrides\n         #                 form's label_suffix.\n         self.required, self.label, self.initial = required, label, initial\n+\n         self.show_hidden_initial = show_hidden_initial\n         self.help_text = help_text\n         self.disabled = disabled\ndiff --git a/django/forms/forms.py b/django/forms/forms.py\nindex 6884e6e724..d05b8cb8ff 100644\n--- a/django/forms/forms.py\n+++ b/django/forms/forms.py\n@@ -517,6 +517,7 @@ class BaseForm(RenderableFormMixin):\n         Return initial data for field on form. Use initial data from the form\n         or the field, in that order. Evaluate callable values.\n         \"\"\"\n+\n         value = self.initial.get(field_name, field.initial)\n         if callable(value):\n             value = value()\n",
    "variant_0": "diff --git a/django/forms/boundfield.py b/django/forms/boundfield.py\nindex 9f2ae59ab4..554ae5e62e 100644\n--- a/django/forms/boundfield.py\n+++ b/django/forms/boundfield.py\n@@ -136,22 +136,31 @@ class BoundField:\n             data = self.field.bound_data(self.data, data)\n         return self.field.prepare_value(data)\n \n+    def _has_changed(self):\n+        field = self.field\n+\n     def _has_changed(self):\n         field = self.field\n         if field.show_hidden_initial:\n-            hidden_widget = field.hidden_widget()\n-            initial_value = self.form._widget_data_value(\n-                hidden_widget,\n-                self.html_initial_name,\n-            )\n-            try:\n-                initial_value = field.to_python(initial_value)\n-            except ValidationError:\n-                # Always assume data has changed if validation fails.\n-                return True\n+            # For callable defaults (like default=list), use the properly evaluated\n+            # initial value instead of cached hidden widget data to avoid stale values\n+            if callable(field.initial):\n+                initial_value = self.initial\n+            else:\n+                hidden_widget = field.hidden_widget()\n+                initial_value = self.form._widget_data_value(\n+                    hidden_widget,\n+                    self.html_initial_name,\n+                )\n+                try:\n+                    initial_value = field.to_python(initial_value)\n+                except ValidationError:\n+                    # Always assume data has changed if validation fails.\n+                    return True\n         else:\n             initial_value = self.initial\n         return field.has_changed(initial_value, self.data)\n+        return field.has_changed(initial_value, self.data)\n \n     def label_tag(self, contents=None, attrs=None, label_suffix=None, tag=None):\n         \"\"\"\n@@ -251,8 +260,10 @@ class BoundField:\n         return widget.id_for_label(id_)\n \n     @cached_property\n-    def initial(self):\n-        return self.form.get_initial_for_field(self.field, self.name)\n+\n+@cached_property\n+def initial(self):\n+    return self.form.get_initial_for_field(self.field, self.name)\n \n     def build_widget_attrs(self, attrs, widget=None):\n         widget = widget or self.field.widget\ndiff --git a/django/forms/fields.py b/django/forms/fields.py\nindex 46de2f53a0..2d8bf55959 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -101,7 +101,17 @@ class Field:\n         initial=None,\n         help_text=\"\",\n         error_messages=None,\n-        show_hidden_initial=False,\n+\n+    def _has_changed(self, initial, data):\n+        \"\"\"Return True if data differs from initial.\"\"\"\n+        # Always call the field's has_changed() because the field's\n+        # has_changed() might do some normalization on the data values.\n+        # Check for callable defaults when show_hidden_initial is True\n+        if self.form.show_hidden_initial and callable(self.field.initial):\n+            initial_value = self.initial\n+        else:\n+            initial_value = initial\n+        return self.field.has_changed(initial_value, data)\n         validators=(),\n         localize=False,\n         disabled=False,\n@@ -131,6 +141,7 @@ class Field:\n         # label_suffix -- Suffix to be added to the label. Overrides\n         #                 form's label_suffix.\n         self.required, self.label, self.initial = required, label, initial\n+\n         self.show_hidden_initial = show_hidden_initial\n         self.help_text = help_text\n         self.disabled = disabled\ndiff --git a/django/forms/forms.py b/django/forms/forms.py\nindex 6884e6e724..2de632d1b6 100644\n--- a/django/forms/forms.py\n+++ b/django/forms/forms.py\n@@ -517,9 +517,25 @@ class BaseForm(RenderableFormMixin):\n         Return initial data for field on form. Use initial data from the form\n         or the field, in that order. Evaluate callable values.\n         \"\"\"\n-        value = self.initial.get(field_name, field.initial)\n-        if callable(value):\n-            value = value()\n+\n+    def _has_changed(self, initial, data):\n+        \"\"\"Return True if data differs from initial.\"\"\"\n+        # Always check for changes if the field has a callable initial value\n+        # to ensure fresh evaluation on each form submission (fixes ArrayField issue)\n+        if callable(self.field.initial):\n+            initial_value = self.initial\n+        elif self.form.show_hidden_initial:\n+            initial_value = self.form._widget_data_value(\n+                self.form.get_initial_for_field(self.field, self.name),\n+                self.field.hidden_widget(),\n+            )\n+        else:\n+            initial_value = initial\n+        if initial_value is None:\n+            initial_value = \"\"\n+        if data is None:\n+            data = \"\"\n+        return initial_value != data\n         # If this is an auto-generated default date, nix the microseconds\n         # for standardized handling. See #22502.\n         if (\n",
    "variant_1": "diff --git a/django/forms/boundfield.py b/django/forms/boundfield.py\nindex 9f2ae59ab4..22637f3f99 100644\n--- a/django/forms/boundfield.py\n+++ b/django/forms/boundfield.py\n@@ -136,22 +136,31 @@ class BoundField:\n             data = self.field.bound_data(self.data, data)\n         return self.field.prepare_value(data)\n \n+    def _has_changed(self):\n+        field = self.field\n+\n     def _has_changed(self):\n         field = self.field\n         if field.show_hidden_initial:\n-            hidden_widget = field.hidden_widget()\n-            initial_value = self.form._widget_data_value(\n-                hidden_widget,\n-                self.html_initial_name,\n-            )\n-            try:\n-                initial_value = field.to_python(initial_value)\n-            except ValidationError:\n-                # Always assume data has changed if validation fails.\n-                return True\n+            # For callable defaults (like default=list), use the properly evaluated\n+            # initial value instead of the cached hidden widget value\n+            if callable(field.initial):\n+                initial_value = self.initial\n+            else:\n+                hidden_widget = field.hidden_widget()\n+                initial_value = self.form._widget_data_value(\n+                    hidden_widget,\n+                    self.html_initial_name,\n+                )\n+                try:\n+                    initial_value = field.to_python(initial_value)\n+                except ValidationError:\n+                    # Always assume data has changed if validation fails.\n+                    return True\n         else:\n             initial_value = self.initial\n         return field.has_changed(initial_value, self.data)\n+        return field.has_changed(initial_value, self.data)\n \n     def label_tag(self, contents=None, attrs=None, label_suffix=None, tag=None):\n         \"\"\"\n@@ -251,8 +260,10 @@ class BoundField:\n         return widget.id_for_label(id_)\n \n     @cached_property\n-    def initial(self):\n-        return self.form.get_initial_for_field(self.field, self.name)\n+\n+@cached_property\n+def initial(self):\n+    return self.form.get_initial_for_field(self.field, self.name)\n \n     def build_widget_attrs(self, attrs, widget=None):\n         widget = widget or self.field.widget\ndiff --git a/django/forms/fields.py b/django/forms/fields.py\nindex 46de2f53a0..3526533c9f 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -101,7 +101,27 @@ class Field:\n         initial=None,\n         help_text=\"\",\n         error_messages=None,\n-        show_hidden_initial=False,\n+\n+    def _has_changed(self, initial, data):\n+        \"\"\"Return True if data differs from initial.\"\"\"\n+        # Always return False if the field is disabled since self.bound_data\n+        # always uses the initial value in this case.\n+        if self.field.disabled:\n+            return False\n+        try:\n+            data = self.field.to_python(data)\n+            if hasattr(self, '_initial'):\n+                # For callable defaults, use the properly evaluated initial value\n+                # instead of the cached hidden value to prevent stale data issues\n+                if callable(self.field.initial):\n+                    initial = self.initial\n+                else:\n+                    initial = self._initial\n+            else:\n+                initial = self.initial\n+            return self.field.has_changed(initial, data)\n+        except ValidationError:\n+            return True\n         validators=(),\n         localize=False,\n         disabled=False,\n@@ -131,6 +151,7 @@ class Field:\n         # label_suffix -- Suffix to be added to the label. Overrides\n         #                 form's label_suffix.\n         self.required, self.label, self.initial = required, label, initial\n+\n         self.show_hidden_initial = show_hidden_initial\n         self.help_text = help_text\n         self.disabled = disabled\ndiff --git a/django/forms/forms.py b/django/forms/forms.py\nindex 6884e6e724..f4c1acf44b 100644\n--- a/django/forms/forms.py\n+++ b/django/forms/forms.py\n@@ -517,9 +517,21 @@ class BaseForm(RenderableFormMixin):\n         Return initial data for field on form. Use initial data from the form\n         or the field, in that order. Evaluate callable values.\n         \"\"\"\n-        value = self.initial.get(field_name, field.initial)\n-        if callable(value):\n-            value = value()\n+\n+    def _has_changed(self, initial, data):\n+        \"\"\"Return True if data differs from initial.\"\"\"\n+        # Always check for changes if show_hidden_initial is disabled or if\n+        # field.initial is callable (e.g., default=list for ArrayField)\n+        if not self.form.show_hidden_initial or callable(self.field.initial):\n+            # Use the properly evaluated initial value for callable defaults\n+            initial_value = self.initial if callable(self.field.initial) else initial\n+            return self.field.has_changed(initial_value, data)\n+        \n+        # For backward compatibility with existing hidden initial behavior\n+        if self.field.show_hidden_initial:\n+            initial_value = self.form.get_initial_for_field(self.field, self.name)\n+            return self.field.has_changed(initial_value, data)\n+        return self.field.has_changed(initial, data)\n         # If this is an auto-generated default date, nix the microseconds\n         # for standardized handling. See #22502.\n         if (\n",
    "variant_2": "diff --git a/django/forms/boundfield.py b/django/forms/boundfield.py\nindex 9f2ae59ab4..1ea9560387 100644\n--- a/django/forms/boundfield.py\n+++ b/django/forms/boundfield.py\n@@ -136,22 +136,31 @@ class BoundField:\n             data = self.field.bound_data(self.data, data)\n         return self.field.prepare_value(data)\n \n+    def _has_changed(self):\n+        field = self.field\n+\n     def _has_changed(self):\n         field = self.field\n         if field.show_hidden_initial:\n-            hidden_widget = field.hidden_widget()\n-            initial_value = self.form._widget_data_value(\n-                hidden_widget,\n-                self.html_initial_name,\n-            )\n-            try:\n-                initial_value = field.to_python(initial_value)\n-            except ValidationError:\n-                # Always assume data has changed if validation fails.\n-                return True\n+            # For callable defaults (like default=list), use the properly evaluated\n+            # initial value instead of cached hidden widget data to avoid stale values\n+            if callable(field.initial):\n+                initial_value = self.initial\n+            else:\n+                hidden_widget = field.hidden_widget()\n+                initial_value = self.form._widget_data_value(\n+                    hidden_widget,\n+                    self.html_initial_name,\n+                )\n+                try:\n+                    initial_value = field.to_python(initial_value)\n+                except ValidationError:\n+                    # Always assume data has changed if validation fails.\n+                    return True\n         else:\n             initial_value = self.initial\n         return field.has_changed(initial_value, self.data)\n+        return field.has_changed(initial_value, self.data)\n \n     def label_tag(self, contents=None, attrs=None, label_suffix=None, tag=None):\n         \"\"\"\n@@ -251,8 +260,19 @@ class BoundField:\n         return widget.id_for_label(id_)\n \n     @cached_property\n-    def initial(self):\n-        return self.form.get_initial_for_field(self.field, self.name)\n+\n+    def _has_changed(self, initial, data):\n+        \"\"\"Return True if data differs from initial.\"\"\"\n+        # Always call the field's has_changed() method; this handles\n+        # field-specific logic for comparing data.\n+        if hasattr(self.field, 'has_changed'):\n+            return self.field.has_changed(initial, data)\n+        # For fields without has_changed(), use default comparison.\n+        # For callable defaults (like default=list), use the evaluated initial value\n+        # instead of cached hidden values to prevent stale data issues.\n+        if callable(self.field.initial):\n+            initial = self.initial\n+        return initial != data\n \n     def build_widget_attrs(self, attrs, widget=None):\n         widget = widget or self.field.widget\ndiff --git a/django/forms/fields.py b/django/forms/fields.py\nindex 46de2f53a0..8fc0c20960 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -101,7 +101,33 @@ class Field:\n         initial=None,\n         help_text=\"\",\n         error_messages=None,\n-        show_hidden_initial=False,\n+\n+    def _has_changed(self, initial, data):\n+        \"\"\"Return True if data differs from initial.\"\"\"\n+        # Always return False if the field is disabled since self.data is\n+        # not updated in the form.clean() method.\n+        if self.field.disabled:\n+            return False\n+        try:\n+            data = self.field.to_python(data)\n+            if hasattr(self, '_coerce'):\n+                return self._coerce(data) != self._coerce(initial)\n+        except ValidationError:\n+            return True\n+        # For purposes of seeing whether something has changed, None is\n+        # the same as an empty string, if the data or initial value we get\n+        # is None, replace it with ''.\n+        initial_value = initial\n+        # Handle callable defaults properly by using evaluated initial value\n+        if callable(self.field.initial):\n+            initial_value = self.initial\n+        elif self.field.show_hidden_initial:\n+            initial_value = self.form.initial.get(self.name, self.field.initial)\n+        if initial_value is None:\n+            initial_value = ''\n+        if data is None:\n+            data = ''\n+        return initial_value != data\n         validators=(),\n         localize=False,\n         disabled=False,\n@@ -131,6 +157,7 @@ class Field:\n         # label_suffix -- Suffix to be added to the label. Overrides\n         #                 form's label_suffix.\n         self.required, self.label, self.initial = required, label, initial\n+\n         self.show_hidden_initial = show_hidden_initial\n         self.help_text = help_text\n         self.disabled = disabled\ndiff --git a/django/forms/forms.py b/django/forms/forms.py\nindex 6884e6e724..c9435135c1 100644\n--- a/django/forms/forms.py\n+++ b/django/forms/forms.py\n@@ -517,9 +517,25 @@ class BaseForm(RenderableFormMixin):\n         Return initial data for field on form. Use initial data from the form\n         or the field, in that order. Evaluate callable values.\n         \"\"\"\n-        value = self.initial.get(field_name, field.initial)\n-        if callable(value):\n-            value = value()\n+\n+    def _has_changed(self, initial, data):\n+        \"\"\"Return True if data differs from initial.\"\"\"\n+        # Always check using the current initial value for callable defaults\n+        if callable(self.field.initial):\n+            initial_value = self.initial\n+        else:\n+            # For hidden widgets, initial value is passed from the form.\n+            if self.field.show_hidden_initial:\n+                initial_value = self.form._widget_data_value(\n+                    self.field.hidden_widget(), self.html_initial_name\n+                )\n+            else:\n+                initial_value = initial\n+        if self.field.show_hidden_initial:\n+            initial_value = initial_value or initial\n+        return self.field.widget.value_omitted_from_data(\n+            self.data, self.form.files, self.html_name\n+        ) or self.field.has_changed(initial_value, data)\n         # If this is an auto-generated default date, nix the microseconds\n         # for standardized handling. See #22502.\n         if (\n",
    "variant_3": "diff --git a/django/forms/boundfield.py b/django/forms/boundfield.py\nindex 9f2ae59ab4..b8f191452d 100644\n--- a/django/forms/boundfield.py\n+++ b/django/forms/boundfield.py\n@@ -136,22 +136,31 @@ class BoundField:\n             data = self.field.bound_data(self.data, data)\n         return self.field.prepare_value(data)\n \n+    def _has_changed(self):\n+        field = self.field\n+\n     def _has_changed(self):\n         field = self.field\n         if field.show_hidden_initial:\n-            hidden_widget = field.hidden_widget()\n-            initial_value = self.form._widget_data_value(\n-                hidden_widget,\n-                self.html_initial_name,\n-            )\n-            try:\n-                initial_value = field.to_python(initial_value)\n-            except ValidationError:\n-                # Always assume data has changed if validation fails.\n-                return True\n+            # For callable defaults (like default=list), use the properly evaluated\n+            # initial value instead of the cached hidden value to prevent stale data\n+            if callable(field.initial):\n+                initial_value = self.initial\n+            else:\n+                hidden_widget = field.hidden_widget()\n+                initial_value = self.form._widget_data_value(\n+                    hidden_widget,\n+                    self.html_initial_name,\n+                )\n+                try:\n+                    initial_value = field.to_python(initial_value)\n+                except ValidationError:\n+                    # Always assume data has changed if validation fails.\n+                    return True\n         else:\n             initial_value = self.initial\n         return field.has_changed(initial_value, self.data)\n+        return field.has_changed(initial_value, self.data)\n \n     def label_tag(self, contents=None, attrs=None, label_suffix=None, tag=None):\n         \"\"\"\n@@ -251,8 +260,10 @@ class BoundField:\n         return widget.id_for_label(id_)\n \n     @cached_property\n-    def initial(self):\n-        return self.form.get_initial_for_field(self.field, self.name)\n+\n+@cached_property\n+def initial(self):\n+    return self.form.get_initial_for_field(self.field, self.name)\n \n     def build_widget_attrs(self, attrs, widget=None):\n         widget = widget or self.field.widget\ndiff --git a/django/forms/fields.py b/django/forms/fields.py\nindex 46de2f53a0..bf74df114f 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -101,7 +101,26 @@ class Field:\n         initial=None,\n         help_text=\"\",\n         error_messages=None,\n-        show_hidden_initial=False,\n+\n+    def _has_changed(self, initial, data):\n+        \"\"\"Return True if data differs from initial.\"\"\"\n+        # Always return False if the field is disabled since self.bound_data\n+        # always uses the initial value in this case.\n+        if self.field.disabled:\n+            return False\n+        try:\n+            data = self.field.to_python(data)\n+            if hasattr(self, '_initial'):\n+                initial_value = self._initial\n+            else:\n+                # For callable defaults, use properly evaluated initial value\n+                if callable(self.field.initial):\n+                    initial_value = self.initial\n+                else:\n+                    initial_value = initial\n+            return self.field.has_changed(initial_value, data)\n+        except ValidationError:\n+            return True\n         validators=(),\n         localize=False,\n         disabled=False,\n@@ -131,6 +150,7 @@ class Field:\n         # label_suffix -- Suffix to be added to the label. Overrides\n         #                 form's label_suffix.\n         self.required, self.label, self.initial = required, label, initial\n+\n         self.show_hidden_initial = show_hidden_initial\n         self.help_text = help_text\n         self.disabled = disabled\ndiff --git a/django/forms/forms.py b/django/forms/forms.py\nindex 6884e6e724..94f7ed1488 100644\n--- a/django/forms/forms.py\n+++ b/django/forms/forms.py\n@@ -512,6 +512,12 @@ class BaseForm(RenderableFormMixin):\n         \"\"\"\n         return [field for field in self if not field.is_hidden]\n \n+    def get_initial_for_field(self, field, field_name):\n+        \"\"\"\n+        Return initial data for field on form. Use initial data from the form\n+        or the field, in that order. Evaluate callable values.\n+        \"\"\"\n+\n     def get_initial_for_field(self, field, field_name):\n         \"\"\"\n         Return initial data for field on form. Use initial data from the form\n@@ -528,6 +534,14 @@ class BaseForm(RenderableFormMixin):\n         ):\n             value = value.replace(microsecond=0)\n         return value\n+        # If this is an auto-generated default date, nix the microseconds\n+        # for standardized handling. See #22502.\n+        if (\n+            isinstance(value, (datetime.datetime, datetime.time))\n+            and not field.widget.supports_microseconds\n+        ):\n+            value = value.replace(microsecond=0)\n+        return value\n \n \n class Form(BaseForm, metaclass=DeclarativeFieldsMetaclass):\n",
    "variant_4": "diff --git a/django/forms/boundfield.py b/django/forms/boundfield.py\nindex 9f2ae59ab4..2135d0a7b9 100644\n--- a/django/forms/boundfield.py\n+++ b/django/forms/boundfield.py\n@@ -136,22 +136,31 @@ class BoundField:\n             data = self.field.bound_data(self.data, data)\n         return self.field.prepare_value(data)\n \n+    def _has_changed(self):\n+        field = self.field\n+\n     def _has_changed(self):\n         field = self.field\n         if field.show_hidden_initial:\n-            hidden_widget = field.hidden_widget()\n-            initial_value = self.form._widget_data_value(\n-                hidden_widget,\n-                self.html_initial_name,\n-            )\n-            try:\n-                initial_value = field.to_python(initial_value)\n-            except ValidationError:\n-                # Always assume data has changed if validation fails.\n-                return True\n+            # For callable defaults (like default=list), use the properly evaluated\n+            # initial value instead of cached hidden widget data to avoid stale values\n+            if callable(field.initial):\n+                initial_value = self.initial\n+            else:\n+                hidden_widget = field.hidden_widget()\n+                initial_value = self.form._widget_data_value(\n+                    hidden_widget,\n+                    self.html_initial_name,\n+                )\n+                try:\n+                    initial_value = field.to_python(initial_value)\n+                except ValidationError:\n+                    # Always assume data has changed if validation fails.\n+                    return True\n         else:\n             initial_value = self.initial\n         return field.has_changed(initial_value, self.data)\n+        return field.has_changed(initial_value, self.data)\n \n     def label_tag(self, contents=None, attrs=None, label_suffix=None, tag=None):\n         \"\"\"\n@@ -251,8 +260,18 @@ class BoundField:\n         return widget.id_for_label(id_)\n \n     @cached_property\n-    def initial(self):\n-        return self.form.get_initial_for_field(self.field, self.name)\n+\n+    def _has_changed(self, initial, data):\n+        \"\"\"Return True if data differs from initial.\"\"\"\n+        # Always call the field's has_changed() because the field's\n+        # has_changed() might do some normalization on the data.\n+        if callable(self.field.initial):\n+            # For callable defaults, use the properly evaluated initial value\n+            # instead of cached hidden values to ensure fresh evaluation\n+            initial_value = self.initial\n+        else:\n+            initial_value = initial\n+        return self.field.has_changed(initial_value, data)\n \n     def build_widget_attrs(self, attrs, widget=None):\n         widget = widget or self.field.widget\ndiff --git a/django/forms/fields.py b/django/forms/fields.py\nindex 46de2f53a0..a0392854ed 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -101,7 +101,30 @@ class Field:\n         initial=None,\n         help_text=\"\",\n         error_messages=None,\n-        show_hidden_initial=False,\n+\n+    def _has_changed(self, initial, data):\n+        \"\"\"Return True if data differs from initial.\"\"\"\n+        # Always return False if the field is disabled since self.data is\n+        # not updated in the form's __init__() method.\n+        if self.field.disabled:\n+            return False\n+        try:\n+            data = self.field.to_python(data)\n+            if hasattr(self, '_coerce'):\n+                return self._coerce(data) != self._coerce(initial)\n+        except ValidationError:\n+            return True\n+        # For purposes of seeing whether something has changed, None is\n+        # the same as an empty string, if the data or initial value we get\n+        # is None, replace it with ''.\n+        initial_value = initial if initial is not None else ''\n+        data_value = data if data is not None else ''\n+        \n+        # Handle callable defaults by using the properly evaluated initial value\n+        if callable(self.field.initial):\n+            initial_value = self.initial if self.initial is not None else ''\n+        \n+        return initial_value != data_value\n         validators=(),\n         localize=False,\n         disabled=False,\n@@ -131,6 +154,7 @@ class Field:\n         # label_suffix -- Suffix to be added to the label. Overrides\n         #                 form's label_suffix.\n         self.required, self.label, self.initial = required, label, initial\n+\n         self.show_hidden_initial = show_hidden_initial\n         self.help_text = help_text\n         self.disabled = disabled\ndiff --git a/django/forms/forms.py b/django/forms/forms.py\nindex 6884e6e724..b772e7178a 100644\n--- a/django/forms/forms.py\n+++ b/django/forms/forms.py\n@@ -517,9 +517,23 @@ class BaseForm(RenderableFormMixin):\n         Return initial data for field on form. Use initial data from the form\n         or the field, in that order. Evaluate callable values.\n         \"\"\"\n-        value = self.initial.get(field_name, field.initial)\n-        if callable(value):\n-            value = value()\n+\n+    def _has_changed(self, initial, data):\n+        \"\"\"Return True if data differs from initial.\"\"\"\n+        # Always check against the initial data\n+        # For a checkbox input, the initial data is a boolean value,\n+        # but the data from a form submission is a string, so we need\n+        # to convert it.\n+        if self.field.show_hidden_initial:\n+            # Check if field has callable initial value that needs fresh evaluation\n+            if callable(self.field.initial):\n+                initial_value = self.initial\n+            else:\n+                initial_value = self.form.get_initial_for_field(\n+                    self.field, self.name\n+                )\n+            return self.field.widget.value_changed(initial_value, data)\n+        return self.field.widget.value_changed(initial, data)\n         # If this is an auto-generated default date, nix the microseconds\n         # for standardized handling. See #22502.\n         if (\n",
    "variant_5": "diff --git a/django/forms/boundfield.py b/django/forms/boundfield.py\nindex 9f2ae59ab4..b2117d283d 100644\n--- a/django/forms/boundfield.py\n+++ b/django/forms/boundfield.py\n@@ -136,22 +136,31 @@ class BoundField:\n             data = self.field.bound_data(self.data, data)\n         return self.field.prepare_value(data)\n \n+    def _has_changed(self):\n+        field = self.field\n+\n     def _has_changed(self):\n         field = self.field\n         if field.show_hidden_initial:\n-            hidden_widget = field.hidden_widget()\n-            initial_value = self.form._widget_data_value(\n-                hidden_widget,\n-                self.html_initial_name,\n-            )\n-            try:\n-                initial_value = field.to_python(initial_value)\n-            except ValidationError:\n-                # Always assume data has changed if validation fails.\n-                return True\n+            # For callable defaults (like list), use the properly evaluated initial value\n+            # instead of the cached hidden widget value to avoid stale data\n+            if callable(field.initial):\n+                initial_value = self.initial\n+            else:\n+                hidden_widget = field.hidden_widget()\n+                initial_value = self.form._widget_data_value(\n+                    hidden_widget,\n+                    self.html_initial_name,\n+                )\n+                try:\n+                    initial_value = field.to_python(initial_value)\n+                except ValidationError:\n+                    # Always assume data has changed if validation fails.\n+                    return True\n         else:\n             initial_value = self.initial\n         return field.has_changed(initial_value, self.data)\n+        return field.has_changed(initial_value, self.data)\n \n     def label_tag(self, contents=None, attrs=None, label_suffix=None, tag=None):\n         \"\"\"\n@@ -251,8 +260,18 @@ class BoundField:\n         return widget.id_for_label(id_)\n \n     @cached_property\n-    def initial(self):\n-        return self.form.get_initial_for_field(self.field, self.name)\n+\n+    def _has_changed(self, initial, data):\n+        \"\"\"Return True if data differs from initial.\"\"\"\n+        # Always show the field if the user explicitly sets show_hidden_initial.\n+        if self.form.show_hidden_initial:\n+            initial_value = initial\n+            # For callable defaults (like default=list), use the properly evaluated\n+            # initial value instead of potentially stale cached hidden values\n+            if callable(self.field.initial):\n+                initial_value = self.initial\n+            return initial_value != data\n+        return self.field.has_changed(initial, data)\n \n     def build_widget_attrs(self, attrs, widget=None):\n         widget = widget or self.field.widget\ndiff --git a/django/forms/fields.py b/django/forms/fields.py\nindex 46de2f53a0..9a176281f3 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -101,7 +101,27 @@ class Field:\n         initial=None,\n         help_text=\"\",\n         error_messages=None,\n-        show_hidden_initial=False,\n+\n+    def _has_changed(self, initial, data):\n+        \"\"\"Return True if data differs from initial.\"\"\"\n+        # Always return False if the field is disabled since self.bound_data\n+        # always uses the initial value in this case.\n+        if self.field.disabled:\n+            return False\n+        try:\n+            data = self.field.to_python(data)\n+            if hasattr(self, '_initial'):\n+                # For callable defaults like default=list, use the properly evaluated\n+                # initial value instead of the cached hidden value\n+                if callable(self.field.initial):\n+                    initial = self.initial\n+                else:\n+                    initial = self._initial\n+            else:\n+                initial = self.field.to_python(initial)\n+            return self.field.has_changed(initial, data)\n+        except ValidationError:\n+            return True\n         validators=(),\n         localize=False,\n         disabled=False,\n@@ -131,6 +151,7 @@ class Field:\n         # label_suffix -- Suffix to be added to the label. Overrides\n         #                 form's label_suffix.\n         self.required, self.label, self.initial = required, label, initial\n+\n         self.show_hidden_initial = show_hidden_initial\n         self.help_text = help_text\n         self.disabled = disabled\ndiff --git a/django/forms/forms.py b/django/forms/forms.py\nindex 6884e6e724..66bc426d16 100644\n--- a/django/forms/forms.py\n+++ b/django/forms/forms.py\n@@ -517,9 +517,28 @@ class BaseForm(RenderableFormMixin):\n         Return initial data for field on form. Use initial data from the form\n         or the field, in that order. Evaluate callable values.\n         \"\"\"\n-        value = self.initial.get(field_name, field.initial)\n-        if callable(value):\n-            value = value()\n+\n+    def _has_changed(self, initial, data):\n+        \"\"\"Return True if data differs from initial.\"\"\"\n+        # Always check the field's show_hidden_initial attribute; a HiddenInput\n+        # widget alone is not enough to determine if the field is hidden.\n+        if self.field.show_hidden_initial:\n+            # Check if field has a callable initial value (like default=list)\n+            if callable(self.field.initial):\n+                # Use the properly evaluated initial value instead of cached hidden value\n+                initial_value = self.initial\n+            else:\n+                # Use the hidden widget's value for non-callable defaults\n+                initial_value = self.field.widget.value_from_datadict(\n+                    self.form.data, self.form.files, self.add_initial_prefix(self.name)\n+                )\n+        else:\n+            initial_value = initial\n+        try:\n+            data = self.field.to_python(data)\n+        except ValidationError:\n+            return True\n+        return self.field.has_changed(initial_value, data)\n         # If this is an auto-generated default date, nix the microseconds\n         # for standardized handling. See #22502.\n         if (\n",
    "variant_6": "diff --git a/django/forms/boundfield.py b/django/forms/boundfield.py\nindex 9f2ae59ab4..9e750a282c 100644\n--- a/django/forms/boundfield.py\n+++ b/django/forms/boundfield.py\n@@ -136,22 +136,31 @@ class BoundField:\n             data = self.field.bound_data(self.data, data)\n         return self.field.prepare_value(data)\n \n+    def _has_changed(self):\n+        field = self.field\n+\n     def _has_changed(self):\n         field = self.field\n         if field.show_hidden_initial:\n-            hidden_widget = field.hidden_widget()\n-            initial_value = self.form._widget_data_value(\n-                hidden_widget,\n-                self.html_initial_name,\n-            )\n-            try:\n-                initial_value = field.to_python(initial_value)\n-            except ValidationError:\n-                # Always assume data has changed if validation fails.\n-                return True\n+            # For callable defaults (like default=list), use the properly evaluated\n+            # initial value instead of the cached hidden widget value\n+            if callable(field.initial):\n+                initial_value = self.initial\n+            else:\n+                hidden_widget = field.hidden_widget()\n+                initial_value = self.form._widget_data_value(\n+                    hidden_widget,\n+                    self.html_initial_name,\n+                )\n+                try:\n+                    initial_value = field.to_python(initial_value)\n+                except ValidationError:\n+                    # Always assume data has changed if validation fails.\n+                    return True\n         else:\n             initial_value = self.initial\n         return field.has_changed(initial_value, self.data)\n+        return field.has_changed(initial_value, self.data)\n \n     def label_tag(self, contents=None, attrs=None, label_suffix=None, tag=None):\n         \"\"\"\n@@ -251,8 +260,26 @@ class BoundField:\n         return widget.id_for_label(id_)\n \n     @cached_property\n-    def initial(self):\n-        return self.form.get_initial_for_field(self.field, self.name)\n+\n+    def _has_changed(self, initial, data):\n+        \"\"\"Return True if data differs from initial.\"\"\"\n+        # Always show initial value for hidden widgets because it can be\n+        # beneficial (e.g., widgets for referencing parent model in inline\n+        # forms may not be rendered, but may hold such values).\n+        # An exception is made for callable defaults to prevent stale cached values\n+        if self.field.show_hidden_initial and not callable(self.field.initial):\n+            initial_value = self.form.get_initial_for_field(self.field, self.name)\n+            try:\n+                initial_value = self.field.to_python(initial_value)\n+            except ValidationError:\n+                # Always assume data has changed if validation fails.\n+                return True\n+        # For callable defaults, use the properly evaluated initial value\n+        elif callable(self.field.initial):\n+            initial_value = self.initial\n+        else:\n+            initial_value = initial\n+        return self.field.has_changed(initial_value, data)\n \n     def build_widget_attrs(self, attrs, widget=None):\n         widget = widget or self.field.widget\ndiff --git a/django/forms/fields.py b/django/forms/fields.py\nindex 46de2f53a0..acc1b453b6 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -101,7 +101,31 @@ class Field:\n         initial=None,\n         help_text=\"\",\n         error_messages=None,\n-        show_hidden_initial=False,\n+\n+    def _has_changed(self, initial, data):\n+        \"\"\"Return True if data differs from initial.\"\"\"\n+        # Always compare against a string because that's what data will be.\n+        # This is not entirely correct for e.g. multiple select fields, but\n+        # it's better than nothing.\n+        if data is None:\n+            data_value = ''\n+        else:\n+            data_value = data\n+        if initial is None:\n+            # Use field's initial value if it's callable, otherwise use empty string\n+            if callable(self.field.initial):\n+                initial_value = self.initial\n+            else:\n+                initial_value = ''\n+        else:\n+            if isinstance(initial, bool):\n+                # Special case for boolean values which may be represented as\n+                # strings '1' and '0' in widgets. Use the string representation\n+                # for comparison.\n+                initial_value = str(initial)\n+            else:\n+                initial_value = initial\n+        return initial_value != data_value\n         validators=(),\n         localize=False,\n         disabled=False,\n@@ -131,6 +155,7 @@ class Field:\n         # label_suffix -- Suffix to be added to the label. Overrides\n         #                 form's label_suffix.\n         self.required, self.label, self.initial = required, label, initial\n+\n         self.show_hidden_initial = show_hidden_initial\n         self.help_text = help_text\n         self.disabled = disabled\ndiff --git a/django/forms/forms.py b/django/forms/forms.py\nindex 6884e6e724..8bc76d2584 100644\n--- a/django/forms/forms.py\n+++ b/django/forms/forms.py\n@@ -517,9 +517,25 @@ class BaseForm(RenderableFormMixin):\n         Return initial data for field on form. Use initial data from the form\n         or the field, in that order. Evaluate callable values.\n         \"\"\"\n-        value = self.initial.get(field_name, field.initial)\n-        if callable(value):\n-            value = value()\n+\n+    def _has_changed(self, initial, data):\n+        \"\"\"Return True if data differs from initial.\"\"\"\n+        # Always check the field's show_hidden_initial attribute; a subclass\n+        # overriding widget can provide a widget that renders initial data as\n+        # a hidden field.\n+        if self.field.show_hidden_initial:\n+            # If the field has a callable initial value (like default=list),\n+            # use the evaluated initial value instead of cached hidden value\n+            if callable(self.field.initial):\n+                initial_value = self.initial\n+            else:\n+                initial_value = self.form.get_initial_for_field(\n+                    self.field, self.name\n+                )\n+            return self.field.widget.value_omitted_from_data(\n+                self.data, self.files, self.html_initial_name\n+            ) or self.field.widget._has_changed(initial_value, data)\n+        return self.field._has_changed(initial, data)\n         # If this is an auto-generated default date, nix the microseconds\n         # for standardized handling. See #22502.\n         if (\n",
    "variant_7": "diff --git a/django/forms/boundfield.py b/django/forms/boundfield.py\nindex 9f2ae59ab4..b9d68da764 100644\n--- a/django/forms/boundfield.py\n+++ b/django/forms/boundfield.py\n@@ -136,22 +136,31 @@ class BoundField:\n             data = self.field.bound_data(self.data, data)\n         return self.field.prepare_value(data)\n \n+    def _has_changed(self):\n+        field = self.field\n+\n     def _has_changed(self):\n         field = self.field\n         if field.show_hidden_initial:\n-            hidden_widget = field.hidden_widget()\n-            initial_value = self.form._widget_data_value(\n-                hidden_widget,\n-                self.html_initial_name,\n-            )\n-            try:\n-                initial_value = field.to_python(initial_value)\n-            except ValidationError:\n-                # Always assume data has changed if validation fails.\n-                return True\n+            # For callable defaults (like default=list), use the properly evaluated\n+            # initial value instead of cached hidden widget data to avoid stale values\n+            if callable(field.initial):\n+                initial_value = self.initial\n+            else:\n+                hidden_widget = field.hidden_widget()\n+                initial_value = self.form._widget_data_value(\n+                    hidden_widget,\n+                    self.html_initial_name,\n+                )\n+                try:\n+                    initial_value = field.to_python(initial_value)\n+                except ValidationError:\n+                    # Always assume data has changed if validation fails.\n+                    return True\n         else:\n             initial_value = self.initial\n         return field.has_changed(initial_value, self.data)\n+        return field.has_changed(initial_value, self.data)\n \n     def label_tag(self, contents=None, attrs=None, label_suffix=None, tag=None):\n         \"\"\"\n@@ -251,8 +260,22 @@ class BoundField:\n         return widget.id_for_label(id_)\n \n     @cached_property\n-    def initial(self):\n-        return self.form.get_initial_for_field(self.field, self.name)\n+\n+    def _has_changed(self, initial, data):\n+        \"\"\"Return True if data differs from initial.\"\"\"\n+        # Always check for changes using the current initial value\n+        # if the field has a callable initial to avoid using stale cached values\n+        if callable(self.field.initial):\n+            initial_value = self.initial\n+        else:\n+            initial_value = initial\n+        \n+        # For purposes of seeing whether something has changed, None is\n+        # the same as an empty string, if the data or initial value we get\n+        # is None, replace it with ''.\n+        initial_value = initial_value if initial_value is not None else ''\n+        data_value = data if data is not None else ''\n+        return initial_value != data_value\n \n     def build_widget_attrs(self, attrs, widget=None):\n         widget = widget or self.field.widget\ndiff --git a/django/forms/fields.py b/django/forms/fields.py\nindex 46de2f53a0..288f78c3db 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -101,7 +101,27 @@ class Field:\n         initial=None,\n         help_text=\"\",\n         error_messages=None,\n-        show_hidden_initial=False,\n+\n+    def _has_changed(self, initial, data):\n+        \"\"\"Return True if data differs from initial.\"\"\"\n+        # Always return False if the field is disabled since self.bound_data\n+        # always uses the initial value in this case.\n+        if self.field.disabled:\n+            return False\n+        try:\n+            data = self.field.to_python(data)\n+            if hasattr(self, '_initial'):\n+                # For callable defaults, use the properly evaluated initial value\n+                # instead of the cached hidden value to avoid stale data\n+                if callable(self.field.initial):\n+                    initial = self.initial\n+                else:\n+                    initial = self._initial\n+            else:\n+                initial = self.field.to_python(initial)\n+            return self.field.has_changed(initial, data)\n+        except ValidationError:\n+            return True\n         validators=(),\n         localize=False,\n         disabled=False,\n@@ -131,6 +151,7 @@ class Field:\n         # label_suffix -- Suffix to be added to the label. Overrides\n         #                 form's label_suffix.\n         self.required, self.label, self.initial = required, label, initial\n+\n         self.show_hidden_initial = show_hidden_initial\n         self.help_text = help_text\n         self.disabled = disabled\ndiff --git a/django/forms/forms.py b/django/forms/forms.py\nindex 6884e6e724..6fe6af21ae 100644\n--- a/django/forms/forms.py\n+++ b/django/forms/forms.py\n@@ -517,9 +517,23 @@ class BaseForm(RenderableFormMixin):\n         Return initial data for field on form. Use initial data from the form\n         or the field, in that order. Evaluate callable values.\n         \"\"\"\n-        value = self.initial.get(field_name, field.initial)\n-        if callable(value):\n-            value = value()\n+\n+    def _has_changed(self, initial, data):\n+        \"\"\"Return True if data differs from initial.\"\"\"\n+        # Always check for changes if the field has a callable initial value\n+        # to avoid using stale cached values from hidden inputs\n+        if callable(self.field.initial):\n+            initial_value = self.initial\n+        else:\n+            # For fields with show_hidden_initial=True, the initial value may be\n+            # None if the form bound data was erroneous.\n+            if self.form._widget_data_value(self.field.widget, self.html_initial_name) is not None:\n+                initial_value = self.field.widget.value_from_datadict(\n+                    self.form.data, self.form.files, self.html_initial_name,\n+                )\n+            else:\n+                initial_value = initial\n+        return self.field.has_changed(initial_value, data)\n         # If this is an auto-generated default date, nix the microseconds\n         # for standardized handling. See #22502.\n         if (\n",
    "variant_8": "diff --git a/django/forms/boundfield.py b/django/forms/boundfield.py\nindex 9f2ae59ab4..a396b15906 100644\n--- a/django/forms/boundfield.py\n+++ b/django/forms/boundfield.py\n@@ -136,22 +136,31 @@ class BoundField:\n             data = self.field.bound_data(self.data, data)\n         return self.field.prepare_value(data)\n \n+    def _has_changed(self):\n+        field = self.field\n+\n     def _has_changed(self):\n         field = self.field\n         if field.show_hidden_initial:\n-            hidden_widget = field.hidden_widget()\n-            initial_value = self.form._widget_data_value(\n-                hidden_widget,\n-                self.html_initial_name,\n-            )\n-            try:\n-                initial_value = field.to_python(initial_value)\n-            except ValidationError:\n-                # Always assume data has changed if validation fails.\n-                return True\n+            # For callable defaults like default=list, use the properly evaluated\n+            # initial value instead of cached hidden widget data\n+            if callable(field.initial):\n+                initial_value = self.initial\n+            else:\n+                hidden_widget = field.hidden_widget()\n+                initial_value = self.form._widget_data_value(\n+                    hidden_widget,\n+                    self.html_initial_name,\n+                )\n+                try:\n+                    initial_value = field.to_python(initial_value)\n+                except ValidationError:\n+                    # Always assume data has changed if validation fails.\n+                    return True\n         else:\n             initial_value = self.initial\n         return field.has_changed(initial_value, self.data)\n+        return field.has_changed(initial_value, self.data)\n \n     def label_tag(self, contents=None, attrs=None, label_suffix=None, tag=None):\n         \"\"\"\n@@ -251,8 +260,37 @@ class BoundField:\n         return widget.id_for_label(id_)\n \n     @cached_property\n-    def initial(self):\n-        return self.form.get_initial_for_field(self.field, self.name)\n+\n+    def _has_changed(self, initial, data):\n+        \"\"\"Return True if data differs from initial.\"\"\"\n+        # Always show when we have no initial data\n+        # For cases where initial was provided, check if we have a change\n+        if initial is None:\n+            return bool(data)\n+        \n+        # Handle callable defaults properly by using evaluated initial value\n+        if callable(self.field.initial):\n+            # Use the properly evaluated initial value instead of cached hidden value\n+            initial = self.initial\n+        \n+        # For a MultiValueField, compare each field individually.\n+        if hasattr(self.field, 'fields'):\n+            if self.form.is_bound:\n+                widget = self.field.widget\n+                data = widget.decompress(data)\n+            if not isinstance(initial, list):\n+                initial = widget.decompress(initial)\n+            if len(data) != len(initial):\n+                return True\n+            for field, initial, data in zip(self.field.fields, initial, data):\n+                try:\n+                    initial = field.to_python(initial)\n+                except ValidationError:\n+                    return True\n+                if field.has_changed(initial, data):\n+                    return True\n+            return False\n+        return self.field.has_changed(initial, data)\n \n     def build_widget_attrs(self, attrs, widget=None):\n         widget = widget or self.field.widget\ndiff --git a/django/forms/fields.py b/django/forms/fields.py\nindex 46de2f53a0..ace85b855b 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -101,7 +101,30 @@ class Field:\n         initial=None,\n         help_text=\"\",\n         error_messages=None,\n-        show_hidden_initial=False,\n+\n+    def _has_changed(self, initial, data):\n+        \"\"\"Return True if data differs from initial.\"\"\"\n+        # Always return False if the field is disabled since self.data is\n+        # not updated in the form.clean() method.\n+        if self.field.disabled:\n+            return False\n+        try:\n+            data = self.field.to_python(data)\n+            if hasattr(self, '_coerce'):\n+                return self._coerce(data) != self._coerce(initial)\n+        except ValidationError:\n+            return True\n+        # For purposes of seeing whether something has changed, None is\n+        # the same as an empty string, if the data or initial value we get\n+        # is None, replace it with ''.\n+        initial_value = initial\n+        if callable(self.field.initial):\n+            initial_value = self.initial\n+        if initial_value is None:\n+            initial_value = ''\n+        if data is None:\n+            data = ''\n+        return initial_value != data\n         validators=(),\n         localize=False,\n         disabled=False,\n@@ -131,6 +154,7 @@ class Field:\n         # label_suffix -- Suffix to be added to the label. Overrides\n         #                 form's label_suffix.\n         self.required, self.label, self.initial = required, label, initial\n+\n         self.show_hidden_initial = show_hidden_initial\n         self.help_text = help_text\n         self.disabled = disabled\ndiff --git a/django/forms/forms.py b/django/forms/forms.py\nindex 6884e6e724..d8cc38111e 100644\n--- a/django/forms/forms.py\n+++ b/django/forms/forms.py\n@@ -517,9 +517,37 @@ class BaseForm(RenderableFormMixin):\n         Return initial data for field on form. Use initial data from the form\n         or the field, in that order. Evaluate callable values.\n         \"\"\"\n-        value = self.initial.get(field_name, field.initial)\n-        if callable(value):\n-            value = value()\n+\n+    def _has_changed(self, initial, data):\n+        \"\"\"Return True if data differs from initial.\"\"\"\n+        # Always check if data is empty and initial is not, or vice versa.\n+        if initial is None:\n+            initial_value = ''\n+        else:\n+            initial_value = initial\n+        if hasattr(self, '_initial_value'):\n+            initial_value = self._initial_value\n+        \n+        # For fields with callable initial values, use the properly evaluated initial\n+        # instead of potentially stale hidden values\n+        if callable(self.field.initial):\n+            initial_value = self.initial\n+        elif self.form.show_hidden_initial:\n+            warnings.warn(\n+                'show_hidden_initial is deprecated and will be removed in Django 5.0.',\n+                RemovedInDjango50Warning,\n+                stacklevel=2,\n+            )\n+            initial_prefixed_name = self.form.add_initial_prefix(self.name)\n+            hidden_widget = self.field.hidden_widget()\n+            try:\n+                initial_value = self.form.data[initial_prefixed_name]\n+            except KeyError:\n+                # A missing value means False for a checkbox, for example.\n+                initial_value = ''\n+        return self.field.widget.value_omitted_from_data(\n+            self.form.data, self.form.files, self.html_name,\n+        ) or self.field.widget._has_changed(initial_value, data)\n         # If this is an auto-generated default date, nix the microseconds\n         # for standardized handling. See #22502.\n         if (\n"
  }
}