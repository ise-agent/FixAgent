{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/django/django/template/autoreload.py lines 43-46)": "\n@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\ndef watch_for_template_changes(sender, **kwargs):\n    for directory in get_template_directories():\n        # Skip directories that are likely project roots to avoid watching too many files\n        directory_path = Path(directory)\n        \n        # Check if this directory contains common project root indicators\n        is_project_root = (\n            (directory_path / 'manage.py').exists() or\n            (directory_path / 'settings.py').exists() or\n            any((directory_path / name).exists() for name in ['setup.py', 'pyproject.toml', '.git'])\n        )\n        \n        if is_project_root:\n            # For project roots, only watch common template file extensions\n            # instead of all files to avoid performance issues\n            for pattern in ['**/*.html', '**/*.txt', '**/*.xml']:\n                sender.watch_dir(directory, pattern)\n        else:\n            # For dedicated template directories, watch all files as before\n            sender.watch_dir(directory, '**/*')\n",
    "Location 2 (/root/hy/projects_2/django/django/template/autoreload.py lines 12-32)": "\n@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\ndef watch_for_template_changes(sender, **kwargs):\n    template_dirs = get_template_directories()\n    # Filter out directories that are too broad (like project root)\n    cwd = Path.cwd()\n    filtered_dirs = set()\n    \n    for template_dir in template_dirs:\n        # Skip if directory is the current working directory (project root)\n        if template_dir.resolve() == cwd.resolve():\n            continue\n        # Skip if directory contains manage.py (likely project root)\n        if (template_dir / 'manage.py').exists():\n            continue\n        # Skip if directory is a parent of cwd (broader than project)\n        try:\n            cwd.relative_to(template_dir)\n            continue  # template_dir is a parent of cwd, skip it\n        except ValueError:\n            pass  # template_dir is not a parent of cwd, safe to include\n        \n        filtered_dirs.add(template_dir)\n    \n    for directory in filtered_dirs:\n        sender.watch_dir(directory, '**/*.html')  # More restrictive pattern\n",
    "Location 3 (/root/hy/projects_2/django/django/utils/autoreload.py lines 276-288)": "\ndef watch_for_template_changes(sender, **kwargs):\n    for directory in get_template_directories():\n        # Skip directories that are too broad (like project roots)\n        # Check if directory contains common project files indicating it's a root\n        if any((directory / marker).exists() for marker in ['manage.py', 'setup.py', '.git']):\n            continue\n        \n        # Check if directory is the current working directory or a parent of it\n        try:\n            cwd = Path.cwd()\n            if directory == cwd or directory in cwd.parents:\n                continue\n        except (OSError, RuntimeError):\n            pass\n        \n        # Use a more specific pattern for template files instead of watching everything\n        autoreload.watch_dir(directory, '**/*.html')\n        autoreload.watch_dir(directory, '**/*.txt')\n        autoreload.watch_dir(directory, '**/*.xml')\n        autoreload.watch_dir(directory, '**/*.json')\n",
    "Location 4 (/root/hy/projects_2/django/django/utils/autoreload.py lines 166-193)": "\ndef watch_for_template_changes():\n    template_dirs = get_template_directories()\n    # Filter out overly broad directories like project roots\n    filtered_dirs = []\n    for template_dir in template_dirs:\n        # Skip if directory contains manage.py (likely project root)\n        if (template_dir / 'manage.py').exists():\n            continue\n        # Skip if directory is current working directory (likely project root)\n        if template_dir.resolve() == Path.cwd().resolve():\n            continue\n        # Skip if directory contains settings.py (likely project root)\n        if any((template_dir / f).exists() for f in ['settings.py', 'settings']):\n            continue\n        filtered_dirs.append(template_dir)\n    \n    for template_dir in filtered_dirs:\n        autoreload.watch_dir(template_dir, '**/*.html')\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/django/django/template/autoreload.py lines 43-46)": [
      "\n@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\ndef watch_for_template_changes(sender, **kwargs):\n    for directory in get_template_directories():\n        # Skip directories that are likely project roots to prevent excessive file watching\n        if _is_project_root(directory):\n            # For project roots, only watch common template file patterns\n            sender.watch_dir(directory, '**/*.html')\n            sender.watch_dir(directory, '**/*.txt')\n        else:\n            sender.watch_dir(directory, '**/*')\n\n\ndef _is_project_root(directory):\n    \"\"\"Check if a directory appears to be a Django project root.\"\"\"\n    directory = Path(directory)\n    \n    # Check for common Django project files\n    django_files = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n    if any((directory / file).exists() for file in django_files):\n        return True\n    \n    # Check if directory contains a settings module/package\n    if (directory / 'settings').is_dir() or any(directory.glob('*/settings.py')):\n        return True\n        \n    return False\n",
      "\n@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\ndef watch_for_template_changes(sender, **kwargs):\n    for directory in get_template_directories():\n        # Skip directories that are likely project roots to avoid watching too many files\n        if _is_project_root(directory):\n            # For project roots, only watch common template file extensions\n            sender.watch_dir(directory, '**/*.html')\n            sender.watch_dir(directory, '**/*.txt')\n        else:\n            sender.watch_dir(directory, '**/*')\n\n\ndef _is_project_root(directory):\n    \"\"\"Check if a directory appears to be a Django project root.\"\"\"\n    directory = Path(directory)\n    \n    # Check for common Django project files\n    django_files = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n    if any((directory / filename).exists() for filename in django_files):\n        return True\n    \n    # Check if directory contains a settings module/package\n    if (directory / 'settings').exists() or any(\n        (directory / name).is_dir() and (directory / name / 'settings.py').exists()\n        for name in directory.iterdir() if name.is_dir()\n    ):\n        return True\n    \n    return False\n",
      "\n@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\ndef watch_for_template_changes(sender, **kwargs):\n    for directory in get_template_directories():\n        # Skip watching directories that are likely project roots to prevent\n        # performance issues from recursively watching entire projects\n        if _is_project_root(directory):\n            # For project roots, only watch template files specifically\n            sender.watch_dir(directory, '**/*.html')\n            sender.watch_dir(directory, '**/*.txt')\n        else:\n            sender.watch_dir(directory, '**/*')\n\n\ndef _is_project_root(directory):\n    \"\"\"Check if a directory appears to be a Django project root.\"\"\"\n    directory = Path(directory)\n    \n    # Check for common Django project files\n    django_files = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n    if any((directory / file).exists() for file in django_files):\n        return True\n    \n    # Check if directory contains a settings module structure\n    if any((directory / name / 'settings.py').exists() \n           for name in directory.iterdir() \n           if name.is_dir() and not name.name.startswith('.')):\n        return True\n    \n    return False\n",
      "\n@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\ndef watch_for_template_changes(sender, **kwargs):\n    for directory in get_template_directories():\n        # Skip watching directories that are likely project roots to prevent\n        # overwhelming the file watcher with too many files\n        if _is_project_root(directory):\n            # For project roots, only watch common template file patterns\n            sender.watch_dir(directory, '**/*.html')\n            sender.watch_dir(directory, '**/*.txt')  # For email templates\n        else:\n            sender.watch_dir(directory, '**/*')\n\n\ndef _is_project_root(directory):\n    \"\"\"\n    Check if a directory appears to be a Django project root.\n    Project roots typically contain manage.py or are the current working directory.\n    \"\"\"\n    directory = Path(directory)\n    \n    # Check if directory contains common Django project files\n    if (directory / 'manage.py').exists():\n        return True\n    \n    # Check if directory is the current working directory (common for BASE_DIR)\n    try:\n        if directory.resolve() == Path.cwd().resolve():\n            return True\n    except (OSError, RuntimeError):\n        pass\n    \n    # Check if directory has an unusually large number of subdirectories\n    # which might indicate it's a project root\n    try:\n        subdirs = [p for p in directory.iterdir() if p.is_dir()]\n        if len(subdirs) > 10:  # Arbitrary threshold for \"too many\" subdirectories\n            return True\n    except (OSError, PermissionError):\n        pass\n    \n    return False\n",
      "\n@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\ndef watch_for_template_changes(sender, **kwargs):\n    for directory in get_template_directories():\n        # Skip watching directories that are likely project roots to prevent\n        # performance issues from recursive watching of entire projects\n        if _is_project_root(directory):\n            # For project roots, only watch template files directly\n            sender.watch_dir(directory, '*.html')\n            sender.watch_dir(directory, '*.txt')\n        else:\n            # For dedicated template directories, watch all files recursively\n            sender.watch_dir(directory, '**/*')\n\n\ndef _is_project_root(directory):\n    \"\"\"Check if a directory appears to be a Django project root.\"\"\"\n    directory = Path(directory)\n    \n    # Check for common Django project files\n    django_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n    for indicator in django_indicators:\n        if (directory / indicator).exists():\n            return True\n    \n    # Check if it's a common project structure (has apps, config dirs)\n    common_dirs = ['apps', 'config', 'static', 'media', 'requirements']\n    indicator_count = sum(1 for dirname in common_dirs if (directory / dirname).exists())\n    if indicator_count >= 2:\n        return True\n    \n    # Check if it's the current working directory (often the project root)\n    try:\n        if directory.resolve() == Path.cwd().resolve():\n            return True\n    except (OSError, RuntimeError):\n        pass\n    \n    return False\n",
      "\n@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\ndef watch_for_template_changes(sender, **kwargs):\n    for directory in get_template_directories():\n        # Skip watching directories that are likely project roots to prevent\n        # performance issues from recursive watching of entire projects\n        if _is_project_root_directory(directory):\n            continue\n        sender.watch_dir(directory, '**/*.html')\n\n\ndef _is_project_root_directory(directory):\n    \"\"\"\n    Check if a directory appears to be a Django project root.\n    Project roots typically contain manage.py and should not be watched\n    recursively as they can contain thousands of non-template files.\n    \"\"\"\n    directory = Path(directory)\n    \n    # Check if directory contains typical Django project files\n    project_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n    if any((directory / indicator).exists() for indicator in project_indicators):\n        return True\n    \n    # Check if directory is the current working directory (common for BASE_DIR)\n    try:\n        if directory.resolve() == Path.cwd().resolve():\n            return True\n    except (OSError, ValueError):\n        pass\n    \n    return False\n",
      "\n@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\ndef watch_for_template_changes(sender, **kwargs):\n    for directory in get_template_directories():\n        # Skip watching directories that are too broad (e.g., project root)\n        if _is_project_root_or_too_broad(directory):\n            # For broad directories, only watch template files specifically\n            sender.watch_dir(directory, '**/*.html')\n            sender.watch_dir(directory, '**/*.txt')\n        else:\n            sender.watch_dir(directory, '**/*')\n\n\ndef _is_project_root_or_too_broad(directory):\n    \"\"\"\n    Check if a directory is likely a project root or contains too many files\n    to watch efficiently.\n    \"\"\"\n    directory = Path(directory)\n    \n    # Check if directory contains common Django project files\n    project_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n    if any((directory / indicator).exists() for indicator in project_indicators):\n        return True\n    \n    # Check if directory is the current working directory\n    if directory.resolve() == Path.cwd().resolve():\n        return True\n    \n    # Check if directory has too many immediate subdirectories (heuristic)\n    try:\n        subdirs = [p for p in directory.iterdir() if p.is_dir()]\n        if len(subdirs) > 10:  # Arbitrary threshold\n            return True\n    except (OSError, PermissionError):\n        pass\n    \n    return False\n",
      "\n@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\ndef watch_for_template_changes(sender, **kwargs):\n    for directory in get_template_directories():\n        # Skip watching directories that are likely project roots to prevent\n        # overwhelming the file watcher with too many files\n        if _is_project_root(directory):\n            # For project roots, only watch template files specifically\n            sender.watch_dir(directory, '**/*.html')\n            sender.watch_dir(directory, '**/*.txt')\n        else:\n            sender.watch_dir(directory, '**/*')\n\n\ndef _is_project_root(directory):\n    \"\"\"\n    Check if a directory appears to be a Django project root.\n    Project roots typically contain manage.py and should not be watched recursively.\n    \"\"\"\n    directory = Path(directory)\n    \n    # Check if directory contains common Django project files\n    if (directory / 'manage.py').exists():\n        return True\n    \n    # Check if directory contains settings module indicators\n    if any((directory / name).exists() for name in ['settings.py', 'settings']):\n        return True\n    \n    # Check if this is the current working directory (common for project roots)\n    try:\n        if directory.resolve() == Path.cwd().resolve():\n            return True\n    except (OSError, RuntimeError):\n        pass\n    \n    return False\n"
    ],
    "Location 2 (/root/hy/projects_2/django/django/template/autoreload.py lines 12-32)": [
      "\n@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\ndef watch_for_template_changes(sender, **kwargs):\n    for directory in get_template_directories():\n        # Skip watching directories that are too broad (like project root)\n        # to prevent overwhelming the file watcher\n        if _is_overly_broad_directory(directory):\n            continue\n        sender.watch_dir(directory, '**/*')\n\n\ndef _is_overly_broad_directory(directory):\n    \"\"\"\n    Check if a directory is too broad to watch recursively.\n    Returns True for directories that are likely project roots or contain\n    too many files/subdirectories.\n    \"\"\"\n    try:\n        # Convert to Path object if it isn't already\n        path = Path(directory)\n        \n        # Check if this is the current working directory (likely project root)\n        if path.resolve() == Path.cwd().resolve():\n            return True\n            \n        # Check if directory contains common project root indicators\n        project_indicators = ['manage.py', 'setup.py', 'pyproject.toml', '.git']\n        if any((path / indicator).exists() for indicator in project_indicators):\n            return True\n            \n        # Count immediate subdirectories - if too many, it's likely too broad\n        try:\n            subdirs = [p for p in path.iterdir() if p.is_dir()]\n            if len(subdirs) > 20:  # Threshold for \"too many\" subdirectories\n                return True\n        except (OSError, PermissionError):\n            # If we can't read the directory, don't watch it\n            return True\n            \n    except (OSError, TypeError):\n        # If path operations fail, err on the side of caution\n        return True\n        \n    return False\n",
      "\n@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\ndef watch_for_template_changes(sender, **kwargs):\n    for directory in get_template_directories():\n        # Skip watching directories that are project roots or too broad\n        if _is_overly_broad_directory(directory):\n            continue\n        sender.watch_dir(directory, '**/*')\n\n\ndef _is_overly_broad_directory(directory):\n    \"\"\"\n    Check if a directory is too broad to watch recursively.\n    Returns True if the directory should not be watched to prevent\n    performance issues with the autoreload system.\n    \"\"\"\n    try:\n        directory = Path(directory)\n        cwd = Path.cwd()\n        \n        # Don't watch the current working directory (project root)\n        if directory.resolve() == cwd.resolve():\n            return True\n            \n        # Don't watch parent directories of the current working directory\n        try:\n            cwd.relative_to(directory)\n            return True\n        except ValueError:\n            pass\n            \n        # Don't watch directories that contain manage.py (Django project roots)\n        if (directory / 'manage.py').exists():\n            return True\n            \n        # Don't watch directories with too many immediate subdirectories\n        if directory.is_dir():\n            subdir_count = sum(1 for item in directory.iterdir() if item.is_dir())\n            if subdir_count > 20:  # Configurable threshold\n                return True\n                \n    except (OSError, ValueError):\n        # If we can't access the directory, don't watch it\n        return True\n        \n    return False\n",
      "\ndef get_template_directories():\n    # Iterate through each template backend and find\n    # any template_loader that has a 'get_dirs' method.\n    # Collect the directories, filtering out Django templates.\n    cwd = Path.cwd()\n    items = set()\n    for backend in engines.all():\n        if not isinstance(backend, DjangoTemplates):\n            continue\n\n        # Filter out directories that are too broad (like project root)\n        for dir in backend.engine.dirs:\n            dir_path = cwd / to_path(dir)\n            # Skip if directory is the current working directory (project root)\n            # or contains manage.py (indicating it's a Django project root)\n            if (dir_path.resolve() == cwd.resolve() or \n                (dir_path / 'manage.py').exists()):\n                continue\n            items.add(dir_path)\n\n        for loader in backend.engine.template_loaders:\n            if not hasattr(loader, 'get_dirs'):\n                continue\n            for directory in loader.get_dirs():\n                if is_django_path(directory):\n                    continue\n                dir_path = cwd / to_path(directory)\n                # Skip if directory is the current working directory (project root)\n                # or contains manage.py (indicating it's a Django project root)\n                if (dir_path.resolve() == cwd.resolve() or \n                    (dir_path / 'manage.py').exists()):\n                    continue\n                items.add(dir_path)\n    return items\n",
      "\n@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\ndef watch_for_template_changes(sender, **kwargs):\n    for directory in get_template_directories():\n        # Skip watching directories that are too broad (like project root)\n        # to prevent overwhelming the file watcher\n        if is_project_root_directory(directory):\n            # Watch only template files in project root, not everything\n            sender.watch_file(directory / '**/*.html', directory)\n            sender.watch_file(directory / '**/*.txt', directory)\n        else:\n            sender.watch_dir(directory, '**/*')\n\n\ndef is_project_root_directory(directory):\n    \"\"\"\n    Check if a directory appears to be a Django project root that shouldn't\n    be watched recursively to avoid performance issues.\n    \"\"\"\n    directory = Path(directory)\n    \n    # Check if it's the current working directory (common case)\n    if directory.resolve() == Path.cwd().resolve():\n        return True\n    \n    # Check for common Django project files that indicate project root\n    django_project_markers = [\n        'manage.py',\n        'settings.py',\n        'wsgi.py',\n        'asgi.py',\n    ]\n    \n    for marker in django_project_markers:\n        if (directory / marker).exists():\n            return True\n    \n    # Check if directory contains a settings module/package\n    if (directory / 'settings').is_dir():\n        return True\n    \n    return False\n",
      "\n@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\ndef watch_for_template_changes(sender, **kwargs):\n    for directory in get_template_directories():\n        # Skip directories that are too broad (like project root)\n        # to prevent overwhelming the file watcher\n        if _is_overly_broad_directory(directory):\n            continue\n        sender.watch_dir(directory, '**/*')\n\n\ndef _is_overly_broad_directory(directory):\n    \"\"\"\n    Check if a directory is too broad to watch recursively.\n    Returns True for directories that would cause performance issues.\n    \"\"\"\n    try:\n        path = Path(directory)\n        cwd = Path.cwd()\n        \n        # Don't watch the current working directory (project root)\n        if path.resolve() == cwd.resolve():\n            return True\n            \n        # Don't watch parent directories of the current working directory\n        if cwd.is_relative_to(path):\n            return True\n            \n        # Check for common project root indicators\n        project_indicators = ['manage.py', 'setup.py', 'pyproject.toml', '.git']\n        if any((path / indicator).exists() for indicator in project_indicators):\n            return True\n            \n        return False\n    except (OSError, ValueError):\n        # If we can't analyze the directory, err on the side of caution\n        return True\n",
      "\ndef watch_for_template_changes():\n    template_dirs = get_template_directories()\n    # Filter out directories that are too broad to watch efficiently\n    filtered_dirs = set()\n    cwd = Path.cwd()\n    \n    for directory in template_dirs:\n        # Skip if directory is the project root or contains it\n        try:\n            if directory == cwd or cwd in directory.parents:\n                continue\n            # Skip if directory contains manage.py (likely project root)\n            if (directory / 'manage.py').exists():\n                continue\n            # Skip very large directories by checking immediate subdirectory count\n            if directory.exists() and directory.is_dir():\n                subdir_count = sum(1 for item in directory.iterdir() if item.is_dir())\n                if subdir_count > 50:  # Arbitrary threshold for \"too many\" subdirs\n                    continue\n            filtered_dirs.add(directory)\n        except (OSError, PermissionError):\n            # Skip directories we can't access\n            continue\n    \n    # Use more specific glob pattern for templates\n    for directory in filtered_dirs:\n        watch_dir(directory, '**/*.html')\n        watch_dir(directory, '**/*.txt')\n        watch_dir(directory, '**/*.xml')\n",
      "\n@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\ndef watch_for_template_changes(sender, **kwargs):\n    cwd = Path.cwd()\n    for directory in get_template_directories():\n        # Skip directories that are project roots or overly broad\n        try:\n            # Check if directory is the project root or contains it\n            if directory == cwd or cwd.is_relative_to(directory):\n                continue\n            # Check if directory contains common project files indicating it's a root\n            if any((directory / marker).exists() for marker in ['manage.py', 'settings.py', 'wsgi.py']):\n                continue\n        except (OSError, ValueError):\n            # Skip directories that can't be processed\n            continue\n        sender.watch_dir(directory, '**/*.html')\n",
      "\ndef get_template_directories():\n    # Iterate through each template backend and find\n    # any template_loader that has a 'get_dirs' method.\n    # Collect the directories, filtering out Django templates.\n    cwd = Path.cwd()\n    items = set()\n    for backend in engines.all():\n        if not isinstance(backend, DjangoTemplates):\n            continue\n\n        # Filter out directories that are too broad (like project root)\n        for dir in backend.engine.dirs:\n            dir_path = cwd / to_path(dir)\n            # Skip if directory is the current working directory (project root)\n            # or if it's a parent of cwd (even broader)\n            if dir_path == cwd or cwd.is_relative_to(dir_path):\n                continue\n            items.add(dir_path)\n\n        for loader in backend.engine.template_loaders:\n            if not hasattr(loader, 'get_dirs'):\n                continue\n            for directory in loader.get_dirs():\n                if is_django_path(directory):\n                    continue\n                dir_path = cwd / to_path(directory)\n                # Skip if directory is the current working directory (project root)\n                # or if it's a parent of cwd (even broader)\n                if dir_path == cwd or cwd.is_relative_to(dir_path):\n                    continue\n                items.add(dir_path)\n    return items\n"
    ],
    "Location 3 (/root/hy/projects_2/django/django/utils/autoreload.py lines 276-288)": [
      "\ndef watch_for_template_changes():\n    for template_dir in get_template_directories():\n        # Skip watching directories that are likely project roots or too broad\n        if _is_problematic_watch_dir(template_dir):\n            logger.debug(\n                'Skipping template directory %s as it appears to be a project root '\n                'or overly broad directory that could cause performance issues.',\n                template_dir\n            )\n            continue\n        autoreload.watch_dir(template_dir, '**/*.html')\n\n\ndef _is_problematic_watch_dir(path):\n    \"\"\"\n    Check if a directory should not be watched due to being too broad.\n    Returns True if the directory is likely a project root or contains\n    too many files/subdirectories to watch efficiently.\n    \"\"\"\n    try:\n        path_obj = Path(path)\n        # Check if this is the current working directory or a parent of it\n        cwd = Path.cwd()\n        if path_obj == cwd or path_obj in cwd.parents:\n            return True\n        \n        # Check for common project root indicators\n        project_indicators = ['manage.py', 'setup.py', 'pyproject.toml', '.git']\n        if any((path_obj / indicator).exists() for indicator in project_indicators):\n            return True\n            \n        # Check if directory has too many immediate subdirectories (heuristic)\n        if path_obj.is_dir():\n            subdirs = [p for p in path_obj.iterdir() if p.is_dir()]\n            if len(subdirs) > 20:  # Configurable threshold\n                return True\n                \n    except (OSError, PermissionError):\n        # If we can't access the directory, it's safer to skip it\n        return True\n    \n    return False\n",
      "\ndef watch_for_template_changes(sender, **kwargs):\n    for template_dir in get_template_directories():\n        # Skip watching directories that are too broad (like project root)\n        # to prevent performance issues with recursive file watching\n        if _is_overly_broad_directory(template_dir):\n            logger.debug(\n                'Skipping template directory %s as it appears to be too broad for efficient watching',\n                template_dir\n            )\n            continue\n        sender.watch_dir(template_dir, '**/*')\n\n\ndef _is_overly_broad_directory(path):\n    \"\"\"\n    Check if a directory is too broad to watch efficiently.\n    Returns True for directories that likely contain entire projects.\n    \"\"\"\n    path = Path(path)\n    try:\n        path = path.resolve()\n    except (OSError, RuntimeError):\n        return True\n    \n    # Check if directory contains common project root indicators\n    project_indicators = ['manage.py', 'setup.py', 'pyproject.toml', '.git', '.hg', '.svn']\n    if any((path / indicator).exists() for indicator in project_indicators):\n        return True\n    \n    # Check if this is the current working directory or a parent of it\n    try:\n        cwd = Path.cwd()\n        if path == cwd or path in cwd.parents:\n            return True\n    except (OSError, RuntimeError):\n        pass\n    \n    # Check if directory has too many immediate subdirectories (heuristic)\n    try:\n        subdirs = [p for p in path.iterdir() if p.is_dir()]\n        if len(subdirs) > 20:  # Arbitrary threshold\n            return True\n    except (OSError, PermissionError):\n        return True\n    \n    return False\n",
      "\ndef watch_for_template_changes():\n    for directory in get_template_directories():\n        # Skip watching directories that are likely project roots to prevent\n        # performance issues with recursive file watching\n        if _is_project_root_directory(directory):\n            logger.debug(\n                'Skipping template directory %s as it appears to be a project root',\n                directory\n            )\n            continue\n        autoreload.watch_dir(directory, '**/*.html')\n\n\ndef _is_project_root_directory(directory):\n    \"\"\"\n    Check if a directory is likely a Django project root that shouldn't be\n    watched recursively for template changes.\n    \"\"\"\n    try:\n        directory = Path(directory)\n        if not directory.is_dir():\n            return False\n        \n        # Check for common Django project root indicators\n        project_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n        for indicator in project_indicators:\n            if (directory / indicator).exists():\n                return True\n        \n        # Check if directory contains a settings module structure\n        for item in directory.iterdir():\n            if item.is_dir() and (item / 'settings.py').exists():\n                return True\n                \n        return False\n    except (OSError, PermissionError):\n        return False\n",
      "\ndef watch_for_template_changes():\n    for directory in get_template_directories():\n        # Skip watching directories that are likely project roots to prevent\n        # performance issues with recursive file watching\n        if _is_project_root_directory(directory):\n            logger.debug(\n                'Skipping template directory %s as it appears to be a project root.',\n                directory,\n            )\n            continue\n        # Use a more restrictive glob pattern to avoid watching non-template files\n        autoreload.watch_dir(directory, '**/*.html')\n\n\ndef _is_project_root_directory(directory):\n    \"\"\"\n    Check if a directory is likely a project root that shouldn't be watched recursively.\n    \"\"\"\n    try:\n        path = Path(directory)\n        # Check if directory contains common Django project files\n        if (path / 'manage.py').exists():\n            return True\n        if (path / 'settings.py').exists():\n            return True\n        # Check if it's the current working directory (common for BASE_DIR)\n        if path.resolve() == Path.cwd().resolve():\n            return True\n        # Check if directory has too many subdirectories (heuristic)\n        subdirs = [p for p in path.iterdir() if p.is_dir()]\n        if len(subdirs) > 20:  # Arbitrary threshold\n            return True\n    except (OSError, PermissionError):\n        # If we can't access the directory, err on the side of caution\n        return True\n    return False\n",
      "\ndef watch_for_template_changes():\n    for directory in get_template_directories():\n        # Skip watching directories that are likely project roots to prevent\n        # overwhelming the file watcher with recursive monitoring\n        if _is_project_root_directory(directory):\n            logger.debug(\n                'Skipping watch on directory %s as it appears to be a project root.',\n                directory\n            )\n            continue\n        autoreload.watch_dir(directory, '**/*.html')\n\n\ndef _is_project_root_directory(directory):\n    \"\"\"\n    Check if a directory is likely a project root that shouldn't be watched recursively.\n    \"\"\"\n    directory = Path(directory)\n    \n    # Check if directory contains common project root indicators\n    project_indicators = ['manage.py', 'setup.py', 'pyproject.toml', '.git', '.gitignore']\n    for indicator in project_indicators:\n        if (directory / indicator).exists():\n            return True\n    \n    # Check if directory is the current working directory\n    try:\n        if directory.resolve() == Path.cwd().resolve():\n            return True\n    except (OSError, RuntimeError):\n        pass\n    \n    # Check if directory has an excessive number of subdirectories\n    try:\n        subdirs = [p for p in directory.iterdir() if p.is_dir()]\n        if len(subdirs) > 20:  # Arbitrary threshold for \"too many\" subdirectories\n            return True\n    except (OSError, PermissionError):\n        pass\n    \n    return False\n",
      "\ndef watch_for_template_changes(sender, **kwargs):\n    for directory in get_template_directories():\n        # Skip directories that are likely project roots to avoid performance issues\n        if _is_project_root(directory):\n            logger.debug('Skipping template directory %s as it appears to be a project root', directory)\n            continue\n        # Use a more restrictive pattern to avoid watching too many files\n        sender.watch_dir(directory, '**/*.html')\n\n\ndef _is_project_root(directory):\n    \"\"\"\n    Check if a directory is likely a project root that shouldn't be watched recursively.\n    \"\"\"\n    directory = Path(directory)\n    \n    # Check if directory contains common Django project files\n    project_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n    if any((directory / indicator).exists() for indicator in project_indicators):\n        return True\n    \n    # Check if directory is the current working directory\n    try:\n        if directory.resolve() == Path.cwd().resolve():\n            return True\n    except (OSError, RuntimeError):\n        pass\n    \n    # Check if directory has too many subdirectories (likely a project root)\n    try:\n        subdirs = [p for p in directory.iterdir() if p.is_dir()]\n        if len(subdirs) > 10:  # Arbitrary threshold\n            return True\n    except (OSError, PermissionError):\n        pass\n    \n    return False\n",
      "\ndef watch_for_template_changes():\n    for directory in get_template_directories():\n        # Skip directories that are likely project roots to avoid watching too many files\n        if _is_project_root_directory(directory):\n            logger.debug(\n                'Skipping template directory %s as it appears to be a project root.',\n                directory\n            )\n            continue\n        autoreload.watch_dir(directory, '**/*.html')\n\n\ndef _is_project_root_directory(directory):\n    \"\"\"\n    Check if a directory appears to be a Django project root that shouldn't\n    be watched recursively to avoid performance issues.\n    \"\"\"\n    try:\n        path = Path(directory).resolve()\n        \n        # Check if directory contains common Django project files\n        project_markers = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n        if any((path / marker).exists() for marker in project_markers):\n            return True\n            \n        # Check if it's the current working directory (likely project root)\n        if path == Path.cwd():\n            return True\n            \n        # Check if directory has too many subdirectories (heuristic for project root)\n        try:\n            subdirs = [p for p in path.iterdir() if p.is_dir()]\n            if len(subdirs) > 10:  # Arbitrary threshold\n                return True\n        except (OSError, PermissionError):\n            pass\n            \n        return False\n    except (OSError, ValueError):\n        return False\n",
      "\ndef watch_for_template_changes():\n    for directory in get_template_directories():\n        # Skip watching directories that are likely project roots to prevent\n        # performance issues with recursive file watching\n        if _is_project_root_directory(directory):\n            logger.debug(\n                'Skipping template directory %s as it appears to be a project root.',\n                directory\n            )\n            continue\n        autoreload.watch_dir(directory, '**/*.html')\n\n\ndef _is_project_root_directory(directory):\n    \"\"\"\n    Check if a directory is likely a project root that shouldn't be watched\n    recursively to avoid performance issues.\n    \"\"\"\n    directory = Path(directory)\n    \n    # Check if directory contains common Django project files\n    django_indicators = ['manage.py', 'wsgi.py', 'asgi.py', 'settings.py']\n    if any((directory / indicator).exists() for indicator in django_indicators):\n        return True\n    \n    # Check if directory is the current working directory (common for BASE_DIR)\n    try:\n        if directory.resolve() == Path.cwd().resolve():\n            return True\n    except (OSError, RuntimeError):\n        pass\n    \n    # Check if directory has an excessive number of subdirectories\n    try:\n        subdirs = [p for p in directory.iterdir() if p.is_dir()]\n        if len(subdirs) > 20:  # Arbitrary threshold for \"too many\" subdirectories\n            return True\n    except (OSError, PermissionError):\n        pass\n    \n    return False\n"
    ],
    "Location 4 (/root/hy/projects_2/django/django/utils/autoreload.py lines 166-193)": [
      "\ndef watch_for_template_changes():\n    for directory in get_template_directories():\n        # Skip watching directories that are likely project roots to prevent\n        # performance issues with recursive file watching\n        if _is_project_root_directory(directory):\n            continue\n        # Use a more specific pattern to avoid watching non-template files\n        autoreload.watch_dir(directory, '**/*.html')\n\n\ndef _is_project_root_directory(directory):\n    \"\"\"\n    Check if a directory appears to be a Django project root that would\n    cause performance issues if watched recursively.\n    \"\"\"\n    directory = Path(directory)\n    \n    # Check if directory contains typical Django project files\n    django_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n    if any((directory / indicator).exists() for indicator in django_indicators):\n        return True\n    \n    # Check if directory contains common project structure indicators\n    project_indicators = ['.git', '.gitignore', 'requirements.txt', 'setup.py']\n    if any((directory / indicator).exists() for indicator in project_indicators):\n        return True\n    \n    # Check if directory is the current working directory (often the project root)\n    if directory.resolve() == Path.cwd().resolve():\n        return True\n    \n    return False\n",
      "\ndef watch_for_template_changes(sender, **kwargs):\n    # Avoid circular import\n    from django.template.backends.django import DjangoTemplates\n\n    for backend in sender.template_engines:\n        if isinstance(backend, DjangoTemplates):\n            for template_dir in get_template_directories():\n                # Skip watching directories that are likely project roots\n                # to prevent overwhelming the file watcher\n                if _is_project_root_directory(template_dir):\n                    continue\n                # Use a more specific pattern to watch only template files\n                # instead of all files recursively\n                autoreload.watch_dir(template_dir, '**/*.html')\n\n\ndef _is_project_root_directory(directory):\n    \"\"\"\n    Check if a directory appears to be a project root that shouldn't be\n    watched recursively to avoid performance issues.\n    \"\"\"\n    try:\n        # Convert to Path object if it's a string\n        dir_path = Path(directory) if not isinstance(directory, Path) else directory\n        \n        # Check if directory contains common project root indicators\n        project_indicators = ['manage.py', 'setup.py', 'pyproject.toml', '.git']\n        has_indicators = any((dir_path / indicator).exists() for indicator in project_indicators)\n        \n        # Check if it's the current working directory or a parent of it\n        cwd = Path.cwd()\n        is_cwd_or_parent = dir_path == cwd or cwd.is_relative_to(dir_path)\n        \n        # Check if directory has too many immediate subdirectories (likely a project root)\n        try:\n            subdirs = [p for p in dir_path.iterdir() if p.is_dir()]\n            has_many_subdirs = len(subdirs) > 10\n        except (OSError, PermissionError):\n            has_many_subdirs = False\n        \n        return has_indicators or (is_cwd_or_parent and has_many_subdirs)\n    except (OSError, ValueError):\n        # If we can't analyze the directory, err on the side of caution\n        return True\n",
      "\ndef watch_for_template_changes():\n    for template_dir in get_template_directories():\n        # Skip directories that are project roots or overly broad\n        if _is_problematic_directory(template_dir):\n            # Watch only template files directly in the directory\n            autoreload.watch_file(template_dir / '*.html')\n            autoreload.watch_file(template_dir / '*.txt')\n            continue\n        autoreload.watch_dir(template_dir, '**/*')\n\n\ndef _is_problematic_directory(template_dir):\n    \"\"\"\n    Check if a template directory is too broad to watch recursively.\n    Returns True for directories that are likely project roots or contain\n    too many non-template files.\n    \"\"\"\n    # Check if directory contains Django project indicators\n    django_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n    if any((template_dir / indicator).exists() for indicator in django_indicators):\n        return True\n    \n    # Check if this is the current working directory (common project root)\n    try:\n        if template_dir.resolve() == Path.cwd().resolve():\n            return True\n    except (OSError, ValueError):\n        pass\n    \n    # Check if directory has too many subdirectories (heuristic for project root)\n    try:\n        subdirs = [p for p in template_dir.iterdir() if p.is_dir()]\n        if len(subdirs) > 10:  # Arbitrary threshold for \"too many\" subdirectories\n            return True\n    except (OSError, ValueError):\n        pass\n    \n    return False\n",
      "\ndef watch_for_template_changes():\n    for directory in get_template_directories():\n        # Skip directories that would cause excessive file watching\n        if _is_problematic_directory(directory):\n            logger.debug('Skipping template directory due to potential performance issues: %s', directory)\n            continue\n        # Use a more specific pattern to avoid watching non-template files\n        autoreload.watch_dir(directory, '**/*.html')\n        autoreload.watch_dir(directory, '**/*.txt')\n        autoreload.watch_dir(directory, '**/*.xml')\n\n\ndef _is_problematic_directory(directory):\n    \"\"\"\n    Check if a directory should be skipped for template watching to avoid\n    performance issues with recursive file monitoring.\n    \"\"\"\n    directory = Path(directory)\n    \n    # Skip if directory contains manage.py (likely project root)\n    if (directory / 'manage.py').exists():\n        return True\n    \n    # Skip if directory is current working directory or parent\n    cwd = Path.cwd()\n    try:\n        if directory.resolve() == cwd.resolve() or cwd.resolve() in directory.resolve().parents:\n            return True\n    except (OSError, ValueError):\n        pass\n    \n    # Skip very large directories (more than 1000 immediate subdirectories)\n    try:\n        subdir_count = sum(1 for item in directory.iterdir() if item.is_dir())\n        if subdir_count > 1000:\n            return True\n    except (OSError, PermissionError):\n        return True\n    \n    return False\n",
      "\ndef watch_for_template_changes():\n    template_dirs = get_template_directories()\n    # Filter out overly broad directories like project roots\n    filtered_dirs = []\n    for template_dir in template_dirs:\n        # Skip directories that are likely project roots\n        if is_project_root(template_dir):\n            # For project roots, only watch specific template subdirs if they exist\n            common_template_subdirs = ['templates', 'template']\n            for subdir_name in common_template_subdirs:\n                subdir = template_dir / subdir_name\n                if subdir.exists() and subdir.is_dir():\n                    filtered_dirs.append(subdir)\n        else:\n            filtered_dirs.append(template_dir)\n    \n    for template_dir in filtered_dirs:\n        # Use more specific pattern to avoid watching too many files\n        autoreload.watch_dir(template_dir, \"**/*.html\")\n\n\ndef is_project_root(path):\n    \"\"\"\n    Check if a directory appears to be a Django project root.\n    Project roots typically contain manage.py or common Django files.\n    \"\"\"\n    path = Path(path)\n    # Check for common Django project indicators\n    django_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n    has_indicators = any((path / indicator).exists() for indicator in django_indicators)\n    \n    # Also check if it's the current working directory (common for project roots)\n    is_cwd = path.resolve() == Path.cwd().resolve()\n    \n    # Check if directory has too many immediate subdirectories (sign of a project root)\n    try:\n        subdir_count = len([d for d in path.iterdir() if d.is_dir()])\n        has_many_subdirs = subdir_count > 10\n    except (OSError, PermissionError):\n        has_many_subdirs = False\n    \n    return has_indicators or is_cwd or has_many_subdirs\n",
      "\ndef watch_for_template_changes():\n    for directory in get_template_directories():\n        # Skip directories that are likely project roots to avoid watching\n        # too many files recursively, which can overwhelm the file watcher\n        if _is_project_root_directory(directory):\n            continue\n        # Use a more restrictive pattern for template files to limit scope\n        autoreload.watch_dir(directory, '**/*.html')\n\n\ndef _is_project_root_directory(directory):\n    \"\"\"\n    Check if a directory appears to be a Django project root that should\n    not be watched recursively to avoid performance issues.\n    \"\"\"\n    try:\n        directory_path = Path(directory)\n        # Check if directory contains common Django project files\n        has_manage_py = (directory_path / 'manage.py').exists()\n        has_settings = any((directory_path / name).exists() for name in ['settings.py', 'settings'])\n        \n        # Check if directory is the current working directory (likely project root)\n        is_cwd = directory_path.resolve() == Path.cwd().resolve()\n        \n        # Check if directory has many subdirectories (heuristic for project root)\n        try:\n            subdirs = [p for p in directory_path.iterdir() if p.is_dir()]\n            has_many_subdirs = len(subdirs) > 5\n        except (OSError, PermissionError):\n            has_many_subdirs = False\n        \n        return has_manage_py or has_settings or is_cwd or has_many_subdirs\n    except (OSError, ValueError):\n        return False\n",
      "\ndef watch_for_template_changes():\n    for directory in get_template_directories():\n        # Skip directories that are too broad to watch efficiently\n        if _is_overly_broad_directory(directory):\n            continue\n        autoreload.watch_dir(directory, '**/*')\n\n\ndef _is_overly_broad_directory(directory):\n    \"\"\"\n    Check if a directory is too broad to watch efficiently.\n    Returns True for project roots or directories with excessive subdirectories.\n    \"\"\"\n    try:\n        directory = Path(directory).resolve()\n        \n        # Check if this is likely a project root\n        project_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py', '.git', 'requirements.txt']\n        if any((directory / indicator).exists() for indicator in project_indicators):\n            return True\n            \n        # Check if directory is the current working directory\n        if directory == Path.cwd().resolve():\n            return True\n            \n        # Count immediate subdirectories - if too many, it's likely too broad\n        try:\n            subdirs = [p for p in directory.iterdir() if p.is_dir()]\n            if len(subdirs) > 20:  # Arbitrary threshold for \"too many\" subdirectories\n                return True\n        except (OSError, PermissionError):\n            # If we can't read the directory, skip it\n            return True\n            \n    except (OSError, ValueError):\n        return True\n        \n    return False\n",
      "\ndef watch_for_template_changes():\n    for directory in get_template_directories():\n        # Skip watching directories that are likely project roots to prevent\n        # performance issues with recursive file watching\n        if _is_project_root_directory(directory):\n            continue\n        # Use a more specific pattern for template files to reduce overhead\n        autoreload.watch_dir(directory, '**/*.html')\n\n\ndef _is_project_root_directory(directory):\n    \"\"\"\n    Check if a directory appears to be a Django project root that shouldn't\n    be watched recursively due to performance concerns.\n    \"\"\"\n    directory = Path(directory)\n    \n    # Check if directory contains common Django project files\n    project_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n    if any((directory / indicator).exists() for indicator in project_indicators):\n        return True\n    \n    # Check if directory is the current working directory (common for BASE_DIR)\n    try:\n        if directory.resolve() == Path.cwd().resolve():\n            return True\n    except (OSError, ValueError):\n        pass\n    \n    # Check if directory has an excessive number of subdirectories\n    try:\n        subdirs = [p for p in directory.iterdir() if p.is_dir()]\n        if len(subdirs) > 20:  # Arbitrary threshold for \"too many\" subdirectories\n            return True\n    except (OSError, PermissionError):\n        pass\n    \n    return False\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/template/autoreload.py b/django/template/autoreload.py\nindex cf1b20ba95..d8ab4ffde5 100644\n--- a/django/template/autoreload.py\n+++ b/django/template/autoreload.py\n@@ -9,6 +9,7 @@ from django.utils.autoreload import (\n )\n \n \n+\n def get_template_directories():\n     # Iterate through each template backend and find\n     # any template_loader that has a 'get_dirs' method.\n@@ -19,7 +20,11 @@ def get_template_directories():\n         if not isinstance(backend, DjangoTemplates):\n             continue\n \n-        items.update(cwd / to_path(dir) for dir in backend.engine.dirs)\n+        # Filter out problematic directories when adding from backend.engine.dirs\n+        for dir in backend.engine.dirs:\n+            dir_path = cwd / to_path(dir)\n+            # Always include the directory, but mark problematic ones for special handling\n+            items.add(dir_path)\n \n         for loader in backend.engine.template_loaders:\n             if not hasattr(loader, 'get_dirs'):\n@@ -40,10 +45,49 @@ def reset_loaders():\n             loader.reset()\n \n \n+\n @receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n def watch_for_template_changes(sender, **kwargs):\n     for directory in get_template_directories():\n-        sender.watch_dir(directory, '**/*')\n+        # Skip watching directories that are too broad (like project roots)\n+        # to prevent overwhelming the file watcher system\n+        if _is_project_root_directory(directory):\n+            # For project root directories, only watch template files specifically\n+            sender.watch_dir(directory, '**/*.html')\n+            sender.watch_dir(directory, '**/*.txt')\n+        else:\n+            sender.watch_dir(directory, '**/*')\n+\n+\n+def _is_project_root_directory(directory):\n+    \"\"\"\n+    Check if a directory appears to be a project root that would be too broad\n+    to watch recursively with '**/*' pattern.\n+    \"\"\"\n+    directory = Path(directory)\n+    \n+    # Check if directory contains common project root indicators\n+    project_indicators = ['manage.py', 'settings.py', 'setup.py', 'pyproject.toml']\n+    for indicator in project_indicators:\n+        if (directory / indicator).exists():\n+            return True\n+    \n+    # Check if it's the current working directory (common case for BASE_DIR)\n+    try:\n+        if directory.resolve() == Path.cwd().resolve():\n+            return True\n+    except (OSError, ValueError):\n+        pass\n+    \n+    # Check if directory has too many immediate subdirectories (heuristic)\n+    try:\n+        subdirs = [p for p in directory.iterdir() if p.is_dir()]\n+        if len(subdirs) > 10:  # Arbitrary threshold for \"too many\" subdirs\n+            return True\n+    except (OSError, PermissionError):\n+        pass\n+    \n+    return False\n \n \n @receiver(file_changed, dispatch_uid='template_loaders_file_changed')\ndiff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 583c2be647..38923e0c71 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -162,6 +162,8 @@ def iter_modules_and_files(modules, extra_files):\n     return frozenset(results)\n \n \n+@functools.lru_cache(maxsize=1)\n+\n @functools.lru_cache(maxsize=1)\n def common_roots(paths):\n     \"\"\"\n@@ -190,7 +192,42 @@ def common_roots(paths):\n         if not node:\n             yield Path(*path)\n \n-    return tuple(_walk(tree, ()))\n+    roots = tuple(_walk(tree, ()))\n+    \n+    # Filter out roots that would be too broad to watch efficiently\n+    filtered_roots = []\n+    for root in roots:\n+        # If a root appears to be overly broad (like a project root),\n+        # split it back into its constituent paths to avoid watching too much\n+        if _would_be_overly_broad_root(root, paths):\n+            # Instead of using the common root, use the original paths\n+            filtered_roots.extend(p for p in paths if root in p.parents or p == root)\n+        else:\n+            filtered_roots.append(root)\n+    \n+    return tuple(set(filtered_roots))\n+\n+\n+def _would_be_overly_broad_root(root, original_paths):\n+    \"\"\"\n+    Check if using this root would result in watching too many files.\n+    \"\"\"\n+    try:\n+        # If the root has many immediate subdirectories, it might be too broad\n+        subdirs = [p for p in root.iterdir() if p.is_dir()]\n+        if len(subdirs) > 20:\n+            return True\n+            \n+        # Check if it's a project root\n+        project_indicators = ['manage.py', 'setup.py', 'pyproject.toml', '.git']\n+        for indicator in project_indicators:\n+            if (root / indicator).exists():\n+                return True\n+                \n+    except (OSError, PermissionError):\n+        return True\n+        \n+    return False\n \n \n def sys_path_directories():\n@@ -273,6 +310,7 @@ class BaseReloader:\n         self.directory_globs = defaultdict(set)\n         self._stop_condition = threading.Event()\n \n+\n     def watch_dir(self, path, glob):\n         path = Path(path)\n         try:\n@@ -284,9 +322,44 @@ class BaseReloader:\n                 exc_info=True,\n             )\n             return\n+        \n+        # Add safety check to prevent watching overly broad directories\n+        # with recursive patterns that could overwhelm the file watcher\n+        if glob == '**/*' and _is_overly_broad_watch(path):\n+            logger.debug(\n+                'Skipping overly broad watch of %s with glob %s to prevent '\n+                'file watcher overload.', path, glob\n+            )\n+            return\n+            \n         logger.debug('Watching dir %s with glob %s.', path, glob)\n         self.directory_globs[path].add(glob)\n \n+\n+def _is_overly_broad_watch(path):\n+    \"\"\"\n+    Check if watching a directory would be overly broad and potentially\n+    overwhelm the file watching system.\n+    \"\"\"\n+    try:\n+        # Count immediate subdirectories as a heuristic\n+        subdirs = [p for p in path.iterdir() if p.is_dir()]\n+        # If there are many subdirectories, watching recursively could be expensive\n+        if len(subdirs) > 15:\n+            return True\n+            \n+        # Check for common project root indicators\n+        project_files = ['manage.py', 'setup.py', 'pyproject.toml', '.git']\n+        for indicator in project_files:\n+            if (path / indicator).exists():\n+                return True\n+                \n+    except (OSError, PermissionError):\n+        # If we can't read the directory, err on the side of caution\n+        return True\n+        \n+    return False\n+\n     def watched_files(self, include_globs=True):\n         \"\"\"\n         Yield all files that need to be watched, including module files and\n",
    "variant_0": "diff --git a/django/template/autoreload.py b/django/template/autoreload.py\nindex cf1b20ba95..bb9f35d696 100644\n--- a/django/template/autoreload.py\n+++ b/django/template/autoreload.py\n@@ -9,27 +9,32 @@ from django.utils.autoreload import (\n )\n \n \n-def get_template_directories():\n-    # Iterate through each template backend and find\n-    # any template_loader that has a 'get_dirs' method.\n-    # Collect the directories, filtering out Django templates.\n+\n+@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n+def watch_for_template_changes(sender, **kwargs):\n+    template_dirs = get_template_directories()\n+    # Filter out directories that are too broad (like project root)\n     cwd = Path.cwd()\n-    items = set()\n-    for backend in engines.all():\n-        if not isinstance(backend, DjangoTemplates):\n+    filtered_dirs = set()\n+    \n+    for template_dir in template_dirs:\n+        # Skip if directory is the current working directory (project root)\n+        if template_dir.resolve() == cwd.resolve():\n             continue\n-\n-        items.update(cwd / to_path(dir) for dir in backend.engine.dirs)\n-\n-        for loader in backend.engine.template_loaders:\n-            if not hasattr(loader, 'get_dirs'):\n-                continue\n-            items.update(\n-                cwd / to_path(directory)\n-                for directory in loader.get_dirs()\n-                if not is_django_path(directory)\n-            )\n-    return items\n+        # Skip if directory contains manage.py (likely project root)\n+        if (template_dir / 'manage.py').exists():\n+            continue\n+        # Skip if directory is a parent of cwd (broader than project)\n+        try:\n+            cwd.relative_to(template_dir)\n+            continue  # template_dir is a parent of cwd, skip it\n+        except ValueError:\n+            pass  # template_dir is not a parent of cwd, safe to include\n+        \n+        filtered_dirs.add(template_dir)\n+    \n+    for directory in filtered_dirs:\n+        sender.watch_dir(directory, '**/*.html')  # More restrictive pattern\n \n \n def reset_loaders():\n@@ -40,10 +45,28 @@ def reset_loaders():\n             loader.reset()\n \n \n+\n @receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n def watch_for_template_changes(sender, **kwargs):\n     for directory in get_template_directories():\n-        sender.watch_dir(directory, '**/*')\n+        # Skip directories that are likely project roots to avoid watching too many files\n+        directory_path = Path(directory)\n+        \n+        # Check if this directory contains common project root indicators\n+        is_project_root = (\n+            (directory_path / 'manage.py').exists() or\n+            (directory_path / 'settings.py').exists() or\n+            any((directory_path / name).exists() for name in ['setup.py', 'pyproject.toml', '.git'])\n+        )\n+        \n+        if is_project_root:\n+            # For project roots, only watch common template file extensions\n+            # instead of all files to avoid performance issues\n+            for pattern in ['**/*.html', '**/*.txt', '**/*.xml']:\n+                sender.watch_dir(directory, pattern)\n+        else:\n+            # For dedicated template directories, watch all files as before\n+            sender.watch_dir(directory, '**/*')\n \n \n @receiver(file_changed, dispatch_uid='template_loaders_file_changed')\ndiff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 583c2be647..7f28cca8af 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -163,34 +163,25 @@ def iter_modules_and_files(modules, extra_files):\n \n \n @functools.lru_cache(maxsize=1)\n-def common_roots(paths):\n-    \"\"\"\n-    Return a tuple of common roots that are shared between the given paths.\n-    File system watchers operate on directories and aren't cheap to create.\n-    Try to find the minimum set of directories to watch that encompass all of\n-    the files that need to be watched.\n-    \"\"\"\n-    # Inspired from Werkzeug:\n-    # https://github.com/pallets/werkzeug/blob/7477be2853df70a022d9613e765581b9411c3c39/werkzeug/_reloader.py\n-    # Create a sorted list of the path components, longest first.\n-    path_parts = sorted([x.parts for x in paths], key=len, reverse=True)\n-    tree = {}\n-    for chunks in path_parts:\n-        node = tree\n-        # Add each part of the path to the tree.\n-        for chunk in chunks:\n-            node = node.setdefault(chunk, {})\n-        # Clear the last leaf in the tree.\n-        node.clear()\n-\n-    # Turn the tree into a list of Path instances.\n-    def _walk(node, path):\n-        for prefix, child in node.items():\n-            yield from _walk(child, path + (prefix,))\n-        if not node:\n-            yield Path(*path)\n-\n-    return tuple(_walk(tree, ()))\n+\n+def watch_for_template_changes():\n+    template_dirs = get_template_directories()\n+    # Filter out overly broad directories like project roots\n+    filtered_dirs = []\n+    for template_dir in template_dirs:\n+        # Skip if directory contains manage.py (likely project root)\n+        if (template_dir / 'manage.py').exists():\n+            continue\n+        # Skip if directory is current working directory (likely project root)\n+        if template_dir.resolve() == Path.cwd().resolve():\n+            continue\n+        # Skip if directory contains settings.py (likely project root)\n+        if any((template_dir / f).exists() for f in ['settings.py', 'settings']):\n+            continue\n+        filtered_dirs.append(template_dir)\n+    \n+    for template_dir in filtered_dirs:\n+        autoreload.watch_dir(template_dir, '**/*.html')\n \n \n def sys_path_directories():\n@@ -273,19 +264,27 @@ class BaseReloader:\n         self.directory_globs = defaultdict(set)\n         self._stop_condition = threading.Event()\n \n-    def watch_dir(self, path, glob):\n-        path = Path(path)\n+\n+def watch_for_template_changes(sender, **kwargs):\n+    for directory in get_template_directories():\n+        # Skip directories that are too broad (like project roots)\n+        # Check if directory contains common project files indicating it's a root\n+        if any((directory / marker).exists() for marker in ['manage.py', 'setup.py', '.git']):\n+            continue\n+        \n+        # Check if directory is the current working directory or a parent of it\n         try:\n-            path = path.absolute()\n-        except FileNotFoundError:\n-            logger.debug(\n-                'Unable to watch directory %s as it cannot be resolved.',\n-                path,\n-                exc_info=True,\n-            )\n-            return\n-        logger.debug('Watching dir %s with glob %s.', path, glob)\n-        self.directory_globs[path].add(glob)\n+            cwd = Path.cwd()\n+            if directory == cwd or directory in cwd.parents:\n+                continue\n+        except (OSError, RuntimeError):\n+            pass\n+        \n+        # Use a more specific pattern for template files instead of watching everything\n+        autoreload.watch_dir(directory, '**/*.html')\n+        autoreload.watch_dir(directory, '**/*.txt')\n+        autoreload.watch_dir(directory, '**/*.xml')\n+        autoreload.watch_dir(directory, '**/*.json')\n \n     def watched_files(self, include_globs=True):\n         \"\"\"\n",
    "variant_1": "diff --git a/django/template/autoreload.py b/django/template/autoreload.py\nindex cf1b20ba95..7fda1af7d4 100644\n--- a/django/template/autoreload.py\n+++ b/django/template/autoreload.py\n@@ -9,27 +9,50 @@ from django.utils.autoreload import (\n )\n \n \n-def get_template_directories():\n-    # Iterate through each template backend and find\n-    # any template_loader that has a 'get_dirs' method.\n-    # Collect the directories, filtering out Django templates.\n-    cwd = Path.cwd()\n-    items = set()\n-    for backend in engines.all():\n-        if not isinstance(backend, DjangoTemplates):\n+\n+@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n+def watch_for_template_changes(sender, **kwargs):\n+    for directory in get_template_directories():\n+        # Skip watching directories that are too broad (like project root)\n+        # to prevent overwhelming the file watcher\n+        if _is_overly_broad_directory(directory):\n             continue\n+        sender.watch_dir(directory, '**/*')\n \n-        items.update(cwd / to_path(dir) for dir in backend.engine.dirs)\n \n-        for loader in backend.engine.template_loaders:\n-            if not hasattr(loader, 'get_dirs'):\n-                continue\n-            items.update(\n-                cwd / to_path(directory)\n-                for directory in loader.get_dirs()\n-                if not is_django_path(directory)\n-            )\n-    return items\n+def _is_overly_broad_directory(directory):\n+    \"\"\"\n+    Check if a directory is too broad to watch recursively.\n+    Returns True for directories that are likely project roots or contain\n+    too many files/subdirectories.\n+    \"\"\"\n+    try:\n+        # Convert to Path object if it isn't already\n+        path = Path(directory)\n+        \n+        # Check if this is the current working directory (likely project root)\n+        if path.resolve() == Path.cwd().resolve():\n+            return True\n+            \n+        # Check if directory contains common project root indicators\n+        project_indicators = ['manage.py', 'setup.py', 'pyproject.toml', '.git']\n+        if any((path / indicator).exists() for indicator in project_indicators):\n+            return True\n+            \n+        # Count immediate subdirectories - if too many, it's likely too broad\n+        try:\n+            subdirs = [p for p in path.iterdir() if p.is_dir()]\n+            if len(subdirs) > 20:  # Threshold for \"too many\" subdirectories\n+                return True\n+        except (OSError, PermissionError):\n+            # If we can't read the directory, don't watch it\n+            return True\n+            \n+    except (OSError, TypeError):\n+        # If path operations fail, err on the side of caution\n+        return True\n+        \n+    return False\n \n \n def reset_loaders():\n@@ -40,10 +63,33 @@ def reset_loaders():\n             loader.reset()\n \n \n+\n @receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n def watch_for_template_changes(sender, **kwargs):\n     for directory in get_template_directories():\n-        sender.watch_dir(directory, '**/*')\n+        # Skip directories that are likely project roots to prevent excessive file watching\n+        if _is_project_root(directory):\n+            # For project roots, only watch common template file patterns\n+            sender.watch_dir(directory, '**/*.html')\n+            sender.watch_dir(directory, '**/*.txt')\n+        else:\n+            sender.watch_dir(directory, '**/*')\n+\n+\n+def _is_project_root(directory):\n+    \"\"\"Check if a directory appears to be a Django project root.\"\"\"\n+    directory = Path(directory)\n+    \n+    # Check for common Django project files\n+    django_files = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n+    if any((directory / file).exists() for file in django_files):\n+        return True\n+    \n+    # Check if directory contains a settings module/package\n+    if (directory / 'settings').is_dir() or any(directory.glob('*/settings.py')):\n+        return True\n+        \n+    return False\n \n \n @receiver(file_changed, dispatch_uid='template_loaders_file_changed')\ndiff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 583c2be647..b2a24325a9 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -163,34 +163,39 @@ def iter_modules_and_files(modules, extra_files):\n \n \n @functools.lru_cache(maxsize=1)\n-def common_roots(paths):\n+\n+def watch_for_template_changes():\n+    for directory in get_template_directories():\n+        # Skip watching directories that are likely project roots to prevent\n+        # performance issues with recursive file watching\n+        if _is_project_root_directory(directory):\n+            continue\n+        # Use a more specific pattern to avoid watching non-template files\n+        autoreload.watch_dir(directory, '**/*.html')\n+\n+\n+def _is_project_root_directory(directory):\n     \"\"\"\n-    Return a tuple of common roots that are shared between the given paths.\n-    File system watchers operate on directories and aren't cheap to create.\n-    Try to find the minimum set of directories to watch that encompass all of\n-    the files that need to be watched.\n+    Check if a directory appears to be a Django project root that would\n+    cause performance issues if watched recursively.\n     \"\"\"\n-    # Inspired from Werkzeug:\n-    # https://github.com/pallets/werkzeug/blob/7477be2853df70a022d9613e765581b9411c3c39/werkzeug/_reloader.py\n-    # Create a sorted list of the path components, longest first.\n-    path_parts = sorted([x.parts for x in paths], key=len, reverse=True)\n-    tree = {}\n-    for chunks in path_parts:\n-        node = tree\n-        # Add each part of the path to the tree.\n-        for chunk in chunks:\n-            node = node.setdefault(chunk, {})\n-        # Clear the last leaf in the tree.\n-        node.clear()\n-\n-    # Turn the tree into a list of Path instances.\n-    def _walk(node, path):\n-        for prefix, child in node.items():\n-            yield from _walk(child, path + (prefix,))\n-        if not node:\n-            yield Path(*path)\n-\n-    return tuple(_walk(tree, ()))\n+    directory = Path(directory)\n+    \n+    # Check if directory contains typical Django project files\n+    django_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n+    if any((directory / indicator).exists() for indicator in django_indicators):\n+        return True\n+    \n+    # Check if directory contains common project structure indicators\n+    project_indicators = ['.git', '.gitignore', 'requirements.txt', 'setup.py']\n+    if any((directory / indicator).exists() for indicator in project_indicators):\n+        return True\n+    \n+    # Check if directory is the current working directory (often the project root)\n+    if directory.resolve() == Path.cwd().resolve():\n+        return True\n+    \n+    return False\n \n \n def sys_path_directories():\n@@ -273,19 +278,49 @@ class BaseReloader:\n         self.directory_globs = defaultdict(set)\n         self._stop_condition = threading.Event()\n \n-    def watch_dir(self, path, glob):\n-        path = Path(path)\n-        try:\n-            path = path.absolute()\n-        except FileNotFoundError:\n+\n+def watch_for_template_changes():\n+    for template_dir in get_template_directories():\n+        # Skip watching directories that are likely project roots or too broad\n+        if _is_problematic_watch_dir(template_dir):\n             logger.debug(\n-                'Unable to watch directory %s as it cannot be resolved.',\n-                path,\n-                exc_info=True,\n+                'Skipping template directory %s as it appears to be a project root '\n+                'or overly broad directory that could cause performance issues.',\n+                template_dir\n             )\n-            return\n-        logger.debug('Watching dir %s with glob %s.', path, glob)\n-        self.directory_globs[path].add(glob)\n+            continue\n+        autoreload.watch_dir(template_dir, '**/*.html')\n+\n+\n+def _is_problematic_watch_dir(path):\n+    \"\"\"\n+    Check if a directory should not be watched due to being too broad.\n+    Returns True if the directory is likely a project root or contains\n+    too many files/subdirectories to watch efficiently.\n+    \"\"\"\n+    try:\n+        path_obj = Path(path)\n+        # Check if this is the current working directory or a parent of it\n+        cwd = Path.cwd()\n+        if path_obj == cwd or path_obj in cwd.parents:\n+            return True\n+        \n+        # Check for common project root indicators\n+        project_indicators = ['manage.py', 'setup.py', 'pyproject.toml', '.git']\n+        if any((path_obj / indicator).exists() for indicator in project_indicators):\n+            return True\n+            \n+        # Check if directory has too many immediate subdirectories (heuristic)\n+        if path_obj.is_dir():\n+            subdirs = [p for p in path_obj.iterdir() if p.is_dir()]\n+            if len(subdirs) > 20:  # Configurable threshold\n+                return True\n+                \n+    except (OSError, PermissionError):\n+        # If we can't access the directory, it's safer to skip it\n+        return True\n+    \n+    return False\n \n     def watched_files(self, include_globs=True):\n         \"\"\"\n",
    "variant_2": "diff --git a/django/template/autoreload.py b/django/template/autoreload.py\nindex cf1b20ba95..9581fa3f06 100644\n--- a/django/template/autoreload.py\n+++ b/django/template/autoreload.py\n@@ -9,27 +9,52 @@ from django.utils.autoreload import (\n )\n \n \n-def get_template_directories():\n-    # Iterate through each template backend and find\n-    # any template_loader that has a 'get_dirs' method.\n-    # Collect the directories, filtering out Django templates.\n-    cwd = Path.cwd()\n-    items = set()\n-    for backend in engines.all():\n-        if not isinstance(backend, DjangoTemplates):\n+\n+@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n+def watch_for_template_changes(sender, **kwargs):\n+    for directory in get_template_directories():\n+        # Skip watching directories that are project roots or too broad\n+        if _is_overly_broad_directory(directory):\n             continue\n+        sender.watch_dir(directory, '**/*')\n \n-        items.update(cwd / to_path(dir) for dir in backend.engine.dirs)\n \n-        for loader in backend.engine.template_loaders:\n-            if not hasattr(loader, 'get_dirs'):\n-                continue\n-            items.update(\n-                cwd / to_path(directory)\n-                for directory in loader.get_dirs()\n-                if not is_django_path(directory)\n-            )\n-    return items\n+def _is_overly_broad_directory(directory):\n+    \"\"\"\n+    Check if a directory is too broad to watch recursively.\n+    Returns True if the directory should not be watched to prevent\n+    performance issues with the autoreload system.\n+    \"\"\"\n+    try:\n+        directory = Path(directory)\n+        cwd = Path.cwd()\n+        \n+        # Don't watch the current working directory (project root)\n+        if directory.resolve() == cwd.resolve():\n+            return True\n+            \n+        # Don't watch parent directories of the current working directory\n+        try:\n+            cwd.relative_to(directory)\n+            return True\n+        except ValueError:\n+            pass\n+            \n+        # Don't watch directories that contain manage.py (Django project roots)\n+        if (directory / 'manage.py').exists():\n+            return True\n+            \n+        # Don't watch directories with too many immediate subdirectories\n+        if directory.is_dir():\n+            subdir_count = sum(1 for item in directory.iterdir() if item.is_dir())\n+            if subdir_count > 20:  # Configurable threshold\n+                return True\n+                \n+    except (OSError, ValueError):\n+        # If we can't access the directory, don't watch it\n+        return True\n+        \n+    return False\n \n \n def reset_loaders():\n@@ -40,10 +65,36 @@ def reset_loaders():\n             loader.reset()\n \n \n+\n @receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n def watch_for_template_changes(sender, **kwargs):\n     for directory in get_template_directories():\n-        sender.watch_dir(directory, '**/*')\n+        # Skip directories that are likely project roots to avoid watching too many files\n+        if _is_project_root(directory):\n+            # For project roots, only watch common template file extensions\n+            sender.watch_dir(directory, '**/*.html')\n+            sender.watch_dir(directory, '**/*.txt')\n+        else:\n+            sender.watch_dir(directory, '**/*')\n+\n+\n+def _is_project_root(directory):\n+    \"\"\"Check if a directory appears to be a Django project root.\"\"\"\n+    directory = Path(directory)\n+    \n+    # Check for common Django project files\n+    django_files = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n+    if any((directory / filename).exists() for filename in django_files):\n+        return True\n+    \n+    # Check if directory contains a settings module/package\n+    if (directory / 'settings').exists() or any(\n+        (directory / name).is_dir() and (directory / name / 'settings.py').exists()\n+        for name in directory.iterdir() if name.is_dir()\n+    ):\n+        return True\n+    \n+    return False\n \n \n @receiver(file_changed, dispatch_uid='template_loaders_file_changed')\ndiff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 583c2be647..81ffe95a9c 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -163,34 +163,51 @@ def iter_modules_and_files(modules, extra_files):\n \n \n @functools.lru_cache(maxsize=1)\n-def common_roots(paths):\n+\n+def watch_for_template_changes(sender, **kwargs):\n+    # Avoid circular import\n+    from django.template.backends.django import DjangoTemplates\n+\n+    for backend in sender.template_engines:\n+        if isinstance(backend, DjangoTemplates):\n+            for template_dir in get_template_directories():\n+                # Skip watching directories that are likely project roots\n+                # to prevent overwhelming the file watcher\n+                if _is_project_root_directory(template_dir):\n+                    continue\n+                # Use a more specific pattern to watch only template files\n+                # instead of all files recursively\n+                autoreload.watch_dir(template_dir, '**/*.html')\n+\n+\n+def _is_project_root_directory(directory):\n     \"\"\"\n-    Return a tuple of common roots that are shared between the given paths.\n-    File system watchers operate on directories and aren't cheap to create.\n-    Try to find the minimum set of directories to watch that encompass all of\n-    the files that need to be watched.\n+    Check if a directory appears to be a project root that shouldn't be\n+    watched recursively to avoid performance issues.\n     \"\"\"\n-    # Inspired from Werkzeug:\n-    # https://github.com/pallets/werkzeug/blob/7477be2853df70a022d9613e765581b9411c3c39/werkzeug/_reloader.py\n-    # Create a sorted list of the path components, longest first.\n-    path_parts = sorted([x.parts for x in paths], key=len, reverse=True)\n-    tree = {}\n-    for chunks in path_parts:\n-        node = tree\n-        # Add each part of the path to the tree.\n-        for chunk in chunks:\n-            node = node.setdefault(chunk, {})\n-        # Clear the last leaf in the tree.\n-        node.clear()\n-\n-    # Turn the tree into a list of Path instances.\n-    def _walk(node, path):\n-        for prefix, child in node.items():\n-            yield from _walk(child, path + (prefix,))\n-        if not node:\n-            yield Path(*path)\n-\n-    return tuple(_walk(tree, ()))\n+    try:\n+        # Convert to Path object if it's a string\n+        dir_path = Path(directory) if not isinstance(directory, Path) else directory\n+        \n+        # Check if directory contains common project root indicators\n+        project_indicators = ['manage.py', 'setup.py', 'pyproject.toml', '.git']\n+        has_indicators = any((dir_path / indicator).exists() for indicator in project_indicators)\n+        \n+        # Check if it's the current working directory or a parent of it\n+        cwd = Path.cwd()\n+        is_cwd_or_parent = dir_path == cwd or cwd.is_relative_to(dir_path)\n+        \n+        # Check if directory has too many immediate subdirectories (likely a project root)\n+        try:\n+            subdirs = [p for p in dir_path.iterdir() if p.is_dir()]\n+            has_many_subdirs = len(subdirs) > 10\n+        except (OSError, PermissionError):\n+            has_many_subdirs = False\n+        \n+        return has_indicators or (is_cwd_or_parent and has_many_subdirs)\n+    except (OSError, ValueError):\n+        # If we can't analyze the directory, err on the side of caution\n+        return True\n \n \n def sys_path_directories():\n@@ -273,19 +290,53 @@ class BaseReloader:\n         self.directory_globs = defaultdict(set)\n         self._stop_condition = threading.Event()\n \n-    def watch_dir(self, path, glob):\n-        path = Path(path)\n-        try:\n-            path = path.absolute()\n-        except FileNotFoundError:\n+\n+def watch_for_template_changes(sender, **kwargs):\n+    for template_dir in get_template_directories():\n+        # Skip watching directories that are too broad (like project root)\n+        # to prevent performance issues with recursive file watching\n+        if _is_overly_broad_directory(template_dir):\n             logger.debug(\n-                'Unable to watch directory %s as it cannot be resolved.',\n-                path,\n-                exc_info=True,\n+                'Skipping template directory %s as it appears to be too broad for efficient watching',\n+                template_dir\n             )\n-            return\n-        logger.debug('Watching dir %s with glob %s.', path, glob)\n-        self.directory_globs[path].add(glob)\n+            continue\n+        sender.watch_dir(template_dir, '**/*')\n+\n+\n+def _is_overly_broad_directory(path):\n+    \"\"\"\n+    Check if a directory is too broad to watch efficiently.\n+    Returns True for directories that likely contain entire projects.\n+    \"\"\"\n+    path = Path(path)\n+    try:\n+        path = path.resolve()\n+    except (OSError, RuntimeError):\n+        return True\n+    \n+    # Check if directory contains common project root indicators\n+    project_indicators = ['manage.py', 'setup.py', 'pyproject.toml', '.git', '.hg', '.svn']\n+    if any((path / indicator).exists() for indicator in project_indicators):\n+        return True\n+    \n+    # Check if this is the current working directory or a parent of it\n+    try:\n+        cwd = Path.cwd()\n+        if path == cwd or path in cwd.parents:\n+            return True\n+    except (OSError, RuntimeError):\n+        pass\n+    \n+    # Check if directory has too many immediate subdirectories (heuristic)\n+    try:\n+        subdirs = [p for p in path.iterdir() if p.is_dir()]\n+        if len(subdirs) > 20:  # Arbitrary threshold\n+            return True\n+    except (OSError, PermissionError):\n+        return True\n+    \n+    return False\n \n     def watched_files(self, include_globs=True):\n         \"\"\"\n",
    "variant_3": "diff --git a/django/template/autoreload.py b/django/template/autoreload.py\nindex cf1b20ba95..4fe8548957 100644\n--- a/django/template/autoreload.py\n+++ b/django/template/autoreload.py\n@@ -9,6 +9,7 @@ from django.utils.autoreload import (\n )\n \n \n+\n def get_template_directories():\n     # Iterate through each template backend and find\n     # any template_loader that has a 'get_dirs' method.\n@@ -19,16 +20,29 @@ def get_template_directories():\n         if not isinstance(backend, DjangoTemplates):\n             continue\n \n-        items.update(cwd / to_path(dir) for dir in backend.engine.dirs)\n+        # Filter out directories that are too broad (like project root)\n+        for dir in backend.engine.dirs:\n+            dir_path = cwd / to_path(dir)\n+            # Skip if directory is the current working directory (project root)\n+            # or contains manage.py (indicating it's a Django project root)\n+            if (dir_path.resolve() == cwd.resolve() or \n+                (dir_path / 'manage.py').exists()):\n+                continue\n+            items.add(dir_path)\n \n         for loader in backend.engine.template_loaders:\n             if not hasattr(loader, 'get_dirs'):\n                 continue\n-            items.update(\n-                cwd / to_path(directory)\n-                for directory in loader.get_dirs()\n-                if not is_django_path(directory)\n-            )\n+            for directory in loader.get_dirs():\n+                if is_django_path(directory):\n+                    continue\n+                dir_path = cwd / to_path(directory)\n+                # Skip if directory is the current working directory (project root)\n+                # or contains manage.py (indicating it's a Django project root)\n+                if (dir_path.resolve() == cwd.resolve() or \n+                    (dir_path / 'manage.py').exists()):\n+                    continue\n+                items.add(dir_path)\n     return items\n \n \n@@ -40,10 +54,36 @@ def reset_loaders():\n             loader.reset()\n \n \n+\n @receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n def watch_for_template_changes(sender, **kwargs):\n     for directory in get_template_directories():\n-        sender.watch_dir(directory, '**/*')\n+        # Skip watching directories that are likely project roots to prevent\n+        # performance issues from recursively watching entire projects\n+        if _is_project_root(directory):\n+            # For project roots, only watch template files specifically\n+            sender.watch_dir(directory, '**/*.html')\n+            sender.watch_dir(directory, '**/*.txt')\n+        else:\n+            sender.watch_dir(directory, '**/*')\n+\n+\n+def _is_project_root(directory):\n+    \"\"\"Check if a directory appears to be a Django project root.\"\"\"\n+    directory = Path(directory)\n+    \n+    # Check for common Django project files\n+    django_files = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n+    if any((directory / file).exists() for file in django_files):\n+        return True\n+    \n+    # Check if directory contains a settings module structure\n+    if any((directory / name / 'settings.py').exists() \n+           for name in directory.iterdir() \n+           if name.is_dir() and not name.name.startswith('.')):\n+        return True\n+    \n+    return False\n \n \n @receiver(file_changed, dispatch_uid='template_loaders_file_changed')\ndiff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 583c2be647..540bb49386 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -163,34 +163,45 @@ def iter_modules_and_files(modules, extra_files):\n \n \n @functools.lru_cache(maxsize=1)\n-def common_roots(paths):\n+\n+def watch_for_template_changes():\n+    for template_dir in get_template_directories():\n+        # Skip directories that are project roots or overly broad\n+        if _is_problematic_directory(template_dir):\n+            # Watch only template files directly in the directory\n+            autoreload.watch_file(template_dir / '*.html')\n+            autoreload.watch_file(template_dir / '*.txt')\n+            continue\n+        autoreload.watch_dir(template_dir, '**/*')\n+\n+\n+def _is_problematic_directory(template_dir):\n     \"\"\"\n-    Return a tuple of common roots that are shared between the given paths.\n-    File system watchers operate on directories and aren't cheap to create.\n-    Try to find the minimum set of directories to watch that encompass all of\n-    the files that need to be watched.\n+    Check if a template directory is too broad to watch recursively.\n+    Returns True for directories that are likely project roots or contain\n+    too many non-template files.\n     \"\"\"\n-    # Inspired from Werkzeug:\n-    # https://github.com/pallets/werkzeug/blob/7477be2853df70a022d9613e765581b9411c3c39/werkzeug/_reloader.py\n-    # Create a sorted list of the path components, longest first.\n-    path_parts = sorted([x.parts for x in paths], key=len, reverse=True)\n-    tree = {}\n-    for chunks in path_parts:\n-        node = tree\n-        # Add each part of the path to the tree.\n-        for chunk in chunks:\n-            node = node.setdefault(chunk, {})\n-        # Clear the last leaf in the tree.\n-        node.clear()\n-\n-    # Turn the tree into a list of Path instances.\n-    def _walk(node, path):\n-        for prefix, child in node.items():\n-            yield from _walk(child, path + (prefix,))\n-        if not node:\n-            yield Path(*path)\n-\n-    return tuple(_walk(tree, ()))\n+    # Check if directory contains Django project indicators\n+    django_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n+    if any((template_dir / indicator).exists() for indicator in django_indicators):\n+        return True\n+    \n+    # Check if this is the current working directory (common project root)\n+    try:\n+        if template_dir.resolve() == Path.cwd().resolve():\n+            return True\n+    except (OSError, ValueError):\n+        pass\n+    \n+    # Check if directory has too many subdirectories (heuristic for project root)\n+    try:\n+        subdirs = [p for p in template_dir.iterdir() if p.is_dir()]\n+        if len(subdirs) > 10:  # Arbitrary threshold for \"too many\" subdirectories\n+            return True\n+    except (OSError, ValueError):\n+        pass\n+    \n+    return False\n \n \n def sys_path_directories():\n@@ -273,19 +284,44 @@ class BaseReloader:\n         self.directory_globs = defaultdict(set)\n         self._stop_condition = threading.Event()\n \n-    def watch_dir(self, path, glob):\n-        path = Path(path)\n-        try:\n-            path = path.absolute()\n-        except FileNotFoundError:\n+\n+def watch_for_template_changes():\n+    for directory in get_template_directories():\n+        # Skip watching directories that are likely project roots to prevent\n+        # performance issues with recursive file watching\n+        if _is_project_root_directory(directory):\n             logger.debug(\n-                'Unable to watch directory %s as it cannot be resolved.',\n-                path,\n-                exc_info=True,\n+                'Skipping template directory %s as it appears to be a project root',\n+                directory\n             )\n-            return\n-        logger.debug('Watching dir %s with glob %s.', path, glob)\n-        self.directory_globs[path].add(glob)\n+            continue\n+        autoreload.watch_dir(directory, '**/*.html')\n+\n+\n+def _is_project_root_directory(directory):\n+    \"\"\"\n+    Check if a directory is likely a Django project root that shouldn't be\n+    watched recursively for template changes.\n+    \"\"\"\n+    try:\n+        directory = Path(directory)\n+        if not directory.is_dir():\n+            return False\n+        \n+        # Check for common Django project root indicators\n+        project_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n+        for indicator in project_indicators:\n+            if (directory / indicator).exists():\n+                return True\n+        \n+        # Check if directory contains a settings module structure\n+        for item in directory.iterdir():\n+            if item.is_dir() and (item / 'settings.py').exists():\n+                return True\n+                \n+        return False\n+    except (OSError, PermissionError):\n+        return False\n \n     def watched_files(self, include_globs=True):\n         \"\"\"\n",
    "variant_4": "diff --git a/django/template/autoreload.py b/django/template/autoreload.py\nindex cf1b20ba95..14241825b8 100644\n--- a/django/template/autoreload.py\n+++ b/django/template/autoreload.py\n@@ -9,27 +9,48 @@ from django.utils.autoreload import (\n )\n \n \n-def get_template_directories():\n-    # Iterate through each template backend and find\n-    # any template_loader that has a 'get_dirs' method.\n-    # Collect the directories, filtering out Django templates.\n-    cwd = Path.cwd()\n-    items = set()\n-    for backend in engines.all():\n-        if not isinstance(backend, DjangoTemplates):\n-            continue\n \n-        items.update(cwd / to_path(dir) for dir in backend.engine.dirs)\n+@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n+def watch_for_template_changes(sender, **kwargs):\n+    for directory in get_template_directories():\n+        # Skip watching directories that are too broad (like project root)\n+        # to prevent overwhelming the file watcher\n+        if is_project_root_directory(directory):\n+            # Watch only template files in project root, not everything\n+            sender.watch_file(directory / '**/*.html', directory)\n+            sender.watch_file(directory / '**/*.txt', directory)\n+        else:\n+            sender.watch_dir(directory, '**/*')\n \n-        for loader in backend.engine.template_loaders:\n-            if not hasattr(loader, 'get_dirs'):\n-                continue\n-            items.update(\n-                cwd / to_path(directory)\n-                for directory in loader.get_dirs()\n-                if not is_django_path(directory)\n-            )\n-    return items\n+\n+def is_project_root_directory(directory):\n+    \"\"\"\n+    Check if a directory appears to be a Django project root that shouldn't\n+    be watched recursively to avoid performance issues.\n+    \"\"\"\n+    directory = Path(directory)\n+    \n+    # Check if it's the current working directory (common case)\n+    if directory.resolve() == Path.cwd().resolve():\n+        return True\n+    \n+    # Check for common Django project files that indicate project root\n+    django_project_markers = [\n+        'manage.py',\n+        'settings.py',\n+        'wsgi.py',\n+        'asgi.py',\n+    ]\n+    \n+    for marker in django_project_markers:\n+        if (directory / marker).exists():\n+            return True\n+    \n+    # Check if directory contains a settings module/package\n+    if (directory / 'settings').is_dir():\n+        return True\n+    \n+    return False\n \n \n def reset_loaders():\n@@ -40,10 +61,48 @@ def reset_loaders():\n             loader.reset()\n \n \n+\n @receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n def watch_for_template_changes(sender, **kwargs):\n     for directory in get_template_directories():\n-        sender.watch_dir(directory, '**/*')\n+        # Skip watching directories that are likely project roots to prevent\n+        # overwhelming the file watcher with too many files\n+        if _is_project_root(directory):\n+            # For project roots, only watch common template file patterns\n+            sender.watch_dir(directory, '**/*.html')\n+            sender.watch_dir(directory, '**/*.txt')  # For email templates\n+        else:\n+            sender.watch_dir(directory, '**/*')\n+\n+\n+def _is_project_root(directory):\n+    \"\"\"\n+    Check if a directory appears to be a Django project root.\n+    Project roots typically contain manage.py or are the current working directory.\n+    \"\"\"\n+    directory = Path(directory)\n+    \n+    # Check if directory contains common Django project files\n+    if (directory / 'manage.py').exists():\n+        return True\n+    \n+    # Check if directory is the current working directory (common for BASE_DIR)\n+    try:\n+        if directory.resolve() == Path.cwd().resolve():\n+            return True\n+    except (OSError, RuntimeError):\n+        pass\n+    \n+    # Check if directory has an unusually large number of subdirectories\n+    # which might indicate it's a project root\n+    try:\n+        subdirs = [p for p in directory.iterdir() if p.is_dir()]\n+        if len(subdirs) > 10:  # Arbitrary threshold for \"too many\" subdirectories\n+            return True\n+    except (OSError, PermissionError):\n+        pass\n+    \n+    return False\n \n \n @receiver(file_changed, dispatch_uid='template_loaders_file_changed')\ndiff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 583c2be647..aeb205b17f 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -163,34 +163,47 @@ def iter_modules_and_files(modules, extra_files):\n \n \n @functools.lru_cache(maxsize=1)\n-def common_roots(paths):\n+\n+def watch_for_template_changes():\n+    for directory in get_template_directories():\n+        # Skip directories that would cause excessive file watching\n+        if _is_problematic_directory(directory):\n+            logger.debug('Skipping template directory due to potential performance issues: %s', directory)\n+            continue\n+        # Use a more specific pattern to avoid watching non-template files\n+        autoreload.watch_dir(directory, '**/*.html')\n+        autoreload.watch_dir(directory, '**/*.txt')\n+        autoreload.watch_dir(directory, '**/*.xml')\n+\n+\n+def _is_problematic_directory(directory):\n     \"\"\"\n-    Return a tuple of common roots that are shared between the given paths.\n-    File system watchers operate on directories and aren't cheap to create.\n-    Try to find the minimum set of directories to watch that encompass all of\n-    the files that need to be watched.\n+    Check if a directory should be skipped for template watching to avoid\n+    performance issues with recursive file monitoring.\n     \"\"\"\n-    # Inspired from Werkzeug:\n-    # https://github.com/pallets/werkzeug/blob/7477be2853df70a022d9613e765581b9411c3c39/werkzeug/_reloader.py\n-    # Create a sorted list of the path components, longest first.\n-    path_parts = sorted([x.parts for x in paths], key=len, reverse=True)\n-    tree = {}\n-    for chunks in path_parts:\n-        node = tree\n-        # Add each part of the path to the tree.\n-        for chunk in chunks:\n-            node = node.setdefault(chunk, {})\n-        # Clear the last leaf in the tree.\n-        node.clear()\n-\n-    # Turn the tree into a list of Path instances.\n-    def _walk(node, path):\n-        for prefix, child in node.items():\n-            yield from _walk(child, path + (prefix,))\n-        if not node:\n-            yield Path(*path)\n-\n-    return tuple(_walk(tree, ()))\n+    directory = Path(directory)\n+    \n+    # Skip if directory contains manage.py (likely project root)\n+    if (directory / 'manage.py').exists():\n+        return True\n+    \n+    # Skip if directory is current working directory or parent\n+    cwd = Path.cwd()\n+    try:\n+        if directory.resolve() == cwd.resolve() or cwd.resolve() in directory.resolve().parents:\n+            return True\n+    except (OSError, ValueError):\n+        pass\n+    \n+    # Skip very large directories (more than 1000 immediate subdirectories)\n+    try:\n+        subdir_count = sum(1 for item in directory.iterdir() if item.is_dir())\n+        if subdir_count > 1000:\n+            return True\n+    except (OSError, PermissionError):\n+        return True\n+    \n+    return False\n \n \n def sys_path_directories():\n@@ -273,19 +286,43 @@ class BaseReloader:\n         self.directory_globs = defaultdict(set)\n         self._stop_condition = threading.Event()\n \n-    def watch_dir(self, path, glob):\n-        path = Path(path)\n-        try:\n-            path = path.absolute()\n-        except FileNotFoundError:\n+\n+def watch_for_template_changes():\n+    for directory in get_template_directories():\n+        # Skip watching directories that are likely project roots to prevent\n+        # performance issues with recursive file watching\n+        if _is_project_root_directory(directory):\n             logger.debug(\n-                'Unable to watch directory %s as it cannot be resolved.',\n-                path,\n-                exc_info=True,\n+                'Skipping template directory %s as it appears to be a project root.',\n+                directory,\n             )\n-            return\n-        logger.debug('Watching dir %s with glob %s.', path, glob)\n-        self.directory_globs[path].add(glob)\n+            continue\n+        # Use a more restrictive glob pattern to avoid watching non-template files\n+        autoreload.watch_dir(directory, '**/*.html')\n+\n+\n+def _is_project_root_directory(directory):\n+    \"\"\"\n+    Check if a directory is likely a project root that shouldn't be watched recursively.\n+    \"\"\"\n+    try:\n+        path = Path(directory)\n+        # Check if directory contains common Django project files\n+        if (path / 'manage.py').exists():\n+            return True\n+        if (path / 'settings.py').exists():\n+            return True\n+        # Check if it's the current working directory (common for BASE_DIR)\n+        if path.resolve() == Path.cwd().resolve():\n+            return True\n+        # Check if directory has too many subdirectories (heuristic)\n+        subdirs = [p for p in path.iterdir() if p.is_dir()]\n+        if len(subdirs) > 20:  # Arbitrary threshold\n+            return True\n+    except (OSError, PermissionError):\n+        # If we can't access the directory, err on the side of caution\n+        return True\n+    return False\n \n     def watched_files(self, include_globs=True):\n         \"\"\"\n",
    "variant_5": "diff --git a/django/template/autoreload.py b/django/template/autoreload.py\nindex cf1b20ba95..d192d3257a 100644\n--- a/django/template/autoreload.py\n+++ b/django/template/autoreload.py\n@@ -9,27 +9,43 @@ from django.utils.autoreload import (\n )\n \n \n-def get_template_directories():\n-    # Iterate through each template backend and find\n-    # any template_loader that has a 'get_dirs' method.\n-    # Collect the directories, filtering out Django templates.\n-    cwd = Path.cwd()\n-    items = set()\n-    for backend in engines.all():\n-        if not isinstance(backend, DjangoTemplates):\n+\n+@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n+def watch_for_template_changes(sender, **kwargs):\n+    for directory in get_template_directories():\n+        # Skip directories that are too broad (like project root)\n+        # to prevent overwhelming the file watcher\n+        if _is_overly_broad_directory(directory):\n             continue\n+        sender.watch_dir(directory, '**/*')\n \n-        items.update(cwd / to_path(dir) for dir in backend.engine.dirs)\n \n-        for loader in backend.engine.template_loaders:\n-            if not hasattr(loader, 'get_dirs'):\n-                continue\n-            items.update(\n-                cwd / to_path(directory)\n-                for directory in loader.get_dirs()\n-                if not is_django_path(directory)\n-            )\n-    return items\n+def _is_overly_broad_directory(directory):\n+    \"\"\"\n+    Check if a directory is too broad to watch recursively.\n+    Returns True for directories that would cause performance issues.\n+    \"\"\"\n+    try:\n+        path = Path(directory)\n+        cwd = Path.cwd()\n+        \n+        # Don't watch the current working directory (project root)\n+        if path.resolve() == cwd.resolve():\n+            return True\n+            \n+        # Don't watch parent directories of the current working directory\n+        if cwd.is_relative_to(path):\n+            return True\n+            \n+        # Check for common project root indicators\n+        project_indicators = ['manage.py', 'setup.py', 'pyproject.toml', '.git']\n+        if any((path / indicator).exists() for indicator in project_indicators):\n+            return True\n+            \n+        return False\n+    except (OSError, ValueError):\n+        # If we can't analyze the directory, err on the side of caution\n+        return True\n \n \n def reset_loaders():\n@@ -40,10 +56,45 @@ def reset_loaders():\n             loader.reset()\n \n \n+\n @receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n def watch_for_template_changes(sender, **kwargs):\n     for directory in get_template_directories():\n-        sender.watch_dir(directory, '**/*')\n+        # Skip watching directories that are likely project roots to prevent\n+        # performance issues from recursive watching of entire projects\n+        if _is_project_root(directory):\n+            # For project roots, only watch template files directly\n+            sender.watch_dir(directory, '*.html')\n+            sender.watch_dir(directory, '*.txt')\n+        else:\n+            # For dedicated template directories, watch all files recursively\n+            sender.watch_dir(directory, '**/*')\n+\n+\n+def _is_project_root(directory):\n+    \"\"\"Check if a directory appears to be a Django project root.\"\"\"\n+    directory = Path(directory)\n+    \n+    # Check for common Django project files\n+    django_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n+    for indicator in django_indicators:\n+        if (directory / indicator).exists():\n+            return True\n+    \n+    # Check if it's a common project structure (has apps, config dirs)\n+    common_dirs = ['apps', 'config', 'static', 'media', 'requirements']\n+    indicator_count = sum(1 for dirname in common_dirs if (directory / dirname).exists())\n+    if indicator_count >= 2:\n+        return True\n+    \n+    # Check if it's the current working directory (often the project root)\n+    try:\n+        if directory.resolve() == Path.cwd().resolve():\n+            return True\n+    except (OSError, RuntimeError):\n+        pass\n+    \n+    return False\n \n \n @receiver(file_changed, dispatch_uid='template_loaders_file_changed')\ndiff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 583c2be647..3f0934784b 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -163,34 +163,49 @@ def iter_modules_and_files(modules, extra_files):\n \n \n @functools.lru_cache(maxsize=1)\n-def common_roots(paths):\n+\n+def watch_for_template_changes():\n+    template_dirs = get_template_directories()\n+    # Filter out overly broad directories like project roots\n+    filtered_dirs = []\n+    for template_dir in template_dirs:\n+        # Skip directories that are likely project roots\n+        if is_project_root(template_dir):\n+            # For project roots, only watch specific template subdirs if they exist\n+            common_template_subdirs = ['templates', 'template']\n+            for subdir_name in common_template_subdirs:\n+                subdir = template_dir / subdir_name\n+                if subdir.exists() and subdir.is_dir():\n+                    filtered_dirs.append(subdir)\n+        else:\n+            filtered_dirs.append(template_dir)\n+    \n+    for template_dir in filtered_dirs:\n+        # Use more specific pattern to avoid watching too many files\n+        autoreload.watch_dir(template_dir, \"**/*.html\")\n+\n+\n+def is_project_root(path):\n     \"\"\"\n-    Return a tuple of common roots that are shared between the given paths.\n-    File system watchers operate on directories and aren't cheap to create.\n-    Try to find the minimum set of directories to watch that encompass all of\n-    the files that need to be watched.\n+    Check if a directory appears to be a Django project root.\n+    Project roots typically contain manage.py or common Django files.\n     \"\"\"\n-    # Inspired from Werkzeug:\n-    # https://github.com/pallets/werkzeug/blob/7477be2853df70a022d9613e765581b9411c3c39/werkzeug/_reloader.py\n-    # Create a sorted list of the path components, longest first.\n-    path_parts = sorted([x.parts for x in paths], key=len, reverse=True)\n-    tree = {}\n-    for chunks in path_parts:\n-        node = tree\n-        # Add each part of the path to the tree.\n-        for chunk in chunks:\n-            node = node.setdefault(chunk, {})\n-        # Clear the last leaf in the tree.\n-        node.clear()\n-\n-    # Turn the tree into a list of Path instances.\n-    def _walk(node, path):\n-        for prefix, child in node.items():\n-            yield from _walk(child, path + (prefix,))\n-        if not node:\n-            yield Path(*path)\n-\n-    return tuple(_walk(tree, ()))\n+    path = Path(path)\n+    # Check for common Django project indicators\n+    django_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n+    has_indicators = any((path / indicator).exists() for indicator in django_indicators)\n+    \n+    # Also check if it's the current working directory (common for project roots)\n+    is_cwd = path.resolve() == Path.cwd().resolve()\n+    \n+    # Check if directory has too many immediate subdirectories (sign of a project root)\n+    try:\n+        subdir_count = len([d for d in path.iterdir() if d.is_dir()])\n+        has_many_subdirs = subdir_count > 10\n+    except (OSError, PermissionError):\n+        has_many_subdirs = False\n+    \n+    return has_indicators or is_cwd or has_many_subdirs\n \n \n def sys_path_directories():\n@@ -273,19 +288,48 @@ class BaseReloader:\n         self.directory_globs = defaultdict(set)\n         self._stop_condition = threading.Event()\n \n-    def watch_dir(self, path, glob):\n-        path = Path(path)\n-        try:\n-            path = path.absolute()\n-        except FileNotFoundError:\n+\n+def watch_for_template_changes():\n+    for directory in get_template_directories():\n+        # Skip watching directories that are likely project roots to prevent\n+        # overwhelming the file watcher with recursive monitoring\n+        if _is_project_root_directory(directory):\n             logger.debug(\n-                'Unable to watch directory %s as it cannot be resolved.',\n-                path,\n-                exc_info=True,\n+                'Skipping watch on directory %s as it appears to be a project root.',\n+                directory\n             )\n-            return\n-        logger.debug('Watching dir %s with glob %s.', path, glob)\n-        self.directory_globs[path].add(glob)\n+            continue\n+        autoreload.watch_dir(directory, '**/*.html')\n+\n+\n+def _is_project_root_directory(directory):\n+    \"\"\"\n+    Check if a directory is likely a project root that shouldn't be watched recursively.\n+    \"\"\"\n+    directory = Path(directory)\n+    \n+    # Check if directory contains common project root indicators\n+    project_indicators = ['manage.py', 'setup.py', 'pyproject.toml', '.git', '.gitignore']\n+    for indicator in project_indicators:\n+        if (directory / indicator).exists():\n+            return True\n+    \n+    # Check if directory is the current working directory\n+    try:\n+        if directory.resolve() == Path.cwd().resolve():\n+            return True\n+    except (OSError, RuntimeError):\n+        pass\n+    \n+    # Check if directory has an excessive number of subdirectories\n+    try:\n+        subdirs = [p for p in directory.iterdir() if p.is_dir()]\n+        if len(subdirs) > 20:  # Arbitrary threshold for \"too many\" subdirectories\n+            return True\n+    except (OSError, PermissionError):\n+        pass\n+    \n+    return False\n \n     def watched_files(self, include_globs=True):\n         \"\"\"\n",
    "variant_6": "diff --git a/django/template/autoreload.py b/django/template/autoreload.py\nindex cf1b20ba95..40f15fc25f 100644\n--- a/django/template/autoreload.py\n+++ b/django/template/autoreload.py\n@@ -9,27 +9,36 @@ from django.utils.autoreload import (\n )\n \n \n-def get_template_directories():\n-    # Iterate through each template backend and find\n-    # any template_loader that has a 'get_dirs' method.\n-    # Collect the directories, filtering out Django templates.\n-    cwd = Path.cwd()\n-    items = set()\n-    for backend in engines.all():\n-        if not isinstance(backend, DjangoTemplates):\n-            continue\n \n-        items.update(cwd / to_path(dir) for dir in backend.engine.dirs)\n-\n-        for loader in backend.engine.template_loaders:\n-            if not hasattr(loader, 'get_dirs'):\n+def watch_for_template_changes():\n+    template_dirs = get_template_directories()\n+    # Filter out directories that are too broad to watch efficiently\n+    filtered_dirs = set()\n+    cwd = Path.cwd()\n+    \n+    for directory in template_dirs:\n+        # Skip if directory is the project root or contains it\n+        try:\n+            if directory == cwd or cwd in directory.parents:\n                 continue\n-            items.update(\n-                cwd / to_path(directory)\n-                for directory in loader.get_dirs()\n-                if not is_django_path(directory)\n-            )\n-    return items\n+            # Skip if directory contains manage.py (likely project root)\n+            if (directory / 'manage.py').exists():\n+                continue\n+            # Skip very large directories by checking immediate subdirectory count\n+            if directory.exists() and directory.is_dir():\n+                subdir_count = sum(1 for item in directory.iterdir() if item.is_dir())\n+                if subdir_count > 50:  # Arbitrary threshold for \"too many\" subdirs\n+                    continue\n+            filtered_dirs.add(directory)\n+        except (OSError, PermissionError):\n+            # Skip directories we can't access\n+            continue\n+    \n+    # Use more specific glob pattern for templates\n+    for directory in filtered_dirs:\n+        watch_dir(directory, '**/*.html')\n+        watch_dir(directory, '**/*.txt')\n+        watch_dir(directory, '**/*.xml')\n \n \n def reset_loaders():\n@@ -40,10 +49,38 @@ def reset_loaders():\n             loader.reset()\n \n \n+\n @receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n def watch_for_template_changes(sender, **kwargs):\n     for directory in get_template_directories():\n-        sender.watch_dir(directory, '**/*')\n+        # Skip watching directories that are likely project roots to prevent\n+        # performance issues from recursive watching of entire projects\n+        if _is_project_root_directory(directory):\n+            continue\n+        sender.watch_dir(directory, '**/*.html')\n+\n+\n+def _is_project_root_directory(directory):\n+    \"\"\"\n+    Check if a directory appears to be a Django project root.\n+    Project roots typically contain manage.py and should not be watched\n+    recursively as they can contain thousands of non-template files.\n+    \"\"\"\n+    directory = Path(directory)\n+    \n+    # Check if directory contains typical Django project files\n+    project_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n+    if any((directory / indicator).exists() for indicator in project_indicators):\n+        return True\n+    \n+    # Check if directory is the current working directory (common for BASE_DIR)\n+    try:\n+        if directory.resolve() == Path.cwd().resolve():\n+            return True\n+    except (OSError, ValueError):\n+        pass\n+    \n+    return False\n \n \n @receiver(file_changed, dispatch_uid='template_loaders_file_changed')\ndiff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 583c2be647..c9a12d4ef6 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -163,34 +163,41 @@ def iter_modules_and_files(modules, extra_files):\n \n \n @functools.lru_cache(maxsize=1)\n-def common_roots(paths):\n+\n+def watch_for_template_changes():\n+    for directory in get_template_directories():\n+        # Skip directories that are likely project roots to avoid watching\n+        # too many files recursively, which can overwhelm the file watcher\n+        if _is_project_root_directory(directory):\n+            continue\n+        # Use a more restrictive pattern for template files to limit scope\n+        autoreload.watch_dir(directory, '**/*.html')\n+\n+\n+def _is_project_root_directory(directory):\n     \"\"\"\n-    Return a tuple of common roots that are shared between the given paths.\n-    File system watchers operate on directories and aren't cheap to create.\n-    Try to find the minimum set of directories to watch that encompass all of\n-    the files that need to be watched.\n+    Check if a directory appears to be a Django project root that should\n+    not be watched recursively to avoid performance issues.\n     \"\"\"\n-    # Inspired from Werkzeug:\n-    # https://github.com/pallets/werkzeug/blob/7477be2853df70a022d9613e765581b9411c3c39/werkzeug/_reloader.py\n-    # Create a sorted list of the path components, longest first.\n-    path_parts = sorted([x.parts for x in paths], key=len, reverse=True)\n-    tree = {}\n-    for chunks in path_parts:\n-        node = tree\n-        # Add each part of the path to the tree.\n-        for chunk in chunks:\n-            node = node.setdefault(chunk, {})\n-        # Clear the last leaf in the tree.\n-        node.clear()\n-\n-    # Turn the tree into a list of Path instances.\n-    def _walk(node, path):\n-        for prefix, child in node.items():\n-            yield from _walk(child, path + (prefix,))\n-        if not node:\n-            yield Path(*path)\n-\n-    return tuple(_walk(tree, ()))\n+    try:\n+        directory_path = Path(directory)\n+        # Check if directory contains common Django project files\n+        has_manage_py = (directory_path / 'manage.py').exists()\n+        has_settings = any((directory_path / name).exists() for name in ['settings.py', 'settings'])\n+        \n+        # Check if directory is the current working directory (likely project root)\n+        is_cwd = directory_path.resolve() == Path.cwd().resolve()\n+        \n+        # Check if directory has many subdirectories (heuristic for project root)\n+        try:\n+            subdirs = [p for p in directory_path.iterdir() if p.is_dir()]\n+            has_many_subdirs = len(subdirs) > 5\n+        except (OSError, PermissionError):\n+            has_many_subdirs = False\n+        \n+        return has_manage_py or has_settings or is_cwd or has_many_subdirs\n+    except (OSError, ValueError):\n+        return False\n \n \n def sys_path_directories():\n@@ -273,19 +280,44 @@ class BaseReloader:\n         self.directory_globs = defaultdict(set)\n         self._stop_condition = threading.Event()\n \n-    def watch_dir(self, path, glob):\n-        path = Path(path)\n-        try:\n-            path = path.absolute()\n-        except FileNotFoundError:\n-            logger.debug(\n-                'Unable to watch directory %s as it cannot be resolved.',\n-                path,\n-                exc_info=True,\n-            )\n-            return\n-        logger.debug('Watching dir %s with glob %s.', path, glob)\n-        self.directory_globs[path].add(glob)\n+\n+def watch_for_template_changes(sender, **kwargs):\n+    for directory in get_template_directories():\n+        # Skip directories that are likely project roots to avoid performance issues\n+        if _is_project_root(directory):\n+            logger.debug('Skipping template directory %s as it appears to be a project root', directory)\n+            continue\n+        # Use a more restrictive pattern to avoid watching too many files\n+        sender.watch_dir(directory, '**/*.html')\n+\n+\n+def _is_project_root(directory):\n+    \"\"\"\n+    Check if a directory is likely a project root that shouldn't be watched recursively.\n+    \"\"\"\n+    directory = Path(directory)\n+    \n+    # Check if directory contains common Django project files\n+    project_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n+    if any((directory / indicator).exists() for indicator in project_indicators):\n+        return True\n+    \n+    # Check if directory is the current working directory\n+    try:\n+        if directory.resolve() == Path.cwd().resolve():\n+            return True\n+    except (OSError, RuntimeError):\n+        pass\n+    \n+    # Check if directory has too many subdirectories (likely a project root)\n+    try:\n+        subdirs = [p for p in directory.iterdir() if p.is_dir()]\n+        if len(subdirs) > 10:  # Arbitrary threshold\n+            return True\n+    except (OSError, PermissionError):\n+        pass\n+    \n+    return False\n \n     def watched_files(self, include_globs=True):\n         \"\"\"\n",
    "variant_7": "diff --git a/django/template/autoreload.py b/django/template/autoreload.py\nindex cf1b20ba95..914d184d08 100644\n--- a/django/template/autoreload.py\n+++ b/django/template/autoreload.py\n@@ -9,27 +9,23 @@ from django.utils.autoreload import (\n )\n \n \n-def get_template_directories():\n-    # Iterate through each template backend and find\n-    # any template_loader that has a 'get_dirs' method.\n-    # Collect the directories, filtering out Django templates.\n-    cwd = Path.cwd()\n-    items = set()\n-    for backend in engines.all():\n-        if not isinstance(backend, DjangoTemplates):\n-            continue\n \n-        items.update(cwd / to_path(dir) for dir in backend.engine.dirs)\n-\n-        for loader in backend.engine.template_loaders:\n-            if not hasattr(loader, 'get_dirs'):\n+@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n+def watch_for_template_changes(sender, **kwargs):\n+    cwd = Path.cwd()\n+    for directory in get_template_directories():\n+        # Skip directories that are project roots or overly broad\n+        try:\n+            # Check if directory is the project root or contains it\n+            if directory == cwd or cwd.is_relative_to(directory):\n                 continue\n-            items.update(\n-                cwd / to_path(directory)\n-                for directory in loader.get_dirs()\n-                if not is_django_path(directory)\n-            )\n-    return items\n+            # Check if directory contains common project files indicating it's a root\n+            if any((directory / marker).exists() for marker in ['manage.py', 'settings.py', 'wsgi.py']):\n+                continue\n+        except (OSError, ValueError):\n+            # Skip directories that can't be processed\n+            continue\n+        sender.watch_dir(directory, '**/*.html')\n \n \n def reset_loaders():\n@@ -40,10 +36,44 @@ def reset_loaders():\n             loader.reset()\n \n \n+\n @receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n def watch_for_template_changes(sender, **kwargs):\n     for directory in get_template_directories():\n-        sender.watch_dir(directory, '**/*')\n+        # Skip watching directories that are too broad (e.g., project root)\n+        if _is_project_root_or_too_broad(directory):\n+            # For broad directories, only watch template files specifically\n+            sender.watch_dir(directory, '**/*.html')\n+            sender.watch_dir(directory, '**/*.txt')\n+        else:\n+            sender.watch_dir(directory, '**/*')\n+\n+\n+def _is_project_root_or_too_broad(directory):\n+    \"\"\"\n+    Check if a directory is likely a project root or contains too many files\n+    to watch efficiently.\n+    \"\"\"\n+    directory = Path(directory)\n+    \n+    # Check if directory contains common Django project files\n+    project_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n+    if any((directory / indicator).exists() for indicator in project_indicators):\n+        return True\n+    \n+    # Check if directory is the current working directory\n+    if directory.resolve() == Path.cwd().resolve():\n+        return True\n+    \n+    # Check if directory has too many immediate subdirectories (heuristic)\n+    try:\n+        subdirs = [p for p in directory.iterdir() if p.is_dir()]\n+        if len(subdirs) > 10:  # Arbitrary threshold\n+            return True\n+    except (OSError, PermissionError):\n+        pass\n+    \n+    return False\n \n \n @receiver(file_changed, dispatch_uid='template_loaders_file_changed')\ndiff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 583c2be647..5d87d08ecf 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -163,34 +163,45 @@ def iter_modules_and_files(modules, extra_files):\n \n \n @functools.lru_cache(maxsize=1)\n-def common_roots(paths):\n+\n+def watch_for_template_changes():\n+    for directory in get_template_directories():\n+        # Skip directories that are too broad to watch efficiently\n+        if _is_overly_broad_directory(directory):\n+            continue\n+        autoreload.watch_dir(directory, '**/*')\n+\n+\n+def _is_overly_broad_directory(directory):\n     \"\"\"\n-    Return a tuple of common roots that are shared between the given paths.\n-    File system watchers operate on directories and aren't cheap to create.\n-    Try to find the minimum set of directories to watch that encompass all of\n-    the files that need to be watched.\n+    Check if a directory is too broad to watch efficiently.\n+    Returns True for project roots or directories with excessive subdirectories.\n     \"\"\"\n-    # Inspired from Werkzeug:\n-    # https://github.com/pallets/werkzeug/blob/7477be2853df70a022d9613e765581b9411c3c39/werkzeug/_reloader.py\n-    # Create a sorted list of the path components, longest first.\n-    path_parts = sorted([x.parts for x in paths], key=len, reverse=True)\n-    tree = {}\n-    for chunks in path_parts:\n-        node = tree\n-        # Add each part of the path to the tree.\n-        for chunk in chunks:\n-            node = node.setdefault(chunk, {})\n-        # Clear the last leaf in the tree.\n-        node.clear()\n-\n-    # Turn the tree into a list of Path instances.\n-    def _walk(node, path):\n-        for prefix, child in node.items():\n-            yield from _walk(child, path + (prefix,))\n-        if not node:\n-            yield Path(*path)\n-\n-    return tuple(_walk(tree, ()))\n+    try:\n+        directory = Path(directory).resolve()\n+        \n+        # Check if this is likely a project root\n+        project_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py', '.git', 'requirements.txt']\n+        if any((directory / indicator).exists() for indicator in project_indicators):\n+            return True\n+            \n+        # Check if directory is the current working directory\n+        if directory == Path.cwd().resolve():\n+            return True\n+            \n+        # Count immediate subdirectories - if too many, it's likely too broad\n+        try:\n+            subdirs = [p for p in directory.iterdir() if p.is_dir()]\n+            if len(subdirs) > 20:  # Arbitrary threshold for \"too many\" subdirectories\n+                return True\n+        except (OSError, PermissionError):\n+            # If we can't read the directory, skip it\n+            return True\n+            \n+    except (OSError, ValueError):\n+        return True\n+        \n+    return False\n \n \n def sys_path_directories():\n@@ -273,19 +284,47 @@ class BaseReloader:\n         self.directory_globs = defaultdict(set)\n         self._stop_condition = threading.Event()\n \n-    def watch_dir(self, path, glob):\n-        path = Path(path)\n-        try:\n-            path = path.absolute()\n-        except FileNotFoundError:\n+\n+def watch_for_template_changes():\n+    for directory in get_template_directories():\n+        # Skip directories that are likely project roots to avoid watching too many files\n+        if _is_project_root_directory(directory):\n             logger.debug(\n-                'Unable to watch directory %s as it cannot be resolved.',\n-                path,\n-                exc_info=True,\n+                'Skipping template directory %s as it appears to be a project root.',\n+                directory\n             )\n-            return\n-        logger.debug('Watching dir %s with glob %s.', path, glob)\n-        self.directory_globs[path].add(glob)\n+            continue\n+        autoreload.watch_dir(directory, '**/*.html')\n+\n+\n+def _is_project_root_directory(directory):\n+    \"\"\"\n+    Check if a directory appears to be a Django project root that shouldn't\n+    be watched recursively to avoid performance issues.\n+    \"\"\"\n+    try:\n+        path = Path(directory).resolve()\n+        \n+        # Check if directory contains common Django project files\n+        project_markers = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n+        if any((path / marker).exists() for marker in project_markers):\n+            return True\n+            \n+        # Check if it's the current working directory (likely project root)\n+        if path == Path.cwd():\n+            return True\n+            \n+        # Check if directory has too many subdirectories (heuristic for project root)\n+        try:\n+            subdirs = [p for p in path.iterdir() if p.is_dir()]\n+            if len(subdirs) > 10:  # Arbitrary threshold\n+                return True\n+        except (OSError, PermissionError):\n+            pass\n+            \n+        return False\n+    except (OSError, ValueError):\n+        return False\n \n     def watched_files(self, include_globs=True):\n         \"\"\"\n",
    "variant_8": "diff --git a/django/template/autoreload.py b/django/template/autoreload.py\nindex cf1b20ba95..c36921488a 100644\n--- a/django/template/autoreload.py\n+++ b/django/template/autoreload.py\n@@ -9,6 +9,7 @@ from django.utils.autoreload import (\n )\n \n \n+\n def get_template_directories():\n     # Iterate through each template backend and find\n     # any template_loader that has a 'get_dirs' method.\n@@ -19,16 +20,27 @@ def get_template_directories():\n         if not isinstance(backend, DjangoTemplates):\n             continue\n \n-        items.update(cwd / to_path(dir) for dir in backend.engine.dirs)\n+        # Filter out directories that are too broad (like project root)\n+        for dir in backend.engine.dirs:\n+            dir_path = cwd / to_path(dir)\n+            # Skip if directory is the current working directory (project root)\n+            # or if it's a parent of cwd (even broader)\n+            if dir_path == cwd or cwd.is_relative_to(dir_path):\n+                continue\n+            items.add(dir_path)\n \n         for loader in backend.engine.template_loaders:\n             if not hasattr(loader, 'get_dirs'):\n                 continue\n-            items.update(\n-                cwd / to_path(directory)\n-                for directory in loader.get_dirs()\n-                if not is_django_path(directory)\n-            )\n+            for directory in loader.get_dirs():\n+                if is_django_path(directory):\n+                    continue\n+                dir_path = cwd / to_path(directory)\n+                # Skip if directory is the current working directory (project root)\n+                # or if it's a parent of cwd (even broader)\n+                if dir_path == cwd or cwd.is_relative_to(dir_path):\n+                    continue\n+                items.add(dir_path)\n     return items\n \n \n@@ -40,10 +52,43 @@ def reset_loaders():\n             loader.reset()\n \n \n+\n @receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')\n def watch_for_template_changes(sender, **kwargs):\n     for directory in get_template_directories():\n-        sender.watch_dir(directory, '**/*')\n+        # Skip watching directories that are likely project roots to prevent\n+        # overwhelming the file watcher with too many files\n+        if _is_project_root(directory):\n+            # For project roots, only watch template files specifically\n+            sender.watch_dir(directory, '**/*.html')\n+            sender.watch_dir(directory, '**/*.txt')\n+        else:\n+            sender.watch_dir(directory, '**/*')\n+\n+\n+def _is_project_root(directory):\n+    \"\"\"\n+    Check if a directory appears to be a Django project root.\n+    Project roots typically contain manage.py and should not be watched recursively.\n+    \"\"\"\n+    directory = Path(directory)\n+    \n+    # Check if directory contains common Django project files\n+    if (directory / 'manage.py').exists():\n+        return True\n+    \n+    # Check if directory contains settings module indicators\n+    if any((directory / name).exists() for name in ['settings.py', 'settings']):\n+        return True\n+    \n+    # Check if this is the current working directory (common for project roots)\n+    try:\n+        if directory.resolve() == Path.cwd().resolve():\n+            return True\n+    except (OSError, RuntimeError):\n+        pass\n+    \n+    return False\n \n \n @receiver(file_changed, dispatch_uid='template_loaders_file_changed')\ndiff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 583c2be647..b50ac7670c 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -163,34 +163,45 @@ def iter_modules_and_files(modules, extra_files):\n \n \n @functools.lru_cache(maxsize=1)\n-def common_roots(paths):\n+\n+def watch_for_template_changes():\n+    for directory in get_template_directories():\n+        # Skip watching directories that are likely project roots to prevent\n+        # performance issues with recursive file watching\n+        if _is_project_root_directory(directory):\n+            continue\n+        # Use a more specific pattern for template files to reduce overhead\n+        autoreload.watch_dir(directory, '**/*.html')\n+\n+\n+def _is_project_root_directory(directory):\n     \"\"\"\n-    Return a tuple of common roots that are shared between the given paths.\n-    File system watchers operate on directories and aren't cheap to create.\n-    Try to find the minimum set of directories to watch that encompass all of\n-    the files that need to be watched.\n+    Check if a directory appears to be a Django project root that shouldn't\n+    be watched recursively due to performance concerns.\n     \"\"\"\n-    # Inspired from Werkzeug:\n-    # https://github.com/pallets/werkzeug/blob/7477be2853df70a022d9613e765581b9411c3c39/werkzeug/_reloader.py\n-    # Create a sorted list of the path components, longest first.\n-    path_parts = sorted([x.parts for x in paths], key=len, reverse=True)\n-    tree = {}\n-    for chunks in path_parts:\n-        node = tree\n-        # Add each part of the path to the tree.\n-        for chunk in chunks:\n-            node = node.setdefault(chunk, {})\n-        # Clear the last leaf in the tree.\n-        node.clear()\n-\n-    # Turn the tree into a list of Path instances.\n-    def _walk(node, path):\n-        for prefix, child in node.items():\n-            yield from _walk(child, path + (prefix,))\n-        if not node:\n-            yield Path(*path)\n-\n-    return tuple(_walk(tree, ()))\n+    directory = Path(directory)\n+    \n+    # Check if directory contains common Django project files\n+    project_indicators = ['manage.py', 'settings.py', 'wsgi.py', 'asgi.py']\n+    if any((directory / indicator).exists() for indicator in project_indicators):\n+        return True\n+    \n+    # Check if directory is the current working directory (common for BASE_DIR)\n+    try:\n+        if directory.resolve() == Path.cwd().resolve():\n+            return True\n+    except (OSError, ValueError):\n+        pass\n+    \n+    # Check if directory has an excessive number of subdirectories\n+    try:\n+        subdirs = [p for p in directory.iterdir() if p.is_dir()]\n+        if len(subdirs) > 20:  # Arbitrary threshold for \"too many\" subdirectories\n+            return True\n+    except (OSError, PermissionError):\n+        pass\n+    \n+    return False\n \n \n def sys_path_directories():\n@@ -273,19 +284,48 @@ class BaseReloader:\n         self.directory_globs = defaultdict(set)\n         self._stop_condition = threading.Event()\n \n-    def watch_dir(self, path, glob):\n-        path = Path(path)\n-        try:\n-            path = path.absolute()\n-        except FileNotFoundError:\n+\n+def watch_for_template_changes():\n+    for directory in get_template_directories():\n+        # Skip watching directories that are likely project roots to prevent\n+        # performance issues with recursive file watching\n+        if _is_project_root_directory(directory):\n             logger.debug(\n-                'Unable to watch directory %s as it cannot be resolved.',\n-                path,\n-                exc_info=True,\n+                'Skipping template directory %s as it appears to be a project root.',\n+                directory\n             )\n-            return\n-        logger.debug('Watching dir %s with glob %s.', path, glob)\n-        self.directory_globs[path].add(glob)\n+            continue\n+        autoreload.watch_dir(directory, '**/*.html')\n+\n+\n+def _is_project_root_directory(directory):\n+    \"\"\"\n+    Check if a directory is likely a project root that shouldn't be watched\n+    recursively to avoid performance issues.\n+    \"\"\"\n+    directory = Path(directory)\n+    \n+    # Check if directory contains common Django project files\n+    django_indicators = ['manage.py', 'wsgi.py', 'asgi.py', 'settings.py']\n+    if any((directory / indicator).exists() for indicator in django_indicators):\n+        return True\n+    \n+    # Check if directory is the current working directory (common for BASE_DIR)\n+    try:\n+        if directory.resolve() == Path.cwd().resolve():\n+            return True\n+    except (OSError, RuntimeError):\n+        pass\n+    \n+    # Check if directory has an excessive number of subdirectories\n+    try:\n+        subdirs = [p for p in directory.iterdir() if p.is_dir()]\n+        if len(subdirs) > 20:  # Arbitrary threshold for \"too many\" subdirectories\n+            return True\n+    except (OSError, PermissionError):\n+        pass\n+    \n+    return False\n \n     def watched_files(self, include_globs=True):\n         \"\"\"\n"
  }
}