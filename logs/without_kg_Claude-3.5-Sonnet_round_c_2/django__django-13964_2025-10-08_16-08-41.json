{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/django/django/db/models/fields/related_descriptors.py lines 256-257)": "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                # This prevents capturing empty/None primary key values that may be set later\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # If the related object doesn't have a valid primary key yet,\n                    # clear the foreign key field to avoid stale values\n                    setattr(instance, lh_field.attname, None)\n",
    "Location 2 (/root/hy/projects_2/django/django/db/models/fields/related_descriptors.py lines 251-252)": "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                # This prevents capturing empty/None primary keys that may be set later\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # Clear the foreign key field if related object has no valid primary key\n                    setattr(instance, lh_field.attname, None)\n",
    "Location 3 (/root/hy/projects_2/django/django/db/models/fields/related_descriptors.py lines 259-261)": "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                # This prevents capturing empty/None primary keys that may be set later\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # Clear the foreign key field if related object has no valid primary key\n                    setattr(instance, lh_field.attname, None)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        # Only cache if we have a valid foreign key relationship\n        if value is not None:\n            # Check if all foreign key fields have valid values before caching\n            cache_valid = True\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                if rh_value is None or rh_value == '':\n                    cache_valid = False\n                    break\n            \n            if cache_valid:\n                self.field.set_cached_value(instance, value)\n        else:\n            self.field.set_cached_value(instance, value)\n",
    "Location 4 (/root/hy/projects_2/django/django/db/models/fields/related_descriptors.py lines 266-267)": "\n        # Set the related object on the forward side of the relation.\n        for lh_field, rh_field in self.field.related_fields:\n            rh_value = getattr(value, rh_field.attname)\n            # Only set the foreign key if the related object has a valid primary key\n            # This prevents capturing empty/unset primary keys that may be set later\n            if rh_value is not None and rh_value != '':\n                setattr(instance, lh_field.attname, rh_value)\n            else:\n                # If the related object doesn't have a valid primary key yet,\n                # clear the foreign key field and defer the assignment\n                setattr(instance, lh_field.attname, None)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n\n        # If this is a one-to-one relation, set the reverse accessor cache on\n        # the related object to the current instance to avoid an extra SQL\n        # query if it's accessed later on.\n        if value is not None and not remote_field.multiple:\n            # Only set reverse cache if we actually set the foreign key\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                if rh_value is not None and rh_value != '':\n                    remote_field.set_cached_value(value, instance)\n                    break\n",
    "Location 5 (/root/hy/projects_2/django/django/db/models/fields/related_descriptors.py lines 203-212)": "\n    def __set__(self, instance, value):\n        \"\"\"\n        Set the related instance through the forward relation.\n\n        With the example above, when setting ``child.parent = parent``:\n\n        - ``self`` is the descriptor managing the ``parent`` attribute\n        - ``instance`` is the ``child`` instance\n        - ``value`` is the ``parent`` instance on the right of the equal sign\n        \n        Note: If the related object has an empty primary key, the foreign key\n        assignment will be deferred until the related object gets a valid primary key.\n        \"\"\"\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/django/django/db/models/fields/related_descriptors.py lines 256-257)": [
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                # This prevents capturing empty/None primary key values that might change later\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # If the related object doesn't have a valid primary key yet,\n                    # clear the foreign key field to avoid stale references\n                    setattr(instance, lh_field.attname, None)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                # This prevents capturing empty/None primary keys that may be set later\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # Clear the foreign key field if related object has no valid primary key\n                    setattr(instance, lh_field.attname, None)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                # This prevents capturing empty/None primary keys that may be set later\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # Clear the foreign key field if related object has no valid primary key\n                    setattr(instance, lh_field.attname, None)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                # Get the primary key value from the related object\n                pk_value = getattr(value, rh_field.attname)\n                \n                # Only set the foreign key if the related object has a valid primary key\n                # This prevents capturing empty/default primary key values that may change later\n                if pk_value is not None and pk_value != '' and pk_value != 0:\n                    setattr(instance, lh_field.attname, pk_value)\n                else:\n                    # If the related object doesn't have a valid primary key yet,\n                    # we'll defer the foreign key assignment. The foreign key field\n                    # will be set when the related object is saved and gets a valid primary key.\n                    # For now, we don't set the foreign key field, but we still cache the instance.\n                    pass\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                # This prevents capturing empty/None primary keys that may be set later\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # Clear the foreign key field if related object's PK is empty\n                    setattr(instance, lh_field.attname, None)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                # This prevents capturing empty/None primary key values that might be set later\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # If the related object doesn't have a valid primary key yet,\n                    # clear the foreign key field to avoid stale references\n                    setattr(instance, lh_field.attname, None)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                # This prevents capturing empty/None primary keys that may be set later\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # Clear the foreign key field if related object's pk is empty/None\n                    setattr(instance, lh_field.attname, None)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                # This prevents capturing empty/None primary key values that may be set later\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # Clear the foreign key field if related object's primary key is empty\n                    setattr(instance, lh_field.attname, None)\n"
    ],
    "Location 2 (/root/hy/projects_2/django/django/db/models/fields/related_descriptors.py lines 251-252)": [
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                # This prevents capturing empty/None primary key values that may be set later\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # If the related object doesn't have a valid primary key yet,\n                    # clear the foreign key field to avoid stale values\n                    setattr(instance, lh_field.attname, None)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                # This prevents capturing empty/None primary keys that may be set later\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # Clear the foreign key field if related object has no valid primary key\n                    setattr(instance, lh_field.attname, None)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                # This prevents capturing empty/None primary keys that may be set later\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # Clear the foreign key field if related object has invalid primary key\n                    setattr(instance, lh_field.attname, None)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                # This prevents capturing empty/None primary key values that may be set later\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # Clear the foreign key field if related object has no valid primary key\n                    setattr(instance, lh_field.attname, None)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                # If the primary key is empty/None, defer the assignment\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # Clear the foreign key field when related object has invalid primary key\n                    setattr(instance, lh_field.attname, None)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                # This prevents capturing empty/None primary key values that might be set later\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # Clear the foreign key field if related object's primary key is empty\n                    setattr(instance, lh_field.attname, None)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                # This prevents capturing empty/None primary keys that may be set later\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # Clear the foreign key field if related object has no valid primary key\n                    setattr(instance, lh_field.attname, None)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                # If the primary key is empty/None, defer the assignment\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # Clear the foreign key field if related object has no valid primary key\n                    setattr(instance, lh_field.attname, None)\n"
    ],
    "Location 3 (/root/hy/projects_2/django/django/db/models/fields/related_descriptors.py lines 259-261)": [
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                # This prevents capturing empty/None primary keys that may be set later\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # If the related object doesn't have a valid primary key yet,\n                    # clear the foreign key field to avoid stale references\n                    setattr(instance, lh_field.attname, None)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        # Only cache if we have a valid foreign key relationship\n        if value is not None:\n            # Check if all foreign key fields have valid values before caching\n            cache_valid = True\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                if rh_value is None or rh_value == '':\n                    cache_valid = False\n                    break\n            \n            if cache_valid:\n                self.field.set_cached_value(instance, value)\n            else:\n                # Clear the cache if foreign key is not valid\n                self.field.set_cached_value(instance, None)\n        else:\n            self.field.set_cached_value(instance, value)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                # This prevents capturing empty/None primary keys that may be set later\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # Clear the foreign key field if related object has no valid primary key\n                    setattr(instance, lh_field.attname, None)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                # If the primary key is empty/None, defer setting until it's available\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # Store a reference to update the foreign key later when the related object gets a valid PK\n                    if not hasattr(instance, '_deferred_fk_assignments'):\n                        instance._deferred_fk_assignments = {}\n                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n\n        # If this is a one-to-one relation, set the reverse accessor cache on\n        # the related object to the current instance to avoid an extra SQL\n        # query if it's accessed later on.\n        if value is not None and not remote_field.multiple:\n            remote_field.set_cached_value(value, instance)\n            \n            # Set up a signal handler to update deferred foreign key assignments\n            # when the related object's primary key is saved\n            def update_deferred_fk(sender, instance_obj, **kwargs):\n                if hasattr(instance, '_deferred_fk_assignments'):\n                    for lh_attname, (related_obj, rh_attname) in list(instance._deferred_fk_assignments.items()):\n                        if related_obj is instance_obj:\n                            rh_value = getattr(related_obj, rh_attname)\n                            if rh_value is not None and rh_value != '':\n                                setattr(instance, lh_attname, rh_value)\n                                del instance._deferred_fk_assignments[lh_attname]\n            \n            # Connect the signal handler if we have deferred assignments\n            if hasattr(instance, '_deferred_fk_assignments') and instance._deferred_fk_assignments:\n                signals.post_save.connect(update_deferred_fk, sender=value.__class__, weak=False)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                # This prevents capturing empty/None primary keys that may be set later\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # If the related object doesn't have a valid primary key yet,\n                    # clear the foreign key field to avoid stale values\n                    setattr(instance, lh_field.attname, None)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                # This prevents capturing empty/None primary key values that may be set later\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # If the related object doesn't have a valid primary key yet,\n                    # clear the foreign key field to avoid stale references\n                    setattr(instance, lh_field.attname, None)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                # This prevents capturing empty/None primary key values that may be set later\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # If the related object doesn't have a valid primary key yet,\n                    # clear the foreign key field to avoid stale values\n                    setattr(instance, lh_field.attname, None)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                # This prevents capturing empty/None primary keys that may be set later\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # If related object doesn't have a valid primary key yet,\n                    # clear the foreign key field to avoid stale references\n                    setattr(instance, lh_field.attname, None)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n",
      "\n        # Set the values of the related field.\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                # This prevents capturing empty/None primary keys that may be set later\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # Clear the foreign key field if related object has no valid primary key\n                    setattr(instance, lh_field.attname, None)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        # Only cache if we have a valid foreign key relationship\n        if value is not None:\n            # Check if all foreign key fields have valid values before caching\n            all_fk_valid = True\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                if rh_value is None or rh_value == '':\n                    all_fk_valid = False\n                    break\n            \n            if all_fk_valid:\n                self.field.set_cached_value(instance, value)\n        else:\n            self.field.set_cached_value(instance, value)\n"
    ],
    "Location 4 (/root/hy/projects_2/django/django/db/models/fields/related_descriptors.py lines 266-267)": [
      "\n        # Set the related object on the related field\n        if value is None:\n            for lh_field, rh_field in self.field.related_fields:\n                setattr(instance, lh_field.attname, None)\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                # Check if the related object has a valid primary key value\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a non-empty primary key\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # Store a reference to update the foreign key later when the related object gets a valid primary key\n                    if not hasattr(instance, '_deferred_fk_assignments'):\n                        instance._deferred_fk_assignments = {}\n                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n\n        # If this is a one-to-one relation, set the reverse accessor cache on\n        # the related object to the current instance to avoid an extra SQL\n        # query if it's accessed later on.\n        if value is not None and not remote_field.multiple:\n            remote_field.set_cached_value(value, instance)\n",
      "\n        # Set the concrete fk value on the to-be-saved instance\n        for lh_field, rh_field in self.field.related_fields:\n            # Check if the related object's primary key is empty/unset\n            rh_value = getattr(value, rh_field.attname)\n            if rh_value in (None, ''):\n                # Don't set the foreign key field if the related object's pk is empty\n                # This prevents foreign key constraint violations\n                continue\n            setattr(instance, lh_field.attname, rh_value)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n\n        # If this is a one-to-one relation, set the reverse accessor cache on\n        # the related object to the current instance to avoid an extra SQL\n        # query if it's accessed later on.\n        if value is not None and not remote_field.multiple:\n            remote_field.set_cached_value(value, instance)\n",
      "\n        # Set the related object on the related field of all the related fields.\n        for lh_field, rh_field in self.field.related_fields:\n            # Check if the related object's primary key is empty/None\n            rh_value = getattr(value, rh_field.attname)\n            if rh_value is None or rh_value == '':\n                # Don't set the foreign key field if the related object's PK is empty\n                # This prevents foreign key constraint violations\n                continue\n            setattr(instance, lh_field.attname, rh_value)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n\n        # If this is a one-to-one relation, set the reverse accessor cache on\n        # the related object to the current instance to avoid an extra SQL\n        # query if it's accessed later on.\n        if value is not None and not remote_field.multiple:\n            # Only set reverse cache if foreign key was actually assigned\n            pk_value = getattr(value, value._meta.pk.attname)\n            if pk_value is not None and pk_value != '':\n                remote_field.set_cached_value(value, instance)\n",
      "\n        # Set the concrete foreign key value on the model instance.\n        if value is None:\n            for lh_field, rh_field in self.field.related_fields:\n                setattr(instance, lh_field.attname, None)\n        else:\n            # Check if the related object has a valid primary key\n            has_valid_pk = True\n            for lh_field, rh_field in self.field.related_fields:\n                pk_value = getattr(value, rh_field.attname)\n                # Consider empty string, None, or 0 as invalid primary key values\n                if pk_value is None or pk_value == '' or pk_value == 0:\n                    has_valid_pk = False\n                    break\n            \n            if has_valid_pk:\n                # Primary key is valid, set foreign key fields normally\n                for lh_field, rh_field in self.field.related_fields:\n                    setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n            else:\n                # Primary key is invalid/empty, defer assignment by storing reference\n                # and setting up a callback to update foreign key when pk becomes valid\n                def update_fk_when_pk_set():\n                    for lh_field, rh_field in self.field.related_fields:\n                        pk_value = getattr(value, rh_field.attname)\n                        if pk_value is not None and pk_value != '' and pk_value != 0:\n                            setattr(instance, lh_field.attname, pk_value)\n                \n                # Store the update function to be called later\n                if not hasattr(instance, '_deferred_fk_updates'):\n                    instance._deferred_fk_updates = []\n                instance._deferred_fk_updates.append((self.field, value, update_fk_when_pk_set))\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n\n        # If this is a one-to-one relation, set the reverse accessor cache on\n        # the related object to the current instance to avoid an extra SQL\n        # query if it's accessed later on.\n        if value is not None and not remote_field.multiple:\n            # Only set reverse cache if we have a valid foreign key assignment\n            has_valid_fk = True\n            for lh_field, rh_field in self.field.related_fields:\n                if getattr(instance, lh_field.attname) is None:\n                    has_valid_fk = False\n                    break\n            \n            if has_valid_fk:\n                remote_field.set_cached_value(value, instance)\n",
      "\n            # Set the related object on the related field on all related fields:\n            for lh_field, rh_field in self.field.related_fields:\n                rh_value = getattr(value, rh_field.attname)\n                # Only set the foreign key if the related object has a valid primary key\n                # This prevents capturing empty/default primary key values that may change later\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # If the related object doesn't have a valid primary key yet,\n                    # we'll need to update the foreign key when it gets one\n                    # For now, set it to None to avoid foreign key violations\n                    setattr(instance, lh_field.attname, None)\n",
      "\n        # Set the related fields on the current instance\n        for lh_field, rh_field in self.field.related_fields:\n            rh_value = getattr(value, rh_field.attname)\n            # Only set the foreign key if the related object has a valid primary key\n            # This prevents capturing empty/default primary key values\n            if rh_value is not None and rh_value != '':\n                setattr(instance, lh_field.attname, rh_value)\n            else:\n                # If the related object doesn't have a valid primary key yet,\n                # clear the foreign key field to avoid stale values\n                setattr(instance, lh_field.attname, None)\n",
      "\n        # Set the related object on the related field on the model instance.\n        if value is None:\n            # An object that's related to a given instance is being removed.\n            for lh_field, rh_field in self.field.related_fields:\n                setattr(instance, lh_field.attname, None)\n        else:\n            # Check if the related object has a valid primary key before setting foreign key fields\n            has_valid_pk = True\n            for lh_field, rh_field in self.field.related_fields:\n                pk_value = getattr(value, rh_field.attname)\n                if pk_value in (None, ''):\n                    has_valid_pk = False\n                    break\n            \n            if has_valid_pk:\n                # Related object has valid primary key, set foreign key fields normally\n                for lh_field, rh_field in self.field.related_fields:\n                    setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n            else:\n                # Related object doesn't have valid primary key, defer assignment\n                # Store the related object for later assignment when it gets a valid primary key\n                if not hasattr(instance, '_deferred_fk_assignments'):\n                    instance._deferred_fk_assignments = {}\n                instance._deferred_fk_assignments[self.field.name] = value\n                \n                # Clear the foreign key fields for now\n                for lh_field, rh_field in self.field.related_fields:\n                    setattr(instance, lh_field.attname, None)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n\n        # If this is a one-to-one relation, set the reverse accessor cache on\n        # the related object to the current instance to avoid an extra SQL\n        # query if it's accessed later on.\n        if value is not None and not remote_field.multiple:\n            # Only set reverse cache if we successfully set the foreign key fields\n            if not hasattr(instance, '_deferred_fk_assignments') or self.field.name not in instance._deferred_fk_assignments:\n                remote_field.set_cached_value(value, instance)\n",
      "\n        # Set the related object on the related field\n        if value is not None:\n            for lh_field, rh_field in self.field.related_fields:\n                # Check if the related object has a valid primary key value\n                rh_value = getattr(value, rh_field.attname)\n                if rh_value is not None and rh_value != '':\n                    setattr(instance, lh_field.attname, rh_value)\n                else:\n                    # Defer foreign key assignment until related object has valid PK\n                    # Store reference to update FK when related object's PK is set\n                    if not hasattr(instance, '_deferred_fk_assignments'):\n                        instance._deferred_fk_assignments = {}\n                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n        else:\n            for lh_field, rh_field in self.field.related_fields:\n                setattr(instance, lh_field.attname, None)\n\n        # Set the related instance cache used by __get__ to avoid an SQL query\n        # when accessing the attribute we just set.\n        self.field.set_cached_value(instance, value)\n\n        # If this is a one-to-one relation, set the reverse accessor cache on\n        # the related object to the current instance to avoid an extra SQL\n        # query if it's accessed later on.\n        if value is not None and not remote_field.multiple:\n            # Only set reverse cache if FK assignment was successful\n            fk_assigned = True\n            for lh_field, rh_field in self.field.related_fields:\n                if hasattr(instance, '_deferred_fk_assignments') and lh_field.attname in instance._deferred_fk_assignments:\n                    fk_assigned = False\n                    break\n            if fk_assigned:\n                remote_field.set_cached_value(value, instance)\n"
    ],
    "Location 5 (/root/hy/projects_2/django/django/db/models/fields/related_descriptors.py lines 203-212)": [
      "\n    def __set__(self, instance, value):\n        \"\"\"\n        Set the related instance through the forward relation.\n\n        With the example above, when setting ``child.parent = parent``:\n\n        - ``self`` is the descriptor managing the ``parent`` attribute\n        - ``instance`` is the ``child`` instance\n        - ``value`` is the ``parent`` instance on the right of the equal sign\n        \n        Note: If the related object has an empty or unset primary key,\n        the foreign key assignment will be deferred until the related\n        object obtains a valid primary key value.\n        \"\"\"\n",
      "\n    def __set__(self, instance, value):\n        \"\"\"\n        Set the related instance through the forward relation.\n\n        With the example above, when setting ``child.parent = parent``:\n\n        - ``self`` is the descriptor managing the ``parent`` attribute\n        - ``instance`` is the ``child`` instance\n        - ``value`` is the ``parent`` instance on the right of the equal sign\n        \n        Note: If the related object has an empty or None primary key,\n        the foreign key assignment will be deferred until the related\n        object obtains a valid primary key value.\n        \"\"\"\n",
      "\n    def __set__(self, instance, value):\n        \"\"\"\n        Set the related instance through the forward relation.\n\n        With the example above, when setting ``child.parent = parent``:\n\n        - ``self`` is the descriptor managing the ``parent`` attribute\n        - ``instance`` is the ``child`` instance\n        - ``value`` is the ``parent`` instance on the right of the equal sign\n        \n        Note: If the related object has an empty or unset primary key,\n        the foreign key assignment will be deferred until the related\n        object has a valid primary key value.\n        \"\"\"\n",
      "\n    def __set__(self, instance, value):\n        \"\"\"\n        Set the related instance through the forward relation.\n\n        With the example above, when setting ``child.parent = parent``:\n\n        - ``self`` is the descriptor managing the ``parent`` attribute\n        - ``instance`` is the ``child`` instance\n        - ``value`` is the ``parent`` instance on the right of the equal sign\n        \n        Note: If the related object has an empty or unset primary key,\n        the foreign key assignment will be deferred until the related\n        object has a valid primary key value.\n        \"\"\"\n",
      "\n    def __set__(self, instance, value):\n        \"\"\"\n        Set the related instance through the forward relation.\n\n        With the example above, when setting ``child.parent = parent``:\n\n        - ``self`` is the descriptor managing the ``parent`` attribute\n        - ``instance`` is the ``child`` instance\n        - ``value`` is the ``parent`` instance on the right of the equal sign\n        \n        Note: If the related object has an empty or None primary key, the foreign\n        key assignment will be deferred until the related object has a valid primary key.\n        \"\"\"\n        # An object must be an instance of the related class.\n        if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n            raise ValueError(\n                'Cannot assign \"%r\": \"%s.%s\" must be a \"%s\" instance.' % (\n                    value,\n                    instance._meta.object_name,\n                    self.field.name,\n                    self.field.remote_field.model._meta.object_name,\n                )\n            )\n\n        # If null=True, we can assign None here.\n        if value is None:\n            # Clear the foreign key field and caches\n            setattr(instance, self.field.attname, None)\n            # Clear the cached related object\n            self.field.delete_cached_value(instance)\n        else:\n            # Check if the related object has a valid primary key\n            related_pk = value._get_pk_val()\n            if related_pk is not None and related_pk != '':\n                # Set the foreign key field to the related object's primary key\n                setattr(instance, self.field.attname, related_pk)\n                # Set the cached related object\n                self.field.set_cached_value(instance, value)\n                # Set the reverse relation cache if applicable\n                if self.field.remote_field.is_cached(value):\n                    remote_field = self.field.remote_field\n                    if remote_field.multiple:\n                        manager = remote_field.get_cached_value(value)\n                        if manager is not None:\n                            manager._add_item(instance)\n                    else:\n                        remote_field.set_cached_value(value, instance)\n            else:\n                # Related object has no valid primary key - store the object but don't set foreign key yet\n                # This allows the foreign key to be set later when the related object gets a valid primary key\n                self.field.set_cached_value(instance, value)\n                # Clear the foreign key field since we can't set it to an invalid value\n                setattr(instance, self.field.attname, None)\n",
      "\n    def __set__(self, instance, value):\n        \"\"\"\n        Set the related instance through the forward relation.\n\n        With the example above, when setting ``child.parent = parent``:\n\n        - ``self`` is the descriptor managing the ``parent`` attribute\n        - ``instance`` is the ``child`` instance\n        - ``value`` is the ``parent`` instance on the right of the equal sign\n        \n        If the related object has an empty or None primary key, the foreign key\n        assignment is deferred until the related object has a valid primary key.\n        \"\"\"\n",
      "\n    def __set__(self, instance, value):\n        \"\"\"\n        Set the related instance through the forward relation.\n\n        With the example above, when setting ``child.parent = parent``:\n\n        - ``self`` is the descriptor managing the ``parent`` attribute\n        - ``instance`` is the ``child`` instance\n        - ``value`` is the ``parent`` instance on the right of the equal sign\n        \n        Note: If the related object has an empty or None primary key, the foreign\n        key assignment will be deferred until the related object gets a valid\n        primary key value.\n        \"\"\"\n",
      "\n    def __set__(self, instance, value):\n        \"\"\"\n        Set the related instance through the forward relation.\n\n        With the example above, when setting ``child.parent = parent``:\n\n        - ``self`` is the descriptor managing the ``parent`` attribute\n        - ``instance`` is the ``child`` instance\n        - ``value`` is the ``parent`` instance on the right of the equal sign\n        \n        Note: If the related object has an empty or unset primary key,\n        the foreign key assignment will be deferred until the related\n        object obtains a valid primary key value.\n        \"\"\"\n        # An object must be an instance of the related class.\n        if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n            raise ValueError(\n                'Cannot assign \"%r\": \"%s.%s\" must be a \"%s\" instance.' % (\n                    value,\n                    instance._meta.object_name,\n                    self.field.name,\n                    self.field.remote_field.model._meta.object_name,\n                )\n            )\n\n        # Set the values of the related field.\n        if value is None:\n            # Set the foreign key field to None\n            setattr(instance, self.field.attname, None)\n        else:\n            # Get the primary key value from the related object\n            related_pk = value._get_pk_val()\n            \n            # Only set the foreign key if the related object has a valid primary key\n            # Empty strings, None, and other falsy values indicate invalid/unset primary keys\n            if related_pk:\n                setattr(instance, self.field.attname, related_pk)\n            else:\n                # Defer foreign key assignment - don't set the attname field yet\n                # The foreign key will need to be set later when the related object gets a valid PK\n                pass\n\n        # Set the related instance cache regardless of foreign key assignment status\n        # This allows the relationship to work even when foreign key assignment is deferred\n        self.field.set_cached_value(instance, value)\n\n        # Set the reverse relation cache on the related object\n        if value is not None and self.field.remote_field.is_cached(value):\n            self.field.remote_field.set_cached_value(value, instance)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex 872a4c98dc..649f74f6cb 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -200,6 +200,7 @@ class ForwardManyToOneDescriptor:\n         else:\n             return rel_obj\n \n+\n     def __set__(self, instance, value):\n         \"\"\"\n         Set the related instance through the forward relation.\n@@ -209,6 +210,9 @@ class ForwardManyToOneDescriptor:\n         - ``self`` is the descriptor managing the ``parent`` attribute\n         - ``instance`` is the ``child`` instance\n         - ``value`` is the ``parent`` instance on the right of the equal sign\n+        \n+        Note: If the related object's primary key is empty or invalid,\n+        the foreign key field will be set to None instead of the empty value.\n         \"\"\"\n         # An object must be an instance of the related class.\n         if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n@@ -248,13 +252,24 @@ class ForwardManyToOneDescriptor:\n             if related is not None:\n                 remote_field.set_cached_value(related, None)\n \n+\n             for lh_field, rh_field in self.field.related_fields:\n                 setattr(instance, lh_field.attname, None)\n \n         # Set the values of the related field.\n         else:\n+\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+                # Get the foreign key value from the related object\n+                fk_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                # For CharField primary keys, empty string is considered invalid\n+                if fk_value or (fk_value is not None and not isinstance(rh_field, type(rh_field)) or not getattr(rh_field, 'empty_strings_allowed', True)):\n+                    setattr(instance, lh_field.attname, fk_value)\n+                else:\n+                    # If the related object's primary key is empty/invalid, set foreign key to None\n+                    setattr(instance, lh_field.attname, None)\n+\n \n         # Set the related instance cache used by __get__ to avoid an SQL query\n         # when accessing the attribute we just set.\n@@ -263,6 +278,7 @@ class ForwardManyToOneDescriptor:\n         # If this is a one-to-one relation, set the reverse accessor cache on\n         # the related object to the current instance to avoid an extra SQL\n         # query if it's accessed later on.\n+\n         if value is not None and not remote_field.multiple:\n             remote_field.set_cached_value(value, instance)\n \n",
    "variant_0": "diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex 872a4c98dc..81727d6d23 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -200,6 +200,7 @@ class ForwardManyToOneDescriptor:\n         else:\n             return rel_obj\n \n+\n     def __set__(self, instance, value):\n         \"\"\"\n         Set the related instance through the forward relation.\n@@ -209,6 +210,9 @@ class ForwardManyToOneDescriptor:\n         - ``self`` is the descriptor managing the ``parent`` attribute\n         - ``instance`` is the ``child`` instance\n         - ``value`` is the ``parent`` instance on the right of the equal sign\n+        \n+        Note: If the related object has an empty primary key, the foreign key\n+        assignment will be deferred until the related object gets a valid primary key.\n         \"\"\"\n         # An object must be an instance of the related class.\n         if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n@@ -248,13 +252,80 @@ class ForwardManyToOneDescriptor:\n             if related is not None:\n                 remote_field.set_cached_value(related, None)\n \n+\n+        # Set the values of the related field.\n+        else:\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, None)\n+                rh_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                # This prevents capturing empty/None primary keys that may be set later\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # Clear the foreign key field if related object has no valid primary key\n+                    setattr(instance, lh_field.attname, None)\n+\n+        # Set the values of the related field.\n+        else:\n \n         # Set the values of the related field.\n         else:\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+                rh_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                # This prevents capturing empty/None primary key values that may be set later\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # If the related object doesn't have a valid primary key yet,\n+                    # clear the foreign key field to avoid stale values\n+                    setattr(instance, lh_field.attname, None)\n+\n+\n+        # Set the values of the related field.\n+        else:\n+            for lh_field, rh_field in self.field.related_fields:\n+                rh_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                # This prevents capturing empty/None primary keys that may be set later\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # Clear the foreign key field if related object has no valid primary key\n+                    setattr(instance, lh_field.attname, None)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        # Only cache if we have a valid foreign key relationship\n+        if value is not None:\n+            # Check if all foreign key fields have valid values before caching\n+            cache_valid = True\n+            for lh_field, rh_field in self.field.related_fields:\n+                rh_value = getattr(value, rh_field.attname)\n+                if rh_value is None or rh_value == '':\n+                    cache_valid = False\n+                    break\n+            \n+            if cache_valid:\n+                self.field.set_cached_value(instance, value)\n+        else:\n+            self.field.set_cached_value(instance, value)\n+\n+        # If this is a one-to-one relation, set the reverse accessor cache on\n+        # the related object to the current instance to avoid an extra SQL\n+        # query if it's accessed later on.\n+\n+        # Set the related object on the forward side of the relation.\n+        for lh_field, rh_field in self.field.related_fields:\n+            rh_value = getattr(value, rh_field.attname)\n+            # Only set the foreign key if the related object has a valid primary key\n+            # This prevents capturing empty/unset primary keys that may be set later\n+            if rh_value is not None and rh_value != '':\n+                setattr(instance, lh_field.attname, rh_value)\n+            else:\n+                # If the related object doesn't have a valid primary key yet,\n+                # clear the foreign key field and defer the assignment\n+                setattr(instance, lh_field.attname, None)\n \n         # Set the related instance cache used by __get__ to avoid an SQL query\n         # when accessing the attribute we just set.\n@@ -264,7 +335,12 @@ class ForwardManyToOneDescriptor:\n         # the related object to the current instance to avoid an extra SQL\n         # query if it's accessed later on.\n         if value is not None and not remote_field.multiple:\n-            remote_field.set_cached_value(value, instance)\n+            # Only set reverse cache if we actually set the foreign key\n+            for lh_field, rh_field in self.field.related_fields:\n+                rh_value = getattr(value, rh_field.attname)\n+                if rh_value is not None and rh_value != '':\n+                    remote_field.set_cached_value(value, instance)\n+                    break\n \n     def __reduce__(self):\n         \"\"\"\n",
    "variant_1": "diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex 872a4c98dc..dbfaf24e74 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -200,6 +200,7 @@ class ForwardManyToOneDescriptor:\n         else:\n             return rel_obj\n \n+\n     def __set__(self, instance, value):\n         \"\"\"\n         Set the related instance through the forward relation.\n@@ -209,6 +210,10 @@ class ForwardManyToOneDescriptor:\n         - ``self`` is the descriptor managing the ``parent`` attribute\n         - ``instance`` is the ``child`` instance\n         - ``value`` is the ``parent`` instance on the right of the equal sign\n+        \n+        Note: If the related object has an empty or unset primary key,\n+        the foreign key assignment will be deferred until the related\n+        object obtains a valid primary key value.\n         \"\"\"\n         # An object must be an instance of the related class.\n         if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n@@ -248,13 +253,90 @@ class ForwardManyToOneDescriptor:\n             if related is not None:\n                 remote_field.set_cached_value(related, None)\n \n+\n+        # Set the values of the related field.\n+        else:\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, None)\n+                rh_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                # This prevents capturing empty/None primary key values that may be set later\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # If the related object doesn't have a valid primary key yet,\n+                    # clear the foreign key field to avoid stale values\n+                    setattr(instance, lh_field.attname, None)\n+\n+        # Set the values of the related field.\n+        else:\n \n         # Set the values of the related field.\n         else:\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+                rh_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                # This prevents capturing empty/None primary key values that might change later\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # If the related object doesn't have a valid primary key yet,\n+                    # clear the foreign key field to avoid stale references\n+                    setattr(instance, lh_field.attname, None)\n+\n+\n+        # Set the values of the related field.\n+        else:\n+            for lh_field, rh_field in self.field.related_fields:\n+                rh_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                # This prevents capturing empty/None primary keys that may be set later\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # If the related object doesn't have a valid primary key yet,\n+                    # clear the foreign key field to avoid stale references\n+                    setattr(instance, lh_field.attname, None)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        # Only cache if we have a valid foreign key relationship\n+        if value is not None:\n+            # Check if all foreign key fields have valid values before caching\n+            cache_valid = True\n+            for lh_field, rh_field in self.field.related_fields:\n+                rh_value = getattr(value, rh_field.attname)\n+                if rh_value is None or rh_value == '':\n+                    cache_valid = False\n+                    break\n+            \n+            if cache_valid:\n+                self.field.set_cached_value(instance, value)\n+            else:\n+                # Clear the cache if foreign key is not valid\n+                self.field.set_cached_value(instance, None)\n+        else:\n+            self.field.set_cached_value(instance, value)\n+\n+        # If this is a one-to-one relation, set the reverse accessor cache on\n+        # the related object to the current instance to avoid an extra SQL\n+        # query if it's accessed later on.\n+\n+        # Set the related object on the related field\n+        if value is None:\n+            for lh_field, rh_field in self.field.related_fields:\n+                setattr(instance, lh_field.attname, None)\n+        else:\n+            for lh_field, rh_field in self.field.related_fields:\n+                # Check if the related object has a valid primary key value\n+                rh_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a non-empty primary key\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # Store a reference to update the foreign key later when the related object gets a valid primary key\n+                    if not hasattr(instance, '_deferred_fk_assignments'):\n+                        instance._deferred_fk_assignments = {}\n+                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n \n         # Set the related instance cache used by __get__ to avoid an SQL query\n         # when accessing the attribute we just set.\n",
    "variant_2": "diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex 872a4c98dc..c46ed38fb6 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -200,6 +200,7 @@ class ForwardManyToOneDescriptor:\n         else:\n             return rel_obj\n \n+\n     def __set__(self, instance, value):\n         \"\"\"\n         Set the related instance through the forward relation.\n@@ -209,6 +210,10 @@ class ForwardManyToOneDescriptor:\n         - ``self`` is the descriptor managing the ``parent`` attribute\n         - ``instance`` is the ``child`` instance\n         - ``value`` is the ``parent`` instance on the right of the equal sign\n+        \n+        Note: If the related object has an empty or None primary key,\n+        the foreign key assignment will be deferred until the related\n+        object obtains a valid primary key value.\n         \"\"\"\n         # An object must be an instance of the related class.\n         if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n@@ -248,13 +253,64 @@ class ForwardManyToOneDescriptor:\n             if related is not None:\n                 remote_field.set_cached_value(related, None)\n \n+\n+        # Set the values of the related field.\n+        else:\n+            for lh_field, rh_field in self.field.related_fields:\n+                rh_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                # This prevents capturing empty/None primary keys that may be set later\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # Clear the foreign key field if related object has no valid primary key\n+                    setattr(instance, lh_field.attname, None)\n+\n+        # Set the values of the related field.\n+        else:\n+\n+        # Set the values of the related field.\n+        else:\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, None)\n+                rh_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                # This prevents capturing empty/None primary keys that may be set later\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # Clear the foreign key field if related object has no valid primary key\n+                    setattr(instance, lh_field.attname, None)\n+\n \n         # Set the values of the related field.\n         else:\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+                rh_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                # This prevents capturing empty/None primary keys that may be set later\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # Clear the foreign key field if related object has no valid primary key\n+                    setattr(instance, lh_field.attname, None)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+\n+        # If this is a one-to-one relation, set the reverse accessor cache on\n+        # the related object to the current instance to avoid an extra SQL\n+        # query if it's accessed later on.\n+\n+        # Set the concrete fk value on the to-be-saved instance\n+        for lh_field, rh_field in self.field.related_fields:\n+            # Check if the related object's primary key is empty/unset\n+            rh_value = getattr(value, rh_field.attname)\n+            if rh_value in (None, ''):\n+                # Don't set the foreign key field if the related object's pk is empty\n+                # This prevents foreign key constraint violations\n+                continue\n+            setattr(instance, lh_field.attname, rh_value)\n \n         # Set the related instance cache used by __get__ to avoid an SQL query\n         # when accessing the attribute we just set.\n",
    "variant_3": "diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex 872a4c98dc..1de0954703 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -200,6 +200,7 @@ class ForwardManyToOneDescriptor:\n         else:\n             return rel_obj\n \n+\n     def __set__(self, instance, value):\n         \"\"\"\n         Set the related instance through the forward relation.\n@@ -209,6 +210,10 @@ class ForwardManyToOneDescriptor:\n         - ``self`` is the descriptor managing the ``parent`` attribute\n         - ``instance`` is the ``child`` instance\n         - ``value`` is the ``parent`` instance on the right of the equal sign\n+        \n+        Note: If the related object has an empty or unset primary key,\n+        the foreign key assignment will be deferred until the related\n+        object has a valid primary key value.\n         \"\"\"\n         # An object must be an instance of the related class.\n         if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n@@ -248,13 +253,48 @@ class ForwardManyToOneDescriptor:\n             if related is not None:\n                 remote_field.set_cached_value(related, None)\n \n+\n+        # Set the values of the related field.\n+        else:\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, None)\n+                rh_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                # This prevents capturing empty/None primary keys that may be set later\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # Clear the foreign key field if related object has invalid primary key\n+                    setattr(instance, lh_field.attname, None)\n+\n+        # Set the values of the related field.\n+        else:\n \n         # Set the values of the related field.\n         else:\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+                rh_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                # This prevents capturing empty/None primary keys that may be set later\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # Clear the foreign key field if related object has no valid primary key\n+                    setattr(instance, lh_field.attname, None)\n+\n+\n+        # Set the values of the related field.\n+        else:\n+            for lh_field, rh_field in self.field.related_fields:\n+                rh_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                # If the primary key is empty/None, defer setting until it's available\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # Store a reference to update the foreign key later when the related object gets a valid PK\n+                    if not hasattr(instance, '_deferred_fk_assignments'):\n+                        instance._deferred_fk_assignments = {}\n+                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n \n         # Set the related instance cache used by __get__ to avoid an SQL query\n         # when accessing the attribute we just set.\n@@ -265,6 +305,48 @@ class ForwardManyToOneDescriptor:\n         # query if it's accessed later on.\n         if value is not None and not remote_field.multiple:\n             remote_field.set_cached_value(value, instance)\n+            \n+            # Set up a signal handler to update deferred foreign key assignments\n+            # when the related object's primary key is saved\n+            def update_deferred_fk(sender, instance_obj, **kwargs):\n+                if hasattr(instance, '_deferred_fk_assignments'):\n+                    for lh_attname, (related_obj, rh_attname) in list(instance._deferred_fk_assignments.items()):\n+                        if related_obj is instance_obj:\n+                            rh_value = getattr(related_obj, rh_attname)\n+                            if rh_value is not None and rh_value != '':\n+                                setattr(instance, lh_attname, rh_value)\n+                                del instance._deferred_fk_assignments[lh_attname]\n+            \n+            # Connect the signal handler if we have deferred assignments\n+            if hasattr(instance, '_deferred_fk_assignments') and instance._deferred_fk_assignments:\n+                signals.post_save.connect(update_deferred_fk, sender=value.__class__, weak=False)\n+\n+        # If this is a one-to-one relation, set the reverse accessor cache on\n+        # the related object to the current instance to avoid an extra SQL\n+        # query if it's accessed later on.\n+\n+        # Set the related object on the related field of all the related fields.\n+        for lh_field, rh_field in self.field.related_fields:\n+            # Check if the related object's primary key is empty/None\n+            rh_value = getattr(value, rh_field.attname)\n+            if rh_value is None or rh_value == '':\n+                # Don't set the foreign key field if the related object's PK is empty\n+                # This prevents foreign key constraint violations\n+                continue\n+            setattr(instance, lh_field.attname, rh_value)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+\n+        # If this is a one-to-one relation, set the reverse accessor cache on\n+        # the related object to the current instance to avoid an extra SQL\n+        # query if it's accessed later on.\n+        if value is not None and not remote_field.multiple:\n+            # Only set reverse cache if foreign key was actually assigned\n+            pk_value = getattr(value, value._meta.pk.attname)\n+            if pk_value is not None and pk_value != '':\n+                remote_field.set_cached_value(value, instance)\n \n     def __reduce__(self):\n         \"\"\"\n",
    "variant_4": "diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex 872a4c98dc..df1c23af1b 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -200,6 +200,7 @@ class ForwardManyToOneDescriptor:\n         else:\n             return rel_obj\n \n+\n     def __set__(self, instance, value):\n         \"\"\"\n         Set the related instance through the forward relation.\n@@ -209,6 +210,10 @@ class ForwardManyToOneDescriptor:\n         - ``self`` is the descriptor managing the ``parent`` attribute\n         - ``instance`` is the ``child`` instance\n         - ``value`` is the ``parent`` instance on the right of the equal sign\n+        \n+        Note: If the related object has an empty or unset primary key,\n+        the foreign key assignment will be deferred until the related\n+        object has a valid primary key value.\n         \"\"\"\n         # An object must be an instance of the related class.\n         if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n@@ -248,13 +253,92 @@ class ForwardManyToOneDescriptor:\n             if related is not None:\n                 remote_field.set_cached_value(related, None)\n \n+\n+        # Set the values of the related field.\n+        else:\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, None)\n+                rh_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                # This prevents capturing empty/None primary key values that may be set later\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # Clear the foreign key field if related object has no valid primary key\n+                    setattr(instance, lh_field.attname, None)\n+\n+        # Set the values of the related field.\n+        else:\n+\n+        # Set the values of the related field.\n+        else:\n+            for lh_field, rh_field in self.field.related_fields:\n+                # Get the primary key value from the related object\n+                pk_value = getattr(value, rh_field.attname)\n+                \n+                # Only set the foreign key if the related object has a valid primary key\n+                # This prevents capturing empty/default primary key values that may change later\n+                if pk_value is not None and pk_value != '' and pk_value != 0:\n+                    setattr(instance, lh_field.attname, pk_value)\n+                else:\n+                    # If the related object doesn't have a valid primary key yet,\n+                    # we'll defer the foreign key assignment. The foreign key field\n+                    # will be set when the related object is saved and gets a valid primary key.\n+                    # For now, we don't set the foreign key field, but we still cache the instance.\n+                    pass\n+\n \n         # Set the values of the related field.\n         else:\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+                rh_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                # This prevents capturing empty/None primary keys that may be set later\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # If the related object doesn't have a valid primary key yet,\n+                    # clear the foreign key field to avoid stale values\n+                    setattr(instance, lh_field.attname, None)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+\n+        # If this is a one-to-one relation, set the reverse accessor cache on\n+        # the related object to the current instance to avoid an extra SQL\n+        # query if it's accessed later on.\n+\n+        # Set the concrete foreign key value on the model instance.\n+        if value is None:\n+            for lh_field, rh_field in self.field.related_fields:\n+                setattr(instance, lh_field.attname, None)\n+        else:\n+            # Check if the related object has a valid primary key\n+            has_valid_pk = True\n+            for lh_field, rh_field in self.field.related_fields:\n+                pk_value = getattr(value, rh_field.attname)\n+                # Consider empty string, None, or 0 as invalid primary key values\n+                if pk_value is None or pk_value == '' or pk_value == 0:\n+                    has_valid_pk = False\n+                    break\n+            \n+            if has_valid_pk:\n+                # Primary key is valid, set foreign key fields normally\n+                for lh_field, rh_field in self.field.related_fields:\n+                    setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+            else:\n+                # Primary key is invalid/empty, defer assignment by storing reference\n+                # and setting up a callback to update foreign key when pk becomes valid\n+                def update_fk_when_pk_set():\n+                    for lh_field, rh_field in self.field.related_fields:\n+                        pk_value = getattr(value, rh_field.attname)\n+                        if pk_value is not None and pk_value != '' and pk_value != 0:\n+                            setattr(instance, lh_field.attname, pk_value)\n+                \n+                # Store the update function to be called later\n+                if not hasattr(instance, '_deferred_fk_updates'):\n+                    instance._deferred_fk_updates = []\n+                instance._deferred_fk_updates.append((self.field, value, update_fk_when_pk_set))\n \n         # Set the related instance cache used by __get__ to avoid an SQL query\n         # when accessing the attribute we just set.\n@@ -264,7 +348,15 @@ class ForwardManyToOneDescriptor:\n         # the related object to the current instance to avoid an extra SQL\n         # query if it's accessed later on.\n         if value is not None and not remote_field.multiple:\n-            remote_field.set_cached_value(value, instance)\n+            # Only set reverse cache if we have a valid foreign key assignment\n+            has_valid_fk = True\n+            for lh_field, rh_field in self.field.related_fields:\n+                if getattr(instance, lh_field.attname) is None:\n+                    has_valid_fk = False\n+                    break\n+            \n+            if has_valid_fk:\n+                remote_field.set_cached_value(value, instance)\n \n     def __reduce__(self):\n         \"\"\"\n",
    "variant_5": "diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex 872a4c98dc..8ccd29188d 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -200,6 +200,7 @@ class ForwardManyToOneDescriptor:\n         else:\n             return rel_obj\n \n+\n     def __set__(self, instance, value):\n         \"\"\"\n         Set the related instance through the forward relation.\n@@ -209,8 +210,51 @@ class ForwardManyToOneDescriptor:\n         - ``self`` is the descriptor managing the ``parent`` attribute\n         - ``instance`` is the ``child`` instance\n         - ``value`` is the ``parent`` instance on the right of the equal sign\n+        \n+        Note: If the related object has an empty or None primary key, the foreign\n+        key assignment will be deferred until the related object has a valid primary key.\n         \"\"\"\n         # An object must be an instance of the related class.\n+        if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n+            raise ValueError(\n+                'Cannot assign \"%r\": \"%s.%s\" must be a \"%s\" instance.' % (\n+                    value,\n+                    instance._meta.object_name,\n+                    self.field.name,\n+                    self.field.remote_field.model._meta.object_name,\n+                )\n+            )\n+\n+        # If null=True, we can assign None here.\n+        if value is None:\n+            # Clear the foreign key field and caches\n+            setattr(instance, self.field.attname, None)\n+            # Clear the cached related object\n+            self.field.delete_cached_value(instance)\n+        else:\n+            # Check if the related object has a valid primary key\n+            related_pk = value._get_pk_val()\n+            if related_pk is not None and related_pk != '':\n+                # Set the foreign key field to the related object's primary key\n+                setattr(instance, self.field.attname, related_pk)\n+                # Set the cached related object\n+                self.field.set_cached_value(instance, value)\n+                # Set the reverse relation cache if applicable\n+                if self.field.remote_field.is_cached(value):\n+                    remote_field = self.field.remote_field\n+                    if remote_field.multiple:\n+                        manager = remote_field.get_cached_value(value)\n+                        if manager is not None:\n+                            manager._add_item(instance)\n+                    else:\n+                        remote_field.set_cached_value(value, instance)\n+            else:\n+                # Related object has no valid primary key - store the object but don't set foreign key yet\n+                # This allows the foreign key to be set later when the related object gets a valid primary key\n+                self.field.set_cached_value(instance, value)\n+                # Clear the foreign key field since we can't set it to an invalid value\n+                setattr(instance, self.field.attname, None)\n+        # An object must be an instance of the related class.\n         if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n             raise ValueError(\n                 'Cannot assign \"%r\": \"%s.%s\" must be a \"%s\" instance.' % (\n@@ -248,13 +292,47 @@ class ForwardManyToOneDescriptor:\n             if related is not None:\n                 remote_field.set_cached_value(related, None)\n \n+\n+        # Set the values of the related field.\n+        else:\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, None)\n+                rh_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                # If the primary key is empty/None, defer the assignment\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # Clear the foreign key field when related object has invalid primary key\n+                    setattr(instance, lh_field.attname, None)\n+\n+        # Set the values of the related field.\n+        else:\n \n         # Set the values of the related field.\n         else:\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+                rh_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                # This prevents capturing empty/None primary keys that may be set later\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # Clear the foreign key field if related object's PK is empty\n+                    setattr(instance, lh_field.attname, None)\n+\n+\n+        # Set the values of the related field.\n+        else:\n+            for lh_field, rh_field in self.field.related_fields:\n+                rh_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                # This prevents capturing empty/None primary key values that may be set later\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # If the related object doesn't have a valid primary key yet,\n+                    # clear the foreign key field to avoid stale references\n+                    setattr(instance, lh_field.attname, None)\n \n         # Set the related instance cache used by __get__ to avoid an SQL query\n         # when accessing the attribute we just set.\n@@ -263,8 +341,19 @@ class ForwardManyToOneDescriptor:\n         # If this is a one-to-one relation, set the reverse accessor cache on\n         # the related object to the current instance to avoid an extra SQL\n         # query if it's accessed later on.\n-        if value is not None and not remote_field.multiple:\n-            remote_field.set_cached_value(value, instance)\n+\n+            # Set the related object on the related field on all related fields:\n+            for lh_field, rh_field in self.field.related_fields:\n+                rh_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                # This prevents capturing empty/default primary key values that may change later\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # If the related object doesn't have a valid primary key yet,\n+                    # we'll need to update the foreign key when it gets one\n+                    # For now, set it to None to avoid foreign key violations\n+                    setattr(instance, lh_field.attname, None)\n \n     def __reduce__(self):\n         \"\"\"\n",
    "variant_6": "diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex 872a4c98dc..1559654736 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -200,6 +200,7 @@ class ForwardManyToOneDescriptor:\n         else:\n             return rel_obj\n \n+\n     def __set__(self, instance, value):\n         \"\"\"\n         Set the related instance through the forward relation.\n@@ -209,6 +210,9 @@ class ForwardManyToOneDescriptor:\n         - ``self`` is the descriptor managing the ``parent`` attribute\n         - ``instance`` is the ``child`` instance\n         - ``value`` is the ``parent`` instance on the right of the equal sign\n+        \n+        If the related object has an empty or None primary key, the foreign key\n+        assignment is deferred until the related object has a valid primary key.\n         \"\"\"\n         # An object must be an instance of the related class.\n         if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n@@ -248,13 +252,48 @@ class ForwardManyToOneDescriptor:\n             if related is not None:\n                 remote_field.set_cached_value(related, None)\n \n+\n+        # Set the values of the related field.\n+        else:\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, None)\n+                rh_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                # This prevents capturing empty/None primary key values that might be set later\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # Clear the foreign key field if related object's primary key is empty\n+                    setattr(instance, lh_field.attname, None)\n+\n+        # Set the values of the related field.\n+        else:\n \n         # Set the values of the related field.\n         else:\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+                rh_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                # This prevents capturing empty/None primary key values that might be set later\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # If the related object doesn't have a valid primary key yet,\n+                    # clear the foreign key field to avoid stale references\n+                    setattr(instance, lh_field.attname, None)\n+\n+\n+        # Set the values of the related field.\n+        else:\n+            for lh_field, rh_field in self.field.related_fields:\n+                rh_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                # This prevents capturing empty/None primary key values that may be set later\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # If the related object doesn't have a valid primary key yet,\n+                    # clear the foreign key field to avoid stale values\n+                    setattr(instance, lh_field.attname, None)\n \n         # Set the related instance cache used by __get__ to avoid an SQL query\n         # when accessing the attribute we just set.\n@@ -263,8 +302,18 @@ class ForwardManyToOneDescriptor:\n         # If this is a one-to-one relation, set the reverse accessor cache on\n         # the related object to the current instance to avoid an extra SQL\n         # query if it's accessed later on.\n-        if value is not None and not remote_field.multiple:\n-            remote_field.set_cached_value(value, instance)\n+\n+        # Set the related fields on the current instance\n+        for lh_field, rh_field in self.field.related_fields:\n+            rh_value = getattr(value, rh_field.attname)\n+            # Only set the foreign key if the related object has a valid primary key\n+            # This prevents capturing empty/default primary key values\n+            if rh_value is not None and rh_value != '':\n+                setattr(instance, lh_field.attname, rh_value)\n+            else:\n+                # If the related object doesn't have a valid primary key yet,\n+                # clear the foreign key field to avoid stale values\n+                setattr(instance, lh_field.attname, None)\n \n     def __reduce__(self):\n         \"\"\"\n",
    "variant_7": "diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex 872a4c98dc..be1f06cc3a 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -200,6 +200,7 @@ class ForwardManyToOneDescriptor:\n         else:\n             return rel_obj\n \n+\n     def __set__(self, instance, value):\n         \"\"\"\n         Set the related instance through the forward relation.\n@@ -209,6 +210,10 @@ class ForwardManyToOneDescriptor:\n         - ``self`` is the descriptor managing the ``parent`` attribute\n         - ``instance`` is the ``child`` instance\n         - ``value`` is the ``parent`` instance on the right of the equal sign\n+        \n+        Note: If the related object has an empty or None primary key, the foreign\n+        key assignment will be deferred until the related object gets a valid\n+        primary key value.\n         \"\"\"\n         # An object must be an instance of the related class.\n         if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n@@ -248,13 +253,88 @@ class ForwardManyToOneDescriptor:\n             if related is not None:\n                 remote_field.set_cached_value(related, None)\n \n+\n+        # Set the values of the related field.\n+        else:\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, None)\n+                rh_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                # This prevents capturing empty/None primary keys that may be set later\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # Clear the foreign key field if related object has no valid primary key\n+                    setattr(instance, lh_field.attname, None)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+\n+        # Set the values of the related field.\n+        else:\n \n         # Set the values of the related field.\n         else:\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+                rh_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                # This prevents capturing empty/None primary keys that may be set later\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # Clear the foreign key field if related object's pk is empty/None\n+                    setattr(instance, lh_field.attname, None)\n+\n+\n+        # Set the values of the related field.\n+        else:\n+            for lh_field, rh_field in self.field.related_fields:\n+                rh_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                # This prevents capturing empty/None primary keys that may be set later\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # If related object doesn't have a valid primary key yet,\n+                    # clear the foreign key field to avoid stale references\n+                    setattr(instance, lh_field.attname, None)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        self.field.set_cached_value(instance, value)\n+\n+        # If this is a one-to-one relation, set the reverse accessor cache on\n+        # the related object to the current instance to avoid an extra SQL\n+        # query if it's accessed later on.\n+\n+        # Set the related object on the related field on the model instance.\n+        if value is None:\n+            # An object that's related to a given instance is being removed.\n+            for lh_field, rh_field in self.field.related_fields:\n+                setattr(instance, lh_field.attname, None)\n+        else:\n+            # Check if the related object has a valid primary key before setting foreign key fields\n+            has_valid_pk = True\n+            for lh_field, rh_field in self.field.related_fields:\n+                pk_value = getattr(value, rh_field.attname)\n+                if pk_value in (None, ''):\n+                    has_valid_pk = False\n+                    break\n+            \n+            if has_valid_pk:\n+                # Related object has valid primary key, set foreign key fields normally\n+                for lh_field, rh_field in self.field.related_fields:\n+                    setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+            else:\n+                # Related object doesn't have valid primary key, defer assignment\n+                # Store the related object for later assignment when it gets a valid primary key\n+                if not hasattr(instance, '_deferred_fk_assignments'):\n+                    instance._deferred_fk_assignments = {}\n+                instance._deferred_fk_assignments[self.field.name] = value\n+                \n+                # Clear the foreign key fields for now\n+                for lh_field, rh_field in self.field.related_fields:\n+                    setattr(instance, lh_field.attname, None)\n \n         # Set the related instance cache used by __get__ to avoid an SQL query\n         # when accessing the attribute we just set.\n@@ -264,7 +344,9 @@ class ForwardManyToOneDescriptor:\n         # the related object to the current instance to avoid an extra SQL\n         # query if it's accessed later on.\n         if value is not None and not remote_field.multiple:\n-            remote_field.set_cached_value(value, instance)\n+            # Only set reverse cache if we successfully set the foreign key fields\n+            if not hasattr(instance, '_deferred_fk_assignments') or self.field.name not in instance._deferred_fk_assignments:\n+                remote_field.set_cached_value(value, instance)\n \n     def __reduce__(self):\n         \"\"\"\n",
    "variant_8": "diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex 872a4c98dc..8f9c0d1e70 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -200,6 +200,7 @@ class ForwardManyToOneDescriptor:\n         else:\n             return rel_obj\n \n+\n     def __set__(self, instance, value):\n         \"\"\"\n         Set the related instance through the forward relation.\n@@ -209,8 +210,47 @@ class ForwardManyToOneDescriptor:\n         - ``self`` is the descriptor managing the ``parent`` attribute\n         - ``instance`` is the ``child`` instance\n         - ``value`` is the ``parent`` instance on the right of the equal sign\n+        \n+        Note: If the related object has an empty or unset primary key,\n+        the foreign key assignment will be deferred until the related\n+        object obtains a valid primary key value.\n         \"\"\"\n         # An object must be an instance of the related class.\n+        if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n+            raise ValueError(\n+                'Cannot assign \"%r\": \"%s.%s\" must be a \"%s\" instance.' % (\n+                    value,\n+                    instance._meta.object_name,\n+                    self.field.name,\n+                    self.field.remote_field.model._meta.object_name,\n+                )\n+            )\n+\n+        # Set the values of the related field.\n+        if value is None:\n+            # Set the foreign key field to None\n+            setattr(instance, self.field.attname, None)\n+        else:\n+            # Get the primary key value from the related object\n+            related_pk = value._get_pk_val()\n+            \n+            # Only set the foreign key if the related object has a valid primary key\n+            # Empty strings, None, and other falsy values indicate invalid/unset primary keys\n+            if related_pk:\n+                setattr(instance, self.field.attname, related_pk)\n+            else:\n+                # Defer foreign key assignment - don't set the attname field yet\n+                # The foreign key will need to be set later when the related object gets a valid PK\n+                pass\n+\n+        # Set the related instance cache regardless of foreign key assignment status\n+        # This allows the relationship to work even when foreign key assignment is deferred\n+        self.field.set_cached_value(instance, value)\n+\n+        # Set the reverse relation cache on the related object\n+        if value is not None and self.field.remote_field.is_cached(value):\n+            self.field.remote_field.set_cached_value(value, instance)\n+        # An object must be an instance of the related class.\n         if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model):\n             raise ValueError(\n                 'Cannot assign \"%r\": \"%s.%s\" must be a \"%s\" instance.' % (\n@@ -248,13 +288,84 @@ class ForwardManyToOneDescriptor:\n             if related is not None:\n                 remote_field.set_cached_value(related, None)\n \n+\n+        # Set the values of the related field.\n+        else:\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, None)\n+                rh_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                # If the primary key is empty/None, defer the assignment\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # Clear the foreign key field if related object has no valid primary key\n+                    setattr(instance, lh_field.attname, None)\n+\n+        # Set the values of the related field.\n+        else:\n \n         # Set the values of the related field.\n         else:\n             for lh_field, rh_field in self.field.related_fields:\n-                setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n+                rh_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                # This prevents capturing empty/None primary key values that may be set later\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # Clear the foreign key field if related object's primary key is empty\n+                    setattr(instance, lh_field.attname, None)\n+\n+\n+        # Set the values of the related field.\n+        else:\n+            for lh_field, rh_field in self.field.related_fields:\n+                rh_value = getattr(value, rh_field.attname)\n+                # Only set the foreign key if the related object has a valid primary key\n+                # This prevents capturing empty/None primary keys that may be set later\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # Clear the foreign key field if related object has no valid primary key\n+                    setattr(instance, lh_field.attname, None)\n+\n+        # Set the related instance cache used by __get__ to avoid an SQL query\n+        # when accessing the attribute we just set.\n+        # Only cache if we have a valid foreign key relationship\n+        if value is not None:\n+            # Check if all foreign key fields have valid values before caching\n+            all_fk_valid = True\n+            for lh_field, rh_field in self.field.related_fields:\n+                rh_value = getattr(value, rh_field.attname)\n+                if rh_value is None or rh_value == '':\n+                    all_fk_valid = False\n+                    break\n+            \n+            if all_fk_valid:\n+                self.field.set_cached_value(instance, value)\n+        else:\n+            self.field.set_cached_value(instance, value)\n+\n+        # If this is a one-to-one relation, set the reverse accessor cache on\n+        # the related object to the current instance to avoid an extra SQL\n+        # query if it's accessed later on.\n+\n+        # Set the related object on the related field\n+        if value is not None:\n+            for lh_field, rh_field in self.field.related_fields:\n+                # Check if the related object has a valid primary key value\n+                rh_value = getattr(value, rh_field.attname)\n+                if rh_value is not None and rh_value != '':\n+                    setattr(instance, lh_field.attname, rh_value)\n+                else:\n+                    # Defer foreign key assignment until related object has valid PK\n+                    # Store reference to update FK when related object's PK is set\n+                    if not hasattr(instance, '_deferred_fk_assignments'):\n+                        instance._deferred_fk_assignments = {}\n+                    instance._deferred_fk_assignments[lh_field.attname] = (value, rh_field.attname)\n+        else:\n+            for lh_field, rh_field in self.field.related_fields:\n+                setattr(instance, lh_field.attname, None)\n \n         # Set the related instance cache used by __get__ to avoid an SQL query\n         # when accessing the attribute we just set.\n@@ -264,7 +375,14 @@ class ForwardManyToOneDescriptor:\n         # the related object to the current instance to avoid an extra SQL\n         # query if it's accessed later on.\n         if value is not None and not remote_field.multiple:\n-            remote_field.set_cached_value(value, instance)\n+            # Only set reverse cache if FK assignment was successful\n+            fk_assigned = True\n+            for lh_field, rh_field in self.field.related_fields:\n+                if hasattr(instance, '_deferred_fk_assignments') and lh_field.attname in instance._deferred_fk_assignments:\n+                    fk_assigned = False\n+                    break\n+            if fk_assigned:\n+                remote_field.set_cached_value(value, instance)\n \n     def __reduce__(self):\n         \"\"\"\n"
  }
}