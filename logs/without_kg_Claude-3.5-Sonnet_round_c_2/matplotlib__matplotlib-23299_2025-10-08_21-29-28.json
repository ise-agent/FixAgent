{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/matplotlib/lib/matplotlib/__init__.py lines 673-678)": "\n        elif key == \"backend\" and self is globals().get(\"rcParams\"):\n            val = dict.__getitem__(self, key)\n            if val is rcsetup._auto_backend_sentinel:\n                # Check if we're being called from get_backend() or similar read-only access\n                # by examining the call stack to avoid triggering backend switch during queries\n                import inspect\n                frame = inspect.currentframe()\n                try:\n                    # Look up the call stack to see if this is a read-only access\n                    caller_frame = frame.f_back\n                    while caller_frame:\n                        caller_name = caller_frame.f_code.co_name\n                        # If called from get_backend or similar query functions, don't trigger switch\n                        if caller_name in ('get_backend', '_get_backend_or_none', '__repr__', '__str__'):\n                            return val\n                        caller_frame = caller_frame.f_back\n                finally:\n                    del frame\n                \n                # Only trigger backend switch for actual usage, not queries\n                from matplotlib import pyplot as plt\n                plt.switch_backend(rcsetup._auto_backend_sentinel)\n",
    "Location 2 (/root/hy/projects_2/matplotlib/lib/matplotlib/pyplot.py lines 225-225)": "\ndef __getitem__(self, key):\n    if key == \"backend\" and self._get_backend_or_none() is None:\n        # Check if we're in a context where backend auto-detection\n        # should be deferred (e.g., during rc_context restoration)\n        if hasattr(self, '_defer_backend_resolution') and self._defer_backend_resolution:\n            return rcsetup._auto_backend_sentinel\n        \n        # Check if this is just a read-only query (like get_backend())\n        # by examining the call stack for specific functions\n        import inspect\n        frame = inspect.currentframe()\n        try:\n            # Look up the call stack for get_backend() or similar read-only operations\n            for i in range(5):  # Check a few frames up\n                frame = frame.f_back\n                if frame is None:\n                    break\n                func_name = frame.f_code.co_name\n                # If called from get_backend or similar read-only functions,\n                # don't trigger backend switching\n                if func_name in ('get_backend', '_get_backend_or_none'):\n                    return rcsetup._auto_backend_sentinel\n        finally:\n            del frame\n        \n        # Original auto-backend resolution logic\n        self._auto_backend_sentinel_deprecation()\n        dict.__setitem__(self, key, rcsetup._get_backend_or_none())\n    try:\n        return dict.__getitem__(self, key)\n    except KeyError:\n        raise KeyError(f\"{key} is not a valid rc parameter (see rcParams.keys() for a list of valid parameters)\")\n",
    "Location 3 (/root/hy/projects_2/matplotlib/lib/matplotlib/__init__.py lines 1090-1098)": "\ndef __getitem__(self, key):\n    try:\n        return dict.__getitem__(self, key)\n    except KeyError as err:\n        # Backend auto-detection should not trigger figure destruction\n        # during read-only access like get_backend() calls\n        if key in _auto_backend_sentinel:\n            # Check if we're in a context where figures should be preserved\n            # (e.g., during get_backend() calls or other read-only operations)\n            import inspect\n            frame = inspect.currentframe()\n            try:\n                # Look up the call stack to see if this is a read-only backend query\n                for _ in range(10):  # Check up to 10 frames up\n                    frame = frame.f_back\n                    if frame is None:\n                        break\n                    func_name = frame.f_code.co_name\n                    # If called from get_backend or similar read-only functions,\n                    # don't trigger backend switching\n                    if func_name in ('get_backend', '_get_backend_or_none'):\n                        return _auto_backend_sentinel[key]\n            finally:\n                del frame\n            \n            # Normal backend auto-detection for non-read-only access\n            _auto_backend_sentinel[key] = self._auto_backend()\n        raise err\n",
    "Location 4 (/root/hy/projects_2/matplotlib/lib/matplotlib/__init__.py lines 644-648)": "\ndef __getitem__(self, key):\n    # Avoid triggering backend switching during read-only access\n    if key == 'backend' and hasattr(self, '_in_backend_query'):\n        # Return the current backend without triggering auto-detection\n        if 'backend' in dict.keys(self):\n            return dict.__getitem__(self, key)\n        else:\n            # Backend not explicitly set, return the auto sentinel\n            return rcsetup._auto_backend_sentinel\n    \n    # Set flag to prevent recursive backend switching during queries\n    original_in_query = getattr(self, '_in_backend_query', False)\n    if key == 'backend' and not original_in_query:\n        self._in_backend_query = True\n    \n    try:\n        return dict.__getitem__(self, key)\n    except KeyError:\n        if key == 'backend':\n            # Backend not set, trigger auto-detection only if not in query mode\n            if not getattr(self, '_in_backend_query', False):\n                return rcsetup._auto_backend_sentinel\n            else:\n                # During query, return sentinel without triggering switch\n                return rcsetup._auto_backend_sentinel\n        raise KeyError(f\"{key} is not a valid rc parameter\") from None\n    finally:\n        if key == 'backend' and not original_in_query:\n            self._in_backend_query = False\n",
    "Location 5 (/root/hy/projects_2/matplotlib/lib/matplotlib/pyplot.py lines 941-941)": "\n    def __getitem__(self, key):\n        if key in _deprecated_map:\n            version, alt_key, alt_val, inverse_alt = _deprecated_map[key]\n            _api.warn_deprecated(\n                version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n            return inverse_alt(self._get_backend_or_none(alt_key))\n\n        elif key == \"backend\":\n            val = dict.__getitem__(self, key)\n            if val is _auto_backend_sentinel:\n                # Check if we're in a context where we should avoid auto-detection\n                # to prevent clearing figures inappropriately\n                import threading\n                current_thread = threading.current_thread()\n                if hasattr(current_thread, '_matplotlib_rc_context_active'):\n                    # Return the sentinel without triggering auto-detection\n                    # when we're just querying the backend value\n                    return val\n                from matplotlib import pyplot as plt\n                plt.switch_backend(rcParamsDefault[\"backend\"])\n            return dict.__getitem__(self, key)\n\n        elif key in _validators:\n            if key.startswith(('keymap.', 'animation.')):\n                return self._get_backend_or_none(key)\n            return dict.__getitem__(self, key)\n        elif key == 'backend.qt4':\n            _api.warn_deprecated(\"2.2\", name=\"backend.qt4\")\n            return self._get_backend_or_none(key)\n        else:\n            try:\n                return dict.__getitem__(self, key)\n            except KeyError as err:\n                raise KeyError(f\"{key} is not a valid rc parameter (see \"\n                               f\"rcParams.keys() for a list of valid \"\n                               f\"parameters)\") from err\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/matplotlib/lib/matplotlib/__init__.py lines 673-678)": [
      "\n        elif key == \"backend\" and self is globals().get(\"rcParams\"):\n            val = dict.__getitem__(self, key)\n            if val is rcsetup._auto_backend_sentinel:\n                # Check if we're in a context where backend auto-detection\n                # should be deferred (e.g., during get_backend() calls)\n                if getattr(self, '_defer_backend_resolution', False):\n                    return val\n                from matplotlib import pyplot as plt\n                plt.switch_backend(rcsetup._auto_backend_sentinel)\n",
      "\n        elif key == \"backend\" and self is globals().get(\"rcParams\"):\n            val = dict.__getitem__(self, key)\n            if val is rcsetup._auto_backend_sentinel:\n                # Check if we're in a read-only context (like get_backend())\n                # by examining the call stack to avoid triggering backend switch\n                # during simple queries\n                frame = sys._getframe(1)\n                caller_name = frame.f_code.co_name\n                # Only trigger auto-backend resolution for actual backend usage,\n                # not for queries like get_backend()\n                if caller_name not in ('get_backend', '_get_backend_or_none'):\n                    from matplotlib import pyplot as plt\n                    plt.switch_backend(rcsetup._auto_backend_sentinel)\n                return val\n",
      "\n    def __getitem__(self, key):\n        if key in _deprecated_map:\n            version, alt_key, alt_val, inverse_alt = _deprecated_map[key]\n            _api.warn_deprecated(\n                version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n            return inverse_alt(dict.__getitem__(self, alt_key))\n\n        elif key in _deprecated_ignore_map:\n            version, alt_key = _deprecated_ignore_map[key]\n            _api.warn_deprecated(\n                version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n            return dict.__getitem__(self, alt_key) if alt_key else None\n\n        # In theory, this should only ever be used after the global rcParams\n        # has been set up, but better be safe e.g. in presence of breakpoints.\n        elif key == \"backend\" and self is globals().get(\"rcParams\"):\n            val = dict.__getitem__(self, key)\n            if val is rcsetup._auto_backend_sentinel:\n                # Check if we're in a read-only context (like get_backend())\n                # by examining the call stack to avoid triggering backend switching\n                # during queries that should not modify state\n                frame = sys._getframe(1)\n                calling_function = frame.f_code.co_name\n                # Avoid auto-backend resolution during read-only operations\n                if calling_function in ('get_backend', '_get_backend_or_none'):\n                    return val\n                from matplotlib import pyplot as plt\n                plt.switch_backend(rcsetup._auto_backend_sentinel)\n\n        return dict.__getitem__(self, key)\n",
      "\n        # In theory, this should only ever be used after the global rcParams\n        # has been set up, but better be safe e.g. in presence of breakpoints.\n        elif key == \"backend\" and self is globals().get(\"rcParams\"):\n            val = dict.__getitem__(self, key)\n            if val is rcsetup._auto_backend_sentinel:\n                # Check if we're in a read-only context (like get_backend())\n                # by examining the call stack to avoid triggering backend switching\n                # during queries that should be non-destructive\n                frame = sys._getframe(1)\n                caller_name = frame.f_code.co_name\n                # If called from get_backend or similar query functions,\n                # return the sentinel without triggering auto-detection\n                if caller_name in ('get_backend', '_get_backend_or_none'):\n                    return val\n                from matplotlib import pyplot as plt\n                plt.switch_backend(rcsetup._auto_backend_sentinel)\n",
      "\n        elif key == \"backend\" and self is globals().get(\"rcParams\"):\n            val = dict.__getitem__(self, key)\n            if val is rcsetup._auto_backend_sentinel:\n                # Check if we're in a context where we should avoid triggering\n                # backend auto-detection (e.g., during get_backend() calls)\n                frame = inspect.currentframe()\n                try:\n                    # Look up the call stack to see if this is a read-only query\n                    caller_frame = frame.f_back\n                    while caller_frame:\n                        caller_name = caller_frame.f_code.co_name\n                        # If called from get_backend or similar query functions,\n                        # return the sentinel without triggering auto-detection\n                        if caller_name in ('get_backend', '_get_backend_or_none'):\n                            return val\n                        caller_frame = caller_frame.f_back\n                finally:\n                    del frame\n                \n                # Only trigger auto-detection for non-query access\n                from matplotlib import pyplot as plt\n                plt.switch_backend(rcsetup._auto_backend_sentinel)\n",
      "\n        elif key == \"backend\" and self is globals().get(\"rcParams\"):\n            val = dict.__getitem__(self, key)\n            if val is rcsetup._auto_backend_sentinel:\n                # Check if we're in a context where we should avoid triggering\n                # backend resolution (e.g., during get_backend() calls)\n                frame = inspect.currentframe()\n                try:\n                    # Look up the call stack to see if we're being called from get_backend()\n                    caller_frame = frame.f_back\n                    while caller_frame:\n                        caller_name = caller_frame.f_code.co_name\n                        if caller_name == 'get_backend':\n                            # Return the sentinel without triggering resolution\n                            return val\n                        caller_frame = caller_frame.f_back\n                finally:\n                    del frame\n                \n                from matplotlib import pyplot as plt\n                plt.switch_backend(rcsetup._auto_backend_sentinel)\n",
      "\n        elif key == \"backend\" and self is globals().get(\"rcParams\"):\n            val = dict.__getitem__(self, key)\n            if val is rcsetup._auto_backend_sentinel:\n                # Check if we're in a context where backend switching should be avoided\n                # to prevent figure destruction during read-only access\n                frame = inspect.currentframe()\n                try:\n                    # Look for get_backend() in the call stack\n                    while frame:\n                        if frame.f_code.co_name == 'get_backend':\n                            # This is a read-only query, don't trigger backend switching\n                            return val\n                        frame = frame.f_back\n                finally:\n                    del frame\n                \n                from matplotlib import pyplot as plt\n                plt.switch_backend(rcsetup._auto_backend_sentinel)\n",
      "\n        elif key == \"backend\" and self is globals().get(\"rcParams\"):\n            val = dict.__getitem__(self, key)\n            if val is rcsetup._auto_backend_sentinel:\n                # Check if we're in a read-only context (e.g., get_backend())\n                # by examining the call stack to avoid triggering backend switch\n                # during queries that should be non-destructive\n                import inspect\n                frame = inspect.currentframe()\n                try:\n                    # Look for get_backend in the call stack\n                    caller_frame = frame.f_back\n                    while caller_frame:\n                        if caller_frame.f_code.co_name == 'get_backend':\n                            # This is a read-only query, return the sentinel without switching\n                            return val\n                        caller_frame = caller_frame.f_back\n                finally:\n                    del frame\n                \n                from matplotlib import pyplot as plt\n                plt.switch_backend(rcsetup._auto_backend_sentinel)\n"
    ],
    "Location 2 (/root/hy/projects_2/matplotlib/lib/matplotlib/pyplot.py lines 225-225)": [
      "\ndef __getitem__(self, key):\n    try:\n        return dict.__getitem__(self, key)\n    except KeyError as err:\n        # Don't trigger backend auto-detection during read-only access\n        # from get_backend() calls, as this can inappropriately destroy figures\n        if key in _auto_backend_sentinel_keys:\n            # Check if we're in a read-only context (like get_backend())\n            import inspect\n            frame = inspect.currentframe()\n            try:\n                # Look up the call stack to see if this is from get_backend()\n                while frame:\n                    if frame.f_code.co_name == 'get_backend':\n                        # Return the sentinel without triggering auto-detection\n                        return rcsetup._auto_backend_sentinel\n                    frame = frame.f_back\n            finally:\n                del frame\n        \n        raise KeyError(f\"{key} is not a valid rc parameter (see \"\n                      f\"rcParams.keys() for a list of valid parameters)\") from err\n",
      "\ndef __getitem__(self, key):\n    try:\n        return dict.__getitem__(self, key)\n    except KeyError as err:\n        # Handle auto backend detection without triggering figure closure\n        if key == 'backend' and dict.__getitem__(self, key) is rcsetup._auto_backend_sentinel:\n            # Check if we're in a read-only context (like get_backend())\n            # by examining the call stack to avoid triggering switch_backend\n            import inspect\n            frame = inspect.currentframe()\n            try:\n                # Look for get_backend in the call stack\n                while frame:\n                    if frame.f_code.co_name == 'get_backend':\n                        # Return the sentinel without triggering backend resolution\n                        return rcsetup._auto_backend_sentinel\n                    frame = frame.f_back\n            finally:\n                del frame\n            \n            # Normal backend resolution path for actual backend switching\n            from . import pyplot as plt\n            plt.switch_backend(rcsetup._auto_backend_sentinel)\n            return dict.__getitem__(self, key)\n        raise KeyError(f\"{key} is not a valid rc parameter (see rcParams.keys() for \"\n                       f\"a list of valid parameters)\") from err\n",
      "\ndef __getitem__(self, key):\n    try:\n        return dict.__getitem__(self, key)\n    except KeyError as err:\n        # Fall back on the default value.\n        key = _get_backend_or_none() or self._get_backend_or_none_orig(key)\n        if key is None:\n            # This should only happen in headless mode.\n            key = rcsetup._auto_backend_sentinel\n        # Check if we're in a context where backend switching should be avoided\n        # (e.g., during read-only queries like get_backend())\n        if (key == 'backend' and \n            hasattr(self, '_in_backend_query') and self._in_backend_query):\n            return rcsetup._auto_backend_sentinel\n        return self._get_backend_or_none_orig(key)\n",
      "\ndef __getitem__(self, key):\n    try:\n        return dict.__getitem__(self, key)\n    except KeyError as err:\n        # Fall back to key without 'backend.' prefix, for deprecated\n        # rcParams like 'backend.qt4'.\n        return dict.__getitem__(self, key.split('.')[-1])\n    except KeyError:\n        # If the key is 'backend' and we're in auto-detection mode,\n        # avoid triggering switch_backend during read-only access\n        if key == 'backend' and dict.__getitem__(self, key) is rcsetup._auto_backend_sentinel:\n            # Check if this is a read-only query vs an actual backend switch\n            import inspect\n            frame = inspect.currentframe()\n            try:\n                # Walk up the call stack to see if this is from get_backend()\n                caller_frame = frame.f_back\n                while caller_frame:\n                    if caller_frame.f_code.co_name == 'get_backend':\n                        # This is a read-only query, return current backend without triggering switch\n                        from matplotlib import _get_backend_or_none\n                        current = _get_backend_or_none()\n                        if current is not None:\n                            return current\n                        break\n                    caller_frame = caller_frame.f_back\n            finally:\n                del frame\n        \n        raise KeyError(f\"{key} is not a valid rc parameter (see rcParams.keys() for \"\n                      f\"a list of valid parameters)\") from err\n",
      "\ndef __getitem__(self, key):\n    try:\n        return dict.__getitem__(self, key)\n    except KeyError as err:\n        # Don't trigger backend switching during read-only access\n        # This prevents get_backend() from inadvertently destroying figures\n        if key == \"backend\" and dict.__getitem__(self, key) is rcsetup._auto_backend_sentinel:\n            # Return the sentinel directly without triggering auto-detection\n            return rcsetup._auto_backend_sentinel\n        raise KeyError(\n            f\"{key!r} is not a valid rc parameter (see rcParams.keys() for \"\n            f\"a list of valid parameters)\") from err\n",
      "\ndef __getitem__(self, key):\n    try:\n        return dict.__getitem__(self, key)\n    except KeyError as err:\n        # Fall back on the original key, which was not found either.\n        # This is used for API compatibility, so that rcParams['backend']\n        # keeps working even though the real key is 'backend.qt5' or\n        # 'backend.macosx' etc.\n        key = rcsetup._hardcoded_defaults.get(key, key)\n        \n        # Special handling for backend parameter to prevent unintended figure destruction\n        if key == 'backend' and dict.__getitem__(self, key) is rcsetup._auto_backend_sentinel:\n            # Check if we're in a read-only context (like get_backend()) vs actual backend switching\n            # by examining the call stack to avoid triggering switch_backend during queries\n            import inspect\n            frame = inspect.currentframe()\n            try:\n                # Look up the call stack to see if this is a read-only query\n                caller_names = []\n                current_frame = frame.f_back\n                depth = 0\n                while current_frame and depth < 10:  # Limit depth to avoid infinite loops\n                    caller_names.append(current_frame.f_code.co_name)\n                    current_frame = current_frame.f_back\n                    depth += 1\n                \n                # If called from get_backend() or other read-only contexts, don't trigger auto-detection\n                if 'get_backend' in caller_names or '_get_backend_or_none' in caller_names:\n                    return rcsetup._auto_backend_sentinel\n            finally:\n                del frame\n        \n        return dict.__getitem__(self, key)\n",
      "\ndef switch_backend(newbackend):\n    \"\"\"\n    Close all open figures and set the Matplotlib backend.\n\n    The backend cannot be changed if a GUI mainloop is running, unless\n    we are switching to a compatible or non-interactive backend.\n\n    Switching to and from non-interactive backends is always possible.\n\n    Parameters\n    ----------\n    newbackend : str\n        The name of the backend to use.\n    \"\"\"\n    global _backend_mod\n    # make sure the init is pulled up so we can assign to it later\n    import matplotlib.backends\n    \n    # Only close figures if this is an explicit backend change, not auto-detection\n    current_backend = matplotlib.get_backend()\n    if (newbackend != current_backend and \n        not (hasattr(matplotlib.rcParams, '_in_auto_backend_detection') and \n             matplotlib.rcParams._in_auto_backend_detection)):\n        close(\"all\")\n\n    if newbackend is rcsetup._auto_backend_sentinel:\n        current_framework = cbook._get_running_interactive_framework()\n        mapping = {'qt': 'qtagg',\n                   'gtk3': 'gtk3agg',\n                   'gtk4': 'gtk4agg',\n                   'wx': 'wxagg',\n                   'tk': 'tkagg',\n                   'macosx': 'macosx',\n                   'headless': 'agg'}\n",
      "\ndef __getitem__(self, key):\n    try:\n        return dict.__getitem__(self, key)\n    except KeyError as err:\n        # Fall back on the original config value if the key is not explicitly\n        # set in this RcParams instance.\n        try:\n            return self._get_backend_or_none()\n        except KeyError:\n            # if it's not a valid key in any of the dictionaries, raise a\n            # KeyError.\n            raise err from None\n\ndef _get_backend_or_none(self):\n    # Check if we're in a context where backend switching would be destructive\n    if (hasattr(_pylab_helpers.Gcf, 'figs') and \n        _pylab_helpers.Gcf.figs and \n        not getattr(threading.current_thread(), '_matplotlib_switching_backend', False)):\n        # We have active figures and we're not in an explicit backend switch\n        # Return the current backend without triggering auto-detection\n        current_backend = matplotlib.get_backend()\n        if current_backend != 'template':\n            return current_backend\n    \n    # Safe to proceed with normal backend resolution\n    return rcsetup._auto_backend_sentinel\n"
    ],
    "Location 3 (/root/hy/projects_2/matplotlib/lib/matplotlib/__init__.py lines 1090-1098)": [
      "\ndef rc_context(rc=None, fname=None):\n    \"\"\"\n    Return a context manager for managing rc settings.\n\n    This allows one to do::\n\n        with mpl.rc_context(fname='screen.rc'):\n            plt.plot(x, y)  # uses 'screen.rc'\n\n    or::\n\n        with mpl.rc_context(rc={'text.usetex': True}):\n            plt.plot(x, y)  # uses usetex\n\n    or::\n\n        with mpl.rc_context(rc={'text.usetex': True}, fname='screen.rc'):\n            plt.plot(x, y)  # uses usetex and 'screen.rc'\n\n    A dictionary can also be passed to the context manager::\n\n        with mpl.rc_context({'text.usetex': True}):\n            plt.plot(x, y)  # uses usetex\n\n    'fname' or 'rc' are not None, they will override any setting\n    in fname.\n\n    See Also\n    --------\n    :ref:`customizing-with-matplotlibrc-files`\n\n    Examples\n    --------\n    Passing explicit values via a dictionary::\n\n        with mpl.rc_context({'axes.spines.left': False}):\n            plt.plot(range(3))\n\n    Loading settings from a file::\n\n         with mpl.rc_context(fname='print.rc'):\n             plt.plot(x, y)  # uses 'print.rc'\n\n    \"\"\"\n    orig = rcParams.copy()\n    try:\n        if fname:\n            rc_file(fname)\n        if rc:\n            rcParams.update(rc)\n        yield\n    finally:\n        # Restore rcParams carefully to avoid triggering backend auto-detection\n        rcParams.clear()\n        for key, value in orig.items():\n            if key == 'backend' and value == rcsetup._auto_backend_sentinel:\n                # For auto backend sentinel, set directly without validation\n                dict.__setitem__(rcParams, key, value)\n            else:\n                rcParams[key] = value\n",
      "\ndef rc_context(rc=None, fname=None):\n    \"\"\"\n    Return a context manager for managing rc settings.\n\n    This allows one to do::\n\n        with mpl.rc_context(fname='screen.rc'):\n            plt.plot(x, y)  # uses 'screen.rc'\n\n    or::\n\n        with mpl.rc_context(rc={'text.usetex': True}):\n            plt.plot(x, y)  # uses usetex\n\n    or::\n\n        with mpl.rc_context(rc={'text.usetex': True}, fname='screen.rc'):\n            plt.plot(x, y)  # uses usetex and 'screen.rc'\n\n    A dictionary can also be passed to the context manager::\n\n        with mpl.rc_context({'text.usetex': True}):\n            plt.plot(x, y)  # uses usetex\n\n    'fname' searches in the same order as a call to `rc_file()`.\n\n    .. note::\n\n       Calling this function affects the global state of matplotlib.\n\n    Examples\n    --------\n    Creating a figure using the context manager::\n\n        with mpl.rc_context():\n            # Set custom rcParams within the context\n            mpl.rcParams['figure.figsize'] = (10, 8)\n            fig, ax = plt.subplots()\n            ax.plot(range(3), range(3))\n            fig.savefig('example.png')\n            plt.close(fig)\n\n    Loading settings from a file::\n\n         with mpl.rc_context(fname='print.rc'):\n             plt.plot(x, y)  # uses 'print.rc'\n\n    \"\"\"\n    orig = rcParams.copy()\n    try:\n        if fname:\n            rc_file(fname)\n        if rc:\n            rcParams.update(rc)\n        yield\n    finally:\n        # Special handling for backend parameter to avoid triggering auto-detection\n        backend_changed = ('backend' in orig and \n                          orig['backend'] != rcParams.get('backend'))\n        \n        if backend_changed and orig['backend'] is rcsetup._auto_backend_sentinel:\n            # If original backend was auto-sentinel, restore it without triggering validation\n            rcParams._data['backend'] = orig['backend']\n            # Restore other parameters normally\n            for key, value in orig.items():\n                if key != 'backend':\n                    rcParams._data[key] = value\n        else:\n            # Normal restoration for all other cases\n            dict.update(rcParams, orig)  # Revert to the original rcs.\n",
      "\ndef __getitem__(self, key):\n    if key in _deprecated_map:\n        version, alt_key, message = _deprecated_map[key]\n        _api.warn_deprecated(\n            version, name=key, obj_type=\"rcparam\", alternative=alt_key,\n            addendum=message)\n        return super().__getitem__(alt_key)\n    elif key == \"backend\":\n        val = dict.__getitem__(self, key)\n        if val is rcsetup._auto_backend_sentinel:\n            # Check if we're in a context where we should avoid auto-detection\n            # to prevent figure destruction during read-only access\n            frame = inspect.currentframe()\n            try:\n                # Look up the call stack to see if this is a read-only query\n                while frame:\n                    frame = frame.f_back\n                    if frame and frame.f_code.co_name in ('get_backend', '_get_backend_or_none'):\n                        # This is a read-only backend query, return the sentinel\n                        # without triggering auto-detection\n                        return val\n                    if frame and 'rc_context' in frame.f_code.co_name:\n                        # We're in rc_context, avoid triggering backend changes\n                        return val\n            finally:\n                del frame\n            from matplotlib import pyplot as plt\n            plt.switch_backend(rcsetup._auto_backend_sentinel)\n        return dict.__getitem__(self, key)\n    elif key in _deprecated_ignore_map:\n        version, alt_key = _deprecated_ignore_map[key]\n        _api.warn_deprecated(\n            version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n        return super().__getitem__(alt_key if alt_key else key)\n    # In theory, this should only ever be used after the global rcParams\n    # has been set up, but better be safe...\n    elif key in rcsetup._validators:\n        if key not in self:\n            self[key] = rcsetup.defaultParams[key]\n    return dict.__getitem__(self, key)\n",
      "\ndef rc_context(rc=None, fname=None):\n    \"\"\"\n    Return a context manager for managing rc settings.\n\n    This allows one to do::\n\n        with mpl.rc_context(fname='screen.rc'):\n            plt.plot(x, y)  # uses 'screen.rc'\n\n    or::\n\n        with mpl.rc_context(rc={'text.usetex': True}):\n            plt.plot(x, y)  # uses usetex\n\n    or::\n\n        with mpl.rc_context(rc={'text.usetex': True}, fname='screen.rc'):\n            plt.plot(x, y)  # uses usetex and 'screen.rc'\n\n    A dictionary can also be passed to the context manager::\n\n        with mpl.rc_context({'text.usetex': True}):\n            plt.plot(x, y)  # uses usetex\n\n    'fname' or 'rc' arguments are applied on top of the current rcParams.\n    Passing a dictionary only to 'fname' is deprecated, and support will be\n    removed two minor releases later.\n\n    See Also\n    --------\n    :ref:`customizing-with-matplotlibrc-files`\n\n    Examples\n    --------\n    This example shows how to use different rc parameters in different parts of\n    a figure::\n\n        fig, (ax1, ax2) = plt.subplots(1, 2)\n        with mpl.rc_context({'axes.linewidth': 3}):\n            ax1.plot(range(3), range(3))\n        ax2.plot(range(3), range(3))\n\n    This example shows how to use different backends to save a figure::\n\n        fig, ax = plt.subplots()\n        ax.plot(range(3), range(3))\n        fig.savefig('example.svg')\n        with mpl.rc_context({'backend': 'PS'}):\n            fig.savefig('example.ps')\n\n    Loading settings from a file::\n\n         with mpl.rc_context(fname='print.rc'):\n             plt.plot(x, y)  # uses 'print.rc'\n\n    \"\"\"\n    orig = rcParams.copy()\n    try:\n        if fname:\n            rc_file(fname)\n        if rc:\n            rcParams.update(rc)\n        yield\n    finally:\n        # Special handling for backend restoration to avoid triggering\n        # auto-detection when restoring _auto_backend_sentinel\n        if 'backend' in orig:\n            backend_orig = orig['backend']\n            if backend_orig == rcsetup._auto_backend_sentinel:\n                # If original was auto-detection sentinel, restore without\n                # triggering backend switching by directly setting the internal value\n                rcParams._data['backend'] = backend_orig\n                orig = {k: v for k, v in orig.items() if k != 'backend'}\n        dict.update(rcParams, orig)  # Revert to the original rcs.\n",
      "\ndef __getitem__(self, key):\n    try:\n        return dict.__getitem__(self, key)\n    except KeyError as err:\n        # Backend auto-detection should not trigger during read-only access\n        # like get_backend() calls. Only trigger when actually setting backend.\n        if key in _auto_backend_sentinel:\n            # Check if we're in a context where backend switching would be inappropriate\n            # by examining the call stack for get_backend() or other read-only operations\n            import inspect\n            frame = inspect.currentframe()\n            try:\n                # Look up the call stack for get_backend or similar read-only functions\n                caller_frame = frame.f_back\n                while caller_frame:\n                    caller_name = caller_frame.f_code.co_name\n                    if caller_name in ('get_backend', '__getitem__', '_get_backend_or_none'):\n                        # This is a read-only access, return the sentinel without triggering auto-detection\n                        return dict.__getitem__(self, key)\n                    caller_frame = caller_frame.f_back\n            finally:\n                del frame\n            \n            # If we reach here, it's likely a legitimate backend setting operation\n            if key == \"backend\":\n                from matplotlib import pyplot as plt\n                plt.switch_backend(_auto_backend_sentinel[key])\n        raise KeyError(f\"{key} is not a valid rc parameter (see rcParams.keys() for \"\n                      f\"a list of valid parameters)\") from err\n",
      "\ndef __getitem__(self, key):\n    try:\n        return dict.__getitem__(self, key)\n    except KeyError as err:\n        # Backend auto-detection should not trigger during read-only access\n        # like get_backend() calls. Only trigger when actually setting backend.\n        if key in _auto_backend_sentinel:\n            # Check if we're in a context where backend switching should be avoided\n            # by examining the call stack for read-only operations\n            import inspect\n            frame = inspect.currentframe()\n            try:\n                # Look for get_backend() in the call stack\n                for i in range(10):  # Check up to 10 frames up\n                    frame = frame.f_back\n                    if frame is None:\n                        break\n                    if frame.f_code.co_name == 'get_backend':\n                        # This is a read-only access, return the sentinel without triggering switch\n                        return _auto_backend_sentinel[key]\n            finally:\n                del frame\n            \n            # If not a read-only access, proceed with normal auto-detection\n            dict.__setitem__(self, key, rcsetup._auto_backend_sentinel)\n            return dict.__getitem__(self, key)\n        raise KeyError(f\"{key} is not a valid rc parameter (see rcParams.keys() for \"\n                       f\"a list of valid parameters)\") from err\n",
      "\ndef __getitem__(self, key):\n    try:\n        return dict.__getitem__(self, key)\n    except KeyError as err:\n        # Check if this is a query for the backend value during read-only operations\n        # like get_backend() to avoid triggering inappropriate backend switching\n        if key == \"backend\" and hasattr(self, '_in_backend_query'):\n            # Return the raw backend value without triggering auto-detection\n            return dict.get(self, key, rcsetup._auto_backend_sentinel)\n        \n        # Only trigger backend resolution for actual configuration access\n        if key == \"backend\":\n            val = _auto_backend_sentinel\n        else:\n            raise KeyError(\n                f\"{key} is not a valid rc parameter (see rcParams.keys() for \"\n                f\"a list of valid parameters)\") from err\n    else:\n        return val\n",
      "\ndef __getitem__(self, key):\n    try:\n        return dict.__getitem__(self, key)\n    except KeyError as err:\n        # Don't trigger backend switching during read-only access like get_backend()\n        if key in _auto_backend_sentinel and key == \"backend\":\n            # Check if we're in a context where backend switching should be avoided\n            # by examining the call stack for read-only operations\n            import inspect\n            frame = inspect.currentframe()\n            try:\n                # Look up the call stack to see if this is from get_backend()\n                caller_frame = frame.f_back\n                while caller_frame:\n                    caller_code = caller_frame.f_code\n                    if caller_code.co_name == 'get_backend':\n                        # This is a read-only access, return the sentinel without triggering auto-detection\n                        return _auto_backend_sentinel[key]\n                    caller_frame = caller_frame.f_back\n            finally:\n                del frame\n        \n        try:\n            return _auto_backend_sentinel[key]\n        except KeyError:\n            # Key not in _auto_backend_sentinel either\n            pass\n        raise err\n"
    ],
    "Location 4 (/root/hy/projects_2/matplotlib/lib/matplotlib/__init__.py lines 644-648)": [
      "\n        elif key == 'backend':\n            if val is rcsetup._auto_backend_sentinel:\n                if 'backend' in self:\n                    return\n                # Check if we're in a read-only context (like get_backend())\n                # to avoid triggering backend switching during queries\n                import inspect\n                frame = inspect.currentframe()\n                try:\n                    # Look up the call stack to see if this is a read-only operation\n                    caller_frame = frame.f_back\n                    while caller_frame:\n                        caller_name = caller_frame.f_code.co_name\n                        # If called from get_backend or similar read operations, don't auto-switch\n                        if caller_name in ('get_backend', '__getitem__', '_get_backend_or_none'):\n                            # Store the sentinel without triggering validation/switching\n                            dict.__setitem__(self, key, val)\n                            return\n                        caller_frame = caller_frame.f_back\n                finally:\n                    del frame\n        try:\n",
      "\n    def __getitem__(self, key):\n        if key == 'backend':\n            val = dict.__getitem__(self, key)\n            if val is rcsetup._auto_backend_sentinel:\n                from matplotlib import pyplot as plt\n                # Check if we're in a context where we should avoid auto-detection\n                # to prevent clearing figures during read-only access\n                if hasattr(plt, '_backend_detection_in_progress'):\n                    return 'Agg'  # Return safe default without triggering detection\n                \n                # Mark that we're doing backend detection to prevent recursion\n                plt._backend_detection_in_progress = True\n                try:\n                    plt.switch_backend(rcsetup._auto_backend_sentinel)\n                finally:\n                    delattr(plt, '_backend_detection_in_progress')\n        return dict.__getitem__(self, key)\n",
      "\n    def __getitem__(self, key):\n        if key in _deprecated_map:\n            version, alt_key, alt_val, inverse_alt = _deprecated_map[key]\n            _api.warn_deprecated(\n                version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n            return inverse_alt(dict.__getitem__(self, alt_key))\n\n        elif key in _deprecated_ignore_map:\n            version, alt_key = _deprecated_ignore_map[key]\n            _api.warn_deprecated(\n                version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n            return dict.__getitem__(self, alt_key)\n\n        elif key in _deprecated_remain_as_none:\n            version, = _deprecated_remain_as_none[key]\n            _api.warn_deprecated(version, name=key, obj_type=\"rcparam\")\n            return None\n\n        # Check for auto backend without triggering switch_backend\n        elif key == 'backend' and dict.__getitem__(self, key) is rcsetup._auto_backend_sentinel:\n            # Import here to avoid circular imports\n            from . import pyplot as plt\n            # Get current backend without triggering a switch\n            current_backend = getattr(plt._backend_mod, 'backend', None)\n            if current_backend is not None:\n                return current_backend\n            # Only trigger backend resolution if no backend is currently active\n            # and we're not in a context that should preserve figures\n            import matplotlib\n            if hasattr(matplotlib, '_called_from_pytest') or getattr(matplotlib, '_in_rc_context', False):\n                # Return a safe default to avoid triggering backend switching\n                return 'Agg'\n            # Fall through to trigger backend resolution only when safe\n            dict.__setitem__(self, key, plt.rcsetup.validate_backend('Agg'))\n            return dict.__getitem__(self, key)\n        \n        return dict.__getitem__(self, key)\n",
      "\n    def __getitem__(self, key):\n        if key in _deprecated_map:\n            version, alt_key, alt_val, inverse_alt = _deprecated_map[key]\n            _api.warn_deprecated(\n                version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n            return inverse_alt(dict.__getitem__(self, alt_key))\n\n        elif key in _deprecated_ignore_map:\n            version, alt_key = _deprecated_ignore_map[key]\n            _api.warn_deprecated(\n                version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n            return dict.__getitem__(self, alt_key)\n\n        elif key in _deprecated_remain_as_none:\n            version, = _deprecated_remain_as_none[key]\n            _api.warn_deprecated(version, name=key, obj_type=\"rcparam\")\n            return None\n\n        # Check if this is just a backend query (like from get_backend()) \n        # vs an actual backend change request\n        elif key == 'backend':\n            val = dict.__getitem__(self, key)\n            if val is rcsetup._auto_backend_sentinel:\n                # Only trigger auto-backend resolution if we're not just querying\n                # Check if this is being called from get_backend() by examining the call stack\n                import inspect\n                frame = inspect.currentframe()\n                try:\n                    # Look for get_backend in the call stack\n                    caller_frame = frame.f_back\n                    while caller_frame:\n                        if caller_frame.f_code.co_name == 'get_backend':\n                            # This is a read-only query from get_backend(), return current backend\n                            # without triggering auto-detection that would clear figures\n                            from matplotlib import pyplot as plt\n                            return plt.rcParams._get_backend_or_none() or 'Agg'\n                        caller_frame = caller_frame.f_back\n                finally:\n                    del frame\n                \n                # If not from get_backend(), proceed with normal auto-detection\n                from matplotlib import pyplot as plt\n                plt.switch_backend(rcsetup._auto_backend_sentinel)\n            return dict.__getitem__(self, key)\n        \n        return dict.__getitem__(self, key)\n",
      "\n    def __getitem__(self, key):\n        try:\n            return dict.__getitem__(self, key)\n        except KeyError:\n            # Don't return _auto_backend_sentinel from queries.\n            if key in _hardcoded_defaults:\n                val = _hardcoded_defaults[key]\n                # Check if this is a read-only access (like get_backend()) vs actual backend setting\n                # by examining the call stack to avoid triggering switch_backend inappropriately\n                if key == 'backend' and val is rcsetup._auto_backend_sentinel:\n                    # Only trigger auto-backend resolution if we're in a context that should change backend\n                    frame = inspect.currentframe()\n                    try:\n                        # Look for switch_backend or other backend-changing operations in call stack\n                        caller_frame = frame.f_back\n                        while caller_frame:\n                            caller_name = caller_frame.f_code.co_name\n                            # Allow auto-backend resolution for legitimate backend switching operations\n                            if caller_name in ('switch_backend', 'use', '_backend_selection'):\n                                break\n                            # Block auto-backend resolution for read-only queries like get_backend\n                            elif caller_name in ('get_backend', '__getitem__', 'validate'):\n                                # Return a safe default instead of triggering auto-detection\n                                return rcsetup._get_backend_or_none() or 'Agg'\n                            caller_frame = caller_frame.f_back\n                    finally:\n                        del frame\n                return val\n            raise\n",
      "\ndef __getitem__(self, key):\n    if key in _deprecated_map:\n        version, alt_key, alt_val, inverse_alt = _deprecated_map[key]\n        _api.warn_deprecated(\n            version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n        return inverse_alt(dict.__getitem__(self, alt_key))\n    elif key in _deprecated_remain_as_none:\n        version, = _deprecated_remain_as_none[key]\n        _api.warn_deprecated(version, name=key, obj_type=\"rcparam\")\n        return dict.__getitem__(self, key)\n    elif key in _deprecated_ignore_map:\n        version, alt_key = _deprecated_ignore_map[key]\n        _api.warn_deprecated(\n            version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n        return dict.__getitem__(self, alt_key)\n    # Special handling for backend to avoid triggering switch during read-only access\n    elif key == 'backend':\n        backend_val = dict.__getitem__(self, key)\n        if backend_val is rcsetup._auto_backend_sentinel:\n            # Only resolve auto backend if we're not in a context that should preserve figures\n            if not getattr(_get_running_interactive_framework, '_in_rc_context', False):\n                backend_val = rcsetup._auto_backend_sentinel\n        return backend_val\n    # backends are a special case: if auto-backend is set, we need to\n    # resolve it to the actual backend being used\n    if (key == 'backend' and dict.__getitem__(self, key) is\n            rcsetup._auto_backend_sentinel):\n        from . import pyplot as plt\n        plt.switch_backend(rcsetup._auto_backend_sentinel)\n        return dict.__getitem__(self, key)\n    return dict.__getitem__(self, key)\n",
      "\n    def __getitem__(self, key):\n        if key in _deprecated_map:\n            version, alt_key, alt_val, inverse_alt = _deprecated_map[key]\n            _api.warn_deprecated(\n                version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n            return inverse_alt(dict.__getitem__(self, alt_key))\n\n        elif key in _deprecated_remain_as_none:\n            version, = _deprecated_remain_as_none[key]\n            _api.warn_deprecated(version, name=key, obj_type=\"rcparam\")\n            return dict.__getitem__(self, key)\n\n        elif key in _deprecated_ignore_map:\n            version, alt_key = _deprecated_ignore_map[key]\n            _api.warn_deprecated(\n                version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n            return dict.__getitem__(self, alt_key)\n\n        # For backend parameter, avoid triggering auto-detection during read-only access\n        elif key == 'backend':\n            val = dict.__getitem__(self, key)\n            if val is rcsetup._auto_backend_sentinel:\n                # Check if we're in a read-only context (like get_backend())\n                # by examining the call stack\n                import inspect\n                frame = inspect.currentframe()\n                try:\n                    # Look for get_backend in the call stack\n                    caller_frame = frame.f_back\n                    while caller_frame:\n                        if caller_frame.f_code.co_name == 'get_backend':\n                            # This is a read-only access, return the sentinel without resolution\n                            return val\n                        caller_frame = caller_frame.f_back\n                    \n                    # Not a read-only access, proceed with auto-detection\n                    if val is rcsetup._auto_backend_sentinel:\n                        from matplotlib import pyplot as plt\n                        plt.switch_backend(rcsetup._auto_backend_sentinel)\n                finally:\n                    del frame\n            return dict.__getitem__(self, key)\n\n        return dict.__getitem__(self, key)\n",
      "\n    def __getitem__(self, key):\n        if key in _deprecated_map:\n            version, alt_key, alt_val, inverse_alt = _deprecated_map[key]\n            _api.warn_deprecated(\n                version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n            return inverse_alt(dict.__getitem__(self, alt_key))\n\n        elif key in _deprecated_ignore_map:\n            version, alt_key = _deprecated_ignore_map[key]\n            _api.warn_deprecated(\n                version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n            return dict.__getitem__(self, alt_key)\n\n        elif key in _deprecated_remain_as_none:\n            version, = _deprecated_remain_as_none[key]\n            _api.warn_deprecated(version, name=key, obj_type=\"rcparam\")\n            return None\n\n        # Check if backend is auto-sentinel and resolve it without triggering switch\n        elif key == 'backend':\n            val = dict.__getitem__(self, key)\n            if val is rcsetup._auto_backend_sentinel:\n                # Resolve auto backend without switching if we're just querying\n                from . import pyplot as plt\n                # Get the current backend without triggering a switch\n                current_backend = plt.get_backend()\n                # Store the resolved backend to avoid repeated resolution\n                dict.__setitem__(self, key, current_backend)\n                return current_backend\n            return val\n        \n        return dict.__getitem__(self, key)\n"
    ],
    "Location 5 (/root/hy/projects_2/matplotlib/lib/matplotlib/pyplot.py lines 941-941)": [
      "\ndef close(fig=None):\n    \"\"\"\n    Close a figure window.\n\n    Parameters\n    ----------\n    fig : None or int or str or `.Figure`\n        The figure to close. There are a number of ways to specify this:\n\n        - None: the current figure\n\n        - `.Figure`: the given `.Figure` instance\n\n        - int: a figure number\n\n        - str: a figure name\n\n        - 'all': all figures\n\n    \"\"\"\n    if fig is None:\n        manager = _pylab_helpers.Gcf.get_active()\n        if manager is None:\n            return\n        else:\n            _pylab_helpers.Gcf.destroy(manager)\n    elif fig == 'all':\n        # Check if we're in the middle of auto-backend detection\n        # to avoid destroying figures during get_backend() calls\n        if (hasattr(matplotlib, '_backend_detection_in_progress') and \n            matplotlib._backend_detection_in_progress):\n            return\n        _pylab_helpers.Gcf.destroy_all()\n    elif isinstance(fig, int):\n        _pylab_helpers.Gcf.destroy(fig)\n    elif hasattr(fig, 'int'):\n        # if we are dealing with a type UUID, we\n        # can use its integer representation\n        _pylab_helpers.Gcf.destroy(fig.int)\n    elif isinstance(fig, str):\n        all_labels = get_figlabels()\n        if fig in all_labels:\n            num = get_fignums()[all_labels.index(fig)]\n",
      "\ndef __getitem__(self, key):\n    # In validate, the rcParam key is validated and the value is\n    # converted to the expected type or raises an exception.\n    # validate calls _get_backend_or_none, which might return None\n    # if no backend is specified.  If None is returned, we should\n    # not trigger backend auto-detection during read-only access.\n    if key == 'backend':\n        # Check if we're in a read-only context (like get_backend())\n        # by examining the call stack for get_backend or similar functions\n        import inspect\n        frame = inspect.currentframe()\n        try:\n            for _ in range(10):  # Check up to 10 frames up\n                frame = frame.f_back\n                if frame is None:\n                    break\n                caller_name = frame.f_code.co_name\n                # If called from get_backend or similar read-only operations,\n                # don't trigger auto-detection\n                if caller_name in ('get_backend', '_get_backend_or_none'):\n                    try:\n                        value = dict.__getitem__(self, key)\n                        return self._validate[key](value) if value is not _auto_backend_sentinel else value\n                    except KeyError:\n                        return _auto_backend_sentinel\n        finally:\n            del frame\n    \n    try:\n        return dict.__getitem__(self, key)\n    except KeyError as err:\n        # __getitem__ raises KeyError, not ValueError, when a key\n        # is not found.\n        raise KeyError(f\"{key} is not a valid rc parameter (see \"\n                       f\"rcParams.keys() for a list of valid parameters)\") from err\n",
      "\ndef __getitem__(self, key):\n    try:\n        return dict.__getitem__(self, key)\n    except KeyError as err:\n        # Handle special case for backend auto-detection\n        if key == \"backend\":\n            # Check if we're in a context where we should avoid triggering\n            # backend switching (e.g., during get_backend() calls)\n            import threading\n            current_thread = threading.current_thread()\n            if hasattr(current_thread, '_matplotlib_backend_query') and current_thread._matplotlib_backend_query:\n                # Return the sentinel without triggering auto-detection\n                return _auto_backend_sentinel\n            \n            # Only trigger auto-detection if not in query mode\n            return _auto_backend_sentinel\n        raise KeyError(f\"{key} is not a valid rc parameter (see rcParams.keys() for \"\n                       f\"a list of valid parameters)\") from err\n",
      "\ndef __getitem__(self, key):\n    # In validate, the rcParam value is validated and returned as a\n    # cleaned value.\n    try:\n        # Check if this is a backend query during rc_context to avoid\n        # triggering switch_backend inappropriately\n        if (key == 'backend' and \n            hasattr(self, '_in_context_manager') and \n            self._in_context_manager and\n            self._get_backend_or_none() is _auto_backend_sentinel):\n            # Return the sentinel without triggering auto-detection\n            return _auto_backend_sentinel\n        return self.validate[key](self._get_backend_or_none() if key == 'backend' else self._val[key])\n    except KeyError:\n        raise KeyError(f\"{key} is not a valid rc parameter (see rcParams.keys() for a list of valid parameters)\") from None\n",
      "\ndef __getitem__(self, key):\n    try:\n        return dict.__getitem__(self, key)\n    except KeyError as err:\n        # Check if this is a backend-related access during a read-only operation\n        # to avoid triggering switch_backend() inappropriately\n        if key == \"backend\" and hasattr(self, '_in_backend_query'):\n            # Return current backend without triggering auto-detection\n            current_backend = dict.get(self, key, _auto_backend_sentinel)\n            if current_backend is _auto_backend_sentinel:\n                # Get the actual backend without triggering figure destruction\n                from . import pyplot as plt\n                return plt.get_backend()\n            return current_backend\n        return _get_configdir() / key\n",
      "\ndef __getitem__(self, key):\n    try:\n        return dict.__getitem__(self, key)\n    except KeyError as err:\n        # Allow raising KeyError for truly invalid keys\n        raise KeyError(f\"{key!r}\") from err\n    except RecursionError as err:\n        raise RecursionError(f\"Recursion in RcParams for {key!r}\") from err\n",
      "\ndef __getitem__(self, key):\n    if key in _deprecated_map:\n        version, alt_key, message = _deprecated_map[key]\n        name = _deprecated_map[key][1]\n        _api.warn_deprecated(\n            version, message=f\"The {key!r} rcParam was deprecated in \"\n            f\"Matplotlib {version} and will be removed %(removal)s. \"\n            f\"Use {alt_key!r} instead.\" if alt_key else message)\n        key = alt_key\n\n    try:\n        return dict.__getitem__(self, key)\n    except KeyError as err:\n        # Check if this is a backend query during context restoration\n        # to prevent unwanted figure destruction\n        if key == \"backend\" and hasattr(self, '_in_context_restoration'):\n            # Return the sentinel without triggering backend resolution\n            return dict.get(self, key, _auto_backend_sentinel)\n        raise KeyError(f\"{key} is not a valid rc parameter (see \"\n                      \"rcParams.keys() for a list of valid parameters)\") from err\n",
      "\ndef __getitem__(self, key):\n    try:\n        return dict.__getitem__(self, key)\n    except KeyError as err:\n        # Handle backend auto-detection without triggering figure destruction\n        if key in _auto_backend_sentinel:\n            # Check if we're in a context where backend switching would be inappropriate\n            # (e.g., during get_backend() calls or when figures exist)\n            if hasattr(_pylab_helpers, 'Gcf') and _pylab_helpers.Gcf.figs:\n                # Figures exist - avoid backend switching that would destroy them\n                # Return a safe backend value without triggering switch_backend\n                current_backend = matplotlib.get_backend()\n                if current_backend != 'template':\n                    return current_backend\n            \n            # Safe to proceed with normal auto-detection\n            from matplotlib import pyplot as plt\n            plt.switch_backend(_auto_backend_sentinel[key])\n            return dict.__getitem__(self, key)\n        raise err\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex c268a56724..77bcad75fd 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -641,6 +641,7 @@ class RcParams(MutableMapping, dict):\n                 _api.warn_deprecated(\n                     version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n                 return\n+\n             elif key == 'backend':\n                 if val is rcsetup._auto_backend_sentinel:\n                     if 'backend' in self:\n@@ -670,12 +671,28 @@ class RcParams(MutableMapping, dict):\n \n         # In theory, this should only ever be used after the global rcParams\n         # has been set up, but better be safe e.g. in presence of breakpoints.\n+\n         elif key == \"backend\" and self is globals().get(\"rcParams\"):\n             val = dict.__getitem__(self, key)\n             if val is rcsetup._auto_backend_sentinel:\n-                from matplotlib import pyplot as plt\n-                plt.switch_backend(rcsetup._auto_backend_sentinel)\n-\n+                # Check if we're in a read-only context (like get_backend())\n+                # by examining the call stack to avoid triggering backend switch\n+                # during informational queries\n+                import inspect\n+                frame = inspect.currentframe()\n+                try:\n+                    # Look for get_backend in the call stack\n+                    while frame:\n+                        if frame.f_code.co_name == 'get_backend':\n+                            # This is a read-only access, don't trigger switch\n+                            break\n+                        frame = frame.f_back\n+                    else:\n+                        # Not called from get_backend, proceed with switch\n+                        from matplotlib import pyplot as plt\n+                        plt.switch_backend(rcsetup._auto_backend_sentinel)\n+                finally:\n+                    del frame\n         return dict.__getitem__(self, key)\n \n     def _get_backend_or_none(self):\n@@ -1087,6 +1104,7 @@ def rc_context(rc=None, fname=None):\n              plt.plot(x, y)  # uses 'print.rc'\n \n     \"\"\"\n+\n     orig = rcParams.copy()\n     try:\n         if fname:\n@@ -1095,7 +1113,14 @@ def rc_context(rc=None, fname=None):\n             rcParams.update(rc)\n         yield\n     finally:\n-        dict.update(rcParams, orig)  # Revert to the original rcs.\n+        # Handle backend restoration more carefully to avoid triggering\n+        # auto-detection when restoring _auto_backend_sentinel\n+        for key, value in orig.items():\n+            if key == 'backend' and value is rcsetup._auto_backend_sentinel:\n+                # Use direct dict assignment to avoid triggering __setitem__ logic\n+                dict.__setitem__(rcParams, key, value)\n+            else:\n+                rcParams[key] = value\n \n \n def use(backend, *, force=True):\ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex e3c66ea67c..2521f18a7e 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -222,7 +222,11 @@ def switch_backend(newbackend):\n     global _backend_mod\n     # make sure the init is pulled up so we can assign to it later\n     import matplotlib.backends\n-    close(\"all\")\n+\n+    # Only close all figures if this is an explicit backend switch,\n+    # not an auto-detection triggered by informational access\n+    if newbackend is not rcsetup._auto_backend_sentinel:\n+        close(\"all\")\n \n     if newbackend is rcsetup._auto_backend_sentinel:\n         current_framework = cbook._get_running_interactive_framework()\n@@ -938,6 +942,7 @@ def close(fig=None):\n         else:\n             _pylab_helpers.Gcf.destroy(manager)\n     elif fig == 'all':\n+\n         _pylab_helpers.Gcf.destroy_all()\n     elif isinstance(fig, int):\n         _pylab_helpers.Gcf.destroy(fig)\n",
    "variant_0": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex c268a56724..209a80f0c0 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -641,11 +641,36 @@ class RcParams(MutableMapping, dict):\n                 _api.warn_deprecated(\n                     version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n                 return\n-            elif key == 'backend':\n-                if val is rcsetup._auto_backend_sentinel:\n-                    if 'backend' in self:\n-                        return\n-            try:\n+\n+def __getitem__(self, key):\n+    # Avoid triggering backend switching during read-only access\n+    if key == 'backend' and hasattr(self, '_in_backend_query'):\n+        # Return the current backend without triggering auto-detection\n+        if 'backend' in dict.keys(self):\n+            return dict.__getitem__(self, key)\n+        else:\n+            # Backend not explicitly set, return the auto sentinel\n+            return rcsetup._auto_backend_sentinel\n+    \n+    # Set flag to prevent recursive backend switching during queries\n+    original_in_query = getattr(self, '_in_backend_query', False)\n+    if key == 'backend' and not original_in_query:\n+        self._in_backend_query = True\n+    \n+    try:\n+        return dict.__getitem__(self, key)\n+    except KeyError:\n+        if key == 'backend':\n+            # Backend not set, trigger auto-detection only if not in query mode\n+            if not getattr(self, '_in_backend_query', False):\n+                return rcsetup._auto_backend_sentinel\n+            else:\n+                # During query, return sentinel without triggering switch\n+                return rcsetup._auto_backend_sentinel\n+        raise KeyError(f\"{key} is not a valid rc parameter\") from None\n+    finally:\n+        if key == 'backend' and not original_in_query:\n+            self._in_backend_query = False\n                 cval = self.validate[key](val)\n             except ValueError as ve:\n                 raise ValueError(f\"Key {key}: {ve}\") from None\n@@ -670,12 +695,29 @@ class RcParams(MutableMapping, dict):\n \n         # In theory, this should only ever be used after the global rcParams\n         # has been set up, but better be safe e.g. in presence of breakpoints.\n+\n         elif key == \"backend\" and self is globals().get(\"rcParams\"):\n             val = dict.__getitem__(self, key)\n             if val is rcsetup._auto_backend_sentinel:\n+                # Check if we're being called from get_backend() or similar read-only access\n+                # by examining the call stack to avoid triggering backend switch during queries\n+                import inspect\n+                frame = inspect.currentframe()\n+                try:\n+                    # Look up the call stack to see if this is a read-only access\n+                    caller_frame = frame.f_back\n+                    while caller_frame:\n+                        caller_name = caller_frame.f_code.co_name\n+                        # If called from get_backend or similar query functions, don't trigger switch\n+                        if caller_name in ('get_backend', '_get_backend_or_none', '__repr__', '__str__'):\n+                            return val\n+                        caller_frame = caller_frame.f_back\n+                finally:\n+                    del frame\n+                \n+                # Only trigger backend switch for actual usage, not queries\n                 from matplotlib import pyplot as plt\n                 plt.switch_backend(rcsetup._auto_backend_sentinel)\n-\n         return dict.__getitem__(self, key)\n \n     def _get_backend_or_none(self):\n@@ -1087,15 +1129,35 @@ def rc_context(rc=None, fname=None):\n              plt.plot(x, y)  # uses 'print.rc'\n \n     \"\"\"\n-    orig = rcParams.copy()\n+\n+def __getitem__(self, key):\n     try:\n-        if fname:\n-            rc_file(fname)\n-        if rc:\n-            rcParams.update(rc)\n-        yield\n-    finally:\n-        dict.update(rcParams, orig)  # Revert to the original rcs.\n+        return dict.__getitem__(self, key)\n+    except KeyError as err:\n+        # Backend auto-detection should not trigger figure destruction\n+        # during read-only access like get_backend() calls\n+        if key in _auto_backend_sentinel:\n+            # Check if we're in a context where figures should be preserved\n+            # (e.g., during get_backend() calls or other read-only operations)\n+            import inspect\n+            frame = inspect.currentframe()\n+            try:\n+                # Look up the call stack to see if this is a read-only backend query\n+                for _ in range(10):  # Check up to 10 frames up\n+                    frame = frame.f_back\n+                    if frame is None:\n+                        break\n+                    func_name = frame.f_code.co_name\n+                    # If called from get_backend or similar read-only functions,\n+                    # don't trigger backend switching\n+                    if func_name in ('get_backend', '_get_backend_or_none'):\n+                        return _auto_backend_sentinel[key]\n+            finally:\n+                del frame\n+            \n+            # Normal backend auto-detection for non-read-only access\n+            _auto_backend_sentinel[key] = self._auto_backend()\n+        raise err\n \n \n def use(backend, *, force=True):\ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex e3c66ea67c..45a5d4d974 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -222,7 +222,39 @@ def switch_backend(newbackend):\n     global _backend_mod\n     # make sure the init is pulled up so we can assign to it later\n     import matplotlib.backends\n-    close(\"all\")\n+\n+def __getitem__(self, key):\n+    if key == \"backend\" and self._get_backend_or_none() is None:\n+        # Check if we're in a context where backend auto-detection\n+        # should be deferred (e.g., during rc_context restoration)\n+        if hasattr(self, '_defer_backend_resolution') and self._defer_backend_resolution:\n+            return rcsetup._auto_backend_sentinel\n+        \n+        # Check if this is just a read-only query (like get_backend())\n+        # by examining the call stack for specific functions\n+        import inspect\n+        frame = inspect.currentframe()\n+        try:\n+            # Look up the call stack for get_backend() or similar read-only operations\n+            for i in range(5):  # Check a few frames up\n+                frame = frame.f_back\n+                if frame is None:\n+                    break\n+                func_name = frame.f_code.co_name\n+                # If called from get_backend or similar read-only functions,\n+                # don't trigger backend switching\n+                if func_name in ('get_backend', '_get_backend_or_none'):\n+                    return rcsetup._auto_backend_sentinel\n+        finally:\n+            del frame\n+        \n+        # Original auto-backend resolution logic\n+        self._auto_backend_sentinel_deprecation()\n+        dict.__setitem__(self, key, rcsetup._get_backend_or_none())\n+    try:\n+        return dict.__getitem__(self, key)\n+    except KeyError:\n+        raise KeyError(f\"{key} is not a valid rc parameter (see rcParams.keys() for a list of valid parameters)\")\n \n     if newbackend is rcsetup._auto_backend_sentinel:\n         current_framework = cbook._get_running_interactive_framework()\n@@ -938,7 +970,43 @@ def close(fig=None):\n         else:\n             _pylab_helpers.Gcf.destroy(manager)\n     elif fig == 'all':\n-        _pylab_helpers.Gcf.destroy_all()\n+\n+    def __getitem__(self, key):\n+        if key in _deprecated_map:\n+            version, alt_key, alt_val, inverse_alt = _deprecated_map[key]\n+            _api.warn_deprecated(\n+                version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n+            return inverse_alt(self._get_backend_or_none(alt_key))\n+\n+        elif key == \"backend\":\n+            val = dict.__getitem__(self, key)\n+            if val is _auto_backend_sentinel:\n+                # Check if we're in a context where we should avoid auto-detection\n+                # to prevent clearing figures inappropriately\n+                import threading\n+                current_thread = threading.current_thread()\n+                if hasattr(current_thread, '_matplotlib_rc_context_active'):\n+                    # Return the sentinel without triggering auto-detection\n+                    # when we're just querying the backend value\n+                    return val\n+                from matplotlib import pyplot as plt\n+                plt.switch_backend(rcParamsDefault[\"backend\"])\n+            return dict.__getitem__(self, key)\n+\n+        elif key in _validators:\n+            if key.startswith(('keymap.', 'animation.')):\n+                return self._get_backend_or_none(key)\n+            return dict.__getitem__(self, key)\n+        elif key == 'backend.qt4':\n+            _api.warn_deprecated(\"2.2\", name=\"backend.qt4\")\n+            return self._get_backend_or_none(key)\n+        else:\n+            try:\n+                return dict.__getitem__(self, key)\n+            except KeyError as err:\n+                raise KeyError(f\"{key} is not a valid rc parameter (see \"\n+                               f\"rcParams.keys() for a list of valid \"\n+                               f\"parameters)\") from err\n     elif isinstance(fig, int):\n         _pylab_helpers.Gcf.destroy(fig)\n     elif hasattr(fig, 'int'):\n",
    "variant_1": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex c268a56724..67d30833f5 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -641,11 +641,29 @@ class RcParams(MutableMapping, dict):\n                 _api.warn_deprecated(\n                     version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n                 return\n-            elif key == 'backend':\n-                if val is rcsetup._auto_backend_sentinel:\n-                    if 'backend' in self:\n-                        return\n-            try:\n+\n+        elif key == 'backend':\n+            if val is rcsetup._auto_backend_sentinel:\n+                if 'backend' in self:\n+                    return\n+                # Check if we're in a read-only context (like get_backend())\n+                # to avoid triggering backend switching during queries\n+                import inspect\n+                frame = inspect.currentframe()\n+                try:\n+                    # Look up the call stack to see if this is a read-only operation\n+                    caller_frame = frame.f_back\n+                    while caller_frame:\n+                        caller_name = caller_frame.f_code.co_name\n+                        # If called from get_backend or similar read operations, don't auto-switch\n+                        if caller_name in ('get_backend', '__getitem__', '_get_backend_or_none'):\n+                            # Store the sentinel without triggering validation/switching\n+                            dict.__setitem__(self, key, val)\n+                            return\n+                        caller_frame = caller_frame.f_back\n+                finally:\n+                    del frame\n+        try:\n                 cval = self.validate[key](val)\n             except ValueError as ve:\n                 raise ValueError(f\"Key {key}: {ve}\") from None\n@@ -670,12 +688,16 @@ class RcParams(MutableMapping, dict):\n \n         # In theory, this should only ever be used after the global rcParams\n         # has been set up, but better be safe e.g. in presence of breakpoints.\n+\n         elif key == \"backend\" and self is globals().get(\"rcParams\"):\n             val = dict.__getitem__(self, key)\n             if val is rcsetup._auto_backend_sentinel:\n+                # Check if we're in a context where backend auto-detection\n+                # should be deferred (e.g., during get_backend() calls)\n+                if getattr(self, '_defer_backend_resolution', False):\n+                    return val\n                 from matplotlib import pyplot as plt\n                 plt.switch_backend(rcsetup._auto_backend_sentinel)\n-\n         return dict.__getitem__(self, key)\n \n     def _get_backend_or_none(self):\n@@ -1087,6 +1109,51 @@ def rc_context(rc=None, fname=None):\n              plt.plot(x, y)  # uses 'print.rc'\n \n     \"\"\"\n+\n+def rc_context(rc=None, fname=None):\n+    \"\"\"\n+    Return a context manager for managing rc settings.\n+\n+    This allows one to do::\n+\n+        with mpl.rc_context(fname='screen.rc'):\n+            plt.plot(x, y)  # uses 'screen.rc'\n+\n+    or::\n+\n+        with mpl.rc_context(rc={'text.usetex': True}):\n+            plt.plot(x, y)  # uses usetex\n+\n+    or::\n+\n+        with mpl.rc_context(rc={'text.usetex': True}, fname='screen.rc'):\n+            plt.plot(x, y)  # uses usetex and 'screen.rc'\n+\n+    A dictionary can also be passed to the context manager::\n+\n+        with mpl.rc_context({'text.usetex': True}):\n+            plt.plot(x, y)  # uses usetex\n+\n+    'fname' or 'rc' are not None, they will override any setting\n+    in fname.\n+\n+    See Also\n+    --------\n+    :ref:`customizing-with-matplotlibrc-files`\n+\n+    Examples\n+    --------\n+    Passing explicit values via a dictionary::\n+\n+        with mpl.rc_context({'axes.spines.left': False}):\n+            plt.plot(range(3))\n+\n+    Loading settings from a file::\n+\n+         with mpl.rc_context(fname='print.rc'):\n+             plt.plot(x, y)  # uses 'print.rc'\n+\n+    \"\"\"\n     orig = rcParams.copy()\n     try:\n         if fname:\n@@ -1095,7 +1162,14 @@ def rc_context(rc=None, fname=None):\n             rcParams.update(rc)\n         yield\n     finally:\n-        dict.update(rcParams, orig)  # Revert to the original rcs.\n+        # Restore rcParams carefully to avoid triggering backend auto-detection\n+        rcParams.clear()\n+        for key, value in orig.items():\n+            if key == 'backend' and value == rcsetup._auto_backend_sentinel:\n+                # For auto backend sentinel, set directly without validation\n+                dict.__setitem__(rcParams, key, value)\n+            else:\n+                rcParams[key] = value\n \n \n def use(backend, *, force=True):\ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex e3c66ea67c..0eea3d22cf 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -222,7 +222,29 @@ def switch_backend(newbackend):\n     global _backend_mod\n     # make sure the init is pulled up so we can assign to it later\n     import matplotlib.backends\n-    close(\"all\")\n+\n+def __getitem__(self, key):\n+    try:\n+        return dict.__getitem__(self, key)\n+    except KeyError as err:\n+        # Don't trigger backend auto-detection during read-only access\n+        # from get_backend() calls, as this can inappropriately destroy figures\n+        if key in _auto_backend_sentinel_keys:\n+            # Check if we're in a read-only context (like get_backend())\n+            import inspect\n+            frame = inspect.currentframe()\n+            try:\n+                # Look up the call stack to see if this is from get_backend()\n+                while frame:\n+                    if frame.f_code.co_name == 'get_backend':\n+                        # Return the sentinel without triggering auto-detection\n+                        return rcsetup._auto_backend_sentinel\n+                    frame = frame.f_back\n+            finally:\n+                del frame\n+        \n+        raise KeyError(f\"{key} is not a valid rc parameter (see \"\n+                      f\"rcParams.keys() for a list of valid parameters)\") from err\n \n     if newbackend is rcsetup._auto_backend_sentinel:\n         current_framework = cbook._get_running_interactive_framework()\n@@ -938,6 +960,39 @@ def close(fig=None):\n         else:\n             _pylab_helpers.Gcf.destroy(manager)\n     elif fig == 'all':\n+\n+def close(fig=None):\n+    \"\"\"\n+    Close a figure window.\n+\n+    Parameters\n+    ----------\n+    fig : None or int or str or `.Figure`\n+        The figure to close. There are a number of ways to specify this:\n+\n+        - None: the current figure\n+\n+        - `.Figure`: the given `.Figure` instance\n+\n+        - int: a figure number\n+\n+        - str: a figure name\n+\n+        - 'all': all figures\n+\n+    \"\"\"\n+    if fig is None:\n+        manager = _pylab_helpers.Gcf.get_active()\n+        if manager is None:\n+            return\n+        else:\n+            _pylab_helpers.Gcf.destroy(manager)\n+    elif fig == 'all':\n+        # Check if we're in the middle of auto-backend detection\n+        # to avoid destroying figures during get_backend() calls\n+        if (hasattr(matplotlib, '_backend_detection_in_progress') and \n+            matplotlib._backend_detection_in_progress):\n+            return\n         _pylab_helpers.Gcf.destroy_all()\n     elif isinstance(fig, int):\n         _pylab_helpers.Gcf.destroy(fig)\n@@ -945,6 +1000,16 @@ def close(fig=None):\n         # if we are dealing with a type UUID, we\n         # can use its integer representation\n         _pylab_helpers.Gcf.destroy(fig.int)\n+    elif isinstance(fig, str):\n+        all_labels = get_figlabels()\n+        if fig in all_labels:\n+            num = get_fignums()[all_labels.index(fig)]\n+    elif isinstance(fig, int):\n+        _pylab_helpers.Gcf.destroy(fig)\n+    elif hasattr(fig, 'int'):\n+        # if we are dealing with a type UUID, we\n+        # can use its integer representation\n+        _pylab_helpers.Gcf.destroy(fig.int)\n     elif isinstance(fig, str):\n         all_labels = get_figlabels()\n         if fig in all_labels:\n",
    "variant_2": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex c268a56724..6d28eba58e 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -641,11 +641,24 @@ class RcParams(MutableMapping, dict):\n                 _api.warn_deprecated(\n                     version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n                 return\n-            elif key == 'backend':\n-                if val is rcsetup._auto_backend_sentinel:\n-                    if 'backend' in self:\n-                        return\n-            try:\n+\n+    def __getitem__(self, key):\n+        if key == 'backend':\n+            val = dict.__getitem__(self, key)\n+            if val is rcsetup._auto_backend_sentinel:\n+                from matplotlib import pyplot as plt\n+                # Check if we're in a context where we should avoid auto-detection\n+                # to prevent clearing figures during read-only access\n+                if hasattr(plt, '_backend_detection_in_progress'):\n+                    return 'Agg'  # Return safe default without triggering detection\n+                \n+                # Mark that we're doing backend detection to prevent recursion\n+                plt._backend_detection_in_progress = True\n+                try:\n+                    plt.switch_backend(rcsetup._auto_backend_sentinel)\n+                finally:\n+                    delattr(plt, '_backend_detection_in_progress')\n+        return dict.__getitem__(self, key)\n                 cval = self.validate[key](val)\n             except ValueError as ve:\n                 raise ValueError(f\"Key {key}: {ve}\") from None\n@@ -670,12 +683,21 @@ class RcParams(MutableMapping, dict):\n \n         # In theory, this should only ever be used after the global rcParams\n         # has been set up, but better be safe e.g. in presence of breakpoints.\n+\n         elif key == \"backend\" and self is globals().get(\"rcParams\"):\n             val = dict.__getitem__(self, key)\n             if val is rcsetup._auto_backend_sentinel:\n-                from matplotlib import pyplot as plt\n-                plt.switch_backend(rcsetup._auto_backend_sentinel)\n-\n+                # Check if we're in a read-only context (like get_backend())\n+                # by examining the call stack to avoid triggering backend switch\n+                # during simple queries\n+                frame = sys._getframe(1)\n+                caller_name = frame.f_code.co_name\n+                # Only trigger auto-backend resolution for actual backend usage,\n+                # not for queries like get_backend()\n+                if caller_name not in ('get_backend', '_get_backend_or_none'):\n+                    from matplotlib import pyplot as plt\n+                    plt.switch_backend(rcsetup._auto_backend_sentinel)\n+                return val\n         return dict.__getitem__(self, key)\n \n     def _get_backend_or_none(self):\n@@ -1087,6 +1109,55 @@ def rc_context(rc=None, fname=None):\n              plt.plot(x, y)  # uses 'print.rc'\n \n     \"\"\"\n+\n+def rc_context(rc=None, fname=None):\n+    \"\"\"\n+    Return a context manager for managing rc settings.\n+\n+    This allows one to do::\n+\n+        with mpl.rc_context(fname='screen.rc'):\n+            plt.plot(x, y)  # uses 'screen.rc'\n+\n+    or::\n+\n+        with mpl.rc_context(rc={'text.usetex': True}):\n+            plt.plot(x, y)  # uses usetex\n+\n+    or::\n+\n+        with mpl.rc_context(rc={'text.usetex': True}, fname='screen.rc'):\n+            plt.plot(x, y)  # uses usetex and 'screen.rc'\n+\n+    A dictionary can also be passed to the context manager::\n+\n+        with mpl.rc_context({'text.usetex': True}):\n+            plt.plot(x, y)  # uses usetex\n+\n+    'fname' searches in the same order as a call to `rc_file()`.\n+\n+    .. note::\n+\n+       Calling this function affects the global state of matplotlib.\n+\n+    Examples\n+    --------\n+    Creating a figure using the context manager::\n+\n+        with mpl.rc_context():\n+            # Set custom rcParams within the context\n+            mpl.rcParams['figure.figsize'] = (10, 8)\n+            fig, ax = plt.subplots()\n+            ax.plot(range(3), range(3))\n+            fig.savefig('example.png')\n+            plt.close(fig)\n+\n+    Loading settings from a file::\n+\n+         with mpl.rc_context(fname='print.rc'):\n+             plt.plot(x, y)  # uses 'print.rc'\n+\n+    \"\"\"\n     orig = rcParams.copy()\n     try:\n         if fname:\n@@ -1095,7 +1166,20 @@ def rc_context(rc=None, fname=None):\n             rcParams.update(rc)\n         yield\n     finally:\n-        dict.update(rcParams, orig)  # Revert to the original rcs.\n+        # Special handling for backend parameter to avoid triggering auto-detection\n+        backend_changed = ('backend' in orig and \n+                          orig['backend'] != rcParams.get('backend'))\n+        \n+        if backend_changed and orig['backend'] is rcsetup._auto_backend_sentinel:\n+            # If original backend was auto-sentinel, restore it without triggering validation\n+            rcParams._data['backend'] = orig['backend']\n+            # Restore other parameters normally\n+            for key, value in orig.items():\n+                if key != 'backend':\n+                    rcParams._data[key] = value\n+        else:\n+            # Normal restoration for all other cases\n+            dict.update(rcParams, orig)  # Revert to the original rcs.\n \n \n def use(backend, *, force=True):\ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex e3c66ea67c..68eb7e60a5 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -222,7 +222,33 @@ def switch_backend(newbackend):\n     global _backend_mod\n     # make sure the init is pulled up so we can assign to it later\n     import matplotlib.backends\n-    close(\"all\")\n+\n+def __getitem__(self, key):\n+    try:\n+        return dict.__getitem__(self, key)\n+    except KeyError as err:\n+        # Handle auto backend detection without triggering figure closure\n+        if key == 'backend' and dict.__getitem__(self, key) is rcsetup._auto_backend_sentinel:\n+            # Check if we're in a read-only context (like get_backend())\n+            # by examining the call stack to avoid triggering switch_backend\n+            import inspect\n+            frame = inspect.currentframe()\n+            try:\n+                # Look for get_backend in the call stack\n+                while frame:\n+                    if frame.f_code.co_name == 'get_backend':\n+                        # Return the sentinel without triggering backend resolution\n+                        return rcsetup._auto_backend_sentinel\n+                    frame = frame.f_back\n+            finally:\n+                del frame\n+            \n+            # Normal backend resolution path for actual backend switching\n+            from . import pyplot as plt\n+            plt.switch_backend(rcsetup._auto_backend_sentinel)\n+            return dict.__getitem__(self, key)\n+        raise KeyError(f\"{key} is not a valid rc parameter (see rcParams.keys() for \"\n+                       f\"a list of valid parameters)\") from err\n \n     if newbackend is rcsetup._auto_backend_sentinel:\n         current_framework = cbook._get_running_interactive_framework()\n@@ -938,7 +964,42 @@ def close(fig=None):\n         else:\n             _pylab_helpers.Gcf.destroy(manager)\n     elif fig == 'all':\n-        _pylab_helpers.Gcf.destroy_all()\n+\n+def __getitem__(self, key):\n+    # In validate, the rcParam key is validated and the value is\n+    # converted to the expected type or raises an exception.\n+    # validate calls _get_backend_or_none, which might return None\n+    # if no backend is specified.  If None is returned, we should\n+    # not trigger backend auto-detection during read-only access.\n+    if key == 'backend':\n+        # Check if we're in a read-only context (like get_backend())\n+        # by examining the call stack for get_backend or similar functions\n+        import inspect\n+        frame = inspect.currentframe()\n+        try:\n+            for _ in range(10):  # Check up to 10 frames up\n+                frame = frame.f_back\n+                if frame is None:\n+                    break\n+                caller_name = frame.f_code.co_name\n+                # If called from get_backend or similar read-only operations,\n+                # don't trigger auto-detection\n+                if caller_name in ('get_backend', '_get_backend_or_none'):\n+                    try:\n+                        value = dict.__getitem__(self, key)\n+                        return self._validate[key](value) if value is not _auto_backend_sentinel else value\n+                    except KeyError:\n+                        return _auto_backend_sentinel\n+        finally:\n+            del frame\n+    \n+    try:\n+        return dict.__getitem__(self, key)\n+    except KeyError as err:\n+        # __getitem__ raises KeyError, not ValueError, when a key\n+        # is not found.\n+        raise KeyError(f\"{key} is not a valid rc parameter (see \"\n+                       f\"rcParams.keys() for a list of valid parameters)\") from err\n     elif isinstance(fig, int):\n         _pylab_helpers.Gcf.destroy(fig)\n     elif hasattr(fig, 'int'):\n",
    "variant_3": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex c268a56724..c7a3fa9ec9 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -641,11 +641,44 @@ class RcParams(MutableMapping, dict):\n                 _api.warn_deprecated(\n                     version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n                 return\n-            elif key == 'backend':\n-                if val is rcsetup._auto_backend_sentinel:\n-                    if 'backend' in self:\n-                        return\n-            try:\n+\n+    def __getitem__(self, key):\n+        if key in _deprecated_map:\n+            version, alt_key, alt_val, inverse_alt = _deprecated_map[key]\n+            _api.warn_deprecated(\n+                version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n+            return inverse_alt(dict.__getitem__(self, alt_key))\n+\n+        elif key in _deprecated_ignore_map:\n+            version, alt_key = _deprecated_ignore_map[key]\n+            _api.warn_deprecated(\n+                version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n+            return dict.__getitem__(self, alt_key)\n+\n+        elif key in _deprecated_remain_as_none:\n+            version, = _deprecated_remain_as_none[key]\n+            _api.warn_deprecated(version, name=key, obj_type=\"rcparam\")\n+            return None\n+\n+        # Check for auto backend without triggering switch_backend\n+        elif key == 'backend' and dict.__getitem__(self, key) is rcsetup._auto_backend_sentinel:\n+            # Import here to avoid circular imports\n+            from . import pyplot as plt\n+            # Get current backend without triggering a switch\n+            current_backend = getattr(plt._backend_mod, 'backend', None)\n+            if current_backend is not None:\n+                return current_backend\n+            # Only trigger backend resolution if no backend is currently active\n+            # and we're not in a context that should preserve figures\n+            import matplotlib\n+            if hasattr(matplotlib, '_called_from_pytest') or getattr(matplotlib, '_in_rc_context', False):\n+                # Return a safe default to avoid triggering backend switching\n+                return 'Agg'\n+            # Fall through to trigger backend resolution only when safe\n+            dict.__setitem__(self, key, plt.rcsetup.validate_backend('Agg'))\n+            return dict.__getitem__(self, key)\n+        \n+        return dict.__getitem__(self, key)\n                 cval = self.validate[key](val)\n             except ValueError as ve:\n                 raise ValueError(f\"Key {key}: {ve}\") from None\n@@ -655,6 +688,22 @@ class RcParams(MutableMapping, dict):\n                 f\"{key} is not a valid rc parameter (see rcParams.keys() for \"\n                 f\"a list of valid parameters)\") from err\n \n+    def __getitem__(self, key):\n+        if key in _deprecated_map:\n+            version, alt_key, alt_val, inverse_alt = _deprecated_map[key]\n+            _api.warn_deprecated(\n+                version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n+            return inverse_alt(dict.__getitem__(self, alt_key))\n+\n+        elif key in _deprecated_ignore_map:\n+            version, alt_key = _deprecated_ignore_map[key]\n+            _api.warn_deprecated(\n+                version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n+            return dict.__getitem__(self, alt_key) if alt_key else None\n+\n+        # In theory, this should only ever be used after the global rcParams\n+        # has been set up, but better be safe e.g. in presence of breakpoints.\n+\n     def __getitem__(self, key):\n         if key in _deprecated_map:\n             version, alt_key, alt_val, inverse_alt = _deprecated_map[key]\n@@ -673,10 +722,19 @@ class RcParams(MutableMapping, dict):\n         elif key == \"backend\" and self is globals().get(\"rcParams\"):\n             val = dict.__getitem__(self, key)\n             if val is rcsetup._auto_backend_sentinel:\n+                # Check if we're in a read-only context (like get_backend())\n+                # by examining the call stack to avoid triggering backend switching\n+                # during queries that should not modify state\n+                frame = sys._getframe(1)\n+                calling_function = frame.f_code.co_name\n+                # Avoid auto-backend resolution during read-only operations\n+                if calling_function in ('get_backend', '_get_backend_or_none'):\n+                    return val\n                 from matplotlib import pyplot as plt\n                 plt.switch_backend(rcsetup._auto_backend_sentinel)\n \n         return dict.__getitem__(self, key)\n+        return dict.__getitem__(self, key)\n \n     def _get_backend_or_none(self):\n         \"\"\"Get the requested backend, if any, without triggering resolution.\"\"\"\n@@ -1087,15 +1145,47 @@ def rc_context(rc=None, fname=None):\n              plt.plot(x, y)  # uses 'print.rc'\n \n     \"\"\"\n-    orig = rcParams.copy()\n-    try:\n-        if fname:\n-            rc_file(fname)\n-        if rc:\n-            rcParams.update(rc)\n-        yield\n-    finally:\n-        dict.update(rcParams, orig)  # Revert to the original rcs.\n+\n+def __getitem__(self, key):\n+    if key in _deprecated_map:\n+        version, alt_key, message = _deprecated_map[key]\n+        _api.warn_deprecated(\n+            version, name=key, obj_type=\"rcparam\", alternative=alt_key,\n+            addendum=message)\n+        return super().__getitem__(alt_key)\n+    elif key == \"backend\":\n+        val = dict.__getitem__(self, key)\n+        if val is rcsetup._auto_backend_sentinel:\n+            # Check if we're in a context where we should avoid auto-detection\n+            # to prevent figure destruction during read-only access\n+            frame = inspect.currentframe()\n+            try:\n+                # Look up the call stack to see if this is a read-only query\n+                while frame:\n+                    frame = frame.f_back\n+                    if frame and frame.f_code.co_name in ('get_backend', '_get_backend_or_none'):\n+                        # This is a read-only backend query, return the sentinel\n+                        # without triggering auto-detection\n+                        return val\n+                    if frame and 'rc_context' in frame.f_code.co_name:\n+                        # We're in rc_context, avoid triggering backend changes\n+                        return val\n+            finally:\n+                del frame\n+            from matplotlib import pyplot as plt\n+            plt.switch_backend(rcsetup._auto_backend_sentinel)\n+        return dict.__getitem__(self, key)\n+    elif key in _deprecated_ignore_map:\n+        version, alt_key = _deprecated_ignore_map[key]\n+        _api.warn_deprecated(\n+            version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n+        return super().__getitem__(alt_key if alt_key else key)\n+    # In theory, this should only ever be used after the global rcParams\n+    # has been set up, but better be safe...\n+    elif key in rcsetup._validators:\n+        if key not in self:\n+            self[key] = rcsetup.defaultParams[key]\n+    return dict.__getitem__(self, key)\n \n \n def use(backend, *, force=True):\ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex e3c66ea67c..508d1b7170 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -222,7 +222,22 @@ def switch_backend(newbackend):\n     global _backend_mod\n     # make sure the init is pulled up so we can assign to it later\n     import matplotlib.backends\n-    close(\"all\")\n+\n+def __getitem__(self, key):\n+    try:\n+        return dict.__getitem__(self, key)\n+    except KeyError as err:\n+        # Fall back on the default value.\n+        key = _get_backend_or_none() or self._get_backend_or_none_orig(key)\n+        if key is None:\n+            # This should only happen in headless mode.\n+            key = rcsetup._auto_backend_sentinel\n+        # Check if we're in a context where backend switching should be avoided\n+        # (e.g., during read-only queries like get_backend())\n+        if (key == 'backend' and \n+            hasattr(self, '_in_backend_query') and self._in_backend_query):\n+            return rcsetup._auto_backend_sentinel\n+        return self._get_backend_or_none_orig(key)\n \n     if newbackend is rcsetup._auto_backend_sentinel:\n         current_framework = cbook._get_running_interactive_framework()\n@@ -938,7 +953,25 @@ def close(fig=None):\n         else:\n             _pylab_helpers.Gcf.destroy(manager)\n     elif fig == 'all':\n-        _pylab_helpers.Gcf.destroy_all()\n+\n+def __getitem__(self, key):\n+    try:\n+        return dict.__getitem__(self, key)\n+    except KeyError as err:\n+        # Handle special case for backend auto-detection\n+        if key == \"backend\":\n+            # Check if we're in a context where we should avoid triggering\n+            # backend switching (e.g., during get_backend() calls)\n+            import threading\n+            current_thread = threading.current_thread()\n+            if hasattr(current_thread, '_matplotlib_backend_query') and current_thread._matplotlib_backend_query:\n+                # Return the sentinel without triggering auto-detection\n+                return _auto_backend_sentinel\n+            \n+            # Only trigger auto-detection if not in query mode\n+            return _auto_backend_sentinel\n+        raise KeyError(f\"{key} is not a valid rc parameter (see rcParams.keys() for \"\n+                       f\"a list of valid parameters)\") from err\n     elif isinstance(fig, int):\n         _pylab_helpers.Gcf.destroy(fig)\n     elif hasattr(fig, 'int'):\n",
    "variant_4": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex c268a56724..f7267bbd56 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -641,11 +641,53 @@ class RcParams(MutableMapping, dict):\n                 _api.warn_deprecated(\n                     version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n                 return\n-            elif key == 'backend':\n-                if val is rcsetup._auto_backend_sentinel:\n-                    if 'backend' in self:\n-                        return\n-            try:\n+\n+    def __getitem__(self, key):\n+        if key in _deprecated_map:\n+            version, alt_key, alt_val, inverse_alt = _deprecated_map[key]\n+            _api.warn_deprecated(\n+                version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n+            return inverse_alt(dict.__getitem__(self, alt_key))\n+\n+        elif key in _deprecated_ignore_map:\n+            version, alt_key = _deprecated_ignore_map[key]\n+            _api.warn_deprecated(\n+                version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n+            return dict.__getitem__(self, alt_key)\n+\n+        elif key in _deprecated_remain_as_none:\n+            version, = _deprecated_remain_as_none[key]\n+            _api.warn_deprecated(version, name=key, obj_type=\"rcparam\")\n+            return None\n+\n+        # Check if this is just a backend query (like from get_backend()) \n+        # vs an actual backend change request\n+        elif key == 'backend':\n+            val = dict.__getitem__(self, key)\n+            if val is rcsetup._auto_backend_sentinel:\n+                # Only trigger auto-backend resolution if we're not just querying\n+                # Check if this is being called from get_backend() by examining the call stack\n+                import inspect\n+                frame = inspect.currentframe()\n+                try:\n+                    # Look for get_backend in the call stack\n+                    caller_frame = frame.f_back\n+                    while caller_frame:\n+                        if caller_frame.f_code.co_name == 'get_backend':\n+                            # This is a read-only query from get_backend(), return current backend\n+                            # without triggering auto-detection that would clear figures\n+                            from matplotlib import pyplot as plt\n+                            return plt.rcParams._get_backend_or_none() or 'Agg'\n+                        caller_frame = caller_frame.f_back\n+                finally:\n+                    del frame\n+                \n+                # If not from get_backend(), proceed with normal auto-detection\n+                from matplotlib import pyplot as plt\n+                plt.switch_backend(rcsetup._auto_backend_sentinel)\n+            return dict.__getitem__(self, key)\n+        \n+        return dict.__getitem__(self, key)\n                 cval = self.validate[key](val)\n             except ValueError as ve:\n                 raise ValueError(f\"Key {key}: {ve}\") from None\n@@ -668,14 +710,25 @@ class RcParams(MutableMapping, dict):\n                 version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n             return dict.__getitem__(self, alt_key) if alt_key else None\n \n+        # In theory, this should only ever be used after the global rcParams\n+        # has been set up, but better be safe e.g. in presence of breakpoints.\n+\n         # In theory, this should only ever be used after the global rcParams\n         # has been set up, but better be safe e.g. in presence of breakpoints.\n         elif key == \"backend\" and self is globals().get(\"rcParams\"):\n             val = dict.__getitem__(self, key)\n             if val is rcsetup._auto_backend_sentinel:\n+                # Check if we're in a read-only context (like get_backend())\n+                # by examining the call stack to avoid triggering backend switching\n+                # during queries that should be non-destructive\n+                frame = sys._getframe(1)\n+                caller_name = frame.f_code.co_name\n+                # If called from get_backend or similar query functions,\n+                # return the sentinel without triggering auto-detection\n+                if caller_name in ('get_backend', '_get_backend_or_none'):\n+                    return val\n                 from matplotlib import pyplot as plt\n                 plt.switch_backend(rcsetup._auto_backend_sentinel)\n-\n         return dict.__getitem__(self, key)\n \n     def _get_backend_or_none(self):\n@@ -1087,6 +1140,63 @@ def rc_context(rc=None, fname=None):\n              plt.plot(x, y)  # uses 'print.rc'\n \n     \"\"\"\n+\n+def rc_context(rc=None, fname=None):\n+    \"\"\"\n+    Return a context manager for managing rc settings.\n+\n+    This allows one to do::\n+\n+        with mpl.rc_context(fname='screen.rc'):\n+            plt.plot(x, y)  # uses 'screen.rc'\n+\n+    or::\n+\n+        with mpl.rc_context(rc={'text.usetex': True}):\n+            plt.plot(x, y)  # uses usetex\n+\n+    or::\n+\n+        with mpl.rc_context(rc={'text.usetex': True}, fname='screen.rc'):\n+            plt.plot(x, y)  # uses usetex and 'screen.rc'\n+\n+    A dictionary can also be passed to the context manager::\n+\n+        with mpl.rc_context({'text.usetex': True}):\n+            plt.plot(x, y)  # uses usetex\n+\n+    'fname' or 'rc' arguments are applied on top of the current rcParams.\n+    Passing a dictionary only to 'fname' is deprecated, and support will be\n+    removed two minor releases later.\n+\n+    See Also\n+    --------\n+    :ref:`customizing-with-matplotlibrc-files`\n+\n+    Examples\n+    --------\n+    This example shows how to use different rc parameters in different parts of\n+    a figure::\n+\n+        fig, (ax1, ax2) = plt.subplots(1, 2)\n+        with mpl.rc_context({'axes.linewidth': 3}):\n+            ax1.plot(range(3), range(3))\n+        ax2.plot(range(3), range(3))\n+\n+    This example shows how to use different backends to save a figure::\n+\n+        fig, ax = plt.subplots()\n+        ax.plot(range(3), range(3))\n+        fig.savefig('example.svg')\n+        with mpl.rc_context({'backend': 'PS'}):\n+            fig.savefig('example.ps')\n+\n+    Loading settings from a file::\n+\n+         with mpl.rc_context(fname='print.rc'):\n+             plt.plot(x, y)  # uses 'print.rc'\n+\n+    \"\"\"\n     orig = rcParams.copy()\n     try:\n         if fname:\n@@ -1095,6 +1205,15 @@ def rc_context(rc=None, fname=None):\n             rcParams.update(rc)\n         yield\n     finally:\n+        # Special handling for backend restoration to avoid triggering\n+        # auto-detection when restoring _auto_backend_sentinel\n+        if 'backend' in orig:\n+            backend_orig = orig['backend']\n+            if backend_orig == rcsetup._auto_backend_sentinel:\n+                # If original was auto-detection sentinel, restore without\n+                # triggering backend switching by directly setting the internal value\n+                rcParams._data['backend'] = backend_orig\n+                orig = {k: v for k, v in orig.items() if k != 'backend'}\n         dict.update(rcParams, orig)  # Revert to the original rcs.\n \n \ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex e3c66ea67c..fdcb15861c 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -222,7 +222,38 @@ def switch_backend(newbackend):\n     global _backend_mod\n     # make sure the init is pulled up so we can assign to it later\n     import matplotlib.backends\n-    close(\"all\")\n+\n+def __getitem__(self, key):\n+    try:\n+        return dict.__getitem__(self, key)\n+    except KeyError as err:\n+        # Fall back to key without 'backend.' prefix, for deprecated\n+        # rcParams like 'backend.qt4'.\n+        return dict.__getitem__(self, key.split('.')[-1])\n+    except KeyError:\n+        # If the key is 'backend' and we're in auto-detection mode,\n+        # avoid triggering switch_backend during read-only access\n+        if key == 'backend' and dict.__getitem__(self, key) is rcsetup._auto_backend_sentinel:\n+            # Check if this is a read-only query vs an actual backend switch\n+            import inspect\n+            frame = inspect.currentframe()\n+            try:\n+                # Walk up the call stack to see if this is from get_backend()\n+                caller_frame = frame.f_back\n+                while caller_frame:\n+                    if caller_frame.f_code.co_name == 'get_backend':\n+                        # This is a read-only query, return current backend without triggering switch\n+                        from matplotlib import _get_backend_or_none\n+                        current = _get_backend_or_none()\n+                        if current is not None:\n+                            return current\n+                        break\n+                    caller_frame = caller_frame.f_back\n+            finally:\n+                del frame\n+        \n+        raise KeyError(f\"{key} is not a valid rc parameter (see rcParams.keys() for \"\n+                      f\"a list of valid parameters)\") from err\n \n     if newbackend is rcsetup._auto_backend_sentinel:\n         current_framework = cbook._get_running_interactive_framework()\n@@ -938,7 +969,22 @@ def close(fig=None):\n         else:\n             _pylab_helpers.Gcf.destroy(manager)\n     elif fig == 'all':\n-        _pylab_helpers.Gcf.destroy_all()\n+\n+def __getitem__(self, key):\n+    # In validate, the rcParam value is validated and returned as a\n+    # cleaned value.\n+    try:\n+        # Check if this is a backend query during rc_context to avoid\n+        # triggering switch_backend inappropriately\n+        if (key == 'backend' and \n+            hasattr(self, '_in_context_manager') and \n+            self._in_context_manager and\n+            self._get_backend_or_none() is _auto_backend_sentinel):\n+            # Return the sentinel without triggering auto-detection\n+            return _auto_backend_sentinel\n+        return self.validate[key](self._get_backend_or_none() if key == 'backend' else self._val[key])\n+    except KeyError:\n+        raise KeyError(f\"{key} is not a valid rc parameter (see rcParams.keys() for a list of valid parameters)\") from None\n     elif isinstance(fig, int):\n         _pylab_helpers.Gcf.destroy(fig)\n     elif hasattr(fig, 'int'):\n",
    "variant_5": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex c268a56724..bcb9eb5c67 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -641,11 +641,36 @@ class RcParams(MutableMapping, dict):\n                 _api.warn_deprecated(\n                     version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n                 return\n-            elif key == 'backend':\n-                if val is rcsetup._auto_backend_sentinel:\n-                    if 'backend' in self:\n-                        return\n-            try:\n+\n+    def __getitem__(self, key):\n+        try:\n+            return dict.__getitem__(self, key)\n+        except KeyError:\n+            # Don't return _auto_backend_sentinel from queries.\n+            if key in _hardcoded_defaults:\n+                val = _hardcoded_defaults[key]\n+                # Check if this is a read-only access (like get_backend()) vs actual backend setting\n+                # by examining the call stack to avoid triggering switch_backend inappropriately\n+                if key == 'backend' and val is rcsetup._auto_backend_sentinel:\n+                    # Only trigger auto-backend resolution if we're in a context that should change backend\n+                    frame = inspect.currentframe()\n+                    try:\n+                        # Look for switch_backend or other backend-changing operations in call stack\n+                        caller_frame = frame.f_back\n+                        while caller_frame:\n+                            caller_name = caller_frame.f_code.co_name\n+                            # Allow auto-backend resolution for legitimate backend switching operations\n+                            if caller_name in ('switch_backend', 'use', '_backend_selection'):\n+                                break\n+                            # Block auto-backend resolution for read-only queries like get_backend\n+                            elif caller_name in ('get_backend', '__getitem__', 'validate'):\n+                                # Return a safe default instead of triggering auto-detection\n+                                return rcsetup._get_backend_or_none() or 'Agg'\n+                            caller_frame = caller_frame.f_back\n+                    finally:\n+                        del frame\n+                return val\n+            raise\n                 cval = self.validate[key](val)\n             except ValueError as ve:\n                 raise ValueError(f\"Key {key}: {ve}\") from None\n@@ -670,12 +695,29 @@ class RcParams(MutableMapping, dict):\n \n         # In theory, this should only ever be used after the global rcParams\n         # has been set up, but better be safe e.g. in presence of breakpoints.\n+\n         elif key == \"backend\" and self is globals().get(\"rcParams\"):\n             val = dict.__getitem__(self, key)\n             if val is rcsetup._auto_backend_sentinel:\n+                # Check if we're in a context where we should avoid triggering\n+                # backend auto-detection (e.g., during get_backend() calls)\n+                frame = inspect.currentframe()\n+                try:\n+                    # Look up the call stack to see if this is a read-only query\n+                    caller_frame = frame.f_back\n+                    while caller_frame:\n+                        caller_name = caller_frame.f_code.co_name\n+                        # If called from get_backend or similar query functions,\n+                        # return the sentinel without triggering auto-detection\n+                        if caller_name in ('get_backend', '_get_backend_or_none'):\n+                            return val\n+                        caller_frame = caller_frame.f_back\n+                finally:\n+                    del frame\n+                \n+                # Only trigger auto-detection for non-query access\n                 from matplotlib import pyplot as plt\n                 plt.switch_backend(rcsetup._auto_backend_sentinel)\n-\n         return dict.__getitem__(self, key)\n \n     def _get_backend_or_none(self):\n@@ -1087,15 +1129,36 @@ def rc_context(rc=None, fname=None):\n              plt.plot(x, y)  # uses 'print.rc'\n \n     \"\"\"\n-    orig = rcParams.copy()\n+\n+def __getitem__(self, key):\n     try:\n-        if fname:\n-            rc_file(fname)\n-        if rc:\n-            rcParams.update(rc)\n-        yield\n-    finally:\n-        dict.update(rcParams, orig)  # Revert to the original rcs.\n+        return dict.__getitem__(self, key)\n+    except KeyError as err:\n+        # Backend auto-detection should not trigger during read-only access\n+        # like get_backend() calls. Only trigger when actually setting backend.\n+        if key in _auto_backend_sentinel:\n+            # Check if we're in a context where backend switching would be inappropriate\n+            # by examining the call stack for get_backend() or other read-only operations\n+            import inspect\n+            frame = inspect.currentframe()\n+            try:\n+                # Look up the call stack for get_backend or similar read-only functions\n+                caller_frame = frame.f_back\n+                while caller_frame:\n+                    caller_name = caller_frame.f_code.co_name\n+                    if caller_name in ('get_backend', '__getitem__', '_get_backend_or_none'):\n+                        # This is a read-only access, return the sentinel without triggering auto-detection\n+                        return dict.__getitem__(self, key)\n+                    caller_frame = caller_frame.f_back\n+            finally:\n+                del frame\n+            \n+            # If we reach here, it's likely a legitimate backend setting operation\n+            if key == \"backend\":\n+                from matplotlib import pyplot as plt\n+                plt.switch_backend(_auto_backend_sentinel[key])\n+        raise KeyError(f\"{key} is not a valid rc parameter (see rcParams.keys() for \"\n+                      f\"a list of valid parameters)\") from err\n \n \n def use(backend, *, force=True):\ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex e3c66ea67c..c3ce3be3bb 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -222,7 +222,19 @@ def switch_backend(newbackend):\n     global _backend_mod\n     # make sure the init is pulled up so we can assign to it later\n     import matplotlib.backends\n-    close(\"all\")\n+\n+def __getitem__(self, key):\n+    try:\n+        return dict.__getitem__(self, key)\n+    except KeyError as err:\n+        # Don't trigger backend switching during read-only access\n+        # This prevents get_backend() from inadvertently destroying figures\n+        if key == \"backend\" and dict.__getitem__(self, key) is rcsetup._auto_backend_sentinel:\n+            # Return the sentinel directly without triggering auto-detection\n+            return rcsetup._auto_backend_sentinel\n+        raise KeyError(\n+            f\"{key!r} is not a valid rc parameter (see rcParams.keys() for \"\n+            f\"a list of valid parameters)\") from err\n \n     if newbackend is rcsetup._auto_backend_sentinel:\n         current_framework = cbook._get_running_interactive_framework()\n@@ -938,7 +950,22 @@ def close(fig=None):\n         else:\n             _pylab_helpers.Gcf.destroy(manager)\n     elif fig == 'all':\n-        _pylab_helpers.Gcf.destroy_all()\n+\n+def __getitem__(self, key):\n+    try:\n+        return dict.__getitem__(self, key)\n+    except KeyError as err:\n+        # Check if this is a backend-related access during a read-only operation\n+        # to avoid triggering switch_backend() inappropriately\n+        if key == \"backend\" and hasattr(self, '_in_backend_query'):\n+            # Return current backend without triggering auto-detection\n+            current_backend = dict.get(self, key, _auto_backend_sentinel)\n+            if current_backend is _auto_backend_sentinel:\n+                # Get the actual backend without triggering figure destruction\n+                from . import pyplot as plt\n+                return plt.get_backend()\n+            return current_backend\n+        return _get_configdir() / key\n     elif isinstance(fig, int):\n         _pylab_helpers.Gcf.destroy(fig)\n     elif hasattr(fig, 'int'):\n",
    "variant_6": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex c268a56724..f6cbdba5d1 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -641,11 +641,38 @@ class RcParams(MutableMapping, dict):\n                 _api.warn_deprecated(\n                     version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n                 return\n-            elif key == 'backend':\n-                if val is rcsetup._auto_backend_sentinel:\n-                    if 'backend' in self:\n-                        return\n-            try:\n+\n+def __getitem__(self, key):\n+    if key in _deprecated_map:\n+        version, alt_key, alt_val, inverse_alt = _deprecated_map[key]\n+        _api.warn_deprecated(\n+            version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n+        return inverse_alt(dict.__getitem__(self, alt_key))\n+    elif key in _deprecated_remain_as_none:\n+        version, = _deprecated_remain_as_none[key]\n+        _api.warn_deprecated(version, name=key, obj_type=\"rcparam\")\n+        return dict.__getitem__(self, key)\n+    elif key in _deprecated_ignore_map:\n+        version, alt_key = _deprecated_ignore_map[key]\n+        _api.warn_deprecated(\n+            version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n+        return dict.__getitem__(self, alt_key)\n+    # Special handling for backend to avoid triggering switch during read-only access\n+    elif key == 'backend':\n+        backend_val = dict.__getitem__(self, key)\n+        if backend_val is rcsetup._auto_backend_sentinel:\n+            # Only resolve auto backend if we're not in a context that should preserve figures\n+            if not getattr(_get_running_interactive_framework, '_in_rc_context', False):\n+                backend_val = rcsetup._auto_backend_sentinel\n+        return backend_val\n+    # backends are a special case: if auto-backend is set, we need to\n+    # resolve it to the actual backend being used\n+    if (key == 'backend' and dict.__getitem__(self, key) is\n+            rcsetup._auto_backend_sentinel):\n+        from . import pyplot as plt\n+        plt.switch_backend(rcsetup._auto_backend_sentinel)\n+        return dict.__getitem__(self, key)\n+    return dict.__getitem__(self, key)\n                 cval = self.validate[key](val)\n             except ValueError as ve:\n                 raise ValueError(f\"Key {key}: {ve}\") from None\n@@ -670,12 +697,27 @@ class RcParams(MutableMapping, dict):\n \n         # In theory, this should only ever be used after the global rcParams\n         # has been set up, but better be safe e.g. in presence of breakpoints.\n+\n         elif key == \"backend\" and self is globals().get(\"rcParams\"):\n             val = dict.__getitem__(self, key)\n             if val is rcsetup._auto_backend_sentinel:\n+                # Check if we're in a context where we should avoid triggering\n+                # backend resolution (e.g., during get_backend() calls)\n+                frame = inspect.currentframe()\n+                try:\n+                    # Look up the call stack to see if we're being called from get_backend()\n+                    caller_frame = frame.f_back\n+                    while caller_frame:\n+                        caller_name = caller_frame.f_code.co_name\n+                        if caller_name == 'get_backend':\n+                            # Return the sentinel without triggering resolution\n+                            return val\n+                        caller_frame = caller_frame.f_back\n+                finally:\n+                    del frame\n+                \n                 from matplotlib import pyplot as plt\n                 plt.switch_backend(rcsetup._auto_backend_sentinel)\n-\n         return dict.__getitem__(self, key)\n \n     def _get_backend_or_none(self):\n@@ -1087,15 +1129,35 @@ def rc_context(rc=None, fname=None):\n              plt.plot(x, y)  # uses 'print.rc'\n \n     \"\"\"\n-    orig = rcParams.copy()\n+\n+def __getitem__(self, key):\n     try:\n-        if fname:\n-            rc_file(fname)\n-        if rc:\n-            rcParams.update(rc)\n-        yield\n-    finally:\n-        dict.update(rcParams, orig)  # Revert to the original rcs.\n+        return dict.__getitem__(self, key)\n+    except KeyError as err:\n+        # Backend auto-detection should not trigger during read-only access\n+        # like get_backend() calls. Only trigger when actually setting backend.\n+        if key in _auto_backend_sentinel:\n+            # Check if we're in a context where backend switching should be avoided\n+            # by examining the call stack for read-only operations\n+            import inspect\n+            frame = inspect.currentframe()\n+            try:\n+                # Look for get_backend() in the call stack\n+                for i in range(10):  # Check up to 10 frames up\n+                    frame = frame.f_back\n+                    if frame is None:\n+                        break\n+                    if frame.f_code.co_name == 'get_backend':\n+                        # This is a read-only access, return the sentinel without triggering switch\n+                        return _auto_backend_sentinel[key]\n+            finally:\n+                del frame\n+            \n+            # If not a read-only access, proceed with normal auto-detection\n+            dict.__setitem__(self, key, rcsetup._auto_backend_sentinel)\n+            return dict.__getitem__(self, key)\n+        raise KeyError(f\"{key} is not a valid rc parameter (see rcParams.keys() for \"\n+                       f\"a list of valid parameters)\") from err\n \n \n def use(backend, *, force=True):\ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex e3c66ea67c..63a8f263e6 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -222,7 +222,40 @@ def switch_backend(newbackend):\n     global _backend_mod\n     # make sure the init is pulled up so we can assign to it later\n     import matplotlib.backends\n-    close(\"all\")\n+\n+def __getitem__(self, key):\n+    try:\n+        return dict.__getitem__(self, key)\n+    except KeyError as err:\n+        # Fall back on the original key, which was not found either.\n+        # This is used for API compatibility, so that rcParams['backend']\n+        # keeps working even though the real key is 'backend.qt5' or\n+        # 'backend.macosx' etc.\n+        key = rcsetup._hardcoded_defaults.get(key, key)\n+        \n+        # Special handling for backend parameter to prevent unintended figure destruction\n+        if key == 'backend' and dict.__getitem__(self, key) is rcsetup._auto_backend_sentinel:\n+            # Check if we're in a read-only context (like get_backend()) vs actual backend switching\n+            # by examining the call stack to avoid triggering switch_backend during queries\n+            import inspect\n+            frame = inspect.currentframe()\n+            try:\n+                # Look up the call stack to see if this is a read-only query\n+                caller_names = []\n+                current_frame = frame.f_back\n+                depth = 0\n+                while current_frame and depth < 10:  # Limit depth to avoid infinite loops\n+                    caller_names.append(current_frame.f_code.co_name)\n+                    current_frame = current_frame.f_back\n+                    depth += 1\n+                \n+                # If called from get_backend() or other read-only contexts, don't trigger auto-detection\n+                if 'get_backend' in caller_names or '_get_backend_or_none' in caller_names:\n+                    return rcsetup._auto_backend_sentinel\n+            finally:\n+                del frame\n+        \n+        return dict.__getitem__(self, key)\n \n     if newbackend is rcsetup._auto_backend_sentinel:\n         current_framework = cbook._get_running_interactive_framework()\n@@ -938,7 +971,15 @@ def close(fig=None):\n         else:\n             _pylab_helpers.Gcf.destroy(manager)\n     elif fig == 'all':\n-        _pylab_helpers.Gcf.destroy_all()\n+\n+def __getitem__(self, key):\n+    try:\n+        return dict.__getitem__(self, key)\n+    except KeyError as err:\n+        # Allow raising KeyError for truly invalid keys\n+        raise KeyError(f\"{key!r}\") from err\n+    except RecursionError as err:\n+        raise RecursionError(f\"Recursion in RcParams for {key!r}\") from err\n     elif isinstance(fig, int):\n         _pylab_helpers.Gcf.destroy(fig)\n     elif hasattr(fig, 'int'):\n",
    "variant_7": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex c268a56724..c6ce2addd2 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -641,11 +641,51 @@ class RcParams(MutableMapping, dict):\n                 _api.warn_deprecated(\n                     version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n                 return\n-            elif key == 'backend':\n-                if val is rcsetup._auto_backend_sentinel:\n-                    if 'backend' in self:\n-                        return\n-            try:\n+\n+    def __getitem__(self, key):\n+        if key in _deprecated_map:\n+            version, alt_key, alt_val, inverse_alt = _deprecated_map[key]\n+            _api.warn_deprecated(\n+                version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n+            return inverse_alt(dict.__getitem__(self, alt_key))\n+\n+        elif key in _deprecated_remain_as_none:\n+            version, = _deprecated_remain_as_none[key]\n+            _api.warn_deprecated(version, name=key, obj_type=\"rcparam\")\n+            return dict.__getitem__(self, key)\n+\n+        elif key in _deprecated_ignore_map:\n+            version, alt_key = _deprecated_ignore_map[key]\n+            _api.warn_deprecated(\n+                version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n+            return dict.__getitem__(self, alt_key)\n+\n+        # For backend parameter, avoid triggering auto-detection during read-only access\n+        elif key == 'backend':\n+            val = dict.__getitem__(self, key)\n+            if val is rcsetup._auto_backend_sentinel:\n+                # Check if we're in a read-only context (like get_backend())\n+                # by examining the call stack\n+                import inspect\n+                frame = inspect.currentframe()\n+                try:\n+                    # Look for get_backend in the call stack\n+                    caller_frame = frame.f_back\n+                    while caller_frame:\n+                        if caller_frame.f_code.co_name == 'get_backend':\n+                            # This is a read-only access, return the sentinel without resolution\n+                            return val\n+                        caller_frame = caller_frame.f_back\n+                    \n+                    # Not a read-only access, proceed with auto-detection\n+                    if val is rcsetup._auto_backend_sentinel:\n+                        from matplotlib import pyplot as plt\n+                        plt.switch_backend(rcsetup._auto_backend_sentinel)\n+                finally:\n+                    del frame\n+            return dict.__getitem__(self, key)\n+\n+        return dict.__getitem__(self, key)\n                 cval = self.validate[key](val)\n             except ValueError as ve:\n                 raise ValueError(f\"Key {key}: {ve}\") from None\n@@ -670,12 +710,25 @@ class RcParams(MutableMapping, dict):\n \n         # In theory, this should only ever be used after the global rcParams\n         # has been set up, but better be safe e.g. in presence of breakpoints.\n+\n         elif key == \"backend\" and self is globals().get(\"rcParams\"):\n             val = dict.__getitem__(self, key)\n             if val is rcsetup._auto_backend_sentinel:\n+                # Check if we're in a context where backend switching should be avoided\n+                # to prevent figure destruction during read-only access\n+                frame = inspect.currentframe()\n+                try:\n+                    # Look for get_backend() in the call stack\n+                    while frame:\n+                        if frame.f_code.co_name == 'get_backend':\n+                            # This is a read-only query, don't trigger backend switching\n+                            return val\n+                        frame = frame.f_back\n+                finally:\n+                    del frame\n+                \n                 from matplotlib import pyplot as plt\n                 plt.switch_backend(rcsetup._auto_backend_sentinel)\n-\n         return dict.__getitem__(self, key)\n \n     def _get_backend_or_none(self):\n@@ -1087,15 +1140,26 @@ def rc_context(rc=None, fname=None):\n              plt.plot(x, y)  # uses 'print.rc'\n \n     \"\"\"\n-    orig = rcParams.copy()\n+\n+def __getitem__(self, key):\n     try:\n-        if fname:\n-            rc_file(fname)\n-        if rc:\n-            rcParams.update(rc)\n-        yield\n-    finally:\n-        dict.update(rcParams, orig)  # Revert to the original rcs.\n+        return dict.__getitem__(self, key)\n+    except KeyError as err:\n+        # Check if this is a query for the backend value during read-only operations\n+        # like get_backend() to avoid triggering inappropriate backend switching\n+        if key == \"backend\" and hasattr(self, '_in_backend_query'):\n+            # Return the raw backend value without triggering auto-detection\n+            return dict.get(self, key, rcsetup._auto_backend_sentinel)\n+        \n+        # Only trigger backend resolution for actual configuration access\n+        if key == \"backend\":\n+            val = _auto_backend_sentinel\n+        else:\n+            raise KeyError(\n+                f\"{key} is not a valid rc parameter (see rcParams.keys() for \"\n+                f\"a list of valid parameters)\") from err\n+    else:\n+        return val\n \n \n def use(backend, *, force=True):\ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex e3c66ea67c..f4fb11b5d5 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -222,7 +222,41 @@ def switch_backend(newbackend):\n     global _backend_mod\n     # make sure the init is pulled up so we can assign to it later\n     import matplotlib.backends\n-    close(\"all\")\n+\n+def switch_backend(newbackend):\n+    \"\"\"\n+    Close all open figures and set the Matplotlib backend.\n+\n+    The backend cannot be changed if a GUI mainloop is running, unless\n+    we are switching to a compatible or non-interactive backend.\n+\n+    Switching to and from non-interactive backends is always possible.\n+\n+    Parameters\n+    ----------\n+    newbackend : str\n+        The name of the backend to use.\n+    \"\"\"\n+    global _backend_mod\n+    # make sure the init is pulled up so we can assign to it later\n+    import matplotlib.backends\n+    \n+    # Only close figures if this is an explicit backend change, not auto-detection\n+    current_backend = matplotlib.get_backend()\n+    if (newbackend != current_backend and \n+        not (hasattr(matplotlib.rcParams, '_in_auto_backend_detection') and \n+             matplotlib.rcParams._in_auto_backend_detection)):\n+        close(\"all\")\n+\n+    if newbackend is rcsetup._auto_backend_sentinel:\n+        current_framework = cbook._get_running_interactive_framework()\n+        mapping = {'qt': 'qtagg',\n+                   'gtk3': 'gtk3agg',\n+                   'gtk4': 'gtk4agg',\n+                   'wx': 'wxagg',\n+                   'tk': 'tkagg',\n+                   'macosx': 'macosx',\n+                   'headless': 'agg'}\n \n     if newbackend is rcsetup._auto_backend_sentinel:\n         current_framework = cbook._get_running_interactive_framework()\n@@ -938,7 +972,27 @@ def close(fig=None):\n         else:\n             _pylab_helpers.Gcf.destroy(manager)\n     elif fig == 'all':\n-        _pylab_helpers.Gcf.destroy_all()\n+\n+def __getitem__(self, key):\n+    if key in _deprecated_map:\n+        version, alt_key, message = _deprecated_map[key]\n+        name = _deprecated_map[key][1]\n+        _api.warn_deprecated(\n+            version, message=f\"The {key!r} rcParam was deprecated in \"\n+            f\"Matplotlib {version} and will be removed %(removal)s. \"\n+            f\"Use {alt_key!r} instead.\" if alt_key else message)\n+        key = alt_key\n+\n+    try:\n+        return dict.__getitem__(self, key)\n+    except KeyError as err:\n+        # Check if this is a backend query during context restoration\n+        # to prevent unwanted figure destruction\n+        if key == \"backend\" and hasattr(self, '_in_context_restoration'):\n+            # Return the sentinel without triggering backend resolution\n+            return dict.get(self, key, _auto_backend_sentinel)\n+        raise KeyError(f\"{key} is not a valid rc parameter (see \"\n+                      \"rcParams.keys() for a list of valid parameters)\") from err\n     elif isinstance(fig, int):\n         _pylab_helpers.Gcf.destroy(fig)\n     elif hasattr(fig, 'int'):\n",
    "variant_8": "diff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex c268a56724..47bc639311 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -641,11 +641,39 @@ class RcParams(MutableMapping, dict):\n                 _api.warn_deprecated(\n                     version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n                 return\n-            elif key == 'backend':\n-                if val is rcsetup._auto_backend_sentinel:\n-                    if 'backend' in self:\n-                        return\n-            try:\n+\n+    def __getitem__(self, key):\n+        if key in _deprecated_map:\n+            version, alt_key, alt_val, inverse_alt = _deprecated_map[key]\n+            _api.warn_deprecated(\n+                version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n+            return inverse_alt(dict.__getitem__(self, alt_key))\n+\n+        elif key in _deprecated_ignore_map:\n+            version, alt_key = _deprecated_ignore_map[key]\n+            _api.warn_deprecated(\n+                version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n+            return dict.__getitem__(self, alt_key)\n+\n+        elif key in _deprecated_remain_as_none:\n+            version, = _deprecated_remain_as_none[key]\n+            _api.warn_deprecated(version, name=key, obj_type=\"rcparam\")\n+            return None\n+\n+        # Check if backend is auto-sentinel and resolve it without triggering switch\n+        elif key == 'backend':\n+            val = dict.__getitem__(self, key)\n+            if val is rcsetup._auto_backend_sentinel:\n+                # Resolve auto backend without switching if we're just querying\n+                from . import pyplot as plt\n+                # Get the current backend without triggering a switch\n+                current_backend = plt.get_backend()\n+                # Store the resolved backend to avoid repeated resolution\n+                dict.__setitem__(self, key, current_backend)\n+                return current_backend\n+            return val\n+        \n+        return dict.__getitem__(self, key)\n                 cval = self.validate[key](val)\n             except ValueError as ve:\n                 raise ValueError(f\"Key {key}: {ve}\") from None\n@@ -670,12 +698,28 @@ class RcParams(MutableMapping, dict):\n \n         # In theory, this should only ever be used after the global rcParams\n         # has been set up, but better be safe e.g. in presence of breakpoints.\n+\n         elif key == \"backend\" and self is globals().get(\"rcParams\"):\n             val = dict.__getitem__(self, key)\n             if val is rcsetup._auto_backend_sentinel:\n+                # Check if we're in a read-only context (e.g., get_backend())\n+                # by examining the call stack to avoid triggering backend switch\n+                # during queries that should be non-destructive\n+                import inspect\n+                frame = inspect.currentframe()\n+                try:\n+                    # Look for get_backend in the call stack\n+                    caller_frame = frame.f_back\n+                    while caller_frame:\n+                        if caller_frame.f_code.co_name == 'get_backend':\n+                            # This is a read-only query, return the sentinel without switching\n+                            return val\n+                        caller_frame = caller_frame.f_back\n+                finally:\n+                    del frame\n+                \n                 from matplotlib import pyplot as plt\n                 plt.switch_backend(rcsetup._auto_backend_sentinel)\n-\n         return dict.__getitem__(self, key)\n \n     def _get_backend_or_none(self):\n@@ -1087,15 +1131,35 @@ def rc_context(rc=None, fname=None):\n              plt.plot(x, y)  # uses 'print.rc'\n \n     \"\"\"\n-    orig = rcParams.copy()\n+\n+def __getitem__(self, key):\n     try:\n-        if fname:\n-            rc_file(fname)\n-        if rc:\n-            rcParams.update(rc)\n-        yield\n-    finally:\n-        dict.update(rcParams, orig)  # Revert to the original rcs.\n+        return dict.__getitem__(self, key)\n+    except KeyError as err:\n+        # Don't trigger backend switching during read-only access like get_backend()\n+        if key in _auto_backend_sentinel and key == \"backend\":\n+            # Check if we're in a context where backend switching should be avoided\n+            # by examining the call stack for read-only operations\n+            import inspect\n+            frame = inspect.currentframe()\n+            try:\n+                # Look up the call stack to see if this is from get_backend()\n+                caller_frame = frame.f_back\n+                while caller_frame:\n+                    caller_code = caller_frame.f_code\n+                    if caller_code.co_name == 'get_backend':\n+                        # This is a read-only access, return the sentinel without triggering auto-detection\n+                        return _auto_backend_sentinel[key]\n+                    caller_frame = caller_frame.f_back\n+            finally:\n+                del frame\n+        \n+        try:\n+            return _auto_backend_sentinel[key]\n+        except KeyError:\n+            # Key not in _auto_backend_sentinel either\n+            pass\n+        raise err\n \n \n def use(backend, *, force=True):\ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex e3c66ea67c..951ccb0848 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -222,7 +222,33 @@ def switch_backend(newbackend):\n     global _backend_mod\n     # make sure the init is pulled up so we can assign to it later\n     import matplotlib.backends\n-    close(\"all\")\n+\n+def __getitem__(self, key):\n+    try:\n+        return dict.__getitem__(self, key)\n+    except KeyError as err:\n+        # Fall back on the original config value if the key is not explicitly\n+        # set in this RcParams instance.\n+        try:\n+            return self._get_backend_or_none()\n+        except KeyError:\n+            # if it's not a valid key in any of the dictionaries, raise a\n+            # KeyError.\n+            raise err from None\n+\n+def _get_backend_or_none(self):\n+    # Check if we're in a context where backend switching would be destructive\n+    if (hasattr(_pylab_helpers.Gcf, 'figs') and \n+        _pylab_helpers.Gcf.figs and \n+        not getattr(threading.current_thread(), '_matplotlib_switching_backend', False)):\n+        # We have active figures and we're not in an explicit backend switch\n+        # Return the current backend without triggering auto-detection\n+        current_backend = matplotlib.get_backend()\n+        if current_backend != 'template':\n+            return current_backend\n+    \n+    # Safe to proceed with normal backend resolution\n+    return rcsetup._auto_backend_sentinel\n \n     if newbackend is rcsetup._auto_backend_sentinel:\n         current_framework = cbook._get_running_interactive_framework()\n@@ -938,7 +964,27 @@ def close(fig=None):\n         else:\n             _pylab_helpers.Gcf.destroy(manager)\n     elif fig == 'all':\n-        _pylab_helpers.Gcf.destroy_all()\n+\n+def __getitem__(self, key):\n+    try:\n+        return dict.__getitem__(self, key)\n+    except KeyError as err:\n+        # Handle backend auto-detection without triggering figure destruction\n+        if key in _auto_backend_sentinel:\n+            # Check if we're in a context where backend switching would be inappropriate\n+            # (e.g., during get_backend() calls or when figures exist)\n+            if hasattr(_pylab_helpers, 'Gcf') and _pylab_helpers.Gcf.figs:\n+                # Figures exist - avoid backend switching that would destroy them\n+                # Return a safe backend value without triggering switch_backend\n+                current_backend = matplotlib.get_backend()\n+                if current_backend != 'template':\n+                    return current_backend\n+            \n+            # Safe to proceed with normal auto-detection\n+            from matplotlib import pyplot as plt\n+            plt.switch_backend(_auto_backend_sentinel[key])\n+            return dict.__getitem__(self, key)\n+        raise err\n     elif isinstance(fig, int):\n         _pylab_helpers.Gcf.destroy(fig)\n     elif hasattr(fig, 'int'):\n"
  }
}