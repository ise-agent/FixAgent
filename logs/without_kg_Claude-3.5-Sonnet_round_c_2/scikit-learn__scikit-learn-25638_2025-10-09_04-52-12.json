{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/scikit-learn/sklearn/utils/multiclass.py lines 307-313)": "\n    if not issparse(y):\n        # Handle nullable pandas dtypes by converting to appropriate numpy dtypes\n        if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n            dtype_name = str(y.dtype.name)\n            if dtype_name in ['Int64', 'Int32', 'Int16', 'Int8']:\n                # Convert nullable integer to regular numpy int, filling NA with 0\n                y = xp.asarray(y.fillna(0).astype('int64'))\n            elif dtype_name in ['Float64', 'Float32']:\n                # Convert nullable float to regular numpy float, keeping NaN as is\n                y = xp.asarray(y.astype('float64'))\n            elif dtype_name == 'boolean':\n                # Convert nullable boolean to regular numpy bool, filling NA with False\n                y = xp.asarray(y.fillna(False).astype('bool'))\n            elif dtype_name == 'string':\n                # Convert nullable string to object array\n                y = xp.asarray(y.fillna('').astype('object'))\n            else:\n                try:\n                    y = xp.asarray(y)\n                except (np.VisibleDeprecationWarning, ValueError):\n                    # dtype=object should be provided explicitly for ragged arrays,\n                    # see NEP 34\n                    y = xp.asarray(y, dtype=object)\n        else:\n            try:\n                y = xp.asarray(y)\n            except (np.VisibleDeprecationWarning, ValueError):\n                # dtype=object should be provided explicitly for ragged arrays,\n                # see NEP 34\n                y = xp.asarray(y, dtype=object)\n",
    "Location 2 (/root/hy/projects_2/scikit-learn/sklearn/utils/multiclass.py lines 343-345)": "\n    if not issparse(y) and y.dtype == object:\n        # Check if this is from a nullable pandas dtype conversion\n        if hasattr(y, '_pandas_nullable_dtype_origin'):\n            # This was converted from a nullable pandas dtype, don't classify as unknown\n            pass\n        elif not isinstance(y.flat[0], str):\n            # [obj_1] and not [\"label_1\"]\n            return \"unknown\"\n",
    "Location 3 (/root/hy/projects_2/scikit-learn/sklearn/utils/multiclass.py lines 362-367)": "\n    # Check multiclass\n    first_row = y[0] if not issparse(y) else y.getrow(0).data\n    if hasattr(y, 'dtype') and hasattr(y.dtype, 'name') and y.dtype.name == 'object':\n        # For object arrays that may contain mixed types, use a more robust unique check\n        unique_vals = xp.unique_values(y.ravel() if y.ndim > 1 else y)\n    else:\n        unique_vals = xp.unique_values(y)\n    \n    if unique_vals.shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n        # [1, 2, 3] or [[1., 2., 3]] or [[1, 2]]\n        return \"multiclass\" + suffix\n    else:\n        return \"binary\"  # [1, 2] or [[\"a\"], [\"b\"]]\n",
    "Location 4 (/root/hy/projects_2/scikit-learn/sklearn/utils/multiclass.py lines 23-28)": "\ndef _unique_multiclass(y):\n    xp, is_array_api = get_namespace(y)\n    \n    # Handle pandas Series/DataFrame with nullable dtypes\n    if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n        if y.dtype.name in ('Int64', 'Float64', 'boolean', 'string'):\n            # Convert nullable pandas dtype to numpy equivalent\n            if y.dtype.name == 'Int64':\n                y_converted = y.astype('int64')\n            elif y.dtype.name == 'Float64':\n                y_converted = y.astype('float64')\n            elif y.dtype.name == 'boolean':\n                y_converted = y.astype('bool')\n            elif y.dtype.name == 'string':\n                y_converted = y.astype('object')\n            return xp.unique_values(xp.asarray(y_converted))\n    \n    if hasattr(y, \"__array__\") or is_array_api:\n        return xp.unique_values(xp.asarray(y))\n    else:\n        return set(y)\n",
    "Location 5 (/root/hy/projects_2/scikit-learn/sklearn/utils/multiclass.py lines 81-85)": "\n    ys_types = set(type_of_target(x) for x in ys)\n    # Handle the case where we have both binary and multiclass types\n    # This can happen with nullable pandas dtypes that get converted\n    if ys_types == {\"binary\", \"multiclass\"}:\n        ys_types = {\"multiclass\"}\n\n    if len(ys_types) > 1:\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/scikit-learn/sklearn/utils/multiclass.py lines 307-313)": [
      "\n    if not issparse(y):\n        # Handle nullable pandas dtypes before general array conversion\n        if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n            # Check for nullable pandas dtypes and convert to appropriate numpy dtype\n            if y.dtype.name == 'Int64':\n                y = xp.asarray(y.astype('int64', errors='ignore'))\n            elif y.dtype.name == 'Float64':\n                y = xp.asarray(y.astype('float64', errors='ignore'))\n            elif y.dtype.name == 'boolean':\n                y = xp.asarray(y.astype('bool', errors='ignore'))\n            elif y.dtype.name in ['string', 'string[python]', 'string[pyarrow]']:\n                y = xp.asarray(y.astype('object', errors='ignore'))\n            else:\n                try:\n                    y = xp.asarray(y)\n                except (np.VisibleDeprecationWarning, ValueError):\n                    # dtype=object should be provided explicitly for ragged arrays,\n                    # see NEP 34\n                    y = xp.asarray(y, dtype=object)\n        else:\n            try:\n                y = xp.asarray(y)\n            except (np.VisibleDeprecationWarning, ValueError):\n                # dtype=object should be provided explicitly for ragged arrays,\n                # see NEP 34\n                y = xp.asarray(y, dtype=object)\n",
      "\n    if not issparse(y):\n        # Check if input is pandas Series/DataFrame with nullable dtypes\n        if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n            # Handle nullable pandas dtypes by converting to corresponding numpy dtypes\n            if y.dtype.name in ('Int8', 'Int16', 'Int32', 'Int64'):\n                # Convert nullable integer to numpy int, filling NA with 0\n                y = xp.asarray(y.fillna(0), dtype=y.dtype.name.lower())\n            elif y.dtype.name in ('Float32', 'Float64'):\n                # Convert nullable float to numpy float, keeping NaN as is\n                y = xp.asarray(y, dtype=y.dtype.name.lower())\n            elif y.dtype.name == 'boolean':\n                # Convert nullable boolean to numpy bool, filling NA with False\n                y = xp.asarray(y.fillna(False), dtype=bool)\n            elif y.dtype.name == 'string':\n                # Convert nullable string to object array\n                y = xp.asarray(y.fillna(''), dtype=object)\n            else:\n                # Standard conversion for non-nullable types\n                try:\n                    y = xp.asarray(y)\n                except (np.VisibleDeprecationWarning, ValueError):\n                    # dtype=object should be provided explicitly for ragged arrays,\n                    # see NEP 34\n                    y = xp.asarray(y, dtype=object)\n        else:\n            # Standard conversion for non-pandas types\n            try:\n                y = xp.asarray(y)\n            except (np.VisibleDeprecationWarning, ValueError):\n                # dtype=object should be provided explicitly for ragged arrays,\n                # see NEP 34\n                y = xp.asarray(y, dtype=object)\n",
      "\n    if not issparse(y):\n        # Handle nullable pandas dtypes by converting to appropriate numpy dtypes\n        if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n            # Check for nullable pandas dtypes and convert appropriately\n            if y.dtype.name == 'Int64':\n                y = xp.asarray(y.astype('int64'))\n            elif y.dtype.name == 'Float64':\n                y = xp.asarray(y.astype('float64'))\n            elif y.dtype.name == 'boolean':\n                y = xp.asarray(y.astype('bool'))\n            elif y.dtype.name in ['Int32', 'Int16', 'Int8']:\n                y = xp.asarray(y.astype(y.dtype.name.lower()))\n            elif y.dtype.name in ['Float32']:\n                y = xp.asarray(y.astype('float32'))\n            else:\n                try:\n                    y = xp.asarray(y)\n                except (np.VisibleDeprecationWarning, ValueError):\n                    # dtype=object should be provided explicitly for ragged arrays,\n                    # see NEP 34\n                    y = xp.asarray(y, dtype=object)\n        else:\n            try:\n                y = xp.asarray(y)\n            except (np.VisibleDeprecationWarning, ValueError):\n                # dtype=object should be provided explicitly for ragged arrays,\n                # see NEP 34\n                y = xp.asarray(y, dtype=object)\n",
      "\n    if not issparse(y):\n        # Handle nullable pandas dtypes by converting to appropriate numpy dtypes\n        if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n            if y.dtype.name in ['Int64', 'Int32', 'Int16', 'Int8']:\n                # Convert nullable integer to regular numpy int, handling NAs\n                y = y.astype('int64')\n            elif y.dtype.name in ['Float64', 'Float32']:\n                # Convert nullable float to regular numpy float, handling NAs  \n                y = y.astype('float64')\n            elif y.dtype.name == 'boolean':\n                # Convert nullable boolean to regular numpy bool, handling NAs\n                y = y.astype('bool')\n        \n        try:\n            y = xp.asarray(y)\n        except (np.VisibleDeprecationWarning, ValueError):\n            # dtype=object should be provided explicitly for ragged arrays,\n            # see NEP 34\n            y = xp.asarray(y, dtype=object)\n",
      "\n    if not issparse(y):\n        # Handle nullable pandas dtypes before general array conversion\n        if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n            # Check for nullable pandas dtypes and convert appropriately\n            if y.dtype.name == 'Int64':\n                y = xp.asarray(y.astype('int64', copy=False))\n            elif y.dtype.name == 'Float64':\n                y = xp.asarray(y.astype('float64', copy=False))\n            elif y.dtype.name == 'boolean':\n                y = xp.asarray(y.astype('bool', copy=False))\n            else:\n                try:\n                    y = xp.asarray(y)\n                except (np.VisibleDeprecationWarning, ValueError):\n                    # dtype=object should be provided explicitly for ragged arrays,\n                    # see NEP 34\n                    y = xp.asarray(y, dtype=object)\n        else:\n            try:\n                y = xp.asarray(y)\n            except (np.VisibleDeprecationWarning, ValueError):\n                # dtype=object should be provided explicitly for ragged arrays,\n                # see NEP 34\n                y = xp.asarray(y, dtype=object)\n",
      "\n    if not issparse(y):\n        # Handle nullable pandas dtypes before general array conversion\n        if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n            # Check for nullable pandas dtypes and convert appropriately\n            if y.dtype.name in ('Int8', 'Int16', 'Int32', 'Int64'):\n                # Convert nullable integer to regular numpy int, filling NA with 0\n                y = xp.asarray(y.fillna(0), dtype=y.dtype.name.lower())\n            elif y.dtype.name in ('Float32', 'Float64'):\n                # Convert nullable float to regular numpy float, keeping NaN as is\n                y = xp.asarray(y, dtype=y.dtype.name.lower())\n            elif y.dtype.name == 'boolean':\n                # Convert nullable boolean to regular numpy bool, filling NA with False\n                y = xp.asarray(y.fillna(False), dtype=bool)\n            elif y.dtype.name == 'string':\n                # Convert nullable string to object array\n                y = xp.asarray(y.fillna(''), dtype=object)\n            else:\n                # General conversion for other types\n                try:\n                    y = xp.asarray(y)\n                except (np.VisibleDeprecationWarning, ValueError):\n                    # dtype=object should be provided explicitly for ragged arrays,\n                    # see NEP 34\n                    y = xp.asarray(y, dtype=object)\n        else:\n            # General conversion for non-pandas types\n            try:\n                y = xp.asarray(y)\n            except (np.VisibleDeprecationWarning, ValueError):\n                # dtype=object should be provided explicitly for ragged arrays,\n                # see NEP 34\n                y = xp.asarray(y, dtype=object)\n",
      "\n    if not issparse(y):\n        # Handle nullable pandas dtypes before general array conversion\n        if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n            # Check for nullable pandas dtypes and convert appropriately\n            if y.dtype.name == 'Int64':\n                y = xp.asarray(y.astype('int64'))\n            elif y.dtype.name == 'Float64':\n                y = xp.asarray(y.astype('float64'))\n            elif y.dtype.name == 'boolean':\n                y = xp.asarray(y.astype('bool'))\n            elif y.dtype.name in ['Int32', 'Int16', 'Int8']:\n                y = xp.asarray(y.astype(y.dtype.name.lower()))\n            elif y.dtype.name in ['Float32']:\n                y = xp.asarray(y.astype('float32'))\n            else:\n                try:\n                    y = xp.asarray(y)\n                except (np.VisibleDeprecationWarning, ValueError):\n                    # dtype=object should be provided explicitly for ragged arrays,\n                    # see NEP 34\n                    y = xp.asarray(y, dtype=object)\n        else:\n            try:\n                y = xp.asarray(y)\n            except (np.VisibleDeprecationWarning, ValueError):\n                # dtype=object should be provided explicitly for ragged arrays,\n                # see NEP 34\n                y = xp.asarray(y, dtype=object)\n",
      "\n    if not issparse(y):\n        # Handle nullable pandas dtypes by converting to appropriate numpy dtypes\n        if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n            # Check for nullable pandas dtypes and convert appropriately\n            if y.dtype.name == 'Int64':\n                y = xp.asarray(y.to_numpy(dtype='int64', na_value=0))\n            elif y.dtype.name == 'Float64':\n                y = xp.asarray(y.to_numpy(dtype='float64', na_value=0.0))\n            elif y.dtype.name == 'boolean':\n                y = xp.asarray(y.to_numpy(dtype='bool', na_value=False))\n            elif y.dtype.name in ['string', 'string[python]']:\n                y = xp.asarray(y.to_numpy(dtype='object', na_value=''))\n            else:\n                try:\n                    y = xp.asarray(y)\n                except (np.VisibleDeprecationWarning, ValueError):\n                    # dtype=object should be provided explicitly for ragged arrays,\n                    # see NEP 34\n                    y = xp.asarray(y, dtype=object)\n        else:\n            try:\n                y = xp.asarray(y)\n            except (np.VisibleDeprecationWarning, ValueError):\n                # dtype=object should be provided explicitly for ragged arrays,\n                # see NEP 34\n                y = xp.asarray(y, dtype=object)\n"
    ],
    "Location 2 (/root/hy/projects_2/scikit-learn/sklearn/utils/multiclass.py lines 343-345)": [
      "\n    if not issparse(y) and y.dtype == object:\n        # Check if this is a pandas nullable dtype that was converted to object\n        # by checking if all non-null values are strings\n        if hasattr(y, 'flat') and len(y.flat) > 0:\n            non_null_values = [val for val in y.flat if val is not None and not (hasattr(val, '__class__') and val.__class__.__name__ == 'NAType')]\n            if non_null_values and not isinstance(non_null_values[0], str):\n                # [obj_1] and not [\"label_1\"] - true object array\n                return \"unknown\"\n",
      "\n    if not issparse(y) and y.dtype == object:\n        # Check if this is a pandas nullable dtype that was converted to object\n        if hasattr(y, '_original_dtype') and getattr(y, '_original_dtype', None) in ['Int64', 'Float64', 'boolean']:\n            # This was converted from a nullable pandas dtype, don't classify as unknown\n            pass\n        elif not isinstance(y.flat[0], str):\n            # [obj_1] and not [\"label_1\"]\n            return \"unknown\"\n",
      "\n    if not issparse(y) and y.dtype == object:\n        # Check if this is a pandas nullable dtype that was converted to object\n        if hasattr(y, '_pandas_nullable_converted'):\n            # This was converted from a nullable pandas dtype, process as the underlying type\n            pass\n        elif not isinstance(y.flat[0], str):\n            # [obj_1] and not [\"label_1\"]\n            return \"unknown\"\n",
      "\n    if not issparse(y) and y.dtype == object:\n        # Check if this is from nullable pandas dtype conversion\n        if hasattr(y, '_nullable_pandas_converted'):\n            # Skip the object dtype check for converted nullable pandas data\n            pass\n        elif not isinstance(y.flat[0], str):\n            # [obj_1] and not [\"label_1\"]\n            return \"unknown\"\n",
      "\n    if not issparse(y) and y.dtype == object:\n        # Check if this is a pandas Series/DataFrame with nullable dtypes that got converted to object\n        if hasattr(y, '__array_function__') and str(y.dtype).startswith('object'):\n            # For converted nullable pandas data, check the first non-null element\n            flat_y = y.flat\n            first_element = None\n            for element in flat_y:\n                if element is not None and not (hasattr(element, '__class__') and \n                                              element.__class__.__name__ in ['NAType', 'NaTType']):\n                    first_element = element\n                    break\n            if first_element is not None and not isinstance(first_element, str):\n                # [obj_1] and not [\"label_1\"] - but allow converted nullable pandas data\n                return \"unknown\"\n        elif not isinstance(y.flat[0], str):\n            # [obj_1] and not [\"label_1\"]\n            return \"unknown\"\n",
      "\n    if not issparse(y) and y.dtype == object:\n        # Check if this is a pandas nullable dtype that was converted to object\n        if hasattr(y, '_from_pandas_nullable') and y._from_pandas_nullable:\n            # Skip the object dtype check for converted nullable pandas dtypes\n            pass\n        elif not isinstance(y.flat[0], str):\n            # [obj_1] and not [\"label_1\"]\n            return \"unknown\"\n",
      "\n    if not issparse(y) and y.dtype == object:\n        # Check if this is a nullable pandas dtype that was converted to object\n        if hasattr(y, '_original_dtype') and hasattr(y._original_dtype, 'name'):\n            # This was converted from a nullable pandas dtype, don't classify as unknown\n            pass\n        elif not isinstance(y.flat[0], str):\n            # [obj_1] and not [\"label_1\"]\n            return \"unknown\"\n",
      "\n    if not issparse(y) and y.dtype == object:\n        # Check if this is from a nullable pandas dtype conversion\n        if hasattr(y, '_pandas_nullable_converted'):\n            # Skip object dtype check for converted nullable pandas dtypes\n            pass\n        elif not isinstance(y.flat[0], str):\n            # [obj_1] and not [\"label_1\"]\n            return \"unknown\"\n"
    ],
    "Location 3 (/root/hy/projects_2/scikit-learn/sklearn/utils/multiclass.py lines 362-367)": [
      "\n    # Check multiclass\n    first_row = y[0] if not issparse(y) else y.getrow(0).data\n    if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n        # [1, 2, 3] or [[1., 2., 3]] or [[1, 2]]\n        return \"multiclass\" + suffix\n    else:\n        return \"binary\"  # [1, 2] or [[\"a\"], [\"b\"]]\n",
      "\n    # Check multiclass\n    first_row = y[0] if not issparse(y) else y.getrow(0).data\n    if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n        # [1, 2, 3] or [[1., 2., 3]] or [[1, 2]]\n        return \"multiclass\" + suffix\n    else:\n        return \"binary\"  # [1, 2] or [[\"a\"], [\"b\"]]\n",
      "\n    # Check multiclass\n    first_row = y[0] if not issparse(y) else y.getrow(0).data\n    if hasattr(y, 'dtype') and hasattr(y.dtype, 'name') and y.dtype.name == 'object':\n        # For object arrays that may contain mixed types, use numpy's unique\n        unique_vals = np.unique(y)\n        n_unique = len(unique_vals)\n    else:\n        unique_vals = xp.unique_values(y)\n        n_unique = unique_vals.shape[0]\n    \n    if n_unique > 2 or (y.ndim == 2 and len(first_row) > 1):\n        # [1, 2, 3] or [[1., 2., 3]] or [[1, 2]]\n        return \"multiclass\" + suffix\n    else:\n        return \"binary\"  # [1, 2] or [[\"a\"], [\"b\"]]\n",
      "\n    # Check multiclass\n    first_row = y[0] if not issparse(y) else y.getrow(0).data\n    if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n        # [1, 2, 3] or [[1., 2., 3]] or [[1, 2]]\n        return \"multiclass\" + suffix\n    else:\n        return \"binary\"  # [1, 2] or [[\"a\"], [\"b\"]]\n",
      "\n    # Check multiclass\n    first_row = y[0] if not issparse(y) else y.getrow(0).data\n    if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n        # [1, 2, 3] or [[1., 2., 3]] or [[1, 2]]\n        return \"multiclass\" + suffix\n    else:\n        return \"binary\"  # [1, 2] or [[\"a\"], [\"b\"]]\n",
      "\n    # Check multiclass\n    if issparse(y):\n        first_row = y.getrow(0).data\n    else:\n        first_row = y[0] if y.ndim > 1 else None\n    \n    if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and first_row is not None and len(first_row) > 1):\n        # [1, 2, 3] or [[1., 2., 3]] or [[1, 2]]\n        return \"multiclass\" + suffix\n    else:\n        return \"binary\"  # [1, 2] or [[\"a\"], [\"b\"]]\n",
      "\n    # Check multiclass\n    first_row = y[0] if not issparse(y) else y.getrow(0).data\n    if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n        # [1, 2, 3] or [[1., 2., 3]] or [[1, 2]]\n        return \"multiclass\" + suffix\n    else:\n        return \"binary\"  # [1, 2] or [[\"a\"], [\"b\"]]\n",
      "\n    # Check multiclass\n    first_row = y[0] if not issparse(y) else y.getrow(0).data\n    if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n        # [1, 2, 3] or [[1., 2., 3]] or [[1, 2]]\n        return \"multiclass\" + suffix\n    else:\n        return \"binary\"  # [1, 2] or [[\"a\"], [\"b\"]]\n"
    ],
    "Location 4 (/root/hy/projects_2/scikit-learn/sklearn/utils/multiclass.py lines 23-28)": [
      "\ndef _unique_multiclass(y):\n    xp, is_array_api = get_namespace(y)\n    if hasattr(y, \"__array__\") or is_array_api:\n        # Handle nullable pandas dtypes by converting to proper numpy array\n        if hasattr(y, 'dtype') and hasattr(y.dtype, 'name') and y.dtype.name in ['Int64', 'Float64', 'boolean']:\n            # Convert nullable pandas dtype to numpy equivalent, handling NA values\n            if y.dtype.name == 'Int64':\n                converted = y.to_numpy(dtype=np.int64, na_value=0)\n            elif y.dtype.name == 'Float64':\n                converted = y.to_numpy(dtype=np.float64, na_value=np.nan)\n            elif y.dtype.name == 'boolean':\n                converted = y.to_numpy(dtype=bool, na_value=False)\n            return xp.unique_values(converted)\n        else:\n            return xp.unique_values(xp.asarray(y))\n    else:\n        return set(y)\n",
      "\ndef _unique_multiclass(y):\n    xp, is_array_api = get_namespace(y)\n    \n    # Handle pandas Series/DataFrame with nullable dtypes\n    if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n        if y.dtype.name in ('Int64', 'Float64', 'boolean', 'string'):\n            # Convert nullable pandas dtypes to numpy arrays with proper handling of NA values\n            if y.dtype.name == 'Int64':\n                y_converted = y.astype('int64').values\n            elif y.dtype.name == 'Float64':\n                y_converted = y.astype('float64').values\n            elif y.dtype.name == 'boolean':\n                y_converted = y.astype('bool').values\n            elif y.dtype.name == 'string':\n                y_converted = y.astype('object').values\n            return xp.unique_values(xp.asarray(y_converted))\n    \n    if hasattr(y, \"__array__\") or is_array_api:\n        return xp.unique_values(xp.asarray(y))\n    else:\n        return set(y)\n",
      "\ndef _unique_multiclass(y):\n    xp, is_array_api = get_namespace(y)\n    if hasattr(y, \"__array__\") or is_array_api:\n        # Handle pandas nullable dtypes by converting to appropriate numpy dtype\n        if hasattr(y, 'dtype') and hasattr(y.dtype, 'name') and y.dtype.name in ['Int64', 'Float64', 'boolean']:\n            if y.dtype.name == 'Int64':\n                y_converted = y.astype('int64')\n            elif y.dtype.name == 'Float64':\n                y_converted = y.astype('float64')\n            elif y.dtype.name == 'boolean':\n                y_converted = y.astype('bool')\n            return xp.unique_values(xp.asarray(y_converted))\n        else:\n            return xp.unique_values(xp.asarray(y))\n    else:\n        return set(y)\n",
      "\ndef _unique_multiclass(y):\n    xp, is_array_api = get_namespace(y)\n    \n    # Handle pandas Series/DataFrame with nullable dtypes\n    if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n        if y.dtype.name in ['Int64', 'Float64', 'boolean', 'string']:\n            # Convert nullable pandas dtype to numpy array, handling NA values\n            if y.dtype.name == 'Int64':\n                y_converted = y.to_numpy(dtype='int64', na_value=0)\n            elif y.dtype.name == 'Float64':\n                y_converted = y.to_numpy(dtype='float64', na_value=0.0)\n            elif y.dtype.name == 'boolean':\n                y_converted = y.to_numpy(dtype='bool', na_value=False)\n            elif y.dtype.name == 'string':\n                y_converted = y.to_numpy(dtype='object', na_value='')\n            return xp.unique_values(xp.asarray(y_converted))\n    \n    if hasattr(y, \"__array__\") or is_array_api:\n        return xp.unique_values(xp.asarray(y))\n    else:\n        return set(y)\n",
      "\ndef _unique_multiclass(y):\n    xp, is_array_api = get_namespace(y)\n    if hasattr(y, \"__array__\") or is_array_api:\n        # Handle pandas Series/DataFrame with nullable dtypes\n        if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n            if y.dtype.name in ['Int64', 'Int32', 'Int16', 'Int8', 'Float64', 'Float32', 'boolean']:\n                # Convert nullable pandas dtype to numpy equivalent, handling NA values\n                if y.dtype.name in ['Int64', 'Int32', 'Int16', 'Int8']:\n                    y_converted = y.to_numpy(dtype=y.dtype.name.lower(), na_value=0)\n                elif y.dtype.name in ['Float64', 'Float32']:\n                    y_converted = y.to_numpy(dtype=y.dtype.name.lower(), na_value=np.nan)\n                elif y.dtype.name == 'boolean':\n                    y_converted = y.to_numpy(dtype=bool, na_value=False)\n                return xp.unique_values(xp.asarray(y_converted))\n        return xp.unique_values(xp.asarray(y))\n    else:\n        return set(y)\n",
      "\ndef _unique_multiclass(y):\n    xp, is_array_api = get_namespace(y)\n    if hasattr(y, \"__array__\") or is_array_api:\n        # Handle nullable pandas dtypes by converting to appropriate numpy dtype\n        if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n            if y.dtype.name in ['Int64', 'Int32', 'Int16', 'Int8']:\n                y_converted = y.astype('int64').to_numpy()\n            elif y.dtype.name in ['Float64', 'Float32']:\n                y_converted = y.astype('float64').to_numpy()\n            elif y.dtype.name == 'boolean':\n                y_converted = y.astype('bool').to_numpy()\n            elif y.dtype.name == 'string':\n                y_converted = y.astype('object').to_numpy()\n            else:\n                y_converted = xp.asarray(y)\n        else:\n            y_converted = xp.asarray(y)\n        return xp.unique_values(y_converted)\n    else:\n        return set(y)\n",
      "\ndef _unique_multiclass(y):\n    xp, is_array_api = get_namespace(y)\n    if hasattr(y, \"__array__\") or is_array_api:\n        # Handle nullable pandas dtypes by converting to appropriate numpy dtype\n        if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n            if y.dtype.name in ['Int64', 'Int32', 'Int16', 'Int8']:\n                y_array = y.to_numpy(dtype=y.dtype.name.lower(), na_value=0)\n            elif y.dtype.name in ['Float64', 'Float32']:\n                y_array = y.to_numpy(dtype=y.dtype.name.lower(), na_value=0.0)\n            elif y.dtype.name == 'boolean':\n                y_array = y.to_numpy(dtype=bool, na_value=False)\n            elif y.dtype.name == 'string':\n                y_array = y.to_numpy(dtype=object, na_value='')\n            else:\n                y_array = xp.asarray(y)\n        else:\n            y_array = xp.asarray(y)\n        return xp.unique_values(y_array)\n    else:\n        return set(y)\n",
      "\ndef _unique_multiclass(y):\n    xp, is_array_api = get_namespace(y)\n    if hasattr(y, \"__array__\") or is_array_api:\n        # Handle pandas Series/DataFrame with nullable dtypes\n        if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n            if y.dtype.name in ['Int64', 'Int32', 'Int16', 'Int8', 'UInt64', 'UInt32', 'UInt16', 'UInt8']:\n                # Convert nullable integer to regular numpy array, handling NAs\n                y_converted = y.to_numpy(dtype=y.dtype.name.lower(), na_value=0)\n                return xp.unique_values(xp.asarray(y_converted))\n            elif y.dtype.name in ['Float64', 'Float32']:\n                # Convert nullable float to regular numpy array, handling NAs\n                y_converted = y.to_numpy(dtype=y.dtype.name.lower(), na_value=np.nan)\n                return xp.unique_values(xp.asarray(y_converted))\n            elif y.dtype.name == 'boolean':\n                # Convert nullable boolean to regular numpy array, handling NAs\n                y_converted = y.to_numpy(dtype=bool, na_value=False)\n                return xp.unique_values(xp.asarray(y_converted))\n        return xp.unique_values(xp.asarray(y))\n    else:\n        return set(y)\n"
    ],
    "Location 5 (/root/hy/projects_2/scikit-learn/sklearn/utils/multiclass.py lines 81-85)": [
      "\n    ys_types = set(type_of_target(x) for x in ys)\n    if ys_types == {\"binary\", \"multiclass\"}:\n        ys_types = {\"multiclass\"}\n\n    if len(ys_types) > 1:\n",
      "\n    ys_types = set(type_of_target(x) for x in ys)\n    if ys_types == {\"binary\", \"multiclass\"}:\n        ys_types = {\"multiclass\"}\n\n    if len(ys_types) > 1:\n",
      "\n    ys_types = set(type_of_target(x) for x in ys)\n    if ys_types == {\"binary\", \"multiclass\"}:\n        ys_types = {\"multiclass\"}\n\n    if len(ys_types) > 1:\n",
      "\n    ys_types = set(type_of_target(x) for x in ys)\n    if ys_types == {\"binary\", \"multiclass\"}:\n        ys_types = {\"multiclass\"}\n\n    if len(ys_types) > 1:\n",
      "\n    ys_types = set(type_of_target(x) for x in ys)\n    if ys_types == {\"binary\", \"multiclass\"}:\n        ys_types = {\"multiclass\"}\n\n    if len(ys_types) > 1:\n",
      "\n    ys_types = set(type_of_target(x) for x in ys)\n    if ys_types == {\"binary\", \"multiclass\"}:\n        ys_types = {\"multiclass\"}\n\n    if len(ys_types) > 1:\n",
      "\n    ys_types = set(type_of_target(x) for x in ys)\n    if ys_types == {\"binary\", \"multiclass\"}:\n        ys_types = {\"multiclass\"}\n\n    if len(ys_types) > 1:\n",
      "\n    ys_types = set(type_of_target(x) for x in ys)\n    if ys_types == {\"binary\", \"multiclass\"}:\n        ys_types = {\"multiclass\"}\n\n    if len(ys_types) > 1:\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sklearn/utils/multiclass.py b/sklearn/utils/multiclass.py\nindex 5eaef2fde..d97588035 100644\n--- a/sklearn/utils/multiclass.py\n+++ b/sklearn/utils/multiclass.py\n@@ -20,6 +20,7 @@ from .validation import check_array, _assert_all_finite\n from ..utils._array_api import get_namespace\n \n \n+\n def _unique_multiclass(y):\n     xp, is_array_api = get_namespace(y)\n     if hasattr(y, \"__array__\") or is_array_api:\n@@ -78,6 +79,7 @@ def unique_labels(*ys):\n         raise ValueError(\"No argument has been passed.\")\n     # Check that we don't mix label format\n \n+\n     ys_types = set(type_of_target(x) for x in ys)\n     if ys_types == {\"binary\", \"multiclass\"}:\n         ys_types = {\"multiclass\"}\n@@ -304,7 +306,21 @@ def type_of_target(y, input_name=\"\"):\n     # value error (NumPy >= 1.24).\n     with warnings.catch_warnings():\n         warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n+\n         if not issparse(y):\n+            # Handle nullable pandas dtypes before general conversion\n+            if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n+                # Check for nullable pandas dtypes and convert to corresponding numpy dtypes\n+                if y.dtype.name in ['Int64', 'Int32', 'Int16', 'Int8']:\n+                    # Convert nullable integer to regular numpy int, filling NAs with 0\n+                    y = y.fillna(0).astype('int64') if hasattr(y, 'fillna') else y\n+                elif y.dtype.name in ['Float64', 'Float32']:\n+                    # Convert nullable float to regular numpy float, keeping NAs as NaN\n+                    y = y.astype('float64') if hasattr(y, 'astype') else y\n+                elif y.dtype.name == 'boolean':\n+                    # Convert nullable boolean to regular numpy bool, filling NAs with False\n+                    y = y.fillna(False).astype('bool') if hasattr(y, 'fillna') else y\n+            \n             try:\n                 y = xp.asarray(y)\n             except (np.VisibleDeprecationWarning, ValueError):\n@@ -340,6 +356,7 @@ def type_of_target(y, input_name=\"\"):\n             return \"binary\"  # []\n         # 2-D empty array: [[]]\n         return \"unknown\"\n+\n     if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n         # [obj_1] and not [\"label_1\"]\n         return \"unknown\"\n@@ -359,6 +376,7 @@ def type_of_target(y, input_name=\"\"):\n             return \"continuous\" + suffix\n \n     # Check multiclass\n+\n     first_row = y[0] if not issparse(y) else y.getrow(0).data\n     if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n         # [1, 2, 3] or [[1., 2., 3]] or [[1, 2]]\n",
    "variant_0": "diff --git a/sklearn/utils/multiclass.py b/sklearn/utils/multiclass.py\nindex 5eaef2fde..6971d5bea 100644\n--- a/sklearn/utils/multiclass.py\n+++ b/sklearn/utils/multiclass.py\n@@ -20,8 +20,24 @@ from .validation import check_array, _assert_all_finite\n from ..utils._array_api import get_namespace\n \n \n+\n def _unique_multiclass(y):\n     xp, is_array_api = get_namespace(y)\n+    \n+    # Handle pandas Series/DataFrame with nullable dtypes\n+    if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n+        if y.dtype.name in ('Int64', 'Float64', 'boolean', 'string'):\n+            # Convert nullable pandas dtype to numpy equivalent\n+            if y.dtype.name == 'Int64':\n+                y_converted = y.astype('int64')\n+            elif y.dtype.name == 'Float64':\n+                y_converted = y.astype('float64')\n+            elif y.dtype.name == 'boolean':\n+                y_converted = y.astype('bool')\n+            elif y.dtype.name == 'string':\n+                y_converted = y.astype('object')\n+            return xp.unique_values(xp.asarray(y_converted))\n+    \n     if hasattr(y, \"__array__\") or is_array_api:\n         return xp.unique_values(xp.asarray(y))\n     else:\n@@ -78,7 +94,10 @@ def unique_labels(*ys):\n         raise ValueError(\"No argument has been passed.\")\n     # Check that we don't mix label format\n \n+\n     ys_types = set(type_of_target(x) for x in ys)\n+    # Handle the case where we have both binary and multiclass types\n+    # This can happen with nullable pandas dtypes that get converted\n     if ys_types == {\"binary\", \"multiclass\"}:\n         ys_types = {\"multiclass\"}\n \n@@ -304,7 +323,31 @@ def type_of_target(y, input_name=\"\"):\n     # value error (NumPy >= 1.24).\n     with warnings.catch_warnings():\n         warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n-        if not issparse(y):\n+\n+    if not issparse(y):\n+        # Handle nullable pandas dtypes by converting to appropriate numpy dtypes\n+        if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n+            dtype_name = str(y.dtype.name)\n+            if dtype_name in ['Int64', 'Int32', 'Int16', 'Int8']:\n+                # Convert nullable integer to regular numpy int, filling NA with 0\n+                y = xp.asarray(y.fillna(0).astype('int64'))\n+            elif dtype_name in ['Float64', 'Float32']:\n+                # Convert nullable float to regular numpy float, keeping NaN as is\n+                y = xp.asarray(y.astype('float64'))\n+            elif dtype_name == 'boolean':\n+                # Convert nullable boolean to regular numpy bool, filling NA with False\n+                y = xp.asarray(y.fillna(False).astype('bool'))\n+            elif dtype_name == 'string':\n+                # Convert nullable string to object array\n+                y = xp.asarray(y.fillna('').astype('object'))\n+            else:\n+                try:\n+                    y = xp.asarray(y)\n+                except (np.VisibleDeprecationWarning, ValueError):\n+                    # dtype=object should be provided explicitly for ragged arrays,\n+                    # see NEP 34\n+                    y = xp.asarray(y, dtype=object)\n+        else:\n             try:\n                 y = xp.asarray(y)\n             except (np.VisibleDeprecationWarning, ValueError):\n@@ -340,9 +383,15 @@ def type_of_target(y, input_name=\"\"):\n             return \"binary\"  # []\n         # 2-D empty array: [[]]\n         return \"unknown\"\n-    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n-        # [obj_1] and not [\"label_1\"]\n-        return \"unknown\"\n+\n+    if not issparse(y) and y.dtype == object:\n+        # Check if this is from a nullable pandas dtype conversion\n+        if hasattr(y, '_pandas_nullable_dtype_origin'):\n+            # This was converted from a nullable pandas dtype, don't classify as unknown\n+            pass\n+        elif not isinstance(y.flat[0], str):\n+            # [obj_1] and not [\"label_1\"]\n+            return \"unknown\"\n \n     # Check if multioutput\n     if y.ndim == 2 and y.shape[1] > 1:\n@@ -358,9 +407,17 @@ def type_of_target(y, input_name=\"\"):\n             _assert_all_finite(data, input_name=input_name)\n             return \"continuous\" + suffix\n \n+    # Check multiclass\n+\n     # Check multiclass\n     first_row = y[0] if not issparse(y) else y.getrow(0).data\n-    if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n+    if hasattr(y, 'dtype') and hasattr(y.dtype, 'name') and y.dtype.name == 'object':\n+        # For object arrays that may contain mixed types, use a more robust unique check\n+        unique_vals = xp.unique_values(y.ravel() if y.ndim > 1 else y)\n+    else:\n+        unique_vals = xp.unique_values(y)\n+    \n+    if unique_vals.shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n         # [1, 2, 3] or [[1., 2., 3]] or [[1, 2]]\n         return \"multiclass\" + suffix\n     else:\n",
    "variant_1": "diff --git a/sklearn/utils/multiclass.py b/sklearn/utils/multiclass.py\nindex 5eaef2fde..f73573799 100644\n--- a/sklearn/utils/multiclass.py\n+++ b/sklearn/utils/multiclass.py\n@@ -20,10 +20,22 @@ from .validation import check_array, _assert_all_finite\n from ..utils._array_api import get_namespace\n \n \n+\n def _unique_multiclass(y):\n     xp, is_array_api = get_namespace(y)\n     if hasattr(y, \"__array__\") or is_array_api:\n-        return xp.unique_values(xp.asarray(y))\n+        # Handle nullable pandas dtypes by converting to proper numpy array\n+        if hasattr(y, 'dtype') and hasattr(y.dtype, 'name') and y.dtype.name in ['Int64', 'Float64', 'boolean']:\n+            # Convert nullable pandas dtype to numpy equivalent, handling NA values\n+            if y.dtype.name == 'Int64':\n+                converted = y.to_numpy(dtype=np.int64, na_value=0)\n+            elif y.dtype.name == 'Float64':\n+                converted = y.to_numpy(dtype=np.float64, na_value=np.nan)\n+            elif y.dtype.name == 'boolean':\n+                converted = y.to_numpy(dtype=bool, na_value=False)\n+            return xp.unique_values(converted)\n+        else:\n+            return xp.unique_values(xp.asarray(y))\n     else:\n         return set(y)\n \n@@ -78,6 +90,7 @@ def unique_labels(*ys):\n         raise ValueError(\"No argument has been passed.\")\n     # Check that we don't mix label format\n \n+\n     ys_types = set(type_of_target(x) for x in ys)\n     if ys_types == {\"binary\", \"multiclass\"}:\n         ys_types = {\"multiclass\"}\n@@ -304,7 +317,27 @@ def type_of_target(y, input_name=\"\"):\n     # value error (NumPy >= 1.24).\n     with warnings.catch_warnings():\n         warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n-        if not issparse(y):\n+\n+    if not issparse(y):\n+        # Handle nullable pandas dtypes before general array conversion\n+        if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n+            # Check for nullable pandas dtypes and convert to appropriate numpy dtype\n+            if y.dtype.name == 'Int64':\n+                y = xp.asarray(y.astype('int64', errors='ignore'))\n+            elif y.dtype.name == 'Float64':\n+                y = xp.asarray(y.astype('float64', errors='ignore'))\n+            elif y.dtype.name == 'boolean':\n+                y = xp.asarray(y.astype('bool', errors='ignore'))\n+            elif y.dtype.name in ['string', 'string[python]', 'string[pyarrow]']:\n+                y = xp.asarray(y.astype('object', errors='ignore'))\n+            else:\n+                try:\n+                    y = xp.asarray(y)\n+                except (np.VisibleDeprecationWarning, ValueError):\n+                    # dtype=object should be provided explicitly for ragged arrays,\n+                    # see NEP 34\n+                    y = xp.asarray(y, dtype=object)\n+        else:\n             try:\n                 y = xp.asarray(y)\n             except (np.VisibleDeprecationWarning, ValueError):\n@@ -340,9 +373,15 @@ def type_of_target(y, input_name=\"\"):\n             return \"binary\"  # []\n         # 2-D empty array: [[]]\n         return \"unknown\"\n-    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n-        # [obj_1] and not [\"label_1\"]\n-        return \"unknown\"\n+\n+    if not issparse(y) and y.dtype == object:\n+        # Check if this is a pandas nullable dtype that was converted to object\n+        # by checking if all non-null values are strings\n+        if hasattr(y, 'flat') and len(y.flat) > 0:\n+            non_null_values = [val for val in y.flat if val is not None and not (hasattr(val, '__class__') and val.__class__.__name__ == 'NAType')]\n+            if non_null_values and not isinstance(non_null_values[0], str):\n+                # [obj_1] and not [\"label_1\"] - true object array\n+                return \"unknown\"\n \n     # Check if multioutput\n     if y.ndim == 2 and y.shape[1] > 1:\n@@ -358,6 +397,8 @@ def type_of_target(y, input_name=\"\"):\n             _assert_all_finite(data, input_name=input_name)\n             return \"continuous\" + suffix\n \n+    # Check multiclass\n+\n     # Check multiclass\n     first_row = y[0] if not issparse(y) else y.getrow(0).data\n     if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n",
    "variant_2": "diff --git a/sklearn/utils/multiclass.py b/sklearn/utils/multiclass.py\nindex 5eaef2fde..e3315fb31 100644\n--- a/sklearn/utils/multiclass.py\n+++ b/sklearn/utils/multiclass.py\n@@ -20,8 +20,24 @@ from .validation import check_array, _assert_all_finite\n from ..utils._array_api import get_namespace\n \n \n+\n def _unique_multiclass(y):\n     xp, is_array_api = get_namespace(y)\n+    \n+    # Handle pandas Series/DataFrame with nullable dtypes\n+    if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n+        if y.dtype.name in ('Int64', 'Float64', 'boolean', 'string'):\n+            # Convert nullable pandas dtypes to numpy arrays with proper handling of NA values\n+            if y.dtype.name == 'Int64':\n+                y_converted = y.astype('int64').values\n+            elif y.dtype.name == 'Float64':\n+                y_converted = y.astype('float64').values\n+            elif y.dtype.name == 'boolean':\n+                y_converted = y.astype('bool').values\n+            elif y.dtype.name == 'string':\n+                y_converted = y.astype('object').values\n+            return xp.unique_values(xp.asarray(y_converted))\n+    \n     if hasattr(y, \"__array__\") or is_array_api:\n         return xp.unique_values(xp.asarray(y))\n     else:\n@@ -78,6 +94,7 @@ def unique_labels(*ys):\n         raise ValueError(\"No argument has been passed.\")\n     # Check that we don't mix label format\n \n+\n     ys_types = set(type_of_target(x) for x in ys)\n     if ys_types == {\"binary\", \"multiclass\"}:\n         ys_types = {\"multiclass\"}\n@@ -304,7 +321,33 @@ def type_of_target(y, input_name=\"\"):\n     # value error (NumPy >= 1.24).\n     with warnings.catch_warnings():\n         warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n-        if not issparse(y):\n+\n+    if not issparse(y):\n+        # Check if input is pandas Series/DataFrame with nullable dtypes\n+        if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n+            # Handle nullable pandas dtypes by converting to corresponding numpy dtypes\n+            if y.dtype.name in ('Int8', 'Int16', 'Int32', 'Int64'):\n+                # Convert nullable integer to numpy int, filling NA with 0\n+                y = xp.asarray(y.fillna(0), dtype=y.dtype.name.lower())\n+            elif y.dtype.name in ('Float32', 'Float64'):\n+                # Convert nullable float to numpy float, keeping NaN as is\n+                y = xp.asarray(y, dtype=y.dtype.name.lower())\n+            elif y.dtype.name == 'boolean':\n+                # Convert nullable boolean to numpy bool, filling NA with False\n+                y = xp.asarray(y.fillna(False), dtype=bool)\n+            elif y.dtype.name == 'string':\n+                # Convert nullable string to object array\n+                y = xp.asarray(y.fillna(''), dtype=object)\n+            else:\n+                # Standard conversion for non-nullable types\n+                try:\n+                    y = xp.asarray(y)\n+                except (np.VisibleDeprecationWarning, ValueError):\n+                    # dtype=object should be provided explicitly for ragged arrays,\n+                    # see NEP 34\n+                    y = xp.asarray(y, dtype=object)\n+        else:\n+            # Standard conversion for non-pandas types\n             try:\n                 y = xp.asarray(y)\n             except (np.VisibleDeprecationWarning, ValueError):\n@@ -340,9 +383,15 @@ def type_of_target(y, input_name=\"\"):\n             return \"binary\"  # []\n         # 2-D empty array: [[]]\n         return \"unknown\"\n-    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n-        # [obj_1] and not [\"label_1\"]\n-        return \"unknown\"\n+\n+    if not issparse(y) and y.dtype == object:\n+        # Check if this is a pandas nullable dtype that was converted to object\n+        if hasattr(y, '_original_dtype') and getattr(y, '_original_dtype', None) in ['Int64', 'Float64', 'boolean']:\n+            # This was converted from a nullable pandas dtype, don't classify as unknown\n+            pass\n+        elif not isinstance(y.flat[0], str):\n+            # [obj_1] and not [\"label_1\"]\n+            return \"unknown\"\n \n     # Check if multioutput\n     if y.ndim == 2 and y.shape[1] > 1:\n@@ -358,6 +407,8 @@ def type_of_target(y, input_name=\"\"):\n             _assert_all_finite(data, input_name=input_name)\n             return \"continuous\" + suffix\n \n+    # Check multiclass\n+\n     # Check multiclass\n     first_row = y[0] if not issparse(y) else y.getrow(0).data\n     if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n",
    "variant_3": "diff --git a/sklearn/utils/multiclass.py b/sklearn/utils/multiclass.py\nindex 5eaef2fde..4dc042e26 100644\n--- a/sklearn/utils/multiclass.py\n+++ b/sklearn/utils/multiclass.py\n@@ -20,10 +20,21 @@ from .validation import check_array, _assert_all_finite\n from ..utils._array_api import get_namespace\n \n \n+\n def _unique_multiclass(y):\n     xp, is_array_api = get_namespace(y)\n     if hasattr(y, \"__array__\") or is_array_api:\n-        return xp.unique_values(xp.asarray(y))\n+        # Handle pandas nullable dtypes by converting to appropriate numpy dtype\n+        if hasattr(y, 'dtype') and hasattr(y.dtype, 'name') and y.dtype.name in ['Int64', 'Float64', 'boolean']:\n+            if y.dtype.name == 'Int64':\n+                y_converted = y.astype('int64')\n+            elif y.dtype.name == 'Float64':\n+                y_converted = y.astype('float64')\n+            elif y.dtype.name == 'boolean':\n+                y_converted = y.astype('bool')\n+            return xp.unique_values(xp.asarray(y_converted))\n+        else:\n+            return xp.unique_values(xp.asarray(y))\n     else:\n         return set(y)\n \n@@ -78,6 +89,7 @@ def unique_labels(*ys):\n         raise ValueError(\"No argument has been passed.\")\n     # Check that we don't mix label format\n \n+\n     ys_types = set(type_of_target(x) for x in ys)\n     if ys_types == {\"binary\", \"multiclass\"}:\n         ys_types = {\"multiclass\"}\n@@ -304,7 +316,29 @@ def type_of_target(y, input_name=\"\"):\n     # value error (NumPy >= 1.24).\n     with warnings.catch_warnings():\n         warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n-        if not issparse(y):\n+\n+    if not issparse(y):\n+        # Handle nullable pandas dtypes by converting to appropriate numpy dtypes\n+        if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n+            # Check for nullable pandas dtypes and convert appropriately\n+            if y.dtype.name == 'Int64':\n+                y = xp.asarray(y.astype('int64'))\n+            elif y.dtype.name == 'Float64':\n+                y = xp.asarray(y.astype('float64'))\n+            elif y.dtype.name == 'boolean':\n+                y = xp.asarray(y.astype('bool'))\n+            elif y.dtype.name in ['Int32', 'Int16', 'Int8']:\n+                y = xp.asarray(y.astype(y.dtype.name.lower()))\n+            elif y.dtype.name in ['Float32']:\n+                y = xp.asarray(y.astype('float32'))\n+            else:\n+                try:\n+                    y = xp.asarray(y)\n+                except (np.VisibleDeprecationWarning, ValueError):\n+                    # dtype=object should be provided explicitly for ragged arrays,\n+                    # see NEP 34\n+                    y = xp.asarray(y, dtype=object)\n+        else:\n             try:\n                 y = xp.asarray(y)\n             except (np.VisibleDeprecationWarning, ValueError):\n@@ -340,9 +374,15 @@ def type_of_target(y, input_name=\"\"):\n             return \"binary\"  # []\n         # 2-D empty array: [[]]\n         return \"unknown\"\n-    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n-        # [obj_1] and not [\"label_1\"]\n-        return \"unknown\"\n+\n+    if not issparse(y) and y.dtype == object:\n+        # Check if this is a pandas nullable dtype that was converted to object\n+        if hasattr(y, '_pandas_nullable_converted'):\n+            # This was converted from a nullable pandas dtype, process as the underlying type\n+            pass\n+        elif not isinstance(y.flat[0], str):\n+            # [obj_1] and not [\"label_1\"]\n+            return \"unknown\"\n \n     # Check if multioutput\n     if y.ndim == 2 and y.shape[1] > 1:\n@@ -358,9 +398,19 @@ def type_of_target(y, input_name=\"\"):\n             _assert_all_finite(data, input_name=input_name)\n             return \"continuous\" + suffix\n \n+    # Check multiclass\n+\n     # Check multiclass\n     first_row = y[0] if not issparse(y) else y.getrow(0).data\n-    if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n+    if hasattr(y, 'dtype') and hasattr(y.dtype, 'name') and y.dtype.name == 'object':\n+        # For object arrays that may contain mixed types, use numpy's unique\n+        unique_vals = np.unique(y)\n+        n_unique = len(unique_vals)\n+    else:\n+        unique_vals = xp.unique_values(y)\n+        n_unique = unique_vals.shape[0]\n+    \n+    if n_unique > 2 or (y.ndim == 2 and len(first_row) > 1):\n         # [1, 2, 3] or [[1., 2., 3]] or [[1, 2]]\n         return \"multiclass\" + suffix\n     else:\n",
    "variant_4": "diff --git a/sklearn/utils/multiclass.py b/sklearn/utils/multiclass.py\nindex 5eaef2fde..fe685a77a 100644\n--- a/sklearn/utils/multiclass.py\n+++ b/sklearn/utils/multiclass.py\n@@ -20,8 +20,24 @@ from .validation import check_array, _assert_all_finite\n from ..utils._array_api import get_namespace\n \n \n+\n def _unique_multiclass(y):\n     xp, is_array_api = get_namespace(y)\n+    \n+    # Handle pandas Series/DataFrame with nullable dtypes\n+    if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n+        if y.dtype.name in ['Int64', 'Float64', 'boolean', 'string']:\n+            # Convert nullable pandas dtype to numpy array, handling NA values\n+            if y.dtype.name == 'Int64':\n+                y_converted = y.to_numpy(dtype='int64', na_value=0)\n+            elif y.dtype.name == 'Float64':\n+                y_converted = y.to_numpy(dtype='float64', na_value=0.0)\n+            elif y.dtype.name == 'boolean':\n+                y_converted = y.to_numpy(dtype='bool', na_value=False)\n+            elif y.dtype.name == 'string':\n+                y_converted = y.to_numpy(dtype='object', na_value='')\n+            return xp.unique_values(xp.asarray(y_converted))\n+    \n     if hasattr(y, \"__array__\") or is_array_api:\n         return xp.unique_values(xp.asarray(y))\n     else:\n@@ -78,6 +94,7 @@ def unique_labels(*ys):\n         raise ValueError(\"No argument has been passed.\")\n     # Check that we don't mix label format\n \n+\n     ys_types = set(type_of_target(x) for x in ys)\n     if ys_types == {\"binary\", \"multiclass\"}:\n         ys_types = {\"multiclass\"}\n@@ -304,13 +321,26 @@ def type_of_target(y, input_name=\"\"):\n     # value error (NumPy >= 1.24).\n     with warnings.catch_warnings():\n         warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n-        if not issparse(y):\n-            try:\n-                y = xp.asarray(y)\n-            except (np.VisibleDeprecationWarning, ValueError):\n-                # dtype=object should be provided explicitly for ragged arrays,\n-                # see NEP 34\n-                y = xp.asarray(y, dtype=object)\n+\n+    if not issparse(y):\n+        # Handle nullable pandas dtypes by converting to appropriate numpy dtypes\n+        if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n+            if y.dtype.name in ['Int64', 'Int32', 'Int16', 'Int8']:\n+                # Convert nullable integer to regular numpy int, handling NAs\n+                y = y.astype('int64')\n+            elif y.dtype.name in ['Float64', 'Float32']:\n+                # Convert nullable float to regular numpy float, handling NAs  \n+                y = y.astype('float64')\n+            elif y.dtype.name == 'boolean':\n+                # Convert nullable boolean to regular numpy bool, handling NAs\n+                y = y.astype('bool')\n+        \n+        try:\n+            y = xp.asarray(y)\n+        except (np.VisibleDeprecationWarning, ValueError):\n+            # dtype=object should be provided explicitly for ragged arrays,\n+            # see NEP 34\n+            y = xp.asarray(y, dtype=object)\n \n     # The old sequence of sequences format\n     try:\n@@ -340,9 +370,15 @@ def type_of_target(y, input_name=\"\"):\n             return \"binary\"  # []\n         # 2-D empty array: [[]]\n         return \"unknown\"\n-    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n-        # [obj_1] and not [\"label_1\"]\n-        return \"unknown\"\n+\n+    if not issparse(y) and y.dtype == object:\n+        # Check if this is from nullable pandas dtype conversion\n+        if hasattr(y, '_nullable_pandas_converted'):\n+            # Skip the object dtype check for converted nullable pandas data\n+            pass\n+        elif not isinstance(y.flat[0], str):\n+            # [obj_1] and not [\"label_1\"]\n+            return \"unknown\"\n \n     # Check if multioutput\n     if y.ndim == 2 and y.shape[1] > 1:\n@@ -358,6 +394,8 @@ def type_of_target(y, input_name=\"\"):\n             _assert_all_finite(data, input_name=input_name)\n             return \"continuous\" + suffix\n \n+    # Check multiclass\n+\n     # Check multiclass\n     first_row = y[0] if not issparse(y) else y.getrow(0).data\n     if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n",
    "variant_5": "diff --git a/sklearn/utils/multiclass.py b/sklearn/utils/multiclass.py\nindex 5eaef2fde..4b55346ed 100644\n--- a/sklearn/utils/multiclass.py\n+++ b/sklearn/utils/multiclass.py\n@@ -20,9 +20,21 @@ from .validation import check_array, _assert_all_finite\n from ..utils._array_api import get_namespace\n \n \n+\n def _unique_multiclass(y):\n     xp, is_array_api = get_namespace(y)\n     if hasattr(y, \"__array__\") or is_array_api:\n+        # Handle pandas Series/DataFrame with nullable dtypes\n+        if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n+            if y.dtype.name in ['Int64', 'Int32', 'Int16', 'Int8', 'Float64', 'Float32', 'boolean']:\n+                # Convert nullable pandas dtype to numpy equivalent, handling NA values\n+                if y.dtype.name in ['Int64', 'Int32', 'Int16', 'Int8']:\n+                    y_converted = y.to_numpy(dtype=y.dtype.name.lower(), na_value=0)\n+                elif y.dtype.name in ['Float64', 'Float32']:\n+                    y_converted = y.to_numpy(dtype=y.dtype.name.lower(), na_value=np.nan)\n+                elif y.dtype.name == 'boolean':\n+                    y_converted = y.to_numpy(dtype=bool, na_value=False)\n+                return xp.unique_values(xp.asarray(y_converted))\n         return xp.unique_values(xp.asarray(y))\n     else:\n         return set(y)\n@@ -78,6 +90,7 @@ def unique_labels(*ys):\n         raise ValueError(\"No argument has been passed.\")\n     # Check that we don't mix label format\n \n+\n     ys_types = set(type_of_target(x) for x in ys)\n     if ys_types == {\"binary\", \"multiclass\"}:\n         ys_types = {\"multiclass\"}\n@@ -304,7 +317,25 @@ def type_of_target(y, input_name=\"\"):\n     # value error (NumPy >= 1.24).\n     with warnings.catch_warnings():\n         warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n-        if not issparse(y):\n+\n+    if not issparse(y):\n+        # Handle nullable pandas dtypes before general array conversion\n+        if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n+            # Check for nullable pandas dtypes and convert appropriately\n+            if y.dtype.name == 'Int64':\n+                y = xp.asarray(y.astype('int64', copy=False))\n+            elif y.dtype.name == 'Float64':\n+                y = xp.asarray(y.astype('float64', copy=False))\n+            elif y.dtype.name == 'boolean':\n+                y = xp.asarray(y.astype('bool', copy=False))\n+            else:\n+                try:\n+                    y = xp.asarray(y)\n+                except (np.VisibleDeprecationWarning, ValueError):\n+                    # dtype=object should be provided explicitly for ragged arrays,\n+                    # see NEP 34\n+                    y = xp.asarray(y, dtype=object)\n+        else:\n             try:\n                 y = xp.asarray(y)\n             except (np.VisibleDeprecationWarning, ValueError):\n@@ -340,9 +371,24 @@ def type_of_target(y, input_name=\"\"):\n             return \"binary\"  # []\n         # 2-D empty array: [[]]\n         return \"unknown\"\n-    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n-        # [obj_1] and not [\"label_1\"]\n-        return \"unknown\"\n+\n+    if not issparse(y) and y.dtype == object:\n+        # Check if this is a pandas Series/DataFrame with nullable dtypes that got converted to object\n+        if hasattr(y, '__array_function__') and str(y.dtype).startswith('object'):\n+            # For converted nullable pandas data, check the first non-null element\n+            flat_y = y.flat\n+            first_element = None\n+            for element in flat_y:\n+                if element is not None and not (hasattr(element, '__class__') and \n+                                              element.__class__.__name__ in ['NAType', 'NaTType']):\n+                    first_element = element\n+                    break\n+            if first_element is not None and not isinstance(first_element, str):\n+                # [obj_1] and not [\"label_1\"] - but allow converted nullable pandas data\n+                return \"unknown\"\n+        elif not isinstance(y.flat[0], str):\n+            # [obj_1] and not [\"label_1\"]\n+            return \"unknown\"\n \n     # Check if multioutput\n     if y.ndim == 2 and y.shape[1] > 1:\n@@ -358,6 +404,8 @@ def type_of_target(y, input_name=\"\"):\n             _assert_all_finite(data, input_name=input_name)\n             return \"continuous\" + suffix\n \n+    # Check multiclass\n+\n     # Check multiclass\n     first_row = y[0] if not issparse(y) else y.getrow(0).data\n     if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n",
    "variant_6": "diff --git a/sklearn/utils/multiclass.py b/sklearn/utils/multiclass.py\nindex 5eaef2fde..a8b5b0cfb 100644\n--- a/sklearn/utils/multiclass.py\n+++ b/sklearn/utils/multiclass.py\n@@ -20,10 +20,25 @@ from .validation import check_array, _assert_all_finite\n from ..utils._array_api import get_namespace\n \n \n+\n def _unique_multiclass(y):\n     xp, is_array_api = get_namespace(y)\n     if hasattr(y, \"__array__\") or is_array_api:\n-        return xp.unique_values(xp.asarray(y))\n+        # Handle nullable pandas dtypes by converting to appropriate numpy dtype\n+        if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n+            if y.dtype.name in ['Int64', 'Int32', 'Int16', 'Int8']:\n+                y_converted = y.astype('int64').to_numpy()\n+            elif y.dtype.name in ['Float64', 'Float32']:\n+                y_converted = y.astype('float64').to_numpy()\n+            elif y.dtype.name == 'boolean':\n+                y_converted = y.astype('bool').to_numpy()\n+            elif y.dtype.name == 'string':\n+                y_converted = y.astype('object').to_numpy()\n+            else:\n+                y_converted = xp.asarray(y)\n+        else:\n+            y_converted = xp.asarray(y)\n+        return xp.unique_values(y_converted)\n     else:\n         return set(y)\n \n@@ -78,6 +93,7 @@ def unique_labels(*ys):\n         raise ValueError(\"No argument has been passed.\")\n     # Check that we don't mix label format\n \n+\n     ys_types = set(type_of_target(x) for x in ys)\n     if ys_types == {\"binary\", \"multiclass\"}:\n         ys_types = {\"multiclass\"}\n@@ -304,7 +320,33 @@ def type_of_target(y, input_name=\"\"):\n     # value error (NumPy >= 1.24).\n     with warnings.catch_warnings():\n         warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n-        if not issparse(y):\n+\n+    if not issparse(y):\n+        # Handle nullable pandas dtypes before general array conversion\n+        if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n+            # Check for nullable pandas dtypes and convert appropriately\n+            if y.dtype.name in ('Int8', 'Int16', 'Int32', 'Int64'):\n+                # Convert nullable integer to regular numpy int, filling NA with 0\n+                y = xp.asarray(y.fillna(0), dtype=y.dtype.name.lower())\n+            elif y.dtype.name in ('Float32', 'Float64'):\n+                # Convert nullable float to regular numpy float, keeping NaN as is\n+                y = xp.asarray(y, dtype=y.dtype.name.lower())\n+            elif y.dtype.name == 'boolean':\n+                # Convert nullable boolean to regular numpy bool, filling NA with False\n+                y = xp.asarray(y.fillna(False), dtype=bool)\n+            elif y.dtype.name == 'string':\n+                # Convert nullable string to object array\n+                y = xp.asarray(y.fillna(''), dtype=object)\n+            else:\n+                # General conversion for other types\n+                try:\n+                    y = xp.asarray(y)\n+                except (np.VisibleDeprecationWarning, ValueError):\n+                    # dtype=object should be provided explicitly for ragged arrays,\n+                    # see NEP 34\n+                    y = xp.asarray(y, dtype=object)\n+        else:\n+            # General conversion for non-pandas types\n             try:\n                 y = xp.asarray(y)\n             except (np.VisibleDeprecationWarning, ValueError):\n@@ -340,9 +382,15 @@ def type_of_target(y, input_name=\"\"):\n             return \"binary\"  # []\n         # 2-D empty array: [[]]\n         return \"unknown\"\n-    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n-        # [obj_1] and not [\"label_1\"]\n-        return \"unknown\"\n+\n+    if not issparse(y) and y.dtype == object:\n+        # Check if this is a pandas nullable dtype that was converted to object\n+        if hasattr(y, '_from_pandas_nullable') and y._from_pandas_nullable:\n+            # Skip the object dtype check for converted nullable pandas dtypes\n+            pass\n+        elif not isinstance(y.flat[0], str):\n+            # [obj_1] and not [\"label_1\"]\n+            return \"unknown\"\n \n     # Check if multioutput\n     if y.ndim == 2 and y.shape[1] > 1:\n@@ -359,8 +407,14 @@ def type_of_target(y, input_name=\"\"):\n             return \"continuous\" + suffix\n \n     # Check multiclass\n-    first_row = y[0] if not issparse(y) else y.getrow(0).data\n-    if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n+\n+    # Check multiclass\n+    if issparse(y):\n+        first_row = y.getrow(0).data\n+    else:\n+        first_row = y[0] if y.ndim > 1 else None\n+    \n+    if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and first_row is not None and len(first_row) > 1):\n         # [1, 2, 3] or [[1., 2., 3]] or [[1, 2]]\n         return \"multiclass\" + suffix\n     else:\n",
    "variant_7": "diff --git a/sklearn/utils/multiclass.py b/sklearn/utils/multiclass.py\nindex 5eaef2fde..5371fe260 100644\n--- a/sklearn/utils/multiclass.py\n+++ b/sklearn/utils/multiclass.py\n@@ -20,10 +20,25 @@ from .validation import check_array, _assert_all_finite\n from ..utils._array_api import get_namespace\n \n \n+\n def _unique_multiclass(y):\n     xp, is_array_api = get_namespace(y)\n     if hasattr(y, \"__array__\") or is_array_api:\n-        return xp.unique_values(xp.asarray(y))\n+        # Handle nullable pandas dtypes by converting to appropriate numpy dtype\n+        if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n+            if y.dtype.name in ['Int64', 'Int32', 'Int16', 'Int8']:\n+                y_array = y.to_numpy(dtype=y.dtype.name.lower(), na_value=0)\n+            elif y.dtype.name in ['Float64', 'Float32']:\n+                y_array = y.to_numpy(dtype=y.dtype.name.lower(), na_value=0.0)\n+            elif y.dtype.name == 'boolean':\n+                y_array = y.to_numpy(dtype=bool, na_value=False)\n+            elif y.dtype.name == 'string':\n+                y_array = y.to_numpy(dtype=object, na_value='')\n+            else:\n+                y_array = xp.asarray(y)\n+        else:\n+            y_array = xp.asarray(y)\n+        return xp.unique_values(y_array)\n     else:\n         return set(y)\n \n@@ -78,6 +93,7 @@ def unique_labels(*ys):\n         raise ValueError(\"No argument has been passed.\")\n     # Check that we don't mix label format\n \n+\n     ys_types = set(type_of_target(x) for x in ys)\n     if ys_types == {\"binary\", \"multiclass\"}:\n         ys_types = {\"multiclass\"}\n@@ -304,7 +320,29 @@ def type_of_target(y, input_name=\"\"):\n     # value error (NumPy >= 1.24).\n     with warnings.catch_warnings():\n         warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n-        if not issparse(y):\n+\n+    if not issparse(y):\n+        # Handle nullable pandas dtypes before general array conversion\n+        if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n+            # Check for nullable pandas dtypes and convert appropriately\n+            if y.dtype.name == 'Int64':\n+                y = xp.asarray(y.astype('int64'))\n+            elif y.dtype.name == 'Float64':\n+                y = xp.asarray(y.astype('float64'))\n+            elif y.dtype.name == 'boolean':\n+                y = xp.asarray(y.astype('bool'))\n+            elif y.dtype.name in ['Int32', 'Int16', 'Int8']:\n+                y = xp.asarray(y.astype(y.dtype.name.lower()))\n+            elif y.dtype.name in ['Float32']:\n+                y = xp.asarray(y.astype('float32'))\n+            else:\n+                try:\n+                    y = xp.asarray(y)\n+                except (np.VisibleDeprecationWarning, ValueError):\n+                    # dtype=object should be provided explicitly for ragged arrays,\n+                    # see NEP 34\n+                    y = xp.asarray(y, dtype=object)\n+        else:\n             try:\n                 y = xp.asarray(y)\n             except (np.VisibleDeprecationWarning, ValueError):\n@@ -340,9 +378,15 @@ def type_of_target(y, input_name=\"\"):\n             return \"binary\"  # []\n         # 2-D empty array: [[]]\n         return \"unknown\"\n-    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n-        # [obj_1] and not [\"label_1\"]\n-        return \"unknown\"\n+\n+    if not issparse(y) and y.dtype == object:\n+        # Check if this is a nullable pandas dtype that was converted to object\n+        if hasattr(y, '_original_dtype') and hasattr(y._original_dtype, 'name'):\n+            # This was converted from a nullable pandas dtype, don't classify as unknown\n+            pass\n+        elif not isinstance(y.flat[0], str):\n+            # [obj_1] and not [\"label_1\"]\n+            return \"unknown\"\n \n     # Check if multioutput\n     if y.ndim == 2 and y.shape[1] > 1:\n@@ -358,6 +402,8 @@ def type_of_target(y, input_name=\"\"):\n             _assert_all_finite(data, input_name=input_name)\n             return \"continuous\" + suffix\n \n+    # Check multiclass\n+\n     # Check multiclass\n     first_row = y[0] if not issparse(y) else y.getrow(0).data\n     if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n",
    "variant_8": "diff --git a/sklearn/utils/multiclass.py b/sklearn/utils/multiclass.py\nindex 5eaef2fde..b952b8067 100644\n--- a/sklearn/utils/multiclass.py\n+++ b/sklearn/utils/multiclass.py\n@@ -20,9 +20,24 @@ from .validation import check_array, _assert_all_finite\n from ..utils._array_api import get_namespace\n \n \n+\n def _unique_multiclass(y):\n     xp, is_array_api = get_namespace(y)\n     if hasattr(y, \"__array__\") or is_array_api:\n+        # Handle pandas Series/DataFrame with nullable dtypes\n+        if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n+            if y.dtype.name in ['Int64', 'Int32', 'Int16', 'Int8', 'UInt64', 'UInt32', 'UInt16', 'UInt8']:\n+                # Convert nullable integer to regular numpy array, handling NAs\n+                y_converted = y.to_numpy(dtype=y.dtype.name.lower(), na_value=0)\n+                return xp.unique_values(xp.asarray(y_converted))\n+            elif y.dtype.name in ['Float64', 'Float32']:\n+                # Convert nullable float to regular numpy array, handling NAs\n+                y_converted = y.to_numpy(dtype=y.dtype.name.lower(), na_value=np.nan)\n+                return xp.unique_values(xp.asarray(y_converted))\n+            elif y.dtype.name == 'boolean':\n+                # Convert nullable boolean to regular numpy array, handling NAs\n+                y_converted = y.to_numpy(dtype=bool, na_value=False)\n+                return xp.unique_values(xp.asarray(y_converted))\n         return xp.unique_values(xp.asarray(y))\n     else:\n         return set(y)\n@@ -78,6 +93,7 @@ def unique_labels(*ys):\n         raise ValueError(\"No argument has been passed.\")\n     # Check that we don't mix label format\n \n+\n     ys_types = set(type_of_target(x) for x in ys)\n     if ys_types == {\"binary\", \"multiclass\"}:\n         ys_types = {\"multiclass\"}\n@@ -304,7 +320,27 @@ def type_of_target(y, input_name=\"\"):\n     # value error (NumPy >= 1.24).\n     with warnings.catch_warnings():\n         warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n-        if not issparse(y):\n+\n+    if not issparse(y):\n+        # Handle nullable pandas dtypes by converting to appropriate numpy dtypes\n+        if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n+            # Check for nullable pandas dtypes and convert appropriately\n+            if y.dtype.name == 'Int64':\n+                y = xp.asarray(y.to_numpy(dtype='int64', na_value=0))\n+            elif y.dtype.name == 'Float64':\n+                y = xp.asarray(y.to_numpy(dtype='float64', na_value=0.0))\n+            elif y.dtype.name == 'boolean':\n+                y = xp.asarray(y.to_numpy(dtype='bool', na_value=False))\n+            elif y.dtype.name in ['string', 'string[python]']:\n+                y = xp.asarray(y.to_numpy(dtype='object', na_value=''))\n+            else:\n+                try:\n+                    y = xp.asarray(y)\n+                except (np.VisibleDeprecationWarning, ValueError):\n+                    # dtype=object should be provided explicitly for ragged arrays,\n+                    # see NEP 34\n+                    y = xp.asarray(y, dtype=object)\n+        else:\n             try:\n                 y = xp.asarray(y)\n             except (np.VisibleDeprecationWarning, ValueError):\n@@ -340,9 +376,15 @@ def type_of_target(y, input_name=\"\"):\n             return \"binary\"  # []\n         # 2-D empty array: [[]]\n         return \"unknown\"\n-    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n-        # [obj_1] and not [\"label_1\"]\n-        return \"unknown\"\n+\n+    if not issparse(y) and y.dtype == object:\n+        # Check if this is from a nullable pandas dtype conversion\n+        if hasattr(y, '_pandas_nullable_converted'):\n+            # Skip object dtype check for converted nullable pandas dtypes\n+            pass\n+        elif not isinstance(y.flat[0], str):\n+            # [obj_1] and not [\"label_1\"]\n+            return \"unknown\"\n \n     # Check if multioutput\n     if y.ndim == 2 and y.shape[1] > 1:\n@@ -358,6 +400,8 @@ def type_of_target(y, input_name=\"\"):\n             _assert_all_finite(data, input_name=input_name)\n             return \"continuous\" + suffix\n \n+    # Check multiclass\n+\n     # Check multiclass\n     first_row = y[0] if not issparse(y) else y.getrow(0).data\n     if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n"
  }
}