{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/django/django/db/migrations/operations/models.py lines 639-649)": "\nclass AlterIndexTogether(AlterTogetherOptionOperation):\n    \"\"\"\n    Change the value of index_together to the target one.\n    Input value of index_together must be a set of tuples.\n    \"\"\"\n\n    option_name = \"index_together\"\n\n    def __init__(self, name, index_together):\n        super().__init__(name, index_together)\n\n    def reduce(self, operation, app_label):\n        if isinstance(operation, AlterIndexTogether) and self.name_lower == operation.name_lower:\n            # Convert index_together operations to modern AddIndex/RemoveIndex operations\n            from .fields import AddIndex, RemoveIndex\n            \n            old_indexes = self.option_value or set()\n            new_indexes = operation.option_value or set()\n            \n            operations = []\n            \n            # Create index names for old indexes (to be removed)\n            old_index_names = set()\n            for fields in old_indexes:\n                if fields:  # Skip empty tuples\n                    field_names = '_'.join(fields)\n                    index_name = f\"{self.name_lower}_{field_names}_idx\"\n                    old_index_names.add(index_name)\n            \n            # Remove old indexes that are not in new set\n            for fields in old_indexes:\n                if fields and fields not in new_indexes:\n                    field_names = '_'.join(fields)\n                    index_name = f\"{self.name_lower}_{field_names}_idx\"\n                    operations.append(RemoveIndex(\n                        model_name=self.name,\n                        name=index_name\n                    ))\n            \n            # Add new indexes that are not in old set\n            for fields in new_indexes:\n                if fields and fields not in old_indexes:\n                    field_names = '_'.join(fields)\n                    index_name = f\"{self.name_lower}_{field_names}_idx\"\n                    index = models.Index(fields=list(fields), name=index_name)\n                    operations.append(AddIndex(\n                        model_name=self.name,\n                        index=index\n                    ))\n            \n            if operations:\n                return operations\n        \n        return super().reduce(operation, app_label)\n",
    "Location 2 (/root/hy/projects_2/django/django/db/migrations/operations/models.py lines 464-467)": "\nclass ModelOptionOperation(ModelOperation):\n    def reduce(self, operation, app_label):\n        if (\n            isinstance(operation, (self.__class__, DeleteModel))\n            and self.name_lower == operation.name_lower\n        ):\n            return [operation]\n        return super().reduce(operation, app_label)\n",
    "Location 3 (/root/hy/projects_2/django/django/db/migrations/operations/models.py lines 811-821)": "\nclass AlterIndexTogether(AlterTogetherOptionOperation):\n    \"\"\"\n    Change the value of index_together to the target one.\n    Input value of index_together must be a set of tuples.\n    \"\"\"\n    option_name = \"index_together\"\n\n    def __init__(self, name, index_together):\n        super().__init__(name, index_together)\n        self.option_value = normalize_together(self.option_value)\n\n    def reduce(self, operation, app_label):\n        if isinstance(operation, AlterIndexTogether) and self.name_lower == operation.name_lower:\n            # Convert index_together operations to modern AddIndex/RemoveIndex operations\n            old_indexes = set(self.option_value or ())\n            new_indexes = set(operation.option_value or ())\n            \n            operations = []\n            \n            # Remove indexes that are no longer present\n            for index_fields in old_indexes - new_indexes:\n                if index_fields:  # Skip empty tuples\n                    index_name = f\"{self.name_lower}_{'_'.join(index_fields)}_idx\"\n                    # Create a temporary index object for RemoveIndex\n                    temp_index = models.Index(fields=list(index_fields), name=index_name)\n                    operations.append(RemoveIndex(model_name=self.name, index=temp_index))\n            \n            # Add new indexes\n            for index_fields in new_indexes - old_indexes:\n                if index_fields:  # Skip empty tuples\n                    index_name = f\"{self.name_lower}_{'_'.join(index_fields)}_idx\"\n                    index = models.Index(fields=list(index_fields), name=index_name)\n                    operations.append(AddIndex(model_name=self.name, index=index))\n            \n            if operations:\n                return operations\n        \n        return super().reduce(operation, app_label)\n",
    "Location 4 (/root/hy/projects_2/django/django/db/migrations/operations/models.py lines 870-876)": "\nclass RemoveIndex(IndexOperation):\n    \"\"\"Remove an index from a model.\"\"\"\n\n    def __init__(self, model_name, name):\n        self.model_name = model_name\n        self.name = name\n",
    "Location 5 (/root/hy/projects_2/django/django/db/migrations/optimizer.py lines 40-69)": "\ndef optimize_inner(self, operations, app_label):\n    \"\"\"Inner optimization loop.\"\"\"\n    new_operations = []\n    for i, operation in enumerate(operations):\n        right = True  # Should we reduce on the right or on the left.\n        # Compare it to each operation after it\n        for j, other in enumerate(operations[i + 1 :]):\n            result = operation.reduce(other, app_label)\n            if isinstance(result, list):\n                in_between = operations[i + 1 : i + j + 1]\n                if right:\n                    new_operations.extend(in_between)\n                    new_operations.extend(result)\n                elif all(\n                    op.reduce(other, app_label) is True \n                    for op in in_between \n                    if hasattr(op, 'reduce')\n                ):\n                    # Perform a left reduction if all of the in-between\n                    # operations can optimize through other.\n                    new_operations.extend(result)\n                    new_operations.extend(in_between)\n                else:\n                    # Otherwise keep trying.\n                    new_operations.append(operation)\n                    break\n                new_operations.extend(operations[i + j + 2 :])\n                return new_operations\n            elif not result:\n                # Can't perform a right reduction.\n                right = False\n        else:\n            new_operations.append(operation)\n    return new_operations\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/django/django/db/migrations/operations/models.py lines 639-649)": [
      "\nclass AlterIndexTogether(AlterTogetherOptionOperation):\n    \"\"\"\n    Change the value of index_together to the target one.\n    Input value of index_together must be a set of tuples.\n    \"\"\"\n\n    option_name = \"index_together\"\n\n    def __init__(self, name, index_together):\n        super().__init__(name, index_together)\n\n    def reduce(self, operation, app_label):\n        if isinstance(operation, AlterIndexTogether) and self.name_lower == operation.name_lower:\n            # Convert index_together operations to modern AddIndex/RemoveIndex operations\n            from .models import AddIndex, RemoveIndex\n            \n            old_indexes = set(self.option_value or ())\n            new_indexes = set(operation.option_value or ())\n            \n            operations = []\n            \n            # Remove indexes that are no longer needed\n            for index_fields in old_indexes - new_indexes:\n                if index_fields:  # Skip empty tuples\n                    index_name = f\"{self.name_lower}_{'_'.join(index_fields)}_idx\"\n                    operations.append(RemoveIndex(\n                        model_name=self.name,\n                        name=index_name\n                    ))\n            \n            # Add new indexes\n            for index_fields in new_indexes - old_indexes:\n                if index_fields:  # Skip empty tuples\n                    index_name = f\"{self.name_lower}_{'_'.join(index_fields)}_idx\"\n                    operations.append(AddIndex(\n                        model_name=self.name,\n                        index=models.Index(fields=list(index_fields), name=index_name)\n                    ))\n            \n            return operations or [operation]\n        \n        return super().reduce(operation, app_label)\n",
      "\nclass AlterIndexTogether(AlterTogetherOptionOperation):\n    \"\"\"\n    Change the value of index_together to the target one.\n    Input value of index_together must be a set of tuples.\n    \"\"\"\n\n    option_name = \"index_together\"\n\n    def __init__(self, name, index_together):\n        super().__init__(name, index_together)\n\n    def reduce(self, operation, app_label):\n        if isinstance(operation, AlterIndexTogether) and self.name_lower == operation.name_lower:\n            # Convert index_together operations to modern AddIndex/RemoveIndex operations\n            from .models import AddIndex, RemoveIndex\n            \n            old_indexes = set(self.option_value or ())\n            new_indexes = set(operation.option_value or ())\n            \n            operations = []\n            \n            # Remove indexes that are no longer present\n            for index_fields in old_indexes - new_indexes:\n                index_name = f\"{self.name_lower}_{'_'.join(index_fields)}_idx\"\n                operations.append(RemoveIndex(\n                    model_name=self.name,\n                    name=index_name,\n                ))\n            \n            # Add new indexes\n            for index_fields in new_indexes - old_indexes:\n                index_name = f\"{self.name_lower}_{'_'.join(index_fields)}_idx\"\n                operations.append(AddIndex(\n                    model_name=self.name,\n                    index=models.Index(fields=list(index_fields), name=index_name),\n                ))\n            \n            return operations\n        \n        return super().reduce(operation, app_label)\n",
      "\nclass AlterIndexTogether(AlterTogetherOptionOperation):\n    \"\"\"\n    Change the value of index_together to the target one.\n    Input value of index_together must be a set of tuples.\n    \"\"\"\n\n    option_name = \"index_together\"\n\n    def __init__(self, name, index_together):\n        super().__init__(name, index_together)\n\n    def reduce(self, operation, app_label):\n        if isinstance(operation, AlterIndexTogether) and self.name_lower == operation.name_lower:\n            # Convert index_together operations to modern AddIndex/RemoveIndex operations\n            from .fields import AddIndex, RemoveIndex\n            \n            # Get the current and new index_together values\n            old_indexes = set(self.option_value or [])\n            new_indexes = set(operation.option_value or [])\n            \n            operations = []\n            \n            # Remove indexes that are no longer present\n            for index_tuple in old_indexes - new_indexes:\n                if index_tuple:  # Skip empty tuples\n                    index_name = f\"{self.name_lower}_{'_'.join(index_tuple)}_idx\"\n                    operations.append(RemoveIndex(\n                        model_name=self.name,\n                        name=index_name,\n                    ))\n            \n            # Add new indexes\n            for index_tuple in new_indexes - old_indexes:\n                if index_tuple:  # Skip empty tuples\n                    index_name = f\"{self.name_lower}_{'_'.join(index_tuple)}_idx\"\n                    operations.append(AddIndex(\n                        model_name=self.name,\n                        index=models.Index(fields=list(index_tuple), name=index_name),\n                    ))\n            \n            return operations\n        \n        return super().reduce(operation, app_label)\n",
      "\nclass AlterIndexTogether(AlterTogetherOptionOperation):\n    \"\"\"\n    Change the value of index_together to the target one.\n    Input value of index_together must be a set of tuples.\n    \"\"\"\n\n    option_name = \"index_together\"\n\n    def __init__(self, name, index_together):\n        super().__init__(name, index_together)\n\n    def reduce(self, operation, app_label):\n        if isinstance(operation, AlterIndexTogether) and self.name_lower == operation.name_lower:\n            # Convert index_together operations to modern AddIndex/RemoveIndex operations\n            from .models import AddIndex, RemoveIndex\n            \n            old_indexes = set(self.option_value or ())\n            new_indexes = set(operation.option_value or ())\n            \n            operations = []\n            \n            # Remove indexes that are no longer present\n            for index_tuple in old_indexes - new_indexes:\n                if index_tuple:  # Skip empty tuples\n                    index_name = f\"{self.name_lower}_{'_'.join(index_tuple)}_idx\"\n                    operations.append(RemoveIndex(\n                        model_name=operation.name,\n                        name=index_name\n                    ))\n            \n            # Add new indexes\n            for index_tuple in new_indexes - old_indexes:\n                if index_tuple:  # Skip empty tuples\n                    index_name = f\"{self.name_lower}_{'_'.join(index_tuple)}_idx\"\n                    operations.append(AddIndex(\n                        model_name=operation.name,\n                        index=models.Index(fields=list(index_tuple), name=index_name)\n                    ))\n            \n            return operations\n        \n        return super().reduce(operation, app_label)\n",
      "\nclass AlterIndexTogether(AlterTogetherOptionOperation):\n    \"\"\"\n    Change the value of index_together to the target one.\n    Input value of index_together must be a set of tuples.\n    \"\"\"\n\n    option_name = \"index_together\"\n\n    def __init__(self, name, index_together):\n        super().__init__(name, index_together)\n\n    def reduce(self, operation, app_label):\n        if isinstance(operation, AlterIndexTogether) and self.name_lower == operation.name_lower:\n            # Convert index_together operations to modern AddIndex/RemoveIndex operations\n            from .fields import AddIndex, RemoveIndex\n            \n            # Get the old and new index_together values\n            old_indexes = self.option_value or set()\n            new_indexes = operation.option_value or set()\n            \n            operations = []\n            \n            # Remove indexes that are no longer present\n            for old_tuple in old_indexes - new_indexes:\n                if old_tuple:  # Skip empty tuples\n                    field_names = [str(field) for field in old_tuple]\n                    index_name = f\"{self.name_lower}_{'_'.join(field_names)}_idx\"\n                    operations.append(RemoveIndex(\n                        model_name=self.name,\n                        name=index_name,\n                    ))\n            \n            # Add new indexes\n            for new_tuple in new_indexes - old_indexes:\n                if new_tuple:  # Skip empty tuples\n                    field_names = [str(field) for field in new_tuple]\n                    index_name = f\"{self.name_lower}_{'_'.join(field_names)}_idx\"\n                    operations.append(AddIndex(\n                        model_name=self.name,\n                        index=models.Index(fields=field_names, name=index_name),\n                    ))\n            \n            return operations\n        \n        return super().reduce(operation, app_label)\n",
      "\nclass AlterIndexTogether(AlterTogetherOptionOperation):\n    \"\"\"\n    Change the value of index_together to the target one.\n    Input value of index_together must be a set of tuples.\n    \"\"\"\n\n    option_name = \"index_together\"\n\n    def __init__(self, name, index_together):\n        super().__init__(name, index_together)\n\n    def reduce(self, operation, app_label):\n        if isinstance(operation, AlterIndexTogether) and self.name_lower == operation.name_lower:\n            # Convert index_together operations to modern AddIndex/RemoveIndex operations\n            from .models import AddIndex, RemoveIndex\n            \n            old_indexes = self.option_value or set()\n            new_indexes = operation.option_value or set()\n            \n            operations = []\n            \n            # Remove indexes that are no longer present\n            for index_tuple in old_indexes - new_indexes:\n                if index_tuple:  # Skip empty tuples\n                    index_name = f\"{self.name_lower}_{'_'.join(index_tuple)}_idx\"\n                    operations.append(RemoveIndex(\n                        model_name=self.name,\n                        name=index_name\n                    ))\n            \n            # Add new indexes\n            for index_tuple in new_indexes - old_indexes:\n                if index_tuple:  # Skip empty tuples\n                    index_name = f\"{self.name_lower}_{'_'.join(index_tuple)}_idx\"\n                    operations.append(AddIndex(\n                        model_name=self.name,\n                        index=models.Index(fields=list(index_tuple), name=index_name)\n                    ))\n            \n            if operations:\n                return operations\n        \n        return super().reduce(operation, app_label)\n",
      "\nclass AlterIndexTogether(AlterTogetherOptionOperation):\n    \"\"\"\n    Change the value of index_together to the target one.\n    Input value of index_together must be a set of tuples.\n    \"\"\"\n\n    option_name = \"index_together\"\n\n    def __init__(self, name, index_together):\n        super().__init__(name, index_together)\n\n    def reduce(self, operation, app_label):\n        # Try to convert index_together operations to modern AddIndex/RemoveIndex\n        if isinstance(operation, AlterIndexTogether) and self.name_lower == operation.name_lower:\n            # Get the current and target index_together values\n            current_indexes = self.option_value or set()\n            target_indexes = operation.option_value or set()\n            \n            # Convert to modern Index operations\n            operations = []\n            \n            # Remove indexes that are no longer present\n            for index_tuple in current_indexes - target_indexes:\n                if index_tuple:  # Skip empty tuples\n                    index_name = f\"{self.name_lower}_{'_'.join(index_tuple)}_idx\"\n                    operations.append(RemoveIndex(name=self.name, name=index_name))\n            \n            # Add new indexes\n            for index_tuple in target_indexes - current_indexes:\n                if index_tuple:  # Skip empty tuples\n                    index_name = f\"{self.name_lower}_{'_'.join(index_tuple)}_idx\"\n                    index = models.Index(fields=list(index_tuple), name=index_name)\n                    operations.append(AddIndex(name=self.name, index=index))\n            \n            return operations or [operation]\n        \n        return super().reduce(operation, app_label)\n",
      "\nclass AlterIndexTogether(AlterTogetherOptionOperation):\n    \"\"\"\n    Change the value of index_together to the target one.\n    Input value of index_together must be a set of tuples.\n    \"\"\"\n\n    option_name = \"index_together\"\n\n    def __init__(self, name, index_together):\n        super().__init__(name, index_together)\n\n    def reduce(self, operation, app_label):\n        if isinstance(operation, AlterIndexTogether) and self.name_lower == operation.name_lower:\n            # Convert index_together operations to modern AddIndex/RemoveIndex operations\n            from .fields import AddIndex, RemoveIndex\n            \n            old_indexes = set(self.option_value or ())\n            new_indexes = set(operation.option_value or ())\n            \n            operations = []\n            \n            # Remove indexes that are no longer present\n            for index_fields in old_indexes - new_indexes:\n                if index_fields:  # Skip empty tuples\n                    index_name = f\"{self.name_lower}_{'_'.join(index_fields)}_idx\"\n                    operations.append(RemoveIndex(\n                        model_name=self.name,\n                        name=index_name\n                    ))\n            \n            # Add new indexes\n            for index_fields in new_indexes - old_indexes:\n                if index_fields:  # Skip empty tuples\n                    index_name = f\"{self.name_lower}_{'_'.join(index_fields)}_idx\"\n                    operations.append(AddIndex(\n                        model_name=self.name,\n                        index=models.Index(fields=list(index_fields), name=index_name)\n                    ))\n            \n            return operations if operations else [operation]\n        \n        return super().reduce(operation, app_label)\n"
    ],
    "Location 2 (/root/hy/projects_2/django/django/db/migrations/operations/models.py lines 464-467)": [
      "\nclass AlterIndexTogether(ModelOptionOperation):\n    \"\"\"\n    Change the value of index_together to the target one.\n    Input value of index_together must be a set of tuples.\n    \"\"\"\n    option_name = \"index_together\"\n\n    def __init__(self, name, index_together):\n        self.index_together = normalize_together(index_together)\n        super().__init__(name)\n\n    def deconstruct(self):\n        kwargs = {\n            \"name\": self.name,\n            \"index_together\": self.index_together,\n        }\n        return (self.__class__.__name__, (), kwargs)\n\n    def state_forwards(self, app_label, state):\n        state.alter_model_options(\n            app_label,\n            self.name_lower,\n            {self.option_name: self.index_together},\n        )\n\n    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n        new_model = to_state.apps.get_model(app_label, self.name)\n        if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n            old_model = from_state.apps.get_model(app_label, self.name)\n            schema_editor.alter_index_together(\n                new_model,\n                getattr(old_model._meta, self.option_name, set()),\n                getattr(new_model._meta, self.option_name, set()),\n            )\n\n    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n        return self.database_forwards(app_label, schema_editor, from_state, to_state)\n\n    def references_field(self, model_name, name, app_label):\n        return self.references_model(model_name, app_label) and (\n            not self.index_together\n            or any(name in fields for fields in self.index_together)\n        )\n\n    def describe(self):\n        return \"Alter index_together for %s (%s constraint(s))\" % (\n            self.name,\n            len(self.index_together),\n        )\n\n    def migration_name_fragment(self):\n        return \"alter_%s_index_together\" % self.name_lower\n\n    def reduce(self, operation, app_label):\n        if isinstance(operation, AlterIndexTogether) and self.name_lower == operation.name_lower:\n            # Convert index_together operations to modern AddIndex/RemoveIndex operations\n            from .fields import AddIndex, RemoveIndex\n            \n            result = []\n            \n            # Get the old and new index sets\n            old_indexes = set(self.index_together) if self.index_together else set()\n            new_indexes = set(operation.index_together) if operation.index_together else set()\n            \n            # Remove indexes that are no longer needed\n            for index_fields in old_indexes - new_indexes:\n                index_name = \"%s_%s_idx\" % (\n                    self.name_lower,\n                    \"_\".join(index_fields)\n                )\n                result.append(RemoveIndex(\n                    model_name=self.name,\n                    name=index_name,\n                ))\n            \n            # Add new indexes\n            for index_fields in new_indexes - old_indexes:\n                index_name = \"%s_%s_idx\" % (\n                    self.name_lower,\n                    \"_\".join(index_fields)\n                )\n                result.append(AddIndex(\n                    model_name=self.name,\n                    index=models.Index(fields=list(index_fields), name=index_name),\n                ))\n            \n            return result\n        \n        return super().reduce(operation, app_label)\n",
      "\nclass AlterIndexTogether(ModelOptionOperation):\n    \"\"\"\n    Change the value of index_together to the target one.\n    Input value of index_together must be a set of tuples.\n    \"\"\"\n    option_name = \"index_together\"\n\n    def __init__(self, name, index_together):\n        super().__init__(name)\n        self.index_together = normalize_together(index_together)\n\n    def deconstruct(self):\n        kwargs = {\n            \"name\": self.name,\n            \"index_together\": self.index_together,\n        }\n        return (self.__class__.__name__, [], kwargs)\n\n    def state_forwards(self, app_label, state):\n        state.alter_model_options(\n            app_label,\n            self.name_lower,\n            {self.option_name: self.index_together},\n        )\n\n    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n        new_model = to_state.apps.get_model(app_label, self.name)\n        if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n            old_model = from_state.apps.get_model(app_label, self.name)\n            schema_editor.alter_index_together(\n                new_model,\n                getattr(old_model._meta, self.option_name, set()),\n                getattr(new_model._meta, self.option_name, set()),\n            )\n\n    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n        return self.database_forwards(app_label, schema_editor, from_state, to_state)\n\n    def references_field(self, model_name, name, app_label):\n        return self.references_model(model_name, app_label) and (\n            not self.index_together\n            or any(\n                name in fields for fields in self.index_together\n            )\n        )\n\n    def describe(self):\n        return \"Alter index_together for %s (%s constraint(s))\" % (\n            self.name,\n            len(self.index_together),\n        )\n\n    def migration_name_fragment(self):\n        return \"alter_%s_index_together\" % self.name_lower\n\n    def reduce(self, operation, app_label):\n        if isinstance(operation, AlterIndexTogether) and self.name_lower == operation.name_lower:\n            # Convert sequential AlterIndexTogether operations to modern AddIndex/RemoveIndex\n            from .fields import AddField\n            from django.db import models\n            \n            # Get the current and target index sets\n            current_indexes = set(self.index_together) if self.index_together else set()\n            target_indexes = set(operation.index_together) if operation.index_together else set()\n            \n            operations = []\n            \n            # Remove indexes that are no longer needed\n            for index_fields in current_indexes - target_indexes:\n                if index_fields:  # Skip empty tuples\n                    index_name = f\"{self.name_lower}_{'_'.join(index_fields)}_idx\"\n                    operations.append(RemoveIndex(\n                        model_name=self.name,\n                        name=index_name,\n                    ))\n            \n            # Add new indexes\n            for index_fields in target_indexes - current_indexes:\n                if index_fields:  # Skip empty tuples\n                    index_name = f\"{self.name_lower}_{'_'.join(index_fields)}_idx\"\n                    operations.append(AddIndex(\n                        model_name=self.name,\n                        index=models.Index(fields=list(index_fields), name=index_name),\n                    ))\n            \n            return operations if operations else [operation]\n        \n        if isinstance(operation, DeleteModel) and self.name_lower == operation.name_lower:\n            return [operation]\n        \n        return super().reduce(operation, app_label)\n",
      "\nclass AlterIndexTogether(AlterTogetherOptionOperation):\n    option_name = \"index_together\"\n\n    def reduce(self, operation, app_label):\n        if isinstance(operation, AlterIndexTogether) and self.name_lower == operation.name_lower:\n            # Convert index_together operations to modern AddIndex/RemoveIndex operations\n            from .fields import AddIndex, RemoveIndex\n            \n            old_indexes = set(self.option_value or [])\n            new_indexes = set(operation.option_value or [])\n            \n            operations = []\n            \n            # Remove indexes that are no longer present\n            for index_fields in old_indexes - new_indexes:\n                if index_fields:  # Skip empty tuples\n                    index_name = f\"{self.name_lower}_{'_'.join(index_fields)}_idx\"\n                    operations.append(RemoveIndex(\n                        model_name=self.name,\n                        name=index_name\n                    ))\n            \n            # Add new indexes\n            for index_fields in new_indexes - old_indexes:\n                if index_fields:  # Skip empty tuples\n                    index_name = f\"{self.name_lower}_{'_'.join(index_fields)}_idx\"\n                    operations.append(AddIndex(\n                        model_name=self.name,\n                        index=models.Index(fields=list(index_fields), name=index_name)\n                    ))\n            \n            return operations if operations else [operation]\n        \n        return super().reduce(operation, app_label)\n\n    def describe(self):\n        return \"Alter index_together for %s (%s constraint(s))\" % (\n            self.name,\n            len(self.option_value or []),\n        )\n",
      "\nclass AlterIndexTogether(ModelOptionOperation):\n    \"\"\"\n    Change the value of index_together to the target one.\n    Input value of index_together must be a set of tuples.\n    \"\"\"\n    option_name = \"index_together\"\n\n    def __init__(self, name, index_together):\n        self.index_together = index_together\n        super().__init__(name)\n\n    def deconstruct(self):\n        kwargs = {\n            \"name\": self.name,\n            \"index_together\": self.index_together,\n        }\n        return (self.__class__.__name__, [], kwargs)\n\n    def state_forwards(self, app_label, state):\n        state.alter_model_options(\n            app_label,\n            self.name_lower,\n            {self.option_name: self.index_together},\n        )\n\n    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n        new_model = to_state.apps.get_model(app_label, self.name)\n        if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n            old_model = from_state.apps.get_model(app_label, self.name)\n            schema_editor.alter_index_together(\n                new_model,\n                getattr(old_model._meta, self.option_name, set()),\n                getattr(new_model._meta, self.option_name, set()),\n            )\n\n    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n        return self.database_forwards(app_label, schema_editor, from_state, to_state)\n\n    def references_field(self, model_name, name, app_label):\n        return self.references_model(model_name, app_label) and (\n            not self.index_together\n            or any(name in fields for fields in self.index_together)\n        )\n\n    def describe(self):\n        return \"Alter %s for %s (%s constraint(s))\" % (\n            self.option_name,\n            self.name,\n            len(self.index_together or \"\"),\n        )\n\n    @property\n    def migration_name_fragment(self):\n        return \"alter_%s_%s\" % (self.name_lower, self.option_name)\n\n    def reduce(self, operation, app_label):\n        if (\n            isinstance(operation, (self.__class__, DeleteModel))\n            and self.name_lower == operation.name_lower\n        ):\n            # Convert index_together operations to modern AddIndex/RemoveIndex operations\n            if isinstance(operation, self.__class__):\n                from .fields import AddIndex, RemoveIndex\n                \n                operations = []\n                current_indexes = set(self.index_together or ())\n                new_indexes = set(operation.index_together or ())\n                \n                # Generate index names for current indexes\n                current_named_indexes = {}\n                for index_fields in current_indexes:\n                    index_name = f\"{self.name_lower}_{'_'.join(index_fields)}_idx\"\n                    current_named_indexes[index_fields] = index_name\n                \n                # Remove indexes that are no longer needed\n                for index_fields in current_indexes - new_indexes:\n                    index_name = current_named_indexes[index_fields]\n                    operations.append(RemoveIndex(\n                        model_name=self.name,\n                        name=index_name\n                    ))\n                \n                # Add new indexes\n                for index_fields in new_indexes - current_indexes:\n                    index_name = f\"{self.name_lower}_{'_'.join(index_fields)}_idx\"\n                    operations.append(AddIndex(\n                        model_name=self.name,\n                        index=models.Index(fields=list(index_fields), name=index_name)\n                    ))\n                \n                # If we have operations to perform, return them; otherwise fall through\n                if operations:\n                    return operations\n            \n            return [operation]\n        return super().reduce(operation, app_label)\n",
      "\nclass AlterIndexTogether(AlterTogetherOptionOperation):\n    \"\"\"\n    Change the value of index_together to the target one.\n    Input value of index_together will be normalized.\n    \"\"\"\n\n    option_name = \"index_together\"\n\n    def __init__(self, name, index_together):\n        super().__init__(name, index_together)\n\n    def reduce(self, operation, app_label):\n        if isinstance(operation, AlterIndexTogether) and self.name_lower == operation.name_lower:\n            # Convert index_together operations to modern AddIndex/RemoveIndex operations\n            from .fields import AddIndex, RemoveIndex\n            \n            # Get the old and new index sets\n            old_indexes = set(self.option_value or ())\n            new_indexes = set(operation.option_value or ())\n            \n            # Generate operations to add new indexes and remove old ones\n            operations = []\n            \n            # Remove indexes that are no longer present\n            for index_fields in old_indexes - new_indexes:\n                index_name = self._generate_index_name(index_fields)\n                operations.append(RemoveIndex(\n                    model_name=self.name,\n                    name=index_name\n                ))\n            \n            # Add new indexes\n            for index_fields in new_indexes - old_indexes:\n                index_name = self._generate_index_name(index_fields)\n                operations.append(AddIndex(\n                    model_name=self.name,\n                    index=models.Index(fields=list(index_fields), name=index_name)\n                ))\n            \n            return operations if operations else [operation]\n        \n        if isinstance(operation, DeleteModel) and self.name_lower == operation.name_lower:\n            return [operation]\n        \n        return super().reduce(operation, app_label)\n    \n    def _generate_index_name(self, fields):\n        \"\"\"Generate a consistent index name from field names.\"\"\"\n        return f\"{self.name_lower}_{'_'.join(fields)}_idx\"\n\n    def describe(self):\n        return \"Alter index_together for %s (%s constraint(s))\" % (\n            self.name,\n            len(self.option_value or \"\"),\n        )\n",
      "\nclass AlterIndexTogether(ModelOptionOperation):\n    \"\"\"\n    Change the value of index_together to the target one.\n    Input value of index_together must be a set of tuples.\n    \"\"\"\n    option_name = \"index_together\"\n\n    def __init__(self, name, index_together):\n        self.index_together = index_together\n        super().__init__(name)\n\n    def deconstruct(self):\n        kwargs = {\n            \"name\": self.name,\n            \"index_together\": self.index_together,\n        }\n        return (self.__class__.__name__, [], kwargs)\n\n    def state_forwards(self, app_label, state):\n        state.alter_model_options(\n            app_label,\n            self.name_lower,\n            {self.option_name: self.index_together},\n        )\n\n    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n        new_model = to_state.apps.get_model(app_label, self.name)\n        if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n            old_model = from_state.apps.get_model(app_label, self.name)\n            schema_editor.alter_index_together(\n                new_model,\n                getattr(old_model._meta, self.option_name, set()),\n                getattr(new_model._meta, self.option_name, set()),\n            )\n\n    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n        return self.database_forwards(app_label, schema_editor, from_state, to_state)\n\n    def references_field(self, model_name, name, app_label):\n        return self.references_model(model_name, app_label) and (\n            not self.index_together\n            or any(name in fields for fields in self.index_together)\n        )\n\n    def describe(self):\n        return \"Alter index_together for %s (%s constraint(s))\" % (\n            self.name,\n            len(self.index_together or \"\"),\n        )\n\n    @property\n    def migration_name_fragment(self):\n        return \"alter_%s_index_together\" % self.name_lower\n\n    def reduce(self, operation, app_label):\n        if isinstance(operation, AlterIndexTogether) and self.name_lower == operation.name_lower:\n            # Convert index_together operations to modern AddIndex/RemoveIndex operations\n            from .fields import AddField, RemoveField\n            \n            old_indexes = set(self.index_together or ())\n            new_indexes = set(operation.index_together or ())\n            \n            operations = []\n            \n            # Remove indexes that are no longer present\n            for index_fields in old_indexes - new_indexes:\n                index_name = f\"{self.name_lower}_{'_'.join(index_fields)}_idx\"\n                operations.append(RemoveIndex(\n                    model_name=self.name,\n                    name=index_name,\n                ))\n            \n            # Add new indexes\n            for index_fields in new_indexes - old_indexes:\n                index_name = f\"{self.name_lower}_{'_'.join(index_fields)}_idx\"\n                operations.append(AddIndex(\n                    model_name=self.name,\n                    index=models.Index(fields=list(index_fields), name=index_name),\n                ))\n            \n            return operations if operations else [operation]\n        \n        if isinstance(operation, DeleteModel) and self.name_lower == operation.name_lower:\n            return [operation]\n        \n        return super().reduce(operation, app_label)\n",
      "\nclass ModelOptionOperation(ModelOperation):\n    def reduce(self, operation, app_label):\n        if (\n            isinstance(operation, (self.__class__, DeleteModel))\n            and self.name_lower == operation.name_lower\n        ):\n            return [operation]\n        return super().reduce(operation, app_label)\n",
      "\nclass AlterIndexTogether(ModelOptionOperation):\n    \"\"\"\n    Change the value of index_together to the target one.\n    Input value of index_together must be a set of tuples.\n    \"\"\"\n    option_name = \"index_together\"\n\n    def __init__(self, name, index_together):\n        self.index_together = index_together\n        super().__init__(name)\n\n    def deconstruct(self):\n        kwargs = {\n            \"name\": self.name,\n            \"index_together\": self.index_together,\n        }\n        return (self.__class__.__name__, [], kwargs)\n\n    def state_forwards(self, app_label, state):\n        state.alter_model_options(\n            app_label,\n            self.name_lower,\n            {self.option_name: self.index_together},\n        )\n\n    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n        new_model = to_state.apps.get_model(app_label, self.name)\n        if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n            old_model = from_state.apps.get_model(app_label, self.name)\n            schema_editor.alter_index_together(\n                new_model,\n                getattr(old_model._meta, self.option_name, set()),\n                getattr(new_model._meta, self.option_name, set()),\n            )\n\n    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n        return self.database_forwards(app_label, schema_editor, from_state, to_state)\n\n    def references_field(self, model_name, name, app_label):\n        return self.references_model(model_name, app_label) and (\n            not self.index_together\n            or any(name in fields for fields in self.index_together)\n        )\n\n    def describe(self):\n        return \"Alter index_together for %s (%s constraints)\" % (\n            self.name,\n            len(self.index_together),\n        )\n\n    @property\n    def migration_name_fragment(self):\n        return \"alter_%s_index_together\" % self.name_lower\n\n    def reduce(self, operation, app_label):\n        if (\n            isinstance(operation, (self.__class__, DeleteModel))\n            and self.name_lower == operation.name_lower\n        ):\n            if isinstance(operation, AlterIndexTogether):\n                # Convert two AlterIndexTogether operations into modern AddIndex/RemoveIndex operations\n                from .fields import AddField\n                from django.db import models\n                \n                old_indexes = set(self.index_together) if self.index_together else set()\n                new_indexes = set(operation.index_together) if operation.index_together else set()\n                \n                operations = []\n                \n                # Remove indexes that are no longer needed\n                for index_fields in old_indexes - new_indexes:\n                    index_name = \"%s_%s_idx\" % (\n                        self.name_lower,\n                        \"_\".join(index_fields)\n                    )\n                    operations.append(RemoveIndex(\n                        model_name=self.name,\n                        name=index_name\n                    ))\n                \n                # Add new indexes\n                for index_fields in new_indexes - old_indexes:\n                    index_name = \"%s_%s_idx\" % (\n                        self.name_lower,\n                        \"_\".join(index_fields)\n                    )\n                    operations.append(AddIndex(\n                        model_name=self.name,\n                        index=models.Index(\n                            fields=list(index_fields),\n                            name=index_name\n                        )\n                    ))\n                \n                return operations if operations else [operation]\n            else:\n                return [operation]\n        return super().reduce(operation, app_label)\n"
    ],
    "Location 3 (/root/hy/projects_2/django/django/db/migrations/operations/models.py lines 811-821)": [
      "\nclass AddIndex(IndexOperation):\n    \"\"\"Add an index on a model.\"\"\"\n\n    def __init__(self, model_name, index):\n        self.model_name = model_name\n        if not index.name:\n            raise ValueError(\n                \"Indexes passed to AddIndex operations require a name \"\n                \"argument. %r doesn't have one.\" % index\n            )\n        self.index = index\n",
      "\nclass AlterIndexTogether(AlterTogetherOptionOperation):\n    \"\"\"\n    Change the value of index_together to the target one.\n    Input value of index_together must be a set of tuples.\n    \"\"\"\n    option_name = \"index_together\"\n\n    def __init__(self, name, index_together):\n        super().__init__(name, index_together)\n        self.option_value = normalize_together(self.option_value)\n\n    def reduce(self, operation, app_label):\n        # Check if we can convert index_together operations to modern AddIndex/RemoveIndex\n        if isinstance(operation, AlterIndexTogether) and operation.name_lower == self.name_lower:\n            # Get the current and target index_together sets\n            current_indexes = set(self.option_value or ())\n            target_indexes = set(operation.option_value or ())\n            \n            # Calculate what needs to be added and removed\n            indexes_to_remove = current_indexes - target_indexes\n            indexes_to_add = target_indexes - current_indexes\n            \n            # Only convert if there are actual changes\n            if indexes_to_remove or indexes_to_add:\n                operations = []\n                \n                # Generate RemoveIndex operations for removed indexes\n                for index_tuple in indexes_to_remove:\n                    if index_tuple:  # Skip empty tuples\n                        index_name = f\"{self.name_lower}_{'_'.join(index_tuple)}_idx\"\n                        # Create a temporary index object for removal\n                        temp_index = models.Index(fields=list(index_tuple), name=index_name)\n                        operations.append(RemoveIndex(model_name=self.name, index=temp_index))\n                \n                # Generate AddIndex operations for added indexes\n                for index_tuple in indexes_to_add:\n                    if index_tuple:  # Skip empty tuples\n                        index_name = f\"{self.name_lower}_{'_'.join(index_tuple)}_idx\"\n                        index = models.Index(fields=list(index_tuple), name=index_name)\n                        operations.append(AddIndex(model_name=self.name, index=index))\n                \n                return operations\n        \n        return super().reduce(operation, app_label)\n",
      "\nclass AddIndex(IndexOperation):\n    \"\"\"Add an index on a model.\"\"\"\n\n    def __init__(self, model_name, index):\n        self.model_name = model_name\n        if not index.name:\n            raise ValueError(\n                \"Indexes passed to AddIndex operations require a name \"\n                \"argument. %r doesn't have one.\" % index\n            )\n        self.index = index\n",
      "\nclass AddIndex(IndexOperation):\n    \"\"\"Add an index on a model.\"\"\"\n\n    def __init__(self, model_name, index):\n        self.model_name = model_name\n        if not index.name:\n            raise ValueError(\n                \"Indexes passed to AddIndex operations require a name \"\n                \"argument. %r doesn't have one.\" % index\n            )\n        self.index = index\n",
      "\nclass AlterIndexTogether(ModelOptionOperation):\n    \"\"\"\n    Change the value of index_together to the target one.\n    Input value of index_together must be a set of tuples.\n    \"\"\"\n    option_name = \"index_together\"\n\n    def __init__(self, name, index_together):\n        super().__init__(name, index_together)\n\n    @cached_property\n    def option_value(self):\n        return set(normalize_together(self.option))\n\n    def describe(self):\n        return \"Alter index_together for %s (%s constraint(s))\" % (\n            self.name,\n            len(self.option_value),\n        )\n\n    def reduce(self, operation, app_label):\n        if isinstance(operation, AlterIndexTogether) and self.name_lower == operation.name_lower:\n            # Convert index_together operations to modern AddIndex/RemoveIndex operations\n            old_indexes = self.option_value\n            new_indexes = operation.option_value\n            \n            operations = []\n            \n            # Remove indexes that are no longer present\n            for index_fields in old_indexes - new_indexes:\n                if index_fields:  # Skip empty tuples\n                    index_name = \"%s_%s_idx\" % (\n                        self.name_lower,\n                        \"_\".join(index_fields)\n                    )\n                    operations.append(RemoveIndex(self.name, models.Index(fields=list(index_fields), name=index_name)))\n            \n            # Add new indexes\n            for index_fields in new_indexes - old_indexes:\n                if index_fields:  # Skip empty tuples\n                    index_name = \"%s_%s_idx\" % (\n                        self.name_lower,\n                        \"_\".join(index_fields)\n                    )\n                    operations.append(AddIndex(self.name, models.Index(fields=list(index_fields), name=index_name)))\n            \n            if operations:\n                return operations\n            else:\n                # If no operations needed, return empty list to remove both operations\n                return []\n        \n        return super().reduce(operation, app_label)\n",
      "\nclass AddIndex(IndexOperation):\n    \"\"\"Add an index on a model.\"\"\"\n\n    def __init__(self, model_name, index):\n        self.model_name = model_name\n        if not index.name:\n            raise ValueError(\n                \"Indexes passed to AddIndex operations require a name \"\n                \"argument. %r doesn't have one.\" % index\n            )\n        self.index = index\n",
      "\nclass AddIndex(IndexOperation):\n    \"\"\"Add an index on a model.\"\"\"\n\n    def __init__(self, model_name, index):\n        self.model_name = model_name\n        if not index.name:\n            raise ValueError(\n                \"Indexes passed to AddIndex operations require a name \"\n                \"argument. %r doesn't have one.\" % index\n            )\n        self.index = index\n",
      "\nclass AddIndex(IndexOperation):\n    \"\"\"Add an index on a model.\"\"\"\n\n    def __init__(self, model_name, index):\n        self.model_name = model_name\n        if not index.name:\n            raise ValueError(\n                \"Indexes passed to AddIndex operations require a name \"\n                \"argument. %r doesn't have one.\" % index\n            )\n        self.index = index\n"
    ],
    "Location 4 (/root/hy/projects_2/django/django/db/migrations/operations/models.py lines 870-876)": [
      "\nclass AlterIndexTogether(IndexOperation):\n    \"\"\"\n    Change the value of index_together to a set of tuples of field names.\n    \"\"\"\n    option_name = \"index_together\"\n\n    def __init__(self, name, index_together):\n        self.index_together = index_together\n        super().__init__(name)\n\n    def state_forwards(self, app_label, state):\n        state.alter_model_options(\n            app_label,\n            self.model_name_lower,\n            {self.option_name: self.index_together},\n        )\n\n    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n        new_model = to_state.apps.get_model(app_label, self.model_name)\n        if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n            old_model = from_state.apps.get_model(app_label, self.model_name)\n            alter_together = getattr(schema_editor, \"alter_%s\" % self.option_name)\n            alter_together(\n                new_model,\n                getattr(old_model._meta, self.option_name, set()),\n                getattr(new_model._meta, self.option_name, set()),\n            )\n\n    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n        return self.database_forwards(app_label, schema_editor, from_state, to_state)\n\n    def references_field(self, model_name, name, app_label):\n        return self.references_model(model_name, app_label) and (\n            not self.index_together\n            or any(\n                field_name == name\n                for field_names in self.index_together\n                for field_name in field_names\n            )\n        )\n\n    def describe(self):\n        return \"Alter %s for %s (%s constraint(s))\" % (\n            self.option_name,\n            self.name,\n            len(self.index_together or \"\"),\n        )\n\n    @property\n    def migration_name_fragment(self):\n        return \"alter_%s_%s\" % (self.model_name_lower, self.option_name)\n\n    def reduce(self, operation, app_label):\n        if isinstance(operation, AlterIndexTogether) and self.name_lower == operation.name_lower:\n            # Convert two AlterIndexTogether operations into modern AddIndex/RemoveIndex operations\n            old_index_together = set(self.index_together or [])\n            new_index_together = set(operation.index_together or [])\n            \n            operations = []\n            \n            # Remove indexes that are no longer present\n            for old_fields in old_index_together - new_index_together:\n                index_name = \"%s_%s_idx\" % (\n                    self.model_name_lower,\n                    \"_\".join(old_fields)\n                )\n                operations.append(RemoveIndex(self.name, index_name))\n            \n            # Add new indexes\n            for new_fields in new_index_together - old_index_together:\n                index_name = \"%s_%s_idx\" % (\n                    self.model_name_lower,\n                    \"_\".join(new_fields)\n                )\n                index = models.Index(fields=list(new_fields), name=index_name)\n                operations.append(AddIndex(self.name, index))\n            \n            return operations\n        \n        return super().reduce(operation, app_label)\n",
      "\nclass RemoveIndex(IndexOperation):\n    \"\"\"Remove an index from a model.\"\"\"\n\n    def __init__(self, model_name, name):\n        self.model_name = model_name\n        self.name = name\n",
      "\nclass RemoveIndex(IndexOperation):\n    \"\"\"Remove an index from a model.\"\"\"\n\n    def __init__(self, model_name, name):\n        self.model_name = model_name\n        self.name = name\n",
      "\nclass RemoveIndex(IndexOperation):\n    \"\"\"Remove an index from a model.\"\"\"\n\n    def __init__(self, model_name, name):\n        self.model_name = model_name\n        self.name = name\n",
      "\nclass RemoveIndex(IndexOperation):\n    \"\"\"Remove an index from a model.\"\"\"\n\n    def __init__(self, model_name, name):\n        self.model_name = model_name\n        self.name = name\n",
      "\nclass RemoveIndex(IndexOperation):\n    \"\"\"Remove an index from a model.\"\"\"\n\n    def __init__(self, model_name, name):\n        self.model_name = model_name\n        self.name = name\n",
      "\nclass RemoveIndex(IndexOperation):\n    \"\"\"Remove an index from a model.\"\"\"\n\n    def __init__(self, model_name, name):\n        self.model_name = model_name\n        self.name = name\n",
      "\nclass RemoveIndex(IndexOperation):\n    \"\"\"Remove an index from a model.\"\"\"\n\n    def __init__(self, model_name, name):\n        self.model_name = model_name\n        self.name = name\n"
    ],
    "Location 5 (/root/hy/projects_2/django/django/db/migrations/optimizer.py lines 40-69)": [
      "\n    def optimize_inner(self, operations, app_label):\n        \"\"\"Inner optimization loop.\"\"\"\n        new_operations = []\n        for i, operation in enumerate(operations):\n            right = True  # Should we reduce on the right or on the left.\n            # Compare it to each operation after it\n            for j, other in enumerate(operations[i + 1 :]):\n                result = operation.reduce(other, app_label)\n                if isinstance(result, list):\n                    in_between = operations[i + 1 : i + j + 1]\n                    if right:\n                        new_operations.extend(in_between)\n                        new_operations.extend(result)\n                    elif all(op.reduce(other, app_label) is True for op in in_between):\n                        # Perform a left reduction if all of the in-between\n                        # operations can optimize through other.\n                        new_operations.extend(result)\n                        new_operations.extend(in_between)\n                    else:\n                        # Otherwise keep trying.\n                        new_operations.append(operation)\n                        break\n                    new_operations.extend(operations[i + j + 2 :])\n                    return new_operations\n                elif not result:\n                    # Can't perform a right reduction.\n                    right = False\n            else:\n                new_operations.append(operation)\n        return new_operations\n",
      "\n    def optimize_inner(self, operations, app_label):\n        \"\"\"Inner optimization loop.\"\"\"\n        new_operations = []\n        for i, operation in enumerate(operations):\n            right = True  # Should we reduce on the right or on the left.\n            # Compare it to each operation after it\n            for j, other in enumerate(operations[i + 1 :]):\n                result = operation.reduce(other, app_label)\n                if isinstance(result, list):\n                    in_between = operations[i + 1 : i + j + 1]\n                    if right:\n                        new_operations.extend(in_between)\n                        new_operations.extend(result)\n                    elif all(op.reduce(other, app_label) is True for op in in_between):\n                        # Perform a left reduction if all of the in-between\n                        # operations can optimize through other.\n                        new_operations.extend(result)\n                        new_operations.extend(in_between)\n                    else:\n                        # Otherwise keep trying.\n                        new_operations.append(operation)\n                        break\n                    new_operations.extend(operations[i + j + 2 :])\n                    return new_operations\n                elif not result:\n                    # Can't perform a right reduction.\n                    right = False\n            else:\n                new_operations.append(operation)\n        return new_operations\n",
      "\n    def optimize_inner(self, operations, app_label):\n        \"\"\"Inner optimization loop.\"\"\"\n        new_operations = []\n        for i, operation in enumerate(operations):\n            right = True  # Should we reduce on the right or on the left.\n            # Compare it to each operation after it\n            for j, other in enumerate(operations[i + 1 :]):\n                result = operation.reduce(other, app_label)\n                if isinstance(result, list):\n                    in_between = operations[i + 1 : i + j + 1]\n                    if right:\n                        new_operations.extend(in_between)\n                        new_operations.extend(result)\n                    elif all(op.reduce(other, app_label) is True for op in in_between):\n                        # Perform a left reduction if all of the in-between\n                        # operations can optimize through other.\n                        new_operations.extend(result)\n                        new_operations.extend(in_between)\n                    else:\n                        # Otherwise keep trying.\n                        new_operations.append(operation)\n                        break\n                    new_operations.extend(operations[i + j + 2 :])\n                    return new_operations\n                elif not result:\n                    # Can't perform a right reduction.\n                    right = False\n            else:\n                new_operations.append(operation)\n        return new_operations\n",
      "\ndef optimize_inner(self, operations, app_label):\n    \"\"\"Inner optimization loop.\"\"\"\n    new_operations = []\n    for i, operation in enumerate(operations):\n        right = True  # Should we reduce on the right or on the left.\n        # Compare it to each operation after it\n        for j, other in enumerate(operations[i + 1 :]):\n            result = operation.reduce(other, app_label)\n            if isinstance(result, list):\n                in_between = operations[i + 1 : i + j + 1]\n                if right:\n                    new_operations.extend(in_between)\n                    new_operations.extend(result)\n                elif all(op.reduce(other, app_label) is True for op in in_between):\n                    # Perform a left reduction if all of the in-between\n                    # operations can optimize through other.\n                    new_operations.extend(result)\n                    new_operations.extend(in_between)\n                else:\n                    # Otherwise keep trying.\n                    new_operations.append(operation)\n                    break\n                new_operations.extend(operations[i + j + 2 :])\n                return new_operations\n            elif not result:\n                # Can't perform a right reduction.\n                right = False\n        else:\n            new_operations.append(operation)\n    return new_operations\n",
      "\n    def optimize_inner(self, operations, app_label):\n        \"\"\"Inner optimization loop.\"\"\"\n        new_operations = []\n        for i, operation in enumerate(operations):\n            right = True  # Should we reduce on the right or on the left.\n            # Compare it to each operation after it\n            for j, other in enumerate(operations[i + 1 :]):\n                result = operation.reduce(other, app_label)\n                if isinstance(result, list):\n                    in_between = operations[i + 1 : i + j + 1]\n                    if right:\n                        new_operations.extend(in_between)\n                        new_operations.extend(result)\n                    elif all(op.reduce(other, app_label) is True for op in in_between):\n                        # Perform a left reduction if all of the in-between\n                        # operations can optimize through other.\n                        new_operations.extend(result)\n                        new_operations.extend(in_between)\n                    else:\n                        # Otherwise keep trying.\n                        new_operations.append(operation)\n                        break\n                    new_operations.extend(operations[i + j + 2 :])\n                    return new_operations\n                elif not result:\n                    # Can't perform a right reduction.\n                    right = False\n            else:\n                new_operations.append(operation)\n        return new_operations\n",
      "\n    def optimize_inner(self, operations, app_label):\n        \"\"\"Inner optimization loop.\"\"\"\n        new_operations = []\n        for i, operation in enumerate(operations):\n            right = True  # Should we reduce on the right or on the left.\n            # Compare it to each operation after it\n            for j, other in enumerate(operations[i + 1 :]):\n                result = operation.reduce(other, app_label)\n                if isinstance(result, list):\n                    in_between = operations[i + 1 : i + j + 1]\n                    if right:\n                        new_operations.extend(in_between)\n                        new_operations.extend(result)\n                    elif all(op.reduce(other, app_label) is True for op in in_between):\n                        # Perform a left reduction if all of the in-between\n                        # operations can optimize through other.\n                        new_operations.extend(result)\n                        new_operations.extend(in_between)\n                    else:\n                        # Otherwise keep trying.\n                        new_operations.append(operation)\n                        break\n                    new_operations.extend(operations[i + j + 2 :])\n                    return new_operations\n                elif not result:\n                    # Can't perform a right reduction.\n                    right = False\n            else:\n                new_operations.append(operation)\n        return new_operations\n",
      "\n    def optimize_inner(self, operations, app_label):\n        \"\"\"Inner optimization loop.\"\"\"\n        new_operations = []\n        for i, operation in enumerate(operations):\n            right = True  # Should we reduce on the right or on the left.\n            # Compare it to each operation after it\n            for j, other in enumerate(operations[i + 1 :]):\n                result = operation.reduce(other, app_label)\n                if isinstance(result, list):\n                    in_between = operations[i + 1 : i + j + 1]\n                    if right:\n                        new_operations.extend(in_between)\n                        new_operations.extend(result)\n                    elif all(op.reduce(other, app_label) is True for op in in_between):\n                        # Perform a left reduction if all of the in-between\n                        # operations can optimize through other.\n                        new_operations.extend(result)\n                        new_operations.extend(in_between)\n                    else:\n                        # Otherwise keep trying.\n                        new_operations.append(operation)\n                        break\n                    new_operations.extend(operations[i + j + 2 :])\n                    return new_operations\n                elif not result:\n                    # Can't perform a right reduction.\n                    right = False\n            else:\n                new_operations.append(operation)\n        return new_operations\n",
      "\n    def optimize_inner(self, operations, app_label):\n        \"\"\"Inner optimization loop.\"\"\"\n        new_operations = []\n        for i, operation in enumerate(operations):\n            right = True  # Should we reduce on the right or on the left.\n            # Compare it to each operation after it\n            for j, other in enumerate(operations[i + 1 :]):\n                result = operation.reduce(other, app_label)\n                if isinstance(result, list):\n                    in_between = operations[i + 1 : i + j + 1]\n                    if right:\n                        new_operations.extend(in_between)\n                        new_operations.extend(result)\n                    elif all(op.reduce(other, app_label) is True for op in in_between):\n                        # Perform a left reduction if all of the in-between\n                        # operations can optimize through other.\n                        new_operations.extend(result)\n                        new_operations.extend(in_between)\n                    else:\n                        # Otherwise keep trying.\n                        new_operations.append(operation)\n                        break\n                    new_operations.extend(operations[i + j + 2 :])\n                    return new_operations\n                elif not result:\n                    # Can't perform a right reduction.\n                    right = False\n            else:\n                new_operations.append(operation)\n        return new_operations\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex b89b6b511b..8a63e2d3ee 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -461,6 +461,7 @@ class RenameModel(ModelOperation):\n \n \n class ModelOptionOperation(ModelOperation):\n+\n     def reduce(self, operation, app_label):\n         if (\n             isinstance(operation, (self.__class__, DeleteModel))\n@@ -468,6 +469,9 @@ class ModelOptionOperation(ModelOperation):\n         ):\n             return [operation]\n         return super().reduce(operation, app_label)\n+        ):\n+            return [operation]\n+        return super().reduce(operation, app_label)\n \n \n class AlterModelTable(ModelOptionOperation):\n@@ -636,6 +640,7 @@ class AlterUniqueTogether(AlterTogetherOptionOperation):\n         super().__init__(name, unique_together)\n \n \n+\n class AlterIndexTogether(AlterTogetherOptionOperation):\n     \"\"\"\n     Change the value of index_together to the target one.\n@@ -647,6 +652,43 @@ class AlterIndexTogether(AlterTogetherOptionOperation):\n     def __init__(self, name, index_together):\n         super().__init__(name, index_together)\n \n+    def reduce(self, operation, app_label):\n+        \"\"\"\n+        Override reduce to convert index_together operations to modern AddIndex/RemoveIndex\n+        operations during migration squashing, eliminating deprecation warnings.\n+        \"\"\"\n+        if (\n+            isinstance(operation, AlterIndexTogether)\n+            and self.name_lower == operation.name_lower\n+        ):\n+            # Convert index_together operations to modern AddIndex/RemoveIndex operations\n+            result_operations = []\n+            \n+            # Get the current and target index_together values\n+            current_indexes = normalize_together(self.index_together)\n+            target_indexes = normalize_together(operation.index_together)\n+            \n+            # Generate index names for current indexes (to be removed)\n+            current_index_names = set()\n+            for fields in current_indexes:\n+                if fields:  # Skip empty tuples\n+                    index_name = f\"{self.name_lower}_{'_'.join(fields)}_idx\"\n+                    current_index_names.add(index_name)\n+                    result_operations.append(RemoveIndex(self.name, index_name))\n+            \n+            # Generate AddIndex operations for target indexes\n+            for fields in target_indexes:\n+                if fields:  # Skip empty tuples\n+                    index_name = f\"{self.name_lower}_{'_'.join(fields)}_idx\"\n+                    # Only add if it's not already present\n+                    if index_name not in current_index_names:\n+                        index = models.Index(fields=list(fields), name=index_name)\n+                        result_operations.append(AddIndex(self.name, index))\n+            \n+            return result_operations\n+        \n+        # Fall back to inherited behavior for other operation types\n+        return super().reduce(operation, app_label)\n \n class AlterOrderWithRespectTo(ModelOptionOperation):\n     \"\"\"Represent a change with the order_with_respect_to option.\"\"\"\n@@ -808,6 +850,7 @@ class IndexOperation(Operation):\n         return self.model_name.lower()\n \n \n+\n class AddIndex(IndexOperation):\n     \"\"\"Add an index on a model.\"\"\"\n \n@@ -867,13 +910,13 @@ class AddIndex(IndexOperation):\n         return super().reduce(operation, app_label)\n \n \n+\n class RemoveIndex(IndexOperation):\n     \"\"\"Remove an index from a model.\"\"\"\n \n     def __init__(self, model_name, name):\n         self.model_name = model_name\n         self.name = name\n-\n     def state_forwards(self, app_label, state):\n         state.remove_index(app_label, self.model_name_lower, self.name)\n \ndiff --git a/django/db/migrations/optimizer.py b/django/db/migrations/optimizer.py\nindex 7e5dea2377..6aafe7519a 100644\n--- a/django/db/migrations/optimizer.py\n+++ b/django/db/migrations/optimizer.py\n@@ -37,6 +37,7 @@ class MigrationOptimizer:\n                 return result\n             operations = result\n \n+\n     def optimize_inner(self, operations, app_label):\n         \"\"\"Inner optimization loop.\"\"\"\n         new_operations = []\n",
    "variant_0": "diff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex b89b6b511b..ce4de3e76d 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -460,6 +460,8 @@ class RenameModel(ModelOperation):\n         ) or not operation.references_model(self.new_name, app_label)\n \n \n+class ModelOptionOperation(ModelOperation):\n+\n class ModelOptionOperation(ModelOperation):\n     def reduce(self, operation, app_label):\n         if (\n@@ -468,6 +470,9 @@ class ModelOptionOperation(ModelOperation):\n         ):\n             return [operation]\n         return super().reduce(operation, app_label)\n+        ):\n+            return [operation]\n+        return super().reduce(operation, app_label)\n \n \n class AlterModelTable(ModelOptionOperation):\n@@ -636,6 +641,7 @@ class AlterUniqueTogether(AlterTogetherOptionOperation):\n         super().__init__(name, unique_together)\n \n \n+\n class AlterIndexTogether(AlterTogetherOptionOperation):\n     \"\"\"\n     Change the value of index_together to the target one.\n@@ -647,6 +653,49 @@ class AlterIndexTogether(AlterTogetherOptionOperation):\n     def __init__(self, name, index_together):\n         super().__init__(name, index_together)\n \n+    def reduce(self, operation, app_label):\n+        if isinstance(operation, AlterIndexTogether) and self.name_lower == operation.name_lower:\n+            # Convert index_together operations to modern AddIndex/RemoveIndex operations\n+            from .fields import AddIndex, RemoveIndex\n+            \n+            old_indexes = self.option_value or set()\n+            new_indexes = operation.option_value or set()\n+            \n+            operations = []\n+            \n+            # Create index names for old indexes (to be removed)\n+            old_index_names = set()\n+            for fields in old_indexes:\n+                if fields:  # Skip empty tuples\n+                    field_names = '_'.join(fields)\n+                    index_name = f\"{self.name_lower}_{field_names}_idx\"\n+                    old_index_names.add(index_name)\n+            \n+            # Remove old indexes that are not in new set\n+            for fields in old_indexes:\n+                if fields and fields not in new_indexes:\n+                    field_names = '_'.join(fields)\n+                    index_name = f\"{self.name_lower}_{field_names}_idx\"\n+                    operations.append(RemoveIndex(\n+                        model_name=self.name,\n+                        name=index_name\n+                    ))\n+            \n+            # Add new indexes that are not in old set\n+            for fields in new_indexes:\n+                if fields and fields not in old_indexes:\n+                    field_names = '_'.join(fields)\n+                    index_name = f\"{self.name_lower}_{field_names}_idx\"\n+                    index = models.Index(fields=list(fields), name=index_name)\n+                    operations.append(AddIndex(\n+                        model_name=self.name,\n+                        index=index\n+                    ))\n+            \n+            if operations:\n+                return operations\n+        \n+        return super().reduce(operation, app_label)\n \n class AlterOrderWithRespectTo(ModelOptionOperation):\n     \"\"\"Represent a change with the order_with_respect_to option.\"\"\"\n@@ -808,17 +857,45 @@ class IndexOperation(Operation):\n         return self.model_name.lower()\n \n \n-class AddIndex(IndexOperation):\n-    \"\"\"Add an index on a model.\"\"\"\n \n-    def __init__(self, model_name, index):\n-        self.model_name = model_name\n-        if not index.name:\n-            raise ValueError(\n-                \"Indexes passed to AddIndex operations require a name \"\n-                \"argument. %r doesn't have one.\" % index\n-            )\n-        self.index = index\n+class AlterIndexTogether(AlterTogetherOptionOperation):\n+    \"\"\"\n+    Change the value of index_together to the target one.\n+    Input value of index_together must be a set of tuples.\n+    \"\"\"\n+    option_name = \"index_together\"\n+\n+    def __init__(self, name, index_together):\n+        super().__init__(name, index_together)\n+        self.option_value = normalize_together(self.option_value)\n+\n+    def reduce(self, operation, app_label):\n+        if isinstance(operation, AlterIndexTogether) and self.name_lower == operation.name_lower:\n+            # Convert index_together operations to modern AddIndex/RemoveIndex operations\n+            old_indexes = set(self.option_value or ())\n+            new_indexes = set(operation.option_value or ())\n+            \n+            operations = []\n+            \n+            # Remove indexes that are no longer present\n+            for index_fields in old_indexes - new_indexes:\n+                if index_fields:  # Skip empty tuples\n+                    index_name = f\"{self.name_lower}_{'_'.join(index_fields)}_idx\"\n+                    # Create a temporary index object for RemoveIndex\n+                    temp_index = models.Index(fields=list(index_fields), name=index_name)\n+                    operations.append(RemoveIndex(model_name=self.name, index=temp_index))\n+            \n+            # Add new indexes\n+            for index_fields in new_indexes - old_indexes:\n+                if index_fields:  # Skip empty tuples\n+                    index_name = f\"{self.name_lower}_{'_'.join(index_fields)}_idx\"\n+                    index = models.Index(fields=list(index_fields), name=index_name)\n+                    operations.append(AddIndex(model_name=self.name, index=index))\n+            \n+            if operations:\n+                return operations\n+        \n+        return super().reduce(operation, app_label)\n \n     def state_forwards(self, app_label, state):\n         state.add_index(app_label, self.model_name_lower, self.index)\n@@ -867,13 +944,13 @@ class AddIndex(IndexOperation):\n         return super().reduce(operation, app_label)\n \n \n+\n class RemoveIndex(IndexOperation):\n     \"\"\"Remove an index from a model.\"\"\"\n \n     def __init__(self, model_name, name):\n         self.model_name = model_name\n         self.name = name\n-\n     def state_forwards(self, app_label, state):\n         state.remove_index(app_label, self.model_name_lower, self.name)\n \ndiff --git a/django/db/migrations/optimizer.py b/django/db/migrations/optimizer.py\nindex 7e5dea2377..9bfc1c7c8e 100644\n--- a/django/db/migrations/optimizer.py\n+++ b/django/db/migrations/optimizer.py\n@@ -37,33 +37,38 @@ class MigrationOptimizer:\n                 return result\n             operations = result\n \n-    def optimize_inner(self, operations, app_label):\n-        \"\"\"Inner optimization loop.\"\"\"\n-        new_operations = []\n-        for i, operation in enumerate(operations):\n-            right = True  # Should we reduce on the right or on the left.\n-            # Compare it to each operation after it\n-            for j, other in enumerate(operations[i + 1 :]):\n-                result = operation.reduce(other, app_label)\n-                if isinstance(result, list):\n-                    in_between = operations[i + 1 : i + j + 1]\n-                    if right:\n-                        new_operations.extend(in_between)\n-                        new_operations.extend(result)\n-                    elif all(op.reduce(other, app_label) is True for op in in_between):\n-                        # Perform a left reduction if all of the in-between\n-                        # operations can optimize through other.\n-                        new_operations.extend(result)\n-                        new_operations.extend(in_between)\n-                    else:\n-                        # Otherwise keep trying.\n-                        new_operations.append(operation)\n-                        break\n-                    new_operations.extend(operations[i + j + 2 :])\n-                    return new_operations\n-                elif not result:\n-                    # Can't perform a right reduction.\n-                    right = False\n-            else:\n-                new_operations.append(operation)\n-        return new_operations\n+\n+def optimize_inner(self, operations, app_label):\n+    \"\"\"Inner optimization loop.\"\"\"\n+    new_operations = []\n+    for i, operation in enumerate(operations):\n+        right = True  # Should we reduce on the right or on the left.\n+        # Compare it to each operation after it\n+        for j, other in enumerate(operations[i + 1 :]):\n+            result = operation.reduce(other, app_label)\n+            if isinstance(result, list):\n+                in_between = operations[i + 1 : i + j + 1]\n+                if right:\n+                    new_operations.extend(in_between)\n+                    new_operations.extend(result)\n+                elif all(\n+                    op.reduce(other, app_label) is True \n+                    for op in in_between \n+                    if hasattr(op, 'reduce')\n+                ):\n+                    # Perform a left reduction if all of the in-between\n+                    # operations can optimize through other.\n+                    new_operations.extend(result)\n+                    new_operations.extend(in_between)\n+                else:\n+                    # Otherwise keep trying.\n+                    new_operations.append(operation)\n+                    break\n+                new_operations.extend(operations[i + j + 2 :])\n+                return new_operations\n+            elif not result:\n+                # Can't perform a right reduction.\n+                right = False\n+        else:\n+            new_operations.append(operation)\n+    return new_operations\n",
    "variant_1": "diff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex b89b6b511b..917f6ce18b 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -461,10 +461,96 @@ class RenameModel(ModelOperation):\n \n \n class ModelOptionOperation(ModelOperation):\n+\n+class AlterIndexTogether(ModelOptionOperation):\n+    \"\"\"\n+    Change the value of index_together to the target one.\n+    Input value of index_together must be a set of tuples.\n+    \"\"\"\n+    option_name = \"index_together\"\n+\n+    def __init__(self, name, index_together):\n+        self.index_together = normalize_together(index_together)\n+        super().__init__(name)\n+\n+    def deconstruct(self):\n+        kwargs = {\n+            \"name\": self.name,\n+            \"index_together\": self.index_together,\n+        }\n+        return (self.__class__.__name__, (), kwargs)\n+\n+    def state_forwards(self, app_label, state):\n+        state.alter_model_options(\n+            app_label,\n+            self.name_lower,\n+            {self.option_name: self.index_together},\n+        )\n+\n+    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n+        new_model = to_state.apps.get_model(app_label, self.name)\n+        if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n+            old_model = from_state.apps.get_model(app_label, self.name)\n+            schema_editor.alter_index_together(\n+                new_model,\n+                getattr(old_model._meta, self.option_name, set()),\n+                getattr(new_model._meta, self.option_name, set()),\n+            )\n+\n+    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n+        return self.database_forwards(app_label, schema_editor, from_state, to_state)\n+\n+    def references_field(self, model_name, name, app_label):\n+        return self.references_model(model_name, app_label) and (\n+            not self.index_together\n+            or any(name in fields for fields in self.index_together)\n+        )\n+\n+    def describe(self):\n+        return \"Alter index_together for %s (%s constraint(s))\" % (\n+            self.name,\n+            len(self.index_together),\n+        )\n+\n+    def migration_name_fragment(self):\n+        return \"alter_%s_index_together\" % self.name_lower\n+\n     def reduce(self, operation, app_label):\n-        if (\n-            isinstance(operation, (self.__class__, DeleteModel))\n-            and self.name_lower == operation.name_lower\n+        if isinstance(operation, AlterIndexTogether) and self.name_lower == operation.name_lower:\n+            # Convert index_together operations to modern AddIndex/RemoveIndex operations\n+            from .fields import AddIndex, RemoveIndex\n+            \n+            result = []\n+            \n+            # Get the old and new index sets\n+            old_indexes = set(self.index_together) if self.index_together else set()\n+            new_indexes = set(operation.index_together) if operation.index_together else set()\n+            \n+            # Remove indexes that are no longer needed\n+            for index_fields in old_indexes - new_indexes:\n+                index_name = \"%s_%s_idx\" % (\n+                    self.name_lower,\n+                    \"_\".join(index_fields)\n+                )\n+                result.append(RemoveIndex(\n+                    model_name=self.name,\n+                    name=index_name,\n+                ))\n+            \n+            # Add new indexes\n+            for index_fields in new_indexes - old_indexes:\n+                index_name = \"%s_%s_idx\" % (\n+                    self.name_lower,\n+                    \"_\".join(index_fields)\n+                )\n+                result.append(AddIndex(\n+                    model_name=self.name,\n+                    index=models.Index(fields=list(index_fields), name=index_name),\n+                ))\n+            \n+            return result\n+        \n+        return super().reduce(operation, app_label)\n         ):\n             return [operation]\n         return super().reduce(operation, app_label)\n@@ -636,6 +722,7 @@ class AlterUniqueTogether(AlterTogetherOptionOperation):\n         super().__init__(name, unique_together)\n \n \n+\n class AlterIndexTogether(AlterTogetherOptionOperation):\n     \"\"\"\n     Change the value of index_together to the target one.\n@@ -647,6 +734,37 @@ class AlterIndexTogether(AlterTogetherOptionOperation):\n     def __init__(self, name, index_together):\n         super().__init__(name, index_together)\n \n+    def reduce(self, operation, app_label):\n+        if isinstance(operation, AlterIndexTogether) and self.name_lower == operation.name_lower:\n+            # Convert index_together operations to modern AddIndex/RemoveIndex operations\n+            from .models import AddIndex, RemoveIndex\n+            \n+            old_indexes = set(self.option_value or ())\n+            new_indexes = set(operation.option_value or ())\n+            \n+            operations = []\n+            \n+            # Remove indexes that are no longer needed\n+            for index_fields in old_indexes - new_indexes:\n+                if index_fields:  # Skip empty tuples\n+                    index_name = f\"{self.name_lower}_{'_'.join(index_fields)}_idx\"\n+                    operations.append(RemoveIndex(\n+                        model_name=self.name,\n+                        name=index_name\n+                    ))\n+            \n+            # Add new indexes\n+            for index_fields in new_indexes - old_indexes:\n+                if index_fields:  # Skip empty tuples\n+                    index_name = f\"{self.name_lower}_{'_'.join(index_fields)}_idx\"\n+                    operations.append(AddIndex(\n+                        model_name=self.name,\n+                        index=models.Index(fields=list(index_fields), name=index_name)\n+                    ))\n+            \n+            return operations or [operation]\n+        \n+        return super().reduce(operation, app_label)\n \n class AlterOrderWithRespectTo(ModelOptionOperation):\n     \"\"\"Represent a change with the order_with_respect_to option.\"\"\"\n@@ -808,6 +926,7 @@ class IndexOperation(Operation):\n         return self.model_name.lower()\n \n \n+\n class AddIndex(IndexOperation):\n     \"\"\"Add an index on a model.\"\"\"\n \n@@ -867,13 +986,87 @@ class AddIndex(IndexOperation):\n         return super().reduce(operation, app_label)\n \n \n-class RemoveIndex(IndexOperation):\n-    \"\"\"Remove an index from a model.\"\"\"\n \n-    def __init__(self, model_name, name):\n-        self.model_name = model_name\n-        self.name = name\n+class AlterIndexTogether(IndexOperation):\n+    \"\"\"\n+    Change the value of index_together to a set of tuples of field names.\n+    \"\"\"\n+    option_name = \"index_together\"\n+\n+    def __init__(self, name, index_together):\n+        self.index_together = index_together\n+        super().__init__(name)\n+\n+    def state_forwards(self, app_label, state):\n+        state.alter_model_options(\n+            app_label,\n+            self.model_name_lower,\n+            {self.option_name: self.index_together},\n+        )\n+\n+    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n+        new_model = to_state.apps.get_model(app_label, self.model_name)\n+        if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n+            old_model = from_state.apps.get_model(app_label, self.model_name)\n+            alter_together = getattr(schema_editor, \"alter_%s\" % self.option_name)\n+            alter_together(\n+                new_model,\n+                getattr(old_model._meta, self.option_name, set()),\n+                getattr(new_model._meta, self.option_name, set()),\n+            )\n+\n+    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n+        return self.database_forwards(app_label, schema_editor, from_state, to_state)\n+\n+    def references_field(self, model_name, name, app_label):\n+        return self.references_model(model_name, app_label) and (\n+            not self.index_together\n+            or any(\n+                field_name == name\n+                for field_names in self.index_together\n+                for field_name in field_names\n+            )\n+        )\n+\n+    def describe(self):\n+        return \"Alter %s for %s (%s constraint(s))\" % (\n+            self.option_name,\n+            self.name,\n+            len(self.index_together or \"\"),\n+        )\n+\n+    @property\n+    def migration_name_fragment(self):\n+        return \"alter_%s_%s\" % (self.model_name_lower, self.option_name)\n \n+    def reduce(self, operation, app_label):\n+        if isinstance(operation, AlterIndexTogether) and self.name_lower == operation.name_lower:\n+            # Convert two AlterIndexTogether operations into modern AddIndex/RemoveIndex operations\n+            old_index_together = set(self.index_together or [])\n+            new_index_together = set(operation.index_together or [])\n+            \n+            operations = []\n+            \n+            # Remove indexes that are no longer present\n+            for old_fields in old_index_together - new_index_together:\n+                index_name = \"%s_%s_idx\" % (\n+                    self.model_name_lower,\n+                    \"_\".join(old_fields)\n+                )\n+                operations.append(RemoveIndex(self.name, index_name))\n+            \n+            # Add new indexes\n+            for new_fields in new_index_together - old_index_together:\n+                index_name = \"%s_%s_idx\" % (\n+                    self.model_name_lower,\n+                    \"_\".join(new_fields)\n+                )\n+                index = models.Index(fields=list(new_fields), name=index_name)\n+                operations.append(AddIndex(self.name, index))\n+            \n+            return operations\n+        \n+        return super().reduce(operation, app_label)\n     def state_forwards(self, app_label, state):\n         state.remove_index(app_label, self.model_name_lower, self.name)\n \ndiff --git a/django/db/migrations/optimizer.py b/django/db/migrations/optimizer.py\nindex 7e5dea2377..6aafe7519a 100644\n--- a/django/db/migrations/optimizer.py\n+++ b/django/db/migrations/optimizer.py\n@@ -37,6 +37,7 @@ class MigrationOptimizer:\n                 return result\n             operations = result\n \n+\n     def optimize_inner(self, operations, app_label):\n         \"\"\"Inner optimization loop.\"\"\"\n         new_operations = []\n",
    "variant_2": "diff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex b89b6b511b..e5ec2816a9 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -461,10 +461,98 @@ class RenameModel(ModelOperation):\n \n \n class ModelOptionOperation(ModelOperation):\n+\n+class AlterIndexTogether(ModelOptionOperation):\n+    \"\"\"\n+    Change the value of index_together to the target one.\n+    Input value of index_together must be a set of tuples.\n+    \"\"\"\n+    option_name = \"index_together\"\n+\n+    def __init__(self, name, index_together):\n+        super().__init__(name)\n+        self.index_together = normalize_together(index_together)\n+\n+    def deconstruct(self):\n+        kwargs = {\n+            \"name\": self.name,\n+            \"index_together\": self.index_together,\n+        }\n+        return (self.__class__.__name__, [], kwargs)\n+\n+    def state_forwards(self, app_label, state):\n+        state.alter_model_options(\n+            app_label,\n+            self.name_lower,\n+            {self.option_name: self.index_together},\n+        )\n+\n+    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n+        new_model = to_state.apps.get_model(app_label, self.name)\n+        if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n+            old_model = from_state.apps.get_model(app_label, self.name)\n+            schema_editor.alter_index_together(\n+                new_model,\n+                getattr(old_model._meta, self.option_name, set()),\n+                getattr(new_model._meta, self.option_name, set()),\n+            )\n+\n+    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n+        return self.database_forwards(app_label, schema_editor, from_state, to_state)\n+\n+    def references_field(self, model_name, name, app_label):\n+        return self.references_model(model_name, app_label) and (\n+            not self.index_together\n+            or any(\n+                name in fields for fields in self.index_together\n+            )\n+        )\n+\n+    def describe(self):\n+        return \"Alter index_together for %s (%s constraint(s))\" % (\n+            self.name,\n+            len(self.index_together),\n+        )\n+\n+    def migration_name_fragment(self):\n+        return \"alter_%s_index_together\" % self.name_lower\n+\n     def reduce(self, operation, app_label):\n-        if (\n-            isinstance(operation, (self.__class__, DeleteModel))\n-            and self.name_lower == operation.name_lower\n+        if isinstance(operation, AlterIndexTogether) and self.name_lower == operation.name_lower:\n+            # Convert sequential AlterIndexTogether operations to modern AddIndex/RemoveIndex\n+            from .fields import AddField\n+            from django.db import models\n+            \n+            # Get the current and target index sets\n+            current_indexes = set(self.index_together) if self.index_together else set()\n+            target_indexes = set(operation.index_together) if operation.index_together else set()\n+            \n+            operations = []\n+            \n+            # Remove indexes that are no longer needed\n+            for index_fields in current_indexes - target_indexes:\n+                if index_fields:  # Skip empty tuples\n+                    index_name = f\"{self.name_lower}_{'_'.join(index_fields)}_idx\"\n+                    operations.append(RemoveIndex(\n+                        model_name=self.name,\n+                        name=index_name,\n+                    ))\n+            \n+            # Add new indexes\n+            for index_fields in target_indexes - current_indexes:\n+                if index_fields:  # Skip empty tuples\n+                    index_name = f\"{self.name_lower}_{'_'.join(index_fields)}_idx\"\n+                    operations.append(AddIndex(\n+                        model_name=self.name,\n+                        index=models.Index(fields=list(index_fields), name=index_name),\n+                    ))\n+            \n+            return operations if operations else [operation]\n+        \n+        if isinstance(operation, DeleteModel) and self.name_lower == operation.name_lower:\n+            return [operation]\n+        \n+        return super().reduce(operation, app_label)\n         ):\n             return [operation]\n         return super().reduce(operation, app_label)\n@@ -636,6 +724,7 @@ class AlterUniqueTogether(AlterTogetherOptionOperation):\n         super().__init__(name, unique_together)\n \n \n+\n class AlterIndexTogether(AlterTogetherOptionOperation):\n     \"\"\"\n     Change the value of index_together to the target one.\n@@ -647,6 +736,35 @@ class AlterIndexTogether(AlterTogetherOptionOperation):\n     def __init__(self, name, index_together):\n         super().__init__(name, index_together)\n \n+    def reduce(self, operation, app_label):\n+        if isinstance(operation, AlterIndexTogether) and self.name_lower == operation.name_lower:\n+            # Convert index_together operations to modern AddIndex/RemoveIndex operations\n+            from .models import AddIndex, RemoveIndex\n+            \n+            old_indexes = set(self.option_value or ())\n+            new_indexes = set(operation.option_value or ())\n+            \n+            operations = []\n+            \n+            # Remove indexes that are no longer present\n+            for index_fields in old_indexes - new_indexes:\n+                index_name = f\"{self.name_lower}_{'_'.join(index_fields)}_idx\"\n+                operations.append(RemoveIndex(\n+                    model_name=self.name,\n+                    name=index_name,\n+                ))\n+            \n+            # Add new indexes\n+            for index_fields in new_indexes - old_indexes:\n+                index_name = f\"{self.name_lower}_{'_'.join(index_fields)}_idx\"\n+                operations.append(AddIndex(\n+                    model_name=self.name,\n+                    index=models.Index(fields=list(index_fields), name=index_name),\n+                ))\n+            \n+            return operations\n+        \n+        return super().reduce(operation, app_label)\n \n class AlterOrderWithRespectTo(ModelOptionOperation):\n     \"\"\"Represent a change with the order_with_respect_to option.\"\"\"\n@@ -808,17 +926,51 @@ class IndexOperation(Operation):\n         return self.model_name.lower()\n \n \n-class AddIndex(IndexOperation):\n-    \"\"\"Add an index on a model.\"\"\"\n \n-    def __init__(self, model_name, index):\n-        self.model_name = model_name\n-        if not index.name:\n-            raise ValueError(\n-                \"Indexes passed to AddIndex operations require a name \"\n-                \"argument. %r doesn't have one.\" % index\n-            )\n-        self.index = index\n+class AlterIndexTogether(AlterTogetherOptionOperation):\n+    \"\"\"\n+    Change the value of index_together to the target one.\n+    Input value of index_together must be a set of tuples.\n+    \"\"\"\n+    option_name = \"index_together\"\n+\n+    def __init__(self, name, index_together):\n+        super().__init__(name, index_together)\n+        self.option_value = normalize_together(self.option_value)\n+\n+    def reduce(self, operation, app_label):\n+        # Check if we can convert index_together operations to modern AddIndex/RemoveIndex\n+        if isinstance(operation, AlterIndexTogether) and operation.name_lower == self.name_lower:\n+            # Get the current and target index_together sets\n+            current_indexes = set(self.option_value or ())\n+            target_indexes = set(operation.option_value or ())\n+            \n+            # Calculate what needs to be added and removed\n+            indexes_to_remove = current_indexes - target_indexes\n+            indexes_to_add = target_indexes - current_indexes\n+            \n+            # Only convert if there are actual changes\n+            if indexes_to_remove or indexes_to_add:\n+                operations = []\n+                \n+                # Generate RemoveIndex operations for removed indexes\n+                for index_tuple in indexes_to_remove:\n+                    if index_tuple:  # Skip empty tuples\n+                        index_name = f\"{self.name_lower}_{'_'.join(index_tuple)}_idx\"\n+                        # Create a temporary index object for removal\n+                        temp_index = models.Index(fields=list(index_tuple), name=index_name)\n+                        operations.append(RemoveIndex(model_name=self.name, index=temp_index))\n+                \n+                # Generate AddIndex operations for added indexes\n+                for index_tuple in indexes_to_add:\n+                    if index_tuple:  # Skip empty tuples\n+                        index_name = f\"{self.name_lower}_{'_'.join(index_tuple)}_idx\"\n+                        index = models.Index(fields=list(index_tuple), name=index_name)\n+                        operations.append(AddIndex(model_name=self.name, index=index))\n+                \n+                return operations\n+        \n+        return super().reduce(operation, app_label)\n \n     def state_forwards(self, app_label, state):\n         state.add_index(app_label, self.model_name_lower, self.index)\n@@ -867,13 +1019,13 @@ class AddIndex(IndexOperation):\n         return super().reduce(operation, app_label)\n \n \n+\n class RemoveIndex(IndexOperation):\n     \"\"\"Remove an index from a model.\"\"\"\n \n     def __init__(self, model_name, name):\n         self.model_name = model_name\n         self.name = name\n-\n     def state_forwards(self, app_label, state):\n         state.remove_index(app_label, self.model_name_lower, self.name)\n \ndiff --git a/django/db/migrations/optimizer.py b/django/db/migrations/optimizer.py\nindex 7e5dea2377..6aafe7519a 100644\n--- a/django/db/migrations/optimizer.py\n+++ b/django/db/migrations/optimizer.py\n@@ -37,6 +37,7 @@ class MigrationOptimizer:\n                 return result\n             operations = result\n \n+\n     def optimize_inner(self, operations, app_label):\n         \"\"\"Inner optimization loop.\"\"\"\n         new_operations = []\n",
    "variant_3": "diff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex b89b6b511b..b07b344a1f 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -461,10 +461,47 @@ class RenameModel(ModelOperation):\n \n \n class ModelOptionOperation(ModelOperation):\n+\n+class AlterIndexTogether(AlterTogetherOptionOperation):\n+    option_name = \"index_together\"\n+\n     def reduce(self, operation, app_label):\n-        if (\n-            isinstance(operation, (self.__class__, DeleteModel))\n-            and self.name_lower == operation.name_lower\n+        if isinstance(operation, AlterIndexTogether) and self.name_lower == operation.name_lower:\n+            # Convert index_together operations to modern AddIndex/RemoveIndex operations\n+            from .fields import AddIndex, RemoveIndex\n+            \n+            old_indexes = set(self.option_value or [])\n+            new_indexes = set(operation.option_value or [])\n+            \n+            operations = []\n+            \n+            # Remove indexes that are no longer present\n+            for index_fields in old_indexes - new_indexes:\n+                if index_fields:  # Skip empty tuples\n+                    index_name = f\"{self.name_lower}_{'_'.join(index_fields)}_idx\"\n+                    operations.append(RemoveIndex(\n+                        model_name=self.name,\n+                        name=index_name\n+                    ))\n+            \n+            # Add new indexes\n+            for index_fields in new_indexes - old_indexes:\n+                if index_fields:  # Skip empty tuples\n+                    index_name = f\"{self.name_lower}_{'_'.join(index_fields)}_idx\"\n+                    operations.append(AddIndex(\n+                        model_name=self.name,\n+                        index=models.Index(fields=list(index_fields), name=index_name)\n+                    ))\n+            \n+            return operations if operations else [operation]\n+        \n+        return super().reduce(operation, app_label)\n+\n+    def describe(self):\n+        return \"Alter index_together for %s (%s constraint(s))\" % (\n+            self.name,\n+            len(self.option_value or []),\n+        )\n         ):\n             return [operation]\n         return super().reduce(operation, app_label)\n@@ -636,6 +673,7 @@ class AlterUniqueTogether(AlterTogetherOptionOperation):\n         super().__init__(name, unique_together)\n \n \n+\n class AlterIndexTogether(AlterTogetherOptionOperation):\n     \"\"\"\n     Change the value of index_together to the target one.\n@@ -647,6 +685,38 @@ class AlterIndexTogether(AlterTogetherOptionOperation):\n     def __init__(self, name, index_together):\n         super().__init__(name, index_together)\n \n+    def reduce(self, operation, app_label):\n+        if isinstance(operation, AlterIndexTogether) and self.name_lower == operation.name_lower:\n+            # Convert index_together operations to modern AddIndex/RemoveIndex operations\n+            from .fields import AddIndex, RemoveIndex\n+            \n+            # Get the current and new index_together values\n+            old_indexes = set(self.option_value or [])\n+            new_indexes = set(operation.option_value or [])\n+            \n+            operations = []\n+            \n+            # Remove indexes that are no longer present\n+            for index_tuple in old_indexes - new_indexes:\n+                if index_tuple:  # Skip empty tuples\n+                    index_name = f\"{self.name_lower}_{'_'.join(index_tuple)}_idx\"\n+                    operations.append(RemoveIndex(\n+                        model_name=self.name,\n+                        name=index_name,\n+                    ))\n+            \n+            # Add new indexes\n+            for index_tuple in new_indexes - old_indexes:\n+                if index_tuple:  # Skip empty tuples\n+                    index_name = f\"{self.name_lower}_{'_'.join(index_tuple)}_idx\"\n+                    operations.append(AddIndex(\n+                        model_name=self.name,\n+                        index=models.Index(fields=list(index_tuple), name=index_name),\n+                    ))\n+            \n+            return operations\n+        \n+        return super().reduce(operation, app_label)\n \n class AlterOrderWithRespectTo(ModelOptionOperation):\n     \"\"\"Represent a change with the order_with_respect_to option.\"\"\"\n@@ -808,6 +878,7 @@ class IndexOperation(Operation):\n         return self.model_name.lower()\n \n \n+\n class AddIndex(IndexOperation):\n     \"\"\"Add an index on a model.\"\"\"\n \n@@ -867,13 +938,13 @@ class AddIndex(IndexOperation):\n         return super().reduce(operation, app_label)\n \n \n+\n class RemoveIndex(IndexOperation):\n     \"\"\"Remove an index from a model.\"\"\"\n \n     def __init__(self, model_name, name):\n         self.model_name = model_name\n         self.name = name\n-\n     def state_forwards(self, app_label, state):\n         state.remove_index(app_label, self.model_name_lower, self.name)\n \ndiff --git a/django/db/migrations/optimizer.py b/django/db/migrations/optimizer.py\nindex 7e5dea2377..6aafe7519a 100644\n--- a/django/db/migrations/optimizer.py\n+++ b/django/db/migrations/optimizer.py\n@@ -37,6 +37,7 @@ class MigrationOptimizer:\n                 return result\n             operations = result\n \n+\n     def optimize_inner(self, operations, app_label):\n         \"\"\"Inner optimization loop.\"\"\"\n         new_operations = []\n",
    "variant_4": "diff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex b89b6b511b..9034195eb3 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -461,10 +461,103 @@ class RenameModel(ModelOperation):\n \n \n class ModelOptionOperation(ModelOperation):\n+\n+class AlterIndexTogether(ModelOptionOperation):\n+    \"\"\"\n+    Change the value of index_together to the target one.\n+    Input value of index_together must be a set of tuples.\n+    \"\"\"\n+    option_name = \"index_together\"\n+\n+    def __init__(self, name, index_together):\n+        self.index_together = index_together\n+        super().__init__(name)\n+\n+    def deconstruct(self):\n+        kwargs = {\n+            \"name\": self.name,\n+            \"index_together\": self.index_together,\n+        }\n+        return (self.__class__.__name__, [], kwargs)\n+\n+    def state_forwards(self, app_label, state):\n+        state.alter_model_options(\n+            app_label,\n+            self.name_lower,\n+            {self.option_name: self.index_together},\n+        )\n+\n+    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n+        new_model = to_state.apps.get_model(app_label, self.name)\n+        if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n+            old_model = from_state.apps.get_model(app_label, self.name)\n+            schema_editor.alter_index_together(\n+                new_model,\n+                getattr(old_model._meta, self.option_name, set()),\n+                getattr(new_model._meta, self.option_name, set()),\n+            )\n+\n+    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n+        return self.database_forwards(app_label, schema_editor, from_state, to_state)\n+\n+    def references_field(self, model_name, name, app_label):\n+        return self.references_model(model_name, app_label) and (\n+            not self.index_together\n+            or any(name in fields for fields in self.index_together)\n+        )\n+\n+    def describe(self):\n+        return \"Alter %s for %s (%s constraint(s))\" % (\n+            self.option_name,\n+            self.name,\n+            len(self.index_together or \"\"),\n+        )\n+\n+    @property\n+    def migration_name_fragment(self):\n+        return \"alter_%s_%s\" % (self.name_lower, self.option_name)\n+\n     def reduce(self, operation, app_label):\n         if (\n             isinstance(operation, (self.__class__, DeleteModel))\n             and self.name_lower == operation.name_lower\n+        ):\n+            # Convert index_together operations to modern AddIndex/RemoveIndex operations\n+            if isinstance(operation, self.__class__):\n+                from .fields import AddIndex, RemoveIndex\n+                \n+                operations = []\n+                current_indexes = set(self.index_together or ())\n+                new_indexes = set(operation.index_together or ())\n+                \n+                # Generate index names for current indexes\n+                current_named_indexes = {}\n+                for index_fields in current_indexes:\n+                    index_name = f\"{self.name_lower}_{'_'.join(index_fields)}_idx\"\n+                    current_named_indexes[index_fields] = index_name\n+                \n+                # Remove indexes that are no longer needed\n+                for index_fields in current_indexes - new_indexes:\n+                    index_name = current_named_indexes[index_fields]\n+                    operations.append(RemoveIndex(\n+                        model_name=self.name,\n+                        name=index_name\n+                    ))\n+                \n+                # Add new indexes\n+                for index_fields in new_indexes - current_indexes:\n+                    index_name = f\"{self.name_lower}_{'_'.join(index_fields)}_idx\"\n+                    operations.append(AddIndex(\n+                        model_name=self.name,\n+                        index=models.Index(fields=list(index_fields), name=index_name)\n+                    ))\n+                \n+                # If we have operations to perform, return them; otherwise fall through\n+                if operations:\n+                    return operations\n+            \n+            return [operation]\n+        return super().reduce(operation, app_label)\n         ):\n             return [operation]\n         return super().reduce(operation, app_label)\n@@ -636,6 +729,7 @@ class AlterUniqueTogether(AlterTogetherOptionOperation):\n         super().__init__(name, unique_together)\n \n \n+\n class AlterIndexTogether(AlterTogetherOptionOperation):\n     \"\"\"\n     Change the value of index_together to the target one.\n@@ -647,6 +741,37 @@ class AlterIndexTogether(AlterTogetherOptionOperation):\n     def __init__(self, name, index_together):\n         super().__init__(name, index_together)\n \n+    def reduce(self, operation, app_label):\n+        if isinstance(operation, AlterIndexTogether) and self.name_lower == operation.name_lower:\n+            # Convert index_together operations to modern AddIndex/RemoveIndex operations\n+            from .models import AddIndex, RemoveIndex\n+            \n+            old_indexes = set(self.option_value or ())\n+            new_indexes = set(operation.option_value or ())\n+            \n+            operations = []\n+            \n+            # Remove indexes that are no longer present\n+            for index_tuple in old_indexes - new_indexes:\n+                if index_tuple:  # Skip empty tuples\n+                    index_name = f\"{self.name_lower}_{'_'.join(index_tuple)}_idx\"\n+                    operations.append(RemoveIndex(\n+                        model_name=operation.name,\n+                        name=index_name\n+                    ))\n+            \n+            # Add new indexes\n+            for index_tuple in new_indexes - old_indexes:\n+                if index_tuple:  # Skip empty tuples\n+                    index_name = f\"{self.name_lower}_{'_'.join(index_tuple)}_idx\"\n+                    operations.append(AddIndex(\n+                        model_name=operation.name,\n+                        index=models.Index(fields=list(index_tuple), name=index_name)\n+                    ))\n+            \n+            return operations\n+        \n+        return super().reduce(operation, app_label)\n \n class AlterOrderWithRespectTo(ModelOptionOperation):\n     \"\"\"Represent a change with the order_with_respect_to option.\"\"\"\n@@ -808,6 +933,7 @@ class IndexOperation(Operation):\n         return self.model_name.lower()\n \n \n+\n class AddIndex(IndexOperation):\n     \"\"\"Add an index on a model.\"\"\"\n \n@@ -867,13 +993,13 @@ class AddIndex(IndexOperation):\n         return super().reduce(operation, app_label)\n \n \n+\n class RemoveIndex(IndexOperation):\n     \"\"\"Remove an index from a model.\"\"\"\n \n     def __init__(self, model_name, name):\n         self.model_name = model_name\n         self.name = name\n-\n     def state_forwards(self, app_label, state):\n         state.remove_index(app_label, self.model_name_lower, self.name)\n \ndiff --git a/django/db/migrations/optimizer.py b/django/db/migrations/optimizer.py\nindex 7e5dea2377..1389eb9a57 100644\n--- a/django/db/migrations/optimizer.py\n+++ b/django/db/migrations/optimizer.py\n@@ -37,33 +37,34 @@ class MigrationOptimizer:\n                 return result\n             operations = result\n \n-    def optimize_inner(self, operations, app_label):\n-        \"\"\"Inner optimization loop.\"\"\"\n-        new_operations = []\n-        for i, operation in enumerate(operations):\n-            right = True  # Should we reduce on the right or on the left.\n-            # Compare it to each operation after it\n-            for j, other in enumerate(operations[i + 1 :]):\n-                result = operation.reduce(other, app_label)\n-                if isinstance(result, list):\n-                    in_between = operations[i + 1 : i + j + 1]\n-                    if right:\n-                        new_operations.extend(in_between)\n-                        new_operations.extend(result)\n-                    elif all(op.reduce(other, app_label) is True for op in in_between):\n-                        # Perform a left reduction if all of the in-between\n-                        # operations can optimize through other.\n-                        new_operations.extend(result)\n-                        new_operations.extend(in_between)\n-                    else:\n-                        # Otherwise keep trying.\n-                        new_operations.append(operation)\n-                        break\n-                    new_operations.extend(operations[i + j + 2 :])\n-                    return new_operations\n-                elif not result:\n-                    # Can't perform a right reduction.\n-                    right = False\n-            else:\n-                new_operations.append(operation)\n-        return new_operations\n+\n+def optimize_inner(self, operations, app_label):\n+    \"\"\"Inner optimization loop.\"\"\"\n+    new_operations = []\n+    for i, operation in enumerate(operations):\n+        right = True  # Should we reduce on the right or on the left.\n+        # Compare it to each operation after it\n+        for j, other in enumerate(operations[i + 1 :]):\n+            result = operation.reduce(other, app_label)\n+            if isinstance(result, list):\n+                in_between = operations[i + 1 : i + j + 1]\n+                if right:\n+                    new_operations.extend(in_between)\n+                    new_operations.extend(result)\n+                elif all(op.reduce(other, app_label) is True for op in in_between):\n+                    # Perform a left reduction if all of the in-between\n+                    # operations can optimize through other.\n+                    new_operations.extend(result)\n+                    new_operations.extend(in_between)\n+                else:\n+                    # Otherwise keep trying.\n+                    new_operations.append(operation)\n+                    break\n+                new_operations.extend(operations[i + j + 2 :])\n+                return new_operations\n+            elif not result:\n+                # Can't perform a right reduction.\n+                right = False\n+        else:\n+            new_operations.append(operation)\n+    return new_operations\n",
    "variant_5": "diff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex b89b6b511b..f43cbb849c 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -461,10 +461,62 @@ class RenameModel(ModelOperation):\n \n \n class ModelOptionOperation(ModelOperation):\n+\n+class AlterIndexTogether(AlterTogetherOptionOperation):\n+    \"\"\"\n+    Change the value of index_together to the target one.\n+    Input value of index_together will be normalized.\n+    \"\"\"\n+\n+    option_name = \"index_together\"\n+\n+    def __init__(self, name, index_together):\n+        super().__init__(name, index_together)\n+\n     def reduce(self, operation, app_label):\n-        if (\n-            isinstance(operation, (self.__class__, DeleteModel))\n-            and self.name_lower == operation.name_lower\n+        if isinstance(operation, AlterIndexTogether) and self.name_lower == operation.name_lower:\n+            # Convert index_together operations to modern AddIndex/RemoveIndex operations\n+            from .fields import AddIndex, RemoveIndex\n+            \n+            # Get the old and new index sets\n+            old_indexes = set(self.option_value or ())\n+            new_indexes = set(operation.option_value or ())\n+            \n+            # Generate operations to add new indexes and remove old ones\n+            operations = []\n+            \n+            # Remove indexes that are no longer present\n+            for index_fields in old_indexes - new_indexes:\n+                index_name = self._generate_index_name(index_fields)\n+                operations.append(RemoveIndex(\n+                    model_name=self.name,\n+                    name=index_name\n+                ))\n+            \n+            # Add new indexes\n+            for index_fields in new_indexes - old_indexes:\n+                index_name = self._generate_index_name(index_fields)\n+                operations.append(AddIndex(\n+                    model_name=self.name,\n+                    index=models.Index(fields=list(index_fields), name=index_name)\n+                ))\n+            \n+            return operations if operations else [operation]\n+        \n+        if isinstance(operation, DeleteModel) and self.name_lower == operation.name_lower:\n+            return [operation]\n+        \n+        return super().reduce(operation, app_label)\n+    \n+    def _generate_index_name(self, fields):\n+        \"\"\"Generate a consistent index name from field names.\"\"\"\n+        return f\"{self.name_lower}_{'_'.join(fields)}_idx\"\n+\n+    def describe(self):\n+        return \"Alter index_together for %s (%s constraint(s))\" % (\n+            self.name,\n+            len(self.option_value or \"\"),\n+        )\n         ):\n             return [operation]\n         return super().reduce(operation, app_label)\n@@ -636,6 +688,7 @@ class AlterUniqueTogether(AlterTogetherOptionOperation):\n         super().__init__(name, unique_together)\n \n \n+\n class AlterIndexTogether(AlterTogetherOptionOperation):\n     \"\"\"\n     Change the value of index_together to the target one.\n@@ -647,6 +700,40 @@ class AlterIndexTogether(AlterTogetherOptionOperation):\n     def __init__(self, name, index_together):\n         super().__init__(name, index_together)\n \n+    def reduce(self, operation, app_label):\n+        if isinstance(operation, AlterIndexTogether) and self.name_lower == operation.name_lower:\n+            # Convert index_together operations to modern AddIndex/RemoveIndex operations\n+            from .fields import AddIndex, RemoveIndex\n+            \n+            # Get the old and new index_together values\n+            old_indexes = self.option_value or set()\n+            new_indexes = operation.option_value or set()\n+            \n+            operations = []\n+            \n+            # Remove indexes that are no longer present\n+            for old_tuple in old_indexes - new_indexes:\n+                if old_tuple:  # Skip empty tuples\n+                    field_names = [str(field) for field in old_tuple]\n+                    index_name = f\"{self.name_lower}_{'_'.join(field_names)}_idx\"\n+                    operations.append(RemoveIndex(\n+                        model_name=self.name,\n+                        name=index_name,\n+                    ))\n+            \n+            # Add new indexes\n+            for new_tuple in new_indexes - old_indexes:\n+                if new_tuple:  # Skip empty tuples\n+                    field_names = [str(field) for field in new_tuple]\n+                    index_name = f\"{self.name_lower}_{'_'.join(field_names)}_idx\"\n+                    operations.append(AddIndex(\n+                        model_name=self.name,\n+                        index=models.Index(fields=field_names, name=index_name),\n+                    ))\n+            \n+            return operations\n+        \n+        return super().reduce(operation, app_label)\n \n class AlterOrderWithRespectTo(ModelOptionOperation):\n     \"\"\"Represent a change with the order_with_respect_to option.\"\"\"\n@@ -808,17 +895,60 @@ class IndexOperation(Operation):\n         return self.model_name.lower()\n \n \n-class AddIndex(IndexOperation):\n-    \"\"\"Add an index on a model.\"\"\"\n \n-    def __init__(self, model_name, index):\n-        self.model_name = model_name\n-        if not index.name:\n-            raise ValueError(\n-                \"Indexes passed to AddIndex operations require a name \"\n-                \"argument. %r doesn't have one.\" % index\n-            )\n-        self.index = index\n+class AlterIndexTogether(ModelOptionOperation):\n+    \"\"\"\n+    Change the value of index_together to the target one.\n+    Input value of index_together must be a set of tuples.\n+    \"\"\"\n+    option_name = \"index_together\"\n+\n+    def __init__(self, name, index_together):\n+        super().__init__(name, index_together)\n+\n+    @cached_property\n+    def option_value(self):\n+        return set(normalize_together(self.option))\n+\n+    def describe(self):\n+        return \"Alter index_together for %s (%s constraint(s))\" % (\n+            self.name,\n+            len(self.option_value),\n+        )\n+\n+    def reduce(self, operation, app_label):\n+        if isinstance(operation, AlterIndexTogether) and self.name_lower == operation.name_lower:\n+            # Convert index_together operations to modern AddIndex/RemoveIndex operations\n+            old_indexes = self.option_value\n+            new_indexes = operation.option_value\n+            \n+            operations = []\n+            \n+            # Remove indexes that are no longer present\n+            for index_fields in old_indexes - new_indexes:\n+                if index_fields:  # Skip empty tuples\n+                    index_name = \"%s_%s_idx\" % (\n+                        self.name_lower,\n+                        \"_\".join(index_fields)\n+                    )\n+                    operations.append(RemoveIndex(self.name, models.Index(fields=list(index_fields), name=index_name)))\n+            \n+            # Add new indexes\n+            for index_fields in new_indexes - old_indexes:\n+                if index_fields:  # Skip empty tuples\n+                    index_name = \"%s_%s_idx\" % (\n+                        self.name_lower,\n+                        \"_\".join(index_fields)\n+                    )\n+                    operations.append(AddIndex(self.name, models.Index(fields=list(index_fields), name=index_name)))\n+            \n+            if operations:\n+                return operations\n+            else:\n+                # If no operations needed, return empty list to remove both operations\n+                return []\n+        \n+        return super().reduce(operation, app_label)\n \n     def state_forwards(self, app_label, state):\n         state.add_index(app_label, self.model_name_lower, self.index)\n@@ -867,13 +997,13 @@ class AddIndex(IndexOperation):\n         return super().reduce(operation, app_label)\n \n \n+\n class RemoveIndex(IndexOperation):\n     \"\"\"Remove an index from a model.\"\"\"\n \n     def __init__(self, model_name, name):\n         self.model_name = model_name\n         self.name = name\n-\n     def state_forwards(self, app_label, state):\n         state.remove_index(app_label, self.model_name_lower, self.name)\n \ndiff --git a/django/db/migrations/optimizer.py b/django/db/migrations/optimizer.py\nindex 7e5dea2377..6aafe7519a 100644\n--- a/django/db/migrations/optimizer.py\n+++ b/django/db/migrations/optimizer.py\n@@ -37,6 +37,7 @@ class MigrationOptimizer:\n                 return result\n             operations = result\n \n+\n     def optimize_inner(self, operations, app_label):\n         \"\"\"Inner optimization loop.\"\"\"\n         new_operations = []\n",
    "variant_6": "diff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex b89b6b511b..1f220843bf 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -461,10 +461,93 @@ class RenameModel(ModelOperation):\n \n \n class ModelOptionOperation(ModelOperation):\n+\n+class AlterIndexTogether(ModelOptionOperation):\n+    \"\"\"\n+    Change the value of index_together to the target one.\n+    Input value of index_together must be a set of tuples.\n+    \"\"\"\n+    option_name = \"index_together\"\n+\n+    def __init__(self, name, index_together):\n+        self.index_together = index_together\n+        super().__init__(name)\n+\n+    def deconstruct(self):\n+        kwargs = {\n+            \"name\": self.name,\n+            \"index_together\": self.index_together,\n+        }\n+        return (self.__class__.__name__, [], kwargs)\n+\n+    def state_forwards(self, app_label, state):\n+        state.alter_model_options(\n+            app_label,\n+            self.name_lower,\n+            {self.option_name: self.index_together},\n+        )\n+\n+    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n+        new_model = to_state.apps.get_model(app_label, self.name)\n+        if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n+            old_model = from_state.apps.get_model(app_label, self.name)\n+            schema_editor.alter_index_together(\n+                new_model,\n+                getattr(old_model._meta, self.option_name, set()),\n+                getattr(new_model._meta, self.option_name, set()),\n+            )\n+\n+    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n+        return self.database_forwards(app_label, schema_editor, from_state, to_state)\n+\n+    def references_field(self, model_name, name, app_label):\n+        return self.references_model(model_name, app_label) and (\n+            not self.index_together\n+            or any(name in fields for fields in self.index_together)\n+        )\n+\n+    def describe(self):\n+        return \"Alter index_together for %s (%s constraint(s))\" % (\n+            self.name,\n+            len(self.index_together or \"\"),\n+        )\n+\n+    @property\n+    def migration_name_fragment(self):\n+        return \"alter_%s_index_together\" % self.name_lower\n+\n     def reduce(self, operation, app_label):\n-        if (\n-            isinstance(operation, (self.__class__, DeleteModel))\n-            and self.name_lower == operation.name_lower\n+        if isinstance(operation, AlterIndexTogether) and self.name_lower == operation.name_lower:\n+            # Convert index_together operations to modern AddIndex/RemoveIndex operations\n+            from .fields import AddField, RemoveField\n+            \n+            old_indexes = set(self.index_together or ())\n+            new_indexes = set(operation.index_together or ())\n+            \n+            operations = []\n+            \n+            # Remove indexes that are no longer present\n+            for index_fields in old_indexes - new_indexes:\n+                index_name = f\"{self.name_lower}_{'_'.join(index_fields)}_idx\"\n+                operations.append(RemoveIndex(\n+                    model_name=self.name,\n+                    name=index_name,\n+                ))\n+            \n+            # Add new indexes\n+            for index_fields in new_indexes - old_indexes:\n+                index_name = f\"{self.name_lower}_{'_'.join(index_fields)}_idx\"\n+                operations.append(AddIndex(\n+                    model_name=self.name,\n+                    index=models.Index(fields=list(index_fields), name=index_name),\n+                ))\n+            \n+            return operations if operations else [operation]\n+        \n+        if isinstance(operation, DeleteModel) and self.name_lower == operation.name_lower:\n+            return [operation]\n+        \n+        return super().reduce(operation, app_label)\n         ):\n             return [operation]\n         return super().reduce(operation, app_label)\n@@ -636,6 +719,7 @@ class AlterUniqueTogether(AlterTogetherOptionOperation):\n         super().__init__(name, unique_together)\n \n \n+\n class AlterIndexTogether(AlterTogetherOptionOperation):\n     \"\"\"\n     Change the value of index_together to the target one.\n@@ -647,6 +731,38 @@ class AlterIndexTogether(AlterTogetherOptionOperation):\n     def __init__(self, name, index_together):\n         super().__init__(name, index_together)\n \n+    def reduce(self, operation, app_label):\n+        if isinstance(operation, AlterIndexTogether) and self.name_lower == operation.name_lower:\n+            # Convert index_together operations to modern AddIndex/RemoveIndex operations\n+            from .models import AddIndex, RemoveIndex\n+            \n+            old_indexes = self.option_value or set()\n+            new_indexes = operation.option_value or set()\n+            \n+            operations = []\n+            \n+            # Remove indexes that are no longer present\n+            for index_tuple in old_indexes - new_indexes:\n+                if index_tuple:  # Skip empty tuples\n+                    index_name = f\"{self.name_lower}_{'_'.join(index_tuple)}_idx\"\n+                    operations.append(RemoveIndex(\n+                        model_name=self.name,\n+                        name=index_name\n+                    ))\n+            \n+            # Add new indexes\n+            for index_tuple in new_indexes - old_indexes:\n+                if index_tuple:  # Skip empty tuples\n+                    index_name = f\"{self.name_lower}_{'_'.join(index_tuple)}_idx\"\n+                    operations.append(AddIndex(\n+                        model_name=self.name,\n+                        index=models.Index(fields=list(index_tuple), name=index_name)\n+                    ))\n+            \n+            if operations:\n+                return operations\n+        \n+        return super().reduce(operation, app_label)\n \n class AlterOrderWithRespectTo(ModelOptionOperation):\n     \"\"\"Represent a change with the order_with_respect_to option.\"\"\"\n@@ -808,6 +924,7 @@ class IndexOperation(Operation):\n         return self.model_name.lower()\n \n \n+\n class AddIndex(IndexOperation):\n     \"\"\"Add an index on a model.\"\"\"\n \n@@ -867,13 +984,13 @@ class AddIndex(IndexOperation):\n         return super().reduce(operation, app_label)\n \n \n+\n class RemoveIndex(IndexOperation):\n     \"\"\"Remove an index from a model.\"\"\"\n \n     def __init__(self, model_name, name):\n         self.model_name = model_name\n         self.name = name\n-\n     def state_forwards(self, app_label, state):\n         state.remove_index(app_label, self.model_name_lower, self.name)\n \ndiff --git a/django/db/migrations/optimizer.py b/django/db/migrations/optimizer.py\nindex 7e5dea2377..6aafe7519a 100644\n--- a/django/db/migrations/optimizer.py\n+++ b/django/db/migrations/optimizer.py\n@@ -37,6 +37,7 @@ class MigrationOptimizer:\n                 return result\n             operations = result\n \n+\n     def optimize_inner(self, operations, app_label):\n         \"\"\"Inner optimization loop.\"\"\"\n         new_operations = []\n",
    "variant_7": "diff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex b89b6b511b..cc8788a454 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -460,6 +460,8 @@ class RenameModel(ModelOperation):\n         ) or not operation.references_model(self.new_name, app_label)\n \n \n+class ModelOptionOperation(ModelOperation):\n+\n class ModelOptionOperation(ModelOperation):\n     def reduce(self, operation, app_label):\n         if (\n@@ -468,6 +470,9 @@ class ModelOptionOperation(ModelOperation):\n         ):\n             return [operation]\n         return super().reduce(operation, app_label)\n+        ):\n+            return [operation]\n+        return super().reduce(operation, app_label)\n \n \n class AlterModelTable(ModelOptionOperation):\n@@ -636,6 +641,7 @@ class AlterUniqueTogether(AlterTogetherOptionOperation):\n         super().__init__(name, unique_together)\n \n \n+\n class AlterIndexTogether(AlterTogetherOptionOperation):\n     \"\"\"\n     Change the value of index_together to the target one.\n@@ -647,6 +653,32 @@ class AlterIndexTogether(AlterTogetherOptionOperation):\n     def __init__(self, name, index_together):\n         super().__init__(name, index_together)\n \n+    def reduce(self, operation, app_label):\n+        # Try to convert index_together operations to modern AddIndex/RemoveIndex\n+        if isinstance(operation, AlterIndexTogether) and self.name_lower == operation.name_lower:\n+            # Get the current and target index_together values\n+            current_indexes = self.option_value or set()\n+            target_indexes = operation.option_value or set()\n+            \n+            # Convert to modern Index operations\n+            operations = []\n+            \n+            # Remove indexes that are no longer present\n+            for index_tuple in current_indexes - target_indexes:\n+                if index_tuple:  # Skip empty tuples\n+                    index_name = f\"{self.name_lower}_{'_'.join(index_tuple)}_idx\"\n+                    operations.append(RemoveIndex(name=self.name, name=index_name))\n+            \n+            # Add new indexes\n+            for index_tuple in target_indexes - current_indexes:\n+                if index_tuple:  # Skip empty tuples\n+                    index_name = f\"{self.name_lower}_{'_'.join(index_tuple)}_idx\"\n+                    index = models.Index(fields=list(index_tuple), name=index_name)\n+                    operations.append(AddIndex(name=self.name, index=index))\n+            \n+            return operations or [operation]\n+        \n+        return super().reduce(operation, app_label)\n \n class AlterOrderWithRespectTo(ModelOptionOperation):\n     \"\"\"Represent a change with the order_with_respect_to option.\"\"\"\n@@ -808,6 +840,7 @@ class IndexOperation(Operation):\n         return self.model_name.lower()\n \n \n+\n class AddIndex(IndexOperation):\n     \"\"\"Add an index on a model.\"\"\"\n \n@@ -867,13 +900,13 @@ class AddIndex(IndexOperation):\n         return super().reduce(operation, app_label)\n \n \n+\n class RemoveIndex(IndexOperation):\n     \"\"\"Remove an index from a model.\"\"\"\n \n     def __init__(self, model_name, name):\n         self.model_name = model_name\n         self.name = name\n-\n     def state_forwards(self, app_label, state):\n         state.remove_index(app_label, self.model_name_lower, self.name)\n \ndiff --git a/django/db/migrations/optimizer.py b/django/db/migrations/optimizer.py\nindex 7e5dea2377..6aafe7519a 100644\n--- a/django/db/migrations/optimizer.py\n+++ b/django/db/migrations/optimizer.py\n@@ -37,6 +37,7 @@ class MigrationOptimizer:\n                 return result\n             operations = result\n \n+\n     def optimize_inner(self, operations, app_label):\n         \"\"\"Inner optimization loop.\"\"\"\n         new_operations = []\n",
    "variant_8": "diff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex b89b6b511b..f5ca7bf409 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -461,10 +461,105 @@ class RenameModel(ModelOperation):\n \n \n class ModelOptionOperation(ModelOperation):\n+\n+class AlterIndexTogether(ModelOptionOperation):\n+    \"\"\"\n+    Change the value of index_together to the target one.\n+    Input value of index_together must be a set of tuples.\n+    \"\"\"\n+    option_name = \"index_together\"\n+\n+    def __init__(self, name, index_together):\n+        self.index_together = index_together\n+        super().__init__(name)\n+\n+    def deconstruct(self):\n+        kwargs = {\n+            \"name\": self.name,\n+            \"index_together\": self.index_together,\n+        }\n+        return (self.__class__.__name__, [], kwargs)\n+\n+    def state_forwards(self, app_label, state):\n+        state.alter_model_options(\n+            app_label,\n+            self.name_lower,\n+            {self.option_name: self.index_together},\n+        )\n+\n+    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n+        new_model = to_state.apps.get_model(app_label, self.name)\n+        if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n+            old_model = from_state.apps.get_model(app_label, self.name)\n+            schema_editor.alter_index_together(\n+                new_model,\n+                getattr(old_model._meta, self.option_name, set()),\n+                getattr(new_model._meta, self.option_name, set()),\n+            )\n+\n+    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n+        return self.database_forwards(app_label, schema_editor, from_state, to_state)\n+\n+    def references_field(self, model_name, name, app_label):\n+        return self.references_model(model_name, app_label) and (\n+            not self.index_together\n+            or any(name in fields for fields in self.index_together)\n+        )\n+\n+    def describe(self):\n+        return \"Alter index_together for %s (%s constraints)\" % (\n+            self.name,\n+            len(self.index_together),\n+        )\n+\n+    @property\n+    def migration_name_fragment(self):\n+        return \"alter_%s_index_together\" % self.name_lower\n+\n     def reduce(self, operation, app_label):\n         if (\n             isinstance(operation, (self.__class__, DeleteModel))\n             and self.name_lower == operation.name_lower\n+        ):\n+            if isinstance(operation, AlterIndexTogether):\n+                # Convert two AlterIndexTogether operations into modern AddIndex/RemoveIndex operations\n+                from .fields import AddField\n+                from django.db import models\n+                \n+                old_indexes = set(self.index_together) if self.index_together else set()\n+                new_indexes = set(operation.index_together) if operation.index_together else set()\n+                \n+                operations = []\n+                \n+                # Remove indexes that are no longer needed\n+                for index_fields in old_indexes - new_indexes:\n+                    index_name = \"%s_%s_idx\" % (\n+                        self.name_lower,\n+                        \"_\".join(index_fields)\n+                    )\n+                    operations.append(RemoveIndex(\n+                        model_name=self.name,\n+                        name=index_name\n+                    ))\n+                \n+                # Add new indexes\n+                for index_fields in new_indexes - old_indexes:\n+                    index_name = \"%s_%s_idx\" % (\n+                        self.name_lower,\n+                        \"_\".join(index_fields)\n+                    )\n+                    operations.append(AddIndex(\n+                        model_name=self.name,\n+                        index=models.Index(\n+                            fields=list(index_fields),\n+                            name=index_name\n+                        )\n+                    ))\n+                \n+                return operations if operations else [operation]\n+            else:\n+                return [operation]\n+        return super().reduce(operation, app_label)\n         ):\n             return [operation]\n         return super().reduce(operation, app_label)\n@@ -636,6 +731,7 @@ class AlterUniqueTogether(AlterTogetherOptionOperation):\n         super().__init__(name, unique_together)\n \n \n+\n class AlterIndexTogether(AlterTogetherOptionOperation):\n     \"\"\"\n     Change the value of index_together to the target one.\n@@ -647,6 +743,37 @@ class AlterIndexTogether(AlterTogetherOptionOperation):\n     def __init__(self, name, index_together):\n         super().__init__(name, index_together)\n \n+    def reduce(self, operation, app_label):\n+        if isinstance(operation, AlterIndexTogether) and self.name_lower == operation.name_lower:\n+            # Convert index_together operations to modern AddIndex/RemoveIndex operations\n+            from .fields import AddIndex, RemoveIndex\n+            \n+            old_indexes = set(self.option_value or ())\n+            new_indexes = set(operation.option_value or ())\n+            \n+            operations = []\n+            \n+            # Remove indexes that are no longer present\n+            for index_fields in old_indexes - new_indexes:\n+                if index_fields:  # Skip empty tuples\n+                    index_name = f\"{self.name_lower}_{'_'.join(index_fields)}_idx\"\n+                    operations.append(RemoveIndex(\n+                        model_name=self.name,\n+                        name=index_name\n+                    ))\n+            \n+            # Add new indexes\n+            for index_fields in new_indexes - old_indexes:\n+                if index_fields:  # Skip empty tuples\n+                    index_name = f\"{self.name_lower}_{'_'.join(index_fields)}_idx\"\n+                    operations.append(AddIndex(\n+                        model_name=self.name,\n+                        index=models.Index(fields=list(index_fields), name=index_name)\n+                    ))\n+            \n+            return operations if operations else [operation]\n+        \n+        return super().reduce(operation, app_label)\n \n class AlterOrderWithRespectTo(ModelOptionOperation):\n     \"\"\"Represent a change with the order_with_respect_to option.\"\"\"\n@@ -808,6 +935,7 @@ class IndexOperation(Operation):\n         return self.model_name.lower()\n \n \n+\n class AddIndex(IndexOperation):\n     \"\"\"Add an index on a model.\"\"\"\n \n@@ -867,13 +995,13 @@ class AddIndex(IndexOperation):\n         return super().reduce(operation, app_label)\n \n \n+\n class RemoveIndex(IndexOperation):\n     \"\"\"Remove an index from a model.\"\"\"\n \n     def __init__(self, model_name, name):\n         self.model_name = model_name\n         self.name = name\n-\n     def state_forwards(self, app_label, state):\n         state.remove_index(app_label, self.model_name_lower, self.name)\n \ndiff --git a/django/db/migrations/optimizer.py b/django/db/migrations/optimizer.py\nindex 7e5dea2377..6aafe7519a 100644\n--- a/django/db/migrations/optimizer.py\n+++ b/django/db/migrations/optimizer.py\n@@ -37,6 +37,7 @@ class MigrationOptimizer:\n                 return result\n             operations = result\n \n+\n     def optimize_inner(self, operations, app_label):\n         \"\"\"Inner optimization loop.\"\"\"\n         new_operations = []\n"
  }
}