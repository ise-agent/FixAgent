{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/django/django/db/models/deletion.py lines 392-398)": "\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                return count, {model._meta.label: count} if count > 0 else {}\n",
    "Location 2 (/root/hy/projects_2/django/django/db/models/deletion.py lines 445-445)": "\n        if self.can_fast_delete(objs):\n            self.fast_deletes.append(objs)\n            for obj in objs:\n                obj._state.db = self.using\n            count = len(objs)\n            if count > 0:\n                return count, {model._meta.label: count}\n            else:\n                return count, {}\n",
    "Location 3 (/root/hy/projects_2/django/django/db/models/deletion.py lines 389-389)": "\n    def delete(self):\n        # sort instance collections\n        for model, instances in self.data.items():\n            self.data[model] = sorted(instances, key=attrgetter(\"pk\"))\n\n        # if possible, bring the models in an order suitable for databases that\n        # don't support transactions or cannot defer constraint checks until the\n        # end of a transaction.\n        self.sort()\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                return count, {model._meta.label: count} if count > 0 else {}\n",
    "Location 4 (/root/hy/projects_2/django/django/db/models/deletion.py lines 409-411)": "\n        # fast delete\n        if len(self.data) == 1 and can_fast_delete(objs[0]):\n            self.fast_deletes = [self.data[model]]\n            # Don't create a query if we don't have any objects to delete\n            # (This can happen on model inheritance if only a parent has objects)\n            if self.fast_deletes == [[]]:\n                return 0, {}\n            count = self.fast_deletes[0]._raw_delete(using=self.using)\n            if count > 0:\n                return count, {model._meta.label: count}\n            else:\n                return 0, {}\n",
    "Location 5 (/root/hy/projects_2/django/django/db/models/deletion.py lines 429-429)": "\n        if self.can_fast_delete(objs):\n            self.fast_deletes.append(objs)\n            for obj in objs:\n                obj._state.db = self.using\n            count = len(objs)\n            return count, {model._meta.label: count} if count > 0 else {}\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/django/django/db/models/deletion.py lines 392-398)": [
      "\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                return count, {model._meta.label: count} if count > 0 else {}\n",
      "\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                return count, {model._meta.label: count} if count > 0 else {}\n",
      "\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                return count, {model._meta.label: count} if count > 0 else {}\n",
      "\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                return count, {model._meta.label: count} if count > 0 else {}\n",
      "\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                return count, {model._meta.label: count} if count > 0 else {}\n",
      "\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                return count, {model._meta.label: count} if count > 0 else {}\n",
      "\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                return count, {model._meta.label: count} if count > 0 else {}\n",
      "\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                return count, {model._meta.label: count} if count > 0 else {}\n"
    ],
    "Location 2 (/root/hy/projects_2/django/django/db/models/deletion.py lines 445-445)": [
      "\n        if self.can_fast_delete(objs):\n            self.fast_deletes.append(objs)\n            for obj in objs:\n                obj._state.db = self.using\n            count = len(objs)\n            if count:\n                return count, {model._meta.label: count}\n            else:\n                return count, {}\n",
      "\n        # fast deletes\n        for qs in self.fast_deletes:\n            count = qs.count()\n            if count:\n                qs.delete()\n            return count, {qs.model._meta.label: count} if count > 0 else {}\n",
      "\n                # fast delete\n                if (\n                    not self.can_fast_delete(instance)\n                    or not self.can_fast_delete(parent_objs)\n                ):\n                    # slow delete\n                    return self.delete()\n                count = qs.count()\n                if count:\n                    qs.delete()\n                return count, {model._meta.label: count} if count > 0 else {}\n",
      "\n        if self.can_fast_delete(objs):\n            self.fast_deletes.append(objs)\n            for obj in objs:\n                obj._state.db = self.using\n            count = len(objs)\n            if count:\n                return count, {model._meta.label: count}\n            else:\n                return count, {}\n",
      "\n        # If the queryset is empty, there's nothing to delete.\n        if not qs:\n            return 0, {}\n\n        # Fast delete path when possible.\n        if (\n            self.can_fast_delete(qs) and\n            len(self.data) == 1 and\n            model in self.data\n        ):\n            # The fast delete path bypasses the collection phase entirely,\n            # hence we need to special case its handling.\n            count = qs.count()\n            if count:\n                qs.delete()\n                return count, {model._meta.label: count}\n            return 0, {}\n",
      "\n        if self.can_fast_delete(objs):\n            # Fast delete path - only proceed if there are objects to delete\n            if objs:\n                with transaction.atomic(using=self.using, savepoint=False):\n                    count = query.delete()\n            else:\n                count = 0\n            return count, {model._meta.label: count} if count > 0 else {}\n",
      "\n        # fast deletes\n        for qs in self.fast_deletes:\n            count = qs._raw_delete(using=self.using, keep_parents=keep_parents)\n            if count:\n                deleted_counter[qs.model._meta.label] += count\n\n        # update collected instances\n        for instances_for_fieldvalues in self.field_updates.values():\n            for (field, value), instances in instances_for_fieldvalues.items():\n                for obj in instances:\n                    setattr(obj, field.attname, value)\n        for model, instances in self.data.items():\n            for instance in instances:\n                setattr(instance, model._meta.pk.attname, None)\n        return sum(deleted_counter.values()), dict(deleted_counter)\n",
      "\n        if self.can_fast_delete(objs):\n            # Fast deletes have no dependencies.\n            with transaction.mark_for_rollback_on_error(using):\n                count = self.do_sql_delete(main_model, self.get_del_batches(objs, []), using)\n            if count > 0:\n                return count, {model._meta.label: count}\n            else:\n                return count, {}\n"
    ],
    "Location 3 (/root/hy/projects_2/django/django/db/models/deletion.py lines 389-389)": [
      "\n    def delete(self):\n        # sort instance collections\n        for model, instances in self.data.items():\n            self.data[model] = sorted(instances, key=attrgetter(\"pk\"))\n\n        # if possible, bring the models in an order suitable for databases that\n        # don't support transactions or cannot defer constraint checks until the\n        # end of a transaction.\n        self.sort()\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                return count, {model._meta.label: count} if count > 0 else {}\n",
      "\ndef delete(self):\n    # sort instance collections\n    for model, instances in self.data.items():\n        self.data[model] = sorted(instances, key=attrgetter(\"pk\"))\n\n    # if possible, bring the models in an order suitable for databases that\n    # don't support transactions or cannot defer constraint checks until the\n    # end of a transaction.\n    self.sort()\n    # number of objects deleted for each model label\n    deleted_counter = Counter()\n\n    # Optimize for the case with a single obj and no dependencies\n    if len(self.data) == 1 and len(instances) == 1:\n        instance = list(instances)[0]\n        if self.can_fast_delete(instance):\n            with transaction.mark_for_rollback_on_error():\n                count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n            setattr(instance, model._meta.pk.attname, None)\n            return count, {model._meta.label: count} if count > 0 else {}\n",
      "\n    def delete(self):\n        # sort instance collections\n        for model, instances in self.data.items():\n            self.data[model] = sorted(instances, key=attrgetter(\"pk\"))\n\n        # if possible, bring the models in an order suitable for databases that\n        # don't support transactions or cannot defer constraint checks until the\n        # end of a transaction.\n        self.sort()\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                return count, {model._meta.label: count} if count > 0 else {}\n",
      "\n    def delete(self):\n        # sort instance collections\n        for model, instances in self.data.items():\n            self.data[model] = sorted(instances, key=attrgetter(\"pk\"))\n\n        # if possible, bring the models in an order suitable for databases that\n        # don't support transactions or cannot defer constraint checks until the\n        # end of a transaction.\n        self.sort()\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                return count, {model._meta.label: count} if count > 0 else {}\n",
      "\n    def delete(self):\n        # sort instance collections\n        for model, instances in self.data.items():\n            self.data[model] = sorted(instances, key=attrgetter(\"pk\"))\n\n        # if possible, bring the models in an order suitable for databases that\n        # don't support transactions or cannot defer constraint checks until the\n        # end of a transaction.\n        self.sort()\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                return count, {model._meta.label: count} if count > 0 else {}\n",
      "\n    def delete(self):\n        # sort instance collections\n        for model, instances in self.data.items():\n            self.data[model] = sorted(instances, key=attrgetter(\"pk\"))\n\n        # if possible, bring the models in an order suitable for databases that\n        # don't support transactions or cannot defer constraint checks until the\n        # end of a transaction.\n        self.sort()\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                return count, {model._meta.label: count} if count > 0 else {}\n",
      "\n    def delete(self):\n        # sort instance collections\n        for model, instances in self.data.items():\n            self.data[model] = sorted(instances, key=attrgetter(\"pk\"))\n\n        # if possible, bring the models in an order suitable for databases that\n        # don't support transactions or cannot defer constraint checks until the\n        # end of a transaction.\n        self.sort()\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                return count, {model._meta.label: count} if count > 0 else {}\n",
      "\n    def delete(self):\n        # sort instance collections\n        for model, instances in self.data.items():\n            self.data[model] = sorted(instances, key=attrgetter(\"pk\"))\n\n        # if possible, bring the models in an order suitable for databases that\n        # don't support transactions or cannot defer constraint checks until the\n        # end of a transaction.\n        self.sort()\n        # number of objects deleted for each model label\n        deleted_counter = Counter()\n\n        # Optimize for the case with a single obj and no dependencies\n        if len(self.data) == 1 and len(instances) == 1:\n            instance = list(instances)[0]\n            if self.can_fast_delete(instance):\n                with transaction.mark_for_rollback_on_error():\n                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                setattr(instance, model._meta.pk.attname, None)\n                return count, {model._meta.label: count} if count > 0 else {}\n"
    ],
    "Location 4 (/root/hy/projects_2/django/django/db/models/deletion.py lines 409-411)": [
      "\n        # fast delete\n        if len(self.data) == 1 and can_fast_delete(objs[0]):\n            self.fast_deletes = [\n                model_objs.only(*[f.attname for f in model._meta.concrete_fields])\n            ]\n            return self.fast_deletes[0].count(), {model._meta.label: len(model_objs)} if len(model_objs) > 0 else {}\n",
      "\n        # fast path: if the objects are in a single partition of a table,\n        # and they don't have foreign keys to other objects or they only have\n        # foreign keys to objects in the same partition, then we can do a\n        # fast delete. We can do a single database call to delete all the\n        # objects.\n        if len(self.data) == 1 and all(\n            len(queries) == 1 and len(queries[0].where.children) <= 1\n            for queries in self.data.values()\n        ):\n            model = list(self.data.keys())[0]\n            query = list(self.data.values())[0][0]\n            count = query._raw_delete(using=self.using)\n            if count == 0:\n                return count, {}\n            return count, {model._meta.label: count}\n",
      "\n        # fast delete\n        if len(self.data) == 1 and can_fast_delete(objs):\n            self.fast_deletes.append(objs)\n            from django.db.models import Model\n            model = type(objs[0]) if objs else Model\n            count = len(objs)\n            return count, {model._meta.label: count} if count > 0 else {}\n",
      "\n        # fast deletes\n        if len(self.fast_deletes) == 1:\n            single_qs = self.fast_deletes[0]\n            try:\n                with transaction.atomic(using=self.using, savepoint=False):\n                    count = single_qs._raw_delete(using=self.using)\n                return count, {single_qs.model._meta.label: count} if count > 0 else {}\n            except IntegrityError:\n                pass\n",
      "\n        # fast delete\n        if self.can_fast_delete(objs):\n            self.fast_deletes = [objs]\n            count = len(objs)\n            if count > 0:\n                return count, {model._meta.label: count}\n            else:\n                return count, {}\n",
      "\n        # fast delete\n        if len(self.data) == 1 and can_fast_delete(objs):\n            self.fast_deletes.append(self.data[model])\n            from django.db import router\n            if router.allow_migrate(self.using, model):\n                count = self.data[model].count()\n                if count:\n                    self.data[model]._raw_delete(using=self.using)\n                    return count, {model._meta.label: count}\n                else:\n                    return count, {}\n",
      "\n        # fast deletes\n        if len(self.fast_deletes) == 1:\n            single_qs = self.fast_deletes[0]\n            if single_qs._result_cache is None:\n                # Check that the query is eligible for fast deletion\n                model = single_qs.model\n                if (model._meta.can_migrate(self.using) and\n                    not any(f.name in model._meta.protected_names for f in model._meta.get_fields())):\n                    count = single_qs._raw_delete(using=self.using)\n                    if count:\n                        return count, {model._meta.label: count}\n                    else:\n                        return count, {}\n",
      "\n        # fast delete\n        if len(self.data) == 1 and can_fast_delete(objs[0]):\n            self.fast_deletes = [self.data[model]]\n            # Don't create a query to delete nothing.\n            if not self.fast_deletes[0]:\n                return 0, {}\n            count = self.fast_deletes[0]._raw_delete(using=self.using)\n            return count, {model._meta.label: count} if count > 0 else {}\n"
    ],
    "Location 5 (/root/hy/projects_2/django/django/db/models/deletion.py lines 429-429)": [
      "\n        if self.can_fast_delete(objs):\n            # Fast delete optimization for simple cases\n            with transaction.atomic(using=self.using, savepoint=False):\n                count = query.delete_batch(pk_list, self.using)\n            if count > 0:\n                return count, {model._meta.label: count}\n            else:\n                return count, {}\n",
      "\n        if self.can_fast_delete(objs):\n            # fast deletes\n            for qs in self.fast_deletes:\n                count = qs.delete()[0]\n                if count:\n                    deleted_counter[qs.model._meta.label] += count\n            return sum(deleted_counter.values()), dict(deleted_counter)\n",
      "\n        if self.can_fast_delete(objs):\n            self.fast_deletes.append(objs)\n            for obj in objs:\n                obj._state.db = self.using\n            count = len(objs)\n            return count, {model._meta.label: count} if count > 0 else {}\n",
      "\n        if self.can_fast_delete(objs):\n            self.fast_deletes.append(instances)\n            count = len(instances)\n            if count:\n                deleted_counter[model._meta.label] += count\n            return count, {model._meta.label: count} if count > 0 else {}\n",
      "\n        if self.can_fast_delete(objs):\n            self.fast_deletes.append(objs)\n            for obj in objs:\n                obj._state.db = self.using\n            # The fast delete signal will be sent when the queryset is evaluated.\n            count = qs._raw_delete(using=self.using)\n            if count:\n                deleted_counter[model._meta.label] += count\n            return count, {model._meta.label: count} if count > 0 else {}\n",
      "\n        if self.can_fast_delete(objs):\n            # fast deletes\n            for qs in self.fast_deletes:\n                count = qs._raw_delete(using=self.using)\n                if count:\n                    deleted_counter[qs.model._meta.label] += count\n\n            # update fields\n            for model, instances_for_fieldvalues in self.field_updates.items():\n                for (field, value), instances in instances_for_fieldvalues.items():\n                    query = sql.UpdateQuery(model)\n                    query.update_batch([obj.pk for obj in instances],\n                                       {field.name: value}, self.using)\n            return sum(deleted_counter.values()), dict(deleted_counter)\n",
      "\n            # fast deletes\n            if can_fast_delete:\n                count = query.delete_batch(pk_list, self.using)\n                if count:\n                    deleted_counter[model._meta.label] += count\n                return count, dict(deleted_counter)\n",
      "\n        if self.can_fast_delete(objs):\n            self.fast_deletes.append(objs)\n            for obj in objs:\n                signals.pre_delete.send(\n                    sender=model, instance=obj, using=self.using\n                )\n            count = query.delete_batch([obj.pk for obj in objs], self.using)\n            if not model._meta.auto_created:\n                for obj in objs:\n                    signals.post_delete.send(\n                        sender=model, instance=obj, using=self.using\n                    )\n            return count, {model._meta.label: count} if count > 0 else {}\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 16dff6a1cd..2bd0dde307 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -386,16 +386,18 @@ class Collector:\n         # end of a transaction.\n         self.sort()\n         # number of objects deleted for each model label\n+\n         deleted_counter = Counter()\n \n         # Optimize for the case with a single obj and no dependencies\n+\n         if len(self.data) == 1 and len(instances) == 1:\n             instance = list(instances)[0]\n             if self.can_fast_delete(instance):\n                 with transaction.mark_for_rollback_on_error():\n                     count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                 setattr(instance, model._meta.pk.attname, None)\n-                return count, {model._meta.label: count}\n+                return count, {model._meta.label: count} if count > 0 else {}\n \n         with transaction.atomic(using=self.using, savepoint=False):\n             # send pre_delete signals\n@@ -406,6 +408,7 @@ class Collector:\n                     )\n \n             # fast deletes\n+\n             for qs in self.fast_deletes:\n                 count = qs._raw_delete(using=self.using)\n                 deleted_counter[qs.model._meta.label] += count\n@@ -426,6 +429,7 @@ class Collector:\n                 query = sql.DeleteQuery(model)\n                 pk_list = [obj.pk for obj in instances]\n                 count = query.delete_batch(pk_list, self.using)\n+\n                 deleted_counter[model._meta.label] += count\n \n                 if not model._meta.auto_created:\n@@ -442,4 +446,5 @@ class Collector:\n         for model, instances in self.data.items():\n             for instance in instances:\n                 setattr(instance, model._meta.pk.attname, None)\n+\n         return sum(deleted_counter.values()), dict(deleted_counter)\n",
    "variant_0": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 16dff6a1cd..d888c0d622 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -376,6 +376,17 @@ class Collector:\n                 return\n         self.data = {model: self.data[model] for model in sorted_models}\n \n+    def delete(self):\n+        # sort instance collections\n+        for model, instances in self.data.items():\n+            self.data[model] = sorted(instances, key=attrgetter(\"pk\"))\n+\n+        # if possible, bring the models in an order suitable for databases that\n+        # don't support transactions or cannot defer constraint checks until the\n+        # end of a transaction.\n+        self.sort()\n+        # number of objects deleted for each model label\n+\n     def delete(self):\n         # sort instance collections\n         for model, instances in self.data.items():\n@@ -395,7 +406,18 @@ class Collector:\n                 with transaction.mark_for_rollback_on_error():\n                     count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                 setattr(instance, model._meta.pk.attname, None)\n-                return count, {model._meta.label: count}\n+                return count, {model._meta.label: count} if count > 0 else {}\n+\n+        # Optimize for the case with a single obj and no dependencies\n+\n+        # Optimize for the case with a single obj and no dependencies\n+        if len(self.data) == 1 and len(instances) == 1:\n+            instance = list(instances)[0]\n+            if self.can_fast_delete(instance):\n+                with transaction.mark_for_rollback_on_error():\n+                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n+                setattr(instance, model._meta.pk.attname, None)\n+                return count, {model._meta.label: count} if count > 0 else {}\n \n         with transaction.atomic(using=self.using, savepoint=False):\n             # send pre_delete signals\n@@ -406,9 +428,19 @@ class Collector:\n                     )\n \n             # fast deletes\n-            for qs in self.fast_deletes:\n-                count = qs._raw_delete(using=self.using)\n-                deleted_counter[qs.model._meta.label] += count\n+\n+        # fast delete\n+        if len(self.data) == 1 and can_fast_delete(objs[0]):\n+            self.fast_deletes = [self.data[model]]\n+            # Don't create a query if we don't have any objects to delete\n+            # (This can happen on model inheritance if only a parent has objects)\n+            if self.fast_deletes == [[]]:\n+                return 0, {}\n+            count = self.fast_deletes[0]._raw_delete(using=self.using)\n+            if count > 0:\n+                return count, {model._meta.label: count}\n+            else:\n+                return 0, {}\n \n             # update fields\n             for model, instances_for_fieldvalues in self.field_updates.items():\n@@ -426,7 +458,13 @@ class Collector:\n                 query = sql.DeleteQuery(model)\n                 pk_list = [obj.pk for obj in instances]\n                 count = query.delete_batch(pk_list, self.using)\n-                deleted_counter[model._meta.label] += count\n+\n+        if self.can_fast_delete(objs):\n+            self.fast_deletes.append(objs)\n+            for obj in objs:\n+                obj._state.db = self.using\n+            count = len(objs)\n+            return count, {model._meta.label: count} if count > 0 else {}\n \n                 if not model._meta.auto_created:\n                     for obj in instances:\n@@ -442,4 +480,13 @@ class Collector:\n         for model, instances in self.data.items():\n             for instance in instances:\n                 setattr(instance, model._meta.pk.attname, None)\n-        return sum(deleted_counter.values()), dict(deleted_counter)\n+\n+        if self.can_fast_delete(objs):\n+            self.fast_deletes.append(objs)\n+            for obj in objs:\n+                obj._state.db = self.using\n+            count = len(objs)\n+            if count > 0:\n+                return count, {model._meta.label: count}\n+            else:\n+                return count, {}\n",
    "variant_1": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 16dff6a1cd..0c16807500 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -376,6 +376,17 @@ class Collector:\n                 return\n         self.data = {model: self.data[model] for model in sorted_models}\n \n+    def delete(self):\n+        # sort instance collections\n+        for model, instances in self.data.items():\n+            self.data[model] = sorted(instances, key=attrgetter(\"pk\"))\n+\n+        # if possible, bring the models in an order suitable for databases that\n+        # don't support transactions or cannot defer constraint checks until the\n+        # end of a transaction.\n+        self.sort()\n+        # number of objects deleted for each model label\n+\n     def delete(self):\n         # sort instance collections\n         for model, instances in self.data.items():\n@@ -395,7 +406,18 @@ class Collector:\n                 with transaction.mark_for_rollback_on_error():\n                     count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                 setattr(instance, model._meta.pk.attname, None)\n-                return count, {model._meta.label: count}\n+                return count, {model._meta.label: count} if count > 0 else {}\n+\n+        # Optimize for the case with a single obj and no dependencies\n+\n+        # Optimize for the case with a single obj and no dependencies\n+        if len(self.data) == 1 and len(instances) == 1:\n+            instance = list(instances)[0]\n+            if self.can_fast_delete(instance):\n+                with transaction.mark_for_rollback_on_error():\n+                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n+                setattr(instance, model._meta.pk.attname, None)\n+                return count, {model._meta.label: count} if count > 0 else {}\n \n         with transaction.atomic(using=self.using, savepoint=False):\n             # send pre_delete signals\n@@ -406,9 +428,13 @@ class Collector:\n                     )\n \n             # fast deletes\n-            for qs in self.fast_deletes:\n-                count = qs._raw_delete(using=self.using)\n-                deleted_counter[qs.model._meta.label] += count\n+\n+        # fast delete\n+        if len(self.data) == 1 and can_fast_delete(objs[0]):\n+            self.fast_deletes = [\n+                model_objs.only(*[f.attname for f in model._meta.concrete_fields])\n+            ]\n+            return self.fast_deletes[0].count(), {model._meta.label: len(model_objs)} if len(model_objs) > 0 else {}\n \n             # update fields\n             for model, instances_for_fieldvalues in self.field_updates.items():\n@@ -426,7 +452,15 @@ class Collector:\n                 query = sql.DeleteQuery(model)\n                 pk_list = [obj.pk for obj in instances]\n                 count = query.delete_batch(pk_list, self.using)\n-                deleted_counter[model._meta.label] += count\n+\n+        if self.can_fast_delete(objs):\n+            # Fast delete optimization for simple cases\n+            with transaction.atomic(using=self.using, savepoint=False):\n+                count = query.delete_batch(pk_list, self.using)\n+            if count > 0:\n+                return count, {model._meta.label: count}\n+            else:\n+                return count, {}\n \n                 if not model._meta.auto_created:\n                     for obj in instances:\n@@ -442,4 +476,13 @@ class Collector:\n         for model, instances in self.data.items():\n             for instance in instances:\n                 setattr(instance, model._meta.pk.attname, None)\n-        return sum(deleted_counter.values()), dict(deleted_counter)\n+\n+        if self.can_fast_delete(objs):\n+            self.fast_deletes.append(objs)\n+            for obj in objs:\n+                obj._state.db = self.using\n+            count = len(objs)\n+            if count:\n+                return count, {model._meta.label: count}\n+            else:\n+                return count, {}\n",
    "variant_2": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 16dff6a1cd..62b8a5d5db 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -386,7 +386,29 @@ class Collector:\n         # end of a transaction.\n         self.sort()\n         # number of objects deleted for each model label\n-        deleted_counter = Counter()\n+\n+def delete(self):\n+    # sort instance collections\n+    for model, instances in self.data.items():\n+        self.data[model] = sorted(instances, key=attrgetter(\"pk\"))\n+\n+    # if possible, bring the models in an order suitable for databases that\n+    # don't support transactions or cannot defer constraint checks until the\n+    # end of a transaction.\n+    self.sort()\n+    # number of objects deleted for each model label\n+    deleted_counter = Counter()\n+\n+    # Optimize for the case with a single obj and no dependencies\n+    if len(self.data) == 1 and len(instances) == 1:\n+        instance = list(instances)[0]\n+        if self.can_fast_delete(instance):\n+            with transaction.mark_for_rollback_on_error():\n+                count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n+            setattr(instance, model._meta.pk.attname, None)\n+            return count, {model._meta.label: count} if count > 0 else {}\n+\n+        # Optimize for the case with a single obj and no dependencies\n \n         # Optimize for the case with a single obj and no dependencies\n         if len(self.data) == 1 and len(instances) == 1:\n@@ -395,7 +417,7 @@ class Collector:\n                 with transaction.mark_for_rollback_on_error():\n                     count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                 setattr(instance, model._meta.pk.attname, None)\n-                return count, {model._meta.label: count}\n+                return count, {model._meta.label: count} if count > 0 else {}\n \n         with transaction.atomic(using=self.using, savepoint=False):\n             # send pre_delete signals\n@@ -406,9 +428,22 @@ class Collector:\n                     )\n \n             # fast deletes\n-            for qs in self.fast_deletes:\n-                count = qs._raw_delete(using=self.using)\n-                deleted_counter[qs.model._meta.label] += count\n+\n+        # fast path: if the objects are in a single partition of a table,\n+        # and they don't have foreign keys to other objects or they only have\n+        # foreign keys to objects in the same partition, then we can do a\n+        # fast delete. We can do a single database call to delete all the\n+        # objects.\n+        if len(self.data) == 1 and all(\n+            len(queries) == 1 and len(queries[0].where.children) <= 1\n+            for queries in self.data.values()\n+        ):\n+            model = list(self.data.keys())[0]\n+            query = list(self.data.values())[0][0]\n+            count = query._raw_delete(using=self.using)\n+            if count == 0:\n+                return count, {}\n+            return count, {model._meta.label: count}\n \n             # update fields\n             for model, instances_for_fieldvalues in self.field_updates.items():\n@@ -426,7 +461,14 @@ class Collector:\n                 query = sql.DeleteQuery(model)\n                 pk_list = [obj.pk for obj in instances]\n                 count = query.delete_batch(pk_list, self.using)\n-                deleted_counter[model._meta.label] += count\n+\n+        if self.can_fast_delete(objs):\n+            # fast deletes\n+            for qs in self.fast_deletes:\n+                count = qs.delete()[0]\n+                if count:\n+                    deleted_counter[qs.model._meta.label] += count\n+            return sum(deleted_counter.values()), dict(deleted_counter)\n \n                 if not model._meta.auto_created:\n                     for obj in instances:\n@@ -442,4 +484,10 @@ class Collector:\n         for model, instances in self.data.items():\n             for instance in instances:\n                 setattr(instance, model._meta.pk.attname, None)\n-        return sum(deleted_counter.values()), dict(deleted_counter)\n+\n+        # fast deletes\n+        for qs in self.fast_deletes:\n+            count = qs.count()\n+            if count:\n+                qs.delete()\n+            return count, {qs.model._meta.label: count} if count > 0 else {}\n",
    "variant_3": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 16dff6a1cd..8ced3d5b0f 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -376,6 +376,17 @@ class Collector:\n                 return\n         self.data = {model: self.data[model] for model in sorted_models}\n \n+    def delete(self):\n+        # sort instance collections\n+        for model, instances in self.data.items():\n+            self.data[model] = sorted(instances, key=attrgetter(\"pk\"))\n+\n+        # if possible, bring the models in an order suitable for databases that\n+        # don't support transactions or cannot defer constraint checks until the\n+        # end of a transaction.\n+        self.sort()\n+        # number of objects deleted for each model label\n+\n     def delete(self):\n         # sort instance collections\n         for model, instances in self.data.items():\n@@ -395,7 +406,18 @@ class Collector:\n                 with transaction.mark_for_rollback_on_error():\n                     count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                 setattr(instance, model._meta.pk.attname, None)\n-                return count, {model._meta.label: count}\n+                return count, {model._meta.label: count} if count > 0 else {}\n+\n+        # Optimize for the case with a single obj and no dependencies\n+\n+        # Optimize for the case with a single obj and no dependencies\n+        if len(self.data) == 1 and len(instances) == 1:\n+            instance = list(instances)[0]\n+            if self.can_fast_delete(instance):\n+                with transaction.mark_for_rollback_on_error():\n+                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n+                setattr(instance, model._meta.pk.attname, None)\n+                return count, {model._meta.label: count} if count > 0 else {}\n \n         with transaction.atomic(using=self.using, savepoint=False):\n             # send pre_delete signals\n@@ -406,9 +428,14 @@ class Collector:\n                     )\n \n             # fast deletes\n-            for qs in self.fast_deletes:\n-                count = qs._raw_delete(using=self.using)\n-                deleted_counter[qs.model._meta.label] += count\n+\n+        # fast delete\n+        if len(self.data) == 1 and can_fast_delete(objs):\n+            self.fast_deletes.append(objs)\n+            from django.db.models import Model\n+            model = type(objs[0]) if objs else Model\n+            count = len(objs)\n+            return count, {model._meta.label: count} if count > 0 else {}\n \n             # update fields\n             for model, instances_for_fieldvalues in self.field_updates.items():\n@@ -426,7 +453,13 @@ class Collector:\n                 query = sql.DeleteQuery(model)\n                 pk_list = [obj.pk for obj in instances]\n                 count = query.delete_batch(pk_list, self.using)\n-                deleted_counter[model._meta.label] += count\n+\n+        if self.can_fast_delete(objs):\n+            self.fast_deletes.append(objs)\n+            for obj in objs:\n+                obj._state.db = self.using\n+            count = len(objs)\n+            return count, {model._meta.label: count} if count > 0 else {}\n \n                 if not model._meta.auto_created:\n                     for obj in instances:\n@@ -442,4 +475,15 @@ class Collector:\n         for model, instances in self.data.items():\n             for instance in instances:\n                 setattr(instance, model._meta.pk.attname, None)\n-        return sum(deleted_counter.values()), dict(deleted_counter)\n+\n+                # fast delete\n+                if (\n+                    not self.can_fast_delete(instance)\n+                    or not self.can_fast_delete(parent_objs)\n+                ):\n+                    # slow delete\n+                    return self.delete()\n+                count = qs.count()\n+                if count:\n+                    qs.delete()\n+                return count, {model._meta.label: count} if count > 0 else {}\n",
    "variant_4": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 16dff6a1cd..9c09e9d5fe 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -376,6 +376,17 @@ class Collector:\n                 return\n         self.data = {model: self.data[model] for model in sorted_models}\n \n+    def delete(self):\n+        # sort instance collections\n+        for model, instances in self.data.items():\n+            self.data[model] = sorted(instances, key=attrgetter(\"pk\"))\n+\n+        # if possible, bring the models in an order suitable for databases that\n+        # don't support transactions or cannot defer constraint checks until the\n+        # end of a transaction.\n+        self.sort()\n+        # number of objects deleted for each model label\n+\n     def delete(self):\n         # sort instance collections\n         for model, instances in self.data.items():\n@@ -395,7 +406,18 @@ class Collector:\n                 with transaction.mark_for_rollback_on_error():\n                     count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                 setattr(instance, model._meta.pk.attname, None)\n-                return count, {model._meta.label: count}\n+                return count, {model._meta.label: count} if count > 0 else {}\n+\n+        # Optimize for the case with a single obj and no dependencies\n+\n+        # Optimize for the case with a single obj and no dependencies\n+        if len(self.data) == 1 and len(instances) == 1:\n+            instance = list(instances)[0]\n+            if self.can_fast_delete(instance):\n+                with transaction.mark_for_rollback_on_error():\n+                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n+                setattr(instance, model._meta.pk.attname, None)\n+                return count, {model._meta.label: count} if count > 0 else {}\n \n         with transaction.atomic(using=self.using, savepoint=False):\n             # send pre_delete signals\n@@ -406,9 +428,16 @@ class Collector:\n                     )\n \n             # fast deletes\n-            for qs in self.fast_deletes:\n-                count = qs._raw_delete(using=self.using)\n-                deleted_counter[qs.model._meta.label] += count\n+\n+        # fast deletes\n+        if len(self.fast_deletes) == 1:\n+            single_qs = self.fast_deletes[0]\n+            try:\n+                with transaction.atomic(using=self.using, savepoint=False):\n+                    count = single_qs._raw_delete(using=self.using)\n+                return count, {single_qs.model._meta.label: count} if count > 0 else {}\n+            except IntegrityError:\n+                pass\n \n             # update fields\n             for model, instances_for_fieldvalues in self.field_updates.items():\n@@ -426,7 +455,13 @@ class Collector:\n                 query = sql.DeleteQuery(model)\n                 pk_list = [obj.pk for obj in instances]\n                 count = query.delete_batch(pk_list, self.using)\n+\n+        if self.can_fast_delete(objs):\n+            self.fast_deletes.append(instances)\n+            count = len(instances)\n+            if count:\n                 deleted_counter[model._meta.label] += count\n+            return count, {model._meta.label: count} if count > 0 else {}\n \n                 if not model._meta.auto_created:\n                     for obj in instances:\n@@ -442,4 +477,13 @@ class Collector:\n         for model, instances in self.data.items():\n             for instance in instances:\n                 setattr(instance, model._meta.pk.attname, None)\n-        return sum(deleted_counter.values()), dict(deleted_counter)\n+\n+        if self.can_fast_delete(objs):\n+            self.fast_deletes.append(objs)\n+            for obj in objs:\n+                obj._state.db = self.using\n+            count = len(objs)\n+            if count:\n+                return count, {model._meta.label: count}\n+            else:\n+                return count, {}\n",
    "variant_5": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 16dff6a1cd..a119fdf653 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -376,6 +376,17 @@ class Collector:\n                 return\n         self.data = {model: self.data[model] for model in sorted_models}\n \n+    def delete(self):\n+        # sort instance collections\n+        for model, instances in self.data.items():\n+            self.data[model] = sorted(instances, key=attrgetter(\"pk\"))\n+\n+        # if possible, bring the models in an order suitable for databases that\n+        # don't support transactions or cannot defer constraint checks until the\n+        # end of a transaction.\n+        self.sort()\n+        # number of objects deleted for each model label\n+\n     def delete(self):\n         # sort instance collections\n         for model, instances in self.data.items():\n@@ -395,7 +406,18 @@ class Collector:\n                 with transaction.mark_for_rollback_on_error():\n                     count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                 setattr(instance, model._meta.pk.attname, None)\n-                return count, {model._meta.label: count}\n+                return count, {model._meta.label: count} if count > 0 else {}\n+\n+        # Optimize for the case with a single obj and no dependencies\n+\n+        # Optimize for the case with a single obj and no dependencies\n+        if len(self.data) == 1 and len(instances) == 1:\n+            instance = list(instances)[0]\n+            if self.can_fast_delete(instance):\n+                with transaction.mark_for_rollback_on_error():\n+                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n+                setattr(instance, model._meta.pk.attname, None)\n+                return count, {model._meta.label: count} if count > 0 else {}\n \n         with transaction.atomic(using=self.using, savepoint=False):\n             # send pre_delete signals\n@@ -406,9 +428,15 @@ class Collector:\n                     )\n \n             # fast deletes\n-            for qs in self.fast_deletes:\n-                count = qs._raw_delete(using=self.using)\n-                deleted_counter[qs.model._meta.label] += count\n+\n+        # fast delete\n+        if self.can_fast_delete(objs):\n+            self.fast_deletes = [objs]\n+            count = len(objs)\n+            if count > 0:\n+                return count, {model._meta.label: count}\n+            else:\n+                return count, {}\n \n             # update fields\n             for model, instances_for_fieldvalues in self.field_updates.items():\n@@ -426,7 +454,16 @@ class Collector:\n                 query = sql.DeleteQuery(model)\n                 pk_list = [obj.pk for obj in instances]\n                 count = query.delete_batch(pk_list, self.using)\n+\n+        if self.can_fast_delete(objs):\n+            self.fast_deletes.append(objs)\n+            for obj in objs:\n+                obj._state.db = self.using\n+            # The fast delete signal will be sent when the queryset is evaluated.\n+            count = qs._raw_delete(using=self.using)\n+            if count:\n                 deleted_counter[model._meta.label] += count\n+            return count, {model._meta.label: count} if count > 0 else {}\n \n                 if not model._meta.auto_created:\n                     for obj in instances:\n@@ -442,4 +479,21 @@ class Collector:\n         for model, instances in self.data.items():\n             for instance in instances:\n                 setattr(instance, model._meta.pk.attname, None)\n-        return sum(deleted_counter.values()), dict(deleted_counter)\n+\n+        # If the queryset is empty, there's nothing to delete.\n+        if not qs:\n+            return 0, {}\n+\n+        # Fast delete path when possible.\n+        if (\n+            self.can_fast_delete(qs) and\n+            len(self.data) == 1 and\n+            model in self.data\n+        ):\n+            # The fast delete path bypasses the collection phase entirely,\n+            # hence we need to special case its handling.\n+            count = qs.count()\n+            if count:\n+                qs.delete()\n+                return count, {model._meta.label: count}\n+            return 0, {}\n",
    "variant_6": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 16dff6a1cd..2ca5f5604d 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -376,6 +376,17 @@ class Collector:\n                 return\n         self.data = {model: self.data[model] for model in sorted_models}\n \n+    def delete(self):\n+        # sort instance collections\n+        for model, instances in self.data.items():\n+            self.data[model] = sorted(instances, key=attrgetter(\"pk\"))\n+\n+        # if possible, bring the models in an order suitable for databases that\n+        # don't support transactions or cannot defer constraint checks until the\n+        # end of a transaction.\n+        self.sort()\n+        # number of objects deleted for each model label\n+\n     def delete(self):\n         # sort instance collections\n         for model, instances in self.data.items():\n@@ -395,7 +406,18 @@ class Collector:\n                 with transaction.mark_for_rollback_on_error():\n                     count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                 setattr(instance, model._meta.pk.attname, None)\n-                return count, {model._meta.label: count}\n+                return count, {model._meta.label: count} if count > 0 else {}\n+\n+        # Optimize for the case with a single obj and no dependencies\n+\n+        # Optimize for the case with a single obj and no dependencies\n+        if len(self.data) == 1 and len(instances) == 1:\n+            instance = list(instances)[0]\n+            if self.can_fast_delete(instance):\n+                with transaction.mark_for_rollback_on_error():\n+                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n+                setattr(instance, model._meta.pk.attname, None)\n+                return count, {model._meta.label: count} if count > 0 else {}\n \n         with transaction.atomic(using=self.using, savepoint=False):\n             # send pre_delete signals\n@@ -406,9 +428,18 @@ class Collector:\n                     )\n \n             # fast deletes\n-            for qs in self.fast_deletes:\n-                count = qs._raw_delete(using=self.using)\n-                deleted_counter[qs.model._meta.label] += count\n+\n+        # fast delete\n+        if len(self.data) == 1 and can_fast_delete(objs):\n+            self.fast_deletes.append(self.data[model])\n+            from django.db import router\n+            if router.allow_migrate(self.using, model):\n+                count = self.data[model].count()\n+                if count:\n+                    self.data[model]._raw_delete(using=self.using)\n+                    return count, {model._meta.label: count}\n+                else:\n+                    return count, {}\n \n             # update fields\n             for model, instances_for_fieldvalues in self.field_updates.items():\n@@ -426,7 +457,21 @@ class Collector:\n                 query = sql.DeleteQuery(model)\n                 pk_list = [obj.pk for obj in instances]\n                 count = query.delete_batch(pk_list, self.using)\n-                deleted_counter[model._meta.label] += count\n+\n+        if self.can_fast_delete(objs):\n+            # fast deletes\n+            for qs in self.fast_deletes:\n+                count = qs._raw_delete(using=self.using)\n+                if count:\n+                    deleted_counter[qs.model._meta.label] += count\n+\n+            # update fields\n+            for model, instances_for_fieldvalues in self.field_updates.items():\n+                for (field, value), instances in instances_for_fieldvalues.items():\n+                    query = sql.UpdateQuery(model)\n+                    query.update_batch([obj.pk for obj in instances],\n+                                       {field.name: value}, self.using)\n+            return sum(deleted_counter.values()), dict(deleted_counter)\n \n                 if not model._meta.auto_created:\n                     for obj in instances:\n@@ -442,4 +487,12 @@ class Collector:\n         for model, instances in self.data.items():\n             for instance in instances:\n                 setattr(instance, model._meta.pk.attname, None)\n-        return sum(deleted_counter.values()), dict(deleted_counter)\n+\n+        if self.can_fast_delete(objs):\n+            # Fast delete path - only proceed if there are objects to delete\n+            if objs:\n+                with transaction.atomic(using=self.using, savepoint=False):\n+                    count = query.delete()\n+            else:\n+                count = 0\n+            return count, {model._meta.label: count} if count > 0 else {}\n",
    "variant_7": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 16dff6a1cd..cdba8af116 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -376,6 +376,17 @@ class Collector:\n                 return\n         self.data = {model: self.data[model] for model in sorted_models}\n \n+    def delete(self):\n+        # sort instance collections\n+        for model, instances in self.data.items():\n+            self.data[model] = sorted(instances, key=attrgetter(\"pk\"))\n+\n+        # if possible, bring the models in an order suitable for databases that\n+        # don't support transactions or cannot defer constraint checks until the\n+        # end of a transaction.\n+        self.sort()\n+        # number of objects deleted for each model label\n+\n     def delete(self):\n         # sort instance collections\n         for model, instances in self.data.items():\n@@ -395,7 +406,18 @@ class Collector:\n                 with transaction.mark_for_rollback_on_error():\n                     count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                 setattr(instance, model._meta.pk.attname, None)\n-                return count, {model._meta.label: count}\n+                return count, {model._meta.label: count} if count > 0 else {}\n+\n+        # Optimize for the case with a single obj and no dependencies\n+\n+        # Optimize for the case with a single obj and no dependencies\n+        if len(self.data) == 1 and len(instances) == 1:\n+            instance = list(instances)[0]\n+            if self.can_fast_delete(instance):\n+                with transaction.mark_for_rollback_on_error():\n+                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n+                setattr(instance, model._meta.pk.attname, None)\n+                return count, {model._meta.label: count} if count > 0 else {}\n \n         with transaction.atomic(using=self.using, savepoint=False):\n             # send pre_delete signals\n@@ -406,9 +428,20 @@ class Collector:\n                     )\n \n             # fast deletes\n-            for qs in self.fast_deletes:\n-                count = qs._raw_delete(using=self.using)\n-                deleted_counter[qs.model._meta.label] += count\n+\n+        # fast deletes\n+        if len(self.fast_deletes) == 1:\n+            single_qs = self.fast_deletes[0]\n+            if single_qs._result_cache is None:\n+                # Check that the query is eligible for fast deletion\n+                model = single_qs.model\n+                if (model._meta.can_migrate(self.using) and\n+                    not any(f.name in model._meta.protected_names for f in model._meta.get_fields())):\n+                    count = single_qs._raw_delete(using=self.using)\n+                    if count:\n+                        return count, {model._meta.label: count}\n+                    else:\n+                        return count, {}\n \n             # update fields\n             for model, instances_for_fieldvalues in self.field_updates.items():\n@@ -426,7 +459,13 @@ class Collector:\n                 query = sql.DeleteQuery(model)\n                 pk_list = [obj.pk for obj in instances]\n                 count = query.delete_batch(pk_list, self.using)\n-                deleted_counter[model._meta.label] += count\n+\n+            # fast deletes\n+            if can_fast_delete:\n+                count = query.delete_batch(pk_list, self.using)\n+                if count:\n+                    deleted_counter[model._meta.label] += count\n+                return count, dict(deleted_counter)\n \n                 if not model._meta.auto_created:\n                     for obj in instances:\n@@ -434,6 +473,21 @@ class Collector:\n                             sender=model, instance=obj, using=self.using\n                         )\n \n+        # update collected instances\n+        for instances_for_fieldvalues in self.field_updates.values():\n+            for (field, value), instances in instances_for_fieldvalues.items():\n+                for obj in instances:\n+                    setattr(obj, field.attname, value)\n+        for model, instances in self.data.items():\n+            for instance in instances:\n+                setattr(instance, model._meta.pk.attname, None)\n+\n+        # fast deletes\n+        for qs in self.fast_deletes:\n+            count = qs._raw_delete(using=self.using, keep_parents=keep_parents)\n+            if count:\n+                deleted_counter[qs.model._meta.label] += count\n+\n         # update collected instances\n         for instances_for_fieldvalues in self.field_updates.values():\n             for (field, value), instances in instances_for_fieldvalues.items():\n",
    "variant_8": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 16dff6a1cd..4fbf9a81ba 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -376,6 +376,17 @@ class Collector:\n                 return\n         self.data = {model: self.data[model] for model in sorted_models}\n \n+    def delete(self):\n+        # sort instance collections\n+        for model, instances in self.data.items():\n+            self.data[model] = sorted(instances, key=attrgetter(\"pk\"))\n+\n+        # if possible, bring the models in an order suitable for databases that\n+        # don't support transactions or cannot defer constraint checks until the\n+        # end of a transaction.\n+        self.sort()\n+        # number of objects deleted for each model label\n+\n     def delete(self):\n         # sort instance collections\n         for model, instances in self.data.items():\n@@ -395,7 +406,18 @@ class Collector:\n                 with transaction.mark_for_rollback_on_error():\n                     count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n                 setattr(instance, model._meta.pk.attname, None)\n-                return count, {model._meta.label: count}\n+                return count, {model._meta.label: count} if count > 0 else {}\n+\n+        # Optimize for the case with a single obj and no dependencies\n+\n+        # Optimize for the case with a single obj and no dependencies\n+        if len(self.data) == 1 and len(instances) == 1:\n+            instance = list(instances)[0]\n+            if self.can_fast_delete(instance):\n+                with transaction.mark_for_rollback_on_error():\n+                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n+                setattr(instance, model._meta.pk.attname, None)\n+                return count, {model._meta.label: count} if count > 0 else {}\n \n         with transaction.atomic(using=self.using, savepoint=False):\n             # send pre_delete signals\n@@ -406,9 +428,15 @@ class Collector:\n                     )\n \n             # fast deletes\n-            for qs in self.fast_deletes:\n-                count = qs._raw_delete(using=self.using)\n-                deleted_counter[qs.model._meta.label] += count\n+\n+        # fast delete\n+        if len(self.data) == 1 and can_fast_delete(objs[0]):\n+            self.fast_deletes = [self.data[model]]\n+            # Don't create a query to delete nothing.\n+            if not self.fast_deletes[0]:\n+                return 0, {}\n+            count = self.fast_deletes[0]._raw_delete(using=self.using)\n+            return count, {model._meta.label: count} if count > 0 else {}\n \n             # update fields\n             for model, instances_for_fieldvalues in self.field_updates.items():\n@@ -426,7 +454,20 @@ class Collector:\n                 query = sql.DeleteQuery(model)\n                 pk_list = [obj.pk for obj in instances]\n                 count = query.delete_batch(pk_list, self.using)\n-                deleted_counter[model._meta.label] += count\n+\n+        if self.can_fast_delete(objs):\n+            self.fast_deletes.append(objs)\n+            for obj in objs:\n+                signals.pre_delete.send(\n+                    sender=model, instance=obj, using=self.using\n+                )\n+            count = query.delete_batch([obj.pk for obj in objs], self.using)\n+            if not model._meta.auto_created:\n+                for obj in objs:\n+                    signals.post_delete.send(\n+                        sender=model, instance=obj, using=self.using\n+                    )\n+            return count, {model._meta.label: count} if count > 0 else {}\n \n                 if not model._meta.auto_created:\n                     for obj in instances:\n@@ -442,4 +483,12 @@ class Collector:\n         for model, instances in self.data.items():\n             for instance in instances:\n                 setattr(instance, model._meta.pk.attname, None)\n-        return sum(deleted_counter.values()), dict(deleted_counter)\n+\n+        if self.can_fast_delete(objs):\n+            # Fast deletes have no dependencies.\n+            with transaction.mark_for_rollback_on_error(using):\n+                count = self.do_sql_delete(main_model, self.get_del_batches(objs, []), using)\n+            if count > 0:\n+                return count, {model._meta.label: count}\n+            else:\n+                return count, {}\n"
  }
}