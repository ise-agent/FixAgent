{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/django/django/db/backends/base/schema.py lines 562-594)": "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs,\n        )\n        if (\n            constraint_kwargs.get(\"unique\") is True\n            and constraint_names\n            and self.connection.features.allows_multiple_constraints_on_same_fields\n        ):\n            # Constraint matching the unique_together name.\n            default_name = str(\n                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n            )\n            if default_name in constraint_names:\n                constraint_names = [default_name]\n        if strict and len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        if constraint_names:\n            self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
    "Location 2 (/root/hy/projects_2/django/django/db/backends/base/schema.py lines 530-535)": "\n    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n        \"\"\"\n        Deal with a model changing its unique_together. The input\n        unique_togethers must be doubly-nested, not the single-nested\n        [\"foo\", \"bar\"] format.\n        \"\"\"\n        olds = {tuple(fields) for fields in old_unique_together}\n        news = {tuple(fields) for fields in new_unique_together}\n        # Deleted uniques\n        for fields in olds.difference(news):\n            self._delete_composed_index(\n                model,\n                fields,\n                {\"unique\": True, \"primary_key\": False},\n                self.sql_delete_unique,\n                strict=False,\n            )\n        # Created uniques\n        for field_names in news.difference(olds):\n            fields = [model._meta.get_field(field) for field in field_names]\n            self.execute(self._create_unique_sql(model, fields))\n",
    "Location 3 (/root/hy/projects_2/django/django/db/backends/base/schema.py lines 551-555)": "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        if strict and len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (len(constraint_names), model._meta.db_table, \", \".join(columns))\n            )\n        for constraint_name in constraint_names:\n            self.execute(sql % {\n                'table': self.quote_name(model._meta.db_table),\n                'name': self.quote_name(constraint_name),\n            })\n",
    "Location 4 (/root/hy/projects_2/django/django/db/backends/base/schema.py lines 585-593)": "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        if (\n            len(constraint_names) > 1\n            and constraint_kwargs.get(\"unique\") is True\n            and constraint_names\n            and self.connection.features.allows_multiple_constraints_on_same_fields\n        ):\n            # Constraint matching the unique_together name.\n            default_name = str(\n                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n            )\n            if default_name in constraint_names:\n                constraint_names = [default_name]\n        if strict and len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        if constraint_names:\n            self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
    "Location 5 (/root/hy/projects_2/django/django/db/backends/base/schema.py lines 527-533)": "\n    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n        \"\"\"\n        Deal with a model changing its unique_together. The input\n        unique_togethers must be doubly-nested, not the single-nested\n        [\"foo\", \"bar\"] format.\n        \"\"\"\n        olds = {tuple(fields) for fields in old_unique_together}\n        news = {tuple(fields) for fields in new_unique_together}\n        # Deleted uniques\n        for fields in olds.difference(news):\n            self._delete_composed_index(\n                model,\n                fields,\n                {\"unique\": True, \"primary_key\": False},\n                self.sql_delete_unique,\n                strict=False\n            )\n        # Created uniques\n        for field_names in news.difference(olds):\n            fields = [model._meta.get_field(field) for field in field_names]\n            self.execute(self._create_unique_sql(model, fields))\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/django/django/db/backends/base/schema.py lines 562-594)": [
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs,\n        )\n        if (\n            constraint_kwargs.get(\"unique\") is True\n            and constraint_names\n            and self.connection.features.allows_multiple_constraints_on_same_fields\n        ):\n            # Constraint matching the unique_together name.\n            default_name = str(\n                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n            )\n            if default_name in constraint_names:\n                constraint_names = [default_name]\n        if strict and len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        if constraint_names:\n            self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs,\n        )\n        if (\n            constraint_kwargs.get(\"unique\") is True\n            and constraint_names\n            and self.connection.features.allows_multiple_constraints_on_same_fields\n        ):\n            # Constraint matching the unique_together name.\n            default_name = str(\n                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n            )\n            if default_name in constraint_names:\n                constraint_names = [default_name]\n        if strict and len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        if constraint_names:\n            self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs,\n        )\n        if (\n            constraint_kwargs.get(\"unique\") is True\n            and constraint_names\n            and self.connection.features.allows_multiple_constraints_on_same_fields\n        ):\n            # Constraint matching the unique_together name.\n            default_name = str(\n                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n            )\n            if default_name in constraint_names:\n                constraint_names = [default_name]\n        if strict and len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        if constraint_names:\n            self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs,\n        )\n        if (\n            constraint_kwargs.get(\"unique\") is True\n            and constraint_names\n            and self.connection.features.allows_multiple_constraints_on_same_fields\n        ):\n            # Constraint matching the unique_together name.\n            default_name = str(\n                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n            )\n            if default_name in constraint_names:\n                constraint_names = [default_name]\n        if strict and len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        if constraint_names:\n            self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs,\n        )\n        if (\n            constraint_kwargs.get(\"unique\") is True\n            and constraint_names\n            and self.connection.features.allows_multiple_constraints_on_same_fields\n        ):\n            # Constraint matching the unique_together name.\n            default_name = str(\n                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n            )\n            if default_name in constraint_names:\n                constraint_names = [default_name]\n        if strict and len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        if constraint_names:\n            self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs,\n        )\n        if (\n            constraint_kwargs.get(\"unique\") is True\n            and constraint_names\n            and self.connection.features.allows_multiple_constraints_on_same_fields\n        ):\n            # Constraint matching the unique_together name.\n            default_name = str(\n                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n            )\n            if default_name in constraint_names:\n                constraint_names = [default_name]\n        if strict and len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        if constraint_names:\n            self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs,\n        )\n        if (\n            constraint_kwargs.get(\"unique\") is True\n            and constraint_names\n            and self.connection.features.allows_multiple_constraints_on_same_fields\n        ):\n            # Constraint matching the unique_together name.\n            default_name = str(\n                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n            )\n            if default_name in constraint_names:\n                constraint_names = [default_name]\n        if strict and len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        if constraint_names:\n            self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model,\n            columns,\n            exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs,\n        )\n        if (\n            constraint_kwargs.get(\"unique\") is True\n            and constraint_names\n            and self.connection.features.allows_multiple_constraints_on_same_fields\n        ):\n            # Constraint matching the unique_together name.\n            default_name = str(\n                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n            )\n            if default_name in constraint_names:\n                constraint_names = [default_name]\n        if strict and len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        if constraint_names:\n            self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n"
    ],
    "Location 2 (/root/hy/projects_2/django/django/db/backends/base/schema.py lines 530-535)": [
      "\n    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n        \"\"\"\n        Deal with a model changing its unique_together. The input\n        unique_togethers must be doubly-nested, not the single-nested\n        [\"foo\", \"bar\"] format.\n        \"\"\"\n        olds = {tuple(fields) for fields in old_unique_together}\n        news = {tuple(fields) for fields in new_unique_together}\n        # Deleted uniques\n        for fields in olds.difference(news):\n            self._delete_composed_index(\n                model,\n                fields,\n                {\"unique\": True, \"primary_key\": False},\n                self.sql_delete_unique,\n                strict=False,\n            )\n        # Created uniques\n        for field_names in news.difference(olds):\n            fields = [model._meta.get_field(field) for field in field_names]\n            self.execute(self._create_unique_sql(model, fields))\n",
      "\n    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n        \"\"\"\n        Deal with a model changing its unique_together. The input\n        unique_togethers must be doubly-nested, not the single-nested\n        [\"foo\", \"bar\"] format.\n        \"\"\"\n        olds = {tuple(fields) for fields in old_unique_together}\n        news = {tuple(fields) for fields in new_unique_together}\n        # Deleted uniques\n        for fields in olds.difference(news):\n            self._delete_composed_index(\n                model,\n                fields,\n                {\"unique\": True, \"primary_key\": False},\n                self.sql_delete_unique,\n                strict=False,\n            )\n",
      "\n    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n        \"\"\"\n        Deal with a model changing its unique_together. The input\n        unique_togethers must be doubly-nested, not the single-nested\n        [\"foo\", \"bar\"] format.\n        \"\"\"\n        olds = {tuple(fields) for fields in old_unique_together}\n        news = {tuple(fields) for fields in new_unique_together}\n        # Deleted uniques\n        for fields in olds.difference(news):\n            self._delete_composed_index(\n                model,\n                fields,\n                {\"unique\": True, \"primary_key\": False},\n                self.sql_delete_unique,\n                strict=False,\n            )\n        # Created uniques\n        for field_names in news.difference(olds):\n            fields = [model._meta.get_field(field) for field in field_names]\n            self.execute(self._create_unique_sql(model, fields))\n",
      "\n    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n        \"\"\"\n        Deal with a model changing its unique_together. The input\n        unique_togethers must be doubly-nested, not the single-nested\n        [\"foo\", \"bar\"] format.\n        \"\"\"\n        olds = {tuple(fields) for fields in old_unique_together}\n        news = {tuple(fields) for fields in new_unique_together}\n        # Deleted uniques\n        for fields in olds.difference(news):\n            self._delete_composed_index(\n                model,\n                fields,\n                {\"unique\": True, \"primary_key\": False},\n                self.sql_delete_unique,\n                strict=False,\n            )\n        # Created uniques\n        for field_names in news.difference(olds):\n            fields = [model._meta.get_field(field) for field in field_names]\n            self.execute(self._create_unique_sql(model, fields))\n",
      "\n    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n        \"\"\"\n        Deal with a model changing its unique_together. The input\n        unique_togethers must be doubly-nested, not the single-nested\n        [\"foo\", \"bar\"] format.\n        \"\"\"\n        olds = {tuple(fields) for fields in old_unique_together}\n        news = {tuple(fields) for fields in new_unique_together}\n        # Deleted uniques\n        for fields in olds.difference(news):\n            self._delete_composed_index(\n                model,\n                fields,\n                {\"unique\": True, \"primary_key\": False},\n                self.sql_delete_unique,\n                strict=False,\n            )\n        # Created uniques\n        for field_names in news.difference(olds):\n            fields = [model._meta.get_field(field) for field in field_names]\n            self.execute(self._create_unique_sql(model, fields))\n",
      "\n    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n        \"\"\"\n        Deal with a model changing its unique_together. The input\n        unique_togethers must be doubly-nested, not the single-nested\n        [\"foo\", \"bar\"] format.\n        \"\"\"\n        olds = {tuple(fields) for fields in old_unique_together}\n        news = {tuple(fields) for fields in new_unique_together}\n        # Deleted uniques\n        for fields in olds.difference(news):\n            self._delete_composed_index(\n                model,\n                fields,\n                {\"unique\": True, \"primary_key\": False},\n                self.sql_delete_unique,\n                strict=False,\n            )\n        # Created uniques\n        for field_names in news.difference(olds):\n            fields = [model._meta.get_field(field) for field in field_names]\n            self.execute(self._create_unique_sql(model, fields))\n",
      "\n    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n        \"\"\"\n        Deal with a model changing its unique_together. The input\n        unique_togethers must be doubly-nested, not the single-nested\n        [\"foo\", \"bar\"] format.\n        \"\"\"\n        olds = {tuple(fields) for fields in old_unique_together}\n        news = {tuple(fields) for fields in new_unique_together}\n        # Deleted uniques\n        for fields in olds.difference(news):\n            self._delete_composed_index(\n                model,\n                fields,\n                {\"unique\": True, \"primary_key\": False},\n                self.sql_delete_unique,\n                strict=False,\n            )\n        # Created uniques\n        for field_names in news.difference(olds):\n            fields = [model._meta.get_field(field) for field in field_names]\n            self.execute(self._create_unique_sql(model, fields))\n",
      "\n    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n        \"\"\"\n        Deal with a model changing its unique_together. The input\n        unique_togethers must be doubly-nested, not the single-nested\n        [\"foo\", \"bar\"] format.\n        \"\"\"\n        olds = {tuple(fields) for fields in old_unique_together}\n        news = {tuple(fields) for fields in new_unique_together}\n        # Deleted uniques\n        for fields in olds.difference(news):\n            self._delete_composed_index(\n                model,\n                fields,\n                {\"unique\": True, \"primary_key\": False},\n                self.sql_delete_unique,\n                strict=False,\n            )\n        # Created uniques\n        for field_names in news.difference(olds):\n            fields = [model._meta.get_field(field) for field in field_names]\n            self.execute(self._create_unique_sql(model, fields))\n"
    ],
    "Location 3 (/root/hy/projects_2/django/django/db/backends/base/schema.py lines 551-555)": [
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        if strict and len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (len(constraint_names), model._meta.db_table, \", \".join(columns))\n            )\n        for constraint_name in constraint_names:\n            self.execute(sql % {\n                'table': self.quote_name(model._meta.db_table),\n                'name': self.quote_name(constraint_name),\n            })\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        if strict and len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (len(constraint_names), model._meta.db_table, \", \".join(columns))\n            )\n        for constraint_name in constraint_names:\n            self.execute(self._delete_constraint_sql(sql, model, constraint_name))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {index.name for index in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        if strict and len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        for constraint_name in constraint_names:\n            self.execute(self._delete_constraint_sql(sql, model, constraint_name))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {index.name for index in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        if strict and len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (len(constraint_names), model._meta.db_table, \", \".join(columns))\n            )\n        for constraint_name in constraint_names:\n            self.execute(sql % {\n                \"table\": self.quote_name(model._meta.db_table),\n                \"name\": self.quote_name(constraint_name),\n            })\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {index.name for index in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        if strict and len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (len(constraint_names), model._meta.db_table, \", \".join(columns))\n            )\n        for constraint_name in constraint_names:\n            self.execute(self._delete_constraint_sql(sql, model, constraint_name))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {index.name for index in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        if strict and len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        for constraint_name in constraint_names:\n            self.execute(sql % {\n                'table': self.quote_name(model._meta.db_table),\n                'name': self.quote_name(constraint_name),\n            })\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        if strict and len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (len(constraint_names), model._meta.db_table, \", \".join(columns))\n            )\n        for constraint_name in constraint_names:\n            self.execute(self._delete_constraint_sql(sql, model, constraint_name))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n        meta_constraint_names = {\n            constraint.name for constraint in model._meta.constraints\n        }\n        meta_index_names = {index.name for index in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        if strict and len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (len(constraint_names), model._meta.db_table, \", \".join(columns))\n            )\n        for constraint_name in constraint_names:\n            self.execute(self._delete_constraint_sql(sql, model, constraint_name))\n"
    ],
    "Location 4 (/root/hy/projects_2/django/django/db/backends/base/schema.py lines 585-593)": [
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        if (\n            len(constraint_names) > 1\n            and constraint_kwargs.get(\"unique\") is True\n            and constraint_names\n            and self.connection.features.allows_multiple_constraints_on_same_fields\n        ):\n            # Constraint matching the unique_together name.\n            default_name = str(\n                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n            )\n            if default_name in constraint_names:\n                constraint_names = [default_name]\n        if strict and len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        if constraint_names:\n            self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        if (\n            len(constraint_names) > 1\n            and constraint_kwargs.get(\"unique\") is True\n            and constraint_names\n            and self.connection.features.allows_multiple_constraints_on_same_fields\n        ):\n            # Constraint matching the unique_together name.\n            default_name = str(\n                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n            )\n            if default_name in constraint_names:\n                constraint_names = [default_name]\n        if strict and len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        if len(constraint_names) == 1:\n            self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names, **constraint_kwargs\n        )\n        if (\n            len(constraint_names) > 1\n            and constraint_kwargs.get(\"unique\") is True\n            and constraint_names\n            and self.connection.features.allows_multiple_constraints_on_same_fields\n        ):\n            # Constraint matching the unique_together name.\n            default_name = str(\n                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n            )\n            if default_name in constraint_names:\n                constraint_names = [default_name]\n        if strict and len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        if constraint_names:\n            self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names\n        )\n        if (\n            len(constraint_names) != 1\n            and constraint_kwargs.get(\"unique\") is True\n            and constraint_names\n            and self.connection.features.allows_multiple_constraints_on_same_fields\n        ):\n            # Constraint matching the unique_together name.\n            default_name = str(\n                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n            )\n            if default_name in constraint_names:\n                constraint_names = [default_name]\n        if strict and len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        if constraint_names:\n            self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names, **constraint_kwargs\n        )\n        if (\n            len(constraint_names) > 1\n            and constraint_kwargs.get(\"unique\") is True\n            and constraint_names\n            and self.connection.features.allows_multiple_constraints_on_same_fields\n        ):\n            # Constraint matching the unique_together name.\n            default_name = str(\n                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n            )\n            if default_name in constraint_names:\n                constraint_names = [default_name]\n        if strict and len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        if constraint_names:\n            self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names, **constraint_kwargs\n        )\n        if (\n            len(constraint_names) != 1\n            and constraint_kwargs.get(\"unique\") is True\n            and constraint_names\n            and self.connection.features.allows_multiple_constraints_on_same_fields\n        ):\n            # Constraint matching the unique_together name.\n            default_name = str(\n                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n            )\n            if default_name in constraint_names:\n                constraint_names = [default_name]\n        if strict and len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        if constraint_names:\n            self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names,\n            **constraint_kwargs\n        )\n        if (\n            len(constraint_names) > 1\n            and constraint_kwargs.get(\"unique\") is True\n            and constraint_names\n            and self.connection.features.allows_multiple_constraints_on_same_fields\n        ):\n            # Constraint matching the unique_together name.\n            default_name = str(\n                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n            )\n            if default_name in constraint_names:\n                constraint_names = [default_name]\n        if strict and len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        if constraint_names:\n            self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n",
      "\n    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n        meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n        columns = [model._meta.get_field(field).column for field in fields]\n        constraint_names = self._constraint_names(\n            model, columns, exclude=meta_constraint_names | meta_index_names, **constraint_kwargs\n        )\n        if (\n            len(constraint_names) > 1\n            and constraint_kwargs.get(\"unique\") is True\n            and constraint_names\n            and self.connection.features.allows_multiple_constraints_on_same_fields\n        ):\n            # Constraint matching the unique_together name.\n            default_name = str(\n                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n            )\n            if default_name in constraint_names:\n                constraint_names = [default_name]\n        if strict and len(constraint_names) != 1:\n            raise ValueError(\n                \"Found wrong number (%s) of constraints for %s(%s)\"\n                % (\n                    len(constraint_names),\n                    model._meta.db_table,\n                    \", \".join(columns),\n                )\n            )\n        if len(constraint_names) == 1:\n            self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n"
    ],
    "Location 5 (/root/hy/projects_2/django/django/db/backends/base/schema.py lines 527-533)": [
      "\n    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n        \"\"\"\n        Deal with a model changing its unique_together. The input\n        unique_togethers must be doubly-nested, not the single-nested\n        [\"foo\", \"bar\"] format.\n        \"\"\"\n        olds = {tuple(fields) for fields in old_unique_together}\n        news = {tuple(fields) for fields in new_unique_together}\n        # Deleted uniques\n        for fields in olds.difference(news):\n            self._delete_composed_index(\n                model,\n                fields,\n                {\"unique\": True, \"primary_key\": False},\n                self.sql_delete_unique,\n                strict=False,\n            )\n        # Created uniques\n        for field_names in news.difference(olds):\n            fields = [model._meta.get_field(field) for field in field_names]\n            self.execute(self._create_unique_sql(model, fields))\n",
      "\n    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n        \"\"\"\n        Deal with a model changing its unique_together. The input\n        unique_togethers must be doubly-nested, not the single-nested\n        [\"foo\", \"bar\"] format.\n        \"\"\"\n        olds = {tuple(fields) for fields in old_unique_together}\n        news = {tuple(fields) for fields in new_unique_together}\n        # Deleted uniques\n        for fields in olds.difference(news):\n            self._delete_composed_index(\n                model,\n                fields,\n                {\"unique\": True, \"primary_key\": False},\n                self.sql_delete_unique,\n                strict=False,\n            )\n        # Created uniques\n        for field_names in news.difference(olds):\n            fields = [model._meta.get_field(field) for field in field_names]\n            self.execute(self._create_unique_sql(model, fields))\n",
      "\n    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n        \"\"\"\n        Deal with a model changing its unique_together. The input\n        unique_togethers must be doubly-nested, not the single-nested\n        [\"foo\", \"bar\"] format.\n        \"\"\"\n        olds = {tuple(fields) for fields in old_unique_together}\n        news = {tuple(fields) for fields in new_unique_together}\n        # Deleted uniques\n        for fields in olds.difference(news):\n            self._delete_composed_index(\n                model,\n                fields,\n                {\"unique\": True, \"primary_key\": False},\n                self.sql_delete_unique,\n                strict=False,\n            )\n",
      "\n    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n        \"\"\"\n        Deal with a model changing its unique_together. The input\n        unique_togethers must be doubly-nested, not the single-nested\n        [\"foo\", \"bar\"] format.\n        \"\"\"\n        olds = {tuple(fields) for fields in old_unique_together}\n        news = {tuple(fields) for fields in new_unique_together}\n        # Deleted uniques\n        for fields in olds.difference(news):\n            self._delete_composed_index(\n                model,\n                fields,\n                {\"unique\": True, \"primary_key\": False},\n                self.sql_delete_unique,\n                strict=False,\n            )\n        # Created uniques\n        for field_names in news.difference(olds):\n            fields = [model._meta.get_field(field) for field in field_names]\n            self.execute(self._create_unique_sql(model, fields))\n",
      "\n    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n        \"\"\"\n        Deal with a model changing its unique_together. The input\n        unique_togethers must be doubly-nested, not the single-nested\n        [\"foo\", \"bar\"] format.\n        \"\"\"\n        olds = {tuple(fields) for fields in old_unique_together}\n        news = {tuple(fields) for fields in new_unique_together}\n        # Deleted uniques\n        for fields in olds.difference(news):\n            self._delete_composed_index(\n                model,\n                fields,\n                {\"unique\": True, \"primary_key\": False},\n                self.sql_delete_unique,\n                strict=False,\n            )\n",
      "\n    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n        \"\"\"\n        Deal with a model changing its unique_together. The input\n        unique_togethers must be doubly-nested, not the single-nested\n        [\"foo\", \"bar\"] format.\n        \"\"\"\n        olds = {tuple(fields) for fields in old_unique_together}\n        news = {tuple(fields) for fields in new_unique_together}\n        # Deleted uniques\n        for fields in olds.difference(news):\n            self._delete_composed_index(\n                model,\n                fields,\n                {\"unique\": True, \"primary_key\": False},\n                self.sql_delete_unique,\n                strict=False,\n            )\n",
      "\n    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n        \"\"\"\n        Deal with a model changing its unique_together. The input\n        unique_togethers must be doubly-nested, not the single-nested\n        [\"foo\", \"bar\"] format.\n        \"\"\"\n        olds = {tuple(fields) for fields in old_unique_together}\n        news = {tuple(fields) for fields in new_unique_together}\n        # Deleted uniques\n        for fields in olds.difference(news):\n            self._delete_composed_index(\n                model,\n                fields,\n                {\"unique\": True, \"primary_key\": False},\n                self.sql_delete_unique,\n                strict=False,\n            )\n        # Created uniques\n        for field_names in news.difference(olds):\n            fields = [model._meta.get_field(field) for field in field_names]\n            self.execute(self._create_unique_sql(model, fields))\n",
      "\n    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n        \"\"\"\n        Deal with a model changing its unique_together. The input\n        unique_togethers must be doubly-nested, not the single-nested\n        [\"foo\", \"bar\"] format.\n        \"\"\"\n        olds = {tuple(fields) for fields in old_unique_together}\n        news = {tuple(fields) for fields in new_unique_together}\n        # Deleted uniques\n        for fields in olds.difference(news):\n            self._delete_composed_index(\n                model,\n                fields,\n                {\"unique\": True, \"primary_key\": False},\n                self.sql_delete_unique,\n                strict=False,\n            )\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 03f0f11507..aa171ef095 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -524,6 +524,7 @@ class BaseDatabaseSchemaEditor:\n         [\"foo\", \"bar\"] format.\n         \"\"\"\n         olds = {tuple(fields) for fields in old_unique_together}\n+\n         news = {tuple(fields) for fields in new_unique_together}\n         # Deleted uniques\n         for fields in olds.difference(news):\n@@ -531,7 +532,9 @@ class BaseDatabaseSchemaEditor:\n                 model,\n                 fields,\n                 {\"unique\": True, \"primary_key\": False},\n+                {\"unique\": True, \"primary_key\": False},\n                 self.sql_delete_unique,\n+                strict=False,\n             )\n         # Created uniques\n         for field_names in news.difference(olds):\n@@ -548,18 +551,22 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_index_together}\n         # Deleted indexes\n         for fields in olds.difference(news):\n+\n             self._delete_composed_index(\n                 model,\n                 fields,\n                 {\"index\": True, \"unique\": False},\n                 self.sql_delete_index,\n+                strict=False,\n+            )\n             )\n         # Created indexes\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields=fields, suffix=\"_idx\"))\n \n-    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n         meta_constraint_names = {\n             constraint.name for constraint in model._meta.constraints\n         }\n@@ -582,7 +589,7 @@ class BaseDatabaseSchemaEditor:\n             )\n             if default_name in constraint_names:\n                 constraint_names = [default_name]\n-        if len(constraint_names) != 1:\n+        if strict and len(constraint_names) != 1:\n             raise ValueError(\n                 \"Found wrong number (%s) of constraints for %s(%s)\"\n                 % (\n@@ -591,6 +598,8 @@ class BaseDatabaseSchemaEditor:\n                     \", \".join(columns),\n                 )\n             )\n+        if constraint_names:\n+            self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def alter_db_table(self, model, old_db_table, new_db_table):\n",
    "variant_0": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 03f0f11507..3b2b037a4e 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -524,6 +524,32 @@ class BaseDatabaseSchemaEditor:\n         [\"foo\", \"bar\"] format.\n         \"\"\"\n         olds = {tuple(fields) for fields in old_unique_together}\n+\n+    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n+        \"\"\"\n+        Deal with a model changing its unique_together. The input\n+        unique_togethers must be doubly-nested, not the single-nested\n+        [\"foo\", \"bar\"] format.\n+        \"\"\"\n+        olds = {tuple(fields) for fields in old_unique_together}\n+        news = {tuple(fields) for fields in new_unique_together}\n+        # Deleted uniques\n+        for fields in olds.difference(news):\n+            self._delete_composed_index(\n+                model,\n+                fields,\n+                {\"unique\": True, \"primary_key\": False},\n+                self.sql_delete_unique,\n+                strict=False\n+            )\n+        # Created uniques\n+        for field_names in news.difference(olds):\n+            fields = [model._meta.get_field(field) for field in field_names]\n+            self.execute(self._create_unique_sql(model, fields))\n+        unique_togethers must be doubly-nested, not the single-nested\n+        [\"foo\", \"bar\"] format.\n+        \"\"\"\n+        olds = {tuple(fields) for fields in old_unique_together}\n         news = {tuple(fields) for fields in new_unique_together}\n         # Deleted uniques\n         for fields in olds.difference(news):\n@@ -532,11 +558,16 @@ class BaseDatabaseSchemaEditor:\n                 fields,\n                 {\"unique\": True, \"primary_key\": False},\n                 self.sql_delete_unique,\n+                strict=False,\n             )\n         # Created uniques\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_unique_sql(model, fields))\n+        # Created uniques\n+        for field_names in news.difference(olds):\n+            fields = [model._meta.get_field(field) for field in field_names]\n+            self.execute(self._create_unique_sql(model, fields))\n \n     def alter_index_together(self, model, old_index_together, new_index_together):\n         \"\"\"\n@@ -548,18 +579,35 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_index_together}\n         # Deleted indexes\n         for fields in olds.difference(news):\n-            self._delete_composed_index(\n-                model,\n-                fields,\n-                {\"index\": True, \"unique\": False},\n-                self.sql_delete_index,\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n+        meta_constraint_names = {\n+            constraint.name for constraint in model._meta.constraints\n+        }\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        constraint_names = self._constraint_names(\n+            model, columns, exclude=meta_constraint_names | meta_index_names,\n+            **constraint_kwargs\n+        )\n+        if strict and len(constraint_names) != 1:\n+            raise ValueError(\n+                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                % (len(constraint_names), model._meta.db_table, \", \".join(columns))\n+            )\n+        for constraint_name in constraint_names:\n+            self.execute(sql % {\n+                'table': self.quote_name(model._meta.db_table),\n+                'name': self.quote_name(constraint_name),\n+            })\n             )\n         # Created indexes\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields=fields, suffix=\"_idx\"))\n \n-    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n         meta_constraint_names = {\n             constraint.name for constraint in model._meta.constraints\n         }\n@@ -582,7 +630,31 @@ class BaseDatabaseSchemaEditor:\n             )\n             if default_name in constraint_names:\n                 constraint_names = [default_name]\n-        if len(constraint_names) != 1:\n+        if strict and len(constraint_names) != 1:\n+            raise ValueError(\n+                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n+            )\n+        if constraint_names:\n+            self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+        )\n+        if (\n+            len(constraint_names) > 1\n+            and constraint_kwargs.get(\"unique\") is True\n+            and constraint_names\n+            and self.connection.features.allows_multiple_constraints_on_same_fields\n+        ):\n+            # Constraint matching the unique_together name.\n+            default_name = str(\n+                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n+            )\n+            if default_name in constraint_names:\n+                constraint_names = [default_name]\n+        if strict and len(constraint_names) != 1:\n             raise ValueError(\n                 \"Found wrong number (%s) of constraints for %s(%s)\"\n                 % (\n@@ -591,6 +663,8 @@ class BaseDatabaseSchemaEditor:\n                     \", \".join(columns),\n                 )\n             )\n+        if constraint_names:\n+            self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def alter_db_table(self, model, old_db_table, new_db_table):\n",
    "variant_1": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 03f0f11507..e0a4d9daa5 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -517,6 +517,14 @@ class BaseDatabaseSchemaEditor:\n         if sql:\n             self.execute(sql)\n \n+    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n+        \"\"\"\n+        Deal with a model changing its unique_together. The input\n+        unique_togethers must be doubly-nested, not the single-nested\n+        [\"foo\", \"bar\"] format.\n+        \"\"\"\n+        olds = {tuple(fields) for fields in old_unique_together}\n+\n     def alter_unique_together(self, model, old_unique_together, new_unique_together):\n         \"\"\"\n         Deal with a model changing its unique_together. The input\n@@ -532,11 +540,34 @@ class BaseDatabaseSchemaEditor:\n                 fields,\n                 {\"unique\": True, \"primary_key\": False},\n                 self.sql_delete_unique,\n+                strict=False,\n             )\n         # Created uniques\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_unique_sql(model, fields))\n+        unique_togethers must be doubly-nested, not the single-nested\n+        [\"foo\", \"bar\"] format.\n+        \"\"\"\n+        olds = {tuple(fields) for fields in old_unique_together}\n+        news = {tuple(fields) for fields in new_unique_together}\n+        # Deleted uniques\n+        for fields in olds.difference(news):\n+            self._delete_composed_index(\n+                model,\n+                fields,\n+                {\"unique\": True, \"primary_key\": False},\n+                self.sql_delete_unique,\n+                strict=False,\n+            )\n+        # Created uniques\n+        for field_names in news.difference(olds):\n+            fields = [model._meta.get_field(field) for field in field_names]\n+            self.execute(self._create_unique_sql(model, fields))\n+        # Created uniques\n+        for field_names in news.difference(olds):\n+            fields = [model._meta.get_field(field) for field in field_names]\n+            self.execute(self._create_unique_sql(model, fields))\n \n     def alter_index_together(self, model, old_index_together, new_index_together):\n         \"\"\"\n@@ -548,18 +579,35 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_index_together}\n         # Deleted indexes\n         for fields in olds.difference(news):\n-            self._delete_composed_index(\n-                model,\n-                fields,\n-                {\"index\": True, \"unique\": False},\n-                self.sql_delete_index,\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n+        meta_constraint_names = {\n+            constraint.name for constraint in model._meta.constraints\n+        }\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        constraint_names = self._constraint_names(\n+            model, columns, exclude=meta_constraint_names | meta_index_names,\n+            **constraint_kwargs\n+        )\n+        if strict and len(constraint_names) != 1:\n+            raise ValueError(\n+                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                % (len(constraint_names), model._meta.db_table, \", \".join(columns))\n+            )\n+        for constraint_name in constraint_names:\n+            self.execute(sql % {\n+                'table': self.quote_name(model._meta.db_table),\n+                'name': self.quote_name(constraint_name),\n+            })\n             )\n         # Created indexes\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields=fields, suffix=\"_idx\"))\n \n-    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n         meta_constraint_names = {\n             constraint.name for constraint in model._meta.constraints\n         }\n@@ -582,7 +630,29 @@ class BaseDatabaseSchemaEditor:\n             )\n             if default_name in constraint_names:\n                 constraint_names = [default_name]\n-        if len(constraint_names) != 1:\n+        if strict and len(constraint_names) != 1:\n+            raise ValueError(\n+                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n+            )\n+        if constraint_names:\n+            self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+            len(constraint_names) > 1\n+            and constraint_kwargs.get(\"unique\") is True\n+            and constraint_names\n+            and self.connection.features.allows_multiple_constraints_on_same_fields\n+        ):\n+            # Constraint matching the unique_together name.\n+            default_name = str(\n+                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n+            )\n+            if default_name in constraint_names:\n+                constraint_names = [default_name]\n+        if strict and len(constraint_names) != 1:\n             raise ValueError(\n                 \"Found wrong number (%s) of constraints for %s(%s)\"\n                 % (\n@@ -591,6 +661,8 @@ class BaseDatabaseSchemaEditor:\n                     \", \".join(columns),\n                 )\n             )\n+        if constraint_names:\n+            self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def alter_db_table(self, model, old_db_table, new_db_table):\n",
    "variant_2": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 03f0f11507..c7988b7452 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -517,6 +517,14 @@ class BaseDatabaseSchemaEditor:\n         if sql:\n             self.execute(sql)\n \n+    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n+        \"\"\"\n+        Deal with a model changing its unique_together. The input\n+        unique_togethers must be doubly-nested, not the single-nested\n+        [\"foo\", \"bar\"] format.\n+        \"\"\"\n+        olds = {tuple(fields) for fields in old_unique_together}\n+\n     def alter_unique_together(self, model, old_unique_together, new_unique_together):\n         \"\"\"\n         Deal with a model changing its unique_together. The input\n@@ -532,6 +540,25 @@ class BaseDatabaseSchemaEditor:\n                 fields,\n                 {\"unique\": True, \"primary_key\": False},\n                 self.sql_delete_unique,\n+                strict=False,\n+            )\n+        # Created uniques\n+        for field_names in news.difference(olds):\n+            fields = [model._meta.get_field(field) for field in field_names]\n+            self.execute(self._create_unique_sql(model, fields))\n+        unique_togethers must be doubly-nested, not the single-nested\n+        [\"foo\", \"bar\"] format.\n+        \"\"\"\n+        olds = {tuple(fields) for fields in old_unique_together}\n+        news = {tuple(fields) for fields in new_unique_together}\n+        # Deleted uniques\n+        for fields in olds.difference(news):\n+            self._delete_composed_index(\n+                model,\n+                fields,\n+                {\"unique\": True, \"primary_key\": False},\n+                self.sql_delete_unique,\n+                strict=False,\n             )\n         # Created uniques\n         for field_names in news.difference(olds):\n@@ -548,18 +575,32 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_index_together}\n         # Deleted indexes\n         for fields in olds.difference(news):\n-            self._delete_composed_index(\n-                model,\n-                fields,\n-                {\"index\": True, \"unique\": False},\n-                self.sql_delete_index,\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n+        meta_constraint_names = {\n+            constraint.name for constraint in model._meta.constraints\n+        }\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        constraint_names = self._constraint_names(\n+            model, columns, exclude=meta_constraint_names | meta_index_names,\n+            **constraint_kwargs\n+        )\n+        if strict and len(constraint_names) != 1:\n+            raise ValueError(\n+                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                % (len(constraint_names), model._meta.db_table, \", \".join(columns))\n+            )\n+        for constraint_name in constraint_names:\n+            self.execute(self._delete_constraint_sql(sql, model, constraint_name))\n             )\n         # Created indexes\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields=fields, suffix=\"_idx\"))\n \n-    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n         meta_constraint_names = {\n             constraint.name for constraint in model._meta.constraints\n         }\n@@ -582,7 +623,29 @@ class BaseDatabaseSchemaEditor:\n             )\n             if default_name in constraint_names:\n                 constraint_names = [default_name]\n-        if len(constraint_names) != 1:\n+        if strict and len(constraint_names) != 1:\n+            raise ValueError(\n+                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n+            )\n+        if constraint_names:\n+            self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+            len(constraint_names) > 1\n+            and constraint_kwargs.get(\"unique\") is True\n+            and constraint_names\n+            and self.connection.features.allows_multiple_constraints_on_same_fields\n+        ):\n+            # Constraint matching the unique_together name.\n+            default_name = str(\n+                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n+            )\n+            if default_name in constraint_names:\n+                constraint_names = [default_name]\n+        if strict and len(constraint_names) != 1:\n             raise ValueError(\n                 \"Found wrong number (%s) of constraints for %s(%s)\"\n                 % (\n@@ -591,6 +654,8 @@ class BaseDatabaseSchemaEditor:\n                     \", \".join(columns),\n                 )\n             )\n+        if len(constraint_names) == 1:\n+            self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def alter_db_table(self, model, old_db_table, new_db_table):\n",
    "variant_3": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 03f0f11507..6ad3d45d1f 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -517,6 +517,14 @@ class BaseDatabaseSchemaEditor:\n         if sql:\n             self.execute(sql)\n \n+    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n+        \"\"\"\n+        Deal with a model changing its unique_together. The input\n+        unique_togethers must be doubly-nested, not the single-nested\n+        [\"foo\", \"bar\"] format.\n+        \"\"\"\n+        olds = {tuple(fields) for fields in old_unique_together}\n+\n     def alter_unique_together(self, model, old_unique_together, new_unique_together):\n         \"\"\"\n         Deal with a model changing its unique_together. The input\n@@ -532,7 +540,26 @@ class BaseDatabaseSchemaEditor:\n                 fields,\n                 {\"unique\": True, \"primary_key\": False},\n                 self.sql_delete_unique,\n+                strict=False,\n             )\n+        unique_togethers must be doubly-nested, not the single-nested\n+        [\"foo\", \"bar\"] format.\n+        \"\"\"\n+        olds = {tuple(fields) for fields in old_unique_together}\n+        news = {tuple(fields) for fields in new_unique_together}\n+        # Deleted uniques\n+        for fields in olds.difference(news):\n+            self._delete_composed_index(\n+                model,\n+                fields,\n+                {\"unique\": True, \"primary_key\": False},\n+                self.sql_delete_unique,\n+                strict=False,\n+            )\n+        # Created uniques\n+        for field_names in news.difference(olds):\n+            fields = [model._meta.get_field(field) for field in field_names]\n+            self.execute(self._create_unique_sql(model, fields))\n         # Created uniques\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n@@ -548,18 +575,36 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_index_together}\n         # Deleted indexes\n         for fields in olds.difference(news):\n-            self._delete_composed_index(\n-                model,\n-                fields,\n-                {\"index\": True, \"unique\": False},\n-                self.sql_delete_index,\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n+        meta_constraint_names = {\n+            constraint.name for constraint in model._meta.constraints\n+        }\n+        meta_index_names = {index.name for index in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        constraint_names = self._constraint_names(\n+            model, columns, exclude=meta_constraint_names | meta_index_names,\n+            **constraint_kwargs\n+        )\n+        if strict and len(constraint_names) != 1:\n+            raise ValueError(\n+                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n+            )\n+        for constraint_name in constraint_names:\n+            self.execute(self._delete_constraint_sql(sql, model, constraint_name))\n             )\n         # Created indexes\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields=fields, suffix=\"_idx\"))\n \n-    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n         meta_constraint_names = {\n             constraint.name for constraint in model._meta.constraints\n         }\n@@ -582,7 +627,28 @@ class BaseDatabaseSchemaEditor:\n             )\n             if default_name in constraint_names:\n                 constraint_names = [default_name]\n-        if len(constraint_names) != 1:\n+        if strict and len(constraint_names) != 1:\n+            raise ValueError(\n+                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n+            )\n+        if constraint_names:\n+            self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+            and constraint_kwargs.get(\"unique\") is True\n+            and constraint_names\n+            and self.connection.features.allows_multiple_constraints_on_same_fields\n+        ):\n+            # Constraint matching the unique_together name.\n+            default_name = str(\n+                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n+            )\n+            if default_name in constraint_names:\n+                constraint_names = [default_name]\n+        if strict and len(constraint_names) != 1:\n             raise ValueError(\n                 \"Found wrong number (%s) of constraints for %s(%s)\"\n                 % (\n@@ -591,6 +657,8 @@ class BaseDatabaseSchemaEditor:\n                     \", \".join(columns),\n                 )\n             )\n+        if constraint_names:\n+            self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def alter_db_table(self, model, old_db_table, new_db_table):\n",
    "variant_4": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 03f0f11507..9cfd5d6b0a 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -517,6 +517,14 @@ class BaseDatabaseSchemaEditor:\n         if sql:\n             self.execute(sql)\n \n+    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n+        \"\"\"\n+        Deal with a model changing its unique_together. The input\n+        unique_togethers must be doubly-nested, not the single-nested\n+        [\"foo\", \"bar\"] format.\n+        \"\"\"\n+        olds = {tuple(fields) for fields in old_unique_together}\n+\n     def alter_unique_together(self, model, old_unique_together, new_unique_together):\n         \"\"\"\n         Deal with a model changing its unique_together. The input\n@@ -532,11 +540,34 @@ class BaseDatabaseSchemaEditor:\n                 fields,\n                 {\"unique\": True, \"primary_key\": False},\n                 self.sql_delete_unique,\n+                strict=False,\n             )\n         # Created uniques\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_unique_sql(model, fields))\n+        unique_togethers must be doubly-nested, not the single-nested\n+        [\"foo\", \"bar\"] format.\n+        \"\"\"\n+        olds = {tuple(fields) for fields in old_unique_together}\n+        news = {tuple(fields) for fields in new_unique_together}\n+        # Deleted uniques\n+        for fields in olds.difference(news):\n+            self._delete_composed_index(\n+                model,\n+                fields,\n+                {\"unique\": True, \"primary_key\": False},\n+                self.sql_delete_unique,\n+                strict=False,\n+            )\n+        # Created uniques\n+        for field_names in news.difference(olds):\n+            fields = [model._meta.get_field(field) for field in field_names]\n+            self.execute(self._create_unique_sql(model, fields))\n+        # Created uniques\n+        for field_names in news.difference(olds):\n+            fields = [model._meta.get_field(field) for field in field_names]\n+            self.execute(self._create_unique_sql(model, fields))\n \n     def alter_index_together(self, model, old_index_together, new_index_together):\n         \"\"\"\n@@ -548,18 +579,35 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_index_together}\n         # Deleted indexes\n         for fields in olds.difference(news):\n-            self._delete_composed_index(\n-                model,\n-                fields,\n-                {\"index\": True, \"unique\": False},\n-                self.sql_delete_index,\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n+        meta_constraint_names = {\n+            constraint.name for constraint in model._meta.constraints\n+        }\n+        meta_index_names = {index.name for index in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        constraint_names = self._constraint_names(\n+            model, columns, exclude=meta_constraint_names | meta_index_names,\n+            **constraint_kwargs\n+        )\n+        if strict and len(constraint_names) != 1:\n+            raise ValueError(\n+                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                % (len(constraint_names), model._meta.db_table, \", \".join(columns))\n+            )\n+        for constraint_name in constraint_names:\n+            self.execute(sql % {\n+                \"table\": self.quote_name(model._meta.db_table),\n+                \"name\": self.quote_name(constraint_name),\n+            })\n             )\n         # Created indexes\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields=fields, suffix=\"_idx\"))\n \n-    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n         meta_constraint_names = {\n             constraint.name for constraint in model._meta.constraints\n         }\n@@ -582,7 +630,28 @@ class BaseDatabaseSchemaEditor:\n             )\n             if default_name in constraint_names:\n                 constraint_names = [default_name]\n-        if len(constraint_names) != 1:\n+        if strict and len(constraint_names) != 1:\n+            raise ValueError(\n+                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n+            )\n+        if constraint_names:\n+            self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+            and constraint_kwargs.get(\"unique\") is True\n+            and constraint_names\n+            and self.connection.features.allows_multiple_constraints_on_same_fields\n+        ):\n+            # Constraint matching the unique_together name.\n+            default_name = str(\n+                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n+            )\n+            if default_name in constraint_names:\n+                constraint_names = [default_name]\n+        if strict and len(constraint_names) != 1:\n             raise ValueError(\n                 \"Found wrong number (%s) of constraints for %s(%s)\"\n                 % (\n@@ -591,6 +660,8 @@ class BaseDatabaseSchemaEditor:\n                     \", \".join(columns),\n                 )\n             )\n+        if constraint_names:\n+            self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def alter_db_table(self, model, old_db_table, new_db_table):\n",
    "variant_5": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 03f0f11507..d480380d3e 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -524,6 +524,28 @@ class BaseDatabaseSchemaEditor:\n         [\"foo\", \"bar\"] format.\n         \"\"\"\n         olds = {tuple(fields) for fields in old_unique_together}\n+\n+    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n+        \"\"\"\n+        Deal with a model changing its unique_together. The input\n+        unique_togethers must be doubly-nested, not the single-nested\n+        [\"foo\", \"bar\"] format.\n+        \"\"\"\n+        olds = {tuple(fields) for fields in old_unique_together}\n+        news = {tuple(fields) for fields in new_unique_together}\n+        # Deleted uniques\n+        for fields in olds.difference(news):\n+            self._delete_composed_index(\n+                model,\n+                fields,\n+                {\"unique\": True, \"primary_key\": False},\n+                self.sql_delete_unique,\n+                strict=False,\n+            )\n+        unique_togethers must be doubly-nested, not the single-nested\n+        [\"foo\", \"bar\"] format.\n+        \"\"\"\n+        olds = {tuple(fields) for fields in old_unique_together}\n         news = {tuple(fields) for fields in new_unique_together}\n         # Deleted uniques\n         for fields in olds.difference(news):\n@@ -532,11 +554,16 @@ class BaseDatabaseSchemaEditor:\n                 fields,\n                 {\"unique\": True, \"primary_key\": False},\n                 self.sql_delete_unique,\n+                strict=False,\n             )\n         # Created uniques\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_unique_sql(model, fields))\n+        # Created uniques\n+        for field_names in news.difference(olds):\n+            fields = [model._meta.get_field(field) for field in field_names]\n+            self.execute(self._create_unique_sql(model, fields))\n \n     def alter_index_together(self, model, old_index_together, new_index_together):\n         \"\"\"\n@@ -548,18 +575,32 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_index_together}\n         # Deleted indexes\n         for fields in olds.difference(news):\n-            self._delete_composed_index(\n-                model,\n-                fields,\n-                {\"index\": True, \"unique\": False},\n-                self.sql_delete_index,\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n+        meta_constraint_names = {\n+            constraint.name for constraint in model._meta.constraints\n+        }\n+        meta_index_names = {index.name for index in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        constraint_names = self._constraint_names(\n+            model, columns, exclude=meta_constraint_names | meta_index_names,\n+            **constraint_kwargs\n+        )\n+        if strict and len(constraint_names) != 1:\n+            raise ValueError(\n+                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                % (len(constraint_names), model._meta.db_table, \", \".join(columns))\n+            )\n+        for constraint_name in constraint_names:\n+            self.execute(self._delete_constraint_sql(sql, model, constraint_name))\n             )\n         # Created indexes\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields=fields, suffix=\"_idx\"))\n \n-    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n         meta_constraint_names = {\n             constraint.name for constraint in model._meta.constraints\n         }\n@@ -582,7 +623,28 @@ class BaseDatabaseSchemaEditor:\n             )\n             if default_name in constraint_names:\n                 constraint_names = [default_name]\n-        if len(constraint_names) != 1:\n+        if strict and len(constraint_names) != 1:\n+            raise ValueError(\n+                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n+            )\n+        if constraint_names:\n+            self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+            and constraint_kwargs.get(\"unique\") is True\n+            and constraint_names\n+            and self.connection.features.allows_multiple_constraints_on_same_fields\n+        ):\n+            # Constraint matching the unique_together name.\n+            default_name = str(\n+                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n+            )\n+            if default_name in constraint_names:\n+                constraint_names = [default_name]\n+        if strict and len(constraint_names) != 1:\n             raise ValueError(\n                 \"Found wrong number (%s) of constraints for %s(%s)\"\n                 % (\n@@ -591,6 +653,8 @@ class BaseDatabaseSchemaEditor:\n                     \", \".join(columns),\n                 )\n             )\n+        if constraint_names:\n+            self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def alter_db_table(self, model, old_db_table, new_db_table):\n",
    "variant_6": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 03f0f11507..8b6938f300 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -517,6 +517,14 @@ class BaseDatabaseSchemaEditor:\n         if sql:\n             self.execute(sql)\n \n+    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n+        \"\"\"\n+        Deal with a model changing its unique_together. The input\n+        unique_togethers must be doubly-nested, not the single-nested\n+        [\"foo\", \"bar\"] format.\n+        \"\"\"\n+        olds = {tuple(fields) for fields in old_unique_together}\n+\n     def alter_unique_together(self, model, old_unique_together, new_unique_together):\n         \"\"\"\n         Deal with a model changing its unique_together. The input\n@@ -532,7 +540,26 @@ class BaseDatabaseSchemaEditor:\n                 fields,\n                 {\"unique\": True, \"primary_key\": False},\n                 self.sql_delete_unique,\n+                strict=False,\n             )\n+        unique_togethers must be doubly-nested, not the single-nested\n+        [\"foo\", \"bar\"] format.\n+        \"\"\"\n+        olds = {tuple(fields) for fields in old_unique_together}\n+        news = {tuple(fields) for fields in new_unique_together}\n+        # Deleted uniques\n+        for fields in olds.difference(news):\n+            self._delete_composed_index(\n+                model,\n+                fields,\n+                {\"unique\": True, \"primary_key\": False},\n+                self.sql_delete_unique,\n+                strict=False,\n+            )\n+        # Created uniques\n+        for field_names in news.difference(olds):\n+            fields = [model._meta.get_field(field) for field in field_names]\n+            self.execute(self._create_unique_sql(model, fields))\n         # Created uniques\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n@@ -548,18 +575,39 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_index_together}\n         # Deleted indexes\n         for fields in olds.difference(news):\n-            self._delete_composed_index(\n-                model,\n-                fields,\n-                {\"index\": True, \"unique\": False},\n-                self.sql_delete_index,\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n+        meta_constraint_names = {\n+            constraint.name for constraint in model._meta.constraints\n+        }\n+        meta_index_names = {index.name for index in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        constraint_names = self._constraint_names(\n+            model, columns, exclude=meta_constraint_names | meta_index_names,\n+            **constraint_kwargs\n+        )\n+        if strict and len(constraint_names) != 1:\n+            raise ValueError(\n+                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n+            )\n+        for constraint_name in constraint_names:\n+            self.execute(sql % {\n+                'table': self.quote_name(model._meta.db_table),\n+                'name': self.quote_name(constraint_name),\n+            })\n             )\n         # Created indexes\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields=fields, suffix=\"_idx\"))\n \n-    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n         meta_constraint_names = {\n             constraint.name for constraint in model._meta.constraints\n         }\n@@ -582,7 +630,28 @@ class BaseDatabaseSchemaEditor:\n             )\n             if default_name in constraint_names:\n                 constraint_names = [default_name]\n-        if len(constraint_names) != 1:\n+        if strict and len(constraint_names) != 1:\n+            raise ValueError(\n+                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n+            )\n+        if constraint_names:\n+            self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+            and constraint_kwargs.get(\"unique\") is True\n+            and constraint_names\n+            and self.connection.features.allows_multiple_constraints_on_same_fields\n+        ):\n+            # Constraint matching the unique_together name.\n+            default_name = str(\n+                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n+            )\n+            if default_name in constraint_names:\n+                constraint_names = [default_name]\n+        if strict and len(constraint_names) != 1:\n             raise ValueError(\n                 \"Found wrong number (%s) of constraints for %s(%s)\"\n                 % (\n@@ -591,6 +660,8 @@ class BaseDatabaseSchemaEditor:\n                     \", \".join(columns),\n                 )\n             )\n+        if constraint_names:\n+            self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def alter_db_table(self, model, old_db_table, new_db_table):\n",
    "variant_7": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 03f0f11507..1090e3be24 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -517,6 +517,14 @@ class BaseDatabaseSchemaEditor:\n         if sql:\n             self.execute(sql)\n \n+    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n+        \"\"\"\n+        Deal with a model changing its unique_together. The input\n+        unique_togethers must be doubly-nested, not the single-nested\n+        [\"foo\", \"bar\"] format.\n+        \"\"\"\n+        olds = {tuple(fields) for fields in old_unique_together}\n+\n     def alter_unique_together(self, model, old_unique_together, new_unique_together):\n         \"\"\"\n         Deal with a model changing its unique_together. The input\n@@ -532,11 +540,34 @@ class BaseDatabaseSchemaEditor:\n                 fields,\n                 {\"unique\": True, \"primary_key\": False},\n                 self.sql_delete_unique,\n+                strict=False,\n             )\n         # Created uniques\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_unique_sql(model, fields))\n+        unique_togethers must be doubly-nested, not the single-nested\n+        [\"foo\", \"bar\"] format.\n+        \"\"\"\n+        olds = {tuple(fields) for fields in old_unique_together}\n+        news = {tuple(fields) for fields in new_unique_together}\n+        # Deleted uniques\n+        for fields in olds.difference(news):\n+            self._delete_composed_index(\n+                model,\n+                fields,\n+                {\"unique\": True, \"primary_key\": False},\n+                self.sql_delete_unique,\n+                strict=False,\n+            )\n+        # Created uniques\n+        for field_names in news.difference(olds):\n+            fields = [model._meta.get_field(field) for field in field_names]\n+            self.execute(self._create_unique_sql(model, fields))\n+        # Created uniques\n+        for field_names in news.difference(olds):\n+            fields = [model._meta.get_field(field) for field in field_names]\n+            self.execute(self._create_unique_sql(model, fields))\n \n     def alter_index_together(self, model, old_index_together, new_index_together):\n         \"\"\"\n@@ -548,18 +579,32 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_index_together}\n         # Deleted indexes\n         for fields in olds.difference(news):\n-            self._delete_composed_index(\n-                model,\n-                fields,\n-                {\"index\": True, \"unique\": False},\n-                self.sql_delete_index,\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n+        meta_constraint_names = {\n+            constraint.name for constraint in model._meta.constraints\n+        }\n+        meta_index_names = {constraint.name for constraint in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        constraint_names = self._constraint_names(\n+            model, columns, exclude=meta_constraint_names | meta_index_names,\n+            **constraint_kwargs\n+        )\n+        if strict and len(constraint_names) != 1:\n+            raise ValueError(\n+                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                % (len(constraint_names), model._meta.db_table, \", \".join(columns))\n+            )\n+        for constraint_name in constraint_names:\n+            self.execute(self._delete_constraint_sql(sql, model, constraint_name))\n             )\n         # Created indexes\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields=fields, suffix=\"_idx\"))\n \n-    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n         meta_constraint_names = {\n             constraint.name for constraint in model._meta.constraints\n         }\n@@ -582,7 +627,29 @@ class BaseDatabaseSchemaEditor:\n             )\n             if default_name in constraint_names:\n                 constraint_names = [default_name]\n-        if len(constraint_names) != 1:\n+        if strict and len(constraint_names) != 1:\n+            raise ValueError(\n+                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n+            )\n+        if constraint_names:\n+            self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+            len(constraint_names) > 1\n+            and constraint_kwargs.get(\"unique\") is True\n+            and constraint_names\n+            and self.connection.features.allows_multiple_constraints_on_same_fields\n+        ):\n+            # Constraint matching the unique_together name.\n+            default_name = str(\n+                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n+            )\n+            if default_name in constraint_names:\n+                constraint_names = [default_name]\n+        if strict and len(constraint_names) != 1:\n             raise ValueError(\n                 \"Found wrong number (%s) of constraints for %s(%s)\"\n                 % (\n@@ -591,6 +658,8 @@ class BaseDatabaseSchemaEditor:\n                     \", \".join(columns),\n                 )\n             )\n+        if constraint_names:\n+            self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def alter_db_table(self, model, old_db_table, new_db_table):\n",
    "variant_8": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 03f0f11507..a631bf8ee7 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -524,6 +524,28 @@ class BaseDatabaseSchemaEditor:\n         [\"foo\", \"bar\"] format.\n         \"\"\"\n         olds = {tuple(fields) for fields in old_unique_together}\n+\n+    def alter_unique_together(self, model, old_unique_together, new_unique_together):\n+        \"\"\"\n+        Deal with a model changing its unique_together. The input\n+        unique_togethers must be doubly-nested, not the single-nested\n+        [\"foo\", \"bar\"] format.\n+        \"\"\"\n+        olds = {tuple(fields) for fields in old_unique_together}\n+        news = {tuple(fields) for fields in new_unique_together}\n+        # Deleted uniques\n+        for fields in olds.difference(news):\n+            self._delete_composed_index(\n+                model,\n+                fields,\n+                {\"unique\": True, \"primary_key\": False},\n+                self.sql_delete_unique,\n+                strict=False,\n+            )\n+        unique_togethers must be doubly-nested, not the single-nested\n+        [\"foo\", \"bar\"] format.\n+        \"\"\"\n+        olds = {tuple(fields) for fields in old_unique_together}\n         news = {tuple(fields) for fields in new_unique_together}\n         # Deleted uniques\n         for fields in olds.difference(news):\n@@ -532,11 +554,16 @@ class BaseDatabaseSchemaEditor:\n                 fields,\n                 {\"unique\": True, \"primary_key\": False},\n                 self.sql_delete_unique,\n+                strict=False,\n             )\n         # Created uniques\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_unique_sql(model, fields))\n+        # Created uniques\n+        for field_names in news.difference(olds):\n+            fields = [model._meta.get_field(field) for field in field_names]\n+            self.execute(self._create_unique_sql(model, fields))\n \n     def alter_index_together(self, model, old_index_together, new_index_together):\n         \"\"\"\n@@ -548,18 +575,32 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_index_together}\n         # Deleted indexes\n         for fields in olds.difference(news):\n-            self._delete_composed_index(\n-                model,\n-                fields,\n-                {\"index\": True, \"unique\": False},\n-                self.sql_delete_index,\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n+        meta_constraint_names = {\n+            constraint.name for constraint in model._meta.constraints\n+        }\n+        meta_index_names = {index.name for index in model._meta.indexes}\n+        columns = [model._meta.get_field(field).column for field in fields]\n+        constraint_names = self._constraint_names(\n+            model, columns, exclude=meta_constraint_names | meta_index_names,\n+            **constraint_kwargs\n+        )\n+        if strict and len(constraint_names) != 1:\n+            raise ValueError(\n+                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                % (len(constraint_names), model._meta.db_table, \", \".join(columns))\n+            )\n+        for constraint_name in constraint_names:\n+            self.execute(self._delete_constraint_sql(sql, model, constraint_name))\n             )\n         # Created indexes\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields=fields, suffix=\"_idx\"))\n \n-    def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+\n+    def _delete_composed_index(self, model, fields, constraint_kwargs, sql, strict=True):\n         meta_constraint_names = {\n             constraint.name for constraint in model._meta.constraints\n         }\n@@ -582,7 +623,28 @@ class BaseDatabaseSchemaEditor:\n             )\n             if default_name in constraint_names:\n                 constraint_names = [default_name]\n-        if len(constraint_names) != 1:\n+        if strict and len(constraint_names) != 1:\n+            raise ValueError(\n+                \"Found wrong number (%s) of constraints for %s(%s)\"\n+                % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n+            )\n+        if constraint_names:\n+            self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+            and constraint_kwargs.get(\"unique\") is True\n+            and constraint_names\n+            and self.connection.features.allows_multiple_constraints_on_same_fields\n+        ):\n+            # Constraint matching the unique_together name.\n+            default_name = str(\n+                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n+            )\n+            if default_name in constraint_names:\n+                constraint_names = [default_name]\n+        if strict and len(constraint_names) != 1:\n             raise ValueError(\n                 \"Found wrong number (%s) of constraints for %s(%s)\"\n                 % (\n@@ -591,6 +653,8 @@ class BaseDatabaseSchemaEditor:\n                     \", \".join(columns),\n                 )\n             )\n+        if len(constraint_names) == 1:\n+            self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def alter_db_table(self, model, old_db_table, new_db_table):\n"
  }
}