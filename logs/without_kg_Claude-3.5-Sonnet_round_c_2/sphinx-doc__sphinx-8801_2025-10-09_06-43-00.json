{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/sphinx/sphinx/ext/autodoc/__init__.py lines 761-769)": "\n            elif (namespace, membername) in attr_docs:\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep documented attributes\n                    keep = True\n                isattr = True\n            else:\n                # Check parent class namespaces for inherited attribute docs\n                found_in_parent = False\n                if self.objpath:\n                    # Build parent class paths by walking up the inheritance hierarchy\n                    for cls in inspect.getmro(self.object)[1:]:  # Skip self.object\n                        if cls is object:\n                            continue\n                        parent_namespace = cls.__module__ + '.' + cls.__qualname__\n                        if (parent_namespace, membername) in attr_docs:\n                            found_in_parent = True\n                            break\n                \n                if found_in_parent:\n                    if want_all and isprivate:\n                        if self.options.private_members is None:\n                            keep = False\n                        else:\n                            keep = membername in self.options.private_members\n                    else:\n                        # keep documented attributes from parent classes\n                        keep = True\n                    isattr = True\n",
    "Location 2 (/root/hy/projects_2/sphinx/sphinx/ext/autodoc/__init__.py lines 783-787)": "\n            else:\n                if (self.options.members is ALL and\n                        is_filtered_inherited_member(membername, obj)):\n                    keep = False\n                else:\n                    # ignore undocumented members if :undoc-members: is not given\n                    # For inherited annotation-only members, check parent class namespaces\n                    if not has_doc and hasattr(obj, '__objclass__'):\n                        # Check if this is an inherited annotation-only attribute\n                        parent_class = obj.__objclass__\n                        if hasattr(parent_class, '__annotations__') and membername in parent_class.__annotations__:\n                            # Build parent namespace and check for docs\n                            parent_module = getattr(parent_class, '__module__', None)\n                            if parent_module:\n                                parent_namespace = f\"{parent_module}.{parent_class.__qualname__}\"\n                                if (parent_namespace, membername) in attr_docs:\n                                    has_doc = True\n                    \n                    keep = has_doc or self.options.undoc_members\n",
    "Location 3 (/root/hy/projects_2/sphinx/sphinx/ext/autodoc/__init__.py lines 697-702)": "\n        # search for members in source code too\n        namespace = '.'.join(self.objpath)  # will be empty for modules\n        \n        # Build list of parent namespaces for inherited member lookup\n        parent_namespaces = []\n        if self.objpath:\n            # Get the class hierarchy for namespace lookup\n            try:\n                current_class = self.object\n                for cls in inspect.getmro(current_class)[1:]:  # Skip self\n                    if hasattr(cls, '__module__') and hasattr(cls, '__qualname__'):\n                        parent_ns = f\"{cls.__module__}.{cls.__qualname__}\"\n                        parent_namespaces.append(parent_ns)\n            except (AttributeError, TypeError):\n                pass\n\n        if self.analyzer:\n            attr_docs = self.analyzer.find_attr_docs()\n        else:\n            attr_docs = {}\n",
    "Location 4 (/root/hy/projects_2/sphinx/sphinx/ext/autodoc/__init__.py lines 713-731)": "\n            doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n                         self.parent, self.object_name)\n            if not isinstance(doc, str):\n                # Ignore non-string __doc__\n                doc = None\n\n            # if the member __doc__ is the same as self's __doc__, it's just\n            # inherited and therefore not the member's doc\n            cls = self.get_attr(member, '__class__', None)\n            if cls:\n                cls_doc = self.get_attr(cls, '__doc__', None)\n                if cls_doc == doc:\n                    doc = None\n\n            # For inherited annotation-only attributes, check parent class namespaces for docs\n            if doc is None and isattr and hasattr(self.object, '__mro__'):\n                for parent_cls in self.object.__mro__[1:]:  # Skip self.object\n                    if hasattr(parent_cls, '__annotations__') and membername in parent_cls.__annotations__:\n                        parent_namespace = parent_cls.__module__ + '.' + parent_cls.__qualname__\n                        if hasattr(self, 'analyzer') and self.analyzer and (parent_namespace, membername) in self.analyzer.attr_docs:\n                            doc = '\\n'.join(self.analyzer.attr_docs[(parent_namespace, membername)])\n                            break\n\n            if isinstance(obj, ObjectMember) and obj.docstring:\n                # hack for ClassDocumenter to inject docstring via ObjectMember\n                doc = obj.docstring\n\n            has_doc = bool(doc)\n",
    "Location 5 (/root/hy/projects_2/sphinx/sphinx/ext/autodoc/__init__.py lines 679-692)": "\n        def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n            if inspect.isclass(self.object):\n                for cls in self.object.__mro__:\n                    if cls.__name__ == self.options.inherited_members and cls != self.object:\n                        # given member is a member of specified *super class*\n                        return True\n                    elif name in cls.__dict__:\n                        return False\n                    elif name in self.get_attr(cls, '__annotations__', {}):\n                        return False\n                    elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n                        return False\n\n            return False\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/sphinx/sphinx/ext/autodoc/__init__.py lines 761-769)": [
      "\n            elif (namespace, membername) in attr_docs:\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep documented attributes\n                    keep = True\n                isattr = True\n            else:\n                # Check parent class namespaces for inherited attribute docs\n                found_in_parent = False\n                if self.object and hasattr(self.object, '__mro__'):\n                    for parent_cls in self.object.__mro__[1:]:  # Skip self\n                        parent_namespace = parent_cls.__module__ + '.' + parent_cls.__qualname__\n                        if (parent_namespace, membername) in attr_docs:\n                            if want_all and isprivate:\n                                if self.options.private_members is None:\n                                    keep = False\n                                else:\n                                    keep = membername in self.options.private_members\n                            else:\n                                # keep documented attributes from parent\n                                keep = True\n                            isattr = True\n                            found_in_parent = True\n                            break\n                \n                if not found_in_parent and (namespace, membername) in attr_docs:\n                    if want_all and isprivate:\n                        if self.options.private_members is None:\n                            keep = False\n                        else:\n                            keep = membername in self.options.private_members\n                    else:\n                        # keep documented attributes\n                        keep = True\n                    isattr = True\n",
      "\n            elif (namespace, membername) in attr_docs:\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep documented attributes\n                    keep = True\n                isattr = True\n            else:\n                # Check parent class namespaces for inherited attribute docs\n                found_in_parent = False\n                if self.objpath:\n                    # Build parent class namespaces by traversing the inheritance hierarchy\n                    for parent_cls in inspect.getmro(self.object)[1:]:  # Skip self.object\n                        if hasattr(parent_cls, '__module__') and hasattr(parent_cls, '__qualname__'):\n                            parent_namespace = f\"{parent_cls.__module__}.{parent_cls.__qualname__}\"\n                            if (parent_namespace, membername) in attr_docs:\n                                found_in_parent = True\n                                break\n                \n                if found_in_parent:\n                    if want_all and isprivate:\n                        if self.options.private_members is None:\n                            keep = False\n                        else:\n                            keep = membername in self.options.private_members\n                    else:\n                        # keep documented attributes from parent classes\n                        keep = True\n                    isattr = True\n",
      "\n            elif (namespace, membername) in attr_docs:\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep documented attributes\n                    keep = True\n                isattr = True\n            elif want_all and isprivate:\n                # Check if this is an inherited annotation-only attribute with docs in parent namespace\n                inherited_attr_docs = False\n                if hasattr(self.object, '__mro__'):\n                    for base in self.object.__mro__[1:]:  # Skip current class\n                        base_namespace = base.__module__ + '.' + base.__qualname__\n                        if (base_namespace, membername) in attr_docs:\n                            inherited_attr_docs = True\n                            break\n                \n                if inherited_attr_docs:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                    isattr = True\n",
      "\n            elif (namespace, membername) in attr_docs:\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep documented attributes\n                    keep = True\n                isattr = True\n            else:\n                # Check parent class namespaces for inherited attribute docs\n                found_in_parent = False\n                if self.analyzer:\n                    for cls in inspect.getmro(self.object)[1:]:  # Skip self.object (current class)\n                        if cls is object:\n                            break\n                        parent_namespace = cls.__module__ + '.' + cls.__qualname__\n                        if (parent_namespace, membername) in attr_docs:\n                            if want_all and isprivate:\n                                if self.options.private_members is None:\n                                    keep = False\n                                else:\n                                    keep = membername in self.options.private_members\n                            else:\n                                # keep documented attributes from parent\n                                keep = True\n                            isattr = True\n                            found_in_parent = True\n                            break\n                \n                if not found_in_parent and (namespace, membername) in attr_docs:\n                    if want_all and isprivate:\n                        if self.options.private_members is None:\n                            keep = False\n                        else:\n                            keep = membername in self.options.private_members\n                    else:\n                        # keep documented attributes\n                        keep = True\n                    isattr = True\n",
      "\n            elif (namespace, membername) in attr_docs:\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep documented attributes\n                    keep = True\n                isattr = True\n            else:\n                # Check parent class namespaces for inherited attribute documentation\n                found_in_parent = False\n                if self.analyzer:\n                    # Build list of parent class namespaces to check\n                    parent_namespaces = []\n                    if hasattr(self.object, '__mro__'):\n                        for base_cls in self.object.__mro__[1:]:  # Skip self\n                            if hasattr(base_cls, '__module__') and hasattr(base_cls, '__qualname__'):\n                                parent_namespace = f\"{base_cls.__module__}.{base_cls.__qualname__}\"\n                                parent_namespaces.append(parent_namespace)\n                    \n                    # Check each parent namespace for attribute documentation\n                    for parent_namespace in parent_namespaces:\n                        if (parent_namespace, membername) in attr_docs:\n                            found_in_parent = True\n                            break\n                \n                if found_in_parent:\n                    if want_all and isprivate:\n                        if self.options.private_members is None:\n                            keep = False\n                        else:\n                            keep = membername in self.options.private_members\n                    else:\n                        # keep documented attributes from parent classes\n                        keep = True\n                    isattr = True\n",
      "\n            elif (namespace, membername) in attr_docs:\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep documented attributes\n                    keep = True\n                isattr = True\n            else:\n                # Check parent class namespaces for inherited attribute docs\n                found_in_parent = False\n                if hasattr(self.object, '__mro__'):\n                    for parent_cls in self.object.__mro__[1:]:  # Skip self\n                        parent_namespace = parent_cls.__module__ + '.' + parent_cls.__qualname__\n                        if (parent_namespace, membername) in attr_docs:\n                            if want_all and isprivate:\n                                if self.options.private_members is None:\n                                    keep = False\n                                else:\n                                    keep = membername in self.options.private_members\n                            else:\n                                # keep documented attributes from parent\n                                keep = True\n                            isattr = True\n                            found_in_parent = True\n                            break\n                \n                if not found_in_parent:\n",
      "\n            elif (namespace, membername) in attr_docs:\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep documented attributes\n                    keep = True\n                isattr = True\n            else:\n                # Check parent class namespaces for inherited attribute documentation\n                found_in_parent = False\n                if self.analyzer:\n                    for cls in inspect.getmro(self.object)[1:]:  # Skip self.object, start from parents\n                        if hasattr(cls, '__module__') and hasattr(cls, '__qualname__'):\n                            parent_namespace = f\"{cls.__module__}.{cls.__qualname__}\"\n                            if (parent_namespace, membername) in attr_docs:\n                                if want_all and isprivate:\n                                    if self.options.private_members is None:\n                                        keep = False\n                                    else:\n                                        keep = membername in self.options.private_members\n                                else:\n                                    # keep documented attributes from parent classes\n                                    keep = True\n                                isattr = True\n                                found_in_parent = True\n                                break\n                \n                if not found_in_parent and want_all and isprivate:\n",
      "\n            elif (namespace, membername) in attr_docs:\n                if want_all and isprivate:\n                    if self.options.private_members is None:\n                        keep = False\n                    else:\n                        keep = membername in self.options.private_members\n                else:\n                    # keep documented attributes\n                    keep = True\n                isattr = True\n            elif is_filtered_inherited_member(membername, obj):\n                # Check for attribute docs in parent class namespaces for inherited members\n                found_in_parent = False\n                if hasattr(self.object, '__mro__'):\n                    for parent_cls in self.object.__mro__[1:]:  # Skip self.object\n                        parent_namespace = parent_cls.__module__ + '.' + parent_cls.__qualname__\n                        if (parent_namespace, membername) in attr_docs:\n                            found_in_parent = True\n                            break\n                \n                if found_in_parent:\n                    if want_all and isprivate:\n                        if self.options.private_members is None:\n                            keep = False\n                        else:\n                            keep = membername in self.options.private_members\n                    else:\n                        # keep documented attributes from parent classes\n                        keep = True\n                    isattr = True\n                else:\n                    if want_all and isprivate:\n                        if has_doc or self.options.undoc_members:\n                            if self.options.private_members is None:\n                                keep = False\n                            elif is_filtered_inherited_member(membername, obj):\n                                keep = False\n                            else:\n                                keep = membername in self.options.private_members\n                        else:\n                            keep = False\n                    else:\n                        # keep it anyway if we want all and it's documented\n                        keep = has_doc or self.options.undoc_members\n"
    ],
    "Location 2 (/root/hy/projects_2/sphinx/sphinx/ext/autodoc/__init__.py lines 783-787)": [
      "\n            else:\n                if (self.options.members is ALL and\n                        is_filtered_inherited_member(membername, obj)):\n                    # For inherited annotation-only attributes, check if they have docs in parent classes\n                    if isinstance(obj, ObjectMember) and obj.skipped is False:\n                        # Check parent class namespaces for attribute documentation\n                        parent_has_doc = False\n                        if hasattr(self.object, '__mro__'):\n                            for parent_cls in self.object.__mro__[1:]:  # Skip self\n                                parent_namespace = parent_cls.__module__ + '.' + parent_cls.__qualname__\n                                if (parent_namespace, membername) in attr_docs:\n                                    parent_has_doc = True\n                                    break\n                        keep = parent_has_doc\n                    else:\n                        keep = False\n                else:\n                    # ignore undocumented members if :undoc-members: is not given\n                    keep = has_doc or self.options.undoc_members\n",
      "\n            else:\n                if (self.options.members is ALL and\n                        is_filtered_inherited_member(membername, obj)):\n                    keep = False\n                else:\n                    # ignore undocumented members if :undoc-members: is not given\n                    # For inherited annotation-only attributes, check parent class namespaces\n                    if not has_doc and isinstance(obj, ObjectMember) and obj.parent:\n                        # Check if this is an inherited annotation-only attribute with docs in parent\n                        parent_cls = obj.parent\n                        while parent_cls and not has_doc:\n                            parent_namespace = parent_cls.__module__ + '.' + parent_cls.__qualname__\n                            if (parent_namespace, membername) in attr_docs:\n                                has_doc = True\n                                break\n                            # Move up the inheritance chain\n                            parent_cls = getattr(parent_cls, '__bases__', [None])[0] if hasattr(parent_cls, '__bases__') and parent_cls.__bases__ else None\n                    \n                    keep = has_doc or self.options.undoc_members\n",
      "\n            else:\n                if (self.options.members is ALL and\n                        is_filtered_inherited_member(membername, obj)):\n                    # For inherited annotation-only attributes, check if they have docs in parent classes\n                    if isinstance(obj, ObjectMember) and obj.skipped is False:\n                        # Check parent class namespaces for attribute documentation\n                        parent_has_doc = False\n                        if hasattr(self.object, '__mro__'):\n                            for parent_cls in self.object.__mro__[1:]:  # Skip self\n                                parent_namespace = parent_cls.__module__ + '.' + parent_cls.__qualname__\n                                if (parent_namespace, membername) in attr_docs:\n                                    parent_has_doc = True\n                                    break\n                        keep = parent_has_doc\n                    else:\n                        keep = False\n                else:\n                    # ignore undocumented members if :undoc-members: is not given\n                    keep = has_doc or self.options.undoc_members\n",
      "\n            else:\n                if (self.options.members is ALL and\n                        is_filtered_inherited_member(membername, obj)):\n                    keep = False\n                else:\n                    # ignore undocumented members if :undoc-members: is not given\n                    # For inherited annotation-only attributes, check parent class namespaces\n                    if not has_doc and isinstance(obj, ObjectMember) and obj.class_ != self.object:\n                        # This is an inherited member, check parent class namespaces for docs\n                        parent_has_doc = False\n                        if self.analyzer:\n                            # Get the parent class namespace\n                            parent_objpath = []\n                            if hasattr(obj.class_, '__module__'):\n                                parent_objpath.append(obj.class_.__module__)\n                            if hasattr(obj.class_, '__qualname__'):\n                                parent_objpath.extend(obj.class_.__qualname__.split('.'))\n                            elif hasattr(obj.class_, '__name__'):\n                                parent_objpath.append(obj.class_.__name__)\n                            \n                            parent_namespace = '.'.join(parent_objpath)\n                            if (parent_namespace, membername) in self.analyzer.attr_docs:\n                                parent_has_doc = True\n                        \n                        keep = parent_has_doc or self.options.undoc_members\n                    else:\n                        keep = has_doc or self.options.undoc_members\n",
      "\n            else:\n                if (self.options.members is ALL and\n                        is_filtered_inherited_member(membername, obj)):\n                    keep = False\n                else:\n                    # Check for documentation in parent class namespaces for inherited members\n                    has_doc_in_parent = False\n                    if isinstance(obj, ObjectMember) and obj.class_ != self.object:\n                        # This is an inherited member, check parent namespaces\n                        for cls in inspect.getmro(self.object)[1:]:  # Skip current class\n                            parent_namespace = cls.__module__ + '.' + cls.__qualname__\n                            if (parent_namespace, membername) in attr_docs:\n                                has_doc_in_parent = True\n                                break\n                    \n                    # ignore undocumented members if :undoc-members: is not given\n                    keep = has_doc or has_doc_in_parent or self.options.undoc_members\n",
      "\n            else:\n                if (self.options.members is ALL and\n                        is_filtered_inherited_member(membername, obj)):\n                    keep = False\n                else:\n                    # ignore undocumented members if :undoc-members: is not given\n                    # but check for inherited annotation docs before marking as undocumented\n                    if not has_doc and isinstance(obj, ObjectMember) and obj.parent != self.object:\n                        # Check if this inherited member has annotation docs in parent classes\n                        for cls in inspect.getmro(self.object):\n                            if cls == self.object:\n                                continue\n                            parent_namespace = '.'.join(self.objpath[:-1] + [cls.__name__])\n                            if (parent_namespace, membername) in attr_docs:\n                                has_doc = True\n                                break\n                    keep = has_doc or self.options.undoc_members\n",
      "\n            else:\n                if (self.options.members is ALL and\n                        is_filtered_inherited_member(membername, obj)):\n                    keep = False\n                else:\n                    # ignore undocumented members if :undoc-members: is not given\n                    # For inherited annotation-only attributes, check parent class namespaces\n                    if not has_doc and isinstance(obj, ObjectMember) and obj.class_:\n                        # Check if this is an inherited annotation-only attribute with docs in parent\n                        parent_namespace = '.'.join(obj.class_.__module__.split('.') + [obj.class_.__qualname__])\n                        if (parent_namespace, membername) in attr_docs:\n                            has_doc = True\n                    keep = has_doc or self.options.undoc_members\n",
      "\n            else:\n                if (self.options.members is ALL and\n                        is_filtered_inherited_member(membername, obj)):\n                    # For inherited annotation-only attributes, check if they have docs in parent classes\n                    if isinstance(obj, ObjectMember) and obj.skipped is False:\n                        # Check parent class namespaces for attribute documentation\n                        parent_has_doc = False\n                        if hasattr(self.object, '__mro__'):\n                            for parent_cls in self.object.__mro__[1:]:  # Skip self.object\n                                parent_namespace = parent_cls.__module__ + '.' + parent_cls.__qualname__\n                                if (parent_namespace, membername) in attr_docs:\n                                    parent_has_doc = True\n                                    break\n                        keep = parent_has_doc\n                    else:\n                        keep = False\n                else:\n                    # ignore undocumented members if :undoc-members: is not given\n                    keep = has_doc or self.options.undoc_members\n"
    ],
    "Location 3 (/root/hy/projects_2/sphinx/sphinx/ext/autodoc/__init__.py lines 697-702)": [
      "\n        namespace = '.'.join(self.objpath)  # will be empty for modules\n        \n        # Build list of namespaces to check for inherited attribute docs\n        parent_namespaces = []\n        if self.objpath:\n            # Add current class namespace\n            parent_namespaces.append(namespace)\n            # Add parent class namespaces for inherited members\n            for cls in inspect.getmro(self.object)[1:]:  # Skip self.object\n                if cls is object:\n                    break\n                parent_ns = '.'.join(self.objpath[:-1] + [cls.__name__])\n                if parent_ns not in parent_namespaces:\n                    parent_namespaces.append(parent_ns)\n\n        if self.analyzer:\n            attr_docs = self.analyzer.find_attr_docs()\n        else:\n            attr_docs = {}\n",
      "\n        # search for members in source code too\n        namespace = '.'.join(self.objpath)  # will be empty for modules\n        \n        # Build list of parent namespaces for inherited member lookup\n        parent_namespaces = []\n        if self.objpath and hasattr(self.object, '__mro__'):\n            for cls in self.object.__mro__[1:]:  # Skip self, start from parent\n                if hasattr(cls, '__module__') and hasattr(cls, '__qualname__'):\n                    parent_ns = f\"{cls.__module__}.{cls.__qualname__}\"\n                    parent_namespaces.append(parent_ns)\n\n        if self.analyzer:\n            attr_docs = self.analyzer.find_attr_docs()\n        else:\n            attr_docs = {}\n",
      "\n        # search for members in source code too\n        namespace = '.'.join(self.objpath)  # will be empty for modules\n        \n        # Build list of parent namespaces for inherited member lookup\n        parent_namespaces = []\n        if self.object and hasattr(self.object, '__mro__'):\n            for cls in self.object.__mro__[1:]:  # Skip self, start from parents\n                if hasattr(cls, '__module__') and hasattr(cls, '__qualname__'):\n                    parent_ns = f\"{cls.__module__}.{cls.__qualname__}\"\n                    parent_namespaces.append(parent_ns)\n\n        if self.analyzer:\n            attr_docs = self.analyzer.find_attr_docs()\n        else:\n            attr_docs = {}\n",
      "\n        namespace = '.'.join(self.objpath)  # will be empty for modules\n        \n        # Build list of namespaces to check for inherited attribute docs\n        parent_namespaces = []\n        if self.objpath:\n            # Add current class namespace\n            parent_namespaces.append(namespace)\n            # Add parent class namespaces for inherited member lookup\n            try:\n                for cls in inspect.getmro(self.object)[1:]:  # Skip self.object\n                    if hasattr(cls, '__module__') and hasattr(cls, '__qualname__'):\n                        parent_ns = f\"{cls.__module__}.{cls.__qualname__}\"\n                        if parent_ns not in parent_namespaces:\n                            parent_namespaces.append(parent_ns)\n            except (AttributeError, TypeError):\n                pass\n\n        if self.analyzer:\n            attr_docs = self.analyzer.find_attr_docs()\n        else:\n            attr_docs = {}\n",
      "\n        # search for members in source code too\n        namespace = '.'.join(self.objpath)  # will be empty for modules\n        \n        # Build list of parent namespaces for inherited member lookup\n        parent_namespaces = []\n        if hasattr(self.object, '__mro__'):\n            for cls in self.object.__mro__[1:]:  # Skip self.object (current class)\n                if hasattr(cls, '__module__') and hasattr(cls, '__qualname__'):\n                    parent_ns = f\"{cls.__module__}.{cls.__qualname__}\"\n                    parent_namespaces.append(parent_ns)\n\n        if self.analyzer:\n            attr_docs = self.analyzer.find_attr_docs()\n        else:\n            attr_docs = {}\n",
      "\n        namespace = '.'.join(self.objpath)  # will be empty for modules\n\n        if self.analyzer:\n            attr_docs = self.analyzer.find_attr_docs()\n        else:\n            attr_docs = {}\n        \n        # Build namespace hierarchy for inherited member lookup\n        namespace_hierarchy = [namespace]\n        if hasattr(self.object, '__mro__'):\n            for base_cls in self.object.__mro__[1:]:  # Skip self\n                if hasattr(base_cls, '__module__') and hasattr(base_cls, '__qualname__'):\n                    base_namespace = f\"{base_cls.__module__}.{base_cls.__qualname__}\"\n                    if base_namespace not in namespace_hierarchy:\n                        namespace_hierarchy.append(base_namespace)\n",
      "\n        # search for members in source code too\n        namespace = '.'.join(self.objpath)  # will be empty for modules\n        \n        # Build list of parent namespaces for inherited member lookup\n        parent_namespaces = []\n        if self.objpath and hasattr(self.object, '__mro__'):\n            for cls in self.object.__mro__[1:]:  # Skip self, start from parent\n                if hasattr(cls, '__module__') and hasattr(cls, '__qualname__'):\n                    parent_ns = f\"{cls.__module__}.{cls.__qualname__}\"\n                    parent_namespaces.append(parent_ns)\n\n        if self.analyzer:\n            attr_docs = self.analyzer.find_attr_docs()\n        else:\n            attr_docs = {}\n",
      "\n        # search for members in source code too\n        namespace = '.'.join(self.objpath)  # will be empty for modules\n        \n        # Build list of parent namespaces for inherited member lookup\n        parent_namespaces = []\n        if hasattr(self.object, '__mro__'):\n            for cls in self.object.__mro__[1:]:  # Skip self\n                if hasattr(cls, '__module__') and hasattr(cls, '__qualname__'):\n                    parent_ns = f\"{cls.__module__}.{cls.__qualname__}\"\n                    parent_namespaces.append(parent_ns)\n\n        if self.analyzer:\n            attr_docs = self.analyzer.find_attr_docs()\n        else:\n            attr_docs = {}\n"
    ],
    "Location 4 (/root/hy/projects_2/sphinx/sphinx/ext/autodoc/__init__.py lines 713-731)": [
      "\n            doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n                         self.parent, self.object_name)\n            if not isinstance(doc, str):\n                # Ignore non-string __doc__\n                doc = None\n\n            # if the member __doc__ is the same as self's __doc__, it's just\n            # inherited and therefore not the member's doc\n            cls = self.get_attr(member, '__class__', None)\n            if cls:\n                cls_doc = self.get_attr(cls, '__doc__', None)\n                if cls_doc == doc:\n                    doc = None\n\n            # For inherited annotation-only attributes, check if doc is available\n            # in parent class attribute docs when regular getdoc fails\n            if not doc and member is INSTANCEATTR:\n                # Check if this is an inherited annotation-only attribute\n                for cls in inspect.getmro(self.object):\n                    if hasattr(cls, '__annotations__') and membername in cls.__annotations__:\n                        parent_namespace = cls.__module__ + '.' + cls.__qualname__\n                        if (parent_namespace, membername) in attr_docs:\n                            doc = '\\n'.join(attr_docs[(parent_namespace, membername)])\n                            break\n\n            if isinstance(obj, ObjectMember) and obj.docstring:\n                # hack for ClassDocumenter to inject docstring via ObjectMember\n                doc = obj.docstring\n\n            has_doc = bool(doc)\n",
      "\n            doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n                         self.parent, self.object_name)\n            if not isinstance(doc, str):\n                # Ignore non-string __doc__\n                doc = None\n\n            # if the member __doc__ is the same as self's __doc__, it's just\n            # inherited and therefore not the member's doc\n            cls = self.get_attr(member, '__class__', None)\n            if cls:\n                cls_doc = self.get_attr(cls, '__doc__', None)\n                if cls_doc == doc:\n                    doc = None\n\n            # For inherited annotation-only attributes, check parent class documentation\n            if doc is None and isinstance(obj, ObjectMember) and obj.skipped:\n                # Check if this is an inherited annotation-only attribute\n                for parent_cls in inspect.getmro(self.object)[1:]:\n                    if hasattr(parent_cls, '__annotations__') and membername in parent_cls.__annotations__:\n                        # Try to get documentation from parent class analyzer\n                        try:\n                            parent_module = inspect.getmodule(parent_cls)\n                            if parent_module:\n                                parent_analyzer = ModuleAnalyzer.for_module(parent_module.__name__)\n                                parent_analyzer.find_attr_docs()\n                                parent_namespace = '.'.join([parent_cls.__module__, parent_cls.__qualname__])\n                                if (parent_namespace, membername) in parent_analyzer.attr_docs:\n                                    doc = '\\n'.join(parent_analyzer.attr_docs[parent_namespace, membername])\n                                    break\n                        except (PycodeError, AttributeError):\n                            continue\n\n            if isinstance(obj, ObjectMember) and obj.docstring:\n                # hack for ClassDocumenter to inject docstring via ObjectMember\n                doc = obj.docstring\n\n            has_doc = bool(doc)\n",
      "\n            doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n                         self.parent, self.object_name)\n            if not isinstance(doc, str):\n                # Ignore non-string __doc__\n                doc = None\n\n            # if the member __doc__ is the same as self's __doc__, it's just\n            # inherited and therefore not the member's doc\n            cls = self.get_attr(member, '__class__', None)\n            if cls:\n                cls_doc = self.get_attr(cls, '__doc__', None)\n                if cls_doc == doc:\n                    doc = None\n\n            # For inherited annotation-only attributes, check parent class namespaces for docs\n            if not doc and member is INSTANCEATTR:\n                # Check if this is an inherited annotation-only attribute\n                if hasattr(self.object, '__mro__'):\n                    for base_cls in self.object.__mro__[1:]:  # Skip self.object\n                        if hasattr(base_cls, '__annotations__') and membername in base_cls.__annotations__:\n                            # Try to get docs from parent class namespace\n                            base_namespace = base_cls.__module__ + '.' + base_cls.__qualname__\n                            if (base_namespace, membername) in attr_docs:\n                                doc = '\\n'.join(attr_docs[(base_namespace, membername)])\n                                break\n\n            if isinstance(obj, ObjectMember) and obj.docstring:\n                # hack for ClassDocumenter to inject docstring via ObjectMember\n                doc = obj.docstring\n\n            has_doc = bool(doc)\n",
      "\n            doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n                         self.parent, self.object_name)\n            if not isinstance(doc, str):\n                # Ignore non-string __doc__\n                doc = None\n\n            # if the member __doc__ is the same as self's __doc__, it's just\n            # inherited and therefore not the member's doc\n            cls = self.get_attr(member, '__class__', None)\n            if cls:\n                cls_doc = self.get_attr(cls, '__doc__', None)\n                if cls_doc == doc:\n                    doc = None\n\n            # For inherited annotation-only attributes, check parent class namespaces\n            # for attribute documentation when primary doc extraction fails\n            if not doc and member is INSTANCEATTR:\n                # Check if this is an inherited annotation-only attribute\n                for cls in inspect.getmro(self.object):\n                    if cls is self.object:\n                        continue\n                    if hasattr(cls, '__annotations__') and membername in cls.__annotations__:\n                        # Found the parent class with this annotation, check its namespace\n                        parent_namespace = cls.__module__ + '.' + cls.__qualname__\n                        if hasattr(self.analyzer, 'attr_docs') and self.analyzer.attr_docs:\n                            if (parent_namespace, membername) in self.analyzer.attr_docs:\n                                doc = '\\n'.join(self.analyzer.attr_docs[parent_namespace, membername])\n                                break\n\n            if isinstance(obj, ObjectMember) and obj.docstring:\n                # hack for ClassDocumenter to inject docstring via ObjectMember\n                doc = obj.docstring\n\n            has_doc = bool(doc)\n",
      "\n            doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n                         self.parent, self.object_name)\n            if not isinstance(doc, str):\n                # Ignore non-string __doc__\n                doc = None\n\n            # if the member __doc__ is the same as self's __doc__, it's just\n            # inherited and therefore not the member's doc\n            cls = self.get_attr(member, '__class__', None)\n            if cls:\n                cls_doc = self.get_attr(cls, '__doc__', None)\n                if cls_doc == doc:\n                    doc = None\n\n            # For inherited annotation-only attributes, check parent class namespaces\n            # for attribute documentation when regular doc extraction fails\n            if not doc and isattr and hasattr(self.object, '__mro__'):\n                for parent_cls in self.object.__mro__[1:]:  # Skip self.object\n                    if hasattr(parent_cls, '__annotations__') and membername in parent_cls.__annotations__:\n                        parent_namespace = parent_cls.__module__ + '.' + parent_cls.__qualname__\n                        if (parent_namespace, membername) in attr_docs:\n                            doc = '\\n'.join(attr_docs[(parent_namespace, membername)])\n                            break\n\n            if isinstance(obj, ObjectMember) and obj.docstring:\n                # hack for ClassDocumenter to inject docstring via ObjectMember\n                doc = obj.docstring\n\n            has_doc = bool(doc)\n",
      "\n            doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n                         self.parent, self.object_name)\n            if not isinstance(doc, str):\n                # Ignore non-string __doc__\n                doc = None\n\n            # if the member __doc__ is the same as self's __doc__, it's just\n            # inherited and therefore not the member's doc\n            cls = self.get_attr(member, '__class__', None)\n            if cls:\n                cls_doc = self.get_attr(cls, '__doc__', None)\n                if cls_doc == doc:\n                    doc = None\n\n            # For inherited annotation-only attributes, check parent class namespaces\n            # for attribute documentation when getdoc fails\n            if not doc and isattr and member is INSTANCEATTR:\n                # Build list of parent class namespaces to check\n                parent_namespaces = []\n                for cls in inspect.getmro(self.object):\n                    if cls is self.object:\n                        continue\n                    cls_path = []\n                    if hasattr(cls, '__module__') and cls.__module__:\n                        cls_path.append(cls.__module__)\n                    if hasattr(cls, '__qualname__'):\n                        cls_path.append(cls.__qualname__)\n                    elif hasattr(cls, '__name__'):\n                        cls_path.append(cls.__name__)\n                    if cls_path:\n                        parent_namespaces.append('.'.join(cls_path))\n                \n                # Check each parent namespace for attribute docs\n                for parent_ns in parent_namespaces:\n                    if (parent_ns, membername) in attr_docs:\n                        doc = '\\n'.join(attr_docs[(parent_ns, membername)])\n                        break\n\n            if isinstance(obj, ObjectMember) and obj.docstring:\n                # hack for ClassDocumenter to inject docstring via ObjectMember\n                doc = obj.docstring\n\n            has_doc = bool(doc)\n",
      "\n            doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n                         self.parent, self.object_name)\n            if not isinstance(doc, str):\n                # Ignore non-string __doc__\n                doc = None\n\n            # if the member __doc__ is the same as self's __doc__, it's just\n            # inherited and therefore not the member's doc\n            cls = self.get_attr(member, '__class__', None)\n            if cls:\n                cls_doc = self.get_attr(cls, '__doc__', None)\n                if cls_doc == doc:\n                    doc = None\n\n            # For inherited annotation-only attributes, try to get doc from parent classes\n            if doc is None and member is INSTANCEATTR:\n                # Check if this is an inherited annotation-only attribute\n                for cls in inspect.getmro(self.object):\n                    if cls is self.object:\n                        continue\n                    if hasattr(cls, '__annotations__') and membername in cls.__annotations__:\n                        # Found the class that defines this annotation, try to get its attr_docs\n                        try:\n                            parent_analyzer = ModuleAnalyzer.for_module(cls.__module__)\n                            parent_attr_docs = parent_analyzer.find_attr_docs()\n                            parent_namespace = cls.__module__ + '.' + cls.__qualname__\n                            if (parent_namespace, membername) in parent_attr_docs:\n                                doc = '\\n'.join(parent_attr_docs[(parent_namespace, membername)])\n                                break\n                        except (PycodeError, AttributeError):\n                            continue\n\n            if isinstance(obj, ObjectMember) and obj.docstring:\n                # hack for ClassDocumenter to inject docstring via ObjectMember\n                doc = obj.docstring\n\n            has_doc = bool(doc)\n",
      "\n            doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n                         self.parent, self.object_name)\n            if not isinstance(doc, str):\n                # Ignore non-string __doc__\n                doc = None\n\n            # if the member __doc__ is the same as self's __doc__, it's just\n            # inherited and therefore not the member's doc\n            cls = self.get_attr(member, '__class__', None)\n            if cls:\n                cls_doc = self.get_attr(cls, '__doc__', None)\n                if cls_doc == doc:\n                    doc = None\n\n            # For inherited annotation-only attributes, check parent class namespaces\n            # for attribute documentation when regular doc extraction fails\n            if not doc and member is INSTANCEATTR:\n                # Check if this is an inherited annotation-only attribute\n                for cls in inspect.getmro(self.object):\n                    if cls is self.object:\n                        continue\n                    if hasattr(cls, '__annotations__') and membername in cls.__annotations__:\n                        # Found the class where this annotation is defined\n                        parent_namespace = cls.__module__ + '.' + cls.__qualname__\n                        if hasattr(self, 'analyzer') and self.analyzer and self.analyzer.attr_docs:\n                            if (parent_namespace, membername) in self.analyzer.attr_docs:\n                                doc = '\\n'.join(self.analyzer.attr_docs[parent_namespace, membername])\n                                break\n\n            if isinstance(obj, ObjectMember) and obj.docstring:\n                # hack for ClassDocumenter to inject docstring via ObjectMember\n                doc = obj.docstring\n\n            has_doc = bool(doc)\n"
    ],
    "Location 5 (/root/hy/projects_2/sphinx/sphinx/ext/autodoc/__init__.py lines 679-692)": [
      "\n        def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n            if inspect.isclass(self.object):\n                for cls in self.object.__mro__:\n                    if cls.__name__ == self.options.inherited_members and cls != self.object:\n                        # given member is a member of specified *super class*\n                        return True\n                    elif name in cls.__dict__:\n                        return False\n                    elif name in self.get_attr(cls, '__annotations__', {}):\n                        return False\n                    elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n                        return False\n\n            return False\n",
      "\n        def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n            if inspect.isclass(self.object):\n                for cls in self.object.__mro__:\n                    if cls.__name__ == self.options.inherited_members and cls != self.object:\n                        # given member is a member of specified *super class*\n                        return True\n                    elif name in cls.__dict__:\n                        return False\n                    elif name in self.get_attr(cls, '__annotations__', {}):\n                        return False\n                    elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n                        return False\n\n            return False\n",
      "\n        def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n            if inspect.isclass(self.object):\n                for cls in self.object.__mro__:\n                    if cls.__name__ == self.options.inherited_members and cls != self.object:\n                        # given member is a member of specified *super class*\n                        return True\n                    elif name in cls.__dict__:\n                        return False\n                    elif name in self.get_attr(cls, '__annotations__', {}):\n                        return False\n                    elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n                        return False\n\n            return False\n",
      "\n        def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n            if inspect.isclass(self.object):\n                for cls in self.object.__mro__:\n                    if cls.__name__ == self.options.inherited_members and cls != self.object:\n                        # given member is a member of specified *super class*\n                        return True\n                    elif name in cls.__dict__:\n                        return False\n                    elif name in self.get_attr(cls, '__annotations__', {}):\n                        return False\n                    elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n                        return False\n\n            return False\n",
      "\n        def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n            if inspect.isclass(self.object):\n                for cls in self.object.__mro__:\n                    if cls.__name__ == self.options.inherited_members and cls != self.object:\n                        # given member is a member of specified *super class*\n                        return True\n                    elif name in cls.__dict__:\n                        return False\n                    elif name in self.get_attr(cls, '__annotations__', {}):\n                        return False\n                    elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n                        return False\n\n            return False\n",
      "\n        def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n            if inspect.isclass(self.object):\n                for cls in self.object.__mro__:\n                    if cls.__name__ == self.options.inherited_members and cls != self.object:\n                        # given member is a member of specified *super class*\n                        return True\n                    elif name in cls.__dict__:\n                        return False\n                    elif name in self.get_attr(cls, '__annotations__', {}):\n                        return False\n                    elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n                        return False\n\n            return False\n",
      "\n        def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n            if inspect.isclass(self.object):\n                for cls in self.object.__mro__:\n                    if cls.__name__ == self.options.inherited_members and cls != self.object:\n                        # given member is a member of specified *super class*\n                        return True\n                    elif name in cls.__dict__:\n                        return False\n                    elif name in self.get_attr(cls, '__annotations__', {}):\n                        return False\n                    elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n                        return False\n\n            return False\n",
      "\n        def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n            if inspect.isclass(self.object):\n                for cls in self.object.__mro__:\n                    if cls.__name__ == self.options.inherited_members and cls != self.object:\n                        # given member is a member of specified *super class*\n                        return True\n                    elif name in cls.__dict__:\n                        return False\n                    elif name in self.get_attr(cls, '__annotations__', {}):\n                        return False\n                    elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n                        return False\n\n            return False\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex dc413b5c2..ced0f8d55 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -676,6 +676,7 @@ class Documenter:\n         The user can override the skipping decision by connecting to the\n         ``autodoc-skip-member`` event.\n         \"\"\"\n+\n         def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n             if inspect.isclass(self.object):\n                 for cls in self.object.__mro__:\n@@ -694,6 +695,7 @@ class Documenter:\n         ret = []\n \n         # search for members in source code too\n+\n         namespace = '.'.join(self.objpath)  # will be empty for modules\n \n         if self.analyzer:\n@@ -710,6 +712,7 @@ class Documenter:\n             else:\n                 isattr = False\n \n+\n             doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n                          self.parent, self.object_name)\n             if not isinstance(doc, str):\n@@ -728,6 +731,21 @@ class Documenter:\n                 # hack for ClassDocumenter to inject docstring via ObjectMember\n                 doc = obj.docstring\n \n+            # For inherited annotation-only attributes, check if documentation exists in parent classes\n+            if (not doc and inspect.isclass(self.object) and \n+                self.options.inherited_members and \n+                membername in self.get_attr(self.object, '__annotations__', {})):\n+                # Check parent class namespaces for attribute documentation\n+                for cls in self.object.__mro__[1:]:  # Skip self.object\n+                    if cls.__name__ == 'object':\n+                        break\n+                    parent_objpath = self.objpath[:-1] + [cls.__name__]\n+                    parent_namespace = '.'.join(parent_objpath)\n+                    if (parent_namespace, membername) in attr_docs:\n+                        # Found documentation in parent class\n+                        doc = \"inherited annotation attribute\"  # Placeholder to indicate documented\n+                        break\n+\n             has_doc = bool(doc)\n \n             metadata = extract_metadata(doc)\n@@ -758,6 +776,7 @@ class Documenter:\n                         keep = has_doc or self.options.undoc_members\n                 else:\n                     keep = False\n+\n             elif (namespace, membername) in attr_docs:\n                 if want_all and isprivate:\n                     if self.options.private_members is None:\n@@ -767,6 +786,31 @@ class Documenter:\n                 else:\n                     # keep documented attributes\n                     keep = True\n+            # Check for inherited annotation-only attributes with documentation\n+            elif (inspect.isclass(self.object) and \n+                  self.options.inherited_members and \n+                  membername in self.get_attr(self.object, '__annotations__', {})):\n+                # For inherited annotation-only attributes, check parent class namespaces\n+                found_in_parent = False\n+                for cls in self.object.__mro__[1:]:  # Skip self.object\n+                    if cls.__name__ == 'object':\n+                        break\n+                    parent_objpath = self.objpath[:-1] + [cls.__name__]\n+                    parent_namespace = '.'.join(parent_objpath)\n+                    if (parent_namespace, membername) in attr_docs:\n+                        found_in_parent = True\n+                        break\n+                \n+                if found_in_parent:\n+                    if want_all and isprivate:\n+                        if self.options.private_members is None:\n+                            keep = False\n+                        else:\n+                            keep = membername in self.options.private_members\n+                    else:\n+                        # keep documented inherited attributes\n+                        keep = True\n+                    isattr = True\n                 isattr = True\n             elif want_all and isprivate:\n                 if has_doc or self.options.undoc_members:\n@@ -780,11 +824,33 @@ class Documenter:\n                     keep = False\n             else:\n                 if (self.options.members is ALL and\n+\n                         is_filtered_inherited_member(membername, obj)):\n                     keep = False\n                 else:\n-                    # ignore undocumented members if :undoc-members: is not given\n-                    keep = has_doc or self.options.undoc_members\n+                    # Check if this is an inherited annotation-only attribute with documentation\n+                    if (inspect.isclass(self.object) and \n+                        self.options.inherited_members and \n+                        membername in self.get_attr(self.object, '__annotations__', {})):\n+                        # Check parent class namespaces for documentation\n+                        found_inherited_doc = False\n+                        for cls in self.object.__mro__[1:]:  # Skip self.object\n+                            if cls.__name__ == 'object':\n+                                break\n+                            parent_objpath = self.objpath[:-1] + [cls.__name__]\n+                            parent_namespace = '.'.join(parent_objpath)\n+                            if (parent_namespace, membername) in attr_docs:\n+                                found_inherited_doc = True\n+                                break\n+                        \n+                        if found_inherited_doc:\n+                            keep = True\n+                        else:\n+                            # ignore undocumented members if :undoc-members: is not given\n+                            keep = has_doc or self.options.undoc_members\n+                    else:\n+                        # ignore undocumented members if :undoc-members: is not given\n+                        keep = has_doc or self.options.undoc_members\n \n             if isinstance(obj, ObjectMember) and obj.skipped:\n                 # forcedly skipped member (ex. a module attribute not defined in __all__)\n",
    "variant_0": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex dc413b5c2..145b8e862 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -676,6 +676,7 @@ class Documenter:\n         The user can override the skipping decision by connecting to the\n         ``autodoc-skip-member`` event.\n         \"\"\"\n+\n         def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n             if inspect.isclass(self.object):\n                 for cls in self.object.__mro__:\n@@ -693,8 +694,23 @@ class Documenter:\n \n         ret = []\n \n+        # search for members in source code too\n+\n         # search for members in source code too\n         namespace = '.'.join(self.objpath)  # will be empty for modules\n+        \n+        # Build list of parent namespaces for inherited member lookup\n+        parent_namespaces = []\n+        if self.objpath:\n+            # Get the class hierarchy for namespace lookup\n+            try:\n+                current_class = self.object\n+                for cls in inspect.getmro(current_class)[1:]:  # Skip self\n+                    if hasattr(cls, '__module__') and hasattr(cls, '__qualname__'):\n+                        parent_ns = f\"{cls.__module__}.{cls.__qualname__}\"\n+                        parent_namespaces.append(parent_ns)\n+            except (AttributeError, TypeError):\n+                pass\n \n         if self.analyzer:\n             attr_docs = self.analyzer.find_attr_docs()\n@@ -710,6 +726,7 @@ class Documenter:\n             else:\n                 isattr = False\n \n+\n             doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n                          self.parent, self.object_name)\n             if not isinstance(doc, str):\n@@ -724,6 +741,15 @@ class Documenter:\n                 if cls_doc == doc:\n                     doc = None\n \n+            # For inherited annotation-only attributes, check parent class namespaces for docs\n+            if doc is None and isattr and hasattr(self.object, '__mro__'):\n+                for parent_cls in self.object.__mro__[1:]:  # Skip self.object\n+                    if hasattr(parent_cls, '__annotations__') and membername in parent_cls.__annotations__:\n+                        parent_namespace = parent_cls.__module__ + '.' + parent_cls.__qualname__\n+                        if hasattr(self, 'analyzer') and self.analyzer and (parent_namespace, membername) in self.analyzer.attr_docs:\n+                            doc = '\\n'.join(self.analyzer.attr_docs[(parent_namespace, membername)])\n+                            break\n+\n             if isinstance(obj, ObjectMember) and obj.docstring:\n                 # hack for ClassDocumenter to inject docstring via ObjectMember\n                 doc = obj.docstring\n@@ -758,6 +784,7 @@ class Documenter:\n                         keep = has_doc or self.options.undoc_members\n                 else:\n                     keep = False\n+\n             elif (namespace, membername) in attr_docs:\n                 if want_all and isprivate:\n                     if self.options.private_members is None:\n@@ -768,6 +795,30 @@ class Documenter:\n                     # keep documented attributes\n                     keep = True\n                 isattr = True\n+            else:\n+                # Check parent class namespaces for inherited attribute docs\n+                found_in_parent = False\n+                if self.objpath:\n+                    # Build parent class paths by walking up the inheritance hierarchy\n+                    for cls in inspect.getmro(self.object)[1:]:  # Skip self.object\n+                        if cls is object:\n+                            continue\n+                        parent_namespace = cls.__module__ + '.' + cls.__qualname__\n+                        if (parent_namespace, membername) in attr_docs:\n+                            found_in_parent = True\n+                            break\n+                \n+                if found_in_parent:\n+                    if want_all and isprivate:\n+                        if self.options.private_members is None:\n+                            keep = False\n+                        else:\n+                            keep = membername in self.options.private_members\n+                    else:\n+                        # keep documented attributes from parent classes\n+                        keep = True\n+                    isattr = True\n+                isattr = True\n             elif want_all and isprivate:\n                 if has_doc or self.options.undoc_members:\n                     if self.options.private_members is None:\n@@ -778,12 +829,27 @@ class Documenter:\n                         keep = membername in self.options.private_members\n                 else:\n                     keep = False\n+            else:\n+                if (self.options.members is ALL and\n+\n             else:\n                 if (self.options.members is ALL and\n                         is_filtered_inherited_member(membername, obj)):\n                     keep = False\n                 else:\n                     # ignore undocumented members if :undoc-members: is not given\n+                    # For inherited annotation-only members, check parent class namespaces\n+                    if not has_doc and hasattr(obj, '__objclass__'):\n+                        # Check if this is an inherited annotation-only attribute\n+                        parent_class = obj.__objclass__\n+                        if hasattr(parent_class, '__annotations__') and membername in parent_class.__annotations__:\n+                            # Build parent namespace and check for docs\n+                            parent_module = getattr(parent_class, '__module__', None)\n+                            if parent_module:\n+                                parent_namespace = f\"{parent_module}.{parent_class.__qualname__}\"\n+                                if (parent_namespace, membername) in attr_docs:\n+                                    has_doc = True\n+                    \n                     keep = has_doc or self.options.undoc_members\n \n             if isinstance(obj, ObjectMember) and obj.skipped:\n",
    "variant_1": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex dc413b5c2..953439d0a 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -676,6 +676,7 @@ class Documenter:\n         The user can override the skipping decision by connecting to the\n         ``autodoc-skip-member`` event.\n         \"\"\"\n+\n         def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n             if inspect.isclass(self.object):\n                 for cls in self.object.__mro__:\n@@ -694,7 +695,21 @@ class Documenter:\n         ret = []\n \n         # search for members in source code too\n+\n         namespace = '.'.join(self.objpath)  # will be empty for modules\n+        \n+        # Build list of namespaces to check for inherited attribute docs\n+        parent_namespaces = []\n+        if self.objpath:\n+            # Add current class namespace\n+            parent_namespaces.append(namespace)\n+            # Add parent class namespaces for inherited members\n+            for cls in inspect.getmro(self.object)[1:]:  # Skip self.object\n+                if cls is object:\n+                    break\n+                parent_ns = '.'.join(self.objpath[:-1] + [cls.__name__])\n+                if parent_ns not in parent_namespaces:\n+                    parent_namespaces.append(parent_ns)\n \n         if self.analyzer:\n             attr_docs = self.analyzer.find_attr_docs()\n@@ -710,6 +725,7 @@ class Documenter:\n             else:\n                 isattr = False\n \n+\n             doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n                          self.parent, self.object_name)\n             if not isinstance(doc, str):\n@@ -724,6 +740,17 @@ class Documenter:\n                 if cls_doc == doc:\n                     doc = None\n \n+            # For inherited annotation-only attributes, check if doc is available\n+            # in parent class attribute docs when regular getdoc fails\n+            if not doc and member is INSTANCEATTR:\n+                # Check if this is an inherited annotation-only attribute\n+                for cls in inspect.getmro(self.object):\n+                    if hasattr(cls, '__annotations__') and membername in cls.__annotations__:\n+                        parent_namespace = cls.__module__ + '.' + cls.__qualname__\n+                        if (parent_namespace, membername) in attr_docs:\n+                            doc = '\\n'.join(attr_docs[(parent_namespace, membername)])\n+                            break\n+\n             if isinstance(obj, ObjectMember) and obj.docstring:\n                 # hack for ClassDocumenter to inject docstring via ObjectMember\n                 doc = obj.docstring\n@@ -758,6 +785,7 @@ class Documenter:\n                         keep = has_doc or self.options.undoc_members\n                 else:\n                     keep = False\n+\n             elif (namespace, membername) in attr_docs:\n                 if want_all and isprivate:\n                     if self.options.private_members is None:\n@@ -768,6 +796,36 @@ class Documenter:\n                     # keep documented attributes\n                     keep = True\n                 isattr = True\n+            else:\n+                # Check parent class namespaces for inherited attribute docs\n+                found_in_parent = False\n+                if self.object and hasattr(self.object, '__mro__'):\n+                    for parent_cls in self.object.__mro__[1:]:  # Skip self\n+                        parent_namespace = parent_cls.__module__ + '.' + parent_cls.__qualname__\n+                        if (parent_namespace, membername) in attr_docs:\n+                            if want_all and isprivate:\n+                                if self.options.private_members is None:\n+                                    keep = False\n+                                else:\n+                                    keep = membername in self.options.private_members\n+                            else:\n+                                # keep documented attributes from parent\n+                                keep = True\n+                            isattr = True\n+                            found_in_parent = True\n+                            break\n+                \n+                if not found_in_parent and (namespace, membername) in attr_docs:\n+                    if want_all and isprivate:\n+                        if self.options.private_members is None:\n+                            keep = False\n+                        else:\n+                            keep = membername in self.options.private_members\n+                    else:\n+                        # keep documented attributes\n+                        keep = True\n+                    isattr = True\n+                isattr = True\n             elif want_all and isprivate:\n                 if has_doc or self.options.undoc_members:\n                     if self.options.private_members is None:\n@@ -778,10 +836,25 @@ class Documenter:\n                         keep = membername in self.options.private_members\n                 else:\n                     keep = False\n+            else:\n+                if (self.options.members is ALL and\n+\n             else:\n                 if (self.options.members is ALL and\n                         is_filtered_inherited_member(membername, obj)):\n-                    keep = False\n+                    # For inherited annotation-only attributes, check if they have docs in parent classes\n+                    if isinstance(obj, ObjectMember) and obj.skipped is False:\n+                        # Check parent class namespaces for attribute documentation\n+                        parent_has_doc = False\n+                        if hasattr(self.object, '__mro__'):\n+                            for parent_cls in self.object.__mro__[1:]:  # Skip self\n+                                parent_namespace = parent_cls.__module__ + '.' + parent_cls.__qualname__\n+                                if (parent_namespace, membername) in attr_docs:\n+                                    parent_has_doc = True\n+                                    break\n+                        keep = parent_has_doc\n+                    else:\n+                        keep = False\n                 else:\n                     # ignore undocumented members if :undoc-members: is not given\n                     keep = has_doc or self.options.undoc_members\n",
    "variant_2": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex dc413b5c2..894d8d3ee 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -676,6 +676,7 @@ class Documenter:\n         The user can override the skipping decision by connecting to the\n         ``autodoc-skip-member`` event.\n         \"\"\"\n+\n         def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n             if inspect.isclass(self.object):\n                 for cls in self.object.__mro__:\n@@ -693,8 +694,18 @@ class Documenter:\n \n         ret = []\n \n+        # search for members in source code too\n+\n         # search for members in source code too\n         namespace = '.'.join(self.objpath)  # will be empty for modules\n+        \n+        # Build list of parent namespaces for inherited member lookup\n+        parent_namespaces = []\n+        if self.objpath and hasattr(self.object, '__mro__'):\n+            for cls in self.object.__mro__[1:]:  # Skip self, start from parent\n+                if hasattr(cls, '__module__') and hasattr(cls, '__qualname__'):\n+                    parent_ns = f\"{cls.__module__}.{cls.__qualname__}\"\n+                    parent_namespaces.append(parent_ns)\n \n         if self.analyzer:\n             attr_docs = self.analyzer.find_attr_docs()\n@@ -710,6 +721,7 @@ class Documenter:\n             else:\n                 isattr = False\n \n+\n             doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n                          self.parent, self.object_name)\n             if not isinstance(doc, str):\n@@ -724,6 +736,24 @@ class Documenter:\n                 if cls_doc == doc:\n                     doc = None\n \n+            # For inherited annotation-only attributes, check parent class documentation\n+            if doc is None and isinstance(obj, ObjectMember) and obj.skipped:\n+                # Check if this is an inherited annotation-only attribute\n+                for parent_cls in inspect.getmro(self.object)[1:]:\n+                    if hasattr(parent_cls, '__annotations__') and membername in parent_cls.__annotations__:\n+                        # Try to get documentation from parent class analyzer\n+                        try:\n+                            parent_module = inspect.getmodule(parent_cls)\n+                            if parent_module:\n+                                parent_analyzer = ModuleAnalyzer.for_module(parent_module.__name__)\n+                                parent_analyzer.find_attr_docs()\n+                                parent_namespace = '.'.join([parent_cls.__module__, parent_cls.__qualname__])\n+                                if (parent_namespace, membername) in parent_analyzer.attr_docs:\n+                                    doc = '\\n'.join(parent_analyzer.attr_docs[parent_namespace, membername])\n+                                    break\n+                        except (PycodeError, AttributeError):\n+                            continue\n+\n             if isinstance(obj, ObjectMember) and obj.docstring:\n                 # hack for ClassDocumenter to inject docstring via ObjectMember\n                 doc = obj.docstring\n@@ -758,6 +788,7 @@ class Documenter:\n                         keep = has_doc or self.options.undoc_members\n                 else:\n                     keep = False\n+\n             elif (namespace, membername) in attr_docs:\n                 if want_all and isprivate:\n                     if self.options.private_members is None:\n@@ -768,6 +799,29 @@ class Documenter:\n                     # keep documented attributes\n                     keep = True\n                 isattr = True\n+            else:\n+                # Check parent class namespaces for inherited attribute docs\n+                found_in_parent = False\n+                if self.objpath:\n+                    # Build parent class namespaces by traversing the inheritance hierarchy\n+                    for parent_cls in inspect.getmro(self.object)[1:]:  # Skip self.object\n+                        if hasattr(parent_cls, '__module__') and hasattr(parent_cls, '__qualname__'):\n+                            parent_namespace = f\"{parent_cls.__module__}.{parent_cls.__qualname__}\"\n+                            if (parent_namespace, membername) in attr_docs:\n+                                found_in_parent = True\n+                                break\n+                \n+                if found_in_parent:\n+                    if want_all and isprivate:\n+                        if self.options.private_members is None:\n+                            keep = False\n+                        else:\n+                            keep = membername in self.options.private_members\n+                    else:\n+                        # keep documented attributes from parent classes\n+                        keep = True\n+                    isattr = True\n+                isattr = True\n             elif want_all and isprivate:\n                 if has_doc or self.options.undoc_members:\n                     if self.options.private_members is None:\n@@ -778,12 +832,27 @@ class Documenter:\n                         keep = membername in self.options.private_members\n                 else:\n                     keep = False\n+            else:\n+                if (self.options.members is ALL and\n+\n             else:\n                 if (self.options.members is ALL and\n                         is_filtered_inherited_member(membername, obj)):\n                     keep = False\n                 else:\n                     # ignore undocumented members if :undoc-members: is not given\n+                    # For inherited annotation-only attributes, check parent class namespaces\n+                    if not has_doc and isinstance(obj, ObjectMember) and obj.parent:\n+                        # Check if this is an inherited annotation-only attribute with docs in parent\n+                        parent_cls = obj.parent\n+                        while parent_cls and not has_doc:\n+                            parent_namespace = parent_cls.__module__ + '.' + parent_cls.__qualname__\n+                            if (parent_namespace, membername) in attr_docs:\n+                                has_doc = True\n+                                break\n+                            # Move up the inheritance chain\n+                            parent_cls = getattr(parent_cls, '__bases__', [None])[0] if hasattr(parent_cls, '__bases__') and parent_cls.__bases__ else None\n+                    \n                     keep = has_doc or self.options.undoc_members\n \n             if isinstance(obj, ObjectMember) and obj.skipped:\n",
    "variant_3": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex dc413b5c2..26aceea01 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -676,6 +676,7 @@ class Documenter:\n         The user can override the skipping decision by connecting to the\n         ``autodoc-skip-member`` event.\n         \"\"\"\n+\n         def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n             if inspect.isclass(self.object):\n                 for cls in self.object.__mro__:\n@@ -693,8 +694,18 @@ class Documenter:\n \n         ret = []\n \n+        # search for members in source code too\n+\n         # search for members in source code too\n         namespace = '.'.join(self.objpath)  # will be empty for modules\n+        \n+        # Build list of parent namespaces for inherited member lookup\n+        parent_namespaces = []\n+        if self.object and hasattr(self.object, '__mro__'):\n+            for cls in self.object.__mro__[1:]:  # Skip self, start from parents\n+                if hasattr(cls, '__module__') and hasattr(cls, '__qualname__'):\n+                    parent_ns = f\"{cls.__module__}.{cls.__qualname__}\"\n+                    parent_namespaces.append(parent_ns)\n \n         if self.analyzer:\n             attr_docs = self.analyzer.find_attr_docs()\n@@ -710,6 +721,7 @@ class Documenter:\n             else:\n                 isattr = False\n \n+\n             doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n                          self.parent, self.object_name)\n             if not isinstance(doc, str):\n@@ -724,6 +736,18 @@ class Documenter:\n                 if cls_doc == doc:\n                     doc = None\n \n+            # For inherited annotation-only attributes, check parent class namespaces for docs\n+            if not doc and member is INSTANCEATTR:\n+                # Check if this is an inherited annotation-only attribute\n+                if hasattr(self.object, '__mro__'):\n+                    for base_cls in self.object.__mro__[1:]:  # Skip self.object\n+                        if hasattr(base_cls, '__annotations__') and membername in base_cls.__annotations__:\n+                            # Try to get docs from parent class namespace\n+                            base_namespace = base_cls.__module__ + '.' + base_cls.__qualname__\n+                            if (base_namespace, membername) in attr_docs:\n+                                doc = '\\n'.join(attr_docs[(base_namespace, membername)])\n+                                break\n+\n             if isinstance(obj, ObjectMember) and obj.docstring:\n                 # hack for ClassDocumenter to inject docstring via ObjectMember\n                 doc = obj.docstring\n@@ -758,6 +782,7 @@ class Documenter:\n                         keep = has_doc or self.options.undoc_members\n                 else:\n                     keep = False\n+\n             elif (namespace, membername) in attr_docs:\n                 if want_all and isprivate:\n                     if self.options.private_members is None:\n@@ -768,6 +793,23 @@ class Documenter:\n                     # keep documented attributes\n                     keep = True\n                 isattr = True\n+            elif want_all and isprivate:\n+                # Check if this is an inherited annotation-only attribute with docs in parent namespace\n+                inherited_attr_docs = False\n+                if hasattr(self.object, '__mro__'):\n+                    for base in self.object.__mro__[1:]:  # Skip current class\n+                        base_namespace = base.__module__ + '.' + base.__qualname__\n+                        if (base_namespace, membername) in attr_docs:\n+                            inherited_attr_docs = True\n+                            break\n+                \n+                if inherited_attr_docs:\n+                    if self.options.private_members is None:\n+                        keep = False\n+                    else:\n+                        keep = membername in self.options.private_members\n+                    isattr = True\n+                isattr = True\n             elif want_all and isprivate:\n                 if has_doc or self.options.undoc_members:\n                     if self.options.private_members is None:\n@@ -778,10 +820,25 @@ class Documenter:\n                         keep = membername in self.options.private_members\n                 else:\n                     keep = False\n+            else:\n+                if (self.options.members is ALL and\n+\n             else:\n                 if (self.options.members is ALL and\n                         is_filtered_inherited_member(membername, obj)):\n-                    keep = False\n+                    # For inherited annotation-only attributes, check if they have docs in parent classes\n+                    if isinstance(obj, ObjectMember) and obj.skipped is False:\n+                        # Check parent class namespaces for attribute documentation\n+                        parent_has_doc = False\n+                        if hasattr(self.object, '__mro__'):\n+                            for parent_cls in self.object.__mro__[1:]:  # Skip self\n+                                parent_namespace = parent_cls.__module__ + '.' + parent_cls.__qualname__\n+                                if (parent_namespace, membername) in attr_docs:\n+                                    parent_has_doc = True\n+                                    break\n+                        keep = parent_has_doc\n+                    else:\n+                        keep = False\n                 else:\n                     # ignore undocumented members if :undoc-members: is not given\n                     keep = has_doc or self.options.undoc_members\n",
    "variant_4": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex dc413b5c2..e8f5c4071 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -676,6 +676,7 @@ class Documenter:\n         The user can override the skipping decision by connecting to the\n         ``autodoc-skip-member`` event.\n         \"\"\"\n+\n         def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n             if inspect.isclass(self.object):\n                 for cls in self.object.__mro__:\n@@ -694,7 +695,23 @@ class Documenter:\n         ret = []\n \n         # search for members in source code too\n+\n         namespace = '.'.join(self.objpath)  # will be empty for modules\n+        \n+        # Build list of namespaces to check for inherited attribute docs\n+        parent_namespaces = []\n+        if self.objpath:\n+            # Add current class namespace\n+            parent_namespaces.append(namespace)\n+            # Add parent class namespaces for inherited member lookup\n+            try:\n+                for cls in inspect.getmro(self.object)[1:]:  # Skip self.object\n+                    if hasattr(cls, '__module__') and hasattr(cls, '__qualname__'):\n+                        parent_ns = f\"{cls.__module__}.{cls.__qualname__}\"\n+                        if parent_ns not in parent_namespaces:\n+                            parent_namespaces.append(parent_ns)\n+            except (AttributeError, TypeError):\n+                pass\n \n         if self.analyzer:\n             attr_docs = self.analyzer.find_attr_docs()\n@@ -710,6 +727,7 @@ class Documenter:\n             else:\n                 isattr = False\n \n+\n             doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n                          self.parent, self.object_name)\n             if not isinstance(doc, str):\n@@ -724,6 +742,21 @@ class Documenter:\n                 if cls_doc == doc:\n                     doc = None\n \n+            # For inherited annotation-only attributes, check parent class namespaces\n+            # for attribute documentation when primary doc extraction fails\n+            if not doc and member is INSTANCEATTR:\n+                # Check if this is an inherited annotation-only attribute\n+                for cls in inspect.getmro(self.object):\n+                    if cls is self.object:\n+                        continue\n+                    if hasattr(cls, '__annotations__') and membername in cls.__annotations__:\n+                        # Found the parent class with this annotation, check its namespace\n+                        parent_namespace = cls.__module__ + '.' + cls.__qualname__\n+                        if hasattr(self.analyzer, 'attr_docs') and self.analyzer.attr_docs:\n+                            if (parent_namespace, membername) in self.analyzer.attr_docs:\n+                                doc = '\\n'.join(self.analyzer.attr_docs[parent_namespace, membername])\n+                                break\n+\n             if isinstance(obj, ObjectMember) and obj.docstring:\n                 # hack for ClassDocumenter to inject docstring via ObjectMember\n                 doc = obj.docstring\n@@ -758,6 +791,7 @@ class Documenter:\n                         keep = has_doc or self.options.undoc_members\n                 else:\n                     keep = False\n+\n             elif (namespace, membername) in attr_docs:\n                 if want_all and isprivate:\n                     if self.options.private_members is None:\n@@ -768,6 +802,38 @@ class Documenter:\n                     # keep documented attributes\n                     keep = True\n                 isattr = True\n+            else:\n+                # Check parent class namespaces for inherited attribute docs\n+                found_in_parent = False\n+                if self.analyzer:\n+                    for cls in inspect.getmro(self.object)[1:]:  # Skip self.object (current class)\n+                        if cls is object:\n+                            break\n+                        parent_namespace = cls.__module__ + '.' + cls.__qualname__\n+                        if (parent_namespace, membername) in attr_docs:\n+                            if want_all and isprivate:\n+                                if self.options.private_members is None:\n+                                    keep = False\n+                                else:\n+                                    keep = membername in self.options.private_members\n+                            else:\n+                                # keep documented attributes from parent\n+                                keep = True\n+                            isattr = True\n+                            found_in_parent = True\n+                            break\n+                \n+                if not found_in_parent and (namespace, membername) in attr_docs:\n+                    if want_all and isprivate:\n+                        if self.options.private_members is None:\n+                            keep = False\n+                        else:\n+                            keep = membername in self.options.private_members\n+                    else:\n+                        # keep documented attributes\n+                        keep = True\n+                    isattr = True\n+                isattr = True\n             elif want_all and isprivate:\n                 if has_doc or self.options.undoc_members:\n                     if self.options.private_members is None:\n@@ -778,13 +844,36 @@ class Documenter:\n                         keep = membername in self.options.private_members\n                 else:\n                     keep = False\n+            else:\n+                if (self.options.members is ALL and\n+\n             else:\n                 if (self.options.members is ALL and\n                         is_filtered_inherited_member(membername, obj)):\n                     keep = False\n                 else:\n                     # ignore undocumented members if :undoc-members: is not given\n-                    keep = has_doc or self.options.undoc_members\n+                    # For inherited annotation-only attributes, check parent class namespaces\n+                    if not has_doc and isinstance(obj, ObjectMember) and obj.class_ != self.object:\n+                        # This is an inherited member, check parent class namespaces for docs\n+                        parent_has_doc = False\n+                        if self.analyzer:\n+                            # Get the parent class namespace\n+                            parent_objpath = []\n+                            if hasattr(obj.class_, '__module__'):\n+                                parent_objpath.append(obj.class_.__module__)\n+                            if hasattr(obj.class_, '__qualname__'):\n+                                parent_objpath.extend(obj.class_.__qualname__.split('.'))\n+                            elif hasattr(obj.class_, '__name__'):\n+                                parent_objpath.append(obj.class_.__name__)\n+                            \n+                            parent_namespace = '.'.join(parent_objpath)\n+                            if (parent_namespace, membername) in self.analyzer.attr_docs:\n+                                parent_has_doc = True\n+                        \n+                        keep = parent_has_doc or self.options.undoc_members\n+                    else:\n+                        keep = has_doc or self.options.undoc_members\n \n             if isinstance(obj, ObjectMember) and obj.skipped:\n                 # forcedly skipped member (ex. a module attribute not defined in __all__)\n",
    "variant_5": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex dc413b5c2..1004974e3 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -676,6 +676,7 @@ class Documenter:\n         The user can override the skipping decision by connecting to the\n         ``autodoc-skip-member`` event.\n         \"\"\"\n+\n         def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n             if inspect.isclass(self.object):\n                 for cls in self.object.__mro__:\n@@ -693,8 +694,18 @@ class Documenter:\n \n         ret = []\n \n+        # search for members in source code too\n+\n         # search for members in source code too\n         namespace = '.'.join(self.objpath)  # will be empty for modules\n+        \n+        # Build list of parent namespaces for inherited member lookup\n+        parent_namespaces = []\n+        if hasattr(self.object, '__mro__'):\n+            for cls in self.object.__mro__[1:]:  # Skip self.object (current class)\n+                if hasattr(cls, '__module__') and hasattr(cls, '__qualname__'):\n+                    parent_ns = f\"{cls.__module__}.{cls.__qualname__}\"\n+                    parent_namespaces.append(parent_ns)\n \n         if self.analyzer:\n             attr_docs = self.analyzer.find_attr_docs()\n@@ -710,6 +721,7 @@ class Documenter:\n             else:\n                 isattr = False\n \n+\n             doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n                          self.parent, self.object_name)\n             if not isinstance(doc, str):\n@@ -724,6 +736,16 @@ class Documenter:\n                 if cls_doc == doc:\n                     doc = None\n \n+            # For inherited annotation-only attributes, check parent class namespaces\n+            # for attribute documentation when regular doc extraction fails\n+            if not doc and isattr and hasattr(self.object, '__mro__'):\n+                for parent_cls in self.object.__mro__[1:]:  # Skip self.object\n+                    if hasattr(parent_cls, '__annotations__') and membername in parent_cls.__annotations__:\n+                        parent_namespace = parent_cls.__module__ + '.' + parent_cls.__qualname__\n+                        if (parent_namespace, membername) in attr_docs:\n+                            doc = '\\n'.join(attr_docs[(parent_namespace, membername)])\n+                            break\n+\n             if isinstance(obj, ObjectMember) and obj.docstring:\n                 # hack for ClassDocumenter to inject docstring via ObjectMember\n                 doc = obj.docstring\n@@ -758,6 +780,7 @@ class Documenter:\n                         keep = has_doc or self.options.undoc_members\n                 else:\n                     keep = False\n+\n             elif (namespace, membername) in attr_docs:\n                 if want_all and isprivate:\n                     if self.options.private_members is None:\n@@ -768,6 +791,35 @@ class Documenter:\n                     # keep documented attributes\n                     keep = True\n                 isattr = True\n+            else:\n+                # Check parent class namespaces for inherited attribute documentation\n+                found_in_parent = False\n+                if self.analyzer:\n+                    # Build list of parent class namespaces to check\n+                    parent_namespaces = []\n+                    if hasattr(self.object, '__mro__'):\n+                        for base_cls in self.object.__mro__[1:]:  # Skip self\n+                            if hasattr(base_cls, '__module__') and hasattr(base_cls, '__qualname__'):\n+                                parent_namespace = f\"{base_cls.__module__}.{base_cls.__qualname__}\"\n+                                parent_namespaces.append(parent_namespace)\n+                    \n+                    # Check each parent namespace for attribute documentation\n+                    for parent_namespace in parent_namespaces:\n+                        if (parent_namespace, membername) in attr_docs:\n+                            found_in_parent = True\n+                            break\n+                \n+                if found_in_parent:\n+                    if want_all and isprivate:\n+                        if self.options.private_members is None:\n+                            keep = False\n+                        else:\n+                            keep = membername in self.options.private_members\n+                    else:\n+                        # keep documented attributes from parent classes\n+                        keep = True\n+                    isattr = True\n+                isattr = True\n             elif want_all and isprivate:\n                 if has_doc or self.options.undoc_members:\n                     if self.options.private_members is None:\n@@ -778,13 +830,26 @@ class Documenter:\n                         keep = membername in self.options.private_members\n                 else:\n                     keep = False\n+            else:\n+                if (self.options.members is ALL and\n+\n             else:\n                 if (self.options.members is ALL and\n                         is_filtered_inherited_member(membername, obj)):\n                     keep = False\n                 else:\n+                    # Check for documentation in parent class namespaces for inherited members\n+                    has_doc_in_parent = False\n+                    if isinstance(obj, ObjectMember) and obj.class_ != self.object:\n+                        # This is an inherited member, check parent namespaces\n+                        for cls in inspect.getmro(self.object)[1:]:  # Skip current class\n+                            parent_namespace = cls.__module__ + '.' + cls.__qualname__\n+                            if (parent_namespace, membername) in attr_docs:\n+                                has_doc_in_parent = True\n+                                break\n+                    \n                     # ignore undocumented members if :undoc-members: is not given\n-                    keep = has_doc or self.options.undoc_members\n+                    keep = has_doc or has_doc_in_parent or self.options.undoc_members\n \n             if isinstance(obj, ObjectMember) and obj.skipped:\n                 # forcedly skipped member (ex. a module attribute not defined in __all__)\n",
    "variant_6": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex dc413b5c2..2181b3ed7 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -676,6 +676,7 @@ class Documenter:\n         The user can override the skipping decision by connecting to the\n         ``autodoc-skip-member`` event.\n         \"\"\"\n+\n         def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n             if inspect.isclass(self.object):\n                 for cls in self.object.__mro__:\n@@ -694,12 +695,22 @@ class Documenter:\n         ret = []\n \n         # search for members in source code too\n+\n         namespace = '.'.join(self.objpath)  # will be empty for modules\n \n         if self.analyzer:\n             attr_docs = self.analyzer.find_attr_docs()\n         else:\n             attr_docs = {}\n+        \n+        # Build namespace hierarchy for inherited member lookup\n+        namespace_hierarchy = [namespace]\n+        if hasattr(self.object, '__mro__'):\n+            for base_cls in self.object.__mro__[1:]:  # Skip self\n+                if hasattr(base_cls, '__module__') and hasattr(base_cls, '__qualname__'):\n+                    base_namespace = f\"{base_cls.__module__}.{base_cls.__qualname__}\"\n+                    if base_namespace not in namespace_hierarchy:\n+                        namespace_hierarchy.append(base_namespace)\n \n         # process members and determine which to skip\n         for obj in members:\n@@ -710,6 +721,7 @@ class Documenter:\n             else:\n                 isattr = False\n \n+\n             doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n                          self.parent, self.object_name)\n             if not isinstance(doc, str):\n@@ -724,6 +736,30 @@ class Documenter:\n                 if cls_doc == doc:\n                     doc = None\n \n+            # For inherited annotation-only attributes, check parent class namespaces\n+            # for attribute documentation when getdoc fails\n+            if not doc and isattr and member is INSTANCEATTR:\n+                # Build list of parent class namespaces to check\n+                parent_namespaces = []\n+                for cls in inspect.getmro(self.object):\n+                    if cls is self.object:\n+                        continue\n+                    cls_path = []\n+                    if hasattr(cls, '__module__') and cls.__module__:\n+                        cls_path.append(cls.__module__)\n+                    if hasattr(cls, '__qualname__'):\n+                        cls_path.append(cls.__qualname__)\n+                    elif hasattr(cls, '__name__'):\n+                        cls_path.append(cls.__name__)\n+                    if cls_path:\n+                        parent_namespaces.append('.'.join(cls_path))\n+                \n+                # Check each parent namespace for attribute docs\n+                for parent_ns in parent_namespaces:\n+                    if (parent_ns, membername) in attr_docs:\n+                        doc = '\\n'.join(attr_docs[(parent_ns, membername)])\n+                        break\n+\n             if isinstance(obj, ObjectMember) and obj.docstring:\n                 # hack for ClassDocumenter to inject docstring via ObjectMember\n                 doc = obj.docstring\n@@ -758,6 +794,7 @@ class Documenter:\n                         keep = has_doc or self.options.undoc_members\n                 else:\n                     keep = False\n+\n             elif (namespace, membername) in attr_docs:\n                 if want_all and isprivate:\n                     if self.options.private_members is None:\n@@ -768,6 +805,27 @@ class Documenter:\n                     # keep documented attributes\n                     keep = True\n                 isattr = True\n+            else:\n+                # Check parent class namespaces for inherited attribute docs\n+                found_in_parent = False\n+                if hasattr(self.object, '__mro__'):\n+                    for parent_cls in self.object.__mro__[1:]:  # Skip self\n+                        parent_namespace = parent_cls.__module__ + '.' + parent_cls.__qualname__\n+                        if (parent_namespace, membername) in attr_docs:\n+                            if want_all and isprivate:\n+                                if self.options.private_members is None:\n+                                    keep = False\n+                                else:\n+                                    keep = membername in self.options.private_members\n+                            else:\n+                                # keep documented attributes from parent\n+                                keep = True\n+                            isattr = True\n+                            found_in_parent = True\n+                            break\n+                \n+                if not found_in_parent:\n+                isattr = True\n             elif want_all and isprivate:\n                 if has_doc or self.options.undoc_members:\n                     if self.options.private_members is None:\n@@ -778,12 +836,25 @@ class Documenter:\n                         keep = membername in self.options.private_members\n                 else:\n                     keep = False\n+            else:\n+                if (self.options.members is ALL and\n+\n             else:\n                 if (self.options.members is ALL and\n                         is_filtered_inherited_member(membername, obj)):\n                     keep = False\n                 else:\n                     # ignore undocumented members if :undoc-members: is not given\n+                    # but check for inherited annotation docs before marking as undocumented\n+                    if not has_doc and isinstance(obj, ObjectMember) and obj.parent != self.object:\n+                        # Check if this inherited member has annotation docs in parent classes\n+                        for cls in inspect.getmro(self.object):\n+                            if cls == self.object:\n+                                continue\n+                            parent_namespace = '.'.join(self.objpath[:-1] + [cls.__name__])\n+                            if (parent_namespace, membername) in attr_docs:\n+                                has_doc = True\n+                                break\n                     keep = has_doc or self.options.undoc_members\n \n             if isinstance(obj, ObjectMember) and obj.skipped:\n",
    "variant_7": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex dc413b5c2..c609ddfa7 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -676,6 +676,7 @@ class Documenter:\n         The user can override the skipping decision by connecting to the\n         ``autodoc-skip-member`` event.\n         \"\"\"\n+\n         def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n             if inspect.isclass(self.object):\n                 for cls in self.object.__mro__:\n@@ -693,8 +694,18 @@ class Documenter:\n \n         ret = []\n \n+        # search for members in source code too\n+\n         # search for members in source code too\n         namespace = '.'.join(self.objpath)  # will be empty for modules\n+        \n+        # Build list of parent namespaces for inherited member lookup\n+        parent_namespaces = []\n+        if self.objpath and hasattr(self.object, '__mro__'):\n+            for cls in self.object.__mro__[1:]:  # Skip self, start from parent\n+                if hasattr(cls, '__module__') and hasattr(cls, '__qualname__'):\n+                    parent_ns = f\"{cls.__module__}.{cls.__qualname__}\"\n+                    parent_namespaces.append(parent_ns)\n \n         if self.analyzer:\n             attr_docs = self.analyzer.find_attr_docs()\n@@ -710,6 +721,7 @@ class Documenter:\n             else:\n                 isattr = False\n \n+\n             doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n                          self.parent, self.object_name)\n             if not isinstance(doc, str):\n@@ -724,6 +736,24 @@ class Documenter:\n                 if cls_doc == doc:\n                     doc = None\n \n+            # For inherited annotation-only attributes, try to get doc from parent classes\n+            if doc is None and member is INSTANCEATTR:\n+                # Check if this is an inherited annotation-only attribute\n+                for cls in inspect.getmro(self.object):\n+                    if cls is self.object:\n+                        continue\n+                    if hasattr(cls, '__annotations__') and membername in cls.__annotations__:\n+                        # Found the class that defines this annotation, try to get its attr_docs\n+                        try:\n+                            parent_analyzer = ModuleAnalyzer.for_module(cls.__module__)\n+                            parent_attr_docs = parent_analyzer.find_attr_docs()\n+                            parent_namespace = cls.__module__ + '.' + cls.__qualname__\n+                            if (parent_namespace, membername) in parent_attr_docs:\n+                                doc = '\\n'.join(parent_attr_docs[(parent_namespace, membername)])\n+                                break\n+                        except (PycodeError, AttributeError):\n+                            continue\n+\n             if isinstance(obj, ObjectMember) and obj.docstring:\n                 # hack for ClassDocumenter to inject docstring via ObjectMember\n                 doc = obj.docstring\n@@ -758,6 +788,7 @@ class Documenter:\n                         keep = has_doc or self.options.undoc_members\n                 else:\n                     keep = False\n+\n             elif (namespace, membername) in attr_docs:\n                 if want_all and isprivate:\n                     if self.options.private_members is None:\n@@ -768,6 +799,28 @@ class Documenter:\n                     # keep documented attributes\n                     keep = True\n                 isattr = True\n+            else:\n+                # Check parent class namespaces for inherited attribute documentation\n+                found_in_parent = False\n+                if self.analyzer:\n+                    for cls in inspect.getmro(self.object)[1:]:  # Skip self.object, start from parents\n+                        if hasattr(cls, '__module__') and hasattr(cls, '__qualname__'):\n+                            parent_namespace = f\"{cls.__module__}.{cls.__qualname__}\"\n+                            if (parent_namespace, membername) in attr_docs:\n+                                if want_all and isprivate:\n+                                    if self.options.private_members is None:\n+                                        keep = False\n+                                    else:\n+                                        keep = membername in self.options.private_members\n+                                else:\n+                                    # keep documented attributes from parent classes\n+                                    keep = True\n+                                isattr = True\n+                                found_in_parent = True\n+                                break\n+                \n+                if not found_in_parent and want_all and isprivate:\n+                isattr = True\n             elif want_all and isprivate:\n                 if has_doc or self.options.undoc_members:\n                     if self.options.private_members is None:\n@@ -778,12 +831,21 @@ class Documenter:\n                         keep = membername in self.options.private_members\n                 else:\n                     keep = False\n+            else:\n+                if (self.options.members is ALL and\n+\n             else:\n                 if (self.options.members is ALL and\n                         is_filtered_inherited_member(membername, obj)):\n                     keep = False\n                 else:\n                     # ignore undocumented members if :undoc-members: is not given\n+                    # For inherited annotation-only attributes, check parent class namespaces\n+                    if not has_doc and isinstance(obj, ObjectMember) and obj.class_:\n+                        # Check if this is an inherited annotation-only attribute with docs in parent\n+                        parent_namespace = '.'.join(obj.class_.__module__.split('.') + [obj.class_.__qualname__])\n+                        if (parent_namespace, membername) in attr_docs:\n+                            has_doc = True\n                     keep = has_doc or self.options.undoc_members\n \n             if isinstance(obj, ObjectMember) and obj.skipped:\n",
    "variant_8": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex dc413b5c2..58b8bde06 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -676,6 +676,7 @@ class Documenter:\n         The user can override the skipping decision by connecting to the\n         ``autodoc-skip-member`` event.\n         \"\"\"\n+\n         def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n             if inspect.isclass(self.object):\n                 for cls in self.object.__mro__:\n@@ -693,8 +694,18 @@ class Documenter:\n \n         ret = []\n \n+        # search for members in source code too\n+\n         # search for members in source code too\n         namespace = '.'.join(self.objpath)  # will be empty for modules\n+        \n+        # Build list of parent namespaces for inherited member lookup\n+        parent_namespaces = []\n+        if hasattr(self.object, '__mro__'):\n+            for cls in self.object.__mro__[1:]:  # Skip self\n+                if hasattr(cls, '__module__') and hasattr(cls, '__qualname__'):\n+                    parent_ns = f\"{cls.__module__}.{cls.__qualname__}\"\n+                    parent_namespaces.append(parent_ns)\n \n         if self.analyzer:\n             attr_docs = self.analyzer.find_attr_docs()\n@@ -710,6 +721,7 @@ class Documenter:\n             else:\n                 isattr = False\n \n+\n             doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n                          self.parent, self.object_name)\n             if not isinstance(doc, str):\n@@ -724,6 +736,21 @@ class Documenter:\n                 if cls_doc == doc:\n                     doc = None\n \n+            # For inherited annotation-only attributes, check parent class namespaces\n+            # for attribute documentation when regular doc extraction fails\n+            if not doc and member is INSTANCEATTR:\n+                # Check if this is an inherited annotation-only attribute\n+                for cls in inspect.getmro(self.object):\n+                    if cls is self.object:\n+                        continue\n+                    if hasattr(cls, '__annotations__') and membername in cls.__annotations__:\n+                        # Found the class where this annotation is defined\n+                        parent_namespace = cls.__module__ + '.' + cls.__qualname__\n+                        if hasattr(self, 'analyzer') and self.analyzer and self.analyzer.attr_docs:\n+                            if (parent_namespace, membername) in self.analyzer.attr_docs:\n+                                doc = '\\n'.join(self.analyzer.attr_docs[parent_namespace, membername])\n+                                break\n+\n             if isinstance(obj, ObjectMember) and obj.docstring:\n                 # hack for ClassDocumenter to inject docstring via ObjectMember\n                 doc = obj.docstring\n@@ -758,6 +785,7 @@ class Documenter:\n                         keep = has_doc or self.options.undoc_members\n                 else:\n                     keep = False\n+\n             elif (namespace, membername) in attr_docs:\n                 if want_all and isprivate:\n                     if self.options.private_members is None:\n@@ -768,6 +796,41 @@ class Documenter:\n                     # keep documented attributes\n                     keep = True\n                 isattr = True\n+            elif is_filtered_inherited_member(membername, obj):\n+                # Check for attribute docs in parent class namespaces for inherited members\n+                found_in_parent = False\n+                if hasattr(self.object, '__mro__'):\n+                    for parent_cls in self.object.__mro__[1:]:  # Skip self.object\n+                        parent_namespace = parent_cls.__module__ + '.' + parent_cls.__qualname__\n+                        if (parent_namespace, membername) in attr_docs:\n+                            found_in_parent = True\n+                            break\n+                \n+                if found_in_parent:\n+                    if want_all and isprivate:\n+                        if self.options.private_members is None:\n+                            keep = False\n+                        else:\n+                            keep = membername in self.options.private_members\n+                    else:\n+                        # keep documented attributes from parent classes\n+                        keep = True\n+                    isattr = True\n+                else:\n+                    if want_all and isprivate:\n+                        if has_doc or self.options.undoc_members:\n+                            if self.options.private_members is None:\n+                                keep = False\n+                            elif is_filtered_inherited_member(membername, obj):\n+                                keep = False\n+                            else:\n+                                keep = membername in self.options.private_members\n+                        else:\n+                            keep = False\n+                    else:\n+                        # keep it anyway if we want all and it's documented\n+                        keep = has_doc or self.options.undoc_members\n+                isattr = True\n             elif want_all and isprivate:\n                 if has_doc or self.options.undoc_members:\n                     if self.options.private_members is None:\n@@ -778,10 +841,25 @@ class Documenter:\n                         keep = membername in self.options.private_members\n                 else:\n                     keep = False\n+            else:\n+                if (self.options.members is ALL and\n+\n             else:\n                 if (self.options.members is ALL and\n                         is_filtered_inherited_member(membername, obj)):\n-                    keep = False\n+                    # For inherited annotation-only attributes, check if they have docs in parent classes\n+                    if isinstance(obj, ObjectMember) and obj.skipped is False:\n+                        # Check parent class namespaces for attribute documentation\n+                        parent_has_doc = False\n+                        if hasattr(self.object, '__mro__'):\n+                            for parent_cls in self.object.__mro__[1:]:  # Skip self.object\n+                                parent_namespace = parent_cls.__module__ + '.' + parent_cls.__qualname__\n+                                if (parent_namespace, membername) in attr_docs:\n+                                    parent_has_doc = True\n+                                    break\n+                        keep = parent_has_doc\n+                    else:\n+                        keep = False\n                 else:\n                     # ignore undocumented members if :undoc-members: is not given\n                     keep = has_doc or self.options.undoc_members\n"
  }
}