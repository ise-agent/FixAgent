{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/pytest/src/_pytest/assertion/rewrite.py lines 605-607)": "\n            elif tp in {tokenize.NEWLINE, tokenize.ENDMARKER}:\n                _write_and_reset()\n            elif lines and lineno not in seen_lines:\n                # Only append lines if we're still within the assertion context\n                # Check if this line starts with tokens that indicate end of assertion\n                line_stripped = line.strip()\n                if line_stripped and not line_stripped.startswith(('@', 'def ', 'class ', 'if ', 'elif ', 'else:', 'for ', 'while ', 'with ', 'try:', 'except', 'finally:', 'return', 'yield', 'break', 'continue', 'pass', 'raise', 'import', 'from ')):\n                    lines.append(line)\n                    seen_lines.add(lineno)\n",
    "Location 2 (/root/hy/projects_2/pytest/src/_pytest/assertion/rewrite.py lines 603-604)": "\n            elif tp in {tokenize.NEWLINE, tokenize.ENDMARKER}:\n                _write_and_reset()\n                # Reset state to prevent collecting unrelated lines after assertion ends\n                assert_lineno = None\n",
    "Location 3 (/root/hy/projects_2/pytest/src/_pytest/assertion/rewrite.py lines 578-580)": "\n        if tp == tokenize.NAME and source == \"assert\":\n            assert_lineno = lineno\n        elif assert_lineno is not None:\n            # Check for tokens that clearly terminate an assertion\n            if tp == tokenize.OP and source == \"@\":\n                _write_and_reset()\n                continue\n            elif tp == tokenize.NAME and source in (\"def\", \"class\", \"async\"):\n                _write_and_reset()\n                continue\n",
    "Location 4 (/root/hy/projects_2/pytest/src/_pytest/assertion/rewrite.py lines 567-574)": "\ndef _write_and_reset() -> None:\n    nonlocal depth, lines, assert_lineno, seen_lines\n    if assert_lineno is not None and lines:\n        ret[assert_lineno] = \"\".join(lines).rstrip().rstrip(\"\\\\\")\n    depth = 0\n    lines = []\n    assert_lineno = None\n    seen_lines = set()\n",
    "Location 5 (/root/hy/projects_2/pytest/testing/test_assertrewrite.py lines 1658-1667)": "\n        pytest.param(\n            b\"def x(): assert 5\",\n            {1: \"5\"},\n            id=\"no newline at end of file\",\n        ),\n        pytest.param(\n            b\"def test():\\n    assert 1\\n\\n    @t\\ndef inner(): pass\\n\",\n            {2: \"1\"},\n            id=\"assertion followed by decorator should not include decorator\",\n        ),\n        # fmt: on\n    ),\n)\ndef test_get_assertion_exprs(src, expected) -> None:\n    assert _get_assertion_exprs(src) == expected\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/pytest/src/_pytest/assertion/rewrite.py lines 605-607)": [
      "\n            elif lines and lineno not in seen_lines:\n                # Only append lines if we're still within the assertion expression\n                # Check if this line contains tokens that would terminate the assertion\n                line_tokens = list(tokenize.generate_tokens(io.StringIO(line).readline))\n                is_assertion_continuation = False\n                \n                # Check if line starts with whitespace (continuation) or contains operators/brackets\n                stripped_line = line.strip()\n                if stripped_line and not stripped_line.startswith(('@', 'def ', 'class ', 'if ', 'for ', 'while ', 'with ', 'try:')):\n                    # Check for continuation patterns\n                    for line_token in line_tokens:\n                        if line_token.type in (tokenize.OP, tokenize.NAME) and line_token.string in ('(', '[', '{', '.', '+', '-', '*', '/', '==', '!=', '<', '>', '<=', '>=', 'and', 'or', 'not', 'in', 'is'):\n                            is_assertion_continuation = True\n                            break\n                    \n                    # Also check if previous line ended with continuation character\n                    if lines and (lines[-1].rstrip().endswith(('\\\\', ',', '(', '[', '{')) or is_assertion_continuation):\n                        lines.append(line)\n                        seen_lines.add(lineno)\n",
      "\n            elif lines and lineno not in seen_lines:\n                # Only append lines if we're still within the assertion context\n                # Check if this line could be part of a multi-line assertion\n                stripped_line = line.strip()\n                if (stripped_line and \n                    not stripped_line.startswith('@') and \n                    not stripped_line.startswith('def ') and\n                    not stripped_line.startswith('class ') and\n                    not stripped_line.startswith('import ') and\n                    not stripped_line.startswith('from ')):\n                    lines.append(line)\n                    seen_lines.add(lineno)\n",
      "\n            elif lines and lineno not in seen_lines:\n                # Only append lines if we're still within the assertion context\n                # Check if this line starts with tokens that indicate assertion end\n                line_stripped = line.strip()\n                if line_stripped and not line_stripped.startswith(('@', 'def ', 'class ', 'if ', 'for ', 'while ', 'with ', 'try:', 'except', 'finally:', 'else:', 'elif ')):\n                    lines.append(line)\n                    seen_lines.add(lineno)\n",
      "\n            elif tp in {tokenize.NEWLINE, tokenize.ENDMARKER}:\n                _write_and_reset()\n            elif lines and lineno not in seen_lines:\n                # Only append lines if we're still in the assertion context\n                # Check if this is a decorator or other construct that should end collection\n                if source.lstrip().startswith('@') or source.lstrip().startswith('def ') or source.lstrip().startswith('class '):\n                    _write_and_reset()\n                else:\n                    lines.append(line)\n                    seen_lines.add(lineno)\n",
      "\n            elif lines and lineno not in seen_lines:\n                # Only append lines if we're still within the assertion context\n                # Check if this line starts with tokens that clearly end the assertion\n                line_stripped = line.strip()\n                if line_stripped.startswith(('@', 'def ', 'class ', 'if ', 'for ', 'while ', 'with ', 'try:')):\n                    # This line starts a new construct, don't include it\n                    _write_and_reset()\n                else:\n                    lines.append(line)\n                    seen_lines.add(lineno)\n",
      "\n            elif lines and lineno not in seen_lines and tp not in {tokenize.OP}:\n                # Only append lines if we're still within the assertion context\n                # Check if this is a continuation of the assertion or a new construct\n                if tp == tokenize.OP and source == '@':\n                    # Decorator found - stop collecting lines\n                    _write_and_reset()\n                elif tp == tokenize.NAME and source in {'def', 'class', 'async'}:\n                    # Function/class definition found - stop collecting lines\n                    _write_and_reset()\n                else:\n                    lines.append(line)\n                    seen_lines.add(lineno)\n",
      "\n            elif lines and lineno not in seen_lines:\n                # Only add lines that are part of the assertion expression\n                # Check if we're still within the assertion context\n                if assert_lineno is not None and tp not in {tokenize.OP} or (tp == tokenize.OP and source not in {'@'}):\n                    lines.append(line)\n                    seen_lines.add(lineno)\n",
      "\n            elif lines and lineno not in seen_lines:\n                # Only append lines if we're still within the assertion context\n                # Check if this line could be part of a multi-line assertion\n                if (tp not in {tokenize.OP} or source not in {'@'}) and not line.strip().startswith('@'):\n                    lines.append(line)\n                    seen_lines.add(lineno)\n"
    ],
    "Location 2 (/root/hy/projects_2/pytest/src/_pytest/assertion/rewrite.py lines 603-604)": [
      "\n            elif tp in {tokenize.NEWLINE, tokenize.ENDMARKER}:\n                _write_and_reset()\n",
      "\n            elif tp in {tokenize.NEWLINE, tokenize.ENDMARKER}:\n                _write_and_reset()\n",
      "\n            elif tp in {tokenize.NEWLINE, tokenize.ENDMARKER}:\n                _write_and_reset()\n",
      "\n            elif tp in {tokenize.NEWLINE, tokenize.ENDMARKER}:\n                _write_and_reset()\n                # Reset state to prevent collecting unrelated lines after assertion ends\n                assert_lineno = None\n",
      "\n            elif tp in {tokenize.NEWLINE, tokenize.ENDMARKER}:\n                _write_and_reset()\n                # Reset state to prevent collecting unrelated subsequent lines\n                if tp == tokenize.NEWLINE and not lines:\n                    assert_lineno = None\n",
      "\n            elif tp in {tokenize.NEWLINE, tokenize.ENDMARKER}:\n                _write_and_reset()\n",
      "\n            elif tp in {tokenize.NEWLINE, tokenize.ENDMARKER}:\n                _write_and_reset()\n",
      "\n            elif tp in {tokenize.NEWLINE, tokenize.ENDMARKER}:\n                _write_and_reset()\n                # Reset state to prevent collecting unrelated lines after assertion ends\n                if tp == tokenize.NEWLINE and not lines:\n                    assert_lineno = None\n"
    ],
    "Location 3 (/root/hy/projects_2/pytest/src/_pytest/assertion/rewrite.py lines 578-580)": [
      "\n        if tp == tokenize.NAME and source == \"assert\":\n            assert_lineno = lineno\n        elif assert_lineno is not None:\n",
      "\n        if tp == tokenize.NAME and source == \"assert\":\n            assert_lineno = lineno\n        elif assert_lineno is not None:\n            # Check for tokens that clearly indicate the assertion has ended\n            if tp == tokenize.OP and source == \"@\":\n                # Decorator found - assertion is complete\n                _write_and_reset()\n                continue\n            elif tp == tokenize.NAME and source in (\"def\", \"class\", \"if\", \"for\", \"while\", \"with\", \"try\"):\n                # New statement found - assertion is complete\n                _write_and_reset()\n                continue\n",
      "\n        if tp == tokenize.NAME and source == \"assert\":\n            assert_lineno = lineno\n        elif assert_lineno is not None:\n            # Check for tokens that clearly end an assertion (decorators, function definitions, etc.)\n            if tp == tokenize.OP and source == \"@\":\n                _write_and_reset()\n                continue\n            elif tp == tokenize.NAME and source in (\"def\", \"class\", \"async\"):\n                _write_and_reset()\n                continue\n",
      "\n        if tp == tokenize.NAME and source == \"assert\":\n            assert_lineno = lineno\n        elif assert_lineno is not None:\n            # Check for tokens that clearly terminate an assertion\n            if tp == tokenize.OP and source == \"@\":\n                # Decorator found - assertion is complete\n                _write_and_reset()\n                continue\n            elif tp == tokenize.NAME and source in (\"def\", \"class\", \"async\"):\n                # Function/class definition found - assertion is complete\n                _write_and_reset()\n                continue\n",
      "\n        if tp == tokenize.NAME and source == \"assert\":\n            assert_lineno = lineno\n        elif assert_lineno is not None:\n            # Check for tokens that clearly terminate an assertion\n            if tp == tokenize.OP and source == \"@\":\n                _write_and_reset()\n                continue\n            elif tp == tokenize.NAME and source in (\"def\", \"class\", \"async\"):\n                _write_and_reset()\n                continue\n",
      "\n        if tp == tokenize.NAME and source == \"assert\":\n            assert_lineno = lineno\n        elif assert_lineno is not None:\n            # Check if we've encountered a decorator or function definition that ends the assertion\n            if tp == tokenize.OP and source == \"@\":\n                _write_and_reset()\n                continue\n            elif tp == tokenize.NAME and source == \"def\":\n                _write_and_reset()\n                continue\n",
      "\n        if tp == tokenize.NAME and source == \"assert\":\n            assert_lineno = lineno\n        elif assert_lineno is not None:\n",
      "\n        if tp == tokenize.NAME and source == \"assert\":\n            assert_lineno = lineno\n        elif assert_lineno is not None:\n            # Stop collecting if we encounter a decorator or function definition\n            if tp == tokenize.OP and source == \"@\":\n                _write_and_reset()\n            elif tp == tokenize.NAME and source == \"def\":\n                _write_and_reset()\n"
    ],
    "Location 4 (/root/hy/projects_2/pytest/src/_pytest/assertion/rewrite.py lines 567-574)": [
      "\ndef _write_and_reset() -> None:\n    nonlocal depth, lines, assert_lineno, seen_lines\n    assert assert_lineno is not None\n    ret[assert_lineno] = \"\".join(lines).rstrip().rstrip(\"\\\\\")\n    depth = 0\n    lines = []\n    assert_lineno = None\n    seen_lines = set()\n",
      "\ndef _write_and_reset() -> None:\n    nonlocal depth, lines, assert_lineno, seen_lines\n    if assert_lineno is not None and lines:\n        ret[assert_lineno] = \"\".join(lines).rstrip().rstrip(\"\\\\\")\n    depth = 0\n    lines = []\n    assert_lineno = None\n    seen_lines = set()\n",
      "\ndef _write_and_reset() -> None:\n    nonlocal depth, lines, assert_lineno, seen_lines\n    if assert_lineno is not None and lines:\n        ret[assert_lineno] = \"\".join(lines).rstrip().rstrip(\"\\\\\")\n    depth = 0\n    lines = []\n    assert_lineno = None\n    seen_lines = set()\n",
      "\ndef _write_and_reset() -> None:\n    nonlocal depth, lines, assert_lineno, seen_lines\n    if assert_lineno is not None and lines:\n        ret[assert_lineno] = \"\".join(lines).rstrip().rstrip(\"\\\\\")\n    depth = 0\n    lines = []\n    assert_lineno = None\n    seen_lines = set()\n",
      "\ndef _write_and_reset() -> None:\n    nonlocal depth, lines, assert_lineno, seen_lines\n    if assert_lineno is not None and lines:\n        ret[assert_lineno] = \"\".join(lines).rstrip().rstrip(\"\\\\\")\n    depth = 0\n    lines = []\n    assert_lineno = None\n    seen_lines = set()\n",
      "\ndef _write_and_reset() -> None:\n    nonlocal depth, lines, assert_lineno, seen_lines\n    if assert_lineno is not None and lines:\n        ret[assert_lineno] = \"\".join(lines).rstrip().rstrip(\"\\\\\")\n    depth = 0\n    lines = []\n    assert_lineno = None\n    seen_lines = set()\n",
      "\ndef _write_and_reset() -> None:\n    nonlocal depth, lines, assert_lineno, seen_lines\n    assert assert_lineno is not None\n    ret[assert_lineno] = \"\".join(lines).rstrip().rstrip(\"\\\\\")\n    depth = 0\n    lines = []\n    assert_lineno = None\n    seen_lines = set()\n",
      "\ndef _write_and_reset() -> None:\n    nonlocal depth, lines, assert_lineno, seen_lines\n    if assert_lineno is not None and lines:\n        ret[assert_lineno] = \"\".join(lines).rstrip().rstrip(\"\\\\\")\n    depth = 0\n    lines = []\n    assert_lineno = None\n    seen_lines = set()\n"
    ],
    "Location 5 (/root/hy/projects_2/pytest/testing/test_assertrewrite.py lines 1658-1667)": [
      "\n        pytest.param(\n            b\"def test():\\n    assert 1\\n\\n    @t\\ndef inner(): pass\\n\",\n            {2: \"1\"},\n            id=\"assertion followed by decorator should not include decorator\",\n        ),\n        pytest.param(\n            b\"def x(): assert 5\",\n            {1: \"5\"},\n            id=\"no newline at end of file\",\n        ),\n        # fmt: on\n    ),\n)\ndef test_get_assertion_exprs(src, expected) -> None:\n    assert _get_assertion_exprs(src) == expected\n",
      "\n        pytest.param(\n            b\"def x(): assert 5\",\n            {1: \"5\"},\n            id=\"no newline at end of file\",\n        ),\n        pytest.param(\n            b\"def test():\\n    assert 1\\n\\n    @t\\ndef inner(): pass\\n\",\n            {2: \"1\"},\n            id=\"assertion followed by decorator\",\n        ),\n        # fmt: on\n    ),\n)\ndef test_get_assertion_exprs(src, expected) -> None:\n    assert _get_assertion_exprs(src) == expected\n",
      "\n        pytest.param(\n            b\"def x(): assert 5\",\n            {1: \"5\"},\n            id=\"no newline at end of file\",\n        ),\n        pytest.param(\n            b\"def test():\\n    assert 1\\n\\n    @t\\ndef inner(): pass\\n\",\n            {2: \"1\"},\n            id=\"assertion followed by decorator should not include decorator\",\n        ),\n        # fmt: on\n    ),\n)\ndef test_get_assertion_exprs(src, expected) -> None:\n    assert _get_assertion_exprs(src) == expected\n",
      "\n        pytest.param(\n            b\"def x(): assert 5\",\n            {1: \"5\"},\n            id=\"no newline at end of file\",\n        ),\n        pytest.param(\n            b\"def test():\\n    assert 1\\n\\n    @t\\ndef inner(): pass\\n\",\n            {2: \"1\"},\n            id=\"assertion followed by decorator should not include decorator\",\n        ),\n        # fmt: on\n    ),\n)\ndef test_get_assertion_exprs(src, expected) -> None:\n    assert _get_assertion_exprs(src) == expected\n",
      "\n        pytest.param(\n            b\"def x(): assert 5\",\n            {1: \"5\"},\n            id=\"no newline at end of file\",\n        ),\n        pytest.param(\n            b\"def test():\\n    assert 1\\n\\n    @t\\ndef inner(): pass\\n\",\n            {2: \"1\"},\n            id=\"assertion followed by decorator should not include decorator\",\n        ),\n        # fmt: on\n    ),\n)\ndef test_get_assertion_exprs(src, expected) -> None:\n    assert _get_assertion_exprs(src) == expected\n",
      "\n        pytest.param(\n            b\"def x(): assert 5\",\n            {1: \"5\"},\n            id=\"no newline at end of file\",\n        ),\n        pytest.param(\n            b\"def test():\\n    assert 1\\n\\n    @t\\ndef inner(): pass\\n\",\n            {2: \"1\"},\n            id=\"assertion followed by decorator should not include decorator\",\n        ),\n        # fmt: on\n    ),\n)\ndef test_get_assertion_exprs(src, expected) -> None:\n    assert _get_assertion_exprs(src) == expected\n",
      "\n        pytest.param(\n            b\"def x(): assert 5\",\n            {1: \"5\"},\n            id=\"no newline at end of file\",\n        ),\n        pytest.param(\n            b\"def test():\\n    assert 1\\n\\n    @t\\ndef inner(): pass\\n\",\n            {2: \"1\"},\n            id=\"assertion followed by decorator\",\n        ),\n        # fmt: on\n    ),\n)\ndef test_get_assertion_exprs(src, expected) -> None:\n    assert _get_assertion_exprs(src) == expected\n",
      "\n        pytest.param(\n            b\"def x(): assert 5\",\n            {1: \"5\"},\n            id=\"no newline at end of file\",\n        ),\n        pytest.param(\n            b\"def test():\\n    assert 1\\n\\n    @t\\ndef inner(): pass\\n\",\n            {2: \"1\"},\n            id=\"assertion followed by decorator should not include decorator\",\n        ),\n        # fmt: on\n    ),\n)\ndef test_get_assertion_exprs(src, expected) -> None:\n    assert _get_assertion_exprs(src) == expected\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 456681ab2..e3ca60641 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -564,6 +564,7 @@ def _get_assertion_exprs(src: bytes) -> Dict[int, str]:\n     assert_lineno: Optional[int] = None\n     seen_lines: Set[int] = set()\n \n+\n     def _write_and_reset() -> None:\n         nonlocal depth, lines, assert_lineno, seen_lines\n         assert assert_lineno is not None\n@@ -575,6 +576,7 @@ def _get_assertion_exprs(src: bytes) -> Dict[int, str]:\n \n     tokens = tokenize.tokenize(io.BytesIO(src).readline)\n     for tp, source, (lineno, offset), _, line in tokens:\n+\n         if tp == tokenize.NAME and source == \"assert\":\n             assert_lineno = lineno\n         elif assert_lineno is not None:\n@@ -600,9 +602,13 @@ def _get_assertion_exprs(src: bytes) -> Dict[int, str]:\n                 else:\n                     lines.append(line[:offset])\n                 _write_and_reset()\n+\n             elif tp in {tokenize.NEWLINE, tokenize.ENDMARKER}:\n                 _write_and_reset()\n-            elif lines and lineno not in seen_lines:\n+            elif tp == tokenize.OP and source == \"@\" and lines:\n+                _write_and_reset()\n+\n+            elif lines and lineno not in seen_lines and depth > 0:\n                 lines.append(line)\n                 seen_lines.add(lineno)\n \ndiff --git a/testing/test_assertrewrite.py b/testing/test_assertrewrite.py\nindex 61f5760e7..49b5dcade 100644\n--- a/testing/test_assertrewrite.py\n+++ b/testing/test_assertrewrite.py\n@@ -1655,6 +1655,12 @@ class TestAssertionPass:\n             {2: \"x\"},\n             id=\"escaped newlines plus message\",\n         ),\n+\n+        pytest.param(\n+            b\"def test():\\n    assert 1\\n\\n    @t\\ndef inner(): pass\\n\",\n+            {2: \"1\"},\n+            id=\"decorator after assertion\",\n+        ),\n         pytest.param(\n             b\"def x(): assert 5\",\n             {1: \"5\"},\n",
    "variant_0": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 456681ab2..71afaa2fb 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -564,20 +564,29 @@ def _get_assertion_exprs(src: bytes) -> Dict[int, str]:\n     assert_lineno: Optional[int] = None\n     seen_lines: Set[int] = set()\n \n-    def _write_and_reset() -> None:\n-        nonlocal depth, lines, assert_lineno, seen_lines\n-        assert assert_lineno is not None\n+\n+def _write_and_reset() -> None:\n+    nonlocal depth, lines, assert_lineno, seen_lines\n+    if assert_lineno is not None and lines:\n         ret[assert_lineno] = \"\".join(lines).rstrip().rstrip(\"\\\\\")\n-        depth = 0\n-        lines = []\n-        assert_lineno = None\n-        seen_lines = set()\n+    depth = 0\n+    lines = []\n+    assert_lineno = None\n+    seen_lines = set()\n \n     tokens = tokenize.tokenize(io.BytesIO(src).readline)\n     for tp, source, (lineno, offset), _, line in tokens:\n+\n         if tp == tokenize.NAME and source == \"assert\":\n             assert_lineno = lineno\n         elif assert_lineno is not None:\n+            # Check for tokens that clearly terminate an assertion\n+            if tp == tokenize.OP and source == \"@\":\n+                _write_and_reset()\n+                continue\n+            elif tp == tokenize.NAME and source in (\"def\", \"class\", \"async\"):\n+                _write_and_reset()\n+                continue\n             # keep track of depth for the assert-message `,` lookup\n             if tp == tokenize.OP and source in \"([{\":\n                 depth += 1\n@@ -600,11 +609,21 @@ def _get_assertion_exprs(src: bytes) -> Dict[int, str]:\n                 else:\n                     lines.append(line[:offset])\n                 _write_and_reset()\n+\n+            elif tp in {tokenize.NEWLINE, tokenize.ENDMARKER}:\n+                _write_and_reset()\n+                # Reset state to prevent collecting unrelated lines after assertion ends\n+                assert_lineno = None\n+\n             elif tp in {tokenize.NEWLINE, tokenize.ENDMARKER}:\n                 _write_and_reset()\n             elif lines and lineno not in seen_lines:\n-                lines.append(line)\n-                seen_lines.add(lineno)\n+                # Only append lines if we're still within the assertion context\n+                # Check if this line starts with tokens that indicate end of assertion\n+                line_stripped = line.strip()\n+                if line_stripped and not line_stripped.startswith(('@', 'def ', 'class ', 'if ', 'elif ', 'else:', 'for ', 'while ', 'with ', 'try:', 'except', 'finally:', 'return', 'yield', 'break', 'continue', 'pass', 'raise', 'import', 'from ')):\n+                    lines.append(line)\n+                    seen_lines.add(lineno)\n \n     return ret\n \ndiff --git a/testing/test_assertrewrite.py b/testing/test_assertrewrite.py\nindex 61f5760e7..82775b926 100644\n--- a/testing/test_assertrewrite.py\n+++ b/testing/test_assertrewrite.py\n@@ -1655,11 +1655,17 @@ class TestAssertionPass:\n             {2: \"x\"},\n             id=\"escaped newlines plus message\",\n         ),\n+\n         pytest.param(\n             b\"def x(): assert 5\",\n             {1: \"5\"},\n             id=\"no newline at end of file\",\n         ),\n+        pytest.param(\n+            b\"def test():\\n    assert 1\\n\\n    @t\\ndef inner(): pass\\n\",\n+            {2: \"1\"},\n+            id=\"assertion followed by decorator should not include decorator\",\n+        ),\n         # fmt: on\n     ),\n )\n",
    "variant_1": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 456681ab2..cf3d4617a 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -564,17 +564,19 @@ def _get_assertion_exprs(src: bytes) -> Dict[int, str]:\n     assert_lineno: Optional[int] = None\n     seen_lines: Set[int] = set()\n \n-    def _write_and_reset() -> None:\n-        nonlocal depth, lines, assert_lineno, seen_lines\n-        assert assert_lineno is not None\n-        ret[assert_lineno] = \"\".join(lines).rstrip().rstrip(\"\\\\\")\n-        depth = 0\n-        lines = []\n-        assert_lineno = None\n-        seen_lines = set()\n+\n+def _write_and_reset() -> None:\n+    nonlocal depth, lines, assert_lineno, seen_lines\n+    assert assert_lineno is not None\n+    ret[assert_lineno] = \"\".join(lines).rstrip().rstrip(\"\\\\\")\n+    depth = 0\n+    lines = []\n+    assert_lineno = None\n+    seen_lines = set()\n \n     tokens = tokenize.tokenize(io.BytesIO(src).readline)\n     for tp, source, (lineno, offset), _, line in tokens:\n+\n         if tp == tokenize.NAME and source == \"assert\":\n             assert_lineno = lineno\n         elif assert_lineno is not None:\n@@ -600,11 +602,29 @@ def _get_assertion_exprs(src: bytes) -> Dict[int, str]:\n                 else:\n                     lines.append(line[:offset])\n                 _write_and_reset()\n+\n             elif tp in {tokenize.NEWLINE, tokenize.ENDMARKER}:\n                 _write_and_reset()\n+\n             elif lines and lineno not in seen_lines:\n-                lines.append(line)\n-                seen_lines.add(lineno)\n+                # Only append lines if we're still within the assertion expression\n+                # Check if this line contains tokens that would terminate the assertion\n+                line_tokens = list(tokenize.generate_tokens(io.StringIO(line).readline))\n+                is_assertion_continuation = False\n+                \n+                # Check if line starts with whitespace (continuation) or contains operators/brackets\n+                stripped_line = line.strip()\n+                if stripped_line and not stripped_line.startswith(('@', 'def ', 'class ', 'if ', 'for ', 'while ', 'with ', 'try:')):\n+                    # Check for continuation patterns\n+                    for line_token in line_tokens:\n+                        if line_token.type in (tokenize.OP, tokenize.NAME) and line_token.string in ('(', '[', '{', '.', '+', '-', '*', '/', '==', '!=', '<', '>', '<=', '>=', 'and', 'or', 'not', 'in', 'is'):\n+                            is_assertion_continuation = True\n+                            break\n+                    \n+                    # Also check if previous line ended with continuation character\n+                    if lines and (lines[-1].rstrip().endswith(('\\\\', ',', '(', '[', '{')) or is_assertion_continuation):\n+                        lines.append(line)\n+                        seen_lines.add(lineno)\n \n     return ret\n \ndiff --git a/testing/test_assertrewrite.py b/testing/test_assertrewrite.py\nindex 61f5760e7..b810aa4af 100644\n--- a/testing/test_assertrewrite.py\n+++ b/testing/test_assertrewrite.py\n@@ -1655,6 +1655,12 @@ class TestAssertionPass:\n             {2: \"x\"},\n             id=\"escaped newlines plus message\",\n         ),\n+\n+        pytest.param(\n+            b\"def test():\\n    assert 1\\n\\n    @t\\ndef inner(): pass\\n\",\n+            {2: \"1\"},\n+            id=\"assertion followed by decorator should not include decorator\",\n+        ),\n         pytest.param(\n             b\"def x(): assert 5\",\n             {1: \"5\"},\n",
    "variant_2": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 456681ab2..83351ea32 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -564,20 +564,31 @@ def _get_assertion_exprs(src: bytes) -> Dict[int, str]:\n     assert_lineno: Optional[int] = None\n     seen_lines: Set[int] = set()\n \n-    def _write_and_reset() -> None:\n-        nonlocal depth, lines, assert_lineno, seen_lines\n-        assert assert_lineno is not None\n+\n+def _write_and_reset() -> None:\n+    nonlocal depth, lines, assert_lineno, seen_lines\n+    if assert_lineno is not None and lines:\n         ret[assert_lineno] = \"\".join(lines).rstrip().rstrip(\"\\\\\")\n-        depth = 0\n-        lines = []\n-        assert_lineno = None\n-        seen_lines = set()\n+    depth = 0\n+    lines = []\n+    assert_lineno = None\n+    seen_lines = set()\n \n     tokens = tokenize.tokenize(io.BytesIO(src).readline)\n     for tp, source, (lineno, offset), _, line in tokens:\n+\n         if tp == tokenize.NAME and source == \"assert\":\n             assert_lineno = lineno\n         elif assert_lineno is not None:\n+            # Check for tokens that clearly indicate the assertion has ended\n+            if tp == tokenize.OP and source == \"@\":\n+                # Decorator found - assertion is complete\n+                _write_and_reset()\n+                continue\n+            elif tp == tokenize.NAME and source in (\"def\", \"class\", \"if\", \"for\", \"while\", \"with\", \"try\"):\n+                # New statement found - assertion is complete\n+                _write_and_reset()\n+                continue\n             # keep track of depth for the assert-message `,` lookup\n             if tp == tokenize.OP and source in \"([{\":\n                 depth += 1\n@@ -600,11 +611,22 @@ def _get_assertion_exprs(src: bytes) -> Dict[int, str]:\n                 else:\n                     lines.append(line[:offset])\n                 _write_and_reset()\n+\n             elif tp in {tokenize.NEWLINE, tokenize.ENDMARKER}:\n                 _write_and_reset()\n+\n             elif lines and lineno not in seen_lines:\n-                lines.append(line)\n-                seen_lines.add(lineno)\n+                # Only append lines if we're still within the assertion context\n+                # Check if this line could be part of a multi-line assertion\n+                stripped_line = line.strip()\n+                if (stripped_line and \n+                    not stripped_line.startswith('@') and \n+                    not stripped_line.startswith('def ') and\n+                    not stripped_line.startswith('class ') and\n+                    not stripped_line.startswith('import ') and\n+                    not stripped_line.startswith('from ')):\n+                    lines.append(line)\n+                    seen_lines.add(lineno)\n \n     return ret\n \ndiff --git a/testing/test_assertrewrite.py b/testing/test_assertrewrite.py\nindex 61f5760e7..03b30e3a4 100644\n--- a/testing/test_assertrewrite.py\n+++ b/testing/test_assertrewrite.py\n@@ -1655,11 +1655,17 @@ class TestAssertionPass:\n             {2: \"x\"},\n             id=\"escaped newlines plus message\",\n         ),\n+\n         pytest.param(\n             b\"def x(): assert 5\",\n             {1: \"5\"},\n             id=\"no newline at end of file\",\n         ),\n+        pytest.param(\n+            b\"def test():\\n    assert 1\\n\\n    @t\\ndef inner(): pass\\n\",\n+            {2: \"1\"},\n+            id=\"assertion followed by decorator\",\n+        ),\n         # fmt: on\n     ),\n )\n",
    "variant_3": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 456681ab2..6f2f1ce81 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -564,20 +564,29 @@ def _get_assertion_exprs(src: bytes) -> Dict[int, str]:\n     assert_lineno: Optional[int] = None\n     seen_lines: Set[int] = set()\n \n-    def _write_and_reset() -> None:\n-        nonlocal depth, lines, assert_lineno, seen_lines\n-        assert assert_lineno is not None\n+\n+def _write_and_reset() -> None:\n+    nonlocal depth, lines, assert_lineno, seen_lines\n+    if assert_lineno is not None and lines:\n         ret[assert_lineno] = \"\".join(lines).rstrip().rstrip(\"\\\\\")\n-        depth = 0\n-        lines = []\n-        assert_lineno = None\n-        seen_lines = set()\n+    depth = 0\n+    lines = []\n+    assert_lineno = None\n+    seen_lines = set()\n \n     tokens = tokenize.tokenize(io.BytesIO(src).readline)\n     for tp, source, (lineno, offset), _, line in tokens:\n+\n         if tp == tokenize.NAME and source == \"assert\":\n             assert_lineno = lineno\n         elif assert_lineno is not None:\n+            # Check for tokens that clearly end an assertion (decorators, function definitions, etc.)\n+            if tp == tokenize.OP and source == \"@\":\n+                _write_and_reset()\n+                continue\n+            elif tp == tokenize.NAME and source in (\"def\", \"class\", \"async\"):\n+                _write_and_reset()\n+                continue\n             # keep track of depth for the assert-message `,` lookup\n             if tp == tokenize.OP and source in \"([{\":\n                 depth += 1\n@@ -600,11 +609,17 @@ def _get_assertion_exprs(src: bytes) -> Dict[int, str]:\n                 else:\n                     lines.append(line[:offset])\n                 _write_and_reset()\n+\n             elif tp in {tokenize.NEWLINE, tokenize.ENDMARKER}:\n                 _write_and_reset()\n+\n             elif lines and lineno not in seen_lines:\n-                lines.append(line)\n-                seen_lines.add(lineno)\n+                # Only append lines if we're still within the assertion context\n+                # Check if this line starts with tokens that indicate assertion end\n+                line_stripped = line.strip()\n+                if line_stripped and not line_stripped.startswith(('@', 'def ', 'class ', 'if ', 'for ', 'while ', 'with ', 'try:', 'except', 'finally:', 'else:', 'elif ')):\n+                    lines.append(line)\n+                    seen_lines.add(lineno)\n \n     return ret\n \ndiff --git a/testing/test_assertrewrite.py b/testing/test_assertrewrite.py\nindex 61f5760e7..82775b926 100644\n--- a/testing/test_assertrewrite.py\n+++ b/testing/test_assertrewrite.py\n@@ -1655,11 +1655,17 @@ class TestAssertionPass:\n             {2: \"x\"},\n             id=\"escaped newlines plus message\",\n         ),\n+\n         pytest.param(\n             b\"def x(): assert 5\",\n             {1: \"5\"},\n             id=\"no newline at end of file\",\n         ),\n+        pytest.param(\n+            b\"def test():\\n    assert 1\\n\\n    @t\\ndef inner(): pass\\n\",\n+            {2: \"1\"},\n+            id=\"assertion followed by decorator should not include decorator\",\n+        ),\n         # fmt: on\n     ),\n )\n",
    "variant_4": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 456681ab2..725e4ba7d 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -564,20 +564,31 @@ def _get_assertion_exprs(src: bytes) -> Dict[int, str]:\n     assert_lineno: Optional[int] = None\n     seen_lines: Set[int] = set()\n \n-    def _write_and_reset() -> None:\n-        nonlocal depth, lines, assert_lineno, seen_lines\n-        assert assert_lineno is not None\n+\n+def _write_and_reset() -> None:\n+    nonlocal depth, lines, assert_lineno, seen_lines\n+    if assert_lineno is not None and lines:\n         ret[assert_lineno] = \"\".join(lines).rstrip().rstrip(\"\\\\\")\n-        depth = 0\n-        lines = []\n-        assert_lineno = None\n-        seen_lines = set()\n+    depth = 0\n+    lines = []\n+    assert_lineno = None\n+    seen_lines = set()\n \n     tokens = tokenize.tokenize(io.BytesIO(src).readline)\n     for tp, source, (lineno, offset), _, line in tokens:\n+\n         if tp == tokenize.NAME and source == \"assert\":\n             assert_lineno = lineno\n         elif assert_lineno is not None:\n+            # Check for tokens that clearly terminate an assertion\n+            if tp == tokenize.OP and source == \"@\":\n+                # Decorator found - assertion is complete\n+                _write_and_reset()\n+                continue\n+            elif tp == tokenize.NAME and source in (\"def\", \"class\", \"async\"):\n+                # Function/class definition found - assertion is complete\n+                _write_and_reset()\n+                continue\n             # keep track of depth for the assert-message `,` lookup\n             if tp == tokenize.OP and source in \"([{\":\n                 depth += 1\n@@ -600,11 +611,22 @@ def _get_assertion_exprs(src: bytes) -> Dict[int, str]:\n                 else:\n                     lines.append(line[:offset])\n                 _write_and_reset()\n+\n+            elif tp in {tokenize.NEWLINE, tokenize.ENDMARKER}:\n+                _write_and_reset()\n+                # Reset state to prevent collecting unrelated lines after assertion ends\n+                assert_lineno = None\n+\n             elif tp in {tokenize.NEWLINE, tokenize.ENDMARKER}:\n                 _write_and_reset()\n             elif lines and lineno not in seen_lines:\n-                lines.append(line)\n-                seen_lines.add(lineno)\n+                # Only append lines if we're still in the assertion context\n+                # Check if this is a decorator or other construct that should end collection\n+                if source.lstrip().startswith('@') or source.lstrip().startswith('def ') or source.lstrip().startswith('class '):\n+                    _write_and_reset()\n+                else:\n+                    lines.append(line)\n+                    seen_lines.add(lineno)\n \n     return ret\n \ndiff --git a/testing/test_assertrewrite.py b/testing/test_assertrewrite.py\nindex 61f5760e7..82775b926 100644\n--- a/testing/test_assertrewrite.py\n+++ b/testing/test_assertrewrite.py\n@@ -1655,11 +1655,17 @@ class TestAssertionPass:\n             {2: \"x\"},\n             id=\"escaped newlines plus message\",\n         ),\n+\n         pytest.param(\n             b\"def x(): assert 5\",\n             {1: \"5\"},\n             id=\"no newline at end of file\",\n         ),\n+        pytest.param(\n+            b\"def test():\\n    assert 1\\n\\n    @t\\ndef inner(): pass\\n\",\n+            {2: \"1\"},\n+            id=\"assertion followed by decorator should not include decorator\",\n+        ),\n         # fmt: on\n     ),\n )\n",
    "variant_5": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 456681ab2..8a7bf72c8 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -564,20 +564,29 @@ def _get_assertion_exprs(src: bytes) -> Dict[int, str]:\n     assert_lineno: Optional[int] = None\n     seen_lines: Set[int] = set()\n \n-    def _write_and_reset() -> None:\n-        nonlocal depth, lines, assert_lineno, seen_lines\n-        assert assert_lineno is not None\n+\n+def _write_and_reset() -> None:\n+    nonlocal depth, lines, assert_lineno, seen_lines\n+    if assert_lineno is not None and lines:\n         ret[assert_lineno] = \"\".join(lines).rstrip().rstrip(\"\\\\\")\n-        depth = 0\n-        lines = []\n-        assert_lineno = None\n-        seen_lines = set()\n+    depth = 0\n+    lines = []\n+    assert_lineno = None\n+    seen_lines = set()\n \n     tokens = tokenize.tokenize(io.BytesIO(src).readline)\n     for tp, source, (lineno, offset), _, line in tokens:\n+\n         if tp == tokenize.NAME and source == \"assert\":\n             assert_lineno = lineno\n         elif assert_lineno is not None:\n+            # Check for tokens that clearly terminate an assertion\n+            if tp == tokenize.OP and source == \"@\":\n+                _write_and_reset()\n+                continue\n+            elif tp == tokenize.NAME and source in (\"def\", \"class\", \"async\"):\n+                _write_and_reset()\n+                continue\n             # keep track of depth for the assert-message `,` lookup\n             if tp == tokenize.OP and source in \"([{\":\n                 depth += 1\n@@ -600,11 +609,23 @@ def _get_assertion_exprs(src: bytes) -> Dict[int, str]:\n                 else:\n                     lines.append(line[:offset])\n                 _write_and_reset()\n+\n             elif tp in {tokenize.NEWLINE, tokenize.ENDMARKER}:\n                 _write_and_reset()\n+                # Reset state to prevent collecting unrelated subsequent lines\n+                if tp == tokenize.NEWLINE and not lines:\n+                    assert_lineno = None\n+\n             elif lines and lineno not in seen_lines:\n-                lines.append(line)\n-                seen_lines.add(lineno)\n+                # Only append lines if we're still within the assertion context\n+                # Check if this line starts with tokens that clearly end the assertion\n+                line_stripped = line.strip()\n+                if line_stripped.startswith(('@', 'def ', 'class ', 'if ', 'for ', 'while ', 'with ', 'try:')):\n+                    # This line starts a new construct, don't include it\n+                    _write_and_reset()\n+                else:\n+                    lines.append(line)\n+                    seen_lines.add(lineno)\n \n     return ret\n \ndiff --git a/testing/test_assertrewrite.py b/testing/test_assertrewrite.py\nindex 61f5760e7..82775b926 100644\n--- a/testing/test_assertrewrite.py\n+++ b/testing/test_assertrewrite.py\n@@ -1655,11 +1655,17 @@ class TestAssertionPass:\n             {2: \"x\"},\n             id=\"escaped newlines plus message\",\n         ),\n+\n         pytest.param(\n             b\"def x(): assert 5\",\n             {1: \"5\"},\n             id=\"no newline at end of file\",\n         ),\n+        pytest.param(\n+            b\"def test():\\n    assert 1\\n\\n    @t\\ndef inner(): pass\\n\",\n+            {2: \"1\"},\n+            id=\"assertion followed by decorator should not include decorator\",\n+        ),\n         # fmt: on\n     ),\n )\n",
    "variant_6": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 456681ab2..5412fcc21 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -564,20 +564,29 @@ def _get_assertion_exprs(src: bytes) -> Dict[int, str]:\n     assert_lineno: Optional[int] = None\n     seen_lines: Set[int] = set()\n \n-    def _write_and_reset() -> None:\n-        nonlocal depth, lines, assert_lineno, seen_lines\n-        assert assert_lineno is not None\n+\n+def _write_and_reset() -> None:\n+    nonlocal depth, lines, assert_lineno, seen_lines\n+    if assert_lineno is not None and lines:\n         ret[assert_lineno] = \"\".join(lines).rstrip().rstrip(\"\\\\\")\n-        depth = 0\n-        lines = []\n-        assert_lineno = None\n-        seen_lines = set()\n+    depth = 0\n+    lines = []\n+    assert_lineno = None\n+    seen_lines = set()\n \n     tokens = tokenize.tokenize(io.BytesIO(src).readline)\n     for tp, source, (lineno, offset), _, line in tokens:\n+\n         if tp == tokenize.NAME and source == \"assert\":\n             assert_lineno = lineno\n         elif assert_lineno is not None:\n+            # Check if we've encountered a decorator or function definition that ends the assertion\n+            if tp == tokenize.OP and source == \"@\":\n+                _write_and_reset()\n+                continue\n+            elif tp == tokenize.NAME and source == \"def\":\n+                _write_and_reset()\n+                continue\n             # keep track of depth for the assert-message `,` lookup\n             if tp == tokenize.OP and source in \"([{\":\n                 depth += 1\n@@ -600,11 +609,22 @@ def _get_assertion_exprs(src: bytes) -> Dict[int, str]:\n                 else:\n                     lines.append(line[:offset])\n                 _write_and_reset()\n+\n             elif tp in {tokenize.NEWLINE, tokenize.ENDMARKER}:\n                 _write_and_reset()\n-            elif lines and lineno not in seen_lines:\n-                lines.append(line)\n-                seen_lines.add(lineno)\n+\n+            elif lines and lineno not in seen_lines and tp not in {tokenize.OP}:\n+                # Only append lines if we're still within the assertion context\n+                # Check if this is a continuation of the assertion or a new construct\n+                if tp == tokenize.OP and source == '@':\n+                    # Decorator found - stop collecting lines\n+                    _write_and_reset()\n+                elif tp == tokenize.NAME and source in {'def', 'class', 'async'}:\n+                    # Function/class definition found - stop collecting lines\n+                    _write_and_reset()\n+                else:\n+                    lines.append(line)\n+                    seen_lines.add(lineno)\n \n     return ret\n \ndiff --git a/testing/test_assertrewrite.py b/testing/test_assertrewrite.py\nindex 61f5760e7..82775b926 100644\n--- a/testing/test_assertrewrite.py\n+++ b/testing/test_assertrewrite.py\n@@ -1655,11 +1655,17 @@ class TestAssertionPass:\n             {2: \"x\"},\n             id=\"escaped newlines plus message\",\n         ),\n+\n         pytest.param(\n             b\"def x(): assert 5\",\n             {1: \"5\"},\n             id=\"no newline at end of file\",\n         ),\n+        pytest.param(\n+            b\"def test():\\n    assert 1\\n\\n    @t\\ndef inner(): pass\\n\",\n+            {2: \"1\"},\n+            id=\"assertion followed by decorator should not include decorator\",\n+        ),\n         # fmt: on\n     ),\n )\n",
    "variant_7": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 456681ab2..015286a4e 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -564,17 +564,19 @@ def _get_assertion_exprs(src: bytes) -> Dict[int, str]:\n     assert_lineno: Optional[int] = None\n     seen_lines: Set[int] = set()\n \n-    def _write_and_reset() -> None:\n-        nonlocal depth, lines, assert_lineno, seen_lines\n-        assert assert_lineno is not None\n-        ret[assert_lineno] = \"\".join(lines).rstrip().rstrip(\"\\\\\")\n-        depth = 0\n-        lines = []\n-        assert_lineno = None\n-        seen_lines = set()\n+\n+def _write_and_reset() -> None:\n+    nonlocal depth, lines, assert_lineno, seen_lines\n+    assert assert_lineno is not None\n+    ret[assert_lineno] = \"\".join(lines).rstrip().rstrip(\"\\\\\")\n+    depth = 0\n+    lines = []\n+    assert_lineno = None\n+    seen_lines = set()\n \n     tokens = tokenize.tokenize(io.BytesIO(src).readline)\n     for tp, source, (lineno, offset), _, line in tokens:\n+\n         if tp == tokenize.NAME and source == \"assert\":\n             assert_lineno = lineno\n         elif assert_lineno is not None:\n@@ -600,11 +602,16 @@ def _get_assertion_exprs(src: bytes) -> Dict[int, str]:\n                 else:\n                     lines.append(line[:offset])\n                 _write_and_reset()\n+\n             elif tp in {tokenize.NEWLINE, tokenize.ENDMARKER}:\n                 _write_and_reset()\n+\n             elif lines and lineno not in seen_lines:\n-                lines.append(line)\n-                seen_lines.add(lineno)\n+                # Only add lines that are part of the assertion expression\n+                # Check if we're still within the assertion context\n+                if assert_lineno is not None and tp not in {tokenize.OP} or (tp == tokenize.OP and source not in {'@'}):\n+                    lines.append(line)\n+                    seen_lines.add(lineno)\n \n     return ret\n \ndiff --git a/testing/test_assertrewrite.py b/testing/test_assertrewrite.py\nindex 61f5760e7..03b30e3a4 100644\n--- a/testing/test_assertrewrite.py\n+++ b/testing/test_assertrewrite.py\n@@ -1655,11 +1655,17 @@ class TestAssertionPass:\n             {2: \"x\"},\n             id=\"escaped newlines plus message\",\n         ),\n+\n         pytest.param(\n             b\"def x(): assert 5\",\n             {1: \"5\"},\n             id=\"no newline at end of file\",\n         ),\n+        pytest.param(\n+            b\"def test():\\n    assert 1\\n\\n    @t\\ndef inner(): pass\\n\",\n+            {2: \"1\"},\n+            id=\"assertion followed by decorator\",\n+        ),\n         # fmt: on\n     ),\n )\n",
    "variant_8": "diff --git a/src/_pytest/assertion/rewrite.py b/src/_pytest/assertion/rewrite.py\nindex 456681ab2..cc7a79343 100644\n--- a/src/_pytest/assertion/rewrite.py\n+++ b/src/_pytest/assertion/rewrite.py\n@@ -564,20 +564,27 @@ def _get_assertion_exprs(src: bytes) -> Dict[int, str]:\n     assert_lineno: Optional[int] = None\n     seen_lines: Set[int] = set()\n \n-    def _write_and_reset() -> None:\n-        nonlocal depth, lines, assert_lineno, seen_lines\n-        assert assert_lineno is not None\n+\n+def _write_and_reset() -> None:\n+    nonlocal depth, lines, assert_lineno, seen_lines\n+    if assert_lineno is not None and lines:\n         ret[assert_lineno] = \"\".join(lines).rstrip().rstrip(\"\\\\\")\n-        depth = 0\n-        lines = []\n-        assert_lineno = None\n-        seen_lines = set()\n+    depth = 0\n+    lines = []\n+    assert_lineno = None\n+    seen_lines = set()\n \n     tokens = tokenize.tokenize(io.BytesIO(src).readline)\n     for tp, source, (lineno, offset), _, line in tokens:\n+\n         if tp == tokenize.NAME and source == \"assert\":\n             assert_lineno = lineno\n         elif assert_lineno is not None:\n+            # Stop collecting if we encounter a decorator or function definition\n+            if tp == tokenize.OP and source == \"@\":\n+                _write_and_reset()\n+            elif tp == tokenize.NAME and source == \"def\":\n+                _write_and_reset()\n             # keep track of depth for the assert-message `,` lookup\n             if tp == tokenize.OP and source in \"([{\":\n                 depth += 1\n@@ -600,11 +607,19 @@ def _get_assertion_exprs(src: bytes) -> Dict[int, str]:\n                 else:\n                     lines.append(line[:offset])\n                 _write_and_reset()\n+\n             elif tp in {tokenize.NEWLINE, tokenize.ENDMARKER}:\n                 _write_and_reset()\n+                # Reset state to prevent collecting unrelated lines after assertion ends\n+                if tp == tokenize.NEWLINE and not lines:\n+                    assert_lineno = None\n+\n             elif lines and lineno not in seen_lines:\n-                lines.append(line)\n-                seen_lines.add(lineno)\n+                # Only append lines if we're still within the assertion context\n+                # Check if this line could be part of a multi-line assertion\n+                if (tp not in {tokenize.OP} or source not in {'@'}) and not line.strip().startswith('@'):\n+                    lines.append(line)\n+                    seen_lines.add(lineno)\n \n     return ret\n \ndiff --git a/testing/test_assertrewrite.py b/testing/test_assertrewrite.py\nindex 61f5760e7..82775b926 100644\n--- a/testing/test_assertrewrite.py\n+++ b/testing/test_assertrewrite.py\n@@ -1655,11 +1655,17 @@ class TestAssertionPass:\n             {2: \"x\"},\n             id=\"escaped newlines plus message\",\n         ),\n+\n         pytest.param(\n             b\"def x(): assert 5\",\n             {1: \"5\"},\n             id=\"no newline at end of file\",\n         ),\n+        pytest.param(\n+            b\"def test():\\n    assert 1\\n\\n    @t\\ndef inner(): pass\\n\",\n+            {2: \"1\"},\n+            id=\"assertion followed by decorator should not include decorator\",\n+        ),\n         # fmt: on\n     ),\n )\n"
  }
}