{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/django/django/forms/widgets.py lines 118-150)": "\n    @staticmethod\n    def merge(list_1, list_2):\n        \"\"\"\n        Merge two lists while trying to keep the relative order of the elements.\n        Warn if the lists have the same two elements in a different relative\n        order.\n\n        For static assets it can be important to have them included in the DOM\n        in a certain order. In JavaScript you may not be able to reference a\n        global or in CSS you might want to override a style.\n        \"\"\"\n        if not list_1:\n            return list(list_2)\n        if not list_2:\n            return list(list_1)\n        \n        # Build a dependency graph based on the order in each list\n        dependencies = {}  # item -> set of items that must come before it\n        all_items = set(list_1) | set(list_2)\n        \n        for item in all_items:\n            dependencies[item] = set()\n        \n        # Add dependencies from list_1\n        for i in range(len(list_1) - 1):\n            dependencies[list_1[i + 1]].add(list_1[i])\n        \n        # Add dependencies from list_2, checking for conflicts\n        for i in range(len(list_2) - 1):\n            current = list_2[i]\n            next_item = list_2[i + 1]\n            \n            # Check if this would create a conflict with list_1's ordering\n            if (current in list_1 and next_item in list_1 and \n                list_1.index(current) > list_1.index(next_item)):\n                warnings.warn(\n                    'Detected duplicate Media files in an opposite order:\\n'\n                    '%s\\n%s' % (current, next_item),\n                    MediaOrderConflictWarning,\n                )\n            \n            dependencies[next_item].add(current)\n        \n        # Topological sort using Kahn's algorithm\n        result = []\n        in_degree = {item: len(dependencies[item]) for item in all_items}\n        queue = [item for item in all_items if in_degree[item] == 0]\n        \n        # Sort queue to ensure deterministic output when multiple items have no dependencies\n        queue.sort(key=lambda x: (list_1.index(x) if x in list_1 else float('inf'),\n                                  list_2.index(x) if x in list_2 else float('inf')))\n        \n        while queue:\n            current = queue.pop(0)\n            result.append(current)\n            \n            # Remove current from all dependency sets and update in_degree\n            for item in all_items:\n                if current in dependencies[item]:\n                    dependencies[item].remove(current)\n                    in_degree[item] -= 1\n                    if in_degree[item] == 0:\n                        queue.append(item)\n            \n            # Keep queue sorted for deterministic output\n            queue.sort(key=lambda x: (list_1.index(x) if x in list_1 else float('inf'),\n                                      list_2.index(x) if x in list_2 else float('inf')))\n        \n        return result\n",
    "Location 2 (/root/hy/projects_2/django/django/forms/widgets.py lines 72-77)": "\n    @property\n    def _js(self):\n        # Collect all JS lists for global merge instead of sequential pairwise merging\n        all_js_lists = [js_list for js_list in self._js_lists if js_list]\n        if not all_js_lists:\n            return []\n        elif len(all_js_lists) == 1:\n            return all_js_lists[0]\n        else:\n            # Perform single global merge of all lists to avoid false intermediate constraints\n            return self.merge_all(all_js_lists)\n",
    "Location 3 (/root/hy/projects_2/django/django/forms/widgets.py lines 141-146)": "\n    def merge(self, list_1, list_2):\n        \"\"\"\n        Merge two lists while trying to keep the relative order of elements.\n        Warn if the lists have the same elements in a different relative order.\n        \n        For example, merging:\n        ['a', 'b', 'c', 'd']\n        ['b', 'd', 'e']\n        Would result in:\n        ['a', 'b', 'c', 'd', 'e']\n        \"\"\"\n        # Convert lists to preserve order while allowing efficient lookups\n        combined_list = list(list_1)\n        \n        # Track positions of elements from list_1 for conflict detection\n        list_1_positions = {item: i for i, item in enumerate(list_1)}\n        \n        # Process list_2 elements in forward order\n        for item in list_2:\n            if item in combined_list:\n                # Item already exists, check for ordering conflicts\n                current_index = combined_list.index(item)\n                \n                # Find the best insertion point based on dependencies\n                insert_index = current_index\n                \n                # Look for items that should come before this one based on list_2\n                item_index_in_list_2 = list_2.index(item)\n                for j in range(item_index_in_list_2):\n                    predecessor = list_2[j]\n                    if predecessor in combined_list:\n                        pred_index = combined_list.index(predecessor)\n                        insert_index = max(insert_index, pred_index + 1)\n                \n                # Check for genuine ordering conflicts\n                if item in list_1_positions:\n                    # Find items that appear after this item in list_1 but before it in list_2\n                    for k in range(item_index_in_list_2):\n                        other_item = list_2[k]\n                        if (other_item in list_1_positions and \n                            list_1_positions[other_item] > list_1_positions[item]):\n                            warnings.warn(\n                                'Detected duplicate Media files in an opposite order:\\n'\n                                '%s\\n%s' % (other_item, item),\n                                MediaOrderConflictWarning,\n                            )\n                            break\n                \n                # Move item to correct position if needed\n                if insert_index != current_index:\n                    combined_list.pop(current_index)\n                    combined_list.insert(insert_index if insert_index <= current_index else insert_index - 1, item)\n            else:\n                # Item doesn't exist, find the best insertion point\n                insert_index = len(combined_list)\n                \n                # Look for items that should come before this one\n                item_index_in_list_2 = list_2.index(item)\n                for j in range(item_index_in_list_2):\n                    predecessor = list_2[j]\n                    if predecessor in combined_list:\n                        pred_index = combined_list.index(predecessor)\n                        insert_index = min(insert_index, pred_index + 1)\n                \n                # Look for items that should come after this one\n                for j in range(item_index_in_list_2 + 1, len(list_2)):\n                    successor = list_2[j]\n                    if successor in combined_list:\n                        succ_index = combined_list.index(successor)\n                        insert_index = min(insert_index, succ_index)\n                        break\n                \n                combined_list.insert(insert_index, item)\n        \n        return combined_list\n",
    "Location 4 (/root/hy/projects_2/django/django/forms/widgets.py lines 152-156)": "\n    def __add__(self, other):\n        combined = Media()\n        # Preserve original media lists for global dependency resolution\n        combined._css_lists = list(self._css_lists) + list(other._css_lists)\n        combined._js_lists = list(self._js_lists) + list(other._js_lists)\n        return combined\n",
    "Location 5 (/root/hy/projects_2/django/django/forms/widgets.py lines 133-149)": "\n    def merge(self, list_1, list_2):\n        \"\"\"\n        Merge two lists while trying to keep the relative order of the elements.\n        Warn if the lists have the same elements in a different relative order.\n\n        For static assets it can be important to have them included in the DOM\n        in a certain order. In JavaScript you may not be able to reference a\n        global or in CSS you might want to override a style.\n        \"\"\"\n        if not list_1:\n            return list(list_2)\n        if not list_2:\n            return list(list_1)\n            \n        # Build dependency graph from both lists\n        dependencies = {}\n        all_items = set(list_1) | set(list_2)\n        \n        for item in all_items:\n            dependencies[item] = set()\n        \n        # Add dependencies from list_1\n        for i in range(len(list_1) - 1):\n            dependencies[list_1[i + 1]].add(list_1[i])\n            \n        # Add dependencies from list_2, checking for conflicts\n        for i in range(len(list_2) - 1):\n            curr_item = list_2[i + 1]\n            prev_item = list_2[i]\n            \n            # Check if this creates a cycle (genuine conflict)\n            if self._would_create_cycle(dependencies, prev_item, curr_item):\n                # Find the conflicting items for warning\n                pos1_in_list1 = list_1.index(curr_item) if curr_item in list_1 else -1\n                pos2_in_list1 = list_1.index(prev_item) if prev_item in list_1 else -1\n                \n                if pos1_in_list1 != -1 and pos2_in_list1 != -1 and pos1_in_list1 < pos2_in_list1:\n                    warnings.warn(\n                        'Detected duplicate Media files in an opposite order:\\n'\n                        '%s\\n%s' % (prev_item, curr_item),\n                        MediaOrderConflictWarning,\n                    )\n            else:\n                dependencies[curr_item].add(prev_item)\n        \n        # Topological sort\n        return self._topological_sort(dependencies, list_1, list_2)\n    \n    def _would_create_cycle(self, dependencies, from_item, to_item):\n        \"\"\"Check if adding dependency from_item -> to_item would create a cycle.\"\"\"\n        if from_item == to_item:\n            return True\n            \n        visited = set()\n        \n        def has_path(start, end):\n            if start == end:\n                return True\n            if start in visited:\n                return False\n            visited.add(start)\n            \n            for dep in dependencies.get(start, set()):\n                if has_path(dep, end):\n                    return True\n            return False\n        \n        return has_path(to_item, from_item)\n    \n    def _topological_sort(self, dependencies, list_1, list_2):\n        \"\"\"Perform topological sort respecting original list priorities.\"\"\"\n        result = []\n        remaining = set(dependencies.keys())\n        \n        # Priority order: items appearing earlier in list_1, then list_2\n        def get_priority(item):\n            try:\n                return (0, list_1.index(item))\n            except ValueError:\n                try:\n                    return (1, list_2.index(item))\n                except ValueError:\n                    return (2, 0)\n        \n        while remaining:\n            # Find items with no remaining dependencies\n            ready = [item for item in remaining \n                    if not (dependencies[item] & remaining)]\n            \n            if not ready:\n                # Cycle detected, break it by choosing highest priority item\n                ready = [min(remaining, key=get_priority)]\n            \n            # Sort ready items by priority\n            ready.sort(key=get_priority)\n            next_item = ready[0]\n            \n            result.append(next_item)\n            remaining.remove(next_item)\n        \n        return result\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/django/django/forms/widgets.py lines 118-150)": [
      "\n    @staticmethod\n    def merge(list_1, list_2):\n        \"\"\"\n        Merge two lists while trying to keep the relative order of the elements.\n        Warn if the lists have the same two elements in a different relative\n        order.\n\n        For static assets it can be important to have them included in the DOM\n        in a certain order. In JavaScript you may not be able to reference a\n        global or in CSS you might want to override a style.\n        \"\"\"\n        if not list_1:\n            return list(list_2)\n        if not list_2:\n            return list(list_1)\n        \n        # Build a dependency graph from both lists\n        dependencies = {}\n        all_items = set(list_1) | set(list_2)\n        \n        for item in all_items:\n            dependencies[item] = set()\n        \n        # Add dependencies from list_1\n        for i in range(len(list_1) - 1):\n            dependencies[list_1[i + 1]].add(list_1[i])\n        \n        # Add dependencies from list_2, checking for conflicts\n        for i in range(len(list_2) - 1):\n            current = list_2[i + 1]\n            predecessor = list_2[i]\n            \n            # Check if adding this dependency would create a conflict\n            if predecessor in dependencies[current]:\n                continue  # Already have this dependency\n            \n            # Check for reverse dependency (conflict)\n            if current in dependencies[predecessor]:\n                # Find the conflicting items in their original contexts\n                list_1_has_conflict = False\n                list_2_has_conflict = False\n                \n                try:\n                    idx1_pred = list_1.index(predecessor)\n                    idx1_curr = list_1.index(current)\n                    list_1_has_conflict = idx1_pred > idx1_curr\n                except ValueError:\n                    pass\n                \n                try:\n                    idx2_pred = list_2.index(predecessor)\n                    idx2_curr = list_2.index(current)\n                    list_2_has_conflict = idx2_pred < idx2_curr\n                except ValueError:\n                    pass\n                \n                if list_1_has_conflict and list_2_has_conflict:\n                    warnings.warn(\n                        'Detected duplicate Media files in an opposite order:\\n'\n                        '%s\\n%s' % (predecessor, current),\n                        MediaOrderConflictWarning,\n                    )\n                continue\n            \n            dependencies[current].add(predecessor)\n        \n        # Topological sort using Kahn's algorithm\n        in_degree = {item: len(deps) for item, deps in dependencies.items()}\n        queue = [item for item in all_items if in_degree[item] == 0]\n        result = []\n        \n        while queue:\n            # Sort queue to ensure deterministic output\n            queue.sort()\n            current = queue.pop(0)\n            result.append(current)\n            \n            # Update in-degrees of dependent items\n            for item, deps in dependencies.items():\n                if current in deps:\n                    in_degree[item] -= 1\n                    if in_degree[item] == 0:\n                        queue.append(item)\n        \n        # Check for cycles (shouldn't happen with valid input)\n        if len(result) != len(all_items):\n            # Fallback to original behavior if cycle detected\n            combined_list = list(list_1)\n            for item in list_2:\n                if item not in combined_list:\n                    combined_list.append(item)\n            return combined_list\n        \n        return result\n",
      "\n    @staticmethod\n    def merge(list_1, list_2):\n        \"\"\"\n        Merge two lists while trying to keep the relative order of the elements.\n        Warn if the lists have the same two elements in a different relative\n        order.\n\n        For static assets it can be important to have them included in the DOM\n        in a certain order. In JavaScript you may not be able to reference a\n        global or in CSS you might want to override a style.\n        \"\"\"\n        if not list_1:\n            return list(list_2)\n        if not list_2:\n            return list(list_1)\n        \n        # Build a dependency graph based on relative ordering in each list\n        dependencies = {}  # item -> set of items that must come before it\n        all_items = set(list_1) | set(list_2)\n        \n        for item in all_items:\n            dependencies[item] = set()\n        \n        # Add dependencies from list_1\n        for i, item in enumerate(list_1):\n            for j in range(i):\n                dependencies[item].add(list_1[j])\n        \n        # Add dependencies from list_2, checking for conflicts\n        for i, item in enumerate(list_2):\n            for j in range(i):\n                predecessor = list_2[j]\n                if predecessor in dependencies[item]:\n                    continue  # Already have this dependency\n                \n                # Check for conflict: item should come before predecessor in list_1\n                if item in dependencies[predecessor]:\n                    warnings.warn(\n                        'Detected duplicate Media files in an opposite order:\\n'\n                        '%s\\n%s' % (predecessor, item),\n                        MediaOrderConflictWarning,\n                    )\n                else:\n                    dependencies[item].add(predecessor)\n        \n        # Topological sort\n        result = []\n        visited = set()\n        temp_visited = set()\n        \n        def visit(item):\n            if item in temp_visited:\n                # Circular dependency - just add the item\n                return\n            if item in visited:\n                return\n            \n            temp_visited.add(item)\n            for dep in dependencies[item]:\n                if dep in all_items:\n                    visit(dep)\n            temp_visited.remove(item)\n            visited.add(item)\n            result.append(item)\n        \n        for item in all_items:\n            if item not in visited:\n                visit(item)\n        \n        return result\n",
      "\n    @staticmethod\n    def merge(list_1, list_2):\n        \"\"\"\n        Merge two lists while trying to keep the relative order of the elements.\n        Warn if the lists have the same two elements in a different relative\n        order.\n\n        For static assets it can be important to have them included in the DOM\n        in a certain order. In JavaScript you may not be able to reference a\n        global or in CSS you might want to override a style.\n        \"\"\"\n        if not list_1:\n            return list(list_2)\n        if not list_2:\n            return list(list_1)\n        \n        # Build dependency graphs from both lists\n        deps_1 = {}\n        deps_2 = {}\n        all_items = set(list_1) | set(list_2)\n        \n        # Extract dependencies from list_1\n        for i in range(len(list_1) - 1):\n            item = list_1[i]\n            if item not in deps_1:\n                deps_1[item] = set()\n            deps_1[item].add(list_1[i + 1])\n        \n        # Extract dependencies from list_2\n        for i in range(len(list_2) - 1):\n            item = list_2[i]\n            if item not in deps_2:\n                deps_2[item] = set()\n            deps_2[item].add(list_2[i + 1])\n        \n        # Check for genuine conflicts (same items in opposite order)\n        for item1 in all_items:\n            for item2 in all_items:\n                if item1 != item2:\n                    # Check if item1 -> item2 in list_1 but item2 -> item1 in list_2\n                    deps1_has_12 = item1 in deps_1 and item2 in deps_1[item1]\n                    deps2_has_21 = item2 in deps_2 and item1 in deps_2[item2]\n                    if deps1_has_12 and deps2_has_21:\n                        warnings.warn(\n                            'Detected duplicate Media files in an opposite order:\\n'\n                            '%s\\n%s' % (item1, item2),\n                            MediaOrderConflictWarning,\n                        )\n        \n        # Merge dependencies, preferring list_1's ordering\n        merged_deps = {}\n        for item in all_items:\n            merged_deps[item] = set()\n            if item in deps_1:\n                merged_deps[item].update(deps_1[item])\n            if item in deps_2:\n                merged_deps[item].update(deps_2[item])\n        \n        # Topological sort\n        result = []\n        in_degree = {item: 0 for item in all_items}\n        \n        # Calculate in-degrees\n        for item in all_items:\n            for dep in merged_deps[item]:\n                in_degree[dep] += 1\n        \n        # Queue items with no dependencies, maintaining original order preference\n        queue = []\n        for item in list_1 + [x for x in list_2 if x not in list_1]:\n            if in_degree[item] == 0:\n                queue.append(item)\n        \n        while queue:\n            current = queue.pop(0)\n            result.append(current)\n            \n            # Process dependencies in stable order\n            deps_to_process = sorted(merged_deps[current])\n            for dep in deps_to_process:\n                in_degree[dep] -= 1\n                if in_degree[dep] == 0:\n                    queue.append(dep)\n        \n        return result\n",
      "\n    @staticmethod\n    def merge(list_1, list_2):\n        \"\"\"\n        Merge two lists while trying to keep the relative order of the elements.\n        Warn if the lists have the same two elements in a different relative\n        order.\n\n        For static assets it can be important to have them included in the DOM\n        in a certain order. In JavaScript you may not be able to reference a\n        global or in CSS you might want to override a style.\n        \"\"\"\n        if not list_1:\n            return list(list_2)\n        if not list_2:\n            return list(list_1)\n        \n        # Build dependency graphs from both lists\n        deps_1 = {}\n        deps_2 = {}\n        all_items = set(list_1) | set(list_2)\n        \n        # Extract dependencies from list_1\n        for i, item in enumerate(list_1):\n            deps_1[item] = set(list_1[:i])\n        \n        # Extract dependencies from list_2  \n        for i, item in enumerate(list_2):\n            deps_2[item] = set(list_2[:i])\n        \n        # Check for genuine conflicts (same items with contradictory ordering)\n        for item in all_items:\n            deps1 = deps_1.get(item, set())\n            deps2 = deps_2.get(item, set())\n            common_deps = deps1 & deps2\n            \n            # Check if any common dependency has conflicting order\n            for dep in common_deps:\n                if (dep in deps1 and item in deps_2.get(dep, set())) or \\\n                   (dep in deps2 and item in deps_1.get(dep, set())):\n                    warnings.warn(\n                        'Detected duplicate Media files in an opposite order:\\n'\n                        '%s\\n%s' % (dep, item),\n                        MediaOrderConflictWarning,\n                    )\n        \n        # Merge dependencies (union for items present in both lists)\n        merged_deps = {}\n        for item in all_items:\n            merged_deps[item] = deps_1.get(item, set()) | deps_2.get(item, set())\n        \n        # Topological sort\n        result = []\n        temp_mark = set()\n        perm_mark = set()\n        \n        def visit(item):\n            if item in temp_mark:\n                return  # Cycle detected, skip\n            if item in perm_mark:\n                return\n            \n            temp_mark.add(item)\n            for dep in merged_deps.get(item, set()):\n                if dep in all_items:\n                    visit(dep)\n            temp_mark.remove(item)\n            perm_mark.add(item)\n            result.append(item)\n        \n        # Visit items in order they appear in the original lists to maintain stability\n        for item in list_1 + [x for x in list_2 if x not in list_1]:\n            if item not in perm_mark:\n                visit(item)\n        \n        return result\n",
      "\n    @staticmethod\n    def merge(list_1, list_2):\n        \"\"\"\n        Merge two lists while trying to keep the relative order of the elements.\n        Warn if the lists have the same two elements in a different relative\n        order.\n\n        For static assets it can be important to have them included in the DOM\n        in a certain order. In JavaScript you may not be able to reference a\n        global or in CSS you might want to override a style.\n        \"\"\"\n        if not list_1:\n            return list(list_2)\n        if not list_2:\n            return list(list_1)\n        \n        # Build a dependency graph based on relative ordering in both lists\n        dependencies = {}\n        all_items = set(list_1) | set(list_2)\n        \n        for item in all_items:\n            dependencies[item] = set()\n        \n        # Add dependencies from list_1\n        for i, item in enumerate(list_1):\n            for j in range(i + 1, len(list_1)):\n                dependencies[list_1[j]].add(item)\n        \n        # Add dependencies from list_2, checking for conflicts\n        for i, item in enumerate(list_2):\n            for j in range(i + 1, len(list_2)):\n                dependent = list_2[j]\n                # Check for genuine conflict (opposite ordering in both lists)\n                if item in dependencies[dependent]:\n                    # This is a real conflict - same items in opposite order\n                    warnings.warn(\n                        'Detected duplicate Media files in an opposite order:\\n'\n                        '%s\\n%s' % (item, dependent),\n                        MediaOrderConflictWarning,\n                    )\n                else:\n                    dependencies[dependent].add(item)\n        \n        # Topological sort using Kahn's algorithm\n        result = []\n        in_degree = {item: len(dependencies[item]) for item in all_items}\n        queue = [item for item in all_items if in_degree[item] == 0]\n        \n        # Sort queue to maintain consistent ordering\n        queue.sort(key=lambda x: (list_1.index(x) if x in list_1 else len(list_1),\n                                  list_2.index(x) if x in list_2 else len(list_2)))\n        \n        while queue:\n            current = queue.pop(0)\n            result.append(current)\n            \n            # Update in-degrees and add newly available items\n            for item in all_items:\n                if current in dependencies[item]:\n                    in_degree[item] -= 1\n                    if in_degree[item] == 0:\n                        queue.append(item)\n            \n            # Keep queue sorted for consistent results\n            queue.sort(key=lambda x: (list_1.index(x) if x in list_1 else len(list_1),\n                                      list_2.index(x) if x in list_2 else len(list_2)))\n        \n        return result\n",
      "\n    @staticmethod\n    def merge(list_1, list_2):\n        \"\"\"\n        Merge two lists while trying to keep the relative order of the elements.\n        Warn if the lists have the same two elements in a different relative\n        order.\n\n        For static assets it can be important to have them included in the DOM\n        in a certain order. In JavaScript you may not be able to reference a\n        global or in CSS you might want to override a style.\n        \"\"\"\n        if not list_1:\n            return list(list_2)\n        if not list_2:\n            return list(list_1)\n        \n        # Build a dependency graph based on relative ordering in both lists\n        dependencies = {}  # item -> set of items that must come before it\n        all_items = set(list_1) | set(list_2)\n        \n        for item in all_items:\n            dependencies[item] = set()\n        \n        # Extract dependencies from list_1\n        for i, item in enumerate(list_1):\n            for j in range(i):\n                dependencies[item].add(list_1[j])\n        \n        # Extract dependencies from list_2 and check for conflicts\n        for i, item in enumerate(list_2):\n            for j in range(i):\n                predecessor = list_2[j]\n                if predecessor in dependencies[item]:\n                    continue  # Consistent ordering\n                elif item in dependencies[predecessor]:\n                    # Conflict detected - same items in opposite order\n                    warnings.warn(\n                        'Detected duplicate Media files in an opposite order:\\n'\n                        '%s\\n%s' % (predecessor, item),\n                        MediaOrderConflictWarning,\n                    )\n                else:\n                    # Add new dependency\n                    dependencies[item].add(predecessor)\n        \n        # Topological sort using Kahn's algorithm\n        result = []\n        in_degree = {item: len(deps) for item, deps in dependencies.items()}\n        queue = [item for item in all_items if in_degree[item] == 0]\n        \n        while queue:\n            # Sort queue to ensure deterministic output\n            queue.sort()\n            current = queue.pop(0)\n            result.append(current)\n            \n            # Update in-degrees for items that depend on current\n            for item in all_items:\n                if current in dependencies[item]:\n                    in_degree[item] -= 1\n                    if in_degree[item] == 0:\n                        queue.append(item)\n        \n        return result\n",
      "\n    @staticmethod\n    def merge(list_1, list_2):\n        \"\"\"\n        Merge two lists while trying to keep the relative order of the elements.\n        Warn if the lists have the same two elements in a different relative\n        order.\n\n        For static assets it can be important to have them included in the DOM\n        in a certain order. In JavaScript you may not be able to reference a\n        global or in CSS you might want to override a style.\n        \"\"\"\n        if not list_1:\n            return list(list_2)\n        if not list_2:\n            return list(list_1)\n        \n        # Build dependency graph from both lists\n        dependencies = {}  # item -> set of items that must come before it\n        all_items = set(list_1) | set(list_2)\n        \n        for item in all_items:\n            dependencies[item] = set()\n        \n        # Add dependencies from list_1\n        for i in range(len(list_1)):\n            for j in range(i + 1, len(list_1)):\n                dependencies[list_1[j]].add(list_1[i])\n        \n        # Add dependencies from list_2, checking for conflicts\n        for i in range(len(list_2)):\n            for j in range(i + 1, len(list_2)):\n                # Check if this creates a conflict with existing dependencies\n                if list_2[i] in dependencies[list_2[j]]:\n                    warnings.warn(\n                        'Detected duplicate Media files in an opposite order:\\n'\n                        '%s\\n%s' % (list_2[j], list_2[i]),\n                        MediaOrderConflictWarning,\n                    )\n                else:\n                    dependencies[list_2[j]].add(list_2[i])\n        \n        # Topological sort\n        result = []\n        in_degree = {item: len(deps) for item, deps in dependencies.items()}\n        queue = [item for item in all_items if in_degree[item] == 0]\n        \n        # Sort queue to ensure deterministic output\n        queue.sort()\n        \n        while queue:\n            # Remove item with no dependencies\n            current = queue.pop(0)\n            result.append(current)\n            \n            # Update dependencies\n            for item in all_items:\n                if current in dependencies[item]:\n                    dependencies[item].remove(current)\n                    in_degree[item] -= 1\n                    if in_degree[item] == 0:\n                        queue.append(item)\n                        queue.sort()  # Keep deterministic order\n        \n        return result\n",
      "\n    @staticmethod\n    def merge(list_1, list_2):\n        \"\"\"\n        Merge two lists while trying to keep the relative order of the elements.\n        Warn if the lists have the same two elements in a different relative\n        order.\n\n        For static assets it can be important to have them included in the DOM\n        in a certain order. In JavaScript you may not be able to reference a\n        global or in CSS you might want to override a style.\n        \"\"\"\n        if not list_1:\n            return list(list_2)\n        if not list_2:\n            return list(list_1)\n        \n        # Build dependency graph from both lists\n        dependencies = {}\n        all_items = set(list_1) | set(list_2)\n        \n        # Initialize dependencies for all items\n        for item in all_items:\n            dependencies[item] = set()\n        \n        # Add dependencies from list_1\n        for i in range(len(list_1) - 1):\n            dependencies[list_1[i + 1]].add(list_1[i])\n        \n        # Add dependencies from list_2, checking for conflicts\n        for i in range(len(list_2) - 1):\n            current = list_2[i + 1]\n            predecessor = list_2[i]\n            \n            # Check if this creates a conflict with existing dependencies\n            if predecessor in dependencies[current]:\n                continue  # Already have this dependency\n            \n            # Check for reverse dependency (conflict)\n            if current in dependencies[predecessor]:\n                warnings.warn(\n                    'Detected duplicate Media files in an opposite order:\\n'\n                    '%s\\n%s' % (predecessor, current),\n                    MediaOrderConflictWarning,\n                )\n            else:\n                dependencies[current].add(predecessor)\n        \n        # Topological sort using Kahn's algorithm\n        in_degree = {item: len(dependencies[item]) for item in all_items}\n        queue = [item for item in all_items if in_degree[item] == 0]\n        result = []\n        \n        while queue:\n            # Sort queue to ensure deterministic output\n            queue.sort()\n            current = queue.pop(0)\n            result.append(current)\n            \n            # Update in-degrees for items that depend on current\n            for item in all_items:\n                if current in dependencies[item]:\n                    in_degree[item] -= 1\n                    if in_degree[item] == 0:\n                        queue.append(item)\n        \n        # If we couldn't process all items, there's a cycle\n        if len(result) != len(all_items):\n            # Fall back to preserving order from list_1 + new items from list_2\n            result = list(list_1)\n            for item in list_2:\n                if item not in result:\n                    result.append(item)\n        \n        return result\n"
    ],
    "Location 2 (/root/hy/projects_2/django/django/forms/widgets.py lines 72-77)": [
      "\n    @property\n    def _js(self):\n        # Collect all JS lists first to enable global dependency resolution\n        all_js_lists = [js_list for js_list in self._js_lists if js_list]\n        \n        if not all_js_lists:\n            return []\n        elif len(all_js_lists) == 1:\n            return all_js_lists[0]\n        \n        # Perform single global merge instead of sequential pairwise merges\n        return self.merge_global(all_js_lists)\n",
      "\n    @property\n    def _js(self):\n        # Collect all JS lists to perform global merge instead of sequential pairwise merges\n        all_js_lists = [js_list for js_list in self._js_lists if js_list]\n        if not all_js_lists:\n            return []\n        elif len(all_js_lists) == 1:\n            return all_js_lists[0]\n        else:\n            # Perform single global merge of all lists\n            return self.merge_all(all_js_lists)\n",
      "\n    @property\n    def _js(self):\n        # Collect all JS lists for global merge instead of sequential pairwise merging\n        all_js_lists = [js_list for js_list in self._js_lists if js_list]\n        if not all_js_lists:\n            return []\n        elif len(all_js_lists) == 1:\n            return all_js_lists[0]\n        else:\n            # Perform single global merge to avoid false intermediate constraints\n            return self.merge_all(all_js_lists)\n",
      "\n    @property\n    def _js(self):\n        # Collect all JS lists without intermediate merging\n        all_js_lists = [js_list for js_list in self._js_lists if js_list]\n        if not all_js_lists:\n            return []\n        if len(all_js_lists) == 1:\n            return all_js_lists[0]\n        \n        # Perform global merge of all lists at once\n        return self.merge_all(all_js_lists)\n",
      "\n    @property\n    def _js(self):\n        # Collect all JS lists to merge globally instead of sequentially\n        all_js_lists = [js_list for js_list in self._js_lists if js_list]\n        if not all_js_lists:\n            return []\n        elif len(all_js_lists) == 1:\n            return all_js_lists[0]\n        else:\n            # Perform global merge of all lists at once\n            return self.merge_all(all_js_lists)\n",
      "\n    @property\n    def _js(self):\n        # Collect all js lists for global merge instead of sequential pairwise merging\n        all_js_lists = [js_list for js_list in self._js_lists if js_list]\n        if not all_js_lists:\n            return []\n        if len(all_js_lists) == 1:\n            return all_js_lists[0]\n        \n        # Perform global merge of all lists at once\n        return self.merge_all(all_js_lists)\n",
      "\n    @property\n    def _js(self):\n        # Collect all JS lists for global merge instead of sequential pairwise merging\n        all_js_lists = [js_list for js_list in self._js_lists if js_list]\n        if not all_js_lists:\n            return []\n        if len(all_js_lists) == 1:\n            return all_js_lists[0]\n        \n        # Perform global merge of all lists at once to avoid false intermediate constraints\n        return self._global_merge(all_js_lists)\n",
      "\n    @property\n    def _js(self):\n        if len(self._js_lists) <= 1:\n            return self._js_lists[0] if self._js_lists else []\n        \n        # Collect all non-empty JS lists for global merge\n        js_lists = [js_list for js_list in self._js_lists if js_list]\n        if not js_lists:\n            return []\n        if len(js_lists) == 1:\n            return js_lists[0]\n        \n        # Perform global merge instead of sequential pairwise merging\n        return self._global_merge(js_lists)\n"
    ],
    "Location 3 (/root/hy/projects_2/django/django/forms/widgets.py lines 141-146)": [
      "\n    def merge(self, list_1, list_2):\n        \"\"\"\n        Merge two lists while maintaining relative ordering and avoiding\n        false conflicts from intermediate results.\n        \"\"\"\n        if not list_1:\n            return list_2[:]\n        if not list_2:\n            return list_1[:]\n        \n        # Create a combined list preserving relative order from both inputs\n        combined_list = list_1[:]\n        \n        # Track positions of items from list_1 for dependency resolution\n        positions = {item: idx for idx, item in enumerate(list_1)}\n        \n        # Process list_2 items in forward order to respect dependencies\n        for item in list_2:\n            if item in combined_list:\n                # Item already exists, check for genuine conflicts\n                existing_idx = combined_list.index(item)\n                # Only warn if this creates a real ordering conflict\n                # (same item in different relative positions in original lists)\n                list_1_has_item = item in list_1\n                if list_1_has_item:\n                    list_1_idx = list_1.index(item)\n                    list_2_idx = list_2.index(item)\n                    \n                    # Check items that appear after this item in both lists\n                    for other_item in list_2[list_2_idx + 1:]:\n                        if other_item in list_1:\n                            other_list_1_idx = list_1.index(other_item)\n                            if other_list_1_idx < list_1_idx:\n                                # Genuine conflict: item comes after other_item in list_2\n                                # but before other_item in list_1\n                                warnings.warn(\n                                    'Detected duplicate Media files in an opposite order:\\n'\n                                    '%s\\n%s' % (item, other_item),\n                                    MediaOrderConflictWarning,\n                                )\n                                break\n            else:\n                # Find the best insertion point based on dependencies\n                insert_idx = len(combined_list)\n                \n                # Look for items in list_2 that should come after this item\n                item_idx_in_list_2 = list_2.index(item)\n                for later_item in list_2[item_idx_in_list_2 + 1:]:\n                    if later_item in combined_list:\n                        later_idx = combined_list.index(later_item)\n                        insert_idx = min(insert_idx, later_idx)\n                \n                # Look for items in list_1 that should come before this item\n                for earlier_item in reversed(list_1):\n                    if earlier_item in combined_list:\n                        earlier_idx = combined_list.index(earlier_item)\n                        insert_idx = max(insert_idx, earlier_idx + 1)\n                        break\n                \n                combined_list.insert(insert_idx, item)\n        \n        return combined_list\n",
      "\n    def merge(self, list_1, list_2):\n        \"\"\"\n        Merge two lists while trying to keep the relative order of the elements.\n        Warn if the lists have the same elements in a different relative order.\n        \n        For example, merging:\n        ['a', 'b', 'c', 'd']\n        ['b', 'd', 'e']\n        Would result in ['a', 'b', 'c', 'd', 'e']\n        \"\"\"\n        # Convert to lists to handle various iterable types\n        list_1 = list(list_1)\n        list_2 = list(list_2) \n        \n        if not list_1:\n            return list_2[:]\n        if not list_2:\n            return list_1[:]\n            \n        # Build a combined list starting with list_1\n        combined_list = list_1[:]\n        \n        # Track positions of elements from list_1 for conflict detection\n        original_positions = {item: i for i, item in enumerate(list_1)}\n        \n        # Process list_2 elements in order\n        for item in list_2:\n            if item in combined_list:\n                # Item already exists, check for genuine conflicts\n                current_pos = combined_list.index(item)\n                expected_pos = original_positions.get(item)\n                \n                if expected_pos is not None:\n                    # Find items from list_2 that should come before this item\n                    items_before = [x for x in list_2[:list_2.index(item)] if x in combined_list]\n                    \n                    # Check if any item that should come before appears after in combined_list\n                    conflict_detected = False\n                    for before_item in items_before:\n                        before_pos = combined_list.index(before_item)\n                        if before_pos > current_pos:\n                            warnings.warn(\n                                'Detected duplicate Media files in an opposite order:\\n'\n                                '%s\\n%s' % (before_item, item),\n                                MediaOrderConflictWarning,\n                            )\n                            conflict_detected = True\n                            break\n            else:\n                # Item doesn't exist, find the best insertion point\n                # Look for the latest position where we can insert while respecting list_2 order\n                insert_pos = len(combined_list)\n                \n                # Find items from list_2 that come after this item\n                items_after = [x for x in list_2[list_2.index(item)+1:] if x in combined_list]\n                \n                # Insert before the first \"after\" item we find\n                for after_item in items_after:\n                    after_pos = combined_list.index(after_item)\n                    insert_pos = min(insert_pos, after_pos)\n                \n                combined_list.insert(insert_pos, item)\n        \n        return combined_list\n",
      "\n    def merge(self, list_1, list_2):\n        \"\"\"\n        Merge two lists while trying to keep the relative order of the elements.\n        Warn if the lists have the same elements in a different relative order.\n\n        For example, merging:\n        ['a', 'b', 'c'] and ['d', 'b', 'e']\n        to ['a', 'd', 'b', 'c', 'e']\n        \"\"\"\n        # Convert lists to preserve order information\n        if not list_1:\n            return list(list_2)\n        if not list_2:\n            return list(list_1)\n\n        # Build a dependency graph based on relative ordering in each list\n        dependencies = {}  # item -> set of items that must come before it\n        all_items = set(list_1) | set(list_2)\n        \n        for item in all_items:\n            dependencies[item] = set()\n        \n        # Add dependencies from list_1\n        for i, item in enumerate(list_1):\n            for prev_item in list_1[:i]:\n                dependencies[item].add(prev_item)\n        \n        # Add dependencies from list_2, checking for conflicts\n        for i, item in enumerate(list_2):\n            for prev_item in list_2[:i]:\n                # Check if this creates a conflict with existing dependencies\n                if item in dependencies and prev_item not in dependencies[item]:\n                    # Check if we have a reverse dependency (conflict)\n                    if prev_item in dependencies and item in dependencies[prev_item]:\n                        warnings.warn(\n                            'Detected duplicate Media files in an opposite order:\\n'\n                            '%s\\n%s' % (prev_item, item),\n                            MediaOrderConflictWarning,\n                        )\n                dependencies[item].add(prev_item)\n        \n        # Topological sort to resolve final order\n        result = []\n        remaining = set(all_items)\n        \n        while remaining:\n            # Find items with no remaining dependencies\n            ready = {item for item in remaining \n                    if not (dependencies[item] & remaining)}\n            \n            if not ready:\n                # Circular dependency - break it and warn\n                # Choose the item that appears first in either original list\n                for item in list_1 + list_2:\n                    if item in remaining:\n                        ready = {item}\n                        break\n            \n            # Sort ready items to maintain stable output\n            # Prefer order from list_1, then list_2\n            ready_list = []\n            for lst in [list_1, list_2]:\n                for item in lst:\n                    if item in ready and item not in ready_list:\n                        ready_list.append(item)\n            \n            result.extend(ready_list)\n            remaining -= set(ready_list)\n        \n        return result\n",
      "\n    def merge(self, list_1, list_2):\n        \"\"\"\n        Merge two lists while preserving their relative order and avoiding\n        false conflicts from intermediate merge results.\n        \"\"\"\n        if not list_1:\n            return list_2[:]\n        if not list_2:\n            return list_1[:]\n        \n        # Build a dependency graph from both lists\n        dependencies = {}  # item -> set of items that must come before it\n        all_items = set(list_1 + list_2)\n        \n        # Initialize all items with empty dependency sets\n        for item in all_items:\n            dependencies[item] = set()\n        \n        # Add dependencies from list_1\n        for i in range(len(list_1) - 1):\n            dependencies[list_1[i + 1]].add(list_1[i])\n        \n        # Add dependencies from list_2, checking for conflicts\n        for i in range(len(list_2) - 1):\n            curr_item = list_2[i + 1]\n            prev_item = list_2[i]\n            \n            # Check if this would create a cycle (genuine conflict)\n            if prev_item in dependencies and curr_item in dependencies[prev_item]:\n                # Find the conflicting positions in original lists\n                pos1_curr = list_1.index(curr_item) if curr_item in list_1 else -1\n                pos1_prev = list_1.index(prev_item) if prev_item in list_1 else -1\n                \n                if pos1_curr != -1 and pos1_prev != -1 and pos1_curr < pos1_prev:\n                    warnings.warn(\n                        'Detected duplicate Media files in an opposite order:\\n'\n                        '%s\\n%s' % (prev_item, curr_item),\n                        MediaOrderConflictWarning,\n                    )\n            \n            dependencies[curr_item].add(prev_item)\n        \n        # Topological sort using Kahn's algorithm\n        result = []\n        in_degree = {item: len(dependencies[item]) for item in all_items}\n        queue = [item for item in all_items if in_degree[item] == 0]\n        \n        # Process items in a stable order (prefer list_1 order, then list_2 order)\n        def sort_key(item):\n            pos1 = list_1.index(item) if item in list_1 else len(list_1)\n            pos2 = list_2.index(item) if item in list_2 else len(list_2)\n            return (pos1, pos2)\n        \n        while queue:\n            queue.sort(key=sort_key)\n            current = queue.pop(0)\n            result.append(current)\n            \n            # Update in-degrees for items that depend on current\n            for item in all_items:\n                if current in dependencies[item]:\n                    in_degree[item] -= 1\n                    if in_degree[item] == 0:\n                        queue.append(item)\n        \n        return result\n",
      "\n    def merge(self, list_1, list_2):\n        \"\"\"\n        Merge two lists while trying to keep the relative order of elements.\n        Warn if the lists have the same elements in a different relative order.\n        \n        For example, merging:\n        ['a', 'b', 'c'] and ['d', 'b', 'e'] would result in ['a', 'd', 'b', 'c', 'e']\n        \"\"\"\n        # Build a dependency graph from both lists\n        dependencies = {}\n        all_items = set()\n        \n        # Process list_1 to establish ordering constraints\n        for i, item in enumerate(list_1):\n            all_items.add(item)\n            if item not in dependencies:\n                dependencies[item] = set()\n            # Each item depends on all items that come before it in list_1\n            for j in range(i):\n                dependencies[item].add(list_1[j])\n        \n        # Process list_2 to establish ordering constraints\n        for i, item in enumerate(list_2):\n            all_items.add(item)\n            if item not in dependencies:\n                dependencies[item] = set()\n            # Each item depends on all items that come before it in list_2\n            for j in range(i):\n                dependencies[item].add(list_2[j])\n        \n        # Check for genuine conflicts (cycles in the dependency graph)\n        def has_cycle():\n            visited = set()\n            rec_stack = set()\n            \n            def dfs(node):\n                if node in rec_stack:\n                    return True\n                if node in visited:\n                    return False\n                \n                visited.add(node)\n                rec_stack.add(node)\n                \n                for neighbor in dependencies.get(node, []):\n                    if neighbor in all_items and dfs(neighbor):\n                        return True\n                \n                rec_stack.remove(node)\n                return False\n            \n            for item in all_items:\n                if item not in visited and dfs(item):\n                    return True\n            return False\n        \n        if has_cycle():\n            # Find conflicting items for warning\n            common_items = set(list_1) & set(list_2)\n            for item in common_items:\n                idx1 = list_1.index(item) if item in list_1 else -1\n                idx2 = list_2.index(item) if item in list_2 else -1\n                if idx1 >= 0 and idx2 >= 0:\n                    # Check relative ordering with other common items\n                    for other in common_items:\n                        if other != item:\n                            other_idx1 = list_1.index(other) if other in list_1 else -1\n                            other_idx2 = list_2.index(other) if other in list_2 else -1\n                            if (other_idx1 >= 0 and other_idx2 >= 0 and \n                                (idx1 < other_idx1) != (idx2 < other_idx2)):\n                                warnings.warn(\n                                    'Detected duplicate Media files in an opposite order:\\n'\n                                    '%s\\n%s' % (item, other),\n                                    MediaOrderConflictWarning,\n                                )\n                                break\n        \n        # Topological sort to resolve dependencies\n        result = []\n        visited = set()\n        temp_visited = set()\n        \n        def topological_sort(item):\n            if item in temp_visited:\n                return  # Cycle detected, skip\n            if item in visited:\n                return\n            \n            temp_visited.add(item)\n            for dep in dependencies.get(item, []):\n                if dep in all_items:\n                    topological_sort(dep)\n            temp_visited.remove(item)\n            visited.add(item)\n            result.append(item)\n        \n        # Sort items to ensure deterministic output\n        for item in sorted(all_items):\n            if item not in visited:\n                topological_sort(item)\n        \n        return result\n",
      "\n    def merge(self, list_1, list_2):\n        \"\"\"\n        Merge two lists while trying to keep the relative order of the elements.\n        Warn if the lists have the same elements in a different relative order.\n\n        For example, merging:\n        ['a', 'b', 'c', 'd']\n        ['b', 'd', 'e']\n        Would result in ['a', 'b', 'c', 'd', 'e']\n        \"\"\"\n        # Convert to lists if not already\n        if not isinstance(list_1, list):\n            list_1 = list(list_1)\n        if not isinstance(list_2, list):\n            list_2 = list(list_2)\n            \n        # Build a dependency graph\n        dependencies = {}\n        all_items = set(list_1 + list_2)\n        \n        # Initialize dependencies\n        for item in all_items:\n            dependencies[item] = set()\n        \n        # Add dependencies from list_1\n        for i in range(len(list_1) - 1):\n            dependencies[list_1[i + 1]].add(list_1[i])\n        \n        # Add dependencies from list_2\n        for i in range(len(list_2) - 1):\n            dependencies[list_2[i + 1]].add(list_2[i])\n        \n        # Check for conflicts (cycles in dependency graph)\n        def has_path(start, end, visited=None):\n            if visited is None:\n                visited = set()\n            if start == end:\n                return True\n            if start in visited:\n                return False\n            visited.add(start)\n            for dep in dependencies.get(start, set()):\n                if has_path(dep, end, visited):\n                    return True\n            return False\n        \n        # Find conflicting pairs and warn\n        conflicting_pairs = []\n        for item1 in all_items:\n            for item2 in all_items:\n                if item1 != item2 and has_path(item1, item2) and has_path(item2, item1):\n                    pair = tuple(sorted([item1, item2]))\n                    if pair not in conflicting_pairs:\n                        conflicting_pairs.append(pair)\n        \n        for item1, item2 in conflicting_pairs:\n            warnings.warn(\n                'Detected duplicate Media files in an opposite order:\\n'\n                '%s\\n%s' % (item1, item2),\n                MediaOrderConflictWarning,\n            )\n        \n        # Topological sort\n        result = []\n        in_degree = {item: len(dependencies[item]) for item in all_items}\n        queue = [item for item in all_items if in_degree[item] == 0]\n        \n        # Preserve original order preference when possible\n        def sort_key(item):\n            try:\n                return list_1.index(item)\n            except ValueError:\n                try:\n                    return len(list_1) + list_2.index(item)\n                except ValueError:\n                    return len(list_1) + len(list_2)\n        \n        while queue:\n            queue.sort(key=sort_key)\n            current = queue.pop(0)\n            result.append(current)\n            \n            # Update in-degrees\n            for item in all_items:\n                if current in dependencies[item]:\n                    in_degree[item] -= 1\n                    if in_degree[item] == 0:\n                        queue.append(item)\n        \n        return result\n",
      "\n    def merge(self, list_1, list_2):\n        \"\"\"\n        Merge two lists while trying to keep the relative order of the elements.\n        Warn if the lists have the same elements in a different relative order.\n\n        For example, merging:\n        ['A', 'B', 'C'] and ['B', 'C', 'D']\n        would result in ['A', 'B', 'C', 'D'].\n\n        This method uses a topological sort approach to handle complex dependency\n        chains without creating false ordering constraints.\n        \"\"\"\n        if not list_1:\n            return list(list_2)\n        if not list_2:\n            return list(list_1)\n\n        # Build a dependency graph\n        dependencies = {}  # item -> set of items that must come before it\n        all_items = set(list_1 + list_2)\n        \n        for item in all_items:\n            dependencies[item] = set()\n\n        # Add dependencies from list_1\n        for i in range(len(list_1) - 1):\n            dependencies[list_1[i + 1]].add(list_1[i])\n\n        # Add dependencies from list_2\n        for i in range(len(list_2) - 1):\n            dependencies[list_2[i + 1]].add(list_2[i])\n\n        # Check for genuine conflicts (cycles in dependency graph)\n        def has_cycle():\n            visited = set()\n            rec_stack = set()\n            \n            def dfs(node):\n                visited.add(node)\n                rec_stack.add(node)\n                \n                for neighbor in dependencies[node]:\n                    if neighbor not in visited:\n                        if dfs(neighbor):\n                            return True\n                    elif neighbor in rec_stack:\n                        return True\n                \n                rec_stack.remove(node)\n                return False\n            \n            for item in all_items:\n                if item not in visited:\n                    if dfs(item):\n                        return True\n            return False\n\n        # Warn about genuine conflicts\n        if has_cycle():\n            # Find conflicting items by checking original list positions\n            conflicts = []\n            for item in all_items:\n                pos_1 = list_1.index(item) if item in list_1 else -1\n                pos_2 = list_2.index(item) if item in list_2 else -1\n                if pos_1 >= 0 and pos_2 >= 0:\n                    for other_item in all_items:\n                        if item != other_item:\n                            other_pos_1 = list_1.index(other_item) if other_item in list_1 else -1\n                            other_pos_2 = list_2.index(other_item) if other_item in list_2 else -1\n                            if (other_pos_1 >= 0 and other_pos_2 >= 0 and\n                                (pos_1 < other_pos_1) != (pos_2 < other_pos_2)):\n                                conflicts.append((item, other_item))\n            \n            if conflicts:\n                warnings.warn(\n                    'Detected duplicate Media files in an opposite order:\\n'\n                    '%s\\n%s' % conflicts[0],\n                    MediaOrderConflictWarning,\n                )\n\n        # Perform topological sort\n        result = []\n        in_degree = {item: len(dependencies[item]) for item in all_items}\n        queue = [item for item in all_items if in_degree[item] == 0]\n\n        while queue:\n            # Sort queue to ensure deterministic output\n            queue.sort()\n            current = queue.pop(0)\n            result.append(current)\n\n            # Update in-degrees of dependent items\n            for item in all_items:\n                if current in dependencies[item]:\n                    dependencies[item].remove(current)\n                    in_degree[item] -= 1\n                    if in_degree[item] == 0:\n                        queue.append(item)\n\n        return result\n",
      "\n    def merge(list_1, list_2):\n        \"\"\"\n        Merge two lists while trying to keep the relative order of the elements.\n        Warn if the lists have the same elements in a different relative order.\n        \n        For example, calling merge([1, 3], [2, 3]) would return [1, 2, 3].\n        \"\"\"\n        # Handle edge cases\n        if not list_1:\n            return list(list_2)\n        if not list_2:\n            return list(list_1)\n        \n        # Build a combined list preserving order from both lists\n        combined_list = []\n        seen = set()\n        \n        # Track positions of elements in each list for conflict detection\n        pos_1 = {item: i for i, item in enumerate(list_1)}\n        pos_2 = {item: i for i, item in enumerate(list_2)}\n        \n        # Get all unique items in order they first appear\n        all_items = []\n        for item in list_1:\n            if item not in seen:\n                all_items.append(item)\n                seen.add(item)\n        for item in list_2:\n            if item not in seen:\n                all_items.append(item)\n                seen.add(item)\n        \n        # Check for genuine ordering conflicts\n        conflicts = []\n        for i, item_a in enumerate(all_items):\n            for j, item_b in enumerate(all_items):\n                if i < j:  # item_a comes before item_b in our ordering\n                    # Check if both items exist in both lists\n                    if (item_a in pos_1 and item_b in pos_1 and \n                        item_a in pos_2 and item_b in pos_2):\n                        # Check if they have opposite relative order in the two lists\n                        if (pos_1[item_a] > pos_1[item_b] and \n                            pos_2[item_a] < pos_2[item_b]):\n                            conflicts.append((item_a, item_b))\n        \n        # Warn about genuine conflicts\n        if conflicts:\n            for item_a, item_b in conflicts:\n                warnings.warn(\n                    'Detected duplicate Media files in an opposite order:\\n'\n                    '%s\\n%s' % (item_a, item_b),\n                    MediaOrderConflictWarning,\n                )\n        \n        # Build final ordering respecting dependencies from both lists\n        result = []\n        remaining = set(all_items)\n        \n        while remaining:\n            # Find items that have no unprocessed dependencies\n            candidates = []\n            for item in remaining:\n                can_add = True\n                # Check dependencies from list_1\n                if item in pos_1:\n                    for other in remaining:\n                        if other in pos_1 and pos_1[other] < pos_1[item]:\n                            can_add = False\n                            break\n                # Check dependencies from list_2\n                if can_add and item in pos_2:\n                    for other in remaining:\n                        if other in pos_2 and pos_2[other] < pos_2[item]:\n                            can_add = False\n                            break\n                if can_add:\n                    candidates.append(item)\n            \n            if not candidates:\n                # Fallback: add remaining items in original order\n                candidates = [item for item in all_items if item in remaining]\n            \n            # Add the first candidate (maintains stability)\n            next_item = candidates[0]\n            result.append(next_item)\n            remaining.remove(next_item)\n        \n        return result\n"
    ],
    "Location 4 (/root/hy/projects_2/django/django/forms/widgets.py lines 152-156)": [
      "\n    def __add__(self, other):\n        combined = Media()\n        # Store original media lists to enable global dependency resolution\n        combined._css_lists = self._css_lists + other._css_lists\n        combined._js_lists = self._js_lists + other._js_lists\n        return combined\n",
      "\n    def __add__(self, other):\n        combined = Media()\n        # Store original lists instead of merging immediately\n        combined._css_lists = self._css_lists + other._css_lists\n        combined._js_lists = self._js_lists + other._js_lists\n        return combined\n",
      "\n    def __add__(self, other):\n        combined = Media()\n        # Store original media lists to support global dependency resolution\n        combined._css_lists = self._css_lists + other._css_lists\n        combined._js_lists = self._js_lists + other._js_lists\n        return combined\n",
      "\n    def __add__(self, other):\n        combined = Media()\n        # Store original lists to preserve dependency information\n        combined._css_lists = list(self._css_lists) + list(other._css_lists)\n        combined._js_lists = list(self._js_lists) + list(other._js_lists)\n        return combined\n",
      "\n    def __add__(self, other):\n        combined = Media()\n        # Store original media lists to enable global dependency resolution\n        combined._css_lists = self._css_lists + other._css_lists\n        combined._js_lists = self._js_lists + other._js_lists\n        return combined\n",
      "\n    def __add__(self, other):\n        combined = Media()\n        combined._css_lists = self._css_lists + other._css_lists\n        combined._js_lists = self._js_lists + other._js_lists\n        return combined\n",
      "\n    def __add__(self, other):\n        combined = Media()\n        # Store original media lists to preserve dependency information\n        combined._css_lists = self._css_lists + other._css_lists\n        combined._js_lists = self._js_lists + other._js_lists\n        return combined\n",
      "\n    def __add__(self, other):\n        combined = Media()\n        # Store original lists to preserve structure for global merging\n        combined._css_lists = self._css_lists + other._css_lists\n        combined._js_lists = self._js_lists + other._js_lists\n        return combined\n"
    ],
    "Location 5 (/root/hy/projects_2/django/django/forms/widgets.py lines 133-149)": [
      "\n    @staticmethod\n    def merge(*lists):\n        \"\"\"\n        Merge lists while respecting dependencies and detecting conflicts.\n        \n        This function merges multiple lists while preserving the relative order\n        of items within each list. If the same item appears in multiple lists,\n        the function ensures consistency across all appearances.\n        \"\"\"\n        if not lists:\n            return []\n        \n        # Flatten all lists and track positions\n        all_items = []\n        item_positions = {}  # item -> [(list_index, position_in_list), ...]\n        \n        for list_idx, lst in enumerate(lists):\n            for pos, item in enumerate(lst):\n                if item not in item_positions:\n                    item_positions[item] = []\n                item_positions[item].append((list_idx, pos))\n                if item not in all_items:\n                    all_items.append(item)\n        \n        # Check for genuine conflicts\n        conflicts = []\n        for item, positions in item_positions.items():\n            if len(positions) > 1:\n                # Check if this item has conflicting relative positions\n                for i, (list1_idx, pos1) in enumerate(positions):\n                    for list2_idx, pos2 in positions[i+1:]:\n                        # Find common items between these two lists\n                        list1_items = set(lists[list1_idx])\n                        list2_items = set(lists[list2_idx])\n                        common_items = list1_items & list2_items\n                        \n                        # Check relative ordering of common items\n                        for common_item in common_items:\n                            if common_item != item:\n                                common_pos1 = lists[list1_idx].index(common_item)\n                                common_pos2 = lists[list2_idx].index(common_item)\n                                \n                                # Check if relative order is inconsistent\n                                if ((pos1 < common_pos1) != (pos2 < common_pos2)):\n                                    conflicts.append((item, common_item))\n        \n        # Warn about genuine conflicts\n        for item1, item2 in conflicts:\n            warnings.warn(\n                'Detected duplicate Media files in an opposite order:\\n'\n                '%s\\n%s' % (item1, item2),\n                MediaOrderConflictWarning,\n            )\n        \n        # Build result preserving original list order constraints\n        result = []\n        processed = set()\n        \n        # Process items in the order they first appear\n        for item in all_items:\n            if item in processed:\n                continue\n                \n            # Find the best position for this item\n            best_position = len(result)\n            \n            # Check constraints from all lists containing this item\n            for list_idx, pos_in_list in item_positions[item]:\n                current_list = lists[list_idx]\n                \n                # Find items that should come before this item in current_list\n                predecessors_in_result = []\n                for pred_pos in range(pos_in_list):\n                    pred_item = current_list[pred_pos]\n                    if pred_item in processed:\n                        pred_idx = result.index(pred_item)\n                        predecessors_in_result.append(pred_idx)\n                \n                # Position should be after the latest predecessor\n                if predecessors_in_result:\n                    min_position = max(predecessors_in_result) + 1\n                    best_position = max(best_position, min_position)\n            \n            # Insert at the determined position\n            result.insert(best_position, item)\n            processed.add(item)\n        \n        return result\n",
      "\n    @staticmethod\n    def merge(*lists):\n        \"\"\"\n        Merge lists while trying to keep the relative order of the elements.\n        Warn if the lists have the same elements in a different relative order.\n\n        For static assets it can be important to have them included in the DOM\n        in a certain order. In JavaScript you may not be able to reference a\n        global or in CSS you might want to override a style.\n        \"\"\"\n        if not lists:\n            return []\n        \n        # Collect all unique items while preserving first occurrence order\n        all_items = []\n        seen = set()\n        for lst in lists:\n            for item in lst:\n                if item not in seen:\n                    all_items.append(item)\n                    seen.add(item)\n        \n        # Build dependency graph from all input lists\n        dependencies = {item: set() for item in all_items}\n        \n        for lst in lists:\n            for i, item in enumerate(lst):\n                # Item depends on all items that come before it in this list\n                for j in range(i):\n                    dependencies[item].add(lst[j])\n        \n        # Check for genuine conflicts (cycles in dependency graph)\n        def has_conflict(item1, item2):\n            return item2 in dependencies[item1] and item1 in dependencies[item2]\n        \n        # Detect and warn about genuine conflicts\n        for i, item1 in enumerate(all_items):\n            for j in range(i + 1, len(all_items)):\n                item2 = all_items[j]\n                if has_conflict(item1, item2):\n                    warnings.warn(\n                        'Detected duplicate Media files in an opposite order:\\n'\n                        '%s\\n%s' % (item1, item2),\n                        MediaOrderConflictWarning,\n                    )\n        \n        # Topological sort with conflict resolution\n        result = []\n        remaining = set(all_items)\n        \n        while remaining:\n            # Find items with no unresolved dependencies\n            ready = []\n            for item in remaining:\n                if not (dependencies[item] & remaining):\n                    ready.append(item)\n            \n            if not ready:\n                # Cycle detected, break it by choosing item with minimum dependencies\n                ready = [min(remaining, key=lambda x: len(dependencies[x] & remaining))]\n            \n            # Sort ready items by their original appearance order\n            ready.sort(key=lambda x: all_items.index(x))\n            \n            # Add the first ready item to result\n            next_item = ready[0]\n            result.append(next_item)\n            remaining.remove(next_item)\n        \n        return result\n",
      "\n    def merge(self, list_1, list_2):\n        \"\"\"\n        Merge two lists while trying to keep the relative order of elements.\n        Warn if the lists have the same elements in a different relative order.\n\n        For static assets it can be important to have them included in the DOM\n        in a certain order. In JavaScript you may not be able to reference a\n        global or in CSS you might want to override a style.\n        \"\"\"\n        if not list_1:\n            return list(list_2)\n        if not list_2:\n            return list(list_1)\n        \n        # Build dependency graph from both lists\n        dependencies = {}\n        all_items = set(list_1) | set(list_2)\n        \n        for item in all_items:\n            dependencies[item] = set()\n        \n        # Add dependencies from list_1\n        for i, item in enumerate(list_1):\n            for j in range(i + 1, len(list_1)):\n                dependencies[list_1[j]].add(item)\n        \n        # Add dependencies from list_2 and check for conflicts\n        for i, item in enumerate(list_2):\n            for j in range(i + 1, len(list_2)):\n                dependent = list_2[j]\n                if item in dependencies[dependent]:\n                    # This is fine, same dependency in both lists\n                    continue\n                elif dependent in dependencies[item]:\n                    # Conflict: opposite dependency order\n                    warnings.warn(\n                        'Detected duplicate Media files in an opposite order:\\n'\n                        '%s\\n%s' % (item, dependent),\n                        MediaOrderConflictWarning,\n                    )\n                else:\n                    # New dependency from list_2\n                    dependencies[dependent].add(item)\n        \n        # Topological sort\n        result = []\n        remaining = set(all_items)\n        \n        while remaining:\n            # Find items with no remaining dependencies\n            ready = [item for item in remaining \n                    if not (dependencies[item] & remaining)]\n            \n            if not ready:\n                # Circular dependency - fallback to original order preference\n                ready = [next(iter(remaining))]\n            \n            # Sort ready items to maintain stable order\n            ready.sort(key=lambda x: (\n                list_1.index(x) if x in list_1 else len(list_1),\n                list_2.index(x) if x in list_2 else len(list_2)\n            ))\n            \n            result.append(ready[0])\n            remaining.remove(ready[0])\n        \n        return result\n",
      "\n    def merge(self, list_1, list_2):\n        \"\"\"\n        Merge two lists while preserving their relative ordering and trying to\n        minimize the number of files.\n\n        For static assets it can be important to have them included in the DOM\n        in a certain order. In JavaScript you may not be able to reference a\n        global or in CSS you might want to override a style.\n        \"\"\"\n        if not list_1:\n            return list(list_2)\n        if not list_2:\n            return list(list_1)\n        \n        # Build dependency graph from both lists\n        dependencies = {}\n        all_items = set(list_1) | set(list_2)\n        \n        for item in all_items:\n            dependencies[item] = set()\n        \n        # Add dependencies from list_1\n        for i in range(len(list_1) - 1):\n            dependencies[list_1[i + 1]].add(list_1[i])\n        \n        # Add dependencies from list_2\n        for i in range(len(list_2) - 1):\n            dependencies[list_2[i + 1]].add(list_2[i])\n        \n        # Topological sort using Kahn's algorithm\n        in_degree = {item: len(deps) for item, deps in dependencies.items()}\n        queue = [item for item, degree in in_degree.items() if degree == 0]\n        result = []\n        \n        while queue:\n            # Sort queue to ensure deterministic output\n            queue.sort()\n            current = queue.pop(0)\n            result.append(current)\n            \n            # Update in-degrees of dependent items\n            for item, deps in dependencies.items():\n                if current in deps:\n                    in_degree[item] -= 1\n                    if in_degree[item] == 0:\n                        queue.append(item)\n        \n        # Check for cycles (genuine conflicts)\n        if len(result) != len(all_items):\n            remaining = all_items - set(result)\n            conflicts = []\n            for item in remaining:\n                item_pos_1 = list_1.index(item) if item in list_1 else -1\n                item_pos_2 = list_2.index(item) if item in list_2 else -1\n                if item_pos_1 >= 0 and item_pos_2 >= 0:\n                    conflicts.append(item)\n            \n            if conflicts:\n                warnings.warn(\n                    'Detected genuine Media file ordering conflicts: %s' % ', '.join(conflicts),\n                    MediaOrderConflictWarning,\n                )\n            \n            # Add remaining items in original order from list_1, then list_2\n            for item in list_1:\n                if item in remaining and item not in result:\n                    result.append(item)\n            for item in list_2:\n                if item in remaining and item not in result:\n                    result.append(item)\n        \n        return result\n",
      "\n    def merge(self, list_1, list_2):\n        \"\"\"\n        Merge two lists while trying to keep the relative order of the elements.\n        Warn if the lists have the same elements in a different relative order.\n\n        For static assets it can be important to have them included in the DOM\n        in a certain order. In JavaScript you may not be able to reference a\n        global or in CSS you might want to override a style.\n        \"\"\"\n        if not list_1:\n            return list(list_2)\n        if not list_2:\n            return list(list_1)\n        \n        # Build a dependency graph based on the relative ordering in both lists\n        dependencies = {}\n        all_items = set(list_1) | set(list_2)\n        \n        # Initialize dependencies\n        for item in all_items:\n            dependencies[item] = set()\n        \n        # Add dependencies from list_1\n        for i, item in enumerate(list_1):\n            for j in range(i + 1, len(list_1)):\n                dependencies[list_1[j]].add(item)\n        \n        # Add dependencies from list_2, checking for conflicts\n        for i, item in enumerate(list_2):\n            for j in range(i + 1, len(list_2)):\n                dependent = list_2[j]\n                if item in dependencies[dependent]:\n                    # This would create a cycle - genuine conflict\n                    if item in list_1 and dependent in list_1:\n                        idx1 = list_1.index(item)\n                        idx2 = list_1.index(dependent)\n                        if idx1 > idx2:  # Different order in original lists\n                            warnings.warn(\n                                'Detected duplicate Media files in an opposite order:\\n'\n                                '%s\\n%s' % (item, dependent),\n                                MediaOrderConflictWarning,\n                            )\n                else:\n                    dependencies[dependent].add(item)\n        \n        # Topological sort using Kahn's algorithm\n        result = []\n        in_degree = {item: len(deps) for item, deps in dependencies.items()}\n        queue = [item for item in all_items if in_degree[item] == 0]\n        \n        # Sort queue to maintain deterministic output\n        queue.sort()\n        \n        while queue:\n            current = queue.pop(0)\n            result.append(current)\n            \n            # Remove current from all dependency sets and update in_degrees\n            for item in all_items:\n                if current in dependencies[item]:\n                    dependencies[item].remove(current)\n                    in_degree[item] -= 1\n                    if in_degree[item] == 0:\n                        queue.append(item)\n            \n            # Keep queue sorted for deterministic results\n            queue.sort()\n        \n        return result\n",
      "\n    def merge(self, list_1, list_2):\n        \"\"\"\n        Merge two lists while trying to keep the relative order of the elements.\n        Warn if the lists have the same elements in a different relative order.\n\n        For static assets it can be important to have them included in the DOM\n        in a certain order. In JavaScript you may not be able to reference a\n        global or in CSS you might want to override a style.\n        \"\"\"\n        # Build dependency graph from both lists\n        dependencies = {}  # item -> set of items that must come before it\n        all_items = []\n        \n        # Process list_1 to establish ordering dependencies\n        for i, item in enumerate(list_1):\n            if item not in dependencies:\n                dependencies[item] = set()\n                all_items.append(item)\n            # Add dependencies from previous items in this list\n            for prev_item in list_1[:i]:\n                dependencies[item].add(prev_item)\n        \n        # Process list_2 to establish ordering dependencies\n        for i, item in enumerate(list_2):\n            if item not in dependencies:\n                dependencies[item] = set()\n                all_items.append(item)\n            # Add dependencies from previous items in this list\n            for prev_item in list_2[:i]:\n                dependencies[item].add(prev_item)\n        \n        # Check for genuine conflicts (same items in different relative order)\n        conflicts = []\n        for item1 in all_items:\n            for item2 in all_items:\n                if item1 != item2:\n                    # Check if item1 comes before item2 in one list but after in another\n                    in_list1_before = False\n                    in_list1_after = False\n                    in_list2_before = False\n                    in_list2_after = False\n                    \n                    try:\n                        idx1_list1 = list_1.index(item1)\n                        idx2_list1 = list_1.index(item2)\n                        in_list1_before = idx1_list1 < idx2_list1\n                        in_list1_after = idx1_list1 > idx2_list1\n                    except ValueError:\n                        pass\n                    \n                    try:\n                        idx1_list2 = list_2.index(item1)\n                        idx2_list2 = list_2.index(item2)\n                        in_list2_before = idx1_list2 < idx2_list2\n                        in_list2_after = idx1_list2 > idx2_list2\n                    except ValueError:\n                        pass\n                    \n                    if (in_list1_before and in_list2_after) or (in_list1_after and in_list2_before):\n                        conflicts.append((item1, item2))\n        \n        # Warn about genuine conflicts\n        for item1, item2 in conflicts:\n            warnings.warn(\n                'Detected duplicate Media files in an opposite order:\\n'\n                '%s\\n%s' % (item1, item2),\n                MediaOrderConflictWarning,\n            )\n        \n        # Topological sort to resolve dependencies\n        result = []\n        remaining = set(all_items)\n        \n        while remaining:\n            # Find items with no unresolved dependencies\n            ready = []\n            for item in remaining:\n                if not (dependencies[item] & remaining):\n                    ready.append(item)\n            \n            if not ready:\n                # Circular dependency or conflict - fall back to original order\n                ready = [next(iter(remaining))]\n            \n            # Sort ready items by their first appearance to maintain stability\n            ready.sort(key=lambda x: next((i for i, item in enumerate(all_items) if item == x), len(all_items)))\n            \n            # Add the first ready item\n            next_item = ready[0]\n            result.append(next_item)\n            remaining.remove(next_item)\n        \n        return result\n",
      "\n    def merge(self, list_1, list_2):\n        \"\"\"\n        Merge two lists while trying to keep the relative order of elements.\n        Warn if the lists have the same elements in a different relative order.\n\n        For static assets it can be important to have them included in the DOM\n        in a certain order. In JavaScript you may not be able to reference a\n        global or in CSS you might want to override a style.\n        \"\"\"\n        if not list_1:\n            return list(list_2)\n        if not list_2:\n            return list(list_1)\n            \n        # Build a dependency graph based on the relative ordering in both lists\n        all_items = set(list_1) | set(list_2)\n        dependencies = {item: set() for item in all_items}\n        \n        # Add dependencies from list_1\n        for i, item in enumerate(list_1):\n            for j in range(i + 1, len(list_1)):\n                dependencies[list_1[j]].add(item)\n        \n        # Add dependencies from list_2, checking for conflicts\n        for i, item in enumerate(list_2):\n            for j in range(i + 1, len(list_2)):\n                next_item = list_2[j]\n                # Check if this creates a conflict with list_1 ordering\n                if (item in list_1 and next_item in list_1 and \n                    list_1.index(item) > list_1.index(next_item)):\n                    warnings.warn(\n                        'Detected duplicate Media files in an opposite order:\\n'\n                        '%s\\n%s' % (item, next_item),\n                        MediaOrderConflictWarning,\n                    )\n                dependencies[next_item].add(item)\n        \n        # Topological sort to resolve dependencies\n        result = []\n        remaining = set(all_items)\n        \n        while remaining:\n            # Find items with no remaining dependencies\n            ready = [item for item in remaining \n                    if not (dependencies[item] & remaining)]\n            \n            if not ready:\n                # Cycle detected - fallback to original behavior\n                ready = [remaining.pop()]\n            \n            # Sort ready items to maintain stable ordering\n            ready.sort(key=lambda x: (\n                list_1.index(x) if x in list_1 else float('inf'),\n                list_2.index(x) if x in list_2 else float('inf')\n            ))\n            \n            for item in ready:\n                if item in remaining:\n                    result.append(item)\n                    remaining.remove(item)\n        \n        return result\n",
      "\n    @staticmethod\n    def merge(*lists):\n        \"\"\"\n        Merge lists while trying to keep the relative order of the elements.\n        Warn if the lists have the same elements in a different relative order.\n\n        For static assets it can be important to have them included in the DOM\n        in a certain order. In JavaScript you may not be able to reference a\n        global or in CSS you might want to override a style.\n        \"\"\"\n        if not lists:\n            return []\n        if len(lists) == 1:\n            return list(lists[0])\n        \n        # Build a dependency graph from all input lists\n        dependency_graph = {}\n        all_items = set()\n        \n        for lst in lists:\n            lst_items = list(lst)\n            all_items.update(lst_items)\n            \n            # Add dependencies based on order in this list\n            for i, item in enumerate(lst_items):\n                if item not in dependency_graph:\n                    dependency_graph[item] = set()\n                \n                # This item depends on all items that come before it in this list\n                for j in range(i):\n                    dependency_graph[item].add(lst_items[j])\n        \n        # Check for genuine conflicts (cycles in dependency graph)\n        def has_cycle():\n            visited = set()\n            rec_stack = set()\n            \n            def dfs(node):\n                if node in rec_stack:\n                    return True\n                if node in visited:\n                    return False\n                    \n                visited.add(node)\n                rec_stack.add(node)\n                \n                for neighbor in dependency_graph.get(node, set()):\n                    if dfs(neighbor):\n                        return True\n                        \n                rec_stack.remove(node)\n                return False\n            \n            for item in all_items:\n                if item not in visited:\n                    if dfs(item):\n                        return True\n            return False\n        \n        # Warn about genuine conflicts only\n        if has_cycle():\n            # Find conflicting items for warning\n            conflicting_items = []\n            for lst in lists:\n                lst_items = list(lst)\n                for i in range(len(lst_items)):\n                    for j in range(i + 1, len(lst_items)):\n                        item1, item2 = lst_items[i], lst_items[j]\n                        # Check if there's a reverse dependency in another list\n                        for other_lst in lists:\n                            other_items = list(other_lst)\n                            try:\n                                idx1 = other_items.index(item1)\n                                idx2 = other_items.index(item2)\n                                if idx1 > idx2:  # Reverse order found\n                                    conflicting_items = [item1, item2]\n                                    break\n                            except ValueError:\n                                continue\n                        if conflicting_items:\n                            break\n                    if conflicting_items:\n                        break\n                if conflicting_items:\n                    break\n            \n            if conflicting_items:\n                warnings.warn(\n                    'Detected duplicate Media files in an opposite order:\\n'\n                    '%s\\n%s' % (conflicting_items[0], conflicting_items[1]),\n                    MediaOrderConflictWarning,\n                )\n        \n        # Perform topological sort\n        result = []\n        visited = set()\n        \n        def topological_sort(node):\n            if node in visited:\n                return\n            visited.add(node)\n            \n            # Visit all dependencies first\n            for dep in dependency_graph.get(node, set()):\n                topological_sort(dep)\n            \n            result.append(node)\n        \n        # Sort items to ensure deterministic output\n        for item in sorted(all_items):\n            topological_sort(item)\n        \n        return result\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex 02aa32b207..e915c15868 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -68,13 +68,23 @@ class Media:\n             }\n         return css\n \n+    @property\n+\n     @property\n     def _js(self):\n-        js = self._js_lists[0]\n-        # filter(None, ...) avoids calling merge() with empty lists.\n-        for obj in filter(None, self._js_lists[1:]):\n-            js = self.merge(js, obj)\n-        return js\n+        # Collect all JS lists first, then merge them globally\n+        all_js_lists = [js_list for js_list in self._js_lists if js_list]\n+        if not all_js_lists:\n+            return []\n+        \n+        # Start with the first list\n+        result = list(all_js_lists[0])\n+        \n+        # Merge each subsequent list\n+        for js_list in all_js_lists[1:]:\n+            result = self.merge(result, js_list)\n+        \n+        return result\n \n     def render(self):\n         return mark_safe('\\n'.join(chain.from_iterable(getattr(self, 'render_' + name)() for name in MEDIA_TYPES)))\n@@ -114,6 +124,8 @@ class Media:\n             return Media(**{str(name): getattr(self, '_' + name)})\n         raise KeyError('Unknown media type \"%s\"' % name)\n \n+    @staticmethod\n+\n     @staticmethod\n     def merge(list_1, list_2):\n         \"\"\"\n@@ -127,28 +139,90 @@ class Media:\n         \"\"\"\n         # Start with a copy of list_1.\n         combined_list = list(list_1)\n-        last_insert_index = len(list_1)\n-        # Walk list_2 in reverse, inserting each element into combined_list if\n-        # it doesn't already exist.\n-        for path in reversed(list_2):\n-            try:\n-                # Does path already exist in the list?\n-                index = combined_list.index(path)\n-            except ValueError:\n-                # Add path to combined_list since it doesn't exist.\n-                combined_list.insert(last_insert_index, path)\n+        \n+        # Process list_2 in forward order to maintain natural dependencies\n+        for path in list_2:\n+            if path not in combined_list:\n+                # Add new path to the end\n+                combined_list.append(path)\n             else:\n-                if index > last_insert_index:\n-                    warnings.warn(\n-                        'Detected duplicate Media files in an opposite order:\\n'\n-                        '%s\\n%s' % (combined_list[last_insert_index], combined_list[index]),\n-                        MediaOrderConflictWarning,\n-                    )\n+                # Path already exists - check for genuine conflicts\n+                existing_index = combined_list.index(path)\n+                \n+                # Find the position where this path should be based on list_2's ordering\n+                # Look for any items from list_2 that come before this path\n+                desired_position = 0\n+                for earlier_path in list_2:\n+                    if earlier_path == path:\n+                        break\n+                    if earlier_path in combined_list:\n+                        earlier_index = combined_list.index(earlier_path)\n+                        desired_position = max(desired_position, earlier_index + 1)\n+                \n+                # Only warn if there's a genuine ordering conflict\n+                if existing_index < desired_position:\n+                    # Find the conflicting file that should come after but appears before\n+                    conflicting_path = None\n+                    for i in range(existing_index + 1, len(combined_list)):\n+                        if combined_list[i] in list_2:\n+                            list_2_index_current = list_2.index(path)\n+                            list_2_index_other = list_2.index(combined_list[i])\n+                            if list_2_index_current < list_2_index_other:\n+                                conflicting_path = combined_list[i]\n+                                break\n+                    \n+                    if conflicting_path:\n+                        warnings.warn(\n+                            'Detected duplicate Media files in an opposite order:\\n'\n+                            '%s\\n%s' % (path, conflicting_path),\n+                            MediaOrderConflictWarning,\n+                        )\n+                    \n+                    # Move the path to its correct position\n+                    combined_list.pop(existing_index)\n+                    combined_list.insert(desired_position, path)\n+        \n+        return combined_list\n+                        desired_position = max(desired_position, earlier_index + 1)\n+                \n+                # Only warn if there's a genuine ordering conflict\n+                if existing_index < desired_position:\n+                    # Find the conflicting file that should come after but appears before\n+                    conflicting_path = None\n+                    for i in range(existing_index + 1, len(combined_list)):\n+                        if combined_list[i] in list_2:\n+                            list_2_index_current = list_2.index(path)\n+                            list_2_index_other = list_2.index(combined_list[i])\n+                            if list_2_index_current < list_2_index_other:\n+                                conflicting_path = combined_list[i]\n+                                break\n+                    \n+                    if conflicting_path:\n+                        warnings.warn(\n+                            'Detected duplicate Media files in an opposite order:\\n'\n+                            '%s\\n%s' % (path, conflicting_path),\n+                            MediaOrderConflictWarning,\n+                        )\n+                    \n+                    # Move the path to its correct position\n+                    combined_list.pop(existing_index)\n+                    combined_list.insert(desired_position, path)\n+                            if list_2_index_current < list_2_index_other:\n+                                conflicting_path = combined_list[i]\n+                                break\n+                    \n+                    if conflicting_path:\n+                        warnings.warn(\n+                            'Detected duplicate Media files in an opposite order:\\n'\n+                            '%s\\n%s' % (path, conflicting_path),\n+                            MediaOrderConflictWarning,\n+                        )\n                 # path already exists in the list. Update last_insert_index so\n                 # that the following elements are inserted in front of this one.\n                 last_insert_index = index\n         return combined_list\n \n+\n     def __add__(self, other):\n         combined = Media()\n         combined._css_lists = self._css_lists + other._css_lists\n",
    "variant_0": "diff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex 02aa32b207..f2b909f407 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -68,13 +68,19 @@ class Media:\n             }\n         return css\n \n+    @property\n+\n     @property\n     def _js(self):\n-        js = self._js_lists[0]\n-        # filter(None, ...) avoids calling merge() with empty lists.\n-        for obj in filter(None, self._js_lists[1:]):\n-            js = self.merge(js, obj)\n-        return js\n+        # Collect all JS lists for global merge instead of sequential pairwise merging\n+        all_js_lists = [js_list for js_list in self._js_lists if js_list]\n+        if not all_js_lists:\n+            return []\n+        elif len(all_js_lists) == 1:\n+            return all_js_lists[0]\n+        else:\n+            # Perform single global merge of all lists to avoid false intermediate constraints\n+            return self.merge_all(all_js_lists)\n \n     def render(self):\n         return mark_safe('\\n'.join(chain.from_iterable(getattr(self, 'render_' + name)() for name in MEDIA_TYPES)))\n@@ -114,6 +120,8 @@ class Media:\n             return Media(**{str(name): getattr(self, '_' + name)})\n         raise KeyError('Unknown media type \"%s\"' % name)\n \n+    @staticmethod\n+\n     @staticmethod\n     def merge(list_1, list_2):\n         \"\"\"\n@@ -125,34 +133,226 @@ class Media:\n         in a certain order. In JavaScript you may not be able to reference a\n         global or in CSS you might want to override a style.\n         \"\"\"\n-        # Start with a copy of list_1.\n-        combined_list = list(list_1)\n-        last_insert_index = len(list_1)\n-        # Walk list_2 in reverse, inserting each element into combined_list if\n-        # it doesn't already exist.\n-        for path in reversed(list_2):\n-            try:\n-                # Does path already exist in the list?\n-                index = combined_list.index(path)\n-            except ValueError:\n-                # Add path to combined_list since it doesn't exist.\n-                combined_list.insert(last_insert_index, path)\n-            else:\n-                if index > last_insert_index:\n+        if not list_1:\n+            return list(list_2)\n+        if not list_2:\n+            return list(list_1)\n+        \n+        # Build a dependency graph based on the order in each list\n+        dependencies = {}  # item -> set of items that must come before it\n+        all_items = set(list_1) | set(list_2)\n+        \n+        for item in all_items:\n+            dependencies[item] = set()\n+        \n+        # Add dependencies from list_1\n+        for i in range(len(list_1) - 1):\n+            dependencies[list_1[i + 1]].add(list_1[i])\n+        \n+        # Add dependencies from list_2, checking for conflicts\n+        for i in range(len(list_2) - 1):\n+            current = list_2[i]\n+            next_item = list_2[i + 1]\n+            \n+            # Check if this would create a conflict with list_1's ordering\n+            if (current in list_1 and next_item in list_1 and \n+                list_1.index(current) > list_1.index(next_item)):\n+                warnings.warn(\n+                    'Detected duplicate Media files in an opposite order:\\n'\n+                    '%s\\n%s' % (current, next_item),\n+                    MediaOrderConflictWarning,\n+                )\n+            \n+            dependencies[next_item].add(current)\n+        \n+        # Topological sort using Kahn's algorithm\n+        result = []\n+        in_degree = {item: len(dependencies[item]) for item in all_items}\n+        queue = [item for item in all_items if in_degree[item] == 0]\n+        \n+        # Sort queue to ensure deterministic output when multiple items have no dependencies\n+        queue.sort(key=lambda x: (list_1.index(x) if x in list_1 else float('inf'),\n+                                  list_2.index(x) if x in list_2 else float('inf')))\n+        \n+        while queue:\n+            current = queue.pop(0)\n+            result.append(current)\n+            \n+            # Remove current from all dependency sets and update in_degree\n+            for item in all_items:\n+                if current in dependencies[item]:\n+                    dependencies[item].remove(current)\n+                    in_degree[item] -= 1\n+                    if in_degree[item] == 0:\n+                        queue.append(item)\n+            \n+            # Keep queue sorted for deterministic output\n+            queue.sort(key=lambda x: (list_1.index(x) if x in list_1 else float('inf'),\n+                                      list_2.index(x) if x in list_2 else float('inf')))\n+        \n+        return result\n+        \n+        for item in all_items:\n+            dependencies[item] = set()\n+        \n+        # Add dependencies from list_1\n+        for i in range(len(list_1) - 1):\n+            dependencies[list_1[i + 1]].add(list_1[i])\n+            \n+        # Add dependencies from list_2, checking for conflicts\n+        for i in range(len(list_2) - 1):\n+            curr_item = list_2[i + 1]\n+            prev_item = list_2[i]\n+            \n+            # Check if this creates a cycle (genuine conflict)\n+            if self._would_create_cycle(dependencies, prev_item, curr_item):\n+                # Find the conflicting items for warning\n+                pos1_in_list1 = list_1.index(curr_item) if curr_item in list_1 else -1\n+                pos2_in_list1 = list_1.index(prev_item) if prev_item in list_1 else -1\n+                \n+                if pos1_in_list1 != -1 and pos2_in_list1 != -1 and pos1_in_list1 < pos2_in_list1:\n                     warnings.warn(\n                         'Detected duplicate Media files in an opposite order:\\n'\n-                        '%s\\n%s' % (combined_list[last_insert_index], combined_list[index]),\n+                        '%s\\n%s' % (prev_item, curr_item),\n                         MediaOrderConflictWarning,\n                     )\n+            else:\n+                dependencies[curr_item].add(prev_item)\n+        \n+        # Topological sort\n+        return self._topological_sort(dependencies, list_1, list_2)\n+    \n+    def _would_create_cycle(self, dependencies, from_item, to_item):\n+        \"\"\"Check if adding dependency from_item -> to_item would create a cycle.\"\"\"\n+        if from_item == to_item:\n+            return True\n+            \n+        visited = set()\n+        \n+        def has_path(start, end):\n+            if start == end:\n+                return True\n+            if start in visited:\n+                return False\n+            visited.add(start)\n+            \n+            for dep in dependencies.get(start, set()):\n+                if has_path(dep, end):\n+                    return True\n+            return False\n+        \n+        return has_path(to_item, from_item)\n+    \n+    def _topological_sort(self, dependencies, list_1, list_2):\n+        \"\"\"Perform topological sort respecting original list priorities.\"\"\"\n+        result = []\n+        remaining = set(dependencies.keys())\n+        \n+        # Priority order: items appearing earlier in list_1, then list_2\n+        def get_priority(item):\n+            try:\n+                return (0, list_1.index(item))\n+            except ValueError:\n+                try:\n+                    return (1, list_2.index(item))\n+                except ValueError:\n+                    return (2, 0)\n+        \n+        while remaining:\n+            # Find items with no remaining dependencies\n+            ready = [item for item in remaining \n+                    if not (dependencies[item] & remaining)]\n+            \n+            if not ready:\n+                # Cycle detected, break it by choosing highest priority item\n+                ready = [min(remaining, key=get_priority)]\n+            \n+            # Sort ready items by priority\n+            ready.sort(key=get_priority)\n+            next_item = ready[0]\n+            \n+            result.append(next_item)\n+            remaining.remove(next_item)\n+        \n+        return result\n+        Would result in:\n+        ['a', 'b', 'c', 'd', 'e']\n+        \"\"\"\n+        # Convert lists to preserve order while allowing efficient lookups\n+        combined_list = list(list_1)\n+        \n+        # Track positions of elements from list_1 for conflict detection\n+        list_1_positions = {item: i for i, item in enumerate(list_1)}\n+        \n+        # Process list_2 elements in forward order\n+        for item in list_2:\n+            if item in combined_list:\n+                # Item already exists, check for ordering conflicts\n+                current_index = combined_list.index(item)\n+                \n+                # Find the best insertion point based on dependencies\n+                insert_index = current_index\n+                \n+                # Look for items that should come before this one based on list_2\n+                item_index_in_list_2 = list_2.index(item)\n+                for j in range(item_index_in_list_2):\n+                    predecessor = list_2[j]\n+                    if predecessor in combined_list:\n+                        pred_index = combined_list.index(predecessor)\n+                        insert_index = max(insert_index, pred_index + 1)\n+                \n+                # Check for genuine ordering conflicts\n+                if item in list_1_positions:\n+                    # Find items that appear after this item in list_1 but before it in list_2\n+                    for k in range(item_index_in_list_2):\n+                        other_item = list_2[k]\n+                        if (other_item in list_1_positions and \n+                            list_1_positions[other_item] > list_1_positions[item]):\n+                            warnings.warn(\n+                                'Detected duplicate Media files in an opposite order:\\n'\n+                                '%s\\n%s' % (other_item, item),\n+                                MediaOrderConflictWarning,\n+                            )\n+                            break\n+                \n+                # Move item to correct position if needed\n+                if insert_index != current_index:\n+                    combined_list.pop(current_index)\n+                    combined_list.insert(insert_index if insert_index <= current_index else insert_index - 1, item)\n+            else:\n+                # Item doesn't exist, find the best insertion point\n+                insert_index = len(combined_list)\n+                \n+                # Look for items that should come before this one\n+                item_index_in_list_2 = list_2.index(item)\n+                for j in range(item_index_in_list_2):\n+                    predecessor = list_2[j]\n+                    if predecessor in combined_list:\n+                        pred_index = combined_list.index(predecessor)\n+                        insert_index = min(insert_index, pred_index + 1)\n+                \n+                # Look for items that should come after this one\n+                for j in range(item_index_in_list_2 + 1, len(list_2)):\n+                    successor = list_2[j]\n+                    if successor in combined_list:\n+                        succ_index = combined_list.index(successor)\n+                        insert_index = min(insert_index, succ_index)\n+                        break\n+                \n+                combined_list.insert(insert_index, item)\n+        \n+        return combined_list\n                 # path already exists in the list. Update last_insert_index so\n                 # that the following elements are inserted in front of this one.\n                 last_insert_index = index\n         return combined_list\n \n+\n     def __add__(self, other):\n         combined = Media()\n-        combined._css_lists = self._css_lists + other._css_lists\n-        combined._js_lists = self._js_lists + other._js_lists\n+        # Preserve original media lists for global dependency resolution\n+        combined._css_lists = list(self._css_lists) + list(other._css_lists)\n+        combined._js_lists = list(self._js_lists) + list(other._js_lists)\n         return combined\n \n \n",
    "variant_1": "diff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex 02aa32b207..01db4c2543 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -68,13 +68,20 @@ class Media:\n             }\n         return css\n \n+    @property\n+\n     @property\n     def _js(self):\n-        js = self._js_lists[0]\n-        # filter(None, ...) avoids calling merge() with empty lists.\n-        for obj in filter(None, self._js_lists[1:]):\n-            js = self.merge(js, obj)\n-        return js\n+        # Collect all JS lists first to enable global dependency resolution\n+        all_js_lists = [js_list for js_list in self._js_lists if js_list]\n+        \n+        if not all_js_lists:\n+            return []\n+        elif len(all_js_lists) == 1:\n+            return all_js_lists[0]\n+        \n+        # Perform single global merge instead of sequential pairwise merges\n+        return self.merge_global(all_js_lists)\n \n     def render(self):\n         return mark_safe('\\n'.join(chain.from_iterable(getattr(self, 'render_' + name)() for name in MEDIA_TYPES)))\n@@ -114,6 +121,8 @@ class Media:\n             return Media(**{str(name): getattr(self, '_' + name)})\n         raise KeyError('Unknown media type \"%s\"' % name)\n \n+    @staticmethod\n+\n     @staticmethod\n     def merge(list_1, list_2):\n         \"\"\"\n@@ -125,32 +134,223 @@ class Media:\n         in a certain order. In JavaScript you may not be able to reference a\n         global or in CSS you might want to override a style.\n         \"\"\"\n-        # Start with a copy of list_1.\n-        combined_list = list(list_1)\n-        last_insert_index = len(list_1)\n-        # Walk list_2 in reverse, inserting each element into combined_list if\n-        # it doesn't already exist.\n-        for path in reversed(list_2):\n-            try:\n-                # Does path already exist in the list?\n-                index = combined_list.index(path)\n-            except ValueError:\n-                # Add path to combined_list since it doesn't exist.\n-                combined_list.insert(last_insert_index, path)\n-            else:\n-                if index > last_insert_index:\n+        if not list_1:\n+            return list(list_2)\n+        if not list_2:\n+            return list(list_1)\n+        \n+        # Build a dependency graph from both lists\n+        dependencies = {}\n+        all_items = set(list_1) | set(list_2)\n+        \n+        for item in all_items:\n+            dependencies[item] = set()\n+        \n+        # Add dependencies from list_1\n+        for i in range(len(list_1) - 1):\n+            dependencies[list_1[i + 1]].add(list_1[i])\n+        \n+        # Add dependencies from list_2, checking for conflicts\n+        for i in range(len(list_2) - 1):\n+            current = list_2[i + 1]\n+            predecessor = list_2[i]\n+            \n+            # Check if adding this dependency would create a conflict\n+            if predecessor in dependencies[current]:\n+                continue  # Already have this dependency\n+            \n+            # Check for reverse dependency (conflict)\n+            if current in dependencies[predecessor]:\n+                # Find the conflicting items in their original contexts\n+                list_1_has_conflict = False\n+                list_2_has_conflict = False\n+                \n+                try:\n+                    idx1_pred = list_1.index(predecessor)\n+                    idx1_curr = list_1.index(current)\n+                    list_1_has_conflict = idx1_pred > idx1_curr\n+                except ValueError:\n+                    pass\n+                \n+                try:\n+                    idx2_pred = list_2.index(predecessor)\n+                    idx2_curr = list_2.index(current)\n+                    list_2_has_conflict = idx2_pred < idx2_curr\n+                except ValueError:\n+                    pass\n+                \n+                if list_1_has_conflict and list_2_has_conflict:\n                     warnings.warn(\n                         'Detected duplicate Media files in an opposite order:\\n'\n-                        '%s\\n%s' % (combined_list[last_insert_index], combined_list[index]),\n+                        '%s\\n%s' % (predecessor, current),\n                         MediaOrderConflictWarning,\n                     )\n+                continue\n+            \n+            dependencies[current].add(predecessor)\n+        \n+        # Topological sort using Kahn's algorithm\n+        in_degree = {item: len(deps) for item, deps in dependencies.items()}\n+        queue = [item for item in all_items if in_degree[item] == 0]\n+        result = []\n+        \n+        while queue:\n+            # Sort queue to ensure deterministic output\n+            queue.sort()\n+            current = queue.pop(0)\n+            result.append(current)\n+            \n+            # Update in-degrees of dependent items\n+            for item, deps in dependencies.items():\n+                if current in deps:\n+                    in_degree[item] -= 1\n+                    if in_degree[item] == 0:\n+                        queue.append(item)\n+        \n+        # Check for cycles (shouldn't happen with valid input)\n+        if len(result) != len(all_items):\n+            # Fallback to original behavior if cycle detected\n+            combined_list = list(list_1)\n+            for item in list_2:\n+                if item not in combined_list:\n+                    combined_list.append(item)\n+            return combined_list\n+        \n+        return result\n+            for pos, item in enumerate(lst):\n+                if item not in item_positions:\n+                    item_positions[item] = []\n+                item_positions[item].append((list_idx, pos))\n+                if item not in all_items:\n+                    all_items.append(item)\n+        \n+        # Check for genuine conflicts\n+        conflicts = []\n+        for item, positions in item_positions.items():\n+            if len(positions) > 1:\n+                # Check if this item has conflicting relative positions\n+                for i, (list1_idx, pos1) in enumerate(positions):\n+                    for list2_idx, pos2 in positions[i+1:]:\n+                        # Find common items between these two lists\n+                        list1_items = set(lists[list1_idx])\n+                        list2_items = set(lists[list2_idx])\n+                        common_items = list1_items & list2_items\n+                        \n+                        # Check relative ordering of common items\n+                        for common_item in common_items:\n+                            if common_item != item:\n+                                common_pos1 = lists[list1_idx].index(common_item)\n+                                common_pos2 = lists[list2_idx].index(common_item)\n+                                \n+                                # Check if relative order is inconsistent\n+                                if ((pos1 < common_pos1) != (pos2 < common_pos2)):\n+                                    conflicts.append((item, common_item))\n+        \n+        # Warn about genuine conflicts\n+        for item1, item2 in conflicts:\n+            warnings.warn(\n+                'Detected duplicate Media files in an opposite order:\\n'\n+                '%s\\n%s' % (item1, item2),\n+                MediaOrderConflictWarning,\n+            )\n+        \n+        # Build result preserving original list order constraints\n+        result = []\n+        processed = set()\n+        \n+        # Process items in the order they first appear\n+        for item in all_items:\n+            if item in processed:\n+                continue\n+                \n+            # Find the best position for this item\n+            best_position = len(result)\n+            \n+            # Check constraints from all lists containing this item\n+            for list_idx, pos_in_list in item_positions[item]:\n+                current_list = lists[list_idx]\n+                \n+                # Find items that should come before this item in current_list\n+                predecessors_in_result = []\n+                for pred_pos in range(pos_in_list):\n+                    pred_item = current_list[pred_pos]\n+                    if pred_item in processed:\n+                        pred_idx = result.index(pred_item)\n+                        predecessors_in_result.append(pred_idx)\n+                \n+                # Position should be after the latest predecessor\n+                if predecessors_in_result:\n+                    min_position = max(predecessors_in_result) + 1\n+                    best_position = max(best_position, min_position)\n+            \n+            # Insert at the determined position\n+            result.insert(best_position, item)\n+            processed.add(item)\n+        \n+        return result\n+            return list_1[:]\n+        \n+        # Create a combined list preserving relative order from both inputs\n+        combined_list = list_1[:]\n+        \n+        # Track positions of items from list_1 for dependency resolution\n+        positions = {item: idx for idx, item in enumerate(list_1)}\n+        \n+        # Process list_2 items in forward order to respect dependencies\n+        for item in list_2:\n+            if item in combined_list:\n+                # Item already exists, check for genuine conflicts\n+                existing_idx = combined_list.index(item)\n+                # Only warn if this creates a real ordering conflict\n+                # (same item in different relative positions in original lists)\n+                list_1_has_item = item in list_1\n+                if list_1_has_item:\n+                    list_1_idx = list_1.index(item)\n+                    list_2_idx = list_2.index(item)\n+                    \n+                    # Check items that appear after this item in both lists\n+                    for other_item in list_2[list_2_idx + 1:]:\n+                        if other_item in list_1:\n+                            other_list_1_idx = list_1.index(other_item)\n+                            if other_list_1_idx < list_1_idx:\n+                                # Genuine conflict: item comes after other_item in list_2\n+                                # but before other_item in list_1\n+                                warnings.warn(\n+                                    'Detected duplicate Media files in an opposite order:\\n'\n+                                    '%s\\n%s' % (item, other_item),\n+                                    MediaOrderConflictWarning,\n+                                )\n+                                break\n+            else:\n+                # Find the best insertion point based on dependencies\n+                insert_idx = len(combined_list)\n+                \n+                # Look for items in list_2 that should come after this item\n+                item_idx_in_list_2 = list_2.index(item)\n+                for later_item in list_2[item_idx_in_list_2 + 1:]:\n+                    if later_item in combined_list:\n+                        later_idx = combined_list.index(later_item)\n+                        insert_idx = min(insert_idx, later_idx)\n+                \n+                # Look for items in list_1 that should come before this item\n+                for earlier_item in reversed(list_1):\n+                    if earlier_item in combined_list:\n+                        earlier_idx = combined_list.index(earlier_item)\n+                        insert_idx = max(insert_idx, earlier_idx + 1)\n+                        break\n+                \n+                combined_list.insert(insert_idx, item)\n+        \n+        return combined_list\n                 # path already exists in the list. Update last_insert_index so\n                 # that the following elements are inserted in front of this one.\n                 last_insert_index = index\n         return combined_list\n \n+\n     def __add__(self, other):\n         combined = Media()\n+        # Store original media lists to enable global dependency resolution\n         combined._css_lists = self._css_lists + other._css_lists\n         combined._js_lists = self._js_lists + other._js_lists\n         return combined\n",
    "variant_2": "diff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex 02aa32b207..288a97c96b 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -68,13 +68,19 @@ class Media:\n             }\n         return css\n \n+    @property\n+\n     @property\n     def _js(self):\n-        js = self._js_lists[0]\n-        # filter(None, ...) avoids calling merge() with empty lists.\n-        for obj in filter(None, self._js_lists[1:]):\n-            js = self.merge(js, obj)\n-        return js\n+        # Collect all JS lists to perform global merge instead of sequential pairwise merges\n+        all_js_lists = [js_list for js_list in self._js_lists if js_list]\n+        if not all_js_lists:\n+            return []\n+        elif len(all_js_lists) == 1:\n+            return all_js_lists[0]\n+        else:\n+            # Perform single global merge of all lists\n+            return self.merge_all(all_js_lists)\n \n     def render(self):\n         return mark_safe('\\n'.join(chain.from_iterable(getattr(self, 'render_' + name)() for name in MEDIA_TYPES)))\n@@ -114,6 +120,8 @@ class Media:\n             return Media(**{str(name): getattr(self, '_' + name)})\n         raise KeyError('Unknown media type \"%s\"' % name)\n \n+    @staticmethod\n+\n     @staticmethod\n     def merge(list_1, list_2):\n         \"\"\"\n@@ -125,32 +133,183 @@ class Media:\n         in a certain order. In JavaScript you may not be able to reference a\n         global or in CSS you might want to override a style.\n         \"\"\"\n-        # Start with a copy of list_1.\n-        combined_list = list(list_1)\n-        last_insert_index = len(list_1)\n-        # Walk list_2 in reverse, inserting each element into combined_list if\n-        # it doesn't already exist.\n-        for path in reversed(list_2):\n-            try:\n-                # Does path already exist in the list?\n-                index = combined_list.index(path)\n-            except ValueError:\n-                # Add path to combined_list since it doesn't exist.\n-                combined_list.insert(last_insert_index, path)\n-            else:\n-                if index > last_insert_index:\n+        if not list_1:\n+            return list(list_2)\n+        if not list_2:\n+            return list(list_1)\n+        \n+        # Build a dependency graph based on relative ordering in each list\n+        dependencies = {}  # item -> set of items that must come before it\n+        all_items = set(list_1) | set(list_2)\n+        \n+        for item in all_items:\n+            dependencies[item] = set()\n+        \n+        # Add dependencies from list_1\n+        for i, item in enumerate(list_1):\n+            for j in range(i):\n+                dependencies[item].add(list_1[j])\n+        \n+        # Add dependencies from list_2, checking for conflicts\n+        for i, item in enumerate(list_2):\n+            for j in range(i):\n+                predecessor = list_2[j]\n+                if predecessor in dependencies[item]:\n+                    continue  # Already have this dependency\n+                \n+                # Check for conflict: item should come before predecessor in list_1\n+                if item in dependencies[predecessor]:\n                     warnings.warn(\n                         'Detected duplicate Media files in an opposite order:\\n'\n-                        '%s\\n%s' % (combined_list[last_insert_index], combined_list[index]),\n+                        '%s\\n%s' % (predecessor, item),\n                         MediaOrderConflictWarning,\n                     )\n+                else:\n+                    dependencies[item].add(predecessor)\n+        \n+        # Topological sort\n+        result = []\n+        visited = set()\n+        temp_visited = set()\n+        \n+        def visit(item):\n+            if item in temp_visited:\n+                # Circular dependency - just add the item\n+                return\n+            if item in visited:\n+                return\n+            \n+            temp_visited.add(item)\n+            for dep in dependencies[item]:\n+                if dep in all_items:\n+                    visit(dep)\n+            temp_visited.remove(item)\n+            visited.add(item)\n+            result.append(item)\n+        \n+        for item in all_items:\n+            if item not in visited:\n+                visit(item)\n+        \n+        return result\n+            for item in lst:\n+                if item not in seen:\n+                    all_items.append(item)\n+                    seen.add(item)\n+        \n+        # Build dependency graph from all input lists\n+        dependencies = {item: set() for item in all_items}\n+        \n+        for lst in lists:\n+            for i, item in enumerate(lst):\n+                # Item depends on all items that come before it in this list\n+                for j in range(i):\n+                    dependencies[item].add(lst[j])\n+        \n+        # Check for genuine conflicts (cycles in dependency graph)\n+        def has_conflict(item1, item2):\n+            return item2 in dependencies[item1] and item1 in dependencies[item2]\n+        \n+        # Detect and warn about genuine conflicts\n+        for i, item1 in enumerate(all_items):\n+            for j in range(i + 1, len(all_items)):\n+                item2 = all_items[j]\n+                if has_conflict(item1, item2):\n+                    warnings.warn(\n+                        'Detected duplicate Media files in an opposite order:\\n'\n+                        '%s\\n%s' % (item1, item2),\n+                        MediaOrderConflictWarning,\n+                    )\n+        \n+        # Topological sort with conflict resolution\n+        result = []\n+        remaining = set(all_items)\n+        \n+        while remaining:\n+            # Find items with no unresolved dependencies\n+            ready = []\n+            for item in remaining:\n+                if not (dependencies[item] & remaining):\n+                    ready.append(item)\n+            \n+            if not ready:\n+                # Cycle detected, break it by choosing item with minimum dependencies\n+                ready = [min(remaining, key=lambda x: len(dependencies[x] & remaining))]\n+            \n+            # Sort ready items by their original appearance order\n+            ready.sort(key=lambda x: all_items.index(x))\n+            \n+            # Add the first ready item to result\n+            next_item = ready[0]\n+            result.append(next_item)\n+            remaining.remove(next_item)\n+        \n+        return result\n+        Would result in ['a', 'b', 'c', 'd', 'e']\n+        \"\"\"\n+        # Convert to lists to handle various iterable types\n+        list_1 = list(list_1)\n+        list_2 = list(list_2) \n+        \n+        if not list_1:\n+            return list_2[:]\n+        if not list_2:\n+            return list_1[:]\n+            \n+        # Build a combined list starting with list_1\n+        combined_list = list_1[:]\n+        \n+        # Track positions of elements from list_1 for conflict detection\n+        original_positions = {item: i for i, item in enumerate(list_1)}\n+        \n+        # Process list_2 elements in order\n+        for item in list_2:\n+            if item in combined_list:\n+                # Item already exists, check for genuine conflicts\n+                current_pos = combined_list.index(item)\n+                expected_pos = original_positions.get(item)\n+                \n+                if expected_pos is not None:\n+                    # Find items from list_2 that should come before this item\n+                    items_before = [x for x in list_2[:list_2.index(item)] if x in combined_list]\n+                    \n+                    # Check if any item that should come before appears after in combined_list\n+                    conflict_detected = False\n+                    for before_item in items_before:\n+                        before_pos = combined_list.index(before_item)\n+                        if before_pos > current_pos:\n+                            warnings.warn(\n+                                'Detected duplicate Media files in an opposite order:\\n'\n+                                '%s\\n%s' % (before_item, item),\n+                                MediaOrderConflictWarning,\n+                            )\n+                            conflict_detected = True\n+                            break\n+            else:\n+                # Item doesn't exist, find the best insertion point\n+                # Look for the latest position where we can insert while respecting list_2 order\n+                insert_pos = len(combined_list)\n+                \n+                # Find items from list_2 that come after this item\n+                items_after = [x for x in list_2[list_2.index(item)+1:] if x in combined_list]\n+                \n+                # Insert before the first \"after\" item we find\n+                for after_item in items_after:\n+                    after_pos = combined_list.index(after_item)\n+                    insert_pos = min(insert_pos, after_pos)\n+                \n+                combined_list.insert(insert_pos, item)\n+        \n+        return combined_list\n                 # path already exists in the list. Update last_insert_index so\n                 # that the following elements are inserted in front of this one.\n                 last_insert_index = index\n         return combined_list\n \n+\n     def __add__(self, other):\n         combined = Media()\n+        # Store original lists instead of merging immediately\n         combined._css_lists = self._css_lists + other._css_lists\n         combined._js_lists = self._js_lists + other._js_lists\n         return combined\n",
    "variant_3": "diff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex 02aa32b207..0ebbe1ee79 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -68,13 +68,19 @@ class Media:\n             }\n         return css\n \n+    @property\n+\n     @property\n     def _js(self):\n-        js = self._js_lists[0]\n-        # filter(None, ...) avoids calling merge() with empty lists.\n-        for obj in filter(None, self._js_lists[1:]):\n-            js = self.merge(js, obj)\n-        return js\n+        # Collect all JS lists for global merge instead of sequential pairwise merging\n+        all_js_lists = [js_list for js_list in self._js_lists if js_list]\n+        if not all_js_lists:\n+            return []\n+        elif len(all_js_lists) == 1:\n+            return all_js_lists[0]\n+        else:\n+            # Perform single global merge to avoid false intermediate constraints\n+            return self.merge_all(all_js_lists)\n \n     def render(self):\n         return mark_safe('\\n'.join(chain.from_iterable(getattr(self, 'render_' + name)() for name in MEDIA_TYPES)))\n@@ -114,6 +120,8 @@ class Media:\n             return Media(**{str(name): getattr(self, '_' + name)})\n         raise KeyError('Unknown media type \"%s\"' % name)\n \n+    @staticmethod\n+\n     @staticmethod\n     def merge(list_1, list_2):\n         \"\"\"\n@@ -125,32 +133,201 @@ class Media:\n         in a certain order. In JavaScript you may not be able to reference a\n         global or in CSS you might want to override a style.\n         \"\"\"\n-        # Start with a copy of list_1.\n-        combined_list = list(list_1)\n-        last_insert_index = len(list_1)\n-        # Walk list_2 in reverse, inserting each element into combined_list if\n-        # it doesn't already exist.\n-        for path in reversed(list_2):\n-            try:\n-                # Does path already exist in the list?\n-                index = combined_list.index(path)\n-            except ValueError:\n-                # Add path to combined_list since it doesn't exist.\n-                combined_list.insert(last_insert_index, path)\n-            else:\n-                if index > last_insert_index:\n+        if not list_1:\n+            return list(list_2)\n+        if not list_2:\n+            return list(list_1)\n+        \n+        # Build dependency graphs from both lists\n+        deps_1 = {}\n+        deps_2 = {}\n+        all_items = set(list_1) | set(list_2)\n+        \n+        # Extract dependencies from list_1\n+        for i in range(len(list_1) - 1):\n+            item = list_1[i]\n+            if item not in deps_1:\n+                deps_1[item] = set()\n+            deps_1[item].add(list_1[i + 1])\n+        \n+        # Extract dependencies from list_2\n+        for i in range(len(list_2) - 1):\n+            item = list_2[i]\n+            if item not in deps_2:\n+                deps_2[item] = set()\n+            deps_2[item].add(list_2[i + 1])\n+        \n+        # Check for genuine conflicts (same items in opposite order)\n+        for item1 in all_items:\n+            for item2 in all_items:\n+                if item1 != item2:\n+                    # Check if item1 -> item2 in list_1 but item2 -> item1 in list_2\n+                    deps1_has_12 = item1 in deps_1 and item2 in deps_1[item1]\n+                    deps2_has_21 = item2 in deps_2 and item1 in deps_2[item2]\n+                    if deps1_has_12 and deps2_has_21:\n+                        warnings.warn(\n+                            'Detected duplicate Media files in an opposite order:\\n'\n+                            '%s\\n%s' % (item1, item2),\n+                            MediaOrderConflictWarning,\n+                        )\n+        \n+        # Merge dependencies, preferring list_1's ordering\n+        merged_deps = {}\n+        for item in all_items:\n+            merged_deps[item] = set()\n+            if item in deps_1:\n+                merged_deps[item].update(deps_1[item])\n+            if item in deps_2:\n+                merged_deps[item].update(deps_2[item])\n+        \n+        # Topological sort\n+        result = []\n+        in_degree = {item: 0 for item in all_items}\n+        \n+        # Calculate in-degrees\n+        for item in all_items:\n+            for dep in merged_deps[item]:\n+                in_degree[dep] += 1\n+        \n+        # Queue items with no dependencies, maintaining original order preference\n+        queue = []\n+        for item in list_1 + [x for x in list_2 if x not in list_1]:\n+            if in_degree[item] == 0:\n+                queue.append(item)\n+        \n+        while queue:\n+            current = queue.pop(0)\n+            result.append(current)\n+            \n+            # Process dependencies in stable order\n+            deps_to_process = sorted(merged_deps[current])\n+            for dep in deps_to_process:\n+                in_degree[dep] -= 1\n+                if in_degree[dep] == 0:\n+                    queue.append(dep)\n+        \n+        return result\n+        \n+        for item in all_items:\n+            dependencies[item] = set()\n+        \n+        # Add dependencies from list_1\n+        for i, item in enumerate(list_1):\n+            for j in range(i + 1, len(list_1)):\n+                dependencies[list_1[j]].add(item)\n+        \n+        # Add dependencies from list_2 and check for conflicts\n+        for i, item in enumerate(list_2):\n+            for j in range(i + 1, len(list_2)):\n+                dependent = list_2[j]\n+                if item in dependencies[dependent]:\n+                    # This is fine, same dependency in both lists\n+                    continue\n+                elif dependent in dependencies[item]:\n+                    # Conflict: opposite dependency order\n                     warnings.warn(\n                         'Detected duplicate Media files in an opposite order:\\n'\n-                        '%s\\n%s' % (combined_list[last_insert_index], combined_list[index]),\n+                        '%s\\n%s' % (item, dependent),\n                         MediaOrderConflictWarning,\n                     )\n+                else:\n+                    # New dependency from list_2\n+                    dependencies[dependent].add(item)\n+        \n+        # Topological sort\n+        result = []\n+        remaining = set(all_items)\n+        \n+        while remaining:\n+            # Find items with no remaining dependencies\n+            ready = [item for item in remaining \n+                    if not (dependencies[item] & remaining)]\n+            \n+            if not ready:\n+                # Circular dependency - fallback to original order preference\n+                ready = [next(iter(remaining))]\n+            \n+            # Sort ready items to maintain stable order\n+            ready.sort(key=lambda x: (\n+                list_1.index(x) if x in list_1 else len(list_1),\n+                list_2.index(x) if x in list_2 else len(list_2)\n+            ))\n+            \n+            result.append(ready[0])\n+            remaining.remove(ready[0])\n+        \n+        return result\n+        \"\"\"\n+        # Convert lists to preserve order information\n+        if not list_1:\n+            return list(list_2)\n+        if not list_2:\n+            return list(list_1)\n+\n+        # Build a dependency graph based on relative ordering in each list\n+        dependencies = {}  # item -> set of items that must come before it\n+        all_items = set(list_1) | set(list_2)\n+        \n+        for item in all_items:\n+            dependencies[item] = set()\n+        \n+        # Add dependencies from list_1\n+        for i, item in enumerate(list_1):\n+            for prev_item in list_1[:i]:\n+                dependencies[item].add(prev_item)\n+        \n+        # Add dependencies from list_2, checking for conflicts\n+        for i, item in enumerate(list_2):\n+            for prev_item in list_2[:i]:\n+                # Check if this creates a conflict with existing dependencies\n+                if item in dependencies and prev_item not in dependencies[item]:\n+                    # Check if we have a reverse dependency (conflict)\n+                    if prev_item in dependencies and item in dependencies[prev_item]:\n+                        warnings.warn(\n+                            'Detected duplicate Media files in an opposite order:\\n'\n+                            '%s\\n%s' % (prev_item, item),\n+                            MediaOrderConflictWarning,\n+                        )\n+                dependencies[item].add(prev_item)\n+        \n+        # Topological sort to resolve final order\n+        result = []\n+        remaining = set(all_items)\n+        \n+        while remaining:\n+            # Find items with no remaining dependencies\n+            ready = {item for item in remaining \n+                    if not (dependencies[item] & remaining)}\n+            \n+            if not ready:\n+                # Circular dependency - break it and warn\n+                # Choose the item that appears first in either original list\n+                for item in list_1 + list_2:\n+                    if item in remaining:\n+                        ready = {item}\n+                        break\n+            \n+            # Sort ready items to maintain stable output\n+            # Prefer order from list_1, then list_2\n+            ready_list = []\n+            for lst in [list_1, list_2]:\n+                for item in lst:\n+                    if item in ready and item not in ready_list:\n+                        ready_list.append(item)\n+            \n+            result.extend(ready_list)\n+            remaining -= set(ready_list)\n+        \n+        return result\n                 # path already exists in the list. Update last_insert_index so\n                 # that the following elements are inserted in front of this one.\n                 last_insert_index = index\n         return combined_list\n \n+\n     def __add__(self, other):\n         combined = Media()\n+        # Store original media lists to support global dependency resolution\n         combined._css_lists = self._css_lists + other._css_lists\n         combined._js_lists = self._js_lists + other._js_lists\n         return combined\n",
    "variant_4": "diff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex 02aa32b207..d0b624b6ae 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -68,13 +68,19 @@ class Media:\n             }\n         return css\n \n+    @property\n+\n     @property\n     def _js(self):\n-        js = self._js_lists[0]\n-        # filter(None, ...) avoids calling merge() with empty lists.\n-        for obj in filter(None, self._js_lists[1:]):\n-            js = self.merge(js, obj)\n-        return js\n+        # Collect all JS lists without intermediate merging\n+        all_js_lists = [js_list for js_list in self._js_lists if js_list]\n+        if not all_js_lists:\n+            return []\n+        if len(all_js_lists) == 1:\n+            return all_js_lists[0]\n+        \n+        # Perform global merge of all lists at once\n+        return self.merge_all(all_js_lists)\n \n     def render(self):\n         return mark_safe('\\n'.join(chain.from_iterable(getattr(self, 'render_' + name)() for name in MEDIA_TYPES)))\n@@ -114,6 +120,8 @@ class Media:\n             return Media(**{str(name): getattr(self, '_' + name)})\n         raise KeyError('Unknown media type \"%s\"' % name)\n \n+    @staticmethod\n+\n     @staticmethod\n     def merge(list_1, list_2):\n         \"\"\"\n@@ -125,34 +133,194 @@ class Media:\n         in a certain order. In JavaScript you may not be able to reference a\n         global or in CSS you might want to override a style.\n         \"\"\"\n-        # Start with a copy of list_1.\n-        combined_list = list(list_1)\n-        last_insert_index = len(list_1)\n-        # Walk list_2 in reverse, inserting each element into combined_list if\n-        # it doesn't already exist.\n-        for path in reversed(list_2):\n-            try:\n-                # Does path already exist in the list?\n-                index = combined_list.index(path)\n-            except ValueError:\n-                # Add path to combined_list since it doesn't exist.\n-                combined_list.insert(last_insert_index, path)\n-            else:\n-                if index > last_insert_index:\n+        if not list_1:\n+            return list(list_2)\n+        if not list_2:\n+            return list(list_1)\n+        \n+        # Build dependency graphs from both lists\n+        deps_1 = {}\n+        deps_2 = {}\n+        all_items = set(list_1) | set(list_2)\n+        \n+        # Extract dependencies from list_1\n+        for i, item in enumerate(list_1):\n+            deps_1[item] = set(list_1[:i])\n+        \n+        # Extract dependencies from list_2  \n+        for i, item in enumerate(list_2):\n+            deps_2[item] = set(list_2[:i])\n+        \n+        # Check for genuine conflicts (same items with contradictory ordering)\n+        for item in all_items:\n+            deps1 = deps_1.get(item, set())\n+            deps2 = deps_2.get(item, set())\n+            common_deps = deps1 & deps2\n+            \n+            # Check if any common dependency has conflicting order\n+            for dep in common_deps:\n+                if (dep in deps1 and item in deps_2.get(dep, set())) or \\\n+                   (dep in deps2 and item in deps_1.get(dep, set())):\n                     warnings.warn(\n                         'Detected duplicate Media files in an opposite order:\\n'\n-                        '%s\\n%s' % (combined_list[last_insert_index], combined_list[index]),\n+                        '%s\\n%s' % (dep, item),\n                         MediaOrderConflictWarning,\n                     )\n+        \n+        # Merge dependencies (union for items present in both lists)\n+        merged_deps = {}\n+        for item in all_items:\n+            merged_deps[item] = deps_1.get(item, set()) | deps_2.get(item, set())\n+        \n+        # Topological sort\n+        result = []\n+        temp_mark = set()\n+        perm_mark = set()\n+        \n+        def visit(item):\n+            if item in temp_mark:\n+                return  # Cycle detected, skip\n+            if item in perm_mark:\n+                return\n+            \n+            temp_mark.add(item)\n+            for dep in merged_deps.get(item, set()):\n+                if dep in all_items:\n+                    visit(dep)\n+            temp_mark.remove(item)\n+            perm_mark.add(item)\n+            result.append(item)\n+        \n+        # Visit items in order they appear in the original lists to maintain stability\n+        for item in list_1 + [x for x in list_2 if x not in list_1]:\n+            if item not in perm_mark:\n+                visit(item)\n+        \n+        return result\n+        \n+        for item in all_items:\n+            dependencies[item] = set()\n+        \n+        # Add dependencies from list_1\n+        for i in range(len(list_1) - 1):\n+            dependencies[list_1[i + 1]].add(list_1[i])\n+        \n+        # Add dependencies from list_2\n+        for i in range(len(list_2) - 1):\n+            dependencies[list_2[i + 1]].add(list_2[i])\n+        \n+        # Topological sort using Kahn's algorithm\n+        in_degree = {item: len(deps) for item, deps in dependencies.items()}\n+        queue = [item for item, degree in in_degree.items() if degree == 0]\n+        result = []\n+        \n+        while queue:\n+            # Sort queue to ensure deterministic output\n+            queue.sort()\n+            current = queue.pop(0)\n+            result.append(current)\n+            \n+            # Update in-degrees of dependent items\n+            for item, deps in dependencies.items():\n+                if current in deps:\n+                    in_degree[item] -= 1\n+                    if in_degree[item] == 0:\n+                        queue.append(item)\n+        \n+        # Check for cycles (genuine conflicts)\n+        if len(result) != len(all_items):\n+            remaining = all_items - set(result)\n+            conflicts = []\n+            for item in remaining:\n+                item_pos_1 = list_1.index(item) if item in list_1 else -1\n+                item_pos_2 = list_2.index(item) if item in list_2 else -1\n+                if item_pos_1 >= 0 and item_pos_2 >= 0:\n+                    conflicts.append(item)\n+            \n+            if conflicts:\n+                warnings.warn(\n+                    'Detected genuine Media file ordering conflicts: %s' % ', '.join(conflicts),\n+                    MediaOrderConflictWarning,\n+                )\n+            \n+            # Add remaining items in original order from list_1, then list_2\n+            for item in list_1:\n+                if item in remaining and item not in result:\n+                    result.append(item)\n+            for item in list_2:\n+                if item in remaining and item not in result:\n+                    result.append(item)\n+        \n+        return result\n+            return list_1[:]\n+        \n+        # Build a dependency graph from both lists\n+        dependencies = {}  # item -> set of items that must come before it\n+        all_items = set(list_1 + list_2)\n+        \n+        # Initialize all items with empty dependency sets\n+        for item in all_items:\n+            dependencies[item] = set()\n+        \n+        # Add dependencies from list_1\n+        for i in range(len(list_1) - 1):\n+            dependencies[list_1[i + 1]].add(list_1[i])\n+        \n+        # Add dependencies from list_2, checking for conflicts\n+        for i in range(len(list_2) - 1):\n+            curr_item = list_2[i + 1]\n+            prev_item = list_2[i]\n+            \n+            # Check if this would create a cycle (genuine conflict)\n+            if prev_item in dependencies and curr_item in dependencies[prev_item]:\n+                # Find the conflicting positions in original lists\n+                pos1_curr = list_1.index(curr_item) if curr_item in list_1 else -1\n+                pos1_prev = list_1.index(prev_item) if prev_item in list_1 else -1\n+                \n+                if pos1_curr != -1 and pos1_prev != -1 and pos1_curr < pos1_prev:\n+                    warnings.warn(\n+                        'Detected duplicate Media files in an opposite order:\\n'\n+                        '%s\\n%s' % (prev_item, curr_item),\n+                        MediaOrderConflictWarning,\n+                    )\n+            \n+            dependencies[curr_item].add(prev_item)\n+        \n+        # Topological sort using Kahn's algorithm\n+        result = []\n+        in_degree = {item: len(dependencies[item]) for item in all_items}\n+        queue = [item for item in all_items if in_degree[item] == 0]\n+        \n+        # Process items in a stable order (prefer list_1 order, then list_2 order)\n+        def sort_key(item):\n+            pos1 = list_1.index(item) if item in list_1 else len(list_1)\n+            pos2 = list_2.index(item) if item in list_2 else len(list_2)\n+            return (pos1, pos2)\n+        \n+        while queue:\n+            queue.sort(key=sort_key)\n+            current = queue.pop(0)\n+            result.append(current)\n+            \n+            # Update in-degrees for items that depend on current\n+            for item in all_items:\n+                if current in dependencies[item]:\n+                    in_degree[item] -= 1\n+                    if in_degree[item] == 0:\n+                        queue.append(item)\n+        \n+        return result\n                 # path already exists in the list. Update last_insert_index so\n                 # that the following elements are inserted in front of this one.\n                 last_insert_index = index\n         return combined_list\n \n+\n     def __add__(self, other):\n         combined = Media()\n-        combined._css_lists = self._css_lists + other._css_lists\n-        combined._js_lists = self._js_lists + other._js_lists\n+        # Store original lists to preserve dependency information\n+        combined._css_lists = list(self._css_lists) + list(other._css_lists)\n+        combined._js_lists = list(self._js_lists) + list(other._js_lists)\n         return combined\n \n \n",
    "variant_5": "diff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex 02aa32b207..c70479b9f3 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -68,13 +68,19 @@ class Media:\n             }\n         return css\n \n+    @property\n+\n     @property\n     def _js(self):\n-        js = self._js_lists[0]\n-        # filter(None, ...) avoids calling merge() with empty lists.\n-        for obj in filter(None, self._js_lists[1:]):\n-            js = self.merge(js, obj)\n-        return js\n+        # Collect all JS lists to merge globally instead of sequentially\n+        all_js_lists = [js_list for js_list in self._js_lists if js_list]\n+        if not all_js_lists:\n+            return []\n+        elif len(all_js_lists) == 1:\n+            return all_js_lists[0]\n+        else:\n+            # Perform global merge of all lists at once\n+            return self.merge_all(all_js_lists)\n \n     def render(self):\n         return mark_safe('\\n'.join(chain.from_iterable(getattr(self, 'render_' + name)() for name in MEDIA_TYPES)))\n@@ -114,6 +120,8 @@ class Media:\n             return Media(**{str(name): getattr(self, '_' + name)})\n         raise KeyError('Unknown media type \"%s\"' % name)\n \n+    @staticmethod\n+\n     @staticmethod\n     def merge(list_1, list_2):\n         \"\"\"\n@@ -125,32 +133,218 @@ class Media:\n         in a certain order. In JavaScript you may not be able to reference a\n         global or in CSS you might want to override a style.\n         \"\"\"\n-        # Start with a copy of list_1.\n-        combined_list = list(list_1)\n-        last_insert_index = len(list_1)\n-        # Walk list_2 in reverse, inserting each element into combined_list if\n-        # it doesn't already exist.\n-        for path in reversed(list_2):\n-            try:\n-                # Does path already exist in the list?\n-                index = combined_list.index(path)\n-            except ValueError:\n-                # Add path to combined_list since it doesn't exist.\n-                combined_list.insert(last_insert_index, path)\n-            else:\n-                if index > last_insert_index:\n+        if not list_1:\n+            return list(list_2)\n+        if not list_2:\n+            return list(list_1)\n+        \n+        # Build a dependency graph based on relative ordering in both lists\n+        dependencies = {}\n+        all_items = set(list_1) | set(list_2)\n+        \n+        for item in all_items:\n+            dependencies[item] = set()\n+        \n+        # Add dependencies from list_1\n+        for i, item in enumerate(list_1):\n+            for j in range(i + 1, len(list_1)):\n+                dependencies[list_1[j]].add(item)\n+        \n+        # Add dependencies from list_2, checking for conflicts\n+        for i, item in enumerate(list_2):\n+            for j in range(i + 1, len(list_2)):\n+                dependent = list_2[j]\n+                # Check for genuine conflict (opposite ordering in both lists)\n+                if item in dependencies[dependent]:\n+                    # This is a real conflict - same items in opposite order\n                     warnings.warn(\n                         'Detected duplicate Media files in an opposite order:\\n'\n-                        '%s\\n%s' % (combined_list[last_insert_index], combined_list[index]),\n+                        '%s\\n%s' % (item, dependent),\n                         MediaOrderConflictWarning,\n                     )\n+                else:\n+                    dependencies[dependent].add(item)\n+        \n+        # Topological sort using Kahn's algorithm\n+        result = []\n+        in_degree = {item: len(dependencies[item]) for item in all_items}\n+        queue = [item for item in all_items if in_degree[item] == 0]\n+        \n+        # Sort queue to maintain consistent ordering\n+        queue.sort(key=lambda x: (list_1.index(x) if x in list_1 else len(list_1),\n+                                  list_2.index(x) if x in list_2 else len(list_2)))\n+        \n+        while queue:\n+            current = queue.pop(0)\n+            result.append(current)\n+            \n+            # Update in-degrees and add newly available items\n+            for item in all_items:\n+                if current in dependencies[item]:\n+                    in_degree[item] -= 1\n+                    if in_degree[item] == 0:\n+                        queue.append(item)\n+            \n+            # Keep queue sorted for consistent results\n+            queue.sort(key=lambda x: (list_1.index(x) if x in list_1 else len(list_1),\n+                                      list_2.index(x) if x in list_2 else len(list_2)))\n+        \n+        return result\n+        \n+        # Initialize dependencies\n+        for item in all_items:\n+            dependencies[item] = set()\n+        \n+        # Add dependencies from list_1\n+        for i, item in enumerate(list_1):\n+            for j in range(i + 1, len(list_1)):\n+                dependencies[list_1[j]].add(item)\n+        \n+        # Add dependencies from list_2, checking for conflicts\n+        for i, item in enumerate(list_2):\n+            for j in range(i + 1, len(list_2)):\n+                dependent = list_2[j]\n+                if item in dependencies[dependent]:\n+                    # This would create a cycle - genuine conflict\n+                    if item in list_1 and dependent in list_1:\n+                        idx1 = list_1.index(item)\n+                        idx2 = list_1.index(dependent)\n+                        if idx1 > idx2:  # Different order in original lists\n+                            warnings.warn(\n+                                'Detected duplicate Media files in an opposite order:\\n'\n+                                '%s\\n%s' % (item, dependent),\n+                                MediaOrderConflictWarning,\n+                            )\n+                else:\n+                    dependencies[dependent].add(item)\n+        \n+        # Topological sort using Kahn's algorithm\n+        result = []\n+        in_degree = {item: len(deps) for item, deps in dependencies.items()}\n+        queue = [item for item in all_items if in_degree[item] == 0]\n+        \n+        # Sort queue to maintain deterministic output\n+        queue.sort()\n+        \n+        while queue:\n+            current = queue.pop(0)\n+            result.append(current)\n+            \n+            # Remove current from all dependency sets and update in_degrees\n+            for item in all_items:\n+                if current in dependencies[item]:\n+                    dependencies[item].remove(current)\n+                    in_degree[item] -= 1\n+                    if in_degree[item] == 0:\n+                        queue.append(item)\n+            \n+            # Keep queue sorted for deterministic results\n+            queue.sort()\n+        \n+        return result\n+        # Build a dependency graph from both lists\n+        dependencies = {}\n+        all_items = set()\n+        \n+        # Process list_1 to establish ordering constraints\n+        for i, item in enumerate(list_1):\n+            all_items.add(item)\n+            if item not in dependencies:\n+                dependencies[item] = set()\n+            # Each item depends on all items that come before it in list_1\n+            for j in range(i):\n+                dependencies[item].add(list_1[j])\n+        \n+        # Process list_2 to establish ordering constraints\n+        for i, item in enumerate(list_2):\n+            all_items.add(item)\n+            if item not in dependencies:\n+                dependencies[item] = set()\n+            # Each item depends on all items that come before it in list_2\n+            for j in range(i):\n+                dependencies[item].add(list_2[j])\n+        \n+        # Check for genuine conflicts (cycles in the dependency graph)\n+        def has_cycle():\n+            visited = set()\n+            rec_stack = set()\n+            \n+            def dfs(node):\n+                if node in rec_stack:\n+                    return True\n+                if node in visited:\n+                    return False\n+                \n+                visited.add(node)\n+                rec_stack.add(node)\n+                \n+                for neighbor in dependencies.get(node, []):\n+                    if neighbor in all_items and dfs(neighbor):\n+                        return True\n+                \n+                rec_stack.remove(node)\n+                return False\n+            \n+            for item in all_items:\n+                if item not in visited and dfs(item):\n+                    return True\n+            return False\n+        \n+        if has_cycle():\n+            # Find conflicting items for warning\n+            common_items = set(list_1) & set(list_2)\n+            for item in common_items:\n+                idx1 = list_1.index(item) if item in list_1 else -1\n+                idx2 = list_2.index(item) if item in list_2 else -1\n+                if idx1 >= 0 and idx2 >= 0:\n+                    # Check relative ordering with other common items\n+                    for other in common_items:\n+                        if other != item:\n+                            other_idx1 = list_1.index(other) if other in list_1 else -1\n+                            other_idx2 = list_2.index(other) if other in list_2 else -1\n+                            if (other_idx1 >= 0 and other_idx2 >= 0 and \n+                                (idx1 < other_idx1) != (idx2 < other_idx2)):\n+                                warnings.warn(\n+                                    'Detected duplicate Media files in an opposite order:\\n'\n+                                    '%s\\n%s' % (item, other),\n+                                    MediaOrderConflictWarning,\n+                                )\n+                                break\n+        \n+        # Topological sort to resolve dependencies\n+        result = []\n+        visited = set()\n+        temp_visited = set()\n+        \n+        def topological_sort(item):\n+            if item in temp_visited:\n+                return  # Cycle detected, skip\n+            if item in visited:\n+                return\n+            \n+            temp_visited.add(item)\n+            for dep in dependencies.get(item, []):\n+                if dep in all_items:\n+                    topological_sort(dep)\n+            temp_visited.remove(item)\n+            visited.add(item)\n+            result.append(item)\n+        \n+        # Sort items to ensure deterministic output\n+        for item in sorted(all_items):\n+            if item not in visited:\n+                topological_sort(item)\n+        \n+        return result\n                 # path already exists in the list. Update last_insert_index so\n                 # that the following elements are inserted in front of this one.\n                 last_insert_index = index\n         return combined_list\n \n+\n     def __add__(self, other):\n         combined = Media()\n+        # Store original media lists to enable global dependency resolution\n         combined._css_lists = self._css_lists + other._css_lists\n         combined._js_lists = self._js_lists + other._js_lists\n         return combined\n",
    "variant_6": "diff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex 02aa32b207..da4db873d0 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -68,13 +68,19 @@ class Media:\n             }\n         return css\n \n+    @property\n+\n     @property\n     def _js(self):\n-        js = self._js_lists[0]\n-        # filter(None, ...) avoids calling merge() with empty lists.\n-        for obj in filter(None, self._js_lists[1:]):\n-            js = self.merge(js, obj)\n-        return js\n+        # Collect all js lists for global merge instead of sequential pairwise merging\n+        all_js_lists = [js_list for js_list in self._js_lists if js_list]\n+        if not all_js_lists:\n+            return []\n+        if len(all_js_lists) == 1:\n+            return all_js_lists[0]\n+        \n+        # Perform global merge of all lists at once\n+        return self.merge_all(all_js_lists)\n \n     def render(self):\n         return mark_safe('\\n'.join(chain.from_iterable(getattr(self, 'render_' + name)() for name in MEDIA_TYPES)))\n@@ -114,6 +120,8 @@ class Media:\n             return Media(**{str(name): getattr(self, '_' + name)})\n         raise KeyError('Unknown media type \"%s\"' % name)\n \n+    @staticmethod\n+\n     @staticmethod\n     def merge(list_1, list_2):\n         \"\"\"\n@@ -125,30 +133,223 @@ class Media:\n         in a certain order. In JavaScript you may not be able to reference a\n         global or in CSS you might want to override a style.\n         \"\"\"\n-        # Start with a copy of list_1.\n-        combined_list = list(list_1)\n-        last_insert_index = len(list_1)\n-        # Walk list_2 in reverse, inserting each element into combined_list if\n-        # it doesn't already exist.\n-        for path in reversed(list_2):\n-            try:\n-                # Does path already exist in the list?\n-                index = combined_list.index(path)\n-            except ValueError:\n-                # Add path to combined_list since it doesn't exist.\n-                combined_list.insert(last_insert_index, path)\n-            else:\n-                if index > last_insert_index:\n+        if not list_1:\n+            return list(list_2)\n+        if not list_2:\n+            return list(list_1)\n+        \n+        # Build a dependency graph based on relative ordering in both lists\n+        dependencies = {}  # item -> set of items that must come before it\n+        all_items = set(list_1) | set(list_2)\n+        \n+        for item in all_items:\n+            dependencies[item] = set()\n+        \n+        # Extract dependencies from list_1\n+        for i, item in enumerate(list_1):\n+            for j in range(i):\n+                dependencies[item].add(list_1[j])\n+        \n+        # Extract dependencies from list_2 and check for conflicts\n+        for i, item in enumerate(list_2):\n+            for j in range(i):\n+                predecessor = list_2[j]\n+                if predecessor in dependencies[item]:\n+                    continue  # Consistent ordering\n+                elif item in dependencies[predecessor]:\n+                    # Conflict detected - same items in opposite order\n                     warnings.warn(\n                         'Detected duplicate Media files in an opposite order:\\n'\n-                        '%s\\n%s' % (combined_list[last_insert_index], combined_list[index]),\n+                        '%s\\n%s' % (predecessor, item),\n                         MediaOrderConflictWarning,\n                     )\n+                else:\n+                    # Add new dependency\n+                    dependencies[item].add(predecessor)\n+        \n+        # Topological sort using Kahn's algorithm\n+        result = []\n+        in_degree = {item: len(deps) for item, deps in dependencies.items()}\n+        queue = [item for item in all_items if in_degree[item] == 0]\n+        \n+        while queue:\n+            # Sort queue to ensure deterministic output\n+            queue.sort()\n+            current = queue.pop(0)\n+            result.append(current)\n+            \n+            # Update in-degrees for items that depend on current\n+            for item in all_items:\n+                if current in dependencies[item]:\n+                    in_degree[item] -= 1\n+                    if in_degree[item] == 0:\n+                        queue.append(item)\n+        \n+        return result\n+                all_items.append(item)\n+            # Add dependencies from previous items in this list\n+            for prev_item in list_1[:i]:\n+                dependencies[item].add(prev_item)\n+        \n+        # Process list_2 to establish ordering dependencies\n+        for i, item in enumerate(list_2):\n+            if item not in dependencies:\n+                dependencies[item] = set()\n+                all_items.append(item)\n+            # Add dependencies from previous items in this list\n+            for prev_item in list_2[:i]:\n+                dependencies[item].add(prev_item)\n+        \n+        # Check for genuine conflicts (same items in different relative order)\n+        conflicts = []\n+        for item1 in all_items:\n+            for item2 in all_items:\n+                if item1 != item2:\n+                    # Check if item1 comes before item2 in one list but after in another\n+                    in_list1_before = False\n+                    in_list1_after = False\n+                    in_list2_before = False\n+                    in_list2_after = False\n+                    \n+                    try:\n+                        idx1_list1 = list_1.index(item1)\n+                        idx2_list1 = list_1.index(item2)\n+                        in_list1_before = idx1_list1 < idx2_list1\n+                        in_list1_after = idx1_list1 > idx2_list1\n+                    except ValueError:\n+                        pass\n+                    \n+                    try:\n+                        idx1_list2 = list_2.index(item1)\n+                        idx2_list2 = list_2.index(item2)\n+                        in_list2_before = idx1_list2 < idx2_list2\n+                        in_list2_after = idx1_list2 > idx2_list2\n+                    except ValueError:\n+                        pass\n+                    \n+                    if (in_list1_before and in_list2_after) or (in_list1_after and in_list2_before):\n+                        conflicts.append((item1, item2))\n+        \n+        # Warn about genuine conflicts\n+        for item1, item2 in conflicts:\n+            warnings.warn(\n+                'Detected duplicate Media files in an opposite order:\\n'\n+                '%s\\n%s' % (item1, item2),\n+                MediaOrderConflictWarning,\n+            )\n+        \n+        # Topological sort to resolve dependencies\n+        result = []\n+        remaining = set(all_items)\n+        \n+        while remaining:\n+            # Find items with no unresolved dependencies\n+            ready = []\n+            for item in remaining:\n+                if not (dependencies[item] & remaining):\n+                    ready.append(item)\n+            \n+            if not ready:\n+                # Circular dependency or conflict - fall back to original order\n+                ready = [next(iter(remaining))]\n+            \n+            # Sort ready items by their first appearance to maintain stability\n+            ready.sort(key=lambda x: next((i for i, item in enumerate(all_items) if item == x), len(all_items)))\n+            \n+            # Add the first ready item\n+            next_item = ready[0]\n+            result.append(next_item)\n+            remaining.remove(next_item)\n+        \n+        return result\n+        Would result in ['a', 'b', 'c', 'd', 'e']\n+        \"\"\"\n+        # Convert to lists if not already\n+        if not isinstance(list_1, list):\n+            list_1 = list(list_1)\n+        if not isinstance(list_2, list):\n+            list_2 = list(list_2)\n+            \n+        # Build a dependency graph\n+        dependencies = {}\n+        all_items = set(list_1 + list_2)\n+        \n+        # Initialize dependencies\n+        for item in all_items:\n+            dependencies[item] = set()\n+        \n+        # Add dependencies from list_1\n+        for i in range(len(list_1) - 1):\n+            dependencies[list_1[i + 1]].add(list_1[i])\n+        \n+        # Add dependencies from list_2\n+        for i in range(len(list_2) - 1):\n+            dependencies[list_2[i + 1]].add(list_2[i])\n+        \n+        # Check for conflicts (cycles in dependency graph)\n+        def has_path(start, end, visited=None):\n+            if visited is None:\n+                visited = set()\n+            if start == end:\n+                return True\n+            if start in visited:\n+                return False\n+            visited.add(start)\n+            for dep in dependencies.get(start, set()):\n+                if has_path(dep, end, visited):\n+                    return True\n+            return False\n+        \n+        # Find conflicting pairs and warn\n+        conflicting_pairs = []\n+        for item1 in all_items:\n+            for item2 in all_items:\n+                if item1 != item2 and has_path(item1, item2) and has_path(item2, item1):\n+                    pair = tuple(sorted([item1, item2]))\n+                    if pair not in conflicting_pairs:\n+                        conflicting_pairs.append(pair)\n+        \n+        for item1, item2 in conflicting_pairs:\n+            warnings.warn(\n+                'Detected duplicate Media files in an opposite order:\\n'\n+                '%s\\n%s' % (item1, item2),\n+                MediaOrderConflictWarning,\n+            )\n+        \n+        # Topological sort\n+        result = []\n+        in_degree = {item: len(dependencies[item]) for item in all_items}\n+        queue = [item for item in all_items if in_degree[item] == 0]\n+        \n+        # Preserve original order preference when possible\n+        def sort_key(item):\n+            try:\n+                return list_1.index(item)\n+            except ValueError:\n+                try:\n+                    return len(list_1) + list_2.index(item)\n+                except ValueError:\n+                    return len(list_1) + len(list_2)\n+        \n+        while queue:\n+            queue.sort(key=sort_key)\n+            current = queue.pop(0)\n+            result.append(current)\n+            \n+            # Update in-degrees\n+            for item in all_items:\n+                if current in dependencies[item]:\n+                    in_degree[item] -= 1\n+                    if in_degree[item] == 0:\n+                        queue.append(item)\n+        \n+        return result\n                 # path already exists in the list. Update last_insert_index so\n                 # that the following elements are inserted in front of this one.\n                 last_insert_index = index\n         return combined_list\n \n+\n     def __add__(self, other):\n         combined = Media()\n         combined._css_lists = self._css_lists + other._css_lists\n",
    "variant_7": "diff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex 02aa32b207..e15c53b4e0 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -68,13 +68,19 @@ class Media:\n             }\n         return css\n \n+    @property\n+\n     @property\n     def _js(self):\n-        js = self._js_lists[0]\n-        # filter(None, ...) avoids calling merge() with empty lists.\n-        for obj in filter(None, self._js_lists[1:]):\n-            js = self.merge(js, obj)\n-        return js\n+        # Collect all JS lists for global merge instead of sequential pairwise merging\n+        all_js_lists = [js_list for js_list in self._js_lists if js_list]\n+        if not all_js_lists:\n+            return []\n+        if len(all_js_lists) == 1:\n+            return all_js_lists[0]\n+        \n+        # Perform global merge of all lists at once to avoid false intermediate constraints\n+        return self._global_merge(all_js_lists)\n \n     def render(self):\n         return mark_safe('\\n'.join(chain.from_iterable(getattr(self, 'render_' + name)() for name in MEDIA_TYPES)))\n@@ -114,6 +120,8 @@ class Media:\n             return Media(**{str(name): getattr(self, '_' + name)})\n         raise KeyError('Unknown media type \"%s\"' % name)\n \n+    @staticmethod\n+\n     @staticmethod\n     def merge(list_1, list_2):\n         \"\"\"\n@@ -125,32 +133,205 @@ class Media:\n         in a certain order. In JavaScript you may not be able to reference a\n         global or in CSS you might want to override a style.\n         \"\"\"\n-        # Start with a copy of list_1.\n-        combined_list = list(list_1)\n-        last_insert_index = len(list_1)\n-        # Walk list_2 in reverse, inserting each element into combined_list if\n-        # it doesn't already exist.\n-        for path in reversed(list_2):\n-            try:\n-                # Does path already exist in the list?\n-                index = combined_list.index(path)\n-            except ValueError:\n-                # Add path to combined_list since it doesn't exist.\n-                combined_list.insert(last_insert_index, path)\n-            else:\n-                if index > last_insert_index:\n+        if not list_1:\n+            return list(list_2)\n+        if not list_2:\n+            return list(list_1)\n+        \n+        # Build dependency graph from both lists\n+        dependencies = {}  # item -> set of items that must come before it\n+        all_items = set(list_1) | set(list_2)\n+        \n+        for item in all_items:\n+            dependencies[item] = set()\n+        \n+        # Add dependencies from list_1\n+        for i in range(len(list_1)):\n+            for j in range(i + 1, len(list_1)):\n+                dependencies[list_1[j]].add(list_1[i])\n+        \n+        # Add dependencies from list_2, checking for conflicts\n+        for i in range(len(list_2)):\n+            for j in range(i + 1, len(list_2)):\n+                # Check if this creates a conflict with existing dependencies\n+                if list_2[i] in dependencies[list_2[j]]:\n+                    warnings.warn(\n+                        'Detected duplicate Media files in an opposite order:\\n'\n+                        '%s\\n%s' % (list_2[j], list_2[i]),\n+                        MediaOrderConflictWarning,\n+                    )\n+                else:\n+                    dependencies[list_2[j]].add(list_2[i])\n+        \n+        # Topological sort\n+        result = []\n+        in_degree = {item: len(deps) for item, deps in dependencies.items()}\n+        queue = [item for item in all_items if in_degree[item] == 0]\n+        \n+        # Sort queue to ensure deterministic output\n+        queue.sort()\n+        \n+        while queue:\n+            # Remove item with no dependencies\n+            current = queue.pop(0)\n+            result.append(current)\n+            \n+            # Update dependencies\n+            for item in all_items:\n+                if current in dependencies[item]:\n+                    dependencies[item].remove(current)\n+                    in_degree[item] -= 1\n+                    if in_degree[item] == 0:\n+                        queue.append(item)\n+                        queue.sort()  # Keep deterministic order\n+        \n+        return result\n+        \n+        # Add dependencies from list_1\n+        for i, item in enumerate(list_1):\n+            for j in range(i + 1, len(list_1)):\n+                dependencies[list_1[j]].add(item)\n+        \n+        # Add dependencies from list_2, checking for conflicts\n+        for i, item in enumerate(list_2):\n+            for j in range(i + 1, len(list_2)):\n+                next_item = list_2[j]\n+                # Check if this creates a conflict with list_1 ordering\n+                if (item in list_1 and next_item in list_1 and \n+                    list_1.index(item) > list_1.index(next_item)):\n                     warnings.warn(\n                         'Detected duplicate Media files in an opposite order:\\n'\n-                        '%s\\n%s' % (combined_list[last_insert_index], combined_list[index]),\n+                        '%s\\n%s' % (item, next_item),\n                         MediaOrderConflictWarning,\n                     )\n+                dependencies[next_item].add(item)\n+        \n+        # Topological sort to resolve dependencies\n+        result = []\n+        remaining = set(all_items)\n+        \n+        while remaining:\n+            # Find items with no remaining dependencies\n+            ready = [item for item in remaining \n+                    if not (dependencies[item] & remaining)]\n+            \n+            if not ready:\n+                # Cycle detected - fallback to original behavior\n+                ready = [remaining.pop()]\n+            \n+            # Sort ready items to maintain stable ordering\n+            ready.sort(key=lambda x: (\n+                list_1.index(x) if x in list_1 else float('inf'),\n+                list_2.index(x) if x in list_2 else float('inf')\n+            ))\n+            \n+            for item in ready:\n+                if item in remaining:\n+                    result.append(item)\n+                    remaining.remove(item)\n+        \n+        return result\n+\n+        This method uses a topological sort approach to handle complex dependency\n+        chains without creating false ordering constraints.\n+        \"\"\"\n+        if not list_1:\n+            return list(list_2)\n+        if not list_2:\n+            return list(list_1)\n+\n+        # Build a dependency graph\n+        dependencies = {}  # item -> set of items that must come before it\n+        all_items = set(list_1 + list_2)\n+        \n+        for item in all_items:\n+            dependencies[item] = set()\n+\n+        # Add dependencies from list_1\n+        for i in range(len(list_1) - 1):\n+            dependencies[list_1[i + 1]].add(list_1[i])\n+\n+        # Add dependencies from list_2\n+        for i in range(len(list_2) - 1):\n+            dependencies[list_2[i + 1]].add(list_2[i])\n+\n+        # Check for genuine conflicts (cycles in dependency graph)\n+        def has_cycle():\n+            visited = set()\n+            rec_stack = set()\n+            \n+            def dfs(node):\n+                visited.add(node)\n+                rec_stack.add(node)\n+                \n+                for neighbor in dependencies[node]:\n+                    if neighbor not in visited:\n+                        if dfs(neighbor):\n+                            return True\n+                    elif neighbor in rec_stack:\n+                        return True\n+                \n+                rec_stack.remove(node)\n+                return False\n+            \n+            for item in all_items:\n+                if item not in visited:\n+                    if dfs(item):\n+                        return True\n+            return False\n+\n+        # Warn about genuine conflicts\n+        if has_cycle():\n+            # Find conflicting items by checking original list positions\n+            conflicts = []\n+            for item in all_items:\n+                pos_1 = list_1.index(item) if item in list_1 else -1\n+                pos_2 = list_2.index(item) if item in list_2 else -1\n+                if pos_1 >= 0 and pos_2 >= 0:\n+                    for other_item in all_items:\n+                        if item != other_item:\n+                            other_pos_1 = list_1.index(other_item) if other_item in list_1 else -1\n+                            other_pos_2 = list_2.index(other_item) if other_item in list_2 else -1\n+                            if (other_pos_1 >= 0 and other_pos_2 >= 0 and\n+                                (pos_1 < other_pos_1) != (pos_2 < other_pos_2)):\n+                                conflicts.append((item, other_item))\n+            \n+            if conflicts:\n+                warnings.warn(\n+                    'Detected duplicate Media files in an opposite order:\\n'\n+                    '%s\\n%s' % conflicts[0],\n+                    MediaOrderConflictWarning,\n+                )\n+\n+        # Perform topological sort\n+        result = []\n+        in_degree = {item: len(dependencies[item]) for item in all_items}\n+        queue = [item for item in all_items if in_degree[item] == 0]\n+\n+        while queue:\n+            # Sort queue to ensure deterministic output\n+            queue.sort()\n+            current = queue.pop(0)\n+            result.append(current)\n+\n+            # Update in-degrees of dependent items\n+            for item in all_items:\n+                if current in dependencies[item]:\n+                    dependencies[item].remove(current)\n+                    in_degree[item] -= 1\n+                    if in_degree[item] == 0:\n+                        queue.append(item)\n+\n+        return result\n                 # path already exists in the list. Update last_insert_index so\n                 # that the following elements are inserted in front of this one.\n                 last_insert_index = index\n         return combined_list\n \n+\n     def __add__(self, other):\n         combined = Media()\n+        # Store original media lists to preserve dependency information\n         combined._css_lists = self._css_lists + other._css_lists\n         combined._js_lists = self._js_lists + other._js_lists\n         return combined\n",
    "variant_8": "diff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex 02aa32b207..d6336e8d81 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -68,13 +68,22 @@ class Media:\n             }\n         return css\n \n+    @property\n+\n     @property\n     def _js(self):\n-        js = self._js_lists[0]\n-        # filter(None, ...) avoids calling merge() with empty lists.\n-        for obj in filter(None, self._js_lists[1:]):\n-            js = self.merge(js, obj)\n-        return js\n+        if len(self._js_lists) <= 1:\n+            return self._js_lists[0] if self._js_lists else []\n+        \n+        # Collect all non-empty JS lists for global merge\n+        js_lists = [js_list for js_list in self._js_lists if js_list]\n+        if not js_lists:\n+            return []\n+        if len(js_lists) == 1:\n+            return js_lists[0]\n+        \n+        # Perform global merge instead of sequential pairwise merging\n+        return self._global_merge(js_lists)\n \n     def render(self):\n         return mark_safe('\\n'.join(chain.from_iterable(getattr(self, 'render_' + name)() for name in MEDIA_TYPES)))\n@@ -114,6 +123,8 @@ class Media:\n             return Media(**{str(name): getattr(self, '_' + name)})\n         raise KeyError('Unknown media type \"%s\"' % name)\n \n+    @staticmethod\n+\n     @staticmethod\n     def merge(list_1, list_2):\n         \"\"\"\n@@ -125,32 +136,254 @@ class Media:\n         in a certain order. In JavaScript you may not be able to reference a\n         global or in CSS you might want to override a style.\n         \"\"\"\n-        # Start with a copy of list_1.\n-        combined_list = list(list_1)\n-        last_insert_index = len(list_1)\n-        # Walk list_2 in reverse, inserting each element into combined_list if\n-        # it doesn't already exist.\n-        for path in reversed(list_2):\n-            try:\n-                # Does path already exist in the list?\n-                index = combined_list.index(path)\n-            except ValueError:\n-                # Add path to combined_list since it doesn't exist.\n-                combined_list.insert(last_insert_index, path)\n+        if not list_1:\n+            return list(list_2)\n+        if not list_2:\n+            return list(list_1)\n+        \n+        # Build dependency graph from both lists\n+        dependencies = {}\n+        all_items = set(list_1) | set(list_2)\n+        \n+        # Initialize dependencies for all items\n+        for item in all_items:\n+            dependencies[item] = set()\n+        \n+        # Add dependencies from list_1\n+        for i in range(len(list_1) - 1):\n+            dependencies[list_1[i + 1]].add(list_1[i])\n+        \n+        # Add dependencies from list_2, checking for conflicts\n+        for i in range(len(list_2) - 1):\n+            current = list_2[i + 1]\n+            predecessor = list_2[i]\n+            \n+            # Check if this creates a conflict with existing dependencies\n+            if predecessor in dependencies[current]:\n+                continue  # Already have this dependency\n+            \n+            # Check for reverse dependency (conflict)\n+            if current in dependencies[predecessor]:\n+                warnings.warn(\n+                    'Detected duplicate Media files in an opposite order:\\n'\n+                    '%s\\n%s' % (predecessor, current),\n+                    MediaOrderConflictWarning,\n+                )\n             else:\n-                if index > last_insert_index:\n-                    warnings.warn(\n-                        'Detected duplicate Media files in an opposite order:\\n'\n-                        '%s\\n%s' % (combined_list[last_insert_index], combined_list[index]),\n-                        MediaOrderConflictWarning,\n-                    )\n+                dependencies[current].add(predecessor)\n+        \n+        # Topological sort using Kahn's algorithm\n+        in_degree = {item: len(dependencies[item]) for item in all_items}\n+        queue = [item for item in all_items if in_degree[item] == 0]\n+        result = []\n+        \n+        while queue:\n+            # Sort queue to ensure deterministic output\n+            queue.sort()\n+            current = queue.pop(0)\n+            result.append(current)\n+            \n+            # Update in-degrees for items that depend on current\n+            for item in all_items:\n+                if current in dependencies[item]:\n+                    in_degree[item] -= 1\n+                    if in_degree[item] == 0:\n+                        queue.append(item)\n+        \n+        # If we couldn't process all items, there's a cycle\n+        if len(result) != len(all_items):\n+            # Fall back to preserving order from list_1 + new items from list_2\n+            result = list(list_1)\n+            for item in list_2:\n+                if item not in result:\n+                    result.append(item)\n+        \n+        return result\n+        all_items = set()\n+        \n+        for lst in lists:\n+            lst_items = list(lst)\n+            all_items.update(lst_items)\n+            \n+            # Add dependencies based on order in this list\n+            for i, item in enumerate(lst_items):\n+                if item not in dependency_graph:\n+                    dependency_graph[item] = set()\n+                \n+                # This item depends on all items that come before it in this list\n+                for j in range(i):\n+                    dependency_graph[item].add(lst_items[j])\n+        \n+        # Check for genuine conflicts (cycles in dependency graph)\n+        def has_cycle():\n+            visited = set()\n+            rec_stack = set()\n+            \n+            def dfs(node):\n+                if node in rec_stack:\n+                    return True\n+                if node in visited:\n+                    return False\n+                    \n+                visited.add(node)\n+                rec_stack.add(node)\n+                \n+                for neighbor in dependency_graph.get(node, set()):\n+                    if dfs(neighbor):\n+                        return True\n+                        \n+                rec_stack.remove(node)\n+                return False\n+            \n+            for item in all_items:\n+                if item not in visited:\n+                    if dfs(item):\n+                        return True\n+            return False\n+        \n+        # Warn about genuine conflicts only\n+        if has_cycle():\n+            # Find conflicting items for warning\n+            conflicting_items = []\n+            for lst in lists:\n+                lst_items = list(lst)\n+                for i in range(len(lst_items)):\n+                    for j in range(i + 1, len(lst_items)):\n+                        item1, item2 = lst_items[i], lst_items[j]\n+                        # Check if there's a reverse dependency in another list\n+                        for other_lst in lists:\n+                            other_items = list(other_lst)\n+                            try:\n+                                idx1 = other_items.index(item1)\n+                                idx2 = other_items.index(item2)\n+                                if idx1 > idx2:  # Reverse order found\n+                                    conflicting_items = [item1, item2]\n+                                    break\n+                            except ValueError:\n+                                continue\n+                        if conflicting_items:\n+                            break\n+                    if conflicting_items:\n+                        break\n+                if conflicting_items:\n+                    break\n+            \n+            if conflicting_items:\n+                warnings.warn(\n+                    'Detected duplicate Media files in an opposite order:\\n'\n+                    '%s\\n%s' % (conflicting_items[0], conflicting_items[1]),\n+                    MediaOrderConflictWarning,\n+                )\n+        \n+        # Perform topological sort\n+        result = []\n+        visited = set()\n+        \n+        def topological_sort(node):\n+            if node in visited:\n+                return\n+            visited.add(node)\n+            \n+            # Visit all dependencies first\n+            for dep in dependency_graph.get(node, set()):\n+                topological_sort(dep)\n+            \n+            result.append(node)\n+        \n+        # Sort items to ensure deterministic output\n+        for item in sorted(all_items):\n+            topological_sort(item)\n+        \n+        return result\n+        if not list_1:\n+            return list(list_2)\n+        if not list_2:\n+            return list(list_1)\n+        \n+        # Build a combined list preserving order from both lists\n+        combined_list = []\n+        seen = set()\n+        \n+        # Track positions of elements in each list for conflict detection\n+        pos_1 = {item: i for i, item in enumerate(list_1)}\n+        pos_2 = {item: i for i, item in enumerate(list_2)}\n+        \n+        # Get all unique items in order they first appear\n+        all_items = []\n+        for item in list_1:\n+            if item not in seen:\n+                all_items.append(item)\n+                seen.add(item)\n+        for item in list_2:\n+            if item not in seen:\n+                all_items.append(item)\n+                seen.add(item)\n+        \n+        # Check for genuine ordering conflicts\n+        conflicts = []\n+        for i, item_a in enumerate(all_items):\n+            for j, item_b in enumerate(all_items):\n+                if i < j:  # item_a comes before item_b in our ordering\n+                    # Check if both items exist in both lists\n+                    if (item_a in pos_1 and item_b in pos_1 and \n+                        item_a in pos_2 and item_b in pos_2):\n+                        # Check if they have opposite relative order in the two lists\n+                        if (pos_1[item_a] > pos_1[item_b] and \n+                            pos_2[item_a] < pos_2[item_b]):\n+                            conflicts.append((item_a, item_b))\n+        \n+        # Warn about genuine conflicts\n+        if conflicts:\n+            for item_a, item_b in conflicts:\n+                warnings.warn(\n+                    'Detected duplicate Media files in an opposite order:\\n'\n+                    '%s\\n%s' % (item_a, item_b),\n+                    MediaOrderConflictWarning,\n+                )\n+        \n+        # Build final ordering respecting dependencies from both lists\n+        result = []\n+        remaining = set(all_items)\n+        \n+        while remaining:\n+            # Find items that have no unprocessed dependencies\n+            candidates = []\n+            for item in remaining:\n+                can_add = True\n+                # Check dependencies from list_1\n+                if item in pos_1:\n+                    for other in remaining:\n+                        if other in pos_1 and pos_1[other] < pos_1[item]:\n+                            can_add = False\n+                            break\n+                # Check dependencies from list_2\n+                if can_add and item in pos_2:\n+                    for other in remaining:\n+                        if other in pos_2 and pos_2[other] < pos_2[item]:\n+                            can_add = False\n+                            break\n+                if can_add:\n+                    candidates.append(item)\n+            \n+            if not candidates:\n+                # Fallback: add remaining items in original order\n+                candidates = [item for item in all_items if item in remaining]\n+            \n+            # Add the first candidate (maintains stability)\n+            next_item = candidates[0]\n+            result.append(next_item)\n+            remaining.remove(next_item)\n+        \n+        return result\n                 # path already exists in the list. Update last_insert_index so\n                 # that the following elements are inserted in front of this one.\n                 last_insert_index = index\n         return combined_list\n \n+\n     def __add__(self, other):\n         combined = Media()\n+        # Store original lists to preserve structure for global merging\n         combined._css_lists = self._css_lists + other._css_lists\n         combined._js_lists = self._js_lists + other._js_lists\n         return combined\n"
  }
}