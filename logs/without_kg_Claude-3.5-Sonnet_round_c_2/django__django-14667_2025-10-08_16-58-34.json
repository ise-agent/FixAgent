{
  "zero_patches": {
    "Location 1 (/root/hy/projects_2/django/django/db/models/sql/query.py lines 681-682)": "\n        field_names, defer = self.deferred_loading\n        if not field_names and defer:\n            return\n",
    "Location 2 (/root/hy/projects_2/django/django/db/models/sql/query.py lines 735-750)": "\n        else:\n            for model, values in must_include.items():\n                if model in seen:\n                    seen[model].update(values)\n                else:\n                    # As we've passed through this model, but not explicitly\n                    # included any fields, we have to make sure it's mentioned\n                    # so that only the \"must include\" fields are pulled in.\n                    seen[model] = values\n            # Now ensure that every model in the inheritance chain is mentioned\n            # in the parent list. Again, it must be mentioned to ensure that\n            # only \"must include\" fields are pulled in.\n            for model in orig_opts.get_parent_list():\n                seen.setdefault(model, set())\n            for model, values in seen.items():\n                callback(target, model, values)\n",
    "Location 3 (/root/hy/projects_2/django/django/db/models/sql/query.py lines 685-685)": "\n        field_names, defer = self.deferred_loading\n        if not field_names and defer:\n            return\n",
    "Location 4 (/root/hy/projects_2/django/django/db/models/sql/query.py lines 736-743)": "\n        if not field_names:\n            # If defer=True and field_names is empty, load all fields\n            # If defer=False and field_names is empty, continue to process must_include\n            if defer:\n                return\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_2/django/django/db/models/sql/query.py lines 681-682)": [
      "\n        field_names, defer = self.deferred_loading\n        if not field_names and defer:\n            return\n",
      "\n        field_names, defer = self.deferred_loading\n        if not field_names and defer:\n            return\n",
      "\n        field_names, defer = self.deferred_loading\n        if not field_names and defer:\n            return\n",
      "\n        field_names, defer = self.deferred_loading\n        if not field_names and defer:\n            return\n",
      "\n        field_names, defer = self.deferred_loading\n        if not field_names and defer:\n            return\n",
      "\n        field_names, defer = self.deferred_loading\n        if not field_names and defer:\n            return\n",
      "\n        field_names, defer = self.deferred_loading\n        if not field_names and defer:\n            return\n",
      "\n        field_names, defer = self.deferred_loading\n        if not field_names and defer:\n            return\n"
    ],
    "Location 2 (/root/hy/projects_2/django/django/db/models/sql/query.py lines 735-750)": [
      "\n        if defer:\n            # Remove any existing deferred names from the current set before\n            # setting the new ones.\n            self.deferred_loading = field_names.difference(existing), True\n            return\n        if field_names:\n            # Replace any existing \"immediate load\" field names.\n            self.deferred_loading = frozenset(field_names), False\n        else:\n            # For immediate loading with empty field_names, we need to check\n            # if this is truly empty (load all fields) or the result of defer\n            # operations (load only must_include fields like primary key)\n            if existing:\n                # This is the result of defer() operations on an only() set\n                # Continue to must_include processing below\n                self.deferred_loading = frozenset(), False\n            else:\n                # This is truly empty immediate loading - load all fields\n                self.deferred_loading = None, False\n                return\n",
      "\n        if defer:\n            # The caller wants to load all fields except those specified in\n            # field_names. Walk through the model's concrete fields and find\n            # any that we need to load.\n            workset = {}\n            for field in self.get_meta().get_fields():\n                if field.concrete:\n                    add_to_dict(workset, field.model, field)\n            for model, values in workset.items():\n                field_names_set = set(field_names)\n                values_to_remove = {f for f in values\n                                    if f.attname in field_names_set}\n                values.difference_update(values_to_remove)\n                # Remove any empty sets (which mean load all fields).\n                if not values:\n                    del workset[model]\n                else:\n                    add_to_dict(must_include, field.model, field)\n                    for field in self.get_meta().parents.values():\n                        add_to_dict(must_include, field.model, field)\n                    for model, values in must_include.items():\n                        add_to_dict(workset, m, field)\n            for model, values in must_include.items():\n                # If we haven't included a model in workset, we don't add the\n                # corresponding must_include fields for that model, since an\n                # empty set means \"include all fields\". That's why there's no\n                # \"else\" branch here.\n                if model in workset:\n                    workset[model].update(values)\n            for model, values in workset.items():\n                callback(target, model, values)\n        else:\n            for model, values in must_include.items():\n                if model in seen:\n                    seen[model].update(values)\n                else:\n                    # As we've passed through this model, but not explicitly\n                    # included any fields, we have to make sure it's mentioned\n                    # so that only the \"must include\" fields are pulled in.\n                    seen[model] = values\n            # Now ensure that every model in the inheritance chain is mentioned\n            # in the parent list. Again, it must be mentioned to ensure that\n            # only \"must include\" fields are pulled in.\n            for model in orig_opts.get_parent_list():\n                seen.setdefault(model, set())\n            for model, values in seen.items():\n                callback(target, model, values)\n",
      "\n        else:\n            for model, values in must_include.items():\n                if model in seen:\n                    seen[model].update(values)\n                else:\n                    # As we've passed through this model, but not explicitly\n                    # included any fields, we have to make sure it's mentioned\n                    # so that only the \"must include\" fields are pulled in.\n                    seen[model] = values\n            # Now ensure that every model in the inheritance chain is mentioned\n            # in the parent list. Again, it must be mentioned to ensure that\n            # only \"must include\" fields are pulled in.\n            for model in orig_opts.get_parent_list():\n                seen.setdefault(model, set())\n            for model, values in seen.items():\n                callback(target, model, values)\n",
      "\n        else:\n            for model, values in must_include.items():\n                if model in seen:\n                    seen[model].update(values)\n                else:\n                    # As we've passed through this model, but not explicitly\n                    # included any fields, we have to make sure it's mentioned\n                    # so that only the \"must include\" fields are pulled in.\n                    seen[model] = values\n            # Now ensure that every model in the inheritance chain is mentioned\n            # in the parent list. Again, it must be mentioned to ensure that\n            # only \"must include\" fields are pulled in.\n            for model in orig_opts.get_parent_list():\n                seen.setdefault(model, set())\n            for model, values in seen.items():\n                callback(target, model, values)\n",
      "\n        if defer:\n            # Remove any existing deferred names from the current set before\n            # setting the new names.\n            self.deferred_loading = field_names, False\n        else:\n            # Replace any existing \"immediate load\" field names.\n            self.deferred_loading = field_names, True\n\n        if field_names and not defer:\n            # Check whether we need to start a new deferred-loading map or can\n            # continue with the existing one. We continue with the existing one\n            # if the current field_names set is a subset of the existing set.\n            existing_field_names, existing_defer = self.deferred_loading\n            if not existing_defer and existing_field_names >= field_names:\n                # If the existing set is already a superset of the new set,\n                # we don't need to do anything.\n                return\n            # We need to start fresh with the new field_names set.\n            self.deferred_loading = field_names, defer\n\n        # We need to build a new deferred loading map.\n        opts = self.get_meta()\n        # must_include holds a set of field names that we have to include.\n        must_include = set()\n        for field in opts.concrete_fields:\n            if field.primary_key or field.name in field_names:\n                must_include.add(field.name)\n\n        # Now, we need to build the actual deferred loading map.\n        if defer:\n            # In defer mode, we start with everything and remove what we don't want.\n            self.deferred_loading = field_names, True\n        else:\n            # In immediate mode, we start with nothing and add what we want.\n            # If field_names is empty but we're in immediate mode, we should only\n            # load the must_include fields (like primary key).\n            if not field_names:\n                # Empty field_names in immediate mode means load only must_include\n                self.deferred_loading = must_include, False\n            else:\n                # Non-empty field_names in immediate mode\n                self.deferred_loading = field_names | must_include, False\n",
      "\n        if defer and field_names:\n            # Remove any existing deferred names from the current set before\n            # setting the new names.\n            self.deferred_loading = field_names.difference(existing), True\n        elif defer:\n            # Remove all fields from the deferred set.\n            self.deferred_loading = existing.difference(field_names), True\n        elif not field_names and not defer:\n            # Load only the must_include fields (like primary key)\n            # when immediate loading is requested but no fields specified\n            pass  # Continue to process must_include logic below\n        elif field_names and not defer:\n            # Replace the current set of immediate loading field names.\n            self.deferred_loading = frozenset(field_names), False\n        else:\n            # Replace the current set of deferred field names.\n            self.deferred_loading = field_names, True\n",
      "\n        if defer:\n            # Remove any mentioned deferred field from the set of any existing\n            # \"immediate load\" fields.\n            for field_name in field_names:\n                try:\n                    self.deferred_loading[1].remove(field_name)\n                except KeyError:\n                    pass\n        elif field_names:\n            # Replace any existing \"immediate load\" fields.\n            self.deferred_loading = (frozenset(field_names), False)\n        else:\n            # For immediate loading with empty field_names, continue to must_include\n            # logic to ensure only essential fields (like primary key) are loaded\n            pass\n\n        if not defer and not field_names:\n            # When immediate loading is requested but no specific fields are given\n            # (e.g., after defer() removes all fields from only() set),\n            # we need to process must_include fields to load only essential fields\n            must_include = {}\n            # Include the model's primary key field and any ancestor link fields.\n            for field in opts.concrete_fields:\n                if field.primary_key:\n                    add_to_dict(must_include, opts, field)\n            for parent in opts.get_parent_list():\n                link = opts.get_ancestor_link(parent)\n                add_to_dict(must_include, parent, link)\n\n            # Handle the case where only must_include fields should be loaded\n            for model, values in must_include.items():\n                callback(target, model, values)\n        elif defer and field_names:\n            # This handles the defer case - load all fields except deferred ones\n            for field in opts.get_fields():\n                if field.name in field_names:\n                    field.contribute_to_class(target, field.name + '_deferred')\n        else:\n            # Handle immediate loading with specific field names\n            # Build workset from requested fields\n            workset = {}\n            for field_name in field_names:\n                try:\n                    field = opts.get_field(field_name)\n                    add_to_dict(workset, opts, field)\n                except FieldDoesNotExist:\n                    # Handle related field lookups\n                    parts = field_name.split(LOOKUP_SEP)\n                    for m in get_child_with_renamed_table(target, parts[:-1], opts):\n                        field = m.get_field(parts[-1])\n                        add_to_dict(workset, m, field)\n            \n            # Add must_include fields\n            must_include = {}\n            for field in opts.concrete_fields:\n                if field.primary_key:\n                    add_to_dict(must_include, opts, field)\n            for parent in opts.get_parent_list():\n                link = opts.get_ancestor_link(parent)\n                add_to_dict(must_include, parent, link)\n            \n            # Merge must_include into workset\n            for model, values in must_include.items():\n                if model in workset:\n                    workset[model].update(values)\n            \n            # Process final field set\n            for model, values in workset.items():\n                callback(target, model, values)\n",
      "\n        else:\n            for model, values in must_include.items():\n                if model in seen:\n                    seen[model].update(values)\n                else:\n                    # As we've passed through this model, but not explicitly\n                    # included any fields, we have to make sure it's mentioned\n                    # so that only the \"must include\" fields are pulled in.\n                    seen[model] = values\n            # Now ensure that every model in the inheritance chain is mentioned\n            # in the parent list. Again, it must be mentioned to ensure that\n            # only \"must include\" fields are pulled in.\n            for model in orig_opts.get_parent_list():\n                seen.setdefault(model, set())\n            for model, values in seen.items():\n                callback(target, model, values)\n"
    ],
    "Location 3 (/root/hy/projects_2/django/django/db/models/sql/query.py lines 685-685)": [
      "\n        field_names, defer = self.deferred_loading\n        if not field_names:\n            # Only return early if we're in defer mode (defer=True)\n            # In immediate loading mode (defer=False), we need to process\n            # must_include fields even with empty field_names\n            if defer:\n                return\n",
      "\n        field_names, defer = self.deferred_loading\n        if not field_names and defer:\n            return\n",
      "\n        field_names, defer = self.deferred_loading\n        if not field_names and defer:\n            return\n",
      "\n        field_names, defer = self.deferred_loading\n        if not field_names and defer:\n            return\n",
      "\n        field_names, defer = self.deferred_loading\n        if not field_names and defer:\n            return\n",
      "\n        field_names, defer = self.deferred_loading\n        if not field_names:\n            # Only return early for deferred loading (defer=True) when no fields specified\n            # For immediate loading (defer=False), continue to process must_include fields\n            if defer:\n                return\n",
      "\n        field_names, defer = self.deferred_loading\n        if not field_names and defer:\n            return\n",
      "\n        field_names, defer = self.deferred_loading\n        if not field_names and defer:\n            return\n        orig_opts = self.get_meta()\n        seen = {}\n"
    ],
    "Location 4 (/root/hy/projects_2/django/django/db/models/sql/query.py lines 736-743)": [
      "\n        if defer:\n            # Remove any mentioned deferred fields from the set of any existing\n            # \"immediate load\" fields.\n            if field_names:\n                field_names = field_names.difference(self.immediate_loading)\n                self.immediate_loading = self.immediate_loading.difference(field_names)\n        else:\n            # Replace any existing \"immediate load\" fields.\n            # Handle the case where immediate loading is empty after defer operations\n            # In this case, we should continue to process must_include fields (like primary key)\n            # rather than loading all fields\n            if field_names or not self.immediate_loading:\n                self.immediate_loading = field_names\n\n        if self.immediate_loading:\n            # Some fields have been nominated for immediate loading. Reduce the\n            # set of deferred fields accordingly.\n            self.deferred_loading = self.deferred_loading.difference(self.immediate_loading)\n            # If there are no deferred fields left, remove the internal flag.\n            if not self.deferred_loading:\n                self.deferred_loading = None\n        # For immediate loading mode with empty field_names, we need to process\n        # must_include fields to ensure only essential fields (like primary key) are loaded\n        elif not defer:\n            # This is immediate loading mode with no specific fields requested\n            # Continue to must_include processing instead of loading all fields\n            pass\n",
      "\n        # If the deferred loading set is empty, only return immediately if\n        # this is truly a deferred loading scenario (defer=True). For immediate\n        # loading (defer=False), we need to process must_include fields even\n        # when field_names is empty.\n        if not field_names and defer:\n            return\n",
      "\n        # Now we need to turn the immediate-loading, deferred-loading and\n        # must-include sets into a single dictionary for each model, so that\n        # the query machinery can load them efficiently.\n        for field, model in immediate.items():\n            try:\n                opts = model._meta\n            except AttributeError:\n                opts = model\n            # In the case of a GenericForeignKey, the FK is hidden in ct_field\n            # and fk_field. We need to add those to the query.\n            if hasattr(field, \"remote_field\") and hasattr(field.remote_field, \"model\"):\n                rel_model = field.remote_field.model\n                if hasattr(rel_model._meta, \"get_field\"):\n                    for f in rel_model._meta.get_fields():\n                        if f.name in (\"content_type\", \"object_id\"):\n                            try:\n                                f = opts.get_field(f.attname)\n                                if f not in seen:\n                                    seen.add(f)\n                                    immediate[f] = opts\n                            except FieldDoesNotExist:\n                                pass\n            if field.is_relation:\n                # For relations, we also need to fetch the fields that the\n                # relation points to. These will be in the select, but we also\n                # need to add them to the related query.\n                for f in field.cached_col:\n                    if f not in seen:\n                        seen.add(f)\n                        immediate[f] = opts\n            else:\n                immediate[field] = opts\n        \n        # Handle the case where defer=False (immediate loading) and field_names is empty\n        # This happens when all fields from only() are deferred, so we should load only must_include fields\n        if not defer and not field_names:\n            # Don't return early - continue to process must_include fields\n            pass\n        elif not field_names:\n            # This is the original early return for the deferred loading case (defer=True)\n            return\n",
      "\n        if defer and field_names:\n            # Remove any mentioned deferred fields from the set of any existing\n            # immediate loads.\n            if immediate:\n                immediate = immediate.difference(field_names)\n            else:\n                immediate = set(opts.fields).difference(field_names)\n\n            # Replace the existing \"immediate\" with the new set of fields.\n            field_names = immediate\n\n        if field_names and defer is False:\n            # Early return for immediate loading with non-empty field_names\n            for field in field_names:\n                try:\n                    field_name = field.name\n                except AttributeError:\n                    field_name = field\n                callback(target, field.model, field_name)\n        elif field_names is None or defer:\n            # Load all fields for deferred loading or when field_names is None\n            callback(target, opts, None)\n        else:\n            # Handle immediate loading with empty field_names - process must_include\n            must_include = {opts: set()}\n            for field in opts.concrete_fields:\n                if field.primary_key or field.name in always_include:\n                    must_include[opts].add(field.name)\n            for model, values in must_include.items():\n                if model in seen:\n                    seen[model].update(values)\n                else:\n                    # As we've passed through this model, but not explicitly\n                    # included any fields, we have to make sure it's mentioned\n                    # so that only the \"must include\" fields are pulled in.\n                    seen[model] = values\n",
      "\n        if defer:\n            # Remove any existing immediate loading field constraints.\n            self.deferred_loading = (set(), False)\n        else:\n            # When defer=False, we need to be more careful about early returns.\n            # If field_names is empty but we have must_include fields (like primary keys),\n            # we should continue processing to ensure only essential fields are loaded.\n            if field_names and not self.deferred_loading[0]:\n                # Clear existing deferred field list.\n                self.deferred_loading = (set(), True)\n",
      "\n        # Deferred loading case.\n        if defer:\n            # Remove any fields from the immediate load set.\n            for field_name in field_names:\n                field_names_defer = self.deferred_loading[1]\n                if field_name in field_names_defer:\n                    field_names_defer.remove(field_name)\n            # Add the new deferred names.\n            self.deferred_loading[1].update(field_names)\n        # Immediate loading case.\n        else:\n            # Remove any fields from the deferred set.\n            for field_name in field_names:\n                field_names_defer = self.deferred_loading[1] \n                if field_name in field_names_defer:\n                    field_names_defer.remove(field_name)\n            # Replace the immediate load set.\n            self.deferred_loading = (frozenset(field_names), self.deferred_loading[1])\n\n    def deferred_to_data(self, target, callback):\n        \"\"\"\n        Convert the self.deferred_loading data structure to mapping of table\n        names to sets of column names which are to be loaded. The callback gets\n        to do the hard work of figuring out the needed table and column names in\n        the current context.\n        \"\"\"\n        defer, field_names = self.deferred_loading\n        if not field_names:\n            if defer:\n                # No defer fields means load all fields.\n                return\n            # For immediate loading with empty field_names, we need to process\n            # must_include to ensure primary keys are loaded.\n        \n        orig_opts = self.get_meta()\n        seen = {}\n        must_include = {orig_opts: set()}\n        for field_name in orig_opts.fields:\n            if field_name.primary_key:\n                must_include[orig_opts].add(field_name)\n\n        def load_data(model, field_names):\n            \"\"\"\n            Helper function to recursively load deferred model data.\n            \"\"\"\n            # Handle proxy model inheritance.\n            if model._meta.proxy:\n                for f in model._meta.local_fields:\n                    if f.primary_key:\n                        must_include.setdefault(model._meta, set()).add(f)\n                model = model._meta.concrete_model\n            # Ensure that the model is in seen, with an empty set if no\n            # specific fields are required.\n            if model not in seen:\n                seen[model] = set()\n            # Add any explicitly required fields for this model.\n            if field_names:\n                seen[model].update(field_names)\n\n        # Handle the main model fields.\n        if defer:\n            # We want to load everything except the deferred fields.\n            for field_name in field_names:\n                field = orig_opts.get_field(field_name)\n                if field.is_relation and field.many_to_one:\n                    # For foreign keys, we need to load the local field.\n                    seen.setdefault(orig_opts, set()).add(field.attname)\n                else:\n                    seen.setdefault(orig_opts, set()).add(field_name)\n        else:\n            # We want to load only the specified fields.\n            if field_names:\n                for field_name in field_names:\n                    field = orig_opts.get_field(field_name)\n                    if field.is_relation and field.many_to_one:\n                        # For foreign keys, we need to load the local field.\n                        seen.setdefault(orig_opts, set()).add(field.attname)\n                    else:\n                        seen.setdefault(orig_opts, set()).add(field_name)\n\n        # Now we need to handle the inheritance tree. First we'll calculate\n        # which fields need to be added for inherited models, then add them.\n        if defer:\n            # Deferred case: start with all fields, remove deferred ones.\n            workset = {}\n            for model in orig_opts.get_parent_list():\n                workset.setdefault(model, set())\n                for field in model._meta.local_fields:\n                    if field.attname not in seen.get(model, set()):\n                        workset[model].add(field.attname)\n            for model, values in must_include.items():\n                # If we haven't included a model in workset, we don't add the\n                # corresponding must_include fields for that model, since an\n                # empty set means \"include all fields\". That's why there's no\n                # \"else\" branch here.\n                if model in workset:\n                    workset[model].update(values)\n            for model, values in workset.items():\n                callback(target, model, values)\n        else:\n            for model, values in must_include.items():\n                if model in seen:\n                    seen[model].update(values)\n                else:\n                    # As we've passed through this model, but not explicitly\n                    # included any fields, we have to make sure it's mentioned\n                    # so that only the \"must include\" fields are pulled in.\n                    seen[model] = values\n",
      "\n        if defer:\n            # Remove any existing immediate fields.\n            self.immediate_loading.difference_update(field_names)\n            if field_names:\n                self.deferred_loading = self.deferred_loading[0].union(\n                    field_names\n                ), self.deferred_loading[1]\n        else:\n            # Add to immediate fields - but only if we have specific fields\n            # or if immediate_loading is not already populated.\n            # This prevents the early return bug when defer() empties an only() set.\n            if field_names or not self.immediate_loading:\n                if field_names:\n                    self.immediate_loading = self.immediate_loading.union(field_names)\n                self.deferred_loading = field_names, self.deferred_loading[1]\n            else:\n                # When field_names is empty but immediate_loading exists,\n                # this means defer() removed all fields from only().\n                # Continue to must_include processing instead of early return.\n                self.deferred_loading = field_names, self.deferred_loading[1]\n",
      "\n        if defer:\n            # Remove any mentioned deferred fields from the set of any existing\n            # \"immediate load\" fields.\n            if only_load:\n                only_load = only_load.difference(field_names)\n                if not only_load:\n                    # If defer=True and only_load becomes empty, we should load\n                    # only the must_include fields (like primary key)\n                    pass  # Continue to process must_include logic below\n            else:\n                self.deferred_loading = (\n                    self.deferred_loading[0].union(field_names),\n                    False,\n                )\n                return\n        if field_names and not only_load:\n            # Empty field_names is a no-op, so only continue if field_names is\n            # non-empty or only_load is non-empty.\n            return\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8837881579..4c441bb46b 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -678,10 +678,16 @@ class Query(BaseExpression):\n         \"target\", and the model and list of fields being added for that model.\n         \"\"\"\n         field_names, defer = self.deferred_loading\n+\n         if not field_names:\n-            return\n+            # Only return early if we're in deferred mode (defer=True).\n+            # In immediate mode (defer=False) with empty field_names, we still need\n+            # to process must_include fields (like primary key).\n+            if defer:\n+                return\n         orig_opts = self.get_meta()\n         seen = {}\n+\n         must_include = {orig_opts.concrete_model: {orig_opts.pk}}\n         for field_name in field_names:\n             parts = field_name.split(LOOKUP_SEP)\n@@ -732,6 +738,7 @@ class Query(BaseExpression):\n                     workset[model].update(values)\n             for model, values in workset.items():\n                 callback(target, model, values)\n+\n         else:\n             for model, values in must_include.items():\n                 if model in seen:\n@@ -748,6 +755,7 @@ class Query(BaseExpression):\n                 seen.setdefault(model, set())\n             for model, values in seen.items():\n                 callback(target, model, values)\n+                callback(target, model, values)\n \n     def table_alias(self, table_name, create=False, filtered_relation=None):\n         \"\"\"\n",
    "variant_0": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8837881579..27f5106bb3 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -678,11 +678,16 @@ class Query(BaseExpression):\n         \"target\", and the model and list of fields being added for that model.\n         \"\"\"\n         field_names, defer = self.deferred_loading\n-        if not field_names:\n+\n+        field_names, defer = self.deferred_loading\n+        if not field_names and defer:\n             return\n         orig_opts = self.get_meta()\n         seen = {}\n-        must_include = {orig_opts.concrete_model: {orig_opts.pk}}\n+\n+        field_names, defer = self.deferred_loading\n+        if not field_names and defer:\n+            return\n         for field_name in field_names:\n             parts = field_name.split(LOOKUP_SEP)\n             cur_model = self.model._meta.concrete_model\n@@ -732,6 +737,7 @@ class Query(BaseExpression):\n                     workset[model].update(values)\n             for model, values in workset.items():\n                 callback(target, model, values)\n+\n         else:\n             for model, values in must_include.items():\n                 if model in seen:\n@@ -748,8 +754,6 @@ class Query(BaseExpression):\n                 seen.setdefault(model, set())\n             for model, values in seen.items():\n                 callback(target, model, values)\n-\n-    def table_alias(self, table_name, create=False, filtered_relation=None):\n         \"\"\"\n         Return a table alias for the given table_name and whether this is a\n         new alias or not.\n",
    "variant_1": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8837881579..cf979b8aa7 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -678,11 +678,20 @@ class Query(BaseExpression):\n         \"target\", and the model and list of fields being added for that model.\n         \"\"\"\n         field_names, defer = self.deferred_loading\n-        if not field_names:\n+\n+        field_names, defer = self.deferred_loading\n+        if not field_names and defer:\n             return\n         orig_opts = self.get_meta()\n         seen = {}\n-        must_include = {orig_opts.concrete_model: {orig_opts.pk}}\n+\n+        field_names, defer = self.deferred_loading\n+        if not field_names:\n+            # Only return early if we're in defer mode (defer=True)\n+            # In immediate loading mode (defer=False), we need to process\n+            # must_include fields even with empty field_names\n+            if defer:\n+                return\n         for field_name in field_names:\n             parts = field_name.split(LOOKUP_SEP)\n             cur_model = self.model._meta.concrete_model\n@@ -732,15 +741,40 @@ class Query(BaseExpression):\n                     workset[model].update(values)\n             for model, values in workset.items():\n                 callback(target, model, values)\n+\n+        if defer:\n+            # Remove any existing deferred names from the current set before\n+            # setting the new ones.\n+            self.deferred_loading = field_names.difference(existing), True\n+            return\n+        if field_names:\n+            # Replace any existing \"immediate load\" field names.\n+            self.deferred_loading = frozenset(field_names), False\n         else:\n-            for model, values in must_include.items():\n-                if model in seen:\n-                    seen[model].update(values)\n-                else:\n-                    # As we've passed through this model, but not explicitly\n-                    # included any fields, we have to make sure it's mentioned\n-                    # so that only the \"must include\" fields are pulled in.\n-                    seen[model] = values\n+            # For immediate loading with empty field_names, we need to check\n+            # if this is truly empty (load all fields) or the result of defer\n+            # operations (load only must_include fields like primary key)\n+            if existing:\n+                # This is the result of defer() operations on an only() set\n+                # Continue to must_include processing below\n+                self.deferred_loading = frozenset(), False\n+            else:\n+                # This is truly empty immediate loading - load all fields\n+                self.deferred_loading = None, False\n+                return\n+        if self.immediate_loading:\n+            # Some fields have been nominated for immediate loading. Reduce the\n+            # set of deferred fields accordingly.\n+            self.deferred_loading = self.deferred_loading.difference(self.immediate_loading)\n+            # If there are no deferred fields left, remove the internal flag.\n+            if not self.deferred_loading:\n+                self.deferred_loading = None\n+        # For immediate loading mode with empty field_names, we need to process\n+        # must_include fields to ensure only essential fields (like primary key) are loaded\n+        elif not defer:\n+            # This is immediate loading mode with no specific fields requested\n+            # Continue to must_include processing instead of loading all fields\n+            pass\n             # Now ensure that every model in the inheritance chain is mentioned\n             # in the parent list. Again, it must be mentioned to ensure that\n             # only \"must include\" fields are pulled in.\n",
    "variant_2": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8837881579..020f8c1709 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -678,11 +678,16 @@ class Query(BaseExpression):\n         \"target\", and the model and list of fields being added for that model.\n         \"\"\"\n         field_names, defer = self.deferred_loading\n-        if not field_names:\n+\n+        field_names, defer = self.deferred_loading\n+        if not field_names and defer:\n             return\n         orig_opts = self.get_meta()\n         seen = {}\n-        must_include = {orig_opts.concrete_model: {orig_opts.pk}}\n+\n+        field_names, defer = self.deferred_loading\n+        if not field_names and defer:\n+            return\n         for field_name in field_names:\n             parts = field_name.split(LOOKUP_SEP)\n             cur_model = self.model._meta.concrete_model\n@@ -732,6 +737,38 @@ class Query(BaseExpression):\n                     workset[model].update(values)\n             for model, values in workset.items():\n                 callback(target, model, values)\n+\n+        if defer:\n+            # The caller wants to load all fields except those specified in\n+            # field_names. Walk through the model's concrete fields and find\n+            # any that we need to load.\n+            workset = {}\n+            for field in self.get_meta().get_fields():\n+                if field.concrete:\n+                    add_to_dict(workset, field.model, field)\n+            for model, values in workset.items():\n+                field_names_set = set(field_names)\n+                values_to_remove = {f for f in values\n+                                    if f.attname in field_names_set}\n+                values.difference_update(values_to_remove)\n+                # Remove any empty sets (which mean load all fields).\n+                if not values:\n+                    del workset[model]\n+                else:\n+                    add_to_dict(must_include, field.model, field)\n+                    for field in self.get_meta().parents.values():\n+                        add_to_dict(must_include, field.model, field)\n+                    for model, values in must_include.items():\n+                        add_to_dict(workset, m, field)\n+            for model, values in must_include.items():\n+                # If we haven't included a model in workset, we don't add the\n+                # corresponding must_include fields for that model, since an\n+                # empty set means \"include all fields\". That's why there's no\n+                # \"else\" branch here.\n+                if model in workset:\n+                    workset[model].update(values)\n+            for model, values in workset.items():\n+                callback(target, model, values)\n         else:\n             for model, values in must_include.items():\n                 if model in seen:\n@@ -748,7 +785,6 @@ class Query(BaseExpression):\n                 seen.setdefault(model, set())\n             for model, values in seen.items():\n                 callback(target, model, values)\n-\n     def table_alias(self, table_name, create=False, filtered_relation=None):\n         \"\"\"\n         Return a table alias for the given table_name and whether this is a\n",
    "variant_3": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8837881579..8c3f8d41ba 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -678,11 +678,16 @@ class Query(BaseExpression):\n         \"target\", and the model and list of fields being added for that model.\n         \"\"\"\n         field_names, defer = self.deferred_loading\n-        if not field_names:\n+\n+        field_names, defer = self.deferred_loading\n+        if not field_names and defer:\n             return\n         orig_opts = self.get_meta()\n         seen = {}\n-        must_include = {orig_opts.concrete_model: {orig_opts.pk}}\n+\n+        field_names, defer = self.deferred_loading\n+        if not field_names and defer:\n+            return\n         for field_name in field_names:\n             parts = field_name.split(LOOKUP_SEP)\n             cur_model = self.model._meta.concrete_model\n@@ -732,6 +737,7 @@ class Query(BaseExpression):\n                     workset[model].update(values)\n             for model, values in workset.items():\n                 callback(target, model, values)\n+\n         else:\n             for model, values in must_include.items():\n                 if model in seen:\n@@ -744,6 +750,40 @@ class Query(BaseExpression):\n             # Now ensure that every model in the inheritance chain is mentioned\n             # in the parent list. Again, it must be mentioned to ensure that\n             # only \"must include\" fields are pulled in.\n+            for model in orig_opts.get_parent_list():\n+                seen.setdefault(model, set())\n+            for model, values in seen.items():\n+                callback(target, model, values)\n+                        if f.name in (\"content_type\", \"object_id\"):\n+                            try:\n+                                f = opts.get_field(f.attname)\n+                                if f not in seen:\n+                                    seen.add(f)\n+                                    immediate[f] = opts\n+                            except FieldDoesNotExist:\n+                                pass\n+            if field.is_relation:\n+                # For relations, we also need to fetch the fields that the\n+                # relation points to. These will be in the select, but we also\n+                # need to add them to the related query.\n+                for f in field.cached_col:\n+                    if f not in seen:\n+                        seen.add(f)\n+                        immediate[f] = opts\n+            else:\n+                immediate[field] = opts\n+        \n+        # Handle the case where defer=False (immediate loading) and field_names is empty\n+        # This happens when all fields from only() are deferred, so we should load only must_include fields\n+        if not defer and not field_names:\n+            # Don't return early - continue to process must_include fields\n+            pass\n+        elif not field_names:\n+            # This is the original early return for the deferred loading case (defer=True)\n+            return\n+            # Now ensure that every model in the inheritance chain is mentioned\n+            # in the parent list. Again, it must be mentioned to ensure that\n+            # only \"must include\" fields are pulled in.\n             for model in orig_opts.get_parent_list():\n                 seen.setdefault(model, set())\n             for model, values in seen.items():\n",
    "variant_4": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8837881579..dc66eba65f 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -678,11 +678,16 @@ class Query(BaseExpression):\n         \"target\", and the model and list of fields being added for that model.\n         \"\"\"\n         field_names, defer = self.deferred_loading\n-        if not field_names:\n+\n+        field_names, defer = self.deferred_loading\n+        if not field_names and defer:\n             return\n         orig_opts = self.get_meta()\n         seen = {}\n-        must_include = {orig_opts.concrete_model: {orig_opts.pk}}\n+\n+        field_names, defer = self.deferred_loading\n+        if not field_names and defer:\n+            return\n         for field_name in field_names:\n             parts = field_name.split(LOOKUP_SEP)\n             cur_model = self.model._meta.concrete_model\n@@ -732,7 +737,37 @@ class Query(BaseExpression):\n                     workset[model].update(values)\n             for model, values in workset.items():\n                 callback(target, model, values)\n+\n+        else:\n+            for model, values in must_include.items():\n+                if model in seen:\n+                    seen[model].update(values)\n+                else:\n+                    # As we've passed through this model, but not explicitly\n+                    # included any fields, we have to make sure it's mentioned\n+                    # so that only the \"must include\" fields are pulled in.\n+                    seen[model] = values\n+            # Now ensure that every model in the inheritance chain is mentioned\n+            # in the parent list. Again, it must be mentioned to ensure that\n+            # only \"must include\" fields are pulled in.\n+            for model in orig_opts.get_parent_list():\n+                seen.setdefault(model, set())\n+            for model, values in seen.items():\n+                callback(target, model, values)\n+                try:\n+                    field_name = field.name\n+                except AttributeError:\n+                    field_name = field\n+                callback(target, field.model, field_name)\n+        elif field_names is None or defer:\n+            # Load all fields for deferred loading or when field_names is None\n+            callback(target, opts, None)\n         else:\n+            # Handle immediate loading with empty field_names - process must_include\n+            must_include = {opts: set()}\n+            for field in opts.concrete_fields:\n+                if field.primary_key or field.name in always_include:\n+                    must_include[opts].add(field.name)\n             for model, values in must_include.items():\n                 if model in seen:\n                     seen[model].update(values)\n",
    "variant_5": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8837881579..c4cebd529a 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -678,11 +678,16 @@ class Query(BaseExpression):\n         \"target\", and the model and list of fields being added for that model.\n         \"\"\"\n         field_names, defer = self.deferred_loading\n-        if not field_names:\n+\n+        field_names, defer = self.deferred_loading\n+        if not field_names and defer:\n             return\n         orig_opts = self.get_meta()\n         seen = {}\n-        must_include = {orig_opts.concrete_model: {orig_opts.pk}}\n+\n+        field_names, defer = self.deferred_loading\n+        if not field_names and defer:\n+            return\n         for field_name in field_names:\n             parts = field_name.split(LOOKUP_SEP)\n             cur_model = self.model._meta.concrete_model\n@@ -732,19 +737,49 @@ class Query(BaseExpression):\n                     workset[model].update(values)\n             for model, values in workset.items():\n                 callback(target, model, values)\n+\n+        if defer:\n+            # Remove any existing deferred names from the current set before\n+            # setting the new names.\n+            self.deferred_loading = field_names, False\n         else:\n-            for model, values in must_include.items():\n-                if model in seen:\n-                    seen[model].update(values)\n-                else:\n-                    # As we've passed through this model, but not explicitly\n-                    # included any fields, we have to make sure it's mentioned\n-                    # so that only the \"must include\" fields are pulled in.\n-                    seen[model] = values\n-            # Now ensure that every model in the inheritance chain is mentioned\n-            # in the parent list. Again, it must be mentioned to ensure that\n-            # only \"must include\" fields are pulled in.\n-            for model in orig_opts.get_parent_list():\n+            # Replace any existing \"immediate load\" field names.\n+            self.deferred_loading = field_names, True\n+\n+        if field_names and not defer:\n+            # Check whether we need to start a new deferred-loading map or can\n+            # continue with the existing one. We continue with the existing one\n+            # if the current field_names set is a subset of the existing set.\n+            existing_field_names, existing_defer = self.deferred_loading\n+            if not existing_defer and existing_field_names >= field_names:\n+                # If the existing set is already a superset of the new set,\n+                # we don't need to do anything.\n+                return\n+            # We need to start fresh with the new field_names set.\n+            self.deferred_loading = field_names, defer\n+\n+        # We need to build a new deferred loading map.\n+        opts = self.get_meta()\n+        # must_include holds a set of field names that we have to include.\n+        must_include = set()\n+        for field in opts.concrete_fields:\n+            if field.primary_key or field.name in field_names:\n+                must_include.add(field.name)\n+\n+        # Now, we need to build the actual deferred loading map.\n+        if defer:\n+            # In defer mode, we start with everything and remove what we don't want.\n+            self.deferred_loading = field_names, True\n+        else:\n+            # In immediate mode, we start with nothing and add what we want.\n+            # If field_names is empty but we're in immediate mode, we should only\n+            # load the must_include fields (like primary key).\n+            if not field_names:\n+                # Empty field_names in immediate mode means load only must_include\n+                self.deferred_loading = must_include, False\n+            else:\n+                # Non-empty field_names in immediate mode\n+                self.deferred_loading = field_names | must_include, False\n                 seen.setdefault(model, set())\n             for model, values in seen.items():\n                 callback(target, model, values)\n",
    "variant_6": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8837881579..0bd7ef2801 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -678,11 +678,19 @@ class Query(BaseExpression):\n         \"target\", and the model and list of fields being added for that model.\n         \"\"\"\n         field_names, defer = self.deferred_loading\n-        if not field_names:\n+\n+        field_names, defer = self.deferred_loading\n+        if not field_names and defer:\n             return\n         orig_opts = self.get_meta()\n         seen = {}\n-        must_include = {orig_opts.concrete_model: {orig_opts.pk}}\n+\n+        field_names, defer = self.deferred_loading\n+        if not field_names:\n+            # Only return early for deferred loading (defer=True) when no fields specified\n+            # For immediate loading (defer=False), continue to process must_include fields\n+            if defer:\n+                return\n         for field_name in field_names:\n             parts = field_name.split(LOOKUP_SEP)\n             cur_model = self.model._meta.concrete_model\n@@ -732,6 +740,109 @@ class Query(BaseExpression):\n                     workset[model].update(values)\n             for model, values in workset.items():\n                 callback(target, model, values)\n+\n+        if defer and field_names:\n+            # Remove any existing deferred names from the current set before\n+            # setting the new names.\n+            self.deferred_loading = field_names.difference(existing), True\n+        elif defer:\n+            # Remove all fields from the deferred set.\n+            self.deferred_loading = existing.difference(field_names), True\n+        elif not field_names and not defer:\n+            # Load only the must_include fields (like primary key)\n+            # when immediate loading is requested but no fields specified\n+            pass  # Continue to process must_include logic below\n+        elif field_names and not defer:\n+            # Replace the current set of immediate loading field names.\n+            self.deferred_loading = frozenset(field_names), False\n+        else:\n+            # Replace the current set of deferred field names.\n+            self.deferred_loading = field_names, True\n+                if field_name in field_names_defer:\n+                    field_names_defer.remove(field_name)\n+            # Replace the immediate load set.\n+            self.deferred_loading = (frozenset(field_names), self.deferred_loading[1])\n+\n+    def deferred_to_data(self, target, callback):\n+        \"\"\"\n+        Convert the self.deferred_loading data structure to mapping of table\n+        names to sets of column names which are to be loaded. The callback gets\n+        to do the hard work of figuring out the needed table and column names in\n+        the current context.\n+        \"\"\"\n+        defer, field_names = self.deferred_loading\n+        if not field_names:\n+            if defer:\n+                # No defer fields means load all fields.\n+                return\n+            # For immediate loading with empty field_names, we need to process\n+            # must_include to ensure primary keys are loaded.\n+        \n+        orig_opts = self.get_meta()\n+        seen = {}\n+        must_include = {orig_opts: set()}\n+        for field_name in orig_opts.fields:\n+            if field_name.primary_key:\n+                must_include[orig_opts].add(field_name)\n+\n+        def load_data(model, field_names):\n+            \"\"\"\n+            Helper function to recursively load deferred model data.\n+            \"\"\"\n+            # Handle proxy model inheritance.\n+            if model._meta.proxy:\n+                for f in model._meta.local_fields:\n+                    if f.primary_key:\n+                        must_include.setdefault(model._meta, set()).add(f)\n+                model = model._meta.concrete_model\n+            # Ensure that the model is in seen, with an empty set if no\n+            # specific fields are required.\n+            if model not in seen:\n+                seen[model] = set()\n+            # Add any explicitly required fields for this model.\n+            if field_names:\n+                seen[model].update(field_names)\n+\n+        # Handle the main model fields.\n+        if defer:\n+            # We want to load everything except the deferred fields.\n+            for field_name in field_names:\n+                field = orig_opts.get_field(field_name)\n+                if field.is_relation and field.many_to_one:\n+                    # For foreign keys, we need to load the local field.\n+                    seen.setdefault(orig_opts, set()).add(field.attname)\n+                else:\n+                    seen.setdefault(orig_opts, set()).add(field_name)\n+        else:\n+            # We want to load only the specified fields.\n+            if field_names:\n+                for field_name in field_names:\n+                    field = orig_opts.get_field(field_name)\n+                    if field.is_relation and field.many_to_one:\n+                        # For foreign keys, we need to load the local field.\n+                        seen.setdefault(orig_opts, set()).add(field.attname)\n+                    else:\n+                        seen.setdefault(orig_opts, set()).add(field_name)\n+\n+        # Now we need to handle the inheritance tree. First we'll calculate\n+        # which fields need to be added for inherited models, then add them.\n+        if defer:\n+            # Deferred case: start with all fields, remove deferred ones.\n+            workset = {}\n+            for model in orig_opts.get_parent_list():\n+                workset.setdefault(model, set())\n+                for field in model._meta.local_fields:\n+                    if field.attname not in seen.get(model, set()):\n+                        workset[model].add(field.attname)\n+            for model, values in must_include.items():\n+                # If we haven't included a model in workset, we don't add the\n+                # corresponding must_include fields for that model, since an\n+                # empty set means \"include all fields\". That's why there's no\n+                # \"else\" branch here.\n+                if model in workset:\n+                    workset[model].update(values)\n+            for model, values in workset.items():\n+                callback(target, model, values)\n         else:\n             for model, values in must_include.items():\n                 if model in seen:\n",
    "variant_7": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8837881579..5ebe3ca5fd 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -678,11 +678,16 @@ class Query(BaseExpression):\n         \"target\", and the model and list of fields being added for that model.\n         \"\"\"\n         field_names, defer = self.deferred_loading\n-        if not field_names:\n+\n+        field_names, defer = self.deferred_loading\n+        if not field_names and defer:\n             return\n         orig_opts = self.get_meta()\n         seen = {}\n-        must_include = {orig_opts.concrete_model: {orig_opts.pk}}\n+\n+        field_names, defer = self.deferred_loading\n+        if not field_names and defer:\n+            return\n         for field_name in field_names:\n             parts = field_name.split(LOOKUP_SEP)\n             cur_model = self.model._meta.concrete_model\n@@ -732,15 +737,82 @@ class Query(BaseExpression):\n                     workset[model].update(values)\n             for model, values in workset.items():\n                 callback(target, model, values)\n+\n+        if defer:\n+            # Remove any mentioned deferred field from the set of any existing\n+            # \"immediate load\" fields.\n+            for field_name in field_names:\n+                try:\n+                    self.deferred_loading[1].remove(field_name)\n+                except KeyError:\n+                    pass\n+        elif field_names:\n+            # Replace any existing \"immediate load\" fields.\n+            self.deferred_loading = (frozenset(field_names), False)\n         else:\n+            # For immediate loading with empty field_names, continue to must_include\n+            # logic to ensure only essential fields (like primary key) are loaded\n+            pass\n+\n+        if not defer and not field_names:\n+            # When immediate loading is requested but no specific fields are given\n+            # (e.g., after defer() removes all fields from only() set),\n+            # we need to process must_include fields to load only essential fields\n+            must_include = {}\n+            # Include the model's primary key field and any ancestor link fields.\n+            for field in opts.concrete_fields:\n+                if field.primary_key:\n+                    add_to_dict(must_include, opts, field)\n+            for parent in opts.get_parent_list():\n+                link = opts.get_ancestor_link(parent)\n+                add_to_dict(must_include, parent, link)\n+\n+            # Handle the case where only must_include fields should be loaded\n             for model, values in must_include.items():\n-                if model in seen:\n-                    seen[model].update(values)\n-                else:\n-                    # As we've passed through this model, but not explicitly\n-                    # included any fields, we have to make sure it's mentioned\n-                    # so that only the \"must include\" fields are pulled in.\n-                    seen[model] = values\n+                callback(target, model, values)\n+        elif defer and field_names:\n+            # This handles the defer case - load all fields except deferred ones\n+            for field in opts.get_fields():\n+                if field.name in field_names:\n+                    field.contribute_to_class(target, field.name + '_deferred')\n+        else:\n+            # Handle immediate loading with specific field names\n+            # Build workset from requested fields\n+            workset = {}\n+            for field_name in field_names:\n+                try:\n+                    field = opts.get_field(field_name)\n+                    add_to_dict(workset, opts, field)\n+                except FieldDoesNotExist:\n+                    # Handle related field lookups\n+                    parts = field_name.split(LOOKUP_SEP)\n+                    for m in get_child_with_renamed_table(target, parts[:-1], opts):\n+                        field = m.get_field(parts[-1])\n+                        add_to_dict(workset, m, field)\n+            \n+            # Add must_include fields\n+            must_include = {}\n+            for field in opts.concrete_fields:\n+                if field.primary_key:\n+                    add_to_dict(must_include, opts, field)\n+            for parent in opts.get_parent_list():\n+                link = opts.get_ancestor_link(parent)\n+                add_to_dict(must_include, parent, link)\n+            \n+            # Merge must_include into workset\n+            for model, values in must_include.items():\n+                if model in workset:\n+                    workset[model].update(values)\n+            \n+            # Process final field set\n+            for model, values in workset.items():\n+                callback(target, model, values)\n+                self.deferred_loading = field_names, self.deferred_loading[1]\n+            else:\n+                # When field_names is empty but immediate_loading exists,\n+                # this means defer() removed all fields from only().\n+                # Continue to must_include processing instead of early return.\n+                self.deferred_loading = field_names, self.deferred_loading[1]\n             # Now ensure that every model in the inheritance chain is mentioned\n             # in the parent list. Again, it must be mentioned to ensure that\n             # only \"must include\" fields are pulled in.\n",
    "variant_8": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8837881579..c010d5f5c2 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -678,11 +678,18 @@ class Query(BaseExpression):\n         \"target\", and the model and list of fields being added for that model.\n         \"\"\"\n         field_names, defer = self.deferred_loading\n-        if not field_names:\n+\n+        field_names, defer = self.deferred_loading\n+        if not field_names and defer:\n+            return\n+        orig_opts = self.get_meta()\n+        seen = {}\n+\n+        field_names, defer = self.deferred_loading\n+        if not field_names and defer:\n             return\n         orig_opts = self.get_meta()\n         seen = {}\n-        must_include = {orig_opts.concrete_model: {orig_opts.pk}}\n         for field_name in field_names:\n             parts = field_name.split(LOOKUP_SEP)\n             cur_model = self.model._meta.concrete_model\n@@ -732,6 +739,7 @@ class Query(BaseExpression):\n                     workset[model].update(values)\n             for model, values in workset.items():\n                 callback(target, model, values)\n+\n         else:\n             for model, values in must_include.items():\n                 if model in seen:\n@@ -748,6 +756,18 @@ class Query(BaseExpression):\n                 seen.setdefault(model, set())\n             for model, values in seen.items():\n                 callback(target, model, values)\n+                return\n+        if field_names and not only_load:\n+            # Empty field_names is a no-op, so only continue if field_names is\n+            # non-empty or only_load is non-empty.\n+            return\n+            # Now ensure that every model in the inheritance chain is mentioned\n+            # in the parent list. Again, it must be mentioned to ensure that\n+            # only \"must include\" fields are pulled in.\n+            for model in orig_opts.get_parent_list():\n+                seen.setdefault(model, set())\n+            for model, values in seen.items():\n+                callback(target, model, values)\n \n     def table_alias(self, table_name, create=False, filtered_relation=None):\n         \"\"\"\n"
  }
}