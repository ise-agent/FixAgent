{
  "zero_patches": {
    "Location 1 (/root/hy/projects/astropy/astropy/io/fits/header.py lines 330-358)": "\n    @classmethod\n    def fromstring(cls, data, sep=''):\n        \"\"\"\n        Creates an HDU header from a byte string containing the entire header\n        data.\n\n        Parameters\n        ----------\n        data : str or bytes\n           String or bytes containing the entire header.\n\n        sep : str or bytes, optional\n            The string separating cards from each other, such as a newline.  By\n            default there is no card separator (as is the case in a raw FITS\n            file).\n\n        Returns\n        -------\n        header\n            A new `Header` instance.\n        \"\"\"\n\n        # Handle bytes input by decoding to string\n        if isinstance(data, bytes):\n            data = data.decode('ascii')\n        \n        if isinstance(sep, bytes):\n            sep = sep.decode('ascii')\n\n        cards = []\n\n        # If the card separator contains characters that may validly appear in\n        # a card, the only way to unambiguously distinguish between cards is to\n        # require that they be Card.length long.  However, if the separator\n        # contains non-valid characters (namely \\n) the cards may be split\n        # immediately at the separator\n        require_full_cardlength = set(sep).issubset(VALID_HEADER_CHARS)\n",
    "Location 2 (/root/hy/projects/astropy/astropy/io/fits/header.py lines 376-380)": "\n            if image:\n                if next_image[:8] == 'CONTINUE':\n                    image.append(next_image)\n                    continue\n                cards.append(Card.fromstring(''.join(image)))\n",
    "Location 3 (/root/hy/projects/astropy/astropy/io/fits/header.py lines 382-389)": "\n            if require_full_cardlength:\n                if isinstance(data, bytes) and next_image == END_CARD.encode('ascii'):\n                    image = []\n                    break\n                elif isinstance(data, str) and next_image == END_CARD:\n                    image = []\n                    break\n            else:\n                end_keyword = 'END'.encode('ascii') if isinstance(data, bytes) else 'END'\n                if next_image.split(sep)[0].rstrip() == end_keyword:\n                    image = []\n                    break\n",
    "Location 4 (/root/hy/projects/astropy/astropy/io/fits/header.py lines 394-395)": "\n        # Add the last image that was found before the end, if any\n        if image:\n            cards.append(Card.fromstring(''.join(image)))\n",
    "Location 5 (/root/hy/projects/astropy/astropy/io/fits/card.py lines 548-559)": "\n    @classmethod\n    def fromstring(cls, image):\n        \"\"\"\n        Construct a `Card` object from a (raw) string or bytes. It will pad the string\n        if it is not the length of a card image (80 columns).  If the card\n        image is longer than 80 columns, assume it contains ``CONTINUE``\n        card(s).\n        \"\"\"\n        # Handle bytes input by decoding to string\n        if isinstance(image, bytes):\n            image = image.decode('ascii')\n\n        card = cls()\n        card._image = _pad(image)\n        card._verified = False\n        return card\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects/astropy/astropy/io/fits/header.py lines 330-358)": [
      "\n    @classmethod\n    def fromstring(cls, data, sep=''):\n        \"\"\"\n        Creates an HDU header from a byte string containing the entire header\n        data.\n\n        Parameters\n        ----------\n        data : str or bytes\n           String or bytes containing the entire header.\n\n        sep : str or bytes, optional\n            The string separating cards from each other, such as a newline.  By\n            default there is no card separator (as is the case in a raw FITS\n            file).\n\n        Returns\n        -------\n        header\n            A new `Header` instance.\n        \"\"\"\n\n        # Handle bytes input by decoding to string\n        if isinstance(data, bytes):\n            data = data.decode('ascii')\n        if isinstance(sep, bytes):\n            sep = sep.decode('ascii')\n\n        cards = []\n\n        # If the card separator contains characters that may validly appear in\n        # a card, the only way to unambiguously distinguish between cards is to\n        # require that they be Card.length long.  However, if the separator\n        # contains non-valid characters (namely \\n) the cards may be split\n        # immediately at the separator\n        require_full_cardlength = set(sep).issubset(VALID_HEADER_CHARS)\n",
      "\n    @classmethod\n    def fromstring(cls, data, sep=''):\n        \"\"\"\n        Creates an HDU header from a byte string containing the entire header\n        data.\n\n        Parameters\n        ----------\n        data : str or bytes\n           String or bytes containing the entire header.\n\n        sep : str or bytes, optional\n            The string separating cards from each other, such as a newline.  By\n            default there is no card separator (as is the case in a raw FITS\n            file).\n\n        Returns\n        -------\n        header\n            A new `Header` instance.\n        \"\"\"\n        \n        # Handle bytes input by decoding to string\n        if isinstance(data, bytes):\n            data = data.decode('ascii')\n        if isinstance(sep, bytes):\n            sep = sep.decode('ascii')\n\n        cards = []\n\n        # If the card separator contains characters that may validly appear in\n        # a card, the only way to unambiguously distinguish between cards is to\n        # require that they be Card.length long.  However, if the separator\n        # contains non-valid characters (namely \\n) the cards may be split\n        # immediately at the separator\n        require_full_cardlength = set(sep).issubset(VALID_HEADER_CHARS)\n",
      "\n    @classmethod\n    def fromstring(cls, data, sep=''):\n        \"\"\"\n        Creates an HDU header from a byte string containing the entire header\n        data.\n\n        Parameters\n        ----------\n        data : str or bytes\n           String or bytes containing the entire header.\n\n        sep : str or bytes, optional\n            The string separating cards from each other, such as a newline.  By\n            default there is no card separator (as is the case in a raw FITS\n            file).\n\n        Returns\n        -------\n        header\n            A new `Header` instance.\n        \"\"\"\n\n        # Handle bytes input by decoding to string\n        if isinstance(data, bytes):\n            data = data.decode('ascii')\n        if isinstance(sep, bytes):\n            sep = sep.decode('ascii')\n\n        cards = []\n\n        # If the card separator contains characters that may validly appear in\n        # a card, the only way to unambiguously distinguish between cards is to\n        # require that they be Card.length long.  However, if the separator\n        # contains non-valid characters (namely \\n) the cards may be split\n        # immediately at the separator\n        require_full_cardlength = set(sep).issubset(VALID_HEADER_CHARS)\n",
      "\n    @classmethod\n    def fromstring(cls, data, sep=''):\n        \"\"\"\n        Creates an HDU header from a byte string containing the entire header\n        data.\n\n        Parameters\n        ----------\n        data : str or bytes\n           String or bytes containing the entire header.\n\n        sep : str or bytes, optional\n            The string separating cards from each other, such as a newline.  By\n            default there is no card separator (as is the case in a raw FITS\n            file).\n\n        Returns\n        -------\n        header\n            A new `Header` instance.\n        \"\"\"\n\n        # Handle bytes input by decoding to string\n        if isinstance(data, bytes):\n            data = data.decode('ascii')\n        if isinstance(sep, bytes):\n            sep = sep.decode('ascii')\n\n        cards = []\n\n        # If the card separator contains characters that may validly appear in\n        # a card, the only way to unambiguously distinguish between cards is to\n        # require that they be Card.length long.  However, if the separator\n        # contains non-valid characters (namely \\n) the cards may be split\n        # immediately at the separator\n        require_full_cardlength = set(sep).issubset(VALID_HEADER_CHARS)\n",
      "\n    @classmethod\n    def fromstring(cls, data, sep=''):\n        \"\"\"\n        Creates an HDU header from a byte string containing the entire header\n        data.\n\n        Parameters\n        ----------\n        data : str or bytes\n           String or bytes containing the entire header.\n\n        sep : str or bytes, optional\n            The string separating cards from each other, such as a newline.  By\n            default there is no card separator (as is the case in a raw FITS\n            file).\n\n        Returns\n        -------\n        header\n            A new `Header` instance.\n        \"\"\"\n\n        # Handle bytes input by decoding to string\n        if isinstance(data, bytes):\n            data = data.decode('ascii')\n        if isinstance(sep, bytes):\n            sep = sep.decode('ascii')\n\n        cards = []\n\n        # If the card separator contains characters that may validly appear in\n        # a card, the only way to unambiguously distinguish between cards is to\n        # require that they be Card.length long.  However, if the separator\n        # contains non-valid characters (namely \\n) the cards may be split\n        # immediately at the separator\n        require_full_cardlength = set(sep).issubset(VALID_HEADER_CHARS)\n",
      "\n    @classmethod\n    def fromstring(cls, data, sep=''):\n        \"\"\"\n        Creates an HDU header from a byte string containing the entire header\n        data.\n\n        Parameters\n        ----------\n        data : str or bytes\n           String or bytes containing the entire header.\n\n        sep : str or bytes, optional\n            The string separating cards from each other, such as a newline.  By\n            default there is no card separator (as is the case in a raw FITS\n            file).\n\n        Returns\n        -------\n        header\n            A new `Header` instance.\n        \"\"\"\n        \n        # Handle bytes input by decoding to string\n        if isinstance(data, bytes):\n            data = data.decode('ascii')\n        \n        # Handle bytes separator by decoding to string\n        if isinstance(sep, bytes):\n            sep = sep.decode('ascii')\n\n        cards = []\n\n        # If the card separator contains characters that may validly appear in\n        # a card, the only way to unambiguously distinguish between cards is to\n        # require that they be Card.length long.  However, if the separator\n        # contains non-valid characters (namely \\n) the cards may be split\n        # immediately at the separator\n        require_full_cardlength = set(sep).issubset(VALID_HEADER_CHARS)\n",
      "\n    @classmethod\n    def fromstring(cls, data, sep=''):\n        \"\"\"\n        Creates an HDU header from a byte string containing the entire header\n        data.\n\n        Parameters\n        ----------\n        data : str or bytes\n           String or bytes containing the entire header.\n\n        sep : str or bytes, optional\n            The string separating cards from each other, such as a newline.  By\n            default there is no card separator (as is the case in a raw FITS\n            file).\n\n        Returns\n        -------\n        header\n            A new `Header` instance.\n        \"\"\"\n\n        # Handle bytes input by decoding to string\n        if isinstance(data, bytes):\n            data = data.decode('ascii')\n        if isinstance(sep, bytes):\n            sep = sep.decode('ascii')\n\n        cards = []\n\n        # If the card separator contains characters that may validly appear in\n        # a card, the only way to unambiguously distinguish between cards is to\n        # require that they be Card.length long.  However, if the separator\n        # contains non-valid characters (namely \\n) the cards may be split\n        # immediately at the separator\n        require_full_cardlength = set(sep).issubset(VALID_HEADER_CHARS)\n",
      "\n    @classmethod\n    def fromstring(cls, data, sep=''):\n        \"\"\"\n        Creates an HDU header from a byte string containing the entire header\n        data.\n\n        Parameters\n        ----------\n        data : str or bytes\n           String or bytes containing the entire header.\n\n        sep : str or bytes, optional\n            The string separating cards from each other, such as a newline.  By\n            default there is no card separator (as is the case in a raw FITS\n            file).\n\n        Returns\n        -------\n        header\n            A new `Header` instance.\n        \"\"\"\n\n        # Handle bytes input by decoding to string\n        if isinstance(data, bytes):\n            data = data.decode('ascii')\n        \n        if isinstance(sep, bytes):\n            sep = sep.decode('ascii')\n\n        cards = []\n\n        # If the card separator contains characters that may validly appear in\n        # a card, the only way to unambiguously distinguish between cards is to\n        # require that they be Card.length long.  However, if the separator\n        # contains non-valid characters (namely \\n) the cards may be split\n        # immediately at the separator\n        require_full_cardlength = set(sep).issubset(VALID_HEADER_CHARS)\n"
    ],
    "Location 2 (/root/hy/projects/astropy/astropy/io/fits/header.py lines 376-380)": [
      "\n            if image:\n                if next_image[:8] == 'CONTINUE':\n                    image.append(next_image)\n                    continue\n                cards.append(Card.fromstring(''.join(image)))\n",
      "\n            if image:\n                if next_image[:8] == 'CONTINUE':\n                    image.append(next_image)\n                    continue\n                cards.append(Card.fromstring(''.join(image)))\n",
      "\n            if image:\n                if next_image[:8] == 'CONTINUE':\n                    image.append(next_image)\n                    continue\n                cards.append(Card.fromstring(''.join(image)))\n",
      "\n            if image:\n                if next_image[:8] == 'CONTINUE':\n                    image.append(next_image)\n                    continue\n                cards.append(Card.fromstring(''.join(image)))\n",
      "\n            if image:\n                if next_image[:8] == 'CONTINUE':\n                    image.append(next_image)\n                    continue\n                cards.append(Card.fromstring(''.join(image)))\n",
      "\n            if image:\n                if next_image[:8] == 'CONTINUE':\n                    image.append(next_image)\n                    continue\n                cards.append(Card.fromstring(''.join(image)))\n",
      "\n            if image:\n                if next_image[:8] == 'CONTINUE':\n                    image.append(next_image)\n                    continue\n                cards.append(Card.fromstring(''.join(image)))\n",
      "\n            if image:\n                if next_image[:8] == 'CONTINUE':\n                    image.append(next_image)\n                    continue\n                cards.append(Card.fromstring(''.join(image)))\n"
    ],
    "Location 3 (/root/hy/projects/astropy/astropy/io/fits/header.py lines 382-389)": [
      "\n        if require_full_cardlength:\n            if next_image == END_CARD:\n                image = []\n                break\n        else:\n            if next_image.split(sep)[0].rstrip() == 'END':\n                image = []\n                break\n",
      "\n            if require_full_cardlength:\n                if isinstance(next_image, bytes):\n                    next_image_str = decode_ascii(next_image)\n                else:\n                    next_image_str = next_image\n                if next_image_str == END_CARD:\n                    image = []\n                    break\n            else:\n                if isinstance(next_image, bytes):\n                    next_image_str = decode_ascii(next_image)\n                else:\n                    next_image_str = next_image\n                if next_image_str.split(sep)[0].rstrip() == 'END':\n                    image = []\n                    break\n",
      "\n            if require_full_cardlength:\n                if isinstance(next_image, bytes):\n                    next_image = next_image.decode('ascii')\n                if next_image == END_CARD:\n                    image = []\n                    break\n            else:\n                if isinstance(next_image, bytes):\n                    next_image = next_image.decode('ascii')\n                if next_image.split(sep)[0].rstrip() == 'END':\n                    image = []\n                    break\n",
      "\n            if require_full_cardlength:\n                if isinstance(next_image, bytes):\n                    next_image = next_image.decode('ascii')\n                if next_image == END_CARD:\n                    image = []\n                    break\n            else:\n                if isinstance(next_image, bytes):\n                    next_image = next_image.decode('ascii')\n                if next_image.split(sep)[0].rstrip() == 'END':\n                    image = []\n                    break\n",
      "\n            if require_full_cardlength:\n                if isinstance(next_image, bytes):\n                    next_image_str = decode_ascii(next_image)\n                else:\n                    next_image_str = next_image\n                if next_image_str == END_CARD:\n                    image = []\n                    break\n            else:\n                if isinstance(next_image, bytes):\n                    next_image_str = decode_ascii(next_image)\n                else:\n                    next_image_str = next_image\n                if next_image_str.split(sep)[0].rstrip() == 'END':\n                    image = []\n                    break\n",
      "\n            if require_full_cardlength:\n                if isinstance(next_image, bytes):\n                    next_image_str = next_image.decode('ascii', errors='replace')\n                else:\n                    next_image_str = next_image\n                if next_image_str == END_CARD:\n                    image = []\n                    break\n            else:\n                if isinstance(next_image, bytes):\n                    next_image_str = next_image.decode('ascii', errors='replace')\n                else:\n                    next_image_str = next_image\n                if next_image_str.split(sep)[0].rstrip() == 'END':\n                    image = []\n                    break\n",
      "\n        if require_full_cardlength:\n            if next_image == END_CARD:\n                image = []\n                break\n        else:\n            if next_image.split(sep)[0].rstrip() == 'END':\n                image = []\n                break\n",
      "\n            if require_full_cardlength:\n                if isinstance(next_image, bytes):\n                    next_image_str = next_image.decode('ascii', errors='replace')\n                    if next_image_str == END_CARD:\n                        image = []\n                        break\n                else:\n                    if next_image == END_CARD:\n                        image = []\n                        break\n            else:\n                if isinstance(next_image, bytes):\n                    next_image_str = next_image.decode('ascii', errors='replace')\n                    if next_image_str.split(sep)[0].rstrip() == 'END':\n                        image = []\n                        break\n                else:\n                    if next_image.split(sep)[0].rstrip() == 'END':\n                        image = []\n                        break\n"
    ],
    "Location 4 (/root/hy/projects/astropy/astropy/io/fits/header.py lines 394-395)": [
      "\n        # Add the last image that was found before the end, if any\n        if image:\n            cards.append(Card.fromstring(''.join(image)))\n",
      "\n        # Add the last image that was found before the end, if any\n        if image:\n            cards.append(Card.fromstring(''.join(image)))\n",
      "\n        # Add the last image that was found before the end, if any\n        if image:\n            cards.append(Card.fromstring(''.join(image)))\n",
      "\n        # Add the last image that was found before the end, if any\n        if image:\n            cards.append(Card.fromstring(''.join(image)))\n",
      "\n        # Add the last image that was found before the end, if any\n        if image:\n            cards.append(Card.fromstring(''.join(image)))\n",
      "\n        # Add the last image that was found before the end, if any\n        if image:\n            cards.append(Card.fromstring(''.join(image)))\n",
      "\n        # Add the last image that was found before the end, if any\n        if image:\n            cards.append(Card.fromstring(''.join(image)))\n",
      "\n        # Add the last image that was found before the end, if any\n        if image:\n            cards.append(Card.fromstring(''.join(image)))\n"
    ],
    "Location 5 (/root/hy/projects/astropy/astropy/io/fits/card.py lines 548-559)": [
      "\n    @classmethod\n    def fromstring(cls, image):\n        \"\"\"\n        Construct a `Card` object from a (raw) string or bytes. It will pad the string\n        if it is not the length of a card image (80 columns).  If the card\n        image is longer than 80 columns, assume it contains ``CONTINUE``\n        card(s).\n        \"\"\"\n        \n        # Convert bytes to string if necessary\n        if isinstance(image, bytes):\n            image = image.decode('ascii')\n\n        card = cls()\n        card._image = _pad(image)\n        card._verified = False\n        return card\n",
      "\n    @classmethod\n    def fromstring(cls, image):\n        \"\"\"\n        Construct a `Card` object from a (raw) string or bytes. It will pad the string\n        if it is not the length of a card image (80 columns).  If the card\n        image is longer than 80 columns, assume it contains ``CONTINUE``\n        card(s).\n        \"\"\"\n        \n        # Handle bytes input by decoding to string\n        if isinstance(image, bytes):\n            image = image.decode('ascii')\n\n        card = cls()\n        card._image = _pad(image)\n        card._verified = False\n        return card\n",
      "\n    @classmethod\n    def fromstring(cls, image):\n        \"\"\"\n        Construct a `Card` object from a (raw) string or bytes. It will pad the string\n        if it is not the length of a card image (80 columns).  If the card\n        image is longer than 80 columns, assume it contains ``CONTINUE``\n        card(s).\n        \"\"\"\n        \n        # Convert bytes to string if necessary\n        if isinstance(image, bytes):\n            image = image.decode('ascii')\n\n        card = cls()\n        card._image = _pad(image)\n        card._verified = False\n        return card\n",
      "\n    @classmethod\n    def fromstring(cls, image):\n        \"\"\"\n        Construct a `Card` object from a (raw) string or bytes. It will pad the string\n        if it is not the length of a card image (80 columns).  If the card\n        image is longer than 80 columns, assume it contains ``CONTINUE``\n        card(s).\n        \"\"\"\n        \n        # Handle bytes input by decoding to string\n        if isinstance(image, bytes):\n            image = image.decode('ascii')\n\n        card = cls()\n        card._image = _pad(image)\n        card._verified = False\n        return card\n",
      "\n    @classmethod\n    def fromstring(cls, image):\n        \"\"\"\n        Construct a `Card` object from a (raw) string or bytes. It will pad the string\n        if it is not the length of a card image (80 columns).  If the card\n        image is longer than 80 columns, assume it contains ``CONTINUE``\n        card(s).\n        \"\"\"\n        \n        # Handle bytes input by decoding to string\n        if isinstance(image, bytes):\n            image = image.decode('ascii')\n\n        card = cls()\n        card._image = _pad(image)\n        card._verified = False\n        return card\n",
      "\n    @classmethod\n    def fromstring(cls, image):\n        \"\"\"\n        Construct a `Card` object from a (raw) string or bytes. It will pad the string\n        if it is not the length of a card image (80 columns).  If the card\n        image is longer than 80 columns, assume it contains ``CONTINUE``\n        card(s).\n        \"\"\"\n        \n        # Convert bytes to string if necessary\n        if isinstance(image, bytes):\n            image = image.decode('ascii')\n\n        card = cls()\n        card._image = _pad(image)\n        card._verified = False\n        return card\n",
      "\n    @classmethod\n    def fromstring(cls, image):\n        \"\"\"\n        Construct a `Card` object from a (raw) string or bytes. It will pad the string\n        if it is not the length of a card image (80 columns).  If the card\n        image is longer than 80 columns, assume it contains ``CONTINUE``\n        card(s).\n        \"\"\"\n        \n        # Handle bytes input by decoding to string\n        if isinstance(image, bytes):\n            image = image.decode('ascii')\n\n        card = cls()\n        card._image = _pad(image)\n        card._verified = False\n        return card\n",
      "\n    @classmethod\n    def fromstring(cls, image):\n        \"\"\"\n        Construct a `Card` object from a (raw) string or bytes. It will pad the string\n        if it is not the length of a card image (80 columns).  If the card\n        image is longer than 80 columns, assume it contains ``CONTINUE``\n        card(s).\n        \"\"\"\n        \n        # Convert bytes to string if necessary\n        if isinstance(image, bytes):\n            image = image.decode('ascii')\n\n        card = cls()\n        card._image = _pad(image)\n        card._verified = False\n        return card\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/astropy/io/fits/card.py b/astropy/io/fits/card.py\nindex 8c1ac5d738..4624d42f4e 100644\n--- a/astropy/io/fits/card.py\n+++ b/astropy/io/fits/card.py\n@@ -544,15 +544,23 @@ class Card(_Verify):\n                 (isinstance(self.value, str) and not self.value) and\n                 not self.comment)\n \n+    @classmethod\n+\n     @classmethod\n     def fromstring(cls, image):\n         \"\"\"\n-        Construct a `Card` object from a (raw) string. It will pad the string\n+        Construct a `Card` object from a (raw) string or bytes. It will pad the string\n         if it is not the length of a card image (80 columns).  If the card\n         image is longer than 80 columns, assume it contains ``CONTINUE``\n         card(s).\n         \"\"\"\n \n+        # Handle bytes input by decoding to string using ASCII\n+        if isinstance(image, bytes):\n+            # Import decode_ascii from util module\n+            from .util import decode_ascii\n+            image = decode_ascii(image)\n+\n         card = cls()\n         card._image = _pad(image)\n         card._verified = False\ndiff --git a/astropy/io/fits/header.py b/astropy/io/fits/header.py\nindex ad07e6d52d..5a60e4f658 100644\n--- a/astropy/io/fits/header.py\n+++ b/astropy/io/fits/header.py\n@@ -326,6 +326,8 @@ class Header:\n     def _modified(self, val):\n         self.__dict__['_modified'] = val\n \n+    @classmethod\n+\n     @classmethod\n     def fromstring(cls, data, sep=''):\n         \"\"\"\n@@ -334,10 +336,10 @@ class Header:\n \n         Parameters\n         ----------\n-        data : str\n-           String containing the entire header.\n+        data : str or bytes\n+           String or bytes containing the entire header.\n \n-        sep : str, optional\n+        sep : str or bytes, optional\n             The string separating cards from each other, such as a newline.  By\n             default there is no card separator (as is the case in a raw FITS\n             file).\n@@ -348,6 +350,12 @@ class Header:\n             A new `Header` instance.\n         \"\"\"\n \n+        # Handle bytes input by decoding to string using ASCII\n+        if isinstance(data, bytes):\n+            data = decode_ascii(data)\n+        if isinstance(sep, bytes):\n+            sep = decode_ascii(sep)\n+\n         cards = []\n \n         # If the card separator contains characters that may validly appear in\n@@ -373,12 +381,14 @@ class Header:\n             next_image = data[idx:end_idx]\n             idx = end_idx + len(sep)\n \n+\n             if image:\n                 if next_image[:8] == 'CONTINUE':\n                     image.append(next_image)\n                     continue\n                 cards.append(Card.fromstring(''.join(image)))\n \n+\n             if require_full_cardlength:\n                 if next_image == END_CARD:\n                     image = []\n@@ -391,6 +401,7 @@ class Header:\n             image = [next_image]\n \n         # Add the last image that was found before the end, if any\n+\n         if image:\n             cards.append(Card.fromstring(''.join(image)))\n \n",
    "variant_0": "diff --git a/astropy/io/fits/card.py b/astropy/io/fits/card.py\nindex 8c1ac5d738..951f0c0837 100644\n--- a/astropy/io/fits/card.py\n+++ b/astropy/io/fits/card.py\n@@ -544,14 +544,19 @@ class Card(_Verify):\n                 (isinstance(self.value, str) and not self.value) and\n                 not self.comment)\n \n+    @classmethod\n+\n     @classmethod\n     def fromstring(cls, image):\n         \"\"\"\n-        Construct a `Card` object from a (raw) string. It will pad the string\n+        Construct a `Card` object from a (raw) string or bytes. It will pad the string\n         if it is not the length of a card image (80 columns).  If the card\n         image is longer than 80 columns, assume it contains ``CONTINUE``\n         card(s).\n         \"\"\"\n+        # Handle bytes input by decoding to string\n+        if isinstance(image, bytes):\n+            image = image.decode('ascii')\n \n         card = cls()\n         card._image = _pad(image)\ndiff --git a/astropy/io/fits/header.py b/astropy/io/fits/header.py\nindex ad07e6d52d..efa8790f5a 100644\n--- a/astropy/io/fits/header.py\n+++ b/astropy/io/fits/header.py\n@@ -326,6 +326,8 @@ class Header:\n     def _modified(self, val):\n         self.__dict__['_modified'] = val\n \n+    @classmethod\n+\n     @classmethod\n     def fromstring(cls, data, sep=''):\n         \"\"\"\n@@ -334,10 +336,10 @@ class Header:\n \n         Parameters\n         ----------\n-        data : str\n-           String containing the entire header.\n+        data : str or bytes\n+           String or bytes containing the entire header.\n \n-        sep : str, optional\n+        sep : str or bytes, optional\n             The string separating cards from each other, such as a newline.  By\n             default there is no card separator (as is the case in a raw FITS\n             file).\n@@ -348,6 +350,13 @@ class Header:\n             A new `Header` instance.\n         \"\"\"\n \n+        # Handle bytes input by decoding to string\n+        if isinstance(data, bytes):\n+            data = data.decode('ascii')\n+        \n+        if isinstance(sep, bytes):\n+            sep = sep.decode('ascii')\n+\n         cards = []\n \n         # If the card separator contains characters that may validly appear in\n@@ -373,23 +382,31 @@ class Header:\n             next_image = data[idx:end_idx]\n             idx = end_idx + len(sep)\n \n+\n             if image:\n                 if next_image[:8] == 'CONTINUE':\n                     image.append(next_image)\n                     continue\n                 cards.append(Card.fromstring(''.join(image)))\n \n+\n             if require_full_cardlength:\n-                if next_image == END_CARD:\n+                if isinstance(data, bytes) and next_image == END_CARD.encode('ascii'):\n+                    image = []\n+                    break\n+                elif isinstance(data, str) and next_image == END_CARD:\n                     image = []\n                     break\n             else:\n-                if next_image.split(sep)[0].rstrip() == 'END':\n+                end_keyword = 'END'.encode('ascii') if isinstance(data, bytes) else 'END'\n+                if next_image.split(sep)[0].rstrip() == end_keyword:\n                     image = []\n                     break\n \n             image = [next_image]\n \n+        # Add the last image that was found before the end, if any\n+\n         # Add the last image that was found before the end, if any\n         if image:\n             cards.append(Card.fromstring(''.join(image)))\n",
    "variant_1": "diff --git a/astropy/io/fits/card.py b/astropy/io/fits/card.py\nindex 8c1ac5d738..155c036caa 100644\n--- a/astropy/io/fits/card.py\n+++ b/astropy/io/fits/card.py\n@@ -544,14 +544,20 @@ class Card(_Verify):\n                 (isinstance(self.value, str) and not self.value) and\n                 not self.comment)\n \n+    @classmethod\n+\n     @classmethod\n     def fromstring(cls, image):\n         \"\"\"\n-        Construct a `Card` object from a (raw) string. It will pad the string\n+        Construct a `Card` object from a (raw) string or bytes. It will pad the string\n         if it is not the length of a card image (80 columns).  If the card\n         image is longer than 80 columns, assume it contains ``CONTINUE``\n         card(s).\n         \"\"\"\n+        \n+        # Convert bytes to string if necessary\n+        if isinstance(image, bytes):\n+            image = image.decode('ascii')\n \n         card = cls()\n         card._image = _pad(image)\ndiff --git a/astropy/io/fits/header.py b/astropy/io/fits/header.py\nindex ad07e6d52d..ce5c403a4f 100644\n--- a/astropy/io/fits/header.py\n+++ b/astropy/io/fits/header.py\n@@ -326,6 +326,8 @@ class Header:\n     def _modified(self, val):\n         self.__dict__['_modified'] = val\n \n+    @classmethod\n+\n     @classmethod\n     def fromstring(cls, data, sep=''):\n         \"\"\"\n@@ -334,10 +336,10 @@ class Header:\n \n         Parameters\n         ----------\n-        data : str\n-           String containing the entire header.\n+        data : str or bytes\n+           String or bytes containing the entire header.\n \n-        sep : str, optional\n+        sep : str or bytes, optional\n             The string separating cards from each other, such as a newline.  By\n             default there is no card separator (as is the case in a raw FITS\n             file).\n@@ -348,6 +350,12 @@ class Header:\n             A new `Header` instance.\n         \"\"\"\n \n+        # Handle bytes input by decoding to string\n+        if isinstance(data, bytes):\n+            data = data.decode('ascii')\n+        if isinstance(sep, bytes):\n+            sep = sep.decode('ascii')\n+\n         cards = []\n \n         # If the card separator contains characters that may validly appear in\n@@ -373,23 +381,27 @@ class Header:\n             next_image = data[idx:end_idx]\n             idx = end_idx + len(sep)\n \n+\n             if image:\n                 if next_image[:8] == 'CONTINUE':\n                     image.append(next_image)\n                     continue\n                 cards.append(Card.fromstring(''.join(image)))\n \n-            if require_full_cardlength:\n-                if next_image == END_CARD:\n-                    image = []\n-                    break\n-            else:\n-                if next_image.split(sep)[0].rstrip() == 'END':\n-                    image = []\n-                    break\n+\n+        if require_full_cardlength:\n+            if next_image == END_CARD:\n+                image = []\n+                break\n+        else:\n+            if next_image.split(sep)[0].rstrip() == 'END':\n+                image = []\n+                break\n \n             image = [next_image]\n \n+        # Add the last image that was found before the end, if any\n+\n         # Add the last image that was found before the end, if any\n         if image:\n             cards.append(Card.fromstring(''.join(image)))\n",
    "variant_2": "diff --git a/astropy/io/fits/card.py b/astropy/io/fits/card.py\nindex 8c1ac5d738..fadc72f4e0 100644\n--- a/astropy/io/fits/card.py\n+++ b/astropy/io/fits/card.py\n@@ -544,14 +544,20 @@ class Card(_Verify):\n                 (isinstance(self.value, str) and not self.value) and\n                 not self.comment)\n \n+    @classmethod\n+\n     @classmethod\n     def fromstring(cls, image):\n         \"\"\"\n-        Construct a `Card` object from a (raw) string. It will pad the string\n+        Construct a `Card` object from a (raw) string or bytes. It will pad the string\n         if it is not the length of a card image (80 columns).  If the card\n         image is longer than 80 columns, assume it contains ``CONTINUE``\n         card(s).\n         \"\"\"\n+        \n+        # Handle bytes input by decoding to string\n+        if isinstance(image, bytes):\n+            image = image.decode('ascii')\n \n         card = cls()\n         card._image = _pad(image)\ndiff --git a/astropy/io/fits/header.py b/astropy/io/fits/header.py\nindex ad07e6d52d..9af7fc5e43 100644\n--- a/astropy/io/fits/header.py\n+++ b/astropy/io/fits/header.py\n@@ -326,6 +326,8 @@ class Header:\n     def _modified(self, val):\n         self.__dict__['_modified'] = val\n \n+    @classmethod\n+\n     @classmethod\n     def fromstring(cls, data, sep=''):\n         \"\"\"\n@@ -334,10 +336,10 @@ class Header:\n \n         Parameters\n         ----------\n-        data : str\n-           String containing the entire header.\n+        data : str or bytes\n+           String or bytes containing the entire header.\n \n-        sep : str, optional\n+        sep : str or bytes, optional\n             The string separating cards from each other, such as a newline.  By\n             default there is no card separator (as is the case in a raw FITS\n             file).\n@@ -347,6 +349,12 @@ class Header:\n         header\n             A new `Header` instance.\n         \"\"\"\n+        \n+        # Handle bytes input by decoding to string\n+        if isinstance(data, bytes):\n+            data = data.decode('ascii')\n+        if isinstance(sep, bytes):\n+            sep = sep.decode('ascii')\n \n         cards = []\n \n@@ -373,23 +381,35 @@ class Header:\n             next_image = data[idx:end_idx]\n             idx = end_idx + len(sep)\n \n+\n             if image:\n                 if next_image[:8] == 'CONTINUE':\n                     image.append(next_image)\n                     continue\n                 cards.append(Card.fromstring(''.join(image)))\n \n+\n             if require_full_cardlength:\n-                if next_image == END_CARD:\n+                if isinstance(next_image, bytes):\n+                    next_image_str = decode_ascii(next_image)\n+                else:\n+                    next_image_str = next_image\n+                if next_image_str == END_CARD:\n                     image = []\n                     break\n             else:\n-                if next_image.split(sep)[0].rstrip() == 'END':\n+                if isinstance(next_image, bytes):\n+                    next_image_str = decode_ascii(next_image)\n+                else:\n+                    next_image_str = next_image\n+                if next_image_str.split(sep)[0].rstrip() == 'END':\n                     image = []\n                     break\n \n             image = [next_image]\n \n+        # Add the last image that was found before the end, if any\n+\n         # Add the last image that was found before the end, if any\n         if image:\n             cards.append(Card.fromstring(''.join(image)))\n",
    "variant_3": "diff --git a/astropy/io/fits/card.py b/astropy/io/fits/card.py\nindex 8c1ac5d738..155c036caa 100644\n--- a/astropy/io/fits/card.py\n+++ b/astropy/io/fits/card.py\n@@ -544,14 +544,20 @@ class Card(_Verify):\n                 (isinstance(self.value, str) and not self.value) and\n                 not self.comment)\n \n+    @classmethod\n+\n     @classmethod\n     def fromstring(cls, image):\n         \"\"\"\n-        Construct a `Card` object from a (raw) string. It will pad the string\n+        Construct a `Card` object from a (raw) string or bytes. It will pad the string\n         if it is not the length of a card image (80 columns).  If the card\n         image is longer than 80 columns, assume it contains ``CONTINUE``\n         card(s).\n         \"\"\"\n+        \n+        # Convert bytes to string if necessary\n+        if isinstance(image, bytes):\n+            image = image.decode('ascii')\n \n         card = cls()\n         card._image = _pad(image)\ndiff --git a/astropy/io/fits/header.py b/astropy/io/fits/header.py\nindex ad07e6d52d..98baba4294 100644\n--- a/astropy/io/fits/header.py\n+++ b/astropy/io/fits/header.py\n@@ -326,6 +326,8 @@ class Header:\n     def _modified(self, val):\n         self.__dict__['_modified'] = val\n \n+    @classmethod\n+\n     @classmethod\n     def fromstring(cls, data, sep=''):\n         \"\"\"\n@@ -334,10 +336,10 @@ class Header:\n \n         Parameters\n         ----------\n-        data : str\n-           String containing the entire header.\n+        data : str or bytes\n+           String or bytes containing the entire header.\n \n-        sep : str, optional\n+        sep : str or bytes, optional\n             The string separating cards from each other, such as a newline.  By\n             default there is no card separator (as is the case in a raw FITS\n             file).\n@@ -348,6 +350,12 @@ class Header:\n             A new `Header` instance.\n         \"\"\"\n \n+        # Handle bytes input by decoding to string\n+        if isinstance(data, bytes):\n+            data = data.decode('ascii')\n+        if isinstance(sep, bytes):\n+            sep = sep.decode('ascii')\n+\n         cards = []\n \n         # If the card separator contains characters that may validly appear in\n@@ -373,23 +381,31 @@ class Header:\n             next_image = data[idx:end_idx]\n             idx = end_idx + len(sep)\n \n+\n             if image:\n                 if next_image[:8] == 'CONTINUE':\n                     image.append(next_image)\n                     continue\n                 cards.append(Card.fromstring(''.join(image)))\n \n+\n             if require_full_cardlength:\n+                if isinstance(next_image, bytes):\n+                    next_image = next_image.decode('ascii')\n                 if next_image == END_CARD:\n                     image = []\n                     break\n             else:\n+                if isinstance(next_image, bytes):\n+                    next_image = next_image.decode('ascii')\n                 if next_image.split(sep)[0].rstrip() == 'END':\n                     image = []\n                     break\n \n             image = [next_image]\n \n+        # Add the last image that was found before the end, if any\n+\n         # Add the last image that was found before the end, if any\n         if image:\n             cards.append(Card.fromstring(''.join(image)))\n",
    "variant_4": "diff --git a/astropy/io/fits/card.py b/astropy/io/fits/card.py\nindex 8c1ac5d738..fadc72f4e0 100644\n--- a/astropy/io/fits/card.py\n+++ b/astropy/io/fits/card.py\n@@ -544,14 +544,20 @@ class Card(_Verify):\n                 (isinstance(self.value, str) and not self.value) and\n                 not self.comment)\n \n+    @classmethod\n+\n     @classmethod\n     def fromstring(cls, image):\n         \"\"\"\n-        Construct a `Card` object from a (raw) string. It will pad the string\n+        Construct a `Card` object from a (raw) string or bytes. It will pad the string\n         if it is not the length of a card image (80 columns).  If the card\n         image is longer than 80 columns, assume it contains ``CONTINUE``\n         card(s).\n         \"\"\"\n+        \n+        # Handle bytes input by decoding to string\n+        if isinstance(image, bytes):\n+            image = image.decode('ascii')\n \n         card = cls()\n         card._image = _pad(image)\ndiff --git a/astropy/io/fits/header.py b/astropy/io/fits/header.py\nindex ad07e6d52d..98baba4294 100644\n--- a/astropy/io/fits/header.py\n+++ b/astropy/io/fits/header.py\n@@ -326,6 +326,8 @@ class Header:\n     def _modified(self, val):\n         self.__dict__['_modified'] = val\n \n+    @classmethod\n+\n     @classmethod\n     def fromstring(cls, data, sep=''):\n         \"\"\"\n@@ -334,10 +336,10 @@ class Header:\n \n         Parameters\n         ----------\n-        data : str\n-           String containing the entire header.\n+        data : str or bytes\n+           String or bytes containing the entire header.\n \n-        sep : str, optional\n+        sep : str or bytes, optional\n             The string separating cards from each other, such as a newline.  By\n             default there is no card separator (as is the case in a raw FITS\n             file).\n@@ -348,6 +350,12 @@ class Header:\n             A new `Header` instance.\n         \"\"\"\n \n+        # Handle bytes input by decoding to string\n+        if isinstance(data, bytes):\n+            data = data.decode('ascii')\n+        if isinstance(sep, bytes):\n+            sep = sep.decode('ascii')\n+\n         cards = []\n \n         # If the card separator contains characters that may validly appear in\n@@ -373,23 +381,31 @@ class Header:\n             next_image = data[idx:end_idx]\n             idx = end_idx + len(sep)\n \n+\n             if image:\n                 if next_image[:8] == 'CONTINUE':\n                     image.append(next_image)\n                     continue\n                 cards.append(Card.fromstring(''.join(image)))\n \n+\n             if require_full_cardlength:\n+                if isinstance(next_image, bytes):\n+                    next_image = next_image.decode('ascii')\n                 if next_image == END_CARD:\n                     image = []\n                     break\n             else:\n+                if isinstance(next_image, bytes):\n+                    next_image = next_image.decode('ascii')\n                 if next_image.split(sep)[0].rstrip() == 'END':\n                     image = []\n                     break\n \n             image = [next_image]\n \n+        # Add the last image that was found before the end, if any\n+\n         # Add the last image that was found before the end, if any\n         if image:\n             cards.append(Card.fromstring(''.join(image)))\n",
    "variant_5": "diff --git a/astropy/io/fits/card.py b/astropy/io/fits/card.py\nindex 8c1ac5d738..fadc72f4e0 100644\n--- a/astropy/io/fits/card.py\n+++ b/astropy/io/fits/card.py\n@@ -544,14 +544,20 @@ class Card(_Verify):\n                 (isinstance(self.value, str) and not self.value) and\n                 not self.comment)\n \n+    @classmethod\n+\n     @classmethod\n     def fromstring(cls, image):\n         \"\"\"\n-        Construct a `Card` object from a (raw) string. It will pad the string\n+        Construct a `Card` object from a (raw) string or bytes. It will pad the string\n         if it is not the length of a card image (80 columns).  If the card\n         image is longer than 80 columns, assume it contains ``CONTINUE``\n         card(s).\n         \"\"\"\n+        \n+        # Handle bytes input by decoding to string\n+        if isinstance(image, bytes):\n+            image = image.decode('ascii')\n \n         card = cls()\n         card._image = _pad(image)\ndiff --git a/astropy/io/fits/header.py b/astropy/io/fits/header.py\nindex ad07e6d52d..bb71046bbc 100644\n--- a/astropy/io/fits/header.py\n+++ b/astropy/io/fits/header.py\n@@ -326,6 +326,8 @@ class Header:\n     def _modified(self, val):\n         self.__dict__['_modified'] = val\n \n+    @classmethod\n+\n     @classmethod\n     def fromstring(cls, data, sep=''):\n         \"\"\"\n@@ -334,10 +336,10 @@ class Header:\n \n         Parameters\n         ----------\n-        data : str\n-           String containing the entire header.\n+        data : str or bytes\n+           String or bytes containing the entire header.\n \n-        sep : str, optional\n+        sep : str or bytes, optional\n             The string separating cards from each other, such as a newline.  By\n             default there is no card separator (as is the case in a raw FITS\n             file).\n@@ -348,6 +350,12 @@ class Header:\n             A new `Header` instance.\n         \"\"\"\n \n+        # Handle bytes input by decoding to string\n+        if isinstance(data, bytes):\n+            data = data.decode('ascii')\n+        if isinstance(sep, bytes):\n+            sep = sep.decode('ascii')\n+\n         cards = []\n \n         # If the card separator contains characters that may validly appear in\n@@ -373,23 +381,35 @@ class Header:\n             next_image = data[idx:end_idx]\n             idx = end_idx + len(sep)\n \n+\n             if image:\n                 if next_image[:8] == 'CONTINUE':\n                     image.append(next_image)\n                     continue\n                 cards.append(Card.fromstring(''.join(image)))\n \n+\n             if require_full_cardlength:\n-                if next_image == END_CARD:\n+                if isinstance(next_image, bytes):\n+                    next_image_str = decode_ascii(next_image)\n+                else:\n+                    next_image_str = next_image\n+                if next_image_str == END_CARD:\n                     image = []\n                     break\n             else:\n-                if next_image.split(sep)[0].rstrip() == 'END':\n+                if isinstance(next_image, bytes):\n+                    next_image_str = decode_ascii(next_image)\n+                else:\n+                    next_image_str = next_image\n+                if next_image_str.split(sep)[0].rstrip() == 'END':\n                     image = []\n                     break\n \n             image = [next_image]\n \n+        # Add the last image that was found before the end, if any\n+\n         # Add the last image that was found before the end, if any\n         if image:\n             cards.append(Card.fromstring(''.join(image)))\n",
    "variant_6": "diff --git a/astropy/io/fits/card.py b/astropy/io/fits/card.py\nindex 8c1ac5d738..155c036caa 100644\n--- a/astropy/io/fits/card.py\n+++ b/astropy/io/fits/card.py\n@@ -544,14 +544,20 @@ class Card(_Verify):\n                 (isinstance(self.value, str) and not self.value) and\n                 not self.comment)\n \n+    @classmethod\n+\n     @classmethod\n     def fromstring(cls, image):\n         \"\"\"\n-        Construct a `Card` object from a (raw) string. It will pad the string\n+        Construct a `Card` object from a (raw) string or bytes. It will pad the string\n         if it is not the length of a card image (80 columns).  If the card\n         image is longer than 80 columns, assume it contains ``CONTINUE``\n         card(s).\n         \"\"\"\n+        \n+        # Convert bytes to string if necessary\n+        if isinstance(image, bytes):\n+            image = image.decode('ascii')\n \n         card = cls()\n         card._image = _pad(image)\ndiff --git a/astropy/io/fits/header.py b/astropy/io/fits/header.py\nindex ad07e6d52d..bca0539ade 100644\n--- a/astropy/io/fits/header.py\n+++ b/astropy/io/fits/header.py\n@@ -326,6 +326,8 @@ class Header:\n     def _modified(self, val):\n         self.__dict__['_modified'] = val\n \n+    @classmethod\n+\n     @classmethod\n     def fromstring(cls, data, sep=''):\n         \"\"\"\n@@ -334,10 +336,10 @@ class Header:\n \n         Parameters\n         ----------\n-        data : str\n-           String containing the entire header.\n+        data : str or bytes\n+           String or bytes containing the entire header.\n \n-        sep : str, optional\n+        sep : str or bytes, optional\n             The string separating cards from each other, such as a newline.  By\n             default there is no card separator (as is the case in a raw FITS\n             file).\n@@ -347,6 +349,14 @@ class Header:\n         header\n             A new `Header` instance.\n         \"\"\"\n+        \n+        # Handle bytes input by decoding to string\n+        if isinstance(data, bytes):\n+            data = data.decode('ascii')\n+        \n+        # Handle bytes separator by decoding to string\n+        if isinstance(sep, bytes):\n+            sep = sep.decode('ascii')\n \n         cards = []\n \n@@ -373,23 +383,35 @@ class Header:\n             next_image = data[idx:end_idx]\n             idx = end_idx + len(sep)\n \n+\n             if image:\n                 if next_image[:8] == 'CONTINUE':\n                     image.append(next_image)\n                     continue\n                 cards.append(Card.fromstring(''.join(image)))\n \n+\n             if require_full_cardlength:\n-                if next_image == END_CARD:\n+                if isinstance(next_image, bytes):\n+                    next_image_str = next_image.decode('ascii', errors='replace')\n+                else:\n+                    next_image_str = next_image\n+                if next_image_str == END_CARD:\n                     image = []\n                     break\n             else:\n-                if next_image.split(sep)[0].rstrip() == 'END':\n+                if isinstance(next_image, bytes):\n+                    next_image_str = next_image.decode('ascii', errors='replace')\n+                else:\n+                    next_image_str = next_image\n+                if next_image_str.split(sep)[0].rstrip() == 'END':\n                     image = []\n                     break\n \n             image = [next_image]\n \n+        # Add the last image that was found before the end, if any\n+\n         # Add the last image that was found before the end, if any\n         if image:\n             cards.append(Card.fromstring(''.join(image)))\n",
    "variant_7": "diff --git a/astropy/io/fits/card.py b/astropy/io/fits/card.py\nindex 8c1ac5d738..fadc72f4e0 100644\n--- a/astropy/io/fits/card.py\n+++ b/astropy/io/fits/card.py\n@@ -544,14 +544,20 @@ class Card(_Verify):\n                 (isinstance(self.value, str) and not self.value) and\n                 not self.comment)\n \n+    @classmethod\n+\n     @classmethod\n     def fromstring(cls, image):\n         \"\"\"\n-        Construct a `Card` object from a (raw) string. It will pad the string\n+        Construct a `Card` object from a (raw) string or bytes. It will pad the string\n         if it is not the length of a card image (80 columns).  If the card\n         image is longer than 80 columns, assume it contains ``CONTINUE``\n         card(s).\n         \"\"\"\n+        \n+        # Handle bytes input by decoding to string\n+        if isinstance(image, bytes):\n+            image = image.decode('ascii')\n \n         card = cls()\n         card._image = _pad(image)\ndiff --git a/astropy/io/fits/header.py b/astropy/io/fits/header.py\nindex ad07e6d52d..ce5c403a4f 100644\n--- a/astropy/io/fits/header.py\n+++ b/astropy/io/fits/header.py\n@@ -326,6 +326,8 @@ class Header:\n     def _modified(self, val):\n         self.__dict__['_modified'] = val\n \n+    @classmethod\n+\n     @classmethod\n     def fromstring(cls, data, sep=''):\n         \"\"\"\n@@ -334,10 +336,10 @@ class Header:\n \n         Parameters\n         ----------\n-        data : str\n-           String containing the entire header.\n+        data : str or bytes\n+           String or bytes containing the entire header.\n \n-        sep : str, optional\n+        sep : str or bytes, optional\n             The string separating cards from each other, such as a newline.  By\n             default there is no card separator (as is the case in a raw FITS\n             file).\n@@ -348,6 +350,12 @@ class Header:\n             A new `Header` instance.\n         \"\"\"\n \n+        # Handle bytes input by decoding to string\n+        if isinstance(data, bytes):\n+            data = data.decode('ascii')\n+        if isinstance(sep, bytes):\n+            sep = sep.decode('ascii')\n+\n         cards = []\n \n         # If the card separator contains characters that may validly appear in\n@@ -373,23 +381,27 @@ class Header:\n             next_image = data[idx:end_idx]\n             idx = end_idx + len(sep)\n \n+\n             if image:\n                 if next_image[:8] == 'CONTINUE':\n                     image.append(next_image)\n                     continue\n                 cards.append(Card.fromstring(''.join(image)))\n \n-            if require_full_cardlength:\n-                if next_image == END_CARD:\n-                    image = []\n-                    break\n-            else:\n-                if next_image.split(sep)[0].rstrip() == 'END':\n-                    image = []\n-                    break\n+\n+        if require_full_cardlength:\n+            if next_image == END_CARD:\n+                image = []\n+                break\n+        else:\n+            if next_image.split(sep)[0].rstrip() == 'END':\n+                image = []\n+                break\n \n             image = [next_image]\n \n+        # Add the last image that was found before the end, if any\n+\n         # Add the last image that was found before the end, if any\n         if image:\n             cards.append(Card.fromstring(''.join(image)))\n",
    "variant_8": "diff --git a/astropy/io/fits/card.py b/astropy/io/fits/card.py\nindex 8c1ac5d738..155c036caa 100644\n--- a/astropy/io/fits/card.py\n+++ b/astropy/io/fits/card.py\n@@ -544,14 +544,20 @@ class Card(_Verify):\n                 (isinstance(self.value, str) and not self.value) and\n                 not self.comment)\n \n+    @classmethod\n+\n     @classmethod\n     def fromstring(cls, image):\n         \"\"\"\n-        Construct a `Card` object from a (raw) string. It will pad the string\n+        Construct a `Card` object from a (raw) string or bytes. It will pad the string\n         if it is not the length of a card image (80 columns).  If the card\n         image is longer than 80 columns, assume it contains ``CONTINUE``\n         card(s).\n         \"\"\"\n+        \n+        # Convert bytes to string if necessary\n+        if isinstance(image, bytes):\n+            image = image.decode('ascii')\n \n         card = cls()\n         card._image = _pad(image)\ndiff --git a/astropy/io/fits/header.py b/astropy/io/fits/header.py\nindex ad07e6d52d..77c4cdcaed 100644\n--- a/astropy/io/fits/header.py\n+++ b/astropy/io/fits/header.py\n@@ -326,6 +326,8 @@ class Header:\n     def _modified(self, val):\n         self.__dict__['_modified'] = val\n \n+    @classmethod\n+\n     @classmethod\n     def fromstring(cls, data, sep=''):\n         \"\"\"\n@@ -334,10 +336,10 @@ class Header:\n \n         Parameters\n         ----------\n-        data : str\n-           String containing the entire header.\n+        data : str or bytes\n+           String or bytes containing the entire header.\n \n-        sep : str, optional\n+        sep : str or bytes, optional\n             The string separating cards from each other, such as a newline.  By\n             default there is no card separator (as is the case in a raw FITS\n             file).\n@@ -348,6 +350,13 @@ class Header:\n             A new `Header` instance.\n         \"\"\"\n \n+        # Handle bytes input by decoding to string\n+        if isinstance(data, bytes):\n+            data = data.decode('ascii')\n+        \n+        if isinstance(sep, bytes):\n+            sep = sep.decode('ascii')\n+\n         cards = []\n \n         # If the card separator contains characters that may validly appear in\n@@ -373,23 +382,39 @@ class Header:\n             next_image = data[idx:end_idx]\n             idx = end_idx + len(sep)\n \n+\n             if image:\n                 if next_image[:8] == 'CONTINUE':\n                     image.append(next_image)\n                     continue\n                 cards.append(Card.fromstring(''.join(image)))\n \n+\n             if require_full_cardlength:\n-                if next_image == END_CARD:\n-                    image = []\n-                    break\n+                if isinstance(next_image, bytes):\n+                    next_image_str = next_image.decode('ascii', errors='replace')\n+                    if next_image_str == END_CARD:\n+                        image = []\n+                        break\n+                else:\n+                    if next_image == END_CARD:\n+                        image = []\n+                        break\n             else:\n-                if next_image.split(sep)[0].rstrip() == 'END':\n-                    image = []\n-                    break\n+                if isinstance(next_image, bytes):\n+                    next_image_str = next_image.decode('ascii', errors='replace')\n+                    if next_image_str.split(sep)[0].rstrip() == 'END':\n+                        image = []\n+                        break\n+                else:\n+                    if next_image.split(sep)[0].rstrip() == 'END':\n+                        image = []\n+                        break\n \n             image = [next_image]\n \n+        # Add the last image that was found before the end, if any\n+\n         # Add the last image that was found before the end, if any\n         if image:\n             cards.append(Card.fromstring(''.join(image)))\n"
  }
}